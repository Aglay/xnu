<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_descrip.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_descrip.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995, 1997 Apple Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)kern_descrip.c	8.8 (Berkeley) 2/14/95
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2006 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/guarded.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mman.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/aio_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/codesign.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/codedir_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/pipe.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/spawn.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/waitq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_misc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs.h&gt;</span>

kern_return_t <span class="enscript-function-name">ipc_object_copyin</span>(ipc_space_t, mach_port_name_t,
    mach_msg_type_name_t, ipc_port_t *);
<span class="enscript-type">void</span> <span class="enscript-function-name">ipc_port_release_send</span>(ipc_port_t);

<span class="enscript-type">struct</span> psemnode;
<span class="enscript-type">struct</span> pshmnode;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">finishdup</span>(proc_t p,
    <span class="enscript-type">struct</span> filedesc *fdp, <span class="enscript-type">int</span> old, <span class="enscript-type">int</span> new, <span class="enscript-type">int</span> flags, int32_t *retval);

<span class="enscript-type">int</span> <span class="enscript-function-name">falloc_locked</span>(proc_t p, <span class="enscript-type">struct</span> fileproc **resultfp, <span class="enscript-type">int</span> *resultfd, vfs_context_t ctx, <span class="enscript-type">int</span> locked);
<span class="enscript-type">void</span> <span class="enscript-function-name">fg_drop</span>(<span class="enscript-type">struct</span> fileproc * fp);
<span class="enscript-type">void</span> <span class="enscript-function-name">fg_free</span>(<span class="enscript-type">struct</span> fileglob *fg);
<span class="enscript-type">void</span> <span class="enscript-function-name">fg_ref</span>(<span class="enscript-type">struct</span> fileproc * fp);
<span class="enscript-type">void</span> <span class="enscript-function-name">fileport_releasefg</span>(<span class="enscript-type">struct</span> fileglob *fg);

<span class="enscript-comment">/* flags for close_internal_locked */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FD_DUP2RESV</span> 1

<span class="enscript-comment">/* We don't want these exported */</span>

__private_extern__
<span class="enscript-type">int</span> <span class="enscript-function-name">unlink1</span>(vfs_context_t, vnode_t, user_addr_t, <span class="enscript-type">enum</span> uio_seg, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">_fdrelse</span>(<span class="enscript-type">struct</span> proc * p, <span class="enscript-type">int</span> fd);


<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">file_lock_init</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> kauth_scope_t	kauth_scope_fileop;

<span class="enscript-comment">/* Conflict wait queue for when selects collide (opaque type) */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> waitq select_conflict_queue;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_flag</span> f_fglob-&gt;fg_flag
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_type</span> f_fglob-&gt;fg_ops-&gt;fo_type
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_msgcount</span> f_fglob-&gt;fg_msgcount
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_cred</span> f_fglob-&gt;fg_cred
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_ops</span> f_fglob-&gt;fg_ops
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_offset</span> f_fglob-&gt;fg_offset
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_data</span> f_fglob-&gt;fg_data
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CHECK_ADD_OVERFLOW_INT64L</span>(x, y) \
		(((((x) &gt; 0) &amp;&amp; ((y) &gt; 0) &amp;&amp; ((x) &gt; LLONG_MAX - (y))) || \
		(((x) &lt; 0) &amp;&amp; ((y) &lt; 0) &amp;&amp; ((x) &lt; LLONG_MIN - (y)))) \
		? 1 : 0)
<span class="enscript-comment">/*
 * Descriptor management.
 */</span>
<span class="enscript-type">struct</span> fmsglist fmsghead;	<span class="enscript-comment">/* head of list of open files */</span>
<span class="enscript-type">struct</span> fmsglist fmsg_ithead;	<span class="enscript-comment">/* head of list of open files */</span>
<span class="enscript-type">int</span> nfiles;			<span class="enscript-comment">/* actual number of open files */</span>


lck_grp_attr_t * file_lck_grp_attr;
lck_grp_t * file_lck_grp;
lck_attr_t * file_lck_attr;

lck_mtx_t * uipc_lock;


<span class="enscript-comment">/*
 * check_file_seek_range
 *
 * Description: Checks if seek offsets are in the range of 0 to LLONG_MAX.
 *
 * Parameters:  fl		Flock structure.
 *		cur_file_offset	Current offset in the file.
 *
 * Returns: 	0 		on Success.
 *		EOVERFLOW	on overflow.
 *		EINVAL   	on offset less than zero.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">check_file_seek_range</span>(<span class="enscript-type">struct</span> flock *fl, off_t cur_file_offset)
{
	<span class="enscript-keyword">if</span> (fl-&gt;l_whence == SEEK_CUR) {
		<span class="enscript-comment">/* Check if the start marker is beyond LLONG_MAX. */</span>
		<span class="enscript-keyword">if</span> (CHECK_ADD_OVERFLOW_INT64L(fl-&gt;l_start, cur_file_offset)) {
			<span class="enscript-comment">/* Check if start marker is negative */</span>
			<span class="enscript-keyword">if</span> (fl-&gt;l_start &lt; 0) {
				<span class="enscript-keyword">return</span> EINVAL;
			}
			<span class="enscript-keyword">return</span> EOVERFLOW;
		}
		<span class="enscript-comment">/* Check if the start marker is negative. */</span>
		<span class="enscript-keyword">if</span> (fl-&gt;l_start + cur_file_offset &lt; 0) {
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">/* Check if end marker is beyond LLONG_MAX. */</span>
		<span class="enscript-keyword">if</span> ((fl-&gt;l_len &gt; 0) &amp;&amp; (CHECK_ADD_OVERFLOW_INT64L(fl-&gt;l_start + 
			cur_file_offset, fl-&gt;l_len - 1))) {
			<span class="enscript-keyword">return</span> EOVERFLOW;
		}
		<span class="enscript-comment">/* Check if the end marker is negative. */</span>
		<span class="enscript-keyword">if</span> ((fl-&gt;l_len &lt;= 0) &amp;&amp; (fl-&gt;l_start + cur_file_offset +
			fl-&gt;l_len &lt; 0)) {
			<span class="enscript-keyword">return</span> EINVAL;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fl-&gt;l_whence == SEEK_SET) {
		<span class="enscript-comment">/* Check if the start marker is negative. */</span>
		<span class="enscript-keyword">if</span> (fl-&gt;l_start &lt; 0) {
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">/* Check if the end marker is beyond LLONG_MAX. */</span>
		<span class="enscript-keyword">if</span> ((fl-&gt;l_len &gt; 0) &amp;&amp; 
		    CHECK_ADD_OVERFLOW_INT64L(fl-&gt;l_start, fl-&gt;l_len - 1)) {
			<span class="enscript-keyword">return</span> EOVERFLOW;
		}
		<span class="enscript-comment">/* Check if the end marker is negative. */</span>
		<span class="enscript-keyword">if</span> ((fl-&gt;l_len &lt; 0) &amp;&amp;  fl-&gt;l_start + fl-&gt;l_len &lt; 0) {
			<span class="enscript-keyword">return</span> EINVAL;
		}
	}
	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
 * file_lock_init
 *
 * Description:	Initialize the file lock group and the uipc and flist locks
 *
 * Parameters:	(void)
 *
 * Returns:	void
 *
 * Notes:	Called at system startup from bsd_init().
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">file_lock_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* allocate file lock group attribute and group */</span>
	file_lck_grp_attr= lck_grp_attr_alloc_init();

	file_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;file&quot;</span>,  file_lck_grp_attr);

	<span class="enscript-comment">/* Allocate file lock attribute */</span>
	file_lck_attr = lck_attr_alloc_init();

	uipc_lock = lck_mtx_alloc_init(file_lck_grp, file_lck_attr);
}


<span class="enscript-comment">/*
 * proc_fdlock, proc_fdlock_spin
 *
 * Description:	Lock to control access to the per process struct fileproc
 *		and struct filedesc
 *
 * Parameters:	p				Process to take the lock on
 *
 * Returns:	void
 *
 * Notes:	The lock is initialized in forkproc() and destroyed in
 *		reap_child_process().
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_fdlock</span>(proc_t p)
{
	lck_mtx_lock(&amp;p-&gt;p_fdmlock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_fdlock_spin</span>(proc_t p)
{
	lck_mtx_lock_spin(&amp;p-&gt;p_fdmlock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_fdlock_assert</span>(proc_t p, <span class="enscript-type">int</span> assertflags)
{
	lck_mtx_assert(&amp;p-&gt;p_fdmlock, assertflags);
}


<span class="enscript-comment">/*
 * proc_fdunlock
 *
 * Description:	Unlock the lock previously locked by a call to proc_fdlock()
 *
 * Parameters:	p				Process to drop the lock on
 *
 * Returns:	void
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_fdunlock</span>(proc_t p)
{
	lck_mtx_unlock(&amp;p-&gt;p_fdmlock);
}


<span class="enscript-comment">/*
 * System calls on descriptors.
 */</span>


<span class="enscript-comment">/*
 * getdtablesize
 *
 * Description:	Returns the per process maximum size of the descriptor table
 *
 * Parameters:	p				Process being queried
 *		retval				Pointer to the call return area
 *
 * Returns:	0				Success
 *
 * Implicit returns:
 *		*retval (modified)		Size of dtable
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getdtablesize</span>(proc_t p, __unused <span class="enscript-type">struct</span> getdtablesize_args *uap, int32_t *retval)
{
	proc_fdlock_spin(p);
	*retval = min((<span class="enscript-type">int</span>)p-&gt;p_rlimit[RLIMIT_NOFILE].rlim_cur, maxfiles);
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">procfdtbl_reservefd</span>(<span class="enscript-type">struct</span> proc * p, <span class="enscript-type">int</span> fd)
{
	p-&gt;p_fd-&gt;fd_ofiles[fd] = NULL;
        p-&gt;p_fd-&gt;fd_ofileflags[fd] |= UF_RESERVED;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">procfdtbl_markclosefd</span>(<span class="enscript-type">struct</span> proc * p, <span class="enscript-type">int</span> fd)
{
        p-&gt;p_fd-&gt;fd_ofileflags[fd] |= (UF_RESERVED | UF_CLOSING);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">procfdtbl_releasefd</span>(<span class="enscript-type">struct</span> proc * p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc * fp)
{
	<span class="enscript-keyword">if</span> (fp != NULL)
        	p-&gt;p_fd-&gt;fd_ofiles[fd] = fp;
        p-&gt;p_fd-&gt;fd_ofileflags[fd] &amp;= ~UF_RESERVED;
	<span class="enscript-keyword">if</span> ((p-&gt;p_fd-&gt;fd_ofileflags[fd] &amp; UF_RESVWAIT) == UF_RESVWAIT) {
		p-&gt;p_fd-&gt;fd_ofileflags[fd] &amp;= ~UF_RESVWAIT;
		wakeup(&amp;p-&gt;p_fd);
	}
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">procfdtbl_waitfd</span>(<span class="enscript-type">struct</span> proc * p, <span class="enscript-type">int</span> fd)
{
        p-&gt;p_fd-&gt;fd_ofileflags[fd] |= UF_RESVWAIT;
	msleep(&amp;p-&gt;p_fd, &amp;p-&gt;p_fdmlock, PRIBIO, <span class="enscript-string">&quot;ftbl_waitfd&quot;</span>, NULL);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">procfdtbl_clearfd</span>(<span class="enscript-type">struct</span> proc * p, <span class="enscript-type">int</span> fd)
{
	<span class="enscript-type">int</span> waiting;

	waiting = (p-&gt;p_fd-&gt;fd_ofileflags[fd] &amp; UF_RESVWAIT);
	p-&gt;p_fd-&gt;fd_ofiles[fd] = NULL;       
	p-&gt;p_fd-&gt;fd_ofileflags[fd] = 0;
	<span class="enscript-keyword">if</span> ( waiting == UF_RESVWAIT) {
		wakeup(&amp;p-&gt;p_fd);
	}
}

<span class="enscript-comment">/*
 * _fdrelse
 *
 * Description:	Inline utility function to free an fd in a filedesc
 *
 * Parameters:	fdp				Pointer to filedesc fd lies in
 *		fd				fd to free
 *		reserv				fd should be reserved
 *
 * Returns:	void
 *
 * Locks:	Assumes proc_fdlock for process pointing to fdp is held by
 *		the caller
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_fdrelse</span>(<span class="enscript-type">struct</span> proc * p, <span class="enscript-type">int</span> fd)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">int</span> nfd = 0;

	<span class="enscript-keyword">if</span> (fd &lt; fdp-&gt;fd_freefile)
		fdp-&gt;fd_freefile = fd;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (fd &gt; fdp-&gt;fd_lastfile)
 		panic(<span class="enscript-string">&quot;fdrelse: fd_lastfile inconsistent&quot;</span>);
#<span class="enscript-reference">endif</span>
	procfdtbl_clearfd(p, fd);

	<span class="enscript-keyword">while</span> ((nfd = fdp-&gt;fd_lastfile) &gt; 0 &amp;&amp;
			fdp-&gt;fd_ofiles[nfd] == NULL &amp;&amp;
			!(fdp-&gt;fd_ofileflags[nfd] &amp; UF_RESERVED))
		fdp-&gt;fd_lastfile--;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">fd_rdwr</span>(
	<span class="enscript-type">int</span> fd,
	<span class="enscript-type">enum</span> uio_rw rw,
	uint64_t base,
	int64_t len,
	<span class="enscript-type">enum</span> uio_seg segflg,
	off_t	offset,
	<span class="enscript-type">int</span>	io_flg,
	int64_t *aresid)
{
        <span class="enscript-type">struct</span> fileproc *fp;
	proc_t	p;
        <span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> flags = 0;
	<span class="enscript-type">int</span> spacetype;
	uio_t auio = NULL;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];
	<span class="enscript-type">struct</span> vfs_context context = *(vfs_context_current());
	bool wrote_some = false;

	p = current_proc();

        error = fp_lookup(p, fd, &amp;fp, 0);
        <span class="enscript-keyword">if</span> (error)
                <span class="enscript-keyword">return</span>(error);

	<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE &amp;&amp; fp-&gt;f_type != DTYPE_PIPE &amp;&amp; fp-&gt;f_type != DTYPE_SOCKET) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (rw == UIO_WRITE &amp;&amp; !(fp-&gt;f_flag &amp; FWRITE)) {
                error = EBADF;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	<span class="enscript-keyword">if</span> (rw == UIO_READ &amp;&amp; !(fp-&gt;f_flag &amp; FREAD)) {
    		error = EBADF;
    		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	context.vc_ucred = fp-&gt;f_fglob-&gt;fg_cred;

	<span class="enscript-keyword">if</span> (UIO_SEG_IS_USER_SPACE(segflg))
		spacetype = proc_is64bit(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	<span class="enscript-keyword">else</span>
		spacetype = UIO_SYSSPACE;

	auio = uio_createwithbuffer(1, offset, spacetype, rw, &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));

	uio_addiov(auio, base, len);

	<span class="enscript-keyword">if</span> ( !(io_flg &amp; IO_APPEND))
		flags = FOF_OFFSET;

	<span class="enscript-keyword">if</span> (rw == UIO_WRITE) {
		user_ssize_t orig_resid = uio_resid(auio);
		error = fo_write(fp, auio, flags, &amp;context);
		wrote_some = uio_resid(auio) &lt; orig_resid;
	} <span class="enscript-keyword">else</span>
		error = fo_read(fp, auio, flags, &amp;context);

	<span class="enscript-keyword">if</span> (aresid)
		*aresid = uio_resid(auio);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (uio_resid(auio) &amp;&amp; error == 0)
			error = EIO;
	}
<span class="enscript-reference">out</span>:
        <span class="enscript-keyword">if</span> (wrote_some)
                fp_drop_written(p, fd, fp);
        <span class="enscript-keyword">else</span>
                fp_drop(p, fd, fp, 0);

	<span class="enscript-keyword">return</span> error;
}



<span class="enscript-comment">/*
 * dup
 *
 * Description:	Duplicate a file descriptor.
 *
 * Parameters:	p				Process performing the dup
 *		uap-&gt;fd				The fd to dup
 *		retval				Pointer to the call return area
 *
 * Returns:	0				Success
 *		!0				Errno
 *
 * Implicit returns:
 *		*retval (modified)		The new descriptor
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dup</span>(proc_t p, <span class="enscript-type">struct</span> dup_args *uap, int32_t *retval)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">int</span> old = uap-&gt;fd;
	<span class="enscript-type">int</span> new, error;
	<span class="enscript-type">struct</span> fileproc *fp;

	proc_fdlock(p);
	<span class="enscript-keyword">if</span> ( (error = fp_lookup(p, old, &amp;fp, 1)) ) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(error);
	}
	<span class="enscript-keyword">if</span> (FP_ISGUARDED(fp, GUARD_DUP)) {
		error = fp_guard_exception(p, old, fp, kGUARD_EXC_DUP);
		(<span class="enscript-type">void</span>) fp_drop(p, old, fp, 1);
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ( (error = fdalloc(p, 0, &amp;new)) ) {
		fp_drop(p, old, fp, 1);
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (error);
	}
	error = finishdup(p, fdp, old, new, 0, retval);
	fp_drop(p, old, fp, 1);
	proc_fdunlock(p);

	<span class="enscript-keyword">if</span> (ENTR_SHOULDTRACE &amp;&amp; fp-&gt;f_type == DTYPE_SOCKET) {
		KERNEL_ENERGYTRACE(kEnTrActKernSocket, DBG_FUNC_START,
		    new, 0, (int64_t)VM_KERNEL_ADDRPERM(fp-&gt;f_data));
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * dup2
 *
 * Description:	Duplicate a file descriptor to a particular value.
 *
 * Parameters:	p				Process performing the dup
 *		uap-&gt;from			The fd to dup
 *		uap-&gt;to				The fd to dup it to
 *		retval				Pointer to the call return area
 *
 * Returns:	0				Success
 *		!0				Errno
 *
 * Implicit returns:
 *		*retval (modified)		The new descriptor
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dup2</span>(proc_t p, <span class="enscript-type">struct</span> dup2_args *uap, int32_t *retval)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">int</span> old = uap-&gt;from, new = uap-&gt;to;
	<span class="enscript-type">int</span> i, error;
	<span class="enscript-type">struct</span> fileproc *fp, *nfp;

	proc_fdlock(p);

<span class="enscript-reference">startover</span>:
	<span class="enscript-keyword">if</span> ( (error = fp_lookup(p, old, &amp;fp, 1)) ) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(error);
	}
	<span class="enscript-keyword">if</span> (FP_ISGUARDED(fp, GUARD_DUP)) {
		error = fp_guard_exception(p, old, fp, kGUARD_EXC_DUP);
		(<span class="enscript-type">void</span>) fp_drop(p, old, fp, 1);
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (new &lt; 0 ||
		(rlim_t)new &gt;= p-&gt;p_rlimit[RLIMIT_NOFILE].rlim_cur ||
	    new &gt;= maxfiles) {
		fp_drop(p, old, fp, 1);
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (EBADF);
	}
	<span class="enscript-keyword">if</span> (old == new) {
		fp_drop(p, old, fp, 1);
		*retval = new;
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> (new &lt; 0 || new &gt;= fdp-&gt;fd_nfiles) {
		<span class="enscript-keyword">if</span> ( (error = fdalloc(p, new, &amp;i)) ) {
			fp_drop(p, old, fp, 1);
			proc_fdunlock(p);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> (new != i) {
			fdrelse(p, i);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">closeit</span>;
		}
	} <span class="enscript-keyword">else</span> {
<span class="enscript-reference">closeit</span>:
		<span class="enscript-keyword">while</span> ((fdp-&gt;fd_ofileflags[new] &amp; UF_RESERVED) == UF_RESERVED)  {
				fp_drop(p, old, fp, 1);
				procfdtbl_waitfd(p, new);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
				proc_fdlock_assert(p, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">startover</span>;
		}

		<span class="enscript-keyword">if</span> ((fdp-&gt;fd_ofiles[new] != NULL) &amp;&amp;
		    ((error = fp_lookup(p, new, &amp;nfp, 1)) == 0)) {
			fp_drop(p, old, fp, 1);
			<span class="enscript-keyword">if</span> (FP_ISGUARDED(nfp, GUARD_CLOSE)) {
				error = fp_guard_exception(p,
				    new, nfp, kGUARD_EXC_CLOSE);
				(<span class="enscript-type">void</span>) fp_drop(p, new, nfp, 1);
				proc_fdunlock(p);
				<span class="enscript-keyword">return</span> (error);
			}
			(<span class="enscript-type">void</span>)close_internal_locked(p, new, nfp, FD_DUP2RESV);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
			proc_fdlock_assert(p, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
			procfdtbl_clearfd(p, new);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">startover</span>;
		} <span class="enscript-keyword">else</span>  {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
			<span class="enscript-keyword">if</span> (fdp-&gt;fd_ofiles[new] != NULL)
				panic(<span class="enscript-string">&quot;dup2: no ref on fileproc %d&quot;</span>, new);
#<span class="enscript-reference">endif</span>
			procfdtbl_reservefd(p, new);
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		proc_fdlock_assert(p, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>

	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (fdp-&gt;fd_ofiles[new] != 0)
		panic(<span class="enscript-string">&quot;dup2: overwriting fd_ofiles with new %d&quot;</span>, new);
	<span class="enscript-keyword">if</span> ((fdp-&gt;fd_ofileflags[new] &amp; UF_RESERVED) == 0)
		panic(<span class="enscript-string">&quot;dup2: unreserved fileflags with new %d&quot;</span>, new);
#<span class="enscript-reference">endif</span>
	error = finishdup(p, fdp, old, new, 0, retval);
	fp_drop(p, old, fp, 1);
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * fcntl
 *
 * Description:	The file control system call.
 *
 * Parameters:	p				Process performing the fcntl
 *		uap-&gt;fd				The fd to operate against
 *		uap-&gt;cmd			The command to perform
 *		uap-&gt;arg			Pointer to the command argument
 *		retval				Pointer to the call return area
 *
 * Returns:	0				Success
 *		!0				Errno (see fcntl_nocancel)
 *
 * Implicit returns:
 *		*retval (modified)		fcntl return value (if any)
 *
 * Notes:	This system call differs from fcntl_nocancel() in that it
 *		tests for cancellation prior to performing a potentially
 *		blocking operation.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fcntl</span>(proc_t p, <span class="enscript-type">struct</span> fcntl_args *uap, int32_t *retval)
{
	__pthread_testcancel(1);
	<span class="enscript-keyword">return</span>(fcntl_nocancel(p, (<span class="enscript-type">struct</span> fcntl_nocancel_args *)uap, retval));
}


<span class="enscript-comment">/*
 * fcntl_nocancel
 *
 * Description:	A non-cancel-testing file control system call.
 *
 * Parameters:	p				Process performing the fcntl
 *		uap-&gt;fd				The fd to operate against
 *		uap-&gt;cmd			The command to perform
 *		uap-&gt;arg			Pointer to the command argument
 *		retval				Pointer to the call return area
 *
 * Returns:	0				Success
 *		EINVAL
 *	fp_lookup:EBADF				Bad file descriptor
 * [F_DUPFD]
 *	fdalloc:EMFILE
 *	fdalloc:ENOMEM
 *	finishdup:EBADF
 *	finishdup:ENOMEM
 * [F_SETOWN]
 *		ESRCH
 * [F_SETLK]
 *		EBADF
 *		EOVERFLOW
 *	copyin:EFAULT
 *	vnode_getwithref:???
 *	VNOP_ADVLOCK:???
 *	msleep:ETIMEDOUT
 * [F_GETLK]
 *		EBADF
 *		EOVERFLOW
 *	copyin:EFAULT
 *	copyout:EFAULT
 *	vnode_getwithref:???
 *	VNOP_ADVLOCK:???
 * [F_PREALLOCATE]
 *		EBADF
 *		EINVAL
 *	copyin:EFAULT
 *	copyout:EFAULT
 *	vnode_getwithref:???
 *	VNOP_ALLOCATE:???
 * [F_SETSIZE,F_RDADVISE]
 *		EBADF
 *	copyin:EFAULT
 *	vnode_getwithref:???
 * [F_RDAHEAD,F_NOCACHE]
 *		EBADF
 *	vnode_getwithref:???
 * [???]
 *
 * Implicit returns:
 *		*retval (modified)		fcntl return value (if any)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fcntl_nocancel</span>(proc_t p, <span class="enscript-type">struct</span> fcntl_nocancel_args *uap, int32_t *retval)
{
	<span class="enscript-type">int</span> fd = uap-&gt;fd;
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">char</span> *pop;
	<span class="enscript-type">struct</span> vnode *vp = NULLVP;	<span class="enscript-comment">/* for AUDIT_ARG() at end */</span>
	<span class="enscript-type">int</span> i, tmp, error, error2, flg = 0;
	<span class="enscript-type">struct</span> flock fl;
	<span class="enscript-type">struct</span> flocktimeout fltimeout;
	<span class="enscript-type">struct</span> timespec *timeout = NULL;
	<span class="enscript-type">struct</span> vfs_context context;
	off_t offset;
	<span class="enscript-type">int</span> newmin;
	daddr64_t lbn, bn;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> fflag;
	user_addr_t argp;
	boolean_t is64bit;

	AUDIT_ARG(fd, uap-&gt;fd);
	AUDIT_ARG(cmd, uap-&gt;cmd);

	proc_fdlock(p);
	<span class="enscript-keyword">if</span> ( (error = fp_lookup(p, fd, &amp;fp, 1)) ) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(error);
	}
	context.vc_thread = current_thread();
	context.vc_ucred = fp-&gt;f_cred;

	is64bit = proc_is64bit(p);
	<span class="enscript-keyword">if</span> (is64bit) {
		argp = uap-&gt;arg;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Since the arg parameter is defined as a long but may be
		 * either a long or a pointer we must take care to handle
		 * sign extension issues.  Our sys call munger will sign
		 * extend a long when we are called from a 32-bit process.
		 * Since we can never have an address greater than 32-bits
		 * from a 32-bit process we lop off the top 32-bits to avoid
		 * getting the wrong address
		 */</span>
		argp = CAST_USER_ADDR_T((uint32_t)uap-&gt;arg);
	}

	pop = &amp;fdp-&gt;fd_ofileflags[fd];

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_file_check_fcntl(proc_ucred(p), fp-&gt;f_fglob, uap-&gt;cmd,
	    uap-&gt;arg);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">switch</span> (uap-&gt;cmd) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_DUPFD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_DUPFD_CLOEXEC</span>:
		<span class="enscript-keyword">if</span> (FP_ISGUARDED(fp, GUARD_DUP)) {
			error = fp_guard_exception(p, fd, fp, kGUARD_EXC_DUP);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		newmin = CAST_DOWN_EXPLICIT(<span class="enscript-type">int</span>, uap-&gt;arg); <span class="enscript-comment">/* arg is an int, so we won't lose bits */</span>
		AUDIT_ARG(value32, newmin);
		<span class="enscript-keyword">if</span> ((u_int)newmin &gt;= p-&gt;p_rlimit[RLIMIT_NOFILE].rlim_cur ||
		    newmin &gt;= maxfiles) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> ( (error = fdalloc(p, newmin, &amp;i)) )
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		error = finishdup(p, fdp, fd, i,
		    uap-&gt;cmd == F_DUPFD_CLOEXEC ? UF_EXCLOSE : 0, retval);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETFD</span>:
		*retval = (*pop &amp; UF_EXCLOSE)? FD_CLOEXEC : 0;
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETFD</span>:
		AUDIT_ARG(value32, uap-&gt;arg);
		<span class="enscript-keyword">if</span> (uap-&gt;arg &amp; FD_CLOEXEC)
			*pop |= UF_EXCLOSE;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (FILEPROC_TYPE(fp) == FTYPE_GUARDED) {
				error = fp_guard_exception(p,
				    fd, fp, kGUARD_EXC_NOCLOEXEC);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			*pop &amp;= ~UF_EXCLOSE;
		}
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETFL</span>:
		*retval = OFLAGS(fp-&gt;f_flag);
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETFL</span>:
		fp-&gt;f_flag &amp;= ~FCNTLFLAGS;
		tmp = CAST_DOWN_EXPLICIT(<span class="enscript-type">int</span>, uap-&gt;arg); <span class="enscript-comment">/* arg is an int, so we won't lose bits */</span>
		AUDIT_ARG(value32, tmp);
		fp-&gt;f_flag |= FFLAGS(tmp) &amp; FCNTLFLAGS;
		tmp = fp-&gt;f_flag &amp; FNONBLOCK;
		error = fo_ioctl(fp, FIONBIO, (caddr_t)&amp;tmp, &amp;context);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		tmp = fp-&gt;f_flag &amp; FASYNC;
		error = fo_ioctl(fp, FIOASYNC, (caddr_t)&amp;tmp, &amp;context);
		<span class="enscript-keyword">if</span> (!error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		fp-&gt;f_flag &amp;= ~FNONBLOCK;
		tmp = 0;
		(<span class="enscript-type">void</span>)fo_ioctl(fp, FIONBIO, (caddr_t)&amp;tmp, &amp;context);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETOWN</span>:
		<span class="enscript-keyword">if</span> (fp-&gt;f_type == DTYPE_SOCKET) {
			*retval = ((<span class="enscript-type">struct</span> socket *)fp-&gt;f_data)-&gt;so_pgid;
			error = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		error = fo_ioctl(fp, (<span class="enscript-type">int</span>)TIOCGPGRP, (caddr_t)retval, &amp;context);
		*retval = -*retval;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETOWN</span>:
		tmp = CAST_DOWN_EXPLICIT(pid_t, uap-&gt;arg); <span class="enscript-comment">/* arg is an int, so we won't lose bits */</span>
		AUDIT_ARG(value32, tmp);
		<span class="enscript-keyword">if</span> (fp-&gt;f_type == DTYPE_SOCKET) {
			((<span class="enscript-type">struct</span> socket *)fp-&gt;f_data)-&gt;so_pgid = tmp;
			error =0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (fp-&gt;f_type == DTYPE_PIPE) {
			error =  fo_ioctl(fp, TIOCSPGRP, (caddr_t)&amp;tmp, &amp;context);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-keyword">if</span> (tmp &lt;= 0) {
			tmp = -tmp;
		} <span class="enscript-keyword">else</span> {
			proc_t p1 = proc_find(tmp);
			<span class="enscript-keyword">if</span> (p1 == 0) {
				error = ESRCH;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			tmp = (<span class="enscript-type">int</span>)p1-&gt;p_pgrpid;
			proc_rele(p1);
		}
		error =  fo_ioctl(fp, (<span class="enscript-type">int</span>)TIOCSPGRP, (caddr_t)&amp;tmp, &amp;context);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETNOSIGPIPE</span>:
		tmp = CAST_DOWN_EXPLICIT(<span class="enscript-type">int</span>, uap-&gt;arg);
		<span class="enscript-keyword">if</span> (fp-&gt;f_type == DTYPE_SOCKET) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
			error = sock_setsockopt((<span class="enscript-type">struct</span> socket *)fp-&gt;f_data,
			    SOL_SOCKET, SO_NOSIGPIPE, &amp;tmp, <span class="enscript-keyword">sizeof</span> (tmp));
#<span class="enscript-reference">else</span>
			error = EINVAL;
#<span class="enscript-reference">endif</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> fileglob *fg = fp-&gt;f_fglob;

			lck_mtx_lock_spin(&amp;fg-&gt;fg_lock);
			<span class="enscript-keyword">if</span> (tmp)
				fg-&gt;fg_lflags |= FG_NOSIGPIPE;
			<span class="enscript-keyword">else</span>
				fg-&gt;fg_lflags &amp;= FG_NOSIGPIPE;
			lck_mtx_unlock(&amp;fg-&gt;fg_lock);
			error = 0;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETNOSIGPIPE</span>:
		<span class="enscript-keyword">if</span> (fp-&gt;f_type == DTYPE_SOCKET) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
			<span class="enscript-type">int</span> retsize = <span class="enscript-keyword">sizeof</span> (*retval);
			error = sock_getsockopt((<span class="enscript-type">struct</span> socket *)fp-&gt;f_data,
			    SOL_SOCKET, SO_NOSIGPIPE, retval, &amp;retsize);
#<span class="enscript-reference">else</span>
			error = EINVAL;
#<span class="enscript-reference">endif</span>
		} <span class="enscript-keyword">else</span> {
			*retval = (fp-&gt;f_fglob-&gt;fg_lflags &amp; FG_NOSIGPIPE) ?
				1 : 0;
			error = 0;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETCONFINED</span>:
		<span class="enscript-comment">/*
		 * If this is the only reference to this fglob in the process
		 * and it's already marked as close-on-fork then mark it as
		 * (immutably) &quot;confined&quot; i.e. any fd that points to it will
		 * forever be close-on-fork, and attempts to use an IPC
		 * mechanism to move the descriptor elsewhere will fail.
		 */</span>
		<span class="enscript-keyword">if</span> (CAST_DOWN_EXPLICIT(<span class="enscript-type">int</span>, uap-&gt;arg)) {
			<span class="enscript-type">struct</span> fileglob *fg = fp-&gt;f_fglob;

			lck_mtx_lock_spin(&amp;fg-&gt;fg_lock);
			<span class="enscript-keyword">if</span> (fg-&gt;fg_lflags &amp; FG_CONFINED)
				error = 0;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (1 != fg-&gt;fg_count)
				error = EAGAIN;	<span class="enscript-comment">/* go close the dup .. */</span>
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (UF_FORKCLOSE == (*pop &amp; UF_FORKCLOSE)) {
				fg-&gt;fg_lflags |= FG_CONFINED;
				error = 0;
			} <span class="enscript-keyword">else</span>
				error = EBADF;	<span class="enscript-comment">/* open without O_CLOFORK? */</span>
			lck_mtx_unlock(&amp;fg-&gt;fg_lock);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Other subsystems may have built on the immutability
			 * of FG_CONFINED; clearing it may be tricky.
			 */</span>
			error = EPERM;		<span class="enscript-comment">/* immutable */</span>
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETCONFINED</span>:
		*retval = (fp-&gt;f_fglob-&gt;fg_lflags &amp; FG_CONFINED) ? 1 : 0;
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETLKWTIMEOUT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETLKW</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_OFD_SETLKWTIMEOUT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_OFD_SETLKW</span>:
		flg |= F_WAIT;
		<span class="enscript-comment">/* Fall into F_SETLK */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETLK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_OFD_SETLK</span>:
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;

		fflag = fp-&gt;f_flag;
		offset = fp-&gt;f_offset;
		proc_fdunlock(p);

		<span class="enscript-comment">/* Copy in the lock structure */</span>
		<span class="enscript-keyword">if</span> (F_SETLKWTIMEOUT == uap-&gt;cmd ||
		    F_OFD_SETLKWTIMEOUT == uap-&gt;cmd) {
			error = copyin(argp, (caddr_t) &amp;fltimeout, <span class="enscript-keyword">sizeof</span>(fltimeout));
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
			}
			fl = fltimeout.fl;
			timeout = &amp;fltimeout.timeout;
		} <span class="enscript-keyword">else</span> {
			error = copyin(argp, (caddr_t)&amp;fl, <span class="enscript-keyword">sizeof</span>(fl));
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
			}
		}

		<span class="enscript-comment">/* Check starting byte and ending byte for EOVERFLOW in SEEK_CUR */</span>
		<span class="enscript-comment">/* and ending byte for EOVERFLOW in SEEK_SET */</span>
		error = check_file_seek_range(&amp;fl, offset);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
		<span class="enscript-keyword">if</span> (fl.l_whence == SEEK_CUR)
			fl.l_start += offset;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_file_check_lock(proc_ucred(p), fp-&gt;f_fglob,
		    F_SETLK, &amp;fl);
		<span class="enscript-keyword">if</span> (error) {
			(<span class="enscript-type">void</span>)vnode_put(vp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">switch</span> (uap-&gt;cmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">F_OFD_SETLK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">F_OFD_SETLKW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">F_OFD_SETLKWTIMEOUT</span>:
			flg |= F_OFD_LOCK;
			<span class="enscript-keyword">switch</span> (fl.l_type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">F_RDLCK</span>:
				<span class="enscript-keyword">if</span> ((fflag &amp; FREAD) == 0) {
					error = EBADF;
					<span class="enscript-keyword">break</span>;
				}
				error = VNOP_ADVLOCK(vp, (caddr_t)fp-&gt;f_fglob,
				    F_SETLK, &amp;fl, flg, &amp;context, timeout);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">F_WRLCK</span>:
				<span class="enscript-keyword">if</span> ((fflag &amp; FWRITE) == 0) {
					error = EBADF;
					<span class="enscript-keyword">break</span>;
				}
				error = VNOP_ADVLOCK(vp, (caddr_t)fp-&gt;f_fglob,
				    F_SETLK, &amp;fl, flg, &amp;context, timeout);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">F_UNLCK</span>:
				error = VNOP_ADVLOCK(vp, (caddr_t)fp-&gt;f_fglob,
				    F_UNLCK, &amp;fl, F_OFD_LOCK, &amp;context,
				    timeout);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (0 == error &amp;&amp;
			    (F_RDLCK == fl.l_type || F_WRLCK == fl.l_type)) {
				<span class="enscript-type">struct</span> fileglob *fg = fp-&gt;f_fglob;

				<span class="enscript-comment">/*
				 * arrange F_UNLCK on last close (once
				 * set, FG_HAS_OFDLOCK is immutable)
				 */</span>
				<span class="enscript-keyword">if</span> ((fg-&gt;fg_lflags &amp; FG_HAS_OFDLOCK) == 0) {
					lck_mtx_lock_spin(&amp;fg-&gt;fg_lock);
					fg-&gt;fg_lflags |= FG_HAS_OFDLOCK;
					lck_mtx_unlock(&amp;fg-&gt;fg_lock);
				}
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			flg |= F_POSIX;
			<span class="enscript-keyword">switch</span> (fl.l_type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">F_RDLCK</span>:
				<span class="enscript-keyword">if</span> ((fflag &amp; FREAD) == 0) {
					error = EBADF;
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-comment">// XXX UInt32 unsafe for LP64 kernel
</span>				OSBitOrAtomic(P_LADVLOCK, &amp;p-&gt;p_ladvflag);
				error = VNOP_ADVLOCK(vp, (caddr_t)p,
				    F_SETLK, &amp;fl, flg, &amp;context, timeout);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">F_WRLCK</span>:
				<span class="enscript-keyword">if</span> ((fflag &amp; FWRITE) == 0) {
					error = EBADF;
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-comment">// XXX UInt32 unsafe for LP64 kernel
</span>				OSBitOrAtomic(P_LADVLOCK, &amp;p-&gt;p_ladvflag);
				error = VNOP_ADVLOCK(vp, (caddr_t)p,
				    F_SETLK, &amp;fl, flg, &amp;context, timeout);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">F_UNLCK</span>:
				error = VNOP_ADVLOCK(vp, (caddr_t)p,
				    F_UNLCK, &amp;fl, F_POSIX, &amp;context, timeout);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">break</span>;
		}
		(<span class="enscript-type">void</span>) vnode_put(vp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETLK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_OFD_GETLK</span>:
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;

		offset = fp-&gt;f_offset;
		proc_fdunlock(p);

		<span class="enscript-comment">/* Copy in the lock structure */</span>
		error = copyin(argp, (caddr_t)&amp;fl, <span class="enscript-keyword">sizeof</span>(fl));
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

		<span class="enscript-comment">/* Check starting byte and ending byte for EOVERFLOW in SEEK_CUR */</span>
		<span class="enscript-comment">/* and ending byte for EOVERFLOW in SEEK_SET */</span>
		error = check_file_seek_range(&amp;fl, offset);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-keyword">if</span> ((fl.l_whence == SEEK_SET) &amp;&amp; (fl.l_start &lt; 0)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-keyword">switch</span> (fl.l_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">F_RDLCK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">F_UNLCK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">F_WRLCK</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-keyword">switch</span> (fl.l_whence) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SEEK_CUR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SEEK_SET</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SEEK_END</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {
			<span class="enscript-keyword">if</span> (fl.l_whence == SEEK_CUR)
			        fl.l_start += offset;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
			error = mac_file_check_lock(proc_ucred(p), fp-&gt;f_fglob,
			    uap-&gt;cmd, &amp;fl);
			<span class="enscript-keyword">if</span> (error == 0)
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">switch</span> (uap-&gt;cmd) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">F_OFD_GETLK</span>:
				error = VNOP_ADVLOCK(vp, (caddr_t)fp-&gt;f_fglob,
				    F_GETLK, &amp;fl, F_OFD_LOCK, &amp;context, NULL);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">F_OFD_GETLKPID</span>:
				error = VNOP_ADVLOCK(vp, (caddr_t)fp-&gt;f_fglob,
				    F_GETLKPID, &amp;fl, F_OFD_LOCK, &amp;context, NULL);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				error = VNOP_ADVLOCK(vp, (caddr_t)p,
				    uap-&gt;cmd, &amp;fl, F_POSIX, &amp;context, NULL);
				<span class="enscript-keyword">break</span>;
			}

			(<span class="enscript-type">void</span>)vnode_put(vp);

			<span class="enscript-keyword">if</span> (error == 0)
				error = copyout((caddr_t)&amp;fl, argp, <span class="enscript-keyword">sizeof</span>(fl));
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_PREALLOCATE</span>: {
		fstore_t alloc_struct;    <span class="enscript-comment">/* structure for allocate command */</span>
		u_int32_t alloc_flags = 0;

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		<span class="enscript-comment">/* make sure that we have write permission */</span>
		<span class="enscript-keyword">if</span> ((fp-&gt;f_flag &amp; FWRITE) == 0) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		error = copyin(argp, (caddr_t)&amp;alloc_struct, <span class="enscript-keyword">sizeof</span>(alloc_struct));
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

		<span class="enscript-comment">/* now set the space allocated to 0 */</span>
		alloc_struct.fst_bytesalloc = 0;
		
		<span class="enscript-comment">/*
		 * Do some simple parameter checking
		 */</span>

		<span class="enscript-comment">/* set up the flags */</span>

		alloc_flags |= PREALLOCATE;
		
		<span class="enscript-keyword">if</span> (alloc_struct.fst_flags &amp; F_ALLOCATECONTIG)
			alloc_flags |= ALLOCATECONTIG;

		<span class="enscript-keyword">if</span> (alloc_struct.fst_flags &amp; F_ALLOCATEALL)
			alloc_flags |= ALLOCATEALL;

		<span class="enscript-comment">/*
		 * Do any position mode specific stuff.  The only
		 * position mode  supported now is PEOFPOSMODE
		 */</span>

		<span class="enscript-keyword">switch</span> (alloc_struct.fst_posmode) {
	
		<span class="enscript-keyword">case</span> <span class="enscript-reference">F_PEOFPOSMODE</span>:
			<span class="enscript-keyword">if</span> (alloc_struct.fst_offset != 0) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
			}

			alloc_flags |= ALLOCATEFROMPEOF;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">F_VOLPOSMODE</span>:
			<span class="enscript-keyword">if</span> (alloc_struct.fst_offset &lt;= 0) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
			}

			alloc_flags |= ALLOCATEFROMVOL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>: {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
			}
		}
		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {
		        <span class="enscript-comment">/*
			 * call allocate to get the space
			 */</span>
		        error = VNOP_ALLOCATE(vp,alloc_struct.fst_length,alloc_flags,
					      &amp;alloc_struct.fst_bytesalloc, alloc_struct.fst_offset,
					      &amp;context);
			(<span class="enscript-type">void</span>)vnode_put(vp);

			error2 = copyout((caddr_t)&amp;alloc_struct, argp, <span class="enscript-keyword">sizeof</span>(alloc_struct));

			<span class="enscript-keyword">if</span> (error == 0)
				error = error2;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		
		}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETSIZE</span>:
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		error = copyin(argp, (caddr_t)&amp;offset, <span class="enscript-keyword">sizeof</span> (off_t));
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		AUDIT_ARG(value64, offset);

		error = vnode_getwithref(vp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_vnode_check_truncate(&amp;context,
		    fp-&gt;f_fglob-&gt;fg_cred, vp);
		<span class="enscript-keyword">if</span> (error) {
			(<span class="enscript-type">void</span>)vnode_put(vp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/*
		 * Make sure that we are root.  Growing a file
		 * without zero filling the data is a security hole 
		 * root would have access anyway so we'll allow it
		 */</span>
		<span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get())) {
			error = EACCES;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * set the file size
			 */</span>
			error = vnode_setsize(vp, offset, IO_NOZEROFILL,
			    &amp;context);
		}

		(<span class="enscript-type">void</span>)vnode_put(vp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_RDAHEAD</span>:
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (uap-&gt;arg)
		        fp-&gt;f_fglob-&gt;fg_flag &amp;= ~FNORDAHEAD;
		<span class="enscript-keyword">else</span>
		        fp-&gt;f_fglob-&gt;fg_flag |= FNORDAHEAD;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_NOCACHE</span>:
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (uap-&gt;arg)
		        fp-&gt;f_fglob-&gt;fg_flag |= FNOCACHE;
		<span class="enscript-keyword">else</span>
		        fp-&gt;f_fglob-&gt;fg_flag &amp;= ~FNOCACHE;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_NODIRECT</span>:
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (uap-&gt;arg)
		        fp-&gt;f_fglob-&gt;fg_flag |= FNODIRECT;
		<span class="enscript-keyword">else</span>
		        fp-&gt;f_fglob-&gt;fg_flag &amp;= ~FNODIRECT;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SINGLE_WRITER</span>:
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (uap-&gt;arg)
		        fp-&gt;f_fglob-&gt;fg_flag |= FSINGLE_WRITER;
		<span class="enscript-keyword">else</span>
		        fp-&gt;f_fglob-&gt;fg_flag &amp;= ~FSINGLE_WRITER;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GLOBAL_NOCACHE</span>:
	        <span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
		        error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {

		        *retval = vnode_isnocache(vp);

			<span class="enscript-keyword">if</span> (uap-&gt;arg)
			        vnode_setnocache(vp);
			<span class="enscript-keyword">else</span>
			        vnode_clearnocache(vp);

			(<span class="enscript-type">void</span>)vnode_put(vp);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_CHECK_OPENEVT</span>:
	        <span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
		        error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {

		        *retval = vnode_is_openevt(vp);

			<span class="enscript-keyword">if</span> (uap-&gt;arg)
			        vnode_set_openevt(vp);
			<span class="enscript-keyword">else</span>
			        vnode_clear_openevt(vp);

			(<span class="enscript-type">void</span>)vnode_put(vp);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_RDADVISE</span>: {
		<span class="enscript-type">struct</span> radvisory ra_struct;

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> ( (error = copyin(argp, (caddr_t)&amp;ra_struct, <span class="enscript-keyword">sizeof</span>(ra_struct))) )
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {
		        error = VNOP_IOCTL(vp, F_RDADVISE, (caddr_t)&amp;ra_struct, 0, &amp;context);

			(<span class="enscript-type">void</span>)vnode_put(vp);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

        <span class="enscript-keyword">case</span> <span class="enscript-reference">F_FLUSH_DATA</span>:

                <span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
                        error = EBADF;
                        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
                }
                vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
                proc_fdunlock(p);

                <span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {
                        error = cluster_push(vp, 0);

                        (<span class="enscript-type">void</span>)vnode_put(vp);
                }
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_LOG2PHYS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_LOG2PHYS_EXT</span>: {
		<span class="enscript-type">struct</span> log2phys l2p_struct;    <span class="enscript-comment">/* structure for allocate command */</span>
		<span class="enscript-type">int</span> devBlockSize;

		off_t file_offset = 0;
		size_t a_size = 0;
		size_t run = 0;

		<span class="enscript-keyword">if</span> (uap-&gt;cmd == F_LOG2PHYS_EXT) {
			error = copyin(argp, (caddr_t)&amp;l2p_struct, <span class="enscript-keyword">sizeof</span>(l2p_struct));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			file_offset = l2p_struct.l2p_devoffset;
		} <span class="enscript-keyword">else</span> {
			file_offset = fp-&gt;f_offset;
		}
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);
		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
		error = VNOP_OFFTOBLK(vp, file_offset, &amp;lbn);
		<span class="enscript-keyword">if</span> (error) {
			(<span class="enscript-type">void</span>)vnode_put(vp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
		error = VNOP_BLKTOOFF(vp, lbn, &amp;offset);
		<span class="enscript-keyword">if</span> (error) {
			(<span class="enscript-type">void</span>)vnode_put(vp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
		devBlockSize = vfs_devblocksize(vnode_mount(vp));
		<span class="enscript-keyword">if</span> (uap-&gt;cmd == F_LOG2PHYS_EXT) {
			<span class="enscript-keyword">if</span> (l2p_struct.l2p_contigbytes &lt; 0) {
				vnode_put(vp);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
			}

			a_size = MIN((uint64_t)l2p_struct.l2p_contigbytes, SIZE_MAX);
		} <span class="enscript-keyword">else</span> {
			a_size = devBlockSize;
		}
		
		error = VNOP_BLOCKMAP(vp, offset, a_size, &amp;bn, &amp;run, NULL, 0, &amp;context);

		(<span class="enscript-type">void</span>)vnode_put(vp);

		<span class="enscript-keyword">if</span> (!error) {
			l2p_struct.l2p_flags = 0;	<span class="enscript-comment">/* for now */</span>
			<span class="enscript-keyword">if</span> (uap-&gt;cmd == F_LOG2PHYS_EXT) {
				l2p_struct.l2p_contigbytes = run - (file_offset - offset);
			} <span class="enscript-keyword">else</span> {
				l2p_struct.l2p_contigbytes = 0;	<span class="enscript-comment">/* for now */</span>
			}

			<span class="enscript-comment">/*
			 * The block number being -1 suggests that the file offset is not backed
			 * by any real blocks on-disk.  As a result, just let it be passed back up wholesale.
			 */</span>
			<span class="enscript-keyword">if</span> (bn == -1) {
				<span class="enscript-comment">/* Don't multiply it by the block size */</span>
				l2p_struct.l2p_devoffset = bn;
			}
			<span class="enscript-keyword">else</span> {
				l2p_struct.l2p_devoffset = bn * devBlockSize;
				l2p_struct.l2p_devoffset += file_offset - offset;
			}
			error = copyout((caddr_t)&amp;l2p_struct, argp, <span class="enscript-keyword">sizeof</span>(l2p_struct));
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETPATH</span>: {
		<span class="enscript-type">char</span> *pathbufp;
		<span class="enscript-type">int</span> pathlen;

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		pathlen = MAXPATHLEN;
		MALLOC(pathbufp, <span class="enscript-type">char</span> *, pathlen, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (pathbufp == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {
		        error = vn_getpath(vp, pathbufp, &amp;pathlen);
		        (<span class="enscript-type">void</span>)vnode_put(vp);

			<span class="enscript-keyword">if</span> (error == 0)
			        error = copyout((caddr_t)pathbufp, argp, pathlen);
		}
		FREE(pathbufp, M_TEMP);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_PATHPKG_CHECK</span>: {
		<span class="enscript-type">char</span> *pathbufp;
		size_t pathlen;

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
		        error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		pathlen = MAXPATHLEN;
		pathbufp = kalloc(MAXPATHLEN);

		<span class="enscript-keyword">if</span> ( (error = copyinstr(argp, pathbufp, MAXPATHLEN, &amp;pathlen)) == 0 ) {
		        <span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {
				AUDIT_ARG(text, pathbufp);
			        error = vn_path_package_check(vp, pathbufp, pathlen, retval);

				(<span class="enscript-type">void</span>)vnode_put(vp);
			}
		}
		kfree(pathbufp, MAXPATHLEN);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_CHKCLEAN</span>:   <span class="enscript-comment">// used by regression tests to see if all dirty pages got cleaned by fsync()
</span>	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_FULLFSYNC</span>:  <span class="enscript-comment">// fsync + flush the journal + DKIOCSYNCHRONIZE
</span>	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_BARRIERFSYNC</span>:  <span class="enscript-comment">// fsync + barrier
</span>	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_FREEZE_FS</span>:  <span class="enscript-comment">// freeze all other fs operations for the fs of this fd
</span>	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_THAW_FS</span>: {  <span class="enscript-comment">// thaw all frozen fs operations for the fs of this fd
</span>		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {
		        error = VNOP_IOCTL(vp, uap-&gt;cmd, (caddr_t)NULL, 0, &amp;context);

			(<span class="enscript-type">void</span>)vnode_put(vp);
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * SPI (private) for opening a file starting from a dir fd
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_OPENFROM</span>: {
		<span class="enscript-type">struct</span> user_fopenfrom fopen;
		<span class="enscript-type">struct</span> vnode_attr va;
		<span class="enscript-type">struct</span> nameidata nd;
		<span class="enscript-type">int</span> cmode;

		<span class="enscript-comment">/* Check if this isn't a valid file descriptor */</span>
		<span class="enscript-keyword">if</span> ((fp-&gt;f_type != DTYPE_VNODE) ||
		    (fp-&gt;f_flag &amp; FREAD) == 0) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> (vnode_getwithref(vp)) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
		
		<span class="enscript-comment">/* Only valid for directories */</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_type != VDIR) {
			vnode_put(vp);
			error = ENOTDIR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-comment">/* Get flags, mode and pathname arguments. */</span>
		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			error = copyin(argp, &amp;fopen, <span class="enscript-keyword">sizeof</span>(fopen));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_fopenfrom fopen32;

			error = copyin(argp, &amp;fopen32, <span class="enscript-keyword">sizeof</span>(fopen32));
			fopen.o_flags = fopen32.o_flags;
			fopen.o_mode = fopen32.o_mode;
			fopen.o_pathname = CAST_USER_ADDR_T(fopen32.o_pathname);
		}
		<span class="enscript-keyword">if</span> (error) {
			vnode_put(vp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
		AUDIT_ARG(fflags, fopen.o_flags);
		AUDIT_ARG(mode, fopen.o_mode);
		VATTR_INIT(&amp;va);
		<span class="enscript-comment">/* Mask off all but regular access permissions */</span>
		cmode = ((fopen.o_mode &amp;~ fdp-&gt;fd_cmask) &amp; ALLPERMS) &amp; ~S_ISTXT;
		VATTR_SET(&amp;va, va_mode, cmode &amp; ACCESSPERMS);

		<span class="enscript-comment">/* Start the lookup relative to the file descriptor's vnode. */</span>
		NDINIT(&amp;nd, LOOKUP, OP_OPEN, USEDVP | FOLLOW | AUDITVNPATH1, UIO_USERSPACE,
		       fopen.o_pathname, &amp;context);
		nd.ni_dvp = vp;

		error = open1(&amp;context, &amp;nd, fopen.o_flags, &amp;va,
			      fileproc_alloc_init, NULL, retval);

		vnode_put(vp);
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-comment">/*
	 * SPI (private) for unlinking a file starting from a dir fd
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_UNLINKFROM</span>: {
		user_addr_t pathname;

		<span class="enscript-comment">/* Check if this isn't a valid file descriptor */</span>
		<span class="enscript-keyword">if</span> ((fp-&gt;f_type != DTYPE_VNODE) ||
		    (fp-&gt;f_flag &amp; FREAD) == 0) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> (vnode_getwithref(vp)) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
		
		<span class="enscript-comment">/* Only valid for directories */</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_type != VDIR) {
			vnode_put(vp);
			error = ENOTDIR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-comment">/* Get flags, mode and pathname arguments. */</span>
		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			pathname = (user_addr_t)argp;
		} <span class="enscript-keyword">else</span> {
			pathname = CAST_USER_ADDR_T(argp);
		}

		<span class="enscript-comment">/* Start the lookup relative to the file descriptor's vnode. */</span>
		error = unlink1(&amp;context, vp, pathname, UIO_USERSPACE, 0);
		
		vnode_put(vp);
		<span class="enscript-keyword">break</span>;

	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_ADDSIGS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_ADDFILESIGS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_ADDFILESIGS_FOR_DYLD_SIM</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_ADDFILESIGS_RETURN</span>:
	{
		<span class="enscript-type">struct</span> cs_blob *blob = NULL;
		<span class="enscript-type">struct</span> user_fsignatures fs;
		kern_return_t kr;
		vm_offset_t kernel_blob_addr;
		vm_size_t kernel_blob_size;
		<span class="enscript-type">int</span> blob_add_flags = 0;

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> (uap-&gt;cmd == F_ADDFILESIGS_FOR_DYLD_SIM) {
			blob_add_flags |= MAC_VNODE_CHECK_DYLD_SIM;
			<span class="enscript-keyword">if</span> ((p-&gt;p_csflags &amp; CS_KILL) == 0) {
				proc_lock(p);
				p-&gt;p_csflags |= CS_KILL;
				proc_unlock(p);
			}
		}

		error = vnode_getwithref(vp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			error = copyin(argp, &amp;fs, <span class="enscript-keyword">sizeof</span> (fs));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_fsignatures fs32;

			error = copyin(argp, &amp;fs32, <span class="enscript-keyword">sizeof</span> (fs32));
			fs.fs_file_start = fs32.fs_file_start;
			fs.fs_blob_start = CAST_USER_ADDR_T(fs32.fs_blob_start);
			fs.fs_blob_size = fs32.fs_blob_size;
		}

		<span class="enscript-keyword">if</span> (error) {
			vnode_put(vp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-comment">/*
		 * First check if we have something loaded a this offset
		 */</span>
		blob = ubc_cs_blob_get(vp, CPU_TYPE_ANY, fs.fs_file_start);
		<span class="enscript-keyword">if</span> (blob != NULL)
		{
			<span class="enscript-comment">/* If this is for dyld_sim revalidate the blob */</span>
			<span class="enscript-keyword">if</span> (uap-&gt;cmd == F_ADDFILESIGS_FOR_DYLD_SIM) {
				error = ubc_cs_blob_revalidate(vp, blob, blob_add_flags);
			}

		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * An arbitrary limit, to prevent someone from mapping in a 20GB blob.  This should cover
			 * our use cases for the immediate future, but note that at the time of this commit, some
			 * platforms are nearing 2MB blob sizes (with a prior soft limit of 2.5MB).
			 *
			 * We should consider how we can manage this more effectively; the above means that some
			 * platforms are using megabytes of memory for signing data; it merely hasn't crossed the
			 * threshold considered ridiculous at the time of this change.
			 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CS_MAX_BLOB_SIZE</span> (40ULL * 1024ULL * 1024ULL)
			<span class="enscript-keyword">if</span> (fs.fs_blob_size &gt; CS_MAX_BLOB_SIZE) {
				error = E2BIG;
				vnode_put(vp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
			}

			kernel_blob_size = CAST_DOWN(vm_size_t, fs.fs_blob_size);
			kr = ubc_cs_blob_allocate(&amp;kernel_blob_addr, &amp;kernel_blob_size);
			<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
				error = ENOMEM;
				vnode_put(vp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
			}

			<span class="enscript-keyword">if</span>(uap-&gt;cmd == F_ADDSIGS) {
				error = copyin(fs.fs_blob_start,
					       (<span class="enscript-type">void</span> *) kernel_blob_addr,
					       kernel_blob_size);
			} <span class="enscript-keyword">else</span> <span class="enscript-comment">/* F_ADDFILESIGS || F_ADDFILESIGS_RETURN || F_ADDFILESIGS_FOR_DYLD_SIM */</span> {
				<span class="enscript-type">int</span> resid;

				error = vn_rdwr(UIO_READ,
						vp,
						(caddr_t) kernel_blob_addr,
						kernel_blob_size,
						fs.fs_file_start + fs.fs_blob_start,
						UIO_SYSSPACE,
						0,
						kauth_cred_get(),
						&amp;resid,
						p);
				<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; resid) {
					<span class="enscript-comment">/* kernel_blob_size rounded to a page size, but signature may be at end of file */</span>
					memset((<span class="enscript-type">void</span> *)(kernel_blob_addr + (kernel_blob_size - resid)), 0x0, resid);
				}
			}
		
			<span class="enscript-keyword">if</span> (error) {
				ubc_cs_blob_deallocate(kernel_blob_addr,
						       kernel_blob_size);
				vnode_put(vp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
			}

			blob = NULL;
			error = ubc_cs_blob_add(vp,
						CPU_TYPE_ANY,	<span class="enscript-comment">/* not for a specific architecture */</span>
						fs.fs_file_start,
						kernel_blob_addr,
						kernel_blob_size,
						blob_add_flags,
						&amp;blob);
			<span class="enscript-keyword">if</span> (error) {
				ubc_cs_blob_deallocate(kernel_blob_addr,
						       kernel_blob_size);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* ubc_blob_add() has consumed &quot;kernel_blob_addr&quot; */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECK_CS_VALIDATION_BITMAP</span>
				ubc_cs_validation_bitmap_allocate( vp );
#<span class="enscript-reference">endif</span>
			}
		}

		<span class="enscript-keyword">if</span> (uap-&gt;cmd == F_ADDFILESIGS_RETURN || uap-&gt;cmd == F_ADDFILESIGS_FOR_DYLD_SIM) {
			<span class="enscript-comment">/*
			 * The first element of the structure is a
			 * off_t that happen to have the same size for
			 * all archs. Lets overwrite that.
			 */</span>
			off_t end_offset = 0;
			<span class="enscript-keyword">if</span> (blob)
				end_offset = blob-&gt;csb_end_offset;
			error = copyout(&amp;end_offset, argp, <span class="enscript-keyword">sizeof</span> (end_offset));
		}

		(<span class="enscript-type">void</span>) vnode_put(vp);
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_FINDSIGS</span>: {
		error = ENOTSUP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETPROTECTIONCLASS</span>: {
		<span class="enscript-type">int</span> class = 0;
		
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;

		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> (vnode_getwithref(vp)) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
	
		error = cp_vnode_getclass (vp, &amp;class);
		<span class="enscript-keyword">if</span> (error == 0) {
			*retval = class;
		}

		vnode_put(vp);
		<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETPROTECTIONCLASS</span>: {
		<span class="enscript-comment">/* tmp must be a valid PROTECTION_CLASS_* */</span>
		tmp = CAST_DOWN_EXPLICIT(uint32_t, uap-&gt;arg);
		
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;

		proc_fdunlock(p);
	
		<span class="enscript-keyword">if</span> (vnode_getwithref(vp)) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}	
		
		<span class="enscript-comment">/* Only go forward if you have write access */</span>
		vfs_context_t ctx = vfs_context_current();
		<span class="enscript-keyword">if</span>(vnode_authorize(vp, NULLVP, (KAUTH_VNODE_ACCESS | KAUTH_VNODE_WRITE_DATA), ctx) != 0) {
			vnode_put(vp);
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
		error = cp_vnode_setclass (vp, tmp);
		vnode_put(vp);
		<span class="enscript-keyword">break</span>;
	}	

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_TRANSCODEKEY</span>: {
		
		<span class="enscript-type">char</span> *backup_keyp = NULL;
		<span class="enscript-type">unsigned</span> backup_key_len = CP_MAX_WRAPPEDKEYSIZE;

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> (vnode_getwithref(vp)) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}	

		MALLOC(backup_keyp, <span class="enscript-type">char</span> *, backup_key_len, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (backup_keyp == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		error = cp_vnode_transcode (vp, backup_keyp, &amp;backup_key_len);
		vnode_put(vp);

		<span class="enscript-keyword">if</span> (error == 0) {
			error = copyout((caddr_t)backup_keyp, argp, backup_key_len);
			*retval = backup_key_len;
		}

		FREE(backup_keyp, M_TEMP);

		<span class="enscript-keyword">break</span>;
	}	

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETPROTECTIONLEVEL</span>:  {
		uint32_t cp_version = 0;

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF; 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		vp = (<span class="enscript-type">struct</span> vnode*) fp-&gt;f_data;
		proc_fdunlock (p);

		<span class="enscript-keyword">if</span> (vnode_getwithref(vp)) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-comment">/*
		 * if cp_get_major_vers fails, error will be set to proper errno 
		 * and cp_version will still be 0.
		 */</span>

		error = cp_get_root_major_vers (vp, &amp;cp_version);
		*retval = cp_version;

		vnode_put (vp);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETDEFAULTPROTLEVEL</span>:  {
		uint32_t cp_default = 0;

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF; 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		vp = (<span class="enscript-type">struct</span> vnode*) fp-&gt;f_data;
		proc_fdunlock (p);

		<span class="enscript-keyword">if</span> (vnode_getwithref(vp)) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-comment">/*
		 * if cp_get_major_vers fails, error will be set to proper errno 
		 * and cp_version will still be 0.
		 */</span>

		error = cp_get_default_level(vp, &amp;cp_default);
		*retval = cp_default;

		vnode_put (vp);
		<span class="enscript-keyword">break</span>;
	}

	
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_PROTECT */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_MOVEDATAEXTENTS</span>: {
		<span class="enscript-type">struct</span> fileproc *fp2 = NULL;
		<span class="enscript-type">struct</span> vnode *src_vp = NULLVP;
		<span class="enscript-type">struct</span> vnode *dst_vp = NULLVP;
		<span class="enscript-comment">/* We need to grab the 2nd FD out of the argments before moving on. */</span>
		<span class="enscript-type">int</span> fd2 = CAST_DOWN_EXPLICIT(int32_t, uap-&gt;arg);
		
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/* For now, special case HFS+ only, since this is SPI. */</span>
		src_vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		<span class="enscript-keyword">if</span> (src_vp-&gt;v_tag != VT_HFS) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/*
		 * Get the references before we start acquiring iocounts on the vnodes, 
		 * while we still hold the proc fd lock
		 */</span>
		<span class="enscript-keyword">if</span> ( (error = fp_lookup(p, fd2, &amp;fp2, 1)) ) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (fp2-&gt;f_type != DTYPE_VNODE) {
			fp_drop(p, fd2, fp2, 1);
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		dst_vp = (<span class="enscript-type">struct</span> vnode *)fp2-&gt;f_data;
		<span class="enscript-keyword">if</span> (dst_vp-&gt;v_tag != VT_HFS) {
			fp_drop(p, fd2, fp2, 1);
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-comment">/* Re-do MAC checks against the new FD, pass in a fake argument */</span>
		error = mac_file_check_fcntl(proc_ucred(p), fp2-&gt;f_fglob, uap-&gt;cmd, 0);
		<span class="enscript-keyword">if</span> (error) {
			fp_drop(p, fd2, fp2, 1);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/* Audit the 2nd FD */</span>
		AUDIT_ARG(fd, fd2);

		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> (vnode_getwithref(src_vp)) {
			fp_drop(p, fd2, fp2, 0);
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}	
		<span class="enscript-keyword">if</span> (vnode_getwithref(dst_vp)) {
			vnode_put (src_vp);
			fp_drop(p, fd2, fp2, 0);
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}	
		
		<span class="enscript-comment">/* 
		 * Basic asserts; validate they are not the same and that
		 * both live on the same filesystem.
		 */</span>
		<span class="enscript-keyword">if</span> (dst_vp == src_vp) {
			vnode_put (src_vp);
			vnode_put (dst_vp);
			fp_drop (p, fd2, fp2, 0);
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}	

		<span class="enscript-keyword">if</span> (dst_vp-&gt;v_mount != src_vp-&gt;v_mount) {
			vnode_put (src_vp);
			vnode_put (dst_vp);
			fp_drop (p, fd2, fp2, 0);
			error = EXDEV;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-comment">/* Now we have a legit pair of FDs.  Go to work */</span>

		<span class="enscript-comment">/* Now check for write access to the target files */</span>
		<span class="enscript-keyword">if</span>(vnode_authorize(src_vp, NULLVP, 
						   (KAUTH_VNODE_ACCESS | KAUTH_VNODE_WRITE_DATA), &amp;context) != 0) {
			vnode_put(src_vp);
			vnode_put(dst_vp);
			fp_drop(p, fd2, fp2, 0);
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
		
		<span class="enscript-keyword">if</span>(vnode_authorize(dst_vp, NULLVP, 
						   (KAUTH_VNODE_ACCESS | KAUTH_VNODE_WRITE_DATA), &amp;context) != 0) {
			vnode_put(src_vp);
			vnode_put(dst_vp);
			fp_drop(p, fd2, fp2, 0);
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
			
		<span class="enscript-comment">/* Verify that both vps point to files and not directories */</span>
		<span class="enscript-keyword">if</span> ( !vnode_isreg(src_vp) || !vnode_isreg(dst_vp)) {
			error = EINVAL;
			vnode_put (src_vp);
			vnode_put (dst_vp);
			fp_drop (p, fd2, fp2, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-comment">/* 
		 * The exchangedata syscall handler passes in 0 for the flags to VNOP_EXCHANGE.
		 * We'll pass in our special bit indicating that the new behavior is expected
		 */</span>
		
		error = VNOP_EXCHANGE(src_vp, dst_vp, FSOPT_EXCHANGE_DATA_ONLY, &amp;context);
		
		vnode_put (src_vp);
		vnode_put (dst_vp);
		fp_drop(p, fd2, fp2, 0);
		<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-comment">/* 
	 * SPI for making a file compressed.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_MAKECOMPRESSED</span>: {
		uint32_t gcounter = CAST_DOWN_EXPLICIT(uint32_t, uap-&gt;arg);

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF; 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		vp = (<span class="enscript-type">struct</span> vnode*) fp-&gt;f_data;
		proc_fdunlock (p);

		<span class="enscript-comment">/* get the vnode */</span>
		<span class="enscript-keyword">if</span> (vnode_getwithref(vp)) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-comment">/* Is it a file? */</span>
		<span class="enscript-keyword">if</span> ((vnode_isreg(vp) == 0) &amp;&amp; (vnode_islnk(vp) == 0)) {
			vnode_put(vp);
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-comment">/* invoke ioctl to pass off to FS */</span>
		<span class="enscript-comment">/* Only go forward if you have write access */</span> 
		vfs_context_t ctx = vfs_context_current();
		<span class="enscript-keyword">if</span>(vnode_authorize(vp, NULLVP, (KAUTH_VNODE_ACCESS | KAUTH_VNODE_WRITE_DATA), ctx) != 0) {
			vnode_put(vp);
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		error = VNOP_IOCTL(vp, uap-&gt;cmd, (caddr_t)&amp;gcounter, 0, &amp;context);

		vnode_put (vp);
		<span class="enscript-keyword">break</span>;				   
	}
			
	<span class="enscript-comment">/*
	 * SPI (private) for indicating to a filesystem that subsequent writes to
	 * the open FD will written to the Fastflow.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SET_GREEDY_MODE</span>:
		<span class="enscript-comment">/* intentionally drop through to the same handler as F_SETSTATIC.
		 * both fcntls should pass the argument and their selector into VNOP_IOCTL.
		 */</span>

	<span class="enscript-comment">/*
	 * SPI (private) for indicating to a filesystem that subsequent writes to
	 * the open FD will represent static content.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETSTATICCONTENT</span>: {
		caddr_t ioctl_arg = NULL;

		<span class="enscript-keyword">if</span> (uap-&gt;arg) {
			ioctl_arg = (caddr_t) 1;
		}

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		error = vnode_getwithref(vp);
		<span class="enscript-keyword">if</span> (error) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-comment">/* Only go forward if you have write access */</span>
		vfs_context_t ctx = vfs_context_current();
		<span class="enscript-keyword">if</span>(vnode_authorize(vp, NULLVP, (KAUTH_VNODE_ACCESS | KAUTH_VNODE_WRITE_DATA), ctx) != 0) {
			vnode_put(vp);
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		error = VNOP_IOCTL(vp, uap-&gt;cmd, ioctl_arg, 0, &amp;context);
		(<span class="enscript-type">void</span>)vnode_put(vp);
	
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * SPI (private) for indicating to the lower level storage driver that the
	 * subsequent writes should be of a particular IO type (burst, greedy, static),
	 * or other flavors that may be necessary.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETIOTYPE</span>: {
		caddr_t param_ptr; 
		uint32_t param;

		<span class="enscript-keyword">if</span> (uap-&gt;arg) {
			<span class="enscript-comment">/* extract 32 bits of flags from userland */</span>
			param_ptr = (caddr_t) uap-&gt;arg;
			param = (uint32_t) param_ptr;
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* If no argument is specified, error out */</span>
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		<span class="enscript-comment">/* 
		 * Validate the different types of flags that can be specified: 
		 * all of them are mutually exclusive for now.
		 */</span>
		<span class="enscript-keyword">switch</span> (param) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">F_IOTYPE_ISOCHRONOUS</span>:
				<span class="enscript-keyword">break</span>;

			<span class="enscript-reference">default</span>:
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}


		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		error = vnode_getwithref(vp);
		<span class="enscript-keyword">if</span> (error) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-comment">/* Only go forward if you have write access */</span>
		vfs_context_t ctx = vfs_context_current();
		<span class="enscript-keyword">if</span>(vnode_authorize(vp, NULLVP, (KAUTH_VNODE_ACCESS | KAUTH_VNODE_WRITE_DATA), ctx) != 0) {
			vnode_put(vp);
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		error = VNOP_IOCTL(vp, uap-&gt;cmd, param_ptr, 0, &amp;context);
		(<span class="enscript-type">void</span>)vnode_put(vp);

		<span class="enscript-keyword">break</span>;
	}

	
	<span class="enscript-comment">/*
	 * Extract the CodeDirectory of the vnode associated with
	 * the file descriptor and copy it back to user space
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETCODEDIR</span>: {
		<span class="enscript-type">struct</span> user_fcodeblobs args;

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> ((fp-&gt;f_flag &amp; FREAD) == 0) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			<span class="enscript-type">struct</span> user64_fcodeblobs args64;

			error = copyin(argp, &amp;args64, <span class="enscript-keyword">sizeof</span>(args64));
			<span class="enscript-keyword">if</span> (error) 
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

			args.f_cd_hash = args64.f_cd_hash;
			args.f_hash_size = args64.f_hash_size;
			args.f_cd_buffer = args64.f_cd_buffer;
			args.f_cd_size = args64.f_cd_size;
			args.f_out_size = args64.f_out_size;
			args.f_arch = args64.f_arch;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_fcodeblobs args32;

			error = copyin(argp, &amp;args32, <span class="enscript-keyword">sizeof</span>(args32));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

			args.f_cd_hash = CAST_USER_ADDR_T(args32.f_cd_hash);
			args.f_hash_size = args32.f_hash_size;
			args.f_cd_buffer = CAST_USER_ADDR_T(args32.f_cd_buffer);
			args.f_cd_size = args32.f_cd_size;
			args.f_out_size = CAST_USER_ADDR_T(args32.f_out_size);
			args.f_arch = args32.f_arch;
		}

		<span class="enscript-keyword">if</span> (vp-&gt;v_ubcinfo == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-type">struct</span> cs_blob *t_blob = vp-&gt;v_ubcinfo-&gt;cs_blobs;

		<span class="enscript-comment">/*
		 * This call fails if there is no cs_blob corresponding to the
		 * vnode, or if there are multiple cs_blobs present, and the caller
		 * did not specify which cpu_type they want the cs_blob for
		 */</span>
		<span class="enscript-keyword">if</span> (t_blob == NULL) {
			error = ENOENT; <span class="enscript-comment">/* there is no codesigning blob for this process */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (args.f_arch == 0 &amp;&amp; t_blob-&gt;csb_next != NULL) {
			error = ENOENT; <span class="enscript-comment">/* too many architectures and none specified */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		<span class="enscript-comment">/* If the user specified an architecture, find the right blob */</span>
		<span class="enscript-keyword">if</span> (args.f_arch != 0) {
			<span class="enscript-keyword">while</span> (t_blob) {
				<span class="enscript-keyword">if</span> (t_blob-&gt;csb_cpu_type == args.f_arch)
					<span class="enscript-keyword">break</span>;
				t_blob = t_blob-&gt;csb_next;
			}
			<span class="enscript-comment">/* The cpu_type the user requested could not be found */</span>
			<span class="enscript-keyword">if</span> (t_blob == NULL) {
				error = ENOENT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
			}
		}

		<span class="enscript-type">const</span> CS_SuperBlob *super_blob = (<span class="enscript-type">void</span> *)t_blob-&gt;csb_mem_kaddr;
		<span class="enscript-type">const</span> CS_CodeDirectory *cd = findCodeDirectory(super_blob,
	 						 (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *) super_blob,
							 (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *) super_blob + t_blob-&gt;csb_mem_size);
		<span class="enscript-keyword">if</span> (cd == NULL) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		uint64_t buffer_size = ntohl(cd-&gt;length);

		<span class="enscript-keyword">if</span> (buffer_size &gt; UINT_MAX) {
			error = ERANGE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		error = copyout(&amp;buffer_size, args.f_out_size, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>));
		<span class="enscript-keyword">if</span> (error) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(t_blob-&gt;csb_cdhash) &gt; args.f_hash_size ||
					buffer_size &gt; args.f_cd_size) {
			error = ERANGE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		error = copyout(t_blob-&gt;csb_cdhash, args.f_cd_hash, <span class="enscript-keyword">sizeof</span>(t_blob-&gt;csb_cdhash));
		<span class="enscript-keyword">if</span> (error) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		error = copyout(cd, args.f_cd_buffer, buffer_size);
		<span class="enscript-keyword">if</span> (error) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;

		<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-comment">/* 
	 * Set the vnode pointed to by 'fd'
	 * and tag it as the (potentially future) backing store
	 * for another filesystem
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETBACKINGSTORE</span>: {
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;

		<span class="enscript-keyword">if</span> (vp-&gt;v_tag != VT_HFS) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> (vnode_getwithref(vp)) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
		
		<span class="enscript-comment">/* only proceed if you have write access */</span>
		vfs_context_t ctx = vfs_context_current();
		<span class="enscript-keyword">if</span>(vnode_authorize(vp, NULLVP, (KAUTH_VNODE_ACCESS | KAUTH_VNODE_WRITE_DATA), ctx) != 0) {
			vnode_put(vp);
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}

		
		<span class="enscript-comment">/* If arg != 0, set, otherwise unset */</span>
		<span class="enscript-keyword">if</span> (uap-&gt;arg) {
			error = VNOP_IOCTL (vp, uap-&gt;cmd, (caddr_t)1, 0, &amp;context);
		}
		<span class="enscript-keyword">else</span> {
			error = VNOP_IOCTL (vp, uap-&gt;cmd, (caddr_t)NULL, 0, &amp;context);
		}
		
		vnode_put(vp);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* 
	 * like F_GETPATH, but special semantics for
	 * the mobile time machine handler.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETPATH_MTMINFO</span>: {
		<span class="enscript-type">char</span> *pathbufp;
		<span class="enscript-type">int</span> pathlen;

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		pathlen = MAXPATHLEN;
		MALLOC(pathbufp, <span class="enscript-type">char</span> *, pathlen, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (pathbufp == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
		}
		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {
			<span class="enscript-type">int</span> backingstore = 0;
			
			<span class="enscript-comment">/* Check for error from vn_getpath before moving on */</span>
			<span class="enscript-keyword">if</span> ((error = vn_getpath(vp, pathbufp, &amp;pathlen)) == 0) {
				<span class="enscript-keyword">if</span> (vp-&gt;v_tag == VT_HFS) {
					error = VNOP_IOCTL (vp, uap-&gt;cmd, (caddr_t) &amp;backingstore, 0, &amp;context);
				}
				(<span class="enscript-type">void</span>)vnode_put(vp);

				<span class="enscript-keyword">if</span> (error == 0) {
					error = copyout((caddr_t)pathbufp, argp, pathlen);
				}
				<span class="enscript-keyword">if</span> (error == 0) {
					<span class="enscript-comment">/* 
					 * If the copyout was successful, now check to ensure
					 * that this vnode is not a BACKINGSTORE vnode.  mtmd
					 * wants the path regardless.
					 */</span>
					<span class="enscript-keyword">if</span> (backingstore) {
						error = EBUSY;
					}
				}
			} <span class="enscript-keyword">else</span>
				(<span class="enscript-type">void</span>)vnode_put(vp);
		}
		FREE(pathbufp, M_TEMP);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">DEVELOPMENT</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_RECYCLE</span>:
		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		vnode_recycle(vp);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/*
		 * This is an fcntl() that we d not recognize at this level;
		 * if this is a vnode, we send it down into the VNOP_IOCTL
		 * for this vnode; this can include special devices, and will
		 * effectively overload fcntl() to send ioctl()'s.
		 */</span>
		<span class="enscript-keyword">if</span>((uap-&gt;cmd &amp; IOC_VOID) &amp;&amp; (uap-&gt;cmd &amp; IOC_INOUT)){
            error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		<span class="enscript-comment">/* Catch any now-invalid fcntl() selectors */</span>
		<span class="enscript-keyword">switch</span> (uap-&gt;cmd) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">F_MARKDEPENDENCY</span>:
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">STK_PARAMS</span> 128
			<span class="enscript-type">char</span> stkbuf[STK_PARAMS];
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> size;
			caddr_t data, memp;
			<span class="enscript-comment">/*
			 * For this to work properly, we have to copy in the
			 * ioctl() cmd argument if there is one; we must also
			 * check that a command parameter, if present, does
			 * not exceed the maximum command length dictated by
			 * the number of bits we have available in the command
			 * to represent a structure length.  Finally, we have
			 * to copy the results back out, if it is that type of
			 * ioctl().
			 */</span>
			size = IOCPARM_LEN(uap-&gt;cmd);
			<span class="enscript-keyword">if</span> (size &gt; IOCPARM_MAX) {
				(<span class="enscript-type">void</span>)vnode_put(vp);
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			memp = NULL;
			<span class="enscript-keyword">if</span> (size &gt; <span class="enscript-keyword">sizeof</span> (stkbuf)) {
				<span class="enscript-keyword">if</span> ((memp = (caddr_t)kalloc(size)) == 0) {
					(<span class="enscript-type">void</span>)vnode_put(vp);
					error = ENOMEM;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
				}
				data = memp;
			} <span class="enscript-keyword">else</span> {
				data = &amp;stkbuf[0];
			}
			
			<span class="enscript-keyword">if</span> (uap-&gt;cmd &amp; IOC_IN) {
				<span class="enscript-keyword">if</span> (size) {
					<span class="enscript-comment">/* structure */</span>
					error = copyin(argp, data, size);
					<span class="enscript-keyword">if</span> (error) {
						(<span class="enscript-type">void</span>)vnode_put(vp);
						<span class="enscript-keyword">if</span> (memp)
							kfree(memp, size);
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">outdrop</span>;
					}

					<span class="enscript-comment">/* Bzero the section beyond that which was needed */</span>
					<span class="enscript-keyword">if</span> (size &lt;= <span class="enscript-keyword">sizeof</span>(stkbuf)) {
						bzero ( (((uint8_t*)data) + size), (<span class="enscript-keyword">sizeof</span>(stkbuf) - size));
					}
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* int */</span>
					<span class="enscript-keyword">if</span> (is64bit) {
						*(user_addr_t *)data = argp;
					} <span class="enscript-keyword">else</span> {
						*(uint32_t *)data = (uint32_t)argp;
					}
				};
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((uap-&gt;cmd &amp; IOC_OUT) &amp;&amp; size) {
				<span class="enscript-comment">/*
				 * Zero the buffer so the user always
				 * gets back something deterministic.
				 */</span>
				bzero(data, size);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uap-&gt;cmd &amp; IOC_VOID) {
				<span class="enscript-keyword">if</span> (is64bit) {
				    *(user_addr_t *)data = argp;
				} <span class="enscript-keyword">else</span> {
				    *(uint32_t *)data = (uint32_t)argp;
				}
			}

			error = VNOP_IOCTL(vp, uap-&gt;cmd, CAST_DOWN(caddr_t, data), 0, &amp;context);

			(<span class="enscript-type">void</span>)vnode_put(vp);

			<span class="enscript-comment">/* Copy any output data to user */</span>
			<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; (uap-&gt;cmd &amp; IOC_OUT) &amp;&amp; size) 
				error = copyout(data, argp, size);
			<span class="enscript-keyword">if</span> (memp)
				kfree(memp, size);
		}
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">outdrop</span>:
	AUDIT_ARG(vnpath_withref, vp, ARG_VNODE1);
	fp_drop(p, fd, fp, 0);
	<span class="enscript-keyword">return</span>(error);
<span class="enscript-reference">out</span>:
	fp_drop(p, fd, fp, 1);
	proc_fdunlock(p);
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * finishdup
 *
 * Description:	Common code for dup, dup2, and fcntl(F_DUPFD).
 *
 * Parameters:	p				Process performing the dup
 *		old				The fd to dup
 *		new				The fd to dup it to
 *		fd_flags			Flags to augment the new fd
 *		retval				Pointer to the call return area
 *
 * Returns:	0				Success
 *		EBADF
 *		ENOMEM
 *
 * Implicit returns:
 *		*retval (modified)		The new descriptor
 *
 * Locks:	Assumes proc_fdlock for process pointing to fdp is held by
 *		the caller
 *
 * Notes:	This function may drop and reacquire this lock; it is unsafe
 *		for a caller to assume that other state protected by the lock
 *		has not been subsequently changed out from under it.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">finishdup</span>(proc_t p,
    <span class="enscript-type">struct</span> filedesc *fdp, <span class="enscript-type">int</span> old, <span class="enscript-type">int</span> new, <span class="enscript-type">int</span> fd_flags, int32_t *retval)
{
	<span class="enscript-type">struct</span> fileproc *nfp;
	<span class="enscript-type">struct</span> fileproc *ofp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	proc_fdlock_assert(p, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((ofp = fdp-&gt;fd_ofiles[old]) == NULL ||
	    (fdp-&gt;fd_ofileflags[old] &amp; UF_RESERVED)) {
		fdrelse(p, new);
		<span class="enscript-keyword">return</span> (EBADF);
	}
	fg_ref(ofp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_file_check_dup(proc_ucred(p), ofp-&gt;f_fglob, new);
	<span class="enscript-keyword">if</span> (error) {
		fg_drop(ofp);
		fdrelse(p, new);
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>

	proc_fdunlock(p);

	nfp = fileproc_alloc_init(NULL);

	proc_fdlock(p);

	<span class="enscript-keyword">if</span> (nfp == NULL) {
		fg_drop(ofp);
		fdrelse(p, new);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	nfp-&gt;f_fglob = ofp-&gt;f_fglob;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (fdp-&gt;fd_ofiles[new] != 0)
		panic(<span class="enscript-string">&quot;finishdup: overwriting fd_ofiles with new %d&quot;</span>, new);
	<span class="enscript-keyword">if</span> ((fdp-&gt;fd_ofileflags[new] &amp; UF_RESERVED) == 0)
		panic(<span class="enscript-string">&quot;finishdup: unreserved fileflags with new %d&quot;</span>, new);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (new &gt; fdp-&gt;fd_lastfile)
		fdp-&gt;fd_lastfile = new;
	*fdflags(p, new) |= fd_flags;
	procfdtbl_releasefd(p, new, nfp);
	*retval = new;
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * close
 *
 * Description:	The implementation of the close(2) system call
 *
 * Parameters:	p			Process in whose per process file table
 *					the close is to occur
 *		uap-&gt;fd			fd to be closed
 *		retval			&lt;unused&gt;
 *
 * Returns:	0			Success
 *	fp_lookup:EBADF			Bad file descriptor
 *      fp_guard_exception:???          Guarded file descriptor
 *	close_internal:EBADF
 *	close_internal:??? 		Anything returnable by a per-fileops
 *					close function
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">close</span>(proc_t p, <span class="enscript-type">struct</span> close_args *uap, int32_t *retval)
{
	__pthread_testcancel(1);
	<span class="enscript-keyword">return</span>(close_nocancel(p, (<span class="enscript-type">struct</span> close_nocancel_args *)uap, retval));
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">close_nocancel</span>(proc_t p, <span class="enscript-type">struct</span> close_nocancel_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> fd = uap-&gt;fd;
	<span class="enscript-type">int</span> error;

	AUDIT_SYSCLOSE(p, fd);

	proc_fdlock(p);

	<span class="enscript-keyword">if</span> ( (error = fp_lookup(p,fd,&amp;fp, 1)) ) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(error);
	}

	<span class="enscript-keyword">if</span> (FP_ISGUARDED(fp, GUARD_CLOSE)) {
		error = fp_guard_exception(p, fd, fp, kGUARD_EXC_CLOSE);
		(<span class="enscript-type">void</span>) fp_drop(p, fd, fp, 1);
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (error);
	}

	error = close_internal_locked(p, fd, fp, 0);

	proc_fdunlock(p);

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * close_internal_locked
 *
 * Close a file descriptor.
 *
 * Parameters:	p			Process in whose per process file table
 *					the close is to occur
 *		fd			fd to be closed
 *		fp			fileproc associated with the fd
 *
 * Returns:	0			Success
 *		EBADF			fd already in close wait state
 *	closef_locked:??? 		Anything returnable by a per-fileops
 *					close function
 *
 * Locks:	Assumes proc_fdlock for process is held by the caller and returns
 *		with lock held
 *
 * Notes:	This function may drop and reacquire this lock; it is unsafe
 *		for a caller to assume that other state protected by the lock
 *		has not been subsequently changed out from under it.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">close_internal_locked</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">int</span> error =0;
	<span class="enscript-type">int</span> resvfd = flags &amp; FD_DUP2RESV;


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	proc_fdlock_assert(p, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Keep people from using the filedesc while we are closing it */</span>
	procfdtbl_markclosefd(p, fd);


	<span class="enscript-keyword">if</span> ((fp-&gt;f_flags &amp; FP_CLOSING) == FP_CLOSING) {
		panic(<span class="enscript-string">&quot;close_internal_locked: being called on already closing fd&quot;</span>);
	}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> ((fdp-&gt;fd_ofileflags[fd] &amp; UF_RESERVED) == 0)
		panic(<span class="enscript-string">&quot;close_internal: unreserved fileflags with fd %d&quot;</span>, fd);
#<span class="enscript-reference">endif</span>

	fp-&gt;f_flags |= FP_CLOSING;

	<span class="enscript-keyword">if</span> ( (fp-&gt;f_flags &amp; FP_AIOISSUED) || kauth_authorize_fileop_has_listeners() ) {

	        proc_fdunlock(p);

		<span class="enscript-keyword">if</span> ( (fp-&gt;f_type == DTYPE_VNODE) &amp;&amp; kauth_authorize_fileop_has_listeners() ) {
		        <span class="enscript-comment">/*
			 * call out to allow 3rd party notification of close. 
			 * Ignore result of kauth_authorize_fileop call.
			 */</span>
		        <span class="enscript-keyword">if</span> (vnode_getwithref((vnode_t)fp-&gt;f_data) == 0) {
		        	u_int	fileop_flags = 0;
		        	<span class="enscript-keyword">if</span> ((fp-&gt;f_flags &amp; FP_WRITTEN) != 0)
		        		fileop_flags |= KAUTH_FILEOP_CLOSE_MODIFIED;
			        kauth_authorize_fileop(fp-&gt;f_fglob-&gt;fg_cred, KAUTH_FILEOP_CLOSE, 
						       (uintptr_t)fp-&gt;f_data, (uintptr_t)fileop_flags);
				vnode_put((vnode_t)fp-&gt;f_data);
			}
		}
		<span class="enscript-keyword">if</span> (fp-&gt;f_flags &amp; FP_AIOISSUED)
		        <span class="enscript-comment">/*
			 * cancel all async IO requests that can be cancelled.
			 */</span>
		        _aio_close( p, fd );

		proc_fdlock(p);
	}

	<span class="enscript-keyword">if</span> (fd &lt; fdp-&gt;fd_knlistsize)
		knote_fdclose(p, fd);

	<span class="enscript-keyword">if</span> (fp-&gt;f_flags &amp; FP_WAITEVENT) 
		(<span class="enscript-type">void</span>)waitevent_close(p, fp);

	fileproc_drain(p, fp);

	<span class="enscript-keyword">if</span> (resvfd == 0) {
		_fdrelse(p, fd);
	} <span class="enscript-keyword">else</span> {
		procfdtbl_reservefd(p, fd);
	}

	<span class="enscript-keyword">if</span> (ENTR_SHOULDTRACE &amp;&amp; fp-&gt;f_type == DTYPE_SOCKET)
		KERNEL_ENERGYTRACE(kEnTrActKernSocket, DBG_FUNC_END,
		    fd, 0, (int64_t)VM_KERNEL_ADDRPERM(fp-&gt;f_data));

	error = closef_locked(fp, fp-&gt;f_fglob, p);
	<span class="enscript-keyword">if</span> ((fp-&gt;f_flags &amp; FP_WAITCLOSE) == FP_WAITCLOSE)
		wakeup(&amp;fp-&gt;f_flags);
	fp-&gt;f_flags &amp;= ~(FP_WAITCLOSE | FP_CLOSING);

	proc_fdunlock(p);

	fileproc_free(fp);	

	proc_fdlock(p);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (resvfd != 0) {
		<span class="enscript-keyword">if</span> ((fdp-&gt;fd_ofileflags[fd] &amp; UF_RESERVED) == 0)
			panic(<span class="enscript-string">&quot;close with reserved fd returns with freed fd:%d: proc: %p&quot;</span>, fd, p);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * fstat1
 *
 * Description:	Return status information about a file descriptor.
 *
 * Parameters:	p				The process doing the fstat
 *		fd				The fd to stat
 *		ub				The user stat buffer
 *		xsecurity			The user extended security
 *						buffer, or 0 if none
 *		xsecurity_size			The size of xsecurity, or 0
 *						if no xsecurity
 *		isstat64			Flag to indicate 64 bit version
 *						for inode size, etc.
 *
 * Returns:	0				Success
 *		EBADF
 *		EFAULT
 *	fp_lookup:EBADF				Bad file descriptor
 *	vnode_getwithref:???
 *	copyout:EFAULT
 *	vnode_getwithref:???
 *	vn_stat:???
 *	soo_stat:???
 *	pipe_stat:???
 *	pshm_stat:???
 *	kqueue_stat:???
 *
 * Notes:	Internal implementation for all other fstat() related
 *		functions
 *
 *		XXX switch on node type is bogus; need a stat in struct
 *		XXX fileops instead.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fstat1</span>(proc_t p, <span class="enscript-type">int</span> fd, user_addr_t ub, user_addr_t xsecurity, user_addr_t xsecurity_size, <span class="enscript-type">int</span> isstat64)
{
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> stat sb;
		<span class="enscript-type">struct</span> stat64 sb64;
	} source;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> user64_stat user64_sb;
		<span class="enscript-type">struct</span> user32_stat user32_sb;
		<span class="enscript-type">struct</span> user64_stat64 user64_sb64;
		<span class="enscript-type">struct</span> user32_stat64 user32_sb64;
	} dest;
	<span class="enscript-type">int</span> error, my_size;
	file_type_t type;
	caddr_t data;
	kauth_filesec_t fsec;
	user_size_t xsecurity_bufsize;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">void</span> * sbptr;


	AUDIT_ARG(fd, fd);

	<span class="enscript-keyword">if</span> ((error = fp_lookup(p, fd, &amp;fp, 0)) != 0) {
		<span class="enscript-keyword">return</span>(error);
	}
	type = fp-&gt;f_type;
	data = fp-&gt;f_data;
	fsec = KAUTH_FILESEC_NONE;

	sbptr = (<span class="enscript-type">void</span> *)&amp;source;

	<span class="enscript-keyword">switch</span> (type) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_VNODE</span>:
		<span class="enscript-keyword">if</span> ((error = vnode_getwithref((vnode_t)data)) == 0) {
			<span class="enscript-comment">/*
			 * If the caller has the file open, and is not
			 * requesting extended security information, we are
			 * going to let them get the basic stat information.
			 */</span>
			<span class="enscript-keyword">if</span> (xsecurity == USER_ADDR_NULL) {
				error = vn_stat_noauth((vnode_t)data, sbptr, NULL, isstat64, ctx);
			} <span class="enscript-keyword">else</span> {
				error = vn_stat((vnode_t)data, sbptr, &amp;fsec, isstat64, ctx);
			}

			AUDIT_ARG(vnpath, (<span class="enscript-type">struct</span> vnode *)data, ARG_VNODE1);
			(<span class="enscript-type">void</span>)vnode_put((vnode_t)data);
		}
		<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_SOCKET</span>:
		error = soo_stat((<span class="enscript-type">struct</span> socket *)data, sbptr, isstat64);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SOCKETS */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PIPE</span>:
		error = pipe_stat((<span class="enscript-type">void</span> *)data, sbptr, isstat64);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PSXSHM</span>:
		error = pshm_stat((<span class="enscript-type">void</span> *)data, sbptr, isstat64);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_KQUEUE</span>:
		error = kqueue_stat((<span class="enscript-type">void</span> *)data, sbptr, isstat64, p);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EBADF;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (error == 0) {
		caddr_t sbp;

		<span class="enscript-keyword">if</span> (isstat64 != 0) {
			source.sb64.st_lspare = 0;
			source.sb64.st_qspare[0] = 0LL;
			source.sb64.st_qspare[1] = 0LL;

			<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(current_proc())) {
				munge_user64_stat64(&amp;source.sb64, &amp;dest.user64_sb64); 
				my_size = <span class="enscript-keyword">sizeof</span>(dest.user64_sb64);
				sbp = (caddr_t)&amp;dest.user64_sb64;
			} <span class="enscript-keyword">else</span> {
				munge_user32_stat64(&amp;source.sb64, &amp;dest.user32_sb64); 
				my_size = <span class="enscript-keyword">sizeof</span>(dest.user32_sb64);
				sbp = (caddr_t)&amp;dest.user32_sb64;
			}
		} <span class="enscript-keyword">else</span> {
			source.sb.st_lspare = 0;
			source.sb.st_qspare[0] = 0LL;
			source.sb.st_qspare[1] = 0LL;
			<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(current_proc())) {
				munge_user64_stat(&amp;source.sb, &amp;dest.user64_sb); 
				my_size = <span class="enscript-keyword">sizeof</span>(dest.user64_sb);
				sbp = (caddr_t)&amp;dest.user64_sb;
			} <span class="enscript-keyword">else</span> {
				munge_user32_stat(&amp;source.sb, &amp;dest.user32_sb); 
				my_size = <span class="enscript-keyword">sizeof</span>(dest.user32_sb);
				sbp = (caddr_t)&amp;dest.user32_sb;
			}
		}

		error = copyout(sbp, ub, my_size);
	}

	<span class="enscript-comment">/* caller wants extended security information? */</span>
	<span class="enscript-keyword">if</span> (xsecurity != USER_ADDR_NULL) {

		<span class="enscript-comment">/* did we get any? */</span>
		 <span class="enscript-keyword">if</span> (fsec == KAUTH_FILESEC_NONE) {
			<span class="enscript-keyword">if</span> (susize(xsecurity_size, 0) != 0) {
				error = EFAULT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* find the user buffer size */</span>
			xsecurity_bufsize = fusize(xsecurity_size);

			<span class="enscript-comment">/* copy out the actual data size */</span>
			<span class="enscript-keyword">if</span> (susize(xsecurity_size, KAUTH_FILESEC_COPYSIZE(fsec)) != 0) {
				error = EFAULT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-comment">/* if the caller supplied enough room, copy out to it */</span>
			<span class="enscript-keyword">if</span> (xsecurity_bufsize &gt;= KAUTH_FILESEC_COPYSIZE(fsec))
				error = copyout(fsec, xsecurity, KAUTH_FILESEC_COPYSIZE(fsec));
		}
	}
<span class="enscript-reference">out</span>:
	fp_drop(p, fd, fp, 0);
	<span class="enscript-keyword">if</span> (fsec != NULL)
		kauth_filesec_free(fsec);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * fstat_extended
 *
 * Description:	Extended version of fstat supporting returning extended
 *		security information
 *
 * Parameters:	p				The process doing the fstat
 *		uap-&gt;fd				The fd to stat
 *		uap-&gt;ub				The user stat buffer
 *		uap-&gt;xsecurity			The user extended security
 *						buffer, or 0 if none
 *		uap-&gt;xsecurity_size		The size of xsecurity, or 0
 *
 * Returns:	0				Success
 *		!0				Errno (see fstat1)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fstat_extended</span>(proc_t p, <span class="enscript-type">struct</span> fstat_extended_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span>(fstat1(p, uap-&gt;fd, uap-&gt;ub, uap-&gt;xsecurity, uap-&gt;xsecurity_size, 0));
}
 

<span class="enscript-comment">/*
 * fstat
 *
 * Description:	Get file status for the file associated with fd
 *
 * Parameters:	p				The process doing the fstat
 *		uap-&gt;fd				The fd to stat
 *		uap-&gt;ub				The user stat buffer
 *
 * Returns:	0				Success
 *		!0				Errno (see fstat1)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fstat</span>(proc_t p, <span class="enscript-type">register</span> <span class="enscript-type">struct</span> fstat_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span>(fstat1(p, uap-&gt;fd, uap-&gt;ub, 0, 0, 0));
}


<span class="enscript-comment">/*
 * fstat64_extended
 *
 * Description:	Extended version of fstat64 supporting returning extended
 *		security information
 *
 * Parameters:	p				The process doing the fstat
 *		uap-&gt;fd				The fd to stat
 *		uap-&gt;ub				The user stat buffer
 *		uap-&gt;xsecurity			The user extended security
 *						buffer, or 0 if none
 *		uap-&gt;xsecurity_size		The size of xsecurity, or 0
 *
 * Returns:	0				Success
 *		!0				Errno (see fstat1)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fstat64_extended</span>(proc_t p, <span class="enscript-type">struct</span> fstat64_extended_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span>(fstat1(p, uap-&gt;fd, uap-&gt;ub, uap-&gt;xsecurity, uap-&gt;xsecurity_size, 1));
}
 

<span class="enscript-comment">/*
 * fstat64
 *
 * Description:	Get 64 bit version of the file status for the file associated
 *		with fd
 *
 * Parameters:	p				The process doing the fstat
 *		uap-&gt;fd				The fd to stat
 *		uap-&gt;ub				The user stat buffer
 *
 * Returns:	0				Success
 *		!0				Errno (see fstat1)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fstat64</span>(proc_t p, <span class="enscript-type">register</span> <span class="enscript-type">struct</span> fstat64_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span>(fstat1(p, uap-&gt;fd, uap-&gt;ub, 0, 0, 1));
}


<span class="enscript-comment">/*
 * fpathconf
 *
 * Description:	Return pathconf information about a file descriptor.
 *
 * Parameters:	p				Process making the request
 *		uap-&gt;fd				fd to get information about
 *		uap-&gt;name			Name of information desired
 *		retval				Pointer to the call return area
 *
 * Returns:	0				Success
 *		EINVAL
 *	fp_lookup:EBADF				Bad file descriptor
 *	vnode_getwithref:???
 *	vn_pathconf:???
 *
 * Implicit returns:
 *		*retval (modified)		Returned information (numeric)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fpathconf</span>(proc_t p, <span class="enscript-type">struct</span> fpathconf_args *uap, int32_t *retval)
{
	<span class="enscript-type">int</span> fd = uap-&gt;fd;
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">int</span> error = 0;
	file_type_t type;
	caddr_t data;


	AUDIT_ARG(fd, uap-&gt;fd);
	<span class="enscript-keyword">if</span> ( (error = fp_lookup(p, fd, &amp;fp, 0)) )
		<span class="enscript-keyword">return</span>(error);
	type = fp-&gt;f_type;
	data = fp-&gt;f_data;

	<span class="enscript-keyword">switch</span> (type) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_SOCKET</span>:
		<span class="enscript-keyword">if</span> (uap-&gt;name != _PC_PIPE_BUF) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		*retval = PIPE_BUF;
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PIPE</span>:
		<span class="enscript-keyword">if</span> (uap-&gt;name != _PC_PIPE_BUF) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		*retval = PIPE_BUF;
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_VNODE</span>:
		vp = (<span class="enscript-type">struct</span> vnode *)data;

		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0) {
		        AUDIT_ARG(vnpath, vp, ARG_VNODE1);

			error = vn_pathconf(vp, uap-&gt;name, retval, vfs_context_current());

			(<span class="enscript-type">void</span>)vnode_put(vp);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	}
	<span class="enscript-comment">/*NOTREACHED*/</span>
<span class="enscript-reference">out</span>:
	fp_drop(p, fd, fp, 0);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Statistics counter for the number of times a process calling fdalloc()
 * has resulted in an expansion of the per process open file table.
 *
 * XXX This would likely be of more use if it were per process
 */</span>
<span class="enscript-type">int</span> fdexpand;


<span class="enscript-comment">/*
 * fdalloc
 *
 * Description:	Allocate a file descriptor for the process.
 *
 * Parameters:	p				Process to allocate the fd in
 *		want				The fd we would prefer to get
 *		result				Pointer to fd we got
 *
 * Returns:	0				Success
 *		EMFILE
 *		ENOMEM
 *
 * Implicit returns:
 *		*result (modified)		The fd which was allocated
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fdalloc</span>(proc_t p, <span class="enscript-type">int</span> want, <span class="enscript-type">int</span> *result)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> lim, last, numfiles, oldnfiles;
	<span class="enscript-type">struct</span> fileproc **newofiles, **ofiles;
	<span class="enscript-type">char</span> *newofileflags;

	<span class="enscript-comment">/*
	 * Search for a free descriptor starting at the higher
	 * of want or fd_freefile.  If that fails, consider
	 * expanding the ofile array.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	proc_fdlock_assert(p, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>

	lim = min((<span class="enscript-type">int</span>)p-&gt;p_rlimit[RLIMIT_NOFILE].rlim_cur, maxfiles);
	<span class="enscript-keyword">for</span> (;;) {
		last = min(fdp-&gt;fd_nfiles, lim);
		<span class="enscript-keyword">if</span> ((i = want) &lt; fdp-&gt;fd_freefile)
			i = fdp-&gt;fd_freefile;
		<span class="enscript-keyword">for</span> (; i &lt; last; i++) {
			<span class="enscript-keyword">if</span> (fdp-&gt;fd_ofiles[i] == NULL &amp;&amp; !(fdp-&gt;fd_ofileflags[i] &amp; UF_RESERVED)) {
				procfdtbl_reservefd(p, i);
				<span class="enscript-keyword">if</span> (i &gt; fdp-&gt;fd_lastfile)
					fdp-&gt;fd_lastfile = i;
				<span class="enscript-keyword">if</span> (want &lt;= fdp-&gt;fd_freefile)
					fdp-&gt;fd_freefile = i;
				*result = i;
				<span class="enscript-keyword">return</span> (0);
			}
		}

		<span class="enscript-comment">/*
		 * No space in current array.  Expand?
		 */</span>
		<span class="enscript-keyword">if</span> (fdp-&gt;fd_nfiles &gt;= lim)
			<span class="enscript-keyword">return</span> (EMFILE);
		<span class="enscript-keyword">if</span> (fdp-&gt;fd_nfiles &lt; NDEXTENT)
			numfiles = NDEXTENT;
		<span class="enscript-keyword">else</span>
			numfiles = 2 * fdp-&gt;fd_nfiles;
		<span class="enscript-comment">/* Enforce lim */</span>
		<span class="enscript-keyword">if</span> (numfiles &gt; lim)
			numfiles = lim;
		proc_fdunlock(p);
		MALLOC_ZONE(newofiles, <span class="enscript-type">struct</span> fileproc **,
				numfiles * OFILESIZE, M_OFILETABL, M_WAITOK);
		proc_fdlock(p);
		<span class="enscript-keyword">if</span> (newofiles == NULL) {
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		<span class="enscript-keyword">if</span> (fdp-&gt;fd_nfiles &gt;= numfiles) {
			FREE_ZONE(newofiles, numfiles * OFILESIZE, M_OFILETABL);
			<span class="enscript-keyword">continue</span>;
		}
		newofileflags = (<span class="enscript-type">char</span> *) &amp;newofiles[numfiles];
		<span class="enscript-comment">/*
		 * Copy the existing ofile and ofileflags arrays
		 * and zero the new portion of each array.
		 */</span>
		oldnfiles = fdp-&gt;fd_nfiles;
		(<span class="enscript-type">void</span>) memcpy(newofiles, fdp-&gt;fd_ofiles,
				oldnfiles * <span class="enscript-keyword">sizeof</span>(*fdp-&gt;fd_ofiles));
		(<span class="enscript-type">void</span>) memset(&amp;newofiles[oldnfiles], 0,
				(numfiles - oldnfiles) * <span class="enscript-keyword">sizeof</span>(*fdp-&gt;fd_ofiles));

		(<span class="enscript-type">void</span>) memcpy(newofileflags, fdp-&gt;fd_ofileflags,
				oldnfiles * <span class="enscript-keyword">sizeof</span>(*fdp-&gt;fd_ofileflags));
		(<span class="enscript-type">void</span>) memset(&amp;newofileflags[oldnfiles], 0,
				(numfiles - oldnfiles) *
						<span class="enscript-keyword">sizeof</span>(*fdp-&gt;fd_ofileflags));
		ofiles = fdp-&gt;fd_ofiles;
		fdp-&gt;fd_ofiles = newofiles;
		fdp-&gt;fd_ofileflags = newofileflags;
		fdp-&gt;fd_nfiles = numfiles;
		FREE_ZONE(ofiles, oldnfiles * OFILESIZE, M_OFILETABL);
		fdexpand++;
	}
}


<span class="enscript-comment">/*
 * fdavail
 *
 * Description:	Check to see whether n user file descriptors are available
 *		to the process p.
 *
 * Parameters:	p				Process to check in
 *		n				The number of fd's desired
 *
 * Returns:	0				No
 *		1				Yes
 *
 * Locks:	Assumes proc_fdlock for process is held by the caller
 *
 * Notes:	The answer only remains valid so long as the proc_fdlock is
 *		held by the caller.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fdavail</span>(proc_t p, <span class="enscript-type">int</span> n)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> fileproc **fpp;
	<span class="enscript-type">char</span> *flags;
	<span class="enscript-type">int</span> i, lim;

	lim = min((<span class="enscript-type">int</span>)p-&gt;p_rlimit[RLIMIT_NOFILE].rlim_cur, maxfiles);
	<span class="enscript-keyword">if</span> ((i = lim - fdp-&gt;fd_nfiles) &gt; 0 &amp;&amp; (n -= i) &lt;= 0)
		<span class="enscript-keyword">return</span> (1);
	fpp = &amp;fdp-&gt;fd_ofiles[fdp-&gt;fd_freefile];
	flags = &amp;fdp-&gt;fd_ofileflags[fdp-&gt;fd_freefile];
	<span class="enscript-keyword">for</span> (i = fdp-&gt;fd_nfiles - fdp-&gt;fd_freefile; --i &gt;= 0; fpp++, flags++)
		<span class="enscript-keyword">if</span> (*fpp == NULL &amp;&amp; !(*flags &amp; UF_RESERVED) &amp;&amp; --n &lt;= 0)
			<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * fdrelse
 *
 * Description:	Legacy KPI wrapper function for _fdrelse
 *
 * Parameters:	p				Process in which fd lives
 *		fd				fd to free
 *
 * Returns:	void
 *
 * Locks:	Assumes proc_fdlock for process is held by the caller
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fdrelse</span>(proc_t p, <span class="enscript-type">int</span> fd)
{
	_fdrelse(p, fd);
}


<span class="enscript-comment">/*
 * fdgetf_noref
 *
 * Description:	Get the fileproc pointer for the given fd from the per process
 *		open file table without taking an explicit reference on it.
 *
 * Parameters:	p				Process containing fd
 *		fd				fd to obtain fileproc for
 *		resultfp			Pointer to pointer return area
 *
 * Returns:	0				Success
 *		EBADF
 *
 * Implicit returns:
 *		*resultfp (modified)		Pointer to fileproc pointer
 *
 * Locks:	Assumes proc_fdlock for process is held by the caller
 *
 * Notes:	Because there is no reference explicitly taken, the returned
 *		fileproc pointer is only valid so long as the proc_fdlock
 *		remains held by the caller.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fdgetf_noref</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc **resultfp)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> fileproc *fp;

	<span class="enscript-keyword">if</span> (fd &lt; 0 || fd &gt;= fdp-&gt;fd_nfiles ||
			(fp = fdp-&gt;fd_ofiles[fd]) == NULL ||
			(fdp-&gt;fd_ofileflags[fd] &amp; UF_RESERVED)) {
		<span class="enscript-keyword">return</span> (EBADF);
	}
	<span class="enscript-keyword">if</span> (resultfp)
		*resultfp = fp;
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * fp_getfvp
 *
 * Description:	Get fileproc and vnode pointer for a given fd from the per
 *		process open file table of the specified process, and if
 *		successful, increment the f_iocount
 *
 * Parameters:	p				Process in which fd lives
 *		fd				fd to get information for
 *		resultfp			Pointer to result fileproc
 *						pointer area, or 0 if none
 *		resultvp			Pointer to result vnode pointer
 *						area, or 0 if none
 *
 * Returns:	0				Success
 *		EBADF				Bad file descriptor
 *		ENOTSUP				fd does not refer to a vnode
 *
 * Implicit returns:
 *		*resultfp (modified)		Fileproc pointer
 *		*resultvp (modified)		vnode pointer
 *
 * Notes:	The resultfp and resultvp fields are optional, and may be
 *		independently specified as NULL to skip returning information
 *
 * Locks:	Internally takes and releases proc_fdlock
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_getfvp</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc **resultfp, <span class="enscript-type">struct</span> vnode **resultvp)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> fileproc *fp;

	proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> (fd &lt; 0 || fd &gt;= fdp-&gt;fd_nfiles ||
			(fp = fdp-&gt;fd_ofiles[fd]) == NULL ||
			(fdp-&gt;fd_ofileflags[fd] &amp; UF_RESERVED)) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (EBADF);
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(ENOTSUP);
	}
	fp-&gt;f_iocount++;

	<span class="enscript-keyword">if</span> (resultfp)
		*resultfp = fp;
	<span class="enscript-keyword">if</span> (resultvp)
		*resultvp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * fp_getfvpandvid
 *
 * Description:	Get fileproc, vnode pointer, and vid for a given fd from the
 *		per process open file table of the specified process, and if
 *		successful, increment the f_iocount
 *
 * Parameters:	p				Process in which fd lives
 *		fd				fd to get information for
 *		resultfp			Pointer to result fileproc
 *						pointer area, or 0 if none
 *		resultvp			Pointer to result vnode pointer
 *						area, or 0 if none
 *		vidp				Pointer to resuld vid area
 *
 * Returns:	0				Success
 *		EBADF				Bad file descriptor
 *		ENOTSUP				fd does not refer to a vnode
 *
 * Implicit returns:
 *		*resultfp (modified)		Fileproc pointer
 *		*resultvp (modified)		vnode pointer
 *		*vidp				vid value
 *
 * Notes:	The resultfp and resultvp fields are optional, and may be
 *		independently specified as NULL to skip returning information
 *
 * Locks:	Internally takes and releases proc_fdlock
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_getfvpandvid</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc **resultfp,
		<span class="enscript-type">struct</span> vnode **resultvp, uint32_t *vidp)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> fileproc *fp;

	proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> (fd &lt; 0 || fd &gt;= fdp-&gt;fd_nfiles ||
			(fp = fdp-&gt;fd_ofiles[fd]) == NULL ||
			(fdp-&gt;fd_ofileflags[fd] &amp; UF_RESERVED)) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (EBADF);
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(ENOTSUP);
	}
	fp-&gt;f_iocount++;

	<span class="enscript-keyword">if</span> (resultfp)
		*resultfp = fp;
	<span class="enscript-keyword">if</span> (resultvp)
		*resultvp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
	<span class="enscript-keyword">if</span> (vidp)
		*vidp = (uint32_t)vnode_vid((<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data);
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * fp_getfsock
 *
 * Description:	Get fileproc and socket pointer for a given fd from the
 *		per process open file table of the specified process, and if
 *		successful, increment the f_iocount
 *
 * Parameters:	p				Process in which fd lives
 *		fd				fd to get information for
 *		resultfp			Pointer to result fileproc
 *						pointer area, or 0 if none
 *		results				Pointer to result socket
 *						pointer area, or 0 if none
 *
 * Returns:	EBADF			The file descriptor is invalid
 *		EOPNOTSUPP		The file descriptor is not a socket
 *		0			Success
 *
 * Implicit returns:
 *		*resultfp (modified)		Fileproc pointer
 *		*results (modified)		socket pointer
 *
 * Notes:	EOPNOTSUPP should probably be ENOTSOCK; this function is only
 *		ever called from accept1().
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_getfsock</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc **resultfp,
	    <span class="enscript-type">struct</span> socket **results)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> fileproc *fp;

	proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> (fd &lt; 0 || fd &gt;= fdp-&gt;fd_nfiles ||
			(fp = fdp-&gt;fd_ofiles[fd]) == NULL ||
			(fdp-&gt;fd_ofileflags[fd] &amp; UF_RESERVED)) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (EBADF);
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_SOCKET) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(EOPNOTSUPP);
	}
	fp-&gt;f_iocount++;

	<span class="enscript-keyword">if</span> (resultfp)
		*resultfp = fp;
	<span class="enscript-keyword">if</span> (results)
		*results = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_data;
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * fp_getfkq
 *
 * Description:	Get fileproc and kqueue pointer for a given fd from the
 *		per process open file table of the specified process, and if
 *		successful, increment the f_iocount
 *
 * Parameters:	p				Process in which fd lives
 *		fd				fd to get information for
 *		resultfp			Pointer to result fileproc
 *						pointer area, or 0 if none
 *		resultkq			Pointer to result kqueue
 *						pointer area, or 0 if none
 *
 * Returns:	EBADF			The file descriptor is invalid
 *		EBADF			The file descriptor is not a socket
 *		0			Success
 *
 * Implicit returns:
 *		*resultfp (modified)		Fileproc pointer
 *		*resultkq (modified)		kqueue pointer
 *
 * Notes:	The second EBADF should probably be something else to make
 *		the error condition distinct.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_getfkq</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc **resultfp,
	  <span class="enscript-type">struct</span> kqueue **resultkq)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> fileproc *fp;

	proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> ( fd &lt; 0 || fd &gt;= fdp-&gt;fd_nfiles ||
			(fp = fdp-&gt;fd_ofiles[fd]) == NULL ||
			(fdp-&gt;fd_ofileflags[fd] &amp; UF_RESERVED)) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (EBADF);
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_KQUEUE) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(EBADF);
	}
	fp-&gt;f_iocount++;

	<span class="enscript-keyword">if</span> (resultfp)
		*resultfp = fp;
	<span class="enscript-keyword">if</span> (resultkq)
		*resultkq = (<span class="enscript-type">struct</span> kqueue *)fp-&gt;f_data;
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * fp_getfpshm
 *
 * Description:	Get fileproc and POSIX shared memory pointer for a given fd
 *		from the per process open file table of the specified process
 *		and if successful, increment the f_iocount
 *
 * Parameters:	p				Process in which fd lives
 *		fd				fd to get information for
 *		resultfp			Pointer to result fileproc
 *						pointer area, or 0 if none
 *		resultpshm			Pointer to result POSIX
 *						shared memory pointer
 *						pointer area, or 0 if none
 *
 * Returns:	EBADF			The file descriptor is invalid
 *		EBADF			The file descriptor is not a POSIX
 *					shared memory area
 *		0			Success
 *
 * Implicit returns:
 *		*resultfp (modified)		Fileproc pointer
 *		*resultpshm (modified)		POSIX shared memory pointer
 *
 * Notes:	The second EBADF should probably be something else to make
 *		the error condition distinct.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_getfpshm</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc **resultfp,
	    <span class="enscript-type">struct</span> pshmnode **resultpshm)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> fileproc *fp;

	proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> (fd &lt; 0 || fd &gt;= fdp-&gt;fd_nfiles ||
			(fp = fdp-&gt;fd_ofiles[fd]) == NULL ||
			(fdp-&gt;fd_ofileflags[fd] &amp; UF_RESERVED)) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (EBADF);
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_PSXSHM) {

		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(EBADF);
	}
	fp-&gt;f_iocount++;

	<span class="enscript-keyword">if</span> (resultfp)
		*resultfp = fp;
	<span class="enscript-keyword">if</span> (resultpshm)
		*resultpshm = (<span class="enscript-type">struct</span> pshmnode *)fp-&gt;f_data;
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * fp_getfsem
 *
 * Description:	Get fileproc and POSIX semaphore pointer for a given fd from
 *		the per process open file table of the specified process
 *		and if successful, increment the f_iocount
 *
 * Parameters:	p				Process in which fd lives
 *		fd				fd to get information for
 *		resultfp			Pointer to result fileproc
 *						pointer area, or 0 if none
 *		resultpsem			Pointer to result POSIX
 *						semaphore pointer area, or
 *						0 if none
 *
 * Returns:	EBADF			The file descriptor is invalid
 *		EBADF			The file descriptor is not a POSIX
 *					semaphore
 *		0			Success
 *
 * Implicit returns:
 *		*resultfp (modified)		Fileproc pointer
 *		*resultpsem (modified)		POSIX semaphore pointer
 *
 * Notes:	The second EBADF should probably be something else to make
 *		the error condition distinct.
 *
 *		In order to support unnamed POSIX semaphores, the named
 *		POSIX semaphores will have to move out of the per-process
 *		open filetable, and into a global table that is shared with
 *		unnamed POSIX semaphores, since unnamed POSIX semaphores
 *		are typically used by declaring instances in shared memory,
 *		and there's no other way to do this without changing the
 *		underlying type, which would introduce binary compatibility
 *		issues.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_getfpsem</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc **resultfp,
	    <span class="enscript-type">struct</span> psemnode **resultpsem)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> fileproc *fp;

	proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> (fd &lt; 0 || fd &gt;= fdp-&gt;fd_nfiles ||
			(fp = fdp-&gt;fd_ofiles[fd]) == NULL ||
			(fdp-&gt;fd_ofileflags[fd] &amp; UF_RESERVED)) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (EBADF);
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_PSXSEM) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(EBADF);
	}
	fp-&gt;f_iocount++;

	<span class="enscript-keyword">if</span> (resultfp)
		*resultfp = fp;
	<span class="enscript-keyword">if</span> (resultpsem)
		*resultpsem = (<span class="enscript-type">struct</span> psemnode *)fp-&gt;f_data;
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * fp_getfpipe
 *
 * Description:	Get fileproc and pipe pointer for a given fd from the
 *		per process open file table of the specified process
 *		and if successful, increment the f_iocount
 *
 * Parameters:	p				Process in which fd lives
 *		fd				fd to get information for
 *		resultfp			Pointer to result fileproc
 *						pointer area, or 0 if none
 *		resultpipe			Pointer to result pipe
 *						pointer area, or 0 if none
 *
 * Returns:	EBADF			The file descriptor is invalid
 *		EBADF			The file descriptor is not a socket
 *		0			Success
 *
 * Implicit returns:
 *		*resultfp (modified)		Fileproc pointer
 *		*resultpipe (modified)		pipe pointer
 *
 * Notes:	The second EBADF should probably be something else to make
 *		the error condition distinct.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_getfpipe</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc **resultfp,
	    <span class="enscript-type">struct</span> pipe **resultpipe)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> fileproc *fp;

	proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> (fd &lt; 0 || fd &gt;= fdp-&gt;fd_nfiles ||
			(fp = fdp-&gt;fd_ofiles[fd]) == NULL ||
			(fdp-&gt;fd_ofileflags[fd] &amp; UF_RESERVED)) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (EBADF);
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_PIPE) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(EBADF);
	}
	fp-&gt;f_iocount++;

	<span class="enscript-keyword">if</span> (resultfp)
		*resultfp = fp;
	<span class="enscript-keyword">if</span> (resultpipe)
		*resultpipe = (<span class="enscript-type">struct</span> pipe *)fp-&gt;f_data;
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * fp_lookup
 *
 * Description:	Get fileproc pointer for a given fd from the per process
 *		open file table of the specified process and if successful,
 *		increment the f_iocount
 *
 * Parameters:	p				Process in which fd lives
 *		fd				fd to get information for
 *		resultfp			Pointer to result fileproc
 *						pointer area, or 0 if none
 *		locked				!0 if the caller holds the
 *						proc_fdlock, 0 otherwise
 *
 * Returns:	0			Success
 *		EBADF			Bad file descriptor
 *
 * Implicit returns:
 *		*resultfp (modified)		Fileproc pointer
 *
 * Locks:	If the argument 'locked' is non-zero, then the caller is
 *		expected to have taken and held the proc_fdlock; if it is
 *		zero, than this routine internally takes and drops this lock.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_lookup</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc **resultfp, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> fileproc *fp;

	<span class="enscript-keyword">if</span> (!locked)
		proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> (fd &lt; 0 || fdp == NULL || fd &gt;= fdp-&gt;fd_nfiles ||
			(fp = fdp-&gt;fd_ofiles[fd]) == NULL ||
			(fdp-&gt;fd_ofileflags[fd] &amp; UF_RESERVED)) {
		<span class="enscript-keyword">if</span> (!locked)
			proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (EBADF);
	}
	fp-&gt;f_iocount++;

	<span class="enscript-keyword">if</span> (resultfp)
		*resultfp = fp;
	<span class="enscript-keyword">if</span> (!locked)
		proc_fdunlock(p);
		
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * fp_tryswap
 * 
 * Description: Swap the fileproc pointer for a given fd with a new
 *		fileproc pointer in the per-process open file table of
 *		the specified process.  The fdlock must be held at entry.
 *
 * Parameters:  p		Process containing the fd
 *		fd		The fd of interest
 *		nfp		Pointer to the newfp
 *
 * Returns:	0		Success
 *		EBADF		Bad file descriptor
 *		EINTR		Interrupted
 *		EKEEPLOOKING	f_iocount changed while lock was dropped.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_tryswap</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc *nfp)
{
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> error;

	proc_fdlock_assert(p, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (0 != (error = fp_lookup(p, fd, &amp;fp, 1)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-comment">/*
	 * At this point, our caller (change_guardedfd_np) has
	 * one f_iocount reference, and we just took another
	 * one to begin the replacement.
	 */</span>
	<span class="enscript-keyword">if</span> (fp-&gt;f_iocount &lt; 2) {
		panic(<span class="enscript-string">&quot;f_iocount too small %d&quot;</span>, fp-&gt;f_iocount);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (2 == fp-&gt;f_iocount) {

		<span class="enscript-comment">/* Copy the contents of *fp, preserving the &quot;type&quot; of *nfp */</span>

		nfp-&gt;f_flags = (nfp-&gt;f_flags &amp; FP_TYPEMASK) |
			(fp-&gt;f_flags &amp; ~FP_TYPEMASK);
		nfp-&gt;f_iocount = fp-&gt;f_iocount;
		nfp-&gt;f_fglob = fp-&gt;f_fglob;
		nfp-&gt;f_wset = fp-&gt;f_wset;

		p-&gt;p_fd-&gt;fd_ofiles[fd] = nfp;
		(<span class="enscript-type">void</span>) fp_drop(p, fd, nfp, 1);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Wait for all other active references to evaporate.
		 */</span>
		p-&gt;p_fpdrainwait = 1;
		error = msleep(&amp;p-&gt;p_fpdrainwait, &amp;p-&gt;p_fdmlock,
		    PRIBIO | PCATCH, <span class="enscript-string">&quot;tryswap fpdrain&quot;</span>, NULL);
		<span class="enscript-keyword">if</span> (0 == error) {
			<span class="enscript-comment">/*
			 * Return an &quot;internal&quot; errno to trigger a full
			 * reevaluation of the change-guard attempt.
			 */</span>
			error = EKEEPLOOKING;
			printf(<span class="enscript-string">&quot;%s: lookup collision fd %d\n&quot;</span>, __func__, fd);
		}
		(<span class="enscript-type">void</span>) fp_drop(p, fd, fp, 1);
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * fp_drop_written
 *
 * Description:	Set the FP_WRITTEN flag on the fileproc and drop the I/O
 *		reference previously taken by calling fp_lookup et. al.
 *
 * Parameters:	p				Process in which the fd lives
 *		fd				fd associated with the fileproc
 *		fp				fileproc on which to set the
 *						flag and drop the reference
 *
 * Returns:	0				Success
 *	fp_drop:EBADF				Bad file descriptor
 *
 * Locks:	This function internally takes and drops the proc_fdlock for
 *		the supplied process
 *
 * Notes:	The fileproc must correspond to the fd in the supplied proc
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_drop_written</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc *fp)
{
        <span class="enscript-type">int</span> error;

	proc_fdlock_spin(p);

	fp-&gt;f_flags |= FP_WRITTEN;
	
	error = fp_drop(p, fd, fp, 1);

	proc_fdunlock(p);
		
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * fp_drop_event
 *
 * Description:	Set the FP_WAITEVENT flag on the fileproc and drop the I/O
 *		reference previously taken by calling fp_lookup et. al.
 *
 * Parameters:	p				Process in which the fd lives
 *		fd				fd associated with the fileproc
 *		fp				fileproc on which to set the
 *						flag and drop the reference
 *
 * Returns:	0				Success
 *	fp_drop:EBADF				Bad file descriptor
 *
 * Locks:	This function internally takes and drops the proc_fdlock for
 *		the supplied process
 *
 * Notes:	The fileproc must correspond to the fd in the supplied proc
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_drop_event</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc *fp)
{
        <span class="enscript-type">int</span> error;

	proc_fdlock_spin(p);

	fp-&gt;f_flags |= FP_WAITEVENT;
	
	error = fp_drop(p, fd, fp, 1);

	proc_fdunlock(p);
		
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * fp_drop
 *
 * Description:	Drop the I/O reference previously taken by calling fp_lookup
 *		et. al.
 *
 * Parameters:	p				Process in which the fd lives
 *		fd				fd associated with the fileproc
 *		fp				fileproc on which to set the
 *						flag and drop the reference
 *		locked				flag to internally take and
 *						drop proc_fdlock if it is not
 *						already held by the caller
 *
 * Returns:	0				Success
 *		EBADF				Bad file descriptor
 *
 * Locks:	This function internally takes and drops the proc_fdlock for
 *		the supplied process if 'locked' is non-zero, and assumes that
 *		the caller already holds this lock if 'locked' is non-zero.
 *
 * Notes:	The fileproc must correspond to the fd in the supplied proc
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_drop</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">int</span>	needwakeup = 0;

	<span class="enscript-keyword">if</span> (!locked)
		proc_fdlock_spin(p);
	 <span class="enscript-keyword">if</span> ((fp == FILEPROC_NULL) &amp;&amp; (fd &lt; 0 || fd &gt;= fdp-&gt;fd_nfiles ||
			(fp = fdp-&gt;fd_ofiles[fd]) == NULL ||
			((fdp-&gt;fd_ofileflags[fd] &amp; UF_RESERVED) &amp;&amp;
			 !(fdp-&gt;fd_ofileflags[fd] &amp; UF_CLOSING)))) {
		<span class="enscript-keyword">if</span> (!locked)
			proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (EBADF);
	}
	fp-&gt;f_iocount--;

	<span class="enscript-keyword">if</span> (fp-&gt;f_iocount == 0) {
		<span class="enscript-keyword">if</span> (fp-&gt;f_flags &amp; FP_SELCONFLICT)
			fp-&gt;f_flags &amp;= ~FP_SELCONFLICT;

		<span class="enscript-keyword">if</span> (p-&gt;p_fpdrainwait) {
			p-&gt;p_fpdrainwait = 0;
			needwakeup = 1;
		}
	}
	<span class="enscript-keyword">if</span> (!locked)
		proc_fdunlock(p);
	<span class="enscript-keyword">if</span> (needwakeup)
	        wakeup(&amp;p-&gt;p_fpdrainwait);
		
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * file_vnode
 *
 * Description:	Given an fd, look it up in the current process's per process
 *		open file table, and return its internal vnode pointer.
 *
 * Parameters:	fd				fd to obtain vnode from
 *		vpp				pointer to vnode return area
 *
 * Returns:	0				Success
 *		EINVAL				The fd does not refer to a
 *						vnode fileproc entry
 *	fp_lookup:EBADF				Bad file descriptor
 *
 * Implicit returns:
 *		*vpp (modified)			Returned vnode pointer
 *
 * Locks:	This function internally takes and drops the proc_fdlock for
 *		the current process
 *
 * Notes:	If successful, this function increments the f_iocount on the
 *		fd's corresponding fileproc.
 *
 *		The fileproc referenced is not returned; because of this, care
 *		must be taken to not drop the last reference (e.g. by closing
 *		the file).  This is inherently unsafe, since the reference may
 *		not be recoverable from the vnode, if there is a subsequent
 *		close that destroys the associate fileproc.  The caller should
 *		therefore retain their own reference on the fileproc so that
 *		the f_iocount can be dropped subsequently.  Failure to do this
 *		can result in the returned pointer immediately becoming invalid
 *		following the call.
 *
 *		Use of this function is discouraged.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">file_vnode</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> vnode **vpp)
{
	proc_t p = current_proc();
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> error;
	
	proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> ( (error = fp_lookup(p, fd, &amp;fp, 1)) ) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(error);
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
		fp_drop(p, fd, fp,1);
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(EINVAL);
	}
	<span class="enscript-keyword">if</span> (vpp != NULL)
		*vpp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * file_vnode_withvid
 *
 * Description:	Given an fd, look it up in the current process's per process
 *		open file table, and return its internal vnode pointer.
 *
 * Parameters:	fd				fd to obtain vnode from
 *		vpp				pointer to vnode return area
 *		vidp				pointer to vid of the returned vnode
 *
 * Returns:	0				Success
 *		EINVAL				The fd does not refer to a
 *						vnode fileproc entry
 *	fp_lookup:EBADF				Bad file descriptor
 *
 * Implicit returns:
 *		*vpp (modified)			Returned vnode pointer
 *
 * Locks:	This function internally takes and drops the proc_fdlock for
 *		the current process
 *
 * Notes:	If successful, this function increments the f_iocount on the
 *		fd's corresponding fileproc.
 *
 *		The fileproc referenced is not returned; because of this, care
 *		must be taken to not drop the last reference (e.g. by closing
 *		the file).  This is inherently unsafe, since the reference may
 *		not be recoverable from the vnode, if there is a subsequent
 *		close that destroys the associate fileproc.  The caller should
 *		therefore retain their own reference on the fileproc so that
 *		the f_iocount can be dropped subsequently.  Failure to do this
 *		can result in the returned pointer immediately becoming invalid
 *		following the call.
 *
 *		Use of this function is discouraged.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">file_vnode_withvid</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> vnode **vpp, uint32_t * vidp)
{
	proc_t p = current_proc();
	<span class="enscript-type">struct</span> fileproc *fp;
	vnode_t vp;
	<span class="enscript-type">int</span> error;
	
	proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> ( (error = fp_lookup(p, fd, &amp;fp, 1)) ) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(error);
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
		fp_drop(p, fd, fp,1);
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(EINVAL);
	}
	vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_data;
	<span class="enscript-keyword">if</span> (vpp != NULL) 
		*vpp = vp;

	<span class="enscript-keyword">if</span> ((vidp != NULL) &amp;&amp; (vp != NULLVP)) 
		*vidp = (uint32_t)vp-&gt;v_id;

	proc_fdunlock(p);

	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * file_socket
 *
 * Description:	Given an fd, look it up in the current process's per process
 *		open file table, and return its internal socket pointer.
 *
 * Parameters:	fd				fd to obtain vnode from
 *		sp				pointer to socket return area
 *
 * Returns:	0				Success
 *		ENOTSOCK			Not a socket
 *		fp_lookup:EBADF			Bad file descriptor
 *
 * Implicit returns:
 *		*sp (modified)			Returned socket pointer
 *
 * Locks:	This function internally takes and drops the proc_fdlock for
 *		the current process
 *
 * Notes:	If successful, this function increments the f_iocount on the
 *		fd's corresponding fileproc.
 *
 *		The fileproc referenced is not returned; because of this, care
 *		must be taken to not drop the last reference (e.g. by closing
 *		the file).  This is inherently unsafe, since the reference may
 *		not be recoverable from the socket, if there is a subsequent
 *		close that destroys the associate fileproc.  The caller should
 *		therefore retain their own reference on the fileproc so that
 *		the f_iocount can be dropped subsequently.  Failure to do this
 *		can result in the returned pointer immediately becoming invalid
 *		following the call.
 *
 *		Use of this function is discouraged.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">file_socket</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> socket **sp)
{
	proc_t p = current_proc();
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> error;
	
	proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> ( (error = fp_lookup(p, fd, &amp;fp, 1)) ) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(error);
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_SOCKET) {
		fp_drop(p, fd, fp,1);
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(ENOTSOCK);
	}
	*sp = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_data;
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * file_flags
 *
 * Description:	Given an fd, look it up in the current process's per process
 *		open file table, and return its fileproc's flags field.
 *
 * Parameters:	fd				fd whose flags are to be
 *						retrieved
 *		flags				pointer to flags data area
 *
 * Returns:	0				Success
 *		ENOTSOCK			Not a socket
 *		fp_lookup:EBADF			Bad file descriptor
 *
 * Implicit returns:
 *		*flags (modified)		Returned flags field
 *
 * Locks:	This function internally takes and drops the proc_fdlock for
 *		the current process
 *
 * Notes:	This function will internally increment and decrement the
 *		f_iocount of the fileproc as part of its operation.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">file_flags</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">int</span> *flags)
{

	proc_t p = current_proc();
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> error;
	
	proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> ( (error = fp_lookup(p, fd, &amp;fp, 1)) ) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(error);
	}
	*flags = (<span class="enscript-type">int</span>)fp-&gt;f_flag;
	fp_drop(p, fd, fp,1);
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * file_drop
 *
 * Description:	Drop an iocount reference on an fd, and wake up any waiters
 *		for draining (i.e. blocked in fileproc_drain() called during
 *		the last attempt to close a file).
 *
 * Parameters:	fd				fd on which an ioreference is
 *						to be dropped
 *
 * Returns:	0				Success
 *		EBADF				Bad file descriptor
 *
 * Description:	Given an fd, look it up in the current process's per process
 *		open file table, and drop it's fileproc's f_iocount by one
 *
 * Notes:	This is intended as a corresponding operation to the functions
 *		file_vnode() and file_socket() operations.
 *
 *		Technically, the close reference is supposed to be protected
 *		by a fileproc_drain(), however, a drain will only block if
 *		the fd refers to a character device, and that device has had
 *		preparefileread() called on it.  If it refers to something
 *		other than a character device, then the drain will occur and
 *		block each close attempt, rather than merely the last close.
 *
 *		Since it's possible for an fd that refers to a character
 *		device to have an intermediate close followed by an open to
 *		cause a different file to correspond to that descriptor,
 *		unless there was a cautionary reference taken on the fileproc,
 *		this is an inherently unsafe function.  This happens in the
 *		case where multiple fd's in a process refer to the same
 *		character device (e.g. stdin/out/err pointing to a tty, etc.).
 *
 *		Use of this function is discouraged.
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">file_drop</span>(<span class="enscript-type">int</span> fd)
{
	<span class="enscript-type">struct</span> fileproc *fp;
	proc_t p = current_proc();
	<span class="enscript-type">int</span>	needwakeup = 0;

	proc_fdlock_spin(p);
	<span class="enscript-keyword">if</span> (fd &lt; 0 || fd &gt;= p-&gt;p_fd-&gt;fd_nfiles ||
			(fp = p-&gt;p_fd-&gt;fd_ofiles[fd]) == NULL ||
			((p-&gt;p_fd-&gt;fd_ofileflags[fd] &amp; UF_RESERVED) &amp;&amp;
			 !(p-&gt;p_fd-&gt;fd_ofileflags[fd] &amp; UF_CLOSING))) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (EBADF);
	}
	fp-&gt;f_iocount --;

	<span class="enscript-keyword">if</span> (fp-&gt;f_iocount == 0) {
		<span class="enscript-keyword">if</span> (fp-&gt;f_flags &amp; FP_SELCONFLICT)
			fp-&gt;f_flags &amp;= ~FP_SELCONFLICT;

		<span class="enscript-keyword">if</span> (p-&gt;p_fpdrainwait) {
			p-&gt;p_fpdrainwait = 0;
			needwakeup = 1;
		}
	}
	proc_fdunlock(p);

	<span class="enscript-keyword">if</span> (needwakeup)
	        wakeup(&amp;p-&gt;p_fpdrainwait);
	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">falloc_withalloc_locked</span>(proc_t, <span class="enscript-type">struct</span> fileproc **, <span class="enscript-type">int</span> *,
    vfs_context_t, <span class="enscript-type">struct</span> fileproc * (*)(<span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);

<span class="enscript-comment">/*
 * falloc
 *
 * Description:	Allocate an entry in the per process open file table and
 *		return the corresponding fileproc and fd.
 *
 * Parameters:	p				The process in whose open file
 *						table the fd is to be allocated
 *		resultfp			Pointer to fileproc pointer
 *						return area
 *		resultfd			Pointer to fd return area
 *		ctx				VFS context
 *
 * Returns:	0				Success
 *	falloc:ENFILE				Too many open files in system
 *	falloc:EMFILE				Too many open files in process
 *	falloc:ENOMEM				M_FILEPROC or M_FILEGLOB zone
 *						exhausted
 *
 * Implicit returns:
 *		*resultfd (modified)		Returned fileproc pointer
 *		*resultfd (modified)		Returned fd
 *
 * Locks:	This function takes and drops the proc_fdlock; if this lock
 *		is already held, use falloc_locked() instead.
 *
 * Notes:	This function takes separate process and context arguments
 *		solely to support kern_exec.c; otherwise, it would take
 *		neither, and expect falloc_locked() to use the
 *		vfs_context_current() routine internally.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">falloc</span>(proc_t p, <span class="enscript-type">struct</span> fileproc **resultfp, <span class="enscript-type">int</span> *resultfd, vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span> (falloc_withalloc(p, resultfp, resultfd, ctx,
	    fileproc_alloc_init, NULL));
}

<span class="enscript-comment">/*
 * Like falloc, but including the fileproc allocator and create-args
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">falloc_withalloc</span>(proc_t p, <span class="enscript-type">struct</span> fileproc **resultfp, <span class="enscript-type">int</span> *resultfd,
    vfs_context_t ctx, fp_allocfn_t fp_zalloc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">int</span> error;

	proc_fdlock(p);
	error = falloc_withalloc_locked(p,
	    resultfp, resultfd, ctx, fp_zalloc, arg, 1);
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * &quot;uninitialized&quot; ops -- ensure fg-&gt;fg_ops-&gt;fo_type always exists
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> fileops uninitops;

<span class="enscript-comment">/*
 * falloc_locked
 *
 * Create a new open file structure and allocate
 * a file descriptor for the process that refers to it.
 *
 * Returns:	0			Success
 *
 * Description:	Allocate an entry in the per process open file table and
 *		return the corresponding fileproc and fd.
 *
 * Parameters:	p				The process in whose open file
 *						table the fd is to be allocated
 *		resultfp			Pointer to fileproc pointer
 *						return area
 *		resultfd			Pointer to fd return area
 *		ctx				VFS context
 *		locked				Flag to indicate whether the
 *						caller holds proc_fdlock
 *
 * Returns:	0				Success
 *		ENFILE				Too many open files in system
 *		fdalloc:EMFILE			Too many open files in process
 *		ENOMEM				M_FILEPROC or M_FILEGLOB zone
 *						exhausted
 *	fdalloc:ENOMEM
 *
 * Implicit returns:
 *		*resultfd (modified)		Returned fileproc pointer
 *		*resultfd (modified)		Returned fd
 *
 * Locks:	If the parameter 'locked' is zero, this function takes and
 *		drops the proc_fdlock; if non-zero, the caller must hold the
 *		lock.
 *
 * Notes:	If you intend to use a non-zero 'locked' parameter, use the
 *		utility function falloc() instead.
 *
 *		This function takes separate process and context arguments
 *		solely to support kern_exec.c; otherwise, it would take
 *		neither, and use the vfs_context_current() routine internally.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">falloc_locked</span>(proc_t p, <span class="enscript-type">struct</span> fileproc **resultfp, <span class="enscript-type">int</span> *resultfd,
	      vfs_context_t ctx, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">return</span> (falloc_withalloc_locked(p, resultfp, resultfd, ctx,
	    fileproc_alloc_init, NULL, locked));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">falloc_withalloc_locked</span>(proc_t p, <span class="enscript-type">struct</span> fileproc **resultfp, <span class="enscript-type">int</span> *resultfd,
    vfs_context_t ctx, fp_allocfn_t fp_zalloc, <span class="enscript-type">void</span> *crarg,
    <span class="enscript-type">int</span> locked)
{
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> fileglob *fg;
	<span class="enscript-type">int</span> error, nfd;

	<span class="enscript-keyword">if</span> (!locked)
		proc_fdlock(p);
	<span class="enscript-keyword">if</span> ( (error = fdalloc(p, 0, &amp;nfd)) ) {
		<span class="enscript-keyword">if</span> (!locked)
			proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (nfiles &gt;= maxfiles) {
		<span class="enscript-keyword">if</span> (!locked)
			proc_fdunlock(p);
		tablefull(<span class="enscript-string">&quot;file&quot;</span>);
		<span class="enscript-keyword">return</span> (ENFILE);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_file_check_create(proc_ucred(p));
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (!locked)
			proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Allocate a new file descriptor.
	 * If the process has file descriptor zero open, add to the list
	 * of open files at that point, otherwise put it at the front of
	 * the list of open files.
	 */</span>
	proc_fdunlock(p);

	fp = (*fp_zalloc)(crarg);
	<span class="enscript-keyword">if</span> (fp == NULL) {
		<span class="enscript-keyword">if</span> (locked)
			proc_fdlock(p);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	MALLOC_ZONE(fg, <span class="enscript-type">struct</span> fileglob *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> fileglob), M_FILEGLOB, M_WAITOK);
	<span class="enscript-keyword">if</span> (fg == NULL) {
		fileproc_free(fp);
		<span class="enscript-keyword">if</span> (locked)
			proc_fdlock(p);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	bzero(fg, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> fileglob));
	lck_mtx_init(&amp;fg-&gt;fg_lock, file_lck_grp, file_lck_attr);

	fp-&gt;f_iocount = 1;
	fg-&gt;fg_count = 1;
	fg-&gt;fg_ops = &amp;uninitops;
	fp-&gt;f_fglob = fg;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_file_label_init(fg);
#<span class="enscript-reference">endif</span>

	kauth_cred_ref(ctx-&gt;vc_ucred);

	proc_fdlock(p);

	fp-&gt;f_cred = ctx-&gt;vc_ucred;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_file_label_associate(fp-&gt;f_cred, fg);
#<span class="enscript-reference">endif</span>

	OSAddAtomic(1, &amp;nfiles);

	p-&gt;p_fd-&gt;fd_ofiles[nfd] = fp;

	<span class="enscript-keyword">if</span> (!locked)
		proc_fdunlock(p);

	<span class="enscript-keyword">if</span> (resultfp)
		*resultfp = fp;
	<span class="enscript-keyword">if</span> (resultfd)
		*resultfd = nfd;

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * fg_free
 *
 * Description:	Free a file structure; drop the global open file count, and
 *		drop the credential reference, if the fileglob has one, and
 *		destroy the instance mutex before freeing
 *
 * Parameters:	fg				Pointer to fileglob to be
 *						freed
 *
 * Returns:	void
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fg_free</span>(<span class="enscript-type">struct</span> fileglob *fg)
{
	OSAddAtomic(-1, &amp;nfiles);

	<span class="enscript-keyword">if</span> (fg-&gt;fg_vn_data) {
		fg_vn_data_free(fg-&gt;fg_vn_data);
		fg-&gt;fg_vn_data = NULL;
	}

	<span class="enscript-keyword">if</span> (IS_VALID_CRED(fg-&gt;fg_cred)) {
		kauth_cred_unref(&amp;fg-&gt;fg_cred);
	}
	lck_mtx_destroy(&amp;fg-&gt;fg_lock, file_lck_grp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_file_label_destroy(fg);
#<span class="enscript-reference">endif</span>
	FREE_ZONE(fg, <span class="enscript-keyword">sizeof</span> *fg, M_FILEGLOB);
}


<span class="enscript-comment">/*
 * fdexec
 *
 * Description:	Perform close-on-exec processing for all files in a process
 *		that are either marked as close-on-exec, or which were in the
 *		process of being opened at the time of the execve
 *
 *		Also handles the case (via posix_spawn()) where -all-
 *		files except those marked with &quot;inherit&quot; as treated as
 *		close-on-exec.
 *
 * Parameters:	p				Pointer to process calling
 *						execve
 *
 * Returns:	void
 *
 * Locks:	This function internally takes and drops proc_fdlock()
 *
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fdexec</span>(proc_t p, <span class="enscript-type">short</span> flags)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">int</span> i;
	boolean_t cloexec_default = (flags &amp; POSIX_SPAWN_CLOEXEC_DEFAULT) != 0;

	proc_fdlock(p);
	<span class="enscript-keyword">for</span> (i = fdp-&gt;fd_lastfile; i &gt;= 0; i--) {

		<span class="enscript-type">struct</span> fileproc *fp = fdp-&gt;fd_ofiles[i];
		<span class="enscript-type">char</span> *flagp = &amp;fdp-&gt;fd_ofileflags[i];

		<span class="enscript-keyword">if</span> (fp &amp;&amp; cloexec_default) {
			<span class="enscript-comment">/*
			 * Reverse the usual semantics of file descriptor
			 * inheritance - all of them should be closed
			 * except files marked explicitly as &quot;inherit&quot; and
			 * not marked close-on-exec.
			 */</span>
			<span class="enscript-keyword">if</span> ((*flagp &amp; (UF_EXCLOSE|UF_INHERIT)) != UF_INHERIT)
				*flagp |= UF_EXCLOSE;
			*flagp &amp;= ~UF_INHERIT;
		}

		<span class="enscript-keyword">if</span> (
		    ((*flagp &amp; (UF_RESERVED|UF_EXCLOSE)) == UF_EXCLOSE)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		    || (fp &amp;&amp; mac_file_check_inherit(proc_ucred(p), fp-&gt;f_fglob))
#<span class="enscript-reference">endif</span>
		) {
                        <span class="enscript-keyword">if</span> (i &lt; fdp-&gt;fd_knlistsize)
                                knote_fdclose(p, i);
			procfdtbl_clearfd(p, i);
			<span class="enscript-keyword">if</span> (i == fdp-&gt;fd_lastfile &amp;&amp; i &gt; 0)
				fdp-&gt;fd_lastfile--;
			<span class="enscript-keyword">if</span> (i &lt; fdp-&gt;fd_freefile)
				fdp-&gt;fd_freefile = i;

			<span class="enscript-comment">/*
			 * Wait for any third party viewers (e.g., lsof)
			 * to release their references to this fileproc.
			 */</span>
			<span class="enscript-keyword">while</span> (fp-&gt;f_iocount &gt; 0) {
				p-&gt;p_fpdrainwait = 1;
				msleep(&amp;p-&gt;p_fpdrainwait, &amp;p-&gt;p_fdmlock, PRIBIO,
				    <span class="enscript-string">&quot;fpdrain&quot;</span>, NULL);
			}

			closef_locked(fp, fp-&gt;f_fglob, p);

			fileproc_free(fp);
		}
	}
	proc_fdunlock(p);
}


<span class="enscript-comment">/*
 * fdcopy
 *
 * Description:	Copy a filedesc structure.  This is normally used as part of
 *		forkproc() when forking a new process, to copy the per process
 *		open file table over to the new process.
 *
 * Parameters:	p				Process whose open file table
 *						is to be copied (parent)
 *		uth_cdir			Per thread current working
 *						cirectory, or NULL
 *
 * Returns:	NULL				Copy failed
 *		!NULL				Pointer to new struct filedesc
 *
 * Locks:	This function internally takes and drops proc_fdlock()
 *
 * Notes:	Files are copied directly, ignoring the new resource limits
 *		for the process that's being copied into.  Since the descriptor
 *		references are just additional references, this does not count
 *		against the number of open files on the system.
 *
 *		The struct filedesc includes the current working directory,
 *		and the current root directory, if the process is chroot'ed.
 *
 *		If the exec was called by a thread using a per thread current
 *		working directory, we inherit the working directory from the
 *		thread making the call, rather than from the process.
 *
 *		In the case of a failure to obtain a reference, for most cases,
 *		the file entry will be silently dropped.  There's an exception
 *		for the case of a chroot dir, since a failure to to obtain a
 *		reference there would constitute an &quot;escape&quot; from the chroot
 *		environment, which must not be allowed.  In that case, we will
 *		deny the execve() operation, rather than allowing the escape.
 */</span>
<span class="enscript-type">struct</span> filedesc *
<span class="enscript-function-name">fdcopy</span>(proc_t p, vnode_t uth_cdir)
{
	<span class="enscript-type">struct</span> filedesc *newfdp, *fdp = p-&gt;p_fd;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> fileproc *ofp, *fp;
	vnode_t	v_dir;

	MALLOC_ZONE(newfdp, <span class="enscript-type">struct</span> filedesc *,
			<span class="enscript-keyword">sizeof</span>(*newfdp), M_FILEDESC, M_WAITOK);
	<span class="enscript-keyword">if</span> (newfdp == NULL)
		<span class="enscript-keyword">return</span>(NULL);

	proc_fdlock(p);

	<span class="enscript-comment">/*
	 * the FD_CHROOT flag will be inherited via this copy
	 */</span>
	(<span class="enscript-type">void</span>) memcpy(newfdp, fdp, <span class="enscript-keyword">sizeof</span>(*newfdp));

	<span class="enscript-comment">/*
	 * If we are running with per-thread current working directories,
	 * inherit the new current working directory from the current thread
	 * instead, before we take our references.
	 */</span>
	<span class="enscript-keyword">if</span> (uth_cdir != NULLVP)
		newfdp-&gt;fd_cdir = uth_cdir;

	<span class="enscript-comment">/*
	 * For both fd_cdir and fd_rdir make sure we get
	 * a valid reference... if we can't, than set
	 * set the pointer(s) to NULL in the child... this
	 * will keep us from using a non-referenced vp
	 * and allows us to do the vnode_rele only on
	 * a properly referenced vp
	 */</span>
	<span class="enscript-keyword">if</span> ( (v_dir = newfdp-&gt;fd_cdir) ) {
	        <span class="enscript-keyword">if</span> (vnode_getwithref(v_dir) == 0) {
		        <span class="enscript-keyword">if</span> ( (vnode_ref(v_dir)) )
			        newfdp-&gt;fd_cdir = NULL;
			vnode_put(v_dir);
		} <span class="enscript-keyword">else</span>
		        newfdp-&gt;fd_cdir = NULL;
	}
	<span class="enscript-keyword">if</span> (newfdp-&gt;fd_cdir == NULL &amp;&amp; fdp-&gt;fd_cdir) {
	        <span class="enscript-comment">/*
		 * we couldn't get a new reference on
		 * the current working directory being
		 * inherited... we might as well drop
		 * our reference from the parent also
		 * since the vnode has gone DEAD making
		 * it useless... by dropping it we'll
		 * be that much closer to recycling it
		 */</span>
	        vnode_rele(fdp-&gt;fd_cdir);
		fdp-&gt;fd_cdir = NULL;
	}

	<span class="enscript-keyword">if</span> ( (v_dir = newfdp-&gt;fd_rdir) ) {
		<span class="enscript-keyword">if</span> (vnode_getwithref(v_dir) == 0) {
			<span class="enscript-keyword">if</span> ( (vnode_ref(v_dir)) )
			        newfdp-&gt;fd_rdir = NULL;
			vnode_put(v_dir);
		} <span class="enscript-keyword">else</span> {
		        newfdp-&gt;fd_rdir = NULL;
		}
	}
	<span class="enscript-comment">/* Coming from a chroot environment and unable to get a reference... */</span>
	<span class="enscript-keyword">if</span> (newfdp-&gt;fd_rdir == NULL &amp;&amp; fdp-&gt;fd_rdir) {
	        <span class="enscript-comment">/*
		 * We couldn't get a new reference on
		 * the chroot directory being
		 * inherited... this is fatal, since
		 * otherwise it would constitute an
		 * escape from a chroot environment by
		 * the new process.
		 */</span>
		<span class="enscript-keyword">if</span> (newfdp-&gt;fd_cdir)
		        vnode_rele(newfdp-&gt;fd_cdir);
		FREE_ZONE(newfdp, <span class="enscript-keyword">sizeof</span> *newfdp, M_FILEDESC);
		<span class="enscript-keyword">return</span>(NULL);
	}

	<span class="enscript-comment">/*
	 * If the number of open files fits in the internal arrays
	 * of the open file structure, use them, otherwise allocate
	 * additional memory for the number of descriptors currently
	 * in use.
	 */</span>
	<span class="enscript-keyword">if</span> (newfdp-&gt;fd_lastfile &lt; NDFILE)
		i = NDFILE;
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Compute the smallest multiple of NDEXTENT needed
		 * for the file descriptors currently in use,
		 * allowing the table to shrink.
		 */</span>
		i = newfdp-&gt;fd_nfiles;
		<span class="enscript-keyword">while</span> (i &gt; 1 + 2 * NDEXTENT &amp;&amp; i &gt; 1 + newfdp-&gt;fd_lastfile * 2)
			i /= 2;
	}
	proc_fdunlock(p);

	MALLOC_ZONE(newfdp-&gt;fd_ofiles, <span class="enscript-type">struct</span> fileproc **,
				i * OFILESIZE, M_OFILETABL, M_WAITOK);
	<span class="enscript-keyword">if</span> (newfdp-&gt;fd_ofiles == NULL) {
		<span class="enscript-keyword">if</span> (newfdp-&gt;fd_cdir)
		        vnode_rele(newfdp-&gt;fd_cdir);
		<span class="enscript-keyword">if</span> (newfdp-&gt;fd_rdir)
			vnode_rele(newfdp-&gt;fd_rdir);

		FREE_ZONE(newfdp, <span class="enscript-keyword">sizeof</span>(*newfdp), M_FILEDESC);
		<span class="enscript-keyword">return</span>(NULL);
	}
	(<span class="enscript-type">void</span>) memset(newfdp-&gt;fd_ofiles, 0, i * OFILESIZE);
	proc_fdlock(p);

	newfdp-&gt;fd_ofileflags = (<span class="enscript-type">char</span> *) &amp;newfdp-&gt;fd_ofiles[i];
	newfdp-&gt;fd_nfiles = i;

	<span class="enscript-keyword">if</span> (fdp-&gt;fd_nfiles &gt; 0) {
		<span class="enscript-type">struct</span> fileproc **fpp;
		<span class="enscript-type">char</span> *flags;

		(<span class="enscript-type">void</span>) memcpy(newfdp-&gt;fd_ofiles, fdp-&gt;fd_ofiles,
					(newfdp-&gt;fd_lastfile + 1) * <span class="enscript-keyword">sizeof</span>(*fdp-&gt;fd_ofiles));
		(<span class="enscript-type">void</span>) memcpy(newfdp-&gt;fd_ofileflags, fdp-&gt;fd_ofileflags,
					(newfdp-&gt;fd_lastfile + 1) * <span class="enscript-keyword">sizeof</span>(*fdp-&gt;fd_ofileflags));

		<span class="enscript-comment">/*
		 * kq descriptors cannot be copied.
		 */</span>
		<span class="enscript-keyword">if</span> (newfdp-&gt;fd_knlistsize != -1) {
			fpp = &amp;newfdp-&gt;fd_ofiles[newfdp-&gt;fd_lastfile];
			flags = &amp;newfdp-&gt;fd_ofileflags[newfdp-&gt;fd_lastfile];
			<span class="enscript-keyword">for</span> (i = newfdp-&gt;fd_lastfile;
			    i &gt;= 0; i--, fpp--, flags--) {
				<span class="enscript-keyword">if</span> (*flags &amp; UF_RESERVED)
					<span class="enscript-keyword">continue</span>;	<span class="enscript-comment">/* (removed below) */</span>
				<span class="enscript-keyword">if</span> (*fpp != NULL &amp;&amp; (*fpp)-&gt;f_type == DTYPE_KQUEUE) {
					*fpp = NULL;
					*flags = 0;
					<span class="enscript-keyword">if</span> (i &lt; newfdp-&gt;fd_freefile)
						newfdp-&gt;fd_freefile = i;
				}
				<span class="enscript-keyword">if</span> (*fpp == NULL &amp;&amp; i == newfdp-&gt;fd_lastfile &amp;&amp; i &gt; 0)
					newfdp-&gt;fd_lastfile--;
			}
			newfdp-&gt;fd_knlist = NULL;
			newfdp-&gt;fd_knlistsize = -1;
			newfdp-&gt;fd_knhash = NULL;
			newfdp-&gt;fd_knhashmask = 0;
		}
		fpp = newfdp-&gt;fd_ofiles;
		flags = newfdp-&gt;fd_ofileflags;

		<span class="enscript-keyword">for</span> (i = newfdp-&gt;fd_lastfile + 1; --i &gt;= 0; fpp++, flags++)
			<span class="enscript-keyword">if</span> ((ofp = *fpp) != NULL &amp;&amp;
			    0 == (ofp-&gt;f_fglob-&gt;fg_lflags &amp; FG_CONFINED) &amp;&amp;
			    0 == (*flags &amp; (UF_FORKCLOSE|UF_RESERVED))) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
				<span class="enscript-keyword">if</span> (FILEPROC_TYPE(ofp) != FTYPE_SIMPLE)
					panic(<span class="enscript-string">&quot;complex fileproc&quot;</span>);
#<span class="enscript-reference">endif</span>
				fp = fileproc_alloc_init(NULL);
				<span class="enscript-keyword">if</span> (fp == NULL) {
					<span class="enscript-comment">/*
					 * XXX no room to copy, unable to
					 * XXX safely unwind state at present
					 */</span>
					*fpp = NULL;
				} <span class="enscript-keyword">else</span> {
					fp-&gt;f_flags |=
					    (ofp-&gt;f_flags &amp; ~FP_TYPEMASK);
					fp-&gt;f_fglob = ofp-&gt;f_fglob;
					(<span class="enscript-type">void</span>)fg_ref(fp);
					*fpp = fp;
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (i &lt; newfdp-&gt;fd_freefile)
					newfdp-&gt;fd_freefile = i;
				*fpp = NULL;
				*flags = 0;
			}
	}

	proc_fdunlock(p);
	<span class="enscript-keyword">return</span> (newfdp);
}


<span class="enscript-comment">/*
 * fdfree
 *
 * Description:	Release a filedesc (per process open file table) structure;
 *		this is done on process exit(), or from forkproc_free() if
 *		the fork fails for some reason subsequent to a successful
 *		call to fdcopy()
 *
 * Parameters:	p				Pointer to process going away
 *
 * Returns:	void
 *
 * Locks:	This function internally takes and drops proc_fdlock()
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fdfree</span>(proc_t p)
{
	<span class="enscript-type">struct</span> filedesc *fdp;
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> i;

	proc_fdlock(p);

	<span class="enscript-keyword">if</span> (p == kernproc || NULL == (fdp = p-&gt;p_fd)) {
	        proc_fdunlock(p);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> filedesc filedesc0;

	<span class="enscript-keyword">if</span> (&amp;filedesc0 == fdp)
		panic(<span class="enscript-string">&quot;filedesc0&quot;</span>);

	<span class="enscript-keyword">if</span> (fdp-&gt;fd_nfiles &gt; 0 &amp;&amp; fdp-&gt;fd_ofiles) {
	        <span class="enscript-keyword">for</span> (i = fdp-&gt;fd_lastfile; i &gt;= 0; i--) {
			<span class="enscript-keyword">if</span> ((fp = fdp-&gt;fd_ofiles[i]) != NULL) {
			  
			  <span class="enscript-keyword">if</span> (fdp-&gt;fd_ofileflags[i] &amp; UF_RESERVED)
			    	panic(<span class="enscript-string">&quot;fdfree: found fp with UF_RESERVED&quot;</span>);

				procfdtbl_reservefd(p, i);

				<span class="enscript-keyword">if</span> (i &lt; fdp-&gt;fd_knlistsize)
					knote_fdclose(p, i);
				<span class="enscript-keyword">if</span> (fp-&gt;f_flags &amp; FP_WAITEVENT) 
					(<span class="enscript-type">void</span>)waitevent_close(p, fp);
				(<span class="enscript-type">void</span>) closef_locked(fp, fp-&gt;f_fglob, p);
				fileproc_free(fp);
			}
		}
		FREE_ZONE(fdp-&gt;fd_ofiles, fdp-&gt;fd_nfiles * OFILESIZE, M_OFILETABL);
		fdp-&gt;fd_ofiles = NULL;
		fdp-&gt;fd_nfiles = 0;
	}        

	proc_fdunlock(p);
	
	<span class="enscript-keyword">if</span> (fdp-&gt;fd_cdir)
	        vnode_rele(fdp-&gt;fd_cdir);
	<span class="enscript-keyword">if</span> (fdp-&gt;fd_rdir)
		vnode_rele(fdp-&gt;fd_rdir);

	proc_fdlock_spin(p);
	p-&gt;p_fd = NULL;
	proc_fdunlock(p);

	<span class="enscript-keyword">if</span> (fdp-&gt;fd_knlist)
		FREE(fdp-&gt;fd_knlist, M_KQUEUE);
	<span class="enscript-keyword">if</span> (fdp-&gt;fd_knhash)
		FREE(fdp-&gt;fd_knhash, M_KQUEUE);

	FREE_ZONE(fdp, <span class="enscript-keyword">sizeof</span>(*fdp), M_FILEDESC);
}

<span class="enscript-comment">/*
 * closef_locked
 *
 * Description:	Internal form of closef; called with proc_fdlock held
 *
 * Parameters:	fp			Pointer to fileproc for fd
 *		fg			Pointer to fileglob for fd
 *		p			Pointer to proc structure
 *
 * Returns:	0			Success
 *	closef_finish:??? 		Anything returnable by a per-fileops
 *					close function
 *
 * Note:	Decrements reference count on file structure; if this was the
 *		last reference, then closef_finish() is called
 *
 *		p and fp are allowed to  be NULL when closing a file that was
 *		being passed in a message (but only if we are called when this
 *		is NOT the last reference).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">closef_locked</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> fileglob *fg, proc_t p)
{
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">struct</span> flock lf;
	<span class="enscript-type">struct</span> vfs_context context;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (fg == NULL) {
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* Set up context with cred stashed in fg */</span>
	<span class="enscript-keyword">if</span> (p == current_proc())
		context.vc_thread = current_thread();
	<span class="enscript-keyword">else</span>
		context.vc_thread = NULL;
	context.vc_ucred = fg-&gt;fg_cred;

	<span class="enscript-comment">/*
	 * POSIX record locking dictates that any close releases ALL
	 * locks owned by this process.  This is handled by setting
	 * a flag in the unlock to free ONLY locks obeying POSIX
	 * semantics, and not to free BSD-style file locks.
	 * If the descriptor was in a message, POSIX-style locks
	 * aren't passed with the descriptor.
	 */</span>
	<span class="enscript-keyword">if</span> (p &amp;&amp; (p-&gt;p_ladvflag &amp; P_LADVLOCK) &amp;&amp;
	    DTYPE_VNODE == FILEGLOB_DTYPE(fg)) {
		proc_fdunlock(p);

		lf.l_whence = SEEK_SET;
		lf.l_start = 0;
		lf.l_len = 0;
		lf.l_type = F_UNLCK;
		vp = (<span class="enscript-type">struct</span> vnode *)fg-&gt;fg_data;

		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {
			(<span class="enscript-type">void</span>) VNOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &amp;lf, F_POSIX, &amp;context, NULL);
			(<span class="enscript-type">void</span>)vnode_put(vp);
		}
		proc_fdlock(p);
	}
	lck_mtx_lock_spin(&amp;fg-&gt;fg_lock);
	fg-&gt;fg_count--;

	<span class="enscript-keyword">if</span> (fg-&gt;fg_count &gt; 0) {
		lck_mtx_unlock(&amp;fg-&gt;fg_lock);
		<span class="enscript-keyword">return</span> (0);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (fg-&gt;fg_count != 0)
		panic(<span class="enscript-string">&quot;fg %p: being freed with bad fg_count (%d)&quot;</span>, fg, fg-&gt;fg_count);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (fp &amp;&amp; (fp-&gt;f_flags &amp; FP_WRITTEN))
	        fg-&gt;fg_flag |= FWASWRITTEN;

	fg-&gt;fg_lflags |= FG_TERM;
	lck_mtx_unlock(&amp;fg-&gt;fg_lock);

	<span class="enscript-keyword">if</span> (p)
		proc_fdunlock(p);

	<span class="enscript-comment">/* Since we ensure that fg-&gt;fg_ops is always initialized, 
	 * it is safe to invoke fo_close on the fg */</span>
	error = fo_close(fg, &amp;context);

	fg_free(fg);
	
	<span class="enscript-keyword">if</span> (p)
		proc_fdlock(p);

	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * fileproc_drain
 *
 * Description:	Drain out pending I/O operations
 *
 * Parameters:	p				Process closing this file
 *		fp				fileproc struct for the open
 *						instance on the file
 *
 * Returns:	void
 *
 * Locks:	Assumes the caller holds the proc_fdlock
 *
 * Notes:	For character devices, this occurs on the last close of the
 *		device; for all other file descriptors, this occurs on each
 *		close to prevent fd's from being closed out from under
 *		operations currently in progress and blocked
 *
 * See Also: 	file_vnode(), file_socket(), file_drop(), and the cautions
 *		regarding their use and interaction with this function.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fileproc_drain</span>(proc_t p, <span class="enscript-type">struct</span> fileproc * fp)
{
	<span class="enscript-type">struct</span> vfs_context context;

	context.vc_thread = proc_thread(p);	<span class="enscript-comment">/* XXX */</span>
	context.vc_ucred = fp-&gt;f_fglob-&gt;fg_cred;

	fp-&gt;f_iocount-- ; <span class="enscript-comment">/* (the one the close holds) */</span>

	<span class="enscript-keyword">while</span> (fp-&gt;f_iocount) {

	        lck_mtx_convert_spin(&amp;p-&gt;p_fdmlock);

		<span class="enscript-keyword">if</span> (fp-&gt;f_fglob-&gt;fg_ops-&gt;fo_drain) {
			(*fp-&gt;f_fglob-&gt;fg_ops-&gt;fo_drain)(fp, &amp;context);
		}
		<span class="enscript-keyword">if</span> ((fp-&gt;f_flags &amp; FP_INSELECT) == FP_INSELECT) {
			<span class="enscript-keyword">if</span> (waitq_wakeup64_all((<span class="enscript-type">struct</span> waitq *)fp-&gt;f_wset, NO_EVENT64,
					       THREAD_INTERRUPTED, WAITQ_ALL_PRIORITIES) == KERN_INVALID_ARGUMENT)
				panic(<span class="enscript-string">&quot;bad wait queue for waitq_wakeup64_all %p (fp:%p)&quot;</span>, fp-&gt;f_wset, fp);
		}
		<span class="enscript-keyword">if</span> ((fp-&gt;f_flags &amp; FP_SELCONFLICT) == FP_SELCONFLICT) {
			<span class="enscript-keyword">if</span> (waitq_wakeup64_all(&amp;select_conflict_queue, NO_EVENT64,
					       THREAD_INTERRUPTED, WAITQ_ALL_PRIORITIES) == KERN_INVALID_ARGUMENT)
				panic(<span class="enscript-string">&quot;bad select_conflict_queue&quot;</span>);
		}
		p-&gt;p_fpdrainwait = 1;

		msleep(&amp;p-&gt;p_fpdrainwait, &amp;p-&gt;p_fdmlock, PRIBIO, <span class="enscript-string">&quot;fpdrain&quot;</span>, NULL);

	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> ((fp-&gt;f_flags &amp; FP_INSELECT) != 0)
		panic(<span class="enscript-string">&quot;FP_INSELECT set on drained fp&quot;</span>);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((fp-&gt;f_flags &amp; FP_SELCONFLICT) == FP_SELCONFLICT)
		fp-&gt;f_flags &amp;= ~FP_SELCONFLICT;
}


<span class="enscript-comment">/*
 * fp_free
 *
 * Description:	Release the fd and free the fileproc associated with the fd
 *		in the per process open file table of the specified process;
 *		these values must correspond.
 *
 * Parameters:	p				Process containing fd
 *		fd				fd to be released
 *		fp				fileproc to be freed
 *
 * Returns:	0				Success
 *
 * Notes:	XXX function should be void - no one interprets the returns
 *		XXX code
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_free</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc * fp)
{
        proc_fdlock_spin(p);
	fdrelse(p, fd);
        proc_fdunlock(p);

	fg_free(fp-&gt;f_fglob);
	fileproc_free(fp);
	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * flock
 *
 * Description:	Apply an advisory lock on a file descriptor.
 *
 * Parameters:	p				Process making request
 *		uap-&gt;fd				fd on which the lock is to be
 *						attempted
 *		uap-&gt;how			(Un)Lock bits, including type
 *		retval				Pointer to the call return area
 *		
 * Returns:	0				Success
 *	fp_getfvp:EBADF				Bad file descriptor
 *	fp_getfvp:ENOTSUP			fd does not refer to a vnode
 *	vnode_getwithref:???
 *	VNOP_ADVLOCK:???
 *
 * Implicit returns:
 *		*retval (modified)		Size of dtable
 *
 * Notes:	Just attempt to get a record lock of the requested type on
 *		the entire file (l_whence = SEEK_SET, l_start = 0, l_len = 0).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">flock</span>(proc_t p, <span class="enscript-type">struct</span> flock_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> fd = uap-&gt;fd;
	<span class="enscript-type">int</span> how = uap-&gt;how;
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">struct</span> flock lf;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">int</span> error=0;

	AUDIT_ARG(fd, uap-&gt;fd);
	<span class="enscript-keyword">if</span> ( (error = fp_getfvp(p, fd, &amp;fp, &amp;vp)) ) {
		<span class="enscript-keyword">return</span>(error);
	}
	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}
	AUDIT_ARG(vnpath, vp, ARG_VNODE1);

	lf.l_whence = SEEK_SET;
	lf.l_start = 0;
	lf.l_len = 0;
	<span class="enscript-keyword">if</span> (how &amp; LOCK_UN) {
		lf.l_type = F_UNLCK;
		fp-&gt;f_flag &amp;= ~FHASLOCK;
		error = VNOP_ADVLOCK(vp, (caddr_t)fp-&gt;f_fglob, F_UNLCK, &amp;lf, F_FLOCK, ctx, NULL);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (how &amp; LOCK_EX)
		lf.l_type = F_WRLCK;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (how &amp; LOCK_SH)
		lf.l_type = F_RDLCK;
	<span class="enscript-keyword">else</span> {
	        error = EBADF;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_file_check_lock(proc_ucred(p), fp-&gt;f_fglob, F_SETLK, &amp;lf);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	fp-&gt;f_flag |= FHASLOCK;
	<span class="enscript-keyword">if</span> (how &amp; LOCK_NB) {
		error = VNOP_ADVLOCK(vp, (caddr_t)fp-&gt;f_fglob, F_SETLK, &amp;lf, F_FLOCK, ctx, NULL);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;	
	}
	error = VNOP_ADVLOCK(vp, (caddr_t)fp-&gt;f_fglob, F_SETLK, &amp;lf, F_FLOCK|F_WAIT, ctx, NULL);
<span class="enscript-reference">out</span>:
	(<span class="enscript-type">void</span>)vnode_put(vp);
<span class="enscript-reference">out1</span>:
	fp_drop(p, fd, fp, 0);
	<span class="enscript-keyword">return</span>(error);

}

<span class="enscript-comment">/*
 * fileport_makeport
 *
 * Description: Obtain a Mach send right for a given file descriptor.
 *
 * Parameters:	p		Process calling fileport
 * 		uap-&gt;fd		The fd to reference
 * 		uap-&gt;portnamep  User address at which to place port name.
 *
 * Returns:	0		Success.
 *     		EBADF		Bad file descriptor.
 *     		EINVAL		File descriptor had type that cannot be sent, misc. other errors.
 *     		EFAULT		Address at which to store port name is not valid.
 *     		EAGAIN		Resource shortage.
 *
 * Implicit returns:
 *		On success, name of send right is stored at user-specified address.		
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fileport_makeport</span>(proc_t p, <span class="enscript-type">struct</span> fileport_makeport_args *uap,
    __unused <span class="enscript-type">int</span> *retval)
{
	<span class="enscript-type">int</span> err;
	<span class="enscript-type">int</span> fd = uap-&gt;fd;
	user_addr_t user_portaddr = uap-&gt;portnamep;
	<span class="enscript-type">struct</span> fileproc *fp = FILEPROC_NULL;
	<span class="enscript-type">struct</span> fileglob *fg = NULL;
	ipc_port_t fileport;
	mach_port_name_t name = MACH_PORT_NULL;

	proc_fdlock(p);
	err = fp_lookup(p, fd, &amp;fp, 1);
	<span class="enscript-keyword">if</span> (err != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
	}

	<span class="enscript-keyword">if</span> (!file_issendable(p, fp)) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
	}

	<span class="enscript-keyword">if</span> (FP_ISGUARDED(fp, GUARD_FILEPORT)) {
		err = fp_guard_exception(p, fd, fp, kGUARD_EXC_FILEPORT);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
	}

	<span class="enscript-comment">/* Dropped when port is deallocated */</span>
	fg = fp-&gt;f_fglob;
	fg_ref(fp);

	proc_fdunlock(p);

	<span class="enscript-comment">/* Allocate and initialize a port */</span>
	fileport = fileport_alloc(fg);
	<span class="enscript-keyword">if</span> (fileport == IPC_PORT_NULL) {
		err = EAGAIN;
		fg_drop(fp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	<span class="enscript-comment">/* Add an entry.  Deallocates port on failure. */</span>
	name = ipc_port_copyout_send(fileport, get_task_ipcspace(p-&gt;task));
	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(name)) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	} 
	
	err = copyout(&amp;name, user_portaddr, <span class="enscript-keyword">sizeof</span>(mach_port_name_t));
	<span class="enscript-keyword">if</span> (err != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Tag the fileglob for debugging purposes */</span>
	lck_mtx_lock_spin(&amp;fg-&gt;fg_lock);
	fg-&gt;fg_lflags |= FG_PORTMADE;
	lck_mtx_unlock(&amp;fg-&gt;fg_lock);

	fp_drop(p, fd, fp, 0);

	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">out_unlock</span>:
	proc_fdunlock(p);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (MACH_PORT_VALID(name)) {
		<span class="enscript-comment">/* Don't care if another thread races us to deallocate the entry */</span>
		(<span class="enscript-type">void</span>) mach_port_deallocate(get_task_ipcspace(p-&gt;task), name);
	}

	<span class="enscript-keyword">if</span> (fp != FILEPROC_NULL) {
		fp_drop(p, fd, fp, 0);
	}

	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">fileport_releasefg</span>(<span class="enscript-type">struct</span> fileglob *fg)
{
	(<span class="enscript-type">void</span>)closef_locked(NULL, fg, PROC_NULL);

	<span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/*
 * fileport_makefd
 *
 * Description: Obtain the file descriptor for a given Mach send right.
 *
 * Parameters:	p		Process calling fileport
 * 		uap-&gt;port	Name of send right to file port.
 *
 * Returns:	0		Success
 *		EINVAL		Invalid Mach port name, or port is not for a file.
 *	fdalloc:EMFILE
 *	fdalloc:ENOMEM		Unable to allocate fileproc or extend file table.
 *
 * Implicit returns:
 *		*retval (modified)		The new descriptor
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fileport_makefd</span>(proc_t p, <span class="enscript-type">struct</span> fileport_makefd_args *uap, int32_t *retval)
{
	<span class="enscript-type">struct</span> fileglob *fg;
 	<span class="enscript-type">struct</span> fileproc *fp = FILEPROC_NULL;
	ipc_port_t port = IPC_PORT_NULL;
	mach_port_name_t send = uap-&gt;port;
	kern_return_t res;
	<span class="enscript-type">int</span> fd;
	<span class="enscript-type">int</span> err;

	res = ipc_object_copyin(get_task_ipcspace(p-&gt;task),
			send, MACH_MSG_TYPE_COPY_SEND, &amp;port);

	<span class="enscript-keyword">if</span> (res != KERN_SUCCESS) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	fg = fileport_port_to_fileglob(port);
	<span class="enscript-keyword">if</span> (fg == NULL) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	fp = fileproc_alloc_init(NULL);
	<span class="enscript-keyword">if</span> (fp == FILEPROC_NULL) {
		err = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	fp-&gt;f_fglob = fg;
	fg_ref(fp);

 	proc_fdlock(p);
	err = fdalloc(p, 0, &amp;fd);
	<span class="enscript-keyword">if</span> (err != 0) {
		proc_fdunlock(p);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	*fdflags(p, fd) |= UF_EXCLOSE;

	procfdtbl_releasefd(p, fd, fp);
	proc_fdunlock(p);

	*retval = fd;
	err = 0;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> ((fp != NULL) &amp;&amp; (0 != err)) {
		fileproc_free(fp);
	} 

	<span class="enscript-keyword">if</span> (IPC_PORT_NULL != port) {
		ipc_port_release_send(port);
	}

	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/*
 * dupfdopen
 *
 * Description:	Duplicate the specified descriptor to a free descriptor;
 *		this is the second half of fdopen(), above.
 *
 * Parameters:	fdp				filedesc pointer to fill in
 *		indx				fd to dup to
 *		dfd				fd to dup from
 *		mode				mode to set on new fd
 *		error				command code
 *
 * Returns:	0				Success
 *		EBADF				Source fd is bad
 *		EACCES				Requested mode not allowed
 *		!0				'error', if not ENODEV or
 *						ENXIO
 *
 * Notes:	XXX This is not thread safe; see fdopen() above
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dupfdopen</span>(<span class="enscript-type">struct</span> filedesc *fdp, <span class="enscript-type">int</span> indx, <span class="enscript-type">int</span> dfd, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> error)
{
	<span class="enscript-type">struct</span> fileproc *wfp;
	<span class="enscript-type">struct</span> fileproc *fp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">int</span> myerror;
#<span class="enscript-reference">endif</span>
	proc_t p = current_proc();

	<span class="enscript-comment">/*
	 * If the to-be-dup'd fd number is greater than the allowed number
	 * of file descriptors, or the fd to be dup'd has already been
	 * closed, reject.  Note, check for new == old is necessary as
	 * falloc could allocate an already closed to-be-dup'd descriptor
	 * as the new descriptor.
	 */</span>
	proc_fdlock(p);

	fp = fdp-&gt;fd_ofiles[indx];
	<span class="enscript-keyword">if</span> (dfd &lt; 0 || dfd &gt;= fdp-&gt;fd_nfiles ||
			(wfp = fdp-&gt;fd_ofiles[dfd]) == NULL || wfp == fp ||
	                (fdp-&gt;fd_ofileflags[dfd] &amp; UF_RESERVED)) {

	        proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (EBADF);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	myerror = mac_file_check_dup(proc_ucred(p), wfp-&gt;f_fglob, dfd);
	<span class="enscript-keyword">if</span> (myerror) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (myerror);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * There are two cases of interest here.
	 *
	 * For ENODEV simply dup (dfd) to file descriptor
	 * (indx) and return.
	 *
	 * For ENXIO steal away the file structure from (dfd) and
	 * store it in (indx).  (dfd) is effectively closed by
	 * this operation.
	 *
	 * Any other error code is just returned.
	 */</span>
	<span class="enscript-keyword">switch</span> (error) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENODEV</span>:
		<span class="enscript-keyword">if</span> (FP_ISGUARDED(wfp, GUARD_DUP)) {
			proc_fdunlock(p);
			<span class="enscript-keyword">return</span> (EPERM);
		}

		<span class="enscript-comment">/*
		 * Check that the mode the file is being opened for is a
		 * subset of the mode of the existing descriptor.
		 */</span>
	        <span class="enscript-keyword">if</span> (((flags &amp; (FREAD|FWRITE)) | wfp-&gt;f_flag) != wfp-&gt;f_flag) {
		        proc_fdunlock(p);
			<span class="enscript-keyword">return</span> (EACCES);
		}
		<span class="enscript-keyword">if</span> (indx &gt; fdp-&gt;fd_lastfile)
			fdp-&gt;fd_lastfile = indx;
		(<span class="enscript-type">void</span>)fg_ref(wfp);

		<span class="enscript-keyword">if</span> (fp-&gt;f_fglob)
		        fg_free(fp-&gt;f_fglob);
		fp-&gt;f_fglob = wfp-&gt;f_fglob;

		fdp-&gt;fd_ofileflags[indx] = fdp-&gt;fd_ofileflags[dfd] |
			(flags &amp; O_CLOEXEC) ? UF_EXCLOSE : 0;

	        proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-reference">default</span>:
	        proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-comment">/* NOTREACHED */</span>
}


<span class="enscript-comment">/*
 * fg_ref
 *
 * Description:	Add a reference to a fileglob by fileproc
 *
 * Parameters:	fp				fileproc containing fileglob
 *						pointer
 *
 * Returns:	void
 *
 * Notes:	XXX Should use OSAddAtomic?
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fg_ref</span>(<span class="enscript-type">struct</span> fileproc * fp)
{
	<span class="enscript-type">struct</span> fileglob *fg;

	fg = fp-&gt;f_fglob;

	lck_mtx_lock_spin(&amp;fg-&gt;fg_lock);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> ((fp-&gt;f_flags &amp; ~((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)FP_VALID_FLAGS)) != 0)
		panic(<span class="enscript-string">&quot;fg_ref: invalid bits on fp %p&quot;</span>, fp);

	<span class="enscript-keyword">if</span> (fg-&gt;fg_count == 0)
		panic(<span class="enscript-string">&quot;fg_ref: adding fgcount to zeroed fg: fp %p fg %p&quot;</span>,
		    fp, fg);
#<span class="enscript-reference">endif</span>
	fg-&gt;fg_count++;
	lck_mtx_unlock(&amp;fg-&gt;fg_lock);
}


<span class="enscript-comment">/*
 * fg_drop
 *
 * Description:	Remove a reference to a fileglob by fileproc
 *
 * Parameters:	fp				fileproc containing fileglob
 *						pointer
 *
 * Returns:	void
 *
 * Notes:	XXX Should use OSAddAtomic?
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fg_drop</span>(<span class="enscript-type">struct</span> fileproc * fp)
{
	<span class="enscript-type">struct</span> fileglob *fg;

	fg = fp-&gt;f_fglob;
	lck_mtx_lock_spin(&amp;fg-&gt;fg_lock);
	fg-&gt;fg_count--;
	lck_mtx_unlock(&amp;fg-&gt;fg_lock);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
<span class="enscript-comment">/*
 * fg_insertuipc_mark
 *
 * Description:	Mark fileglob for insertion onto message queue if needed
 *		Also takes fileglob reference
 *
 * Parameters:	fg	Fileglob pointer to insert
 *
 * Returns:	true, if the fileglob needs to be inserted onto msg queue
 *
 * Locks:	Takes and drops fg_lock, potentially many times
 */</span>
boolean_t
<span class="enscript-function-name">fg_insertuipc_mark</span>(<span class="enscript-type">struct</span> fileglob * fg)
{
	boolean_t insert = FALSE;

	lck_mtx_lock_spin(&amp;fg-&gt;fg_lock);
	<span class="enscript-keyword">while</span> (fg-&gt;fg_lflags &amp; FG_RMMSGQ) {
		lck_mtx_convert_spin(&amp;fg-&gt;fg_lock);

		fg-&gt;fg_lflags |= FG_WRMMSGQ;
		msleep(&amp;fg-&gt;fg_lflags, &amp;fg-&gt;fg_lock, 0, <span class="enscript-string">&quot;fg_insertuipc&quot;</span>, NULL);
	}

	fg-&gt;fg_count++;
	fg-&gt;fg_msgcount++;
	<span class="enscript-keyword">if</span> (fg-&gt;fg_msgcount == 1) {
		fg-&gt;fg_lflags |= FG_INSMSGQ;
		insert = TRUE;
	}
	lck_mtx_unlock(&amp;fg-&gt;fg_lock);
	<span class="enscript-keyword">return</span> (insert);
}

<span class="enscript-comment">/*
 * fg_insertuipc
 *
 * Description:	Insert marked fileglob onto message queue
 *
 * Parameters:	fg	Fileglob pointer to insert
 *
 * Returns:	void
 *
 * Locks:	Takes and drops fg_lock &amp; uipc_lock
 *		DO NOT call this function with proc_fdlock held as unp_gc()
 *		can potentially try to acquire proc_fdlock, which can result
 *		in a deadlock if this function is in unp_gc_wait().
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fg_insertuipc</span>(<span class="enscript-type">struct</span> fileglob * fg)
{
	<span class="enscript-keyword">if</span> (fg-&gt;fg_lflags &amp; FG_INSMSGQ) {
		lck_mtx_lock_spin(uipc_lock);
		unp_gc_wait();
		LIST_INSERT_HEAD(&amp;fmsghead, fg, f_msglist);
		lck_mtx_unlock(uipc_lock);
		lck_mtx_lock(&amp;fg-&gt;fg_lock);
		fg-&gt;fg_lflags &amp;= ~FG_INSMSGQ;
		<span class="enscript-keyword">if</span> (fg-&gt;fg_lflags &amp; FG_WINSMSGQ) {
			fg-&gt;fg_lflags &amp;= ~FG_WINSMSGQ;
			wakeup(&amp;fg-&gt;fg_lflags);
		}
		lck_mtx_unlock(&amp;fg-&gt;fg_lock);
	}
}

<span class="enscript-comment">/*
 * fg_removeuipc_mark
 *
 * Description:	Mark the fileglob for removal from message queue if needed
 *		Also releases fileglob message queue reference
 *
 * Parameters:	fg	Fileglob pointer to remove
 *
 * Returns:	true, if the fileglob needs to be removed from msg queue
 *
 * Locks:	Takes and drops fg_lock, potentially many times
 */</span>
boolean_t
<span class="enscript-function-name">fg_removeuipc_mark</span>(<span class="enscript-type">struct</span> fileglob * fg)
{
	boolean_t remove = FALSE;

	lck_mtx_lock_spin(&amp;fg-&gt;fg_lock);
	<span class="enscript-keyword">while</span> (fg-&gt;fg_lflags &amp; FG_INSMSGQ) {
		lck_mtx_convert_spin(&amp;fg-&gt;fg_lock);

		fg-&gt;fg_lflags |= FG_WINSMSGQ;
		msleep(&amp;fg-&gt;fg_lflags, &amp;fg-&gt;fg_lock, 0, <span class="enscript-string">&quot;fg_removeuipc&quot;</span>, NULL);
	}
	fg-&gt;fg_msgcount--;
	<span class="enscript-keyword">if</span> (fg-&gt;fg_msgcount == 0) {
		fg-&gt;fg_lflags |= FG_RMMSGQ;
		remove = TRUE;
	}
	lck_mtx_unlock(&amp;fg-&gt;fg_lock);
	<span class="enscript-keyword">return</span> (remove);
}

<span class="enscript-comment">/*
 * fg_removeuipc
 *
 * Description:	Remove marked fileglob from message queue
 *
 * Parameters:	fg	Fileglob pointer to remove
 *
 * Returns:	void
 *
 * Locks:	Takes and drops fg_lock &amp; uipc_lock
 *		DO NOT call this function with proc_fdlock held as unp_gc()
 *		can potentially try to acquire proc_fdlock, which can result
 *		in a deadlock if this function is in unp_gc_wait().
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fg_removeuipc</span>(<span class="enscript-type">struct</span> fileglob * fg)
{
	<span class="enscript-keyword">if</span> (fg-&gt;fg_lflags &amp; FG_RMMSGQ) {
		lck_mtx_lock_spin(uipc_lock);
		unp_gc_wait();
		LIST_REMOVE(fg, f_msglist);
		lck_mtx_unlock(uipc_lock);
		lck_mtx_lock(&amp;fg-&gt;fg_lock);
		fg-&gt;fg_lflags &amp;= ~FG_RMMSGQ;
		<span class="enscript-keyword">if</span> (fg-&gt;fg_lflags &amp; FG_WRMMSGQ) {
			fg-&gt;fg_lflags &amp;= ~FG_WRMMSGQ;
			wakeup(&amp;fg-&gt;fg_lflags);
		}
		lck_mtx_unlock(&amp;fg-&gt;fg_lock);
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SOCKETS */</span>

<span class="enscript-comment">/*
 * fo_read
 *
 * Description:	Generic fileops read indirected through the fileops pointer
 *		in the fileproc structure
 *
 * Parameters:	fp				fileproc structure pointer
 *		uio				user I/O structure pointer
 *		flags				FOF_ flags
 *		ctx				VFS context for operation
 *
 * Returns:	0				Success
 *		!0				Errno from read
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fo_read</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span> ((*fp-&gt;f_ops-&gt;fo_read)(fp, uio, flags, ctx));
}


<span class="enscript-comment">/*
 * fo_write
 *
 * Description:	Generic fileops write indirected through the fileops pointer
 *		in the fileproc structure
 *
 * Parameters:	fp				fileproc structure pointer
 *		uio				user I/O structure pointer
 *		flags				FOF_ flags
 *		ctx				VFS context for operation
 *
 * Returns:	0				Success
 *		!0				Errno from write
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fo_write</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span>((*fp-&gt;f_ops-&gt;fo_write)(fp, uio, flags, ctx));
}


<span class="enscript-comment">/*
 * fo_ioctl
 *
 * Description:	Generic fileops ioctl indirected through the fileops pointer
 *		in the fileproc structure
 *
 * Parameters:	fp				fileproc structure pointer
 *		com				ioctl command
 *		data				pointer to internalized copy
 *						of user space ioctl command
 *						parameter data in kernel space
 *		ctx				VFS context for operation
 *
 * Returns:	0				Success
 *		!0				Errno from ioctl
 *
 * Locks:	The caller is assumed to have held the proc_fdlock; this
 *		function releases and reacquires this lock.  If the caller
 *		accesses data protected by this lock prior to calling this
 *		function, it will need to revalidate/reacquire any cached
 *		protected data obtained prior to the call.
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">fo_ioctl</span>(<span class="enscript-type">struct</span> fileproc *fp, u_long com, caddr_t data, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	proc_fdunlock(vfs_context_proc(ctx));
	error = (*fp-&gt;f_ops-&gt;fo_ioctl)(fp, com, data, ctx);
	proc_fdlock(vfs_context_proc(ctx));
	<span class="enscript-keyword">return</span>(error);
}       


<span class="enscript-comment">/*
 * fo_select
 *
 * Description:	Generic fileops select indirected through the fileops pointer
 *		in the fileproc structure
 *
 * Parameters:	fp				fileproc structure pointer
 *		which				select which
 *		wql				pointer to wait queue list
 *		ctx				VFS context for operation
 *
 * Returns:	0				Success
 *		!0				Errno from select
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fo_select</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">int</span> which, <span class="enscript-type">void</span> *wql, vfs_context_t ctx)
{       
	<span class="enscript-keyword">return</span>((*fp-&gt;f_ops-&gt;fo_select)(fp, which, wql, ctx));
}


<span class="enscript-comment">/*
 * fo_close
 *
 * Description:	Generic fileops close indirected through the fileops pointer
 *		in the fileproc structure
 *
 * Parameters:	fp				fileproc structure pointer for
 *						file to close
 *		ctx				VFS context for operation
 *
 * Returns:	0				Success
 *		!0				Errno from close
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fo_close</span>(<span class="enscript-type">struct</span> fileglob *fg, vfs_context_t ctx)
{       
	<span class="enscript-keyword">return</span>((*fg-&gt;fg_ops-&gt;fo_close)(fg, ctx));
}


<span class="enscript-comment">/*
 * fo_kqfilter
 *
 * Description:	Generic fileops kqueue filter indirected through the fileops
 *		pointer in the fileproc structure
 *
 * Parameters:	fp				fileproc structure pointer
 *		kn				pointer to knote to filter on
 *		ctx				VFS context for operation
 *
 * Returns:	0				Success
 *		!0				Errno from kqueue filter
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fo_kqfilter</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> knote *kn, vfs_context_t ctx)
{
        <span class="enscript-keyword">return</span> ((*fp-&gt;f_ops-&gt;fo_kqfilter)(fp, kn, ctx));
}

<span class="enscript-comment">/*
 * The ability to send a file descriptor to another
 * process is opt-in by file type.
 */</span>
boolean_t
<span class="enscript-function-name">file_issendable</span>(proc_t p, <span class="enscript-type">struct</span> fileproc *fp) 
{
	proc_fdlock_assert(p, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">switch</span> (fp-&gt;f_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_VNODE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_SOCKET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PIPE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PSXSHM</span>:
		<span class="enscript-keyword">return</span> (0 == (fp-&gt;f_fglob-&gt;fg_lflags &amp; FG_CONFINED));
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/* DTYPE_KQUEUE, DTYPE_FSEVENTS, DTYPE_PSXSEM */</span>
		<span class="enscript-keyword">return</span> FALSE;
	}
}


<span class="enscript-type">struct</span> fileproc *
<span class="enscript-function-name">fileproc_alloc_init</span>(__unused <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> fileproc *fp;

	MALLOC_ZONE(fp, <span class="enscript-type">struct</span> fileproc *, <span class="enscript-keyword">sizeof</span> (*fp), M_FILEPROC, M_WAITOK);
	<span class="enscript-keyword">if</span> (fp)
		bzero(fp, <span class="enscript-keyword">sizeof</span> (*fp));

	<span class="enscript-keyword">return</span> (fp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">fileproc_free</span>(<span class="enscript-type">struct</span> fileproc *fp)
{
	<span class="enscript-keyword">switch</span> (FILEPROC_TYPE(fp)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FTYPE_SIMPLE</span>:
		FREE_ZONE(fp, <span class="enscript-keyword">sizeof</span> (*fp), M_FILEPROC);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FTYPE_GUARDED</span>:
		guarded_fileproc_free(fp);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;%s: corrupt fp %p flags %x&quot;</span>, __func__, fp, fp-&gt;f_flags);
	}
}
</pre>
<hr />
</body></html>