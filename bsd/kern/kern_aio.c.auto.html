<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_aio.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_aio.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>


<span class="enscript-comment">/*
 * todo:
 *		1) ramesh is looking into how to replace taking a reference on
 *		   	the user's map (vm_map_reference()) since it is believed that 
 *			would not hold the process for us.
 *		2) david is looking into a way for us to set the priority of the
 *		   	worker threads to match that of the user's thread when the 
 *		   	async IO was queued.
 */</span>


<span class="enscript-comment">/*
 * This file contains support for the POSIX 1003.1B AIO/LIO facility.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/aio_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/limits.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/waitq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_work_queued</span>					1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_worker_wake</span>				 	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_completion_sig</span>				3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_completion_cleanup_wait</span>		4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_completion_cleanup_wake</span>		5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_completion_suspend_wake</span> 	6
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_fsync_delay</span>					7
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_cancel</span> 						10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_cancel_async_workq</span>			11
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_cancel_sync_workq</span>			12
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_cancel_activeq</span>				13
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_cancel_doneq</span>				14
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_fsync</span>						20
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_read</span>						30
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_write</span>						40
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_listio</span>						50
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_error</span>						60
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_error_val</span>					61
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_error_activeq</span>				62
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_error_workq</span>					63
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AIO_return</span>						70
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AIO_return_val</span>					71
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AIO_return_activeq</span>				72
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AIO_return_workq</span>				73
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_exec</span>						80
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_exit</span>						90
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_exit_sleep</span>					91
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_close</span>						100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_close_sleep</span>					101
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_suspend</span>						110
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_suspend_sleep</span>				111
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_worker_thread</span>				120

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">KERNEL_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_DEBUG</span> KERNEL_DEBUG_CONSTANT
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* 
 * aio requests queue up on the aio_async_workq or lio_sync_workq (for 
 * lio_listio LIO_WAIT).  Requests then move to the per process aio_activeq 
 * (proc.aio_activeq) when one of our worker threads start the IO. 
 * And finally, requests move to the per process aio_doneq (proc.aio_doneq)
 * when the IO request completes.  The request remains on aio_doneq until 
 * user process calls aio_return or the process exits, either way that is our 
 * trigger to release aio resources. 
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> aio_workq   {
	TAILQ_HEAD(, aio_workq_entry) 	aioq_entries;
	<span class="enscript-type">int</span>				aioq_count;
	lck_mtx_t			aioq_mtx;
	<span class="enscript-type">struct</span> waitq			aioq_waitq;
} *aio_workq_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_NUM_WORK_QUEUES</span> 1
<span class="enscript-type">struct</span> aio_anchor_cb
{
	<span class="enscript-type">volatile</span> int32_t	aio_inflight_count; 	<span class="enscript-comment">/* entries that have been taken from a workq */</span>
	<span class="enscript-type">volatile</span> int32_t	aio_done_count; 	<span class="enscript-comment">/* entries on all done queues (proc.aio_doneq) */</span>
	<span class="enscript-type">volatile</span> int32_t	aio_total_count;	<span class="enscript-comment">/* total extant entries */</span>
	
	<span class="enscript-comment">/* Hash table of queues here */</span>
	<span class="enscript-type">int</span> 			aio_num_workqs;
	<span class="enscript-type">struct</span> aio_workq 	aio_async_workqs[AIO_NUM_WORK_QUEUES];
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> aio_anchor_cb aio_anchor_cb;

<span class="enscript-type">struct</span> aio_lio_context
{
	<span class="enscript-type">int</span>		io_waiter;
	<span class="enscript-type">int</span>		io_issued;
	<span class="enscript-type">int</span>		io_completed;
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> aio_lio_context aio_lio_context;


<span class="enscript-comment">/*
 * Notes on aio sleep / wake channels.
 * We currently pick a couple fields within the proc structure that will allow
 * us sleep channels that currently do not collide with any other kernel routines.
 * At this time, for binary compatibility reasons, we cannot create new proc fields.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_SUSPEND_SLEEP_CHAN</span>  p_aio_active_count
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_CLEANUP_SLEEP_CHAN</span> 	p_aio_total_count

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT_AIO_FROM_PROC</span>(aiop, theproc) 	\
	<span class="enscript-keyword">if</span> ((aiop)-&gt;procp != (theproc)) { 	\
		panic(<span class="enscript-string">&quot;AIO on a proc list that does not belong to that proc.\n&quot;</span>); \
	}

<span class="enscript-comment">/*
 *  LOCAL PROTOTYPES
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_proc_lock(proc_t procp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_proc_lock_spin(proc_t procp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_proc_unlock(proc_t procp);
<span class="enscript-type">static</span> lck_mtx_t*	aio_proc_mutex(proc_t procp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_proc_move_done_locked(proc_t procp, aio_workq_entry *entryp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_proc_remove_done_locked(proc_t procp, aio_workq_entry *entryp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		aio_get_process_count(proc_t procp );
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		aio_active_requests_for_process(proc_t procp );
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		aio_proc_active_requests_for_file(proc_t procp, <span class="enscript-type">int</span> fd);
<span class="enscript-type">static</span> boolean_t	is_already_queued(proc_t procp, user_addr_t aiocbp );
<span class="enscript-type">static</span> boolean_t	should_cancel(aio_workq_entry *entryp, user_addr_t aiocbp, <span class="enscript-type">int</span> fd);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_entry_lock(aio_workq_entry *entryp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_entry_lock_spin(aio_workq_entry *entryp);
<span class="enscript-type">static</span> aio_workq_t	aio_entry_workq(aio_workq_entry *entryp);
<span class="enscript-type">static</span> lck_mtx_t*	aio_entry_mutex(__unused aio_workq_entry *entryp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_workq_remove_entry_locked(aio_workq_t queue, aio_workq_entry *entryp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_workq_add_entry_locked(aio_workq_t queue, aio_workq_entry *entryp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_entry_ref_locked(aio_workq_entry *entryp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_entry_unref_locked(aio_workq_entry *entryp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_entry_ref(aio_workq_entry *entryp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_entry_unref(aio_workq_entry *entryp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_entry_update_for_cancel(aio_workq_entry *entryp, boolean_t cancelled, 
					<span class="enscript-type">int</span> wait_for_completion, boolean_t disable_notification);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		aio_entry_try_workq_remove(aio_workq_entry *entryp);
<span class="enscript-type">static</span> boolean_t	aio_delay_fsync_request( aio_workq_entry *entryp );
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		aio_free_request(aio_workq_entry *entryp);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_workq_init(aio_workq_t wq);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_workq_lock_spin(aio_workq_t wq);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_workq_unlock(aio_workq_t wq);
<span class="enscript-type">static</span> lck_mtx_t*	aio_workq_mutex(aio_workq_t wq);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		aio_work_thread( <span class="enscript-type">void</span> );
<span class="enscript-type">static</span> aio_workq_entry *<span class="enscript-function-name">aio_get_some_work</span>( <span class="enscript-type">void</span> );

<span class="enscript-type">static</span> <span class="enscript-type">int</span>		aio_get_all_queues_count( <span class="enscript-type">void</span> );
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		aio_queue_async_request(proc_t procp, user_addr_t aiocbp, <span class="enscript-type">int</span> kindOfIO );
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		aio_validate( aio_workq_entry *entryp );
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 		aio_increment_total_count(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 		aio_decrement_total_count(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>		do_aio_cancel_locked(proc_t p, <span class="enscript-type">int</span> fd, user_addr_t aiocbp, <span class="enscript-type">int</span> wait_for_completion, boolean_t disable_notification );
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		do_aio_completion( aio_workq_entry *entryp );
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		do_aio_fsync( aio_workq_entry *entryp );
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		do_aio_read( aio_workq_entry *entryp );
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		do_aio_write( aio_workq_entry *entryp );
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 		do_munge_aiocb_user32_to_user( <span class="enscript-type">struct</span> user32_aiocb *my_aiocbp, <span class="enscript-type">struct</span> user_aiocb *the_user_aiocbp );
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 		do_munge_aiocb_user64_to_user( <span class="enscript-type">struct</span> user64_aiocb *my_aiocbp, <span class="enscript-type">struct</span> user_aiocb *the_user_aiocbp );
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	lio_create_entry(proc_t procp, 
					 user_addr_t aiocbp, 
					 <span class="enscript-type">void</span> *group_tag,
					 aio_workq_entry **entrypp );
<span class="enscript-type">static</span> aio_workq_entry *<span class="enscript-function-name">aio_create_queue_entry</span>(proc_t procp,
					user_addr_t aiocbp,
					<span class="enscript-type">void</span> *group_tag,
					<span class="enscript-type">int</span> kindOfIO);
<span class="enscript-type">static</span> user_addr_t *<span class="enscript-function-name">aio_copy_in_list</span>(proc_t procp, user_addr_t aiocblist, <span class="enscript-type">int</span> nent);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		free_lio_context(aio_lio_context* context);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 		aio_enqueue_work( proc_t procp, aio_workq_entry *entryp, <span class="enscript-type">int</span> proc_locked);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT_AIO_PROC_LOCK_OWNED</span>(p)	lck_mtx_assert(aio_proc_mutex((p)), LCK_MTX_ASSERT_OWNED)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT_AIO_WORKQ_LOCK_OWNED</span>(q)	lck_mtx_assert(aio_workq_mutex((q)), LCK_MTX_ASSERT_OWNED)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT_AIO_ENTRY_LOCK_OWNED</span>(e)	lck_mtx_assert(aio_entry_mutex((e)), LCK_MTX_ASSERT_OWNED)

<span class="enscript-comment">/*
 *  EXTERNAL PROTOTYPES
 */</span>

<span class="enscript-comment">/* in ...bsd/kern/sys_generic.c */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dofileread</span>(vfs_context_t ctx, <span class="enscript-type">struct</span> fileproc *fp,
			user_addr_t bufp, user_size_t nbyte, 
			off_t offset, <span class="enscript-type">int</span> flags, user_ssize_t *retval );
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dofilewrite</span>(vfs_context_t ctx, <span class="enscript-type">struct</span> fileproc *fp,
			 user_addr_t bufp, user_size_t nbyte, off_t offset, 
			 <span class="enscript-type">int</span> flags, user_ssize_t *retval );
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> uint32_t                         lio_contexts_alloced = 0; 
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* DEBUG */</span>

<span class="enscript-comment">/*
 * aio external global variables.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> aio_max_requests;  			<span class="enscript-comment">/* AIO_MAX - configurable */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> aio_max_requests_per_process;	<span class="enscript-comment">/* AIO_PROCESS_MAX - configurable */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> aio_worker_threads;			<span class="enscript-comment">/* AIO_THREAD_COUNT - configurable */</span>


<span class="enscript-comment">/*
 * aio static variables.
 */</span>
<span class="enscript-type">static</span> aio_anchor_cb	aio_anchor;
<span class="enscript-type">static</span> lck_grp_t	*aio_proc_lock_grp;
<span class="enscript-type">static</span> lck_grp_t	*aio_entry_lock_grp;
<span class="enscript-type">static</span> lck_grp_t	*aio_queue_lock_grp;
<span class="enscript-type">static</span> lck_attr_t	*aio_lock_attr;
<span class="enscript-type">static</span> lck_grp_attr_t	*aio_lock_grp_attr;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone  	*aio_workq_zonep;
<span class="enscript-type">static</span> lck_mtx_t	aio_entry_mtx;
<span class="enscript-type">static</span> lck_mtx_t	aio_proc_mtx;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">aio_entry_lock</span>(__unused aio_workq_entry *entryp)
{
	lck_mtx_lock(&amp;aio_entry_mtx);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		
<span class="enscript-function-name">aio_entry_lock_spin</span>(__unused aio_workq_entry *entryp)
{
	lck_mtx_lock_spin(&amp;aio_entry_mtx);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	
<span class="enscript-function-name">aio_entry_unlock</span>(__unused aio_workq_entry *entryp)
{
	lck_mtx_unlock(&amp;aio_entry_mtx);
}

<span class="enscript-comment">/* Hash */</span>
<span class="enscript-type">static</span> aio_workq_t
<span class="enscript-function-name">aio_entry_workq</span>(__unused aio_workq_entry *entryp) 
{
	<span class="enscript-keyword">return</span> &amp;aio_anchor.aio_async_workqs[0];
}

<span class="enscript-type">static</span> lck_mtx_t*
<span class="enscript-function-name">aio_entry_mutex</span>(__unused aio_workq_entry *entryp) 
{
	<span class="enscript-keyword">return</span> &amp;aio_entry_mtx;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">aio_workq_init</span>(aio_workq_t wq)
{
	TAILQ_INIT(&amp;wq-&gt;aioq_entries);
	wq-&gt;aioq_count = 0;
	lck_mtx_init(&amp;wq-&gt;aioq_mtx, aio_queue_lock_grp, aio_lock_attr);
	waitq_init(&amp;wq-&gt;aioq_waitq, SYNC_POLICY_FIFO|SYNC_POLICY_DISABLE_IRQ);
}


<span class="enscript-comment">/* 
 * Can be passed a queue which is locked spin.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		
<span class="enscript-function-name">aio_workq_remove_entry_locked</span>(aio_workq_t queue, aio_workq_entry *entryp)
{
	ASSERT_AIO_WORKQ_LOCK_OWNED(queue);

	<span class="enscript-keyword">if</span> (entryp-&gt;aio_workq_link.tqe_prev == NULL) {
		panic(<span class="enscript-string">&quot;Trying to remove an entry from a work queue, but it is not on a queue\n&quot;</span>);
	}
	
	TAILQ_REMOVE(&amp;queue-&gt;aioq_entries, entryp, aio_workq_link);
	queue-&gt;aioq_count--;
	entryp-&gt;aio_workq_link.tqe_prev = NULL; <span class="enscript-comment">/* Not on a workq */</span>
	
	<span class="enscript-keyword">if</span> (queue-&gt;aioq_count  &lt; 0) {
		panic(<span class="enscript-string">&quot;Negative count on a queue.\n&quot;</span>);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		
<span class="enscript-function-name">aio_workq_add_entry_locked</span>(aio_workq_t queue, aio_workq_entry *entryp)
{
	ASSERT_AIO_WORKQ_LOCK_OWNED(queue);

	TAILQ_INSERT_TAIL(&amp;queue-&gt;aioq_entries, entryp, aio_workq_link);
	<span class="enscript-keyword">if</span> (queue-&gt;aioq_count  &lt; 0) {
		panic(<span class="enscript-string">&quot;Negative count on a queue.\n&quot;</span>);
	}
	queue-&gt;aioq_count++;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		
<span class="enscript-function-name">aio_proc_lock</span>(proc_t procp) 
{
	lck_mtx_lock(aio_proc_mutex(procp));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		
<span class="enscript-function-name">aio_proc_lock_spin</span>(proc_t procp)
{
	lck_mtx_lock_spin(aio_proc_mutex(procp));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">aio_proc_move_done_locked</span>(proc_t procp, aio_workq_entry *entryp)
{
	ASSERT_AIO_PROC_LOCK_OWNED(procp);

	TAILQ_REMOVE(&amp;procp-&gt;p_aio_activeq, entryp, aio_proc_link );
	TAILQ_INSERT_TAIL( &amp;procp-&gt;p_aio_doneq, entryp, aio_proc_link);
	procp-&gt;p_aio_active_count--;
	OSIncrementAtomic(&amp;aio_anchor.aio_done_count);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">aio_proc_remove_done_locked</span>(proc_t procp, aio_workq_entry *entryp)
{
	TAILQ_REMOVE(&amp;procp-&gt;p_aio_doneq, entryp, aio_proc_link);
	OSDecrementAtomic(&amp;aio_anchor.aio_done_count);
	aio_decrement_total_count();
	procp-&gt;p_aio_total_count--;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		
<span class="enscript-function-name">aio_proc_unlock</span>(proc_t procp)
{
	lck_mtx_unlock(aio_proc_mutex(procp));
}

<span class="enscript-type">static</span> lck_mtx_t*
<span class="enscript-function-name">aio_proc_mutex</span>(proc_t procp)
{
	<span class="enscript-keyword">return</span> &amp;procp-&gt;p_mlock;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		
<span class="enscript-function-name">aio_entry_ref_locked</span>(aio_workq_entry *entryp)
{
	ASSERT_AIO_ENTRY_LOCK_OWNED(entryp);

	<span class="enscript-keyword">if</span> (entryp-&gt;aio_refcount &lt; 0) {
		panic(<span class="enscript-string">&quot;AIO workq entry with a negative refcount.\n&quot;</span>);
	}
	entryp-&gt;aio_refcount++;
}


<span class="enscript-comment">/* Return 1 if you've freed it */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">aio_entry_unref_locked</span>(aio_workq_entry *entryp)
{
	ASSERT_AIO_ENTRY_LOCK_OWNED(entryp);

	entryp-&gt;aio_refcount--;
	<span class="enscript-keyword">if</span> (entryp-&gt;aio_refcount &lt; 0) {
		panic(<span class="enscript-string">&quot;AIO workq entry with a negative refcount.\n&quot;</span>);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	
<span class="enscript-function-name">aio_entry_ref</span>(aio_workq_entry *entryp)
{
	aio_entry_lock_spin(entryp);
	aio_entry_ref_locked(entryp);
	aio_entry_unlock(entryp);
}
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		
<span class="enscript-function-name">aio_entry_unref</span>(aio_workq_entry *entryp)
{
	aio_entry_lock_spin(entryp);
	aio_entry_unref_locked(entryp);

	<span class="enscript-keyword">if</span> ((entryp-&gt;aio_refcount == 0) &amp;&amp; ((entryp-&gt;flags &amp; AIO_DO_FREE) != 0)) {
		aio_entry_unlock(entryp);
		aio_free_request(entryp);
	} <span class="enscript-keyword">else</span> {
		aio_entry_unlock(entryp);
	}
	
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		
<span class="enscript-function-name">aio_entry_update_for_cancel</span>(aio_workq_entry *entryp, boolean_t cancelled, <span class="enscript-type">int</span> wait_for_completion, boolean_t disable_notification)
{
	aio_entry_lock_spin(entryp);

	<span class="enscript-keyword">if</span> (cancelled) {
		aio_entry_ref_locked(entryp);
		entryp-&gt;errorval = ECANCELED;
		entryp-&gt;returnval = -1;
	}
	
	<span class="enscript-keyword">if</span> ( wait_for_completion ) {
		entryp-&gt;flags |= wait_for_completion; <span class="enscript-comment">/* flag for special completion processing */</span>
	}
	
	<span class="enscript-keyword">if</span> ( disable_notification ) { 
		entryp-&gt;flags |= AIO_DISABLE; <span class="enscript-comment">/* Don't want a signal */</span>
	}

	aio_entry_unlock(entryp); 
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">aio_entry_try_workq_remove</span>(aio_workq_entry *entryp)
{	
	<span class="enscript-comment">/* Can only be cancelled if it's still on a work queue */</span>
	<span class="enscript-keyword">if</span> (entryp-&gt;aio_workq_link.tqe_prev != NULL) {
		aio_workq_t queue;

		<span class="enscript-comment">/* Will have to check again under the lock */</span>
		queue = aio_entry_workq(entryp);
		aio_workq_lock_spin(queue);
		<span class="enscript-keyword">if</span> (entryp-&gt;aio_workq_link.tqe_prev != NULL) {
			aio_workq_remove_entry_locked(queue, entryp);
			aio_workq_unlock(queue);
			<span class="enscript-keyword">return</span> 1;
		}  <span class="enscript-keyword">else</span> {
			aio_workq_unlock(queue);
		}
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		
<span class="enscript-function-name">aio_workq_lock_spin</span>(aio_workq_t wq)
{
	lck_mtx_lock_spin(aio_workq_mutex(wq));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		
<span class="enscript-function-name">aio_workq_unlock</span>(aio_workq_t wq)
{
	lck_mtx_unlock(aio_workq_mutex(wq));
}

<span class="enscript-type">static</span> lck_mtx_t*
<span class="enscript-function-name">aio_workq_mutex</span>(aio_workq_t wq)
{
	<span class="enscript-keyword">return</span> &amp;wq-&gt;aioq_mtx;
}

<span class="enscript-comment">/*
 * aio_cancel - attempt to cancel one or more async IO requests currently
 * outstanding against file descriptor uap-&gt;fd.  If uap-&gt;aiocbp is not 
 * NULL then only one specific IO is cancelled (if possible).  If uap-&gt;aiocbp
 * is NULL then all outstanding async IO request for the given file
 * descriptor are cancelled (if possible).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">aio_cancel</span>(proc_t p, <span class="enscript-type">struct</span> aio_cancel_args *uap, <span class="enscript-type">int</span> *retval )
{
	<span class="enscript-type">struct</span> user_aiocb		my_aiocb;
	<span class="enscript-type">int</span>							result;

	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_cancel)) | DBG_FUNC_START,
		     	  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, 0, 0, 0 );

	<span class="enscript-comment">/* quick check to see if there are any async IO requests queued up */</span>
	<span class="enscript-keyword">if</span> (aio_get_all_queues_count() &lt; 1) {
		result = 0;
		*retval = AIO_ALLDONE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
	}
	
	*retval = -1; 
	<span class="enscript-keyword">if</span> ( uap-&gt;aiocbp != USER_ADDR_NULL ) {
		<span class="enscript-keyword">if</span> ( proc_is64bit(p) ) {
			<span class="enscript-type">struct</span> user64_aiocb aiocb64;
			
			result = copyin( uap-&gt;aiocbp, &amp;aiocb64, <span class="enscript-keyword">sizeof</span>(aiocb64) );
			<span class="enscript-keyword">if</span> (result == 0 )
				do_munge_aiocb_user64_to_user(&amp;aiocb64, &amp;my_aiocb);

		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_aiocb aiocb32;

			result = copyin( uap-&gt;aiocbp, &amp;aiocb32, <span class="enscript-keyword">sizeof</span>(aiocb32) );
			<span class="enscript-keyword">if</span> ( result == 0 )
				do_munge_aiocb_user32_to_user( &amp;aiocb32, &amp;my_aiocb );
		}

		<span class="enscript-keyword">if</span> ( result != 0 ) {
			result = EAGAIN; 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
		}

		<span class="enscript-comment">/* NOTE - POSIX standard says a mismatch between the file */</span>
		<span class="enscript-comment">/* descriptor passed in and the file descriptor embedded in */</span>
		<span class="enscript-comment">/* the aiocb causes unspecified results.  We return EBADF in */</span>
		<span class="enscript-comment">/* that situation.  */</span>
		<span class="enscript-keyword">if</span> ( uap-&gt;fd != my_aiocb.aio_fildes ) {
			result = EBADF;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
		}
	}

	aio_proc_lock(p);
	result = do_aio_cancel_locked( p, uap-&gt;fd, uap-&gt;aiocbp, 0, FALSE );
	ASSERT_AIO_PROC_LOCK_OWNED(p);
	aio_proc_unlock(p);

	<span class="enscript-keyword">if</span> ( result != -1 ) {
		*retval = result;
		result = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
	}
	
	result = EBADF;
	
<span class="enscript-reference">ExitRoutine</span>:
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_cancel)) | DBG_FUNC_END,
		     	  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, result, 0, 0 );

	<span class="enscript-keyword">return</span>( result );

} <span class="enscript-comment">/* aio_cancel */</span>


<span class="enscript-comment">/*
 * _aio_close - internal function used to clean up async IO requests for 
 * a file descriptor that is closing.  
 * THIS MAY BLOCK.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">_aio_close</span>(proc_t p, <span class="enscript-type">int</span> fd )
{
	<span class="enscript-type">int</span>			error;

	<span class="enscript-comment">/* quick check to see if there are any async IO requests queued up */</span>
	<span class="enscript-keyword">if</span> (aio_get_all_queues_count() &lt; 1) {
		<span class="enscript-keyword">return</span>;
	}

	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_close)) | DBG_FUNC_START,
		     	  (<span class="enscript-type">int</span>)p, fd, 0, 0, 0 );
	
	<span class="enscript-comment">/* cancel all async IO requests on our todo queues for this file descriptor */</span>
	aio_proc_lock(p);
	error = do_aio_cancel_locked( p, fd, 0, AIO_CLOSE_WAIT, FALSE );
	ASSERT_AIO_PROC_LOCK_OWNED(p);
	<span class="enscript-keyword">if</span> ( error == AIO_NOTCANCELED ) {
		<span class="enscript-comment">/* 
		 * AIO_NOTCANCELED is returned when we find an aio request for this process 
		 * and file descriptor on the active async IO queue.  Active requests cannot 
		 * be cancelled so we must wait for them to complete.  We will get a special 
		 * wake up call on our channel used to sleep for ALL active requests to 
		 * complete.  This sleep channel (proc.AIO_CLEANUP_SLEEP_CHAN) is only used  
		 * when we must wait for all active aio requests.  
		 */</span>

		KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_close_sleep)) | DBG_FUNC_NONE,
		     	 	  (<span class="enscript-type">int</span>)p, fd, 0, 0, 0 );

		<span class="enscript-keyword">while</span> (aio_proc_active_requests_for_file(p, fd) &gt; 0) {
			msleep(&amp;p-&gt;AIO_CLEANUP_SLEEP_CHAN, aio_proc_mutex(p), PRIBIO, <span class="enscript-string">&quot;aio_close&quot;</span>, 0 );
		}

	}
	
	aio_proc_unlock(p);
	
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_close)) | DBG_FUNC_END,
		     	  (<span class="enscript-type">int</span>)p, fd, 0, 0, 0 );

	<span class="enscript-keyword">return</span>;
	
} <span class="enscript-comment">/* _aio_close */</span>


<span class="enscript-comment">/*
 * aio_error - return the error status associated with the async IO
 * request referred to by uap-&gt;aiocbp.  The error status is the errno
 * value that would be set by the corresponding IO request (read, wrtie,
 * fdatasync, or sync).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">aio_error</span>(proc_t p, <span class="enscript-type">struct</span> aio_error_args *uap, <span class="enscript-type">int</span> *retval )
{
	aio_workq_entry		 		*entryp;
	<span class="enscript-type">int</span>							error;

	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_error)) | DBG_FUNC_START,
		     	  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, 0, 0, 0 );

	<span class="enscript-comment">/* see if there are any aios to check */</span>
	<span class="enscript-keyword">if</span> (aio_get_all_queues_count() &lt; 1) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	aio_proc_lock(p);
	
	<span class="enscript-comment">/* look for a match on our queue of async IO requests that have completed */</span>
	TAILQ_FOREACH( entryp, &amp;p-&gt;p_aio_doneq, aio_proc_link) {
		<span class="enscript-keyword">if</span> ( entryp-&gt;uaiocbp == uap-&gt;aiocbp ) {
			ASSERT_AIO_FROM_PROC(entryp, p);

			aio_entry_lock_spin(entryp);
			*retval = entryp-&gt;errorval;
			error = 0;
			aio_entry_unlock(entryp);
			KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_error_val)) | DBG_FUNC_NONE,
		     	 		   (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, *retval, 0, 0 );
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
		}
	}
	
	<span class="enscript-comment">/* look for a match on our queue of active async IO requests */</span>
	TAILQ_FOREACH( entryp, &amp;p-&gt;p_aio_activeq, aio_proc_link) {
		<span class="enscript-keyword">if</span> ( entryp-&gt;uaiocbp == uap-&gt;aiocbp ) {
			ASSERT_AIO_FROM_PROC(entryp, p);
			*retval = EINPROGRESS;
			error = 0;
			KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_error_activeq)) | DBG_FUNC_NONE,
		     	 		   (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, *retval, 0, 0 );
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
		}
	}

	error = EINVAL;
	
<span class="enscript-reference">ExitRoutine</span>:
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_error)) | DBG_FUNC_END,
		     	  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, error, 0, 0 );
	aio_proc_unlock(p);

	<span class="enscript-keyword">return</span>( error );

} <span class="enscript-comment">/* aio_error */</span>


<span class="enscript-comment">/*
 * aio_fsync - asynchronously force all IO operations associated 
 * with the file indicated by the file descriptor (uap-&gt;aiocbp-&gt;aio_fildes) and 
 * queued at the time of the call to the synchronized completion state.
 * NOTE - we do not support op O_DSYNC at this point since we do not support the 
 * fdatasync() call.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">aio_fsync</span>(proc_t p, <span class="enscript-type">struct</span> aio_fsync_args *uap, <span class="enscript-type">int</span> *retval )
{
	<span class="enscript-type">int</span>			error;
	<span class="enscript-type">int</span>			fsync_kind;

	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_fsync)) | DBG_FUNC_START,
		     	  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, uap-&gt;op, 0, 0 );

	*retval = 0;
	<span class="enscript-comment">/* 0 := O_SYNC for binary backward compatibility with Panther */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;op == O_SYNC || uap-&gt;op == 0)
		fsync_kind = AIO_FSYNC;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( uap-&gt;op == O_DSYNC )
		fsync_kind = AIO_DSYNC;
	<span class="enscript-keyword">else</span> {
		*retval = -1;
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
	}
	
	error = aio_queue_async_request( p, uap-&gt;aiocbp, fsync_kind );
	<span class="enscript-keyword">if</span> ( error != 0 )
		*retval = -1;

<span class="enscript-reference">ExitRoutine</span>:		
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_fsync)) | DBG_FUNC_END,
		     	  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, error, 0, 0 );

	<span class="enscript-keyword">return</span>( error );

} <span class="enscript-comment">/* aio_fsync */</span>


<span class="enscript-comment">/* aio_read - asynchronously read uap-&gt;aiocbp-&gt;aio_nbytes bytes from the 
 * file descriptor (uap-&gt;aiocbp-&gt;aio_fildes) into the buffer 
 * (uap-&gt;aiocbp-&gt;aio_buf).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">aio_read</span>(proc_t p, <span class="enscript-type">struct</span> aio_read_args *uap, <span class="enscript-type">int</span> *retval )
{
	<span class="enscript-type">int</span>			error;

	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_read)) | DBG_FUNC_START,
		     	  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, 0, 0, 0 );
	
	*retval = 0;

	error = aio_queue_async_request( p, uap-&gt;aiocbp, AIO_READ );
	<span class="enscript-keyword">if</span> ( error != 0 )
		*retval = -1;

	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_read)) | DBG_FUNC_END,
		     	  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, error, 0, 0 );
		
	<span class="enscript-keyword">return</span>( error );

} <span class="enscript-comment">/* aio_read */</span>


<span class="enscript-comment">/*
 * aio_return - return the return status associated with the async IO
 * request referred to by uap-&gt;aiocbp.  The return status is the value
 * that would be returned by corresponding IO request (read, write,
 * fdatasync, or sync).  This is where we release kernel resources 
 * held for async IO call associated with the given aiocb pointer.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">aio_return</span>(proc_t p, <span class="enscript-type">struct</span> aio_return_args *uap, user_ssize_t *retval )
{
	aio_workq_entry		 		*entryp;
	<span class="enscript-type">int</span>							error;
	boolean_t					proc_lock_held = FALSE;
	
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_return)) | DBG_FUNC_START,
		     	  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, 0, 0, 0 );

	<span class="enscript-comment">/* See if there are any entries to check */</span>
	<span class="enscript-keyword">if</span> (aio_get_all_queues_count() &lt; 1) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
	}

	aio_proc_lock(p);
	proc_lock_held = TRUE;
	*retval = 0;

	<span class="enscript-comment">/* look for a match on our queue of async IO requests that have completed */</span>
	TAILQ_FOREACH( entryp, &amp;p-&gt;p_aio_doneq, aio_proc_link) {
		ASSERT_AIO_FROM_PROC(entryp, p);
		<span class="enscript-keyword">if</span> ( entryp-&gt;uaiocbp == uap-&gt;aiocbp ) {
			<span class="enscript-comment">/* Done and valid for aio_return(), pull it off the list */</span>
			aio_proc_remove_done_locked(p, entryp);
			
			<span class="enscript-comment">/* Drop the proc lock, but keep the entry locked */</span>
			aio_entry_lock(entryp);
			aio_proc_unlock(p);
			proc_lock_held = FALSE;

			*retval = entryp-&gt;returnval;
			error = 0;

			<span class="enscript-comment">/* No references and off all lists, safe to free */</span>
			<span class="enscript-keyword">if</span> (entryp-&gt;aio_refcount == 0) {
				aio_entry_unlock(entryp);
				aio_free_request(entryp);
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Whoever has the refcount will have to free it */</span>
				entryp-&gt;flags |= AIO_DO_FREE;
				aio_entry_unlock(entryp);
			}


			KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_return_val)) | DBG_FUNC_NONE,
		     	 		   (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, *retval, 0, 0 );
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
		}
	}
	
	<span class="enscript-comment">/* look for a match on our queue of active async IO requests */</span>
	TAILQ_FOREACH( entryp, &amp;p-&gt;p_aio_activeq, aio_proc_link) {
		ASSERT_AIO_FROM_PROC(entryp, p);
		<span class="enscript-keyword">if</span> ( entryp-&gt;uaiocbp == uap-&gt;aiocbp ) {
			error = EINPROGRESS;
			KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_return_activeq)) | DBG_FUNC_NONE,
		     	 		   (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, *retval, 0, 0 );
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
		}
	}
	
	error = EINVAL;
	
<span class="enscript-reference">ExitRoutine</span>:
	<span class="enscript-keyword">if</span> (proc_lock_held)
		aio_proc_unlock(p);
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_return)) | DBG_FUNC_END,
		     	  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, error, 0, 0 );

	<span class="enscript-keyword">return</span>( error );

} <span class="enscript-comment">/* aio_return */</span>


<span class="enscript-comment">/*
 * _aio_exec - internal function used to clean up async IO requests for 
 * a process that is going away due to exec().  We cancel any async IOs   
 * we can and wait for those already active.  We also disable signaling
 * for cancelled or active aio requests that complete. 
 * This routine MAY block!
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">_aio_exec</span>(proc_t p )
{

	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_exec)) | DBG_FUNC_START,
		     	  (<span class="enscript-type">int</span>)p, 0, 0, 0, 0 );

	_aio_exit( p );

	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_exec)) | DBG_FUNC_END,
		     	  (<span class="enscript-type">int</span>)p, 0, 0, 0, 0 );

	<span class="enscript-keyword">return</span>;
		
} <span class="enscript-comment">/* _aio_exec */</span>


<span class="enscript-comment">/*
 * _aio_exit - internal function used to clean up async IO requests for 
 * a process that is terminating (via exit() or exec() ).  We cancel any async IOs   
 * we can and wait for those already active.  We also disable signaling
 * for cancelled or active aio requests that complete.  This routine MAY block!
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">_aio_exit</span>(proc_t p )
{
	<span class="enscript-type">int</span>						error;
	aio_workq_entry 		*entryp;


	<span class="enscript-comment">/* quick check to see if there are any async IO requests queued up */</span>
	<span class="enscript-keyword">if</span> (aio_get_all_queues_count() &lt; 1) {
		<span class="enscript-keyword">return</span>;
	}

	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_exit)) | DBG_FUNC_START,
		     	  (<span class="enscript-type">int</span>)p, 0, 0, 0, 0 );

	aio_proc_lock(p);

	<span class="enscript-comment">/* 
	 * cancel async IO requests on the todo work queue and wait for those  
	 * already active to complete. 
	 */</span>
	error = do_aio_cancel_locked( p, 0, 0, AIO_EXIT_WAIT, TRUE );
	ASSERT_AIO_PROC_LOCK_OWNED(p);
	<span class="enscript-keyword">if</span> ( error == AIO_NOTCANCELED ) {
		<span class="enscript-comment">/* 
		 * AIO_NOTCANCELED is returned when we find an aio request for this process 
		 * on the active async IO queue.  Active requests cannot be cancelled so we 
		 * must wait for them to complete.  We will get a special wake up call on 
		 * our channel used to sleep for ALL active requests to complete.  This sleep 
		 * channel (proc.AIO_CLEANUP_SLEEP_CHAN) is only used when we must wait for all 
		 * active aio requests.  
		 */</span>

		KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_exit_sleep)) | DBG_FUNC_NONE,
		     	 	  (<span class="enscript-type">int</span>)p, 0, 0, 0, 0 );

		<span class="enscript-keyword">while</span> (p-&gt;p_aio_active_count != 0) {
			msleep(&amp;p-&gt;AIO_CLEANUP_SLEEP_CHAN, aio_proc_mutex(p), PRIBIO, <span class="enscript-string">&quot;aio_exit&quot;</span>, 0 );
		}
	}
		
	<span class="enscript-keyword">if</span> (p-&gt;p_aio_active_count != 0) {
		panic(<span class="enscript-string">&quot;Exiting process has %d active AIOs after cancellation has completed.\n&quot;</span>, p-&gt;p_aio_active_count);
	}
	
	<span class="enscript-comment">/* release all aio resources used by this process */</span>
	entryp = TAILQ_FIRST( &amp;p-&gt;p_aio_doneq );
	<span class="enscript-keyword">while</span> ( entryp != NULL ) {
		ASSERT_AIO_FROM_PROC(entryp, p);
		aio_workq_entry		 	*next_entryp;
			
		next_entryp = TAILQ_NEXT( entryp, aio_proc_link);
		aio_proc_remove_done_locked(p, entryp);
			
		<span class="enscript-comment">/* we cannot free requests that are still completing */</span>
		aio_entry_lock_spin(entryp);
		<span class="enscript-keyword">if</span> (entryp-&gt;aio_refcount == 0) {
			aio_proc_unlock(p);
			aio_entry_unlock(entryp);
			aio_free_request(entryp);

			<span class="enscript-comment">/* need to start over since aio_doneq may have been */</span>
			<span class="enscript-comment">/* changed while we were away.  */</span>
			aio_proc_lock(p);
			entryp = TAILQ_FIRST( &amp;p-&gt;p_aio_doneq );
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* whoever has the reference will have to do the free */</span>
			entryp-&gt;flags |= AIO_DO_FREE;
		} 

		aio_entry_unlock(entryp);
		entryp = next_entryp;
	}
	
	aio_proc_unlock(p);
	
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_exit)) | DBG_FUNC_END,
		     	  (<span class="enscript-type">int</span>)p, 0, 0, 0, 0 );
	<span class="enscript-keyword">return</span>;
	
} <span class="enscript-comment">/* _aio_exit */</span>


<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">should_cancel</span>(aio_workq_entry *entryp, user_addr_t aiocbp, <span class="enscript-type">int</span> fd) 
{
	<span class="enscript-keyword">if</span> ( (aiocbp == USER_ADDR_NULL &amp;&amp; fd == 0) ||
			(aiocbp != USER_ADDR_NULL &amp;&amp; entryp-&gt;uaiocbp == aiocbp) ||
			(aiocbp == USER_ADDR_NULL &amp;&amp; fd == entryp-&gt;aiocb.aio_fildes) ) {
		<span class="enscript-keyword">return</span> TRUE;
	}

	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-comment">/*
 * do_aio_cancel_locked - cancel async IO requests (if possible).  We get called by
 * aio_cancel, close, and at exit.  
 * There are three modes of operation: 1) cancel all async IOs for a process - 
 * fd is 0 and aiocbp is NULL 2) cancel all async IOs for file descriptor - fd 
 * is &gt; 0 and aiocbp is NULL 3) cancel one async IO associated with the given
 * aiocbp.
 * Returns -1 if no matches were found, AIO_CANCELED when we cancelled all 
 * target async IO requests, AIO_NOTCANCELED if we could not cancel all 
 * target async IO requests, and AIO_ALLDONE if all target async IO requests 
 * were already complete.
 * WARNING - do not deference aiocbp in this routine, it may point to user 
 * land data that has not been copied in (when called from aio_cancel() )
 *
 * Called with proc locked, and returns the same way.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">do_aio_cancel_locked</span>(proc_t p, <span class="enscript-type">int</span> fd, user_addr_t aiocbp, 
	<span class="enscript-type">int</span> wait_for_completion, boolean_t disable_notification )
{
	ASSERT_AIO_PROC_LOCK_OWNED(p);

	aio_workq_entry		 	*entryp;
	<span class="enscript-type">int</span>						result;

	result = -1;
		
	<span class="enscript-comment">/* look for a match on our queue of async todo work. */</span>
	entryp = TAILQ_FIRST(&amp;p-&gt;p_aio_activeq);
	<span class="enscript-keyword">while</span> ( entryp != NULL ) {
		ASSERT_AIO_FROM_PROC(entryp, p);
		aio_workq_entry		 	*next_entryp;

		next_entryp = TAILQ_NEXT( entryp, aio_proc_link);
		<span class="enscript-keyword">if</span> (!should_cancel(entryp, aiocbp, fd)) {
			entryp = next_entryp;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* Can only be cancelled if it's still on a work queue */</span>
		<span class="enscript-keyword">if</span> (aio_entry_try_workq_remove(entryp) != 0) {
			<span class="enscript-comment">/* Have removed from workq. Update entry state and take a ref */</span>
			aio_entry_update_for_cancel(entryp, TRUE, 0, disable_notification);

			<span class="enscript-comment">/* Put on the proc done queue and update counts, then unlock the proc */</span>
			aio_proc_move_done_locked(p, entryp);
			aio_proc_unlock(p);

			<span class="enscript-comment">/* Now it's officially cancelled.  Do the completion */</span>
			result = AIO_CANCELED;
			KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_cancel_async_workq)) | DBG_FUNC_NONE,
					(<span class="enscript-type">int</span>)entryp-&gt;procp, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, fd, 0, 0 );
			do_aio_completion(entryp);

			<span class="enscript-comment">/* This will free if the aio_return() has already happened ... */</span>
			aio_entry_unref(entryp);
			aio_proc_lock(p);

			<span class="enscript-keyword">if</span> ( aiocbp != USER_ADDR_NULL ) {
				<span class="enscript-keyword">return</span>( result );
			}

			<span class="enscript-comment">/* 
			 * Restart from the head of the proc active queue since it 
			 * may have been changed while we were away doing completion 
			 * processing. 
			 * 
			 * Note that if we found an uncancellable AIO before, we will
			 * either find it again or discover that it's been completed,
			 * so resetting the result will not cause us to return success
			 * despite outstanding AIOs.
			 */</span>
			entryp = TAILQ_FIRST(&amp;p-&gt;p_aio_activeq);
			result = -1; <span class="enscript-comment">/* As if beginning anew */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* 
			 * It's been taken off the active queue already, i.e. is in flight.
			 * All we can do is ask for notification.
			 */</span>
			result = AIO_NOTCANCELED;

			KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_cancel_activeq)) | DBG_FUNC_NONE,
					(<span class="enscript-type">int</span>)entryp-&gt;procp, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, fd, 0, 0 );

			<span class="enscript-comment">/* Mark for waiting and such; will not take a ref if &quot;cancelled&quot; arg is FALSE */</span>
			aio_entry_update_for_cancel(entryp, FALSE, wait_for_completion, disable_notification);

			<span class="enscript-keyword">if</span> ( aiocbp != USER_ADDR_NULL ) {
				<span class="enscript-keyword">return</span>( result );
			}
			entryp = next_entryp;
		}
	} <span class="enscript-comment">/* while... */</span>
		
	<span class="enscript-comment">/* 
	 * if we didn't find any matches on the todo or active queues then look for a 
	 * match on our queue of async IO requests that have completed and if found 
	 * return AIO_ALLDONE result.  
	 *
	 * Proc AIO lock is still held.
	 */</span>
	<span class="enscript-keyword">if</span> ( result == -1 ) {
		TAILQ_FOREACH(entryp, &amp;p-&gt;p_aio_doneq, aio_proc_link) {
			ASSERT_AIO_FROM_PROC(entryp, p);
			<span class="enscript-keyword">if</span> (should_cancel(entryp, aiocbp, fd)) {
				result = AIO_ALLDONE;
				KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_cancel_doneq)) | DBG_FUNC_NONE,
						(<span class="enscript-type">int</span>)entryp-&gt;procp, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, fd, 0, 0 );

				<span class="enscript-keyword">if</span> ( aiocbp != USER_ADDR_NULL ) {
					<span class="enscript-keyword">return</span>( result );
				}
			}
		}
	}

	<span class="enscript-keyword">return</span>( result );
	
}
 <span class="enscript-comment">/* do_aio_cancel_locked */</span>


<span class="enscript-comment">/*
 * aio_suspend - suspend the calling thread until at least one of the async
 * IO operations referenced by uap-&gt;aiocblist has completed, until a signal
 * interrupts the function, or uap-&gt;timeoutp time interval (optional) has
 * passed.
 * Returns 0 if one or more async IOs have completed else -1 and errno is
 * set appropriately - EAGAIN if timeout elapses or EINTR if an interrupt
 * woke us up.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">aio_suspend</span>(proc_t p, <span class="enscript-type">struct</span> aio_suspend_args *uap, <span class="enscript-type">int</span> *retval )
{
	__pthread_testcancel(1);
	<span class="enscript-keyword">return</span>(aio_suspend_nocancel(p, (<span class="enscript-type">struct</span> aio_suspend_nocancel_args *)uap, retval));
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">aio_suspend_nocancel</span>(proc_t p, <span class="enscript-type">struct</span> aio_suspend_nocancel_args *uap, <span class="enscript-type">int</span> *retval )
{
	<span class="enscript-type">int</span>					error;
	<span class="enscript-type">int</span>					i, count;
	uint64_t			abstime;
	<span class="enscript-type">struct</span> user_timespec ts;
	aio_workq_entry 	*entryp;
	user_addr_t			*aiocbpp;
	
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_suspend)) | DBG_FUNC_START,
		     	  (<span class="enscript-type">int</span>)p, uap-&gt;nent, 0, 0, 0 );

	*retval = -1;
	abstime = 0;
	aiocbpp = NULL;

	count = aio_get_all_queues_count( ); 
	<span class="enscript-keyword">if</span> ( count &lt; 1 ) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
	}

	<span class="enscript-keyword">if</span> ( uap-&gt;nent &lt; 1 || uap-&gt;nent &gt; aio_max_requests_per_process ) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
	}

	<span class="enscript-keyword">if</span> ( uap-&gt;timeoutp != USER_ADDR_NULL ) {
		<span class="enscript-keyword">if</span> ( proc_is64bit(p) ) {
			<span class="enscript-type">struct</span> user64_timespec temp;
			error = copyin( uap-&gt;timeoutp, &amp;temp, <span class="enscript-keyword">sizeof</span>(temp) );
			<span class="enscript-keyword">if</span> ( error == 0 ) {
				ts.tv_sec = temp.tv_sec;
				ts.tv_nsec = temp.tv_nsec;
			}
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_timespec temp;
			error = copyin( uap-&gt;timeoutp, &amp;temp, <span class="enscript-keyword">sizeof</span>(temp) );
			<span class="enscript-keyword">if</span> ( error == 0 ) {
				ts.tv_sec = temp.tv_sec;
				ts.tv_nsec = temp.tv_nsec;
			}
		}
		<span class="enscript-keyword">if</span> ( error != 0 ) {
			error = EAGAIN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
		}
			
		<span class="enscript-keyword">if</span> ( ts.tv_sec &lt; 0 || ts.tv_nsec &lt; 0 || ts.tv_nsec &gt;= 1000000000 ) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
		}

		nanoseconds_to_absolutetime( (uint64_t)ts.tv_sec * NSEC_PER_SEC + ts.tv_nsec, 
									 &amp;abstime );
		clock_absolutetime_interval_to_deadline( abstime, &amp;abstime );
	}

	aiocbpp = aio_copy_in_list(p, uap-&gt;aiocblist, uap-&gt;nent);
	<span class="enscript-keyword">if</span> ( aiocbpp == NULL ) {
		error = EAGAIN;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
	}

	<span class="enscript-comment">/* check list of aio requests to see if any have completed */</span>
<span class="enscript-reference">check_for_our_aiocbp</span>:
	aio_proc_lock_spin(p);
	<span class="enscript-keyword">for</span> ( i = 0; i &lt; uap-&gt;nent; i++ ) {
		user_addr_t	aiocbp;  

		<span class="enscript-comment">/* NULL elements are legal so check for 'em */</span>
		aiocbp = *(aiocbpp + i);
		<span class="enscript-keyword">if</span> ( aiocbp == USER_ADDR_NULL )
			<span class="enscript-keyword">continue</span>;
	
		<span class="enscript-comment">/* return immediately if any aio request in the list is done */</span>
		TAILQ_FOREACH( entryp, &amp;p-&gt;p_aio_doneq, aio_proc_link) {
			ASSERT_AIO_FROM_PROC(entryp, p);
			<span class="enscript-keyword">if</span> ( entryp-&gt;uaiocbp == aiocbp ) {
				aio_proc_unlock(p);
				*retval = 0;
				error = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
			}
		}
	} <span class="enscript-comment">/* for ( ; i &lt; uap-&gt;nent; ) */</span>

	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_suspend_sleep)) | DBG_FUNC_NONE,
		     	  (<span class="enscript-type">int</span>)p, uap-&gt;nent, 0, 0, 0 );
	
	<span class="enscript-comment">/* 
	 * wait for an async IO to complete or a signal fires or timeout expires. 
	 * we return EAGAIN (35) for timeout expiration and EINTR (4) when a signal 
	 * interrupts us.  If an async IO completes before a signal fires or our 
	 * timeout expires, we get a wakeup call from aio_work_thread().
	 */</span>

	error = msleep1(&amp;p-&gt;AIO_SUSPEND_SLEEP_CHAN, aio_proc_mutex(p), PCATCH | PWAIT | PDROP, <span class="enscript-string">&quot;aio_suspend&quot;</span>, abstime); <span class="enscript-comment">/* XXX better priority? */</span>
	<span class="enscript-keyword">if</span> ( error == 0 ) {
		<span class="enscript-comment">/* 
		 * got our wakeup call from aio_work_thread().
		 * Since we can get a wakeup on this channel from another thread in the 
		 * same process we head back up to make sure this is for the correct aiocbp.  
		 * If it is the correct aiocbp we will return from where we do the check 
		 * (see entryp-&gt;uaiocbp == aiocbp after check_for_our_aiocbp label)
		 * else we will fall out and just sleep again.  
		 */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">check_for_our_aiocbp</span>;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( error == EWOULDBLOCK ) {
		<span class="enscript-comment">/* our timeout expired */</span>
		error = EAGAIN;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* we were interrupted */</span>
		error = EINTR;
	}

<span class="enscript-reference">ExitThisRoutine</span>:
	<span class="enscript-keyword">if</span> ( aiocbpp != NULL )
		FREE( aiocbpp, M_TEMP );

	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_suspend)) | DBG_FUNC_END,
		     	  (<span class="enscript-type">int</span>)p, uap-&gt;nent, error, 0, 0 );
	
	<span class="enscript-keyword">return</span>( error );	

} <span class="enscript-comment">/* aio_suspend */</span>


<span class="enscript-comment">/* aio_write - asynchronously write uap-&gt;aiocbp-&gt;aio_nbytes bytes to the 
 * file descriptor (uap-&gt;aiocbp-&gt;aio_fildes) from the buffer 
 * (uap-&gt;aiocbp-&gt;aio_buf).
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">aio_write</span>(proc_t p, <span class="enscript-type">struct</span> aio_write_args *uap, <span class="enscript-type">int</span> *retval )
{
	<span class="enscript-type">int</span>			error;
	
	*retval = 0;
	
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_write)) | DBG_FUNC_START,
		     	  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, 0, 0, 0 );

	error = aio_queue_async_request( p, uap-&gt;aiocbp, AIO_WRITE );
	<span class="enscript-keyword">if</span> ( error != 0 )
		*retval = -1;

	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_write)) | DBG_FUNC_END,
		     	  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)uap-&gt;aiocbp, error, 0, 0 );
		
	<span class="enscript-keyword">return</span>( error );

} <span class="enscript-comment">/* aio_write */</span>


<span class="enscript-type">static</span> user_addr_t *
<span class="enscript-function-name">aio_copy_in_list</span>(proc_t procp, user_addr_t aiocblist, <span class="enscript-type">int</span> nent)
{
	user_addr_t	*aiocbpp;
	<span class="enscript-type">int</span>		i, result;

	<span class="enscript-comment">/* we reserve enough space for largest possible pointer size */</span>
	MALLOC( aiocbpp, user_addr_t *, (nent * <span class="enscript-keyword">sizeof</span>(user_addr_t)), M_TEMP, M_WAITOK );
	<span class="enscript-keyword">if</span> ( aiocbpp == NULL )
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

	<span class="enscript-comment">/* copyin our aiocb pointers from list */</span>
	result = copyin( aiocblist, aiocbpp, 
			proc_is64bit(procp) ? (nent * <span class="enscript-keyword">sizeof</span>(user64_addr_t))
					    : (nent * <span class="enscript-keyword">sizeof</span>(user32_addr_t)) );
	<span class="enscript-keyword">if</span> ( result) {
		FREE( aiocbpp, M_TEMP );
		aiocbpp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
	}

	<span class="enscript-comment">/*
	 * We depend on a list of user_addr_t's so we need to
	 * munge and expand when these pointers came from a
	 * 32-bit process
	 */</span>
	<span class="enscript-keyword">if</span> ( !proc_is64bit(procp) ) {
		<span class="enscript-comment">/* copy from last to first to deal with overlap */</span>
		user32_addr_t *my_ptrp = ((user32_addr_t *)aiocbpp) + (nent - 1);
		user_addr_t *my_addrp = aiocbpp + (nent - 1);

		<span class="enscript-keyword">for</span> (i = 0; i &lt; nent; i++, my_ptrp--, my_addrp--) {
			*my_addrp = (user_addr_t) (*my_ptrp);
		}
	}

<span class="enscript-reference">err</span>:
	<span class="enscript-keyword">return</span> (aiocbpp);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">aio_copy_in_sigev</span>(proc_t procp, user_addr_t sigp, <span class="enscript-type">struct</span> user_sigevent *sigev)
{
	<span class="enscript-type">int</span>	result = 0;

	<span class="enscript-keyword">if</span> (sigp == USER_ADDR_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * We need to munge aio_sigevent since it contains pointers.
	 * Since we do not know if sigev_value is an int or a ptr we do
	 * NOT cast the ptr to a user_addr_t.   This means if we send
	 * this info back to user space we need to remember sigev_value
	 * was not expanded for the 32-bit case.
	 *
	 * Notes:	 This does NOT affect us since we don't support
	 *		sigev_value yet in the aio context.
	 */</span>
	<span class="enscript-keyword">if</span> ( proc_is64bit(procp) ) {
		<span class="enscript-type">struct</span> user64_sigevent sigevent64;

		result = copyin( sigp, &amp;sigevent64, <span class="enscript-keyword">sizeof</span>(sigevent64) );
		<span class="enscript-keyword">if</span> ( result == 0 ) {
			sigev-&gt;sigev_notify = sigevent64.sigev_notify;
			sigev-&gt;sigev_signo = sigevent64.sigev_signo;
			sigev-&gt;sigev_value.size_equivalent.sival_int = sigevent64.sigev_value.size_equivalent.sival_int;
			sigev-&gt;sigev_notify_function = sigevent64.sigev_notify_function;
			sigev-&gt;sigev_notify_attributes = sigevent64.sigev_notify_attributes;
		}
		
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_sigevent sigevent32;

		result = copyin( sigp, &amp;sigevent32, <span class="enscript-keyword">sizeof</span>(sigevent32) );
		<span class="enscript-keyword">if</span> ( result == 0 ) {
			sigev-&gt;sigev_notify = sigevent32.sigev_notify;
			sigev-&gt;sigev_signo = sigevent32.sigev_signo;
			sigev-&gt;sigev_value.size_equivalent.sival_int = sigevent32.sigev_value.sival_int;
			sigev-&gt;sigev_notify_function = CAST_USER_ADDR_T(sigevent32.sigev_notify_function);
			sigev-&gt;sigev_notify_attributes = CAST_USER_ADDR_T(sigevent32.sigev_notify_attributes);
		}
	}

	<span class="enscript-keyword">if</span> ( result != 0 ) {
		result = EAGAIN;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/*
 * aio_enqueue_work
 *
 * Queue up the entry on the aio asynchronous work queue in priority order
 * based on the relative priority of the request.  We calculate the relative
 * priority using the nice value of the caller and the value
 *
 * Parameters:	procp			Process queueing the I/O
 *		entryp			The work queue entry being queued
 *
 * Returns:	(void)			No failure modes
 *
 * Notes:	This function is used for both lio_listio and aio
 *
 * XXX:		At some point, we may have to consider thread priority
 *		rather than process priority, but we don't maintain the
 *		adjusted priority for threads the POSIX way.
 *
 *
 * Called with proc locked.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">aio_enqueue_work</span>( proc_t procp, aio_workq_entry *entryp, <span class="enscript-type">int</span> proc_locked)
{
#<span class="enscript-reference">if</span> 0
	aio_workq_entry	*my_entryp;	<span class="enscript-comment">/* used for insertion sort */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0 */</span>
	aio_workq_t queue = aio_entry_workq(entryp);

	<span class="enscript-keyword">if</span> (proc_locked == 0) {
		aio_proc_lock(procp);
	}

	ASSERT_AIO_PROC_LOCK_OWNED(procp);

	<span class="enscript-comment">/* Onto proc queue */</span>
	TAILQ_INSERT_TAIL(&amp;procp-&gt;p_aio_activeq, entryp,  aio_proc_link);
	procp-&gt;p_aio_active_count++;
	procp-&gt;p_aio_total_count++;

	<span class="enscript-comment">/* And work queue */</span>
	aio_workq_lock_spin(queue);
	aio_workq_add_entry_locked(queue, entryp);
	waitq_wakeup64_one(&amp;queue-&gt;aioq_waitq, CAST_EVENT64_T(queue),
			   THREAD_AWAKENED, WAITQ_ALL_PRIORITIES);
	aio_workq_unlock(queue);
	
	<span class="enscript-keyword">if</span> (proc_locked == 0) {
		aio_proc_unlock(procp);
	}

#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * Procedure:
	 *
	 * (1)	The nice value is in the range PRIO_MIN..PRIO_MAX [-20..20]
	 * (2)	The normalized nice value is in the range 0..((2 * NZERO) - 1)
	 *	which is [0..39], with 0 not being used.  In nice values, the
	 *	lower the nice value, the higher the priority.
	 * (3)	The normalized scheduling prioritiy is the highest nice value
	 *	minus the current nice value.  In I/O scheduling priority, the
	 *	higher the value the lower the priority, so it is the inverse
	 *	of the nice value (the higher the number, the higher the I/O
	 *	priority).
	 * (4)	From the normalized scheduling priority, we subtract the
	 *	request priority to get the request priority value number;
	 *	this means that requests are only capable of depressing their
	 *	priority relative to other requests,
	 */</span>
	entryp-&gt;priority = (((2 * NZERO) - 1) - procp-&gt;p_nice);

	<span class="enscript-comment">/* only premit depressing the priority */</span>
	<span class="enscript-keyword">if</span> (entryp-&gt;aiocb.aio_reqprio &lt; 0)
		entryp-&gt;aiocb.aio_reqprio = 0;
	<span class="enscript-keyword">if</span> (entryp-&gt;aiocb.aio_reqprio &gt; 0) {
		entryp-&gt;priority -= entryp-&gt;aiocb.aio_reqprio;
		<span class="enscript-keyword">if</span> (entryp-&gt;priority &lt; 0)
			entryp-&gt;priority = 0;
	}

	<span class="enscript-comment">/* Insertion sort the entry; lowest -&gt;priority to highest */</span>
	TAILQ_FOREACH(my_entryp, &amp;aio_anchor.aio_async_workq, aio_workq_link) {
		<span class="enscript-keyword">if</span> ( entryp-&gt;priority &lt;= my_entryp-&gt;priority) {
			TAILQ_INSERT_BEFORE(my_entryp, entryp, aio_workq_link);
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span> (my_entryp == NULL)
		TAILQ_INSERT_TAIL( &amp;aio_anchor.aio_async_workq, entryp, aio_workq_link );
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0 */</span>
}


<span class="enscript-comment">/*
 * lio_listio - initiate a list of IO requests.  We process the list of
 * aiocbs either synchronously (mode == LIO_WAIT) or asynchronously
 * (mode == LIO_NOWAIT).
 *
 * The caller gets error and return status for each aiocb in the list
 * via aio_error and aio_return.  We must keep completed requests until
 * released by the aio_return call.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">lio_listio</span>(proc_t p, <span class="enscript-type">struct</span> lio_listio_args *uap, <span class="enscript-type">int</span> *retval )
{
	<span class="enscript-type">int</span>				i;
	<span class="enscript-type">int</span>				call_result;
	<span class="enscript-type">int</span>				result;
	<span class="enscript-type">int</span>				old_count;
	aio_workq_entry			**entryp_listp;
	user_addr_t			*aiocbpp;
	<span class="enscript-type">struct</span> user_sigevent		aiosigev;
	aio_lio_context		*lio_context;
	boolean_t 			free_context = FALSE;
	
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_listio)) | DBG_FUNC_START,
		     	  (<span class="enscript-type">int</span>)p, uap-&gt;nent, uap-&gt;mode, 0, 0 );
	
	entryp_listp = NULL;
	lio_context = NULL;
	aiocbpp = NULL;
	call_result = -1;
	*retval = -1;
	<span class="enscript-keyword">if</span> ( !(uap-&gt;mode == LIO_NOWAIT || uap-&gt;mode == LIO_WAIT) ) {
		call_result = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
	}

	<span class="enscript-keyword">if</span> ( uap-&gt;nent &lt; 1 || uap-&gt;nent &gt; AIO_LISTIO_MAX ) {
		call_result = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
	}
		
	<span class="enscript-comment">/* 
	 * allocate a list of aio_workq_entry pointers that we will use
	 * to queue up all our requests at once while holding our lock.
	 */</span>
	MALLOC( entryp_listp, <span class="enscript-type">void</span> *, (uap-&gt;nent * <span class="enscript-keyword">sizeof</span>(aio_workq_entry *)), M_TEMP, M_WAITOK );
	<span class="enscript-keyword">if</span> ( entryp_listp == NULL ) {
		call_result = EAGAIN;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
	}
	
	MALLOC( lio_context, aio_lio_context*, <span class="enscript-keyword">sizeof</span>(aio_lio_context), M_TEMP, M_WAITOK );
	<span class="enscript-keyword">if</span> ( lio_context == NULL ) {
		call_result = EAGAIN;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>	
	OSIncrementAtomic(&amp;lio_contexts_alloced);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	bzero(lio_context, <span class="enscript-keyword">sizeof</span>(aio_lio_context));
	
	aiocbpp = aio_copy_in_list(p, uap-&gt;aiocblist, uap-&gt;nent);
	<span class="enscript-keyword">if</span> ( aiocbpp == NULL ) {
		call_result = EAGAIN;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
	}

	<span class="enscript-comment">/*
	 * Use sigevent passed in to lio_listio for each of our calls, but
	 * only do completion notification after the last request completes.
	 */</span>
	bzero(&amp;aiosigev, <span class="enscript-keyword">sizeof</span>(aiosigev));
	<span class="enscript-comment">/* Only copy in an sigev if the user supplied one */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;sigp != USER_ADDR_NULL) {
		call_result = aio_copy_in_sigev(p, uap-&gt;sigp, &amp;aiosigev);
		<span class="enscript-keyword">if</span> ( call_result)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitRoutine</span>;
	}

	<span class="enscript-comment">/* process list of aio requests */</span>
	lio_context-&gt;io_issued = uap-&gt;nent;
	lio_context-&gt;io_waiter = uap-&gt;mode == LIO_WAIT ? 1 : 0; <span class="enscript-comment">/* Should it be freed by last AIO */</span>
	<span class="enscript-keyword">for</span> ( i = 0; i &lt; uap-&gt;nent; i++ ) {
		user_addr_t my_aiocbp; 
		aio_workq_entry		 		*entryp;
	
		*(entryp_listp + i) = NULL;
		my_aiocbp = *(aiocbpp + i);
		
		<span class="enscript-comment">/* NULL elements are legal so check for 'em */</span>
		<span class="enscript-keyword">if</span> ( my_aiocbp == USER_ADDR_NULL ) {
			aio_proc_lock_spin(p);
			lio_context-&gt;io_issued--;
			aio_proc_unlock(p);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* 
		 * We use lio_context to mark IO requests for delayed completion
		 * processing which means we wait until all IO requests in the
		 * group have completed before we either return to the caller
		 * when mode is LIO_WAIT or signal user when mode is LIO_NOWAIT.
		 *
		 * We use the address of the lio_context for this, since it is
		 * unique in the address space.
		 */</span>
		result = lio_create_entry( p, my_aiocbp, lio_context, (entryp_listp + i) );
		<span class="enscript-keyword">if</span> ( result != 0 &amp;&amp; call_result == -1 )
			call_result = result;
		
		<span class="enscript-comment">/* NULL elements are legal so check for 'em */</span>
		entryp = *(entryp_listp + i);
		<span class="enscript-keyword">if</span> ( entryp == NULL ) {
			aio_proc_lock_spin(p);
			lio_context-&gt;io_issued--;
			aio_proc_unlock(p);
			<span class="enscript-keyword">continue</span>;
		}
	
		<span class="enscript-keyword">if</span> ( uap-&gt;mode == LIO_NOWAIT ) {
			<span class="enscript-comment">/* Set signal hander, if any */</span>
			entryp-&gt;aiocb.aio_sigevent = aiosigev;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* flag that this thread blocks pending completion */</span>
			entryp-&gt;flags |= AIO_LIO_NOTIFY;
		}

		<span class="enscript-comment">/* check our aio limits to throttle bad or rude user land behavior */</span>
		old_count = aio_increment_total_count();

		aio_proc_lock_spin(p);
		<span class="enscript-keyword">if</span> ( old_count &gt;= aio_max_requests ||
			 aio_get_process_count( entryp-&gt;procp ) &gt;= aio_max_requests_per_process ||
			 is_already_queued( entryp-&gt;procp, entryp-&gt;uaiocbp ) == TRUE ) {
			
			lio_context-&gt;io_issued--;
			aio_proc_unlock(p);
	
			aio_decrement_total_count();

			<span class="enscript-keyword">if</span> ( call_result == -1 )
				call_result = EAGAIN;
			aio_free_request(entryp);
			entryp_listp[i] = NULL;
			<span class="enscript-keyword">continue</span>;
		}
		
		lck_mtx_convert_spin(aio_proc_mutex(p));
		aio_enqueue_work(p, entryp, 1);
		aio_proc_unlock(p);
		
		KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_work_queued)) | DBG_FUNC_NONE,
				  (<span class="enscript-type">int</span>)p, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, 0, 0, 0 );
	}

	<span class="enscript-keyword">switch</span>(uap-&gt;mode) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LIO_WAIT</span>:
		aio_proc_lock_spin(p);
		<span class="enscript-keyword">while</span> (lio_context-&gt;io_completed &lt; lio_context-&gt;io_issued) {
			result = msleep(lio_context, aio_proc_mutex(p), PCATCH | PRIBIO | PSPIN, <span class="enscript-string">&quot;lio_listio&quot;</span>, 0);
			
			<span class="enscript-comment">/* If we were interrupted, fail out (even if all finished) */</span>
			<span class="enscript-keyword">if</span> (result != 0) {
				call_result = EINTR;
				lio_context-&gt;io_waiter = 0;
				<span class="enscript-keyword">break</span>;
			} 
		}

		<span class="enscript-comment">/* If all IOs have finished must free it */</span>
		<span class="enscript-keyword">if</span> (lio_context-&gt;io_completed == lio_context-&gt;io_issued) {
			free_context = TRUE;
		} 

		aio_proc_unlock(p);
		<span class="enscript-keyword">break</span>;
		
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LIO_NOWAIT</span>:
		<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-comment">/* call_result == -1 means we had no trouble queueing up requests */</span>
	<span class="enscript-keyword">if</span> ( call_result == -1 ) {
		call_result = 0;
		*retval = 0;
	}

<span class="enscript-reference">ExitRoutine</span>:		
	<span class="enscript-keyword">if</span> ( entryp_listp != NULL )
		FREE( entryp_listp, M_TEMP );
	<span class="enscript-keyword">if</span> ( aiocbpp != NULL )
		FREE( aiocbpp, M_TEMP );
	<span class="enscript-keyword">if</span> ((lio_context != NULL) &amp;&amp; ((lio_context-&gt;io_issued == 0) || (free_context == TRUE))) {
		free_lio_context(lio_context);
	}
	
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_listio)) | DBG_FUNC_END,
		     	  (<span class="enscript-type">int</span>)p, call_result, 0, 0, 0 );
	
	<span class="enscript-keyword">return</span>( call_result );
	
} <span class="enscript-comment">/* lio_listio */</span>


<span class="enscript-comment">/*
 * aio worker thread.  this is where all the real work gets done.
 * we get a wake up call on sleep channel &amp;aio_anchor.aio_async_workq 
 * after new work is queued up.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">aio_work_thread</span>( <span class="enscript-type">void</span> )
{
	aio_workq_entry		 	*entryp;
	<span class="enscript-type">int</span> 			error;
	vm_map_t 		currentmap;
	vm_map_t 		oldmap = VM_MAP_NULL;
	task_t			oldaiotask = TASK_NULL;
	<span class="enscript-type">struct</span> uthread	*uthreadp = NULL;
	
	<span class="enscript-keyword">for</span>( ;; ) {
		<span class="enscript-comment">/* 
		 * returns with the entry ref'ed.
		 * sleeps until work is available. 
		 */</span>
		entryp = aio_get_some_work();         

		KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_worker_thread)) | DBG_FUNC_START,
				(<span class="enscript-type">int</span>)entryp-&gt;procp, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, entryp-&gt;flags, 0, 0 );

		<span class="enscript-comment">/*
		 * Assume the target's address space identity for the duration
		 * of the IO.  Note: don't need to have the entryp locked,
		 * because the proc and map don't change until it's freed.
		 */</span>
		currentmap = get_task_map( (current_proc())-&gt;task );
		<span class="enscript-keyword">if</span> ( currentmap != entryp-&gt;aio_map ) {
			uthreadp = (<span class="enscript-type">struct</span> uthread *) get_bsdthread_info(current_thread());
			oldaiotask = uthreadp-&gt;uu_aio_task;
			uthreadp-&gt;uu_aio_task = entryp-&gt;procp-&gt;task;
			oldmap = vm_map_switch( entryp-&gt;aio_map );
		}

		<span class="enscript-keyword">if</span> ( (entryp-&gt;flags &amp; AIO_READ) != 0 ) {
			error = do_aio_read( entryp );
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( (entryp-&gt;flags &amp; AIO_WRITE) != 0 ) {
			error = do_aio_write( entryp );
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( (entryp-&gt;flags &amp; (AIO_FSYNC | AIO_DSYNC)) != 0 ) {
			error = do_aio_fsync( entryp );
		}
		<span class="enscript-keyword">else</span> {
			printf( <span class="enscript-string">&quot;%s - unknown aio request - flags 0x%02X \n&quot;</span>, 
					__FUNCTION__, entryp-&gt;flags );
			error = EINVAL;
		}

		<span class="enscript-comment">/* Restore old map */</span>
		<span class="enscript-keyword">if</span> ( currentmap != entryp-&gt;aio_map ) {
			(<span class="enscript-type">void</span>) vm_map_switch( oldmap );
			uthreadp-&gt;uu_aio_task = oldaiotask;
		}

		KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_worker_thread)) | DBG_FUNC_END,
				(<span class="enscript-type">int</span>)entryp-&gt;procp, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, entryp-&gt;errorval, 
				entryp-&gt;returnval, 0 );

		
		<span class="enscript-comment">/* XXX COUNTS */</span>
		aio_entry_lock_spin(entryp);
		entryp-&gt;errorval = error;	
		aio_entry_unlock(entryp);

		<span class="enscript-comment">/* we're done with the IO request so pop it off the active queue and */</span>
		<span class="enscript-comment">/* push it on the done queue */</span>
		aio_proc_lock(entryp-&gt;procp);
		aio_proc_move_done_locked(entryp-&gt;procp, entryp);
		aio_proc_unlock(entryp-&gt;procp);

		OSDecrementAtomic(&amp;aio_anchor.aio_inflight_count);

		<span class="enscript-comment">/* remove our reference to the user land map. */</span>
		<span class="enscript-keyword">if</span> ( VM_MAP_NULL != entryp-&gt;aio_map ) {
			vm_map_t 		my_map;

			my_map = entryp-&gt;aio_map;
			entryp-&gt;aio_map = VM_MAP_NULL;
			vm_map_deallocate( my_map );
		}

		<span class="enscript-comment">/* Provide notifications */</span>
		do_aio_completion( entryp );

		<span class="enscript-comment">/* Will free if needed */</span>
		aio_entry_unref(entryp);

	} <span class="enscript-comment">/* for ( ;; ) */</span>

	<span class="enscript-comment">/* NOT REACHED */</span>
	
} <span class="enscript-comment">/* aio_work_thread */</span>


<span class="enscript-comment">/*
 * aio_get_some_work - get the next async IO request that is ready to be executed.
 * aio_fsync complicates matters a bit since we cannot do the fsync until all async
 * IO requests at the time the aio_fsync call came in have completed.
 * NOTE - AIO_LOCK must be held by caller
 */</span>
<span class="enscript-type">static</span> aio_workq_entry *
<span class="enscript-function-name">aio_get_some_work</span>( <span class="enscript-type">void</span> )
{
	aio_workq_entry		 		*entryp = NULL;
	aio_workq_t 				queue = NULL;

	<span class="enscript-comment">/* Just one queue for the moment.  In the future there will be many. */</span>
	queue = &amp;aio_anchor.aio_async_workqs[0];	
	aio_workq_lock_spin(queue);
	<span class="enscript-keyword">if</span> (queue-&gt;aioq_count == 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nowork</span>;
	}

	<span class="enscript-comment">/* 
	 * Hold the queue lock.
	 *
	 * pop some work off the work queue and add to our active queue
	 * Always start with the queue lock held. 
	 */</span>
	<span class="enscript-keyword">for</span>(;;) {
		<span class="enscript-comment">/* 
		 * Pull of of work queue.  Once it's off, it can't be cancelled,
		 * so we can take our ref once we drop the queue lock.
		 */</span>
		entryp = TAILQ_FIRST(&amp;queue-&gt;aioq_entries);

		<span class="enscript-comment">/* 
		 * If there's no work or only fsyncs that need delay, go to sleep 
		 * and then start anew from aio_work_thread 
		 */</span>
		<span class="enscript-keyword">if</span> (entryp == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nowork</span>;
		}

		aio_workq_remove_entry_locked(queue, entryp);
		
		aio_workq_unlock(queue);

		<span class="enscript-comment">/* 
		 * Check if it's an fsync that must be delayed.  No need to lock the entry;
		 * that flag would have been set at initialization.
		 */</span>
		<span class="enscript-keyword">if</span> ( (entryp-&gt;flags &amp; AIO_FSYNC) != 0 ) {
			<span class="enscript-comment">/* 
			 * Check for unfinished operations on the same file
			 * in this proc's queue.
			 */</span>
			aio_proc_lock_spin(entryp-&gt;procp);
			<span class="enscript-keyword">if</span> ( aio_delay_fsync_request( entryp ) ) {
				<span class="enscript-comment">/* It needs to be delayed.  Put it back on the end of the work queue */</span>
				KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_fsync_delay)) | DBG_FUNC_NONE,
							  (<span class="enscript-type">int</span>)entryp-&gt;procp, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, 0, 0, 0 );

				aio_proc_unlock(entryp-&gt;procp);

				aio_workq_lock_spin(queue);
				aio_workq_add_entry_locked(queue, entryp);
				<span class="enscript-keyword">continue</span>;
			} 
			aio_proc_unlock(entryp-&gt;procp);
		}
		
		<span class="enscript-keyword">break</span>;
	}

	aio_entry_ref(entryp);

	OSIncrementAtomic(&amp;aio_anchor.aio_inflight_count);
	<span class="enscript-keyword">return</span>( entryp );

<span class="enscript-reference">nowork</span>:
	<span class="enscript-comment">/* We will wake up when someone enqueues something */</span>
	waitq_assert_wait64(&amp;queue-&gt;aioq_waitq, CAST_EVENT64_T(queue), THREAD_UNINT, 0);
	aio_workq_unlock(queue);
	thread_block( (thread_continue_t)aio_work_thread );

	<span class="enscript-comment">// notreached
</span>	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * aio_delay_fsync_request - look to see if this aio_fsync request should be delayed.
 * A big, simple hammer: only send it off if it's the most recently filed IO which has
 * not been completed.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">aio_delay_fsync_request</span>( aio_workq_entry *entryp )
{
	<span class="enscript-keyword">if</span> (entryp == TAILQ_FIRST(&amp;entryp-&gt;procp-&gt;p_aio_activeq)) {
		<span class="enscript-keyword">return</span> FALSE;
	}
		
	<span class="enscript-keyword">return</span> TRUE;
} <span class="enscript-comment">/* aio_delay_fsync_request */</span>

<span class="enscript-type">static</span> aio_workq_entry *
<span class="enscript-function-name">aio_create_queue_entry</span>(proc_t procp, user_addr_t aiocbp, <span class="enscript-type">void</span> *group_tag, <span class="enscript-type">int</span> kindOfIO)
{
	aio_workq_entry	*entryp;
	<span class="enscript-type">int</span>		result = 0;

	entryp = (aio_workq_entry *) zalloc( aio_workq_zonep );
	<span class="enscript-keyword">if</span> ( entryp == NULL ) {
		result = EAGAIN; 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}

	bzero( entryp, <span class="enscript-keyword">sizeof</span>(*entryp) );

	<span class="enscript-comment">/* fill in the rest of the aio_workq_entry */</span>
	entryp-&gt;procp = procp;
	entryp-&gt;uaiocbp = aiocbp;
	entryp-&gt;flags |= kindOfIO;
	entryp-&gt;group_tag = group_tag;
	entryp-&gt;aio_map = VM_MAP_NULL;
	entryp-&gt;aio_refcount = 0;

	<span class="enscript-keyword">if</span> ( proc_is64bit(procp) ) {
		<span class="enscript-type">struct</span> user64_aiocb aiocb64;
		
		result = copyin( aiocbp, &amp;aiocb64, <span class="enscript-keyword">sizeof</span>(aiocb64) );
		<span class="enscript-keyword">if</span> (result == 0 )
			do_munge_aiocb_user64_to_user(&amp;aiocb64, &amp;entryp-&gt;aiocb);
		
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_aiocb aiocb32;
		
		result = copyin( aiocbp, &amp;aiocb32, <span class="enscript-keyword">sizeof</span>(aiocb32) );
		<span class="enscript-keyword">if</span> ( result == 0 )
			do_munge_aiocb_user32_to_user( &amp;aiocb32, &amp;entryp-&gt;aiocb );
	}

	<span class="enscript-keyword">if</span> ( result != 0 ) {
		result = EAGAIN;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}

	<span class="enscript-comment">/* get a reference to the user land map in order to keep it around */</span>
	entryp-&gt;aio_map = get_task_map( procp-&gt;task );
	vm_map_reference( entryp-&gt;aio_map );

	<span class="enscript-comment">/* do some more validation on the aiocb and embedded file descriptor */</span>
	result = aio_validate( entryp );
	<span class="enscript-keyword">if</span> ( result != 0 )
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit_with_ref</span>;

	<span class="enscript-comment">/* get a reference on the current_thread, which is passed in vfs_context. */</span>
	entryp-&gt;thread = current_thread();
	thread_reference( entryp-&gt;thread );
	<span class="enscript-keyword">return</span> ( entryp );

<span class="enscript-reference">error_exit_with_ref</span>:
	<span class="enscript-keyword">if</span> ( VM_MAP_NULL != entryp-&gt;aio_map ) {
		vm_map_deallocate( entryp-&gt;aio_map );
	}
<span class="enscript-reference">error_exit</span>:
	<span class="enscript-keyword">if</span> ( result &amp;&amp; entryp != NULL ) {
		zfree( aio_workq_zonep, entryp );
		entryp = NULL;
	}

	<span class="enscript-keyword">return</span> ( entryp );
}


<span class="enscript-comment">/*
 * aio_queue_async_request - queue up an async IO request on our work queue then
 * wake up one of our worker threads to do the actual work.  We get a reference
 * to our caller's user land map in order to keep it around while we are
 * processing the request. 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">aio_queue_async_request</span>(proc_t procp, user_addr_t aiocbp, <span class="enscript-type">int</span> kindOfIO )
{
	aio_workq_entry	*entryp;
	<span class="enscript-type">int</span>		result;
	<span class="enscript-type">int</span>		old_count;

	old_count = aio_increment_total_count();
	<span class="enscript-keyword">if</span> (old_count &gt;= aio_max_requests) {
		result = EAGAIN;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_noalloc</span>;
	}

	entryp = aio_create_queue_entry( procp, aiocbp, 0, kindOfIO);
	<span class="enscript-keyword">if</span> ( entryp == NULL ) {
		result = EAGAIN;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_noalloc</span>;
	}


	aio_proc_lock_spin(procp);

	<span class="enscript-keyword">if</span> ( is_already_queued( entryp-&gt;procp, entryp-&gt;uaiocbp ) == TRUE ) {
		result = EAGAIN; 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}

	<span class="enscript-comment">/* check our aio limits to throttle bad or rude user land behavior */</span>
	<span class="enscript-keyword">if</span> (aio_get_process_count( procp ) &gt;= aio_max_requests_per_process) {
		printf(<span class="enscript-string">&quot;aio_queue_async_request(): too many in flight for proc: %d.\n&quot;</span>, procp-&gt;p_aio_total_count);
		result = EAGAIN; 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}
	
	<span class="enscript-comment">/* Add the IO to proc and work queues, wake up threads as appropriate */</span>
	lck_mtx_convert_spin(aio_proc_mutex(procp));
	aio_enqueue_work(procp, entryp, 1);
	
	aio_proc_unlock(procp);
	
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_work_queued)) | DBG_FUNC_NONE,
		     	  (<span class="enscript-type">int</span>)procp, (<span class="enscript-type">int</span>)aiocbp, 0, 0, 0 );

	<span class="enscript-keyword">return</span>( 0 );
	
<span class="enscript-reference">error_exit</span>:
	<span class="enscript-comment">/*
	 * This entry has not been queued up so no worries about
	 * unlocked state and aio_map
	 */</span>
	aio_proc_unlock(procp);
	aio_free_request(entryp);

<span class="enscript-reference">error_noalloc</span>:
	aio_decrement_total_count();

	<span class="enscript-keyword">return</span>( result );
	
} <span class="enscript-comment">/* aio_queue_async_request */</span>


<span class="enscript-comment">/*
 * lio_create_entry
 *
 * Allocate an aio_workq_entry and fill it in.  If all goes well return 0
 * and pass the aio_workq_entry pointer back to our caller.
 *
 * Parameters:	procp			The process makign the request
 *		aiocbp			The aio context buffer pointer
 *		group_tag		The group tag used to indicate a
 *					group of operations has completed
 *		entrypp			Pointer to the pointer to receive the
 *					address of the created aio_workq_entry
 *
 * Returns:	0			Successfully created
 *		EAGAIN			Try again (usually resource shortage)
 *
 *
 * Notes:	We get a reference to our caller's user land map in order
 *		to keep it around while we are processing the request.  
 *
 *		lio_listio calls behave differently at completion they do
 *		completion notification when all async IO requests have
 *		completed.  We use group_tag to tag IO requests that behave
 *		in the delay notification manner. 
 *
 *		All synchronous operations are considered to not have a
 *		signal routine associated with them (sigp == USER_ADDR_NULL).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">lio_create_entry</span>(proc_t procp, user_addr_t aiocbp, <span class="enscript-type">void</span> *group_tag,
		aio_workq_entry **entrypp )
{
	aio_workq_entry	*entryp;
	<span class="enscript-type">int</span>		result;

	entryp = aio_create_queue_entry( procp, aiocbp, group_tag, AIO_LIO);
	<span class="enscript-keyword">if</span> ( entryp == NULL ) {
		result = EAGAIN; 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}

	<span class="enscript-comment">/*
	 * Look for lio_listio LIO_NOP requests and ignore them; this is
	 * not really an error, but we need to free our aio_workq_entry.
	 */</span>
	<span class="enscript-keyword">if</span> ( entryp-&gt;aiocb.aio_lio_opcode == LIO_NOP ) {
		result = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}

	*entrypp = entryp;
	<span class="enscript-keyword">return</span>( 0 );
	
<span class="enscript-reference">error_exit</span>:

	<span class="enscript-keyword">if</span> ( entryp != NULL ) {
		<span class="enscript-comment">/*
		 * This entry has not been queued up so no worries about
		 * unlocked state and aio_map
		 */</span>
		aio_free_request(entryp);
	}
		
	<span class="enscript-keyword">return</span>( result );
	
} <span class="enscript-comment">/* lio_create_entry */</span>


<span class="enscript-comment">/*
 * aio_free_request - remove our reference on the user land map and
 * free the work queue entry resources.  The entry is off all lists
 * and has zero refcount, so no one can have a pointer to it.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">aio_free_request</span>(aio_workq_entry *entryp)
{
	<span class="enscript-comment">/* remove our reference to the user land map. */</span>
	<span class="enscript-keyword">if</span> ( VM_MAP_NULL != entryp-&gt;aio_map) {
		vm_map_deallocate(entryp-&gt;aio_map);
	}

	<span class="enscript-comment">/* remove our reference to thread which enqueued the request */</span>
	<span class="enscript-keyword">if</span> ( NULL != entryp-&gt;thread ) {
		thread_deallocate( entryp-&gt;thread );
	}

	entryp-&gt;aio_refcount = -1; <span class="enscript-comment">/* A bit of poisoning in case of bad refcounting. */</span>
	
	zfree( aio_workq_zonep, entryp );

	<span class="enscript-keyword">return</span>( 0 );
	
} <span class="enscript-comment">/* aio_free_request */</span>


<span class="enscript-comment">/*
 * aio_validate
 *
 * validate the aiocb passed in by one of the aio syscalls.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">aio_validate</span>( aio_workq_entry *entryp ) 
{
	<span class="enscript-type">struct</span> fileproc 				*fp;
	<span class="enscript-type">int</span>							flag;
	<span class="enscript-type">int</span>							result;
	
	result = 0;

	<span class="enscript-keyword">if</span> ( (entryp-&gt;flags &amp; AIO_LIO) != 0 ) {
		<span class="enscript-keyword">if</span> ( entryp-&gt;aiocb.aio_lio_opcode == LIO_READ )
			entryp-&gt;flags |= AIO_READ;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( entryp-&gt;aiocb.aio_lio_opcode == LIO_WRITE )
			entryp-&gt;flags |= AIO_WRITE;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( entryp-&gt;aiocb.aio_lio_opcode == LIO_NOP )
			<span class="enscript-keyword">return</span>( 0 );
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span>( EINVAL );
	}

	flag = FREAD;
	<span class="enscript-keyword">if</span> ( (entryp-&gt;flags &amp; (AIO_WRITE | AIO_FSYNC | AIO_DSYNC)) != 0 ) {
		flag = FWRITE;
	}

	<span class="enscript-keyword">if</span> ( (entryp-&gt;flags &amp; (AIO_READ | AIO_WRITE)) != 0 ) {
		<span class="enscript-keyword">if</span> ( entryp-&gt;aiocb.aio_nbytes &gt; INT_MAX		||
			 entryp-&gt;aiocb.aio_buf == USER_ADDR_NULL ||
			 entryp-&gt;aiocb.aio_offset &lt; 0 )
			<span class="enscript-keyword">return</span>( EINVAL );
	}

	<span class="enscript-comment">/*
	 * validate aiocb.aio_sigevent.  at this point we only support
	 * sigev_notify equal to SIGEV_SIGNAL or SIGEV_NONE.  this means
	 * sigev_value, sigev_notify_function, and sigev_notify_attributes
	 * are ignored, since SIGEV_THREAD is unsupported.  This is consistent
	 * with no [RTS] (RalTime Signal) option group support.
	 */</span>
	<span class="enscript-keyword">switch</span> ( entryp-&gt;aiocb.aio_sigevent.sigev_notify ) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIGEV_SIGNAL</span>:
	    {
		<span class="enscript-type">int</span>		signum;

		<span class="enscript-comment">/* make sure we have a valid signal number */</span>
		signum = entryp-&gt;aiocb.aio_sigevent.sigev_signo;
		<span class="enscript-keyword">if</span> ( signum &lt;= 0 || signum &gt;= NSIG || 
			 signum == SIGKILL || signum == SIGSTOP )
			<span class="enscript-keyword">return</span> (EINVAL);
	    }
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIGEV_NONE</span>:
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIGEV_THREAD</span>:
		<span class="enscript-comment">/* Unsupported [RTS] */</span>

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	
	<span class="enscript-comment">/* validate the file descriptor and that the file was opened
	 * for the appropriate read / write access.
	 */</span>
	proc_fdlock(entryp-&gt;procp);

	result = fp_lookup( entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes, &amp;fp , 1);
	<span class="enscript-keyword">if</span> ( result == 0 ) {
		<span class="enscript-keyword">if</span> ( (fp-&gt;f_fglob-&gt;fg_flag &amp; flag) == 0 ) {
			<span class="enscript-comment">/* we don't have read or write access */</span>
			result = EBADF;
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( FILEGLOB_DTYPE(fp-&gt;f_fglob) != DTYPE_VNODE ) {
			<span class="enscript-comment">/* this is not a file */</span>
			result = ESPIPE;
		} <span class="enscript-keyword">else</span>
		        fp-&gt;f_flags |= FP_AIOISSUED;

		fp_drop(entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes, fp , 1);
	}
	<span class="enscript-keyword">else</span> {
		result = EBADF;
	}
	
	proc_fdunlock(entryp-&gt;procp);

	<span class="enscript-keyword">return</span>( result );

} <span class="enscript-comment">/* aio_validate */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">aio_increment_total_count</span>()
{
	<span class="enscript-keyword">return</span> OSIncrementAtomic(&amp;aio_anchor.aio_total_count);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 		
<span class="enscript-function-name">aio_decrement_total_count</span>()
{
	<span class="enscript-type">int</span> old = OSDecrementAtomic(&amp;aio_anchor.aio_total_count);
	<span class="enscript-keyword">if</span> (old &lt;= 0) {
		panic(<span class="enscript-string">&quot;Negative total AIO count!\n&quot;</span>);
	}

	<span class="enscript-keyword">return</span> old;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">aio_get_process_count</span>(proc_t procp ) 
{
	<span class="enscript-keyword">return</span> procp-&gt;p_aio_total_count;
	
} <span class="enscript-comment">/* aio_get_process_count */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">aio_get_all_queues_count</span>( <span class="enscript-type">void</span> ) 
{
	<span class="enscript-keyword">return</span> aio_anchor.aio_total_count;
	
} <span class="enscript-comment">/* aio_get_all_queues_count */</span>


<span class="enscript-comment">/*
 * do_aio_completion.  Handle async IO completion.  
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">do_aio_completion</span>( aio_workq_entry *entryp ) 
{

	boolean_t		lastLioCompleted = FALSE;
	aio_lio_context	*lio_context = NULL;
	<span class="enscript-type">int</span> waiter = 0;
	
	lio_context = (aio_lio_context *)entryp-&gt;group_tag;
	
	<span class="enscript-keyword">if</span> (lio_context != NULL) {
		
		aio_proc_lock_spin(entryp-&gt;procp);

		<span class="enscript-comment">/* Account for this I/O completing. */</span>
	 	lio_context-&gt;io_completed++;
		
		<span class="enscript-comment">/* Are we done with this lio context? */</span>
	 	<span class="enscript-keyword">if</span> (lio_context-&gt;io_issued == lio_context-&gt;io_completed) {
	 		lastLioCompleted = TRUE;
	 	}
		
		waiter = lio_context-&gt;io_waiter;
		
		<span class="enscript-comment">/* explicit wakeup of lio_listio() waiting in LIO_WAIT */</span>
		<span class="enscript-keyword">if</span> ((entryp-&gt;flags &amp; AIO_LIO_NOTIFY) &amp;&amp; (lastLioCompleted) &amp;&amp; (waiter != 0)) {
			<span class="enscript-comment">/* wake up the waiter */</span>
			wakeup(lio_context);
		}
		
		aio_proc_unlock(entryp-&gt;procp);
	}
	
	<span class="enscript-keyword">if</span> ( entryp-&gt;aiocb.aio_sigevent.sigev_notify == SIGEV_SIGNAL &amp;&amp;
		 (entryp-&gt;flags &amp; AIO_DISABLE) == 0 ) {
		
		boolean_t	performSignal = FALSE;
		 <span class="enscript-keyword">if</span> (lio_context == NULL) {
		 	performSignal = TRUE;
		 }
		 <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* 
			 * If this was the last request in the group and a signal
			 * is desired, send one.
			 */</span>
			performSignal = lastLioCompleted;
		 }
		 
		 <span class="enscript-keyword">if</span> (performSignal) {
		 	
			KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_completion_sig)) | DBG_FUNC_NONE,
				 (<span class="enscript-type">int</span>)entryp-&gt;procp, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, 
				 entryp-&gt;aiocb.aio_sigevent.sigev_signo, 0, 0 );
			
			psignal( entryp-&gt;procp, entryp-&gt;aiocb.aio_sigevent.sigev_signo );
		}
	}

	<span class="enscript-keyword">if</span> ((entryp-&gt;flags &amp; AIO_EXIT_WAIT) &amp;&amp; (entryp-&gt;flags &amp; AIO_CLOSE_WAIT)) {
		panic(<span class="enscript-string">&quot;Close and exit flags set at the same time\n&quot;</span>);
	}
	
	<span class="enscript-comment">/*
	 * need to handle case where a process is trying to exit, exec, or
	 * close and is currently waiting for active aio requests to complete.
	 * If AIO_CLEANUP_WAIT is set then we need to look to see if there are any 
	 * other requests in the active queue for this process.  If there are 
	 * none then wakeup using the AIO_CLEANUP_SLEEP_CHAN tsleep channel.
	 * If there are some still active then do nothing - we only want to
	 * wakeup when all active aio requests for the process are complete. 
	 *
	 * Don't need to lock the entry or proc to check the cleanup flag.  It can only be
	 * set for cancellation, while the entryp is still on a proc list; now it's 
	 * off, so that flag is already set if it's going to be.
	 */</span>
	<span class="enscript-keyword">if</span> ( (entryp-&gt;flags &amp; AIO_EXIT_WAIT) != 0 ) {
		<span class="enscript-type">int</span>		active_requests;

		KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_completion_cleanup_wait)) | DBG_FUNC_NONE,
					  (<span class="enscript-type">int</span>)entryp-&gt;procp, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, 0, 0, 0 );
		
		aio_proc_lock_spin(entryp-&gt;procp);
		active_requests = aio_active_requests_for_process( entryp-&gt;procp );
		<span class="enscript-keyword">if</span> ( active_requests &lt; 1 ) {
			<span class="enscript-comment">/* 
			 * no active aio requests for this process, continue exiting.  In this
			 * case, there should be no one else waiting ont he proc in AIO...
			 */</span>
			wakeup_one((caddr_t)&amp;entryp-&gt;procp-&gt;AIO_CLEANUP_SLEEP_CHAN);
			aio_proc_unlock(entryp-&gt;procp);

			KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_completion_cleanup_wake)) | DBG_FUNC_NONE,
					  	  (<span class="enscript-type">int</span>)entryp-&gt;procp, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, 0, 0, 0 );
		} <span class="enscript-keyword">else</span> {
			aio_proc_unlock(entryp-&gt;procp);
		}
	}
	
	<span class="enscript-keyword">if</span> ( (entryp-&gt;flags &amp; AIO_CLOSE_WAIT) != 0 ) {
		<span class="enscript-type">int</span>		active_requests;

		KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_completion_cleanup_wait)) | DBG_FUNC_NONE,
					  (<span class="enscript-type">int</span>)entryp-&gt;procp, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, 0, 0, 0 );
		
		aio_proc_lock_spin(entryp-&gt;procp);
		active_requests = aio_proc_active_requests_for_file( entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes);
		<span class="enscript-keyword">if</span> ( active_requests &lt; 1 ) {
			<span class="enscript-comment">/* Can't wakeup_one(); multiple closes might be in progress. */</span>
			wakeup(&amp;entryp-&gt;procp-&gt;AIO_CLEANUP_SLEEP_CHAN);
			aio_proc_unlock(entryp-&gt;procp);

			KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_completion_cleanup_wake)) | DBG_FUNC_NONE,
					  	  (<span class="enscript-type">int</span>)entryp-&gt;procp, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, 0, 0, 0 );
		} <span class="enscript-keyword">else</span> {
			aio_proc_unlock(entryp-&gt;procp);
		}
	}
	<span class="enscript-comment">/* 
	 * A thread in aio_suspend() wants to known about completed IOs.  If it checked
	 * the done list before we moved our AIO there, then it already asserted its wait,
	 * and we can wake it up without holding the lock.  If it checked the list after
	 * we did our move, then it already has seen the AIO that we moved.  Herego, we
	 * can do our wakeup without holding the lock.
	 */</span>
	wakeup( (caddr_t) &amp;entryp-&gt;procp-&gt;AIO_SUSPEND_SLEEP_CHAN ); 
	KERNEL_DEBUG( (BSDDBG_CODE(DBG_BSD_AIO, AIO_completion_suspend_wake)) | DBG_FUNC_NONE,
				  (<span class="enscript-type">int</span>)entryp-&gt;procp, (<span class="enscript-type">int</span>)entryp-&gt;uaiocbp, 0, 0, 0 );

	<span class="enscript-comment">/*   
	 * free the LIO context if the last lio completed and no thread is
	 * waiting
	 */</span>
	<span class="enscript-keyword">if</span> (lastLioCompleted &amp;&amp; (waiter == 0)) 
		free_lio_context (lio_context);

	
} <span class="enscript-comment">/* do_aio_completion */</span>


<span class="enscript-comment">/*
 * do_aio_read
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">do_aio_read</span>( aio_workq_entry *entryp )
{
	<span class="enscript-type">struct</span> fileproc		*fp;
	<span class="enscript-type">int</span>					error;
	<span class="enscript-type">struct</span> vfs_context	context;

	<span class="enscript-keyword">if</span> ( (error = fp_lookup(entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes, &amp;fp , 0)) )
		<span class="enscript-keyword">return</span>(error);
	<span class="enscript-keyword">if</span> ( (fp-&gt;f_fglob-&gt;fg_flag &amp; FREAD) == 0 ) {
		fp_drop(entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes, fp, 0);
		<span class="enscript-keyword">return</span>(EBADF);
	}

	context.vc_thread = entryp-&gt;thread;	<span class="enscript-comment">/* XXX */</span>
	context.vc_ucred = fp-&gt;f_fglob-&gt;fg_cred;

	error = dofileread(&amp;context, fp, 
				entryp-&gt;aiocb.aio_buf, 
				entryp-&gt;aiocb.aio_nbytes,
				entryp-&gt;aiocb.aio_offset, FOF_OFFSET, 
				&amp;entryp-&gt;returnval);
	fp_drop(entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes, fp, 0);
			
	<span class="enscript-keyword">return</span>( error );
	
} <span class="enscript-comment">/* do_aio_read */</span>


<span class="enscript-comment">/*
 * do_aio_write
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">do_aio_write</span>( aio_workq_entry *entryp )
{
	<span class="enscript-type">struct</span> fileproc 		*fp;
	<span class="enscript-type">int</span>				error, flags;
	<span class="enscript-type">struct</span> vfs_context		context;

	<span class="enscript-keyword">if</span> ( (error = fp_lookup(entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes, &amp;fp , 0)) )
		<span class="enscript-keyword">return</span>(error);
	<span class="enscript-keyword">if</span> ( (fp-&gt;f_fglob-&gt;fg_flag &amp; FWRITE) == 0 ) {
		fp_drop(entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes, fp, 0);
		<span class="enscript-keyword">return</span>(EBADF);
	}

	flags = FOF_PCRED;
	<span class="enscript-keyword">if</span> ( (fp-&gt;f_fglob-&gt;fg_flag &amp; O_APPEND) == 0 ) {
		flags |= FOF_OFFSET;
	}

	context.vc_thread = entryp-&gt;thread;	<span class="enscript-comment">/* XXX */</span>
	context.vc_ucred = fp-&gt;f_fglob-&gt;fg_cred;

	<span class="enscript-comment">/* NB: tell dofilewrite the offset, and to use the proc cred */</span>
	error = dofilewrite(&amp;context,
				fp,
				entryp-&gt;aiocb.aio_buf,
				entryp-&gt;aiocb.aio_nbytes,
				entryp-&gt;aiocb.aio_offset,
				flags,
				&amp;entryp-&gt;returnval);

	<span class="enscript-keyword">if</span> (entryp-&gt;returnval)
		fp_drop_written(entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes, fp);
	<span class="enscript-keyword">else</span>
		fp_drop(entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes, fp, 0);

	<span class="enscript-keyword">return</span>( error );

} <span class="enscript-comment">/* do_aio_write */</span>


<span class="enscript-comment">/*
 * aio_active_requests_for_process - return number of active async IO
 * requests for the given process.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">aio_active_requests_for_process</span>(proc_t procp )
{
	<span class="enscript-keyword">return</span>( procp-&gt;p_aio_active_count );

} <span class="enscript-comment">/* aio_active_requests_for_process */</span>

<span class="enscript-comment">/*
 * Called with the proc locked.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">aio_proc_active_requests_for_file</span>(proc_t procp, <span class="enscript-type">int</span> fd)
{
	<span class="enscript-type">int</span> count = 0;
	aio_workq_entry *entryp;
	TAILQ_FOREACH(entryp, &amp;procp-&gt;p_aio_activeq, aio_proc_link) {
		<span class="enscript-keyword">if</span> (entryp-&gt;aiocb.aio_fildes == fd) {
			count++;
		}
	}

	<span class="enscript-keyword">return</span> count;
} <span class="enscript-comment">/* aio_active_requests_for_process */</span>



<span class="enscript-comment">/*
 * do_aio_fsync
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">do_aio_fsync</span>( aio_workq_entry *entryp )
{
	<span class="enscript-type">struct</span> vfs_context 	context;
	<span class="enscript-type">struct</span> vnode 		*vp;
	<span class="enscript-type">struct</span> fileproc		*fp;
	<span class="enscript-type">int</span>			sync_flag;
	<span class="enscript-type">int</span>			error;

	<span class="enscript-comment">/*
	 * We are never called unless either AIO_FSYNC or AIO_DSYNC are set.
	 *
	 * If AIO_DSYNC is set, we can tell the lower layers that it is OK
	 * to mark for update the metadata not strictly necessary for data
	 * retrieval, rather than forcing it to disk.
	 *
	 * If AIO_FSYNC is set, we have to also wait for metadata not really
	 * necessary to data retrival are committed to stable storage (e.g.
	 * atime, mtime, ctime, etc.).
	 *
	 * Metadata necessary for data retrieval ust be committed to stable
	 * storage in either case (file length, etc.).
	 */</span>
	<span class="enscript-keyword">if</span> (entryp-&gt;flags &amp; AIO_FSYNC)
		sync_flag = MNT_WAIT;
	<span class="enscript-keyword">else</span>
		sync_flag = MNT_DWAIT;
	
	error = fp_getfvp( entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes, &amp;fp, &amp;vp);
	<span class="enscript-keyword">if</span> ( error == 0 ) {
		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		        fp_drop(entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes, fp, 0);
			entryp-&gt;returnval = -1;
			<span class="enscript-keyword">return</span>(error);
		}
		context.vc_thread = current_thread();
		context.vc_ucred = fp-&gt;f_fglob-&gt;fg_cred;

		error = VNOP_FSYNC( vp, sync_flag, &amp;context);

		(<span class="enscript-type">void</span>)vnode_put(vp);

		fp_drop(entryp-&gt;procp, entryp-&gt;aiocb.aio_fildes, fp, 0);
	}
	<span class="enscript-keyword">if</span> ( error != 0 )
		entryp-&gt;returnval = -1;

	<span class="enscript-keyword">return</span>( error );
		
} <span class="enscript-comment">/* do_aio_fsync */</span>


<span class="enscript-comment">/*
 * is_already_queued - runs through our queues to see if the given  
 * aiocbp / process is there.  Returns TRUE if there is a match
 * on any of our aio queues.
 *
 * Called with proc aio lock held (can be held spin)
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">is_already_queued</span>(proc_t procp, 
					user_addr_t aiocbp ) 
{
	aio_workq_entry		 	*entryp;
	boolean_t				result;
	
	result = FALSE;
		
	<span class="enscript-comment">/* look for matches on our queue of async IO requests that have completed */</span>
	TAILQ_FOREACH( entryp, &amp;procp-&gt;p_aio_doneq, aio_proc_link ) {
		<span class="enscript-keyword">if</span> ( aiocbp == entryp-&gt;uaiocbp ) {
			result = TRUE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
		}
	}
	
	<span class="enscript-comment">/* look for matches on our queue of active async IO requests */</span>
	TAILQ_FOREACH( entryp, &amp;procp-&gt;p_aio_activeq, aio_proc_link ) {
		<span class="enscript-keyword">if</span> ( aiocbp == entryp-&gt;uaiocbp ) {
			result = TRUE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
		}
	}
	
<span class="enscript-reference">ExitThisRoutine</span>:
	<span class="enscript-keyword">return</span>( result );
	
} <span class="enscript-comment">/* is_already_queued */</span>


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">free_lio_context</span>(aio_lio_context* context)
{

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>	
	OSDecrementAtomic(&amp;lio_contexts_alloced);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	FREE( context, M_TEMP );

} <span class="enscript-comment">/* free_lio_context */</span>


<span class="enscript-comment">/*
 * aio initialization
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">aio_init</span>( <span class="enscript-type">void</span> )
{
	<span class="enscript-type">int</span>			i;
	
	aio_lock_grp_attr = lck_grp_attr_alloc_init();
	aio_proc_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;aio_proc&quot;</span>, aio_lock_grp_attr);;
	aio_entry_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;aio_entry&quot;</span>, aio_lock_grp_attr);;
	aio_queue_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;aio_queue&quot;</span>, aio_lock_grp_attr);;
	aio_lock_attr = lck_attr_alloc_init();

	lck_mtx_init(&amp;aio_entry_mtx, aio_entry_lock_grp, aio_lock_attr);
	lck_mtx_init(&amp;aio_proc_mtx, aio_proc_lock_grp, aio_lock_attr);

	aio_anchor.aio_inflight_count = 0;
	aio_anchor.aio_done_count = 0;
	aio_anchor.aio_total_count = 0;
	aio_anchor.aio_num_workqs = AIO_NUM_WORK_QUEUES;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; AIO_NUM_WORK_QUEUES; i++) {
		aio_workq_init(&amp;aio_anchor.aio_async_workqs[i]);
	}


	i = <span class="enscript-keyword">sizeof</span>( aio_workq_entry );
	aio_workq_zonep = zinit( i, i * aio_max_requests, i * aio_max_requests, <span class="enscript-string">&quot;aiowq&quot;</span> );
		
	_aio_create_worker_threads( aio_worker_threads );
	
} <span class="enscript-comment">/* aio_init */</span>


<span class="enscript-comment">/*
 * aio worker threads created here.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">_aio_create_worker_threads</span>( <span class="enscript-type">int</span> num )
{
	<span class="enscript-type">int</span>			i;
	
	<span class="enscript-comment">/* create some worker threads to handle the async IO requests */</span>
	<span class="enscript-keyword">for</span> ( i = 0; i &lt; num; i++ ) {
		thread_t		myThread;
		
		<span class="enscript-keyword">if</span> ( KERN_SUCCESS != kernel_thread_start((thread_continue_t)aio_work_thread, NULL, &amp;myThread) ) {
			printf( <span class="enscript-string">&quot;%s - failed to create a work thread \n&quot;</span>, __FUNCTION__ ); 
		}
		<span class="enscript-keyword">else</span>
			thread_deallocate(myThread);
	}
	
	<span class="enscript-keyword">return</span>;
	
} <span class="enscript-comment">/* _aio_create_worker_threads */</span>

<span class="enscript-comment">/*
 * Return the current activation utask
 */</span>
task_t
<span class="enscript-function-name">get_aiotask</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>  ((<span class="enscript-type">struct</span> uthread *)get_bsdthread_info(current_thread()))-&gt;uu_aio_task;  
}


<span class="enscript-comment">/*
 * In the case of an aiocb from a
 * 32-bit process we need to expand some longs and pointers to the correct
 * sizes in order to let downstream code always work on the same type of
 * aiocb (in our case that is a user_aiocb)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">do_munge_aiocb_user32_to_user</span>( <span class="enscript-type">struct</span> user32_aiocb *my_aiocbp, <span class="enscript-type">struct</span> user_aiocb *the_user_aiocbp ) 
{
	the_user_aiocbp-&gt;aio_fildes = my_aiocbp-&gt;aio_fildes;
	the_user_aiocbp-&gt;aio_offset = my_aiocbp-&gt;aio_offset;
	the_user_aiocbp-&gt;aio_buf = CAST_USER_ADDR_T(my_aiocbp-&gt;aio_buf);
	the_user_aiocbp-&gt;aio_nbytes = my_aiocbp-&gt;aio_nbytes;
	the_user_aiocbp-&gt;aio_reqprio = my_aiocbp-&gt;aio_reqprio;
	the_user_aiocbp-&gt;aio_lio_opcode = my_aiocbp-&gt;aio_lio_opcode;

	<span class="enscript-comment">/* special case here.  since we do not know if sigev_value is an */</span>
	<span class="enscript-comment">/* int or a ptr we do NOT cast the ptr to a user_addr_t.   This  */</span>
	<span class="enscript-comment">/* means if we send this info back to user space we need to remember */</span>
	<span class="enscript-comment">/* sigev_value was not expanded for the 32-bit case.  */</span>
	<span class="enscript-comment">/* NOTE - this does NOT affect us since we don't support sigev_value */</span>
	<span class="enscript-comment">/* yet in the aio context.  */</span>
	<span class="enscript-comment">//LP64
</span>	the_user_aiocbp-&gt;aio_sigevent.sigev_notify = my_aiocbp-&gt;aio_sigevent.sigev_notify;
	the_user_aiocbp-&gt;aio_sigevent.sigev_signo = my_aiocbp-&gt;aio_sigevent.sigev_signo;
	the_user_aiocbp-&gt;aio_sigevent.sigev_value.size_equivalent.sival_int = 
		my_aiocbp-&gt;aio_sigevent.sigev_value.sival_int;
	the_user_aiocbp-&gt;aio_sigevent.sigev_notify_function = 
		CAST_USER_ADDR_T(my_aiocbp-&gt;aio_sigevent.sigev_notify_function);
	the_user_aiocbp-&gt;aio_sigevent.sigev_notify_attributes = 
		CAST_USER_ADDR_T(my_aiocbp-&gt;aio_sigevent.sigev_notify_attributes);
}

<span class="enscript-comment">/* Similar for 64-bit user process, so that we don't need to satisfy
 * the alignment constraints of the original user64_aiocb
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">do_munge_aiocb_user64_to_user</span>( <span class="enscript-type">struct</span> user64_aiocb *my_aiocbp, <span class="enscript-type">struct</span> user_aiocb *the_user_aiocbp ) 
{
	the_user_aiocbp-&gt;aio_fildes = my_aiocbp-&gt;aio_fildes;
	the_user_aiocbp-&gt;aio_offset = my_aiocbp-&gt;aio_offset;
	the_user_aiocbp-&gt;aio_buf = my_aiocbp-&gt;aio_buf;
	the_user_aiocbp-&gt;aio_nbytes = my_aiocbp-&gt;aio_nbytes;
	the_user_aiocbp-&gt;aio_reqprio = my_aiocbp-&gt;aio_reqprio;
	the_user_aiocbp-&gt;aio_lio_opcode = my_aiocbp-&gt;aio_lio_opcode;
	
	the_user_aiocbp-&gt;aio_sigevent.sigev_notify = my_aiocbp-&gt;aio_sigevent.sigev_notify;
	the_user_aiocbp-&gt;aio_sigevent.sigev_signo = my_aiocbp-&gt;aio_sigevent.sigev_signo;
	the_user_aiocbp-&gt;aio_sigevent.sigev_value.size_equivalent.sival_int = 
		my_aiocbp-&gt;aio_sigevent.sigev_value.size_equivalent.sival_int;
	the_user_aiocbp-&gt;aio_sigevent.sigev_notify_function = 
		my_aiocbp-&gt;aio_sigevent.sigev_notify_function;
	the_user_aiocbp-&gt;aio_sigevent.sigev_notify_attributes = 
		my_aiocbp-&gt;aio_sigevent.sigev_notify_attributes;
}
</pre>
<hr />
</body></html>