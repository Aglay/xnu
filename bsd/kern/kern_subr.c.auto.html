<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_subr.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_subr.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)kern_subr.c	8.3 (Berkeley) 1/21/94
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_UIO_COPYOUT</span> 16
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_UIO_COPYIN</span>  17

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/simple_lock.h&gt;</span>

<span class="enscript-type">static</span> uint32_t				uio_t_count = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_VALID_UIO_SEGFLG</span>(segflg)  \
	( (segflg) == UIO_USERSPACE || \
	  (segflg) == UIO_SYSSPACE || \
	  (segflg) == UIO_USERSPACE32 || \
	  (segflg) == UIO_USERSPACE64 || \
	  (segflg) == UIO_SYSSPACE32 || \
	  (segflg) == UIO_USERISPACE || \
	  (segflg) == UIO_PHYS_USERSPACE || \
	  (segflg) == UIO_PHYS_SYSSPACE || \
	  (segflg) == UIO_USERISPACE32 || \
	  (segflg) == UIO_PHYS_USERSPACE32 || \
	  (segflg) == UIO_USERISPACE64 || \
	  (segflg) == UIO_PHYS_USERSPACE64 )

<span class="enscript-comment">/*
 * Returns:	0			Success
 *	uiomove64:EFAULT
 *
 * Notes:	The first argument should be a caddr_t, but const poisoning
 *		for typedef'ed types doesn't work in gcc.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">uiomove</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * cp, <span class="enscript-type">int</span> n, uio_t uio)
{
	<span class="enscript-keyword">return</span> uiomove64((<span class="enscript-type">const</span> addr64_t)(uintptr_t)cp, n, uio);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		EFAULT
 *	copyout:EFAULT
 *	copyin:EFAULT
 *	copywithin:EFAULT
 *	copypv:EFAULT
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">uiomove64</span>(<span class="enscript-type">const</span> addr64_t c_cp, <span class="enscript-type">int</span> n, <span class="enscript-type">struct</span> uio *uio)
{
	addr64_t cp = c_cp;
	uint64_t acnt;
	<span class="enscript-type">int</span> error = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (uio-&gt;uio_rw != UIO_READ &amp;&amp; uio-&gt;uio_rw != UIO_WRITE)
		panic(<span class="enscript-string">&quot;uiomove: mode&quot;</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (IS_VALID_UIO_SEGFLG(uio-&gt;uio_segflg) == 0) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_segflg\n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">while</span> (n &gt; 0 &amp;&amp; uio_resid(uio)) {
		uio_update(uio, 0);
		acnt = uio_curriovlen(uio);
		<span class="enscript-keyword">if</span> (acnt == 0) {
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (n &gt; 0 &amp;&amp; acnt &gt; (uint64_t)n)
			acnt = n;

		<span class="enscript-keyword">switch</span> ((<span class="enscript-type">int</span>) uio-&gt;uio_segflg) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE64</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERISPACE64</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE32</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERISPACE32</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERISPACE</span>:
			<span class="enscript-comment">// LP64 - 3rd argument in debug code is 64 bit, expected to be 32 bit
</span>			<span class="enscript-keyword">if</span> (uio-&gt;uio_rw == UIO_READ)
			  {
			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, DBG_UIO_COPYOUT)) | DBG_FUNC_START,
					 (<span class="enscript-type">int</span>)cp, (uintptr_t)uio-&gt;uio_iovs.uiovp-&gt;iov_base, acnt, 0,0);

					error = copyout( CAST_DOWN(caddr_t, cp), uio-&gt;uio_iovs.uiovp-&gt;iov_base, acnt );

			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, DBG_UIO_COPYOUT)) | DBG_FUNC_END,
					 (<span class="enscript-type">int</span>)cp, (uintptr_t)uio-&gt;uio_iovs.uiovp-&gt;iov_base, acnt, 0,0);
			  }
			<span class="enscript-keyword">else</span>
			  {
			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, DBG_UIO_COPYIN)) | DBG_FUNC_START,
					 (uintptr_t)uio-&gt;uio_iovs.uiovp-&gt;iov_base, (<span class="enscript-type">int</span>)cp, acnt, 0,0);

			        error = copyin(uio-&gt;uio_iovs.uiovp-&gt;iov_base, CAST_DOWN(caddr_t, cp), acnt);

			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, DBG_UIO_COPYIN)) | DBG_FUNC_END,
					 (uintptr_t)uio-&gt;uio_iovs.uiovp-&gt;iov_base, (<span class="enscript-type">int</span>)cp, acnt, 0,0);
			  }
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_SYSSPACE32</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_SYSSPACE</span>:
			<span class="enscript-keyword">if</span> (uio-&gt;uio_rw == UIO_READ)
				error = copywithin(CAST_DOWN(caddr_t, cp), CAST_DOWN(caddr_t, uio-&gt;uio_iovs.kiovp-&gt;iov_base),
						   acnt);
			<span class="enscript-keyword">else</span>
				error = copywithin(CAST_DOWN(caddr_t, uio-&gt;uio_iovs.kiovp-&gt;iov_base), CAST_DOWN(caddr_t, cp),
						   acnt);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_PHYS_USERSPACE64</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_PHYS_USERSPACE32</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_PHYS_USERSPACE</span>:
			<span class="enscript-keyword">if</span> (uio-&gt;uio_rw == UIO_READ)
			  {
			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, DBG_UIO_COPYOUT)) | DBG_FUNC_START,
					 (<span class="enscript-type">int</span>)cp, (uintptr_t)uio-&gt;uio_iovs.uiovp-&gt;iov_base, acnt, 1,0);

				error = copypv((addr64_t)cp, uio-&gt;uio_iovs.uiovp-&gt;iov_base, acnt, cppvPsrc | cppvNoRefSrc);
				<span class="enscript-keyword">if</span> (error) 	<span class="enscript-comment">/* Copy physical to virtual */</span>
				        error = EFAULT;

			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, DBG_UIO_COPYOUT)) | DBG_FUNC_END,
					 (<span class="enscript-type">int</span>)cp, (uintptr_t)uio-&gt;uio_iovs.uiovp-&gt;iov_base, acnt, 1,0);
			  }
			<span class="enscript-keyword">else</span>
			  {
			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, DBG_UIO_COPYIN)) | DBG_FUNC_START,
					 (uintptr_t)uio-&gt;uio_iovs.uiovp-&gt;iov_base, (<span class="enscript-type">int</span>)cp, acnt, 1,0);

				error = copypv(uio-&gt;uio_iovs.uiovp-&gt;iov_base, (addr64_t)cp, acnt, cppvPsnk | cppvNoRefSrc | cppvNoModSnk);
				<span class="enscript-keyword">if</span> (error)	<span class="enscript-comment">/* Copy virtual to physical */</span>
				        error = EFAULT;

			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, DBG_UIO_COPYIN)) | DBG_FUNC_END,
					 (uintptr_t)uio-&gt;uio_iovs.uiovp-&gt;iov_base, (<span class="enscript-type">int</span>)cp, acnt, 1,0);
			  }
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_PHYS_SYSSPACE</span>:
			<span class="enscript-keyword">if</span> (uio-&gt;uio_rw == UIO_READ)
			  {
			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, DBG_UIO_COPYOUT)) | DBG_FUNC_START,
					 (<span class="enscript-type">int</span>)cp, (uintptr_t)uio-&gt;uio_iovs.kiovp-&gt;iov_base, acnt, 2,0);

					error = copypv((addr64_t)cp, uio-&gt;uio_iovs.kiovp-&gt;iov_base, acnt, cppvKmap | cppvPsrc | cppvNoRefSrc);
				<span class="enscript-keyword">if</span> (error) 	<span class="enscript-comment">/* Copy physical to virtual */</span>
				        error = EFAULT;

			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, DBG_UIO_COPYOUT)) | DBG_FUNC_END,
					 (<span class="enscript-type">int</span>)cp, (uintptr_t)uio-&gt;uio_iovs.kiovp-&gt;iov_base, acnt, 2,0);
			  }
			<span class="enscript-keyword">else</span>
			  {
			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, DBG_UIO_COPYIN)) | DBG_FUNC_START,
					 (uintptr_t)uio-&gt;uio_iovs.kiovp-&gt;iov_base, (<span class="enscript-type">int</span>)cp, acnt, 2,0);

					error = copypv(uio-&gt;uio_iovs.kiovp-&gt;iov_base, (addr64_t)cp, acnt, cppvKmap | cppvPsnk | cppvNoRefSrc | cppvNoModSnk);
				<span class="enscript-keyword">if</span> (error)	<span class="enscript-comment">/* Copy virtual to physical */</span>
				        error = EFAULT;

			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, DBG_UIO_COPYIN)) | DBG_FUNC_END,
					 (uintptr_t)uio-&gt;uio_iovs.kiovp-&gt;iov_base, (<span class="enscript-type">int</span>)cp, acnt, 2,0);
			  }
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
		uio_update(uio, acnt);
		cp += acnt;
		n -= acnt;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Give next character to user as result of read.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ureadc</span>(<span class="enscript-type">int</span> c, <span class="enscript-type">struct</span> uio *uio)
{
	<span class="enscript-keyword">if</span> (uio_resid(uio) &lt;= 0)
		panic(<span class="enscript-string">&quot;ureadc: non-positive resid&quot;</span>);
	uio_update(uio, 0);
	<span class="enscript-keyword">if</span> (uio-&gt;uio_iovcnt == 0)
		panic(<span class="enscript-string">&quot;ureadc: non-positive iovcnt&quot;</span>);
	<span class="enscript-keyword">if</span> (uio_curriovlen(uio) &lt;= 0)
		panic(<span class="enscript-string">&quot;ureadc: non-positive iovlen&quot;</span>);

	<span class="enscript-keyword">switch</span> ((<span class="enscript-type">int</span>) uio-&gt;uio_segflg) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERISPACE32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERISPACE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERISPACE64</span>:
		<span class="enscript-keyword">if</span> (subyte((user_addr_t)uio-&gt;uio_iovs.uiovp-&gt;iov_base, c) &lt; 0)
			<span class="enscript-keyword">return</span> (EFAULT);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_SYSSPACE32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_SYSSPACE</span>:
		*(CAST_DOWN(caddr_t, uio-&gt;uio_iovs.kiovp-&gt;iov_base)) = c;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
	uio_update(uio, 1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * General routine to allocate a hash table.
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">hashinit</span>(<span class="enscript-type">int</span> elements, <span class="enscript-type">int</span> type, u_long *hashmask)
{
	<span class="enscript-type">long</span> hashsize;
	LIST_HEAD(generic, generic) *hashtbl;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (elements &lt;= 0)
		panic(<span class="enscript-string">&quot;hashinit: bad cnt&quot;</span>);
	<span class="enscript-keyword">for</span> (hashsize = 1; hashsize &lt;= elements; hashsize &lt;&lt;= 1)
		<span class="enscript-keyword">continue</span>;
	hashsize &gt;&gt;= 1;
	MALLOC(hashtbl, <span class="enscript-type">struct</span> generic *, 
		hashsize * <span class="enscript-keyword">sizeof</span>(*hashtbl), type, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (hashtbl != NULL) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; hashsize; i++)
			LIST_INIT(&amp;hashtbl[i]);
		*hashmask = hashsize - 1;
	}
	<span class="enscript-keyword">return</span> (hashtbl);
}

<span class="enscript-comment">/*
 * uio_resid - return the residual IO value for the given uio_t
 */</span>
user_ssize_t <span class="enscript-function-name">uio_resid</span>( uio_t a_uio )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		printf(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
<span class="enscript-comment">/* 	if (IS_VALID_UIO_SEGFLG(a_uio-&gt;uio_segflg) == 0) { */</span>
<span class="enscript-comment">/* 		panic(&quot;%s :%d - invalid uio_segflg\n&quot;, __FILE__, __LINE__);  */</span>
<span class="enscript-comment">/* 	} */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	<span class="enscript-comment">/* return 0 if there are no active iovecs */</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		<span class="enscript-keyword">return</span>( 0 );
	}

	<span class="enscript-keyword">return</span>( a_uio-&gt;uio_resid_64 );
}

<span class="enscript-comment">/*
 * uio_setresid - set the residual IO value for the given uio_t
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">uio_setresid</span>( uio_t a_uio, user_ssize_t a_value )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
<span class="enscript-comment">/* 	if (IS_VALID_UIO_SEGFLG(a_uio-&gt;uio_segflg) == 0) { */</span>
<span class="enscript-comment">/* 		panic(&quot;%s :%d - invalid uio_segflg\n&quot;, __FILE__, __LINE__);  */</span>
<span class="enscript-comment">/* 	} */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		<span class="enscript-keyword">return</span>;
	}

	a_uio-&gt;uio_resid_64 = a_value;
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * uio_curriovbase - return the base address of the current iovec associated 
 *	with the given uio_t.  May return 0.
 */</span>
user_addr_t <span class="enscript-function-name">uio_curriovbase</span>( uio_t a_uio )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_uio == NULL || a_uio-&gt;uio_iovcnt &lt; 1) {
		<span class="enscript-keyword">return</span>(0);
	}
	
	<span class="enscript-keyword">if</span> (UIO_IS_USER_SPACE(a_uio)) {
		<span class="enscript-keyword">return</span>(a_uio-&gt;uio_iovs.uiovp-&gt;iov_base);
	}
	<span class="enscript-keyword">return</span>((user_addr_t)a_uio-&gt;uio_iovs.kiovp-&gt;iov_base);
	
}

<span class="enscript-comment">/*
 * uio_curriovlen - return the length value of the current iovec associated 
 *	with the given uio_t.
 */</span>
user_size_t <span class="enscript-function-name">uio_curriovlen</span>( uio_t a_uio )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_uio == NULL || a_uio-&gt;uio_iovcnt &lt; 1) {
		<span class="enscript-keyword">return</span>(0);
	}
	
	<span class="enscript-keyword">if</span> (UIO_IS_USER_SPACE(a_uio)) {
		<span class="enscript-keyword">return</span>(a_uio-&gt;uio_iovs.uiovp-&gt;iov_len);
	}
	<span class="enscript-keyword">return</span>((user_size_t)a_uio-&gt;uio_iovs.kiovp-&gt;iov_len);
}

<span class="enscript-comment">/*
 * uio_setcurriovlen - set the length value of the current iovec associated 
 *	with the given uio_t.
 */</span>
__private_extern__ <span class="enscript-type">void</span> uio_setcurriovlen( uio_t a_uio, user_size_t a_value )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		<span class="enscript-keyword">return</span>; 
	}

	<span class="enscript-keyword">if</span> (UIO_IS_USER_SPACE(a_uio)) {
		a_uio-&gt;uio_iovs.uiovp-&gt;iov_len = a_value;
	}
	<span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
		<span class="enscript-keyword">if</span> (a_value &gt; 0xFFFFFFFFull) {
			panic(<span class="enscript-string">&quot;%s :%d - invalid a_value\n&quot;</span>, __FILE__, __LINE__); 
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>
		a_uio-&gt;uio_iovs.kiovp-&gt;iov_len = (size_t)a_value;
	}
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * uio_iovcnt - return count of active iovecs for the given uio_t
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">uio_iovcnt</span>( uio_t a_uio )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		<span class="enscript-keyword">return</span>(0); 
	}

	<span class="enscript-keyword">return</span>( a_uio-&gt;uio_iovcnt );
}

<span class="enscript-comment">/*
 * uio_offset - return the current offset value for the given uio_t
 */</span>
off_t <span class="enscript-function-name">uio_offset</span>( uio_t a_uio )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		<span class="enscript-keyword">return</span>(0); 
	}
	<span class="enscript-keyword">return</span>( a_uio-&gt;uio_offset );
}

<span class="enscript-comment">/*
 * uio_setoffset - set the current offset value for the given uio_t
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">uio_setoffset</span>( uio_t a_uio, off_t a_offset )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		<span class="enscript-keyword">return</span>; 
	}
	a_uio-&gt;uio_offset = a_offset;
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * uio_rw - return the read / write flag for the given uio_t
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">uio_rw</span>( uio_t a_uio )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		<span class="enscript-keyword">return</span>(-1); 
	}
	<span class="enscript-keyword">return</span>( a_uio-&gt;uio_rw );
}

<span class="enscript-comment">/*
 * uio_setrw - set the read / write flag for the given uio_t
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">uio_setrw</span>( uio_t a_uio, <span class="enscript-type">int</span> a_value )
{
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>
		<span class="enscript-keyword">return</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (!(a_value == UIO_READ || a_value == UIO_WRITE)) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid a_value\n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_value == UIO_READ || a_value == UIO_WRITE) {
		a_uio-&gt;uio_rw = a_value;
	}
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * uio_isuserspace - return non zero value if the address space 
 * flag is for a user address space (could be 32 or 64 bit).
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">uio_isuserspace</span>( uio_t a_uio )
{
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>
		<span class="enscript-keyword">return</span>(0);
	}

	<span class="enscript-keyword">if</span> (UIO_SEG_IS_USER_SPACE(a_uio-&gt;uio_segflg)) {
		<span class="enscript-keyword">return</span>( 1 );
	}
	<span class="enscript-keyword">return</span>( 0 );
}


<span class="enscript-comment">/*
 * uio_create - create an uio_t.
 * 	Space is allocated to hold up to a_iovcount number of iovecs.  The uio_t
 *	is not fully initialized until all iovecs are added using uio_addiov calls.
 *	a_iovcount is the maximum number of iovecs you may add.
 */</span>
uio_t <span class="enscript-function-name">uio_create</span>( <span class="enscript-type">int</span> a_iovcount,		<span class="enscript-comment">/* number of iovecs */</span>
				  off_t a_offset,		<span class="enscript-comment">/* current offset */</span>
				  <span class="enscript-type">int</span> a_spacetype,		<span class="enscript-comment">/* type of address space */</span>
				  <span class="enscript-type">int</span> a_iodirection )	<span class="enscript-comment">/* read or write flag */</span>
{
	<span class="enscript-type">void</span> *				my_buf_p;
	size_t				my_size;
	uio_t				my_uio;
	
	my_size = UIO_SIZEOF(a_iovcount);
	my_buf_p = kalloc(my_size);
	my_uio = uio_createwithbuffer( a_iovcount, 
									 a_offset,
									 a_spacetype,
									 a_iodirection,
									 my_buf_p,
									 my_size );
	<span class="enscript-keyword">if</span> (my_uio != 0) {
		<span class="enscript-comment">/* leave a note that we allocated this uio_t */</span>
		my_uio-&gt;uio_flags |= UIO_FLAGS_WE_ALLOCED;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		(<span class="enscript-type">void</span>)hw_atomic_add(&amp;uio_t_count, 1);
#<span class="enscript-reference">endif</span>
	}
	
	<span class="enscript-keyword">return</span>( my_uio );
}


<span class="enscript-comment">/*
 * uio_createwithbuffer - create an uio_t.
 * 	Create a uio_t using the given buffer.  The uio_t
 *	is not fully initialized until all iovecs are added using uio_addiov calls.
 *	a_iovcount is the maximum number of iovecs you may add.
 *	This call may fail if the given buffer is not large enough.
 */</span>
__private_extern__ uio_t 
	uio_createwithbuffer( <span class="enscript-type">int</span> a_iovcount,		<span class="enscript-comment">/* number of iovecs */</span>
				  			off_t a_offset,		<span class="enscript-comment">/* current offset */</span>
				  			<span class="enscript-type">int</span> a_spacetype,	<span class="enscript-comment">/* type of address space */</span>
				 			<span class="enscript-type">int</span> a_iodirection,	<span class="enscript-comment">/* read or write flag */</span>
				 			<span class="enscript-type">void</span> *a_buf_p,		<span class="enscript-comment">/* pointer to a uio_t buffer */</span>
				 			size_t a_buffer_size )	<span class="enscript-comment">/* size of uio_t buffer */</span>
{
	uio_t				my_uio = (uio_t) a_buf_p;
	size_t				my_size;
	
	my_size = UIO_SIZEOF(a_iovcount);
	<span class="enscript-keyword">if</span> (a_buffer_size &lt; my_size) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		panic(<span class="enscript-string">&quot;%s :%d - a_buffer_size is too small\n&quot;</span>, __FILE__, __LINE__); 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
		<span class="enscript-keyword">return</span>( NULL );
	}
	my_size = a_buffer_size;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (my_uio == 0) {
		panic(<span class="enscript-string">&quot;%s :%d - could not allocate uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
	<span class="enscript-keyword">if</span> (!IS_VALID_UIO_SEGFLG(a_spacetype)) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid address space type\n&quot;</span>, __FILE__, __LINE__); 
	}
	<span class="enscript-keyword">if</span> (!(a_iodirection == UIO_READ || a_iodirection == UIO_WRITE)) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid IO direction flag\n&quot;</span>, __FILE__, __LINE__); 
	}
	<span class="enscript-keyword">if</span> (a_iovcount &gt; UIO_MAXIOV) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid a_iovcount\n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	bzero(my_uio, my_size);
	my_uio-&gt;uio_size = my_size;

	<span class="enscript-comment">/*
	 * we use uio_segflg to indicate if the uio_t is the new format or
	 * old (pre LP64 support) legacy format
	 * This switch statement should canonicalize incoming space type
	 * to one of UIO_USERSPACE32/64, UIO_PHYS_USERSPACE32/64, or
	 * UIO_SYSSPACE/UIO_PHYS_SYSSPACE
	 */</span>
	<span class="enscript-keyword">switch</span> (a_spacetype) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE</span>:
		my_uio-&gt;uio_segflg = UIO_USERSPACE32;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_SYSSPACE32</span>:
		my_uio-&gt;uio_segflg = UIO_SYSSPACE;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_PHYS_USERSPACE</span>:
		my_uio-&gt;uio_segflg = UIO_PHYS_USERSPACE32;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		my_uio-&gt;uio_segflg = a_spacetype;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (a_iovcount &gt; 0) {
		my_uio-&gt;uio_iovs.uiovp = (<span class="enscript-type">struct</span> user_iovec *)
			(((uint8_t *)my_uio) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> uio));
	}
	<span class="enscript-keyword">else</span> {
		my_uio-&gt;uio_iovs.uiovp = NULL;
	}

	my_uio-&gt;uio_max_iovs = a_iovcount;
	my_uio-&gt;uio_offset = a_offset;
	my_uio-&gt;uio_rw = a_iodirection;
	my_uio-&gt;uio_flags = UIO_FLAGS_INITED;

	<span class="enscript-keyword">return</span>( my_uio );
}

<span class="enscript-comment">/*
 * uio_spacetype - return the address space type for the given uio_t
 */</span>
__private_extern__ <span class="enscript-type">int</span> uio_spacetype( uio_t a_uio )
{
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>
		<span class="enscript-keyword">return</span>(-1);
	}

	<span class="enscript-keyword">return</span>( a_uio-&gt;uio_segflg );
}

<span class="enscript-comment">/*
 * uio_iovsaddr - get the address of the iovec array for the given uio_t.
 * This returns the location of the iovecs within the uio.
 * NOTE - for compatibility mode we just return the current value in uio_iovs
 * which will increase as the IO is completed and is NOT embedded within the
 * uio, it is a seperate array of one or more iovecs.
 */</span>
__private_extern__ <span class="enscript-type">struct</span> user_iovec * uio_iovsaddr( uio_t a_uio )
{
	<span class="enscript-type">struct</span> user_iovec *		my_addr;
	
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		<span class="enscript-keyword">return</span>(NULL);
	}
	
	<span class="enscript-keyword">if</span> (UIO_SEG_IS_USER_SPACE(a_uio-&gt;uio_segflg)) {
		<span class="enscript-comment">/* we need this for compatibility mode. */</span>
		my_addr = (<span class="enscript-type">struct</span> user_iovec *) a_uio-&gt;uio_iovs.uiovp;
	}
	<span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		panic(<span class="enscript-string">&quot;uio_iovsaddr called for UIO_SYSSPACE request&quot;</span>);
#<span class="enscript-reference">endif</span>
		my_addr = 0;
	}
	<span class="enscript-keyword">return</span>(my_addr);
}

<span class="enscript-comment">/*
 * uio_reset - reset an uio_t.
 * 	Reset the given uio_t to initial values.  The uio_t is not fully initialized
 * 	until all iovecs are added using uio_addiov calls.
 *	The a_iovcount value passed in the uio_create is the maximum number of 
 *	iovecs you may add.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">uio_reset</span>( uio_t a_uio,
				off_t a_offset,			<span class="enscript-comment">/* current offset */</span>
				<span class="enscript-type">int</span> a_spacetype,		<span class="enscript-comment">/* type of address space */</span>
				<span class="enscript-type">int</span> a_iodirection )		<span class="enscript-comment">/* read or write flag */</span>
{
	vm_size_t	my_size;
	<span class="enscript-type">int</span>			my_max_iovs;
	u_int32_t	my_old_flags;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		panic(<span class="enscript-string">&quot;%s :%d - could not allocate uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
	<span class="enscript-keyword">if</span> (!IS_VALID_UIO_SEGFLG(a_spacetype)) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid address space type\n&quot;</span>, __FILE__, __LINE__); 
	}
	<span class="enscript-keyword">if</span> (!(a_iodirection == UIO_READ || a_iodirection == UIO_WRITE)) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid IO direction flag\n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		<span class="enscript-keyword">return</span>;
	}

	my_size = a_uio-&gt;uio_size;
	my_old_flags = a_uio-&gt;uio_flags;
	my_max_iovs = a_uio-&gt;uio_max_iovs;
	bzero(a_uio, my_size);
	a_uio-&gt;uio_size = my_size;

	<span class="enscript-comment">/*
	 * we use uio_segflg to indicate if the uio_t is the new format or
	 * old (pre LP64 support) legacy format
	 * This switch statement should canonicalize incoming space type
	 * to one of UIO_USERSPACE32/64, UIO_PHYS_USERSPACE32/64, or
	 * UIO_SYSSPACE/UIO_PHYS_SYSSPACE
	 */</span>
	<span class="enscript-keyword">switch</span> (a_spacetype) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE</span>:
		a_uio-&gt;uio_segflg = UIO_USERSPACE32;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_SYSSPACE32</span>:
		a_uio-&gt;uio_segflg = UIO_SYSSPACE;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_PHYS_USERSPACE</span>:
		a_uio-&gt;uio_segflg = UIO_PHYS_USERSPACE32;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		a_uio-&gt;uio_segflg = a_spacetype;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (my_max_iovs &gt; 0) {
		a_uio-&gt;uio_iovs.uiovp = (<span class="enscript-type">struct</span> user_iovec *)
			(((uint8_t *)a_uio) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> uio));
	}
	<span class="enscript-keyword">else</span> {
		a_uio-&gt;uio_iovs.uiovp = NULL;
	}

	a_uio-&gt;uio_max_iovs = my_max_iovs;
	a_uio-&gt;uio_offset = a_offset;
	a_uio-&gt;uio_rw = a_iodirection;
	a_uio-&gt;uio_flags = my_old_flags;

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * uio_free - free a uio_t allocated via uio_init.  this also frees all
 * 	associated iovecs.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">uio_free</span>( uio_t a_uio ) 
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		panic(<span class="enscript-string">&quot;%s :%d - passing NULL uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_uio != NULL &amp;&amp; (a_uio-&gt;uio_flags &amp; UIO_FLAGS_WE_ALLOCED) != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">if</span> (hw_atomic_sub(&amp;uio_t_count, 1) == UINT_MAX)
			panic(<span class="enscript-string">&quot;%s :%d - uio_t_count underflow\n&quot;</span>, __FILE__, __LINE__); 
#<span class="enscript-reference">endif</span>
		kfree(a_uio, a_uio-&gt;uio_size);
	}


}

<span class="enscript-comment">/*
 * uio_addiov - add an iovec to the given uio_t.  You may call this up to
 * 	the a_iovcount number that was passed to uio_create.  This call will 
 * 	increment the residual IO count as iovecs are added to the uio_t.
 *	returns 0 if add was successful else non zero.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">uio_addiov</span>( uio_t a_uio, user_addr_t a_baseaddr, user_size_t a_length )
{
	<span class="enscript-type">int</span>			i;
	
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>
		<span class="enscript-keyword">return</span>(-1);
	}

	<span class="enscript-keyword">if</span> (UIO_IS_USER_SPACE(a_uio)) {
		<span class="enscript-keyword">for</span> ( i = 0; i &lt; a_uio-&gt;uio_max_iovs; i++ ) {
			<span class="enscript-keyword">if</span> (a_uio-&gt;uio_iovs.uiovp[i].iov_len == 0 &amp;&amp; a_uio-&gt;uio_iovs.uiovp[i].iov_base == 0) {
				a_uio-&gt;uio_iovs.uiovp[i].iov_len = a_length;
				a_uio-&gt;uio_iovs.uiovp[i].iov_base = a_baseaddr;
				a_uio-&gt;uio_iovcnt++;
				a_uio-&gt;uio_resid_64 += a_length;
				<span class="enscript-keyword">return</span>( 0 );
			}
		}
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">for</span> ( i = 0; i &lt; a_uio-&gt;uio_max_iovs; i++ ) {
			<span class="enscript-keyword">if</span> (a_uio-&gt;uio_iovs.kiovp[i].iov_len == 0 &amp;&amp; a_uio-&gt;uio_iovs.kiovp[i].iov_base == 0) {
				a_uio-&gt;uio_iovs.kiovp[i].iov_len = (u_int64_t)a_length;
				a_uio-&gt;uio_iovs.kiovp[i].iov_base = (u_int64_t)a_baseaddr;
				a_uio-&gt;uio_iovcnt++;
				a_uio-&gt;uio_resid_64 += a_length;
				<span class="enscript-keyword">return</span>( 0 );
			}
		}
	}

	<span class="enscript-keyword">return</span>( -1 );
}

<span class="enscript-comment">/*
 * uio_getiov - get iovec data associated with the given uio_t.  Use
 *  a_index to iterate over each iovec (0 to (uio_iovcnt(uio_t) - 1)).
 *  a_baseaddr_p and a_length_p may be NULL.
 * 	returns -1 when a_index is &gt;= uio_t.uio_iovcnt or invalid uio_t. 
 *	returns 0 when data is returned.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">uio_getiov</span>( uio_t a_uio, 
                 <span class="enscript-type">int</span> a_index, 
                 user_addr_t * a_baseaddr_p, 
                 user_size_t * a_length_p )
{
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
		<span class="enscript-keyword">return</span>(-1);
	}
    <span class="enscript-keyword">if</span> ( a_index &lt; 0 || a_index &gt;= a_uio-&gt;uio_iovcnt) {
		<span class="enscript-keyword">return</span>(-1);
    }

	<span class="enscript-keyword">if</span> (UIO_IS_USER_SPACE(a_uio)) {
        <span class="enscript-keyword">if</span> (a_baseaddr_p != NULL) {
            *a_baseaddr_p = a_uio-&gt;uio_iovs.uiovp[a_index].iov_base;
        }
        <span class="enscript-keyword">if</span> (a_length_p != NULL) {
            *a_length_p = a_uio-&gt;uio_iovs.uiovp[a_index].iov_len;
        }
	}
	<span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> (a_baseaddr_p != NULL) {
            *a_baseaddr_p = a_uio-&gt;uio_iovs.kiovp[a_index].iov_base;
        }
        <span class="enscript-keyword">if</span> (a_length_p != NULL) {
            *a_length_p = a_uio-&gt;uio_iovs.kiovp[a_index].iov_len;
        }
	}

    <span class="enscript-keyword">return</span>( 0 );
}

<span class="enscript-comment">/*
 * uio_calculateresid - runs through all iovecs associated with this
 *	uio_t and calculates (and sets) the residual IO count.
 */</span>
__private_extern__ <span class="enscript-type">int</span> uio_calculateresid( uio_t a_uio )
{
	<span class="enscript-type">int</span>			i;
	u_int64_t		resid = 0;
	
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>
		<span class="enscript-keyword">return</span> EINVAL;
	}

	a_uio-&gt;uio_iovcnt = a_uio-&gt;uio_max_iovs;
	<span class="enscript-keyword">if</span> (UIO_IS_USER_SPACE(a_uio)) {
		a_uio-&gt;uio_resid_64 = 0;
		<span class="enscript-keyword">for</span> ( i = 0; i &lt; a_uio-&gt;uio_max_iovs; i++ ) {
			<span class="enscript-keyword">if</span> (a_uio-&gt;uio_iovs.uiovp[i].iov_len != 0 &amp;&amp; a_uio-&gt;uio_iovs.uiovp[i].iov_base != 0) {
				<span class="enscript-keyword">if</span> (a_uio-&gt;uio_iovs.uiovp[i].iov_len &gt; LONG_MAX)
					<span class="enscript-keyword">return</span> EINVAL; 
				resid += a_uio-&gt;uio_iovs.uiovp[i].iov_len;
				<span class="enscript-keyword">if</span> (resid &gt; LONG_MAX)
					<span class="enscript-keyword">return</span> EINVAL;
			}
		}
		a_uio-&gt;uio_resid_64 = resid;

		<span class="enscript-comment">/* position to first non zero length iovec (4235922) */</span>
		<span class="enscript-keyword">while</span> (a_uio-&gt;uio_iovcnt &gt; 0 &amp;&amp; a_uio-&gt;uio_iovs.uiovp-&gt;iov_len == 0) {
			a_uio-&gt;uio_iovcnt--;
			<span class="enscript-keyword">if</span> (a_uio-&gt;uio_iovcnt &gt; 0) {
				a_uio-&gt;uio_iovs.uiovp++;
			}
		}
	}
	<span class="enscript-keyword">else</span> {
		a_uio-&gt;uio_resid_64 = 0;
		<span class="enscript-keyword">for</span> ( i = 0; i &lt; a_uio-&gt;uio_max_iovs; i++ ) {
			<span class="enscript-keyword">if</span> (a_uio-&gt;uio_iovs.kiovp[i].iov_len != 0 &amp;&amp; a_uio-&gt;uio_iovs.kiovp[i].iov_base != 0) {
				<span class="enscript-keyword">if</span> (a_uio-&gt;uio_iovs.kiovp[i].iov_len &gt; LONG_MAX)
					<span class="enscript-keyword">return</span> EINVAL;
				resid += a_uio-&gt;uio_iovs.kiovp[i].iov_len;
				<span class="enscript-keyword">if</span> (resid &gt; LONG_MAX)
					<span class="enscript-keyword">return</span> EINVAL;
			}
		}
		a_uio-&gt;uio_resid_64 = resid;

		<span class="enscript-comment">/* position to first non zero length iovec (4235922) */</span>
		<span class="enscript-keyword">while</span> (a_uio-&gt;uio_iovcnt &gt; 0 &amp;&amp; a_uio-&gt;uio_iovs.kiovp-&gt;iov_len == 0) {
			a_uio-&gt;uio_iovcnt--;
			<span class="enscript-keyword">if</span> (a_uio-&gt;uio_iovcnt &gt; 0) {
				a_uio-&gt;uio_iovs.kiovp++;
			}
		}
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * uio_update - update the given uio_t for a_count of completed IO.
 *	This call decrements the current iovec length and residual IO value
 *	and increments the current iovec base address and offset value. 
 *	If the current iovec length is 0 then advance to the next
 *	iovec (if any).
 * 	If the a_count passed in is 0, than only do the advancement
 *	over any 0 length iovec's.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">uio_update</span>( uio_t a_uio, user_size_t a_count )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
	<span class="enscript-keyword">if</span> (UIO_IS_32_BIT_SPACE(a_uio) &amp;&amp; a_count &gt; 0xFFFFFFFFull) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid count value \n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_uio == NULL || a_uio-&gt;uio_iovcnt &lt; 1) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (UIO_IS_USER_SPACE(a_uio)) {
	        <span class="enscript-comment">/*
		 * if a_count == 0, then we are asking to skip over
		 * any empty iovs
		 */</span>
	        <span class="enscript-keyword">if</span> (a_count) {
		        <span class="enscript-keyword">if</span> (a_count &gt; a_uio-&gt;uio_iovs.uiovp-&gt;iov_len) {
			        a_uio-&gt;uio_iovs.uiovp-&gt;iov_base += a_uio-&gt;uio_iovs.uiovp-&gt;iov_len;
				a_uio-&gt;uio_iovs.uiovp-&gt;iov_len = 0;
			}
			<span class="enscript-keyword">else</span> {
				a_uio-&gt;uio_iovs.uiovp-&gt;iov_base += a_count;
				a_uio-&gt;uio_iovs.uiovp-&gt;iov_len -= a_count;
			}
			<span class="enscript-keyword">if</span> (a_count &gt; (user_size_t)a_uio-&gt;uio_resid_64) {
				a_uio-&gt;uio_offset += a_uio-&gt;uio_resid_64;
				a_uio-&gt;uio_resid_64 = 0;
			}
			<span class="enscript-keyword">else</span> {
				a_uio-&gt;uio_offset += a_count;
				a_uio-&gt;uio_resid_64 -= a_count;
			}
		}
		<span class="enscript-comment">/*
		 * advance to next iovec if current one is totally consumed
		 */</span>
		<span class="enscript-keyword">while</span> (a_uio-&gt;uio_iovcnt &gt; 0 &amp;&amp; a_uio-&gt;uio_iovs.uiovp-&gt;iov_len == 0) {
			a_uio-&gt;uio_iovcnt--;
			<span class="enscript-keyword">if</span> (a_uio-&gt;uio_iovcnt &gt; 0) {
				a_uio-&gt;uio_iovs.uiovp++;
			}
		}
	}
	<span class="enscript-keyword">else</span> {
	        <span class="enscript-comment">/*
		 * if a_count == 0, then we are asking to skip over
		 * any empty iovs
		 */</span>
	        <span class="enscript-keyword">if</span> (a_count) {
		        <span class="enscript-keyword">if</span> (a_count &gt; a_uio-&gt;uio_iovs.kiovp-&gt;iov_len) {
			        a_uio-&gt;uio_iovs.kiovp-&gt;iov_base += a_uio-&gt;uio_iovs.kiovp-&gt;iov_len;
				a_uio-&gt;uio_iovs.kiovp-&gt;iov_len = 0;
			}
			<span class="enscript-keyword">else</span> {
			        a_uio-&gt;uio_iovs.kiovp-&gt;iov_base += a_count;
				a_uio-&gt;uio_iovs.kiovp-&gt;iov_len -= a_count;
			}
			<span class="enscript-keyword">if</span> (a_count &gt; (user_size_t)a_uio-&gt;uio_resid_64) {
				a_uio-&gt;uio_offset += a_uio-&gt;uio_resid_64;
				a_uio-&gt;uio_resid_64 = 0;
			}
			<span class="enscript-keyword">else</span> {
				a_uio-&gt;uio_offset += a_count;
				a_uio-&gt;uio_resid_64 -= a_count;
			}
		}
		<span class="enscript-comment">/*
		 * advance to next iovec if current one is totally consumed
		 */</span>
		<span class="enscript-keyword">while</span> (a_uio-&gt;uio_iovcnt &gt; 0 &amp;&amp; a_uio-&gt;uio_iovs.kiovp-&gt;iov_len == 0) {
			a_uio-&gt;uio_iovcnt--;
			<span class="enscript-keyword">if</span> (a_uio-&gt;uio_iovcnt &gt; 0) {
				a_uio-&gt;uio_iovs.kiovp++;
			}
		}
	}
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * uio_pushback - undo uncommitted I/O by subtracting from the
 * current base address and offset, and incrementing the residiual
 * IO. If the UIO was previously exhausted, this call will panic.
 * New code should not use this functionality.
 */</span>
__private_extern__ <span class="enscript-type">void</span> uio_pushback( uio_t a_uio, user_size_t a_count )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid uio_t\n&quot;</span>, __FILE__, __LINE__); 
	}
	<span class="enscript-keyword">if</span> (UIO_IS_32_BIT_SPACE(a_uio) &amp;&amp; a_count &gt; 0xFFFFFFFFull) {
		panic(<span class="enscript-string">&quot;%s :%d - invalid count value \n&quot;</span>, __FILE__, __LINE__); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>

	<span class="enscript-keyword">if</span> (a_uio == NULL || a_count == 0) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (a_uio-&gt;uio_iovcnt &lt; 1) {
		panic(<span class="enscript-string">&quot;Invalid uio for pushback&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (UIO_IS_USER_SPACE(a_uio)) {
		a_uio-&gt;uio_iovs.uiovp-&gt;iov_base -= a_count;
		a_uio-&gt;uio_iovs.uiovp-&gt;iov_len += a_count;
	}
	<span class="enscript-keyword">else</span> {
		a_uio-&gt;uio_iovs.kiovp-&gt;iov_base -= a_count;
		a_uio-&gt;uio_iovs.kiovp-&gt;iov_len += a_count;
	}

	a_uio-&gt;uio_offset -= a_count;
	a_uio-&gt;uio_resid_64 += a_count;

	<span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/*
 * uio_duplicate - allocate a new uio and make a copy of the given uio_t.
 *	may return NULL.
 */</span>
uio_t <span class="enscript-function-name">uio_duplicate</span>( uio_t a_uio )
{
	uio_t		my_uio;
	<span class="enscript-type">int</span>			i;

	<span class="enscript-keyword">if</span> (a_uio == NULL) {
		<span class="enscript-keyword">return</span>(NULL);
	}
	
	my_uio = (uio_t) kalloc(a_uio-&gt;uio_size);
	<span class="enscript-keyword">if</span> (my_uio == 0) {
		panic(<span class="enscript-string">&quot;%s :%d - allocation failed\n&quot;</span>, __FILE__, __LINE__); 
	}
	
	bcopy((<span class="enscript-type">void</span> *)a_uio, (<span class="enscript-type">void</span> *)my_uio, a_uio-&gt;uio_size);
	<span class="enscript-comment">/* need to set our iovec pointer to point to first active iovec */</span>
	<span class="enscript-keyword">if</span> (my_uio-&gt;uio_max_iovs &gt; 0) {
		my_uio-&gt;uio_iovs.uiovp = (<span class="enscript-type">struct</span> user_iovec *)
			(((uint8_t *)my_uio) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> uio));

		<span class="enscript-comment">/* advance to first nonzero iovec */</span>
		<span class="enscript-keyword">if</span> (my_uio-&gt;uio_iovcnt &gt; 0) {
			<span class="enscript-keyword">for</span> ( i = 0; i &lt; my_uio-&gt;uio_max_iovs; i++ ) {
				<span class="enscript-keyword">if</span> (UIO_IS_USER_SPACE(a_uio)) {
					<span class="enscript-keyword">if</span> (my_uio-&gt;uio_iovs.uiovp-&gt;iov_len != 0) {
						<span class="enscript-keyword">break</span>;
					}
					my_uio-&gt;uio_iovs.uiovp++;
				}
				<span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (my_uio-&gt;uio_iovs.kiovp-&gt;iov_len != 0) {
						<span class="enscript-keyword">break</span>;
					}
					my_uio-&gt;uio_iovs.kiovp++;
				}
			}
		}
	}

	my_uio-&gt;uio_flags = UIO_FLAGS_WE_ALLOCED | UIO_FLAGS_INITED;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		(<span class="enscript-type">void</span>)hw_atomic_add(&amp;uio_t_count, 1);
#<span class="enscript-reference">endif</span>


	<span class="enscript-keyword">return</span>(my_uio);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">copyin_user_iovec_array</span>(user_addr_t uaddr, <span class="enscript-type">int</span> spacetype, <span class="enscript-type">int</span> count, <span class="enscript-type">struct</span> user_iovec *dst)
{
	size_t size_of_iovec = ( spacetype == UIO_USERSPACE64 ? <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_iovec) : <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_iovec));
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">// copyin to the front of &quot;dst&quot;, without regard for putting records in the right places
</span>	error = copyin(uaddr, dst, count * size_of_iovec);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">// now, unpack the entries in reverse order, so we don't overwrite anything
</span>	<span class="enscript-keyword">for</span> (i = count - 1; i &gt;= 0; i--) {
		<span class="enscript-keyword">if</span> (spacetype == UIO_USERSPACE64) {
			<span class="enscript-type">struct</span> user64_iovec iovec = ((<span class="enscript-type">struct</span> user64_iovec *)dst)[i];
			dst[i].iov_base = iovec.iov_base;
			dst[i].iov_len = iovec.iov_len;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_iovec iovec = ((<span class="enscript-type">struct</span> user32_iovec *)dst)[i];
			dst[i].iov_base = iovec.iov_base;
			dst[i].iov_len = iovec.iov_len;			
		}
	}

	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>