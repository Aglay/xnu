<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mcache.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mcache.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2006-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Memory allocator with per-CPU caching, derived from the kmem magazine
 * concept and implementation as described in the following paper:
 * <a href="http://www.usenix.org/events/usenix01/full_papers/bonwick/bonwick.pdf">http://www.usenix.org/events/usenix01/full_papers/bonwick/bonwick.pdf</a>
 * That implementation is Copyright 2006 Sun Microsystems, Inc.  All rights
 * reserved.  Use is subject to license terms.
 *
 * There are several major differences between this and the original kmem
 * magazine: this derivative implementation allows for multiple objects to
 * be allocated and freed from/to the object cache in one call; in addition,
 * it provides for better flexibility where the user is allowed to define
 * its own slab allocator (instead of the default zone allocator).  Finally,
 * no object construction/destruction takes place at the moment, although
 * this could be added in future to improve efficiency.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/limits.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCACHE_SIZE</span>(n) \
	((size_t)(&amp;((mcache_t *)0)-&gt;mc_cpu[n]))

<span class="enscript-comment">/* Allocate extra in case we need to manually align the pointer */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCACHE_ALLOC_SIZE</span> \
	(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *) + MCACHE_SIZE(ncpu) + CPU_CACHE_LINE_SIZE)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCACHE_CPU</span>(c) \
	(mcache_cpu_t *)((<span class="enscript-type">void</span> *)((<span class="enscript-type">char</span> *)(c) + MCACHE_SIZE(cpu_number())))

<span class="enscript-comment">/*
 * MCACHE_LIST_LOCK() and MCACHE_LIST_UNLOCK() are macros used
 * to serialize accesses to the global list of caches in the system.
 * They also record the thread currently running in the critical
 * section, so that we can avoid recursive requests to reap the
 * caches when memory runs low.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCACHE_LIST_LOCK</span>() {				\
	lck_mtx_lock(mcache_llock);			\
	mcache_llock_owner = current_thread();		\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCACHE_LIST_UNLOCK</span>() {				\
	mcache_llock_owner = NULL;			\
	lck_mtx_unlock(mcache_llock);			\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCACHE_LOCK</span>(l)		lck_mtx_lock(l)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCACHE_UNLOCK</span>(l)	lck_mtx_unlock(l)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCACHE_LOCK_TRY</span>(l)	lck_mtx_try_lock(l)

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ncpu;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> cache_line_size;
<span class="enscript-type">static</span> lck_mtx_t *mcache_llock;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> thread *mcache_llock_owner;
<span class="enscript-type">static</span> lck_attr_t *mcache_llock_attr;
<span class="enscript-type">static</span> lck_grp_t *mcache_llock_grp;
<span class="enscript-type">static</span> lck_grp_attr_t *mcache_llock_grp_attr;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *mcache_zone;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> uint32_t mcache_reap_interval = 15;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> uint32_t mcache_reap_interval_leeway = 2;
<span class="enscript-type">static</span> UInt32 mcache_reaping;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> mcache_ready;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> mcache_updating;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> mcache_bkt_contention = 3;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mcache_flags = MCF_DEBUG;
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mcache_flags = 0;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span> mca_trn_max = MCA_TRN_MAX;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DUMP_MCA_BUF_SIZE</span>	512
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *mca_dump_buf;

<span class="enscript-type">static</span> mcache_bkttype_t mcache_bkttype[] = {
	{ 1,	4096,	32768,	NULL },
	{ 3,	2048,	16384,	NULL },
	{ 7,	1024,	12288,	NULL },
	{ 15,	256,	8192,	NULL },
	{ 31,	64,	4096,	NULL },
	{ 47,	0,	2048,	NULL },
	{ 63,	0,	1024,	NULL },
	{ 95,	0,	512,	NULL },
	{ 143,	0,	256,	NULL },
	{ 165,	0,	0,	NULL },
};

<span class="enscript-type">static</span> mcache_t *<span class="enscript-function-name">mcache_create_common</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, size_t, size_t,
    mcache_allocfn_t, mcache_freefn_t, mcache_auditfn_t, mcache_logfn_t,
    mcache_notifyfn_t, <span class="enscript-type">void</span> *, u_int32_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mcache_slab_alloc</span>(<span class="enscript-type">void</span> *, mcache_obj_t ***,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_slab_free</span>(<span class="enscript-type">void</span> *, mcache_obj_t *, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_slab_audit</span>(<span class="enscript-type">void</span> *, mcache_obj_t *, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_cpu_refill</span>(mcache_cpu_t *, mcache_bkt_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> mcache_bkt_t *<span class="enscript-function-name">mcache_bkt_alloc</span>(mcache_t *, mcache_bktlist_t *,
    mcache_bkttype_t **);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_bkt_free</span>(mcache_t *, mcache_bktlist_t *, mcache_bkt_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_cache_bkt_enable</span>(mcache_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_bkt_purge</span>(mcache_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_bkt_destroy</span>(mcache_t *, mcache_bkttype_t *,
    mcache_bkt_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_bkt_ws_update</span>(mcache_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_bkt_ws_reap</span>(mcache_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_dispatch</span>(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_cache_reap</span>(mcache_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_cache_update</span>(mcache_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_cache_bkt_resize</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_cache_enable</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_update</span>(thread_call_param_t __unused, thread_call_param_t __unused);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_update_timeout</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_applyall</span>(<span class="enscript-type">void</span> (*)(mcache_t *));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_reap_start</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_reap_done</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_reap_timeout</span>(thread_call_param_t __unused, thread_call_param_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_notify</span>(mcache_t *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcache_purge</span>(<span class="enscript-type">void</span> *);

<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(, mcache) mcache_head;
mcache_t *mcache_audit_cache;

<span class="enscript-type">static</span> thread_call_t mcache_reap_tcall;
<span class="enscript-type">static</span> thread_call_t mcache_update_tcall;

<span class="enscript-comment">/*
 * Initialize the framework; this is currently called as part of BSD init.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_init</span>(<span class="enscript-type">void</span>)
{
	mcache_bkttype_t *btp;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
	<span class="enscript-type">char</span> name[32];

	VERIFY(mca_trn_max &gt;= 2);

	ncpu = ml_get_max_cpus();
	(<span class="enscript-type">void</span>) mcache_cache_line_size();	<span class="enscript-comment">/* prime it */</span>

	mcache_llock_grp_attr = lck_grp_attr_alloc_init();
	mcache_llock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;mcache.list&quot;</span>,
	    mcache_llock_grp_attr);
	mcache_llock_attr = lck_attr_alloc_init();
	mcache_llock = lck_mtx_alloc_init(mcache_llock_grp, mcache_llock_attr);

	mcache_reap_tcall = thread_call_allocate(mcache_reap_timeout, NULL);
	mcache_update_tcall = thread_call_allocate(mcache_update, NULL);
	<span class="enscript-keyword">if</span> (mcache_reap_tcall == NULL || mcache_update_tcall == NULL)
		panic(<span class="enscript-string">&quot;mcache_init: thread_call_allocate failed&quot;</span>);

	mcache_zone = zinit(MCACHE_ALLOC_SIZE, 256 * MCACHE_ALLOC_SIZE,
	    PAGE_SIZE, <span class="enscript-string">&quot;mcache&quot;</span>);
	<span class="enscript-keyword">if</span> (mcache_zone == NULL)
		panic(<span class="enscript-string">&quot;mcache_init: failed to allocate mcache zone\n&quot;</span>);
	zone_change(mcache_zone, Z_CALLERACCT, FALSE);

	LIST_INIT(&amp;mcache_head);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span> (mcache_bkttype) / <span class="enscript-keyword">sizeof</span> (*btp); i++) {
		btp = &amp;mcache_bkttype[i];
		(<span class="enscript-type">void</span>) snprintf(name, <span class="enscript-keyword">sizeof</span> (name), <span class="enscript-string">&quot;bkt_%d&quot;</span>,
		    btp-&gt;bt_bktsize);
		btp-&gt;bt_cache = mcache_create(name,
		    (btp-&gt;bt_bktsize + 1) * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *), 0, 0, MCR_SLEEP);
	}

	PE_parse_boot_argn(<span class="enscript-string">&quot;mcache_flags&quot;</span>, &amp;mcache_flags, <span class="enscript-keyword">sizeof</span>(mcache_flags));
	mcache_flags &amp;= MCF_FLAGS_MASK;

	mcache_audit_cache = mcache_create(<span class="enscript-string">&quot;audit&quot;</span>, <span class="enscript-keyword">sizeof</span> (mcache_audit_t),
	    0, 0, MCR_SLEEP);

	mcache_applyall(mcache_cache_bkt_enable);
	mcache_ready = 1;

	printf(<span class="enscript-string">&quot;mcache: %d CPU(s), %d bytes CPU cache line size\n&quot;</span>,
	    ncpu, CPU_CACHE_LINE_SIZE);
}

<span class="enscript-comment">/*
 * Return the global mcache flags.
 */</span>
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mcache_getflags</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (mcache_flags);
}

<span class="enscript-comment">/*
 * Return the CPU cache line size.
 */</span>
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mcache_cache_line_size</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (cache_line_size == 0) {
		ml_cpu_info_t cpu_info;
		ml_cpu_get_info(&amp;cpu_info);
		cache_line_size = cpu_info.cache_line_size;
	}
	<span class="enscript-keyword">return</span> (cache_line_size);
}

<span class="enscript-comment">/*
 * Create a cache using the zone allocator as the backend slab allocator.
 * The caller may specify any alignment for the object; if it specifies 0
 * the default alignment (MCACHE_ALIGN) will be used.
 */</span>
__private_extern__ mcache_t *
<span class="enscript-function-name">mcache_create</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, size_t bufsize, size_t align,
    u_int32_t flags, <span class="enscript-type">int</span> wait)
{
	<span class="enscript-keyword">return</span> (mcache_create_common(name, bufsize, align, mcache_slab_alloc,
	    mcache_slab_free, mcache_slab_audit, NULL, NULL, NULL, flags, 1,
	    wait));
}

<span class="enscript-comment">/*
 * Create a cache using a custom backend slab allocator.  Since the caller
 * is responsible for allocation, no alignment guarantee will be provided
 * by this framework.
 */</span>
__private_extern__ mcache_t *
<span class="enscript-function-name">mcache_create_ext</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, size_t bufsize,
    mcache_allocfn_t allocfn, mcache_freefn_t freefn, mcache_auditfn_t auditfn,
    mcache_logfn_t logfn, mcache_notifyfn_t notifyfn, <span class="enscript-type">void</span> *arg,
    u_int32_t flags, <span class="enscript-type">int</span> wait)
{
	<span class="enscript-keyword">return</span> (mcache_create_common(name, bufsize, 0, allocfn,
	    freefn, auditfn, logfn, notifyfn, arg, flags, 0, wait));
}

<span class="enscript-comment">/*
 * Common cache creation routine.
 */</span>
<span class="enscript-type">static</span> mcache_t *
<span class="enscript-function-name">mcache_create_common</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, size_t bufsize, size_t align,
    mcache_allocfn_t allocfn, mcache_freefn_t freefn, mcache_auditfn_t auditfn,
    mcache_logfn_t logfn, mcache_notifyfn_t notifyfn, <span class="enscript-type">void</span> *arg,
    u_int32_t flags, <span class="enscript-type">int</span> need_zone, <span class="enscript-type">int</span> wait)
{
	mcache_bkttype_t *btp;
	mcache_t *cp = NULL;
	size_t chunksize;
	<span class="enscript-type">void</span> *buf, **pbuf;
	<span class="enscript-type">int</span> c;
	<span class="enscript-type">char</span> lck_name[64];

	<span class="enscript-comment">/* If auditing is on and print buffer is NULL, allocate it now */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; MCF_DEBUG) &amp;&amp; mca_dump_buf == NULL) {
		<span class="enscript-type">int</span> malloc_wait = (wait &amp; MCR_NOSLEEP) ? M_NOWAIT : M_WAITOK;
		MALLOC(mca_dump_buf, <span class="enscript-type">char</span> *, DUMP_MCA_BUF_SIZE, M_TEMP,
		    malloc_wait | M_ZERO);
		<span class="enscript-keyword">if</span> (mca_dump_buf == NULL)
			<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (!(wait &amp; MCR_NOSLEEP))
		buf = zalloc(mcache_zone);
	<span class="enscript-keyword">else</span>
		buf = zalloc_noblock(mcache_zone);

	<span class="enscript-keyword">if</span> (buf == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

	bzero(buf, MCACHE_ALLOC_SIZE);

	<span class="enscript-comment">/*
	 * In case we didn't get a cache-aligned memory, round it up
	 * accordingly.  This is needed in order to get the rest of
	 * structure members aligned properly.  It also means that
	 * the memory span gets shifted due to the round up, but it
	 * is okay since we've allocated extra space for this.
	 */</span>
	cp = (mcache_t *)
	    P2ROUNDUP((intptr_t)buf + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *), CPU_CACHE_LINE_SIZE);
	pbuf = (<span class="enscript-type">void</span> **)((intptr_t)cp - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *));
	*pbuf = buf;

	<span class="enscript-comment">/*
	 * Guaranteed alignment is valid only when we use the internal
	 * slab allocator (currently set to use the zone allocator).
	 */</span>
	<span class="enscript-keyword">if</span> (!need_zone)
		align = 1;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (align == 0)
		align = MCACHE_ALIGN;

	<span class="enscript-keyword">if</span> ((align &amp; (align - 1)) != 0)
		panic(<span class="enscript-string">&quot;mcache_create: bad alignment %lu&quot;</span>, align);

	cp-&gt;mc_align = align;
	cp-&gt;mc_slab_alloc = allocfn;
	cp-&gt;mc_slab_free = freefn;
	cp-&gt;mc_slab_audit = auditfn;
	cp-&gt;mc_slab_log = logfn;
	cp-&gt;mc_slab_notify = notifyfn;
	cp-&gt;mc_private = need_zone ? cp : arg;
	cp-&gt;mc_bufsize = bufsize;
	cp-&gt;mc_flags = (flags &amp; MCF_FLAGS_MASK) | mcache_flags;

	(<span class="enscript-type">void</span>) snprintf(cp-&gt;mc_name, <span class="enscript-keyword">sizeof</span> (cp-&gt;mc_name), <span class="enscript-string">&quot;mcache.%s&quot;</span>, name);

	(<span class="enscript-type">void</span>) snprintf(lck_name, <span class="enscript-keyword">sizeof</span> (lck_name), <span class="enscript-string">&quot;%s.cpu&quot;</span>, cp-&gt;mc_name);
	cp-&gt;mc_cpu_lock_grp_attr = lck_grp_attr_alloc_init();
	cp-&gt;mc_cpu_lock_grp = lck_grp_alloc_init(lck_name,
	    cp-&gt;mc_cpu_lock_grp_attr);
	cp-&gt;mc_cpu_lock_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/*
	 * Allocation chunk size is the object's size plus any extra size
	 * needed to satisfy the object's alignment.  It is enforced to be
	 * at least the size of an LP64 pointer to simplify auditing and to
	 * handle multiple-element allocation requests, where the elements
	 * returned are linked together in a list.
	 */</span>
	chunksize = MAX(bufsize, <span class="enscript-keyword">sizeof</span> (u_int64_t));
	<span class="enscript-keyword">if</span> (need_zone) {
		<span class="enscript-comment">/* Enforce 64-bit minimum alignment for zone-based buffers */</span>
		align = MAX(align, <span class="enscript-keyword">sizeof</span> (u_int64_t));
		chunksize += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *) + align;
		chunksize = P2ROUNDUP(chunksize, align);
		<span class="enscript-keyword">if</span> ((cp-&gt;mc_slab_zone = zinit(chunksize, 64 * 1024 * ncpu,
		    PAGE_SIZE, cp-&gt;mc_name)) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		zone_change(cp-&gt;mc_slab_zone, Z_EXPAND, TRUE);
	}
	cp-&gt;mc_chunksize = chunksize;

	<span class="enscript-comment">/*
	 * Initialize the bucket layer.
	 */</span>
	(<span class="enscript-type">void</span>) snprintf(lck_name, <span class="enscript-keyword">sizeof</span> (lck_name), <span class="enscript-string">&quot;%s.bkt&quot;</span>, cp-&gt;mc_name);
	cp-&gt;mc_bkt_lock_grp_attr = lck_grp_attr_alloc_init();
	cp-&gt;mc_bkt_lock_grp = lck_grp_alloc_init(lck_name,
	    cp-&gt;mc_bkt_lock_grp_attr);
	cp-&gt;mc_bkt_lock_attr = lck_attr_alloc_init();
	lck_mtx_init(&amp;cp-&gt;mc_bkt_lock, cp-&gt;mc_bkt_lock_grp,
	    cp-&gt;mc_bkt_lock_attr);

	(<span class="enscript-type">void</span>) snprintf(lck_name, <span class="enscript-keyword">sizeof</span> (lck_name), <span class="enscript-string">&quot;%s.sync&quot;</span>, cp-&gt;mc_name);
	cp-&gt;mc_sync_lock_grp_attr = lck_grp_attr_alloc_init();
	cp-&gt;mc_sync_lock_grp = lck_grp_alloc_init(lck_name,
	    cp-&gt;mc_sync_lock_grp_attr);
	cp-&gt;mc_sync_lock_attr = lck_attr_alloc_init();
	lck_mtx_init(&amp;cp-&gt;mc_sync_lock, cp-&gt;mc_sync_lock_grp,
	    cp-&gt;mc_sync_lock_attr);

	<span class="enscript-keyword">for</span> (btp = mcache_bkttype; chunksize &lt;= btp-&gt;bt_minbuf; btp++)
		<span class="enscript-keyword">continue</span>;

	cp-&gt;cache_bkttype = btp;

	<span class="enscript-comment">/*
	 * Initialize the CPU layer.  Each per-CPU structure is aligned
	 * on the CPU cache line boundary to prevent false sharing.
	 */</span>
	<span class="enscript-keyword">for</span> (c = 0; c &lt; ncpu; c++) {
		mcache_cpu_t *ccp = &amp;cp-&gt;mc_cpu[c];

		VERIFY(IS_P2ALIGNED(ccp, CPU_CACHE_LINE_SIZE));
		lck_mtx_init(&amp;ccp-&gt;cc_lock, cp-&gt;mc_cpu_lock_grp,
		    cp-&gt;mc_cpu_lock_attr);
		ccp-&gt;cc_objs = -1;
		ccp-&gt;cc_pobjs = -1;
	}

	<span class="enscript-keyword">if</span> (mcache_ready)
		mcache_cache_bkt_enable(cp);

	<span class="enscript-comment">/* TODO: dynamically create sysctl for stats */</span>

	MCACHE_LIST_LOCK();
	LIST_INSERT_HEAD(&amp;mcache_head, cp, mc_list);
	MCACHE_LIST_UNLOCK();

	<span class="enscript-comment">/*
	 * If cache buckets are enabled and this is the first cache
	 * created, start the periodic cache update.
	 */</span>
	<span class="enscript-keyword">if</span> (!(mcache_flags &amp; MCF_NOCPUCACHE) &amp;&amp; !mcache_updating) {
		mcache_updating = 1;
		mcache_update_timeout(NULL);
	}
	<span class="enscript-keyword">if</span> (cp-&gt;mc_flags &amp; MCF_DEBUG) {
		printf(<span class="enscript-string">&quot;mcache_create: %s (%s) arg %p bufsize %lu align %lu &quot;</span>
		    <span class="enscript-string">&quot;chunksize %lu bktsize %d\n&quot;</span>, name, need_zone ? <span class="enscript-string">&quot;i&quot;</span> : <span class="enscript-string">&quot;e&quot;</span>,
		    arg, bufsize, cp-&gt;mc_align, chunksize, btp-&gt;bt_bktsize);
	}
	<span class="enscript-keyword">return</span> (cp);

<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (buf != NULL)
		zfree(mcache_zone, buf);
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * Allocate one or more objects from a cache.
 */</span>
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mcache_alloc_ext</span>(mcache_t *cp, mcache_obj_t **list, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num, <span class="enscript-type">int</span> wait)
{
	mcache_cpu_t *ccp;
	mcache_obj_t **top = &amp;(*list);
	mcache_bkt_t *bkt;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> need = num;
	boolean_t nwretry = FALSE;

	<span class="enscript-comment">/* MCR_NOSLEEP and MCR_FAILOK are mutually exclusive */</span>
	VERIFY((wait &amp; (MCR_NOSLEEP|MCR_FAILOK)) != (MCR_NOSLEEP|MCR_FAILOK));

	ASSERT(list != NULL);
	*list = NULL;

	<span class="enscript-keyword">if</span> (num == 0)
		<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">retry_alloc</span>:
	<span class="enscript-comment">/* We may not always be running in the same CPU in case of retries */</span>
	ccp = MCACHE_CPU(cp);

	MCACHE_LOCK(&amp;ccp-&gt;cc_lock);
	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-comment">/*
		 * If we have an object in the current CPU's filled bucket,
		 * chain the object to any previous objects and return if
		 * we've satisfied the number of requested objects.
		 */</span>
		<span class="enscript-keyword">if</span> (ccp-&gt;cc_objs &gt; 0) {
			mcache_obj_t *tail;
			<span class="enscript-type">int</span> objs;

			<span class="enscript-comment">/*
			 * Objects in the bucket are already linked together
			 * with the most recently freed object at the head of
			 * the list; grab as many objects as we can.
			 */</span>
			objs = MIN((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)ccp-&gt;cc_objs, need);
			*list = ccp-&gt;cc_filled-&gt;bkt_obj[ccp-&gt;cc_objs - 1];
			ccp-&gt;cc_objs -= objs;
			ccp-&gt;cc_alloc += objs;

			tail = ccp-&gt;cc_filled-&gt;bkt_obj[ccp-&gt;cc_objs];
			list = &amp;tail-&gt;obj_next;
			*list = NULL;

			<span class="enscript-comment">/* If we got them all, return to caller */</span>
			<span class="enscript-keyword">if</span> ((need -= objs) == 0) {
				MCACHE_UNLOCK(&amp;ccp-&gt;cc_lock);

				<span class="enscript-keyword">if</span> (!(cp-&gt;mc_flags &amp; MCF_NOLEAKLOG) &amp;&amp;
				    cp-&gt;mc_slab_log != NULL)
					(*cp-&gt;mc_slab_log)(num, *top, TRUE);

				<span class="enscript-keyword">if</span> (cp-&gt;mc_flags &amp; MCF_DEBUG)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">debug_alloc</span>;

				<span class="enscript-keyword">return</span> (num);
			}
		}

		<span class="enscript-comment">/*
		 * The CPU's filled bucket is empty.  If the previous filled
		 * bucket was full, exchange and try again.
		 */</span>
		<span class="enscript-keyword">if</span> (ccp-&gt;cc_pobjs &gt; 0) {
			mcache_cpu_refill(ccp, ccp-&gt;cc_pfilled, ccp-&gt;cc_pobjs);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * If the bucket layer is disabled, allocate from slab.  This
		 * can happen either because MCF_NOCPUCACHE is set, or because
		 * the bucket layer is currently being resized.
		 */</span>
		<span class="enscript-keyword">if</span> (ccp-&gt;cc_bktsize == 0)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * Both of the CPU's buckets are empty; try to get a full
		 * bucket from the bucket layer.  Upon success, refill this
		 * CPU and place any empty bucket into the empty list.
		 */</span>
		bkt = mcache_bkt_alloc(cp, &amp;cp-&gt;mc_full, NULL);
		<span class="enscript-keyword">if</span> (bkt != NULL) {
			<span class="enscript-keyword">if</span> (ccp-&gt;cc_pfilled != NULL)
				mcache_bkt_free(cp, &amp;cp-&gt;mc_empty,
				    ccp-&gt;cc_pfilled);
			mcache_cpu_refill(ccp, bkt, ccp-&gt;cc_bktsize);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * The bucket layer has no full buckets; allocate the
		 * object(s) directly from the slab layer.
		 */</span>
		<span class="enscript-keyword">break</span>;
	}
	MCACHE_UNLOCK(&amp;ccp-&gt;cc_lock);

	need -= (*cp-&gt;mc_slab_alloc)(cp-&gt;mc_private, &amp;list, need, wait);

	<span class="enscript-comment">/*
	 * If this is a blocking allocation, or if it is non-blocking and
	 * the cache's full bucket is non-empty, then retry the allocation.
	 */</span>
	<span class="enscript-keyword">if</span> (need &gt; 0) {
		<span class="enscript-keyword">if</span> (!(wait &amp; MCR_NONBLOCKING)) {
			atomic_add_32(&amp;cp-&gt;mc_wretry_cnt, 1);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry_alloc</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((wait &amp; (MCR_NOSLEEP | MCR_TRYHARD)) &amp;&amp;
		    !mcache_bkt_isempty(cp)) {
			<span class="enscript-keyword">if</span> (!nwretry)
				nwretry = TRUE;
			atomic_add_32(&amp;cp-&gt;mc_nwretry_cnt, 1);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry_alloc</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nwretry) {
			atomic_add_32(&amp;cp-&gt;mc_nwfail_cnt, 1);
		}
	}

	<span class="enscript-keyword">if</span> (!(cp-&gt;mc_flags &amp; MCF_NOLEAKLOG) &amp;&amp; cp-&gt;mc_slab_log != NULL)
		(*cp-&gt;mc_slab_log)((num - need), *top, TRUE);

	<span class="enscript-keyword">if</span> (!(cp-&gt;mc_flags &amp; MCF_DEBUG))
		<span class="enscript-keyword">return</span> (num - need);

<span class="enscript-reference">debug_alloc</span>:
	<span class="enscript-keyword">if</span> (cp-&gt;mc_flags &amp; MCF_DEBUG) {
		mcache_obj_t **o = top;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> n;

		n = 0;
		<span class="enscript-comment">/*
		 * Verify that the chain of objects have the same count as
		 * what we are about to report to the caller.  Any mismatch
		 * here means that the object list is insanely broken and
		 * therefore we must panic.
		 */</span>
		<span class="enscript-keyword">while</span> (*o != NULL) {
			o = &amp;(*o)-&gt;obj_next;
			++n;
		}
		<span class="enscript-keyword">if</span> (n != (num - need)) {
			panic(<span class="enscript-string">&quot;mcache_alloc_ext: %s cp %p corrupted list &quot;</span>
			    <span class="enscript-string">&quot;(got %d actual %d)\n&quot;</span>, cp-&gt;mc_name,
			    (<span class="enscript-type">void</span> *)cp, num - need, n);
		}
	}

	<span class="enscript-comment">/* Invoke the slab layer audit callback if auditing is enabled */</span>
	<span class="enscript-keyword">if</span> ((cp-&gt;mc_flags &amp; MCF_DEBUG) &amp;&amp; cp-&gt;mc_slab_audit != NULL)
		(*cp-&gt;mc_slab_audit)(cp-&gt;mc_private, *top, TRUE);

	<span class="enscript-keyword">return</span> (num - need);
}

<span class="enscript-comment">/*
 * Allocate a single object from a cache.
 */</span>
__private_extern__ <span class="enscript-type">void</span> *
<span class="enscript-function-name">mcache_alloc</span>(mcache_t *cp, <span class="enscript-type">int</span> wait)
{
	mcache_obj_t *buf;

	(<span class="enscript-type">void</span>) mcache_alloc_ext(cp, &amp;buf, 1, wait);
	<span class="enscript-keyword">return</span> (buf);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_waiter_inc</span>(mcache_t *cp)
{
	atomic_add_32(&amp;cp-&gt;mc_waiter_cnt, 1);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_waiter_dec</span>(mcache_t *cp)
{
	atomic_add_32(&amp;cp-&gt;mc_waiter_cnt, -1);
}

__private_extern__ boolean_t
<span class="enscript-function-name">mcache_bkt_isempty</span>(mcache_t *cp)
{
	<span class="enscript-comment">/*
	 * This isn't meant to accurately tell whether there are
	 * any full buckets in the cache; it is simply a way to
	 * obtain &quot;hints&quot; about the state of the cache.
	 */</span>
	<span class="enscript-keyword">return</span> (cp-&gt;mc_full.bl_total == 0);
}

<span class="enscript-comment">/*
 * Notify the slab layer about an event.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_notify</span>(mcache_t *cp, u_int32_t event)
{
	<span class="enscript-keyword">if</span> (cp-&gt;mc_slab_notify != NULL)
		(*cp-&gt;mc_slab_notify)(cp-&gt;mc_private, event);
}

<span class="enscript-comment">/*
 * Purge the cache and disable its buckets.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_purge</span>(<span class="enscript-type">void</span> *arg)
{
	mcache_t *cp = arg;

	mcache_bkt_purge(cp);
	<span class="enscript-comment">/*
	 * We cannot simply call mcache_cache_bkt_enable() from here as
	 * a bucket resize may be in flight and we would cause the CPU
	 * layers of the cache to point to different sizes.  Therefore,
	 * we simply increment the enable count so that during the next
	 * periodic cache update the buckets can be reenabled.
	 */</span>
	lck_mtx_lock_spin(&amp;cp-&gt;mc_sync_lock);
	cp-&gt;mc_enable_cnt++;
	lck_mtx_unlock(&amp;cp-&gt;mc_sync_lock);
}

__private_extern__ boolean_t
<span class="enscript-function-name">mcache_purge_cache</span>(mcache_t *cp, boolean_t async)
{
	<span class="enscript-comment">/*
	 * Purging a cache that has no per-CPU caches or is already
	 * in the process of being purged is rather pointless.
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;mc_flags &amp; MCF_NOCPUCACHE)
		<span class="enscript-keyword">return</span> (FALSE);

	lck_mtx_lock_spin(&amp;cp-&gt;mc_sync_lock);
	<span class="enscript-keyword">if</span> (cp-&gt;mc_purge_cnt &gt; 0) {
		lck_mtx_unlock(&amp;cp-&gt;mc_sync_lock);
		<span class="enscript-keyword">return</span> (FALSE);
	}
	cp-&gt;mc_purge_cnt++;
	lck_mtx_unlock(&amp;cp-&gt;mc_sync_lock);

	<span class="enscript-keyword">if</span> (async)
		mcache_dispatch(mcache_purge, cp);
	<span class="enscript-keyword">else</span>
		mcache_purge(cp);

	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-comment">/*
 * Free a single object to a cache.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_free</span>(mcache_t *cp, <span class="enscript-type">void</span> *buf)
{
	((mcache_obj_t *)buf)-&gt;obj_next = NULL;
	mcache_free_ext(cp, (mcache_obj_t *)buf);
}

<span class="enscript-comment">/*
 * Free one or more objects to a cache.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_free_ext</span>(mcache_t *cp, mcache_obj_t *list)
{
	mcache_cpu_t *ccp = MCACHE_CPU(cp);
	mcache_bkttype_t *btp;
	mcache_obj_t *nlist;
	mcache_bkt_t *bkt;

	<span class="enscript-keyword">if</span> (!(cp-&gt;mc_flags &amp; MCF_NOLEAKLOG) &amp;&amp; cp-&gt;mc_slab_log != NULL)
		(*cp-&gt;mc_slab_log)(0, list, FALSE);

	<span class="enscript-comment">/* Invoke the slab layer audit callback if auditing is enabled */</span>
	<span class="enscript-keyword">if</span> ((cp-&gt;mc_flags &amp; MCF_DEBUG) &amp;&amp; cp-&gt;mc_slab_audit != NULL)
		(*cp-&gt;mc_slab_audit)(cp-&gt;mc_private, list, FALSE);

	MCACHE_LOCK(&amp;ccp-&gt;cc_lock);
	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-comment">/*
		 * If there is space in the current CPU's filled bucket, put
		 * the object there and return once all objects are freed.
		 * Note the cast to unsigned integer takes care of the case
		 * where the bucket layer is disabled (when cc_objs is -1).
		 */</span>
		<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)ccp-&gt;cc_objs &lt;
		    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)ccp-&gt;cc_bktsize) {
			<span class="enscript-comment">/*
			 * Reverse the list while we place the object into the
			 * bucket; this effectively causes the most recently
			 * freed object(s) to be reused during allocation.
			 */</span>
			nlist = list-&gt;obj_next;
			list-&gt;obj_next = (ccp-&gt;cc_objs == 0) ? NULL :
			    ccp-&gt;cc_filled-&gt;bkt_obj[ccp-&gt;cc_objs - 1];
			ccp-&gt;cc_filled-&gt;bkt_obj[ccp-&gt;cc_objs++] = list;
			ccp-&gt;cc_free++;

			<span class="enscript-keyword">if</span> ((list = nlist) != NULL)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-comment">/* We are done; return to caller */</span>
			MCACHE_UNLOCK(&amp;ccp-&gt;cc_lock);

			<span class="enscript-comment">/* If there is a waiter below, notify it */</span>
			<span class="enscript-keyword">if</span> (cp-&gt;mc_waiter_cnt &gt; 0)
				mcache_notify(cp, MCN_RETRYALLOC);
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/*
		 * The CPU's filled bucket is full.  If the previous filled
		 * bucket was empty, exchange and try again.
		 */</span>
		<span class="enscript-keyword">if</span> (ccp-&gt;cc_pobjs == 0) {
			mcache_cpu_refill(ccp, ccp-&gt;cc_pfilled, ccp-&gt;cc_pobjs);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * If the bucket layer is disabled, free to slab.  This can
		 * happen either because MCF_NOCPUCACHE is set, or because
		 * the bucket layer is currently being resized.
		 */</span>
		<span class="enscript-keyword">if</span> (ccp-&gt;cc_bktsize == 0)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * Both of the CPU's buckets are full; try to get an empty
		 * bucket from the bucket layer.  Upon success, empty this
		 * CPU and place any full bucket into the full list.
		 */</span>
		bkt = mcache_bkt_alloc(cp, &amp;cp-&gt;mc_empty, &amp;btp);
		<span class="enscript-keyword">if</span> (bkt != NULL) {
			<span class="enscript-keyword">if</span> (ccp-&gt;cc_pfilled != NULL)
				mcache_bkt_free(cp, &amp;cp-&gt;mc_full,
				    ccp-&gt;cc_pfilled);
			mcache_cpu_refill(ccp, bkt, 0);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * We need an empty bucket to put our freed objects into
		 * but couldn't get an empty bucket from the bucket layer;
		 * attempt to allocate one.  We do not want to block for
		 * allocation here, and if the bucket allocation fails
		 * we will simply fall through to the slab layer.
		 */</span>
		MCACHE_UNLOCK(&amp;ccp-&gt;cc_lock);
		bkt = mcache_alloc(btp-&gt;bt_cache, MCR_NOSLEEP);
		MCACHE_LOCK(&amp;ccp-&gt;cc_lock);

		<span class="enscript-keyword">if</span> (bkt != NULL) {
			<span class="enscript-comment">/*
			 * We have an empty bucket, but since we drop the
			 * CPU lock above, the cache's bucket size may have
			 * changed.  If so, free the bucket and try again.
			 */</span>
			<span class="enscript-keyword">if</span> (ccp-&gt;cc_bktsize != btp-&gt;bt_bktsize) {
				MCACHE_UNLOCK(&amp;ccp-&gt;cc_lock);
				mcache_free(btp-&gt;bt_cache, bkt);
				MCACHE_LOCK(&amp;ccp-&gt;cc_lock);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 * We have an empty bucket of the right size;
			 * add it to the bucket layer and try again.
			 */</span>
			mcache_bkt_free(cp, &amp;cp-&gt;mc_empty, bkt);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * The bucket layer has no empty buckets; free the
		 * object(s) directly to the slab layer.
		 */</span>
		<span class="enscript-keyword">break</span>;
	}
	MCACHE_UNLOCK(&amp;ccp-&gt;cc_lock);

	<span class="enscript-comment">/* If there is a waiter below, notify it */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;mc_waiter_cnt &gt; 0)
		mcache_notify(cp, MCN_RETRYALLOC);

	<span class="enscript-comment">/* Advise the slab layer to purge the object(s) */</span>
	(*cp-&gt;mc_slab_free)(cp-&gt;mc_private, list,
	    (cp-&gt;mc_flags &amp; MCF_DEBUG) || cp-&gt;mc_purge_cnt);
}

<span class="enscript-comment">/*
 * Cache destruction routine.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_destroy</span>(mcache_t *cp)
{
	<span class="enscript-type">void</span> **pbuf;

	MCACHE_LIST_LOCK();
	LIST_REMOVE(cp, mc_list);
	MCACHE_LIST_UNLOCK();

	mcache_bkt_purge(cp);

	<span class="enscript-comment">/*
	 * This cache is dead; there should be no further transaction.
	 * If it's still invoked, make sure that it induces a fault.
	 */</span>
	cp-&gt;mc_slab_alloc = NULL;
	cp-&gt;mc_slab_free = NULL;
	cp-&gt;mc_slab_audit = NULL;

	lck_attr_free(cp-&gt;mc_bkt_lock_attr);
	lck_grp_free(cp-&gt;mc_bkt_lock_grp);
	lck_grp_attr_free(cp-&gt;mc_bkt_lock_grp_attr);

	lck_attr_free(cp-&gt;mc_cpu_lock_attr);
	lck_grp_free(cp-&gt;mc_cpu_lock_grp);
	lck_grp_attr_free(cp-&gt;mc_cpu_lock_grp_attr);

	lck_attr_free(cp-&gt;mc_sync_lock_attr);
	lck_grp_free(cp-&gt;mc_sync_lock_grp);
	lck_grp_attr_free(cp-&gt;mc_sync_lock_grp_attr);

	<span class="enscript-comment">/*
	 * TODO: We need to destroy the zone here, but cannot do it
	 * because there is no such way to achieve that.  Until then
	 * the memory allocated for the zone structure is leaked.
	 * Once it is achievable, uncomment these lines:
	 *
	 *	if (cp-&gt;mc_slab_zone != NULL) {
	 *		zdestroy(cp-&gt;mc_slab_zone);
	 *		cp-&gt;mc_slab_zone = NULL;
	 *	}
	 */</span>

	<span class="enscript-comment">/* Get the original address since we're about to free it */</span>
	pbuf = (<span class="enscript-type">void</span> **)((intptr_t)cp - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *));

	zfree(mcache_zone, *pbuf);
}

<span class="enscript-comment">/*
 * Internal slab allocator used as a backend for simple caches.  The current
 * implementation uses the zone allocator for simplicity reasons.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mcache_slab_alloc</span>(<span class="enscript-type">void</span> *arg, mcache_obj_t ***plist, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num, <span class="enscript-type">int</span> wait)
{
	mcache_t *cp = arg;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> need = num;
	size_t offset = 0;
	size_t rsize = P2ROUNDUP(cp-&gt;mc_bufsize, <span class="enscript-keyword">sizeof</span> (u_int64_t));
	u_int32_t flags = cp-&gt;mc_flags;
	<span class="enscript-type">void</span> *buf, *base, **pbuf;
	mcache_obj_t **list = *plist;

	*list = NULL;

	<span class="enscript-comment">/*
	 * The address of the object returned to the caller is an
	 * offset from the 64-bit aligned base address only if the
	 * cache's alignment requirement is neither 1 nor 8 bytes.
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;mc_align != 1 &amp;&amp; cp-&gt;mc_align != <span class="enscript-keyword">sizeof</span> (u_int64_t))
		offset = cp-&gt;mc_align;

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (!(wait &amp; MCR_NOSLEEP))
			buf = zalloc(cp-&gt;mc_slab_zone);
		<span class="enscript-keyword">else</span>
			buf = zalloc_noblock(cp-&gt;mc_slab_zone);

		<span class="enscript-keyword">if</span> (buf == NULL)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* Get the 64-bit aligned base address for this object */</span>
		base = (<span class="enscript-type">void</span> *)P2ROUNDUP((intptr_t)buf + <span class="enscript-keyword">sizeof</span> (u_int64_t),
		    <span class="enscript-keyword">sizeof</span> (u_int64_t));

		<span class="enscript-comment">/*
		 * Wind back a pointer size from the aligned base and
		 * save the original address so we can free it later.
		 */</span>
		pbuf = (<span class="enscript-type">void</span> **)((intptr_t)base - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *));
		*pbuf = buf;

		<span class="enscript-comment">/*
		 * If auditing is enabled, patternize the contents of
		 * the buffer starting from the 64-bit aligned base to
		 * the end of the buffer; the length is rounded up to
		 * the nearest 64-bit multiply; this is because we use
		 * 64-bit memory access to set/check the pattern.
		 */</span>
		<span class="enscript-keyword">if</span> (flags &amp; MCF_DEBUG) {
			VERIFY(((intptr_t)base + rsize) &lt;=
			    ((intptr_t)buf + cp-&gt;mc_chunksize));
			mcache_set_pattern(MCACHE_FREE_PATTERN, base, rsize);
		}

		<span class="enscript-comment">/*
		 * Fix up the object's address to fulfill the cache's
		 * alignment requirement (if needed) and return this
		 * to the caller.
		 */</span>
		VERIFY(((intptr_t)base + offset + cp-&gt;mc_bufsize) &lt;=
		    ((intptr_t)buf + cp-&gt;mc_chunksize));
		*list = (mcache_obj_t *)((intptr_t)base + offset);

		(*list)-&gt;obj_next = NULL;
		list = *plist = &amp;(*list)-&gt;obj_next;

		<span class="enscript-comment">/* If we got them all, return to mcache */</span>
		<span class="enscript-keyword">if</span> (--need == 0)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (num - need);
}

<span class="enscript-comment">/*
 * Internal slab deallocator used as a backend for simple caches.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_slab_free</span>(<span class="enscript-type">void</span> *arg, mcache_obj_t *list, __unused boolean_t purged)
{
	mcache_t *cp = arg;
	mcache_obj_t *nlist;
	size_t offset = 0;
	size_t rsize = P2ROUNDUP(cp-&gt;mc_bufsize, <span class="enscript-keyword">sizeof</span> (u_int64_t));
	u_int32_t flags = cp-&gt;mc_flags;
	<span class="enscript-type">void</span> *base;
	<span class="enscript-type">void</span> **pbuf;

	<span class="enscript-comment">/*
	 * The address of the object is an offset from a 64-bit
	 * aligned base address only if the cache's alignment
	 * requirement is neither 1 nor 8 bytes.
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;mc_align != 1 &amp;&amp; cp-&gt;mc_align != <span class="enscript-keyword">sizeof</span> (u_int64_t))
		offset = cp-&gt;mc_align;

	<span class="enscript-keyword">for</span> (;;) {
		nlist = list-&gt;obj_next;
		list-&gt;obj_next = NULL;

		<span class="enscript-comment">/* Get the 64-bit aligned base address of this object */</span>
		base = (<span class="enscript-type">void</span> *)((intptr_t)list - offset);
		VERIFY(IS_P2ALIGNED(base, <span class="enscript-keyword">sizeof</span> (u_int64_t)));

		<span class="enscript-comment">/* Get the original address since we're about to free it */</span>
		pbuf = (<span class="enscript-type">void</span> **)((intptr_t)base - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *));

		<span class="enscript-keyword">if</span> (flags &amp; MCF_DEBUG) {
			VERIFY(((intptr_t)base + rsize) &lt;=
			    ((intptr_t)*pbuf + cp-&gt;mc_chunksize));
			mcache_audit_free_verify(NULL, base, offset, rsize);
		}

		<span class="enscript-comment">/* Free it to zone */</span>
		VERIFY(((intptr_t)base + offset + cp-&gt;mc_bufsize) &lt;=
		    ((intptr_t)*pbuf + cp-&gt;mc_chunksize));
		zfree(cp-&gt;mc_slab_zone, *pbuf);

		<span class="enscript-comment">/* No more objects to free; return to mcache */</span>
		<span class="enscript-keyword">if</span> ((list = nlist) == NULL)
			<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-comment">/*
 * Internal slab auditor for simple caches.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_slab_audit</span>(<span class="enscript-type">void</span> *arg, mcache_obj_t *list, boolean_t alloc)
{
	mcache_t *cp = arg;
	size_t offset = 0;
	size_t rsize = P2ROUNDUP(cp-&gt;mc_bufsize, <span class="enscript-keyword">sizeof</span> (u_int64_t));
	<span class="enscript-type">void</span> *base, **pbuf;

	<span class="enscript-comment">/*
	 * The address of the object returned to the caller is an
	 * offset from the 64-bit aligned base address only if the
	 * cache's alignment requirement is neither 1 nor 8 bytes.
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;mc_align != 1 &amp;&amp; cp-&gt;mc_align != <span class="enscript-keyword">sizeof</span> (u_int64_t))
		offset = cp-&gt;mc_align;

	<span class="enscript-keyword">while</span> (list != NULL) {
		mcache_obj_t *next = list-&gt;obj_next;

		<span class="enscript-comment">/* Get the 64-bit aligned base address of this object */</span>
		base = (<span class="enscript-type">void</span> *)((intptr_t)list - offset);
		VERIFY(IS_P2ALIGNED(base, <span class="enscript-keyword">sizeof</span> (u_int64_t)));

		<span class="enscript-comment">/* Get the original address */</span>
		pbuf = (<span class="enscript-type">void</span> **)((intptr_t)base - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *));

		VERIFY(((intptr_t)base + rsize) &lt;=
		    ((intptr_t)*pbuf + cp-&gt;mc_chunksize));

		<span class="enscript-keyword">if</span> (!alloc)
			mcache_set_pattern(MCACHE_FREE_PATTERN, base, rsize);
		<span class="enscript-keyword">else</span>
			mcache_audit_free_verify_set(NULL, base, offset, rsize);

		list = list-&gt;obj_next = next;
	}
}

<span class="enscript-comment">/*
 * Refill the CPU's filled bucket with bkt and save the previous one.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_cpu_refill</span>(mcache_cpu_t *ccp, mcache_bkt_t *bkt, <span class="enscript-type">int</span> objs)
{
	ASSERT((ccp-&gt;cc_filled == NULL &amp;&amp; ccp-&gt;cc_objs == -1) ||
	    (ccp-&gt;cc_filled &amp;&amp; ccp-&gt;cc_objs + objs == ccp-&gt;cc_bktsize));
	ASSERT(ccp-&gt;cc_bktsize &gt; 0);

	ccp-&gt;cc_pfilled = ccp-&gt;cc_filled;
	ccp-&gt;cc_pobjs = ccp-&gt;cc_objs;
	ccp-&gt;cc_filled = bkt;
	ccp-&gt;cc_objs = objs;
}

<span class="enscript-comment">/*
 * Allocate a bucket from the bucket layer.
 */</span>
<span class="enscript-type">static</span> mcache_bkt_t *
<span class="enscript-function-name">mcache_bkt_alloc</span>(mcache_t *cp, mcache_bktlist_t *blp, mcache_bkttype_t **btp)
{
	mcache_bkt_t *bkt;

	<span class="enscript-keyword">if</span> (!MCACHE_LOCK_TRY(&amp;cp-&gt;mc_bkt_lock)) {
		<span class="enscript-comment">/*
		 * The bucket layer lock is held by another CPU; increase
		 * the contention count so that we can later resize the
		 * bucket size accordingly.
		 */</span>
		MCACHE_LOCK(&amp;cp-&gt;mc_bkt_lock);
		cp-&gt;mc_bkt_contention++;
	}

	<span class="enscript-keyword">if</span> ((bkt = blp-&gt;bl_list) != NULL) {
		blp-&gt;bl_list = bkt-&gt;bkt_next;
		<span class="enscript-keyword">if</span> (--blp-&gt;bl_total &lt; blp-&gt;bl_min)
			blp-&gt;bl_min = blp-&gt;bl_total;
		blp-&gt;bl_alloc++;
	}

	<span class="enscript-keyword">if</span> (btp != NULL)
		*btp = cp-&gt;cache_bkttype;

	MCACHE_UNLOCK(&amp;cp-&gt;mc_bkt_lock);

	<span class="enscript-keyword">return</span> (bkt);
}

<span class="enscript-comment">/*
 * Free a bucket to the bucket layer.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_bkt_free</span>(mcache_t *cp, mcache_bktlist_t *blp, mcache_bkt_t *bkt)
{
	MCACHE_LOCK(&amp;cp-&gt;mc_bkt_lock);

	bkt-&gt;bkt_next = blp-&gt;bl_list;
	blp-&gt;bl_list = bkt;
	blp-&gt;bl_total++;

	MCACHE_UNLOCK(&amp;cp-&gt;mc_bkt_lock);
}

<span class="enscript-comment">/*
 * Enable the bucket layer of a cache.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_cache_bkt_enable</span>(mcache_t *cp)
{
	mcache_cpu_t *ccp;
	<span class="enscript-type">int</span> cpu;

	<span class="enscript-keyword">if</span> (cp-&gt;mc_flags &amp; MCF_NOCPUCACHE)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">for</span> (cpu = 0; cpu &lt; ncpu; cpu++) {
		ccp = &amp;cp-&gt;mc_cpu[cpu];
		MCACHE_LOCK(&amp;ccp-&gt;cc_lock);
		ccp-&gt;cc_bktsize = cp-&gt;cache_bkttype-&gt;bt_bktsize;
		MCACHE_UNLOCK(&amp;ccp-&gt;cc_lock);
	}
}

<span class="enscript-comment">/*
 * Purge all buckets from a cache and disable its bucket layer.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_bkt_purge</span>(mcache_t *cp)
{
	mcache_cpu_t *ccp;
	mcache_bkt_t *bp, *pbp;
	mcache_bkttype_t *btp;
	<span class="enscript-type">int</span> cpu, objs, pobjs;

	<span class="enscript-keyword">for</span> (cpu = 0; cpu &lt; ncpu; cpu++) {
		ccp = &amp;cp-&gt;mc_cpu[cpu];

		MCACHE_LOCK(&amp;ccp-&gt;cc_lock);

		btp = cp-&gt;cache_bkttype;
		bp = ccp-&gt;cc_filled;
		pbp = ccp-&gt;cc_pfilled;
		objs = ccp-&gt;cc_objs;
		pobjs = ccp-&gt;cc_pobjs;
		ccp-&gt;cc_filled = NULL;
		ccp-&gt;cc_pfilled = NULL;
		ccp-&gt;cc_objs = -1;
		ccp-&gt;cc_pobjs = -1;
		ccp-&gt;cc_bktsize = 0;

		MCACHE_UNLOCK(&amp;ccp-&gt;cc_lock);

		<span class="enscript-keyword">if</span> (bp != NULL)
			mcache_bkt_destroy(cp, btp, bp, objs);
		<span class="enscript-keyword">if</span> (pbp != NULL)
			mcache_bkt_destroy(cp, btp, pbp, pobjs);
	}

	<span class="enscript-comment">/*
	 * Updating the working set back to back essentially sets
	 * the working set size to zero, so everything is reapable.
	 */</span>
	mcache_bkt_ws_update(cp);
	mcache_bkt_ws_update(cp);

	mcache_bkt_ws_reap(cp);
}

<span class="enscript-comment">/*
 * Free one or more objects in the bucket to the slab layer,
 * and also free the bucket itself.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_bkt_destroy</span>(mcache_t *cp, mcache_bkttype_t *btp, mcache_bkt_t *bkt,
    <span class="enscript-type">int</span> nobjs)
{
	<span class="enscript-keyword">if</span> (nobjs &gt; 0) {
		mcache_obj_t *top = bkt-&gt;bkt_obj[nobjs - 1];

		<span class="enscript-keyword">if</span> (cp-&gt;mc_flags &amp; MCF_DEBUG) {
			mcache_obj_t *o = top;
			<span class="enscript-type">int</span> cnt = 0;

			<span class="enscript-comment">/*
			 * Verify that the chain of objects in the bucket is
			 * valid.  Any mismatch here means a mistake when the
			 * object(s) were freed to the CPU layer, so we panic.
			 */</span>
			<span class="enscript-keyword">while</span> (o != NULL) {
				o = o-&gt;obj_next;
				++cnt;
			}
			<span class="enscript-keyword">if</span> (cnt != nobjs) {
				panic(<span class="enscript-string">&quot;mcache_bkt_destroy: %s cp %p corrupted &quot;</span>
				    <span class="enscript-string">&quot;list in bkt %p (nobjs %d actual %d)\n&quot;</span>,
				    cp-&gt;mc_name, (<span class="enscript-type">void</span> *)cp, (<span class="enscript-type">void</span> *)bkt,
				    nobjs, cnt);
			}
		}

		<span class="enscript-comment">/* Advise the slab layer to purge the object(s) */</span>
		(*cp-&gt;mc_slab_free)(cp-&gt;mc_private, top,
		    (cp-&gt;mc_flags &amp; MCF_DEBUG) || cp-&gt;mc_purge_cnt);
	}
	mcache_free(btp-&gt;bt_cache, bkt);
}

<span class="enscript-comment">/*
 * Update the bucket layer working set statistics.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_bkt_ws_update</span>(mcache_t *cp)
{
	MCACHE_LOCK(&amp;cp-&gt;mc_bkt_lock);

	cp-&gt;mc_full.bl_reaplimit = cp-&gt;mc_full.bl_min;
	cp-&gt;mc_full.bl_min = cp-&gt;mc_full.bl_total;
	cp-&gt;mc_empty.bl_reaplimit = cp-&gt;mc_empty.bl_min;
	cp-&gt;mc_empty.bl_min = cp-&gt;mc_empty.bl_total;

	MCACHE_UNLOCK(&amp;cp-&gt;mc_bkt_lock);
}

<span class="enscript-comment">/*
 * Reap all buckets that are beyond the working set.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_bkt_ws_reap</span>(mcache_t *cp)
{
	<span class="enscript-type">long</span> reap;
	mcache_bkt_t *bkt;
	mcache_bkttype_t *btp;

	reap = MIN(cp-&gt;mc_full.bl_reaplimit, cp-&gt;mc_full.bl_min);
	<span class="enscript-keyword">while</span> (reap-- &amp;&amp;
	    (bkt = mcache_bkt_alloc(cp, &amp;cp-&gt;mc_full, &amp;btp)) != NULL)
		mcache_bkt_destroy(cp, btp, bkt, btp-&gt;bt_bktsize);

	reap = MIN(cp-&gt;mc_empty.bl_reaplimit, cp-&gt;mc_empty.bl_min);
	<span class="enscript-keyword">while</span> (reap-- &amp;&amp;
	    (bkt = mcache_bkt_alloc(cp, &amp;cp-&gt;mc_empty, &amp;btp)) != NULL)
		mcache_bkt_destroy(cp, btp, bkt, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_reap_timeout</span>(thread_call_param_t dummy __unused,
    thread_call_param_t arg)
{
	<span class="enscript-type">volatile</span> UInt32 *flag = arg;

	ASSERT(flag == &amp;mcache_reaping);

	*flag = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_reap_done</span>(<span class="enscript-type">void</span> *flag)
{
	uint64_t deadline, leeway;

	clock_interval_to_deadline(mcache_reap_interval, NSEC_PER_SEC,
	    &amp;deadline);
	clock_interval_to_absolutetime_interval(mcache_reap_interval_leeway,
	    NSEC_PER_SEC, &amp;leeway);
	thread_call_enter_delayed_with_leeway(mcache_reap_tcall, flag,
	    deadline, leeway, THREAD_CALL_DELAY_LEEWAY);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_reap_start</span>(<span class="enscript-type">void</span> *arg)
{
	UInt32 *flag = arg;

	ASSERT(flag == &amp;mcache_reaping);

	mcache_applyall(mcache_cache_reap);
	mcache_dispatch(mcache_reap_done, flag);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_reap</span>(<span class="enscript-type">void</span>)
{
	UInt32 *flag = &amp;mcache_reaping;

	<span class="enscript-keyword">if</span> (mcache_llock_owner == current_thread() ||
	    !OSCompareAndSwap(0, 1, flag))
		<span class="enscript-keyword">return</span>;

	mcache_dispatch(mcache_reap_start, flag);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_cache_reap</span>(mcache_t *cp)
{
	mcache_bkt_ws_reap(cp);
}

<span class="enscript-comment">/*
 * Performs period maintenance on a cache.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_cache_update</span>(mcache_t *cp)
{
	<span class="enscript-type">int</span> need_bkt_resize = 0;
	<span class="enscript-type">int</span> need_bkt_reenable = 0;

	lck_mtx_assert(mcache_llock, LCK_MTX_ASSERT_OWNED);

	mcache_bkt_ws_update(cp);

	<span class="enscript-comment">/*
	 * Cache resize and post-purge reenable are mutually exclusive.
	 * If the cache was previously purged, there is no point of
	 * increasing the bucket size as there was an indication of
	 * memory pressure on the system.
	 */</span>
	lck_mtx_lock_spin(&amp;cp-&gt;mc_sync_lock);
	<span class="enscript-keyword">if</span> (!(cp-&gt;mc_flags &amp; MCF_NOCPUCACHE) &amp;&amp; cp-&gt;mc_enable_cnt)
		need_bkt_reenable = 1;
	lck_mtx_unlock(&amp;cp-&gt;mc_sync_lock);

	MCACHE_LOCK(&amp;cp-&gt;mc_bkt_lock);
	<span class="enscript-comment">/*
	 * If the contention count is greater than the threshold, and if
	 * we are not already at the maximum bucket size, increase it.
	 * Otherwise, if this cache was previously purged by the user
	 * then we simply reenable it.
	 */</span>
	<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)cp-&gt;mc_chunksize &lt; cp-&gt;cache_bkttype-&gt;bt_maxbuf &amp;&amp;
	    (<span class="enscript-type">int</span>)(cp-&gt;mc_bkt_contention - cp-&gt;mc_bkt_contention_prev) &gt;
	    mcache_bkt_contention &amp;&amp; !need_bkt_reenable)
		need_bkt_resize = 1;

	cp -&gt;mc_bkt_contention_prev = cp-&gt;mc_bkt_contention;
	MCACHE_UNLOCK(&amp;cp-&gt;mc_bkt_lock);

	<span class="enscript-keyword">if</span> (need_bkt_resize)
		mcache_dispatch(mcache_cache_bkt_resize, cp);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (need_bkt_reenable)
		mcache_dispatch(mcache_cache_enable, cp);
}

<span class="enscript-comment">/*
 * Recompute a cache's bucket size.  This is an expensive operation
 * and should not be done frequently; larger buckets provide for a
 * higher transfer rate with the bucket while smaller buckets reduce
 * the memory consumption.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_cache_bkt_resize</span>(<span class="enscript-type">void</span> *arg)
{
	mcache_t *cp = arg;
	mcache_bkttype_t *btp = cp-&gt;cache_bkttype;

	<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)cp-&gt;mc_chunksize &lt; btp-&gt;bt_maxbuf) {
		mcache_bkt_purge(cp);

		<span class="enscript-comment">/*
		 * Upgrade to the next bucket type with larger bucket size;
		 * temporarily set the previous contention snapshot to a
		 * negative number to prevent unnecessary resize request.
		 */</span>
		MCACHE_LOCK(&amp;cp-&gt;mc_bkt_lock);
		cp-&gt;cache_bkttype = ++btp;
		cp -&gt;mc_bkt_contention_prev = cp-&gt;mc_bkt_contention + INT_MAX;
		MCACHE_UNLOCK(&amp;cp-&gt;mc_bkt_lock);

		mcache_cache_enable(cp);
	}
}

<span class="enscript-comment">/*
 * Reenable a previously disabled cache due to purge.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_cache_enable</span>(<span class="enscript-type">void</span> *arg)
{
	mcache_t *cp = arg;

	lck_mtx_lock_spin(&amp;cp-&gt;mc_sync_lock);
	cp-&gt;mc_purge_cnt = 0;
	cp-&gt;mc_enable_cnt = 0;
	lck_mtx_unlock(&amp;cp-&gt;mc_sync_lock);

	mcache_cache_bkt_enable(cp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_update_timeout</span>(__unused <span class="enscript-type">void</span> *arg)
{
	uint64_t deadline, leeway;

	clock_interval_to_deadline(mcache_reap_interval, NSEC_PER_SEC,
	    &amp;deadline);
	clock_interval_to_absolutetime_interval(mcache_reap_interval_leeway,
	    NSEC_PER_SEC, &amp;leeway);
	thread_call_enter_delayed_with_leeway(mcache_update_tcall, NULL,
	    deadline, leeway, THREAD_CALL_DELAY_LEEWAY);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_update</span>(thread_call_param_t arg __unused,
    thread_call_param_t dummy __unused)
{
	mcache_applyall(mcache_cache_update);
	mcache_update_timeout(NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_applyall</span>(<span class="enscript-type">void</span> (*func)(mcache_t *))
{
	mcache_t *cp;

	MCACHE_LIST_LOCK();
	LIST_FOREACH(cp, &amp;mcache_head, mc_list) {
		func(cp);
	}
	MCACHE_LIST_UNLOCK();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_dispatch</span>(<span class="enscript-type">void</span> (*func)(<span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *arg)
{
	ASSERT(func != NULL);
	timeout(func, arg, hz/1000);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_buffer_log</span>(mcache_audit_t *mca, <span class="enscript-type">void</span> *addr, mcache_t *cp,
    <span class="enscript-type">struct</span> timeval *base_ts)
{
	<span class="enscript-type">struct</span> timeval now, base = { 0, 0 };
	<span class="enscript-type">void</span> *stack[MCACHE_STACK_DEPTH + 1];
	<span class="enscript-type">struct</span> mca_trn *transaction;

	transaction = &amp;mca-&gt;mca_trns[mca-&gt;mca_next_trn];

	mca-&gt;mca_addr = addr;
	mca-&gt;mca_cache = cp;

	transaction-&gt;mca_thread = current_thread();

	bzero(stack, <span class="enscript-keyword">sizeof</span> (stack));
	transaction-&gt;mca_depth = OSBacktrace(stack, MCACHE_STACK_DEPTH + 1) - 1;
	bcopy(&amp;stack[1], transaction-&gt;mca_stack,
		<span class="enscript-keyword">sizeof</span> (transaction-&gt;mca_stack));

	microuptime(&amp;now);
	<span class="enscript-keyword">if</span> (base_ts != NULL)
		base = *base_ts;
	<span class="enscript-comment">/* tstamp is in ms relative to base_ts */</span>
	transaction-&gt;mca_tstamp = ((now.tv_usec - base.tv_usec) / 1000);
	<span class="enscript-keyword">if</span> ((now.tv_sec - base.tv_sec) &gt; 0)
		transaction-&gt;mca_tstamp += ((now.tv_sec - base.tv_sec) * 1000);

	mca-&gt;mca_next_trn =
		(mca-&gt;mca_next_trn + 1) % mca_trn_max;
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_set_pattern</span>(u_int64_t pattern, <span class="enscript-type">void</span> *buf_arg, size_t size)
{
	u_int64_t *buf_end = (u_int64_t *)((<span class="enscript-type">void</span> *)((<span class="enscript-type">char</span> *)buf_arg + size));
	u_int64_t *buf = (u_int64_t *)buf_arg;

	VERIFY(IS_P2ALIGNED(buf_arg, <span class="enscript-keyword">sizeof</span> (u_int64_t)));
	VERIFY(IS_P2ALIGNED(size, <span class="enscript-keyword">sizeof</span> (u_int64_t)));

	<span class="enscript-keyword">while</span> (buf &lt; buf_end)
		*buf++ = pattern;
}

__private_extern__ <span class="enscript-type">void</span> *
<span class="enscript-function-name">mcache_verify_pattern</span>(u_int64_t pattern, <span class="enscript-type">void</span> *buf_arg, size_t size)
{
	u_int64_t *buf_end = (u_int64_t *)((<span class="enscript-type">void</span> *)((<span class="enscript-type">char</span> *)buf_arg + size));
	u_int64_t *buf;

	VERIFY(IS_P2ALIGNED(buf_arg, <span class="enscript-keyword">sizeof</span> (u_int64_t)));
	VERIFY(IS_P2ALIGNED(size, <span class="enscript-keyword">sizeof</span> (u_int64_t)));

	<span class="enscript-keyword">for</span> (buf = buf_arg; buf &lt; buf_end; buf++) {
		<span class="enscript-keyword">if</span> (*buf != pattern)
			<span class="enscript-keyword">return</span> (buf);
	}
	<span class="enscript-keyword">return</span> (NULL);
}

__private_extern__ <span class="enscript-type">void</span> *
<span class="enscript-function-name">mcache_verify_set_pattern</span>(u_int64_t old, u_int64_t new, <span class="enscript-type">void</span> *buf_arg,
    size_t size)
{
	u_int64_t *buf_end = (u_int64_t *)((<span class="enscript-type">void</span> *)((<span class="enscript-type">char</span> *)buf_arg + size));
	u_int64_t *buf;

	VERIFY(IS_P2ALIGNED(buf_arg, <span class="enscript-keyword">sizeof</span> (u_int64_t)));
	VERIFY(IS_P2ALIGNED(size, <span class="enscript-keyword">sizeof</span> (u_int64_t)));

	<span class="enscript-keyword">for</span> (buf = buf_arg; buf &lt; buf_end; buf++) {
		<span class="enscript-keyword">if</span> (*buf != old) {
			mcache_set_pattern(old, buf_arg,
			    (uintptr_t)buf - (uintptr_t)buf_arg);
			<span class="enscript-keyword">return</span> (buf);
		}
		*buf = new;
	}
	<span class="enscript-keyword">return</span> (NULL);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_audit_free_verify</span>(mcache_audit_t *mca, <span class="enscript-type">void</span> *base, size_t offset,
    size_t size)
{
	<span class="enscript-type">void</span> *addr;
	u_int64_t *oaddr64;
	mcache_obj_t *next;

	addr = (<span class="enscript-type">void</span> *)((uintptr_t)base + offset);
	next = ((mcache_obj_t *)addr)-&gt;obj_next;

	<span class="enscript-comment">/* For the &quot;obj_next&quot; pointer in the buffer */</span>
	oaddr64 = (u_int64_t *)P2ROUNDDOWN(addr, <span class="enscript-keyword">sizeof</span> (u_int64_t));
	*oaddr64 = MCACHE_FREE_PATTERN;

	<span class="enscript-keyword">if</span> ((oaddr64 = mcache_verify_pattern(MCACHE_FREE_PATTERN,
	    (caddr_t)base, size)) != NULL) {
		mcache_audit_panic(mca, addr, (caddr_t)oaddr64 - (caddr_t)base,
		    (int64_t)MCACHE_FREE_PATTERN, (int64_t)*oaddr64);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	((mcache_obj_t *)addr)-&gt;obj_next = next;
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_audit_free_verify_set</span>(mcache_audit_t *mca, <span class="enscript-type">void</span> *base, size_t offset,
    size_t size)
{
	<span class="enscript-type">void</span> *addr;
	u_int64_t *oaddr64;
	mcache_obj_t *next;

	addr = (<span class="enscript-type">void</span> *)((uintptr_t)base + offset);
	next = ((mcache_obj_t *)addr)-&gt;obj_next;

	<span class="enscript-comment">/* For the &quot;obj_next&quot; pointer in the buffer */</span>
	oaddr64 = (u_int64_t *)P2ROUNDDOWN(addr, <span class="enscript-keyword">sizeof</span> (u_int64_t));
	*oaddr64 = MCACHE_FREE_PATTERN;

	<span class="enscript-keyword">if</span> ((oaddr64 = mcache_verify_set_pattern(MCACHE_FREE_PATTERN,
	    MCACHE_UNINITIALIZED_PATTERN, (caddr_t)base, size)) != NULL) {
		mcache_audit_panic(mca, addr, (caddr_t)oaddr64 - (caddr_t)base,
		    (int64_t)MCACHE_FREE_PATTERN, (int64_t)*oaddr64);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	((mcache_obj_t *)addr)-&gt;obj_next = next;
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">panic</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DUMP_TRN_FMT</span>() \
	    <span class="enscript-string">&quot;%s transaction thread %p saved PC stack (%d deep):\n&quot;</span> \
	    <span class="enscript-string">&quot;\t%p, %p, %p, %p, %p, %p, %p, %p\n&quot;</span> \
	    <span class="enscript-string">&quot;\t%p, %p, %p, %p, %p, %p, %p, %p\n&quot;</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DUMP_TRN_FIELDS</span>(s, x) \
	    s, \
	    mca-&gt;mca_trns[x].mca_thread, mca-&gt;mca_trns[x].mca_depth, \
	    mca-&gt;mca_trns[x].mca_stack[0], mca-&gt;mca_trns[x].mca_stack[1], \
	    mca-&gt;mca_trns[x].mca_stack[2], mca-&gt;mca_trns[x].mca_stack[3], \
	    mca-&gt;mca_trns[x].mca_stack[4], mca-&gt;mca_trns[x].mca_stack[5], \
	    mca-&gt;mca_trns[x].mca_stack[6], mca-&gt;mca_trns[x].mca_stack[7], \
	    mca-&gt;mca_trns[x].mca_stack[8], mca-&gt;mca_trns[x].mca_stack[9], \
	    mca-&gt;mca_trns[x].mca_stack[10], mca-&gt;mca_trns[x].mca_stack[11], \
	    mca-&gt;mca_trns[x].mca_stack[12], mca-&gt;mca_trns[x].mca_stack[13], \
	    mca-&gt;mca_trns[x].mca_stack[14], mca-&gt;mca_trns[x].mca_stack[15]

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCA_TRN_LAST</span> ((mca-&gt;mca_next_trn + mca_trn_max) % mca_trn_max)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCA_TRN_PREV</span> ((mca-&gt;mca_next_trn + mca_trn_max - 1) % mca_trn_max)

__private_extern__ <span class="enscript-type">char</span> *
<span class="enscript-function-name">mcache_dump_mca</span>(mcache_audit_t *mca)
{
	<span class="enscript-keyword">if</span> (mca_dump_buf == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	snprintf(mca_dump_buf, DUMP_MCA_BUF_SIZE,
	    <span class="enscript-string">&quot;mca %p: addr %p, cache %p (%s) nxttrn %d\n&quot;</span>
	    DUMP_TRN_FMT()
	    DUMP_TRN_FMT(),

	    mca, mca-&gt;mca_addr, mca-&gt;mca_cache,
	    mca-&gt;mca_cache ? mca-&gt;mca_cache-&gt;mc_name : <span class="enscript-string">&quot;?&quot;</span>,
	    mca-&gt;mca_next_trn,

	    DUMP_TRN_FIELDS(<span class="enscript-string">&quot;last&quot;</span>, MCA_TRN_LAST),
	    DUMP_TRN_FIELDS(<span class="enscript-string">&quot;previous&quot;</span>, MCA_TRN_PREV));

	<span class="enscript-keyword">return</span> (mca_dump_buf);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mcache_audit_panic</span>(mcache_audit_t *mca, <span class="enscript-type">void</span> *addr, size_t offset,
    int64_t expected, int64_t got)
{
	<span class="enscript-keyword">if</span> (mca == NULL) {
		panic(<span class="enscript-string">&quot;mcache_audit: buffer %p modified after free at &quot;</span>
		    <span class="enscript-string">&quot;offset 0x%lx (0x%llx instead of 0x%llx)\n&quot;</span>, addr,
		    offset, got, expected);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	panic(<span class="enscript-string">&quot;mcache_audit: buffer %p modified after free at offset 0x%lx &quot;</span>
	    <span class="enscript-string">&quot;(0x%llx instead of 0x%llx)\n%s\n&quot;</span>,
	    addr, offset, got, expected, mcache_dump_mca(mca));
	<span class="enscript-comment">/* NOTREACHED */</span>
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">assfail</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *f, <span class="enscript-type">int</span> l)
{
	panic(<span class="enscript-string">&quot;assertion failed: %s, file: %s, line: %d&quot;</span>, a, f, l);
	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>