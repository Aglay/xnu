<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>if_utun_crypto_dtls.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">if_utun_crypto_dtls.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_utun.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_utun.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_utun_crypto_dtls.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bpf.h&gt;</span>

<span class="enscript-type">extern</span> errno_t <span class="enscript-function-name">utun_pkt_input</span> (<span class="enscript-type">struct</span> utun_pcb *pcb, mbuf_t m);

<span class="enscript-type">static</span> UInt32                               dtls_kpi_callbacks_inited = FALSE;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>                         dtls_kpi_flags = 0;
<span class="enscript-type">static</span> utun_crypto_kpi_connect_func         dtls_kpi_connect = (__typeof__(dtls_kpi_connect))NULL;
<span class="enscript-type">static</span> utun_crypto_kpi_send_func            dtls_kpi_send = (__typeof__(dtls_kpi_send))NULL;

<span class="enscript-comment">// convert this mutex to shared lock
</span><span class="enscript-type">static</span> UInt32             dtls_ctl_mutex_inited = FALSE;
<span class="enscript-type">static</span> lck_grp_t         *dtls_ctl_mutex_grp = NULL;
<span class="enscript-type">static</span> lck_grp_attr_t    *dtls_ctl_mutex_grp_attr = NULL;
<span class="enscript-type">static</span> lck_attr_t        *dtls_ctl_mutex_attr = NULL;
<span class="enscript-type">static</span> lck_mtx_t          dtls_ctl_mutex;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">utun_ctl_get_first_framer</span>(ctx, inner_type) (utun_crypto_framer_t *)LIST_FIRST(&amp;ctx-&gt;framer_listheads[UTUN_CRYPTO_INNER_TYPE_TO_IDX(inner_type)])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">utun_get_framer_listhead</span>(ctx, inner_type) &amp;ctx-&gt;framer_listheads[UTUN_CRYPTO_INNER_TYPE_TO_IDX(inner_type)]

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_clr_dtls_framer</span> (utun_crypto_framer_t *rem_framer)
{
	<span class="enscript-keyword">if</span> (!rem_framer) <span class="enscript-keyword">return</span>;

	<span class="enscript-comment">// TOFIX: switch to BPF
</span>	LIST_REMOVE(rem_framer, framer_chain); <span class="enscript-comment">// unchain the framer
</span>	<span class="enscript-keyword">if</span> (rem_framer-&gt;dir == UTUN_CRYPTO_DIR_IN) {
		<span class="enscript-keyword">if</span> (utun_crypto_framer_state_dtls_in(rem_framer).in_pattern) {
			utun_free(utun_crypto_framer_state_dtls_in(rem_framer).in_pattern);
		}
		<span class="enscript-keyword">if</span> (utun_crypto_framer_state_dtls_in(rem_framer).in_pattern_mask) {
			utun_free(utun_crypto_framer_state_dtls_in(rem_framer).in_pattern_mask);
		}
		<span class="enscript-keyword">if</span> (utun_crypto_framer_state_dtls_in(rem_framer).in_pattern_masked) {
			utun_free(utun_crypto_framer_state_dtls_in(rem_framer).in_pattern_masked);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (utun_crypto_framer_state_dtls_out(rem_framer).out_pattern) {
			utun_free(utun_crypto_framer_state_dtls_out(rem_framer).out_pattern);
		}
	}
	utun_free(rem_framer);
	
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_clr_dtls_framers</span> (utun_crypto_framer_t *first_framer)
{
	utun_crypto_framer_t *cur_framer, *nxt_framer;
	
	<span class="enscript-comment">// check framer-&gt;state.u.dtls.u.in.listhead for duplicates;
</span>	<span class="enscript-keyword">for</span> (cur_framer = first_framer;
		 cur_framer != NULL;
		 cur_framer = nxt_framer) {
		nxt_framer = (__typeof__(nxt_framer))LIST_NEXT(cur_framer, framer_chain);
		utun_ctl_clr_dtls_framer(cur_framer);
	}
	
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_clr_dtls_all_framers</span> (utun_crypto_ctx_t *crypto_ctx)
{
	utun_ctl_clr_dtls_framers(utun_ctl_get_first_framer(crypto_ctx, UTUN_CRYPTO_INNER_TYPE_IPv4));
	utun_ctl_clr_dtls_framers(utun_ctl_get_first_framer(crypto_ctx, UTUN_CRYPTO_INNER_TYPE_IPv6));
	crypto_ctx-&gt;num_framers = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_restart_dtls_framers</span> (utun_crypto_framer_t *first_framer)
{
	utun_crypto_framer_t *cur_framer;
	
	<span class="enscript-comment">// check framer-&gt;state.u.dtls.u.in.listhead for duplicates;
</span>	<span class="enscript-keyword">for</span> (cur_framer = first_framer;
		 cur_framer != NULL;
		 cur_framer = (__typeof__(cur_framer))LIST_NEXT(cur_framer, framer_chain)) {
		utun_crypto_framer_state_dtls_out(cur_framer).sequence_field = utun_crypto_framer_state_dtls_out(cur_framer).sequence_field_initval;
	}
	
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_restart_dtls_all_framers</span> (utun_crypto_ctx_t *crypto_ctx)
{
	utun_ctl_restart_dtls_framers(utun_ctl_get_first_framer(crypto_ctx, UTUN_CRYPTO_INNER_TYPE_IPv4));
	utun_ctl_restart_dtls_framers(utun_ctl_get_first_framer(crypto_ctx, UTUN_CRYPTO_INNER_TYPE_IPv6));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">is_pattern_all_zeroes</span> (u_int8_t *pattern,
					   <span class="enscript-type">int</span>       pattern_len)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (!pattern || !pattern_len) <span class="enscript-keyword">return</span> FALSE; <span class="enscript-comment">// false if args are NULL
</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; pattern_len; i++) {
		<span class="enscript-keyword">if</span> (pattern[i] != 0) <span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">is_pattern_masked_all_zeroes</span> (u_int8_t *pattern,
							  u_int8_t *pattern_mask,
							  <span class="enscript-type">int</span>       pattern_len)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (!pattern || !pattern_mask || !pattern_len) <span class="enscript-keyword">return</span> FALSE; <span class="enscript-comment">// false if args are NULL
</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; pattern_len; i++) {
		<span class="enscript-keyword">if</span> ((pattern[i] &amp; pattern_mask[i])) <span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_calc_dtls_framer_pattern_and_mask</span> (u_int8_t *pattern_masked, u_int8_t *pattern, u_int8_t *mask, <span class="enscript-type">int</span> len)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; len; i++) {
		pattern_masked[i] = (pattern[i] &amp; mask[i]);
	}
}

<span class="enscript-type">static</span> Boolean
<span class="enscript-function-name">utun_ctl_did_dtls_framer_pattern_match</span> (u_int8_t *input, u_int8_t *pattern_masked, <span class="enscript-type">int</span> len)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; len; i++) {
		<span class="enscript-keyword">if</span> ((input[i] &amp; pattern_masked[i]) != pattern_masked[i]) <span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-type">static</span> Boolean
<span class="enscript-function-name">utun_pkt_dtls_input_frame_is_data</span>(utun_crypto_ctx_t *crypto_ctx,
				  mbuf_t            *pkt,
				  protocol_family_t  family,
				  <span class="enscript-type">int</span>               *striplen)
{
	u_int8_t *p;
	utun_crypto_framer_t *cur_framer;

	p = mtod(*pkt, __typeof__(p));
	<span class="enscript-keyword">for</span> (cur_framer = utun_ctl_get_first_framer(crypto_ctx, utun_crypto_framer_protocol_family_to_inner_type(family));
	     cur_framer != NULL;
	     cur_framer = (__typeof__(cur_framer))LIST_NEXT(cur_framer, framer_chain)) {
		<span class="enscript-keyword">if</span> (m_pktlen(*pkt) &lt; utun_crypto_framer_state_dtls_in(cur_framer).in_pattern_len) {
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> ((*pkt)-&gt;m_len &lt; utun_crypto_framer_state_dtls_in(cur_framer).in_pattern_len) {
		  *pkt = m_pullup(*pkt, utun_crypto_framer_state_dtls_in(cur_framer).in_pattern_len);
			<span class="enscript-keyword">if</span> (!*pkt ||
			    (*pkt)-&gt;m_len &lt; utun_crypto_framer_state_dtls_in(cur_framer).in_pattern_len) {
				<span class="enscript-keyword">return</span> FALSE;
			}
			p = mtod(*pkt, __typeof__(p));
		}
		<span class="enscript-comment">// TOFIX: switch to BPF
</span>		<span class="enscript-keyword">if</span> (utun_ctl_did_dtls_framer_pattern_match(p,
							   utun_crypto_framer_state_dtls_in(cur_framer).in_pattern_masked,
							   utun_crypto_framer_state_dtls_in(cur_framer).in_pattern_len)) {
			*striplen = utun_crypto_framer_state_dtls_in(cur_framer).in_data_offset;
			<span class="enscript-keyword">return</span> TRUE;
		}
	}
	<span class="enscript-keyword">return</span> FALSE;
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">GETLONG</span>(l, cp) {               \
	(l) = *(cp)++ &lt;&lt; 8;	       \
	(l) |= *(cp)++; (l) &lt;&lt;= 8;     \
	(l) |= *(cp)++; (l) &lt;&lt;= 8;     \
	(l) |= *(cp)++;		       \
  }
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PUTLONG</span>(l, cp) {                \
	*(cp)++ = (u_char) ((l) &gt;&gt; 24); \
	*(cp)++ = (u_char) ((l) &gt;&gt; 16); \
	*(cp)++ = (u_char) ((l) &gt;&gt; 8);	\
	*(cp)++ = (u_char) (l);		\
  }

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">utun_pkt_dtls_output_frame_encapsulate</span> (utun_crypto_ctx_t *crypto_ctx,
					mbuf_t            *pkt,
					protocol_family_t  proto)
{
	u_int8_t *p;
	utun_crypto_framer_t *cur_framer;
	u_int32_t pkt_len;

	<span class="enscript-comment">// TOFIX: switch to BPF
</span>
	<span class="enscript-keyword">if</span> (!crypto_ctx-&gt;num_framers) {
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-keyword">if</span> (proto != AF_INET &amp;&amp; proto != AF_INET6) {
		printf(<span class="enscript-string">&quot;%s: unsupported proto %d\n&quot;</span>, __FUNCTION__, proto);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">for</span> (cur_framer = utun_ctl_get_first_framer(crypto_ctx, utun_crypto_framer_protocol_family_to_inner_type(proto));
	     cur_framer != NULL &amp;&amp; !utun_crypto_framer_state_dtls_out(cur_framer).out_pattern;
	     cur_framer = (__typeof__(cur_framer))LIST_NEXT(cur_framer, framer_chain));
	<span class="enscript-keyword">if</span> (!cur_framer ||
	    !utun_crypto_framer_state_dtls_out(cur_framer).out_pattern_len) {
		<span class="enscript-keyword">return</span> 0;
	}

	pkt_len = m_pktlen(*pkt);

	<span class="enscript-comment">// prepend/encapsulate the output pattern
</span>	<span class="enscript-keyword">if</span> (mbuf_prepend(pkt, utun_crypto_framer_state_dtls_out(cur_framer).out_pattern_len, MBUF_DONTWAIT) != 0) {
		printf(<span class="enscript-string">&quot;%s - ifnet_output prepend failed\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> ENOBUFS;
	}

	p = mtod(*pkt, __typeof__(p));
	memcpy(p,
	       utun_crypto_framer_state_dtls_out(cur_framer).out_pattern,
	       utun_crypto_framer_state_dtls_out(cur_framer).out_pattern_len);
	<span class="enscript-comment">// fill a &quot;length&quot; field... if configured
</span>	<span class="enscript-keyword">if</span> (utun_crypto_framer_state_dtls_out(cur_framer).len_field_mask) {
		u_int32_t  tmp;
		u_int8_t  *q = p + utun_crypto_framer_state_dtls_out(cur_framer).len_field_offset;
		GETLONG(tmp, q);
		tmp &amp;= ((pkt_len + utun_crypto_framer_state_dtls_out(cur_framer).len_field_extra) &amp; utun_crypto_framer_state_dtls_out(cur_framer).len_field_mask);
		q = p + utun_crypto_framer_state_dtls_out(cur_framer).len_field_offset;
		PUTLONG(tmp, q);
	}
	<span class="enscript-comment">// fill a &quot;sequence&quot; field... if configured
</span>	<span class="enscript-keyword">if</span> (utun_crypto_framer_state_dtls_out(cur_framer).sequence_field_mask) {
		u_int32_t  tmp = (utun_crypto_framer_state_dtls_out(cur_framer).sequence_field &amp; utun_crypto_framer_state_dtls_out(cur_framer).sequence_field_mask);
		u_int8_t  *q = p + utun_crypto_framer_state_dtls_out(cur_framer).sequence_field_offset;
		GETLONG(tmp, q);
		tmp &amp;= (utun_crypto_framer_state_dtls_out(cur_framer).sequence_field &amp; utun_crypto_framer_state_dtls_out(cur_framer).sequence_field_mask);
		q = p + utun_crypto_framer_state_dtls_out(cur_framer).sequence_field_offset;
		PUTLONG(tmp, q);
		utun_crypto_framer_state_dtls_out(cur_framer).sequence_field++;
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_init_crypto_dtls</span> (<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (OSCompareAndSwap(FALSE, TRUE, &amp;dtls_ctl_mutex_inited)) {
		<span class="enscript-keyword">if</span> (!dtls_ctl_mutex_grp_attr)
			dtls_ctl_mutex_grp_attr = lck_grp_attr_alloc_init();
		<span class="enscript-keyword">if</span> (!dtls_ctl_mutex_grp)
			dtls_ctl_mutex_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;utun-crypto&quot;</span>, dtls_ctl_mutex_grp_attr);
		<span class="enscript-keyword">if</span> (!dtls_ctl_mutex_attr)
			dtls_ctl_mutex_attr = lck_attr_alloc_init();

		lck_mtx_init(&amp;dtls_ctl_mutex, dtls_ctl_mutex_grp, dtls_ctl_mutex_attr);
	}
}

<span class="enscript-comment">/*
 * Summary: registers the DTLS Kext routines with UTUN... so that UTUN can make calls into DTLS
 */</span>
errno_t
<span class="enscript-function-name">utun_ctl_register_dtls</span> (utun_crypto_kpi_reg_t *reg)
{
	<span class="enscript-comment">//printf(&quot;%s: entering\n&quot;, __FUNCTION__);
</span>	<span class="enscript-keyword">if</span> (!reg) <span class="enscript-keyword">return</span> EINVAL;

	<span class="enscript-comment">//printf(&quot;%s: type %d\n&quot;, __FUNCTION__, reg-&gt;crypto_kpi_type);
</span>	<span class="enscript-keyword">if</span> (reg-&gt;crypto_kpi_type != UTUN_CRYPTO_TYPE_DTLS) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (!reg-&gt;crypto_kpi_connect) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (!reg-&gt;crypto_kpi_send) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">//	printf(&quot;%s: pre-value of dtls_kpi_callbacks_inited %lu\n&quot;, __FUNCTION__,
</span>	<span class="enscript-comment">//       dtls_kpi_callbacks_inited);
</span>	<span class="enscript-keyword">if</span> (OSCompareAndSwap(FALSE, TRUE, &amp;dtls_kpi_callbacks_inited)) {
		dtls_kpi_flags = reg-&gt;crypto_kpi_flags;
		dtls_kpi_connect = reg-&gt;crypto_kpi_connect;
		dtls_kpi_send = reg-&gt;crypto_kpi_send;
	}
	<span class="enscript-comment">//printf(&quot;%s: post-value of dtls_kpi_callbacks_inited %lu\n&quot;, __FUNCTION__,
</span>	<span class="enscript-comment">//       dtls_kpi_callbacks_inited);
</span>	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Summary: enables dtls crypto info for the specified utun. dtls ref is passed into args.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_enable_crypto_dtls</span>(<span class="enscript-type">struct</span> utun_pcb   *pcb, utun_crypto_args_t *args)
{
	utun_crypto_ctx_t *crypto_ctx;

	lck_mtx_lock(&amp;dtls_ctl_mutex);

	<span class="enscript-comment">//printf(&quot;%s: entering, flags %x, kpi-handle %x, kpi-ref %p, kpi-refcnt %d\n&quot;, __FUNCTION__, pcb-&gt;utun_flags, crypto_ctx-&gt;kpi_handle, crypto_ctx-&gt;kpi_ref, crypto_ctx-&gt;kpi_refcnt);
</span>	
	crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[UTUN_CRYPTO_DIR_TO_IDX(UTUN_CRYPTO_DIR_IN)];
	<span class="enscript-keyword">if</span> (crypto_ctx-&gt;valid) {
		printf(<span class="enscript-string">&quot;%s: dtls already enabled (prev %u, now %u)\n&quot;</span>, __FUNCTION__,
		       crypto_ctx-&gt;kpi_handle, args-&gt;u.dtls_v1.kpi_handle);
		lck_mtx_unlock(&amp;dtls_ctl_mutex);
		<span class="enscript-keyword">return</span>;
	}

	crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[UTUN_CRYPTO_DIR_TO_IDX(UTUN_CRYPTO_DIR_OUT)];
	<span class="enscript-keyword">if</span> (!crypto_ctx-&gt;valid) {
		crypto_ctx-&gt;kpi_handle = args-&gt;u.dtls_v1.kpi_handle;
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;%s: dtls already enabled for egress (prev %u, now %u)\n&quot;</span>, __FUNCTION__,
		       crypto_ctx-&gt;kpi_handle, args-&gt;u.dtls_v1.kpi_handle);
		lck_mtx_unlock(&amp;dtls_ctl_mutex);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">// crypto_ctx-&gt;valid will be set in utun_ctl_enable_crypto
</span>	lck_mtx_unlock(&amp;dtls_ctl_mutex);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Summary: disables dtls crypto info for the specified utun.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_disable_crypto_dtls</span>(<span class="enscript-type">struct</span> utun_pcb   *pcb)
{
	utun_crypto_ctx_t *crypto_ctx;

	lck_mtx_lock(&amp;dtls_ctl_mutex);

	<span class="enscript-comment">//printf(&quot;%s: entering, flags %x, kpi-handle %d, kpi-ref %p, kpi-refcnt %d\n&quot;, __FUNCTION__, pcb-&gt;utun_flags, crypto_ctx-&gt;kpi_handle, crypto_ctx-&gt;kpi_ref, crypto_ctx-&gt;kpi_refcnt);
</span>	
	crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[UTUN_CRYPTO_DIR_TO_IDX(UTUN_CRYPTO_DIR_IN)];
	<span class="enscript-keyword">if</span> (crypto_ctx-&gt;valid &amp;&amp;
	    crypto_ctx-&gt;type == UTUN_CRYPTO_TYPE_DTLS) {
		utun_ctl_clr_dtls_all_framers(crypto_ctx);
	}

	crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[UTUN_CRYPTO_DIR_TO_IDX(UTUN_CRYPTO_DIR_OUT)];
	<span class="enscript-keyword">if</span> (!crypto_ctx-&gt;valid ||
	    crypto_ctx-&gt;type != UTUN_CRYPTO_TYPE_DTLS) {
		lck_mtx_unlock(&amp;dtls_ctl_mutex);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (crypto_ctx-&gt;kpi_ref) {
		<span class="enscript-keyword">if</span> (dtls_kpi_connect) {
			(<span class="enscript-type">void</span>)dtls_kpi_connect(crypto_ctx-&gt;kpi_handle, NULL);
			<span class="enscript-keyword">if</span> (--crypto_ctx-&gt;kpi_refcnt == 0) {
				crypto_ctx-&gt;kpi_ref = (__typeof__(crypto_ctx-&gt;kpi_ref))NULL;
				crypto_ctx-&gt;kpi_handle = UTUN_CRYPTO_DTLS_HANDLE_INVALID;
			} <span class="enscript-keyword">else</span> {
			  <span class="enscript-comment">//				printf(&quot;%s: ### dtls_kpi_refcnt %d not yet zero\n&quot;,
</span>			  <span class="enscript-comment">//				       __FUNCTION__, crypto_ctx-&gt;kpi_refcnt);
</span>			}
		} <span class="enscript-keyword">else</span> {
			printf(<span class="enscript-string">&quot;%s: ### dtls_ctl_connect unavailable\n&quot;</span>, __FUNCTION__);
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (crypto_ctx-&gt;kpi_handle &lt; 0) {
			printf(<span class="enscript-string">&quot;%s: dtls already disabled\n&quot;</span>, __FUNCTION__);
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span>;
		}
		crypto_ctx-&gt;kpi_handle = UTUN_CRYPTO_DTLS_HANDLE_INVALID;
	}
	utun_ctl_clr_dtls_all_framers(crypto_ctx);
	lck_mtx_unlock(&amp;dtls_ctl_mutex);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> utun_crypto_framer_t *
<span class="enscript-function-name">utun_ctl_get_dtls_in_framer</span> (utun_crypto_framer_t            *first_framer,
			     u_int8_t                        *in_pattern,
			     <span class="enscript-type">int</span>                              in_pattern_len,
			     u_int8_t                        *in_pattern_mask,
			     <span class="enscript-type">int</span>                              in_pattern_mask_len)
{
	utun_crypto_framer_t *cur_framer;

	<span class="enscript-comment">// check framer-&gt;u.listhead for duplicates;
</span>	<span class="enscript-keyword">for</span> (cur_framer = first_framer;
	     cur_framer != NULL;
	     cur_framer = (__typeof__(cur_framer))LIST_NEXT(cur_framer, framer_chain)) {
		<span class="enscript-comment">// TOFIX: use in_pattern_masked
</span>		<span class="enscript-keyword">if</span> (utun_crypto_framer_state_dtls_in(cur_framer).in_pattern_len == in_pattern_len &amp;&amp;
		    memcmp(utun_crypto_framer_state_dtls_in(cur_framer).in_pattern,
			   in_pattern,
			   in_pattern_len) == 0 &amp;&amp;
		    utun_crypto_framer_state_dtls_in(cur_framer).in_pattern_len == in_pattern_mask_len &amp;&amp;
		    memcmp(utun_crypto_framer_state_dtls_in(cur_framer).in_pattern_mask,
			   in_pattern_mask,
			   in_pattern_mask_len) == 0) {
			<span class="enscript-comment">// found
</span>			<span class="enscript-keyword">return</span> cur_framer;
		}
	}

	<span class="enscript-keyword">return</span> NULL;
}

errno_t
<span class="enscript-function-name">utun_ctl_config_crypto_dtls_framer</span> (utun_crypto_ctx_t         *crypto_ctx,
				    utun_crypto_framer_args_t *args)
{
	utun_crypto_framer_t *framer, *new_framer = NULL, *dup_framer;

	<span class="enscript-keyword">if</span> (args-&gt;ver != UTUN_CRYPTO_DTLS_VER_1) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> (!args-&gt;type || args-&gt;type &gt;= UTUN_CRYPTO_INNER_TYPE_MAX) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	lck_mtx_lock(&amp;dtls_ctl_mutex);

	<span class="enscript-keyword">if</span> (args-&gt;dir == UTUN_CRYPTO_DIR_IN) {
		<span class="enscript-comment">// Input framer (for tunnel hdr detection and decapsulation). there can be several pattern that identify data (vs. control) packets.
</span>
		<span class="enscript-comment">// First, the args need to be verified for errors/inconsistencies
</span>		<span class="enscript-comment">// pattern and mask have to be configured
</span>		<span class="enscript-keyword">if</span> (!utun_crypto_framer_args_dtls_in(args).in_pattern_len ||
		    !utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			printf(<span class="enscript-string">&quot;%s: invalid dtls in-pattern %d mask %d\n&quot;</span>, __FUNCTION__, 
			       utun_crypto_framer_args_dtls_in(args).in_pattern_len,
			       utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">// pattern and mask lengths have to match
</span>		<span class="enscript-keyword">if</span> (utun_crypto_framer_args_dtls_in(args).in_pattern_len != utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			printf(<span class="enscript-string">&quot;%s: inconsistent dtls in-pattern %d mask %d\n&quot;</span>,__FUNCTION__, 
			       utun_crypto_framer_args_dtls_in(args).in_pattern_len,
			       utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">// check for len inconsistencies
</span>		<span class="enscript-keyword">if</span> ((u_int32_t)utun_crypto_framer_args_dtls_in(args).in_pattern_len + (u_int32_t)utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len != args-&gt;varargs_buflen) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			printf(<span class="enscript-string">&quot;%s: inconsistent dtls in-pattern %d mask %d, total %d\n&quot;</span>,__FUNCTION__, 
			       utun_crypto_framer_args_dtls_in(args).in_pattern_len,
			       utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len,
			       args-&gt;varargs_buflen);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">// utun_crypto_framer_args_dtls_in(args).in_pattern should not be all zeros
</span>		<span class="enscript-keyword">if</span> (is_pattern_all_zeroes(&amp;args-&gt;varargs_buf[0],
					  utun_crypto_framer_args_dtls_in(args).in_pattern_len)) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			printf(<span class="enscript-string">&quot;%s: in-pattern is all zeros, len %d\n&quot;</span>,__FUNCTION__, 
			       utun_crypto_framer_args_dtls_in(args).in_pattern_len);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">// utun_crypto_framer_args_dtls_in(args).in_pattern_mask should not be all zeros
</span>		<span class="enscript-keyword">if</span> (is_pattern_all_zeroes(&amp;args-&gt;varargs_buf[utun_crypto_framer_args_dtls_in(args).in_pattern_len],
					  utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len)) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			printf(<span class="enscript-string">&quot;%s: in-pattern-mask is all zeros, len %d\n&quot;</span>,__FUNCTION__, 
			       utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">// utun_crypto_framer_args_dtls_in(args).in_pattern &amp; utun_crypto_framer_args_dtls_in(args).in_pattern_mask should not be zeros
</span>		<span class="enscript-keyword">if</span> (is_pattern_masked_all_zeroes(&amp;args-&gt;varargs_buf[0],
						 &amp;args-&gt;varargs_buf[utun_crypto_framer_args_dtls_in(args).in_pattern_len],
						 utun_crypto_framer_args_dtls_in(args).in_pattern_len)) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			printf(<span class="enscript-string">&quot;%s: in-pattern-masked is all zeros, len %d\n&quot;</span>,__FUNCTION__, 
			       utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len);
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">// Secondly, we need to be careful about existing framer configs
</span>		<span class="enscript-keyword">if</span> (!(framer = utun_ctl_get_first_framer(crypto_ctx, args-&gt;inner_type))) {
			<span class="enscript-comment">// no framers configured
</span>			<span class="enscript-keyword">if</span> (!(framer = utun_alloc(<span class="enscript-keyword">sizeof</span>(*framer)))) {
				lck_mtx_unlock(&amp;dtls_ctl_mutex);
				<span class="enscript-keyword">return</span> ENOBUFS;
			}
			bzero(framer, <span class="enscript-keyword">sizeof</span>(*framer));
			<span class="enscript-comment">// fall through to fill-in the 1st framer
</span>		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// at least one framer configured... check framer-&gt;u.listhead for duplicates;
</span>			<span class="enscript-keyword">if</span> ((dup_framer = utun_ctl_get_dtls_in_framer(framer <span class="enscript-comment">/* could be a list */</span>,
								      &amp;args-&gt;varargs_buf[0],
								      utun_crypto_framer_args_dtls_in(args).in_pattern_len,
								      &amp;args-&gt;varargs_buf[utun_crypto_framer_args_dtls_in(args).in_pattern_len],
								      utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len))) {
				<span class="enscript-comment">// duplicate
</span>				lck_mtx_unlock(&amp;dtls_ctl_mutex);
				printf(<span class="enscript-string">&quot;%s: ignoring duplicate framer for type %d\n&quot;</span>,__FUNCTION__, 
				       args-&gt;inner_type);
				<span class="enscript-keyword">return</span> 0;
			}

			<span class="enscript-keyword">if</span> (!(new_framer = utun_alloc(<span class="enscript-keyword">sizeof</span>(*new_framer)))) {
				lck_mtx_unlock(&amp;dtls_ctl_mutex);
				<span class="enscript-keyword">return</span> ENOBUFS;
			}
			bzero(new_framer, <span class="enscript-keyword">sizeof</span>(*new_framer));
			framer = new_framer;
			<span class="enscript-comment">// fall through to fill-in additional framer
</span>		}
		LIST_INSERT_HEAD(utun_get_framer_listhead(crypto_ctx, args-&gt;inner_type),
						 new_framer,
						 framer_chain);

		framer-&gt;inner_type = args-&gt;inner_type;
		framer-&gt;inner_protocol_family = utun_crypto_framer_inner_type_to_protocol_family(args-&gt;inner_type);
		<span class="enscript-comment">// allocate and fill the pattern
</span>		<span class="enscript-keyword">if</span> (!(utun_crypto_framer_state_dtls_in(framer).in_pattern = utun_alloc(utun_crypto_framer_args_dtls_in(args).in_pattern_len))) {
			utun_ctl_clr_dtls_framer(framer);
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		memcpy(utun_crypto_framer_state_dtls_in(framer).in_pattern,
		       &amp;args-&gt;varargs_buf[0],
		       utun_crypto_framer_args_dtls_in(args).in_pattern_len);
		utun_crypto_framer_state_dtls_in(framer).in_pattern_len = utun_crypto_framer_args_dtls_in(args).in_pattern_len;

		<span class="enscript-comment">// allocate and fill the pattern-mask
</span>		<span class="enscript-keyword">if</span> (!(utun_crypto_framer_state_dtls_in(framer).in_pattern_mask = utun_alloc(utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len))) {
			utun_ctl_clr_dtls_framer(framer);
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		memcpy(utun_crypto_framer_state_dtls_in(framer).in_pattern_mask,
		       &amp;args-&gt;varargs_buf[utun_crypto_framer_args_dtls_in(args).in_pattern_len],
		       utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len);
		utun_crypto_framer_state_dtls_in(framer).in_data_offset = utun_crypto_framer_args_dtls_in(args).in_data_offset;

		<span class="enscript-keyword">if</span> (!(utun_crypto_framer_state_dtls_in(framer).in_pattern_masked = utun_alloc(utun_crypto_framer_args_dtls_in(args).in_pattern_len))) {
			utun_ctl_clr_dtls_framer(framer);
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		utun_ctl_calc_dtls_framer_pattern_and_mask(utun_crypto_framer_state_dtls_in(framer).in_pattern_masked,
							   utun_crypto_framer_state_dtls_in(framer).in_pattern,
							   utun_crypto_framer_state_dtls_in(framer).in_pattern_mask,
							   utun_crypto_framer_state_dtls_in(framer).in_pattern_len);
		<span class="enscript-comment">// TOFIX: switch to BPF
</span>		crypto_ctx-&gt;num_framers++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// Output Framer (for tunnel hdr encapsulation)... there can only be one for each type of traffic (see caller of this function)
</span>
		<span class="enscript-comment">// pattern and mask have to be configured
</span>		<span class="enscript-keyword">if</span> (!utun_crypto_framer_args_dtls_out(args).out_pattern_len) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			printf(<span class="enscript-string">&quot;%s: invalid output framer, len %d\n&quot;</span>,__FUNCTION__, 
			       utun_crypto_framer_args_dtls_out(args).out_pattern_len);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">// utun_crypto_framer_args_dtls_out(args).out_pattern should not be all zeros;
</span>		<span class="enscript-keyword">if</span> (is_pattern_all_zeroes(&amp;args-&gt;varargs_buf[0],
					  utun_crypto_framer_args_dtls_out(args).out_pattern_len)) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			printf(<span class="enscript-string">&quot;%s: zeroed output framer, len %d\n&quot;</span>,__FUNCTION__, 
			       utun_crypto_framer_args_dtls_out(args).out_pattern_len);
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">// can't have the offset/extra configured while the mask is cleared
</span>		<span class="enscript-keyword">if</span> ((utun_crypto_framer_args_dtls_out(args).len_field_offset || utun_crypto_framer_args_dtls_out(args).len_field_extra) &amp;&amp; !utun_crypto_framer_args_dtls_out(args).len_field_mask) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			printf(<span class="enscript-string">&quot;%s: output framer has invalid length-field %d,%d,%x\n&quot;</span>,__FUNCTION__, 
			       (<span class="enscript-type">int</span>)utun_crypto_framer_args_dtls_out(args).len_field_offset,
			       (<span class="enscript-type">int</span>)utun_crypto_framer_args_dtls_out(args).len_field_extra,
			       utun_crypto_framer_args_dtls_out(args).len_field_mask);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">// any length field should be within the bounds of the out-pattern
</span>		<span class="enscript-keyword">if</span> (utun_crypto_framer_args_dtls_out(args).len_field_offset &gt;= utun_crypto_framer_args_dtls_out(args).out_pattern_len) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">// can't have the offset configured while the mask is cleared
</span>		<span class="enscript-keyword">if</span> ((utun_crypto_framer_args_dtls_out(args).sequence_field || utun_crypto_framer_args_dtls_out(args).sequence_field_offset) &amp;&amp; !utun_crypto_framer_args_dtls_out(args).sequence_field_mask) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			printf(<span class="enscript-string">&quot;%s: output framer has invalid sequence-field %d,%d,%x\n&quot;</span>,__FUNCTION__, 
			       (<span class="enscript-type">int</span>)utun_crypto_framer_args_dtls_out(args).sequence_field,
			       (<span class="enscript-type">int</span>)utun_crypto_framer_args_dtls_out(args).sequence_field_offset,
			       utun_crypto_framer_args_dtls_out(args).sequence_field_mask);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">// any sequence field should be within the bounds of the out-pattern
</span>		<span class="enscript-keyword">if</span> (utun_crypto_framer_args_dtls_out(args).sequence_field_offset &gt;= utun_crypto_framer_args_dtls_out(args).out_pattern_len) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">// check for len inconsistencies
</span>		<span class="enscript-keyword">if</span> ((u_int32_t)utun_crypto_framer_args_dtls_out(args).out_pattern_len != args-&gt;varargs_buflen) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-keyword">if</span> (!(framer = utun_ctl_get_first_framer(crypto_ctx, args-&gt;inner_type))) {
			<span class="enscript-keyword">if</span> (!(framer = utun_alloc(<span class="enscript-keyword">sizeof</span>(*framer)))) {
				lck_mtx_unlock(&amp;dtls_ctl_mutex);
				<span class="enscript-keyword">return</span> ENOBUFS;
			}
			bzero(framer, <span class="enscript-keyword">sizeof</span>(*framer));
			LIST_INSERT_HEAD(utun_get_framer_listhead(crypto_ctx, args-&gt;inner_type),
							 new_framer,
							 framer_chain);
			<span class="enscript-comment">// fall through to fill-in 1st framer
</span>		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// only one outbound framer may be configured.. is it a dup?
</span>			<span class="enscript-keyword">if</span> (framer-&gt;inner_type == args-&gt;inner_type &amp;&amp;
			    utun_crypto_framer_state_dtls_out(framer).out_pattern_len == utun_crypto_framer_args_dtls_out(args).out_pattern_len &amp;&amp;
			    utun_crypto_framer_state_dtls_out(framer).out_pattern &amp;&amp;
			    memcmp(utun_crypto_framer_state_dtls_out(framer).out_pattern,
				   &amp;args-&gt;varargs_buf[0],
				   utun_crypto_framer_args_dtls_out(args).out_pattern_len) == 0) {
				<span class="enscript-comment">// found
</span>				lck_mtx_unlock(&amp;dtls_ctl_mutex);
				<span class="enscript-keyword">return</span> 0;
			}

			<span class="enscript-comment">// overwrite the previous one
</span>			<span class="enscript-keyword">if</span> (utun_crypto_framer_state_dtls_out(framer).out_pattern) {
				utun_free(utun_crypto_framer_state_dtls_out(framer).out_pattern);
			}
			<span class="enscript-comment">// fall through to fill-in additional framer
</span>		}

		framer-&gt;inner_type = args-&gt;inner_type;
		framer-&gt;inner_protocol_family = utun_crypto_framer_inner_type_to_protocol_family(args-&gt;inner_type);

		<span class="enscript-comment">// alloc and fill in the out-pattern
</span>		<span class="enscript-keyword">if</span> (!(utun_crypto_framer_state_dtls_out(framer).out_pattern = utun_alloc(utun_crypto_framer_args_dtls_out(args).out_pattern_len))) {
			utun_ctl_clr_dtls_framer(framer);
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		memcpy(utun_crypto_framer_state_dtls_out(framer).out_pattern,
		       &amp;args-&gt;varargs_buf[0],
		       utun_crypto_framer_args_dtls_out(args).out_pattern_len);
		utun_crypto_framer_state_dtls_out(framer).out_pattern_len = utun_crypto_framer_args_dtls_out(args).out_pattern_len;

		utun_crypto_framer_state_dtls_out(framer).len_field_mask = utun_crypto_framer_args_dtls_out(args).len_field_mask;
		utun_crypto_framer_state_dtls_out(framer).len_field_offset = utun_crypto_framer_args_dtls_out(args).len_field_offset;
		utun_crypto_framer_state_dtls_out(framer).len_field_extra = utun_crypto_framer_args_dtls_out(args).len_field_extra;
		utun_crypto_framer_state_dtls_out(framer).sequence_field_initval = utun_crypto_framer_args_dtls_out(args).sequence_field;
		utun_crypto_framer_state_dtls_out(framer).sequence_field_mask = utun_crypto_framer_args_dtls_out(args).sequence_field_mask;
		utun_crypto_framer_state_dtls_out(framer).sequence_field_offset = utun_crypto_framer_args_dtls_out(args).sequence_field_offset;
		crypto_ctx-&gt;num_framers = 1;
	}
	framer-&gt;type = args-&gt;type;
	framer-&gt;dir = args-&gt;dir;
	framer-&gt;valid = 1;

	lck_mtx_unlock(&amp;dtls_ctl_mutex);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">utun_ctl_unconfig_crypto_dtls_framer</span> (utun_crypto_ctx_t         *crypto_ctx,
				      utun_crypto_framer_args_t *args)
{
	utun_crypto_framer_t *framer, *rem_framer;

	<span class="enscript-keyword">if</span> (args-&gt;ver != UTUN_CRYPTO_DTLS_VER_1) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> (!args-&gt;type || args-&gt;type &gt;= UTUN_CRYPTO_INNER_TYPE_MAX) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	lck_mtx_lock(&amp;dtls_ctl_mutex);

	<span class="enscript-keyword">if</span> (args-&gt;dir == UTUN_CRYPTO_DIR_IN) {
		<span class="enscript-keyword">if</span> (!utun_crypto_framer_args_dtls_in(args).in_pattern_len) {
			<span class="enscript-comment">// no pattern means... clear all
</span>			utun_ctl_clr_dtls_framers(utun_ctl_get_first_framer(crypto_ctx, args-&gt;inner_type));
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> 0;
		}

		<span class="enscript-comment">// when both specified, pattern and mask lengths have to match
</span>		<span class="enscript-keyword">if</span> (utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len &amp;&amp;
		    utun_crypto_framer_args_dtls_in(args).in_pattern_len != utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">// check for len inconsistencies
</span>		<span class="enscript-keyword">if</span> ((u_int32_t)utun_crypto_framer_args_dtls_in(args).in_pattern_len + (u_int32_t)utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len != args-&gt;varargs_buflen) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">// utun_crypto_framer_args_dtls_in(args).in_pattern should not be all zeros
</span>		<span class="enscript-keyword">if</span> (is_pattern_all_zeroes(&amp;args-&gt;varargs_buf[0],
					  utun_crypto_framer_args_dtls_in(args).in_pattern_len)) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">// when specified, utun_crypto_framer_args_dtls_in(args).in_pattern_mask should not be all zeros
</span>		<span class="enscript-keyword">if</span> (utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len &amp;&amp;
		    is_pattern_all_zeroes(&amp;args-&gt;varargs_buf[utun_crypto_framer_args_dtls_in(args).in_pattern_len],
					  utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len)) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-comment">// utun_crypto_framer_args_dtls_in(args).in_pattern &amp; utun_crypto_framer_args_dtls_in(args).in_pattern_mask should not be zeros
</span>		<span class="enscript-keyword">if</span> (is_pattern_masked_all_zeroes(&amp;args-&gt;varargs_buf[0],
						 &amp;args-&gt;varargs_buf[utun_crypto_framer_args_dtls_in(args).in_pattern_len],
						 utun_crypto_framer_args_dtls_in(args).in_pattern_len)) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-keyword">if</span> ((u_int32_t)utun_crypto_framer_args_dtls_in(args).in_pattern_len + (u_int32_t)utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len != args-&gt;varargs_buflen) {
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-keyword">if</span> (!(framer = utun_ctl_get_first_framer(crypto_ctx, args-&gt;inner_type))) {
			<span class="enscript-comment">// no framers
</span>			printf(<span class="enscript-string">&quot;%s: no framers configured\n&quot;</span>, __FUNCTION__);
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> ((rem_framer = utun_ctl_get_dtls_in_framer(framer,
								      &amp;args-&gt;varargs_buf[0],
								      utun_crypto_framer_args_dtls_in(args).in_pattern_len,
								      &amp;args-&gt;varargs_buf[utun_crypto_framer_args_dtls_in(args).in_pattern_len],
								      utun_crypto_framer_args_dtls_in(args).in_pattern_mask_len))) {
				utun_ctl_clr_dtls_framer(rem_framer);
				<span class="enscript-keyword">if</span> (crypto_ctx-&gt;num_framers) crypto_ctx-&gt;num_framers--;
			} <span class="enscript-keyword">else</span> {
				printf(<span class="enscript-string">&quot;%s: no matching ingress framer\n&quot;</span>, __FUNCTION__);
			}
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> 0;
		}
	} <span class="enscript-keyword">else</span> {
		framer = utun_ctl_get_first_framer(crypto_ctx, args-&gt;inner_type);
		<span class="enscript-comment">// overwrite the previous one
</span>		<span class="enscript-keyword">if</span> (framer) {
			<span class="enscript-keyword">if</span> (framer-&gt;inner_type != args-&gt;inner_type ||
				(utun_crypto_framer_args_dtls_out(args).out_pattern_len &amp;&amp;
				 utun_crypto_framer_state_dtls_out(framer).out_pattern_len != utun_crypto_framer_args_dtls_out(args).out_pattern_len) ||
				(utun_crypto_framer_args_dtls_out(args).out_pattern_len &amp;&amp;
				 memcmp(utun_crypto_framer_state_dtls_out(framer).out_pattern,
						&amp;args-&gt;varargs_buf[0],
						utun_crypto_framer_args_dtls_out(args).out_pattern_len))) {
					printf(<span class="enscript-string">&quot;%s: no matching egress framer\n&quot;</span>, __FUNCTION__);
					lck_mtx_unlock(&amp;dtls_ctl_mutex);
					<span class="enscript-keyword">return</span> EBADF;
			}
			utun_ctl_clr_dtls_framer(framer);
			<span class="enscript-keyword">if</span> (crypto_ctx-&gt;num_framers) crypto_ctx-&gt;num_framers--;
		}
	}

	lck_mtx_unlock(&amp;dtls_ctl_mutex);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Summary: enables handling of data traffic
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_start_datatraffic_crypto_dtls</span>(<span class="enscript-type">struct</span> utun_pcb   *pcb)
{
	utun_crypto_ctx_t *crypto_ctx;

	lck_mtx_lock(&amp;dtls_ctl_mutex);

	<span class="enscript-comment">//printf(&quot;%s: entering, flags %x, kpi-handle %d, kpi-ref %p, kpi-refcnt %d\n&quot;, __FUNCTION__, pcb-&gt;utun_flags, crypto_ctx-&gt;kpi_handle, crypto_ctx-&gt;kpi_ref, crypto_ctx-&gt;kpi_refcnt);
</span>	
	crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[UTUN_CRYPTO_DIR_TO_IDX(UTUN_CRYPTO_DIR_OUT)];

	<span class="enscript-keyword">if</span> (crypto_ctx-&gt;kpi_handle &lt; 0) {
		printf(<span class="enscript-string">&quot;%s: dtls disabled\n&quot;</span>, __FUNCTION__);
		lck_mtx_unlock(&amp;dtls_ctl_mutex);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (!crypto_ctx-&gt;kpi_ref) {
		<span class="enscript-keyword">if</span> (dtls_kpi_connect) {
			crypto_ctx-&gt;kpi_ref = dtls_kpi_connect(crypto_ctx-&gt;kpi_handle, pcb);
			<span class="enscript-keyword">if</span> (!crypto_ctx-&gt;kpi_ref) {
				printf(<span class="enscript-string">&quot;%s: ### dtls_kpi_connect failed\n&quot;</span>, __FUNCTION__);
				lck_mtx_unlock(&amp;dtls_ctl_mutex);
				<span class="enscript-keyword">return</span>;
			}
			crypto_ctx-&gt;kpi_refcnt++;
		} <span class="enscript-keyword">else</span> {
			printf(<span class="enscript-string">&quot;%s: ### dtls_kpi_connect unavailable\n&quot;</span>, __FUNCTION__);
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span>;
		}
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;%s: dtls already stitched\n&quot;</span>, __FUNCTION__);
		lck_mtx_unlock(&amp;dtls_ctl_mutex);
		<span class="enscript-keyword">return</span>;
	}
	utun_ctl_restart_dtls_all_framers(crypto_ctx); <span class="enscript-comment">// for dynamic egress hdrs
</span>
	<span class="enscript-comment">//printf(&quot;%s: leaving, flags %x, kpi-handle %d, kpi-ref %p, kpi-refcnt %d\n&quot;, __FUNCTION__, pcb-&gt;utun_flags, crypto_ctx-&gt;kpi_handle, crypto_ctx-&gt;kpi_ref, crypto_ctx-&gt;kpi_refcnt);
</span>	lck_mtx_unlock(&amp;dtls_ctl_mutex);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Summary: disables handling of data traffic
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_stop_datatraffic_crypto_dtls</span>(<span class="enscript-type">struct</span> utun_pcb   *pcb)
{
	utun_crypto_ctx_t *crypto_ctx;

	lck_mtx_lock(&amp;dtls_ctl_mutex);

	<span class="enscript-comment">//printf(&quot;%s: entering, flags %x, kpi-ref %p, kpi-refcnt %d\n&quot;, __FUNCTION__, pcb-&gt;utun_flags, crypto_ctx-&gt;kpi_ref, crypto_ctx-&gt;kpi_refcnt);
</span>	
	crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[UTUN_CRYPTO_DIR_TO_IDX(UTUN_CRYPTO_DIR_OUT)];

	<span class="enscript-keyword">if</span> (crypto_ctx-&gt;kpi_ref) {
		<span class="enscript-keyword">if</span> (dtls_kpi_connect) {
			(<span class="enscript-type">void</span>)dtls_kpi_connect(crypto_ctx-&gt;kpi_handle, NULL);
			<span class="enscript-keyword">if</span> (--crypto_ctx-&gt;kpi_refcnt == 0) {
				crypto_ctx-&gt;kpi_ref = (__typeof__(crypto_ctx-&gt;kpi_ref))NULL;
				crypto_ctx-&gt;kpi_handle = UTUN_CRYPTO_DTLS_HANDLE_INVALID;
			} <span class="enscript-keyword">else</span> {
			  <span class="enscript-comment">//				printf(&quot;%s: ### dtls_kpi_refcnt %d not yet zero\n&quot;,
</span>			  <span class="enscript-comment">//				       __FUNCTION__, crypto_ctx-&gt;kpi_refcnt);
</span>			}
		} <span class="enscript-keyword">else</span> {
			printf(<span class="enscript-string">&quot;%s: dtls_kpi_connect unavailable\n&quot;</span>, __FUNCTION__);
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span>;
		}
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;%s: dtls already not-stitched\n&quot;</span>, __FUNCTION__);
		lck_mtx_unlock(&amp;dtls_ctl_mutex);
		<span class="enscript-keyword">return</span>;
	}
	lck_mtx_unlock(&amp;dtls_ctl_mutex);
	<span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">utun_pkt_dtls_prepend_proto</span>(pkt, pf) do {                               \
		<span class="enscript-keyword">if</span> (mbuf_prepend(pkt, <span class="enscript-keyword">sizeof</span>(protocol_family_t), MBUF_DONTWAIT) != 0) { \
			printf(<span class="enscript-string">&quot;%s - ifnet_output prepend failed\n&quot;</span>, __FUNCTION__);         \
			lck_mtx_unlock(&amp;dtls_ctl_mutex);                                    \
			<span class="enscript-keyword">return</span> EBADF;                                                       \
		}                                                                       \
		*(protocol_family_t *)mbuf_data(*pkt) = pf;                             \
	} <span class="enscript-keyword">while</span>(0);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">utun_pkt_dtls_puntup</span>(pcb, pkt, errstr, rc) do {                                                 \
		*(protocol_family_t *)mbuf_data(*pkt) = htonl(*(protocol_family_t *)mbuf_data(*pkt));           \
		rc = ctl_enqueuembuf(pcb-&gt;utun_ctlref, pcb-&gt;utun_unit, *pkt, CTL_DATA_EOR);                     \
		<span class="enscript-keyword">if</span> (rc != 0) {                                                                                  \
			printf(<span class="enscript-string">&quot;%s: - ctl_enqueuembuf failed (rc %d) for %s:\n&quot;</span>, __FUNCTION__, rc, errstr); \
			mbuf_freem(*pkt);                                                                           \
			ifnet_stat_increment_out(pcb-&gt;utun_ifp, 0, 0, 1);                                           \
			lck_mtx_unlock(&amp;dtls_ctl_mutex);                                                            \
			<span class="enscript-keyword">return</span> 0;                                                                                   \
		}                                                                                               \
		*pkt = NULL;                                                                                    \
	} <span class="enscript-keyword">while</span>(0);

<span class="enscript-type">int</span>
<span class="enscript-function-name">utun_pkt_dtls_output</span>(<span class="enscript-type">struct</span> utun_pcb *pcb, mbuf_t *pkt)
{
	errno_t            rc = ENETUNREACH;
	<span class="enscript-type">int</span>                len;
	utun_crypto_ctx_t *crypto_ctx;
	protocol_family_t  proto;

	<span class="enscript-comment">//printf(&quot;%s: entering, flags %x, ifp %p\n&quot;, __FUNCTION__, pcb-&gt;utun_flags, pcb-&gt;utun_ifp);
</span>
	<span class="enscript-keyword">if</span> (!(pcb-&gt;utun_flags &amp; UTUN_FLAGS_CRYPTO)) {
		printf(<span class="enscript-string">&quot;%s - crypto disabled\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (!pcb-&gt;utun_ifp) {
		printf(<span class="enscript-string">&quot;%s - utun ifp cleared\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	proto = *(mtod(*pkt, protocol_family_t *));

	lck_mtx_lock(&amp;dtls_ctl_mutex);

	len = mbuf_pkthdr_len(*pkt);

	crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[UTUN_CRYPTO_DIR_TO_IDX(UTUN_CRYPTO_DIR_OUT)];

	<span class="enscript-comment">//printf(&quot;%s: entering, kpi-handle %d, kpi-ref %p, kpi-refcnt %d\n&quot;, __FUNCTION__, crypto_ctx-&gt;kpi_handle, crypto_ctx-&gt;kpi_ref, crypto_ctx-&gt;kpi_refcnt);
</span>
	<span class="enscript-keyword">if</span> (dtls_kpi_send &amp;&amp; (crypto_ctx-&gt;kpi_handle &gt;= 0) &amp;&amp; crypto_ctx-&gt;kpi_ref) {
		m_adj(*pkt, <span class="enscript-keyword">sizeof</span>(protocol_family_t));

		<span class="enscript-keyword">if</span> (!(rc = utun_pkt_dtls_output_frame_encapsulate(crypto_ctx, pkt, proto))) {
			rc = dtls_kpi_send(crypto_ctx-&gt;kpi_ref, pkt);
			<span class="enscript-keyword">if</span> (rc) {
				printf(<span class="enscript-string">&quot;%s: DTLS failed to send pkt %d\n&quot;</span>, __FUNCTION__, rc);
				<span class="enscript-comment">// &lt;rdar://problem/11385397&gt; 
</span>				<span class="enscript-comment">// dtls_kpi_send (by way of so_inject_data_out) frees mbuf during certain error cases, 
</span>				ifnet_stat_increment_out(pcb-&gt;utun_ifp, 0, 0, 1); <span class="enscript-comment">// increment errors
</span>				lck_mtx_unlock(&amp;dtls_ctl_mutex);
				<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">// and drop packet
</span>			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rc == EINVAL) {
			<span class="enscript-comment">// unsupported proto... fall through and punt (but 1st undo the protocol strip)
</span>			utun_pkt_dtls_prepend_proto(pkt, proto);
			utun_pkt_dtls_puntup(pcb, pkt, <span class="enscript-string">&quot;unsupported proto&quot;</span>, rc);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// mbuf_prepend failure... mbuf will be already freed
</span>			printf(<span class="enscript-string">&quot;%s: failed to encrypsulate and send pkt %d\n&quot;</span>, __FUNCTION__,rc);
			ifnet_stat_increment_out(pcb-&gt;utun_ifp, 0, 0, 1); <span class="enscript-comment">// increment errors
</span>			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">// and drop packet
</span>		}
	} <span class="enscript-keyword">else</span> {
		utun_pkt_dtls_puntup(pcb, pkt, <span class="enscript-string">&quot;slowpath&quot;</span>, rc);
	}

	<span class="enscript-keyword">if</span> (!rc)
		ifnet_stat_increment_out(pcb-&gt;utun_ifp, 1, len, 0);

	lck_mtx_unlock(&amp;dtls_ctl_mutex);
	<span class="enscript-keyword">return</span> rc;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">utun_pkt_dtls_input</span>(<span class="enscript-type">struct</span> utun_pcb *pcb, mbuf_t *pkt, __unused protocol_family_t family)
{
	utun_crypto_ctx_t *crypto_ctx;
	<span class="enscript-type">int</span>                striplen = 0;

	<span class="enscript-comment">//printf(&quot;%s: got pkt %d\n&quot;, __FUNCTION__,family);
</span>	<span class="enscript-keyword">if</span> (!(pcb-&gt;utun_flags &amp; UTUN_FLAGS_CRYPTO)) {
		printf(<span class="enscript-string">&quot;%s - crypto disabled\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (!pcb-&gt;utun_ifp) {
		printf(<span class="enscript-string">&quot;%s - utun ifp cleared\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	lck_mtx_lock(&amp;dtls_ctl_mutex);

	<span class="enscript-comment">/*
	 * make sure that family matches what the UTUN was configured for (punt those that don't... along with all that fail to match the data pattern.
	 */</span>
	crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[UTUN_CRYPTO_DIR_TO_IDX(UTUN_CRYPTO_DIR_IN)];
	<span class="enscript-keyword">if</span> (crypto_ctx-&gt;num_framers &amp;&amp;
	    !utun_pkt_dtls_input_frame_is_data(crypto_ctx, pkt, AF_INET, &amp;striplen) &amp;&amp;
	    !utun_pkt_dtls_input_frame_is_data(crypto_ctx, pkt, AF_INET6, &amp;striplen)) {
		<span class="enscript-comment">// control or unknown traffic, so punt up to the plugin
</span>		errno_t rc;

		utun_pkt_dtls_prepend_proto(pkt, family);
		*(protocol_family_t *)mbuf_data(*pkt) = htonl(*(protocol_family_t *)mbuf_data(*pkt));
		rc = ctl_enqueuembuf(pcb-&gt;utun_ctlref, pcb-&gt;utun_unit, *pkt, CTL_DATA_EOR);
		<span class="enscript-keyword">if</span> (rc != 0) {
			<span class="enscript-comment">// drop packet
</span>	  		printf(<span class="enscript-string">&quot;%s: - ctl_enqueuembuf failed: %d\n&quot;</span>, __FUNCTION__, rc);
			mbuf_freem(*pkt);
			lck_mtx_unlock(&amp;dtls_ctl_mutex);
			<span class="enscript-keyword">return</span> rc;
		}
		printf(<span class="enscript-string">&quot;%s: - ctl_enqueuembuf punted a packet up to UTUN ctrl sock: %d\n&quot;</span>, __FUNCTION__, rc);
		ifnet_stat_increment_in(pcb-&gt;utun_ifp, 1, mbuf_pkthdr_len(*pkt), 0);

		*pkt = NULL;
		lck_mtx_unlock(&amp;dtls_ctl_mutex);
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-keyword">if</span> (striplen) {
		<span class="enscript-comment">//printf(&quot;%s: - about to strip tunneled hdr of len %d\n&quot;, __FUNCTION__, striplen);
</span>		m_adj(*pkt, striplen);
	}

	utun_pkt_dtls_prepend_proto(pkt, family);

	ifnet_stat_increment_in(pcb-&gt;utun_ifp, 1, mbuf_pkthdr_len(*pkt), 0);

	(<span class="enscript-type">void</span>)utun_pkt_input(pcb, *pkt);
	lck_mtx_unlock(&amp;dtls_ctl_mutex);
	<span class="enscript-keyword">return</span> 0;
}
</pre>
<hr />
</body></html>