<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>if_var.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">if_var.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	From: @(#)if.h	8.1 (Berkeley) 6/10/93
 * $FreeBSD: src/sys/net/if_var.h,v 1.18.2.7 2001/07/24 19:10:18 brooks Exp $
 */</span>

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">_NET_IF_VAR_H_</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_NET_IF_VAR_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>		<span class="enscript-comment">/* get TAILQ macros */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PRIVATE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_interface.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE__</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_LOOPBACK</span>  1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_ETHERNET</span>  2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_SLIP</span>      3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_TUN</span>       4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_VLAN</span>      5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_PPP</span>       6
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_PVC</span>       7
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_DISC</span>      8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_MDECAP</span>    9
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_GIF</span>       10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_FAITH</span>     11	<span class="enscript-comment">/* deprecated */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_STF</span>       12
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_FIREWIRE</span>  13
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_IF_FAM_BOND</span>      14
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

<span class="enscript-comment">/*
 * 72 was chosen below because it is the size of a TCP/IP
 * header (40) + the minimum mss (32).
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_MINMTU</span>	72
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_MAXMTU</span>	65535

<span class="enscript-comment">/*
 * Structures defining a network interface, providing a packet
 * transport mechanism (ala level 0 of the PUP protocols).
 *
 * Each interface accepts output datagrams of a specified maximum
 * length, and provides higher level routines with input datagrams
 * received from its medium.
 *
 * Output occurs when the routine if_output is called, with three parameters:
 *	(*ifp-&gt;if_output)(ifp, m, dst, rt)
 * Here m is the mbuf chain to be sent and dst is the destination address.
 * The output routine encapsulates the supplied datagram if necessary,
 * and then transmits it on its medium.
 *
 * On input, each interface unwraps the data received by it, and either
 * places it on the input queue of a internetwork datagram routine
 * and posts the associated software interrupt, or passes the datagram to a raw
 * packet input routine.
 *
 * Routines exist for locating interfaces by their addresses
 * or for locating a interface on a certain network, as well as more general
 * routing and gateway routines maintaining information used to locate
 * interfaces.  These routines live in the files if.c and route.c
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFNAMSIZ</span>	16

<span class="enscript-comment">/* This belongs up in socket.h or socketvar.h, depending on how far the
 *   event bubbles up.
 */</span>

<span class="enscript-type">struct</span> net_event_data {
	u_int32_t	if_family;
	u_int32_t	if_unit;
	<span class="enscript-type">char</span>		if_name[IFNAMSIZ];
};

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/_types/_timeval32.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_DATA_TIMEVAL</span> timeval32
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_DATA_TIMEVAL</span> timeval
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>(4)

<span class="enscript-comment">/*
 * Structure describing information about an interface
 * which may be of interest to management entities.
 */</span>
<span class="enscript-type">struct</span> if_data {
	<span class="enscript-comment">/* generic interface information */</span>
	u_char		ifi_type;	<span class="enscript-comment">/* ethernet, tokenring, etc */</span>
	u_char		ifi_typelen;	<span class="enscript-comment">/* Length of frame type id */</span>
	u_char		ifi_physical;	<span class="enscript-comment">/* e.g., AUI, Thinnet, 10base-T, etc */</span>
	u_char		ifi_addrlen;	<span class="enscript-comment">/* media address length */</span>
	u_char		ifi_hdrlen;	<span class="enscript-comment">/* media header length */</span>
	u_char		ifi_recvquota;	<span class="enscript-comment">/* polling quota for receive intrs */</span>
	u_char		ifi_xmitquota;	<span class="enscript-comment">/* polling quota for xmit intrs */</span>
	u_char		ifi_unused1;	<span class="enscript-comment">/* for future use */</span>
	u_int32_t	ifi_mtu;	<span class="enscript-comment">/* maximum transmission unit */</span>
	u_int32_t	ifi_metric;	<span class="enscript-comment">/* routing metric (external only) */</span>
	u_int32_t	ifi_baudrate;	<span class="enscript-comment">/* linespeed */</span>
	<span class="enscript-comment">/* volatile statistics */</span>
	u_int32_t	ifi_ipackets;	<span class="enscript-comment">/* packets received on interface */</span>
	u_int32_t	ifi_ierrors;	<span class="enscript-comment">/* input errors on interface */</span>
	u_int32_t	ifi_opackets;	<span class="enscript-comment">/* packets sent on interface */</span>
	u_int32_t	ifi_oerrors;	<span class="enscript-comment">/* output errors on interface */</span>
	u_int32_t	ifi_collisions;	<span class="enscript-comment">/* collisions on csma interfaces */</span>
	u_int32_t	ifi_ibytes;	<span class="enscript-comment">/* total number of octets received */</span>
	u_int32_t	ifi_obytes;	<span class="enscript-comment">/* total number of octets sent */</span>
	u_int32_t	ifi_imcasts;	<span class="enscript-comment">/* packets received via multicast */</span>
	u_int32_t	ifi_omcasts;	<span class="enscript-comment">/* packets sent via multicast */</span>
	u_int32_t	ifi_iqdrops;	<span class="enscript-comment">/* dropped on input, this interface */</span>
	u_int32_t	ifi_noproto;	<span class="enscript-comment">/* destined for unsupported protocol */</span>
	u_int32_t	ifi_recvtiming;	<span class="enscript-comment">/* usec spent receiving when timing */</span>
	u_int32_t	ifi_xmittiming;	<span class="enscript-comment">/* usec spent xmitting when timing */</span>
	<span class="enscript-type">struct</span> IF_DATA_TIMEVAL ifi_lastchange;	<span class="enscript-comment">/* time of last administrative change */</span>
	u_int32_t	ifi_unused2;	<span class="enscript-comment">/* used to be the default_proto */</span>
	u_int32_t	ifi_hwassist;	<span class="enscript-comment">/* HW offload capabilities */</span>
	u_int32_t	ifi_reserved1;	<span class="enscript-comment">/* for future use */</span>
	u_int32_t	ifi_reserved2;	<span class="enscript-comment">/* for future use */</span>
};

<span class="enscript-comment">/*
 * Structure describing information about an interface
 * which may be of interest to management entities.
 */</span>
<span class="enscript-type">struct</span> if_data64 {
	<span class="enscript-comment">/* generic interface information */</span>
	u_char		ifi_type;		<span class="enscript-comment">/* ethernet, tokenring, etc */</span>
	u_char		ifi_typelen;		<span class="enscript-comment">/* Length of frame type id */</span>
	u_char		ifi_physical;		<span class="enscript-comment">/* e.g., AUI, Thinnet, 10base-T, etc */</span>
	u_char		ifi_addrlen;		<span class="enscript-comment">/* media address length */</span>
	u_char		ifi_hdrlen;		<span class="enscript-comment">/* media header length */</span>
	u_char		ifi_recvquota;		<span class="enscript-comment">/* polling quota for receive intrs */</span>
	u_char		ifi_xmitquota;		<span class="enscript-comment">/* polling quota for xmit intrs */</span>
	u_char		ifi_unused1;		<span class="enscript-comment">/* for future use */</span>
	u_int32_t	ifi_mtu;		<span class="enscript-comment">/* maximum transmission unit */</span>
	u_int32_t	ifi_metric;		<span class="enscript-comment">/* routing metric (external only) */</span>
	u_int64_t	ifi_baudrate;		<span class="enscript-comment">/* linespeed */</span>
	<span class="enscript-comment">/* volatile statistics */</span>
	u_int64_t	ifi_ipackets;		<span class="enscript-comment">/* packets received on interface */</span>
	u_int64_t	ifi_ierrors;		<span class="enscript-comment">/* input errors on interface */</span>
	u_int64_t	ifi_opackets;		<span class="enscript-comment">/* packets sent on interface */</span>
	u_int64_t	ifi_oerrors;		<span class="enscript-comment">/* output errors on interface */</span>
	u_int64_t	ifi_collisions;		<span class="enscript-comment">/* collisions on csma interfaces */</span>
	u_int64_t	ifi_ibytes;		<span class="enscript-comment">/* total number of octets received */</span>
	u_int64_t	ifi_obytes;		<span class="enscript-comment">/* total number of octets sent */</span>
	u_int64_t	ifi_imcasts;		<span class="enscript-comment">/* packets received via multicast */</span>
	u_int64_t	ifi_omcasts;		<span class="enscript-comment">/* packets sent via multicast */</span>
	u_int64_t	ifi_iqdrops;		<span class="enscript-comment">/* dropped on input, this interface */</span>
	u_int64_t	ifi_noproto;		<span class="enscript-comment">/* destined for unsupported protocol */</span>
	u_int32_t	ifi_recvtiming;		<span class="enscript-comment">/* usec spent receiving when timing */</span>
	u_int32_t	ifi_xmittiming;		<span class="enscript-comment">/* usec spent xmitting when timing */</span>
	<span class="enscript-type">struct</span> IF_DATA_TIMEVAL ifi_lastchange;	<span class="enscript-comment">/* time of last administrative change */</span>
};

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PRIVATE</span>
<span class="enscript-type">struct</span> if_traffic_class {
	u_int64_t		ifi_ibepackets;	<span class="enscript-comment">/* TC_BE packets received on interface */</span>
	u_int64_t		ifi_ibebytes;	<span class="enscript-comment">/* TC_BE bytes received on interface */</span>
	u_int64_t		ifi_obepackets;	<span class="enscript-comment">/* TC_BE packet sent on interface */</span>
	u_int64_t		ifi_obebytes;	<span class="enscript-comment">/* TC_BE bytes sent on interface */</span>
	u_int64_t		ifi_ibkpackets;	<span class="enscript-comment">/* TC_BK packets received on interface */</span>
	u_int64_t		ifi_ibkbytes;	<span class="enscript-comment">/* TC_BK bytes received on interface */</span>
	u_int64_t		ifi_obkpackets;	<span class="enscript-comment">/* TC_BK packet sent on interface */</span>
	u_int64_t		ifi_obkbytes;	<span class="enscript-comment">/* TC_BK bytes sent on interface */</span>
	u_int64_t		ifi_ivipackets;	<span class="enscript-comment">/* TC_VI packets received on interface */</span>
	u_int64_t		ifi_ivibytes;	<span class="enscript-comment">/* TC_VI bytes received on interface */</span>
	u_int64_t		ifi_ovipackets;	<span class="enscript-comment">/* TC_VI packets sent on interface */</span>
	u_int64_t		ifi_ovibytes;	<span class="enscript-comment">/* TC_VI bytes sent on interface */</span>
	u_int64_t		ifi_ivopackets;	<span class="enscript-comment">/* TC_VO packets received on interface */</span>
	u_int64_t		ifi_ivobytes;	<span class="enscript-comment">/* TC_VO bytes received on interface */</span>
	u_int64_t		ifi_ovopackets;	<span class="enscript-comment">/* TC_VO packets sent on interface */</span>
	u_int64_t		ifi_ovobytes;	<span class="enscript-comment">/* TC_VO bytes sent on interface */</span>
	u_int64_t		ifi_ipvpackets;	<span class="enscript-comment">/* TC priv packets received on interface */</span>
	u_int64_t		ifi_ipvbytes;	<span class="enscript-comment">/* TC priv bytes received on interface */</span>
	u_int64_t		ifi_opvpackets;	<span class="enscript-comment">/* TC priv packets sent on interface */</span>
	u_int64_t		ifi_opvbytes;	<span class="enscript-comment">/* TC priv bytes sent on interface */</span>
};

<span class="enscript-type">struct</span> if_data_extended {
	u_int64_t	ifi_alignerrs;	<span class="enscript-comment">/* unaligned (32-bit) input pkts */</span>
	u_int64_t	ifi_dt_bytes;	<span class="enscript-comment">/* Data threshold counter */</span>
	u_int64_t	ifi_fpackets;	<span class="enscript-comment">/* forwarded packets on interface */</span>
	u_int64_t	ifi_fbytes;	<span class="enscript-comment">/* forwarded bytes on interface */</span>
	u_int64_t	reserved[12];	<span class="enscript-comment">/* for future */</span>
};

<span class="enscript-type">struct</span> if_packet_stats {
	<span class="enscript-comment">/* TCP */</span>
	u_int64_t		ifi_tcp_badformat;
	u_int64_t		ifi_tcp_unspecv6;
	u_int64_t		ifi_tcp_synfin;
	u_int64_t		ifi_tcp_badformatipsec;
	u_int64_t		ifi_tcp_noconnnolist;
	u_int64_t		ifi_tcp_noconnlist;
	u_int64_t		ifi_tcp_listbadsyn;
	u_int64_t		ifi_tcp_icmp6unreach;
	u_int64_t		ifi_tcp_deprecate6;
	u_int64_t		ifi_tcp_rstinsynrcv;
	u_int64_t		ifi_tcp_ooopacket;
	u_int64_t		ifi_tcp_dospacket;
	u_int64_t		ifi_tcp_cleanup;
	u_int64_t		ifi_tcp_synwindow;
	u_int64_t		reserved[6];
	<span class="enscript-comment">/* UDP */</span>
	u_int64_t		ifi_udp_port_unreach;
	u_int64_t		ifi_udp_faithprefix;
	u_int64_t		ifi_udp_port0;
	u_int64_t		ifi_udp_badlength;
	u_int64_t		ifi_udp_badchksum;
	u_int64_t		ifi_udp_badmcast;
	u_int64_t		ifi_udp_cleanup;
	u_int64_t		ifi_udp_badipsec;
	u_int64_t		_reserved[4];
};

<span class="enscript-type">struct</span> if_description {
	u_int32_t	ifd_maxlen;	<span class="enscript-comment">/* must be IF_DESCSIZE */</span>
	u_int32_t	ifd_len;	<span class="enscript-comment">/* actual ifd_desc length */</span>
	u_int8_t	*ifd_desc;	<span class="enscript-comment">/* ptr to desc buffer */</span>
};

<span class="enscript-type">struct</span> if_bandwidths {
	u_int64_t	eff_bw;		<span class="enscript-comment">/* effective bandwidth */</span>
	u_int64_t	max_bw;		<span class="enscript-comment">/* maximum theoretical bandwidth */</span>
};

<span class="enscript-type">struct</span> if_latencies {
	u_int64_t	eff_lt;		<span class="enscript-comment">/* effective latency */</span>
	u_int64_t	max_lt;		<span class="enscript-comment">/* maximum theoretical latency */</span>
};

<span class="enscript-type">struct</span> if_rxpoll_stats {
	u_int32_t	ifi_poll_off_req;	<span class="enscript-comment">/* total # of POLL_OFF reqs */</span>
	u_int32_t	ifi_poll_off_err;	<span class="enscript-comment">/* total # of POLL_OFF errors */</span>
	u_int32_t	ifi_poll_on_req;	<span class="enscript-comment">/* total # of POLL_ON reqs */</span>
	u_int32_t	ifi_poll_on_err;	<span class="enscript-comment">/* total # of POLL_ON errors */</span>

	u_int32_t	ifi_poll_wakeups_avg;	<span class="enscript-comment">/* avg # of wakeup reqs */</span>
	u_int32_t	ifi_poll_wakeups_lowat;	<span class="enscript-comment">/* wakeups low watermark */</span>
	u_int32_t	ifi_poll_wakeups_hiwat;	<span class="enscript-comment">/* wakeups high watermark */</span>

	u_int64_t	ifi_poll_packets;	<span class="enscript-comment">/* total # of polled packets */</span>
	u_int32_t	ifi_poll_packets_avg;	<span class="enscript-comment">/* average polled packets */</span>
	u_int32_t	ifi_poll_packets_min;	<span class="enscript-comment">/* smallest polled packets */</span>
	u_int32_t	ifi_poll_packets_max;	<span class="enscript-comment">/* largest polled packets */</span>
	u_int32_t	ifi_poll_packets_lowat;	<span class="enscript-comment">/* packets low watermark */</span>
	u_int32_t	ifi_poll_packets_hiwat;	<span class="enscript-comment">/* packets high watermark */</span>

	u_int64_t	ifi_poll_bytes;		<span class="enscript-comment">/* total # of polled bytes */</span>
	u_int32_t	ifi_poll_bytes_avg;	<span class="enscript-comment">/* average polled bytes */</span>
	u_int32_t	ifi_poll_bytes_min;	<span class="enscript-comment">/* smallest polled bytes */</span>
	u_int32_t	ifi_poll_bytes_max;	<span class="enscript-comment">/* largest polled bytes */</span>
	u_int32_t	ifi_poll_bytes_lowat;	<span class="enscript-comment">/* bytes low watermark */</span>
	u_int32_t	ifi_poll_bytes_hiwat;	<span class="enscript-comment">/* bytes high watermark */</span>

	u_int32_t	ifi_poll_packets_limit;	<span class="enscript-comment">/* max packets per poll call */</span>
	u_int64_t	ifi_poll_interval_time;	<span class="enscript-comment">/* poll interval (nsec) */</span>
};

<span class="enscript-comment">/*
 * Interface link status report -- includes statistics related to
 * the link layer technology sent by the driver. The driver will monitor
 * these statistics over an interval (3-4 secs) and will generate a report
 * to the network stack. This will give first-hand information about the
 * status of the first hop of the network path. The version and
 * length values should be correct for the data to be processed correctly.
 * The definitions are different for different kind of interfaces like
 * Wifi, Cellular etc,.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELLULAR_STATUS_REPORT_VERSION_1</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_STATUS_REPORT_VERSION_1</span>		1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELLULAR_STATUS_REPORT_CURRENT_VERSION</span>	\
					IF_CELLULAR_STATUS_REPORT_VERSION_1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_STATUS_REPORT_CURRENT_VERSION</span>	IF_WIFI_STATUS_REPORT_VERSION_1
<span class="enscript-comment">/*
 * For cellular interface --
 * There is no way to share common headers between the Baseband and
 * the kernel. Any changes to this structure will need to be communicated
 * to the Baseband team. It is better to use reserved space instead of
 * changing the size or existing fields in the structure.
 */</span>
<span class="enscript-type">struct</span> if_cellular_status_v1 {
	u_int32_t valid_bitmask; <span class="enscript-comment">/* indicates which fields are valid */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_LINK_QUALITY_METRIC_VALID</span>	0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_EFFECTIVE_BANDWIDTH_VALID</span>	0x2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_MAX_BANDWIDTH_VALID</span>		0x4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_MIN_LATENCY_VALID</span>		0x8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_EFFECTIVE_LATENCY_VALID</span>	0x10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_MAX_LATENCY_VALID</span>		0x20
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_RETXT_LEVEL_VALID</span>		0x40
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_BYTES_LOST_VALID</span>		0x80
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_MIN_QUEUE_SIZE_VALID</span>		0x100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_AVG_QUEUE_SIZE_VALID</span>		0x200
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_MAX_QUEUE_SIZE_VALID</span>		0x400
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_DL_EFFECTIVE_BANDWIDTH_VALID</span>	0x800
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_DL_MAX_BANDWIDTH_VALID</span>		0x1000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_CONFIG_INACTIVITY_TIME_VALID</span>	0x2000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_CONFIG_BACKOFF_TIME_VALID</span>	0x4000
	u_int32_t link_quality_metric;
	u_int32_t ul_effective_bandwidth; <span class="enscript-comment">/* Measured uplink bandwidth based on current activity (bps) */</span>
	u_int32_t ul_max_bandwidth; <span class="enscript-comment">/* Maximum supported uplink bandwidth (bps) */</span>
	u_int32_t ul_min_latency; <span class="enscript-comment">/* min expected uplink latency for first hop (ms) */</span>
	u_int32_t ul_effective_latency; <span class="enscript-comment">/* current expected uplink latency for first hop (ms) */</span>
	u_int32_t ul_max_latency; <span class="enscript-comment">/* max expected uplink latency first hop (ms) */</span>
	u_int32_t ul_retxt_level; <span class="enscript-comment">/* Retransmission metric */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_RETXT_LEVEL_NONE</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_RETXT_LEVEL_LOW</span>	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_RETXT_LEVEL_MEDIUM</span>	3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_CELL_UL_RETXT_LEVEL_HIGH</span>	4
	u_int32_t ul_bytes_lost; <span class="enscript-comment">/* % of total bytes lost on uplink in Q10 format */</span>
	u_int32_t ul_min_queue_size; <span class="enscript-comment">/* minimum bytes in queue */</span>
	u_int32_t ul_avg_queue_size; <span class="enscript-comment">/* average bytes in queue */</span>
	u_int32_t ul_max_queue_size; <span class="enscript-comment">/* maximum bytes in queue */</span>
	u_int32_t dl_effective_bandwidth; <span class="enscript-comment">/* Measured downlink bandwidth based on current activity (bps) */</span>
	u_int32_t dl_max_bandwidth; <span class="enscript-comment">/* Maximum supported downlink bandwidth (bps) */</span>
	u_int32_t config_inactivity_time; <span class="enscript-comment">/* ms */</span>
	u_int32_t config_backoff_time; <span class="enscript-comment">/* new connections backoff time in ms */</span>
	u_int64_t reserved_1;
	u_int64_t reserved_2;
	u_int64_t reserved_3;
	u_int64_t reserved_4;
	u_int64_t reserved_5;
} __attribute__((packed));

<span class="enscript-type">struct</span> if_cellular_status {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> if_cellular_status_v1 if_status_v1;
	} if_cell_u;
};

<span class="enscript-comment">/*
 * These statistics will be provided by the Wifi driver periodically.
 * After sending each report, the driver should start computing again
 * for the next report duration so that the values represent the link
 * status for one report duration.
 */</span>

<span class="enscript-type">struct</span> if_wifi_status_v1 {
	u_int32_t valid_bitmask;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_LINK_QUALITY_METRIC_VALID</span>	0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_UL_EFFECTIVE_BANDWIDTH_VALID</span>	0x2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_UL_MAX_BANDWIDTH_VALID</span>		0x4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_UL_MIN_LATENCY_VALID</span>		0x8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_UL_EFFECTIVE_LATENCY_VALID</span>	0x10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_UL_MAX_LATENCY_VALID</span>		0x20
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_UL_RETXT_LEVEL_VALID</span>		0x40
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_UL_ERROR_RATE_VALID</span>		0x80
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_UL_BYTES_LOST_VALID</span>		0x100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_DL_EFFECTIVE_BANDWIDTH_VALID</span>	0x200
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_DL_MAX_BANDWIDTH_VALID</span>		0x400
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_DL_MIN_LATENCY_VALID</span>		0x800
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_DL_EFFECTIVE_LATENCY_VALID</span>	0x1000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_DL_MAX_LATENCY_VALID</span>		0x2000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_DL_ERROR_RATE_VALID</span>		0x4000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_CONFIG_FREQUENCY_VALID</span>		0x8000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_CONFIG_MULTICAST_RATE_VALID</span>	0x10000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_CONFIG_SCAN_COUNT_VALID</span>		0x20000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_CONFIG_SCAN_DURATION_VALID</span>	0x40000
	u_int32_t link_quality_metric; <span class="enscript-comment">/* link quality metric */</span>
	u_int32_t ul_effective_bandwidth; <span class="enscript-comment">/* Measured uplink bandwidth based on current activity (bps) */</span>
	u_int32_t ul_max_bandwidth; <span class="enscript-comment">/* Maximum supported uplink bandwidth (bps) */</span>
	u_int32_t ul_min_latency; <span class="enscript-comment">/* min expected uplink latency for first hop (ms) */</span>
	u_int32_t ul_effective_latency; <span class="enscript-comment">/* current expected uplink latency for first hop (ms) */</span>
	u_int32_t ul_max_latency; <span class="enscript-comment">/* max expected uplink latency for first hop (ms) */</span>
	u_int32_t ul_retxt_level; <span class="enscript-comment">/* Retransmission metric */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_UL_RETXT_LEVEL_NONE</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_UL_RETXT_LEVEL_LOW</span>	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_UL_RETXT_LEVEL_MEDIUM</span>	3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_UL_RETXT_LEVEL_HIGH</span>	4
	u_int32_t ul_bytes_lost; <span class="enscript-comment">/* % of total bytes lost on uplink in Q10 format */</span>
	u_int32_t ul_error_rate; <span class="enscript-comment">/* % of bytes dropped on uplink after many retransmissions in Q10 format */</span>
	u_int32_t dl_effective_bandwidth; <span class="enscript-comment">/* Measured downlink bandwidth based on current activity (bps) */</span>
	u_int32_t dl_max_bandwidth; <span class="enscript-comment">/* Maximum supported downlink bandwidth (bps) */</span>
	<span class="enscript-comment">/*
	 * The download latency values indicate the time AP may have to wait for the
	 * driver to receive the packet. These values give the range of expected latency
	 * mainly due to co-existence events and channel hopping where the interface
	 * becomes unavailable.
	 */</span>
	u_int32_t dl_min_latency; <span class="enscript-comment">/* min expected latency for first hop in ms */</span>
	u_int32_t dl_effective_latency; <span class="enscript-comment">/* current expected latency for first hop in ms */</span>
	u_int32_t dl_max_latency; <span class="enscript-comment">/* max expected latency for first hop in ms */</span>
	u_int32_t dl_error_rate; <span class="enscript-comment">/* % of CRC or other errors in Q10 format */</span>
	u_int32_t config_frequency; <span class="enscript-comment">/* 2.4 or 5 GHz */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_CONFIG_FREQUENCY_2_4_GHZ</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_WIFI_CONFIG_FREQUENCY_5_0_GHZ</span>	2
	u_int32_t config_multicast_rate; <span class="enscript-comment">/* bps */</span>
	u_int32_t scan_count; <span class="enscript-comment">/* scan count during the previous period */</span>
	u_int32_t scan_duration; <span class="enscript-comment">/* scan duration in ms */</span>
	u_int64_t reserved_1;
	u_int64_t reserved_2;
	u_int64_t reserved_3;
	u_int64_t reserved_4;
} __attribute__((packed));

<span class="enscript-type">struct</span> if_wifi_status {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> if_wifi_status_v1 if_status_v1;
	} if_wifi_u;
};

<span class="enscript-type">struct</span> if_link_status {
	u_int32_t	ifsr_version;	<span class="enscript-comment">/* version of this report */</span>
	u_int32_t	ifsr_len;	<span class="enscript-comment">/* length of the following struct */</span>
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> if_cellular_status ifsr_cell;
		<span class="enscript-type">struct</span> if_wifi_status ifsr_wifi;
	} ifsr_u;
};

<span class="enscript-type">struct</span> if_interface_state {
	<span class="enscript-comment">/*
	 * The bitmask tells which of the fields
	 * to consider:
	 * - When setting, to control which fields
	 *   are being modified;
	 * - When getting, it tells which fields are set.
	 */</span>
	u_int8_t valid_bitmask;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_INTERFACE_STATE_RRC_STATE_VALID</span>		0x1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_INTERFACE_STATE_LQM_STATE_VALID</span>		0x2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_INTERFACE_STATE_INTERFACE_AVAILABILITY_VALID</span>	0x4

	<span class="enscript-comment">/*
	 * Valid only for cellular interface
	 */</span>
	u_int8_t rrc_state;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_INTERFACE_STATE_RRC_STATE_IDLE</span>	0x0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_INTERFACE_STATE_RRC_STATE_CONNECTED</span>	0x1

	<span class="enscript-comment">/*
	 * Values normalized to the edge of the following values
	 * that are defined on &lt;net/if.h&gt;:
	 *  IFNET_LQM_THRESH_BAD
	 *  IFNET_LQM_THRESH_POOR
	 *  IFNET_LQM_THRESH_GOOD
	 */</span>
	int8_t lqm_state;

	<span class="enscript-comment">/*
	 * Indicate if the underlying link is currently
	 * available 
	 */</span>
	u_int8_t interface_availability;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_INTERFACE_STATE_INTERFACE_AVAILABLE</span>		0x0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_INTERFACE_STATE_INTERFACE_UNAVAILABLE</span>	0x1
};

<span class="enscript-type">struct</span> chain_len_stats {
	uint64_t	cls_one;
	uint64_t	cls_two;
	uint64_t	cls_three;
	uint64_t	cls_four;
	uint64_t	cls_five_or_more;
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRIVATE */</span>

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>()

<span class="enscript-comment">/*
 * Structure defining a queue for a network interface.
 */</span>
<span class="enscript-type">struct</span>	ifqueue {
	<span class="enscript-type">void</span>	*ifq_head;
	<span class="enscript-type">void</span>	*ifq_tail;
	<span class="enscript-type">int</span>	ifq_len;
	<span class="enscript-type">int</span>	ifq_maxlen;
	<span class="enscript-type">int</span>	ifq_drops;
};

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
<span class="enscript-comment">/*
 * Internal storage of if_data. This is bound to change. Various places in the
 * stack will translate this data structure in to the externally visible
 * if_data structure above.  Note that during interface attach time, the
 * embedded if_data structure in ifnet is cleared, with the exception of
 * some non-statistics related fields.
 */</span>
<span class="enscript-type">struct</span> if_data_internal {
	<span class="enscript-comment">/* generic interface information */</span>
	u_char		ifi_type;	<span class="enscript-comment">/* ethernet, tokenring, etc */</span>
	u_char		ifi_typelen;	<span class="enscript-comment">/* Length of frame type id */</span>
	u_char		ifi_physical;	<span class="enscript-comment">/* e.g., AUI, Thinnet, 10base-T, etc */</span>
	u_char		ifi_addrlen;	<span class="enscript-comment">/* media address length */</span>
	u_char		ifi_hdrlen;	<span class="enscript-comment">/* media header length */</span>
	u_char		ifi_recvquota;	<span class="enscript-comment">/* polling quota for receive intrs */</span>
	u_char		ifi_xmitquota;	<span class="enscript-comment">/* polling quota for xmit intrs */</span>
	u_char		ifi_unused1;	<span class="enscript-comment">/* for future use */</span>
	u_int32_t	ifi_mtu;	<span class="enscript-comment">/* maximum transmission unit */</span>
	u_int32_t	ifi_metric;	<span class="enscript-comment">/* routing metric (external only) */</span>
	u_int32_t	ifi_baudrate;	<span class="enscript-comment">/* linespeed */</span>
	u_int32_t	ifi_preamblelen;<span class="enscript-comment">/* length of the packet preamble */</span>
	<span class="enscript-comment">/* volatile statistics */</span>
	u_int64_t	ifi_ipackets;	<span class="enscript-comment">/* packets received on interface */</span>
	u_int64_t	ifi_ierrors;	<span class="enscript-comment">/* input errors on interface */</span>
	u_int64_t	ifi_opackets;	<span class="enscript-comment">/* packets sent on interface */</span>
	u_int64_t	ifi_oerrors;	<span class="enscript-comment">/* output errors on interface */</span>
	u_int64_t	ifi_collisions;	<span class="enscript-comment">/* collisions on csma interfaces */</span>
	u_int64_t	ifi_ibytes;	<span class="enscript-comment">/* total number of octets received */</span>
	u_int64_t	ifi_obytes;	<span class="enscript-comment">/* total number of octets sent */</span>
	u_int64_t	ifi_imcasts;	<span class="enscript-comment">/* packets received via multicast */</span>
	u_int64_t	ifi_omcasts;	<span class="enscript-comment">/* packets sent via multicast */</span>
	u_int64_t	ifi_iqdrops;	<span class="enscript-comment">/* dropped on input, this interface */</span>
	u_int64_t	ifi_noproto;	<span class="enscript-comment">/* destined for unsupported protocol */</span>
	u_int32_t	ifi_recvtiming;	<span class="enscript-comment">/* usec spent receiving when timing */</span>
	u_int32_t	ifi_xmittiming;	<span class="enscript-comment">/* usec spent xmitting when timing */</span>
	u_int64_t	ifi_alignerrs;	<span class="enscript-comment">/* unaligned (32-bit) input pkts */</span>
	u_int64_t	ifi_dt_bytes;	<span class="enscript-comment">/* Data threshold counter */</span>
	u_int64_t	ifi_fpackets;	<span class="enscript-comment">/* forwarded packets on interface */</span>
	u_int64_t	ifi_fbytes;	<span class="enscript-comment">/* forwarded bytes on interface */</span>
	<span class="enscript-type">struct</span>	timeval ifi_lastchange;	<span class="enscript-comment">/* time of last administrative change */</span>
	u_int32_t	ifi_hwassist;	<span class="enscript-comment">/* HW offload capabilities */</span>
	u_int32_t	ifi_tso_v4_mtu;	<span class="enscript-comment">/* TCP Segment Offload IPv4 maximum segment size */</span>
	u_int32_t	ifi_tso_v6_mtu;	<span class="enscript-comment">/* TCP Segment Offload IPv6 maximum segment size */</span>
};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MEASURE_BW</span>
<span class="enscript-comment">/*
 * Fields per interface to measure perceived bandwidth.
 */</span>
<span class="enscript-type">struct</span> if_measured_bw {
	u_int64_t	bw;		<span class="enscript-comment">/* measured bandwidth in bytes per ms */</span>
	u_int64_t	bytes;		<span class="enscript-comment">/* XXX not needed */</span>
	u_int64_t	ts;		<span class="enscript-comment">/* XXX not needed */</span>
	u_int64_t	cur_seq __attribute((aligned(8)));	<span class="enscript-comment">/* current sequence for marking a packet */</span>
	u_int64_t	start_ts;	<span class="enscript-comment">/* time at which a measurement started */</span>
	u_int64_t	start_seq;	<span class="enscript-comment">/* sequence at which a measurement should start */</span>
	u_int64_t	last_seq;	<span class="enscript-comment">/* last recorded seq */</span>
	u_int64_t	last_ts;	<span class="enscript-comment">/* last recorded ts */</span>
	u_int32_t	flags __attribute__((aligned(4)));		<span class="enscript-comment">/* flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_MEASURED_BW_INPROGRESS</span> 0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_MEASURED_BW_CALCULATION</span> 0x2
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MEASURE_BW */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PRIVATE</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_mtu</span>		if_data.ifi_mtu
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_type</span>		if_data.ifi_type
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">if_typelen</span>	if_data.ifi_typelen
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">if_physical</span>	if_data.ifi_physical
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_addrlen</span>	if_data.ifi_addrlen
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_hdrlen</span>	if_data.ifi_hdrlen
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_preamblelen</span>	if_data.ifi_preamblelen
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_metric</span>	if_data.ifi_metric
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_baudrate</span>	if_data.ifi_baudrate
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_hwassist</span>	if_data.ifi_hwassist
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_ipackets</span>	if_data.ifi_ipackets
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_ierrors</span>	if_data.ifi_ierrors
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_opackets</span>	if_data.ifi_opackets
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_oerrors</span>	if_data.ifi_oerrors
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_collisions</span>	if_data.ifi_collisions
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_ibytes</span>	if_data.ifi_ibytes
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_obytes</span>	if_data.ifi_obytes
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_imcasts</span>	if_data.ifi_imcasts
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_omcasts</span>	if_data.ifi_omcasts
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_iqdrops</span>	if_data.ifi_iqdrops
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_noproto</span>	if_data.ifi_noproto
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_lastchange</span>	if_data.ifi_lastchange
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">if_recvquota</span>	if_data.ifi_recvquota
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_xmitquota</span>	if_data.ifi_xmitquota
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRIVATE */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_tso_v4_mtu</span>	if_data.ifi_tso_v4_mtu
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_tso_v6_mtu</span>	if_data.ifi_tso_v6_mtu
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_alignerrs</span>	if_data.ifi_alignerrs
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_dt_bytes</span>	if_data.ifi_dt_bytes
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_fpackets</span>	if_data.ifi_fpackets
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_fbytes</span>	if_data.ifi_fbytes
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
<span class="enscript-comment">/*
 * Forward structure declarations for function prototypes [sic].
 */</span>
<span class="enscript-type">struct</span> proc;
<span class="enscript-type">struct</span> rtentry;
<span class="enscript-type">struct</span> socket;
<span class="enscript-type">struct</span> ifnet_filter;
<span class="enscript-type">struct</span> mbuf;
<span class="enscript-type">struct</span> ifaddr;
<span class="enscript-type">struct</span> tqdummy;
<span class="enscript-type">struct</span> proto_hash_entry;
<span class="enscript-type">struct</span> dlil_threading_info;
<span class="enscript-type">struct</span> tcpstat_local;
<span class="enscript-type">struct</span> udpstat_local;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
<span class="enscript-type">struct</span> pfi_kif;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

<span class="enscript-comment">/* we use TAILQs so that the order of instantiation is preserved in the list */</span>
<span class="enscript-function-name">TAILQ_HEAD</span>(ifnethead, ifnet);
<span class="enscript-function-name">TAILQ_HEAD</span>(ifaddrhead, ifaddr);
<span class="enscript-function-name">TAILQ_HEAD</span>(ifprefixhead, ifprefix);
<span class="enscript-function-name">LIST_HEAD</span>(ifmultihead, ifmultiaddr);
<span class="enscript-function-name">TAILQ_HEAD</span>(tailq_head, tqdummy);
<span class="enscript-function-name">TAILQ_HEAD</span>(ifnet_filter_head, ifnet_filter);
<span class="enscript-function-name">TAILQ_HEAD</span>(ddesc_head_name, dlil_demux_desc);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PRIVATE</span>
<span class="enscript-comment">/*
 * All of the following IF_HWASSIST_* flags are defined in kpi_inteface.h as
 * IFNET_* flags. These are redefined here as constants to avoid failures to
 * build user level programs that can not include kpi_interface.h. It is
 * important to keep this in sync with the definitions in kpi_interface.h.
 * The corresponding constant for each definition is mentioned in the comment.
 *
 * Bottom 16 bits reserved for hardware checksum
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_CSUM_IP</span>		0x0001	<span class="enscript-comment">/* will csum IP, IFNET_CSUM_IP */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_CSUM_TCP</span>		0x0002	<span class="enscript-comment">/* will csum TCP, IFNET_CSUM_TCP */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_CSUM_UDP</span>		0x0004	<span class="enscript-comment">/* will csum UDP, IFNET_CSUM_UDP */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_CSUM_IP_FRAGS</span>	0x0008	<span class="enscript-comment">/* will csum IP fragments, IFNET_CSUM_FRAGMENT */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_CSUM_FRAGMENT</span>	0x0010	<span class="enscript-comment">/* will do IP fragmentation, IFNET_IP_FRAGMENT */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_CSUM_TCPIPV6</span>	0x0020	<span class="enscript-comment">/* will csum TCPv6, IFNET_CSUM_TCPIPV6 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_CSUM_UDPIPV6</span>	0x0040	<span class="enscript-comment">/* will csum UDPv6, IFNET_CSUM_UDP */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_CSUM_FRAGMENT_IPV6</span>	0x0080	<span class="enscript-comment">/* will do IPv6 fragmentation, IFNET_IPV6_FRAGMENT */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_CSUM_PARTIAL</span>	0x1000	<span class="enscript-comment">/* simple Sum16 computation, IFNET_CSUM_PARTIAL */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_CSUM_MASK</span>		0xffff
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IF_HWASSIST_CSUM_FLAGS</span>(hwassist)	((hwassist) &amp; IF_HWASSIST_CSUM_MASK)

<span class="enscript-comment">/* VLAN support */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_VLAN_TAGGING</span>	0x00010000	<span class="enscript-comment">/* supports VLAN tagging, IFNET_VLAN_TAGGING */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_VLAN_MTU</span>		0x00020000	<span class="enscript-comment">/* supports VLAN MTU-sized packet (for software VLAN), IFNET_VLAN_MTU */</span>

<span class="enscript-comment">/* TCP Segment Offloading support */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_TSO_V4</span>		0x00200000	<span class="enscript-comment">/* will do TCP Segment offload for IPv4, IFNET_TSO_IPV4 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_HWASSIST_TSO_V6</span>		0x00400000	<span class="enscript-comment">/* will do TCP Segment offload for IPv6, IFNET_TSO_IPV6 */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRIVATE */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PRIVATE</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFXNAMSIZ</span>	(IFNAMSIZ + 8)	<span class="enscript-comment">/* external name (name + unit) */</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
<span class="enscript-comment">/*
 * ifnet is private to BSD portion of kernel
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tree.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/if_classq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>

<span class="enscript-function-name">RB_HEAD</span>(ll_reach_tree, if_llreach);	<span class="enscript-comment">/* define struct ll_reach_tree */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">if_name</span>(ifp)	ifp-&gt;if_xname
<span class="enscript-comment">/*
 * Structure defining a network interface.
 *
 * (Would like to call this struct ``if'', but C isn't PL/1.)
 */</span>
<span class="enscript-type">struct</span> ifnet {
	<span class="enscript-comment">/*
	 * Lock (RW or mutex) to protect this data structure (static storage.)
	 */</span>
	decl_lck_rw_data(, if_lock);
	<span class="enscript-type">void</span>		*if_softc;	<span class="enscript-comment">/* pointer to driver state */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*if_name;	<span class="enscript-comment">/* name, e.g. ``en'' or ``lo'' */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*if_xname;	<span class="enscript-comment">/* external name (name + unit) */</span>
	<span class="enscript-type">struct</span> if_description if_desc;	<span class="enscript-comment">/* extended description */</span>
	TAILQ_ENTRY(ifnet) if_link;	<span class="enscript-comment">/* all struct ifnets are chained */</span>
	TAILQ_ENTRY(ifnet) if_detaching_link; <span class="enscript-comment">/* list of detaching ifnets */</span>

	decl_lck_mtx_data(, if_ref_lock)
	u_int32_t	if_refflags;	<span class="enscript-comment">/* see IFRF flags below */</span>
	u_int32_t	if_refio;	<span class="enscript-comment">/* number of io ops to the underlying driver */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_list</span>		if_link
	<span class="enscript-type">struct</span> ifaddrhead if_addrhead;	<span class="enscript-comment">/* linked list of addresses per if */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">if_addrlist</span>	if_addrhead
	<span class="enscript-type">struct</span> ifaddr	*if_lladdr;	<span class="enscript-comment">/* link address (first/permanent) */</span>

	<span class="enscript-type">int</span>		if_pcount;	<span class="enscript-comment">/* number of promiscuous listeners */</span>
	<span class="enscript-type">struct</span> bpf_if	*if_bpf;	<span class="enscript-comment">/* packet filter structure */</span>
	u_short		if_index;	<span class="enscript-comment">/* numeric abbreviation for this if  */</span>
	<span class="enscript-type">short</span>		if_unit;	<span class="enscript-comment">/* sub-unit for lower level driver */</span>
	<span class="enscript-type">short</span>		if_timer;	<span class="enscript-comment">/* time 'til if_watchdog called */</span>
	<span class="enscript-type">short</span>		if_flags;	<span class="enscript-comment">/* up/down, broadcast, etc. */</span>
	u_int32_t	if_eflags;	<span class="enscript-comment">/* see &lt;net/if.h&gt; */</span>

	<span class="enscript-type">int</span>		if_capabilities;	<span class="enscript-comment">/* interface features &amp; capabilities */</span>
	<span class="enscript-type">int</span>		if_capenable;		<span class="enscript-comment">/* enabled features &amp; capabilities */</span>

	<span class="enscript-type">void</span>		*if_linkmib;	<span class="enscript-comment">/* link-type-specific MIB data */</span>
	size_t		if_linkmiblen;	<span class="enscript-comment">/* length of above data */</span>

	<span class="enscript-type">struct</span> if_data_internal if_data __attribute__((aligned(8)));

	ifnet_family_t		if_family;	<span class="enscript-comment">/* value assigned by Apple */</span>
	ifnet_subfamily_t	if_subfamily;	<span class="enscript-comment">/* value assigned by Apple */</span>
	uintptr_t		if_family_cookie;
	ifnet_output_func	if_output;
	ifnet_pre_enqueue_func	if_pre_enqueue;
	ifnet_start_func	if_start;
	ifnet_ctl_func		if_output_ctl;
	ifnet_input_poll_func	if_input_poll;
	ifnet_ctl_func		if_input_ctl;
	ifnet_ioctl_func	if_ioctl;
	ifnet_set_bpf_tap	if_set_bpf_tap;
	ifnet_detached_func	if_free;
	ifnet_demux_func	if_demux;
	ifnet_event_func	if_event;
	ifnet_framer_func	if_framer_legacy;
	ifnet_framer_extended_func if_framer;
	ifnet_add_proto_func	if_add_proto;
	ifnet_del_proto_func	if_del_proto;
	ifnet_check_multi	if_check_multi;
	<span class="enscript-type">struct</span> proto_hash_entry	*if_proto_hash;
	<span class="enscript-type">void</span>			*if_kpi_storage;

	u_int32_t		if_flowhash;	<span class="enscript-comment">/* interface flow control ID */</span>

	decl_lck_mtx_data(, if_start_lock);
	u_int32_t		if_start_flags;	<span class="enscript-comment">/* see IFSF flags below */</span>
	u_int32_t		if_start_req;
	u_int16_t		if_start_active; <span class="enscript-comment">/* output is active */</span>
	u_int16_t		if_start_delayed;
	u_int16_t		if_start_delay_qlen;
	u_int16_t		if_start_delay_idle;
	u_int64_t		if_start_delay_swin;
	u_int32_t		if_start_delay_cnt;
	u_int32_t		if_start_delay_timeout;	<span class="enscript-comment">/* nanoseconds */</span>
	<span class="enscript-type">struct</span> timespec		if_start_cycle;	 <span class="enscript-comment">/* restart interval */</span>
	<span class="enscript-type">struct</span> thread		*if_start_thread;

	<span class="enscript-type">struct</span> ifclassq		if_snd;		<span class="enscript-comment">/* transmit queue */</span>
	u_int32_t		if_output_sched_model;	<span class="enscript-comment">/* tx sched model */</span>

	<span class="enscript-type">struct</span> if_bandwidths	if_output_bw;
	<span class="enscript-type">struct</span> if_bandwidths	if_input_bw;

	<span class="enscript-type">struct</span> if_latencies	if_output_lt;
	<span class="enscript-type">struct</span> if_latencies	if_input_lt;

	decl_lck_mtx_data(, if_flt_lock)
	u_int32_t		if_flt_busy;
	u_int32_t		if_flt_waiters;
	<span class="enscript-type">struct</span> ifnet_filter_head if_flt_head;

	<span class="enscript-type">struct</span> ifmultihead	if_multiaddrs;	<span class="enscript-comment">/* multicast addresses */</span>
	u_int32_t		if_updatemcasts; <span class="enscript-comment">/* mcast addrs need updating */</span>
	<span class="enscript-type">int</span>			if_amcount;	<span class="enscript-comment">/* # of all-multicast reqs */</span>
	decl_lck_mtx_data(, if_addrconfig_lock); <span class="enscript-comment">/* for serializing addr config */</span>
	<span class="enscript-type">struct</span> in_multi		*if_allhostsinm; <span class="enscript-comment">/* store all-hosts inm for this ifp */</span>

	decl_lck_mtx_data(, if_poll_lock);
	u_int16_t		if_poll_req;
	u_int16_t		if_poll_update;	<span class="enscript-comment">/* link update */</span>
	u_int32_t		if_poll_active;	<span class="enscript-comment">/* polling is active */</span>
	<span class="enscript-type">struct</span> timespec		if_poll_cycle;  <span class="enscript-comment">/* poll interval */</span>
	<span class="enscript-type">struct</span> thread		*if_poll_thread;

	<span class="enscript-type">struct</span> dlil_threading_info *if_inp;

	<span class="enscript-type">struct</span>	ifprefixhead	if_prefixhead;	<span class="enscript-comment">/* list of prefixes per if */</span>
	<span class="enscript-type">struct</span> {
		u_int32_t	length;
		<span class="enscript-type">union</span> {
			u_char	buffer[8];
			u_char	*ptr;
		} u;
	} if_broadcast;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	<span class="enscript-type">struct</span> label		*if_label;	<span class="enscript-comment">/* interface MAC label */</span>
#<span class="enscript-reference">endif</span>

	u_int32_t		if_wake_properties;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	<span class="enscript-type">struct</span> pfi_kif		*if_pf_kif;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

	decl_lck_mtx_data(, if_cached_route_lock);
	u_int32_t		if_fwd_cacheok;
	<span class="enscript-type">struct</span> route		if_fwd_route;	<span class="enscript-comment">/* cached forwarding route */</span>
	<span class="enscript-type">struct</span> route		if_src_route;	<span class="enscript-comment">/* cached ipv4 source route */</span>
	<span class="enscript-type">struct</span> route_in6	if_src_route6;	<span class="enscript-comment">/* cached ipv6 source route */</span>

	decl_lck_rw_data(, if_llreach_lock);
	<span class="enscript-type">struct</span> ll_reach_tree	if_ll_srcs;	<span class="enscript-comment">/* source link-layer tree */</span>

	<span class="enscript-type">void</span>			*if_bridge;	<span class="enscript-comment">/* bridge glue */</span>

	u_int32_t		if_want_aggressive_drain;
	u_int32_t		if_idle_flags;	<span class="enscript-comment">/* idle flags */</span>
	u_int32_t		if_idle_new_flags; <span class="enscript-comment">/* temporary idle flags */</span>
	u_int32_t		if_idle_new_flags_mask; <span class="enscript-comment">/* temporary mask */</span>
	u_int32_t		if_route_refcnt; <span class="enscript-comment">/* idle: route ref count */</span>

	<span class="enscript-type">struct</span> if_traffic_class if_tc __attribute__((aligned(8)));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-type">struct</span> igmp_ifinfo	*if_igi;	<span class="enscript-comment">/* for IGMPv3 */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> mld_ifinfo	*if_mli;	<span class="enscript-comment">/* for MLDv2 */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MEASURE_BW</span>
	<span class="enscript-type">struct</span> if_measured_bw	if_bw;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MEASURE_BW */</span>
	<span class="enscript-type">struct</span> tcpstat_local	*if_tcp_stat;	<span class="enscript-comment">/* TCP specific stats */</span>
	<span class="enscript-type">struct</span> udpstat_local	*if_udp_stat;	<span class="enscript-comment">/* UDP specific stats */</span>

	<span class="enscript-type">struct</span> {
		int32_t		level;		<span class="enscript-comment">/* cached logging level */</span>
		u_int32_t	flags;		<span class="enscript-comment">/* cached logging flags */</span>
		int32_t		category;	<span class="enscript-comment">/* cached category */</span>
		int32_t		subcategory;	<span class="enscript-comment">/* cached subcategory */</span>
	} if_log;

	<span class="enscript-type">struct</span> {
		<span class="enscript-type">struct</span> ifnet	*ifp;		<span class="enscript-comment">/* delegated ifp */</span>
		u_int32_t	type;		<span class="enscript-comment">/* delegated i/f type */</span>
		u_int32_t	family;		<span class="enscript-comment">/* delegated i/f family */</span>
		u_int32_t	subfamily;	<span class="enscript-comment">/* delegated i/f sub-family */</span>
		uint32_t	expensive:1;	<span class="enscript-comment">/* delegated i/f expensive? */</span>
	} if_delegated;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_MAXAGENTS</span>	8
	uuid_t			if_agentids[IF_MAXAGENTS];

	u_int64_t		if_data_threshold;
	u_int32_t		if_fg_sendts;	<span class="enscript-comment">/* last send on a fg socket in seconds */</span>
	u_int32_t		if_rt_sendts;	<span class="enscript-comment">/* last of a real time packet */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	decl_lck_rw_data(, if_inetdata_lock);
	<span class="enscript-type">void</span>			*if_inetdata;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	decl_lck_rw_data(, if_inet6data_lock);
	<span class="enscript-type">void</span>			*if_inet6data;
#<span class="enscript-reference">endif</span>
	decl_lck_rw_data(, if_link_status_lock);
	<span class="enscript-type">struct</span> if_link_status	*if_link_status;
	<span class="enscript-type">struct</span> if_interface_state	if_interface_state;
};

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IF_TCP_STATINC</span>(_ifp, _s) do {					\
	<span class="enscript-keyword">if</span> ((_ifp)-&gt;if_tcp_stat != NULL)				\
		atomic_add_64(&amp;(_ifp)-&gt;if_tcp_stat-&gt;_s, 1);		\
} <span class="enscript-keyword">while</span> (0);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IF_UDP_STATINC</span>(_ifp, _s) do {					\
	<span class="enscript-keyword">if</span> ((_ifp)-&gt;if_udp_stat != NULL)				\
		atomic_add_64(&amp;(_ifp)-&gt;if_udp_stat-&gt;_s, 1);		\
} <span class="enscript-keyword">while</span> (0);

<span class="enscript-comment">/*
 * Valid values for if_refflags
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFRF_ATTACHED</span>	0x1	<span class="enscript-comment">/* ifnet attach is completely done */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFRF_DETACHING</span>	0x2	<span class="enscript-comment">/* detach has been requested */</span>

<span class="enscript-comment">/*
 * Valid values for if_start_flags
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFSF_FLOW_CONTROLLED</span>	0x1	<span class="enscript-comment">/* flow controlled */</span>

<span class="enscript-comment">/*
 * Structure describing a `cloning' interface.
 */</span>
<span class="enscript-type">struct</span> if_clone {
	LIST_ENTRY(if_clone) ifc_list;	<span class="enscript-comment">/* on list of cloners */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*ifc_name;	<span class="enscript-comment">/* name of device, e.g. `vlan' */</span>
	size_t		ifc_namelen;	<span class="enscript-comment">/* length of name */</span>
	u_int32_t	ifc_minifs;	<span class="enscript-comment">/* minimum number of interfaces */</span>
	u_int32_t	ifc_maxunit;	<span class="enscript-comment">/* maximum unit number */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>	*ifc_units;	<span class="enscript-comment">/* bitmap to handle units */</span>
	u_int32_t	ifc_bmlen;	<span class="enscript-comment">/* bitmap length */</span>

	<span class="enscript-type">int</span>		(*ifc_create)(<span class="enscript-type">struct</span> if_clone *, u_int32_t, <span class="enscript-type">void</span> *);
	<span class="enscript-type">int</span>		(*ifc_destroy)(<span class="enscript-type">struct</span> ifnet *);
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IF_CLONE_INITIALIZER</span>(name, create, destroy, minifs, maxunit) {	      \
	{ NULL, NULL }, name, (<span class="enscript-keyword">sizeof</span> (name) - 1), minifs, maxunit, NULL, 0,  \
	create, destroy							      \
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">M_CLONE</span>         M_IFADDR

<span class="enscript-comment">/*
 * Macros to manipulate ifqueue.  Users of these macros are responsible
 * for serialization, by holding whatever lock is appropriate for the
 * corresponding structure that is referring the ifqueue.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IF_QFULL</span>(ifq)		((ifq)-&gt;ifq_len &gt;= (ifq)-&gt;ifq_maxlen)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IF_DROP</span>(ifq)		((ifq)-&gt;ifq_drops++)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IF_ENQUEUE</span>(ifq, m) do {						\
	(m)-&gt;m_nextpkt = NULL;						\
	<span class="enscript-keyword">if</span> ((ifq)-&gt;ifq_tail == NULL)					\
		(ifq)-&gt;ifq_head = m;					\
	<span class="enscript-keyword">else</span>								\
		((<span class="enscript-type">struct</span> mbuf*)(ifq)-&gt;ifq_tail)-&gt;m_nextpkt = m;		\
	(ifq)-&gt;ifq_tail = m;						\
	(ifq)-&gt;ifq_len++;						\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IF_PREPEND</span>(ifq, m) do {						\
	(m)-&gt;m_nextpkt = (ifq)-&gt;ifq_head;				\
	<span class="enscript-keyword">if</span> ((ifq)-&gt;ifq_tail == NULL)					\
		(ifq)-&gt;ifq_tail = (m);					\
	(ifq)-&gt;ifq_head = (m);						\
	(ifq)-&gt;ifq_len++;						\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IF_DEQUEUE</span>(ifq, m) do {						\
	(m) = (ifq)-&gt;ifq_head;						\
	<span class="enscript-keyword">if</span> (m != NULL) {						\
		<span class="enscript-keyword">if</span> (((ifq)-&gt;ifq_head = (m)-&gt;m_nextpkt) == NULL)		\
			(ifq)-&gt;ifq_tail = NULL;				\
		(m)-&gt;m_nextpkt = NULL;					\
		(ifq)-&gt;ifq_len--;					\
	}								\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IF_REMQUEUE</span>(ifq, m) do {					\
	<span class="enscript-type">struct</span> mbuf *_p = (ifq)-&gt;ifq_head;				\
	<span class="enscript-type">struct</span> mbuf *_n = (m)-&gt;m_nextpkt;				\
	<span class="enscript-keyword">if</span> ((m) == _p)							\
		_p = NULL;						\
	<span class="enscript-keyword">while</span> (_p != NULL) {						\
		<span class="enscript-keyword">if</span> (_p-&gt;m_nextpkt == (m))				\
			<span class="enscript-keyword">break</span>;						\
		_p = _p-&gt;m_nextpkt;					\
	}								\
	VERIFY(_p != NULL || ((m) == (ifq)-&gt;ifq_head));			\
	<span class="enscript-keyword">if</span> ((m) == (ifq)-&gt;ifq_head)					\
		(ifq)-&gt;ifq_head = _n;					\
	<span class="enscript-keyword">if</span> ((m) == (ifq)-&gt;ifq_tail)					\
		(ifq)-&gt;ifq_tail = _p;					\
	VERIFY((ifq)-&gt;ifq_tail != NULL || (ifq)-&gt;ifq_head == NULL);	\
	VERIFY((ifq)-&gt;ifq_len != 0);					\
	--(ifq)-&gt;ifq_len;						\
	<span class="enscript-keyword">if</span> (_p != NULL)							\
		_p-&gt;m_nextpkt = _n;					\
	(m)-&gt;m_nextpkt = NULL;						\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IF_DRAIN</span>(ifq) do {						\
	<span class="enscript-type">struct</span> mbuf *_m;						\
	<span class="enscript-keyword">for</span> (;;) {							\
		IF_DEQUEUE(ifq, _m);					\
		<span class="enscript-keyword">if</span> (_m == NULL)						\
			<span class="enscript-keyword">break</span>;						\
		m_freem(_m);						\
	}								\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * The ifaddr structure contains information about one address
 * of an interface.  They are maintained by the different address families,
 * are allocated and attached when an address is set, and are linked
 * together so all addresses for an interface can be located.
 */</span>
<span class="enscript-type">struct</span> ifaddr {
	decl_lck_mtx_data(, ifa_lock);	<span class="enscript-comment">/* lock for ifaddr */</span>
	uint32_t	ifa_refcnt;	<span class="enscript-comment">/* ref count, use IFA_{ADD,REM}REF */</span>
	uint32_t	ifa_debug;	<span class="enscript-comment">/* debug flags */</span>
	<span class="enscript-type">struct</span> sockaddr	*ifa_addr;	<span class="enscript-comment">/* address of interface */</span>
	<span class="enscript-type">struct</span> sockaddr	*ifa_dstaddr;	<span class="enscript-comment">/* other end of p-to-p link */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ifa_broadaddr</span>	ifa_dstaddr	<span class="enscript-comment">/* broadcast address interface */</span>
	<span class="enscript-type">struct</span> sockaddr	*ifa_netmask;	<span class="enscript-comment">/* used to determine subnet */</span>
	<span class="enscript-type">struct</span> ifnet	*ifa_ifp;	<span class="enscript-comment">/* back-pointer to interface */</span>
	TAILQ_ENTRY(ifaddr) ifa_link;	<span class="enscript-comment">/* queue macro glue */</span>
	<span class="enscript-type">void</span> (*ifa_rtrequest)		<span class="enscript-comment">/* check or clean routes (+ or -)'d */</span>
	    (<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> sockaddr *);
	uint32_t	ifa_flags;	<span class="enscript-comment">/* mostly rt_flags for cloning */</span>
	int32_t		ifa_metric;	<span class="enscript-comment">/* cost of going out this interface */</span>
	<span class="enscript-type">void</span> (*ifa_free)(<span class="enscript-type">struct</span> ifaddr *); <span class="enscript-comment">/* callback fn for freeing */</span>
	<span class="enscript-type">void</span> (*ifa_trace)		<span class="enscript-comment">/* callback fn for tracing refs */</span>
	    (<span class="enscript-type">struct</span> ifaddr *, <span class="enscript-type">int</span>);
	<span class="enscript-type">void</span> (*ifa_attached)(<span class="enscript-type">struct</span> ifaddr *); <span class="enscript-comment">/* callback fn for attaching */</span>
	<span class="enscript-type">void</span> (*ifa_detached)(<span class="enscript-type">struct</span> ifaddr *); <span class="enscript-comment">/* callback fn for detaching */</span>
};


<span class="enscript-comment">/*
 * Valid values for ifa_flags
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFA_ROUTE</span>	RTF_UP		<span class="enscript-comment">/* route installed (0x1) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFA_CLONING</span>	RTF_CLONING	<span class="enscript-comment">/* (0x100) */</span>

<span class="enscript-comment">/*
 * Valid values for ifa_debug
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFD_ATTACHED</span>	0x1		<span class="enscript-comment">/* attached to list */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFD_ALLOC</span>	0x2		<span class="enscript-comment">/* dynamically allocated */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFD_DEBUG</span>	0x4		<span class="enscript-comment">/* has debugging info */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFD_LINK</span>	0x8		<span class="enscript-comment">/* link address */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFD_TRASHED</span>	0x10		<span class="enscript-comment">/* in trash list */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFD_SKIP</span>	0x20		<span class="enscript-comment">/* skip this entry */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFD_NOTREADY</span>	0x40		<span class="enscript-comment">/* embryonic; not yet ready */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFA_LOCK_ASSERT_HELD</span>(_ifa)					\
	lck_mtx_assert(&amp;(_ifa)-&gt;ifa_lock, LCK_MTX_ASSERT_OWNED)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFA_LOCK_ASSERT_NOTHELD</span>(_ifa)					\
	lck_mtx_assert(&amp;(_ifa)-&gt;ifa_lock, LCK_MTX_ASSERT_NOTOWNED)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFA_LOCK</span>(_ifa)							\
	lck_mtx_lock(&amp;(_ifa)-&gt;ifa_lock)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFA_LOCK_SPIN</span>(_ifa)						\
	lck_mtx_lock_spin(&amp;(_ifa)-&gt;ifa_lock)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFA_CONVERT_LOCK</span>(_ifa) do {					\
	IFA_LOCK_ASSERT_HELD(_ifa);					\
	lck_mtx_convert_spin(&amp;(_ifa)-&gt;ifa_lock);			\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFA_UNLOCK</span>(_ifa)						\
	lck_mtx_unlock(&amp;(_ifa)-&gt;ifa_lock)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFA_ADDREF</span>(_ifa)						\
	ifa_addref(_ifa, 0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFA_ADDREF_LOCKED</span>(_ifa)						\
	ifa_addref(_ifa, 1)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFA_REMREF</span>(_ifa) do {						\
	(<span class="enscript-type">void</span>) ifa_remref(_ifa, 0);					\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFA_REMREF_LOCKED</span>(_ifa)						\
	ifa_remref(_ifa, 1)

<span class="enscript-comment">/*
 * The prefix structure contains information about one prefix
 * of an interface.  They are maintained by the different address families,
 * are allocated and attached when an prefix or an address is set,
 * and are linked together so all prefixes for an interface can be located.
 */</span>
<span class="enscript-type">struct</span> ifprefix {
	<span class="enscript-type">struct</span>	sockaddr *ifpr_prefix;	<span class="enscript-comment">/* prefix of interface */</span>
	<span class="enscript-type">struct</span>	ifnet *ifpr_ifp;	<span class="enscript-comment">/* back-pointer to interface */</span>
	TAILQ_ENTRY(ifprefix) ifpr_list; <span class="enscript-comment">/* queue macro glue */</span>
	u_char	ifpr_plen;		<span class="enscript-comment">/* prefix length in bits */</span>
	u_char	ifpr_type;		<span class="enscript-comment">/* protocol dependent prefix type */</span>
};

<span class="enscript-comment">/*
 * Multicast address structure.  This is analogous to the ifaddr
 * structure except that it keeps track of multicast addresses.
 * Also, the request count here is a count of requests for this
 * address, not a count of pointers to this structure; anonymous
 * membership(s) holds one outstanding request count.
 */</span>
<span class="enscript-type">struct</span> ifmultiaddr {
	decl_lck_mtx_data(, ifma_lock);
	u_int32_t ifma_refcount;	<span class="enscript-comment">/* reference count */</span>
	u_int32_t ifma_anoncnt;		<span class="enscript-comment">/* # of anonymous requests */</span>
	u_int32_t ifma_reqcnt;		<span class="enscript-comment">/* total requests for this address */</span>
	u_int32_t ifma_debug;		<span class="enscript-comment">/* see ifa_debug flags */</span>
	u_int32_t ifma_flags;		<span class="enscript-comment">/* see below */</span>
	LIST_ENTRY(ifmultiaddr) ifma_link; <span class="enscript-comment">/* queue macro glue */</span>
	<span class="enscript-type">struct</span> sockaddr *ifma_addr;	<span class="enscript-comment">/* address this membership is for */</span>
	<span class="enscript-type">struct</span> ifmultiaddr *ifma_ll;	<span class="enscript-comment">/* link-layer translation, if any */</span>
	<span class="enscript-type">struct</span> ifnet *ifma_ifp;		<span class="enscript-comment">/* back-pointer to interface */</span>
	<span class="enscript-type">void</span> *ifma_protospec;		<span class="enscript-comment">/* protocol-specific state, if any */</span>
	<span class="enscript-type">void</span> (*ifma_trace)		<span class="enscript-comment">/* callback fn for tracing refs */</span>
	    (<span class="enscript-type">struct</span> ifmultiaddr *, <span class="enscript-type">int</span>);
};

<span class="enscript-comment">/*
 * Values for ifma_flags
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFMAF_ANONYMOUS</span>		0x1	<span class="enscript-comment">/* has anonymous request ref(s) held */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFMA_LOCK_ASSERT_HELD</span>(_ifma)					\
	lck_mtx_assert(&amp;(_ifma)-&gt;ifma_lock, LCK_MTX_ASSERT_OWNED)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFMA_LOCK_ASSERT_NOTHELD</span>(_ifma)					\
	lck_mtx_assert(&amp;(_ifma)-&gt;ifma_lock, LCK_MTX_ASSERT_NOTOWNED)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFMA_LOCK</span>(_ifma)						\
	lck_mtx_lock(&amp;(_ifma)-&gt;ifma_lock)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFMA_LOCK_SPIN</span>(_ifma)						\
	lck_mtx_lock_spin(&amp;(_ifma)-&gt;ifma_lock)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFMA_CONVERT_LOCK</span>(_ifma) do {					\
	IFMA_LOCK_ASSERT_HELD(_ifma);					\
	lck_mtx_convert_spin(&amp;(_ifma)-&gt;ifma_lock);			\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFMA_UNLOCK</span>(_ifma)						\
	lck_mtx_unlock(&amp;(_ifma)-&gt;ifma_lock)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFMA_ADDREF</span>(_ifma)						\
	ifma_addref(_ifma, 0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFMA_ADDREF_LOCKED</span>(_ifma)					\
	ifma_addref(_ifma, 1)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFMA_REMREF</span>(_ifma)						\
	ifma_remref(_ifma)

<span class="enscript-comment">/*
 * Indicate whether or not the immediate interface, or the interface delegated
 * by it, is a cellular interface (IFT_CELLULAR).  Delegated interface type is
 * set/cleared along with the delegated ifp; we cache the type for performance
 * to avoid dereferencing delegated ifp each time.
 *
 * Note that this is meant to be used only for accounting and policy purposes;
 * certain places need to explicitly know the immediate interface type, and
 * this macro should not be used there.
 *
 * The test is done against IFT_CELLULAR instead of IFNET_FAMILY_CELLULAR to
 * handle certain cases where the family isn't set to the latter.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFNET_IS_CELLULAR</span>(_ifp)						\
	((_ifp)-&gt;if_type == IFT_CELLULAR ||				\
	(_ifp)-&gt;if_delegated.type == IFT_CELLULAR)

<span class="enscript-comment">/*
 * Indicate whether or not the immediate interface, or the interface delegated
 * by it, is a Wi-Fi interface (IFNET_SUBFAMILY_WIFI).  Delegated interface
 * subfamily is set/cleared along with the delegated ifp; we cache the subfamily
 * for performance to avoid dereferencing delegated ifp each time.
 *
 * Note that this is meant to be used only for accounting and policy purposes;
 * certain places need to explicitly know the immediate interface type, and
 * this macro should not be used there.
 *
 * The test is done against IFNET_SUBFAMILY_WIFI as the family may be set to
 * IFNET_FAMILY_ETHERNET (as well as type to IFT_ETHER) which is too generic.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFNET_IS_WIFI</span>(_ifp)						\
	((_ifp)-&gt;if_subfamily == IFNET_SUBFAMILY_WIFI ||		\
	(_ifp)-&gt;if_delegated.subfamily == IFNET_SUBFAMILY_WIFI)

<span class="enscript-comment">/*
 * Indicate whether or not the immediate interface, or the interface delegated
 * by it, is a Wired interface (several families).  Delegated interface
 * family is set/cleared along with the delegated ifp; we cache the family
 * for performance to avoid dereferencing delegated ifp each time.
 *
 * Note that this is meant to be used only for accounting and policy purposes;
 * certain places need to explicitly know the immediate interface type, and
 * this macro should not be used there.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFNET_IS_WIRED</span>(_ifp)						\
	((_ifp)-&gt;if_family == IFNET_FAMILY_ETHERNET ||			\
	(_ifp)-&gt;if_delegated.family == IFNET_FAMILY_ETHERNET ||		\
	(_ifp)-&gt;if_family == IFNET_FAMILY_FIREWIRE ||			\
	(_ifp)-&gt;if_delegated.family == IFNET_FAMILY_FIREWIRE)

<span class="enscript-comment">/*
 * Indicate whether or not the immediate interface, or the interface delegated
 * by it, is marked as expensive.  The delegated interface is set/cleared 
 * along with the delegated ifp; we cache the flag for performance to avoid 
 * dereferencing delegated ifp each time.
 *
 * Note that this is meant to be used only for policy purposes.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFNET_IS_EXPENSIVE</span>(_ifp)					\
	((_ifp)-&gt;if_eflags &amp; IFEF_EXPENSIVE ||				\
	(_ifp)-&gt;if_delegated.expensive)

<span class="enscript-comment">/*
 * We don't support AWDL interface delegation.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFNET_IS_AWDL_RESTRICTED</span>(_ifp)					\
	(((_ifp)-&gt;if_eflags &amp; (IFEF_AWDL|IFEF_AWDL_RESTRICTED)) == 	\
	    (IFEF_AWDL|IFEF_AWDL_RESTRICTED))


<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifnethead ifnet_head;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifnet **ifindex2ifnet;
<span class="enscript-type">extern</span> u_int32_t if_sndq_maxlen;
<span class="enscript-type">extern</span> u_int32_t if_rcvq_maxlen;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> if_index;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifaddr **ifnet_addrs;
<span class="enscript-type">extern</span> lck_attr_t *ifa_mtx_attr;
<span class="enscript-type">extern</span> lck_grp_t *ifa_mtx_grp;
<span class="enscript-type">extern</span> lck_grp_t *ifnet_lock_group;
<span class="enscript-type">extern</span> lck_attr_t *ifnet_lock_attr;
<span class="enscript-type">extern</span> ifnet_t lo_ifp;
<span class="enscript-type">extern</span> uint32_t if_bw_measure_size;
<span class="enscript-type">extern</span> u_int32_t if_bw_smoothing_val;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_addmulti</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">struct</span> ifmultiaddr **);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_addmulti_anon</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">struct</span> ifmultiaddr **);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_allmulti</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_delmulti</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_delmulti_ifma</span>(<span class="enscript-type">struct</span> ifmultiaddr *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_delmulti_anon</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_down</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_down_all</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_up</span>(<span class="enscript-type">struct</span> ifnet *);
__private_extern__ <span class="enscript-type">void</span> if_updown(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> up);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifioctl</span>(<span class="enscript-type">struct</span> socket *, u_long, caddr_t, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifioctllocked</span>(<span class="enscript-type">struct</span> socket *, u_long, caddr_t, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifnet *<span class="enscript-function-name">ifunit</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifnet *<span class="enscript-function-name">if_withname</span>(<span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_qflush</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_qflush_sc</span>(<span class="enscript-type">struct</span> ifnet *, mbuf_svc_class_t, u_int32_t,
    u_int32_t *, u_int32_t *, <span class="enscript-type">int</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> if_clone *<span class="enscript-function-name">if_clone_lookup</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, u_int32_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_clone_attach</span>(<span class="enscript-type">struct</span> if_clone *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_clone_detach</span>(<span class="enscript-type">struct</span> if_clone *);

<span class="enscript-type">extern</span> u_int32_t <span class="enscript-function-name">if_functional_type</span>(<span class="enscript-type">struct</span> ifnet *);

<span class="enscript-type">extern</span> errno_t <span class="enscript-function-name">if_mcasts_update</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">extern</span> int32_t total_snd_byte_count;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	IFNET_LCK_ASSERT_EXCLUSIVE,	<span class="enscript-comment">/* RW: held as writer */</span>
	IFNET_LCK_ASSERT_SHARED,	<span class="enscript-comment">/* RW: held as reader */</span>
	IFNET_LCK_ASSERT_OWNED,		<span class="enscript-comment">/* RW: writer/reader, MTX: held */</span>
	IFNET_LCK_ASSERT_NOTOWNED	<span class="enscript-comment">/* not held */</span>
} ifnet_lock_assert_t;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IF_LLADDR</span>(_ifp)	\
	(LLADDR(SDL(((_ifp)-&gt;if_lladdr)-&gt;ifa_addr)))

__private_extern__ <span class="enscript-type">void</span> ifnet_lock_assert(<span class="enscript-type">struct</span> ifnet *, ifnet_lock_assert_t);
__private_extern__ <span class="enscript-type">void</span> ifnet_lock_shared(<span class="enscript-type">struct</span> ifnet *ifp);
__private_extern__ <span class="enscript-type">void</span> ifnet_lock_exclusive(<span class="enscript-type">struct</span> ifnet *ifp);
__private_extern__ <span class="enscript-type">void</span> ifnet_lock_done(<span class="enscript-type">struct</span> ifnet *ifp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
__private_extern__ <span class="enscript-type">void</span> if_inetdata_lock_shared(<span class="enscript-type">struct</span> ifnet *ifp);
__private_extern__ <span class="enscript-type">void</span> if_inetdata_lock_exclusive(<span class="enscript-type">struct</span> ifnet *ifp);
__private_extern__ <span class="enscript-type">void</span> if_inetdata_lock_done(<span class="enscript-type">struct</span> ifnet *ifp);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
__private_extern__ <span class="enscript-type">void</span> if_inet6data_lock_shared(<span class="enscript-type">struct</span> ifnet *ifp);
__private_extern__ <span class="enscript-type">void</span> if_inet6data_lock_exclusive(<span class="enscript-type">struct</span> ifnet *ifp);
__private_extern__ <span class="enscript-type">void</span> if_inet6data_lock_done(<span class="enscript-type">struct</span> ifnet *ifp);
#<span class="enscript-reference">endif</span>

__private_extern__ <span class="enscript-type">void</span>	ifnet_head_lock_shared(<span class="enscript-type">void</span>);
__private_extern__ <span class="enscript-type">void</span>	ifnet_head_lock_exclusive(<span class="enscript-type">void</span>);
__private_extern__ <span class="enscript-type">void</span>	ifnet_head_done(<span class="enscript-type">void</span>);

__private_extern__ errno_t ifnet_set_idle_flags_locked(ifnet_t, u_int32_t,
    u_int32_t);
__private_extern__ <span class="enscript-type">int</span> ifnet_is_attached(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span> refio);
__private_extern__ <span class="enscript-type">void</span> ifnet_decr_iorefcnt(<span class="enscript-type">struct</span> ifnet *);
__private_extern__ <span class="enscript-type">void</span> ifnet_set_start_cycle(<span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> timespec *);
__private_extern__ <span class="enscript-type">void</span> ifnet_set_poll_cycle(<span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> timespec *);

__private_extern__ <span class="enscript-type">void</span> if_attach_ifa(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> ifaddr *);
__private_extern__ <span class="enscript-type">void</span> if_attach_link_ifa(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> ifaddr *);
__private_extern__ <span class="enscript-type">void</span> if_detach_ifa(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> ifaddr *);
__private_extern__ <span class="enscript-type">void</span> if_detach_link_ifa(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> ifaddr *);

__private_extern__ <span class="enscript-type">void</span> dlil_if_lock(<span class="enscript-type">void</span>);
__private_extern__ <span class="enscript-type">void</span> dlil_if_unlock(<span class="enscript-type">void</span>);
__private_extern__ <span class="enscript-type">void</span> dlil_if_lock_assert(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">ifa_ifwithaddr</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">ifa_ifwithaddr_scoped</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">ifa_ifwithdstaddr</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">ifa_ifwithnet</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">ifa_ifwithnet_scoped</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">ifa_ifwithroute</span>(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span>	ifaddr *ifa_ifwithroute_locked(<span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">ifa_ifwithroute_scoped_locked</span>(<span class="enscript-type">int</span>,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">ifaof_ifpforaddr</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> ifnet *);
__private_extern__ <span class="enscript-type">struct</span> ifaddr *ifa_ifpgetprimary(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifa_addref</span>(<span class="enscript-type">struct</span> ifaddr *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">ifa_remref</span>(<span class="enscript-type">struct</span> ifaddr *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifa_lock_init</span>(<span class="enscript-type">struct</span> ifaddr *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifa_lock_destroy</span>(<span class="enscript-type">struct</span> ifaddr *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifma_addref</span>(<span class="enscript-type">struct</span> ifmultiaddr *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifma_remref</span>(<span class="enscript-type">struct</span> ifmultiaddr *);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifa_init</span>(<span class="enscript-type">void</span>);

__private_extern__ <span class="enscript-type">struct</span> in_ifaddr *ifa_foraddr(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span> in_ifaddr *ifa_foraddr_scoped(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);

<span class="enscript-type">struct</span> ifreq;
<span class="enscript-type">extern</span> errno_t <span class="enscript-function-name">ifnet_getset_opportunistic</span>(<span class="enscript-type">struct</span> ifnet *, u_long,
    <span class="enscript-type">struct</span> ifreq *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifnet_get_throttle</span>(<span class="enscript-type">struct</span> ifnet *, u_int32_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifnet_set_throttle</span>(<span class="enscript-type">struct</span> ifnet *, u_int32_t);
<span class="enscript-type">extern</span> errno_t <span class="enscript-function-name">ifnet_getset_log</span>(<span class="enscript-type">struct</span> ifnet *, u_long,
    <span class="enscript-type">struct</span> ifreq *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifnet_set_log</span>(<span class="enscript-type">struct</span> ifnet *, int32_t, uint32_t, int32_t, int32_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifnet_get_log</span>(<span class="enscript-type">struct</span> ifnet *, int32_t *, uint32_t *, int32_t *,
    int32_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifnet_notify_address</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">struct</span> in6_addr;
__private_extern__ <span class="enscript-type">struct</span> in6_ifaddr *ifa_foraddr6(<span class="enscript-type">struct</span> in6_addr *);
__private_extern__ <span class="enscript-type">struct</span> in6_ifaddr *ifa_foraddr6_scoped(<span class="enscript-type">struct</span> in6_addr *,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

__private_extern__ <span class="enscript-type">void</span> if_data_internal_to_if_data(<span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> if_data_internal *if_data_int, <span class="enscript-type">struct</span> if_data *if_data);
__private_extern__ <span class="enscript-type">void</span>	if_data_internal_to_if_data64(<span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> if_data_internal *if_data_int, <span class="enscript-type">struct</span> if_data64 *if_data64);
__private_extern__ <span class="enscript-type">void</span>	if_copy_traffic_class(<span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">struct</span> if_traffic_class *if_tc);
__private_extern__ <span class="enscript-type">void</span>	if_copy_data_extended(<span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">struct</span> if_data_extended *if_de);
__private_extern__ <span class="enscript-type">void</span> if_copy_packet_stats(<span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">struct</span> if_packet_stats *if_ps);
__private_extern__ <span class="enscript-type">void</span> if_copy_rxpoll_stats(<span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">struct</span> if_rxpoll_stats *if_rs);

__private_extern__ <span class="enscript-type">struct</span> rtentry *ifnet_cached_rtlookup_inet(<span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> in_addr);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
__private_extern__ <span class="enscript-type">struct</span> rtentry *ifnet_cached_rtlookup_inet6(<span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> in6_addr *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

__private_extern__ errno_t if_state_update(<span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> if_interface_state *);
__private_extern__ <span class="enscript-type">void</span> if_get_state(<span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> if_interface_state *);
__private_extern__ errno_t if_probe_connectivity(<span class="enscript-type">struct</span> ifnet *ifp,
    u_int32_t conn_probe);
__private_extern__ <span class="enscript-type">void</span> if_lqm_update(<span class="enscript-type">struct</span> ifnet *, int32_t, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">void</span> ifnet_update_sndq(<span class="enscript-type">struct</span> ifclassq *, cqev_t);
__private_extern__ <span class="enscript-type">void</span> ifnet_update_rcv(<span class="enscript-type">struct</span> ifnet *, cqev_t);

__private_extern__ <span class="enscript-type">void</span> ifnet_flowadv(uint32_t);

__private_extern__ errno_t ifnet_set_input_bandwidths(<span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> if_bandwidths *);
__private_extern__ errno_t ifnet_set_output_bandwidths(<span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> if_bandwidths *, boolean_t);
__private_extern__ u_int64_t ifnet_output_linkrate(<span class="enscript-type">struct</span> ifnet *);
__private_extern__ u_int64_t ifnet_input_linkrate(<span class="enscript-type">struct</span> ifnet *);

__private_extern__ errno_t ifnet_set_input_latencies(<span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> if_latencies *);
__private_extern__ errno_t ifnet_set_output_latencies(<span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> if_latencies *, boolean_t);

__private_extern__ <span class="enscript-type">void</span> ifnet_clear_netagent(uuid_t);

__private_extern__ <span class="enscript-type">int</span> ifnet_set_netsignature(<span class="enscript-type">struct</span> ifnet *, uint8_t,
    uint8_t, uint16_t, uint8_t *);
__private_extern__ <span class="enscript-type">int</span> ifnet_get_netsignature(<span class="enscript-type">struct</span> ifnet *, uint8_t,
    uint8_t *, uint16_t *, uint8_t *);

__private_extern__ errno_t ifnet_framer_stub(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf **,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, u_int32_t *,
    u_int32_t *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-comment">/* for uuid.c */</span>
__private_extern__ <span class="enscript-type">int</span> uuid_get_ethernet(u_int8_t *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_NET_IF_VAR_H_ */</span>
</pre>
<hr />
</body></html>