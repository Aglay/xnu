<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>rtsock.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">rtsock.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1988, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)rtsock.c	8.5 (Berkeley) 11/2/94
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/raw_cb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_arp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> rtstat rtstat;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> domain routedomain_s;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> domain *routedomain = NULL;

<span class="enscript-function-name">MALLOC_DEFINE</span>(M_RTABLE, <span class="enscript-string">&quot;routetbl&quot;</span>, <span class="enscript-string">&quot;routing tables&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr route_dst = { 2, PF_ROUTE, { 0, } };
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr route_src = { 2, PF_ROUTE, { 0, } };
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr sa_zero   = { <span class="enscript-keyword">sizeof</span> (sa_zero), AF_INET, { 0, } };

<span class="enscript-type">struct</span> route_cb {
	u_int32_t	ip_count;	<span class="enscript-comment">/* attached w/ AF_INET */</span>
	u_int32_t	ip6_count;	<span class="enscript-comment">/* attached w/ AF_INET6 */</span>
	u_int32_t	any_count;	<span class="enscript-comment">/* total attached */</span>
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> route_cb route_cb;

<span class="enscript-type">struct</span> walkarg {
	<span class="enscript-type">int</span>	w_tmemsize;
	<span class="enscript-type">int</span>	w_op, w_arg;
	caddr_t	w_tmem;
	<span class="enscript-type">struct</span> sysctl_req *w_req;
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">route_dinit</span>(<span class="enscript-type">struct</span> domain *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rts_abort</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rts_attach</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rts_bind</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rts_connect</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rts_detach</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rts_disconnect</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rts_peeraddr</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr **);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rts_send</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rts_shutdown</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rts_sockaddr</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr **);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">route_output</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rt_setmetrics</span>(u_int32_t, <span class="enscript-type">struct</span> rt_metrics *, <span class="enscript-type">struct</span> rtentry *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rt_getmetrics</span>(<span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> rt_metrics *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rt_setif</span>(<span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rt_xaddrs</span>(caddr_t, caddr_t, <span class="enscript-type">struct</span> rt_addrinfo *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">rt_msg1</span>(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rt_addrinfo *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rt_msg2</span>(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rt_addrinfo *, caddr_t, <span class="enscript-type">struct</span> walkarg *,
    kauth_cred_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_dumpentry</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">void</span> *vw);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_dumpentry_ext</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">void</span> *vw);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_iflist</span>(<span class="enscript-type">int</span> af, <span class="enscript-type">struct</span> walkarg *w);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_iflist2</span>(<span class="enscript-type">int</span> af, <span class="enscript-type">struct</span> walkarg *w);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_rtstat</span>(<span class="enscript-type">struct</span> sysctl_req *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_rttrash</span>(<span class="enscript-type">struct</span> sysctl_req *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_rtsock SYSCTL_HANDLER_ARGS;

<span class="enscript-function-name">SYSCTL_NODE</span>(_net, PF_ROUTE, routetable, CTLFLAG_RD | CTLFLAG_LOCKED,
	sysctl_rtsock, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_NODE</span>(_net, OID_AUTO, route, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;routing&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ROUNDUP32</span>(a)							\
	((a) &gt; 0 ? (1 + (((a) - 1) | (<span class="enscript-keyword">sizeof</span> (uint32_t) - 1))) :	\
	<span class="enscript-keyword">sizeof</span> (uint32_t))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ADVANCE32</span>(x, n)							\
	(x += ROUNDUP32((n)-&gt;sa_len))

<span class="enscript-comment">/*
 * It really doesn't make any sense at all for this code to share much
 * with raw_usrreq.c, since its functionality is so restricted.  XXX
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rts_abort</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">return</span> (raw_usrreqs.pru_abort(so));
}

<span class="enscript-comment">/* pru_accept is EOPNOTSUPP */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rts_attach</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> proto, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">struct</span> rawcb *rp;
	<span class="enscript-type">int</span> error;

	VERIFY(so-&gt;so_pcb == NULL);

	MALLOC(rp, <span class="enscript-type">struct</span> rawcb *, <span class="enscript-keyword">sizeof</span> (*rp), M_PCB, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (rp == NULL)
		<span class="enscript-keyword">return</span> (ENOBUFS);

	so-&gt;so_pcb = (caddr_t)rp;
	<span class="enscript-comment">/* don't use raw_usrreqs.pru_attach, it checks for SS_PRIV */</span>
	error = raw_attach(so, proto);
	rp = sotorawcb(so);
	<span class="enscript-keyword">if</span> (error) {
		FREE(rp, M_PCB);
		so-&gt;so_pcb = NULL;
		so-&gt;so_flags |= SOF_PCBCLEARING;
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">switch</span> (rp-&gt;rcb_proto.sp_protocol) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		atomic_add_32(&amp;route_cb.ip_count, 1);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		atomic_add_32(&amp;route_cb.ip6_count, 1);
		<span class="enscript-keyword">break</span>;
	}
	rp-&gt;rcb_faddr = &amp;route_src;
	atomic_add_32(&amp;route_cb.any_count, 1);
	<span class="enscript-comment">/* the socket is already locked when we enter rts_attach */</span>
	soisconnected(so);
	so-&gt;so_options |= SO_USELOOPBACK;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rts_bind</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-keyword">return</span> (raw_usrreqs.pru_bind(so, nam, p)); <span class="enscript-comment">/* xxx just EINVAL */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rts_connect</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-keyword">return</span> (raw_usrreqs.pru_connect(so, nam, p)); <span class="enscript-comment">/* XXX just EINVAL */</span>
}

<span class="enscript-comment">/* pru_connect2 is EOPNOTSUPP */</span>
<span class="enscript-comment">/* pru_control is EOPNOTSUPP */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rts_detach</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> rawcb *rp = sotorawcb(so);

	VERIFY(rp != NULL);

	<span class="enscript-keyword">switch</span> (rp-&gt;rcb_proto.sp_protocol) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		atomic_add_32(&amp;route_cb.ip_count, -1);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		atomic_add_32(&amp;route_cb.ip6_count, -1);
		<span class="enscript-keyword">break</span>;
	}
	atomic_add_32(&amp;route_cb.any_count, -1);
	<span class="enscript-keyword">return</span> (raw_usrreqs.pru_detach(so));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rts_disconnect</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">return</span> (raw_usrreqs.pru_disconnect(so));
}

<span class="enscript-comment">/* pru_listen is EOPNOTSUPP */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rts_peeraddr</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-keyword">return</span> (raw_usrreqs.pru_peeraddr(so, nam));
}

<span class="enscript-comment">/* pru_rcvd is EOPNOTSUPP */</span>
<span class="enscript-comment">/* pru_rcvoob is EOPNOTSUPP */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rts_send</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> sockaddr *nam,
    <span class="enscript-type">struct</span> mbuf *control, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-keyword">return</span> (raw_usrreqs.pru_send(so, flags, m, nam, control, p));
}

<span class="enscript-comment">/* pru_sense is null */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rts_shutdown</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">return</span> (raw_usrreqs.pru_shutdown(so));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rts_sockaddr</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-keyword">return</span> (raw_usrreqs.pru_sockaddr(so, nam));
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pr_usrreqs route_usrreqs = {
	.pru_abort =		rts_abort,
	.pru_attach =		rts_attach,
	.pru_bind =		rts_bind,
	.pru_connect =		rts_connect,
	.pru_detach =		rts_detach,
	.pru_disconnect =	rts_disconnect,
	.pru_peeraddr =		rts_peeraddr,
	.pru_send =		rts_send,
	.pru_shutdown =		rts_shutdown,
	.pru_sockaddr =		rts_sockaddr,
	.pru_sosend =		sosend,
	.pru_soreceive =	soreceive,
};

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">route_output</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> rt_msghdr *rtm = NULL;
	<span class="enscript-type">struct</span> rtentry *rt = NULL;
	<span class="enscript-type">struct</span> rtentry *saved_nrt = NULL;
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	<span class="enscript-type">struct</span> rt_addrinfo info;
	<span class="enscript-type">int</span> len, error = 0;
	sa_family_t dst_sa_family = 0;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	<span class="enscript-type">struct</span> sockaddr_in dst_in, gate_in;
	<span class="enscript-type">int</span> sendonlytoself = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope = IFSCOPE_NONE;
	<span class="enscript-type">struct</span> rawcb *rp = NULL;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">senderr</span>(e) { error = (e); goto flush; }
	<span class="enscript-keyword">if</span> (m == NULL || ((m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span> (intptr_t)) &amp;&amp;
	    (m = m_pullup(m, <span class="enscript-keyword">sizeof</span> (intptr_t))) == NULL))
		<span class="enscript-keyword">return</span> (ENOBUFS);
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-comment">/*
	 * Unlock the socket (but keep a reference) it won't be
	 * accessed until raw_input appends to it.
	 */</span>
	socket_unlock(so, 0);
	lck_mtx_lock(rnh_lock);

	len = m-&gt;m_pkthdr.len;
	<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span> (*rtm) ||
	    len != mtod(m, <span class="enscript-type">struct</span> rt_msghdr *)-&gt;rtm_msglen) {
		info.rti_info[RTAX_DST] = NULL;
		senderr(EINVAL);
	}
	R_Malloc(rtm, <span class="enscript-type">struct</span> rt_msghdr *, len);
	<span class="enscript-keyword">if</span> (rtm == NULL) {
		info.rti_info[RTAX_DST] = NULL;
		senderr(ENOBUFS);
	}
	m_copydata(m, 0, len, (caddr_t)rtm);
	<span class="enscript-keyword">if</span> (rtm-&gt;rtm_version != RTM_VERSION) {
		info.rti_info[RTAX_DST] = NULL;
		senderr(EPROTONOSUPPORT);
	}

	<span class="enscript-comment">/*
	 * Silent version of RTM_GET for Reachabiltiy APIs. We may change
	 * all RTM_GETs to be silent in the future, so this is private for now.
	 */</span>
	<span class="enscript-keyword">if</span> (rtm-&gt;rtm_type == RTM_GET_SILENT) {
		<span class="enscript-keyword">if</span> (!(so-&gt;so_options &amp; SO_USELOOPBACK))
			senderr(EINVAL);
		sendonlytoself = 1;
		rtm-&gt;rtm_type = RTM_GET;
	}

	<span class="enscript-comment">/*
	 * Perform permission checking, only privileged sockets
	 * may perform operations other than RTM_GET
	 */</span>
	<span class="enscript-keyword">if</span> (rtm-&gt;rtm_type != RTM_GET &amp;&amp; !(so-&gt;so_state &amp; SS_PRIV)) {
		info.rti_info[RTAX_DST] = NULL;
		senderr(EPERM);
	}

	rtm-&gt;rtm_pid = proc_selfpid();
	info.rti_addrs = rtm-&gt;rtm_addrs;
	<span class="enscript-keyword">if</span> (rt_xaddrs((caddr_t)(rtm + 1), len + (caddr_t)rtm, &amp;info)) {
		info.rti_info[RTAX_DST] = NULL;
		senderr(EINVAL);
	}
	<span class="enscript-keyword">if</span> (info.rti_info[RTAX_DST] == NULL ||
	    info.rti_info[RTAX_DST]-&gt;sa_family &gt;= AF_MAX ||
	    (info.rti_info[RTAX_GATEWAY] != NULL &amp;&amp;
	    info.rti_info[RTAX_GATEWAY]-&gt;sa_family &gt;= AF_MAX))
		senderr(EINVAL);

	<span class="enscript-keyword">if</span> (info.rti_info[RTAX_DST]-&gt;sa_family == AF_INET &amp;&amp;
	    info.rti_info[RTAX_DST]-&gt;sa_len != <span class="enscript-keyword">sizeof</span> (dst_in)) {
		<span class="enscript-comment">/* At minimum, we need up to sin_addr */</span>
		<span class="enscript-keyword">if</span> (info.rti_info[RTAX_DST]-&gt;sa_len &lt;
		    offsetof(<span class="enscript-type">struct</span> sockaddr_in, sin_zero))
			senderr(EINVAL);
		bzero(&amp;dst_in, <span class="enscript-keyword">sizeof</span> (dst_in));
		dst_in.sin_len = <span class="enscript-keyword">sizeof</span> (dst_in);
		dst_in.sin_family = AF_INET;
		dst_in.sin_port = SIN(info.rti_info[RTAX_DST])-&gt;sin_port;
		dst_in.sin_addr = SIN(info.rti_info[RTAX_DST])-&gt;sin_addr;
		info.rti_info[RTAX_DST] = (<span class="enscript-type">struct</span> sockaddr *)&amp;dst_in;
		dst_sa_family = info.rti_info[RTAX_DST]-&gt;sa_family;
	}

	<span class="enscript-keyword">if</span> (info.rti_info[RTAX_GATEWAY] != NULL &amp;&amp;
	    info.rti_info[RTAX_GATEWAY]-&gt;sa_family == AF_INET &amp;&amp;
	    info.rti_info[RTAX_GATEWAY]-&gt;sa_len != <span class="enscript-keyword">sizeof</span> (gate_in)) {
		<span class="enscript-comment">/* At minimum, we need up to sin_addr */</span>
		<span class="enscript-keyword">if</span> (info.rti_info[RTAX_GATEWAY]-&gt;sa_len &lt;
		    offsetof(<span class="enscript-type">struct</span> sockaddr_in, sin_zero))
			senderr(EINVAL);
		bzero(&amp;gate_in, <span class="enscript-keyword">sizeof</span> (gate_in));
		gate_in.sin_len = <span class="enscript-keyword">sizeof</span> (gate_in);
		gate_in.sin_family = AF_INET;
		gate_in.sin_port = SIN(info.rti_info[RTAX_GATEWAY])-&gt;sin_port;
		gate_in.sin_addr = SIN(info.rti_info[RTAX_GATEWAY])-&gt;sin_addr;
		info.rti_info[RTAX_GATEWAY] = (<span class="enscript-type">struct</span> sockaddr *)&amp;gate_in;
	}

	<span class="enscript-keyword">if</span> (info.rti_info[RTAX_GENMASK]) {
		<span class="enscript-type">struct</span> radix_node *t;
		t = rn_addmask((caddr_t)info.rti_info[RTAX_GENMASK], 0, 1);
		<span class="enscript-keyword">if</span> (t != NULL &amp;&amp; Bcmp(info.rti_info[RTAX_GENMASK],
		    t-&gt;rn_key, *(u_char *)info.rti_info[RTAX_GENMASK]) == 0)
			info.rti_info[RTAX_GENMASK] =
			    (<span class="enscript-type">struct</span> sockaddr *)(t-&gt;rn_key);
		<span class="enscript-keyword">else</span>
			senderr(ENOBUFS);
	}

	<span class="enscript-comment">/*
	 * If RTF_IFSCOPE flag is set, then rtm_index specifies the scope.
	 */</span>
	<span class="enscript-keyword">if</span> (rtm-&gt;rtm_flags &amp; RTF_IFSCOPE) {
		<span class="enscript-keyword">if</span> (info.rti_info[RTAX_DST]-&gt;sa_family != AF_INET &amp;&amp;
		    info.rti_info[RTAX_DST]-&gt;sa_family != AF_INET6)
			senderr(EINVAL);
		ifscope = rtm-&gt;rtm_index;
	}

	<span class="enscript-comment">/*
	 * RTF_PROXY can only be set internally from within the kernel.
	 */</span>
	<span class="enscript-keyword">if</span> (rtm-&gt;rtm_flags &amp; RTF_PROXY)
		senderr(EINVAL);

	<span class="enscript-comment">/*
	 * For AF_INET, always zero out the embedded scope ID.  If this is
	 * a scoped request, it must be done explicitly by setting RTF_IFSCOPE
	 * flag and the corresponding rtm_index value.  This is to prevent
	 * false interpretation of the scope ID because it's using the sin_zero
	 * field, which might not be properly cleared by the requestor.
	 */</span>
	<span class="enscript-keyword">if</span> (info.rti_info[RTAX_DST]-&gt;sa_family == AF_INET)
		sin_set_ifscope(info.rti_info[RTAX_DST], IFSCOPE_NONE);
	<span class="enscript-keyword">if</span> (info.rti_info[RTAX_GATEWAY] != NULL &amp;&amp;
	    info.rti_info[RTAX_GATEWAY]-&gt;sa_family == AF_INET)
		sin_set_ifscope(info.rti_info[RTAX_GATEWAY], IFSCOPE_NONE);

	<span class="enscript-keyword">switch</span> (rtm-&gt;rtm_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_ADD</span>:
		<span class="enscript-keyword">if</span> (info.rti_info[RTAX_GATEWAY] == NULL)
			senderr(EINVAL);

		error = rtrequest_scoped_locked(RTM_ADD,
		    info.rti_info[RTAX_DST], info.rti_info[RTAX_GATEWAY],
		    info.rti_info[RTAX_NETMASK], rtm-&gt;rtm_flags, &amp;saved_nrt,
		    ifscope);
		<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; saved_nrt != NULL) {
			RT_LOCK(saved_nrt);
			<span class="enscript-comment">/*
			 * If the route request specified an interface with
			 * IFA and/or IFP, we set the requested interface on
			 * the route with rt_setif.  It would be much better
			 * to do this inside rtrequest, but that would
			 * require passing the desired interface, in some
			 * form, to rtrequest.  Since rtrequest is called in
			 * so many places (roughly 40 in our source), adding
			 * a parameter is to much for us to swallow; this is
			 * something for the FreeBSD developers to tackle.
			 * Instead, we let rtrequest compute whatever
			 * interface it wants, then come in behind it and
			 * stick in the interface that we really want.  This
			 * works reasonably well except when rtrequest can't
			 * figure out what interface to use (with
			 * ifa_withroute) and returns ENETUNREACH.  Ideally
			 * it shouldn't matter if rtrequest can't figure out
			 * the interface if we're going to explicitly set it
			 * ourselves anyway.  But practically we can't
			 * recover here because rtrequest will not do any of
			 * the work necessary to add the route if it can't
			 * find an interface.  As long as there is a default
			 * route that leads to some interface, rtrequest will
			 * find an interface, so this problem should be
			 * rarely encountered.
			 * <a href="mailto:dwiggins@bbn.com">dwiggins@bbn.com</a>
			 */</span>
			rt_setif(saved_nrt,
			    info.rti_info[RTAX_IFP], info.rti_info[RTAX_IFA],
			    info.rti_info[RTAX_GATEWAY], ifscope);
			(<span class="enscript-type">void</span>)rt_setmetrics(rtm-&gt;rtm_inits, &amp;rtm-&gt;rtm_rmx, saved_nrt);
			saved_nrt-&gt;rt_rmx.rmx_locks &amp;= ~(rtm-&gt;rtm_inits);
			saved_nrt-&gt;rt_rmx.rmx_locks |=
			    (rtm-&gt;rtm_inits &amp; rtm-&gt;rtm_rmx.rmx_locks);
			saved_nrt-&gt;rt_genmask = info.rti_info[RTAX_GENMASK];
			RT_REMREF_LOCKED(saved_nrt);
			RT_UNLOCK(saved_nrt);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_DELETE</span>:
		error = rtrequest_scoped_locked(RTM_DELETE,
		    info.rti_info[RTAX_DST], info.rti_info[RTAX_GATEWAY],
		    info.rti_info[RTAX_NETMASK], rtm-&gt;rtm_flags, &amp;saved_nrt,
		    ifscope);
		<span class="enscript-keyword">if</span> (error == 0) {
			rt = saved_nrt;
			RT_LOCK(rt);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">report</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_GET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_CHANGE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_LOCK</span>:
		rnh = rt_tables[info.rti_info[RTAX_DST]-&gt;sa_family];
		<span class="enscript-keyword">if</span> (rnh == NULL)
			senderr(EAFNOSUPPORT);
		<span class="enscript-comment">/*
		 * Lookup the best match based on the key-mask pair;
		 * callee adds a reference and checks for root node.
		 */</span>
		rt = rt_lookup(TRUE, info.rti_info[RTAX_DST],
		    info.rti_info[RTAX_NETMASK], rnh, ifscope);
		<span class="enscript-keyword">if</span> (rt == NULL)
			senderr(ESRCH);
		RT_LOCK(rt);

		<span class="enscript-comment">/*
		 * Holding rnh_lock here prevents the possibility of
		 * ifa from changing (e.g. in_ifinit), so it is safe
		 * to access its ifa_addr (down below) without locking.
		 */</span>
		<span class="enscript-keyword">switch</span> (rtm-&gt;rtm_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_GET</span>: {
			<span class="enscript-type">struct</span> ifaddr *ifa2;
<span class="enscript-reference">report</span>:
			ifa2 = NULL;
			RT_LOCK_ASSERT_HELD(rt);
			info.rti_info[RTAX_DST] = rt_key(rt);
			dst_sa_family = info.rti_info[RTAX_DST]-&gt;sa_family;
			info.rti_info[RTAX_GATEWAY] = rt-&gt;rt_gateway;
			info.rti_info[RTAX_NETMASK] = rt_mask(rt);
			info.rti_info[RTAX_GENMASK] = rt-&gt;rt_genmask;
			<span class="enscript-keyword">if</span> (rtm-&gt;rtm_addrs &amp; (RTA_IFP | RTA_IFA)) {
				ifp = rt-&gt;rt_ifp;
				<span class="enscript-keyword">if</span> (ifp != NULL) {
					ifnet_lock_shared(ifp);
					ifa2 = ifp-&gt;if_lladdr;
					info.rti_info[RTAX_IFP] =
					    ifa2-&gt;ifa_addr;
					IFA_ADDREF(ifa2);
					ifnet_lock_done(ifp);
					info.rti_info[RTAX_IFA] =
					    rt-&gt;rt_ifa-&gt;ifa_addr;
					rtm-&gt;rtm_index = ifp-&gt;if_index;
				} <span class="enscript-keyword">else</span> {
					info.rti_info[RTAX_IFP] = NULL;
					info.rti_info[RTAX_IFA] = NULL;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ifp = rt-&gt;rt_ifp) != NULL) {
				rtm-&gt;rtm_index = ifp-&gt;if_index;
			}
			<span class="enscript-keyword">if</span> (ifa2 != NULL)
				IFA_LOCK(ifa2);
			len = rt_msg2(rtm-&gt;rtm_type, &amp;info, NULL, NULL, NULL);
			<span class="enscript-keyword">if</span> (ifa2 != NULL)
				IFA_UNLOCK(ifa2);
			<span class="enscript-keyword">if</span> (len &gt; rtm-&gt;rtm_msglen) {
				<span class="enscript-type">struct</span> rt_msghdr *new_rtm;
				R_Malloc(new_rtm, <span class="enscript-type">struct</span> rt_msghdr *, len);
				<span class="enscript-keyword">if</span> (new_rtm == NULL) {
					RT_UNLOCK(rt);
					<span class="enscript-keyword">if</span> (ifa2 != NULL)
						IFA_REMREF(ifa2);
					senderr(ENOBUFS);
				}
				Bcopy(rtm, new_rtm, rtm-&gt;rtm_msglen);
				R_Free(rtm); rtm = new_rtm;
			}
			<span class="enscript-keyword">if</span> (ifa2 != NULL)
				IFA_LOCK(ifa2);
			(<span class="enscript-type">void</span>) rt_msg2(rtm-&gt;rtm_type, &amp;info, (caddr_t)rtm,
			    NULL, NULL);
			<span class="enscript-keyword">if</span> (ifa2 != NULL)
				IFA_UNLOCK(ifa2);
			rtm-&gt;rtm_flags = rt-&gt;rt_flags;
			rt_getmetrics(rt, &amp;rtm-&gt;rtm_rmx);
			rtm-&gt;rtm_addrs = info.rti_addrs;
			<span class="enscript-keyword">if</span> (ifa2 != NULL)
				IFA_REMREF(ifa2);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_CHANGE</span>:
			<span class="enscript-keyword">if</span> (info.rti_info[RTAX_GATEWAY] != NULL &amp;&amp;
			    (error = rt_setgate(rt, rt_key(rt),
			    info.rti_info[RTAX_GATEWAY]))) {
				<span class="enscript-type">int</span> tmp = error;
				RT_UNLOCK(rt);
				senderr(tmp);
			}
			<span class="enscript-comment">/*
			 * If they tried to change things but didn't specify
			 * the required gateway, then just use the old one.
			 * This can happen if the user tries to change the
			 * flags on the default route without changing the
			 * default gateway.  Changing flags still doesn't work.
			 */</span>
			<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_GATEWAY) &amp;&amp;
			    info.rti_info[RTAX_GATEWAY] == NULL)
				info.rti_info[RTAX_GATEWAY] = rt-&gt;rt_gateway;

			<span class="enscript-comment">/*
			 * On Darwin, we call rt_setif which contains the
			 * equivalent to the code found at this very spot
			 * in BSD.
			 */</span>
			rt_setif(rt,
			    info.rti_info[RTAX_IFP], info.rti_info[RTAX_IFA],
			    info.rti_info[RTAX_GATEWAY], ifscope);

			<span class="enscript-keyword">if</span> ((error = rt_setmetrics(rtm-&gt;rtm_inits,
			    &amp;rtm-&gt;rtm_rmx, rt))) {
				 <span class="enscript-type">int</span> tmp = error;
				 RT_UNLOCK(rt);
				 senderr(tmp);
			}
			<span class="enscript-keyword">if</span> (info.rti_info[RTAX_GENMASK])
				rt-&gt;rt_genmask = info.rti_info[RTAX_GENMASK];
			<span class="enscript-comment">/* FALLTHRU */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_LOCK</span>:
			rt-&gt;rt_rmx.rmx_locks &amp;= ~(rtm-&gt;rtm_inits);
			rt-&gt;rt_rmx.rmx_locks |=
			    (rtm-&gt;rtm_inits &amp; rtm-&gt;rtm_rmx.rmx_locks);
			<span class="enscript-keyword">break</span>;
		}
		RT_UNLOCK(rt);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		senderr(EOPNOTSUPP);
	}
<span class="enscript-reference">flush</span>:
	<span class="enscript-keyword">if</span> (rtm != NULL) {
		<span class="enscript-keyword">if</span> (error)
			rtm-&gt;rtm_errno = error;
		<span class="enscript-keyword">else</span>
			rtm-&gt;rtm_flags |= RTF_DONE;
	}
	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK_ASSERT_NOTHELD(rt);
		rtfree_locked(rt);
	}
	lck_mtx_unlock(rnh_lock);

	<span class="enscript-comment">/* relock the socket now */</span>
	socket_lock(so, 0);
	<span class="enscript-comment">/*
	 * Check to see if we don't want our own messages.
	 */</span>
	<span class="enscript-keyword">if</span> (!(so-&gt;so_options &amp; SO_USELOOPBACK)) {
		<span class="enscript-keyword">if</span> (route_cb.any_count &lt;= 1) {
			<span class="enscript-keyword">if</span> (rtm != NULL)
				R_Free(rtm);
			m_freem(m);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-comment">/* There is another listener, so construct message */</span>
		rp = sotorawcb(so);
	}
	<span class="enscript-keyword">if</span> (rtm != NULL) {
		m_copyback(m, 0, rtm-&gt;rtm_msglen, (caddr_t)rtm);
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; rtm-&gt;rtm_msglen) {
			m_freem(m);
			m = NULL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &gt; rtm-&gt;rtm_msglen) {
			m_adj(m, rtm-&gt;rtm_msglen - m-&gt;m_pkthdr.len);
		}
		R_Free(rtm);
	}
	<span class="enscript-keyword">if</span> (sendonlytoself &amp;&amp; m != NULL) {
		error = 0;
		<span class="enscript-keyword">if</span> (sbappendaddr(&amp;so-&gt;so_rcv, &amp;route_src, m,
		    NULL, &amp;error) != 0) {
			sorwakeup(so);
		}
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> sockproto route_proto = { PF_ROUTE, 0 };
		<span class="enscript-keyword">if</span> (rp != NULL)
			rp-&gt;rcb_proto.sp_family = 0; <span class="enscript-comment">/* Avoid us */</span>
		<span class="enscript-keyword">if</span> (dst_sa_family != 0)
			route_proto.sp_protocol = dst_sa_family;
		<span class="enscript-keyword">if</span> (m != NULL) {
			socket_unlock(so, 0);
			raw_input(m, &amp;route_proto, &amp;route_src, &amp;route_dst);
			socket_lock(so, 0);
		}
		<span class="enscript-keyword">if</span> (rp != NULL)
			rp-&gt;rcb_proto.sp_family = PF_ROUTE;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rt_setexpire</span>(<span class="enscript-type">struct</span> rtentry *rt, uint64_t expiry)
{
	<span class="enscript-comment">/* set both rt_expire and rmx_expire */</span>
	rt-&gt;rt_expire = expiry;
	<span class="enscript-keyword">if</span> (expiry) {
		rt-&gt;rt_rmx.rmx_expire = expiry + rt-&gt;base_calendartime -
		    rt-&gt;base_uptime;
	} <span class="enscript-keyword">else</span> {
		rt-&gt;rt_rmx.rmx_expire = 0;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rt_setmetrics</span>(u_int32_t which, <span class="enscript-type">struct</span> rt_metrics *in, <span class="enscript-type">struct</span> rtentry *out)
{
	<span class="enscript-keyword">if</span> (!(which &amp; RTV_REFRESH_HOST)) {
		<span class="enscript-type">struct</span> timeval caltime;
		getmicrotime(&amp;caltime);
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">metric</span>(f, e) if (which &amp; (f)) out-&gt;rt_rmx.e = in-&gt;e;
		metric(RTV_RPIPE, rmx_recvpipe);
		metric(RTV_SPIPE, rmx_sendpipe);
		metric(RTV_SSTHRESH, rmx_ssthresh);
		metric(RTV_RTT, rmx_rtt);
		metric(RTV_RTTVAR, rmx_rttvar);
		metric(RTV_HOPCOUNT, rmx_hopcount);
		metric(RTV_MTU, rmx_mtu);
		metric(RTV_EXPIRE, rmx_expire);
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">metric</span>
		<span class="enscript-keyword">if</span> (out-&gt;rt_rmx.rmx_expire &gt; 0) {
			<span class="enscript-comment">/* account for system time change */</span>
			getmicrotime(&amp;caltime);
			out-&gt;base_calendartime +=
				NET_CALCULATE_CLOCKSKEW(caltime,
						out-&gt;base_calendartime,
						net_uptime(), out-&gt;base_uptime);
			rt_setexpire(out,
					out-&gt;rt_rmx.rmx_expire -
					out-&gt;base_calendartime +
					out-&gt;base_uptime);
		} <span class="enscript-keyword">else</span> {
			rt_setexpire(out, 0);
		}

		VERIFY(out-&gt;rt_expire == 0 || out-&gt;rt_rmx.rmx_expire != 0);
		VERIFY(out-&gt;rt_expire != 0 || out-&gt;rt_rmx.rmx_expire == 0);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Only RTV_REFRESH_HOST must be set */</span>
		<span class="enscript-keyword">if</span> ((which &amp; ~RTV_REFRESH_HOST) ||
		    (out-&gt;rt_flags &amp; RTF_STATIC) ||
		    !(out-&gt;rt_flags &amp; RTF_LLINFO)) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-keyword">if</span> (out-&gt;rt_llinfo_refresh == NULL) {
			<span class="enscript-keyword">return</span> (ENOTSUP);
		}

		out-&gt;rt_llinfo_refresh(out);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rt_getmetrics</span>(<span class="enscript-type">struct</span> rtentry *in, <span class="enscript-type">struct</span> rt_metrics *out)
{
	<span class="enscript-type">struct</span> timeval caltime;

	VERIFY(in-&gt;rt_expire == 0 || in-&gt;rt_rmx.rmx_expire != 0);
	VERIFY(in-&gt;rt_expire != 0 || in-&gt;rt_rmx.rmx_expire == 0);

	*out = in-&gt;rt_rmx;

	<span class="enscript-keyword">if</span> (in-&gt;rt_expire != 0) {
		<span class="enscript-comment">/* account for system time change */</span>
		getmicrotime(&amp;caltime);

		in-&gt;base_calendartime +=
		    NET_CALCULATE_CLOCKSKEW(caltime,
		    in-&gt;base_calendartime, net_uptime(), in-&gt;base_uptime);

		out-&gt;rmx_expire = in-&gt;base_calendartime +
		    in-&gt;rt_expire - in-&gt;base_uptime;
	} <span class="enscript-keyword">else</span> {
		out-&gt;rmx_expire = 0;
	}
}

<span class="enscript-comment">/*
 * Set route's interface given info.rti_info[RTAX_IFP],
 * info.rti_info[RTAX_IFA], and gateway.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rt_setif</span>(<span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> sockaddr *Ifpaddr, <span class="enscript-type">struct</span> sockaddr *Ifaaddr,
    <span class="enscript-type">struct</span> sockaddr *Gate, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">struct</span> ifaddr *ifa = NULL;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	<span class="enscript-type">void</span> (*ifa_rtrequest)(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> sockaddr *);

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-comment">/* Don't update a defunct route */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_CONDEMNED)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Add an extra ref for ourselves */</span>
	RT_ADDREF_LOCKED(rt);

	<span class="enscript-comment">/* Become a regular mutex, just in case */</span>
	RT_CONVERT_LOCK(rt);

	<span class="enscript-comment">/*
	 * New gateway could require new ifaddr, ifp; flags may also
	 * be different; ifp may be specified by ll sockaddr when
	 * protocol address is ambiguous.
	 */</span>
	<span class="enscript-keyword">if</span> (Ifpaddr &amp;&amp; (ifa = ifa_ifwithnet_scoped(Ifpaddr, ifscope)) &amp;&amp;
	    (ifp = ifa-&gt;ifa_ifp) &amp;&amp; (Ifaaddr || Gate)) {
		IFA_REMREF(ifa);
		ifa = ifaof_ifpforaddr(Ifaaddr ? Ifaaddr : Gate, ifp);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (ifa != NULL) {
			IFA_REMREF(ifa);
			ifa = NULL;
		}
		<span class="enscript-keyword">if</span> (Ifpaddr &amp;&amp; (ifp = if_withname(Ifpaddr))) {
			<span class="enscript-keyword">if</span> (Gate) {
				ifa = ifaof_ifpforaddr(Gate, ifp);
			} <span class="enscript-keyword">else</span> {
				ifnet_lock_shared(ifp);
				ifa = TAILQ_FIRST(&amp;ifp-&gt;if_addrhead);
				<span class="enscript-keyword">if</span> (ifa != NULL)
					IFA_ADDREF(ifa);
				ifnet_lock_done(ifp);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (Ifaaddr &amp;&amp;
		    (ifa = ifa_ifwithaddr_scoped(Ifaaddr, ifscope))) {
			ifp = ifa-&gt;ifa_ifp;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (Gate != NULL) {
			<span class="enscript-comment">/*
			 * Safe to drop rt_lock and use rt_key, since holding
			 * rnh_lock here prevents another thread from calling
			 * rt_setgate() on this route.  We cannot hold the
			 * lock across ifa_ifwithroute since the lookup done
			 * by that routine may point to the same route.
			 */</span>
			RT_UNLOCK(rt);
			<span class="enscript-keyword">if</span> ((ifa = ifa_ifwithroute_scoped_locked(rt-&gt;rt_flags,
			    rt_key(rt), Gate, ifscope)) != NULL)
				ifp = ifa-&gt;ifa_ifp;
			RT_LOCK(rt);
			<span class="enscript-comment">/* Don't update a defunct route */</span>
			<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_CONDEMNED) {
				<span class="enscript-keyword">if</span> (ifa != NULL)
					IFA_REMREF(ifa);
				<span class="enscript-comment">/* Release extra ref */</span>
				RT_REMREF_LOCKED(rt);
				<span class="enscript-keyword">return</span>;
			}
		}
	}

	<span class="enscript-comment">/* trigger route cache reevaluation */</span>
	<span class="enscript-keyword">if</span> (rt_key(rt)-&gt;sa_family == AF_INET)
		routegenid_inet_update();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rt_key(rt)-&gt;sa_family == AF_INET6)
		routegenid_inet6_update();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	<span class="enscript-keyword">if</span> (ifa != NULL) {
		<span class="enscript-type">struct</span> ifaddr *oifa = rt-&gt;rt_ifa;
		<span class="enscript-keyword">if</span> (oifa != ifa) {
			<span class="enscript-keyword">if</span> (oifa != NULL) {
				IFA_LOCK_SPIN(oifa);
				ifa_rtrequest = oifa-&gt;ifa_rtrequest;
				IFA_UNLOCK(oifa);
				<span class="enscript-keyword">if</span> (ifa_rtrequest != NULL)
					ifa_rtrequest(RTM_DELETE, rt, Gate);
			}
			rtsetifa(rt, ifa);

			<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp != ifp) {
				<span class="enscript-comment">/*
				 * Purge any link-layer info caching.
				 */</span>
				<span class="enscript-keyword">if</span> (rt-&gt;rt_llinfo_purge != NULL)
					rt-&gt;rt_llinfo_purge(rt);

				<span class="enscript-comment">/*
				 * Adjust route ref count for the interfaces.
				 */</span>
				<span class="enscript-keyword">if</span> (rt-&gt;rt_if_ref_fn != NULL) {
					rt-&gt;rt_if_ref_fn(ifp, 1);
					rt-&gt;rt_if_ref_fn(rt-&gt;rt_ifp, -1);
				}
			}
			rt-&gt;rt_ifp = ifp;
			<span class="enscript-comment">/*
			 * If this is the (non-scoped) default route, record
			 * the interface index used for the primary ifscope.
			 */</span>
			<span class="enscript-keyword">if</span> (rt_primary_default(rt, rt_key(rt))) {
				set_primary_ifscope(rt_key(rt)-&gt;sa_family,
				    rt-&gt;rt_ifp-&gt;if_index);
			}
			<span class="enscript-comment">/*
			 * If rmx_mtu is not locked, update it
			 * to the MTU used by the new interface.
			 */</span>
			<span class="enscript-keyword">if</span> (!(rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU))
				rt-&gt;rt_rmx.rmx_mtu = rt-&gt;rt_ifp-&gt;if_mtu;

			<span class="enscript-keyword">if</span> (rt-&gt;rt_ifa != NULL) {
				IFA_LOCK_SPIN(rt-&gt;rt_ifa);
				ifa_rtrequest = rt-&gt;rt_ifa-&gt;ifa_rtrequest;
				IFA_UNLOCK(rt-&gt;rt_ifa);
				<span class="enscript-keyword">if</span> (ifa_rtrequest != NULL)
					ifa_rtrequest(RTM_ADD, rt, Gate);
			}
			IFA_REMREF(ifa);
			<span class="enscript-comment">/* Release extra ref */</span>
			RT_REMREF_LOCKED(rt);
			<span class="enscript-keyword">return</span>;
		}
		IFA_REMREF(ifa);
		ifa = NULL;
	}

	<span class="enscript-comment">/* XXX: to reset gateway to correct value, at RTM_CHANGE */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_ifa != NULL) {
		IFA_LOCK_SPIN(rt-&gt;rt_ifa);
		ifa_rtrequest = rt-&gt;rt_ifa-&gt;ifa_rtrequest;
		IFA_UNLOCK(rt-&gt;rt_ifa);
		<span class="enscript-keyword">if</span> (ifa_rtrequest != NULL)
			ifa_rtrequest(RTM_ADD, rt, Gate);
	}

	<span class="enscript-comment">/*
	 * Workaround for local address routes pointing to the loopback
	 * interface added by configd, until &lt;rdar://problem/12970142&gt;.
	 */</span>
	<span class="enscript-keyword">if</span> ((rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
	    (rt-&gt;rt_flags &amp; RTF_HOST) &amp;&amp; rt-&gt;rt_ifa-&gt;ifa_ifp == rt-&gt;rt_ifp) {
		ifa = ifa_ifwithaddr(rt_key(rt));
		<span class="enscript-keyword">if</span> (ifa != NULL) {
			<span class="enscript-keyword">if</span> (ifa != rt-&gt;rt_ifa)
				rtsetifa(rt, ifa);
			IFA_REMREF(ifa);
		}
	}

	<span class="enscript-comment">/* Release extra ref */</span>
	RT_REMREF_LOCKED(rt);
}

<span class="enscript-comment">/*
 * Extract the addresses of the passed sockaddrs.
 * Do a little sanity checking so as to avoid bad memory references.
 * This data is derived straight from userland.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rt_xaddrs</span>(caddr_t cp, caddr_t cplim, <span class="enscript-type">struct</span> rt_addrinfo *rtinfo)
{
	<span class="enscript-type">struct</span> sockaddr *sa;
	<span class="enscript-type">int</span> i;

	bzero(rtinfo-&gt;rti_info, <span class="enscript-keyword">sizeof</span> (rtinfo-&gt;rti_info));
	<span class="enscript-keyword">for</span> (i = 0; (i &lt; RTAX_MAX) &amp;&amp; (cp &lt; cplim); i++) {
		<span class="enscript-keyword">if</span> ((rtinfo-&gt;rti_addrs &amp; (1 &lt;&lt; i)) == 0)
			<span class="enscript-keyword">continue</span>;
		sa = (<span class="enscript-type">struct</span> sockaddr *)cp;
		<span class="enscript-comment">/*
		 * It won't fit.
		 */</span>
		<span class="enscript-keyword">if</span> ((cp + sa-&gt;sa_len) &gt; cplim)
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-comment">/*
		 * there are no more.. quit now
		 * If there are more bits, they are in error.
		 * I've seen this. route(1) can evidently generate these.
		 * This causes kernel to core dump.
		 * for compatibility, If we see this, point to a safe address.
		 */</span>
		<span class="enscript-keyword">if</span> (sa-&gt;sa_len == 0) {
			rtinfo-&gt;rti_info[i] = &amp;sa_zero;
			<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* should be EINVAL but for compat */</span>
		}
		<span class="enscript-comment">/* accept it */</span>
		rtinfo-&gt;rti_info[i] = sa;
		ADVANCE32(cp, sa);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">rt_msg1</span>(<span class="enscript-type">int</span> type, <span class="enscript-type">struct</span> rt_addrinfo *rtinfo)
{
	<span class="enscript-type">struct</span> rt_msghdr *rtm;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> len, dlen, off;

	<span class="enscript-keyword">switch</span> (type) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_DELADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_NEWADDR</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifa_msghdr);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_DELMADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_NEWMADDR</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifma_msghdr);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_IFINFO</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> if_msghdr);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> rt_msghdr);
	}
	m = m_gethdr(M_DONTWAIT, MT_DATA);
	<span class="enscript-keyword">if</span> (m &amp;&amp; len &gt; MHLEN) {
		MCLGET(m, M_DONTWAIT);
		<span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; M_EXT)) {
			m_free(m);
			m = NULL;
		}
	}
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> (NULL);
	m-&gt;m_pkthdr.len = m-&gt;m_len = len;
	m-&gt;m_pkthdr.rcvif = NULL;
	rtm = mtod(m, <span class="enscript-type">struct</span> rt_msghdr *);
	bzero((caddr_t)rtm, len);
	off = len;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; RTAX_MAX; i++) {
		<span class="enscript-type">struct</span> sockaddr *sa, *hint;
		uint8_t ssbuf[SOCK_MAXADDRLEN + 1];

		<span class="enscript-comment">/*
		 * Make sure to accomodate the largest possible size of sa_len.
		 */</span>
		_CASSERT(<span class="enscript-keyword">sizeof</span> (ssbuf) == (SOCK_MAXADDRLEN + 1));

		<span class="enscript-keyword">if</span> ((sa = rtinfo-&gt;rti_info[i]) == NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">switch</span> (i) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RTAX_DST</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RTAX_NETMASK</span>:
			<span class="enscript-keyword">if</span> ((hint = rtinfo-&gt;rti_info[RTAX_DST]) == NULL)
				hint = rtinfo-&gt;rti_info[RTAX_IFA];

			<span class="enscript-comment">/* Scrub away any trace of embedded interface scope */</span>
			sa = rtm_scrub(type, i, hint, sa, &amp;ssbuf,
			    <span class="enscript-keyword">sizeof</span> (ssbuf), NULL);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}

		rtinfo-&gt;rti_addrs |= (1 &lt;&lt; i);
		dlen = sa-&gt;sa_len;
		m_copyback(m, off, dlen, (caddr_t)sa);
		len = off + dlen;
		off += ROUNDUP32(dlen);
	}
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len != len) {
		m_freem(m);
		<span class="enscript-keyword">return</span> (NULL);
	}
	rtm-&gt;rtm_msglen = len;
	rtm-&gt;rtm_version = RTM_VERSION;
	rtm-&gt;rtm_type = type;
	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rt_msg2</span>(<span class="enscript-type">int</span> type, <span class="enscript-type">struct</span> rt_addrinfo *rtinfo, caddr_t cp, <span class="enscript-type">struct</span> walkarg *w,
	kauth_cred_t* credp)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> len, dlen, rlen, second_time = 0;
	caddr_t cp0;

	rtinfo-&gt;rti_addrs = 0;
<span class="enscript-reference">again</span>:
	<span class="enscript-keyword">switch</span> (type) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_DELADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_NEWADDR</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifa_msghdr);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_DELMADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_NEWMADDR</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifma_msghdr);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_IFINFO</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> if_msghdr);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_IFINFO2</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> if_msghdr2);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_NEWMADDR2</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifma_msghdr2);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_GET_EXT</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> rt_msghdr_ext);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_GET2</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> rt_msghdr2);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> rt_msghdr);
	}
	cp0 = cp;
	<span class="enscript-keyword">if</span> (cp0)
		cp += len;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; RTAX_MAX; i++) {
		<span class="enscript-type">struct</span> sockaddr *sa, *hint;
		uint8_t ssbuf[SOCK_MAXADDRLEN + 1];

		<span class="enscript-comment">/*
		 * Make sure to accomodate the largest possible size of sa_len.
		 */</span>
		_CASSERT(<span class="enscript-keyword">sizeof</span> (ssbuf) == (SOCK_MAXADDRLEN + 1));

		<span class="enscript-keyword">if</span> ((sa = rtinfo-&gt;rti_info[i]) == NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">switch</span> (i) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RTAX_DST</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RTAX_NETMASK</span>:
			<span class="enscript-keyword">if</span> ((hint = rtinfo-&gt;rti_info[RTAX_DST]) == NULL)
				hint = rtinfo-&gt;rti_info[RTAX_IFA];

			<span class="enscript-comment">/* Scrub away any trace of embedded interface scope */</span>
			sa = rtm_scrub(type, i, hint, sa, &amp;ssbuf,
			    <span class="enscript-keyword">sizeof</span> (ssbuf), NULL);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">RTAX_IFP</span>:
			sa = rtm_scrub(type, i, NULL, sa, &amp;ssbuf,
			    <span class="enscript-keyword">sizeof</span> (ssbuf), credp);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}

		rtinfo-&gt;rti_addrs |= (1 &lt;&lt; i);
		dlen = sa-&gt;sa_len;
		rlen = ROUNDUP32(dlen);
		<span class="enscript-keyword">if</span> (cp) {
			bcopy((caddr_t)sa, cp, (size_t)dlen);
			<span class="enscript-keyword">if</span> (dlen != rlen)
				bzero(cp + dlen, rlen - dlen);
			cp += rlen;
		}
		len += rlen;
	}
	<span class="enscript-keyword">if</span> (cp == NULL &amp;&amp; w != NULL &amp;&amp; !second_time) {
		<span class="enscript-type">struct</span> walkarg *rw = w;

		<span class="enscript-keyword">if</span> (rw-&gt;w_req != NULL) {
			<span class="enscript-keyword">if</span> (rw-&gt;w_tmemsize &lt; len) {
				<span class="enscript-keyword">if</span> (rw-&gt;w_tmem != NULL)
					FREE(rw-&gt;w_tmem, M_RTABLE);
				rw-&gt;w_tmem = _MALLOC(len, M_RTABLE, M_WAITOK);
				<span class="enscript-keyword">if</span> (rw-&gt;w_tmem != NULL)
					rw-&gt;w_tmemsize = len;
			}
			<span class="enscript-keyword">if</span> (rw-&gt;w_tmem != NULL) {
				cp = rw-&gt;w_tmem;
				second_time = 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
			}
		}
	}
	<span class="enscript-keyword">if</span> (cp) {
		<span class="enscript-type">struct</span> rt_msghdr *rtm = (<span class="enscript-type">struct</span> rt_msghdr *)(<span class="enscript-type">void</span> *)cp0;

		rtm-&gt;rtm_version = RTM_VERSION;
		rtm-&gt;rtm_type = type;
		rtm-&gt;rtm_msglen = len;
	}
	<span class="enscript-keyword">return</span> (len);
}

<span class="enscript-comment">/*
 * This routine is called to generate a message from the routing
 * socket indicating that a redirect has occurred, a routing lookup
 * has failed, or that a protocol has detected timeouts to a particular
 * destination.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rt_missmsg</span>(<span class="enscript-type">int</span> type, <span class="enscript-type">struct</span> rt_addrinfo *rtinfo, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> error)
{
	<span class="enscript-type">struct</span> rt_msghdr *rtm;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> sockaddr *sa = rtinfo-&gt;rti_info[RTAX_DST];
	<span class="enscript-type">struct</span> sockproto route_proto = { PF_ROUTE, 0 };

	<span class="enscript-keyword">if</span> (route_cb.any_count == 0)
		<span class="enscript-keyword">return</span>;
	m = rt_msg1(type, rtinfo);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span>;
	rtm = mtod(m, <span class="enscript-type">struct</span> rt_msghdr *);
	rtm-&gt;rtm_flags = RTF_DONE | flags;
	rtm-&gt;rtm_errno = error;
	rtm-&gt;rtm_addrs = rtinfo-&gt;rti_addrs;
	route_proto.sp_family = sa ? sa-&gt;sa_family : 0;
	raw_input(m, &amp;route_proto, &amp;route_src, &amp;route_dst);
}

<span class="enscript-comment">/*
 * This routine is called to generate a message from the routing
 * socket indicating that the status of a network interface has changed.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rt_ifmsg</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> if_msghdr *ifm;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> rt_addrinfo info;
	<span class="enscript-type">struct</span>	sockproto route_proto = { PF_ROUTE, 0 };

	<span class="enscript-keyword">if</span> (route_cb.any_count == 0)
		<span class="enscript-keyword">return</span>;
	bzero((caddr_t)&amp;info, <span class="enscript-keyword">sizeof</span> (info));
	m = rt_msg1(RTM_IFINFO, &amp;info);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span>;
	ifm = mtod(m, <span class="enscript-type">struct</span> if_msghdr *);
	ifm-&gt;ifm_index = ifp-&gt;if_index;
	ifm-&gt;ifm_flags = (u_short)ifp-&gt;if_flags;
	if_data_internal_to_if_data(ifp, &amp;ifp-&gt;if_data, &amp;ifm-&gt;ifm_data);
	ifm-&gt;ifm_addrs = 0;
	raw_input(m, &amp;route_proto, &amp;route_src, &amp;route_dst);
}

<span class="enscript-comment">/*
 * This is called to generate messages from the routing socket
 * indicating a network interface has had addresses associated with it.
 * if we ever reverse the logic and replace messages TO the routing
 * socket indicate a request to configure interfaces, then it will
 * be unnecessary as the routing socket will automatically generate
 * copies of it.
 *
 * Since this is coming from the interface, it is expected that the
 * interface will be locked.  Caller must hold rnh_lock and rt_lock.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rt_newaddrmsg</span>(<span class="enscript-type">int</span> cmd, <span class="enscript-type">struct</span> ifaddr *ifa, <span class="enscript-type">int</span> error, <span class="enscript-type">struct</span> rtentry *rt)
{
	<span class="enscript-type">struct</span> rt_addrinfo info;
	<span class="enscript-type">struct</span> sockaddr *sa = 0;
	<span class="enscript-type">int</span> pass;
	<span class="enscript-type">struct</span> mbuf *m = 0;
	<span class="enscript-type">struct</span> ifnet *ifp = ifa-&gt;ifa_ifp;
	<span class="enscript-type">struct</span> sockproto route_proto = { PF_ROUTE, 0 };

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-keyword">if</span> (route_cb.any_count == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Become a regular mutex, just in case */</span>
	RT_CONVERT_LOCK(rt);
	<span class="enscript-keyword">for</span> (pass = 1; pass &lt; 3; pass++) {
		bzero((caddr_t)&amp;info, <span class="enscript-keyword">sizeof</span> (info));
		<span class="enscript-keyword">if</span> ((cmd == RTM_ADD &amp;&amp; pass == 1) ||
		    (cmd == RTM_DELETE &amp;&amp; pass == 2)) {
			<span class="enscript-type">struct</span> ifa_msghdr *ifam;
			<span class="enscript-type">int</span> ncmd = cmd == RTM_ADD ? RTM_NEWADDR : RTM_DELADDR;

			<span class="enscript-comment">/* Lock ifp for if_lladdr */</span>
			ifnet_lock_shared(ifp);
			IFA_LOCK(ifa);
			info.rti_info[RTAX_IFA] = sa = ifa-&gt;ifa_addr;
			<span class="enscript-comment">/*
			 * Holding ifnet lock here prevents the link address
			 * from changing contents, so no need to hold its
			 * lock.  The link address is always present; it's
			 * never freed.
			 */</span>
			info.rti_info[RTAX_IFP] = ifp-&gt;if_lladdr-&gt;ifa_addr;
			info.rti_info[RTAX_NETMASK] = ifa-&gt;ifa_netmask;
			info.rti_info[RTAX_BRD] = ifa-&gt;ifa_dstaddr;
			<span class="enscript-keyword">if</span> ((m = rt_msg1(ncmd, &amp;info)) == NULL) {
				IFA_UNLOCK(ifa);
				ifnet_lock_done(ifp);
				<span class="enscript-keyword">continue</span>;
			}
			IFA_UNLOCK(ifa);
			ifnet_lock_done(ifp);
			ifam = mtod(m, <span class="enscript-type">struct</span> ifa_msghdr *);
			ifam-&gt;ifam_index = ifp-&gt;if_index;
			IFA_LOCK_SPIN(ifa);
			ifam-&gt;ifam_metric = ifa-&gt;ifa_metric;
			ifam-&gt;ifam_flags = ifa-&gt;ifa_flags;
			IFA_UNLOCK(ifa);
			ifam-&gt;ifam_addrs = info.rti_addrs;
		}
		<span class="enscript-keyword">if</span> ((cmd == RTM_ADD &amp;&amp; pass == 2) ||
		    (cmd == RTM_DELETE &amp;&amp; pass == 1)) {
			<span class="enscript-type">struct</span> rt_msghdr *rtm;

			<span class="enscript-keyword">if</span> (rt == NULL)
				<span class="enscript-keyword">continue</span>;
			info.rti_info[RTAX_NETMASK] = rt_mask(rt);
			info.rti_info[RTAX_DST] = sa = rt_key(rt);
			info.rti_info[RTAX_GATEWAY] = rt-&gt;rt_gateway;
			<span class="enscript-keyword">if</span> ((m = rt_msg1(cmd, &amp;info)) == NULL)
				<span class="enscript-keyword">continue</span>;
			rtm = mtod(m, <span class="enscript-type">struct</span> rt_msghdr *);
			rtm-&gt;rtm_index = ifp-&gt;if_index;
			rtm-&gt;rtm_flags |= rt-&gt;rt_flags;
			rtm-&gt;rtm_errno = error;
			rtm-&gt;rtm_addrs = info.rti_addrs;
		}
		route_proto.sp_protocol = sa ? sa-&gt;sa_family : 0;
		raw_input(m, &amp;route_proto, &amp;route_src, &amp;route_dst);
	}
}

<span class="enscript-comment">/*
 * This is the analogue to the rt_newaddrmsg which performs the same
 * function but for multicast group memberhips.  This is easier since
 * there is no route state to worry about.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rt_newmaddrmsg</span>(<span class="enscript-type">int</span> cmd, <span class="enscript-type">struct</span> ifmultiaddr *ifma)
{
	<span class="enscript-type">struct</span> rt_addrinfo info;
	<span class="enscript-type">struct</span> mbuf *m = 0;
	<span class="enscript-type">struct</span> ifnet *ifp = ifma-&gt;ifma_ifp;
	<span class="enscript-type">struct</span> ifma_msghdr *ifmam;
	<span class="enscript-type">struct</span> sockproto route_proto = { PF_ROUTE, 0 };

	<span class="enscript-keyword">if</span> (route_cb.any_count == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Lock ifp for if_lladdr */</span>
	ifnet_lock_shared(ifp);
	bzero((caddr_t)&amp;info, <span class="enscript-keyword">sizeof</span> (info));
	IFMA_LOCK(ifma);
	info.rti_info[RTAX_IFA] = ifma-&gt;ifma_addr;
	<span class="enscript-comment">/* lladdr doesn't need lock */</span>
	info.rti_info[RTAX_IFP] = ifp-&gt;if_lladdr-&gt;ifa_addr;

	<span class="enscript-comment">/*
	 * If a link-layer address is present, present it as a ``gateway''
	 * (similarly to how ARP entries, e.g., are presented).
	 */</span>
	info.rti_info[RTAX_GATEWAY] = (ifma-&gt;ifma_ll != NULL) ?
	    ifma-&gt;ifma_ll-&gt;ifma_addr : NULL;
	<span class="enscript-keyword">if</span> ((m = rt_msg1(cmd, &amp;info)) == NULL) {
		IFMA_UNLOCK(ifma);
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">return</span>;
	}
	ifmam = mtod(m, <span class="enscript-type">struct</span> ifma_msghdr *);
	ifmam-&gt;ifmam_index = ifp-&gt;if_index;
	ifmam-&gt;ifmam_addrs = info.rti_addrs;
	route_proto.sp_protocol = ifma-&gt;ifma_addr-&gt;sa_family;
	IFMA_UNLOCK(ifma);
	ifnet_lock_done(ifp);
	raw_input(m, &amp;route_proto, &amp;route_src, &amp;route_dst);
}

<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">rtm2str</span>(<span class="enscript-type">int</span> cmd)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *c = <span class="enscript-string">&quot;RTM_?&quot;</span>;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_ADD</span>:
		c = <span class="enscript-string">&quot;RTM_ADD&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_DELETE</span>:
		c = <span class="enscript-string">&quot;RTM_DELETE&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_CHANGE</span>:
		c = <span class="enscript-string">&quot;RTM_CHANGE&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_GET</span>:
		c = <span class="enscript-string">&quot;RTM_GET&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_LOSING</span>:
		c = <span class="enscript-string">&quot;RTM_LOSING&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_REDIRECT</span>:
		c = <span class="enscript-string">&quot;RTM_REDIRECT&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_MISS</span>:
		c = <span class="enscript-string">&quot;RTM_MISS&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_LOCK</span>:
		c = <span class="enscript-string">&quot;RTM_LOCK&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_OLDADD</span>:
		c = <span class="enscript-string">&quot;RTM_OLDADD&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_OLDDEL</span>:
		c = <span class="enscript-string">&quot;RTM_OLDDEL&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_RESOLVE</span>:
		c = <span class="enscript-string">&quot;RTM_RESOLVE&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_NEWADDR</span>:
		c = <span class="enscript-string">&quot;RTM_NEWADDR&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_DELADDR</span>:
		c = <span class="enscript-string">&quot;RTM_DELADDR&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_IFINFO</span>:
		c = <span class="enscript-string">&quot;RTM_IFINFO&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_NEWMADDR</span>:
		c = <span class="enscript-string">&quot;RTM_NEWMADDR&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_DELMADDR</span>:
		c = <span class="enscript-string">&quot;RTM_DELMADDR&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_GET_SILENT</span>:
		c = <span class="enscript-string">&quot;RTM_GET_SILENT&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_IFINFO2</span>:
		c = <span class="enscript-string">&quot;RTM_IFINFO2&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_NEWMADDR2</span>:
		c = <span class="enscript-string">&quot;RTM_NEWMADDR2&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_GET2</span>:
		c = <span class="enscript-string">&quot;RTM_GET2&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_GET_EXT</span>:
		c = <span class="enscript-string">&quot;RTM_GET_EXT&quot;</span>;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (c);
}

<span class="enscript-comment">/*
 * This is used in dumping the kernel table via sysctl().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_dumpentry</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">void</span> *vw)
{
	<span class="enscript-type">struct</span> walkarg *w = vw;
	<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)rn;
	<span class="enscript-type">int</span> error = 0, size;
	<span class="enscript-type">struct</span> rt_addrinfo info;
	kauth_cred_t cred;

	cred = kauth_cred_proc_ref(current_proc());

	RT_LOCK(rt);
	<span class="enscript-keyword">if</span> (w-&gt;w_op == NET_RT_FLAGS &amp;&amp; !(rt-&gt;rt_flags &amp; w-&gt;w_arg))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	bzero((caddr_t)&amp;info, <span class="enscript-keyword">sizeof</span> (info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_GATEWAY] = rt-&gt;rt_gateway;
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
	info.rti_info[RTAX_GENMASK] = rt-&gt;rt_genmask;

	<span class="enscript-keyword">if</span> (w-&gt;w_op != NET_RT_DUMP2) {
		size = rt_msg2(RTM_GET, &amp;info, NULL, w, &amp;cred);
		<span class="enscript-keyword">if</span> (w-&gt;w_req != NULL &amp;&amp; w-&gt;w_tmem != NULL) {
			<span class="enscript-type">struct</span> rt_msghdr *rtm =
			    (<span class="enscript-type">struct</span> rt_msghdr *)(<span class="enscript-type">void</span> *)w-&gt;w_tmem;

			rtm-&gt;rtm_flags = rt-&gt;rt_flags;
			rtm-&gt;rtm_use = rt-&gt;rt_use;
			rt_getmetrics(rt, &amp;rtm-&gt;rtm_rmx);
			rtm-&gt;rtm_index = rt-&gt;rt_ifp-&gt;if_index;
			rtm-&gt;rtm_pid = 0;
			rtm-&gt;rtm_seq = 0;
			rtm-&gt;rtm_errno = 0;
			rtm-&gt;rtm_addrs = info.rti_addrs;
			error = SYSCTL_OUT(w-&gt;w_req, (caddr_t)rtm, size);
		}
	} <span class="enscript-keyword">else</span> {
		size = rt_msg2(RTM_GET2, &amp;info, NULL, w, &amp;cred);
		<span class="enscript-keyword">if</span> (w-&gt;w_req != NULL &amp;&amp; w-&gt;w_tmem != NULL) {
			<span class="enscript-type">struct</span> rt_msghdr2 *rtm =
			    (<span class="enscript-type">struct</span> rt_msghdr2 *)(<span class="enscript-type">void</span> *)w-&gt;w_tmem;

			rtm-&gt;rtm_flags = rt-&gt;rt_flags;
			rtm-&gt;rtm_use = rt-&gt;rt_use;
			rt_getmetrics(rt, &amp;rtm-&gt;rtm_rmx);
			rtm-&gt;rtm_index = rt-&gt;rt_ifp-&gt;if_index;
			rtm-&gt;rtm_refcnt = rt-&gt;rt_refcnt;
			<span class="enscript-keyword">if</span> (rt-&gt;rt_parent)
				rtm-&gt;rtm_parentflags = rt-&gt;rt_parent-&gt;rt_flags;
			<span class="enscript-keyword">else</span>
				rtm-&gt;rtm_parentflags = 0;
			rtm-&gt;rtm_reserved = 0;
			rtm-&gt;rtm_addrs = info.rti_addrs;
			error = SYSCTL_OUT(w-&gt;w_req, (caddr_t)rtm, size);
		}
	}

<span class="enscript-reference">done</span>:
	RT_UNLOCK(rt);
	kauth_cred_unref(&amp;cred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * This is used for dumping extended information from route entries.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_dumpentry_ext</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">void</span> *vw)
{
	<span class="enscript-type">struct</span> walkarg *w = vw;
	<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)rn;
	<span class="enscript-type">int</span> error = 0, size;
	<span class="enscript-type">struct</span> rt_addrinfo info;
	kauth_cred_t cred;

	cred = kauth_cred_proc_ref(current_proc());

	RT_LOCK(rt);
	<span class="enscript-keyword">if</span> (w-&gt;w_op == NET_RT_DUMPX_FLAGS &amp;&amp; !(rt-&gt;rt_flags &amp; w-&gt;w_arg))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	bzero(&amp;info, <span class="enscript-keyword">sizeof</span> (info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_GATEWAY] = rt-&gt;rt_gateway;
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
	info.rti_info[RTAX_GENMASK] = rt-&gt;rt_genmask;

	size = rt_msg2(RTM_GET_EXT, &amp;info, NULL, w, &amp;cred);
	<span class="enscript-keyword">if</span> (w-&gt;w_req != NULL &amp;&amp; w-&gt;w_tmem != NULL) {
		<span class="enscript-type">struct</span> rt_msghdr_ext *ertm =
		    (<span class="enscript-type">struct</span> rt_msghdr_ext *)(<span class="enscript-type">void</span> *)w-&gt;w_tmem;

		ertm-&gt;rtm_flags = rt-&gt;rt_flags;
		ertm-&gt;rtm_use = rt-&gt;rt_use;
		rt_getmetrics(rt, &amp;ertm-&gt;rtm_rmx);
		ertm-&gt;rtm_index = rt-&gt;rt_ifp-&gt;if_index;
		ertm-&gt;rtm_pid = 0;
		ertm-&gt;rtm_seq = 0;
		ertm-&gt;rtm_errno = 0;
		ertm-&gt;rtm_addrs = info.rti_addrs;
		<span class="enscript-keyword">if</span> (rt-&gt;rt_llinfo_get_ri == NULL) {
			bzero(&amp;ertm-&gt;rtm_ri, <span class="enscript-keyword">sizeof</span> (ertm-&gt;rtm_ri));
			ertm-&gt;rtm_ri.ri_rssi = IFNET_RSSI_UNKNOWN;
			ertm-&gt;rtm_ri.ri_lqm = IFNET_LQM_THRESH_OFF;
			ertm-&gt;rtm_ri.ri_npm = IFNET_NPM_THRESH_UNKNOWN;
		} <span class="enscript-keyword">else</span> {
			rt-&gt;rt_llinfo_get_ri(rt, &amp;ertm-&gt;rtm_ri);
		}
		error = SYSCTL_OUT(w-&gt;w_req, (caddr_t)ertm, size);
	}

<span class="enscript-reference">done</span>:
	RT_UNLOCK(rt);
	kauth_cred_unref(&amp;cred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * rdar://9307819
 * To avoid to call copyout() while holding locks and to cause problems
 * in the paging path, sysctl_iflist() and sysctl_iflist2() contstruct
 * the list in two passes. In the first pass we compute the total
 * length of the data we are going to copyout, then we release
 * all locks to allocate a temporary buffer that gets filled
 * in the second pass.
 *
 * Note that we are verifying the assumption that _MALLOC returns a buffer
 * that is at least 32 bits aligned and that the messages and addresses are
 * 32 bits aligned.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_iflist</span>(<span class="enscript-type">int</span> af, <span class="enscript-type">struct</span> walkarg *w)
{
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span>	rt_addrinfo info;
	<span class="enscript-type">int</span>	len, error = 0;
	<span class="enscript-type">int</span>	pass = 0;
	<span class="enscript-type">int</span>	total_len = 0, current_len = 0;
	<span class="enscript-type">char</span>	*total_buffer = NULL, *cp = NULL;
	kauth_cred_t cred;

	cred = kauth_cred_proc_ref(current_proc());

	bzero((caddr_t)&amp;info, <span class="enscript-keyword">sizeof</span> (info));

	<span class="enscript-keyword">for</span> (pass = 0; pass &lt; 2; pass++) {
		ifnet_head_lock_shared();

		TAILQ_FOREACH(ifp, &amp;ifnet_head, if_link) {
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (w-&gt;w_arg &amp;&amp; w-&gt;w_arg != ifp-&gt;if_index)
				<span class="enscript-keyword">continue</span>;
			ifnet_lock_shared(ifp);
			<span class="enscript-comment">/*
			 * Holding ifnet lock here prevents the link address
			 * from changing contents, so no need to hold the ifa
			 * lock.  The link address is always present; it's
			 * never freed.
			 */</span>
			ifa = ifp-&gt;if_lladdr;
			info.rti_info[RTAX_IFP] = ifa-&gt;ifa_addr;
			len = rt_msg2(RTM_IFINFO, &amp;info, NULL, NULL, &amp;cred);
			<span class="enscript-keyword">if</span> (pass == 0) {
				total_len += len;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-type">struct</span> if_msghdr *ifm;

				<span class="enscript-keyword">if</span> (current_len + len &gt; total_len) {
					ifnet_lock_done(ifp);
					error = ENOBUFS;
					<span class="enscript-keyword">break</span>;
				}
				info.rti_info[RTAX_IFP] = ifa-&gt;ifa_addr;
				len = rt_msg2(RTM_IFINFO, &amp;info,
				    (caddr_t)cp, NULL, &amp;cred);
				info.rti_info[RTAX_IFP] = NULL;

				ifm = (<span class="enscript-type">struct</span> if_msghdr *)(<span class="enscript-type">void</span> *)cp;
				ifm-&gt;ifm_index = ifp-&gt;if_index;
				ifm-&gt;ifm_flags = (u_short)ifp-&gt;if_flags;
				if_data_internal_to_if_data(ifp, &amp;ifp-&gt;if_data,
				    &amp;ifm-&gt;ifm_data);
				ifm-&gt;ifm_addrs = info.rti_addrs;

				cp += len;
				VERIFY(IS_P2ALIGNED(cp, <span class="enscript-keyword">sizeof</span> (u_int32_t)));
				current_len += len;
			}
			<span class="enscript-keyword">while</span> ((ifa = ifa-&gt;ifa_link.tqe_next) != NULL) {
				IFA_LOCK(ifa);
				<span class="enscript-keyword">if</span> (af &amp;&amp; af != ifa-&gt;ifa_addr-&gt;sa_family) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				info.rti_info[RTAX_IFA] = ifa-&gt;ifa_addr;
				info.rti_info[RTAX_NETMASK] = ifa-&gt;ifa_netmask;
				info.rti_info[RTAX_BRD] = ifa-&gt;ifa_dstaddr;
				len = rt_msg2(RTM_NEWADDR, &amp;info, NULL, NULL,
				    &amp;cred);
				<span class="enscript-keyword">if</span> (pass == 0) {
					total_len += len;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-type">struct</span> ifa_msghdr *ifam;

					<span class="enscript-keyword">if</span> (current_len + len &gt; total_len) {
						IFA_UNLOCK(ifa);
						error = ENOBUFS;
						<span class="enscript-keyword">break</span>;
					}
					len = rt_msg2(RTM_NEWADDR, &amp;info,
					    (caddr_t)cp, NULL, &amp;cred);

					ifam = (<span class="enscript-type">struct</span> ifa_msghdr *)(<span class="enscript-type">void</span> *)cp;
					ifam-&gt;ifam_index =
					    ifa-&gt;ifa_ifp-&gt;if_index;
					ifam-&gt;ifam_flags = ifa-&gt;ifa_flags;
					ifam-&gt;ifam_metric = ifa-&gt;ifa_metric;
					ifam-&gt;ifam_addrs = info.rti_addrs;

					cp += len;
					VERIFY(IS_P2ALIGNED(cp,
					    <span class="enscript-keyword">sizeof</span> (u_int32_t)));
					current_len += len;
				}
				IFA_UNLOCK(ifa);
			}
			ifnet_lock_done(ifp);
			info.rti_info[RTAX_IFA] = info.rti_info[RTAX_NETMASK] =
			    info.rti_info[RTAX_BRD] = NULL;
		}

		ifnet_head_done();

		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">if</span> (error == ENOBUFS)
				printf(<span class="enscript-string">&quot;%s: current_len (%d) + len (%d) &gt; &quot;</span>
				    <span class="enscript-string">&quot;total_len (%d)\n&quot;</span>, __func__, current_len,
				    len, total_len);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (pass == 0) {
			<span class="enscript-comment">/* Better to return zero length buffer than ENOBUFS */</span>
			<span class="enscript-keyword">if</span> (total_len == 0)
				total_len = 1;
			total_len += total_len &gt;&gt; 3;
			total_buffer = _MALLOC(total_len, M_RTABLE,
			    M_ZERO | M_WAITOK);
			<span class="enscript-keyword">if</span> (total_buffer == NULL) {
				printf(<span class="enscript-string">&quot;%s: _MALLOC(%d) failed\n&quot;</span>, __func__,
				    total_len);
				error = ENOBUFS;
				<span class="enscript-keyword">break</span>;
			}
			cp = total_buffer;
			VERIFY(IS_P2ALIGNED(cp, <span class="enscript-keyword">sizeof</span> (u_int32_t)));
		} <span class="enscript-keyword">else</span> {
			error = SYSCTL_OUT(w-&gt;w_req, total_buffer, current_len);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (total_buffer != NULL)
		_FREE(total_buffer, M_RTABLE);

	kauth_cred_unref(&amp;cred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_iflist2</span>(<span class="enscript-type">int</span> af, <span class="enscript-type">struct</span> walkarg *w)
{
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span>	rt_addrinfo info;
	<span class="enscript-type">int</span>	len, error = 0;
	<span class="enscript-type">int</span>	pass = 0;
	<span class="enscript-type">int</span>	total_len = 0, current_len = 0;
	<span class="enscript-type">char</span>	*total_buffer = NULL, *cp = NULL;
	kauth_cred_t cred;

	cred = kauth_cred_proc_ref(current_proc());

	bzero((caddr_t)&amp;info, <span class="enscript-keyword">sizeof</span> (info));

	<span class="enscript-keyword">for</span> (pass = 0; pass &lt; 2; pass++) {
		<span class="enscript-type">struct</span> ifmultiaddr *ifma;

		ifnet_head_lock_shared();

		TAILQ_FOREACH(ifp, &amp;ifnet_head, if_link) {
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (w-&gt;w_arg &amp;&amp; w-&gt;w_arg != ifp-&gt;if_index)
				<span class="enscript-keyword">continue</span>;
			ifnet_lock_shared(ifp);
			<span class="enscript-comment">/*
			 * Holding ifnet lock here prevents the link address
			 * from changing contents, so no need to hold the ifa
			 * lock.  The link address is always present; it's
			 * never freed.
			 */</span>
			ifa = ifp-&gt;if_lladdr;
			info.rti_info[RTAX_IFP] = ifa-&gt;ifa_addr;
			len = rt_msg2(RTM_IFINFO2, &amp;info, NULL, NULL, &amp;cred);
			<span class="enscript-keyword">if</span> (pass == 0) {
				total_len += len;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-type">struct</span> if_msghdr2 *ifm;

				<span class="enscript-keyword">if</span> (current_len + len &gt; total_len) {
					ifnet_lock_done(ifp);
					error = ENOBUFS;
					<span class="enscript-keyword">break</span>;
				}
				info.rti_info[RTAX_IFP] = ifa-&gt;ifa_addr;
				len = rt_msg2(RTM_IFINFO2, &amp;info,
				    (caddr_t)cp, NULL, &amp;cred);
				info.rti_info[RTAX_IFP] = NULL;

				ifm = (<span class="enscript-type">struct</span> if_msghdr2 *)(<span class="enscript-type">void</span> *)cp;
				ifm-&gt;ifm_addrs = info.rti_addrs;
				ifm-&gt;ifm_flags = (u_short)ifp-&gt;if_flags;
				ifm-&gt;ifm_index = ifp-&gt;if_index;
				ifm-&gt;ifm_snd_len = IFCQ_LEN(&amp;ifp-&gt;if_snd);
				ifm-&gt;ifm_snd_maxlen = IFCQ_MAXLEN(&amp;ifp-&gt;if_snd);
				ifm-&gt;ifm_snd_drops =
				    ifp-&gt;if_snd.ifcq_dropcnt.packets;
				ifm-&gt;ifm_timer = ifp-&gt;if_timer;
				if_data_internal_to_if_data64(ifp,
				    &amp;ifp-&gt;if_data, &amp;ifm-&gt;ifm_data);

				cp += len;
				VERIFY(IS_P2ALIGNED(cp, <span class="enscript-keyword">sizeof</span> (u_int32_t)));
				current_len += len;
			}
			<span class="enscript-keyword">while</span> ((ifa = ifa-&gt;ifa_link.tqe_next) != NULL) {
				IFA_LOCK(ifa);
				<span class="enscript-keyword">if</span> (af &amp;&amp; af != ifa-&gt;ifa_addr-&gt;sa_family) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				info.rti_info[RTAX_IFA] = ifa-&gt;ifa_addr;
				info.rti_info[RTAX_NETMASK] = ifa-&gt;ifa_netmask;
				info.rti_info[RTAX_BRD] = ifa-&gt;ifa_dstaddr;
				len = rt_msg2(RTM_NEWADDR, &amp;info, NULL, NULL,
				    &amp;cred);
				<span class="enscript-keyword">if</span> (pass == 0) {
					total_len += len;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-type">struct</span> ifa_msghdr *ifam;

					<span class="enscript-keyword">if</span> (current_len + len &gt; total_len) {
						IFA_UNLOCK(ifa);
						error = ENOBUFS;
						<span class="enscript-keyword">break</span>;
					}
					len = rt_msg2(RTM_NEWADDR, &amp;info,
					    (caddr_t)cp, NULL, &amp;cred);

					ifam = (<span class="enscript-type">struct</span> ifa_msghdr *)(<span class="enscript-type">void</span> *)cp;
					ifam-&gt;ifam_index =
					    ifa-&gt;ifa_ifp-&gt;if_index;
					ifam-&gt;ifam_flags = ifa-&gt;ifa_flags;
					ifam-&gt;ifam_metric = ifa-&gt;ifa_metric;
					ifam-&gt;ifam_addrs = info.rti_addrs;

					cp += len;
					VERIFY(IS_P2ALIGNED(cp,
					    <span class="enscript-keyword">sizeof</span> (u_int32_t)));
					current_len += len;
				}
				IFA_UNLOCK(ifa);
			}
			<span class="enscript-keyword">if</span> (error) {
				ifnet_lock_done(ifp);
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">for</span> (ifma = LIST_FIRST(&amp;ifp-&gt;if_multiaddrs);
			    ifma != NULL; ifma = LIST_NEXT(ifma, ifma_link)) {
				<span class="enscript-type">struct</span> ifaddr *ifa0;

				IFMA_LOCK(ifma);
				<span class="enscript-keyword">if</span> (af &amp;&amp; af != ifma-&gt;ifma_addr-&gt;sa_family) {
					IFMA_UNLOCK(ifma);
					<span class="enscript-keyword">continue</span>;
				}
				bzero((caddr_t)&amp;info, <span class="enscript-keyword">sizeof</span> (info));
				info.rti_info[RTAX_IFA] = ifma-&gt;ifma_addr;
				<span class="enscript-comment">/*
				 * Holding ifnet lock here prevents the link
				 * address from changing contents, so no need
				 * to hold the ifa0 lock.  The link address is
				 * always present; it's never freed.
				 */</span>
				ifa0 = ifp-&gt;if_lladdr;
				info.rti_info[RTAX_IFP] = ifa0-&gt;ifa_addr;
				<span class="enscript-keyword">if</span> (ifma-&gt;ifma_ll != NULL)
					info.rti_info[RTAX_GATEWAY] =
					    ifma-&gt;ifma_ll-&gt;ifma_addr;
				len = rt_msg2(RTM_NEWMADDR2, &amp;info, NULL, NULL,
				    &amp;cred);
				<span class="enscript-keyword">if</span> (pass == 0) {
					total_len += len;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-type">struct</span> ifma_msghdr2 *ifmam;

					<span class="enscript-keyword">if</span> (current_len + len &gt; total_len) {
						IFMA_UNLOCK(ifma);
						error = ENOBUFS;
						<span class="enscript-keyword">break</span>;
					}
					len = rt_msg2(RTM_NEWMADDR2, &amp;info,
					    (caddr_t)cp, NULL, &amp;cred);

					ifmam =
					    (<span class="enscript-type">struct</span> ifma_msghdr2 *)(<span class="enscript-type">void</span> *)cp;
					ifmam-&gt;ifmam_addrs = info.rti_addrs;
					ifmam-&gt;ifmam_flags = 0;
					ifmam-&gt;ifmam_index =
					    ifma-&gt;ifma_ifp-&gt;if_index;
					ifmam-&gt;ifmam_refcount =
					    ifma-&gt;ifma_reqcnt;

					cp += len;
					VERIFY(IS_P2ALIGNED(cp,
					    <span class="enscript-keyword">sizeof</span> (u_int32_t)));
					current_len += len;
				}
				IFMA_UNLOCK(ifma);
			}
			ifnet_lock_done(ifp);
			info.rti_info[RTAX_IFA] = info.rti_info[RTAX_NETMASK] =
			    info.rti_info[RTAX_BRD] = NULL;
		}
		ifnet_head_done();

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == ENOBUFS)
				printf(<span class="enscript-string">&quot;%s: current_len (%d) + len (%d) &gt; &quot;</span>
				    <span class="enscript-string">&quot;total_len (%d)\n&quot;</span>, __func__, current_len,
				    len, total_len);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (pass == 0) {
			<span class="enscript-comment">/* Better to return zero length buffer than ENOBUFS */</span>
			<span class="enscript-keyword">if</span> (total_len == 0)
				total_len = 1;
			total_len += total_len &gt;&gt; 3;
			total_buffer = _MALLOC(total_len, M_RTABLE,
			    M_ZERO | M_WAITOK);
			<span class="enscript-keyword">if</span> (total_buffer == NULL) {
				printf(<span class="enscript-string">&quot;%s: _MALLOC(%d) failed\n&quot;</span>, __func__,
				    total_len);
				error = ENOBUFS;
				<span class="enscript-keyword">break</span>;
			}
			cp = total_buffer;
			VERIFY(IS_P2ALIGNED(cp, <span class="enscript-keyword">sizeof</span> (u_int32_t)));
		} <span class="enscript-keyword">else</span> {
			error = SYSCTL_OUT(w-&gt;w_req, total_buffer, current_len);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (total_buffer != NULL)
		_FREE(total_buffer, M_RTABLE);

	kauth_cred_unref(&amp;cred);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_rtstat</span>(<span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-keyword">return</span> (SYSCTL_OUT(req, &amp;rtstat, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> rtstat)));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_rttrash</span>(<span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-keyword">return</span> (SYSCTL_OUT(req, &amp;rttrash, <span class="enscript-keyword">sizeof</span> (rttrash)));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_rtsock SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>)
	<span class="enscript-type">int</span>	*name = (<span class="enscript-type">int</span> *)arg1;
	u_int	namelen = arg2;
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	<span class="enscript-type">int</span>	i, error = EINVAL;
	u_char  af;
	<span class="enscript-type">struct</span>	walkarg w;

	name ++;
	namelen--;
	<span class="enscript-keyword">if</span> (req-&gt;newptr)
		<span class="enscript-keyword">return</span> (EPERM);
	<span class="enscript-keyword">if</span> (namelen != 3)
		<span class="enscript-keyword">return</span> (EINVAL);
	af = name[0];
	Bzero(&amp;w, <span class="enscript-keyword">sizeof</span> (w));
	w.w_op = name[1];
	w.w_arg = name[2];
	w.w_req = req;

	<span class="enscript-keyword">switch</span> (w.w_op) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">NET_RT_DUMP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NET_RT_DUMP2</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NET_RT_FLAGS</span>:
		lck_mtx_lock(rnh_lock);
		<span class="enscript-keyword">for</span> (i = 1; i &lt;= AF_MAX; i++)
			<span class="enscript-keyword">if</span> ((rnh = rt_tables[i]) &amp;&amp; (af == 0 || af == i) &amp;&amp;
			    (error = rnh-&gt;rnh_walktree(rnh,
			    sysctl_dumpentry, &amp;w)))
				<span class="enscript-keyword">break</span>;
		lck_mtx_unlock(rnh_lock);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NET_RT_DUMPX</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NET_RT_DUMPX_FLAGS</span>:
		lck_mtx_lock(rnh_lock);
		<span class="enscript-keyword">for</span> (i = 1; i &lt;= AF_MAX; i++)
			<span class="enscript-keyword">if</span> ((rnh = rt_tables[i]) &amp;&amp; (af == 0 || af == i) &amp;&amp;
			    (error = rnh-&gt;rnh_walktree(rnh,
			    sysctl_dumpentry_ext, &amp;w)))
				<span class="enscript-keyword">break</span>;
		lck_mtx_unlock(rnh_lock);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NET_RT_IFLIST</span>:
		error = sysctl_iflist(af, &amp;w);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NET_RT_IFLIST2</span>:
		error = sysctl_iflist2(af, &amp;w);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NET_RT_STAT</span>:
		error = sysctl_rtstat(req);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NET_RT_TRASH</span>:
		error = sysctl_rttrash(req);
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (w.w_tmem != NULL)
		FREE(w.w_tmem, M_RTABLE);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Definitions of protocols supported in the ROUTE domain.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> protosw routesw[] = {
{
	.pr_type =		SOCK_RAW,
	.pr_protocol =		0,
	.pr_flags =		PR_ATOMIC|PR_ADDR,
	.pr_output =		route_output,
	.pr_ctlinput =		raw_ctlinput,
	.pr_init =		raw_init,
	.pr_usrreqs =		&amp;route_usrreqs,
}
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> route_proto_count = (<span class="enscript-keyword">sizeof</span> (routesw) / <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> protosw));

<span class="enscript-type">struct</span> domain routedomain_s = {
	.dom_family =		PF_ROUTE,
	.dom_name =		<span class="enscript-string">&quot;route&quot;</span>,
	.dom_init =		route_dinit,
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">route_dinit</span>(<span class="enscript-type">struct</span> domain *dp)
{
	<span class="enscript-type">struct</span> protosw *pr;
	<span class="enscript-type">int</span> i;

	VERIFY(!(dp-&gt;dom_flags &amp; DOM_INITIALIZED));
	VERIFY(routedomain == NULL);

	routedomain = dp;

	<span class="enscript-keyword">for</span> (i = 0, pr = &amp;routesw[0]; i &lt; route_proto_count; i++, pr++)
		net_add_proto(pr, dp, 1);

	route_init();
}
</pre>
<hr />
</body></html>