<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>if_bond.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">if_bond.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * if_bond.c 
 * - bond/failover interface
 * - implements IEEE 802.3ad Link Aggregation
 */</span>

<span class="enscript-comment">/*
 * Modification History:
 *
 * April 29, 2004	Dieter Siegmund (<a href="mailto:dieter@apple.com">dieter@apple.com</a>)
 * - created
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bpf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ethernet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_interface.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_arp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_ether.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_bond_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ieee8023ad.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/lacp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/devtimer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_vlan_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_protocol.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/if_ether.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_media.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/multicast_list.h&gt;</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ether_addr slow_proto_multicast = {
    IEEE8023AD_SLOW_PROTO_MULTICAST
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BOND_MAXUNIT</span>		128
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BONDNAME</span>		<span class="enscript-string">&quot;bond&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">M_BOND</span>	 		M_DEVBUF

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EA_FORMAT</span>	<span class="enscript-string">&quot;%x:%x:%x:%x:%x:%x&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">EA_CH</span>(e, i)	((u_char)((u_char *)(e))[(i)])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">EA_LIST</span>(ea)	EA_CH(ea,0),EA_CH(ea,1),EA_CH(ea,2),EA_CH(ea,3),EA_CH(ea,4),EA_CH(ea,5)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">timestamp_printf</span>	printf

<span class="enscript-comment">/**
 ** bond locks
 **/</span>
<span class="enscript-type">static</span> __inline__ lck_grp_t *
<span class="enscript-function-name">my_lck_grp_alloc_init</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * grp_name)
{
    lck_grp_t *		grp;
    lck_grp_attr_t *	grp_attrs;
    
    grp_attrs = lck_grp_attr_alloc_init();
    grp = lck_grp_alloc_init(grp_name, grp_attrs);
    lck_grp_attr_free(grp_attrs);
    <span class="enscript-keyword">return</span> (grp);
}

<span class="enscript-type">static</span> __inline__ lck_mtx_t *
<span class="enscript-function-name">my_lck_mtx_alloc_init</span>(lck_grp_t * lck_grp)
{
    lck_attr_t * 	lck_attrs;
    lck_mtx_t *		lck_mtx;

    lck_attrs = lck_attr_alloc_init();
    lck_mtx = lck_mtx_alloc_init(lck_grp, lck_attrs);
    lck_attr_free(lck_attrs);
    <span class="enscript-keyword">return</span> (lck_mtx);
}

<span class="enscript-type">static</span> lck_mtx_t * 	bond_lck_mtx;

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_lock_init</span>(<span class="enscript-type">void</span>)
{
    lck_grp_t *		bond_lck_grp;

    bond_lck_grp = my_lck_grp_alloc_init(<span class="enscript-string">&quot;if_bond&quot;</span>);
    bond_lck_mtx = my_lck_mtx_alloc_init(bond_lck_grp);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_assert_lock_held</span>(<span class="enscript-type">void</span>)
{
    lck_mtx_assert(bond_lck_mtx, LCK_MTX_ASSERT_OWNED);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_assert_lock_not_held</span>(<span class="enscript-type">void</span>)
{
    lck_mtx_assert(bond_lck_mtx, LCK_MTX_ASSERT_NOTOWNED);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_lock</span>(<span class="enscript-type">void</span>)
{
    lck_mtx_lock(bond_lck_mtx);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_unlock</span>(<span class="enscript-type">void</span>)
{
    lck_mtx_unlock(bond_lck_mtx);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/**
 ** bond structures, types
 **/</span>

<span class="enscript-type">struct</span> LAG_info_s {
    lacp_system			li_system;
    lacp_system_priority	li_system_priority;
    lacp_key			li_key;
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> LAG_info_s LAG_info, * LAG_info_ref;

<span class="enscript-type">struct</span> bondport_s;
<span class="enscript-function-name">TAILQ_HEAD</span>(port_list, bondport_s);
<span class="enscript-type">struct</span> ifbond_s;
<span class="enscript-function-name">TAILQ_HEAD</span>(ifbond_list, ifbond_s);
<span class="enscript-type">struct</span> LAG_s;
<span class="enscript-function-name">TAILQ_HEAD</span>(lag_list, LAG_s);

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ifbond_s ifbond, * ifbond_ref;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> bondport_s bondport, * bondport_ref;

<span class="enscript-type">struct</span> LAG_s {
    TAILQ_ENTRY(LAG_s)		lag_list;
    <span class="enscript-type">struct</span> port_list		lag_port_list;
    <span class="enscript-type">short</span>			lag_port_count;
    <span class="enscript-type">short</span>			lag_selected_port_count;
    <span class="enscript-type">int</span>				lag_active_media;
    LAG_info			lag_info;
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> LAG_s LAG, * LAG_ref;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> partner_state_s {
    LAG_info			ps_lag_info;
    lacp_port			ps_port;
    lacp_port_priority		ps_port_priority;
    lacp_actor_partner_state	ps_state;
} partner_state, * partner_state_ref;

<span class="enscript-type">struct</span> ifbond_s {
    TAILQ_ENTRY(ifbond_s) 	ifb_bond_list;
    <span class="enscript-type">int</span>				ifb_flags;
    SInt32			ifb_retain_count;
    <span class="enscript-type">char</span> 			ifb_name[IFNAMSIZ];
    <span class="enscript-type">struct</span> ifnet *		ifb_ifp;
    bpf_packet_func		ifb_bpf_input;
    bpf_packet_func 		ifb_bpf_output;
    <span class="enscript-type">int</span>				ifb_altmtu;
    <span class="enscript-type">struct</span> port_list		ifb_port_list;
    <span class="enscript-type">short</span>			ifb_port_count;
    <span class="enscript-type">struct</span> lag_list		ifb_lag_list;
    lacp_key			ifb_key;
    <span class="enscript-type">short</span>			ifb_max_active; <span class="enscript-comment">/* 0 == unlimited */</span>
    LAG_ref			ifb_active_lag;
    <span class="enscript-type">struct</span> ifmultiaddr *	ifb_ifma_slow_proto;
    bondport_ref *		ifb_distributing_array;
    <span class="enscript-type">int</span>				ifb_distributing_count;
    <span class="enscript-type">int</span>				ifb_last_link_event;
    <span class="enscript-type">int</span>				ifb_mode; <span class="enscript-comment">/* LACP, STATIC */</span>
};

<span class="enscript-type">struct</span> media_info {
    <span class="enscript-type">int</span>		mi_active;
    <span class="enscript-type">int</span>		mi_status;
};

<span class="enscript-type">enum</span> {
    ReceiveState_none = 0,
    ReceiveState_INITIALIZE = 1,
    ReceiveState_PORT_DISABLED = 2,
    ReceiveState_EXPIRED = 3,
    ReceiveState_LACP_DISABLED = 4,
    ReceiveState_DEFAULTED = 5,
    ReceiveState_CURRENT = 6,
};

<span class="enscript-type">typedef</span> u_char ReceiveState;

<span class="enscript-type">enum</span> {
    SelectedState_UNSELECTED = IF_BOND_STATUS_SELECTED_STATE_UNSELECTED,
    SelectedState_SELECTED = IF_BOND_STATUS_SELECTED_STATE_SELECTED,
    SelectedState_STANDBY = IF_BOND_STATUS_SELECTED_STATE_STANDBY
};
<span class="enscript-type">typedef</span> u_char SelectedState;

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">SelectedStateString</span>(SelectedState s)
{
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * names[] = { <span class="enscript-string">&quot;UNSELECTED&quot;</span>, <span class="enscript-string">&quot;SELECTED&quot;</span>, <span class="enscript-string">&quot;STANDBY&quot;</span> };

    <span class="enscript-keyword">if</span> (s &lt;= SelectedState_STANDBY) {
	<span class="enscript-keyword">return</span> (names[s]);
    }
    <span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;&lt;unknown&gt;&quot;</span>);
}

<span class="enscript-type">enum</span> {
    MuxState_none = 0,
    MuxState_DETACHED = 1,
    MuxState_WAITING = 2,
    MuxState_ATTACHED = 3,
    MuxState_COLLECTING_DISTRIBUTING = 4,
};

<span class="enscript-type">typedef</span> u_char MuxState;

<span class="enscript-type">struct</span> bondport_s {
    TAILQ_ENTRY(bondport_s) 	po_port_list;
    ifbond_ref			po_bond;
    <span class="enscript-type">struct</span> multicast_list 	po_multicast;
    <span class="enscript-type">struct</span> ifnet *		po_ifp;
    <span class="enscript-type">struct</span> ether_addr		po_saved_addr;
    <span class="enscript-type">int</span>				po_enabled;
    <span class="enscript-type">char</span>			po_name[IFNAMSIZ];
    <span class="enscript-type">struct</span> ifdevmtu		po_devmtu;

    <span class="enscript-comment">/* LACP */</span>
    TAILQ_ENTRY(bondport_s) 	po_lag_port_list;
    devtimer_ref		po_current_while_timer;
    devtimer_ref		po_periodic_timer;
    devtimer_ref		po_wait_while_timer;
    devtimer_ref		po_transmit_timer;
    partner_state		po_partner_state;
    lacp_port_priority		po_priority;
    lacp_actor_partner_state	po_actor_state;
    u_char			po_flags;
    u_char			po_periodic_interval;
    u_char			po_n_transmit;
    ReceiveState		po_receive_state;
    MuxState			po_mux_state;
    SelectedState		po_selected;
    int32_t			po_last_transmit_secs;
    <span class="enscript-type">struct</span> media_info		po_media_info;
    LAG_ref			po_lag;
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFBF_PROMISC</span>		0x1	<span class="enscript-comment">/* promiscuous mode */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IFBF_IF_DETACHING</span>	0x2	<span class="enscript-comment">/* interface is detaching */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IFBF_LLADDR</span>		0x4	<span class="enscript-comment">/* specific link address requested */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IFBF_CHANGE_IN_PROGRESS</span>	0x8	<span class="enscript-comment">/* interface add/remove in progress */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bond_get_status</span>(ifbond_ref ifb, <span class="enscript-type">struct</span> if_bond_req * ibr_p, 
			   user_addr_t datap);

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">ifbond_flags_if_detaching</span>(ifbond_ref ifb)
{
    <span class="enscript-keyword">return</span> ((ifb-&gt;ifb_flags &amp; IFBF_IF_DETACHING) != 0);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ifbond_flags_set_if_detaching</span>(ifbond_ref ifb)
{
    ifb-&gt;ifb_flags |= IFBF_IF_DETACHING;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">ifbond_flags_lladdr</span>(ifbond_ref ifb)
{
    <span class="enscript-keyword">return</span> ((ifb-&gt;ifb_flags &amp; IFBF_LLADDR) != 0);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">ifbond_flags_change_in_progress</span>(ifbond_ref ifb)
{
    <span class="enscript-keyword">return</span> ((ifb-&gt;ifb_flags &amp; IFBF_CHANGE_IN_PROGRESS) != 0);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ifbond_flags_set_change_in_progress</span>(ifbond_ref ifb)
{
    ifb-&gt;ifb_flags |= IFBF_CHANGE_IN_PROGRESS;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ifbond_flags_clear_change_in_progress</span>(ifbond_ref ifb)
{
    ifb-&gt;ifb_flags &amp;= ~IFBF_CHANGE_IN_PROGRESS;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * bondport_ref-&gt;po_flags bits
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BONDPORT_FLAGS_NTT</span>		0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BONDPORT_FLAGS_READY</span>		0x02
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BONDPORT_FLAGS_SELECTED_CHANGED</span>	0x04
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BONDPORT_FLAGS_MUX_ATTACHED</span>	0x08
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BONDPORT_FLAGS_DISTRIBUTING</span>	0x10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BONDPORT_FLAGS_UNUSED2</span>		0x20
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BONDPORT_FLAGS_UNUSED3</span>		0x40
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BONDPORT_FLAGS_UNUSED4</span>		0x80

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_flags_set_ntt</span>(bondport_ref p)
{
    p-&gt;po_flags |= BONDPORT_FLAGS_NTT;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_flags_clear_ntt</span>(bondport_ref p)
{
    p-&gt;po_flags &amp;= ~BONDPORT_FLAGS_NTT;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_flags_ntt</span>(bondport_ref p)
{
    <span class="enscript-keyword">return</span> ((p-&gt;po_flags &amp; BONDPORT_FLAGS_NTT) != 0);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_flags_set_ready</span>(bondport_ref p)
{
    p-&gt;po_flags |= BONDPORT_FLAGS_READY;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_flags_clear_ready</span>(bondport_ref p)
{
    p-&gt;po_flags &amp;= ~BONDPORT_FLAGS_READY;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_flags_ready</span>(bondport_ref p)
{
    <span class="enscript-keyword">return</span> ((p-&gt;po_flags &amp; BONDPORT_FLAGS_READY) != 0);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_flags_set_selected_changed</span>(bondport_ref p)
{
    p-&gt;po_flags |= BONDPORT_FLAGS_SELECTED_CHANGED;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_flags_clear_selected_changed</span>(bondport_ref p)
{
    p-&gt;po_flags &amp;= ~BONDPORT_FLAGS_SELECTED_CHANGED;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_flags_selected_changed</span>(bondport_ref p)
{
    <span class="enscript-keyword">return</span> ((p-&gt;po_flags &amp; BONDPORT_FLAGS_SELECTED_CHANGED) != 0);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_flags_set_mux_attached</span>(bondport_ref p)
{
    p-&gt;po_flags |= BONDPORT_FLAGS_MUX_ATTACHED;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_flags_clear_mux_attached</span>(bondport_ref p)
{
    p-&gt;po_flags &amp;= ~BONDPORT_FLAGS_MUX_ATTACHED;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_flags_mux_attached</span>(bondport_ref p)
{
    <span class="enscript-keyword">return</span> ((p-&gt;po_flags &amp; BONDPORT_FLAGS_MUX_ATTACHED) != 0);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_flags_set_distributing</span>(bondport_ref p)
{
    p-&gt;po_flags |= BONDPORT_FLAGS_DISTRIBUTING;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_flags_clear_distributing</span>(bondport_ref p)
{
    p-&gt;po_flags &amp;= ~BONDPORT_FLAGS_DISTRIBUTING;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_flags_distributing</span>(bondport_ref p)
{
    <span class="enscript-keyword">return</span> ((p-&gt;po_flags &amp; BONDPORT_FLAGS_DISTRIBUTING) != 0);
}

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> bond_globals_s {
    <span class="enscript-type">struct</span> ifbond_list		ifbond_list;
    lacp_system			system;
    lacp_system_priority	system_priority;
    <span class="enscript-type">int</span>				verbose;
} * bond_globals_ref;

<span class="enscript-type">static</span> bond_globals_ref	g_bond;

<span class="enscript-comment">/**
 ** packet_buffer routines
 ** - thin wrapper for mbuf
 **/</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mbuf * packet_buffer_ref;

<span class="enscript-type">static</span> packet_buffer_ref
<span class="enscript-function-name">packet_buffer_allocate</span>(<span class="enscript-type">int</span> length)
{
    packet_buffer_ref	m;
    <span class="enscript-type">int</span>			size;

    <span class="enscript-comment">/* leave room for ethernet header */</span>
    size = length + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header);
    <span class="enscript-keyword">if</span> (size &gt; (<span class="enscript-type">int</span>)MHLEN) {
	<span class="enscript-keyword">if</span> (size &gt; (<span class="enscript-type">int</span>)MCLBYTES) {
	    printf(<span class="enscript-string">&quot;bond: packet_buffer_allocate size %d &gt; max %u\n&quot;</span>,
	           size, MCLBYTES);
	    <span class="enscript-keyword">return</span> (NULL);
	}
	m = m_getcl(M_WAITOK, MT_DATA, M_PKTHDR);
    } <span class="enscript-keyword">else</span> {
	m = m_gethdr(M_WAITOK, MT_DATA);
    }
    <span class="enscript-keyword">if</span> (m == NULL) {
	<span class="enscript-keyword">return</span> (NULL);
    }
    m-&gt;m_len = size;
    m-&gt;m_pkthdr.len = size;
    <span class="enscript-keyword">return</span> (m);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">packet_buffer_byteptr</span>(packet_buffer_ref buf)
{
    <span class="enscript-keyword">return</span> (buf-&gt;m_data + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header));
}

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
    LAEventStart,
    LAEventTimeout,
    LAEventPacket,
    LAEventMediaChange,
    LAEventSelectedChange,
    LAEventPortMoved,
    LAEventReady
} LAEvent;

<span class="enscript-comment">/**
 ** Receive machine
 **/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine</span>(bondport_ref p, LAEvent event,
			 <span class="enscript-type">void</span> * event_data);
<span class="enscript-comment">/**
 ** Periodic Transmission machine
 **/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_periodic_transmit_machine</span>(bondport_ref p, LAEvent event,
				   <span class="enscript-type">void</span> * event_data);

<span class="enscript-comment">/**
 ** Transmit machine
 **/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TRANSMIT_MACHINE_TX_IMMEDIATE</span>	((void *)1)

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_transmit_machine</span>(bondport_ref p, LAEvent event,
			  <span class="enscript-type">void</span> * event_data);

<span class="enscript-comment">/**
 ** Mux machine
 **/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_mux_machine</span>(bondport_ref p, LAEvent event,
		     <span class="enscript-type">void</span> * event_data);

<span class="enscript-comment">/**
 ** bond, LAG
 **/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifbond_activate_LAG</span>(ifbond_ref bond, LAG_ref lag, <span class="enscript-type">int</span> active_media);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifbond_deactivate_LAG</span>(ifbond_ref bond, LAG_ref lag);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ifbond_all_ports_ready</span>(ifbond_ref bond);

<span class="enscript-type">static</span> LAG_ref
<span class="enscript-function-name">ifbond_find_best_LAG</span>(ifbond_ref bond, <span class="enscript-type">int</span> * active_media);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">LAG_get_aggregatable_port_count</span>(LAG_ref lag, <span class="enscript-type">int</span> * active_media);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ifbond_selection</span>(ifbond_ref bond);


<span class="enscript-comment">/**
 ** bondport
 **/</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_lacpdu</span>(bondport_ref p, lacpdu_ref in_lacpdu_p);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_slow_proto_transmit</span>(bondport_ref p, packet_buffer_ref buf);

<span class="enscript-type">static</span> bondport_ref
<span class="enscript-function-name">bondport_create</span>(<span class="enscript-type">struct</span> ifnet * port_ifp, lacp_port_priority priority,
		<span class="enscript-type">int</span> active, <span class="enscript-type">int</span> short_timeout, <span class="enscript-type">int</span> * error);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_start</span>(bondport_ref p);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_free</span>(bondport_ref p);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_aggregatable</span>(bondport_ref p);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_remove_from_LAG</span>(bondport_ref p);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">bondport_set_selected</span>(bondport_ref p, SelectedState s);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_matches_LAG</span>(bondport_ref p, LAG_ref lag);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_link_status_changed</span>(bondport_ref p);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_enable_distributing</span>(bondport_ref p);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_disable_distributing</span>(bondport_ref p);

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_collecting</span>(bondport_ref p)
{
    <span class="enscript-keyword">if</span> (p-&gt;po_bond-&gt;ifb_mode == IF_BOND_MODE_LACP) {
	<span class="enscript-keyword">return</span> (lacp_actor_partner_state_collecting(p-&gt;po_actor_state));
    }
    <span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-comment">/**
 ** bond interface/dlil specific routines
 **/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bond_clone_create</span>(<span class="enscript-type">struct</span> if_clone *, u_int32_t, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bond_clone_destroy</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bond_input</span>(ifnet_t ifp, protocol_family_t protocol, mbuf_t m,
					  <span class="enscript-type">char</span> *frame_header);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bond_output</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bond_ioctl</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, <span class="enscript-type">void</span> * addr);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bond_set_bpf_tap</span>(<span class="enscript-type">struct</span> ifnet * ifp, bpf_tap_mode mode,
			    bpf_packet_func func);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bond_attach_protocol</span>(<span class="enscript-type">struct</span> ifnet *ifp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bond_detach_protocol</span>(<span class="enscript-type">struct</span> ifnet *ifp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bond_setmulti</span>(<span class="enscript-type">struct</span> ifnet *ifp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bond_add_interface</span>(<span class="enscript-type">struct</span> ifnet * ifp, <span class="enscript-type">struct</span> ifnet * port_ifp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bond_remove_interface</span>(ifbond_ref ifb, <span class="enscript-type">struct</span> ifnet * port_ifp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bond_if_free</span>(<span class="enscript-type">struct</span> ifnet * ifp);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> if_clone bond_cloner = IF_CLONE_INITIALIZER(BONDNAME,
							  bond_clone_create, 
							  bond_clone_destroy, 
							  0,
							  BOND_MAXUNIT);
<span class="enscript-type">static</span>	<span class="enscript-type">void</span> interface_link_event(<span class="enscript-type">struct</span> ifnet * ifp, u_int32_t event_code);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">siocsifmtu</span>(<span class="enscript-type">struct</span> ifnet * ifp, <span class="enscript-type">int</span> mtu)
{
    <span class="enscript-type">struct</span> ifreq	ifr;

    bzero(&amp;ifr, <span class="enscript-keyword">sizeof</span>(ifr));
    ifr.ifr_mtu = mtu;
    <span class="enscript-keyword">return</span> (ifnet_ioctl(ifp, 0, SIOCSIFMTU, &amp;ifr));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">siocgifdevmtu</span>(<span class="enscript-type">struct</span> ifnet * ifp, <span class="enscript-type">struct</span> ifdevmtu * ifdm_p)
{
    <span class="enscript-type">struct</span> ifreq	ifr;
    <span class="enscript-type">int</span> 		error;

    bzero(&amp;ifr, <span class="enscript-keyword">sizeof</span>(ifr));
    error = ifnet_ioctl(ifp, 0, SIOCGIFDEVMTU, &amp;ifr);
    <span class="enscript-keyword">if</span> (error == 0) {
	*ifdm_p = ifr.ifr_devmtu;
    }
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ether_addr_copy</span>(<span class="enscript-type">void</span> * dest, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * source)
{
    bcopy(source, dest, ETHER_ADDR_LEN);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ifbond_retain</span>(ifbond_ref ifb)
{
    OSIncrementAtomic(&amp;ifb-&gt;ifb_retain_count);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ifbond_release</span>(ifbond_ref ifb)
{
    UInt32		old_retain_count;

    old_retain_count = OSDecrementAtomic(&amp;ifb-&gt;ifb_retain_count);
    <span class="enscript-keyword">switch</span> (old_retain_count) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
	panic(<span class="enscript-string">&quot;ifbond_release: retain count is 0\n&quot;</span>);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    printf(<span class="enscript-string">&quot;ifbond_release(%s)\n&quot;</span>, ifb-&gt;ifb_name);
	}
	<span class="enscript-keyword">if</span> (ifb-&gt;ifb_ifma_slow_proto != NULL) {
	    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		printf(<span class="enscript-string">&quot;ifbond_release(%s) removing multicast\n&quot;</span>,
		       ifb-&gt;ifb_name);
	    }
	    (<span class="enscript-type">void</span>) if_delmulti_anon(ifb-&gt;ifb_ifma_slow_proto-&gt;ifma_ifp,
	        ifb-&gt;ifb_ifma_slow_proto-&gt;ifma_addr);
	    IFMA_REMREF(ifb-&gt;ifb_ifma_slow_proto);
	}
	<span class="enscript-keyword">if</span> (ifb-&gt;ifb_distributing_array != NULL) {
	    FREE(ifb-&gt;ifb_distributing_array, M_BOND);
	}
	FREE(ifb, M_BOND);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Function: ifbond_wait
 * Purpose:
 *   Allows a single thread to gain exclusive access to the ifbond
 *   data structure.  Some operations take a long time to complete, 
 *   and some have side-effects that we can't predict.  Holding the
 *   bond_lock() across such operations is not possible.
 *
 *   For example:
 *   1) The SIOCSIFLLADDR ioctl takes a long time (several seconds) to 
 *      complete.  Simply holding the bond_lock() would freeze all other
 *      data structure accesses during that time.
 *   2) When we attach our protocol to the interface, a dlil event is
 *      generated and invokes our bond_event() function.  bond_event()
 *      needs to take the bond_lock(), but we're already holding it, so
 *      we're deadlocked against ourselves.
 * Notes:
 *   Before calling, you must be holding the bond_lock and have taken
 *   a reference on the ifbond_ref.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifbond_wait</span>(ifbond_ref ifb, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * msg)
{
    <span class="enscript-type">int</span>		waited = 0;

    <span class="enscript-comment">/* other add/remove in progress */</span>
    <span class="enscript-keyword">while</span> (ifbond_flags_change_in_progress(ifb)) {
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    printf(<span class="enscript-string">&quot;%s: %s msleep\n&quot;</span>, ifb-&gt;ifb_name, msg);
	}
	waited = 1;
	(<span class="enscript-type">void</span>)msleep(ifb, bond_lck_mtx, PZERO, msg, 0);
    }
    <span class="enscript-comment">/* prevent other bond list remove/add from taking place */</span>
    ifbond_flags_set_change_in_progress(ifb);
    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose &amp;&amp; waited) {
	printf(<span class="enscript-string">&quot;%s: %s woke up\n&quot;</span>, ifb-&gt;ifb_name, msg);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Function: ifbond_signal
 * Purpose:
 *   Allows the thread that previously invoked ifbond_wait() to 
 *   give up exclusive access to the ifbond data structure, and wake up
 *   any other threads waiting to access
 * Notes:
 *   Before calling, you must be holding the bond_lock and have taken
 *   a reference on the ifbond_ref.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifbond_signal</span>(ifbond_ref ifb, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * msg)
{
    ifbond_flags_clear_change_in_progress(ifb);
    wakeup((caddr_t)ifb);
    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	printf(<span class="enscript-string">&quot;%s: %s wakeup\n&quot;</span>, ifb-&gt;ifb_name, msg);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/**
 ** Media information
 **/</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">link_speed</span>(<span class="enscript-type">int</span> active)
{
    <span class="enscript-keyword">switch</span> (IFM_SUBTYPE(active)) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_10_T</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_10_2</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_10_5</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_10_STP</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_10_FL</span>:
	<span class="enscript-keyword">return</span> (10);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_100_TX</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_100_FX</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_100_T4</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_100_VG</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_100_T2</span>:
	<span class="enscript-keyword">return</span> (100);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_1000_SX</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_1000_LX</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_1000_CX</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_1000_TX</span>:
	<span class="enscript-keyword">return</span> (1000);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_HPNA_1</span>:
	<span class="enscript-keyword">return</span> (0);
    <span class="enscript-reference">default</span>:
	<span class="enscript-comment">/* assume that new defined types are going to be at least 10GigE */</span>
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_10G_SR</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_10G_LR</span>:
	<span class="enscript-keyword">return</span> (10000);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_2500_T</span>:
	<span class="enscript-keyword">return</span> (2500);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">IFM_5000_T</span>:
	<span class="enscript-keyword">return</span> (5000);
    }
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">media_active</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> media_info * mi)
{
    <span class="enscript-keyword">if</span> ((mi-&gt;mi_status &amp; IFM_AVALID) == 0) {
	<span class="enscript-keyword">return</span> (1);
    }
    <span class="enscript-keyword">return</span> ((mi-&gt;mi_status &amp; IFM_ACTIVE) != 0);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">media_full_duplex</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> media_info * mi)
{
    <span class="enscript-keyword">return</span> ((mi-&gt;mi_active &amp; IFM_FDX) != 0);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">media_speed</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> media_info * mi)
{
    <span class="enscript-keyword">return</span> (link_speed(mi-&gt;mi_active));
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> media_info
<span class="enscript-function-name">interface_media_info</span>(<span class="enscript-type">struct</span> ifnet * ifp)
{
    <span class="enscript-type">struct</span> ifmediareq	ifmr;
    <span class="enscript-type">struct</span> media_info	mi;

    bzero(&amp;mi, <span class="enscript-keyword">sizeof</span>(mi));
    bzero(&amp;ifmr, <span class="enscript-keyword">sizeof</span>(ifmr));
    <span class="enscript-keyword">if</span> (ifnet_ioctl(ifp, 0, SIOCGIFMEDIA, &amp;ifmr) == 0) {
	<span class="enscript-keyword">if</span> (ifmr.ifm_count != 0) {
	    mi.mi_status = ifmr.ifm_status;
	    mi.mi_active = ifmr.ifm_active;
	}
    }
    <span class="enscript-keyword">return</span> (mi);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">if_siflladdr</span>(<span class="enscript-type">struct</span> ifnet * ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ether_addr * ea_p)
{
    <span class="enscript-type">struct</span> ifreq	ifr;

    <span class="enscript-comment">/*
     * XXX setting the sa_len to ETHER_ADDR_LEN is wrong, but the driver
     * currently expects it that way
     */</span>
    ifr.ifr_addr.sa_family = AF_UNSPEC;
    ifr.ifr_addr.sa_len = ETHER_ADDR_LEN;
    ether_addr_copy(ifr.ifr_addr.sa_data, ea_p);
    <span class="enscript-keyword">return</span> (ifnet_ioctl(ifp, 0, SIOCSIFLLADDR, &amp;ifr));
}

<span class="enscript-comment">/**
 ** bond_globals
 **/</span>
<span class="enscript-type">static</span> bond_globals_ref
<span class="enscript-function-name">bond_globals_create</span>(lacp_system_priority sys_pri,
		    lacp_system_ref sys)
{
    bond_globals_ref	b;

    b = _MALLOC(<span class="enscript-keyword">sizeof</span>(*b), M_BOND, M_WAITOK | M_ZERO);
    <span class="enscript-keyword">if</span> (b == NULL) {
	<span class="enscript-keyword">return</span> (NULL);
    }
    TAILQ_INIT(&amp;b-&gt;ifbond_list);
    b-&gt;system = *sys;
    b-&gt;system_priority = sys_pri;
    <span class="enscript-keyword">return</span> (b);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_globals_init</span>(<span class="enscript-type">void</span>)
{
    bond_globals_ref	b;
    <span class="enscript-type">int</span>			i;
    <span class="enscript-type">struct</span> ifnet * 	ifp;

    bond_assert_lock_not_held();

    <span class="enscript-keyword">if</span> (g_bond != NULL) {
	<span class="enscript-keyword">return</span> (0);
    }

    <span class="enscript-comment">/*
     * use en0's ethernet address as the system identifier, and if it's not
     * there, use en1 .. en3
     */</span>
    ifp = NULL;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; 4; i++) {
	<span class="enscript-type">char</span> 		ifname[IFNAMSIZ+1];
	snprintf(ifname, <span class="enscript-keyword">sizeof</span>(ifname), <span class="enscript-string">&quot;en%d&quot;</span>, i);
	ifp = ifunit(ifname);
	<span class="enscript-keyword">if</span> (ifp != NULL) {
	    <span class="enscript-keyword">break</span>;
	}
    }
    b = NULL;
    <span class="enscript-keyword">if</span> (ifp != NULL) {
	b = bond_globals_create(0x8000, (lacp_system_ref)IF_LLADDR(ifp));
    }
    bond_lock();
    <span class="enscript-keyword">if</span> (g_bond != NULL) {
	bond_unlock();
	_FREE(b, M_BOND);
	<span class="enscript-keyword">return</span> (0);
    }
    g_bond = b;
    bond_unlock();
    <span class="enscript-keyword">if</span> (ifp == NULL) {
	<span class="enscript-keyword">return</span> (ENXIO);
    }
    <span class="enscript-keyword">if</span> (b == NULL) {
	<span class="enscript-keyword">return</span> (ENOMEM);
    }
    <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_bpf_vlan</span>(<span class="enscript-type">struct</span> ifnet * ifp, <span class="enscript-type">struct</span> mbuf * m,
	      <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ether_header * eh_p,
	      u_int16_t vlan_tag, bpf_packet_func func)
{
    <span class="enscript-type">struct</span> ether_vlan_header *	vlh_p;
    <span class="enscript-type">struct</span> mbuf *		vl_m;

    vl_m = m_get(M_DONTWAIT, MT_DATA);
    <span class="enscript-keyword">if</span> (vl_m == NULL) {
	<span class="enscript-keyword">return</span>;
    }
    <span class="enscript-comment">/* populate a new mbuf containing the vlan ethernet header */</span>
    vl_m-&gt;m_len = ETHER_HDR_LEN + ETHER_VLAN_ENCAP_LEN;
    vlh_p = mtod(vl_m, <span class="enscript-type">struct</span> ether_vlan_header *);
    bcopy(eh_p, vlh_p, offsetof(<span class="enscript-type">struct</span> ether_header, ether_type));
    vlh_p-&gt;evl_encap_proto = htons(ETHERTYPE_VLAN);
    vlh_p-&gt;evl_tag = htons(vlan_tag);
    vlh_p-&gt;evl_proto = eh_p-&gt;ether_type;
    vl_m-&gt;m_next = m;
    (*func)(ifp, vl_m);
    vl_m-&gt;m_next = NULL;
    m_free(vl_m);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> 
<span class="enscript-function-name">bond_bpf_output</span>(<span class="enscript-type">struct</span> ifnet * ifp, <span class="enscript-type">struct</span> mbuf * m, 
		bpf_packet_func func)
{
    <span class="enscript-keyword">if</span> (func != NULL) {
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_VLAN_TAG_VALID) {
	    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ether_header * eh_p;
	    eh_p = mtod(m, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ether_header *);
	    m-&gt;m_data += ETHER_HDR_LEN;
	    m-&gt;m_len -= ETHER_HDR_LEN;
	    bond_bpf_vlan(ifp, m, eh_p, m-&gt;m_pkthdr.vlan_tag, func);
	    m-&gt;m_data -= ETHER_HDR_LEN;
	    m-&gt;m_len += ETHER_HDR_LEN;
	} <span class="enscript-keyword">else</span> {
	    (*func)(ifp, m);
	}
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> 
<span class="enscript-function-name">bond_bpf_input</span>(ifnet_t ifp, mbuf_t m, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ether_header * eh_p,
		bpf_packet_func func)
{
    <span class="enscript-keyword">if</span> (func != NULL) {
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_VLAN_TAG_VALID) {
	    bond_bpf_vlan(ifp, m, eh_p, m-&gt;m_pkthdr.vlan_tag, func);
	} <span class="enscript-keyword">else</span> {
	    <span class="enscript-comment">/* restore the header */</span>
	    m-&gt;m_data -= ETHER_HDR_LEN;
	    m-&gt;m_len += ETHER_HDR_LEN;
	    (*func)(ifp, m);
	    m-&gt;m_data += ETHER_HDR_LEN;
	    m-&gt;m_len -= ETHER_HDR_LEN;
	}
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Function: bond_setmulti
 * Purpose:
 *   Enable multicast reception on &quot;our&quot; interface by enabling multicasts on
 *   each of the member ports.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_setmulti</span>(<span class="enscript-type">struct</span> ifnet * ifp)
{
    ifbond_ref		ifb;
    <span class="enscript-type">int</span>			error;
    <span class="enscript-type">int</span>			result = 0;
    bondport_ref	p;

    bond_lock();
    ifb = ifnet_softc(ifp);
    <span class="enscript-keyword">if</span> (ifb == NULL || ifbond_flags_if_detaching(ifb) 
	|| TAILQ_EMPTY(&amp;ifb-&gt;ifb_port_list)) {
	bond_unlock();
	<span class="enscript-keyword">return</span> (0);
    }
    ifbond_retain(ifb);
    ifbond_wait(ifb, <span class="enscript-string">&quot;bond_setmulti&quot;</span>);

    <span class="enscript-keyword">if</span> (ifbond_flags_if_detaching(ifb)) {
	<span class="enscript-comment">/* someone destroyed the bond while we were waiting */</span>
	result = EBUSY;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">signal_done</span>;
    }
    bond_unlock();

    <span class="enscript-comment">/* ifbond_wait() let's us safely walk the list without holding the lock */</span>
    TAILQ_FOREACH(p, &amp;ifb-&gt;ifb_port_list, po_port_list) {
	<span class="enscript-type">struct</span> ifnet *	port_ifp = p-&gt;po_ifp;

	error = multicast_list_program(&amp;p-&gt;po_multicast,
				       ifp, port_ifp);
	<span class="enscript-keyword">if</span> (error != 0) {
	    printf(<span class="enscript-string">&quot;bond_setmulti(%s): &quot;</span>
		   <span class="enscript-string">&quot;multicast_list_program(%s%d) failed, %d\n&quot;</span>,
		   ifb-&gt;ifb_name, ifnet_name(port_ifp),
		   ifnet_unit(port_ifp), error);
	    result = error;
	}
    }
    bond_lock();
 <span class="enscript-reference">signal_done</span>:
    ifbond_signal(ifb, <span class="enscript-string">&quot;bond_setmulti&quot;</span>);
    bond_unlock();
    ifbond_release(ifb);
    <span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_clone_attach</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> error;

    <span class="enscript-keyword">if</span> ((error = if_clone_attach(&amp;bond_cloner)) != 0)
	<span class="enscript-keyword">return</span> error;
    bond_lock_init();
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ifbond_add_slow_proto_multicast</span>(ifbond_ref ifb)
{
    <span class="enscript-type">int</span>				error;
    <span class="enscript-type">struct</span> ifmultiaddr * 	ifma = NULL;
    <span class="enscript-type">struct</span> sockaddr_dl		sdl;

    bond_assert_lock_not_held();

    bzero(&amp;sdl, <span class="enscript-keyword">sizeof</span>(sdl));
    sdl.sdl_len = <span class="enscript-keyword">sizeof</span>(sdl);
    sdl.sdl_family = AF_LINK;
    sdl.sdl_type = IFT_ETHER;
    sdl.sdl_nlen = 0;
    sdl.sdl_alen = <span class="enscript-keyword">sizeof</span>(slow_proto_multicast);
    bcopy(&amp;slow_proto_multicast, sdl.sdl_data, <span class="enscript-keyword">sizeof</span>(slow_proto_multicast));
    error = if_addmulti_anon(ifb-&gt;ifb_ifp, (<span class="enscript-type">struct</span> sockaddr *)&amp;sdl, &amp;ifma);
    <span class="enscript-keyword">if</span> (error == 0) {
	ifb-&gt;ifb_ifma_slow_proto = ifma;
    }
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_clone_create</span>(<span class="enscript-type">struct</span> if_clone * ifc, u_int32_t unit, __unused <span class="enscript-type">void</span> *params)
{
	<span class="enscript-type">int</span> 						error;
	ifbond_ref					ifb;
	ifnet_t						ifp;
	<span class="enscript-type">struct</span> ifnet_init_eparams	bond_init;
	
	error = bond_globals_init();
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">return</span> (error);
	}
	
	ifb = _MALLOC(<span class="enscript-keyword">sizeof</span>(ifbond), M_BOND, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (ifb == NULL) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	
	ifbond_retain(ifb);
	TAILQ_INIT(&amp;ifb-&gt;ifb_port_list);
	TAILQ_INIT(&amp;ifb-&gt;ifb_lag_list);
	ifb-&gt;ifb_key = unit + 1;
	
	<span class="enscript-comment">/* use the interface name as the unique id for ifp recycle */</span>
	<span class="enscript-keyword">if</span> ((u_int32_t)snprintf(ifb-&gt;ifb_name, <span class="enscript-keyword">sizeof</span>(ifb-&gt;ifb_name), <span class="enscript-string">&quot;%s%d&quot;</span>,
						 ifc-&gt;ifc_name, unit) &gt;= <span class="enscript-keyword">sizeof</span>(ifb-&gt;ifb_name)) {
		ifbond_release(ifb);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	
	bzero(&amp;bond_init, <span class="enscript-keyword">sizeof</span>(bond_init));
	bond_init.ver = IFNET_INIT_CURRENT_VERSION;
	bond_init.len = <span class="enscript-keyword">sizeof</span> (bond_init);
	bond_init.flags = IFNET_INIT_LEGACY;
	bond_init.uniqueid = ifb-&gt;ifb_name;
	bond_init.uniqueid_len = strlen(ifb-&gt;ifb_name);
	bond_init.name = ifc-&gt;ifc_name;
	bond_init.unit = unit;
	bond_init.family = IFNET_FAMILY_BOND;
	bond_init.type = IFT_IEEE8023ADLAG;
	bond_init.output = bond_output;
	bond_init.demux = ether_demux;
	bond_init.add_proto = ether_add_proto;
	bond_init.del_proto = ether_del_proto;
	bond_init.check_multi = ether_check_multi;
	bond_init.framer_extended = ether_frameout_extended;
	bond_init.ioctl = bond_ioctl;
	bond_init.set_bpf_tap = bond_set_bpf_tap;
	bond_init.detach = bond_if_free;
	bond_init.broadcast_addr = etherbroadcastaddr;
	bond_init.broadcast_len = ETHER_ADDR_LEN;
	bond_init.softc = ifb;
	error = ifnet_allocate_extended(&amp;bond_init, &amp;ifp);
	
	<span class="enscript-keyword">if</span> (error) {
		ifbond_release(ifb);
		<span class="enscript-keyword">return</span> (error);
	}
	
	ifb-&gt;ifb_ifp = ifp;
	ifnet_set_offload(ifp, 0);
	ifnet_set_addrlen(ifp, ETHER_ADDR_LEN); <span class="enscript-comment">/* XXX ethernet specific */</span>
	ifnet_set_flags(ifp, IFF_BROADCAST | IFF_MULTICAST | IFF_SIMPLEX, 0xffff);
	ifnet_set_baudrate(ifp, 0);
	ifnet_set_mtu(ifp, 0);
	
	error = ifnet_attach(ifp, NULL);
	<span class="enscript-keyword">if</span> (error != 0) {
		ifnet_release(ifp);
		ifbond_release(ifb);
		<span class="enscript-keyword">return</span> (error);
	}
	error = ifbond_add_slow_proto_multicast(ifb);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;bond_clone_create(%s): &quot;</span>
			   <span class="enscript-string">&quot;failed to add slow_proto multicast, %d\n&quot;</span>,
			   ifb-&gt;ifb_name, error);
	}
	
	<span class="enscript-comment">/* attach as ethernet */</span>
	bpfattach(ifp, DLT_EN10MB, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header));
	
	bond_lock();
	TAILQ_INSERT_HEAD(&amp;g_bond-&gt;ifbond_list, ifb, ifb_bond_list);
	bond_unlock();
	
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_remove_all_interfaces</span>(ifbond_ref ifb)
{
    bondport_ref	p;

    bond_assert_lock_held();

    <span class="enscript-comment">/*
     * do this in reverse order to avoid re-programming the mac address
     * as each head interface is removed
     */</span>
    <span class="enscript-keyword">while</span> ((p = TAILQ_LAST(&amp;ifb-&gt;ifb_port_list, port_list)) != NULL) {
	bond_remove_interface(ifb, p-&gt;po_ifp);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_remove</span>(ifbond_ref ifb)
{
    bond_assert_lock_held();
    ifbond_flags_set_if_detaching(ifb);
    TAILQ_REMOVE(&amp;g_bond-&gt;ifbond_list, ifb, ifb_bond_list);
    bond_remove_all_interfaces(ifb);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_if_detach</span>(<span class="enscript-type">struct</span> ifnet * ifp)
{
    <span class="enscript-type">int</span>		error;

    error = ifnet_detach(ifp);
    <span class="enscript-keyword">if</span> (error) {
	printf(<span class="enscript-string">&quot;bond_if_detach %s%d: ifnet_detach failed, %d\n&quot;</span>,
	       ifnet_name(ifp), ifnet_unit(ifp), error);
    }
	
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_clone_destroy</span>(<span class="enscript-type">struct</span> ifnet * ifp)
{
    ifbond_ref ifb;

    bond_lock();
    ifb = ifnet_softc(ifp);
    <span class="enscript-keyword">if</span> (ifb == NULL || ifnet_type(ifp) != IFT_IEEE8023ADLAG) {
	bond_unlock();
	<span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">if</span> (ifbond_flags_if_detaching(ifb)) {
	bond_unlock();
	<span class="enscript-keyword">return</span> 0;
    }
    bond_remove(ifb);
    bond_unlock();
    bond_if_detach(ifp);
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">bond_set_bpf_tap</span>(<span class="enscript-type">struct</span> ifnet * ifp, bpf_tap_mode mode, bpf_packet_func func)
{
    ifbond_ref	ifb;

    bond_lock();
    ifb = ifnet_softc(ifp);
    <span class="enscript-keyword">if</span> (ifb == NULL || ifbond_flags_if_detaching(ifb)) {
	bond_unlock();
	<span class="enscript-keyword">return</span> (ENODEV);
    }
    <span class="enscript-keyword">switch</span> (mode) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">BPF_TAP_DISABLE</span>:
	ifb-&gt;ifb_bpf_input = ifb-&gt;ifb_bpf_output = NULL;
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">BPF_TAP_INPUT</span>:
	ifb-&gt;ifb_bpf_input = func;
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">BPF_TAP_OUTPUT</span>:
	ifb-&gt;ifb_bpf_output = func;
	<span class="enscript-keyword">break</span>;
        
    <span class="enscript-keyword">case</span> <span class="enscript-reference">BPF_TAP_INPUT_OUTPUT</span>:
	ifb-&gt;ifb_bpf_input = ifb-&gt;ifb_bpf_output = func;
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    bond_unlock();
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">ether_header_hash</span>(<span class="enscript-type">struct</span> ether_header * eh_p)
{
    uint32_t	h;

    <span class="enscript-comment">/* get 32-bits from destination ether and ether type */</span>
    h = (*((uint16_t *)&amp;eh_p-&gt;ether_dhost[4]) &lt;&lt; 16)
	| eh_p-&gt;ether_type;
    h ^= *((uint32_t *)&amp;eh_p-&gt;ether_dhost[0]);
    <span class="enscript-keyword">return</span> (h);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">S_mbuf_skip_to_offset</span>(<span class="enscript-type">struct</span> mbuf * m, int32_t * offset)
{
    <span class="enscript-type">int</span>			len;

    len = m-&gt;m_len;
    <span class="enscript-keyword">while</span> (*offset &gt;= len) {
	*offset -= len;
	m = m-&gt;m_next;
	<span class="enscript-keyword">if</span> (m == NULL) {
	    <span class="enscript-keyword">break</span>;
	}
	len = m-&gt;m_len;
    }
    <span class="enscript-keyword">return</span> (m);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> == <span class="enscript-variable-name">BIG_ENDIAN</span>
<span class="enscript-type">static</span> __inline__ uint32_t
<span class="enscript-function-name">make_uint32</span>(u_char c0, u_char c1, u_char c2, u_char c3)
{
    <span class="enscript-keyword">return</span> (((uint32_t)c0 &lt;&lt; 24) | ((uint32_t)c1 &lt;&lt; 16) 
	    | ((uint32_t)c2 &lt;&lt; 8) | (uint32_t)c3);
}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* BYTE_ORDER == LITTLE_ENDIAN */</span>
<span class="enscript-type">static</span> __inline__ uint32_t
<span class="enscript-function-name">make_uint32</span>(u_char c0, u_char c1, u_char c2, u_char c3)
{
    <span class="enscript-keyword">return</span> (((uint32_t)c3 &lt;&lt; 24) | ((uint32_t)c2 &lt;&lt; 16) 
	    | ((uint32_t)c1 &lt;&lt; 8) | (uint32_t)c0);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BYTE_ORDER == LITTLE_ENDIAN */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">S_mbuf_copy_uint32</span>(<span class="enscript-type">struct</span> mbuf * m, int32_t offset, uint32_t * val)
{
    <span class="enscript-type">struct</span> mbuf *	current;
    u_char *		current_data;
    <span class="enscript-type">struct</span> mbuf *	next;
    u_char *		next_data;
    <span class="enscript-type">int</span>			space_current;

    current = S_mbuf_skip_to_offset(m, &amp;offset);
    <span class="enscript-keyword">if</span> (current == NULL) {
	<span class="enscript-keyword">return</span> (1);
    }
    current_data = mtod(current, u_char *) + offset;
    space_current = current-&gt;m_len - offset;
    <span class="enscript-keyword">if</span> (space_current &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(uint32_t)) {
	*val = *((uint32_t *)current_data);
	<span class="enscript-keyword">return</span> (0);
    }
    next = current-&gt;m_next;
    <span class="enscript-keyword">if</span> (next == NULL || (next-&gt;m_len + space_current) &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(uint32_t)) {
	<span class="enscript-keyword">return</span> (1);
    }
    next_data = mtod(next, u_char *);
    <span class="enscript-keyword">switch</span> (space_current) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
	*val = make_uint32(current_data[0], next_data[0],
			   next_data[1], next_data[2]);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
	*val = make_uint32(current_data[0], current_data[1],
			   next_data[0], next_data[1]);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	*val = make_uint32(current_data[0], current_data[1],
			   current_data[2], next_data[0]);
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP_SRC_OFFSET</span> (offsetof(struct ip, ip_src) - offsetof(struct ip, ip_p))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP_DST_OFFSET</span> (offsetof(struct ip, ip_dst) - offsetof(struct ip, ip_p))

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">ip_header_hash</span>(<span class="enscript-type">struct</span> mbuf * m)
{
    u_char *		data;
    <span class="enscript-type">struct</span> in_addr	ip_dst;
    <span class="enscript-type">struct</span> in_addr	ip_src;
    u_char		ip_p;
    int32_t		offset;
    <span class="enscript-type">struct</span> mbuf *	orig_m = m;

    <span class="enscript-comment">/* find the IP protocol field relative to the start of the packet */</span>
    offset = offsetof(<span class="enscript-type">struct</span> ip, ip_p) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header);
    m = S_mbuf_skip_to_offset(m, &amp;offset);
    <span class="enscript-keyword">if</span> (m == NULL || m-&gt;m_len &lt; 1) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_ip_packet</span>;
    }
    data = mtod(m, u_char *) + offset;
    ip_p = *data;

    <span class="enscript-comment">/* find the IP src relative to the IP protocol */</span>
    <span class="enscript-keyword">if</span> ((m-&gt;m_len - offset) 
	&gt;= (<span class="enscript-type">int</span>)(IP_SRC_OFFSET + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr) * 2)) {
	<span class="enscript-comment">/* this should be the normal case */</span>
	ip_src = *(<span class="enscript-type">struct</span> in_addr *)(data + IP_SRC_OFFSET);
	ip_dst = *(<span class="enscript-type">struct</span> in_addr *)(data + IP_DST_OFFSET);
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">if</span> (S_mbuf_copy_uint32(m, offset + IP_SRC_OFFSET,
			       (uint32_t *)&amp;ip_src.s_addr)) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_ip_packet</span>;
	}
	<span class="enscript-keyword">if</span> (S_mbuf_copy_uint32(m, offset + IP_DST_OFFSET,
			       (uint32_t *)&amp;ip_dst.s_addr)) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_ip_packet</span>;
	}
    }
    <span class="enscript-keyword">return</span> (ntohl(ip_dst.s_addr) ^ ntohl(ip_src.s_addr) ^ ((uint32_t)ip_p));

 <span class="enscript-reference">bad_ip_packet</span>:
    <span class="enscript-keyword">return</span> (ether_header_hash(mtod(orig_m, <span class="enscript-type">struct</span> ether_header *)));
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP6_ADDRS_LEN</span> 	(sizeof(struct in6_addr) * 2)
<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">ipv6_header_hash</span>(<span class="enscript-type">struct</span> mbuf * m)
{
    u_char *		data;
    <span class="enscript-type">int</span>			i;
    int32_t		offset;
    <span class="enscript-type">struct</span> mbuf *	orig_m = m;
    uint32_t *		scan;
    uint32_t		val;

    <span class="enscript-comment">/* find the IP protocol field relative to the start of the packet */</span>
    offset = offsetof(<span class="enscript-type">struct</span> ip6_hdr, ip6_src) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header);
    m = S_mbuf_skip_to_offset(m, &amp;offset);
    <span class="enscript-keyword">if</span> (m == NULL) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_ipv6_packet</span>;
    }
    data = mtod(m, u_char *) + offset;
    val = 0;
    <span class="enscript-keyword">if</span> ((m-&gt;m_len - offset) &gt;= (<span class="enscript-type">int</span>)IP6_ADDRS_LEN) {
	<span class="enscript-comment">/* this should be the normal case */</span>
	<span class="enscript-keyword">for</span> (i = 0, scan = (uint32_t *)data;
	     i &lt; (<span class="enscript-type">int</span>)(IP6_ADDRS_LEN / <span class="enscript-keyword">sizeof</span>(uint32_t));
	     i++, scan++) {
	    val ^= *scan;
	}
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)(IP6_ADDRS_LEN / <span class="enscript-keyword">sizeof</span>(uint32_t)); i++) {
	    uint32_t	tmp;
	    <span class="enscript-keyword">if</span> (S_mbuf_copy_uint32(m, offset + i * <span class="enscript-keyword">sizeof</span>(uint32_t),
				   (uint32_t *)&amp;tmp)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_ipv6_packet</span>;
	    }
	    val ^= tmp;
	}
    }
    <span class="enscript-keyword">return</span> (ntohl(val));

 <span class="enscript-reference">bad_ipv6_packet</span>:
    <span class="enscript-keyword">return</span> (ether_header_hash(mtod(orig_m, <span class="enscript-type">struct</span> ether_header *)));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_output</span>(<span class="enscript-type">struct</span> ifnet * ifp, <span class="enscript-type">struct</span> mbuf * m)
{
    bpf_packet_func		bpf_func;
    uint32_t			h;
    ifbond_ref			ifb;
    <span class="enscript-type">struct</span> ifnet *		port_ifp = NULL;
    <span class="enscript-type">int</span>				err;
    <span class="enscript-type">struct</span> flowadv		adv = { FADV_SUCCESS };
	
    <span class="enscript-keyword">if</span> (m == 0) {
	<span class="enscript-keyword">return</span> (0);
    }
    <span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_PKTHDR) == 0) {
	m_freem(m);
	<span class="enscript-keyword">return</span> (0);
    }
    <span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flowid != 0) {
	h = m-&gt;m_pkthdr.pkt_flowid;
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-type">struct</span> ether_header *	eh_p;

	eh_p = mtod(m, <span class="enscript-type">struct</span> ether_header *);
	<span class="enscript-keyword">switch</span> (ntohs(eh_p-&gt;ether_type)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ETHERTYPE_IP</span>:
	    h = ip_header_hash(m);
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ETHERTYPE_IPV6</span>:
	    h = ipv6_header_hash(m);
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
	    h = ether_header_hash(eh_p);
	    <span class="enscript-keyword">break</span>;
	}
    }
    bond_lock();
    ifb = ifnet_softc(ifp);
    <span class="enscript-keyword">if</span> (ifb == NULL || ifbond_flags_if_detaching(ifb)
	|| ifb-&gt;ifb_distributing_count == 0) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    h %= ifb-&gt;ifb_distributing_count;
    port_ifp = ifb-&gt;ifb_distributing_array[h]-&gt;po_ifp;
    bpf_func = ifb-&gt;ifb_bpf_output;
    bond_unlock();

    <span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_VLAN_TAG_VALID) {
	(<span class="enscript-type">void</span>)ifnet_stat_increment_out(ifp, 1, 
				       m-&gt;m_pkthdr.len + ETHER_VLAN_ENCAP_LEN,
				       0);
    } <span class="enscript-keyword">else</span> {
	(<span class="enscript-type">void</span>)ifnet_stat_increment_out(ifp, 1, m-&gt;m_pkthdr.len, 0);
    }
    bond_bpf_output(ifp, m, bpf_func);

    err = dlil_output(port_ifp, PF_BOND, m, NULL, NULL, 1, &amp;adv);

    <span class="enscript-keyword">if</span> (err == 0) {
	<span class="enscript-keyword">if</span> (adv.code == FADV_FLOW_CONTROLLED) {
	    err = EQFULL;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (adv.code == FADV_SUSPENDED) {
	    err = EQSUSPENDED;
	}
    }

    <span class="enscript-keyword">return</span> (err);

 <span class="enscript-reference">done</span>:
    bond_unlock();
    m_freem(m);
    <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> bondport_ref
<span class="enscript-function-name">ifbond_lookup_port</span>(ifbond_ref ifb, <span class="enscript-type">struct</span> ifnet * port_ifp)
{
    bondport_ref	p;
    TAILQ_FOREACH(p, &amp;ifb-&gt;ifb_port_list, po_port_list) {
	<span class="enscript-keyword">if</span> (p-&gt;po_ifp == port_ifp) {
	    <span class="enscript-keyword">return</span> (p);
	}
    }
    <span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> bondport_ref
<span class="enscript-function-name">bond_lookup_port</span>(<span class="enscript-type">struct</span> ifnet * port_ifp)
{
    ifbond_ref		ifb;
    bondport_ref	port;

    TAILQ_FOREACH(ifb, &amp;g_bond-&gt;ifbond_list, ifb_bond_list) {
	port = ifbond_lookup_port(ifb, port_ifp);
	<span class="enscript-keyword">if</span> (port != NULL) {
	    <span class="enscript-keyword">return</span> (port);
	}
    }
    <span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_receive_lacpdu</span>(<span class="enscript-type">struct</span> mbuf * m, <span class="enscript-type">struct</span> ifnet * port_ifp)
{
    <span class="enscript-type">struct</span> ifnet *		bond_ifp = NULL;
    ifbond_ref			ifb;
    <span class="enscript-type">int</span>				event_code = 0;
    bondport_ref		p;

    bond_lock();
    <span class="enscript-keyword">if</span> ((ifnet_eflags(port_ifp) &amp; IFEF_BOND) == 0) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    p = bond_lookup_port(port_ifp);
    <span class="enscript-keyword">if</span> (p == NULL) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    <span class="enscript-keyword">if</span> (p-&gt;po_enabled == 0) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    ifb = p-&gt;po_bond;
    <span class="enscript-keyword">if</span> (ifb-&gt;ifb_mode != IF_BOND_MODE_LACP) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    bondport_receive_lacpdu(p, (lacpdu_ref)m-&gt;m_data);
    <span class="enscript-keyword">if</span> (ifbond_selection(ifb)) {
	event_code = (ifb-&gt;ifb_active_lag == NULL) 
	    ? KEV_DL_LINK_OFF 
	    : KEV_DL_LINK_ON;
	<span class="enscript-comment">/* XXX need to take a reference on bond_ifp */</span>
	bond_ifp = ifb-&gt;ifb_ifp;
	ifb-&gt;ifb_last_link_event = event_code;
    }
    <span class="enscript-keyword">else</span> {
	event_code = (ifb-&gt;ifb_active_lag == NULL) 
	    ? KEV_DL_LINK_OFF 
	    : KEV_DL_LINK_ON;
	<span class="enscript-keyword">if</span> (event_code != ifb-&gt;ifb_last_link_event) {
	    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		timestamp_printf(<span class="enscript-string">&quot;%s: (receive) generating LINK event\n&quot;</span>,
				 ifb-&gt;ifb_name);
	    }
	    bond_ifp = ifb-&gt;ifb_ifp;
	    ifb-&gt;ifb_last_link_event = event_code;
	}
    }

 <span class="enscript-reference">done</span>:
    bond_unlock();
    <span class="enscript-keyword">if</span> (bond_ifp != NULL) {
	interface_link_event(bond_ifp, event_code);
    }
    m_freem(m);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_receive_la_marker_pdu</span>(<span class="enscript-type">struct</span> mbuf * m, <span class="enscript-type">struct</span> ifnet * port_ifp)
{
    la_marker_pdu_ref		marker_p;
    bondport_ref		p;

    marker_p = (la_marker_pdu_ref)(m-&gt;m_data + ETHER_HDR_LEN);
    <span class="enscript-keyword">if</span> (marker_p-&gt;lm_marker_tlv_type != LA_MARKER_TLV_TYPE_MARKER) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    bond_lock();
    <span class="enscript-keyword">if</span> ((ifnet_eflags(port_ifp) &amp; IFEF_BOND) == 0) {
	bond_unlock();
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    p = bond_lookup_port(port_ifp);
    <span class="enscript-keyword">if</span> (p == NULL || p-&gt;po_enabled == 0
	|| p-&gt;po_bond-&gt;ifb_mode != IF_BOND_MODE_LACP) {
	bond_unlock();
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    <span class="enscript-comment">/* echo back the same packet as a marker response */</span>
    marker_p-&gt;lm_marker_tlv_type = LA_MARKER_TLV_TYPE_MARKER_RESPONSE;
    bondport_slow_proto_transmit(p, (packet_buffer_ref)m);
    bond_unlock();
    <span class="enscript-keyword">return</span>;

 <span class="enscript-reference">failed</span>:
    m_freem(m);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_input</span>(ifnet_t port_ifp, __unused protocol_family_t protocol, mbuf_t m,
		   <span class="enscript-type">char</span> * frame_header)
{
    bpf_packet_func		bpf_func;
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ether_header *	eh_p;
    ifbond_ref			ifb;
    <span class="enscript-type">struct</span> ifnet *		ifp;	
    bondport_ref		p;

    eh_p = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ether_header *)frame_header;
    <span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_MCAST) != 0
	&amp;&amp; bcmp(eh_p-&gt;ether_dhost, &amp;slow_proto_multicast,
		<span class="enscript-keyword">sizeof</span>(eh_p-&gt;ether_dhost)) == 0
	&amp;&amp; ntohs(eh_p-&gt;ether_type) == IEEE8023AD_SLOW_PROTO_ETHERTYPE) {
	u_char 	subtype = *mtod(m, u_char *);

	<span class="enscript-keyword">if</span> (subtype == IEEE8023AD_SLOW_PROTO_SUBTYPE_LACP) {
	    <span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; (<span class="enscript-type">int</span>)offsetof(lacpdu, la_reserved)) {
		m_freem(m);
		<span class="enscript-keyword">return</span> (0);
	    }
	    <span class="enscript-comment">/* send to lacp */</span>
	    <span class="enscript-keyword">if</span> (m-&gt;m_len &lt; (<span class="enscript-type">int</span>)offsetof(lacpdu, la_reserved)) {
		m = m_pullup(m, offsetof(lacpdu, la_reserved));
		<span class="enscript-keyword">if</span> (m == NULL) {
		    <span class="enscript-keyword">return</span> (0);
		}
	    }
	    bond_receive_lacpdu(m, port_ifp);
	    <span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (subtype == IEEE8023AD_SLOW_PROTO_SUBTYPE_LA_MARKER_PROTOCOL) {
	    <span class="enscript-type">int</span>		min_size;

	    <span class="enscript-comment">/* restore the ethernet header pointer in the mbuf */</span>
	    m-&gt;m_pkthdr.len += ETHER_HDR_LEN;
	    m-&gt;m_data -= ETHER_HDR_LEN;
	    m-&gt;m_len += ETHER_HDR_LEN;
	    min_size = ETHER_HDR_LEN + offsetof(la_marker_pdu, lm_reserved);
	    <span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; min_size) {
		m_freem(m);
		<span class="enscript-keyword">return</span> (0);
	    }
	    <span class="enscript-comment">/* send to lacp */</span>
	    <span class="enscript-keyword">if</span> (m-&gt;m_len &lt; min_size) {
		m = m_pullup(m, min_size);
		<span class="enscript-keyword">if</span> (m == NULL) {
		    <span class="enscript-keyword">return</span> (0);
		}
	    }
	    <span class="enscript-comment">/* send to marker responder */</span>
	    bond_receive_la_marker_pdu(m, port_ifp);
	    <span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (subtype == 0 
		 || subtype &gt; IEEE8023AD_SLOW_PROTO_SUBTYPE_RESERVED_END) {
	    <span class="enscript-comment">/* invalid subtype, discard the frame */</span>
	    m_freem(m);
	    <span class="enscript-keyword">return</span> (0);
	}
    }
    bond_lock();
    <span class="enscript-keyword">if</span> ((ifnet_eflags(port_ifp) &amp; IFEF_BOND) == 0) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    p = bond_lookup_port(port_ifp);
    <span class="enscript-keyword">if</span> (p == NULL || bondport_collecting(p) == 0) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    <span class="enscript-comment">/* make the packet appear as if it arrived on the bonded interface */</span>
    ifb = p-&gt;po_bond;
    ifp = ifb-&gt;ifb_ifp;
    bpf_func = ifb-&gt;ifb_bpf_input;
    bond_unlock();

    <span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_VLAN_TAG_VALID) {
	(<span class="enscript-type">void</span>)ifnet_stat_increment_in(ifp, 1, 
				      (m-&gt;m_pkthdr.len + ETHER_HDR_LEN 
				       + ETHER_VLAN_ENCAP_LEN), 0);
    }
    <span class="enscript-keyword">else</span> {
	(<span class="enscript-type">void</span>)ifnet_stat_increment_in(ifp, 1, 
				      (m-&gt;m_pkthdr.len + ETHER_HDR_LEN), 0);
    }
    m-&gt;m_pkthdr.rcvif = ifp;
    bond_bpf_input(ifp, m, eh_p, bpf_func);
    m-&gt;m_pkthdr.pkt_hdr = frame_header;
    dlil_input_packet_list(ifp, m);
    <span class="enscript-keyword">return</span> 0;

 <span class="enscript-reference">done</span>:
    bond_unlock();
    m_freem(m);
    <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">bondport_get_name</span>(bondport_ref p)
{
    <span class="enscript-keyword">return</span> (p-&gt;po_name);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_get_index</span>(bondport_ref p)
{
    <span class="enscript-keyword">return</span> (ifnet_index(p-&gt;po_ifp));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_slow_proto_transmit</span>(bondport_ref p, packet_buffer_ref buf)
{
    <span class="enscript-type">struct</span> ether_header *	eh_p;
    <span class="enscript-type">int</span>				error;

    <span class="enscript-comment">/* packet_buffer_allocate leaves room for ethernet header */</span>
    eh_p = mtod(buf, <span class="enscript-type">struct</span> ether_header *);
    bcopy(&amp;slow_proto_multicast, &amp;eh_p-&gt;ether_dhost, <span class="enscript-keyword">sizeof</span>(eh_p-&gt;ether_dhost));
    bcopy(&amp;p-&gt;po_saved_addr, eh_p-&gt;ether_shost, <span class="enscript-keyword">sizeof</span>(eh_p-&gt;ether_shost));
    eh_p-&gt;ether_type = htons(IEEE8023AD_SLOW_PROTO_ETHERTYPE);
    error = ifnet_output_raw(p-&gt;po_ifp, PF_BOND, buf);
    <span class="enscript-keyword">if</span> (error != 0) {
	printf(<span class="enscript-string">&quot;bondport_slow_proto_transmit(%s) failed %d\n&quot;</span>,
	       bondport_get_name(p), error);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_timer_process_func</span>(devtimer_ref timer, 
			    devtimer_process_func_event event)
{
    bondport_ref	p;

    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">devtimer_process_func_event_lock</span>:
	bond_lock();
	devtimer_retain(timer);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">devtimer_process_func_event_unlock</span>:
	<span class="enscript-keyword">if</span> (devtimer_valid(timer)) {
	    <span class="enscript-comment">/* as long as the devtimer is valid, we can look at arg0 */</span>
	    <span class="enscript-type">int</span>			event_code = 0;
	    <span class="enscript-type">struct</span> ifnet *	bond_ifp = NULL;

	    p = (bondport_ref)devtimer_arg0(timer);
	    <span class="enscript-keyword">if</span> (ifbond_selection(p-&gt;po_bond)) {
		event_code = (p-&gt;po_bond-&gt;ifb_active_lag == NULL) 
		    ? KEV_DL_LINK_OFF 
		    : KEV_DL_LINK_ON;
		<span class="enscript-comment">/* XXX need to take a reference on bond_ifp */</span>
		bond_ifp = p-&gt;po_bond-&gt;ifb_ifp;
		p-&gt;po_bond-&gt;ifb_last_link_event = event_code;
	    }
	    <span class="enscript-keyword">else</span> {
		event_code = (p-&gt;po_bond-&gt;ifb_active_lag == NULL) 
		    ? KEV_DL_LINK_OFF 
		    : KEV_DL_LINK_ON;
		<span class="enscript-keyword">if</span> (event_code != p-&gt;po_bond-&gt;ifb_last_link_event) {
		    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
			timestamp_printf(<span class="enscript-string">&quot;%s: (timer) generating LINK event\n&quot;</span>,
					 p-&gt;po_bond-&gt;ifb_name);
		    }
		    bond_ifp = p-&gt;po_bond-&gt;ifb_ifp;
		    p-&gt;po_bond-&gt;ifb_last_link_event = event_code;
		}
	    }
	    devtimer_release(timer);
	    bond_unlock();
	    <span class="enscript-keyword">if</span> (bond_ifp != NULL) {
		interface_link_event(bond_ifp, event_code);
	    }
	}
	<span class="enscript-keyword">else</span> {
	    <span class="enscript-comment">/* timer is going away */</span>
	    devtimer_release(timer);
	    bond_unlock();
	}
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
}

<span class="enscript-type">static</span> bondport_ref
<span class="enscript-function-name">bondport_create</span>(<span class="enscript-type">struct</span> ifnet * port_ifp, lacp_port_priority priority,
		<span class="enscript-type">int</span> active, <span class="enscript-type">int</span> short_timeout, <span class="enscript-type">int</span> * ret_error)
{
    <span class="enscript-type">int</span>				error = 0;
    bondport_ref		p = NULL;
    lacp_actor_partner_state	s;

    *ret_error = 0;
    p = _MALLOC(<span class="enscript-keyword">sizeof</span>(*p), M_BOND, M_WAITOK | M_ZERO);
    <span class="enscript-keyword">if</span> (p == NULL) {
	*ret_error = ENOMEM;
	<span class="enscript-keyword">return</span> (NULL);
    }
    multicast_list_init(&amp;p-&gt;po_multicast);
    <span class="enscript-keyword">if</span> ((u_int32_t)snprintf(p-&gt;po_name, <span class="enscript-keyword">sizeof</span>(p-&gt;po_name), <span class="enscript-string">&quot;%s%d&quot;</span>,
			 ifnet_name(port_ifp), ifnet_unit(port_ifp)) 
	&gt;= <span class="enscript-keyword">sizeof</span>(p-&gt;po_name)) {
	printf(<span class="enscript-string">&quot;if_bond: name too large\n&quot;</span>);
	*ret_error = EINVAL;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    error = siocgifdevmtu(port_ifp, &amp;p-&gt;po_devmtu);
    <span class="enscript-keyword">if</span> (error != 0) {
	printf(<span class="enscript-string">&quot;if_bond: SIOCGIFDEVMTU %s failed, %d\n&quot;</span>,
	       bondport_get_name(p), error);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    <span class="enscript-comment">/* remember the current interface MTU so it can be restored */</span>
    p-&gt;po_devmtu.ifdm_current = ifnet_mtu(port_ifp);
    p-&gt;po_ifp = port_ifp;
    p-&gt;po_media_info = interface_media_info(port_ifp);
    p-&gt;po_current_while_timer = devtimer_create(bondport_timer_process_func, p);
    <span class="enscript-keyword">if</span> (p-&gt;po_current_while_timer == NULL) {
	*ret_error = ENOMEM;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    p-&gt;po_periodic_timer = devtimer_create(bondport_timer_process_func, p);
    <span class="enscript-keyword">if</span> (p-&gt;po_periodic_timer == NULL) {
	*ret_error = ENOMEM;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    p-&gt;po_wait_while_timer = devtimer_create(bondport_timer_process_func, p);
    <span class="enscript-keyword">if</span> (p-&gt;po_wait_while_timer == NULL) {
	*ret_error = ENOMEM;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    p-&gt;po_transmit_timer = devtimer_create(bondport_timer_process_func, p);
    <span class="enscript-keyword">if</span> (p-&gt;po_transmit_timer == NULL) {
	*ret_error = ENOMEM;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    p-&gt;po_receive_state = ReceiveState_none;
    p-&gt;po_mux_state = MuxState_none;
    p-&gt;po_priority = priority;
    s = 0;
    s = lacp_actor_partner_state_set_aggregatable(s);
    <span class="enscript-keyword">if</span> (short_timeout) {
	s = lacp_actor_partner_state_set_short_timeout(s);
    }
    <span class="enscript-keyword">if</span> (active) {
	s = lacp_actor_partner_state_set_active_lacp(s);
    }
    p-&gt;po_actor_state = s;
    <span class="enscript-keyword">return</span> (p);

 <span class="enscript-reference">failed</span>:
    bondport_free(p);
    <span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_start</span>(bondport_ref p)
{
    bondport_receive_machine(p, LAEventStart, NULL);
    bondport_mux_machine(p, LAEventStart, NULL);
    bondport_periodic_transmit_machine(p, LAEventStart, NULL);
    bondport_transmit_machine(p, LAEventStart, NULL);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Function: bondport_invalidate_timers
 * Purpose:
 *   Invalidate all of the timers for the bondport.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_invalidate_timers</span>(bondport_ref p)
{
    devtimer_invalidate(p-&gt;po_current_while_timer);
    devtimer_invalidate(p-&gt;po_periodic_timer);
    devtimer_invalidate(p-&gt;po_wait_while_timer);
    devtimer_invalidate(p-&gt;po_transmit_timer);
}

<span class="enscript-comment">/*
 * Function: bondport_cancel_timers
 * Purpose:
 *   Cancel all of the timers for the bondport.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_cancel_timers</span>(bondport_ref p)
{
    devtimer_cancel(p-&gt;po_current_while_timer);
    devtimer_cancel(p-&gt;po_periodic_timer);
    devtimer_cancel(p-&gt;po_wait_while_timer);
    devtimer_cancel(p-&gt;po_transmit_timer);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_free</span>(bondport_ref p)
{
    multicast_list_remove(&amp;p-&gt;po_multicast);
    devtimer_release(p-&gt;po_current_while_timer);
    devtimer_release(p-&gt;po_periodic_timer);
    devtimer_release(p-&gt;po_wait_while_timer);
    devtimer_release(p-&gt;po_transmit_timer);
    FREE(p, M_BOND);
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BOND_ADD_PROGRESS_IN_LIST</span>		0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BOND_ADD_PROGRESS_PROTO_ATTACHED</span>	0x2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BOND_ADD_PROGRESS_LLADDR_SET</span>		0x4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BOND_ADD_PROGRESS_MTU_SET</span>		0x8

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_device_mtu</span>(<span class="enscript-type">struct</span> ifnet * ifp, ifbond_ref ifb)
{
    <span class="enscript-keyword">return</span> (((<span class="enscript-type">int</span>)ifnet_mtu(ifp) &gt; ifb-&gt;ifb_altmtu) 
	    ? (<span class="enscript-type">int</span>)ifnet_mtu(ifp) : ifb-&gt;ifb_altmtu);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_add_interface</span>(<span class="enscript-type">struct</span> ifnet * ifp, <span class="enscript-type">struct</span> ifnet * port_ifp)
{
    <span class="enscript-type">int</span>				devmtu;
    <span class="enscript-type">int</span>				error = 0;
    <span class="enscript-type">int</span>				event_code = 0;
    <span class="enscript-type">int</span>				first = FALSE;
    ifbond_ref			ifb;
    bondport_ref *		new_array = NULL;
    bondport_ref *		old_array = NULL;
    bondport_ref 		p;
    <span class="enscript-type">int</span>				progress = 0;

    <span class="enscript-comment">/* pre-allocate space for new port */</span>
    p = bondport_create(port_ifp, 0x8000, 1, 0, &amp;error);
    <span class="enscript-keyword">if</span> (p == NULL) {
	<span class="enscript-keyword">return</span> (error);
    }
    bond_lock();
    ifb = (ifbond_ref)ifnet_softc(ifp);
    <span class="enscript-keyword">if</span> (ifb == NULL || ifbond_flags_if_detaching(ifb)) {
	bond_unlock();
	bondport_free(p);
	<span class="enscript-keyword">return</span> ((ifb == NULL ? EOPNOTSUPP : EBUSY));
    }

    <span class="enscript-comment">/* make sure this interface can handle our current MTU */</span>
    devmtu = bond_device_mtu(ifp, ifb);
    <span class="enscript-keyword">if</span> (devmtu != 0 
	&amp;&amp; (devmtu &gt; p-&gt;po_devmtu.ifdm_max || devmtu &lt; p-&gt;po_devmtu.ifdm_min)) {
	bond_unlock();
	printf(<span class="enscript-string">&quot;if_bond: interface %s doesn't support mtu %d&quot;</span>,
	       bondport_get_name(p), devmtu);
	bondport_free(p);
	<span class="enscript-keyword">return</span> (EINVAL);
    }

    <span class="enscript-comment">/* make sure ifb doesn't get de-allocated while we wait */</span>
    ifbond_retain(ifb);

    <span class="enscript-comment">/* wait for other add or remove to complete */</span>
    ifbond_wait(ifb, <span class="enscript-string">&quot;bond_add_interface&quot;</span>);

    <span class="enscript-keyword">if</span> (ifbond_flags_if_detaching(ifb)) {
	<span class="enscript-comment">/* someone destroyed the bond while we were waiting */</span>
	error = EBUSY;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">signal_done</span>;
    }
    <span class="enscript-keyword">if</span> (bond_lookup_port(port_ifp) != NULL) {
	<span class="enscript-comment">/* port is already part of a bond */</span>
	error = EBUSY;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">signal_done</span>;
    }
    ifnet_lock_exclusive(port_ifp);
    <span class="enscript-keyword">if</span> ((ifnet_eflags(port_ifp) &amp; (IFEF_VLAN | IFEF_BOND)) != 0) {
	<span class="enscript-comment">/* interface already has VLAN's, or is part of bond */</span>
	ifnet_lock_done(port_ifp);
	error = EBUSY;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">signal_done</span>;
    }

    <span class="enscript-comment">/* mark the interface busy */</span>
    <span class="enscript-comment">/* can't use ifnet_set_eflags because that takes the lock */</span>
    port_ifp-&gt;if_eflags |= IFEF_BOND;
    ifnet_lock_done(port_ifp);

    <span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;ifb-&gt;ifb_port_list)) {
	ifnet_set_offload(ifp, ifnet_offload(port_ifp));
	ifnet_set_flags(ifp, IFF_RUNNING, IFF_RUNNING);
	<span class="enscript-keyword">if</span> (ifbond_flags_lladdr(ifb) == FALSE) {
	    first = TRUE;
	}
    } <span class="enscript-keyword">else</span> {
	ifnet_offload_t		ifp_offload;
	ifnet_offload_t		port_ifp_offload;

	ifp_offload = ifnet_offload(ifp);
	port_ifp_offload = ifnet_offload(port_ifp);
	<span class="enscript-keyword">if</span> (ifp_offload != port_ifp_offload) {
	    ifnet_offload_t	offload;

	    offload = ifp_offload &amp; port_ifp_offload;
	    printf(<span class="enscript-string">&quot;bond_add_interface(%s, %s)  &quot;</span>
		   <span class="enscript-string">&quot;hwassist values don't match 0x%x != 0x%x, using 0x%x instead\n&quot;</span>,
		   ifb-&gt;ifb_name, bondport_get_name(p),
		   ifp_offload, port_ifp_offload, offload);
	    <span class="enscript-comment">/*
	     * XXX
	     * if the bond has VLAN's, we can't simply change the hwassist
	     * field behind its back: this needs work
	     */</span>
	    ifnet_set_offload(ifp, offload);
	}
    }
    p-&gt;po_bond = ifb;

    <span class="enscript-comment">/* remember the port's ethernet address so it can be restored */</span>
    ether_addr_copy(&amp;p-&gt;po_saved_addr, IF_LLADDR(port_ifp));

    <span class="enscript-comment">/* add it to the list of ports */</span>
    TAILQ_INSERT_TAIL(&amp;ifb-&gt;ifb_port_list, p, po_port_list);
    ifb-&gt;ifb_port_count++;

    <span class="enscript-comment">/* set the default MTU */</span>
    <span class="enscript-keyword">if</span> (ifnet_mtu(ifp) == 0) {
	ifnet_set_mtu(ifp, ETHERMTU);
    }
    bond_unlock();


    <span class="enscript-comment">/* first port added to bond determines bond's ethernet address */</span>
    <span class="enscript-keyword">if</span> (first) {
	ifnet_set_lladdr_and_type(ifp, IF_LLADDR(port_ifp), ETHER_ADDR_LEN,
				  IFT_ETHER);
    }

    progress |= BOND_ADD_PROGRESS_IN_LIST;

    <span class="enscript-comment">/* allocate a larger distributing array */</span>
    new_array = (bondport_ref *)
	_MALLOC(<span class="enscript-keyword">sizeof</span>(*new_array) * ifb-&gt;ifb_port_count, M_BOND, M_WAITOK);
    <span class="enscript-keyword">if</span> (new_array == NULL) {
	error = ENOMEM;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }

    <span class="enscript-comment">/* attach our BOND &quot;protocol&quot; to the interface */</span>
    error = bond_attach_protocol(port_ifp);
    <span class="enscript-keyword">if</span> (error) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    progress |= BOND_ADD_PROGRESS_PROTO_ATTACHED;

    <span class="enscript-comment">/* set the interface MTU */</span>
    devmtu = bond_device_mtu(ifp, ifb);
    error = siocsifmtu(port_ifp, devmtu);
    <span class="enscript-keyword">if</span> (error != 0) {
	printf(<span class="enscript-string">&quot;bond_add_interface(%s, %s):&quot;</span>
	       <span class="enscript-string">&quot; SIOCSIFMTU %d failed %d\n&quot;</span>, 
	       ifb-&gt;ifb_name, bondport_get_name(p), devmtu, error);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    progress |= BOND_ADD_PROGRESS_MTU_SET;

    <span class="enscript-comment">/* program the port with our multicast addresses */</span>
    error = multicast_list_program(&amp;p-&gt;po_multicast, ifp, port_ifp);
    <span class="enscript-keyword">if</span> (error) {
	printf(<span class="enscript-string">&quot;bond_add_interface(%s, %s):&quot;</span>
	       <span class="enscript-string">&quot; multicast_list_program failed %d\n&quot;</span>, 
	       ifb-&gt;ifb_name, bondport_get_name(p), error);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }

    <span class="enscript-comment">/* mark the interface up */</span>
    ifnet_set_flags(port_ifp, IFF_UP, IFF_UP);

    error = ifnet_ioctl(port_ifp, 0, SIOCSIFFLAGS, NULL);
    <span class="enscript-keyword">if</span> (error != 0) {
	printf(<span class="enscript-string">&quot;bond_add_interface(%s, %s): SIOCSIFFLAGS failed %d\n&quot;</span>, 
	       ifb-&gt;ifb_name, bondport_get_name(p), error);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }

    <span class="enscript-comment">/* re-program the port's ethernet address */</span>
    error = if_siflladdr(port_ifp, 
			 (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ether_addr *)IF_LLADDR(ifp));
    <span class="enscript-keyword">if</span> (error != 0) {
	<span class="enscript-comment">/* port doesn't support setting the link address */</span>
	printf(<span class="enscript-string">&quot;bond_add_interface(%s, %s): if_siflladdr failed %d\n&quot;</span>, 
	       ifb-&gt;ifb_name, bondport_get_name(p), error);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    progress |= BOND_ADD_PROGRESS_LLADDR_SET;

    bond_lock();

    <span class="enscript-comment">/* no failures past this point */</span>
    p-&gt;po_enabled = 1;

    <span class="enscript-comment">/* copy the contents of the existing distributing array */</span>
    <span class="enscript-keyword">if</span> (ifb-&gt;ifb_distributing_count) {
	bcopy(ifb-&gt;ifb_distributing_array, new_array, 
	      <span class="enscript-keyword">sizeof</span>(*new_array) * ifb-&gt;ifb_distributing_count);
    }
    old_array = ifb-&gt;ifb_distributing_array;
    ifb-&gt;ifb_distributing_array = new_array;

    <span class="enscript-keyword">if</span> (ifb-&gt;ifb_mode == IF_BOND_MODE_LACP) {
	bondport_start(p);

	<span class="enscript-comment">/* check if we need to generate a link status event */</span>
	<span class="enscript-keyword">if</span> (ifbond_selection(ifb)) {
	    event_code = (ifb-&gt;ifb_active_lag == NULL) 
		? KEV_DL_LINK_OFF 
		: KEV_DL_LINK_ON;
	    ifb-&gt;ifb_last_link_event = event_code;
	}
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/* are we adding the first distributing interface? */</span>
	<span class="enscript-keyword">if</span> (media_active(&amp;p-&gt;po_media_info)) {
	    <span class="enscript-keyword">if</span> (ifb-&gt;ifb_distributing_count == 0) {
		ifb-&gt;ifb_last_link_event = event_code = KEV_DL_LINK_ON;
	    }
	    bondport_enable_distributing(p);
	}
	<span class="enscript-keyword">else</span> {
	    bondport_disable_distributing(p);
	}
    }
    <span class="enscript-comment">/* clear the busy state, and wakeup anyone waiting */</span>
    ifbond_signal(ifb, <span class="enscript-string">&quot;bond_add_interface&quot;</span>);
    bond_unlock();
    <span class="enscript-keyword">if</span> (event_code != 0) {
	interface_link_event(ifp, event_code);
    }
    <span class="enscript-keyword">if</span> (old_array != NULL) {
	FREE(old_array, M_BOND);
    }
    <span class="enscript-keyword">return</span> 0;

 <span class="enscript-reference">failed</span>:
    bond_assert_lock_not_held();

    <span class="enscript-comment">/* if this was the first port to be added, clear our address */</span>
    <span class="enscript-keyword">if</span> (first) {
	ifnet_set_lladdr_and_type(ifp, NULL, 0, IFT_IEEE8023ADLAG);
    }

    <span class="enscript-keyword">if</span> (new_array != NULL) {
	FREE(new_array, M_BOND);
    }
    <span class="enscript-keyword">if</span> ((progress &amp; BOND_ADD_PROGRESS_LLADDR_SET) != 0) {
	<span class="enscript-type">int</span>	error1;

	error1 = if_siflladdr(port_ifp, &amp;p-&gt;po_saved_addr);
	<span class="enscript-keyword">if</span> (error1 != 0) {
	    printf(<span class="enscript-string">&quot;bond_add_interface(%s, %s): if_siflladdr failed %d\n&quot;</span>, 
		   ifb-&gt;ifb_name, bondport_get_name(p), error1);
	}
    }
    <span class="enscript-keyword">if</span> ((progress &amp; BOND_ADD_PROGRESS_PROTO_ATTACHED) != 0) {
	(<span class="enscript-type">void</span>)bond_detach_protocol(port_ifp);
    }
    <span class="enscript-keyword">if</span> ((progress &amp; BOND_ADD_PROGRESS_MTU_SET) != 0) {
	<span class="enscript-type">int</span> error1;

	error1 = siocsifmtu(port_ifp, p-&gt;po_devmtu.ifdm_current);
	<span class="enscript-keyword">if</span> (error1 != 0) {
	    printf(<span class="enscript-string">&quot;bond_add_interface(%s, %s): SIOCSIFMTU %d failed %d\n&quot;</span>, 
		   ifb-&gt;ifb_name, bondport_get_name(p),
		   p-&gt;po_devmtu.ifdm_current, error1);
	}
    }
    bond_lock();
    <span class="enscript-keyword">if</span> ((progress &amp; BOND_ADD_PROGRESS_IN_LIST) != 0) {
	TAILQ_REMOVE(&amp;ifb-&gt;ifb_port_list, p, po_port_list);
	ifb-&gt;ifb_port_count--;
    }
    ifnet_set_eflags(ifp, 0, IFEF_BOND);
    <span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;ifb-&gt;ifb_port_list)) {
	ifb-&gt;ifb_altmtu = 0;
	ifnet_set_mtu(ifp, 0);
	ifnet_set_offload(ifp, 0);
    }

 <span class="enscript-reference">signal_done</span>:
    ifbond_signal(ifb, <span class="enscript-string">&quot;bond_add_interface&quot;</span>);
    bond_unlock();
    ifbond_release(ifb);
    bondport_free(p);
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_remove_interface</span>(ifbond_ref ifb, <span class="enscript-type">struct</span> ifnet * port_ifp)
{
    <span class="enscript-type">int</span>				active_lag = 0;
    <span class="enscript-type">int</span> 			error = 0;
    <span class="enscript-type">int</span>				event_code = 0;
    bondport_ref		head_port;
    <span class="enscript-type">struct</span> ifnet *		ifp;
    <span class="enscript-type">int</span>				last = FALSE;
    <span class="enscript-type">int</span>				new_link_address = FALSE;
    bondport_ref 		p;
    lacp_actor_partner_state	s;
    <span class="enscript-type">int</span>				was_distributing;

    bond_assert_lock_held();

    ifbond_retain(ifb);
    ifbond_wait(ifb, <span class="enscript-string">&quot;bond_remove_interface&quot;</span>);

    p = ifbond_lookup_port(ifb, port_ifp);
    <span class="enscript-keyword">if</span> (p == NULL) {
	error = ENXIO;
	<span class="enscript-comment">/* it got removed by another thread */</span>
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">signal_done</span>;
    }

    <span class="enscript-comment">/* de-select it and remove it from the lists */</span>
    was_distributing = bondport_flags_distributing(p);
    bondport_disable_distributing(p);
    <span class="enscript-keyword">if</span> (ifb-&gt;ifb_mode == IF_BOND_MODE_LACP) {
	bondport_set_selected(p, SelectedState_UNSELECTED);
	active_lag = bondport_remove_from_LAG(p);
	<span class="enscript-comment">/* invalidate timers here while holding the bond_lock */</span>
	bondport_invalidate_timers(p);

	<span class="enscript-comment">/* announce that we're Individual now */</span>
	s = p-&gt;po_actor_state;
	s = lacp_actor_partner_state_set_individual(s);
	s = lacp_actor_partner_state_set_not_collecting(s);
	s = lacp_actor_partner_state_set_not_distributing(s);
	s = lacp_actor_partner_state_set_out_of_sync(s);
	p-&gt;po_actor_state = s;
	bondport_flags_set_ntt(p);
    }

    TAILQ_REMOVE(&amp;ifb-&gt;ifb_port_list, p, po_port_list);
    ifb-&gt;ifb_port_count--;

    ifp = ifb-&gt;ifb_ifp;
    head_port = TAILQ_FIRST(&amp;ifb-&gt;ifb_port_list);
    <span class="enscript-keyword">if</span> (head_port == NULL) {
	ifnet_set_flags(ifp, 0, IFF_RUNNING);
	<span class="enscript-keyword">if</span> (ifbond_flags_lladdr(ifb) == FALSE) {
	    last = TRUE;
	}
	ifnet_set_offload(ifp, 0);
	ifnet_set_mtu(ifp, 0);
	ifb-&gt;ifb_altmtu = 0;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifbond_flags_lladdr(ifb) == FALSE
	       &amp;&amp; bcmp(&amp;p-&gt;po_saved_addr, IF_LLADDR(ifp), 
		       ETHER_ADDR_LEN) == 0) {
	new_link_address = TRUE;
    }
    <span class="enscript-comment">/* check if we need to generate a link status event */</span>
    <span class="enscript-keyword">if</span> (ifb-&gt;ifb_mode == IF_BOND_MODE_LACP ) {
	<span class="enscript-keyword">if</span> (ifbond_selection(ifb) || active_lag) {
	    event_code = (ifb-&gt;ifb_active_lag == NULL) 
		? KEV_DL_LINK_OFF 
		: KEV_DL_LINK_ON;
	    ifb-&gt;ifb_last_link_event = event_code;
	}
	bondport_transmit_machine(p, LAEventStart,
				  TRANSMIT_MACHINE_TX_IMMEDIATE);
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/* are we removing the last distributing interface? */</span>
	<span class="enscript-keyword">if</span> (was_distributing &amp;&amp; ifb-&gt;ifb_distributing_count == 0) {
	    ifb-&gt;ifb_last_link_event = event_code = KEV_DL_LINK_OFF;
	}
    }

    bond_unlock();

    <span class="enscript-keyword">if</span> (last) {
	ifnet_set_lladdr_and_type(ifp, NULL, 0, IFT_IEEE8023ADLAG);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (new_link_address) {
	<span class="enscript-type">struct</span> ifnet *	scan_ifp;
	bondport_ref	scan_port;

	<span class="enscript-comment">/* ifbond_wait() allows port list traversal without holding the lock */</span>

	<span class="enscript-comment">/* this port gave the bond its ethernet address, switch to new one */</span>
	ifnet_set_lladdr_and_type(ifp,
				  &amp;head_port-&gt;po_saved_addr, ETHER_ADDR_LEN,
				  IFT_ETHER);

	<span class="enscript-comment">/* re-program each port with the new link address */</span>
	TAILQ_FOREACH(scan_port, &amp;ifb-&gt;ifb_port_list, po_port_list) {
	    scan_ifp = scan_port-&gt;po_ifp;

	    error = if_siflladdr(scan_ifp,
				 (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ether_addr *) IF_LLADDR(ifp));
	    <span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;bond_remove_interface(%s, %s): &quot;</span>
		       <span class="enscript-string">&quot;if_siflladdr (%s) failed %d\n&quot;</span>, 
		       ifb-&gt;ifb_name, bondport_get_name(p),
		       bondport_get_name(scan_port), error);
	    }
	}
    }

    <span class="enscript-comment">/* restore the port's ethernet address */</span>
    error = if_siflladdr(port_ifp, &amp;p-&gt;po_saved_addr);
    <span class="enscript-keyword">if</span> (error != 0) {
	printf(<span class="enscript-string">&quot;bond_remove_interface(%s, %s): if_siflladdr failed %d\n&quot;</span>, 
	       ifb-&gt;ifb_name, bondport_get_name(p), error);
    }

    <span class="enscript-comment">/* restore the port's MTU */</span>
    error = siocsifmtu(port_ifp, p-&gt;po_devmtu.ifdm_current);
    <span class="enscript-keyword">if</span> (error != 0) {
	printf(<span class="enscript-string">&quot;bond_remove_interface(%s, %s): SIOCSIFMTU %d failed %d\n&quot;</span>, 
	       ifb-&gt;ifb_name, bondport_get_name(p), 
	       p-&gt;po_devmtu.ifdm_current, error);
    }

    <span class="enscript-comment">/* remove the bond &quot;protocol&quot; */</span>
    bond_detach_protocol(port_ifp);

    <span class="enscript-comment">/* generate link event */</span>
    <span class="enscript-keyword">if</span> (event_code != 0) {
	interface_link_event(ifp, event_code);
    }

    bond_lock();
    bondport_free(p);
    ifnet_set_eflags(port_ifp, 0, IFEF_BOND);
    <span class="enscript-comment">/* release this bondport's reference to the ifbond */</span>
    ifbond_release(ifb);

 <span class="enscript-reference">signal_done</span>:
    ifbond_signal(ifb, <span class="enscript-string">&quot;bond_remove_interface&quot;</span>);
    ifbond_release(ifb);
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_set_lacp_mode</span>(ifbond_ref ifb)
{
    bondport_ref		p;

    TAILQ_FOREACH(p, &amp;ifb-&gt;ifb_port_list, po_port_list) {
	bondport_disable_distributing(p);
	bondport_start(p);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_set_static_mode</span>(ifbond_ref ifb)
{
    bondport_ref		p;
    lacp_actor_partner_state	s;

    TAILQ_FOREACH(p, &amp;ifb-&gt;ifb_port_list, po_port_list) {
	bondport_disable_distributing(p);
	bondport_set_selected(p, SelectedState_UNSELECTED);
	(<span class="enscript-type">void</span>)bondport_remove_from_LAG(p);
	bondport_cancel_timers(p);

	<span class="enscript-comment">/* announce that we're Individual now */</span>
	s = p-&gt;po_actor_state;
	s = lacp_actor_partner_state_set_individual(s);
	s = lacp_actor_partner_state_set_not_collecting(s);
	s = lacp_actor_partner_state_set_not_distributing(s);
	s = lacp_actor_partner_state_set_out_of_sync(s);
	p-&gt;po_actor_state = s;
	bondport_flags_set_ntt(p);
	bondport_transmit_machine(p, LAEventStart,
				  TRANSMIT_MACHINE_TX_IMMEDIATE);
	<span class="enscript-comment">/* clear state */</span>
	p-&gt;po_actor_state = 0;
	bzero(&amp;p-&gt;po_partner_state, <span class="enscript-keyword">sizeof</span>(p-&gt;po_partner_state));

	<span class="enscript-keyword">if</span> (media_active(&amp;p-&gt;po_media_info)) {
	    bondport_enable_distributing(p);
	}
	<span class="enscript-keyword">else</span> {
	    bondport_disable_distributing(p);
	}
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_set_mode</span>(<span class="enscript-type">struct</span> ifnet * ifp, <span class="enscript-type">int</span> mode)
{
    <span class="enscript-type">int</span>				error = 0;
    <span class="enscript-type">int</span>				event_code = 0;
    ifbond_ref			ifb;

    bond_lock();
    ifb = (ifbond_ref)ifnet_softc(ifp);
    <span class="enscript-keyword">if</span> (ifb == NULL || ifbond_flags_if_detaching(ifb)) {
	bond_unlock();
	<span class="enscript-keyword">return</span> ((ifb == NULL) ? EOPNOTSUPP : EBUSY);
    }
    <span class="enscript-keyword">if</span> (ifb-&gt;ifb_mode == mode) {
	bond_unlock();
	<span class="enscript-keyword">return</span> (0);
    }

    ifbond_retain(ifb);
    ifbond_wait(ifb, <span class="enscript-string">&quot;bond_set_mode&quot;</span>);

    <span class="enscript-comment">/* verify (again) that the mode is actually different */</span>
    <span class="enscript-keyword">if</span> (ifb-&gt;ifb_mode == mode) {
	<span class="enscript-comment">/* nothing to do */</span>
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">signal_done</span>;
    }

    ifb-&gt;ifb_mode = mode;
    <span class="enscript-keyword">if</span> (mode == IF_BOND_MODE_LACP) {
	bond_set_lacp_mode(ifb);
	
	<span class="enscript-comment">/* check if we need to generate a link status event */</span>
	<span class="enscript-keyword">if</span> (ifbond_selection(ifb)) {
	    event_code = (ifb-&gt;ifb_active_lag == NULL) 
		? KEV_DL_LINK_OFF 
		: KEV_DL_LINK_ON;
	}
    } <span class="enscript-keyword">else</span> {
	bond_set_static_mode(ifb);
	event_code = (ifb-&gt;ifb_distributing_count == 0) 
	    ? KEV_DL_LINK_OFF 
	    : KEV_DL_LINK_ON;
    }
    ifb-&gt;ifb_last_link_event = event_code;

 <span class="enscript-reference">signal_done</span>:
    ifbond_signal(ifb, <span class="enscript-string">&quot;bond_set_mode&quot;</span>);
    bond_unlock();
    ifbond_release(ifb);

    <span class="enscript-keyword">if</span> (event_code != 0) {
	interface_link_event(ifp, event_code);
    }
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_get_status</span>(ifbond_ref ifb, <span class="enscript-type">struct</span> if_bond_req * ibr_p, user_addr_t datap)
{
    <span class="enscript-type">int</span>				count;
    user_addr_t			dst;
    <span class="enscript-type">int</span>				error = 0;
    <span class="enscript-type">struct</span> if_bond_status_req *	ibsr;
    <span class="enscript-type">struct</span> if_bond_status	ibs;
    bondport_ref		port;

    ibsr = &amp;(ibr_p-&gt;ibr_ibru.ibru_status);
    <span class="enscript-keyword">if</span> (ibsr-&gt;ibsr_version != IF_BOND_STATUS_REQ_VERSION) {
	<span class="enscript-keyword">return</span> (EINVAL);
    }
    ibsr-&gt;ibsr_key = ifb-&gt;ifb_key;
    ibsr-&gt;ibsr_mode = ifb-&gt;ifb_mode;
    ibsr-&gt;ibsr_total = ifb-&gt;ifb_port_count;
    dst = proc_is64bit(current_proc())
	? ibsr-&gt;ibsr_ibsru.ibsru_buffer64
	: CAST_USER_ADDR_T(ibsr-&gt;ibsr_ibsru.ibsru_buffer);
    <span class="enscript-keyword">if</span> (dst == USER_ADDR_NULL) {
	<span class="enscript-comment">/* just want to know how many there are */</span>
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    <span class="enscript-keyword">if</span> (ibsr-&gt;ibsr_count &lt; 0) {
	<span class="enscript-keyword">return</span> (EINVAL);
    }
    count = (ifb-&gt;ifb_port_count &lt; ibsr-&gt;ibsr_count) 
	? ifb-&gt;ifb_port_count : ibsr-&gt;ibsr_count;
    TAILQ_FOREACH(port, &amp;ifb-&gt;ifb_port_list, po_port_list) {
	<span class="enscript-type">struct</span> if_bond_partner_state * 	ibps_p;
	partner_state_ref		ps;

	<span class="enscript-keyword">if</span> (count == 0) {
	    <span class="enscript-keyword">break</span>;
	}
	bzero(&amp;ibs, <span class="enscript-keyword">sizeof</span>(ibs));
	strlcpy(ibs.ibs_if_name, port-&gt;po_name, <span class="enscript-keyword">sizeof</span>(ibs.ibs_if_name));
	ibs.ibs_port_priority = port-&gt;po_priority;
	<span class="enscript-keyword">if</span> (ifb-&gt;ifb_mode == IF_BOND_MODE_LACP) {
	    ibs.ibs_state = port-&gt;po_actor_state;
	    ibs.ibs_selected_state = port-&gt;po_selected;
	    ps = &amp;port-&gt;po_partner_state;
	    ibps_p = &amp;ibs.ibs_partner_state;
	    ibps_p-&gt;ibps_system = ps-&gt;ps_lag_info.li_system;
	    ibps_p-&gt;ibps_system_priority = ps-&gt;ps_lag_info.li_system_priority;
	    ibps_p-&gt;ibps_key = ps-&gt;ps_lag_info.li_key;
	    ibps_p-&gt;ibps_port = ps-&gt;ps_port;
	    ibps_p-&gt;ibps_port_priority = ps-&gt;ps_port_priority;
	    ibps_p-&gt;ibps_state = ps-&gt;ps_state;
	}
	<span class="enscript-keyword">else</span> {
	    <span class="enscript-comment">/* fake the selected information */</span>
	    ibs.ibs_selected_state = bondport_flags_distributing(port)
		? SelectedState_SELECTED : SelectedState_UNSELECTED;
	}
	error = copyout(&amp;ibs, dst, <span class="enscript-keyword">sizeof</span>(ibs));
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">break</span>;
	}
	dst += <span class="enscript-keyword">sizeof</span>(ibs);
	count--;
    }

 <span class="enscript-reference">done</span>:
    <span class="enscript-keyword">if</span> (error == 0) {
	error = copyout(ibr_p, datap, <span class="enscript-keyword">sizeof</span>(*ibr_p));
    }
    <span class="enscript-keyword">else</span> {
	(<span class="enscript-type">void</span>)copyout(ibr_p, datap, <span class="enscript-keyword">sizeof</span>(*ibr_p));
    }
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_set_promisc</span>(__unused <span class="enscript-type">struct</span> ifnet *ifp)
{
    <span class="enscript-type">int</span> 		error = 0;
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_get_mtu_values</span>(ifbond_ref ifb, <span class="enscript-type">int</span> * ret_min, <span class="enscript-type">int</span> * ret_max)
{
    <span class="enscript-type">int</span>				mtu_min = 0;
    <span class="enscript-type">int</span>				mtu_max = 0;
    bondport_ref		p;

    <span class="enscript-keyword">if</span> (TAILQ_FIRST(&amp;ifb-&gt;ifb_port_list) != NULL) {
	mtu_min = IF_MINMTU;
    }
    TAILQ_FOREACH(p, &amp;ifb-&gt;ifb_port_list, po_port_list) {
	<span class="enscript-type">struct</span> ifdevmtu *	devmtu_p = &amp;p-&gt;po_devmtu;

	<span class="enscript-keyword">if</span> (devmtu_p-&gt;ifdm_min &gt; mtu_min) {
	    mtu_min = devmtu_p-&gt;ifdm_min;
	}
	<span class="enscript-keyword">if</span> (mtu_max == 0 || devmtu_p-&gt;ifdm_max &lt; mtu_max) {
	    mtu_max = devmtu_p-&gt;ifdm_max;
	}
    }
    *ret_min = mtu_min;
    *ret_max = mtu_max;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_set_mtu_on_ports</span>(ifbond_ref ifb, <span class="enscript-type">int</span> mtu)
{
    <span class="enscript-type">int</span>				error = 0;
    bondport_ref		p;

    TAILQ_FOREACH(p, &amp;ifb-&gt;ifb_port_list, po_port_list) {
	error = siocsifmtu(p-&gt;po_ifp, mtu);
	<span class="enscript-keyword">if</span> (error != 0) {
	    printf(<span class="enscript-string">&quot;if_bond(%s): SIOCSIFMTU %s failed, %d\n&quot;</span>,
		   ifb-&gt;ifb_name, bondport_get_name(p), error);
	    <span class="enscript-keyword">break</span>;
	}
    }
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_set_mtu</span>(<span class="enscript-type">struct</span> ifnet * ifp, <span class="enscript-type">int</span> mtu, <span class="enscript-type">int</span> isdevmtu)
{
    <span class="enscript-type">int</span>			error = 0;
    ifbond_ref		ifb;
    <span class="enscript-type">int</span>			mtu_min;
    <span class="enscript-type">int</span>			mtu_max;
    <span class="enscript-type">int</span>			new_max;
    <span class="enscript-type">int</span>			old_max;

    bond_lock();
    ifb = (ifbond_ref)ifnet_softc(ifp);
    <span class="enscript-keyword">if</span> (ifb == NULL || ifbond_flags_if_detaching(ifb)) {
	error = (ifb == NULL) ? EOPNOTSUPP : EBUSY;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    ifbond_retain(ifb);
    ifbond_wait(ifb, <span class="enscript-string">&quot;bond_set_mtu&quot;</span>);

    <span class="enscript-comment">/* check again */</span>
    <span class="enscript-keyword">if</span> (ifnet_softc(ifp) == NULL || ifbond_flags_if_detaching(ifb)) {
	error = EBUSY;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">signal_done</span>;
    }
    bond_get_mtu_values(ifb, &amp;mtu_min, &amp;mtu_max);
    <span class="enscript-keyword">if</span> (mtu &gt; mtu_max) {
	error = EINVAL;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">signal_done</span>;
    }
    <span class="enscript-keyword">if</span> (mtu &lt; mtu_min &amp;&amp; (isdevmtu == 0 || mtu != 0)) {
	<span class="enscript-comment">/* allow SIOCSIFALTMTU to set the mtu to 0 */</span>
	error = EINVAL;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">signal_done</span>;
    }
    <span class="enscript-keyword">if</span> (isdevmtu) {
	new_max = (mtu &gt; (<span class="enscript-type">int</span>)ifnet_mtu(ifp)) ? mtu : (<span class="enscript-type">int</span>)ifnet_mtu(ifp);
    }
    <span class="enscript-keyword">else</span> {
	new_max = (mtu &gt; ifb-&gt;ifb_altmtu) ? mtu : ifb-&gt;ifb_altmtu;
    }
    old_max = ((<span class="enscript-type">int</span>)ifnet_mtu(ifp) &gt; ifb-&gt;ifb_altmtu) 
	? (<span class="enscript-type">int</span>)ifnet_mtu(ifp) : ifb-&gt;ifb_altmtu;
    <span class="enscript-keyword">if</span> (new_max != old_max) {
	<span class="enscript-comment">/* we can safely walk the list of port without the lock held */</span>
	bond_unlock();
	error = bond_set_mtu_on_ports(ifb, new_max);
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-comment">/* try our best to back out of it */</span>
	    (<span class="enscript-type">void</span>)bond_set_mtu_on_ports(ifb, old_max);
	}
	bond_lock();
    }
    <span class="enscript-keyword">if</span> (error == 0) {
	<span class="enscript-keyword">if</span> (isdevmtu) {
	    ifb-&gt;ifb_altmtu = mtu;
	}
	<span class="enscript-keyword">else</span> {
		ifnet_set_mtu(ifp, mtu);
	}
    }

 <span class="enscript-reference">signal_done</span>:
    ifbond_signal(ifb, <span class="enscript-string">&quot;bond_set_mtu&quot;</span>);
    ifbond_release(ifb);
    
 <span class="enscript-reference">done</span>:
    bond_unlock();
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_ioctl</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, <span class="enscript-type">void</span> * data)
{
    <span class="enscript-type">int</span> 		error = 0;
    <span class="enscript-type">struct</span> if_bond_req	ibr;
    <span class="enscript-type">struct</span> ifaddr *	ifa;
    ifbond_ref		ifb;
    <span class="enscript-type">struct</span> ifreq *	ifr;
    <span class="enscript-type">struct</span> ifmediareq	*ifmr;
    <span class="enscript-type">struct</span> ifnet *	port_ifp = NULL;
    user_addr_t		user_addr;

    <span class="enscript-keyword">if</span> (ifnet_type(ifp) != IFT_IEEE8023ADLAG) {
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
    }
    ifr = (<span class="enscript-type">struct</span> ifreq *)data;
    ifa = (<span class="enscript-type">struct</span> ifaddr *)data;

    <span class="enscript-keyword">switch</span> (cmd) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFADDR</span>:
	ifnet_set_flags(ifp, IFF_UP, IFF_UP);
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMEDIA32</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMEDIA64</span>:
	bond_lock();
	ifb = (ifbond_ref)ifnet_softc(ifp);
	<span class="enscript-keyword">if</span> (ifb == NULL || ifbond_flags_if_detaching(ifb)) {
	    bond_unlock();
	    <span class="enscript-keyword">return</span> (ifb == NULL ? EOPNOTSUPP : EBUSY);
	}
	ifmr = (<span class="enscript-type">struct</span> ifmediareq *)data;
	ifmr-&gt;ifm_current = IFM_ETHER;
	ifmr-&gt;ifm_mask = 0;
	ifmr-&gt;ifm_status = IFM_AVALID;
	ifmr-&gt;ifm_active = IFM_ETHER;
	ifmr-&gt;ifm_count = 1;
	<span class="enscript-keyword">if</span> (ifb-&gt;ifb_mode == IF_BOND_MODE_LACP) {
	    <span class="enscript-keyword">if</span> (ifb-&gt;ifb_active_lag != NULL) {
		ifmr-&gt;ifm_active = ifb-&gt;ifb_active_lag-&gt;lag_active_media;
		ifmr-&gt;ifm_status |= IFM_ACTIVE;
	    }
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifb-&gt;ifb_distributing_count &gt; 0) {
	    ifmr-&gt;ifm_active
		= ifb-&gt;ifb_distributing_array[0]-&gt;po_media_info.mi_active;
	    ifmr-&gt;ifm_status |= IFM_ACTIVE;
	}
	bond_unlock();
	user_addr = (cmd == SIOCGIFMEDIA64) ?
	    ((<span class="enscript-type">struct</span> ifmediareq64 *)ifmr)-&gt;ifmu_ulist :
	    CAST_USER_ADDR_T(((<span class="enscript-type">struct</span> ifmediareq32 *)ifmr)-&gt;ifmu_ulist);
	<span class="enscript-keyword">if</span> (user_addr != USER_ADDR_NULL) {
	    error = copyout(&amp;ifmr-&gt;ifm_current,
			    user_addr,
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
	}
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMEDIA</span>:
	<span class="enscript-comment">/* XXX send the SIFMEDIA to all children?  Or force autoselect? */</span>
	error = EINVAL;
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDEVMTU</span>:
	bond_lock();
	ifb = (ifbond_ref)ifnet_softc(ifp);
	<span class="enscript-keyword">if</span> (ifb == NULL || ifbond_flags_if_detaching(ifb)) {
	    bond_unlock();
	    error = (ifb == NULL) ? EOPNOTSUPP : EBUSY;
	    <span class="enscript-keyword">break</span>;
	}
	ifr-&gt;ifr_devmtu.ifdm_current = bond_device_mtu(ifp, ifb);
	bond_get_mtu_values(ifb, &amp;ifr-&gt;ifr_devmtu.ifdm_min,
			    &amp;ifr-&gt;ifr_devmtu.ifdm_max);
	bond_unlock();
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFALTMTU</span>:
	bond_lock();
	ifb = (ifbond_ref)ifnet_softc(ifp);
	<span class="enscript-keyword">if</span> (ifb == NULL || ifbond_flags_if_detaching(ifb)) {
	    bond_unlock();
	    error = (ifb == NULL) ? EOPNOTSUPP : EBUSY;
	    <span class="enscript-keyword">break</span>;
	}
	ifr-&gt;ifr_mtu = ifb-&gt;ifb_altmtu;
	bond_unlock();
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFALTMTU</span>:
	error = bond_set_mtu(ifp, ifr-&gt;ifr_mtu, 1);
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMTU</span>:
	error = bond_set_mtu(ifp, ifr-&gt;ifr_mtu, 0);
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFBOND</span>:
	user_addr = proc_is64bit(current_proc())
	    ? ifr-&gt;ifr_data64 : CAST_USER_ADDR_T(ifr-&gt;ifr_data);
	error = copyin(user_addr, &amp;ibr, <span class="enscript-keyword">sizeof</span>(ibr));
	<span class="enscript-keyword">if</span> (error) {
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">switch</span> (ibr.ibr_op) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_BOND_OP_ADD_INTERFACE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_BOND_OP_REMOVE_INTERFACE</span>:
	    port_ifp = ifunit(ibr.ibr_ibru.ibru_if_name);
	    <span class="enscript-keyword">if</span> (port_ifp == NULL) {
		error = ENXIO;
		<span class="enscript-keyword">break</span>;
	    }
	    <span class="enscript-keyword">if</span> (ifnet_type(port_ifp) != IFT_ETHER) {
		error = EPROTONOSUPPORT;
		<span class="enscript-keyword">break</span>;
	    }
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_BOND_OP_SET_VERBOSE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_BOND_OP_SET_MODE</span>:
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
	    error = EOPNOTSUPP;
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">switch</span> (ibr.ibr_op) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_BOND_OP_ADD_INTERFACE</span>:
	    error = bond_add_interface(ifp, port_ifp);
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_BOND_OP_REMOVE_INTERFACE</span>:
	    bond_lock();
	    ifb = (ifbond_ref)ifnet_softc(ifp);
	    <span class="enscript-keyword">if</span> (ifb == NULL || ifbond_flags_if_detaching(ifb)) {
		bond_unlock();
		<span class="enscript-keyword">return</span> (ifb == NULL ? EOPNOTSUPP : EBUSY);
	    }
	    error = bond_remove_interface(ifb, port_ifp);
	    bond_unlock();
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_BOND_OP_SET_VERBOSE</span>:
	    bond_lock();
	    <span class="enscript-keyword">if</span> (g_bond == NULL) {
		bond_unlock();
		error = ENXIO;
		<span class="enscript-keyword">break</span>;
	    }
	    g_bond-&gt;verbose = ibr.ibr_ibru.ibru_int_val;
	    bond_unlock();
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_BOND_OP_SET_MODE</span>:
	    <span class="enscript-keyword">switch</span> (ibr.ibr_ibru.ibru_int_val) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">IF_BOND_MODE_LACP</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">IF_BOND_MODE_STATIC</span>:
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	    }
	    <span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">break</span>;
	    }
	    error = bond_set_mode(ifp, ibr.ibr_ibru.ibru_int_val);
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* SIOCSIFBOND */</span>
		
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFBOND</span>:
	user_addr = proc_is64bit(current_proc())
	    ? ifr-&gt;ifr_data64 : CAST_USER_ADDR_T(ifr-&gt;ifr_data);
	error = copyin(user_addr, &amp;ibr, <span class="enscript-keyword">sizeof</span>(ibr));
	<span class="enscript-keyword">if</span> (error) {
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">switch</span> (ibr.ibr_op) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_BOND_OP_GET_STATUS</span>:
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
	    error = EOPNOTSUPP;
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">break</span>;
	}
	bond_lock();
	ifb = (ifbond_ref)ifnet_softc(ifp);
	<span class="enscript-keyword">if</span> (ifb == NULL || ifbond_flags_if_detaching(ifb)) {
	    bond_unlock();
	    <span class="enscript-keyword">return</span> (ifb == NULL ? EOPNOTSUPP : EBUSY);
	}
	<span class="enscript-keyword">switch</span> (ibr.ibr_op) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_BOND_OP_GET_STATUS</span>:
	    error = bond_get_status(ifb, &amp;ibr, user_addr);
	    <span class="enscript-keyword">break</span>;
	}
	bond_unlock();
	<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* SIOCGIFBOND */</span>
		
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFLLADDR</span>:
	error = EOPNOTSUPP;
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFFLAGS</span>:
	<span class="enscript-comment">/* enable/disable promiscuous mode */</span>
	bond_lock();
	error = bond_set_promisc(ifp);
	bond_unlock();
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCADDMULTI</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDELMULTI</span>:
	error = bond_setmulti(ifp);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	error = EOPNOTSUPP;
    }
    <span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">bond_if_free</span>(<span class="enscript-type">struct</span> ifnet * ifp)
{
    ifbond_ref 	ifb;

    <span class="enscript-keyword">if</span> (ifp == NULL) {
	<span class="enscript-keyword">return</span>;
    }
    bond_lock();
    ifb = (ifbond_ref)ifnet_softc(ifp);
    <span class="enscript-keyword">if</span> (ifb == NULL) {
	bond_unlock();
	<span class="enscript-keyword">return</span>;
    }
    ifbond_release(ifb);
    bond_unlock();
    ifnet_release(ifp);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_handle_event</span>(<span class="enscript-type">struct</span> ifnet * port_ifp, <span class="enscript-type">int</span> event_code)
{
    <span class="enscript-type">struct</span> ifnet *	bond_ifp = NULL;
    ifbond_ref		ifb;
    <span class="enscript-type">int</span>			old_distributing_count;
    bondport_ref	p;
    <span class="enscript-type">struct</span> media_info	media_info = { 0, 0};

    <span class="enscript-keyword">switch</span> (event_code) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_IF_DETACHED</span>:
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_LINK_OFF</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_LINK_ON</span>:
	media_info = interface_media_info(port_ifp);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">return</span>;
    }
    bond_lock();
    p = bond_lookup_port(port_ifp);
    <span class="enscript-keyword">if</span> (p == NULL) {
	bond_unlock();
	<span class="enscript-keyword">return</span>;
    }
    ifb = p-&gt;po_bond;
    old_distributing_count = ifb-&gt;ifb_distributing_count;
    <span class="enscript-keyword">switch</span> (event_code) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_IF_DETACHED</span>:
	bond_remove_interface(ifb, p-&gt;po_ifp);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_LINK_OFF</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_LINK_ON</span>:
	p-&gt;po_media_info = media_info;
	<span class="enscript-keyword">if</span> (p-&gt;po_enabled) {
	    bondport_link_status_changed(p);
	}
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-comment">/* generate a link-event */</span>
    <span class="enscript-keyword">if</span> (ifb-&gt;ifb_mode == IF_BOND_MODE_LACP) {
	<span class="enscript-keyword">if</span> (ifbond_selection(ifb)) {
	    event_code = (ifb-&gt;ifb_active_lag == NULL) 
		? KEV_DL_LINK_OFF 
		: KEV_DL_LINK_ON;
	    <span class="enscript-comment">/* XXX need to take a reference on bond_ifp */</span>
	    bond_ifp = ifb-&gt;ifb_ifp;
	    ifb-&gt;ifb_last_link_event = event_code;
	}
	<span class="enscript-keyword">else</span> {
	    event_code = (ifb-&gt;ifb_active_lag == NULL) 
		? KEV_DL_LINK_OFF 
		: KEV_DL_LINK_ON;
	    <span class="enscript-keyword">if</span> (event_code != ifb-&gt;ifb_last_link_event) {
		<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		    timestamp_printf(<span class="enscript-string">&quot;%s: (event) generating LINK event\n&quot;</span>,
				     ifb-&gt;ifb_name);
		}
		bond_ifp = ifb-&gt;ifb_ifp;
		ifb-&gt;ifb_last_link_event = event_code;
	    }
	}
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/*
	 * if the distributing array membership changed from 0 &lt;-&gt; !0
	 * generate a link event
	 */</span>
	<span class="enscript-keyword">if</span> (old_distributing_count == 0 
	    &amp;&amp; ifb-&gt;ifb_distributing_count != 0) {
	    event_code = KEV_DL_LINK_ON;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (old_distributing_count != 0 
		 &amp;&amp; ifb-&gt;ifb_distributing_count == 0) {
	    event_code = KEV_DL_LINK_OFF;
	}
	<span class="enscript-keyword">if</span> (event_code != 0 &amp;&amp; event_code != ifb-&gt;ifb_last_link_event) {
	    bond_ifp = ifb-&gt;ifb_ifp;
	    ifb-&gt;ifb_last_link_event = event_code;
	}
    }

    bond_unlock();
    <span class="enscript-keyword">if</span> (bond_ifp != NULL) {
	interface_link_event(bond_ifp, event_code);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bond_event</span>(<span class="enscript-type">struct</span> ifnet * port_ifp, __unused protocol_family_t protocol,
	   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> kev_msg * event)
{
    <span class="enscript-type">int</span>		event_code;

    <span class="enscript-keyword">if</span> (event-&gt;vendor_code != KEV_VENDOR_APPLE 
	|| event-&gt;kev_class != KEV_NETWORK_CLASS 
	|| event-&gt;kev_subclass != KEV_DL_SUBCLASS) {
	<span class="enscript-keyword">return</span>;
    }
    event_code = event-&gt;event_code;
    <span class="enscript-keyword">switch</span> (event_code) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_LINK_OFF</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_LINK_ON</span>:
	<span class="enscript-comment">/* we only care about link status changes */</span>
	bond_handle_event(port_ifp, event_code);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">bond_detached</span>(ifnet_t port_ifp, __unused protocol_family_t protocol)
{
    bond_handle_event(port_ifp, KEV_DL_IF_DETACHED);
    <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">interface_link_event</span>(<span class="enscript-type">struct</span> ifnet * ifp, u_int32_t event_code)
{
    <span class="enscript-type">struct</span> {
	<span class="enscript-type">struct</span> kern_event_msg	header;
	u_int32_t			unit;
	<span class="enscript-type">char</span>			if_name[IFNAMSIZ];
    } event;

    bzero(&amp;event, <span class="enscript-keyword">sizeof</span>(event));
    event.header.total_size    = <span class="enscript-keyword">sizeof</span>(event);
    event.header.vendor_code   = KEV_VENDOR_APPLE;
    event.header.kev_class     = KEV_NETWORK_CLASS;
    event.header.kev_subclass  = KEV_DL_SUBCLASS;
    event.header.event_code    = event_code;
    event.header.event_data[0] = ifnet_family(ifp);
    event.unit                 = (u_int32_t) ifnet_unit(ifp);
    strlcpy(event.if_name, ifnet_name(ifp), IFNAMSIZ);
    ifnet_event(ifp, &amp;event.header);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Function: bond_attach_protocol
 * Purpose:
 *   Attach a DLIL protocol to the interface.
 *
 *   The ethernet demux special cases to always return PF_BOND if the 
 *   interface is bonded.  That means we receive all traffic from that
 *   interface without passing any of the traffic to any other attached
 *   protocol.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_attach_protocol</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
    <span class="enscript-type">int</span>								error;
    <span class="enscript-type">struct</span> ifnet_attach_proto_param	reg;
	
    bzero(&amp;reg, <span class="enscript-keyword">sizeof</span>(reg));
    reg.input = bond_input;
    reg.event = bond_event;
    reg.detached = bond_detached;
	
    error = ifnet_attach_protocol(ifp, PF_BOND, &amp;reg);
    <span class="enscript-keyword">if</span> (error) {
	printf(<span class="enscript-string">&quot;bond over %s%d: ifnet_attach_protocol failed, %d\n&quot;</span>,
	       ifnet_name(ifp), ifnet_unit(ifp), error);
    }
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Function: bond_detach_protocol
 * Purpose:
 *   Detach our DLIL protocol from an interface
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_detach_protocol</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
    <span class="enscript-type">int</span>         error;

    error = ifnet_detach_protocol(ifp, PF_BOND);
    <span class="enscript-keyword">if</span> (error) {
	printf(<span class="enscript-string">&quot;bond over %s%d: ifnet_detach_protocol failed, %d\n&quot;</span>,
	       ifnet_name(ifp), ifnet_unit(ifp), error);
    }
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * DLIL interface family functions
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ether_attach_inet</span>(ifnet_t ifp, protocol_family_t protocol_family);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ether_detach_inet</span>(ifnet_t ifp, protocol_family_t protocol_family);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ether_attach_inet6</span>(ifnet_t ifp, protocol_family_t protocol_family);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ether_detach_inet6</span>(ifnet_t ifp, protocol_family_t protocol_family);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ether_attach_at</span>(ifnet_t ifp, protocol_family_t protocol_family);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ether_detach_at</span>(ifnet_t ifp, protocol_family_t protocol_family);

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">bond_family_init</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> error=0;

    error = proto_register_plumber(PF_INET, APPLE_IF_FAM_BOND, 
				  ether_attach_inet, 
				  ether_detach_inet);
    <span class="enscript-keyword">if</span> (error != 0) {
	printf(<span class="enscript-string">&quot;bond: proto_register_plumber failed for AF_INET error=%d\n&quot;</span>,
	       error);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
    error = proto_register_plumber(PF_INET6, APPLE_IF_FAM_BOND, 
				  ether_attach_inet6, 
				  ether_detach_inet6);
    <span class="enscript-keyword">if</span> (error != 0) {
	printf(<span class="enscript-string">&quot;bond: proto_register_plumber failed for AF_INET6 error=%d\n&quot;</span>,
	       error);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
#<span class="enscript-reference">endif</span>
    error = bond_clone_attach();
    <span class="enscript-keyword">if</span> (error != 0) {
        printf(<span class="enscript-string">&quot;bond: proto_register_plumber failed bond_clone_attach error=%d\n&quot;</span>,
               error);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

 <span class="enscript-reference">done</span>:
    <span class="enscript-keyword">return</span> (error);
}
<span class="enscript-comment">/**
 **
 ** LACP routines:
 **
 **/</span>

<span class="enscript-comment">/**
 ** LACP ifbond_list routines
 **/</span>
<span class="enscript-type">static</span> bondport_ref
<span class="enscript-function-name">ifbond_list_find_moved_port</span>(bondport_ref rx_port, 
			    <span class="enscript-type">const</span> lacp_actor_partner_tlv_ref atlv)
{
    ifbond_ref		bond;
    bondport_ref	p;
    partner_state_ref	ps;
    LAG_info_ref	ps_li;

    TAILQ_FOREACH(bond, &amp;g_bond-&gt;ifbond_list, ifb_bond_list) {
	TAILQ_FOREACH(p, &amp;bond-&gt;ifb_port_list, po_port_list) {

	    <span class="enscript-keyword">if</span> (rx_port == p) {
		<span class="enscript-comment">/* no point in comparing against ourselves */</span>
		<span class="enscript-keyword">continue</span>;
	    }
	    <span class="enscript-keyword">if</span> (p-&gt;po_receive_state != ReceiveState_PORT_DISABLED) {
		<span class="enscript-comment">/* it's not clear that we should be checking this */</span>
		<span class="enscript-keyword">continue</span>;
	    }
	    ps = &amp;p-&gt;po_partner_state;
	    <span class="enscript-keyword">if</span> (lacp_actor_partner_state_defaulted(ps-&gt;ps_state)) {
		<span class="enscript-keyword">continue</span>;
	    }
	    ps_li = &amp;ps-&gt;ps_lag_info;
	    <span class="enscript-keyword">if</span> (ps-&gt;ps_port == lacp_actor_partner_tlv_get_port(atlv)
		&amp;&amp; bcmp(&amp;ps_li-&gt;li_system, atlv-&gt;lap_system,
			<span class="enscript-keyword">sizeof</span>(ps_li-&gt;li_system)) == 0) {
		<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		    timestamp_printf(<span class="enscript-string">&quot;System &quot;</span> EA_FORMAT 
				     <span class="enscript-string">&quot; Port 0x%x moved from %s to %s\n&quot;</span>,
				     EA_LIST(&amp;ps_li-&gt;li_system), ps-&gt;ps_port, 
				     bondport_get_name(p), 
				     bondport_get_name(rx_port));
		}
		<span class="enscript-keyword">return</span> (p);
	    }
	}
    }
    <span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/**
 ** LACP ifbond, LAG routines
 **/</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ifbond_selection</span>(ifbond_ref bond)
{
    <span class="enscript-type">int</span>			all_ports_ready = 0;
    <span class="enscript-type">int</span>			active_media = 0;
    LAG_ref		lag = NULL;
    <span class="enscript-type">int</span>			lag_changed = 0;
    bondport_ref	p;
    <span class="enscript-type">int</span>			port_speed = 0;
    
    lag = ifbond_find_best_LAG(bond, &amp;active_media);
    <span class="enscript-keyword">if</span> (lag != bond-&gt;ifb_active_lag) {
	<span class="enscript-keyword">if</span> (bond-&gt;ifb_active_lag != NULL) {
	    ifbond_deactivate_LAG(bond, bond-&gt;ifb_active_lag);
	    bond-&gt;ifb_active_lag = NULL;
	}
	bond-&gt;ifb_active_lag = lag;
	<span class="enscript-keyword">if</span> (lag != NULL) {
	    ifbond_activate_LAG(bond, lag, active_media);
	}
	lag_changed = 1;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lag != NULL) {
	<span class="enscript-keyword">if</span> (lag-&gt;lag_active_media != active_media) {
	    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		timestamp_printf(<span class="enscript-string">&quot;LAG PORT SPEED CHANGED from %d to %d\n&quot;</span>,
				 link_speed(lag-&gt;lag_active_media), 
				 link_speed(active_media));
	    }
	    ifbond_deactivate_LAG(bond, lag);
	    ifbond_activate_LAG(bond, lag, active_media);
	    lag_changed = 1;
	}
    }
    <span class="enscript-keyword">if</span> (lag != NULL) {
	port_speed = link_speed(active_media);
	all_ports_ready = ifbond_all_ports_ready(bond);
    }
    TAILQ_FOREACH(p, &amp;bond-&gt;ifb_port_list, po_port_list) {
	<span class="enscript-keyword">if</span> (lag != NULL &amp;&amp; p-&gt;po_lag == lag
	    &amp;&amp; media_speed(&amp;p-&gt;po_media_info) == port_speed
	    &amp;&amp; (p-&gt;po_mux_state == MuxState_DETACHED
		|| p-&gt;po_selected == SelectedState_SELECTED
		|| p-&gt;po_selected == SelectedState_STANDBY)
	    &amp;&amp; bondport_aggregatable(p)) {
	    <span class="enscript-keyword">if</span> (bond-&gt;ifb_max_active &gt; 0) {
		<span class="enscript-keyword">if</span> (lag-&gt;lag_selected_port_count &lt; bond-&gt;ifb_max_active) {
		    <span class="enscript-keyword">if</span> (p-&gt;po_selected == SelectedState_STANDBY
			|| p-&gt;po_selected == SelectedState_UNSELECTED) {
			bondport_set_selected(p, SelectedState_SELECTED);
		    }
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p-&gt;po_selected == SelectedState_UNSELECTED) {
		    bondport_set_selected(p, SelectedState_STANDBY);
		}
	    }
	    <span class="enscript-keyword">else</span> {
		bondport_set_selected(p, SelectedState_SELECTED);
	    }
	}
	<span class="enscript-keyword">if</span> (bondport_flags_selected_changed(p)) {
	    bondport_flags_clear_selected_changed(p);
	    bondport_mux_machine(p, LAEventSelectedChange, NULL);
	}
	<span class="enscript-keyword">if</span> (all_ports_ready
	    &amp;&amp; bondport_flags_ready(p)
	    &amp;&amp; p-&gt;po_mux_state == MuxState_WAITING) {
	    bondport_mux_machine(p, LAEventReady, NULL);
	}
	bondport_transmit_machine(p, LAEventStart, NULL);
    }
    <span class="enscript-keyword">return</span> (lag_changed);
}

<span class="enscript-type">static</span> LAG_ref
<span class="enscript-function-name">ifbond_find_best_LAG</span>(ifbond_ref bond, <span class="enscript-type">int</span> * active_media)
{
    <span class="enscript-type">int</span>			best_active = 0;
    LAG_ref		best_lag = NULL;
    <span class="enscript-type">int</span>			best_count = 0;
    <span class="enscript-type">int</span>			best_speed = 0;
    LAG_ref		lag;

    <span class="enscript-keyword">if</span> (bond-&gt;ifb_active_lag != NULL) {
	best_lag = bond-&gt;ifb_active_lag;
	best_count = LAG_get_aggregatable_port_count(best_lag, &amp;best_active);
	<span class="enscript-keyword">if</span> (bond-&gt;ifb_max_active &gt; 0
	    &amp;&amp; best_count &gt; bond-&gt;ifb_max_active) {
	    best_count = bond-&gt;ifb_max_active;
	}
	best_speed = link_speed(best_active);
    }
    TAILQ_FOREACH(lag, &amp;bond-&gt;ifb_lag_list, lag_list) {
	<span class="enscript-type">int</span>	active;
	<span class="enscript-type">int</span>	count;
	<span class="enscript-type">int</span>	speed;

	<span class="enscript-keyword">if</span> (lag == bond-&gt;ifb_active_lag) {
	    <span class="enscript-comment">/* we've already computed it */</span>
	    <span class="enscript-keyword">continue</span>;
	}
	count = LAG_get_aggregatable_port_count(lag, &amp;active);
	<span class="enscript-keyword">if</span> (count == 0) {
	    <span class="enscript-keyword">continue</span>;
	}
	<span class="enscript-keyword">if</span> (bond-&gt;ifb_max_active &gt; 0
	    &amp;&amp; count &gt; bond-&gt;ifb_max_active) {
	    <span class="enscript-comment">/* if there's a limit, don't count extra links */</span>
	    count = bond-&gt;ifb_max_active;
	}
	speed = link_speed(active);
	<span class="enscript-keyword">if</span> ((count * speed) &gt; (best_count * best_speed)) {
	    best_count = count;
	    best_speed = speed;
	    best_active = active;
	    best_lag = lag;
	}
    }
    <span class="enscript-keyword">if</span> (best_count == 0) {
	<span class="enscript-keyword">return</span> (NULL);
    }
    *active_media = best_active;
    <span class="enscript-keyword">return</span> (best_lag);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifbond_deactivate_LAG</span>(__unused ifbond_ref bond, LAG_ref lag)
{
    bondport_ref	p;

    TAILQ_FOREACH(p, &amp;lag-&gt;lag_port_list, po_lag_port_list) {
	bondport_set_selected(p, SelectedState_UNSELECTED);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifbond_activate_LAG</span>(ifbond_ref bond, LAG_ref lag, <span class="enscript-type">int</span> active_media)
{
    <span class="enscript-type">int</span>			need = 0;
    bondport_ref	p;

    <span class="enscript-keyword">if</span> (bond-&gt;ifb_max_active &gt; 0) {
	need = bond-&gt;ifb_max_active;
    }
    lag-&gt;lag_active_media = active_media;
    TAILQ_FOREACH(p, &amp;lag-&gt;lag_port_list, po_lag_port_list) {
	<span class="enscript-keyword">if</span> (bondport_aggregatable(p) == 0) {
	    bondport_set_selected(p, SelectedState_UNSELECTED);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (media_speed(&amp;p-&gt;po_media_info) != link_speed(active_media)) {
	    bondport_set_selected(p, SelectedState_UNSELECTED);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p-&gt;po_mux_state == MuxState_DETACHED) {
	    <span class="enscript-keyword">if</span> (bond-&gt;ifb_max_active &gt; 0) {
		<span class="enscript-keyword">if</span> (need &gt; 0) {
		    bondport_set_selected(p, SelectedState_SELECTED);
		    need--;
		}
		<span class="enscript-keyword">else</span> {
		    bondport_set_selected(p, SelectedState_STANDBY);
		}
	    }
	    <span class="enscript-keyword">else</span> {
		bondport_set_selected(p, SelectedState_SELECTED);
	    }
	}
	<span class="enscript-keyword">else</span> {
	    bondport_set_selected(p, SelectedState_UNSELECTED);
	}
    }
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifbond_set_max_active</span>(ifbond_ref bond, <span class="enscript-type">int</span> max_active)
{
    LAG_ref	lag = bond-&gt;ifb_active_lag;

    bond-&gt;ifb_max_active = max_active;
    <span class="enscript-keyword">if</span> (bond-&gt;ifb_max_active &lt;= 0 || lag == NULL) {
	<span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (lag-&gt;lag_selected_port_count &gt; bond-&gt;ifb_max_active) {
	bondport_ref	p;
	<span class="enscript-type">int</span>			remove_count;

	remove_count = lag-&gt;lag_selected_port_count - bond-&gt;ifb_max_active;
	TAILQ_FOREACH(p, &amp;lag-&gt;lag_port_list, po_lag_port_list) {
	    <span class="enscript-keyword">if</span> (p-&gt;po_selected == SelectedState_SELECTED) {
		bondport_set_selected(p, SelectedState_UNSELECTED);
		remove_count--;
		<span class="enscript-keyword">if</span> (remove_count == 0) {
		    <span class="enscript-keyword">break</span>;
		}
	    }
	}
    }
    <span class="enscript-keyword">return</span>;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ifbond_all_ports_ready</span>(ifbond_ref bond)
{
    <span class="enscript-type">int</span>			ready = 0;
    bondport_ref	p;

    <span class="enscript-keyword">if</span> (bond-&gt;ifb_active_lag == NULL) {
	<span class="enscript-keyword">return</span> (0);
    }
    TAILQ_FOREACH(p, &amp;bond-&gt;ifb_active_lag-&gt;lag_port_list, po_lag_port_list) {
	<span class="enscript-keyword">if</span> (p-&gt;po_mux_state == MuxState_WAITING
	    &amp;&amp; p-&gt;po_selected == SelectedState_SELECTED) {
	    <span class="enscript-keyword">if</span> (bondport_flags_ready(p) == 0) {
		<span class="enscript-keyword">return</span> (0);
	    }
	}
	<span class="enscript-comment">/* note that there was at least one ready port */</span>
	ready = 1;
    }
    <span class="enscript-keyword">return</span> (ready);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ifbond_all_ports_attached</span>(ifbond_ref bond, bondport_ref this_port)
{
    bondport_ref	p;

    TAILQ_FOREACH(p, &amp;bond-&gt;ifb_port_list, po_port_list) {
	<span class="enscript-keyword">if</span> (this_port == p) {
	    <span class="enscript-keyword">continue</span>;
	}
	<span class="enscript-keyword">if</span> (bondport_flags_mux_attached(p) == 0) {
	    <span class="enscript-keyword">return</span> (0);
	}
    }
    <span class="enscript-keyword">return</span> (1);
}

<span class="enscript-type">static</span> LAG_ref
<span class="enscript-function-name">ifbond_get_LAG_matching_port</span>(ifbond_ref bond, bondport_ref p)
{
    LAG_ref	lag;

    TAILQ_FOREACH(lag, &amp;bond-&gt;ifb_lag_list, lag_list) {
	<span class="enscript-keyword">if</span> (bcmp(&amp;lag-&gt;lag_info, &amp;p-&gt;po_partner_state.ps_lag_info,
		 <span class="enscript-keyword">sizeof</span>(lag-&gt;lag_info)) == 0) {
	    <span class="enscript-keyword">return</span> (lag);
	}
    }
    <span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">LAG_get_aggregatable_port_count</span>(LAG_ref lag, <span class="enscript-type">int</span> * active_media)
{
    <span class="enscript-type">int</span>			active;
    <span class="enscript-type">int</span> 		count;
    bondport_ref	p;
    <span class="enscript-type">int</span>			speed;

    active = 0;
    count = 0;
    speed = 0;
    TAILQ_FOREACH(p, &amp;lag-&gt;lag_port_list, po_lag_port_list) {
	<span class="enscript-keyword">if</span> (bondport_aggregatable(p)) {
	    <span class="enscript-type">int</span> this_speed;

	    this_speed = media_speed(&amp;p-&gt;po_media_info);
	    <span class="enscript-keyword">if</span> (this_speed == 0) {
		<span class="enscript-keyword">continue</span>;
	    }
	    <span class="enscript-keyword">if</span> (this_speed &gt; speed) {
		active = p-&gt;po_media_info.mi_active;
		speed = this_speed;
		count = 1;
	    }
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (this_speed == speed) {
		count++;
	    }
	}
    }
    *active_media = active;
    <span class="enscript-keyword">return</span> (count);
}


<span class="enscript-comment">/**
 ** LACP bondport routines
 **/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_link_status_changed</span>(bondport_ref p)
{
    ifbond_ref	bond = p-&gt;po_bond;

    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	<span class="enscript-keyword">if</span> (media_active(&amp;p-&gt;po_media_info)) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Link UP %d Mbit/s %s duplex\n&quot;</span>, 
			     bondport_get_name(p),
			     media_speed(&amp;p-&gt;po_media_info),
			     media_full_duplex(&amp;p-&gt;po_media_info) 
			     ? <span class="enscript-string">&quot;full&quot;</span> : <span class="enscript-string">&quot;half&quot;</span>);
	}
	<span class="enscript-keyword">else</span> {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Link DOWN\n&quot;</span>, bondport_get_name(p));
	}
    }
    <span class="enscript-keyword">if</span> (bond-&gt;ifb_mode == IF_BOND_MODE_LACP) {
	<span class="enscript-keyword">if</span> (media_active(&amp;p-&gt;po_media_info)
	    &amp;&amp; bond-&gt;ifb_active_lag != NULL
	    &amp;&amp; p-&gt;po_lag == bond-&gt;ifb_active_lag
	    &amp;&amp; p-&gt;po_selected != SelectedState_UNSELECTED) {
	    <span class="enscript-keyword">if</span> (media_speed(&amp;p-&gt;po_media_info) != p-&gt;po_lag-&gt;lag_active_media) {
		<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		    timestamp_printf(<span class="enscript-string">&quot;[%s] Port speed %d differs from LAG %d\n&quot;</span>,
				     bondport_get_name(p),
				     media_speed(&amp;p-&gt;po_media_info),
				     link_speed(p-&gt;po_lag-&gt;lag_active_media));
		}
		bondport_set_selected(p, SelectedState_UNSELECTED);
	    }
	}
	bondport_receive_machine(p, LAEventMediaChange, NULL);
	bondport_mux_machine(p, LAEventMediaChange, NULL);
	bondport_periodic_transmit_machine(p, LAEventMediaChange, NULL);
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">if</span> (media_active(&amp;p-&gt;po_media_info)) {
	    bondport_enable_distributing(p);
	}
	<span class="enscript-keyword">else</span> {
	    bondport_disable_distributing(p);
	}
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_aggregatable</span>(bondport_ref p)
{
    partner_state_ref 	ps = &amp;p-&gt;po_partner_state;

    <span class="enscript-keyword">if</span> (lacp_actor_partner_state_aggregatable(p-&gt;po_actor_state) == 0
	|| lacp_actor_partner_state_aggregatable(ps-&gt;ps_state) == 0) {
	<span class="enscript-comment">/* we and/or our partner are individual */</span>
	<span class="enscript-keyword">return</span> (0);
    }
    <span class="enscript-keyword">if</span> (p-&gt;po_lag == NULL) {
	<span class="enscript-keyword">return</span> (0);
    }
    <span class="enscript-keyword">switch</span> (p-&gt;po_receive_state) {
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Port is not selectable\n&quot;</span>, 
			     bondport_get_name(p));
	}
	<span class="enscript-keyword">return</span> (0);
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ReceiveState_CURRENT</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ReceiveState_EXPIRED</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span> (1);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_matches_LAG</span>(bondport_ref p, LAG_ref lag)
{
    LAG_info_ref	lag_li;
    partner_state_ref	ps;
    LAG_info_ref	ps_li;

    ps = &amp;p-&gt;po_partner_state;
    ps_li = &amp;ps-&gt;ps_lag_info;
    lag_li = &amp;lag-&gt;lag_info;
    <span class="enscript-keyword">if</span> (ps_li-&gt;li_system_priority == lag_li-&gt;li_system_priority
	&amp;&amp; ps_li-&gt;li_key == lag_li-&gt;li_key
	&amp;&amp; (bcmp(&amp;ps_li-&gt;li_system, &amp;lag_li-&gt;li_system, 
		 <span class="enscript-keyword">sizeof</span>(lag_li-&gt;li_system))
	    == 0)) {
	<span class="enscript-keyword">return</span> (1);
    }
    <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_remove_from_LAG</span>(bondport_ref p)
{
    <span class="enscript-type">int</span>		active_lag = 0;
    ifbond_ref	bond = p-&gt;po_bond;
    LAG_ref	lag = p-&gt;po_lag;

    <span class="enscript-keyword">if</span> (lag == NULL) {
	<span class="enscript-keyword">return</span> (0);
    }
    TAILQ_REMOVE(&amp;lag-&gt;lag_port_list, p, po_lag_port_list);
    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	timestamp_printf(<span class="enscript-string">&quot;[%s] Removed from LAG (0x%04x,&quot;</span> EA_FORMAT 
			 <span class="enscript-string">&quot;,0x%04x)\n&quot;</span>,
			 bondport_get_name(p),
			 lag-&gt;lag_info.li_system_priority,
			 EA_LIST(&amp;lag-&gt;lag_info.li_system),
			 lag-&gt;lag_info.li_key);
    }
    p-&gt;po_lag = NULL;
    lag-&gt;lag_port_count--;
    <span class="enscript-keyword">if</span> (lag-&gt;lag_port_count &gt; 0) {
	<span class="enscript-keyword">return</span> (bond-&gt;ifb_active_lag == lag);
    }
    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	timestamp_printf(<span class="enscript-string">&quot;Key 0x%04x: LAG Released (%04x,&quot;</span> EA_FORMAT 
			 <span class="enscript-string">&quot;,0x%04x)\n&quot;</span>,
			 bond-&gt;ifb_key,
			 lag-&gt;lag_info.li_system_priority,
			 EA_LIST(&amp;lag-&gt;lag_info.li_system),
			 lag-&gt;lag_info.li_key);
    }
    TAILQ_REMOVE(&amp;bond-&gt;ifb_lag_list, lag, lag_list);
    <span class="enscript-keyword">if</span> (bond-&gt;ifb_active_lag == lag) {
	bond-&gt;ifb_active_lag = NULL;
	active_lag = 1;
    }
    FREE(lag, M_BOND);
    <span class="enscript-keyword">return</span> (active_lag);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_add_to_LAG</span>(bondport_ref p, LAG_ref lag)
{
    TAILQ_INSERT_TAIL(&amp;lag-&gt;lag_port_list, p, po_lag_port_list);
    p-&gt;po_lag = lag;
    lag-&gt;lag_port_count++;
    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	timestamp_printf(<span class="enscript-string">&quot;[%s] Added to LAG (0x%04x,&quot;</span> EA_FORMAT <span class="enscript-string">&quot;0x%04x)\n&quot;</span>,
			 bondport_get_name(p),
			 lag-&gt;lag_info.li_system_priority,
			 EA_LIST(&amp;lag-&gt;lag_info.li_system),
			 lag-&gt;lag_info.li_key);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_assign_to_LAG</span>(bondport_ref p)
{
    ifbond_ref	bond = p-&gt;po_bond;
    LAG_ref	lag;

    <span class="enscript-keyword">if</span> (lacp_actor_partner_state_defaulted(p-&gt;po_actor_state)) {
	bondport_remove_from_LAG(p);
	<span class="enscript-keyword">return</span>;
    }
    lag = p-&gt;po_lag;
    <span class="enscript-keyword">if</span> (lag != NULL) {
	<span class="enscript-keyword">if</span> (bondport_matches_LAG(p, lag)) {
	    <span class="enscript-comment">/* still OK */</span>
	    <span class="enscript-keyword">return</span>;
	}
	bondport_remove_from_LAG(p);
    }
    lag = ifbond_get_LAG_matching_port(bond, p);
    <span class="enscript-keyword">if</span> (lag != NULL) {
	bondport_add_to_LAG(p, lag);
	<span class="enscript-keyword">return</span>;
    }
    lag = (LAG_ref)_MALLOC(<span class="enscript-keyword">sizeof</span>(*lag), M_BOND, M_WAITOK);
    TAILQ_INIT(&amp;lag-&gt;lag_port_list);
    lag-&gt;lag_port_count = 0;
    lag-&gt;lag_selected_port_count = 0;
    lag-&gt;lag_info = p-&gt;po_partner_state.ps_lag_info;
    TAILQ_INSERT_TAIL(&amp;bond-&gt;ifb_lag_list, lag, lag_list);
    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	timestamp_printf(<span class="enscript-string">&quot;Key 0x%04x: LAG Created (0x%04x,&quot;</span> EA_FORMAT 
			 <span class="enscript-string">&quot;,0x%04x)\n&quot;</span>,
			 bond-&gt;ifb_key,
			 lag-&gt;lag_info.li_system_priority,
			 EA_LIST(&amp;lag-&gt;lag_info.li_system),
			 lag-&gt;lag_info.li_key);
    }
    bondport_add_to_LAG(p, lag);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_lacpdu</span>(bondport_ref p, lacpdu_ref in_lacpdu_p)
{
    bondport_ref		moved_port;

    moved_port
	= ifbond_list_find_moved_port(p, (<span class="enscript-type">const</span> lacp_actor_partner_tlv_ref)
				      &amp;in_lacpdu_p-&gt;la_actor_tlv);
    <span class="enscript-keyword">if</span> (moved_port != NULL) {
	bondport_receive_machine(moved_port, LAEventPortMoved, NULL);
    }
    bondport_receive_machine(p, LAEventPacket, in_lacpdu_p);
    bondport_mux_machine(p, LAEventPacket, in_lacpdu_p);
    bondport_periodic_transmit_machine(p, LAEventPacket, in_lacpdu_p);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">bondport_set_selected</span>(bondport_ref p, SelectedState s)
{
    <span class="enscript-keyword">if</span> (s != p-&gt;po_selected) {
	ifbond_ref	bond = p-&gt;po_bond;
	LAG_ref		lag = p-&gt;po_lag;

	bondport_flags_set_selected_changed(p);
	<span class="enscript-keyword">if</span> (lag != NULL &amp;&amp; bond-&gt;ifb_active_lag == lag) {
	    <span class="enscript-keyword">if</span> (p-&gt;po_selected == SelectedState_SELECTED) {
		lag-&gt;lag_selected_port_count--;
	    }
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == SelectedState_SELECTED) {
		lag-&gt;lag_selected_port_count++;
	    }
	    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		timestamp_printf(<span class="enscript-string">&quot;[%s] SetSelected: %s (was %s)\n&quot;</span>,
				 bondport_get_name(p), 
				 SelectedStateString(s),
				 SelectedStateString(p-&gt;po_selected));
	    }
	}
    }
    p-&gt;po_selected = s;
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/**
 ** Receive machine
 **/</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_UpdateDefaultSelected</span>(bondport_ref p)
{
    bondport_set_selected(p, SelectedState_UNSELECTED);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_RecordDefault</span>(bondport_ref p)
{
    bzero(&amp;p-&gt;po_partner_state, <span class="enscript-keyword">sizeof</span>(p-&gt;po_partner_state));
    p-&gt;po_actor_state 
	= lacp_actor_partner_state_set_defaulted(p-&gt;po_actor_state);
    bondport_assign_to_LAG(p);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_UpdateSelected</span>(bondport_ref p, lacpdu_ref lacpdu_p)
{
    lacp_actor_partner_tlv_ref	actor;
    partner_state_ref		ps;
    LAG_info_ref		ps_li;

    <span class="enscript-comment">/* compare the PDU's Actor information to our Partner state */</span>
    actor = (lacp_actor_partner_tlv_ref)lacpdu_p-&gt;la_actor_tlv;
    ps = &amp;p-&gt;po_partner_state;
    ps_li = &amp;ps-&gt;ps_lag_info;
    <span class="enscript-keyword">if</span> (lacp_actor_partner_tlv_get_port(actor) != ps-&gt;ps_port
	|| (lacp_actor_partner_tlv_get_port_priority(actor)
	    != ps-&gt;ps_port_priority)
	|| bcmp(actor-&gt;lap_system, &amp;ps_li-&gt;li_system, <span class="enscript-keyword">sizeof</span>(ps_li-&gt;li_system))
	|| (lacp_actor_partner_tlv_get_system_priority(actor) 
	    != ps_li-&gt;li_system_priority)
	|| (lacp_actor_partner_tlv_get_key(actor) != ps_li-&gt;li_key)
	|| (lacp_actor_partner_state_aggregatable(actor-&gt;lap_state)
	    != lacp_actor_partner_state_aggregatable(ps-&gt;ps_state))) {
	bondport_set_selected(p, SelectedState_UNSELECTED);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] updateSelected UNSELECTED\n&quot;</span>,
			     bondport_get_name(p));
	}
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_RecordPDU</span>(bondport_ref p, lacpdu_ref lacpdu_p)
{
    lacp_actor_partner_tlv_ref	actor;
    ifbond_ref			bond = p-&gt;po_bond;
    <span class="enscript-type">int</span>				lacp_maintain = 0;
    partner_state_ref		ps;
    lacp_actor_partner_tlv_ref	partner;
    LAG_info_ref		ps_li;

    <span class="enscript-comment">/* copy the PDU's Actor information into our Partner state */</span>
    actor = (lacp_actor_partner_tlv_ref)lacpdu_p-&gt;la_actor_tlv;
    ps = &amp;p-&gt;po_partner_state;
    ps_li = &amp;ps-&gt;ps_lag_info;
    ps-&gt;ps_port = lacp_actor_partner_tlv_get_port(actor);
    ps-&gt;ps_port_priority = lacp_actor_partner_tlv_get_port_priority(actor);
    ps_li-&gt;li_system = *((lacp_system_ref)actor-&gt;lap_system);
    ps_li-&gt;li_system_priority 
	= lacp_actor_partner_tlv_get_system_priority(actor);
    ps_li-&gt;li_key = lacp_actor_partner_tlv_get_key(actor);
    ps-&gt;ps_state = lacp_actor_partner_state_set_out_of_sync(actor-&gt;lap_state);
    p-&gt;po_actor_state 
	= lacp_actor_partner_state_set_not_defaulted(p-&gt;po_actor_state);

    <span class="enscript-comment">/* compare the PDU's Partner information to our own information */</span>
    partner = (lacp_actor_partner_tlv_ref)lacpdu_p-&gt;la_partner_tlv;

    <span class="enscript-keyword">if</span> (lacp_actor_partner_state_active_lacp(ps-&gt;ps_state)
	|| (lacp_actor_partner_state_active_lacp(p-&gt;po_actor_state)
	    &amp;&amp; lacp_actor_partner_state_active_lacp(partner-&gt;lap_state))) {
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] recordPDU: LACP will maintain\n&quot;</span>,
			     bondport_get_name(p));
	}
	lacp_maintain = 1;
    }
    <span class="enscript-keyword">if</span> ((lacp_actor_partner_tlv_get_port(partner) 
	 == bondport_get_index(p))
	&amp;&amp; lacp_actor_partner_tlv_get_port_priority(partner) == p-&gt;po_priority
	&amp;&amp; bcmp(partner-&gt;lap_system, &amp;g_bond-&gt;system, 
		<span class="enscript-keyword">sizeof</span>(g_bond-&gt;system)) == 0
	&amp;&amp; (lacp_actor_partner_tlv_get_system_priority(partner) 
	    == g_bond-&gt;system_priority)
	&amp;&amp; lacp_actor_partner_tlv_get_key(partner) == bond-&gt;ifb_key
	&amp;&amp; (lacp_actor_partner_state_aggregatable(partner-&gt;lap_state)
	    == lacp_actor_partner_state_aggregatable(p-&gt;po_actor_state))
	&amp;&amp; lacp_actor_partner_state_in_sync(actor-&gt;lap_state)
	&amp;&amp; lacp_maintain) {
	ps-&gt;ps_state = lacp_actor_partner_state_set_in_sync(ps-&gt;ps_state);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] recordPDU: LACP partner in sync\n&quot;</span>,
			     bondport_get_name(p));
	}
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lacp_actor_partner_state_aggregatable(actor-&gt;lap_state) == 0
	     &amp;&amp; lacp_actor_partner_state_in_sync(actor-&gt;lap_state)
	     &amp;&amp; lacp_maintain) {
	ps-&gt;ps_state = lacp_actor_partner_state_set_in_sync(ps-&gt;ps_state);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] recordPDU: LACP partner in sync (ind)\n&quot;</span>,
			     bondport_get_name(p));
	}
    }
    bondport_assign_to_LAG(p);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ lacp_actor_partner_state
<span class="enscript-function-name">updateNTTBits</span>(lacp_actor_partner_state s)
{
    <span class="enscript-keyword">return</span> (s &amp; (LACP_ACTOR_PARTNER_STATE_LACP_ACTIVITY
		 | LACP_ACTOR_PARTNER_STATE_LACP_TIMEOUT
		 | LACP_ACTOR_PARTNER_STATE_AGGREGATION
		 | LACP_ACTOR_PARTNER_STATE_SYNCHRONIZATION));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_UpdateNTT</span>(bondport_ref p, lacpdu_ref lacpdu_p)
{
    ifbond_ref			bond = p-&gt;po_bond;
    lacp_actor_partner_tlv_ref	partner;

    <span class="enscript-comment">/* compare the PDU's Actor information to our Partner state */</span>
    partner = (lacp_actor_partner_tlv_ref)lacpdu_p-&gt;la_partner_tlv;
    <span class="enscript-keyword">if</span> ((lacp_actor_partner_tlv_get_port(partner) != bondport_get_index(p))
	|| lacp_actor_partner_tlv_get_port_priority(partner) != p-&gt;po_priority
	|| bcmp(partner-&gt;lap_system, &amp;g_bond-&gt;system, <span class="enscript-keyword">sizeof</span>(g_bond-&gt;system))
	|| (lacp_actor_partner_tlv_get_system_priority(partner) 
	    != g_bond-&gt;system_priority)
	|| lacp_actor_partner_tlv_get_key(partner) != bond-&gt;ifb_key
	|| (updateNTTBits(partner-&gt;lap_state) 
	    != updateNTTBits(p-&gt;po_actor_state))) {
	bondport_flags_set_ntt(p);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] updateNTT: Need To Transmit\n&quot;</span>,
			     bondport_get_name(p));
	}
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_AttachMuxToAggregator</span>(bondport_ref p)
{
    <span class="enscript-keyword">if</span> (bondport_flags_mux_attached(p) == 0) {
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Attached Mux To Aggregator\n&quot;</span>,
			     bondport_get_name(p));
	}
	bondport_flags_set_mux_attached(p);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_DetachMuxFromAggregator</span>(bondport_ref p)
{
    <span class="enscript-keyword">if</span> (bondport_flags_mux_attached(p)) {
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Detached Mux From Aggregator\n&quot;</span>,
			     bondport_get_name(p));
	}
	bondport_flags_clear_mux_attached(p);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_enable_distributing</span>(bondport_ref p)
{
    <span class="enscript-keyword">if</span> (bondport_flags_distributing(p) == 0) {
	ifbond_ref	bond = p-&gt;po_bond;

	bond-&gt;ifb_distributing_array[bond-&gt;ifb_distributing_count++] = p;
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Distribution Enabled\n&quot;</span>,
			     bondport_get_name(p));
	}
	bondport_flags_set_distributing(p);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_disable_distributing</span>(bondport_ref p)
{
    <span class="enscript-keyword">if</span> (bondport_flags_distributing(p)) {
	bondport_ref *	array;
	ifbond_ref	bond;
	<span class="enscript-type">int</span>		count;
	<span class="enscript-type">int</span>		i;

	bond = p-&gt;po_bond;
	array = bond-&gt;ifb_distributing_array;
	count = bond-&gt;ifb_distributing_count;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
	    <span class="enscript-keyword">if</span> (array[i] == p) {
		<span class="enscript-type">int</span>	j;

		<span class="enscript-keyword">for</span> (j = i; j &lt; (count - 1); j++) {
		    array[j] = array[j + 1];
		}
		<span class="enscript-keyword">break</span>;
	    }
	}
	bond-&gt;ifb_distributing_count--;
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Distribution Disabled\n&quot;</span>,
			     bondport_get_name(p));
	}
	bondport_flags_clear_distributing(p);
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/**
 ** Receive machine functions
 **/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_initialize</span>(bondport_ref p, LAEvent event,
				    <span class="enscript-type">void</span> * event_data);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_port_disabled</span>(bondport_ref p, LAEvent event,
				       <span class="enscript-type">void</span> * event_data);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_expired</span>(bondport_ref p, LAEvent event,
				 <span class="enscript-type">void</span> * event_data);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_lacp_disabled</span>(bondport_ref p, LAEvent event,
				       <span class="enscript-type">void</span> * event_data);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_defaulted</span>(bondport_ref p, LAEvent event,
				   <span class="enscript-type">void</span> * event_data);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_current</span>(bondport_ref p, LAEvent event,
				 <span class="enscript-type">void</span> * event_data);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_event</span>(bondport_ref p, LAEvent event, 
			       <span class="enscript-type">void</span> * event_data)
{
    <span class="enscript-keyword">switch</span> (p-&gt;po_receive_state) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ReceiveState_none</span>:
	bondport_receive_machine_initialize(p, LAEventStart, NULL);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ReceiveState_INITIALIZE</span>:
	bondport_receive_machine_initialize(p, event, event_data);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ReceiveState_PORT_DISABLED</span>:
	bondport_receive_machine_port_disabled(p, event, event_data);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ReceiveState_EXPIRED</span>:
	bondport_receive_machine_expired(p, event, event_data);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ReceiveState_LACP_DISABLED</span>:
	bondport_receive_machine_lacp_disabled(p, event, event_data);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ReceiveState_DEFAULTED</span>:
	bondport_receive_machine_defaulted(p, event, event_data);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">ReceiveState_CURRENT</span>:
	bondport_receive_machine_current(p, event, event_data);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine</span>(bondport_ref p, LAEvent event,
			 <span class="enscript-type">void</span> * event_data)
{
    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventPacket</span>:
	<span class="enscript-keyword">if</span> (p-&gt;po_receive_state != ReceiveState_LACP_DISABLED) {
	    bondport_receive_machine_current(p, event, event_data);
	}
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventMediaChange</span>:
	<span class="enscript-keyword">if</span> (media_active(&amp;p-&gt;po_media_info)) {
	    <span class="enscript-keyword">switch</span> (p-&gt;po_receive_state) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">ReceiveState_PORT_DISABLED</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">ReceiveState_LACP_DISABLED</span>:
		bondport_receive_machine_port_disabled(p, LAEventMediaChange, NULL);
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	    }
	}
	<span class="enscript-keyword">else</span> {
	    bondport_receive_machine_port_disabled(p, LAEventStart, NULL);
	}
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	bondport_receive_machine_event(p, event, event_data);
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_initialize</span>(bondport_ref p, LAEvent event,
				    __unused <span class="enscript-type">void</span> * event_data)
{
    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventStart</span>:
	devtimer_cancel(p-&gt;po_current_while_timer);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Receive INITIALIZE\n&quot;</span>,
			     bondport_get_name(p));
	}
	p-&gt;po_receive_state = ReceiveState_INITIALIZE;
	bondport_set_selected(p, SelectedState_UNSELECTED);
	bondport_RecordDefault(p);
	p-&gt;po_actor_state
	    = lacp_actor_partner_state_set_not_expired(p-&gt;po_actor_state);
	bondport_receive_machine_port_disabled(p, LAEventStart, NULL);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_port_disabled</span>(bondport_ref p, LAEvent event,
				       __unused <span class="enscript-type">void</span> * event_data)
{
    partner_state_ref	ps;

    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventStart</span>:
	devtimer_cancel(p-&gt;po_current_while_timer);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Receive PORT_DISABLED\n&quot;</span>,
			     bondport_get_name(p));
	}
	p-&gt;po_receive_state = ReceiveState_PORT_DISABLED;
	ps = &amp;p-&gt;po_partner_state;
	ps-&gt;ps_state = lacp_actor_partner_state_set_out_of_sync(ps-&gt;ps_state);
	<span class="enscript-comment">/* FALL THROUGH */</span>
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventMediaChange</span>:
	<span class="enscript-keyword">if</span> (media_active(&amp;p-&gt;po_media_info)) {
	    <span class="enscript-keyword">if</span> (media_full_duplex(&amp;p-&gt;po_media_info)) {
		bondport_receive_machine_expired(p, LAEventStart, NULL);
	    }
	    <span class="enscript-keyword">else</span> {
		bondport_receive_machine_lacp_disabled(p, LAEventStart, NULL);
	    }
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p-&gt;po_selected == SelectedState_SELECTED) {
	    <span class="enscript-type">struct</span> timeval	tv;

	    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		timestamp_printf(<span class="enscript-string">&quot;[%s] Receive PORT_DISABLED: &quot;</span>
				 <span class="enscript-string">&quot;link timer started\n&quot;</span>,
				 bondport_get_name(p));
	    }
	    tv.tv_sec = 1;
	    tv.tv_usec = 0;
	    devtimer_set_relative(p-&gt;po_current_while_timer, tv, 
				  (devtimer_timeout_func)
				  bondport_receive_machine_port_disabled,
				  (<span class="enscript-type">void</span> *)LAEventTimeout, NULL);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p-&gt;po_selected == SelectedState_STANDBY) {
	    bondport_set_selected(p, SelectedState_UNSELECTED);
	}
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventTimeout</span>:
	<span class="enscript-keyword">if</span> (p-&gt;po_selected == SelectedState_SELECTED) {
	    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		timestamp_printf(<span class="enscript-string">&quot;[%s] Receive PORT_DISABLED: &quot;</span>
				 <span class="enscript-string">&quot;link timer completed, marking UNSELECTED\n&quot;</span>,
				 bondport_get_name(p));
	    }
	    bondport_set_selected(p, SelectedState_UNSELECTED);
	}
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventPortMoved</span>:
	bondport_receive_machine_initialize(p, LAEventStart, NULL);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_expired</span>(bondport_ref p, LAEvent event,
				 __unused <span class="enscript-type">void</span> * event_data)
{
    lacp_actor_partner_state	s;
    <span class="enscript-type">struct</span> timeval 		tv;

    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventStart</span>:
	devtimer_cancel(p-&gt;po_current_while_timer);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Receive EXPIRED\n&quot;</span>,
			     bondport_get_name(p));
	}
	p-&gt;po_receive_state = ReceiveState_EXPIRED;
	s = p-&gt;po_partner_state.ps_state;
	s = lacp_actor_partner_state_set_out_of_sync(s);
	s = lacp_actor_partner_state_set_short_timeout(s);
	p-&gt;po_partner_state.ps_state = s;
	p-&gt;po_actor_state 
	    = lacp_actor_partner_state_set_expired(p-&gt;po_actor_state);
	<span class="enscript-comment">/* start current_while timer */</span>
	tv.tv_sec = LACP_SHORT_TIMEOUT_TIME;
	tv.tv_usec = 0;
	devtimer_set_relative(p-&gt;po_current_while_timer, tv, 
			      (devtimer_timeout_func)
			      bondport_receive_machine_expired,
			      (<span class="enscript-type">void</span> *)LAEventTimeout, NULL);

	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventTimeout</span>:
	bondport_receive_machine_defaulted(p, LAEventStart, NULL);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_lacp_disabled</span>(bondport_ref p, LAEvent event,
				       __unused <span class="enscript-type">void</span> * event_data)
{
    partner_state_ref	ps;
    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventStart</span>:
	devtimer_cancel(p-&gt;po_current_while_timer);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Receive LACP_DISABLED\n&quot;</span>,
			     bondport_get_name(p));
	}
	p-&gt;po_receive_state = ReceiveState_LACP_DISABLED;
	bondport_set_selected(p, SelectedState_UNSELECTED);
	bondport_RecordDefault(p);
	ps = &amp;p-&gt;po_partner_state;
	ps-&gt;ps_state = lacp_actor_partner_state_set_individual(ps-&gt;ps_state);
	p-&gt;po_actor_state
	    = lacp_actor_partner_state_set_not_expired(p-&gt;po_actor_state);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_defaulted</span>(bondport_ref p, LAEvent event,
				   __unused <span class="enscript-type">void</span> * event_data)
{
    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventStart</span>:
	devtimer_cancel(p-&gt;po_current_while_timer);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Receive DEFAULTED\n&quot;</span>,
			     bondport_get_name(p));
	}
	p-&gt;po_receive_state = ReceiveState_DEFAULTED;
	bondport_UpdateDefaultSelected(p);
	bondport_RecordDefault(p);
	p-&gt;po_actor_state
	    = lacp_actor_partner_state_set_not_expired(p-&gt;po_actor_state);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_receive_machine_current</span>(bondport_ref p, LAEvent event,
				 <span class="enscript-type">void</span> * event_data)
{
    partner_state_ref	ps;
    <span class="enscript-type">struct</span> timeval	tv;

    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventPacket</span>:
	devtimer_cancel(p-&gt;po_current_while_timer);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Receive CURRENT\n&quot;</span>,
			     bondport_get_name(p));
	}
	p-&gt;po_receive_state = ReceiveState_CURRENT;
	bondport_UpdateSelected(p, event_data);
	bondport_UpdateNTT(p, event_data);
	bondport_RecordPDU(p, event_data);
	p-&gt;po_actor_state
	    = lacp_actor_partner_state_set_not_expired(p-&gt;po_actor_state);
	bondport_assign_to_LAG(p);
	<span class="enscript-comment">/* start current_while timer */</span>
	ps = &amp;p-&gt;po_partner_state;
	<span class="enscript-keyword">if</span> (lacp_actor_partner_state_short_timeout(ps-&gt;ps_state)) {
	    tv.tv_sec = LACP_SHORT_TIMEOUT_TIME;
	}
	<span class="enscript-keyword">else</span> {
	    tv.tv_sec = LACP_LONG_TIMEOUT_TIME;
	}
	tv.tv_usec = 0;
	devtimer_set_relative(p-&gt;po_current_while_timer, tv,
			      (devtimer_timeout_func)
			      bondport_receive_machine_current,
			      (<span class="enscript-type">void</span> *)LAEventTimeout, NULL);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventTimeout</span>:
	bondport_receive_machine_expired(p, LAEventStart, NULL);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/**
 ** Periodic Transmission machine
 **/</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_periodic_transmit_machine</span>(bondport_ref p, LAEvent event,
				   __unused <span class="enscript-type">void</span> * event_data)
{
    <span class="enscript-type">int</span>			interval;
    partner_state_ref	ps;
    <span class="enscript-type">struct</span> timeval	tv;

    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventStart</span>:
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] periodic_transmit Start\n&quot;</span>,
			     bondport_get_name(p));
	}
	<span class="enscript-comment">/* FALL THROUGH */</span>
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventMediaChange</span>:
	devtimer_cancel(p-&gt;po_periodic_timer);
	p-&gt;po_periodic_interval = 0;
	<span class="enscript-keyword">if</span> (media_active(&amp;p-&gt;po_media_info) == 0
	    || media_full_duplex(&amp;p-&gt;po_media_info) == 0) {
	    <span class="enscript-keyword">break</span>;
	}
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventPacket</span>:
	<span class="enscript-comment">/* Neither Partner nor Actor are LACP Active, no periodic tx */</span>
	ps = &amp;p-&gt;po_partner_state;
	<span class="enscript-keyword">if</span> (lacp_actor_partner_state_active_lacp(p-&gt;po_actor_state) == 0
	    &amp;&amp; (lacp_actor_partner_state_active_lacp(ps-&gt;ps_state) 
		== 0)) {
	    devtimer_cancel(p-&gt;po_periodic_timer);
	    p-&gt;po_periodic_interval = 0;
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (lacp_actor_partner_state_short_timeout(ps-&gt;ps_state)) {
	    interval = LACP_FAST_PERIODIC_TIME;
	}
	<span class="enscript-keyword">else</span> {
	    interval = LACP_SLOW_PERIODIC_TIME;
	}
	<span class="enscript-keyword">if</span> (p-&gt;po_periodic_interval != interval) {
	    <span class="enscript-keyword">if</span> (interval == LACP_FAST_PERIODIC_TIME
		&amp;&amp; p-&gt;po_periodic_interval == LACP_SLOW_PERIODIC_TIME) {
		<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		    timestamp_printf(<span class="enscript-string">&quot;[%s] periodic_transmit:&quot;</span>
				     <span class="enscript-string">&quot; Need To Transmit\n&quot;</span>,
				     bondport_get_name(p));
		}
		bondport_flags_set_ntt(p);
	    }
	    p-&gt;po_periodic_interval = interval;
	    tv.tv_usec = 0;
	    tv.tv_sec = interval;
	    devtimer_set_relative(p-&gt;po_periodic_timer, tv, 
				  (devtimer_timeout_func)
				  bondport_periodic_transmit_machine,
				  (<span class="enscript-type">void</span> *)LAEventTimeout, NULL);
	    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		timestamp_printf(<span class="enscript-string">&quot;[%s] Periodic Transmission Timer: %d secs\n&quot;</span>,
				 bondport_get_name(p), 
				 p-&gt;po_periodic_interval);
	    }
	}
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventTimeout</span>:
	bondport_flags_set_ntt(p);
	tv.tv_sec = p-&gt;po_periodic_interval;
	tv.tv_usec = 0;
	devtimer_set_relative(p-&gt;po_periodic_timer, tv, (devtimer_timeout_func)
			      bondport_periodic_transmit_machine,
			      (<span class="enscript-type">void</span> *)LAEventTimeout, NULL);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose &gt; 1) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Periodic Transmission Timer: %d secs\n&quot;</span>,
			     bondport_get_name(p), p-&gt;po_periodic_interval);
	}
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/**
 ** Transmit machine
 **/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bondport_can_transmit</span>(bondport_ref p, int32_t current_secs,
		      __darwin_time_t * next_secs)
{
    <span class="enscript-keyword">if</span> (p-&gt;po_last_transmit_secs != current_secs) {
	p-&gt;po_last_transmit_secs = current_secs;
	p-&gt;po_n_transmit = 0;
    }
    <span class="enscript-keyword">if</span> (p-&gt;po_n_transmit &lt; LACP_PACKET_RATE) {
	p-&gt;po_n_transmit++;
	<span class="enscript-keyword">return</span> (1);
    }
    <span class="enscript-keyword">if</span> (next_secs != NULL) {
	*next_secs = current_secs + 1;
    }
    <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_transmit_machine</span>(bondport_ref p, LAEvent event,
			  <span class="enscript-type">void</span> * event_data)
{
    lacp_actor_partner_tlv_ref	aptlv;
    lacp_collector_tlv_ref	ctlv;
    <span class="enscript-type">struct</span> timeval		next_tick_time = {0, 0};
    lacpdu_ref		out_lacpdu_p;
    packet_buffer_ref		pkt;
    partner_state_ref		ps;
    LAG_info_ref		ps_li;

    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventTimeout</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventStart</span>:
	<span class="enscript-keyword">if</span> (p-&gt;po_periodic_interval == 0 || bondport_flags_ntt(p) == 0) {
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (event_data == TRANSMIT_MACHINE_TX_IMMEDIATE) {
	    <span class="enscript-comment">/* we're going away, transmit the packet no matter what */</span>
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bondport_can_transmit(p, devtimer_current_secs(),
				       &amp;next_tick_time.tv_sec) == 0) {
	    <span class="enscript-keyword">if</span> (devtimer_enabled(p-&gt;po_transmit_timer)) {
		<span class="enscript-keyword">if</span> (g_bond-&gt;verbose &gt; 0) {
		    timestamp_printf(<span class="enscript-string">&quot;[%s] Transmit Timer Already Set\n&quot;</span>,
				     bondport_get_name(p));
		}
	    }
	    <span class="enscript-keyword">else</span> {
		devtimer_set_absolute(p-&gt;po_transmit_timer, next_tick_time,
				      (devtimer_timeout_func)
				      bondport_transmit_machine,
				      (<span class="enscript-type">void</span> *)LAEventTimeout, NULL);
		<span class="enscript-keyword">if</span> (g_bond-&gt;verbose &gt; 0) {
		    timestamp_printf(<span class="enscript-string">&quot;[%s] Transmit Timer Deadline %d secs\n&quot;</span>,
				     bondport_get_name(p),
				     (<span class="enscript-type">int</span>)next_tick_time.tv_sec);
		}
	    }
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose &gt; 0) {
	    <span class="enscript-keyword">if</span> (event == LAEventTimeout) {
		timestamp_printf(<span class="enscript-string">&quot;[%s] Transmit Timer Complete\n&quot;</span>,
				 bondport_get_name(p));
	    }
	}
	pkt = packet_buffer_allocate(<span class="enscript-keyword">sizeof</span>(*out_lacpdu_p));
	<span class="enscript-keyword">if</span> (pkt == NULL) {
	    printf(<span class="enscript-string">&quot;[%s] Transmit: failed to allocate packet buffer\n&quot;</span>,
		   bondport_get_name(p));
	    <span class="enscript-keyword">break</span>;
	}
	out_lacpdu_p = (lacpdu_ref)packet_buffer_byteptr(pkt);
	bzero(out_lacpdu_p, <span class="enscript-keyword">sizeof</span>(*out_lacpdu_p));
	out_lacpdu_p-&gt;la_subtype = IEEE8023AD_SLOW_PROTO_SUBTYPE_LACP;
	out_lacpdu_p-&gt;la_version = LACPDU_VERSION_1;

	<span class="enscript-comment">/* Actor */</span>
	aptlv = (lacp_actor_partner_tlv_ref)out_lacpdu_p-&gt;la_actor_tlv;
	aptlv-&gt;lap_tlv_type = LACPDU_TLV_TYPE_ACTOR;
	aptlv-&gt;lap_length = LACPDU_ACTOR_TLV_LENGTH;
	*((lacp_system_ref)aptlv-&gt;lap_system) = g_bond-&gt;system;
	lacp_actor_partner_tlv_set_system_priority(aptlv, 
						   g_bond-&gt;system_priority);
	lacp_actor_partner_tlv_set_port_priority(aptlv, p-&gt;po_priority);
	lacp_actor_partner_tlv_set_port(aptlv, bondport_get_index(p));
	lacp_actor_partner_tlv_set_key(aptlv, p-&gt;po_bond-&gt;ifb_key);
	aptlv-&gt;lap_state = p-&gt;po_actor_state;

	<span class="enscript-comment">/* Partner */</span>
	aptlv = (lacp_actor_partner_tlv_ref)out_lacpdu_p-&gt;la_partner_tlv;
	aptlv-&gt;lap_tlv_type = LACPDU_TLV_TYPE_PARTNER;
	aptlv-&gt;lap_length = LACPDU_PARTNER_TLV_LENGTH;
	ps = &amp;p-&gt;po_partner_state;
	ps_li = &amp;ps-&gt;ps_lag_info;
	lacp_actor_partner_tlv_set_port(aptlv, ps-&gt;ps_port);
	lacp_actor_partner_tlv_set_port_priority(aptlv, ps-&gt;ps_port_priority);
	*((lacp_system_ref)aptlv-&gt;lap_system) = ps_li-&gt;li_system;
	lacp_actor_partner_tlv_set_system_priority(aptlv, 
						   ps_li-&gt;li_system_priority);
	lacp_actor_partner_tlv_set_key(aptlv, ps_li-&gt;li_key);
	aptlv-&gt;lap_state = ps-&gt;ps_state;

	<span class="enscript-comment">/* Collector */</span>
	ctlv = (lacp_collector_tlv_ref)out_lacpdu_p-&gt;la_collector_tlv;
	ctlv-&gt;lac_tlv_type = LACPDU_TLV_TYPE_COLLECTOR;
	ctlv-&gt;lac_length = LACPDU_COLLECTOR_TLV_LENGTH;

	bondport_slow_proto_transmit(p, pkt);
	bondport_flags_clear_ntt(p);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose &gt; 0) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Transmit Packet %d\n&quot;</span>,
			     bondport_get_name(p), p-&gt;po_n_transmit);
	}
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/**
 ** Mux machine functions
 **/</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_mux_machine_detached</span>(bondport_ref p, LAEvent event,
			      <span class="enscript-type">void</span> * event_data);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_mux_machine_waiting</span>(bondport_ref p, LAEvent event,
			     <span class="enscript-type">void</span> * event_data);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_mux_machine_attached</span>(bondport_ref p, LAEvent event,
			      <span class="enscript-type">void</span> * event_data);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_mux_machine_collecting_distributing</span>(bondport_ref p, LAEvent event,
					     <span class="enscript-type">void</span> * event_data);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_mux_machine</span>(bondport_ref p, LAEvent event, <span class="enscript-type">void</span> * event_data)
{
    <span class="enscript-keyword">switch</span> (p-&gt;po_mux_state) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MuxState_none</span>:
	bondport_mux_machine_detached(p, LAEventStart, NULL);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MuxState_DETACHED</span>:
	bondport_mux_machine_detached(p, event, event_data);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MuxState_WAITING</span>:
	bondport_mux_machine_waiting(p, event, event_data);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MuxState_ATTACHED</span>:
	bondport_mux_machine_attached(p, event, event_data);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">MuxState_COLLECTING_DISTRIBUTING</span>:
	bondport_mux_machine_collecting_distributing(p, event, event_data);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_mux_machine_detached</span>(bondport_ref p, LAEvent event,
			      __unused <span class="enscript-type">void</span> * event_data)
{
    lacp_actor_partner_state	s;

    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventStart</span>:
	devtimer_cancel(p-&gt;po_wait_while_timer);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Mux DETACHED\n&quot;</span>,
			     bondport_get_name(p));
	}
	p-&gt;po_mux_state = MuxState_DETACHED;
	bondport_flags_clear_ready(p);
	bondport_DetachMuxFromAggregator(p);
	bondport_disable_distributing(p);
	s = p-&gt;po_actor_state;
	s = lacp_actor_partner_state_set_out_of_sync(s);
	s = lacp_actor_partner_state_set_not_collecting(s);
	s = lacp_actor_partner_state_set_not_distributing(s);
	p-&gt;po_actor_state = s;
	bondport_flags_set_ntt(p);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventSelectedChange</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventPacket</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventMediaChange</span>:
	<span class="enscript-keyword">if</span> (p-&gt;po_selected == SelectedState_SELECTED
	    || p-&gt;po_selected == SelectedState_STANDBY) {
	    bondport_mux_machine_waiting(p, LAEventStart, NULL);
	}
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_mux_machine_waiting</span>(bondport_ref p, LAEvent event,
			     __unused <span class="enscript-type">void</span> * event_data)
{
    <span class="enscript-type">struct</span> timeval	tv;

    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventStart</span>:
	devtimer_cancel(p-&gt;po_wait_while_timer);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Mux WAITING\n&quot;</span>, 
			     bondport_get_name(p));
	}
	p-&gt;po_mux_state = MuxState_WAITING;
	<span class="enscript-comment">/* FALL THROUGH */</span>
    <span class="enscript-reference">default</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventSelectedChange</span>:
	<span class="enscript-keyword">if</span> (p-&gt;po_selected == SelectedState_UNSELECTED) {
	    bondport_mux_machine_detached(p, LAEventStart, NULL);
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (p-&gt;po_selected == SelectedState_STANDBY) {
	    devtimer_cancel(p-&gt;po_wait_while_timer);
	    <span class="enscript-comment">/* wait until state changes to SELECTED */</span>
	    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		timestamp_printf(<span class="enscript-string">&quot;[%s] Mux WAITING: Standby\n&quot;</span>,
				 bondport_get_name(p));
	    }
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (bondport_flags_ready(p)) {
	    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		timestamp_printf(<span class="enscript-string">&quot;[%s] Mux WAITING: Port is already ready\n&quot;</span>,
				 bondport_get_name(p));
	    }
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (devtimer_enabled(p-&gt;po_wait_while_timer)) {
	    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		timestamp_printf(<span class="enscript-string">&quot;[%s] Mux WAITING: Timer already set\n&quot;</span>,
				 bondport_get_name(p));
	    }
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (ifbond_all_ports_attached(p-&gt;po_bond, p)) {
	    devtimer_cancel(p-&gt;po_wait_while_timer);
	    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		timestamp_printf(<span class="enscript-string">&quot;[%s] Mux WAITING: No waiting\n&quot;</span>,
				 bondport_get_name(p));
	    }
	    bondport_flags_set_ready(p);
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">no_waiting</span>;
	}
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Mux WAITING: 2 seconds\n&quot;</span>, 
			     bondport_get_name(p));
	}
	tv.tv_sec = LACP_AGGREGATE_WAIT_TIME;
	tv.tv_usec = 0;
	devtimer_set_relative(p-&gt;po_wait_while_timer, tv, 
			      (devtimer_timeout_func)
			      bondport_mux_machine_waiting,
			      (<span class="enscript-type">void</span> *)LAEventTimeout, NULL);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventTimeout</span>:
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Mux WAITING: Ready\n&quot;</span>, 
			     bondport_get_name(p));
	}
	bondport_flags_set_ready(p);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventReady</span>:
    <span class="enscript-reference">no_waiting</span>:
	<span class="enscript-keyword">if</span> (bondport_flags_ready(p)){
	    <span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
		timestamp_printf(<span class="enscript-string">&quot;[%s] Mux WAITING: All Ports Ready\n&quot;</span>, 
				 bondport_get_name(p));
	    }
	    bondport_mux_machine_attached(p, LAEventStart, NULL);
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_mux_machine_attached</span>(bondport_ref p, LAEvent event,
			      __unused <span class="enscript-type">void</span> * event_data)
{
    lacp_actor_partner_state	s;

    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventStart</span>:
	devtimer_cancel(p-&gt;po_wait_while_timer);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Mux ATTACHED\n&quot;</span>,
			     bondport_get_name(p));
	}
	p-&gt;po_mux_state = MuxState_ATTACHED;
	bondport_AttachMuxToAggregator(p);
	s = p-&gt;po_actor_state;
	s = lacp_actor_partner_state_set_in_sync(s);
	s = lacp_actor_partner_state_set_not_collecting(s);
	s = lacp_actor_partner_state_set_not_distributing(s);
	bondport_disable_distributing(p);
	p-&gt;po_actor_state = s;
	bondport_flags_set_ntt(p);
	<span class="enscript-comment">/* FALL THROUGH */</span>
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">switch</span> (p-&gt;po_selected) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SelectedState_SELECTED</span>:
	    s = p-&gt;po_partner_state.ps_state;
	    <span class="enscript-keyword">if</span> (lacp_actor_partner_state_in_sync(s)) {
		bondport_mux_machine_collecting_distributing(p, LAEventStart, 
							     NULL);
	    }
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
	    bondport_mux_machine_detached(p, LAEventStart, NULL);
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bondport_mux_machine_collecting_distributing</span>(bondport_ref p, 
					     LAEvent event,
					     __unused <span class="enscript-type">void</span> * event_data)
{
    lacp_actor_partner_state	s;

    <span class="enscript-keyword">switch</span> (event) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">LAEventStart</span>:
	devtimer_cancel(p-&gt;po_wait_while_timer);
	<span class="enscript-keyword">if</span> (g_bond-&gt;verbose) {
	    timestamp_printf(<span class="enscript-string">&quot;[%s] Mux COLLECTING_DISTRIBUTING\n&quot;</span>, 
			     bondport_get_name(p));
	}
	p-&gt;po_mux_state = MuxState_COLLECTING_DISTRIBUTING;
	bondport_enable_distributing(p);
	s = p-&gt;po_actor_state;
	s = lacp_actor_partner_state_set_collecting(s);
	s = lacp_actor_partner_state_set_distributing(s);
	p-&gt;po_actor_state = s;
	bondport_flags_set_ntt(p);
	<span class="enscript-comment">/* FALL THROUGH */</span>
    <span class="enscript-reference">default</span>:
	s = p-&gt;po_partner_state.ps_state;
	<span class="enscript-keyword">if</span> (lacp_actor_partner_state_in_sync(s) == 0) {
	    bondport_mux_machine_attached(p, LAEventStart, NULL);
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">switch</span> (p-&gt;po_selected) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SelectedState_UNSELECTED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SelectedState_STANDBY</span>:
	    bondport_mux_machine_attached(p, LAEventStart, NULL);
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}
</pre>
<hr />
</body></html>