<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>iptap.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">iptap.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1999-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>  

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bpf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pktap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/iptap.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IP_VHL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/kpi_ipfilter.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

<span class="enscript-type">struct</span> iptap_softc {
	LIST_ENTRY(iptap_softc)		iptap_link;
	uint32_t					iptap_unit;
	uint32_t					iptap_dlt_raw_count;
	uint32_t					iptap_dlt_pkttap_count;
	<span class="enscript-type">struct</span> ifnet				*iptap_ifp;
};

<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(iptap_list, iptap_softc) iptap_list = LIST_HEAD_INITIALIZER(iptap_list);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		iptap_lock_shared(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		iptap_lock_exclusive(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		iptap_lock_done(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		iptap_alloc_lock(<span class="enscript-type">void</span>);

<span class="enscript-function-name">decl_lck_rw_data</span>(<span class="enscript-type">static</span>, iptap_lck_rw);
<span class="enscript-type">static</span> lck_grp_t		*iptap_grp;

errno_t <span class="enscript-function-name">iptap_if_output</span>(ifnet_t, mbuf_t);
errno_t <span class="enscript-function-name">iptap_demux</span>(ifnet_t , mbuf_t, <span class="enscript-type">char</span> *, protocol_family_t *);
errno_t <span class="enscript-function-name">iptap_add_proto</span>(ifnet_t, protocol_family_t, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_demux_desc *,
	 u_int32_t);
errno_t <span class="enscript-function-name">iptap_del_proto</span>(ifnet_t, protocol_family_t);
errno_t <span class="enscript-function-name">iptap_getdrvspec</span>(ifnet_t , <span class="enscript-type">struct</span> ifdrv64 *);
errno_t <span class="enscript-function-name">iptap_ioctl</span>(ifnet_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>, <span class="enscript-type">void</span> *);
<span class="enscript-type">void</span> <span class="enscript-function-name">iptap_detach</span>(ifnet_t);
errno_t <span class="enscript-function-name">iptap_tap_callback</span>(ifnet_t , u_int32_t , bpf_tap_mode );
<span class="enscript-type">int</span> <span class="enscript-function-name">iptap_clone_create</span>(<span class="enscript-type">struct</span> if_clone *, u_int32_t, <span class="enscript-type">void</span> *);
<span class="enscript-type">int</span> <span class="enscript-function-name">iptap_clone_destroy</span>(<span class="enscript-type">struct</span> ifnet *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">iptap_ipf_register</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">iptap_ipf_unregister</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">iptap_ipf_input</span>(<span class="enscript-type">void</span> *, mbuf_t *, <span class="enscript-type">int</span>, u_int8_t);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">iptap_ipf_output</span>(<span class="enscript-type">void</span> *, mbuf_t *, ipf_pktopts_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">iptap_ipf_detach</span>(<span class="enscript-type">void</span> *);

<span class="enscript-type">static</span> ipfilter_t iptap_ipf4, iptap_ipf6;

<span class="enscript-type">void</span> <span class="enscript-function-name">iptap_bpf_tap</span>(<span class="enscript-type">struct</span> mbuf *m, u_int32_t proto,  <span class="enscript-type">int</span> outgoing);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> if_clone iptap_cloner = 
	IF_CLONE_INITIALIZER(IPTAP_IFNAME, 
		iptap_clone_create, 
		iptap_clone_destroy,
		0, 
		IF_MAXUNIT);

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_link);
<span class="enscript-function-name">SYSCTL_NODE</span>(_net_link, OID_AUTO, iptap, CTLFLAG_RW|CTLFLAG_LOCKED, 0,
    <span class="enscript-string">&quot;iptap virtual interface&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> iptap_total_tap_count = 0; 
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_iptap, OID_AUTO, total_tap_count,  CTLFLAG_RD | CTLFLAG_LOCKED, 
	&amp;iptap_total_tap_count, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> iptap_log = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_iptap, OID_AUTO, log, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;iptap_log, 0, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IPTAP_LOG</span>(fmt, ...) \
<span class="enscript-keyword">do</span> { \
    <span class="enscript-keyword">if</span> ((iptap_log)) \
        printf(<span class="enscript-string">&quot;%s:%d &quot;</span> fmt, __FUNCTION__, __LINE__, ##__VA_ARGS__); \
} <span class="enscript-keyword">while</span>(false)

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">iptap_init</span>(<span class="enscript-type">void</span>)
{
	errno_t error;
	
	iptap_alloc_lock();
	
	error = if_clone_attach(&amp;iptap_cloner);
	<span class="enscript-keyword">if</span> (error != 0)
		panic(<span class="enscript-string">&quot;%s: if_clone_attach() failed, error %d\n&quot;</span>, __func__, error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">iptap_alloc_lock</span>(<span class="enscript-type">void</span>)
{
	lck_grp_attr_t *grp_attr;
	lck_attr_t *attr;
	
	grp_attr = lck_grp_attr_alloc_init();
	lck_grp_attr_setdefault(grp_attr);
	iptap_grp = lck_grp_alloc_init(IPTAP_IFNAME, grp_attr);
	lck_grp_attr_free(grp_attr);
	
	attr = lck_attr_alloc_init();
	lck_attr_setdefault(attr);
	
	lck_rw_init(&amp;iptap_lck_rw, iptap_grp, attr);
	lck_attr_free(attr);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">iptap_lock_shared</span>(<span class="enscript-type">void</span>)
{
	lck_rw_lock_shared(&amp;iptap_lck_rw);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">iptap_lock_exclusive</span>(<span class="enscript-type">void</span>)
{
	lck_rw_lock_exclusive(&amp;iptap_lck_rw);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">iptap_lock_done</span>(<span class="enscript-type">void</span>)
{
	lck_rw_done(&amp;iptap_lck_rw);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">iptap_clone_create</span>(<span class="enscript-type">struct</span> if_clone *ifc, u_int32_t unit, <span class="enscript-type">void</span> *params)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">params</span>)

	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> iptap_softc *iptap = NULL;
	<span class="enscript-type">struct</span> ifnet_init_params if_init;
	
	iptap = _MALLOC(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> iptap_softc), M_DEVBUF, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (iptap == NULL) {
		printf(<span class="enscript-string">&quot;%s: _MALLOC failed\n&quot;</span>, __func__);
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	iptap-&gt;iptap_unit = unit;

	<span class="enscript-comment">/*
	 * We do not use a set_bpf_tap() function as we rather rely on the more 
	 * accurate callback passed to bpf_attach()
	 */</span>
	bzero(&amp;if_init, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ifnet_init_params));
	if_init.name = ifc-&gt;ifc_name;
	if_init.unit = unit;
	if_init.type = IFT_OTHER;
	if_init.family = IFNET_FAMILY_LOOPBACK;
	if_init.output = iptap_if_output;
	if_init.demux = iptap_demux;
	if_init.add_proto = iptap_add_proto;
	if_init.del_proto = iptap_del_proto;
	if_init.softc = iptap;
	if_init.ioctl = iptap_ioctl;
	if_init.detach = iptap_detach;

	error = ifnet_allocate(&amp;if_init, &amp;iptap-&gt;iptap_ifp);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: ifnet_allocate failed, error %d\n&quot;</span>, __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	
	ifnet_set_flags(iptap-&gt;iptap_ifp, IFF_UP, IFF_UP);
	
	error = ifnet_attach(iptap-&gt;iptap_ifp, NULL);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: ifnet_attach failed - error %d\n&quot;</span>, __func__, error);
		ifnet_release(iptap-&gt;iptap_ifp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	
	<span class="enscript-comment">/* 
	 * Attach by default as DLT_PKTAP for packet metadata
	 * Provide DLT_RAW for legacy
	 */</span>
	bpf_attach(iptap-&gt;iptap_ifp, DLT_PKTAP, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pktap_header), NULL, 
		iptap_tap_callback);
	bpf_attach(iptap-&gt;iptap_ifp, DLT_RAW, 0, NULL,
		iptap_tap_callback);
	
	<span class="enscript-comment">/* Take a reference and add to the global list */</span>
	ifnet_reference(iptap-&gt;iptap_ifp);
	
	iptap_lock_exclusive();
	
	<span class="enscript-keyword">if</span> (LIST_EMPTY(&amp;iptap_list))
		iptap_ipf_register();
	LIST_INSERT_HEAD(&amp;iptap_list, iptap, iptap_link);
	iptap_lock_done();
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">if</span> (iptap != NULL)
			_FREE(iptap, M_DEVBUF);
	}
	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">iptap_clone_destroy</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">int</span> error = 0;

	(<span class="enscript-type">void</span>) ifnet_detach(ifp);
	
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * This function is called whenever a DLT is set on the interface:
 * - When interface is attached to a BPF device via BIOCSETIF for the default DLT
 * - Whenever a new DLT is selected via BIOCSDLT
 * - When the interface is detached from a BPF device (direction is zero)
 */</span>
__private_extern__ errno_t
<span class="enscript-function-name">iptap_tap_callback</span>(ifnet_t ifp, u_int32_t dlt, bpf_tap_mode direction)
{
	<span class="enscript-type">struct</span> iptap_softc *iptap;

	iptap = ifp-&gt;if_softc;
	<span class="enscript-keyword">if</span> (iptap == NULL) {
		printf(<span class="enscript-string">&quot;%s: if_softc is NULL for ifp %s\n&quot;</span>, __func__,
		    ifp-&gt;if_xname);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">switch</span> (dlt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DLT_RAW</span>:
			<span class="enscript-keyword">if</span> (direction == 0) {
				<span class="enscript-keyword">if</span> (iptap-&gt;iptap_dlt_raw_count &gt; 0) {
					iptap-&gt;iptap_dlt_raw_count--;
					OSAddAtomic(-1, &amp;iptap_total_tap_count);

				}
			} <span class="enscript-keyword">else</span> {
				iptap-&gt;iptap_dlt_raw_count++;
				OSAddAtomic(1, &amp;iptap_total_tap_count);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DLT_PKTAP</span>:
			<span class="enscript-keyword">if</span> (direction == 0) {
				<span class="enscript-keyword">if</span> (iptap-&gt;iptap_dlt_pkttap_count &gt; 0) {
					iptap-&gt;iptap_dlt_pkttap_count--;
					OSAddAtomic(-1, &amp;iptap_total_tap_count);
				}
			} <span class="enscript-keyword">else</span> {
				iptap-&gt;iptap_dlt_pkttap_count++;
				OSAddAtomic(1, &amp;iptap_total_tap_count);
			}
			<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/* 
	 * Attachements count must be positive and we're in trouble 
	 * if we have more that 2**31 attachements
	 */</span>
	VERIFY(iptap_total_tap_count &gt;= 0);

	<span class="enscript-keyword">return</span> (0);
}

__private_extern__ errno_t
<span class="enscript-function-name">iptap_if_output</span>(ifnet_t ifp, mbuf_t m)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>)

	mbuf_freem(m);
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

__private_extern__ errno_t
<span class="enscript-function-name">iptap_demux</span>(ifnet_t ifp, mbuf_t m, <span class="enscript-type">char</span> *header, 
	protocol_family_t *ppf)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">m</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">header</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ppf</span>)

	<span class="enscript-keyword">return</span> (ENOTSUP);
}

__private_extern__ errno_t
<span class="enscript-function-name">iptap_add_proto</span>(ifnet_t ifp, protocol_family_t pf,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_demux_desc *dmx, u_int32_t cnt)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">pf</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dmx</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cnt</span>)

	<span class="enscript-keyword">return</span> (0);
}

__private_extern__ errno_t
<span class="enscript-function-name">iptap_del_proto</span>(ifnet_t ifp, protocol_family_t pf)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">pf</span>)

	<span class="enscript-keyword">return</span> (0);
}

__private_extern__ errno_t
<span class="enscript-function-name">iptap_getdrvspec</span>(ifnet_t ifp, <span class="enscript-type">struct</span> ifdrv64 *ifd)
{
	errno_t error = 0;
	<span class="enscript-type">struct</span> iptap_softc *iptap;

	iptap = ifp-&gt;if_softc;
	<span class="enscript-keyword">if</span> (iptap == NULL) {
		error = ENOENT;
		printf(<span class="enscript-string">&quot;%s: iptap NULL - error %d\n&quot;</span>, __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">switch</span> (ifd-&gt;ifd_cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PKTP_CMD_TAP_COUNT</span>: {
		uint32_t tap_count = iptap-&gt;iptap_dlt_raw_count + iptap-&gt;iptap_dlt_pkttap_count;
		
		<span class="enscript-keyword">if</span> (ifd-&gt;ifd_len &lt; <span class="enscript-keyword">sizeof</span>(tap_count)) {
			printf(<span class="enscript-string">&quot;%s: PKTP_CMD_TAP_COUNT ifd_len %llu too small - error %d\n&quot;</span>, 
				__func__, ifd-&gt;ifd_len, error);
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		error = copyout(&amp;tap_count, ifd-&gt;ifd_data, <span class="enscript-keyword">sizeof</span>(tap_count));
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;%s: PKTP_CMD_TAP_COUNT copyout - error %d\n&quot;</span>, __func__, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ errno_t
<span class="enscript-function-name">iptap_ioctl</span>(ifnet_t ifp, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> cmd, <span class="enscript-type">void</span> *data)
{
	errno_t error = 0;

	<span class="enscript-keyword">if</span> ((cmd &amp; IOC_IN)) {
		error = kauth_authorize_generic(kauth_cred_get(), KAUTH_GENERIC_ISSUSER);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}
	
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDRVSPEC32</span>: {
		<span class="enscript-type">struct</span> ifdrv64 ifd;
		<span class="enscript-type">struct</span> ifdrv32 *ifd32 = (<span class="enscript-type">struct</span> ifdrv32 *)data;
		
		memcpy(ifd.ifd_name, ifd32-&gt;ifd_name, <span class="enscript-keyword">sizeof</span>(ifd.ifd_name));
		ifd.ifd_cmd = ifd32-&gt;ifd_cmd;
		ifd.ifd_len = ifd32-&gt;ifd_len;
		ifd.ifd_data = ifd32-&gt;ifd_data;
		
		error = iptap_getdrvspec(ifp, &amp;ifd);
		
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDRVSPEC64</span>: {
		<span class="enscript-type">struct</span> ifdrv64 *ifd64 = (<span class="enscript-type">struct</span> ifdrv64 *)data;
				
		error = iptap_getdrvspec(ifp, ifd64);

		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-reference">default</span>:
		error = ENOTSUP;
		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">iptap_detach</span>(ifnet_t ifp)
{
	<span class="enscript-type">struct</span> iptap_softc *iptap;
	
	iptap_lock_exclusive();

	iptap = ifp-&gt;if_softc;
	ifp-&gt;if_softc = NULL;
	LIST_REMOVE(iptap, iptap_link);

	<span class="enscript-keyword">if</span> (LIST_EMPTY(&amp;iptap_list))
		iptap_ipf_unregister();

	iptap_lock_done();

	<span class="enscript-comment">/* Drop reference as it's no more on the global list */</span>
	ifnet_release(ifp);
	
	_FREE(iptap, M_DEVBUF);

	<span class="enscript-comment">/* This is for the reference taken by ifnet_attach() */</span>
	(<span class="enscript-type">void</span>) ifnet_release(ifp);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">iptap_ipf_register</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> ipf_filter iptap_ipfinit;
	<span class="enscript-type">int</span> err = 0;

	IPTAP_LOG(<span class="enscript-string">&quot;\n&quot;</span>);

	bzero(&amp;iptap_ipfinit, <span class="enscript-keyword">sizeof</span> (iptap_ipfinit));
	iptap_ipfinit.name = IPTAP_IFNAME;
	iptap_ipfinit.cookie = &amp;iptap_ipf4;
	iptap_ipfinit.ipf_input = iptap_ipf_input;
	iptap_ipfinit.ipf_output = iptap_ipf_output;
	iptap_ipfinit.ipf_detach = iptap_ipf_detach;

	err = ipf_addv4(&amp;iptap_ipfinit, &amp;iptap_ipf4);
	<span class="enscript-keyword">if</span> (err != 0) {
		printf(<span class="enscript-string">&quot;%s: ipf_addv4 for %s0 failed - %d\n&quot;</span>,
		    __func__, IPTAP_IFNAME, err);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	iptap_ipfinit.cookie = &amp;iptap_ipf6;
	err = ipf_addv6(&amp;iptap_ipfinit, &amp;iptap_ipf6);
	<span class="enscript-keyword">if</span> (err != 0) {
		printf(<span class="enscript-string">&quot;%s: ipf_addv6 for %s0 failed - %d\n&quot;</span>,
		    __func__, IPTAP_IFNAME, err);
		(<span class="enscript-type">void</span>) ipf_remove(iptap_ipf4);
		iptap_ipf4 = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">iptap_ipf_unregister</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> err = 0;

	IPTAP_LOG(<span class="enscript-string">&quot;\n&quot;</span>);

	<span class="enscript-keyword">if</span> (iptap_ipf4 != NULL) {
		err = ipf_remove(iptap_ipf4);
		<span class="enscript-keyword">if</span> (err != 0) {
			printf(<span class="enscript-string">&quot;%s: ipf_remove (ipv4) for %s0 failed - %d\n&quot;</span>,
			    __func__, IPTAP_IFNAME, err);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		iptap_ipf4 = NULL;
	}

	<span class="enscript-keyword">if</span> (iptap_ipf6 != NULL) {
		err = ipf_remove(iptap_ipf6);
		<span class="enscript-keyword">if</span> (err != 0) {
			printf(<span class="enscript-string">&quot;%s: ipf_remove (ipv6) for %s0 failed - %d\n&quot;</span>,
			    __func__, IPTAP_IFNAME, err);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		iptap_ipf6 = NULL;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">iptap_ipf_input</span>(<span class="enscript-type">void</span> *arg, mbuf_t *mp,  <span class="enscript-type">int</span> off, u_int8_t proto)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">off</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">proto</span>)

	<span class="enscript-keyword">if</span> (arg == (<span class="enscript-type">void</span> *)&amp;iptap_ipf4)
		iptap_bpf_tap(*mp, AF_INET, 0);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (arg == (<span class="enscript-type">void</span> *)&amp;iptap_ipf6)
		iptap_bpf_tap(*mp, AF_INET6, 0);
	<span class="enscript-keyword">else</span>
		IPTAP_LOG(<span class="enscript-string">&quot;%s:%d bad cookie 0x%llx &amp;iptap_ipf4 0x%llx &quot;</span>
		    <span class="enscript-string">&quot;&amp;iptap_ipf6 0x%llx\n&quot;</span>, __func__, __LINE__,
		    (uint64_t)VM_KERNEL_ADDRPERM(arg),
		    (uint64_t)VM_KERNEL_ADDRPERM(&amp;iptap_ipf4),
		    (uint64_t)VM_KERNEL_ADDRPERM(&amp;iptap_ipf6));

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">iptap_ipf_output</span>(<span class="enscript-type">void</span> *arg, mbuf_t *mp, ipf_pktopts_t opt)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">opt</span>)

	<span class="enscript-keyword">if</span> (arg == (<span class="enscript-type">void</span> *)&amp;iptap_ipf4)
		iptap_bpf_tap(*mp, AF_INET, 1);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (arg == (<span class="enscript-type">void</span> *)&amp;iptap_ipf6)
		iptap_bpf_tap(*mp, AF_INET6, 1);
	<span class="enscript-keyword">else</span>
		IPTAP_LOG(<span class="enscript-string">&quot;%s:%d bad cookie 0x%llx &amp;iptap_ipf4 0x%llx &quot;</span>
		    <span class="enscript-string">&quot;&amp;iptap_ipf6 0x%llx\n&quot;</span>, __func__, __LINE__,
		    (uint64_t)VM_KERNEL_ADDRPERM(arg),
		    (uint64_t)VM_KERNEL_ADDRPERM(&amp;iptap_ipf4),
		    (uint64_t)VM_KERNEL_ADDRPERM(&amp;iptap_ipf6));

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">iptap_ipf_detach</span>(<span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>)
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">iptap_bpf_tap</span>(<span class="enscript-type">struct</span> mbuf *m, u_int32_t proto,  <span class="enscript-type">int</span> outgoing)
{
	<span class="enscript-type">struct</span> iptap_softc *iptap;
	<span class="enscript-type">void</span> (*bpf_tap_func)(ifnet_t , u_int32_t , mbuf_t , <span class="enscript-type">void</span> * , size_t ) = 
		outgoing ? bpf_tap_out : bpf_tap_in;

	iptap_lock_shared();

	LIST_FOREACH(iptap, &amp;iptap_list, iptap_link) {
			<span class="enscript-keyword">if</span> (iptap-&gt;iptap_dlt_raw_count &gt; 0) {
					bpf_tap_func(iptap-&gt;iptap_ifp, DLT_RAW, m, 
						NULL, 0);
			}
			<span class="enscript-keyword">if</span> (iptap-&gt;iptap_dlt_pkttap_count &gt; 0) {
				<span class="enscript-type">struct</span> {
					<span class="enscript-type">struct</span> pktap_header hdr;
					u_int32_t proto;
				} hdr_buffer;
				<span class="enscript-type">struct</span> pktap_header *hdr = &amp;hdr_buffer.hdr;
				size_t hdr_size = <span class="enscript-keyword">sizeof</span>(hdr_buffer);
				<span class="enscript-type">struct</span> ifnet *ifp = outgoing ? NULL : m-&gt;m_pkthdr.rcvif;

				<span class="enscript-comment">/* Verify the structure is packed */</span>	
				_CASSERT(<span class="enscript-keyword">sizeof</span>(hdr_buffer) == <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pktap_header) + <span class="enscript-keyword">sizeof</span>(u_int32_t));

				bzero(hdr, <span class="enscript-keyword">sizeof</span>(hdr_buffer));
				hdr-&gt;pth_length = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pktap_header);
				hdr-&gt;pth_type_next = PTH_TYPE_PACKET;
				hdr-&gt;pth_dlt = DLT_NULL;
				<span class="enscript-keyword">if</span> (ifp != NULL)
					snprintf(hdr-&gt;pth_ifname, <span class="enscript-keyword">sizeof</span>(hdr-&gt;pth_ifname), <span class="enscript-string">&quot;%s&quot;</span>, 
						ifp-&gt;if_xname);
				hdr_buffer.proto = proto;
				hdr-&gt;pth_flags = outgoing ? PTH_FLAG_DIR_OUT : PTH_FLAG_DIR_IN;
				hdr-&gt;pth_protocol_family = proto;
				hdr-&gt;pth_frame_pre_length = 0;
				hdr-&gt;pth_frame_post_length = 0;
				hdr-&gt;pth_iftype = ifp != NULL ? ifp-&gt;if_type : 0;
				hdr-&gt;pth_ifunit = ifp != NULL ? ifp-&gt;if_unit : 0;

				pktap_fill_proc_info(hdr, proto, m, 0, outgoing, ifp);
								
				hdr-&gt;pth_svc = so_svc2tc(m-&gt;m_pkthdr.pkt_svc);

				bpf_tap_func(iptap-&gt;iptap_ifp, DLT_PKTAP, m, hdr, hdr_size);
			}
	}
	
	iptap_lock_done();
}
</pre>
<hr />
</body></html>