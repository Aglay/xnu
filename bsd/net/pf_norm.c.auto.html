<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>pf_norm.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">pf_norm.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$apfw: pf_norm.c,v 1.10 2008/08/28 19:10:53 jhw Exp $ */</span>
<span class="enscript-comment">/*	$OpenBSD: pf_norm.c,v 1.107 2006/04/16 00:59:52 pascoe Exp $ */</span>

<span class="enscript-comment">/*
 * Copyright 2001 Niels Provos &lt;<a href="mailto:provos@citi.umich.edu">provos@citi.umich.edu</a>&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/random.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bpf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_pflog.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_fsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_icmp.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfvar.h&gt;</span>

<span class="enscript-type">struct</span> pf_frent {
	LIST_ENTRY(pf_frent)	fr_next;
	<span class="enscript-type">struct</span> mbuf		*fr_m;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fr_ip</span>		fr_u.fru_ipv4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fr_ip6</span>		fr_u.fru_ipv6
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> ip	*fru_ipv4;
		<span class="enscript-type">struct</span> ip6_hdr	*fru_ipv6;
	} fr_u;
	<span class="enscript-type">struct</span> ip6_frag		fr_ip6f_opt;
	<span class="enscript-type">int</span>			fr_ip6f_hlen;
};

<span class="enscript-type">struct</span> pf_frcache {
	LIST_ENTRY(pf_frcache) fr_next;
	uint16_t	fr_off;
	uint16_t	fr_end;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PFFRAG_SEENLAST</span>	0x0001		<span class="enscript-comment">/* Seen the last fragment for this */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PFFRAG_NOBUFFER</span>	0x0002		<span class="enscript-comment">/* Non-buffering fragment cache */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PFFRAG_DROP</span>	0x0004		<span class="enscript-comment">/* Drop all fragments */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BUFFER_FRAGMENTS</span>(fr)	(!((fr)-&gt;fr_flags &amp; PFFRAG_NOBUFFER))

<span class="enscript-type">struct</span> pf_fragment {
	RB_ENTRY(pf_fragment) fr_entry;
	TAILQ_ENTRY(pf_fragment) frag_next;
	<span class="enscript-type">struct</span> pf_addr	fr_srcx;
	<span class="enscript-type">struct</span> pf_addr	fr_dstx;
	u_int8_t	fr_p;		<span class="enscript-comment">/* protocol of this fragment */</span>
	u_int8_t	fr_flags;	<span class="enscript-comment">/* status flags */</span>
	u_int16_t	fr_max;		<span class="enscript-comment">/* fragment data max */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fr_id</span>		fr_uid.fru_id4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fr_id6</span>		fr_uid.fru_id6
	<span class="enscript-type">union</span> {
		u_int16_t	fru_id4;
		u_int32_t	fru_id6;
	} fr_uid;
	<span class="enscript-type">int</span>		fr_af;
	u_int32_t	fr_timeout;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fr_queue</span>	fr_u.fru_queue
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fr_cache</span>	fr_u.fru_cache
	<span class="enscript-type">union</span> {
		LIST_HEAD(pf_fragq, pf_frent) fru_queue;	<span class="enscript-comment">/* buffering */</span>
		LIST_HEAD(pf_cacheq, pf_frcache) fru_cache;	<span class="enscript-comment">/* non-buf */</span>
	} fr_u;
};

<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(pf_fragqueue, pf_fragment)	pf_fragqueue;
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(pf_cachequeue, pf_fragment)	pf_cachequeue;

<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span>  <span class="enscript-function-name">pf_frag_compare</span>(<span class="enscript-type">struct</span> pf_fragment *,
    <span class="enscript-type">struct</span> pf_fragment *);
<span class="enscript-type">static</span> <span class="enscript-function-name">RB_HEAD</span>(pf_frag_tree, pf_fragment)	pf_frag_tree, pf_cache_tree;
<span class="enscript-function-name">RB_PROTOTYPE_SC</span>(__private_extern__, pf_frag_tree, pf_fragment, fr_entry,
    pf_frag_compare);
<span class="enscript-function-name">RB_GENERATE</span>(pf_frag_tree, pf_fragment, fr_entry, pf_frag_compare);

<span class="enscript-comment">/* Private prototypes */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_ip6hdr2key</span>(<span class="enscript-type">struct</span> pf_fragment *, <span class="enscript-type">struct</span> ip6_hdr *,
    <span class="enscript-type">struct</span> ip6_frag *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_ip2key</span>(<span class="enscript-type">struct</span> pf_fragment *, <span class="enscript-type">struct</span> ip *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_remove_fragment</span>(<span class="enscript-type">struct</span> pf_fragment *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_flush_fragments</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_free_fragment</span>(<span class="enscript-type">struct</span> pf_fragment *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pf_fragment *<span class="enscript-function-name">pf_find_fragment_by_key</span>(<span class="enscript-type">struct</span> pf_fragment *,
    <span class="enscript-type">struct</span> pf_frag_tree *);
<span class="enscript-type">static</span> __inline <span class="enscript-type">struct</span> pf_fragment *
    pf_find_fragment_by_ipv4_header(<span class="enscript-type">struct</span> ip *, <span class="enscript-type">struct</span> pf_frag_tree *);
<span class="enscript-type">static</span> __inline <span class="enscript-type">struct</span> pf_fragment *
    pf_find_fragment_by_ipv6_header(<span class="enscript-type">struct</span> ip6_hdr *, <span class="enscript-type">struct</span> ip6_frag *,
    <span class="enscript-type">struct</span> pf_frag_tree *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">pf_reassemble</span>(<span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> pf_fragment **,
    <span class="enscript-type">struct</span> pf_frent *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">pf_fragcache</span>(<span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> ip *,
    <span class="enscript-type">struct</span> pf_fragment **, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">pf_reassemble6</span>(<span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> pf_fragment **,
    <span class="enscript-type">struct</span> pf_frent *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">pf_frag6cache</span>(<span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> ip6_hdr*,
    <span class="enscript-type">struct</span> ip6_frag *, <span class="enscript-type">struct</span> pf_fragment **, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_normalize_tcpopt</span>(<span class="enscript-type">struct</span> pf_rule *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> pfi_kif *,
    <span class="enscript-type">struct</span> pf_pdesc *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> tcphdr *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> *);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DPFPRINTF</span>(x) do {				\
	<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {		\
		printf(<span class="enscript-string">&quot;%s: &quot;</span>, __func__);		\
		printf x ;				\
	}						\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* Globals */</span>
<span class="enscript-type">struct</span> pool		 pf_frent_pl, pf_frag_pl;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pool	 pf_cache_pl, pf_cent_pl;
<span class="enscript-type">struct</span> pool		 pf_state_scrub_pl;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_nfrents, pf_ncache;

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_normalize_init</span>(<span class="enscript-type">void</span>)
{
	pool_init(&amp;pf_frent_pl, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_frent), 0, 0, 0, <span class="enscript-string">&quot;pffrent&quot;</span>,
	    NULL);
	pool_init(&amp;pf_frag_pl, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_fragment), 0, 0, 0, <span class="enscript-string">&quot;pffrag&quot;</span>,
	    NULL);
	pool_init(&amp;pf_cache_pl, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_fragment), 0, 0, 0,
	    <span class="enscript-string">&quot;pffrcache&quot;</span>, NULL);
	pool_init(&amp;pf_cent_pl, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_frcache), 0, 0, 0, <span class="enscript-string">&quot;pffrcent&quot;</span>,
	    NULL);
	pool_init(&amp;pf_state_scrub_pl, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_state_scrub), 0, 0, 0,
	    <span class="enscript-string">&quot;pfstscr&quot;</span>, NULL);

	pool_sethiwat(&amp;pf_frag_pl, PFFRAG_FRAG_HIWAT);
	pool_sethardlimit(&amp;pf_frent_pl, PFFRAG_FRENT_HIWAT, NULL, 0);
	pool_sethardlimit(&amp;pf_cache_pl, PFFRAG_FRCACHE_HIWAT, NULL, 0);
	pool_sethardlimit(&amp;pf_cent_pl, PFFRAG_FRCENT_HIWAT, NULL, 0);

	TAILQ_INIT(&amp;pf_fragqueue);
	TAILQ_INIT(&amp;pf_cachequeue);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_normalize_destroy</span>(<span class="enscript-type">void</span>)
{
	pool_destroy(&amp;pf_state_scrub_pl);
	pool_destroy(&amp;pf_cent_pl);
	pool_destroy(&amp;pf_cache_pl);
	pool_destroy(&amp;pf_frag_pl);
	pool_destroy(&amp;pf_frent_pl);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_normalize_isempty</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (TAILQ_EMPTY(&amp;pf_fragqueue) &amp;&amp; TAILQ_EMPTY(&amp;pf_cachequeue));
}

<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_frag_compare</span>(<span class="enscript-type">struct</span> pf_fragment *a, <span class="enscript-type">struct</span> pf_fragment *b)
{
	<span class="enscript-type">int</span>	diff;

	<span class="enscript-keyword">if</span> ((diff = a-&gt;fr_af - b-&gt;fr_af))
		<span class="enscript-keyword">return</span> (diff);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((diff = a-&gt;fr_p - b-&gt;fr_p))
		<span class="enscript-keyword">return</span> (diff);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> pf_addr *sa = &amp;a-&gt;fr_srcx;
		<span class="enscript-type">struct</span> pf_addr *sb = &amp;b-&gt;fr_srcx;
		<span class="enscript-type">struct</span> pf_addr *da = &amp;a-&gt;fr_dstx;
		<span class="enscript-type">struct</span> pf_addr *db = &amp;b-&gt;fr_dstx;
		
		<span class="enscript-keyword">switch</span> (a-&gt;fr_af) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			<span class="enscript-keyword">if</span> ((diff = a-&gt;fr_id - b-&gt;fr_id))
				<span class="enscript-keyword">return</span> (diff);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;v4.s_addr &lt; sb-&gt;v4.s_addr)
				<span class="enscript-keyword">return</span> (-1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;v4.s_addr &gt; sb-&gt;v4.s_addr)
				<span class="enscript-keyword">return</span> (1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (da-&gt;v4.s_addr &lt; db-&gt;v4.s_addr)
				<span class="enscript-keyword">return</span> (-1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (da-&gt;v4.s_addr &gt; db-&gt;v4.s_addr)
				<span class="enscript-keyword">return</span> (1);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			<span class="enscript-keyword">if</span> ((diff = a-&gt;fr_id6 - b-&gt;fr_id6))
				<span class="enscript-keyword">return</span> (diff);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;addr32[3] &lt; sb-&gt;addr32[3])
				<span class="enscript-keyword">return</span> (-1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;addr32[3] &gt; sb-&gt;addr32[3])
				<span class="enscript-keyword">return</span> (1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;addr32[2] &lt; sb-&gt;addr32[2])
				<span class="enscript-keyword">return</span> (-1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;addr32[2] &gt; sb-&gt;addr32[2])
				<span class="enscript-keyword">return</span> (1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;addr32[1] &lt; sb-&gt;addr32[1])
				<span class="enscript-keyword">return</span> (-1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;addr32[1] &gt; sb-&gt;addr32[1])
				<span class="enscript-keyword">return</span> (1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;addr32[0] &lt; sb-&gt;addr32[0])
				<span class="enscript-keyword">return</span> (-1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;addr32[0] &gt; sb-&gt;addr32[0])
				<span class="enscript-keyword">return</span> (1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (da-&gt;addr32[3] &lt; db-&gt;addr32[3])
				<span class="enscript-keyword">return</span> (-1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (da-&gt;addr32[3] &gt; db-&gt;addr32[3])
				<span class="enscript-keyword">return</span> (1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (da-&gt;addr32[2] &lt; db-&gt;addr32[2])
				<span class="enscript-keyword">return</span> (-1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (da-&gt;addr32[2] &gt; db-&gt;addr32[2])
				<span class="enscript-keyword">return</span> (1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (da-&gt;addr32[1] &lt; db-&gt;addr32[1])
				<span class="enscript-keyword">return</span> (-1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (da-&gt;addr32[1] &gt; db-&gt;addr32[1])
				<span class="enscript-keyword">return</span> (1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (da-&gt;addr32[0] &lt; db-&gt;addr32[0])
				<span class="enscript-keyword">return</span> (-1);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (da-&gt;addr32[0] &gt; db-&gt;addr32[0])
				<span class="enscript-keyword">return</span> (1);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
		<span class="enscript-reference">default</span>:
			VERIFY(!0 &amp;&amp; <span class="enscript-string">&quot;only IPv4 and IPv6 supported!&quot;</span>);
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_purge_expired_fragments</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> pf_fragment *frag;
	u_int32_t expire = pf_time_second() -
	    pf_default_rule.timeout[PFTM_FRAG];

	<span class="enscript-keyword">while</span> ((frag = TAILQ_LAST(&amp;pf_fragqueue, pf_fragqueue)) != NULL) {
		VERIFY(BUFFER_FRAGMENTS(frag));
		<span class="enscript-keyword">if</span> (frag-&gt;fr_timeout &gt; expire)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">switch</span> (frag-&gt;fr_af) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		      DPFPRINTF((<span class="enscript-string">&quot;expiring IPv4 %d(0x%llx) from queue.\n&quot;</span>,
			  ntohs(frag-&gt;fr_id),
			  (uint64_t)VM_KERNEL_ADDRPERM(frag)));
		      <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		      DPFPRINTF((<span class="enscript-string">&quot;expiring IPv6 %d(0x%llx) from queue.\n&quot;</span>,
			  ntohl(frag-&gt;fr_id6),
			  (uint64_t)VM_KERNEL_ADDRPERM(frag)));
		      <span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
		      VERIFY(0 &amp;&amp; <span class="enscript-string">&quot;only IPv4 and IPv6 supported&quot;</span>);
		      <span class="enscript-keyword">break</span>;
		}
		pf_free_fragment(frag);
	}

	<span class="enscript-keyword">while</span> ((frag = TAILQ_LAST(&amp;pf_cachequeue, pf_cachequeue)) != NULL) {
		VERIFY(!BUFFER_FRAGMENTS(frag));
		<span class="enscript-keyword">if</span> (frag-&gt;fr_timeout &gt; expire)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">switch</span> (frag-&gt;fr_af) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		      DPFPRINTF((<span class="enscript-string">&quot;expiring IPv4 %d(0x%llx) from cache.\n&quot;</span>,
			  ntohs(frag-&gt;fr_id),
			  (uint64_t)VM_KERNEL_ADDRPERM(frag)));
		      <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		      DPFPRINTF((<span class="enscript-string">&quot;expiring IPv6 %d(0x%llx) from cache.\n&quot;</span>,
			  ntohl(frag-&gt;fr_id6),
			  (uint64_t)VM_KERNEL_ADDRPERM(frag)));
		      <span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
		      VERIFY(0 &amp;&amp; <span class="enscript-string">&quot;only IPv4 and IPv6 supported&quot;</span>);
		      <span class="enscript-keyword">break</span>;
		}
		pf_free_fragment(frag);
		VERIFY(TAILQ_EMPTY(&amp;pf_cachequeue) ||
		    TAILQ_LAST(&amp;pf_cachequeue, pf_cachequeue) != frag);
	}
}

<span class="enscript-comment">/*
 * Try to flush old fragments to make space for new ones
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_flush_fragments</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> pf_fragment	*frag;
	<span class="enscript-type">int</span>			 goal;

	goal = pf_nfrents * 9 / 10;
	DPFPRINTF((<span class="enscript-string">&quot;trying to free &gt; %d frents\n&quot;</span>,
	    pf_nfrents - goal));
	<span class="enscript-keyword">while</span> (goal &lt; pf_nfrents) {
		frag = TAILQ_LAST(&amp;pf_fragqueue, pf_fragqueue);
		<span class="enscript-keyword">if</span> (frag == NULL)
			<span class="enscript-keyword">break</span>;
		pf_free_fragment(frag);
	}


	goal = pf_ncache * 9 / 10;
	DPFPRINTF((<span class="enscript-string">&quot;trying to free &gt; %d cache entries\n&quot;</span>,
	    pf_ncache - goal));
	<span class="enscript-keyword">while</span> (goal &lt; pf_ncache) {
		frag = TAILQ_LAST(&amp;pf_cachequeue, pf_cachequeue);
		<span class="enscript-keyword">if</span> (frag == NULL)
			<span class="enscript-keyword">break</span>;
		pf_free_fragment(frag);
	}
}

<span class="enscript-comment">/* Frees the fragments and all associated entries */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_free_fragment</span>(<span class="enscript-type">struct</span> pf_fragment *frag)
{
	<span class="enscript-type">struct</span> pf_frent		*frent;
	<span class="enscript-type">struct</span> pf_frcache	*frcache;

	<span class="enscript-comment">/* Free all fragments */</span>
	<span class="enscript-keyword">if</span> (BUFFER_FRAGMENTS(frag)) {
		<span class="enscript-keyword">for</span> (frent = LIST_FIRST(&amp;frag-&gt;fr_queue); frent;
		    frent = LIST_FIRST(&amp;frag-&gt;fr_queue)) {
			LIST_REMOVE(frent, fr_next);

			m_freem(frent-&gt;fr_m);
			pool_put(&amp;pf_frent_pl, frent);
			pf_nfrents--;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">for</span> (frcache = LIST_FIRST(&amp;frag-&gt;fr_cache); frcache;
		    frcache = LIST_FIRST(&amp;frag-&gt;fr_cache)) {
			LIST_REMOVE(frcache, fr_next);

			VERIFY(LIST_EMPTY(&amp;frag-&gt;fr_cache) ||
			    LIST_FIRST(&amp;frag-&gt;fr_cache)-&gt;fr_off &gt;
			    frcache-&gt;fr_end);

			pool_put(&amp;pf_cent_pl, frcache);
			pf_ncache--;
		}
	}

	pf_remove_fragment(frag);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_ip6hdr2key</span>(<span class="enscript-type">struct</span> pf_fragment *key, <span class="enscript-type">struct</span> ip6_hdr *ip6,
    <span class="enscript-type">struct</span> ip6_frag *fh)
{
	key-&gt;fr_p = fh-&gt;ip6f_nxt;
	key-&gt;fr_id6 = fh-&gt;ip6f_ident;
	key-&gt;fr_af = AF_INET6;
	key-&gt;fr_srcx.v6 = ip6-&gt;ip6_src;
	key-&gt;fr_dstx.v6 = ip6-&gt;ip6_dst;
}
 
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_ip2key</span>(<span class="enscript-type">struct</span> pf_fragment *key, <span class="enscript-type">struct</span> ip *ip)
{
	key-&gt;fr_p = ip-&gt;ip_p;
	key-&gt;fr_id = ip-&gt;ip_id;
	key-&gt;fr_af = AF_INET;
	key-&gt;fr_srcx.v4.s_addr = ip-&gt;ip_src.s_addr;
	key-&gt;fr_dstx.v4.s_addr = ip-&gt;ip_dst.s_addr;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pf_fragment *
<span class="enscript-function-name">pf_find_fragment_by_key</span>(<span class="enscript-type">struct</span> pf_fragment *key, <span class="enscript-type">struct</span> pf_frag_tree *tree)
{
	<span class="enscript-type">struct</span> pf_fragment *frag;
	
	frag = RB_FIND(pf_frag_tree, tree, key);
	<span class="enscript-keyword">if</span> (frag != NULL) {
		<span class="enscript-comment">/* XXX Are we sure we want to update the timeout? */</span>
		frag-&gt;fr_timeout = pf_time_second();
		<span class="enscript-keyword">if</span> (BUFFER_FRAGMENTS(frag)) {
			TAILQ_REMOVE(&amp;pf_fragqueue, frag, frag_next);
			TAILQ_INSERT_HEAD(&amp;pf_fragqueue, frag, frag_next);
		} <span class="enscript-keyword">else</span> {
			TAILQ_REMOVE(&amp;pf_cachequeue, frag, frag_next);
			TAILQ_INSERT_HEAD(&amp;pf_cachequeue, frag, frag_next);
		}
	}
	
	<span class="enscript-keyword">return</span> (frag);
}
  
<span class="enscript-type">static</span> __inline <span class="enscript-type">struct</span> pf_fragment *
<span class="enscript-function-name">pf_find_fragment_by_ipv4_header</span>(<span class="enscript-type">struct</span> ip *ip, <span class="enscript-type">struct</span> pf_frag_tree *tree)
{
	<span class="enscript-type">struct</span> pf_fragment key;
	pf_ip2key(&amp;key, ip);
	<span class="enscript-keyword">return</span> pf_find_fragment_by_key(&amp;key, tree);
}

<span class="enscript-type">static</span> __inline <span class="enscript-type">struct</span> pf_fragment *
<span class="enscript-function-name">pf_find_fragment_by_ipv6_header</span>(<span class="enscript-type">struct</span> ip6_hdr *ip6, <span class="enscript-type">struct</span> ip6_frag *fh,
    <span class="enscript-type">struct</span> pf_frag_tree *tree)
{
      <span class="enscript-type">struct</span> pf_fragment key;
      pf_ip6hdr2key(&amp;key, ip6, fh);
      <span class="enscript-keyword">return</span> pf_find_fragment_by_key(&amp;key, tree);
}

<span class="enscript-comment">/* Removes a fragment from the fragment queue and frees the fragment */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_remove_fragment</span>(<span class="enscript-type">struct</span> pf_fragment *frag)
{
	<span class="enscript-keyword">if</span> (BUFFER_FRAGMENTS(frag)) {
		RB_REMOVE(pf_frag_tree, &amp;pf_frag_tree, frag);
		TAILQ_REMOVE(&amp;pf_fragqueue, frag, frag_next);
		pool_put(&amp;pf_frag_pl, frag);
	} <span class="enscript-keyword">else</span> {
		RB_REMOVE(pf_frag_tree, &amp;pf_cache_tree, frag);
		TAILQ_REMOVE(&amp;pf_cachequeue, frag, frag_next);
		pool_put(&amp;pf_cache_pl, frag);
	}
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FR_IP_OFF</span>(fr)	((ntohs((fr)-&gt;fr_ip-&gt;ip_off) &amp; IP_OFFMASK) &lt;&lt; 3)
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">pf_reassemble</span>(<span class="enscript-type">struct</span> mbuf **m0, <span class="enscript-type">struct</span> pf_fragment **frag,
    <span class="enscript-type">struct</span> pf_frent *frent, <span class="enscript-type">int</span> mff)
{
	<span class="enscript-type">struct</span> mbuf	*m = *m0, *m2;
	<span class="enscript-type">struct</span> pf_frent	*frea, *next;
	<span class="enscript-type">struct</span> pf_frent	*frep = NULL;
	<span class="enscript-type">struct</span> ip	*ip = frent-&gt;fr_ip;
	<span class="enscript-type">int</span>		 hlen = ip-&gt;ip_hl &lt;&lt; 2;
	u_int16_t	 off = (ntohs(ip-&gt;ip_off) &amp; IP_OFFMASK) &lt;&lt; 3;
	u_int16_t	 ip_len = ntohs(ip-&gt;ip_len) - ip-&gt;ip_hl * 4;
	u_int16_t	 fr_max = ip_len + off;

	VERIFY(*frag == NULL || BUFFER_FRAGMENTS(*frag));

	<span class="enscript-comment">/* Strip off ip header */</span>
	m-&gt;m_data += hlen;
	m-&gt;m_len -= hlen;

	<span class="enscript-comment">/* Create a new reassembly queue for this packet */</span>
	<span class="enscript-keyword">if</span> (*frag == NULL) {
		*frag = pool_get(&amp;pf_frag_pl, PR_NOWAIT);
		<span class="enscript-keyword">if</span> (*frag == NULL) {
			pf_flush_fragments();
			*frag = pool_get(&amp;pf_frag_pl, PR_NOWAIT);
			<span class="enscript-keyword">if</span> (*frag == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop_fragment</span>;
		}

		(*frag)-&gt;fr_flags = 0;
		(*frag)-&gt;fr_max = 0;
		(*frag)-&gt;fr_af = AF_INET;
		(*frag)-&gt;fr_srcx.v4 = frent-&gt;fr_ip-&gt;ip_src;
		(*frag)-&gt;fr_dstx.v4 = frent-&gt;fr_ip-&gt;ip_dst;
		(*frag)-&gt;fr_p = frent-&gt;fr_ip-&gt;ip_p;
		(*frag)-&gt;fr_id = frent-&gt;fr_ip-&gt;ip_id;
		(*frag)-&gt;fr_timeout = pf_time_second();
		LIST_INIT(&amp;(*frag)-&gt;fr_queue);

		RB_INSERT(pf_frag_tree, &amp;pf_frag_tree, *frag);
		TAILQ_INSERT_HEAD(&amp;pf_fragqueue, *frag, frag_next);

		<span class="enscript-comment">/* We do not have a previous fragment */</span>
		frep = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">insert</span>;
	}

	<span class="enscript-comment">/*
	 * Find a fragment after the current one:
	 *  - off contains the real shifted offset.
	 */</span>
	LIST_FOREACH(frea, &amp;(*frag)-&gt;fr_queue, fr_next) {
		<span class="enscript-keyword">if</span> (FR_IP_OFF(frea) &gt; off)
			<span class="enscript-keyword">break</span>;
		frep = frea;
	}

	VERIFY(frep != NULL || frea != NULL);

	<span class="enscript-keyword">if</span> (frep != NULL &amp;&amp;
	    FR_IP_OFF(frep) + ntohs(frep-&gt;fr_ip-&gt;ip_len) - frep-&gt;fr_ip-&gt;ip_hl *
	    4 &gt; off) {
		u_int16_t	precut;

		precut = FR_IP_OFF(frep) + ntohs(frep-&gt;fr_ip-&gt;ip_len) -
		    frep-&gt;fr_ip-&gt;ip_hl * 4 - off;
		<span class="enscript-keyword">if</span> (precut &gt;= ip_len)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop_fragment</span>;
		m_adj(frent-&gt;fr_m, precut);
		DPFPRINTF((<span class="enscript-string">&quot;overlap -%d\n&quot;</span>, precut));
		<span class="enscript-comment">/* Enforce 8 byte boundaries */</span>
		ip-&gt;ip_off = htons(ntohs(ip-&gt;ip_off) + (precut &gt;&gt; 3));
		off = (ntohs(ip-&gt;ip_off) &amp; IP_OFFMASK) &lt;&lt; 3;
		ip_len -= precut;
		ip-&gt;ip_len = htons(ip_len);
	}

	<span class="enscript-keyword">for</span> (; frea != NULL &amp;&amp; ip_len + off &gt; FR_IP_OFF(frea);
	    frea = next) {
		u_int16_t	aftercut;

		aftercut = ip_len + off - FR_IP_OFF(frea);
		DPFPRINTF((<span class="enscript-string">&quot;adjust overlap %d\n&quot;</span>, aftercut));
		<span class="enscript-keyword">if</span> (aftercut &lt; ntohs(frea-&gt;fr_ip-&gt;ip_len) - frea-&gt;fr_ip-&gt;ip_hl
		    * 4) {
			frea-&gt;fr_ip-&gt;ip_len =
			    htons(ntohs(frea-&gt;fr_ip-&gt;ip_len) - aftercut);
			frea-&gt;fr_ip-&gt;ip_off = htons(ntohs(frea-&gt;fr_ip-&gt;ip_off) +
			    (aftercut &gt;&gt; 3));
			m_adj(frea-&gt;fr_m, aftercut);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* This fragment is completely overlapped, lose it */</span>
		next = LIST_NEXT(frea, fr_next);
		m_freem(frea-&gt;fr_m);
		LIST_REMOVE(frea, fr_next);
		pool_put(&amp;pf_frent_pl, frea);
		pf_nfrents--;
	}

<span class="enscript-reference">insert</span>:
	<span class="enscript-comment">/* Update maximum data size */</span>
	<span class="enscript-keyword">if</span> ((*frag)-&gt;fr_max &lt; fr_max)
		(*frag)-&gt;fr_max = fr_max;
	<span class="enscript-comment">/* This is the last segment */</span>
	<span class="enscript-keyword">if</span> (!mff)
		(*frag)-&gt;fr_flags |= PFFRAG_SEENLAST;

	<span class="enscript-keyword">if</span> (frep == NULL)
		LIST_INSERT_HEAD(&amp;(*frag)-&gt;fr_queue, frent, fr_next);
	<span class="enscript-keyword">else</span>
		LIST_INSERT_AFTER(frep, frent, fr_next);

	<span class="enscript-comment">/* Check if we are completely reassembled */</span>
	<span class="enscript-keyword">if</span> (!((*frag)-&gt;fr_flags &amp; PFFRAG_SEENLAST))
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-comment">/* Check if we have all the data */</span>
	off = 0;
	<span class="enscript-keyword">for</span> (frep = LIST_FIRST(&amp;(*frag)-&gt;fr_queue); frep; frep = next) {
		next = LIST_NEXT(frep, fr_next);

		off += ntohs(frep-&gt;fr_ip-&gt;ip_len) - frep-&gt;fr_ip-&gt;ip_hl * 4;
		<span class="enscript-keyword">if</span> (off &lt; (*frag)-&gt;fr_max &amp;&amp;
		    (next == NULL || FR_IP_OFF(next) != off)) {
			DPFPRINTF((<span class="enscript-string">&quot;missing fragment at %d, next %d, max %d\n&quot;</span>,
			    off, next == NULL ? -1 : FR_IP_OFF(next),
			    (*frag)-&gt;fr_max));
			<span class="enscript-keyword">return</span> (NULL);
		}
	}
	DPFPRINTF((<span class="enscript-string">&quot;%d &lt; %d?\n&quot;</span>, off, (*frag)-&gt;fr_max));
	<span class="enscript-keyword">if</span> (off &lt; (*frag)-&gt;fr_max)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-comment">/* We have all the data */</span>
	frent = LIST_FIRST(&amp;(*frag)-&gt;fr_queue);
	VERIFY(frent != NULL);
	<span class="enscript-keyword">if</span> ((frent-&gt;fr_ip-&gt;ip_hl &lt;&lt; 2) + off &gt; IP_MAXPACKET) {
		DPFPRINTF((<span class="enscript-string">&quot;drop: too big: %d\n&quot;</span>, off));
		pf_free_fragment(*frag);
		*frag = NULL;
		<span class="enscript-keyword">return</span> (NULL);
	}
	next = LIST_NEXT(frent, fr_next);

	<span class="enscript-comment">/* Magic from ip_input */</span>
	ip = frent-&gt;fr_ip;
	m = frent-&gt;fr_m;
	m2 = m-&gt;m_next;
	m-&gt;m_next = NULL;
	m_cat(m, m2);
	pool_put(&amp;pf_frent_pl, frent);
	pf_nfrents--;
	<span class="enscript-keyword">for</span> (frent = next; frent != NULL; frent = next) {
		next = LIST_NEXT(frent, fr_next);

		m2 = frent-&gt;fr_m;
		pool_put(&amp;pf_frent_pl, frent);
		pf_nfrents--;
		m_cat(m, m2);
	}

	ip-&gt;ip_src = (*frag)-&gt;fr_srcx.v4;
	ip-&gt;ip_dst = (*frag)-&gt;fr_dstx.v4;

	<span class="enscript-comment">/* Remove from fragment queue */</span>
	pf_remove_fragment(*frag);
	*frag = NULL;

	hlen = ip-&gt;ip_hl &lt;&lt; 2;
	ip-&gt;ip_len = htons(off + hlen);
	m-&gt;m_len += hlen;
	m-&gt;m_data -= hlen;

	<span class="enscript-comment">/* some debugging cruft by sklower, below, will go away soon */</span>
	<span class="enscript-comment">/* XXX this should be done elsewhere */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR) {
		<span class="enscript-type">int</span> plen = 0;
		<span class="enscript-keyword">for</span> (m2 = m; m2; m2 = m2-&gt;m_next)
			plen += m2-&gt;m_len;
		m-&gt;m_pkthdr.len = plen;
	}

	DPFPRINTF((<span class="enscript-string">&quot;complete: 0x%llx(%d)\n&quot;</span>,
	    (uint64_t)VM_KERNEL_ADDRPERM(m), ntohs(ip-&gt;ip_len)));
	<span class="enscript-keyword">return</span> (m);

<span class="enscript-reference">drop_fragment</span>:
	<span class="enscript-comment">/* Oops - fail safe - drop packet */</span>
	pool_put(&amp;pf_frent_pl, frent);
	pf_nfrents--;
	m_freem(m);
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">pf_fragcache</span>(<span class="enscript-type">struct</span> mbuf **m0, <span class="enscript-type">struct</span> ip *h, <span class="enscript-type">struct</span> pf_fragment **frag, <span class="enscript-type">int</span> mff,
    <span class="enscript-type">int</span> drop, <span class="enscript-type">int</span> *nomem)
{
	<span class="enscript-type">struct</span> mbuf		*m = *m0;
	<span class="enscript-type">struct</span> pf_frcache	*frp, *fra, *cur = NULL;
	<span class="enscript-type">int</span>			 ip_len = ntohs(h-&gt;ip_len) - (h-&gt;ip_hl &lt;&lt; 2);
	u_int16_t		 off = ntohs(h-&gt;ip_off) &lt;&lt; 3;
	u_int16_t		 fr_max = ip_len + off;
	<span class="enscript-type">int</span>			 hosed = 0;

	VERIFY(*frag == NULL || !BUFFER_FRAGMENTS(*frag));

	<span class="enscript-comment">/* Create a new range queue for this packet */</span>
	<span class="enscript-keyword">if</span> (*frag == NULL) {
		*frag = pool_get(&amp;pf_cache_pl, PR_NOWAIT);
		<span class="enscript-keyword">if</span> (*frag == NULL) {
			pf_flush_fragments();
			*frag = pool_get(&amp;pf_cache_pl, PR_NOWAIT);
			<span class="enscript-keyword">if</span> (*frag == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
		}

		<span class="enscript-comment">/* Get an entry for the queue */</span>
		cur = pool_get(&amp;pf_cent_pl, PR_NOWAIT);
		<span class="enscript-keyword">if</span> (cur == NULL) {
			pool_put(&amp;pf_cache_pl, *frag);
			*frag = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
		}
		pf_ncache++;

		(*frag)-&gt;fr_flags = PFFRAG_NOBUFFER;
		(*frag)-&gt;fr_max = 0;
		(*frag)-&gt;fr_af = AF_INET;
		(*frag)-&gt;fr_srcx.v4 = h-&gt;ip_src;
		(*frag)-&gt;fr_dstx.v4 = h-&gt;ip_dst;
		(*frag)-&gt;fr_p = h-&gt;ip_p;
		(*frag)-&gt;fr_id = h-&gt;ip_id;
		(*frag)-&gt;fr_timeout = pf_time_second();

		cur-&gt;fr_off = off;
		cur-&gt;fr_end = fr_max;
		LIST_INIT(&amp;(*frag)-&gt;fr_cache);
		LIST_INSERT_HEAD(&amp;(*frag)-&gt;fr_cache, cur, fr_next);

		RB_INSERT(pf_frag_tree, &amp;pf_cache_tree, *frag);
		TAILQ_INSERT_HEAD(&amp;pf_cachequeue, *frag, frag_next);

		DPFPRINTF((<span class="enscript-string">&quot;fragcache[%d]: new %d-%d\n&quot;</span>, h-&gt;ip_id, off,
		    fr_max));

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">pass</span>;
	}

	<span class="enscript-comment">/*
	 * Find a fragment after the current one:
	 *  - off contains the real shifted offset.
	 */</span>
	frp = NULL;
	LIST_FOREACH(fra, &amp;(*frag)-&gt;fr_cache, fr_next) {
		<span class="enscript-keyword">if</span> (fra-&gt;fr_off &gt; off)
			<span class="enscript-keyword">break</span>;
		frp = fra;
	}

	VERIFY(frp != NULL || fra != NULL);

	<span class="enscript-keyword">if</span> (frp != NULL) {
		<span class="enscript-type">int</span>	precut;

		precut = frp-&gt;fr_end - off;
		<span class="enscript-keyword">if</span> (precut &gt;= ip_len) {
			<span class="enscript-comment">/* Fragment is entirely a duplicate */</span>
			DPFPRINTF((<span class="enscript-string">&quot;fragcache[%d]: dead (%d-%d) %d-%d\n&quot;</span>,
			    h-&gt;ip_id, frp-&gt;fr_off, frp-&gt;fr_end, off, fr_max));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop_fragment</span>;
		}
		<span class="enscript-keyword">if</span> (precut == 0) {
			<span class="enscript-comment">/* They are adjacent.  Fixup cache entry */</span>
			DPFPRINTF((<span class="enscript-string">&quot;fragcache[%d]: adjacent (%d-%d) %d-%d\n&quot;</span>,
			    h-&gt;ip_id, frp-&gt;fr_off, frp-&gt;fr_end, off, fr_max));
			frp-&gt;fr_end = fr_max;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (precut &gt; 0) {
			<span class="enscript-comment">/*
			 * The first part of this payload overlaps with a
			 * fragment that has already been passed.
			 * Need to trim off the first part of the payload.
			 * But to do so easily, we need to create another
			 * mbuf to throw the original header into.
			 */</span>

			DPFPRINTF((<span class="enscript-string">&quot;fragcache[%d]: chop %d (%d-%d) %d-%d\n&quot;</span>,
			    h-&gt;ip_id, precut, frp-&gt;fr_off, frp-&gt;fr_end, off,
			    fr_max));

			off += precut;
			fr_max -= precut;
			<span class="enscript-comment">/* Update the previous frag to encompass this one */</span>
			frp-&gt;fr_end = fr_max;

			<span class="enscript-keyword">if</span> (!drop) {
				<span class="enscript-comment">/*
				 * XXX Optimization opportunity
				 * This is a very heavy way to trim the payload.
				 * we could do it much faster by diddling mbuf
				 * internals but that would be even less legible
				 * than this mbuf magic.  For my next trick,
				 * I'll pull a rabbit out of my laptop.
				 */</span>
				*m0 = m_copym(m, 0, h-&gt;ip_hl &lt;&lt; 2, M_NOWAIT);
				<span class="enscript-keyword">if</span> (*m0 == NULL)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
				VERIFY((*m0)-&gt;m_next == NULL);
				m_adj(m, precut + (h-&gt;ip_hl &lt;&lt; 2));
				m_cat(*m0, m);
				m = *m0;
				<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR) {
					<span class="enscript-type">int</span> plen = 0;
					<span class="enscript-type">struct</span> mbuf *t;
					<span class="enscript-keyword">for</span> (t = m; t; t = t-&gt;m_next)
						plen += t-&gt;m_len;
					m-&gt;m_pkthdr.len = plen;
				}


				h = mtod(m, <span class="enscript-type">struct</span> ip *);


				VERIFY((<span class="enscript-type">int</span>)m-&gt;m_len ==
				    ntohs(h-&gt;ip_len) - precut);
				h-&gt;ip_off = htons(ntohs(h-&gt;ip_off) +
				    (precut &gt;&gt; 3));
				h-&gt;ip_len = htons(ntohs(h-&gt;ip_len) - precut);
			} <span class="enscript-keyword">else</span> {
				hosed++;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* There is a gap between fragments */</span>

			DPFPRINTF((<span class="enscript-string">&quot;fragcache[%d]: gap %d (%d-%d) %d-%d\n&quot;</span>,
			    h-&gt;ip_id, -precut, frp-&gt;fr_off, frp-&gt;fr_end, off,
			    fr_max));

			cur = pool_get(&amp;pf_cent_pl, PR_NOWAIT);
			<span class="enscript-keyword">if</span> (cur == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
			pf_ncache++;

			cur-&gt;fr_off = off;
			cur-&gt;fr_end = fr_max;
			LIST_INSERT_AFTER(frp, cur, fr_next);
		}
	}

	<span class="enscript-keyword">if</span> (fra != NULL) {
		<span class="enscript-type">int</span>	aftercut;
		<span class="enscript-type">int</span>	merge = 0;

		aftercut = fr_max - fra-&gt;fr_off;
		<span class="enscript-keyword">if</span> (aftercut == 0) {
			<span class="enscript-comment">/* Adjacent fragments */</span>
			DPFPRINTF((<span class="enscript-string">&quot;fragcache[%d]: adjacent %d-%d (%d-%d)\n&quot;</span>,
			    h-&gt;ip_id, off, fr_max, fra-&gt;fr_off, fra-&gt;fr_end));
			fra-&gt;fr_off = off;
			merge = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (aftercut &gt; 0) {
			<span class="enscript-comment">/* Need to chop off the tail of this fragment */</span>
			DPFPRINTF((<span class="enscript-string">&quot;fragcache[%d]: chop %d %d-%d (%d-%d)\n&quot;</span>,
			    h-&gt;ip_id, aftercut, off, fr_max, fra-&gt;fr_off,
			    fra-&gt;fr_end));
			fra-&gt;fr_off = off;
			fr_max -= aftercut;

			merge = 1;

			<span class="enscript-keyword">if</span> (!drop) {
				m_adj(m, -aftercut);
				<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR) {
					<span class="enscript-type">int</span> plen = 0;
					<span class="enscript-type">struct</span> mbuf *t;
					<span class="enscript-keyword">for</span> (t = m; t; t = t-&gt;m_next)
						plen += t-&gt;m_len;
					m-&gt;m_pkthdr.len = plen;
				}
				h = mtod(m, <span class="enscript-type">struct</span> ip *);
				VERIFY((<span class="enscript-type">int</span>)m-&gt;m_len ==
				    ntohs(h-&gt;ip_len) - aftercut);
				h-&gt;ip_len = htons(ntohs(h-&gt;ip_len) - aftercut);
			} <span class="enscript-keyword">else</span> {
				hosed++;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (frp == NULL) {
			<span class="enscript-comment">/* There is a gap between fragments */</span>
			DPFPRINTF((<span class="enscript-string">&quot;fragcache[%d]: gap %d %d-%d (%d-%d)\n&quot;</span>,
			    h-&gt;ip_id, -aftercut, off, fr_max, fra-&gt;fr_off,
			    fra-&gt;fr_end));

			cur = pool_get(&amp;pf_cent_pl, PR_NOWAIT);
			<span class="enscript-keyword">if</span> (cur == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
			pf_ncache++;

			cur-&gt;fr_off = off;
			cur-&gt;fr_end = fr_max;
			LIST_INSERT_BEFORE(fra, cur, fr_next);
		}


		<span class="enscript-comment">/* Need to glue together two separate fragment descriptors */</span>
		<span class="enscript-keyword">if</span> (merge) {
			<span class="enscript-keyword">if</span> (cur &amp;&amp; fra-&gt;fr_off &lt;= cur-&gt;fr_end) {
				<span class="enscript-comment">/* Need to merge in a previous 'cur' */</span>
				DPFPRINTF((<span class="enscript-string">&quot;fragcache[%d]: adjacent(merge &quot;</span>
				    <span class="enscript-string">&quot;%d-%d) %d-%d (%d-%d)\n&quot;</span>,
				    h-&gt;ip_id, cur-&gt;fr_off, cur-&gt;fr_end, off,
				    fr_max, fra-&gt;fr_off, fra-&gt;fr_end));
				fra-&gt;fr_off = cur-&gt;fr_off;
				LIST_REMOVE(cur, fr_next);
				pool_put(&amp;pf_cent_pl, cur);
				pf_ncache--;
				cur = NULL;

			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (frp &amp;&amp; fra-&gt;fr_off &lt;= frp-&gt;fr_end) {
				<span class="enscript-comment">/* Need to merge in a modified 'frp' */</span>
				VERIFY(cur == NULL);
				DPFPRINTF((<span class="enscript-string">&quot;fragcache[%d]: adjacent(merge &quot;</span>
				    <span class="enscript-string">&quot;%d-%d) %d-%d (%d-%d)\n&quot;</span>,
				    h-&gt;ip_id, frp-&gt;fr_off, frp-&gt;fr_end, off,
				    fr_max, fra-&gt;fr_off, fra-&gt;fr_end));
				fra-&gt;fr_off = frp-&gt;fr_off;
				LIST_REMOVE(frp, fr_next);
				pool_put(&amp;pf_cent_pl, frp);
				pf_ncache--;
				frp = NULL;

			}
		}
	}

	<span class="enscript-keyword">if</span> (hosed) {
		<span class="enscript-comment">/*
		 * We must keep tracking the overall fragment even when
		 * we're going to drop it anyway so that we know when to
		 * free the overall descriptor.  Thus we drop the frag late.
		 */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop_fragment</span>;
	}


<span class="enscript-reference">pass</span>:
	<span class="enscript-comment">/* Update maximum data size */</span>
	<span class="enscript-keyword">if</span> ((*frag)-&gt;fr_max &lt; fr_max)
		(*frag)-&gt;fr_max = fr_max;

	<span class="enscript-comment">/* This is the last segment */</span>
	<span class="enscript-keyword">if</span> (!mff)
		(*frag)-&gt;fr_flags |= PFFRAG_SEENLAST;

	<span class="enscript-comment">/* Check if we are completely reassembled */</span>
	<span class="enscript-keyword">if</span> (((*frag)-&gt;fr_flags &amp; PFFRAG_SEENLAST) &amp;&amp;
	    LIST_FIRST(&amp;(*frag)-&gt;fr_cache)-&gt;fr_off == 0 &amp;&amp;
	    LIST_FIRST(&amp;(*frag)-&gt;fr_cache)-&gt;fr_end == (*frag)-&gt;fr_max) {
		<span class="enscript-comment">/* Remove from fragment queue */</span>
		DPFPRINTF((<span class="enscript-string">&quot;fragcache[%d]: done 0-%d\n&quot;</span>, h-&gt;ip_id,
		    (*frag)-&gt;fr_max));
		pf_free_fragment(*frag);
		*frag = NULL;
	}

	<span class="enscript-keyword">return</span> (m);

<span class="enscript-reference">no_mem</span>:
	*nomem = 1;

	<span class="enscript-comment">/* Still need to pay attention to !IP_MF */</span>
	<span class="enscript-keyword">if</span> (!mff &amp;&amp; *frag != NULL)
		(*frag)-&gt;fr_flags |= PFFRAG_SEENLAST;

	m_freem(m);
	<span class="enscript-keyword">return</span> (NULL);

<span class="enscript-reference">drop_fragment</span>:

	<span class="enscript-comment">/* Still need to pay attention to !IP_MF */</span>
	<span class="enscript-keyword">if</span> (!mff &amp;&amp; *frag != NULL)
		(*frag)-&gt;fr_flags |= PFFRAG_SEENLAST;

	<span class="enscript-keyword">if</span> (drop) {
		<span class="enscript-comment">/* This fragment has been deemed bad.  Don't reass */</span>
		<span class="enscript-keyword">if</span> (((*frag)-&gt;fr_flags &amp; PFFRAG_DROP) == 0)
			DPFPRINTF((<span class="enscript-string">&quot;fragcache[%d]: dropping overall fragment\n&quot;</span>,
			    h-&gt;ip_id));
		(*frag)-&gt;fr_flags |= PFFRAG_DROP;
	}

	m_freem(m);
	<span class="enscript-keyword">return</span> (NULL);
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FR_IP6_OFF</span>(fr) \
	(ntohs((fr)-&gt;fr_ip6f_opt.ip6f_offlg &amp; IP6F_OFF_MASK))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">FR_IP6_PLEN</span>(fr) (ntohs((fr)-&gt;fr_ip6-&gt;ip6_plen))
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">pf_reassemble6</span>(<span class="enscript-type">struct</span> mbuf **m0, <span class="enscript-type">struct</span> pf_fragment **frag,
    <span class="enscript-type">struct</span> pf_frent *frent, <span class="enscript-type">int</span> mff)
{
	<span class="enscript-type">struct</span> mbuf *m, *m2;
	<span class="enscript-type">struct</span> pf_frent *frea, *frep, *next;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">int</span> plen, off, fr_max;
	
	VERIFY(*frag == NULL || BUFFER_FRAGMENTS(*frag));
	m = *m0;
	frep = NULL;
	ip6 = frent-&gt;fr_ip6;
	off = FR_IP6_OFF(frent);
	plen = FR_IP6_PLEN(frent);
	fr_max = off + plen - (frent-&gt;fr_ip6f_hlen - <span class="enscript-keyword">sizeof</span> *ip6);

	DPFPRINTF((<span class="enscript-string">&quot;0x%llx IPv6 frag plen %u off %u fr_ip6f_hlen %u &quot;</span>
	    <span class="enscript-string">&quot;fr_max %u m_len %u\n&quot;</span>, (uint64_t)VM_KERNEL_ADDRPERM(m), plen, off,
	    frent-&gt;fr_ip6f_hlen, fr_max, m-&gt;m_len));
	
	<span class="enscript-comment">/* strip off headers up to the fragment payload */</span>
	m-&gt;m_data += frent-&gt;fr_ip6f_hlen;
	m-&gt;m_len -= frent-&gt;fr_ip6f_hlen;
	
	<span class="enscript-comment">/* Create a new reassembly queue for this packet */</span>
	<span class="enscript-keyword">if</span> (*frag == NULL) {
		*frag = pool_get(&amp;pf_frag_pl, PR_NOWAIT);
		<span class="enscript-keyword">if</span> (*frag == NULL) {
			pf_flush_fragments();
			*frag = pool_get(&amp;pf_frag_pl, PR_NOWAIT);
			<span class="enscript-keyword">if</span> (*frag == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop_fragment</span>;
		}
		
		(*frag)-&gt;fr_flags = 0;
		(*frag)-&gt;fr_max = 0;
		(*frag)-&gt;fr_af = AF_INET6;
		(*frag)-&gt;fr_srcx.v6 = frent-&gt;fr_ip6-&gt;ip6_src;
		(*frag)-&gt;fr_dstx.v6 = frent-&gt;fr_ip6-&gt;ip6_dst;
		(*frag)-&gt;fr_p = frent-&gt;fr_ip6f_opt.ip6f_nxt;
		(*frag)-&gt;fr_id6 = frent-&gt;fr_ip6f_opt.ip6f_ident;
		(*frag)-&gt;fr_timeout = pf_time_second();
		LIST_INIT(&amp;(*frag)-&gt;fr_queue);
		
		RB_INSERT(pf_frag_tree, &amp;pf_frag_tree, *frag);
		TAILQ_INSERT_HEAD(&amp;pf_fragqueue, *frag, frag_next);
		
		<span class="enscript-comment">/* We do not have a previous fragment */</span>
		frep = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">insert</span>;
	}
	
	<span class="enscript-comment">/*
	 * Find a fragment after the current one:
	 *  - off contains the real shifted offset.
	 */</span>
	LIST_FOREACH(frea, &amp;(*frag)-&gt;fr_queue, fr_next) {
		<span class="enscript-keyword">if</span> (FR_IP6_OFF(frea) &gt; off)
			<span class="enscript-keyword">break</span>;
		frep = frea;
	}
	
	VERIFY(frep != NULL || frea != NULL);
	
	<span class="enscript-keyword">if</span> (frep != NULL &amp;&amp;
	    FR_IP6_OFF(frep) + FR_IP6_PLEN(frep) - frep-&gt;fr_ip6f_hlen &gt; off)
	{
		u_int16_t precut;
		
		precut = FR_IP6_OFF(frep) + FR_IP6_PLEN(frep) -
		    frep-&gt;fr_ip6f_hlen - off;
		<span class="enscript-keyword">if</span> (precut &gt;= plen)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop_fragment</span>;
		m_adj(frent-&gt;fr_m, precut);
		DPFPRINTF((<span class="enscript-string">&quot;overlap -%d\n&quot;</span>, precut));
		<span class="enscript-comment">/* Enforce 8 byte boundaries */</span>
		frent-&gt;fr_ip6f_opt.ip6f_offlg =
		    htons(ntohs(frent-&gt;fr_ip6f_opt.ip6f_offlg) +
		    (precut &gt;&gt; 3));
		off = FR_IP6_OFF(frent);
		plen -= precut;
		ip6-&gt;ip6_plen = htons(plen);
	}
	
	<span class="enscript-keyword">for</span> (; frea != NULL &amp;&amp; plen + off &gt; FR_IP6_OFF(frea); frea = next) {
		u_int16_t	aftercut;
		
		aftercut = plen + off - FR_IP6_OFF(frea);
		DPFPRINTF((<span class="enscript-string">&quot;adjust overlap %d\n&quot;</span>, aftercut));
		<span class="enscript-keyword">if</span> (aftercut &lt; FR_IP6_PLEN(frea) - frea-&gt;fr_ip6f_hlen) {
			frea-&gt;fr_ip6-&gt;ip6_plen = htons(FR_IP6_PLEN(frea) -
				aftercut);
			frea-&gt;fr_ip6f_opt.ip6f_offlg =
			    htons(ntohs(frea-&gt;fr_ip6f_opt.ip6f_offlg) +
			    (aftercut &gt;&gt; 3));
			m_adj(frea-&gt;fr_m, aftercut);
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-comment">/* This fragment is completely overlapped, lose it */</span>
		next = LIST_NEXT(frea, fr_next);
		m_freem(frea-&gt;fr_m);
		LIST_REMOVE(frea, fr_next);
		pool_put(&amp;pf_frent_pl, frea);
		pf_nfrents--;
	}
	
  <span class="enscript-reference">insert</span>:
	<span class="enscript-comment">/* Update maximum data size */</span>
	<span class="enscript-keyword">if</span> ((*frag)-&gt;fr_max &lt; fr_max)
		(*frag)-&gt;fr_max = fr_max;
	<span class="enscript-comment">/* This is the last segment */</span>
	<span class="enscript-keyword">if</span> (!mff)
		(*frag)-&gt;fr_flags |= PFFRAG_SEENLAST;
	
	<span class="enscript-keyword">if</span> (frep == NULL)
		LIST_INSERT_HEAD(&amp;(*frag)-&gt;fr_queue, frent, fr_next);
	<span class="enscript-keyword">else</span>
		LIST_INSERT_AFTER(frep, frent, fr_next);
	
	<span class="enscript-comment">/* Check if we are completely reassembled */</span>
	<span class="enscript-keyword">if</span> (!((*frag)-&gt;fr_flags &amp; PFFRAG_SEENLAST))
		<span class="enscript-keyword">return</span> (NULL);
	
	<span class="enscript-comment">/* Check if we have all the data */</span>
	off = 0;
	<span class="enscript-keyword">for</span> (frep = LIST_FIRST(&amp;(*frag)-&gt;fr_queue); frep; frep = next) {
		next = LIST_NEXT(frep, fr_next);
		off += FR_IP6_PLEN(frep) - (frent-&gt;fr_ip6f_hlen - <span class="enscript-keyword">sizeof</span> *ip6);
		DPFPRINTF((<span class="enscript-string">&quot;frep at %d, next %d, max %d\n&quot;</span>,
			off, next == NULL ? -1 : FR_IP6_OFF(next),
			(*frag)-&gt;fr_max));
		<span class="enscript-keyword">if</span> (off &lt; (*frag)-&gt;fr_max &amp;&amp;
		    (next == NULL || FR_IP6_OFF(next) != off)) {
			DPFPRINTF((<span class="enscript-string">&quot;missing fragment at %d, next %d, max %d\n&quot;</span>,
			    off, next == NULL ? -1 : FR_IP6_OFF(next),
			    (*frag)-&gt;fr_max));
			<span class="enscript-keyword">return</span> (NULL);
		}
	}
	DPFPRINTF((<span class="enscript-string">&quot;%d &lt; %d?\n&quot;</span>, off, (*frag)-&gt;fr_max));
	<span class="enscript-keyword">if</span> (off &lt; (*frag)-&gt;fr_max)
		<span class="enscript-keyword">return</span> (NULL);
	
	<span class="enscript-comment">/* We have all the data */</span>
	frent = LIST_FIRST(&amp;(*frag)-&gt;fr_queue);
	VERIFY(frent != NULL);
	<span class="enscript-keyword">if</span> (frent-&gt;fr_ip6f_hlen + off &gt; IP_MAXPACKET) {
		DPFPRINTF((<span class="enscript-string">&quot;drop: too big: %d\n&quot;</span>, off));
		pf_free_fragment(*frag);
		*frag = NULL;
		<span class="enscript-keyword">return</span> (NULL);
	}
	
	ip6 = frent-&gt;fr_ip6;
	ip6-&gt;ip6_nxt = (*frag)-&gt;fr_p;
	ip6-&gt;ip6_plen = htons(off);
	ip6-&gt;ip6_src = (*frag)-&gt;fr_srcx.v6;
	ip6-&gt;ip6_dst = (*frag)-&gt;fr_dstx.v6;
	
	<span class="enscript-comment">/* Remove from fragment queue */</span>
	pf_remove_fragment(*frag);
	*frag = NULL;
	
	m = frent-&gt;fr_m;
	m-&gt;m_len += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
	m-&gt;m_data -= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
	memmove(m-&gt;m_data, ip6, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
	
	next = LIST_NEXT(frent, fr_next);
	pool_put(&amp;pf_frent_pl, frent);
	pf_nfrents--;
	<span class="enscript-keyword">for</span> (frent = next; next != NULL; frent = next) {
		m2 = frent-&gt;fr_m;

		m_cat(m, m2);
		next = LIST_NEXT(frent, fr_next);
		pool_put(&amp;pf_frent_pl, frent);
		pf_nfrents--;
	}
	
	<span class="enscript-comment">/* XXX this should be done elsewhere */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR) {
		<span class="enscript-type">int</span> pktlen = 0;
		<span class="enscript-keyword">for</span> (m2 = m; m2; m2 = m2-&gt;m_next)
			pktlen += m2-&gt;m_len;
		m-&gt;m_pkthdr.len = pktlen;
	}
	
	DPFPRINTF((<span class="enscript-string">&quot;complete: 0x%llx ip6_plen %d m_pkthdr.len %d\n&quot;</span>,
	    (uint64_t)VM_KERNEL_ADDRPERM(m), ntohs(ip6-&gt;ip6_plen),
	    m-&gt;m_pkthdr.len));

	<span class="enscript-keyword">return</span> m;
	
 <span class="enscript-reference">drop_fragment</span>:
	<span class="enscript-comment">/* Oops - fail safe - drop packet */</span>
	pool_put(&amp;pf_frent_pl, frent);
	--pf_nfrents;
	m_freem(m);
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">pf_frag6cache</span>(<span class="enscript-type">struct</span> mbuf **m0, <span class="enscript-type">struct</span> ip6_hdr *h, <span class="enscript-type">struct</span> ip6_frag *fh,
    <span class="enscript-type">struct</span> pf_fragment **frag, <span class="enscript-type">int</span> hlen, <span class="enscript-type">int</span> mff, <span class="enscript-type">int</span> drop, <span class="enscript-type">int</span> *nomem)
{
	<span class="enscript-type">struct</span> mbuf *m = *m0;
	u_int16_t plen, off, fr_max;
	<span class="enscript-type">struct</span> pf_frcache *frp, *fra, *cur = NULL;
	<span class="enscript-type">int</span> hosed = 0;
	
	VERIFY(*frag == NULL || !BUFFER_FRAGMENTS(*frag));
	m = *m0;
	off = ntohs(fh-&gt;ip6f_offlg &amp; IP6F_OFF_MASK);
	plen = ntohs(h-&gt;ip6_plen) - (hlen - <span class="enscript-keyword">sizeof</span> *h);

	<span class="enscript-comment">/*
	 * Apple Modification: <a href="mailto:dimambro@apple.com">dimambro@apple.com</a>. The hlen, being passed
	 * into this function Includes all the headers associated with 
	 * the packet, and may include routing headers, so to get to
	 * the data payload as stored in the original IPv6 header we need
	 * to subtract al those headers and the IP header.
	 *
	 * The 'max' local variable should also contain the offset from the start
	 * of the reassembled packet to the octet just past the end of the octets
	 * in the current fragment where:
	 * - 'off' is the offset from the start of the reassembled packet to the
	 *    first octet in the fragment,
	 * - 'plen' is the length of the &quot;payload data length&quot; Excluding all the
	 *   IPv6 headers of the fragment.
	 * - 'hlen' is computed in pf_normalize_ip6() as the offset from the start
	 *   of the IPv6 packet to the beginning of the data.
	 */</span>
	fr_max = off + plen;
	
	DPFPRINTF((<span class="enscript-string">&quot;0x%llx plen %u off %u fr_max %u\n&quot;</span>,
	    (uint64_t)VM_KERNEL_ADDRPERM(m), plen, off, fr_max));

	<span class="enscript-comment">/* Create a new range queue for this packet */</span>
	<span class="enscript-keyword">if</span> (*frag == NULL) {
		*frag = pool_get(&amp;pf_cache_pl, PR_NOWAIT);
		<span class="enscript-keyword">if</span> (*frag == NULL) {
			pf_flush_fragments();
			*frag = pool_get(&amp;pf_cache_pl, PR_NOWAIT);
			<span class="enscript-keyword">if</span> (*frag == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
		}
		
		<span class="enscript-comment">/* Get an entry for the queue */</span>
		cur = pool_get(&amp;pf_cent_pl, PR_NOWAIT);
		<span class="enscript-keyword">if</span> (cur == NULL) {
			pool_put(&amp;pf_cache_pl, *frag);
			*frag = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
		}
		pf_ncache++;
		
		(*frag)-&gt;fr_flags = PFFRAG_NOBUFFER;
		(*frag)-&gt;fr_max = 0;
		(*frag)-&gt;fr_af = AF_INET6;
		(*frag)-&gt;fr_srcx.v6 = h-&gt;ip6_src;
		(*frag)-&gt;fr_dstx.v6 = h-&gt;ip6_dst;
		(*frag)-&gt;fr_p = fh-&gt;ip6f_nxt;
		(*frag)-&gt;fr_id6 = fh-&gt;ip6f_ident;
		(*frag)-&gt;fr_timeout = pf_time_second();
		
		cur-&gt;fr_off = off;
		cur-&gt;fr_end = fr_max;
		LIST_INIT(&amp;(*frag)-&gt;fr_cache);
		LIST_INSERT_HEAD(&amp;(*frag)-&gt;fr_cache, cur, fr_next);
		
		RB_INSERT(pf_frag_tree, &amp;pf_cache_tree, *frag);
		TAILQ_INSERT_HEAD(&amp;pf_cachequeue, *frag, frag_next);
		
		DPFPRINTF((<span class="enscript-string">&quot;frag6cache[%d]: new %d-%d\n&quot;</span>, ntohl(fh-&gt;ip6f_ident),
		    off, fr_max));
		
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">pass</span>;
	}
	
	<span class="enscript-comment">/*
	 * Find a fragment after the current one:
	 *  - off contains the real shifted offset.
	 */</span>
	frp = NULL;
	LIST_FOREACH(fra, &amp;(*frag)-&gt;fr_cache, fr_next) {
		<span class="enscript-keyword">if</span> (fra-&gt;fr_off &gt; off)
			<span class="enscript-keyword">break</span>;
		frp = fra;
	}
	
	VERIFY(frp != NULL || fra != NULL);
	
	<span class="enscript-keyword">if</span> (frp != NULL) {
		<span class="enscript-type">int</span> precut;
		
		precut = frp-&gt;fr_end - off;
		<span class="enscript-keyword">if</span> (precut &gt;= plen) {
			<span class="enscript-comment">/* Fragment is entirely a duplicate */</span>
			DPFPRINTF((<span class="enscript-string">&quot;frag6cache[%u]: dead (%d-%d) %d-%d\n&quot;</span>,
			    ntohl(fh-&gt;ip6f_ident), frp-&gt;fr_off, frp-&gt;fr_end,
			    off, fr_max));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop_fragment</span>;
		}
		<span class="enscript-keyword">if</span> (precut == 0) {
			<span class="enscript-comment">/* They are adjacent.  Fixup cache entry */</span>
			DPFPRINTF((<span class="enscript-string">&quot;frag6cache[%u]: adjacent (%d-%d) %d-%d\n&quot;</span>,
			    ntohl(fh-&gt;ip6f_ident), frp-&gt;fr_off, frp-&gt;fr_end,
			    off, fr_max));
			frp-&gt;fr_end = fr_max;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (precut &gt; 0) {
			<span class="enscript-comment">/* The first part of this payload overlaps with a
			 * fragment that has already been passed.
			 * Need to trim off the first part of the payload.
			 * But to do so easily, we need to create another
			 * mbuf to throw the original header into.
			 */</span>
			
			DPFPRINTF((<span class="enscript-string">&quot;frag6cache[%u]: chop %d (%d-%d) %d-%d\n&quot;</span>,
			    ntohl(fh-&gt;ip6f_ident), precut, frp-&gt;fr_off,
			    frp-&gt;fr_end, off, fr_max));
			
			off += precut;
			fr_max -= precut;
			<span class="enscript-comment">/* Update the previous frag to encompass this one */</span>
			frp-&gt;fr_end = fr_max;
			
			<span class="enscript-keyword">if</span> (!drop) {
				<span class="enscript-comment">/* XXX Optimization opportunity
				 * This is a very heavy way to trim the payload.
				 * we could do it much faster by diddling mbuf
				 * internals but that would be even less legible
				 * than this mbuf magic.  For my next trick,
				 * I'll pull a rabbit out of my laptop.
				 */</span>
				*m0 = m_copym(m, 0, hlen, M_NOWAIT);
				<span class="enscript-keyword">if</span> (*m0 == NULL)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
				VERIFY((*m0)-&gt;m_next == NULL);
				m_adj(m, precut + hlen);
				m_cat(*m0, m);
				m = *m0;
				<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR) {
					<span class="enscript-type">int</span> pktlen = 0;
					<span class="enscript-type">struct</span> mbuf *t;
					<span class="enscript-keyword">for</span> (t = m; t; t = t-&gt;m_next)
						pktlen += t-&gt;m_len;
					m-&gt;m_pkthdr.len = pktlen;
				}
				
				h = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
				
				VERIFY((<span class="enscript-type">int</span>)m-&gt;m_len ==
				    ntohs(h-&gt;ip6_plen) - precut);
				fh-&gt;ip6f_offlg &amp;= ~IP6F_OFF_MASK;
				fh-&gt;ip6f_offlg |=
				    htons(ntohs(fh-&gt;ip6f_offlg &amp; IP6F_OFF_MASK)
				    + (precut &gt;&gt; 3));
				h-&gt;ip6_plen = htons(ntohs(h-&gt;ip6_plen) -
				    precut);
			} <span class="enscript-keyword">else</span> {
				hosed++;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* There is a gap between fragments */</span>
			
			DPFPRINTF((<span class="enscript-string">&quot;frag6cache[%u]: gap %d (%d-%d) %d-%d\n&quot;</span>,
			    ntohl(fh-&gt;ip6f_ident), -precut, frp-&gt;fr_off,
			    frp-&gt;fr_end, off, fr_max));
			
			cur = pool_get(&amp;pf_cent_pl, PR_NOWAIT);
			<span class="enscript-keyword">if</span> (cur == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
			pf_ncache++;
			
			cur-&gt;fr_off = off;
			cur-&gt;fr_end = fr_max;
			LIST_INSERT_AFTER(frp, cur, fr_next);
		}
	}
	
	<span class="enscript-keyword">if</span> (fra != NULL) {
		<span class="enscript-type">int</span>	aftercut;
		<span class="enscript-type">int</span>	merge = 0;
		
		aftercut = fr_max - fra-&gt;fr_off;
		<span class="enscript-keyword">if</span> (aftercut == 0) {
			<span class="enscript-comment">/* Adjacent fragments */</span>
			DPFPRINTF((<span class="enscript-string">&quot;frag6cache[%u]: adjacent %d-%d (%d-%d)\n&quot;</span>,
			    ntohl(fh-&gt;ip6f_ident), off, fr_max, fra-&gt;fr_off,
			    fra-&gt;fr_end));
			fra-&gt;fr_off = off;
			merge = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (aftercut &gt; 0) {
			<span class="enscript-comment">/* Need to chop off the tail of this fragment */</span>
			DPFPRINTF((<span class="enscript-string">&quot;frag6cache[%u]: chop %d %d-%d (%d-%d)\n&quot;</span>,
			    ntohl(fh-&gt;ip6f_ident), aftercut, off, fr_max,
			    fra-&gt;fr_off, fra-&gt;fr_end));
			fra-&gt;fr_off = off;
			fr_max -= aftercut;
			
			merge = 1;
			
			<span class="enscript-keyword">if</span> (!drop) {
				m_adj(m, -aftercut);
				<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR) {
					<span class="enscript-type">int</span> pktlen = 0;
					<span class="enscript-type">struct</span> mbuf *t;
					<span class="enscript-keyword">for</span> (t = m; t; t = t-&gt;m_next)
						pktlen += t-&gt;m_len;
					m-&gt;m_pkthdr.len = pktlen;
				}
				h = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
				VERIFY((<span class="enscript-type">int</span>)m-&gt;m_len ==
				    ntohs(h-&gt;ip6_plen) - aftercut);
				h-&gt;ip6_plen =
				    htons(ntohs(h-&gt;ip6_plen) - aftercut);
			} <span class="enscript-keyword">else</span> {
				hosed++;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (frp == NULL) {
			<span class="enscript-comment">/* There is a gap between fragments */</span>
			DPFPRINTF((<span class="enscript-string">&quot;frag6cache[%u]: gap %d %d-%d (%d-%d)\n&quot;</span>,
			    ntohl(fh-&gt;ip6f_ident), -aftercut, off, fr_max,
			    fra-&gt;fr_off, fra-&gt;fr_end));
			
			cur = pool_get(&amp;pf_cent_pl, PR_NOWAIT);
			<span class="enscript-keyword">if</span> (cur == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
			pf_ncache++;
			
			cur-&gt;fr_off = off;
			cur-&gt;fr_end = fr_max;
			LIST_INSERT_BEFORE(fra, cur, fr_next);
		}
		
		<span class="enscript-comment">/* Need to glue together two separate fragment descriptors */</span>
		<span class="enscript-keyword">if</span> (merge) {
			<span class="enscript-keyword">if</span> (cur &amp;&amp; fra-&gt;fr_off &lt;= cur-&gt;fr_end) {
				<span class="enscript-comment">/* Need to merge in a previous 'cur' */</span>
				DPFPRINTF((<span class="enscript-string">&quot;frag6cache[%u]: adjacent(merge &quot;</span>
				    <span class="enscript-string">&quot;%d-%d) %d-%d (%d-%d)\n&quot;</span>,
				    ntohl(fh-&gt;ip6f_ident), cur-&gt;fr_off,
				    cur-&gt;fr_end, off, fr_max, fra-&gt;fr_off,
				    fra-&gt;fr_end));
				fra-&gt;fr_off = cur-&gt;fr_off;
				LIST_REMOVE(cur, fr_next);
				pool_put(&amp;pf_cent_pl, cur);
				pf_ncache--;
				cur = NULL;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (frp &amp;&amp; fra-&gt;fr_off &lt;= frp-&gt;fr_end) {
				<span class="enscript-comment">/* Need to merge in a modified 'frp' */</span>
				VERIFY(cur == NULL);
				DPFPRINTF((<span class="enscript-string">&quot;frag6cache[%u]: adjacent(merge &quot;</span>
				    <span class="enscript-string">&quot;%d-%d) %d-%d (%d-%d)\n&quot;</span>,
				    ntohl(fh-&gt;ip6f_ident), frp-&gt;fr_off,
				    frp-&gt;fr_end, off, fr_max, fra-&gt;fr_off,
				    fra-&gt;fr_end));
				fra-&gt;fr_off = frp-&gt;fr_off;
				LIST_REMOVE(frp, fr_next);
				pool_put(&amp;pf_cent_pl, frp);
				pf_ncache--;
				frp = NULL;
			}
		}
	}
	
	<span class="enscript-keyword">if</span> (hosed) {
		<span class="enscript-comment">/*
		 * We must keep tracking the overall fragment even when
		 * we're going to drop it anyway so that we know when to
		 * free the overall descriptor.  Thus we drop the frag late.
		 */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop_fragment</span>;
	}
	
 <span class="enscript-reference">pass</span>:
	<span class="enscript-comment">/* Update maximum data size */</span>
	<span class="enscript-keyword">if</span> ((*frag)-&gt;fr_max &lt; fr_max)
		(*frag)-&gt;fr_max = fr_max;
	
	<span class="enscript-comment">/* This is the last segment */</span>
	<span class="enscript-keyword">if</span> (!mff)
		(*frag)-&gt;fr_flags |= PFFRAG_SEENLAST;
	
	<span class="enscript-comment">/* Check if we are completely reassembled */</span>
	<span class="enscript-keyword">if</span> (((*frag)-&gt;fr_flags &amp; PFFRAG_SEENLAST) &amp;&amp;
	    LIST_FIRST(&amp;(*frag)-&gt;fr_cache)-&gt;fr_off == 0 &amp;&amp;
	    LIST_FIRST(&amp;(*frag)-&gt;fr_cache)-&gt;fr_end == (*frag)-&gt;fr_max) {
		<span class="enscript-comment">/* Remove from fragment queue */</span>
		DPFPRINTF((<span class="enscript-string">&quot;frag6cache[%u]: done 0-%d\n&quot;</span>,
		    ntohl(fh-&gt;ip6f_ident), (*frag)-&gt;fr_max));
		pf_free_fragment(*frag);
		*frag = NULL;
	}
	
	<span class="enscript-keyword">return</span> (m);
	
 <span class="enscript-reference">no_mem</span>:
	*nomem = 1;
	
	<span class="enscript-comment">/* Still need to pay attention to !IP_MF */</span>
	<span class="enscript-keyword">if</span> (!mff &amp;&amp; *frag != NULL)
		(*frag)-&gt;fr_flags |= PFFRAG_SEENLAST;
	
	m_freem(m);
	<span class="enscript-keyword">return</span> (NULL);
	
 <span class="enscript-reference">drop_fragment</span>:
	
	<span class="enscript-comment">/* Still need to pay attention to !IP_MF */</span>
	<span class="enscript-keyword">if</span> (!mff &amp;&amp; *frag != NULL)
		(*frag)-&gt;fr_flags |= PFFRAG_SEENLAST;
	
	<span class="enscript-keyword">if</span> (drop) {
		<span class="enscript-comment">/* This fragment has been deemed bad.  Don't reass */</span>
		<span class="enscript-keyword">if</span> (((*frag)-&gt;fr_flags &amp; PFFRAG_DROP) == 0)
			DPFPRINTF((<span class="enscript-string">&quot;frag6cache[%u]: dropping overall fragment\n&quot;</span>,
			    ntohl(fh-&gt;ip6f_ident)));
		(*frag)-&gt;fr_flags |= PFFRAG_DROP;
	}
	
	m_freem(m);
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_normalize_ip</span>(<span class="enscript-type">struct</span> mbuf **m0, <span class="enscript-type">int</span> dir, <span class="enscript-type">struct</span> pfi_kif *kif, u_short *reason,
    <span class="enscript-type">struct</span> pf_pdesc *pd)
{
	<span class="enscript-type">struct</span> mbuf		*m = *m0;
	<span class="enscript-type">struct</span> pf_rule		*r;
	<span class="enscript-type">struct</span> pf_frent		*frent;
	<span class="enscript-type">struct</span> pf_fragment	*frag = NULL;
	<span class="enscript-type">struct</span> ip		*h = mtod(m, <span class="enscript-type">struct</span> ip *);
	<span class="enscript-type">int</span>			 mff = (ntohs(h-&gt;ip_off) &amp; IP_MF);
	<span class="enscript-type">int</span>			 hlen = h-&gt;ip_hl &lt;&lt; 2;
	u_int16_t		 fragoff = (ntohs(h-&gt;ip_off) &amp; IP_OFFMASK) &lt;&lt; 3;
	u_int16_t		 fr_max;
	<span class="enscript-type">int</span>			 ip_len;
	<span class="enscript-type">int</span>			 ip_off;
	<span class="enscript-type">int</span>			 asd = 0;
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset = NULL;

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_SCRUB].active.ptr);
	<span class="enscript-keyword">while</span> (r != NULL) {
		r-&gt;evaluations++;
		<span class="enscript-keyword">if</span> (pfi_kif_match(r-&gt;kif, kif) == r-&gt;ifnot)
			r = r-&gt;skip[PF_SKIP_IFP].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;direction &amp;&amp; r-&gt;direction != dir)
			r = r-&gt;skip[PF_SKIP_DIR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;af &amp;&amp; r-&gt;af != AF_INET)
			r = r-&gt;skip[PF_SKIP_AF].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;proto &amp;&amp; r-&gt;proto != h-&gt;ip_p)
			r = r-&gt;skip[PF_SKIP_PROTO].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PF_MISMATCHAW(&amp;r-&gt;src.addr,
		    (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip_src.s_addr, AF_INET,
		    r-&gt;src.neg, kif))
			r = r-&gt;skip[PF_SKIP_SRC_ADDR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PF_MISMATCHAW(&amp;r-&gt;dst.addr,
		    (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip_dst.s_addr, AF_INET,
		    r-&gt;dst.neg, NULL))
			r = r-&gt;skip[PF_SKIP_DST_ADDR].ptr;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (r-&gt;anchor == NULL)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">else</span>
				pf_step_into_anchor(&amp;asd, &amp;ruleset,
				    PF_RULESET_SCRUB, &amp;r, NULL, NULL);
		}
		<span class="enscript-keyword">if</span> (r == NULL &amp;&amp; pf_step_out_of_anchor(&amp;asd, &amp;ruleset,
		    PF_RULESET_SCRUB, &amp;r, NULL, NULL))
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (r == NULL || r-&gt;action == PF_NOSCRUB)
		<span class="enscript-keyword">return</span> (PF_PASS);
	<span class="enscript-keyword">else</span> {
		r-&gt;packets[dir == PF_OUT]++;
		r-&gt;bytes[dir == PF_OUT] += pd-&gt;tot_len;
	}

	<span class="enscript-comment">/* Check for illegal packets */</span>
	<span class="enscript-keyword">if</span> (hlen &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;

	<span class="enscript-keyword">if</span> (hlen &gt; ntohs(h-&gt;ip_len))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;

	<span class="enscript-comment">/* Clear IP_DF if the rule uses the no-df option */</span>
	<span class="enscript-keyword">if</span> (r-&gt;rule_flag &amp; PFRULE_NODF &amp;&amp; h-&gt;ip_off &amp; htons(IP_DF)) {
		u_int16_t ipoff = h-&gt;ip_off;

		h-&gt;ip_off &amp;= htons(~IP_DF);
		h-&gt;ip_sum = pf_cksum_fixup(h-&gt;ip_sum, ipoff, h-&gt;ip_off, 0);
	}

	<span class="enscript-comment">/* We will need other tests here */</span>
	<span class="enscript-keyword">if</span> (!fragoff &amp;&amp; !mff)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_fragment</span>;

	<span class="enscript-comment">/*
	 * We're dealing with a fragment now. Don't allow fragments
	 * with IP_DF to enter the cache. If the flag was cleared by
	 * no-df above, fine. Otherwise drop it.
	 */</span>
	<span class="enscript-keyword">if</span> (h-&gt;ip_off &amp; htons(IP_DF)) {
		DPFPRINTF((<span class="enscript-string">&quot;IP_DF\n&quot;</span>));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	ip_len = ntohs(h-&gt;ip_len) - hlen;
	ip_off = (ntohs(h-&gt;ip_off) &amp; IP_OFFMASK) &lt;&lt; 3;

	<span class="enscript-comment">/* All fragments are 8 byte aligned */</span>
	<span class="enscript-keyword">if</span> (mff &amp;&amp; (ip_len &amp; 0x7)) {
		DPFPRINTF((<span class="enscript-string">&quot;mff and %d\n&quot;</span>, ip_len));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* Respect maximum length */</span>
	<span class="enscript-keyword">if</span> (fragoff + ip_len &gt; IP_MAXPACKET) {
		DPFPRINTF((<span class="enscript-string">&quot;max packet %d\n&quot;</span>, fragoff + ip_len));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	fr_max = fragoff + ip_len;

	<span class="enscript-keyword">if</span> ((r-&gt;rule_flag &amp; (PFRULE_FRAGCROP|PFRULE_FRAGDROP)) == 0) {
		<span class="enscript-comment">/* Fully buffer all of the fragments */</span>

		frag = pf_find_fragment_by_ipv4_header(h, &amp;pf_frag_tree);
		<span class="enscript-comment">/* Check if we saw the last fragment already */</span>
		<span class="enscript-keyword">if</span> (frag != NULL &amp;&amp; (frag-&gt;fr_flags &amp; PFFRAG_SEENLAST) &amp;&amp;
		    fr_max &gt; frag-&gt;fr_max)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		<span class="enscript-comment">/* Get an entry for the fragment queue */</span>
		frent = pool_get(&amp;pf_frent_pl, PR_NOWAIT);
		<span class="enscript-keyword">if</span> (frent == NULL) {
			REASON_SET(reason, PFRES_MEMORY);
			<span class="enscript-keyword">return</span> (PF_DROP);
		}
		pf_nfrents++;
		frent-&gt;fr_ip = h;
		frent-&gt;fr_m = m;

		<span class="enscript-comment">/* Might return a completely reassembled mbuf, or NULL */</span>
		DPFPRINTF((<span class="enscript-string">&quot;reass IPv4 frag %d @ %d-%d\n&quot;</span>, ntohs(h-&gt;ip_id),
		    fragoff, fr_max));
		*m0 = m = pf_reassemble(m0, &amp;frag, frent, mff);

		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span> (PF_DROP);

		VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

		<span class="enscript-comment">/* use mtag from concatenated mbuf chain */</span>
		pd-&gt;pf_mtag = pf_find_mtag(m);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (pd-&gt;pf_mtag == NULL) {
			printf(<span class="enscript-string">&quot;%s: pf_find_mtag returned NULL(1)\n&quot;</span>, __func__);
			<span class="enscript-keyword">if</span> ((pd-&gt;pf_mtag = pf_get_mtag(m)) == NULL) {
				m_freem(m);
				*m0 = NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
			}
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (frag != NULL &amp;&amp; (frag-&gt;fr_flags &amp; PFFRAG_DROP))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;

		h = mtod(m, <span class="enscript-type">struct</span> ip *);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* non-buffering fragment cache (drops or masks overlaps) */</span>
		<span class="enscript-type">int</span>	nomem = 0;

		<span class="enscript-keyword">if</span> (dir == PF_OUT &amp;&amp; (pd-&gt;pf_mtag-&gt;pftag_flags &amp; PF_TAG_FRAGCACHE)) {
			<span class="enscript-comment">/*
			 * Already passed the fragment cache in the
			 * input direction.  If we continued, it would
			 * appear to be a dup and would be dropped.
			 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fragment_pass</span>;
		}

		frag = pf_find_fragment_by_ipv4_header(h, &amp;pf_cache_tree);

		<span class="enscript-comment">/* Check if we saw the last fragment already */</span>
		<span class="enscript-keyword">if</span> (frag != NULL &amp;&amp; (frag-&gt;fr_flags &amp; PFFRAG_SEENLAST) &amp;&amp;
		    fr_max &gt; frag-&gt;fr_max) {
			<span class="enscript-keyword">if</span> (r-&gt;rule_flag &amp; PFRULE_FRAGDROP)
				frag-&gt;fr_flags |= PFFRAG_DROP;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		*m0 = m = pf_fragcache(m0, h, &amp;frag, mff,
		    (r-&gt;rule_flag &amp; PFRULE_FRAGDROP) ? 1 : 0, &amp;nomem);
		<span class="enscript-keyword">if</span> (m == NULL) {
			<span class="enscript-keyword">if</span> (nomem)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
		}

		VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

		<span class="enscript-comment">/* use mtag from copied and trimmed mbuf chain */</span>
		pd-&gt;pf_mtag = pf_find_mtag(m);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (pd-&gt;pf_mtag == NULL) {
			printf(<span class="enscript-string">&quot;%s: pf_find_mtag returned NULL(2)\n&quot;</span>, __func__);
			<span class="enscript-keyword">if</span> ((pd-&gt;pf_mtag = pf_get_mtag(m)) == NULL) {
				m_freem(m);
				*m0 = NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
			}
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (dir == PF_IN)
			pd-&gt;pf_mtag-&gt;pftag_flags |= PF_TAG_FRAGCACHE;

		<span class="enscript-keyword">if</span> (frag != NULL &amp;&amp; (frag-&gt;fr_flags &amp; PFFRAG_DROP))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fragment_pass</span>;
	}

<span class="enscript-reference">no_fragment</span>:
	<span class="enscript-comment">/* At this point, only IP_DF is allowed in ip_off */</span>
	<span class="enscript-keyword">if</span> (h-&gt;ip_off &amp; ~htons(IP_DF)) {
		u_int16_t ipoff = h-&gt;ip_off;

		h-&gt;ip_off &amp;= htons(IP_DF);
		h-&gt;ip_sum = pf_cksum_fixup(h-&gt;ip_sum, ipoff, h-&gt;ip_off, 0);
	}

	<span class="enscript-comment">/* Enforce a minimum ttl, may cause endless packet loops */</span>
	<span class="enscript-keyword">if</span> (r-&gt;min_ttl &amp;&amp; h-&gt;ip_ttl &lt; r-&gt;min_ttl) {
		u_int16_t ip_ttl = h-&gt;ip_ttl;

		h-&gt;ip_ttl = r-&gt;min_ttl;
		h-&gt;ip_sum = pf_cksum_fixup(h-&gt;ip_sum, ip_ttl, h-&gt;ip_ttl, 0);
	}
	<span class="enscript-keyword">if</span> (r-&gt;rule_flag &amp; PFRULE_RANDOMID) {
		u_int16_t oip_id = h-&gt;ip_id;

		h-&gt;ip_id = ip_randomid();
		h-&gt;ip_sum = pf_cksum_fixup(h-&gt;ip_sum, oip_id, h-&gt;ip_id, 0);
	}
	<span class="enscript-keyword">if</span> ((r-&gt;rule_flag &amp; (PFRULE_FRAGCROP|PFRULE_FRAGDROP)) == 0)
		pd-&gt;flags |= PFDESC_IP_REAS;

	<span class="enscript-keyword">return</span> (PF_PASS);

<span class="enscript-reference">fragment_pass</span>:
	<span class="enscript-comment">/* Enforce a minimum ttl, may cause endless packet loops */</span>
	<span class="enscript-keyword">if</span> (r-&gt;min_ttl &amp;&amp; h-&gt;ip_ttl &lt; r-&gt;min_ttl) {
		u_int16_t ip_ttl = h-&gt;ip_ttl;

		h-&gt;ip_ttl = r-&gt;min_ttl;
		h-&gt;ip_sum = pf_cksum_fixup(h-&gt;ip_sum, ip_ttl, h-&gt;ip_ttl, 0);
	}
	<span class="enscript-keyword">if</span> ((r-&gt;rule_flag &amp; (PFRULE_FRAGCROP|PFRULE_FRAGDROP)) == 0)
		pd-&gt;flags |= PFDESC_IP_REAS;
	<span class="enscript-keyword">return</span> (PF_PASS);

<span class="enscript-reference">no_mem</span>:
	REASON_SET(reason, PFRES_MEMORY);
	<span class="enscript-keyword">if</span> (r != NULL &amp;&amp; r-&gt;log)
		PFLOG_PACKET(kif, h, m, AF_INET, dir, *reason, r,
		    NULL, NULL, pd);
	<span class="enscript-keyword">return</span> (PF_DROP);

<span class="enscript-reference">drop</span>:
	REASON_SET(reason, PFRES_NORM);
	<span class="enscript-keyword">if</span> (r != NULL &amp;&amp; r-&gt;log)
		PFLOG_PACKET(kif, h, m, AF_INET, dir, *reason, r,
		    NULL, NULL, pd);
	<span class="enscript-keyword">return</span> (PF_DROP);

<span class="enscript-reference">bad</span>:
	DPFPRINTF((<span class="enscript-string">&quot;dropping bad IPv4 fragment\n&quot;</span>));

	<span class="enscript-comment">/* Free associated fragments */</span>
	<span class="enscript-keyword">if</span> (frag != NULL)
		pf_free_fragment(frag);

	REASON_SET(reason, PFRES_FRAG);
	<span class="enscript-keyword">if</span> (r != NULL &amp;&amp; r-&gt;log)
		PFLOG_PACKET(kif, h, m, AF_INET, dir, *reason, r, NULL, NULL, pd);

	<span class="enscript-keyword">return</span> (PF_DROP);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_normalize_ip6</span>(<span class="enscript-type">struct</span> mbuf **m0, <span class="enscript-type">int</span> dir, <span class="enscript-type">struct</span> pfi_kif *kif,
    u_short *reason, <span class="enscript-type">struct</span> pf_pdesc *pd)
{
	<span class="enscript-type">struct</span> mbuf		*m = *m0;
	<span class="enscript-type">struct</span> pf_rule		*r;
	<span class="enscript-type">struct</span> ip6_hdr		*h = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-type">int</span>			 off;
	<span class="enscript-type">struct</span> ip6_ext		 ext;
<span class="enscript-comment">/* adi XXX */</span>
#<span class="enscript-reference">if</span> 0
	<span class="enscript-type">struct</span> ip6_opt		 opt;
	<span class="enscript-type">struct</span> ip6_opt_jumbo	 jumbo;
	<span class="enscript-type">int</span>			 optend;
	<span class="enscript-type">int</span>			 ooff;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> ip6_frag		 frag;
	u_int32_t		 jumbolen = 0, plen;
	u_int16_t		 fragoff = 0;
	u_int8_t		 proto;
	<span class="enscript-type">int</span>			 terminal;
	<span class="enscript-type">struct</span> pf_frent		*frent;
	<span class="enscript-type">struct</span> pf_fragment	*pff = NULL;
	<span class="enscript-type">int</span>			 mff = 0, rh_cnt = 0;
	u_int16_t		 fr_max;
	<span class="enscript-type">int</span>			 asd = 0;
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset = NULL;

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_SCRUB].active.ptr);
	<span class="enscript-keyword">while</span> (r != NULL) {
		r-&gt;evaluations++;
		<span class="enscript-keyword">if</span> (pfi_kif_match(r-&gt;kif, kif) == r-&gt;ifnot)
			r = r-&gt;skip[PF_SKIP_IFP].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;direction &amp;&amp; r-&gt;direction != dir)
			r = r-&gt;skip[PF_SKIP_DIR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;af &amp;&amp; r-&gt;af != AF_INET6)
			r = r-&gt;skip[PF_SKIP_AF].ptr;
#<span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* header chain! */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;proto &amp;&amp; r-&gt;proto != h-&gt;ip6_nxt)
			r = r-&gt;skip[PF_SKIP_PROTO].ptr;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PF_MISMATCHAW(&amp;r-&gt;src.addr,
		    (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip6_src, AF_INET6,
		    r-&gt;src.neg, kif))
			r = r-&gt;skip[PF_SKIP_SRC_ADDR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PF_MISMATCHAW(&amp;r-&gt;dst.addr,
		    (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip6_dst, AF_INET6,
		    r-&gt;dst.neg, NULL))
			r = r-&gt;skip[PF_SKIP_DST_ADDR].ptr;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (r-&gt;anchor == NULL)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">else</span>
				pf_step_into_anchor(&amp;asd, &amp;ruleset,
				    PF_RULESET_SCRUB, &amp;r, NULL, NULL);
		}
		<span class="enscript-keyword">if</span> (r == NULL &amp;&amp; pf_step_out_of_anchor(&amp;asd, &amp;ruleset,
		    PF_RULESET_SCRUB, &amp;r, NULL, NULL))
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (r == NULL || r-&gt;action == PF_NOSCRUB)
		<span class="enscript-keyword">return</span> (PF_PASS);
	<span class="enscript-keyword">else</span> {
		r-&gt;packets[dir == PF_OUT]++;
		r-&gt;bytes[dir == PF_OUT] += pd-&gt;tot_len;
	}

	<span class="enscript-comment">/* Check for illegal packets */</span>
	<span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) + IPV6_MAXPACKET) &lt; m-&gt;m_pkthdr.len)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;

	off = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr);
	proto = h-&gt;ip6_nxt;
	terminal = 0;
	<span class="enscript-keyword">do</span> {
		pd-&gt;proto = proto;
		<span class="enscript-keyword">switch</span> (proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_FRAGMENT</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fragment</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ROUTING</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_DSTOPTS</span>:
			<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;ext, <span class="enscript-keyword">sizeof</span> (ext), NULL,
			    NULL, AF_INET6))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">shortpkt</span>;
			<span class="enscript-comment">/*
			 * &lt;<a href="mailto:jhw@apple.com">jhw@apple.com</a>&gt;
			 * Multiple routing headers not allowed.
			 * Routing header type zero considered harmful.
			 */</span>
			<span class="enscript-keyword">if</span> (proto == IPPROTO_ROUTING) {
				<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ip6_rthdr *rh =
				    (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ip6_rthdr *)&amp;ext;
				<span class="enscript-keyword">if</span> (rh_cnt++)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
				<span class="enscript-keyword">if</span> (rh-&gt;ip6r_type == IPV6_RTHDR_TYPE_0)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			}
			<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">if</span> (proto == IPPROTO_AH)
				off += (ext.ip6e_len + 2) * 4;
			<span class="enscript-keyword">else</span>
				off += (ext.ip6e_len + 1) * 8;
			proto = ext.ip6e_nxt;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_HOPOPTS</span>:
<span class="enscript-comment">/* adi XXX */</span>
#<span class="enscript-reference">if</span> 0
			<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;ext, <span class="enscript-keyword">sizeof</span> (ext), NULL,
			    NULL, AF_INET6))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">shortpkt</span>;
			optend = off + (ext.ip6e_len + 1) * 8;
			ooff = off + <span class="enscript-keyword">sizeof</span> (ext);
			<span class="enscript-keyword">do</span> {
				<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, ooff, &amp;opt.ip6o_type,
				    <span class="enscript-keyword">sizeof</span> (opt.ip6o_type), NULL, NULL,
				    AF_INET6))
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">shortpkt</span>;
				<span class="enscript-keyword">if</span> (opt.ip6o_type == IP6OPT_PAD1) {
					ooff++;
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, ooff, &amp;opt, <span class="enscript-keyword">sizeof</span> (opt),
				    NULL, NULL, AF_INET6))
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">shortpkt</span>;
				<span class="enscript-keyword">if</span> (ooff + <span class="enscript-keyword">sizeof</span> (opt) + opt.ip6o_len &gt; optend)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
				<span class="enscript-keyword">switch</span> (opt.ip6o_type) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IP6OPT_JUMBO</span>:
					<span class="enscript-keyword">if</span> (h-&gt;ip6_plen != 0)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
					<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, ooff, &amp;jumbo,
					    <span class="enscript-keyword">sizeof</span> (jumbo), NULL, NULL,
					    AF_INET6))
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">shortpkt</span>;
					memcpy(&amp;jumbolen, jumbo.ip6oj_jumbo_len,
					    <span class="enscript-keyword">sizeof</span> (jumbolen));
					jumbolen = ntohl(jumbolen);
					<span class="enscript-keyword">if</span> (jumbolen &lt;= IPV6_MAXPACKET)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
					<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) +
					    jumbolen != m-&gt;m_pkthdr.len)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					<span class="enscript-keyword">break</span>;
				}
				ooff += <span class="enscript-keyword">sizeof</span> (opt) + opt.ip6o_len;
			} <span class="enscript-keyword">while</span> (ooff &lt; optend);

			off = optend;
			proto = ext.ip6e_nxt;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
		<span class="enscript-reference">default</span>:
			terminal = 1;
			<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">while</span> (!terminal);

	<span class="enscript-comment">/* jumbo payload option must be present, or plen &gt; 0 */</span>
	<span class="enscript-keyword">if</span> (ntohs(h-&gt;ip6_plen) == 0)
		plen = jumbolen;
	<span class="enscript-keyword">else</span>
		plen = ntohs(h-&gt;ip6_plen);
	<span class="enscript-keyword">if</span> (plen == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
	<span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) + plen) &gt; m-&gt;m_pkthdr.len)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">shortpkt</span>;

	<span class="enscript-comment">/* Enforce a minimum ttl, may cause endless packet loops */</span>
	<span class="enscript-keyword">if</span> (r-&gt;min_ttl &amp;&amp; h-&gt;ip6_hlim &lt; r-&gt;min_ttl)
		h-&gt;ip6_hlim = r-&gt;min_ttl;

	<span class="enscript-keyword">return</span> (PF_PASS);

<span class="enscript-reference">fragment</span>:
	<span class="enscript-keyword">if</span> (ntohs(h-&gt;ip6_plen) == 0 || jumbolen)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
	plen = ntohs(h-&gt;ip6_plen);

	<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;frag, <span class="enscript-keyword">sizeof</span> (frag), NULL, NULL, AF_INET6))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">shortpkt</span>;
	fragoff = ntohs(frag.ip6f_offlg &amp; IP6F_OFF_MASK);
	pd-&gt;proto = frag.ip6f_nxt;
	mff = ntohs(frag.ip6f_offlg &amp; IP6F_MORE_FRAG);
	off += <span class="enscript-keyword">sizeof</span> frag;
	<span class="enscript-keyword">if</span> (fragoff + (plen - off) &gt; IPV6_MAXPACKET)
	       <span class="enscript-keyword">goto</span> <span class="enscript-reference">badfrag</span>;
	
	fr_max = fragoff + plen - (off - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
	DPFPRINTF((<span class="enscript-string">&quot;0x%llx IPv6 frag plen %u mff %d off %u fragoff %u &quot;</span>
	    <span class="enscript-string">&quot;fr_max %u\n&quot;</span>, (uint64_t)VM_KERNEL_ADDRPERM(m), plen, mff, off,
	    fragoff, fr_max));
	
	<span class="enscript-keyword">if</span> ((r-&gt;rule_flag &amp; (PFRULE_FRAGCROP|PFRULE_FRAGDROP)) == 0) {
		<span class="enscript-comment">/* Fully buffer all of the fragments */</span>
		pd-&gt;flags |= PFDESC_IP_REAS;
		
		pff = pf_find_fragment_by_ipv6_header(h, &amp;frag,
		   &amp;pf_frag_tree);
		
		<span class="enscript-comment">/* Check if we saw the last fragment already */</span>
		<span class="enscript-keyword">if</span> (pff != NULL &amp;&amp; (pff-&gt;fr_flags &amp; PFFRAG_SEENLAST) &amp;&amp;
		    fr_max &gt; pff-&gt;fr_max)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badfrag</span>;
		
		<span class="enscript-comment">/* Get an entry for the fragment queue */</span>
		frent = pool_get(&amp;pf_frent_pl, PR_NOWAIT);
		<span class="enscript-keyword">if</span> (frent == NULL) {
			REASON_SET(reason, PFRES_MEMORY);
			<span class="enscript-keyword">return</span> (PF_DROP);
		}
		pf_nfrents++;
		frent-&gt;fr_ip6 = h;
		frent-&gt;fr_m = m;
		frent-&gt;fr_ip6f_opt = frag;
		frent-&gt;fr_ip6f_hlen = off;
		
		<span class="enscript-comment">/* Might return a completely reassembled mbuf, or NULL */</span>
		DPFPRINTF((<span class="enscript-string">&quot;reass IPv6 frag %d @ %d-%d\n&quot;</span>,
		     ntohl(frag.ip6f_ident), fragoff, fr_max));
		*m0 = m = pf_reassemble6(m0, &amp;pff, frent, mff);
		
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span> (PF_DROP);
		
		<span class="enscript-keyword">if</span> (pff != NULL &amp;&amp; (pff-&gt;fr_flags &amp; PFFRAG_DROP))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
		
		h = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dir == PF_IN || !(pd-&gt;pf_mtag-&gt;pftag_flags &amp; PF_TAG_FRAGCACHE)) {
		<span class="enscript-comment">/* non-buffering fragment cache (overlaps: see RFC 5722) */</span>
		<span class="enscript-type">int</span> nomem = 0;
		
		pff = pf_find_fragment_by_ipv6_header(h, &amp;frag,
		    &amp;pf_cache_tree);
		
		<span class="enscript-comment">/* Check if we saw the last fragment already */</span>
		<span class="enscript-keyword">if</span> (pff != NULL &amp;&amp; (pff-&gt;fr_flags &amp; PFFRAG_SEENLAST) &amp;&amp;
		    fr_max &gt; pff-&gt;fr_max) {
		       <span class="enscript-keyword">if</span> (r-&gt;rule_flag &amp; PFRULE_FRAGDROP)
				pff-&gt;fr_flags |= PFFRAG_DROP;
		       <span class="enscript-keyword">goto</span> <span class="enscript-reference">badfrag</span>;
		}
		
		*m0 = m = pf_frag6cache(m0, h, &amp;frag, &amp;pff, off, mff,
		     (r-&gt;rule_flag &amp; PFRULE_FRAGDROP) ? 1 : 0, &amp;nomem);
		<span class="enscript-keyword">if</span> (m == NULL) {
			<span class="enscript-keyword">if</span> (nomem)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mem</span>;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
		}
		
		<span class="enscript-keyword">if</span> (dir == PF_IN)
			pd-&gt;pf_mtag-&gt;pftag_flags |= PF_TAG_FRAGCACHE;
		
		<span class="enscript-keyword">if</span> (pff != NULL &amp;&amp; (pff-&gt;fr_flags &amp; PFFRAG_DROP))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
	}
	
	<span class="enscript-comment">/* Enforce a minimum ttl, may cause endless packet loops */</span>
	<span class="enscript-keyword">if</span> (r-&gt;min_ttl &amp;&amp; h-&gt;ip6_hlim &lt; r-&gt;min_ttl)
		h-&gt;ip6_hlim = r-&gt;min_ttl;
	<span class="enscript-keyword">return</span> (PF_PASS);

  <span class="enscript-reference">no_mem</span>:
	REASON_SET(reason, PFRES_MEMORY);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropout</span>;
	
  <span class="enscript-reference">shortpkt</span>:
	REASON_SET(reason, PFRES_SHORT);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropout</span>;
	
  <span class="enscript-reference">drop</span>:
	REASON_SET(reason, PFRES_NORM);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropout</span>;
	
  <span class="enscript-reference">badfrag</span>:
	DPFPRINTF((<span class="enscript-string">&quot;dropping bad IPv6 fragment\n&quot;</span>));
	REASON_SET(reason, PFRES_FRAG);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropout</span>;
	
  <span class="enscript-reference">dropout</span>:
	<span class="enscript-keyword">if</span> (pff != NULL)
		pf_free_fragment(pff);
	<span class="enscript-keyword">if</span> (r != NULL &amp;&amp; r-&gt;log)
		PFLOG_PACKET(kif, h, m, AF_INET6, dir, *reason, r, NULL, NULL, pd);
	<span class="enscript-keyword">return</span> (PF_DROP);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_normalize_tcp</span>(<span class="enscript-type">int</span> dir, <span class="enscript-type">struct</span> pfi_kif *kif, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> ipoff,
    <span class="enscript-type">int</span> off, <span class="enscript-type">void</span> *h, <span class="enscript-type">struct</span> pf_pdesc *pd)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ipoff</span>, <span class="enscript-variable-name">h</span>)
	<span class="enscript-type">struct</span> pf_rule	*r, *rm = NULL;
	<span class="enscript-type">struct</span> tcphdr	*th = pd-&gt;hdr.tcp;
	<span class="enscript-type">int</span>		 rewrite = 0;
	<span class="enscript-type">int</span>		 asd = 0;
	u_short		 reason;
	u_int8_t	 flags;
	sa_family_t	 af = pd-&gt;af;
	<span class="enscript-type">struct</span> pf_ruleset *ruleset = NULL;
	<span class="enscript-type">union</span> pf_state_xport sxport, dxport;

	sxport.port = th-&gt;th_sport;
	dxport.port = th-&gt;th_dport;

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_SCRUB].active.ptr);
	<span class="enscript-keyword">while</span> (r != NULL) {
		r-&gt;evaluations++;
		<span class="enscript-keyword">if</span> (pfi_kif_match(r-&gt;kif, kif) == r-&gt;ifnot)
			r = r-&gt;skip[PF_SKIP_IFP].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;direction &amp;&amp; r-&gt;direction != dir)
			r = r-&gt;skip[PF_SKIP_DIR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;af &amp;&amp; r-&gt;af != af)
			r = r-&gt;skip[PF_SKIP_AF].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;proto &amp;&amp; r-&gt;proto != pd-&gt;proto)
			r = r-&gt;skip[PF_SKIP_PROTO].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PF_MISMATCHAW(&amp;r-&gt;src.addr, pd-&gt;src, af,
		    r-&gt;src.neg, kif))
			r = r-&gt;skip[PF_SKIP_SRC_ADDR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;src.xport.range.op &amp;&amp;
		    !pf_match_xport(r-&gt;src.xport.range.op, r-&gt;proto_variant,
		    &amp;r-&gt;src.xport, &amp;sxport))
			r = r-&gt;skip[PF_SKIP_SRC_PORT].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PF_MISMATCHAW(&amp;r-&gt;dst.addr, pd-&gt;dst, af,
		    r-&gt;dst.neg, NULL))
			r = r-&gt;skip[PF_SKIP_DST_ADDR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;dst.xport.range.op &amp;&amp;
		    !pf_match_xport(r-&gt;dst.xport.range.op, r-&gt;proto_variant,
		    &amp;r-&gt;dst.xport, &amp;dxport))
			r = r-&gt;skip[PF_SKIP_DST_PORT].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;os_fingerprint != PF_OSFP_ANY &amp;&amp;
		    !pf_osfp_match(pf_osfp_fingerprint(pd, m, off, th),
		    r-&gt;os_fingerprint))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (r-&gt;anchor == NULL) {
				rm = r;
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> {
				pf_step_into_anchor(&amp;asd, &amp;ruleset,
				    PF_RULESET_SCRUB, &amp;r, NULL, NULL);
			}
		}
		<span class="enscript-keyword">if</span> (r == NULL &amp;&amp; pf_step_out_of_anchor(&amp;asd, &amp;ruleset,
		    PF_RULESET_SCRUB, &amp;r, NULL, NULL))
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (rm == NULL || rm-&gt;action == PF_NOSCRUB)
		<span class="enscript-keyword">return</span> (PF_PASS);
	<span class="enscript-keyword">else</span> {
		r-&gt;packets[dir == PF_OUT]++;
		r-&gt;bytes[dir == PF_OUT] += pd-&gt;tot_len;
	}

	<span class="enscript-keyword">if</span> (rm-&gt;rule_flag &amp; PFRULE_REASSEMBLE_TCP)
		pd-&gt;flags |= PFDESC_TCP_NORM;

	flags = th-&gt;th_flags;
	<span class="enscript-keyword">if</span> (flags &amp; TH_SYN) {
		<span class="enscript-comment">/* Illegal packet */</span>
		<span class="enscript-keyword">if</span> (flags &amp; TH_RST)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tcp_drop</span>;

		<span class="enscript-keyword">if</span> (flags &amp; TH_FIN)
			flags &amp;= ~TH_FIN;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Illegal packet */</span>
		<span class="enscript-keyword">if</span> (!(flags &amp; (TH_ACK|TH_RST)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tcp_drop</span>;
	}

	<span class="enscript-keyword">if</span> (!(flags &amp; TH_ACK)) {
		<span class="enscript-comment">/* These flags are only valid if ACK is set */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; TH_FIN) || (flags &amp; TH_PUSH) || (flags &amp; TH_URG))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tcp_drop</span>;
	}

	<span class="enscript-comment">/* Check for illegal header length */</span>
	<span class="enscript-keyword">if</span> (th-&gt;th_off &lt; (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr) &gt;&gt; 2))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">tcp_drop</span>;

	<span class="enscript-comment">/* If flags changed, or reserved data set, then adjust */</span>
	<span class="enscript-keyword">if</span> (flags != th-&gt;th_flags || th-&gt;th_x2 != 0) {
		u_int16_t	ov, nv;

		ov = *(u_int16_t *)(&amp;th-&gt;th_ack + 1);
		th-&gt;th_flags = flags;
		th-&gt;th_x2 = 0;
		nv = *(u_int16_t *)(&amp;th-&gt;th_ack + 1);

		th-&gt;th_sum = pf_cksum_fixup(th-&gt;th_sum, ov, nv, 0);
		rewrite = 1;
	}

	<span class="enscript-comment">/* Remove urgent pointer, if TH_URG is not set */</span>
	<span class="enscript-keyword">if</span> (!(flags &amp; TH_URG) &amp;&amp; th-&gt;th_urp) {
		th-&gt;th_sum = pf_cksum_fixup(th-&gt;th_sum, th-&gt;th_urp, 0, 0);
		th-&gt;th_urp = 0;
		rewrite = 1;
	}

	<span class="enscript-comment">/* copy back packet headers if we sanitized */</span>
	<span class="enscript-comment">/* Process options */</span>
	<span class="enscript-keyword">if</span> (r-&gt;max_mss) {
		<span class="enscript-type">int</span> rv = pf_normalize_tcpopt(r, dir, kif, pd, m, th, off,
		    &amp;rewrite);
		<span class="enscript-keyword">if</span> (rv == PF_DROP)
			<span class="enscript-keyword">return</span> rv;
		m = pd-&gt;mp;
	}

	<span class="enscript-keyword">if</span> (rewrite) {
		<span class="enscript-type">struct</span> mbuf *mw = pf_lazy_makewritable(pd, m,
		    off + <span class="enscript-keyword">sizeof</span> (*th));
		<span class="enscript-keyword">if</span> (!mw) {
			REASON_SET(&amp;reason, PFRES_MEMORY);
			<span class="enscript-keyword">if</span> (r-&gt;log)
				PFLOG_PACKET(kif, h, m, AF_INET, dir, reason,
				    r, 0, 0, pd);
			<span class="enscript-keyword">return</span> PF_DROP;
		}

		m_copyback(mw, off, <span class="enscript-keyword">sizeof</span> (*th), th);
	}

	<span class="enscript-keyword">return</span> (PF_PASS);

<span class="enscript-reference">tcp_drop</span>:
	REASON_SET(&amp;reason, PFRES_NORM);
	<span class="enscript-keyword">if</span> (rm != NULL &amp;&amp; r-&gt;log)
		PFLOG_PACKET(kif, h, m, AF_INET, dir, reason, r, NULL, NULL, pd);
	<span class="enscript-keyword">return</span> (PF_DROP);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_normalize_tcp_init</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">struct</span> pf_pdesc *pd,
    <span class="enscript-type">struct</span> tcphdr *th, <span class="enscript-type">struct</span> pf_state_peer *src, <span class="enscript-type">struct</span> pf_state_peer *dst)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dst</span>)
	u_int32_t tsval, tsecr;
	u_int8_t hdr[60];
	u_int8_t *opt;

	VERIFY(src-&gt;scrub == NULL);

	src-&gt;scrub = pool_get(&amp;pf_state_scrub_pl, PR_NOWAIT);
	<span class="enscript-keyword">if</span> (src-&gt;scrub == NULL)
		<span class="enscript-keyword">return</span> (1);
	bzero(src-&gt;scrub, <span class="enscript-keyword">sizeof</span> (*src-&gt;scrub));

	<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
		<span class="enscript-type">struct</span> ip *h = mtod(m, <span class="enscript-type">struct</span> ip *);
		src-&gt;scrub-&gt;pfss_ttl = h-&gt;ip_ttl;
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
		<span class="enscript-type">struct</span> ip6_hdr *h = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		src-&gt;scrub-&gt;pfss_ttl = h-&gt;ip6_hlim;
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}


	<span class="enscript-comment">/*
	 * All normalizations below are only begun if we see the start of
	 * the connections.  They must all set an enabled bit in pfss_flags
	 */</span>
	<span class="enscript-keyword">if</span> ((th-&gt;th_flags &amp; TH_SYN) == 0)
		<span class="enscript-keyword">return</span> (0);


	<span class="enscript-keyword">if</span> (th-&gt;th_off &gt; (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr) &gt;&gt; 2) &amp;&amp; src-&gt;scrub &amp;&amp;
	    pf_pull_hdr(m, off, hdr, th-&gt;th_off &lt;&lt; 2, NULL, NULL, pd-&gt;af)) {
		<span class="enscript-comment">/* Diddle with TCP options */</span>
		<span class="enscript-type">int</span> hlen;
		opt = hdr + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
		hlen = (th-&gt;th_off &lt;&lt; 2) - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
		<span class="enscript-keyword">while</span> (hlen &gt;= TCPOLEN_TIMESTAMP) {
			<span class="enscript-keyword">switch</span> (*opt) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_EOL</span>:	<span class="enscript-comment">/* FALLTHROUGH */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_NOP</span>:
				opt++;
				hlen--;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_TIMESTAMP</span>:
				<span class="enscript-keyword">if</span> (opt[1] &gt;= TCPOLEN_TIMESTAMP) {
					src-&gt;scrub-&gt;pfss_flags |=
					    PFSS_TIMESTAMP;
					src-&gt;scrub-&gt;pfss_ts_mod =
					    htonl(random());

					<span class="enscript-comment">/* note PFSS_PAWS not set yet */</span>
					memcpy(&amp;tsval, &amp;opt[2],
					    <span class="enscript-keyword">sizeof</span> (u_int32_t));
					memcpy(&amp;tsecr, &amp;opt[6],
					    <span class="enscript-keyword">sizeof</span> (u_int32_t));
					src-&gt;scrub-&gt;pfss_tsval0 = ntohl(tsval);
					src-&gt;scrub-&gt;pfss_tsval = ntohl(tsval);
					src-&gt;scrub-&gt;pfss_tsecr = ntohl(tsecr);
					getmicrouptime(&amp;src-&gt;scrub-&gt;pfss_last);
				}
				<span class="enscript-comment">/* FALLTHROUGH */</span>
			<span class="enscript-reference">default</span>:
				hlen -= MAX(opt[1], 2);
				opt += MAX(opt[1], 2);
				<span class="enscript-keyword">break</span>;
			}
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_normalize_tcp_cleanup</span>(<span class="enscript-type">struct</span> pf_state *state)
{
	<span class="enscript-keyword">if</span> (state-&gt;src.scrub)
		pool_put(&amp;pf_state_scrub_pl, state-&gt;src.scrub);
	<span class="enscript-keyword">if</span> (state-&gt;dst.scrub)
		pool_put(&amp;pf_state_scrub_pl, state-&gt;dst.scrub);

	<span class="enscript-comment">/* Someday... flush the TCP segment reassembly descriptors. */</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_normalize_tcp_stateful</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">struct</span> pf_pdesc *pd,
    u_short *reason, <span class="enscript-type">struct</span> tcphdr *th, <span class="enscript-type">struct</span> pf_state *state,
    <span class="enscript-type">struct</span> pf_state_peer *src, <span class="enscript-type">struct</span> pf_state_peer *dst, <span class="enscript-type">int</span> *writeback)
{
	<span class="enscript-type">struct</span> timeval uptime;
	u_int32_t tsval, tsecr;
	u_int tsval_from_last;
	u_int8_t hdr[60];
	u_int8_t *opt;
	<span class="enscript-type">int</span> copyback = 0;
	<span class="enscript-type">int</span> got_ts = 0;

	VERIFY(src-&gt;scrub || dst-&gt;scrub);

	<span class="enscript-comment">/*
	 * Enforce the minimum TTL seen for this connection.  Negate a common
	 * technique to evade an intrusion detection system and confuse
	 * firewall state code.
	 */</span>
	<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
		<span class="enscript-keyword">if</span> (src-&gt;scrub) {
			<span class="enscript-type">struct</span> ip *h = mtod(m, <span class="enscript-type">struct</span> ip *);
			<span class="enscript-keyword">if</span> (h-&gt;ip_ttl &gt; src-&gt;scrub-&gt;pfss_ttl)
				src-&gt;scrub-&gt;pfss_ttl = h-&gt;ip_ttl;
			h-&gt;ip_ttl = src-&gt;scrub-&gt;pfss_ttl;
		}
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
		<span class="enscript-keyword">if</span> (src-&gt;scrub) {
			<span class="enscript-type">struct</span> ip6_hdr *h = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
			<span class="enscript-keyword">if</span> (h-&gt;ip6_hlim &gt; src-&gt;scrub-&gt;pfss_ttl)
				src-&gt;scrub-&gt;pfss_ttl = h-&gt;ip6_hlim;
			h-&gt;ip6_hlim = src-&gt;scrub-&gt;pfss_ttl;
		}
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}

	<span class="enscript-keyword">if</span> (th-&gt;th_off &gt; (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr) &gt;&gt; 2) &amp;&amp;
	    ((src-&gt;scrub &amp;&amp; (src-&gt;scrub-&gt;pfss_flags &amp; PFSS_TIMESTAMP)) ||
	    (dst-&gt;scrub &amp;&amp; (dst-&gt;scrub-&gt;pfss_flags &amp; PFSS_TIMESTAMP))) &amp;&amp;
	    pf_pull_hdr(m, off, hdr, th-&gt;th_off &lt;&lt; 2, NULL, NULL, pd-&gt;af)) {
		<span class="enscript-comment">/* Diddle with TCP options */</span>
		<span class="enscript-type">int</span> hlen;
		opt = hdr + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
		hlen = (th-&gt;th_off &lt;&lt; 2) - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
		<span class="enscript-keyword">while</span> (hlen &gt;= TCPOLEN_TIMESTAMP) {
			<span class="enscript-keyword">switch</span> (*opt) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_EOL</span>:	<span class="enscript-comment">/* FALLTHROUGH */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_NOP</span>:
				opt++;
				hlen--;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_TIMESTAMP</span>:
				<span class="enscript-comment">/*
				 * Modulate the timestamps.  Can be used for
				 * NAT detection, OS uptime determination or
				 * reboot detection.
				 */</span>

				<span class="enscript-keyword">if</span> (got_ts) {
					<span class="enscript-comment">/* Huh?  Multiple timestamps!? */</span>
					<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
						DPFPRINTF((<span class="enscript-string">&quot;multiple TS??&quot;</span>));
						pf_print_state(state);
						printf(<span class="enscript-string">&quot;\n&quot;</span>);
					}
					REASON_SET(reason, PFRES_TS);
					<span class="enscript-keyword">return</span> (PF_DROP);
				}
				<span class="enscript-keyword">if</span> (opt[1] &gt;= TCPOLEN_TIMESTAMP) {
					memcpy(&amp;tsval, &amp;opt[2],
					    <span class="enscript-keyword">sizeof</span> (u_int32_t));
					<span class="enscript-keyword">if</span> (tsval &amp;&amp; src-&gt;scrub &amp;&amp;
					    (src-&gt;scrub-&gt;pfss_flags &amp;
					    PFSS_TIMESTAMP)) {
						tsval = ntohl(tsval);
						pf_change_a(&amp;opt[2],
						    &amp;th-&gt;th_sum,
						    htonl(tsval +
						    src-&gt;scrub-&gt;pfss_ts_mod),
						    0);
						copyback = 1;
					}

					<span class="enscript-comment">/* Modulate TS reply iff valid (!0) */</span>
					memcpy(&amp;tsecr, &amp;opt[6],
					    <span class="enscript-keyword">sizeof</span> (u_int32_t));
					<span class="enscript-keyword">if</span> (tsecr &amp;&amp; dst-&gt;scrub &amp;&amp;
					    (dst-&gt;scrub-&gt;pfss_flags &amp;
					    PFSS_TIMESTAMP)) {
						tsecr = ntohl(tsecr)
						    - dst-&gt;scrub-&gt;pfss_ts_mod;
						pf_change_a(&amp;opt[6],
						    &amp;th-&gt;th_sum, htonl(tsecr),
						    0);
						copyback = 1;
					}
					got_ts = 1;
				}
				<span class="enscript-comment">/* FALLTHROUGH */</span>
			<span class="enscript-reference">default</span>:
				hlen -= MAX(opt[1], 2);
				opt += MAX(opt[1], 2);
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (copyback) {
			<span class="enscript-comment">/* Copyback the options, caller copys back header */</span>
			<span class="enscript-type">int</span> optoff = off + <span class="enscript-keyword">sizeof</span> (*th);
			<span class="enscript-type">int</span> optlen = (th-&gt;th_off &lt;&lt; 2) - <span class="enscript-keyword">sizeof</span> (*th);
			m = pf_lazy_makewritable(pd, m, optoff + optlen);
			<span class="enscript-keyword">if</span> (!m) {
				REASON_SET(reason, PFRES_MEMORY);
				<span class="enscript-keyword">return</span> PF_DROP;
			}
			*writeback = optoff + optlen;
			m_copyback(m, optoff, optlen, hdr + <span class="enscript-keyword">sizeof</span> (*th));
		}
	}


	<span class="enscript-comment">/*
	 * Must invalidate PAWS checks on connections idle for too long.
	 * The fastest allowed timestamp clock is 1ms.  That turns out to
	 * be about 24 days before it wraps.  XXX Right now our lowerbound
	 * TS echo check only works for the first 12 days of a connection
	 * when the TS has exhausted half its 32bit space
	 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TS_MAX_IDLE</span>	(24*24*60*60)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TS_MAX_CONN</span>	(12*24*60*60)	<span class="enscript-comment">/* XXX remove when better tsecr check */</span>

	getmicrouptime(&amp;uptime);
	<span class="enscript-keyword">if</span> (src-&gt;scrub &amp;&amp; (src-&gt;scrub-&gt;pfss_flags &amp; PFSS_PAWS) &amp;&amp;
	    (uptime.tv_sec - src-&gt;scrub-&gt;pfss_last.tv_sec &gt; TS_MAX_IDLE ||
	    pf_time_second() - state-&gt;creation &gt; TS_MAX_CONN))  {
		<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
			DPFPRINTF((<span class="enscript-string">&quot;src idled out of PAWS\n&quot;</span>));
			pf_print_state(state);
			printf(<span class="enscript-string">&quot;\n&quot;</span>);
		}
		src-&gt;scrub-&gt;pfss_flags = (src-&gt;scrub-&gt;pfss_flags &amp; ~PFSS_PAWS)
		    | PFSS_PAWS_IDLED;
	}
	<span class="enscript-keyword">if</span> (dst-&gt;scrub &amp;&amp; (dst-&gt;scrub-&gt;pfss_flags &amp; PFSS_PAWS) &amp;&amp;
	    uptime.tv_sec - dst-&gt;scrub-&gt;pfss_last.tv_sec &gt; TS_MAX_IDLE) {
		<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
			DPFPRINTF((<span class="enscript-string">&quot;dst idled out of PAWS\n&quot;</span>));
			pf_print_state(state);
			printf(<span class="enscript-string">&quot;\n&quot;</span>);
		}
		dst-&gt;scrub-&gt;pfss_flags = (dst-&gt;scrub-&gt;pfss_flags &amp; ~PFSS_PAWS)
		    | PFSS_PAWS_IDLED;
	}

	<span class="enscript-keyword">if</span> (got_ts &amp;&amp; src-&gt;scrub &amp;&amp; dst-&gt;scrub &amp;&amp;
	    (src-&gt;scrub-&gt;pfss_flags &amp; PFSS_PAWS) &amp;&amp;
	    (dst-&gt;scrub-&gt;pfss_flags &amp; PFSS_PAWS)) {
		<span class="enscript-comment">/*
		 * Validate that the timestamps are &quot;in-window&quot;.
		 * RFC1323 describes TCP Timestamp options that allow
		 * measurement of RTT (round trip time) and PAWS
		 * (protection against wrapped sequence numbers).  PAWS
		 * gives us a set of rules for rejecting packets on
		 * long fat pipes (packets that were somehow delayed
		 * in transit longer than the time it took to send the
		 * full TCP sequence space of 4Gb).  We can use these
		 * rules and infer a few others that will let us treat
		 * the 32bit timestamp and the 32bit echoed timestamp
		 * as sequence numbers to prevent a blind attacker from
		 * inserting packets into a connection.
		 *
		 * RFC1323 tells us:
		 *  - The timestamp on this packet must be greater than
		 *    or equal to the last value echoed by the other
		 *    endpoint.  The RFC says those will be discarded
		 *    since it is a dup that has already been acked.
		 *    This gives us a lowerbound on the timestamp.
		 *        timestamp &gt;= other last echoed timestamp
		 *  - The timestamp will be less than or equal to
		 *    the last timestamp plus the time between the
		 *    last packet and now.  The RFC defines the max
		 *    clock rate as 1ms.  We will allow clocks to be
		 *    up to 10% fast and will allow a total difference
		 *    or 30 seconds due to a route change.  And this
		 *    gives us an upperbound on the timestamp.
		 *        timestamp &lt;= last timestamp + max ticks
		 *    We have to be careful here.  Windows will send an
		 *    initial timestamp of zero and then initialize it
		 *    to a random value after the 3whs; presumably to
		 *    avoid a DoS by having to call an expensive RNG
		 *    during a SYN flood.  Proof MS has at least one
		 *    good security geek.
		 *
		 *  - The TCP timestamp option must also echo the other
		 *    endpoints timestamp.  The timestamp echoed is the
		 *    one carried on the earliest unacknowledged segment
		 *    on the left edge of the sequence window.  The RFC
		 *    states that the host will reject any echoed
		 *    timestamps that were larger than any ever sent.
		 *    This gives us an upperbound on the TS echo.
		 *        tescr &lt;= largest_tsval
		 *  - The lowerbound on the TS echo is a little more
		 *    tricky to determine.  The other endpoint's echoed
		 *    values will not decrease.  But there may be
		 *    network conditions that re-order packets and
		 *    cause our view of them to decrease.  For now the
		 *    only lowerbound we can safely determine is that
		 *    the TS echo will never be less than the original
		 *    TS.  XXX There is probably a better lowerbound.
		 *    Remove TS_MAX_CONN with better lowerbound check.
		 *        tescr &gt;= other original TS
		 *
		 * It is also important to note that the fastest
		 * timestamp clock of 1ms will wrap its 32bit space in
		 * 24 days.  So we just disable TS checking after 24
		 * days of idle time.  We actually must use a 12d
		 * connection limit until we can come up with a better
		 * lowerbound to the TS echo check.
		 */</span>
		<span class="enscript-type">struct</span> timeval delta_ts;
		<span class="enscript-type">int</span> ts_fudge;


		<span class="enscript-comment">/*
		 * PFTM_TS_DIFF is how many seconds of leeway to allow
		 * a host's timestamp.  This can happen if the previous
		 * packet got delayed in transit for much longer than
		 * this packet.
		 */</span>
		<span class="enscript-keyword">if</span> ((ts_fudge = state-&gt;rule.ptr-&gt;timeout[PFTM_TS_DIFF]) == 0)
			ts_fudge = pf_default_rule.timeout[PFTM_TS_DIFF];


		<span class="enscript-comment">/* Calculate max ticks since the last timestamp */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TS_MAXFREQ</span>	1100		<span class="enscript-comment">/* RFC max TS freq of 1Khz + 10% skew */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TS_MICROSECS</span>	1000000		<span class="enscript-comment">/* microseconds per second */</span>
		timersub(&amp;uptime, &amp;src-&gt;scrub-&gt;pfss_last, &amp;delta_ts);
		tsval_from_last = (delta_ts.tv_sec + ts_fudge) * TS_MAXFREQ;
		tsval_from_last += delta_ts.tv_usec / (TS_MICROSECS/TS_MAXFREQ);


		<span class="enscript-keyword">if</span> ((src-&gt;state &gt;= TCPS_ESTABLISHED &amp;&amp;
		    dst-&gt;state &gt;= TCPS_ESTABLISHED) &amp;&amp;
		    (SEQ_LT(tsval, dst-&gt;scrub-&gt;pfss_tsecr) ||
		    SEQ_GT(tsval, src-&gt;scrub-&gt;pfss_tsval + tsval_from_last) ||
		    (tsecr &amp;&amp; (SEQ_GT(tsecr, dst-&gt;scrub-&gt;pfss_tsval) ||
		    SEQ_LT(tsecr, dst-&gt;scrub-&gt;pfss_tsval0))))) {
			<span class="enscript-comment">/*
			 * Bad RFC1323 implementation or an insertion attack.
			 *
			 * - Solaris 2.6 and 2.7 are known to send another ACK
			 *   after the FIN,FIN|ACK,ACK closing that carries
			 *   an old timestamp.
			 */</span>

			DPFPRINTF((<span class="enscript-string">&quot;Timestamp failed %c%c%c%c\n&quot;</span>,
			    SEQ_LT(tsval, dst-&gt;scrub-&gt;pfss_tsecr) ? <span class="enscript-string">'0'</span> : <span class="enscript-string">' '</span>,
			    SEQ_GT(tsval, src-&gt;scrub-&gt;pfss_tsval +
			    tsval_from_last) ? <span class="enscript-string">'1'</span> : <span class="enscript-string">' '</span>,
			    SEQ_GT(tsecr, dst-&gt;scrub-&gt;pfss_tsval) ? <span class="enscript-string">'2'</span> : <span class="enscript-string">' '</span>,
			    SEQ_LT(tsecr, dst-&gt;scrub-&gt;pfss_tsval0)? <span class="enscript-string">'3'</span> : <span class="enscript-string">' '</span>));
			DPFPRINTF((<span class="enscript-string">&quot; tsval: %u  tsecr: %u  +ticks: %u  &quot;</span>
			    <span class="enscript-string">&quot;idle: %lus %ums\n&quot;</span>,
			    tsval, tsecr, tsval_from_last, delta_ts.tv_sec,
			    delta_ts.tv_usec / 1000));
			DPFPRINTF((<span class="enscript-string">&quot; src-&gt;tsval: %u  tsecr: %u\n&quot;</span>,
			    src-&gt;scrub-&gt;pfss_tsval, src-&gt;scrub-&gt;pfss_tsecr));
			DPFPRINTF((<span class="enscript-string">&quot; dst-&gt;tsval: %u  tsecr: %u  tsval0: %u\n&quot;</span>,
			    dst-&gt;scrub-&gt;pfss_tsval, dst-&gt;scrub-&gt;pfss_tsecr,
			    dst-&gt;scrub-&gt;pfss_tsval0));
			<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
				pf_print_state(state);
				pf_print_flags(th-&gt;th_flags);
				printf(<span class="enscript-string">&quot;\n&quot;</span>);
			}
			REASON_SET(reason, PFRES_TS);
			<span class="enscript-keyword">return</span> (PF_DROP);
		}

		<span class="enscript-comment">/* XXX I'd really like to require tsecr but it's optional */</span>

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!got_ts &amp;&amp; (th-&gt;th_flags &amp; TH_RST) == 0 &amp;&amp;
	    ((src-&gt;state == TCPS_ESTABLISHED &amp;&amp; dst-&gt;state == TCPS_ESTABLISHED)
	    || pd-&gt;p_len &gt; 0 || (th-&gt;th_flags &amp; TH_SYN)) &amp;&amp;
	    src-&gt;scrub &amp;&amp; dst-&gt;scrub &amp;&amp;
	    (src-&gt;scrub-&gt;pfss_flags &amp; PFSS_PAWS) &amp;&amp;
	    (dst-&gt;scrub-&gt;pfss_flags &amp; PFSS_PAWS)) {
		<span class="enscript-comment">/*
		 * Didn't send a timestamp.  Timestamps aren't really useful
		 * when:
		 *  - connection opening or closing (often not even sent).
		 *    but we must not let an attacker to put a FIN on a
		 *    data packet to sneak it through our ESTABLISHED check.
		 *  - on a TCP reset.  RFC suggests not even looking at TS.
		 *  - on an empty ACK.  The TS will not be echoed so it will
		 *    probably not help keep the RTT calculation in sync and
		 *    there isn't as much danger when the sequence numbers
		 *    got wrapped.  So some stacks don't include TS on empty
		 *    ACKs :-(
		 *
		 * To minimize the disruption to mostly RFC1323 conformant
		 * stacks, we will only require timestamps on data packets.
		 *
		 * And what do ya know, we cannot require timestamps on data
		 * packets.  There appear to be devices that do legitimate
		 * TCP connection hijacking.  There are HTTP devices that allow
		 * a 3whs (with timestamps) and then buffer the HTTP request.
		 * If the intermediate device has the HTTP response cache, it
		 * will spoof the response but not bother timestamping its
		 * packets.  So we can look for the presence of a timestamp in
		 * the first data packet and if there, require it in all future
		 * packets.
		 */</span>

		<span class="enscript-keyword">if</span> (pd-&gt;p_len &gt; 0 &amp;&amp; (src-&gt;scrub-&gt;pfss_flags &amp; PFSS_DATA_TS)) {
			<span class="enscript-comment">/*
			 * Hey!  Someone tried to sneak a packet in.  Or the
			 * stack changed its RFC1323 behavior?!?!
			 */</span>
			<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
				DPFPRINTF((<span class="enscript-string">&quot;Did not receive expected RFC1323 &quot;</span>
				    <span class="enscript-string">&quot;timestamp\n&quot;</span>));
				pf_print_state(state);
				pf_print_flags(th-&gt;th_flags);
				printf(<span class="enscript-string">&quot;\n&quot;</span>);
			}
			REASON_SET(reason, PFRES_TS);
			<span class="enscript-keyword">return</span> (PF_DROP);
		}
	}


	<span class="enscript-comment">/*
	 * We will note if a host sends his data packets with or without
	 * timestamps.  And require all data packets to contain a timestamp
	 * if the first does.  PAWS implicitly requires that all data packets be
	 * timestamped.  But I think there are middle-man devices that hijack
	 * TCP streams immediately after the 3whs and don't timestamp their
	 * packets (seen in a WWW accelerator or cache).
	 */</span>
	<span class="enscript-keyword">if</span> (pd-&gt;p_len &gt; 0 &amp;&amp; src-&gt;scrub &amp;&amp; (src-&gt;scrub-&gt;pfss_flags &amp;
	    (PFSS_TIMESTAMP|PFSS_DATA_TS|PFSS_DATA_NOTS)) == PFSS_TIMESTAMP) {
		<span class="enscript-keyword">if</span> (got_ts)
			src-&gt;scrub-&gt;pfss_flags |= PFSS_DATA_TS;
		<span class="enscript-keyword">else</span> {
			src-&gt;scrub-&gt;pfss_flags |= PFSS_DATA_NOTS;
			<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC &amp;&amp; dst-&gt;scrub &amp;&amp;
			    (dst-&gt;scrub-&gt;pfss_flags &amp; PFSS_TIMESTAMP)) {
				<span class="enscript-comment">/* Don't warn if other host rejected RFC1323 */</span>
				DPFPRINTF((<span class="enscript-string">&quot;Broken RFC1323 stack did not &quot;</span>
				    <span class="enscript-string">&quot;timestamp data packet. Disabled PAWS &quot;</span>
				    <span class="enscript-string">&quot;security.\n&quot;</span>));
				pf_print_state(state);
				pf_print_flags(th-&gt;th_flags);
				printf(<span class="enscript-string">&quot;\n&quot;</span>);
			}
		}
	}


	<span class="enscript-comment">/*
	 * Update PAWS values
	 */</span>
	<span class="enscript-keyword">if</span> (got_ts &amp;&amp; src-&gt;scrub &amp;&amp; PFSS_TIMESTAMP == (src-&gt;scrub-&gt;pfss_flags &amp;
	    (PFSS_PAWS_IDLED|PFSS_TIMESTAMP))) {
		getmicrouptime(&amp;src-&gt;scrub-&gt;pfss_last);
		<span class="enscript-keyword">if</span> (SEQ_GEQ(tsval, src-&gt;scrub-&gt;pfss_tsval) ||
		    (src-&gt;scrub-&gt;pfss_flags &amp; PFSS_PAWS) == 0)
			src-&gt;scrub-&gt;pfss_tsval = tsval;

		<span class="enscript-keyword">if</span> (tsecr) {
			<span class="enscript-keyword">if</span> (SEQ_GEQ(tsecr, src-&gt;scrub-&gt;pfss_tsecr) ||
			    (src-&gt;scrub-&gt;pfss_flags &amp; PFSS_PAWS) == 0)
				src-&gt;scrub-&gt;pfss_tsecr = tsecr;

			<span class="enscript-keyword">if</span> ((src-&gt;scrub-&gt;pfss_flags &amp; PFSS_PAWS) == 0 &amp;&amp;
			    (SEQ_LT(tsval, src-&gt;scrub-&gt;pfss_tsval0) ||
			    src-&gt;scrub-&gt;pfss_tsval0 == 0)) {
				<span class="enscript-comment">/* tsval0 MUST be the lowest timestamp */</span>
				src-&gt;scrub-&gt;pfss_tsval0 = tsval;
			}

			<span class="enscript-comment">/* Only fully initialized after a TS gets echoed */</span>
			<span class="enscript-keyword">if</span> ((src-&gt;scrub-&gt;pfss_flags &amp; PFSS_PAWS) == 0)
				src-&gt;scrub-&gt;pfss_flags |= PFSS_PAWS;
		}
	}

	<span class="enscript-comment">/* I have a dream....  TCP segment reassembly.... */</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_normalize_tcpopt</span>(<span class="enscript-type">struct</span> pf_rule *r, <span class="enscript-type">int</span> dir, <span class="enscript-type">struct</span> pfi_kif *kif,
    <span class="enscript-type">struct</span> pf_pdesc *pd, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> tcphdr *th, <span class="enscript-type">int</span> off,
    <span class="enscript-type">int</span> *rewrptr)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dir</span>, <span class="enscript-variable-name">kif</span>)
	sa_family_t af = pd-&gt;af;
	u_int16_t	*mss;
	<span class="enscript-type">int</span>		thoff;
	<span class="enscript-type">int</span>		opt, cnt, optlen = 0;
	<span class="enscript-type">int</span>		rewrite = 0;
	u_char		opts[MAX_TCPOPTLEN];
	u_char		*optp = opts;

	thoff = th-&gt;th_off &lt;&lt; 2;
	cnt = thoff - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);

	<span class="enscript-keyword">if</span> (cnt &gt; 0 &amp;&amp; !pf_pull_hdr(m, off + <span class="enscript-keyword">sizeof</span> (*th), opts, cnt,
	    NULL, NULL, af))
		<span class="enscript-keyword">return</span> PF_DROP;

	<span class="enscript-keyword">for</span> (; cnt &gt; 0; cnt -= optlen, optp += optlen) {
		opt = optp[0];
		<span class="enscript-keyword">if</span> (opt == TCPOPT_EOL)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (opt == TCPOPT_NOP)
			optlen = 1;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (cnt &lt; 2)
				<span class="enscript-keyword">break</span>;
			optlen = optp[1];
			<span class="enscript-keyword">if</span> (optlen &lt; 2 || optlen &gt; cnt)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">switch</span> (opt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_MAXSEG</span>:
			mss = (u_int16_t *)(<span class="enscript-type">void</span> *)(optp + 2);
			<span class="enscript-keyword">if</span> ((ntohs(*mss)) &gt; r-&gt;max_mss) {
				<span class="enscript-comment">/*
				 * &lt;<a href="mailto:jhw@apple.com">jhw@apple.com</a>&gt;
				 *  Only do the TCP checksum fixup if delayed
				 * checksum calculation will not be performed.
				 */</span>
				<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.rcvif ||
				    !(m-&gt;m_pkthdr.csum_flags &amp; CSUM_TCP))
					th-&gt;th_sum = pf_cksum_fixup(th-&gt;th_sum,
					    *mss, htons(r-&gt;max_mss), 0);
				*mss = htons(r-&gt;max_mss);
				rewrite = 1;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (rewrite) {
		<span class="enscript-type">struct</span> mbuf *mw;
		u_short reason;

		mw = pf_lazy_makewritable(pd, pd-&gt;mp,
		    off + <span class="enscript-keyword">sizeof</span> (*th) + thoff);
		<span class="enscript-keyword">if</span> (!mw) {
			REASON_SET(&amp;reason, PFRES_MEMORY);
			<span class="enscript-keyword">if</span> (r-&gt;log)
				PFLOG_PACKET(kif, h, m, AF_INET, dir, reason,
				    r, 0, 0, pd);
			<span class="enscript-keyword">return</span> PF_DROP;
		}

		*rewrptr = 1;
		m_copyback(mw, off + <span class="enscript-keyword">sizeof</span> (*th), thoff - <span class="enscript-keyword">sizeof</span> (*th), opts);
	}

	<span class="enscript-keyword">return</span> PF_PASS;
}
</pre>
<hr />
</body></html>