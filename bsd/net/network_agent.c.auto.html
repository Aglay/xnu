<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>network_agent.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">network_agent.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSMalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_control.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/network_agent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>

u_int32_t netagent_debug = LOG_NOTICE; <span class="enscript-comment">// 0=None, 1=Basic
</span>
<span class="enscript-function-name">SYSCTL_NODE</span>(_net, OID_AUTO, netagent, CTLFLAG_RW | CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;NetworkAgent&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_netagent, OID_AUTO, debug, CTLFLAG_LOCKED | CTLFLAG_RW, &amp;netagent_debug, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> netagent_registered_count = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_netagent, OID_AUTO, registered_count , CTLFLAG_RD | CTLFLAG_LOCKED,
		   &amp;netagent_registered_count, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> netagent_active_count = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_netagent, OID_AUTO, active_count , CTLFLAG_RD | CTLFLAG_LOCKED,
		   &amp;netagent_active_count, 0, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NETAGENTLOG</span>(level, format, ...) do {											\
	<span class="enscript-keyword">if</span> (level &lt;= netagent_debug)					\
		log((level &gt; LOG_NOTICE ? LOG_NOTICE : level), <span class="enscript-string">&quot;%s: &quot;</span> format <span class="enscript-string">&quot;\n&quot;</span>, __FUNCTION__, __VA_ARGS__);	\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NETAGENTLOG0</span>(level, msg) do {											\
	<span class="enscript-keyword">if</span> (level &lt;= netagent_debug)					\
		log((level &gt; LOG_NOTICE ? LOG_NOTICE : level), <span class="enscript-string">&quot;%s: %s\n&quot;</span>, __FUNCTION__, msg);	\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">struct</span> netagent_assertion {
	LIST_ENTRY(netagent_assertion) assertion_chain;
	uuid_t asserted_uuid;
};

<span class="enscript-type">struct</span> netagent_wrapper {
	LIST_ENTRY(netagent_wrapper) master_chain;
	u_int32_t control_unit;
	<span class="enscript-type">struct</span> netagent netagent;
};

<span class="enscript-type">struct</span> netagent_session {
	u_int32_t control_unit;
	<span class="enscript-type">struct</span> netagent_wrapper *wrapper;
	LIST_HEAD(_netagent_assertion_list, netagent_assertion) assertion_list;
};

<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(_netagent_list, netagent_wrapper) master_netagent_list;

<span class="enscript-type">static</span> kern_ctl_ref	netagent_kctlref;
<span class="enscript-type">static</span> u_int32_t	netagent_family;
<span class="enscript-type">static</span> OSMallocTag	netagent_malloc_tag;
<span class="enscript-type">static</span>	lck_grp_attr_t	*netagent_grp_attr	= NULL;
<span class="enscript-type">static</span>	lck_attr_t		*netagent_mtx_attr	= NULL;
<span class="enscript-type">static</span>	lck_grp_t		*netagent_mtx_grp		= NULL;
<span class="enscript-function-name">decl_lck_rw_data</span>(<span class="enscript-type">static</span>, netagent_lock);

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">netagent_register_control</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">netagent_ctl_connect</span>(kern_ctl_ref kctlref, <span class="enscript-type">struct</span> sockaddr_ctl *sac,
									<span class="enscript-type">void</span> **unitinfo);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">netagent_ctl_disconnect</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">netagent_ctl_send</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo,
								 mbuf_t m, <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">netagent_ctl_rcvd</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">netagent_ctl_getopt</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo,
								   <span class="enscript-type">int</span> opt, <span class="enscript-type">void</span> *data, size_t *len);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">netagent_ctl_setopt</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo,
								   <span class="enscript-type">int</span> opt, <span class="enscript-type">void</span> *data, size_t len);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">netagent_send_ctl_data</span>(u_int32_t control_unit, u_int8_t *buffer, size_t buffer_size);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> netagent_session *<span class="enscript-function-name">netagent_create_session</span>(u_int32_t control_unit);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">netagent_delete_session</span>(<span class="enscript-type">struct</span> netagent_session *session);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">netagent_handle_register</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int32_t message_id,
									 u_int32_t payload_length, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">netagent_handle_unregister</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int32_t message_id,
									   u_int32_t payload_length, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">netagent_handle_update</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int32_t message_id,
								   u_int32_t payload_length, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">netagent_handle_get</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int32_t message_id,
								u_int32_t payload_length, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">netagent_handle_assert</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int32_t message_id,
								   u_int32_t payload_length, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">netagent_handle_unassert</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int32_t message_id,
									 u_int32_t payload_length, mbuf_t packet, <span class="enscript-type">int</span> offset);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> netagent_wrapper *<span class="enscript-function-name">netagent_find_agent_with_uuid</span>(uuid_t uuid);

errno_t
<span class="enscript-function-name">netagent_init</span>(<span class="enscript-type">void</span>)
{
	errno_t result = 0;

	result = netagent_register_control();
	<span class="enscript-keyword">if</span> (result != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	netagent_grp_attr = lck_grp_attr_alloc_init();
	<span class="enscript-keyword">if</span> (netagent_grp_attr == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;lck_grp_attr_alloc_init failed&quot;</span>);
		result = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	netagent_mtx_grp = lck_grp_alloc_init(NETAGENT_CONTROL_NAME, netagent_grp_attr);
	<span class="enscript-keyword">if</span> (netagent_mtx_grp == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;lck_grp_alloc_init failed&quot;</span>);
		result = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	netagent_mtx_attr = lck_attr_alloc_init();
	<span class="enscript-keyword">if</span> (netagent_mtx_attr == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;lck_attr_alloc_init failed&quot;</span>);
		result = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	lck_rw_init(&amp;netagent_lock, netagent_mtx_grp, netagent_mtx_attr);

	LIST_INIT(&amp;master_netagent_list);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (result != 0) {
		<span class="enscript-keyword">if</span> (netagent_mtx_attr != NULL) {
			lck_attr_free(netagent_mtx_attr);
			netagent_mtx_attr = NULL;
		}
		<span class="enscript-keyword">if</span> (netagent_mtx_grp != NULL) {
			lck_grp_free(netagent_mtx_grp);
			netagent_mtx_grp = NULL;
		}
		<span class="enscript-keyword">if</span> (netagent_grp_attr != NULL) {
			lck_grp_attr_free(netagent_grp_attr);
			netagent_grp_attr = NULL;
		}
		<span class="enscript-keyword">if</span> (netagent_kctlref != NULL) {
			ctl_deregister(netagent_kctlref);
			netagent_kctlref = NULL;
		}
	}
	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">netagent_register_control</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> kern_ctl_reg	kern_ctl;
	errno_t				result = 0;

	<span class="enscript-comment">// Create a tag to allocate memory
</span>	netagent_malloc_tag = OSMalloc_Tagalloc(NETAGENT_CONTROL_NAME, OSMT_DEFAULT);

	<span class="enscript-comment">// Find a unique value for our interface family
</span>	result = mbuf_tag_id_find(NETAGENT_CONTROL_NAME, &amp;netagent_family);
	<span class="enscript-keyword">if</span> (result != 0) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;mbuf_tag_id_find_internal failed: %d&quot;</span>, result);
		<span class="enscript-keyword">return</span> (result);
	}

	bzero(&amp;kern_ctl, <span class="enscript-keyword">sizeof</span>(kern_ctl));
	strlcpy(kern_ctl.ctl_name, NETAGENT_CONTROL_NAME, <span class="enscript-keyword">sizeof</span>(kern_ctl.ctl_name));
	kern_ctl.ctl_name[<span class="enscript-keyword">sizeof</span>(kern_ctl.ctl_name) - 1] = 0;
	kern_ctl.ctl_flags = CTL_FLAG_PRIVILEGED; <span class="enscript-comment">// Require root
</span>	kern_ctl.ctl_sendsize = 64 * 1024;
	kern_ctl.ctl_recvsize = 64 * 1024;
	kern_ctl.ctl_connect = netagent_ctl_connect;
	kern_ctl.ctl_disconnect = netagent_ctl_disconnect;
	kern_ctl.ctl_send = netagent_ctl_send;
	kern_ctl.ctl_rcvd = netagent_ctl_rcvd;
	kern_ctl.ctl_setopt = netagent_ctl_setopt;
	kern_ctl.ctl_getopt = netagent_ctl_getopt;

	result = ctl_register(&amp;kern_ctl, &amp;netagent_kctlref);
	<span class="enscript-keyword">if</span> (result != 0) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;ctl_register failed: %d&quot;</span>, result);
		<span class="enscript-keyword">return</span> (result);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">netagent_ctl_connect</span>(kern_ctl_ref kctlref, <span class="enscript-type">struct</span> sockaddr_ctl *sac, <span class="enscript-type">void</span> **unitinfo)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>)
	*unitinfo = netagent_create_session(sac-&gt;sc_unit);
	<span class="enscript-keyword">if</span> (*unitinfo == NULL) {
		<span class="enscript-comment">// Could not allocate session
</span>		<span class="enscript-keyword">return</span> (ENOBUFS);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">netagent_ctl_disconnect</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">unit</span>)
	<span class="enscript-type">struct</span> netagent_session *session = (<span class="enscript-type">struct</span> netagent_session *)unitinfo;
	<span class="enscript-keyword">if</span> (session != NULL) {
		netagent_delete_session(session);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">// Kernel events
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">netagent_post_event</span>(uuid_t agent_uuid, u_int32_t event_code)
{
	<span class="enscript-type">struct</span> kev_msg ev_msg;
	memset(&amp;ev_msg, 0, <span class="enscript-keyword">sizeof</span>(ev_msg));

	<span class="enscript-type">struct</span> kev_netagent_data event_data;

	ev_msg.vendor_code	= KEV_VENDOR_APPLE;
	ev_msg.kev_class	= KEV_NETWORK_CLASS;
	ev_msg.kev_subclass	= KEV_NETAGENT_SUBCLASS;
	ev_msg.event_code	= event_code;

	uuid_copy(event_data.netagent_uuid, agent_uuid);
	ev_msg.dv[0].data_ptr	 = &amp;event_data;
	ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span>(event_data);

	kev_post_msg(&amp;ev_msg);
}

<span class="enscript-comment">// Message handling
</span><span class="enscript-type">static</span> u_int8_t *
<span class="enscript-function-name">netagent_buffer_write_message_header</span>(u_int8_t *buffer, u_int8_t message_type, u_int8_t flags,
									 u_int32_t message_id, u_int32_t error, u_int32_t payload_length)
{
	((<span class="enscript-type">struct</span> netagent_message_header *)(<span class="enscript-type">void</span> *)buffer)-&gt;message_type = message_type;
	((<span class="enscript-type">struct</span> netagent_message_header *)(<span class="enscript-type">void</span> *)buffer)-&gt;message_flags = flags;
	((<span class="enscript-type">struct</span> netagent_message_header *)(<span class="enscript-type">void</span> *)buffer)-&gt;message_id = message_id;
	((<span class="enscript-type">struct</span> netagent_message_header *)(<span class="enscript-type">void</span> *)buffer)-&gt;message_error = error;
	((<span class="enscript-type">struct</span> netagent_message_header *)(<span class="enscript-type">void</span> *)buffer)-&gt;message_payload_length = payload_length;
	<span class="enscript-keyword">return</span> (buffer + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent_message_header));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">netagent_send_ctl_data</span>(u_int32_t control_unit, u_int8_t *buffer, size_t buffer_size)
{
	<span class="enscript-keyword">if</span> (netagent_kctlref == NULL || control_unit == 0 || buffer == NULL || buffer_size == 0) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">return</span> ctl_enqueuedata(netagent_kctlref, control_unit, buffer, buffer_size, CTL_DATA_EOR);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">netagent_send_trigger</span>(<span class="enscript-type">struct</span> netagent_wrapper *wrapper, <span class="enscript-type">struct</span> proc *p, u_int32_t flags, u_int32_t trigger_type)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> netagent_trigger_message *trigger_message = NULL;
	u_int8_t *trigger = NULL;
	size_t trigger_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent_message_header) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent_trigger_message);

	MALLOC(trigger, u_int8_t *, trigger_size, M_NETAGENT, M_WAITOK);
	<span class="enscript-keyword">if</span> (trigger == NULL) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	(<span class="enscript-type">void</span>)netagent_buffer_write_message_header(trigger, trigger_type, 0, 0, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent_trigger_message));

	trigger_message = (<span class="enscript-type">struct</span> netagent_trigger_message *)(<span class="enscript-type">void</span> *)(trigger + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent_message_header));
	trigger_message-&gt;trigger_flags = flags;
	<span class="enscript-keyword">if</span> (p != NULL) {
		trigger_message-&gt;trigger_pid = proc_pid(p);
		proc_getexecutableuuid(p, trigger_message-&gt;trigger_proc_uuid, <span class="enscript-keyword">sizeof</span>(trigger_message-&gt;trigger_proc_uuid));
	} <span class="enscript-keyword">else</span> {
		trigger_message-&gt;trigger_pid = 0;
		uuid_clear(trigger_message-&gt;trigger_proc_uuid);
	}

	<span class="enscript-keyword">if</span> ((error = netagent_send_ctl_data(wrapper-&gt;control_unit, (u_int8_t *)trigger, trigger_size))) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to send trigger message on control unit %d&quot;</span>, wrapper-&gt;control_unit);
	}

	FREE(trigger, M_NETAGENT);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">netagent_send_success_response</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int8_t message_type, u_int32_t message_id)
{
	<span class="enscript-type">int</span> error = 0;
	u_int8_t *response = NULL;
	size_t response_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent_message_header);
	MALLOC(response, u_int8_t *, response_size, M_NETAGENT, M_WAITOK);
	<span class="enscript-keyword">if</span> (response == NULL) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	(<span class="enscript-type">void</span>)netagent_buffer_write_message_header(response, message_type, NETAGENT_MESSAGE_FLAGS_RESPONSE, message_id, 0, 0);

	<span class="enscript-keyword">if</span> ((error = netagent_send_ctl_data(session-&gt;control_unit, (u_int8_t *)response, response_size))) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to send response&quot;</span>);
	}

	FREE(response, M_NETAGENT);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">netagent_send_error_response</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int8_t message_type,
							 u_int32_t message_id, u_int32_t error_code)
{
	<span class="enscript-type">int</span> error = 0;
	u_int8_t *response = NULL;
	size_t response_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent_message_header);
	MALLOC(response, u_int8_t *, response_size, M_NETAGENT, M_WAITOK);
	<span class="enscript-keyword">if</span> (response == NULL) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	(<span class="enscript-type">void</span>)netagent_buffer_write_message_header(response, message_type, NETAGENT_MESSAGE_FLAGS_RESPONSE,
											   message_id, error_code, 0);

	<span class="enscript-keyword">if</span> ((error = netagent_send_ctl_data(session-&gt;control_unit, (u_int8_t *)response, response_size))) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to send response&quot;</span>);
	}

	FREE(response, M_NETAGENT);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">netagent_ctl_send</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, mbuf_t packet, <span class="enscript-type">int</span> flags)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">unit</span>, <span class="enscript-variable-name">flags</span>)
	<span class="enscript-type">struct</span> netagent_session *session = (<span class="enscript-type">struct</span> netagent_session *)unitinfo;
	<span class="enscript-type">struct</span> netagent_message_header header;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (session == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Got a NULL session&quot;</span>);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (mbuf_pkthdr_len(packet) &lt; <span class="enscript-keyword">sizeof</span>(header)) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Got a bad packet, length (%lu) &lt; sizeof header (%lu)&quot;</span>,
					mbuf_pkthdr_len(packet), <span class="enscript-keyword">sizeof</span>(header));
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = mbuf_copydata(packet, 0, <span class="enscript-keyword">sizeof</span>(header), &amp;header);
	<span class="enscript-keyword">if</span> (error) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;mbuf_copydata failed for the header: %d&quot;</span>, error);
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">switch</span> (header.message_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NETAGENT_MESSAGE_TYPE_REGISTER</span>: {
			netagent_handle_register(session, header.message_id, header.message_payload_length,
									 packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NETAGENT_MESSAGE_TYPE_UNREGISTER</span>: {
			netagent_handle_unregister(session, header.message_id, header.message_payload_length,
									   packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NETAGENT_MESSAGE_TYPE_UPDATE</span>: {
			netagent_handle_update(session, header.message_id, header.message_payload_length,
								   packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NETAGENT_MESSAGE_TYPE_GET</span>: {
			netagent_handle_get(session, header.message_id, header.message_payload_length,
								packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NETAGENT_MESSAGE_TYPE_ASSERT</span>: {
			netagent_handle_assert(session, header.message_id, header.message_payload_length,
								packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NETAGENT_MESSAGE_TYPE_UNASSERT</span>: {
			netagent_handle_unassert(session, header.message_id, header.message_payload_length,
								packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>: {
			NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Received unknown message type %d&quot;</span>, header.message_type);
			netagent_send_error_response(session, header.message_type, header.message_id,
										 NETAGENT_MESSAGE_ERROR_UNKNOWN_TYPE);
			<span class="enscript-keyword">break</span>;
		}
	}

<span class="enscript-reference">done</span>:
	mbuf_freem(packet);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">netagent_ctl_rcvd</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, <span class="enscript-type">int</span> flags)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">unit</span>, <span class="enscript-variable-name">unitinfo</span>, <span class="enscript-variable-name">flags</span>)
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">netagent_ctl_getopt</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, <span class="enscript-type">int</span> opt,
					<span class="enscript-type">void</span> *data, size_t *len)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">unit</span>, <span class="enscript-variable-name">unitinfo</span>, <span class="enscript-variable-name">opt</span>, <span class="enscript-variable-name">data</span>, <span class="enscript-variable-name">len</span>)
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">netagent_ctl_setopt</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, <span class="enscript-type">int</span> opt,
					<span class="enscript-type">void</span> *data, size_t len)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">unit</span>, <span class="enscript-variable-name">unitinfo</span>, <span class="enscript-variable-name">opt</span>, <span class="enscript-variable-name">data</span>, <span class="enscript-variable-name">len</span>)
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">// Session Management
</span><span class="enscript-type">static</span> <span class="enscript-type">struct</span> netagent_session *
<span class="enscript-function-name">netagent_create_session</span>(u_int32_t control_unit)
{
	<span class="enscript-type">struct</span> netagent_session *new_session = NULL;

	MALLOC(new_session, <span class="enscript-type">struct</span> netagent_session *, <span class="enscript-keyword">sizeof</span>(*new_session), M_NETAGENT, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_session == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	NETAGENTLOG(LOG_DEBUG, <span class="enscript-string">&quot;Create agent session, control unit %d&quot;</span>, control_unit);
	memset(new_session, 0, <span class="enscript-keyword">sizeof</span>(*new_session));
	new_session-&gt;control_unit = control_unit;
	LIST_INIT(&amp;new_session-&gt;assertion_list);
	new_session-&gt;wrapper = NULL;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (new_session);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">netagent_unregister_session_wrapper</span>(<span class="enscript-type">struct</span> netagent_session *session)
{
	bool unregistered = FALSE;
	uuid_t unregistered_uuid;
	<span class="enscript-type">struct</span> netagent_wrapper *wrapper = NULL;
	lck_rw_lock_exclusive(&amp;netagent_lock);
	<span class="enscript-keyword">if</span> (session != NULL) {
		wrapper = session-&gt;wrapper;
		<span class="enscript-keyword">if</span> (wrapper != NULL) {
			<span class="enscript-keyword">if</span> (netagent_registered_count &gt; 0) {
				netagent_registered_count--;
			}
			<span class="enscript-keyword">if</span> ((session-&gt;wrapper-&gt;netagent.netagent_flags &amp; NETAGENT_FLAG_ACTIVE) &amp;&amp;
				netagent_active_count &gt; 0) {
				netagent_active_count--;
			}

			LIST_REMOVE(wrapper, master_chain);

			unregistered = TRUE;
			uuid_copy(unregistered_uuid, session-&gt;wrapper-&gt;netagent.netagent_uuid);

			FREE(wrapper, M_NETAGENT);
			session-&gt;wrapper = NULL;
			NETAGENTLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Unregistered agent&quot;</span>);
		}
	}
	lck_rw_done(&amp;netagent_lock);

	<span class="enscript-keyword">if</span> (unregistered) {
		netagent_post_event(unregistered_uuid, KEV_NETAGENT_UNREGISTERED);
		ifnet_clear_netagent(unregistered_uuid);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">netagent_delete_session</span>(<span class="enscript-type">struct</span> netagent_session *session)
{
	<span class="enscript-keyword">if</span> (session != NULL) {
		netagent_unregister_session_wrapper(session);

		<span class="enscript-comment">// Unassert any pending assertions
</span>		lck_rw_lock_shared(&amp;netagent_lock);
		<span class="enscript-type">struct</span> netagent_assertion *search_assertion = NULL;
		<span class="enscript-type">struct</span> netagent_assertion *temp_assertion = NULL;
		LIST_FOREACH_SAFE(search_assertion, &amp;session-&gt;assertion_list, assertion_chain, temp_assertion) {
			<span class="enscript-type">struct</span> netagent_wrapper *wrapper = netagent_find_agent_with_uuid(search_assertion-&gt;asserted_uuid);
			<span class="enscript-keyword">if</span> (wrapper != NULL) {
				netagent_send_trigger(wrapper, current_proc(), NETAGENT_TRIGGER_FLAG_USER, NETAGENT_MESSAGE_TYPE_TRIGGER_UNASSERT);
			}
			LIST_REMOVE(search_assertion, assertion_chain);
			FREE(search_assertion, M_NETAGENT);
		}
		lck_rw_done(&amp;netagent_lock);

		FREE(session, M_NETAGENT);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">netagent_packet_get_netagent_data_size</span>(mbuf_t packet, <span class="enscript-type">int</span> offset, <span class="enscript-type">int</span> *err)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-type">struct</span> netagent netagent_peek;
	memset(&amp;netagent_peek, 0, <span class="enscript-keyword">sizeof</span>(netagent_peek));

	*err = 0;

	error = mbuf_copydata(packet, offset, <span class="enscript-keyword">sizeof</span>(netagent_peek), &amp;netagent_peek);
	<span class="enscript-keyword">if</span> (error) {
		*err = ENOENT;
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">return</span> (netagent_peek.netagent_data_size);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">netagent_handle_register</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int32_t message_id,
						 u_int32_t payload_length, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> data_size = 0;
	<span class="enscript-type">struct</span> netagent_wrapper *new_wrapper = NULL;
	u_int32_t response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
	uuid_t netagent_uuid;
	uuid_clear(netagent_uuid);

	<span class="enscript-keyword">if</span> (session == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to find session&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-keyword">if</span> (session-&gt;wrapper != NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Session already has a registered agent&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_ALREADY_REGISTERED;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-keyword">if</span> (payload_length &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent)) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Register message size too small for agent: (%d &lt; %d)&quot;</span>,
					payload_length, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent));
		response_error = NETAGENT_MESSAGE_ERROR_INVALID_DATA;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	data_size = netagent_packet_get_netagent_data_size(packet, offset, &amp;error);
	<span class="enscript-keyword">if</span> (error || data_size &lt; 0 || data_size &gt; NETAGENT_MAX_DATA_SIZE) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Register message size could not be read, error %d data_size %d&quot;</span>,
					error, data_size);
		response_error = NETAGENT_MESSAGE_ERROR_INVALID_DATA;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	MALLOC(new_wrapper, <span class="enscript-type">struct</span> netagent_wrapper *, <span class="enscript-keyword">sizeof</span>(*new_wrapper) + data_size, M_NETAGENT, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_wrapper == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to allocate agent&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	memset(new_wrapper, 0, <span class="enscript-keyword">sizeof</span>(*new_wrapper) + data_size);

	error = mbuf_copydata(packet, offset, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent) + data_size,
						  &amp;new_wrapper-&gt;netagent);
	<span class="enscript-keyword">if</span> (error) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to read data into agent structure: %d&quot;</span>, error);
		FREE(new_wrapper, M_NETAGENT);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	lck_rw_lock_exclusive(&amp;netagent_lock);

	new_wrapper-&gt;control_unit = session-&gt;control_unit;

	session-&gt;wrapper = new_wrapper;
	LIST_INSERT_HEAD(&amp;master_netagent_list, new_wrapper, master_chain);

	new_wrapper-&gt;netagent.netagent_flags |= NETAGENT_FLAG_REGISTERED;
	netagent_registered_count++;
	<span class="enscript-keyword">if</span> (new_wrapper-&gt;netagent.netagent_flags &amp; NETAGENT_FLAG_ACTIVE) {
		netagent_active_count++;
	}

	lck_rw_done(&amp;netagent_lock);

	NETAGENTLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Registered new agent&quot;</span>);
	netagent_send_success_response(session, NETAGENT_MESSAGE_TYPE_REGISTER, message_id);
	netagent_post_event(new_wrapper-&gt;netagent.netagent_uuid, KEV_NETAGENT_REGISTERED);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">fail</span>:
	netagent_send_error_response(session, NETAGENT_MESSAGE_TYPE_REGISTER, message_id, response_error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">netagent_handle_unregister</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int32_t message_id,
						   u_int32_t payload_length, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">payload_length</span>, <span class="enscript-variable-name">packet</span>, <span class="enscript-variable-name">offset</span>)
	u_int32_t response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;

	<span class="enscript-keyword">if</span> (session == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to find session&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	netagent_unregister_session_wrapper(session);

	netagent_send_success_response(session, NETAGENT_MESSAGE_TYPE_UNREGISTER, message_id);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">fail</span>:
	netagent_send_error_response(session, NETAGENT_MESSAGE_TYPE_UNREGISTER, message_id, response_error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">netagent_handle_update</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int32_t message_id,
					   u_int32_t payload_length, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> data_size = 0;
	<span class="enscript-type">struct</span> netagent_wrapper *new_wrapper = NULL;
	u_int32_t response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
	uuid_t netagent_uuid;
	uuid_clear(netagent_uuid);

	<span class="enscript-keyword">if</span> (session == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to find session&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-keyword">if</span> (session-&gt;wrapper == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Session has no agent to update&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_NOT_REGISTERED;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-keyword">if</span> (payload_length &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent)) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Update message size too small for agent: (%d &lt; %d)&quot;</span>,
					payload_length, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent));
		response_error = NETAGENT_MESSAGE_ERROR_INVALID_DATA;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	data_size = netagent_packet_get_netagent_data_size(packet, offset, &amp;error);
	<span class="enscript-keyword">if</span> (error || data_size &lt; 0 || data_size &gt; NETAGENT_MAX_DATA_SIZE) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Update message size could not be read, error %d data_size %d&quot;</span>,
					error, data_size);
		response_error = NETAGENT_MESSAGE_ERROR_INVALID_DATA;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	MALLOC(new_wrapper, <span class="enscript-type">struct</span> netagent_wrapper *, <span class="enscript-keyword">sizeof</span>(*new_wrapper) + data_size, M_NETAGENT, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_wrapper == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to allocate agent&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	memset(new_wrapper, 0, <span class="enscript-keyword">sizeof</span>(*new_wrapper) + data_size);

	error = mbuf_copydata(packet, offset, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent) + data_size, &amp;new_wrapper-&gt;netagent);
	<span class="enscript-keyword">if</span> (error) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to read data into agent structure: %d&quot;</span>, error);
		FREE(new_wrapper, M_NETAGENT);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	lck_rw_lock_exclusive(&amp;netagent_lock);

	<span class="enscript-keyword">if</span> (uuid_compare(session-&gt;wrapper-&gt;netagent.netagent_uuid, new_wrapper-&gt;netagent.netagent_uuid) != 0 ||
		memcmp(&amp;session-&gt;wrapper-&gt;netagent.netagent_domain, &amp;new_wrapper-&gt;netagent.netagent_domain,
			   <span class="enscript-keyword">sizeof</span>(new_wrapper-&gt;netagent.netagent_domain)) != 0 ||
		memcmp(&amp;session-&gt;wrapper-&gt;netagent.netagent_type, &amp;new_wrapper-&gt;netagent.netagent_type,
			   <span class="enscript-keyword">sizeof</span>(new_wrapper-&gt;netagent.netagent_type)) != 0) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Basic agent parameters do not match, cannot update&quot;</span>);
		FREE(new_wrapper, M_NETAGENT);
		response_error = NETAGENT_MESSAGE_ERROR_CANNOT_UPDATE;
		lck_rw_done(&amp;netagent_lock);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	new_wrapper-&gt;netagent.netagent_flags |= NETAGENT_FLAG_REGISTERED;
	<span class="enscript-keyword">if</span> ((new_wrapper-&gt;netagent.netagent_flags &amp; NETAGENT_FLAG_ACTIVE) &amp;&amp;
		!(session-&gt;wrapper-&gt;netagent.netagent_flags &amp; NETAGENT_FLAG_ACTIVE)) {
		netagent_active_count++;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(new_wrapper-&gt;netagent.netagent_flags &amp; NETAGENT_FLAG_ACTIVE) &amp;&amp;
			   (session-&gt;wrapper-&gt;netagent.netagent_flags &amp; NETAGENT_FLAG_ACTIVE) &amp;&amp;
			   netagent_active_count &gt; 0) {
		netagent_active_count--;
	}

	LIST_REMOVE(session-&gt;wrapper, master_chain);
	FREE(session-&gt;wrapper, M_NETAGENT);
	session-&gt;wrapper = new_wrapper;
	new_wrapper-&gt;control_unit = session-&gt;control_unit;
	LIST_INSERT_HEAD(&amp;master_netagent_list, new_wrapper, master_chain);

	lck_rw_done(&amp;netagent_lock);

	NETAGENTLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Updated agent&quot;</span>);
	netagent_send_success_response(session, NETAGENT_MESSAGE_TYPE_UPDATE, message_id);
	netagent_post_event(new_wrapper-&gt;netagent.netagent_uuid, KEV_NETAGENT_UPDATED);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">fail</span>:
	netagent_send_error_response(session, NETAGENT_MESSAGE_TYPE_UPDATE, message_id, response_error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">netagent_handle_get</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int32_t message_id,
					u_int32_t payload_length, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">payload_length</span>, <span class="enscript-variable-name">packet</span>, <span class="enscript-variable-name">offset</span>)
	u_int8_t *response = NULL;
	u_int8_t *cursor = NULL;
	u_int32_t response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;

	<span class="enscript-keyword">if</span> (session == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to find session&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-keyword">if</span> (session-&gt;wrapper == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Session has no agent to get&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_NOT_REGISTERED;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	lck_rw_lock_shared(&amp;netagent_lock);

	size_t response_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent_message_header) + <span class="enscript-keyword">sizeof</span>(session-&gt;wrapper-&gt;netagent)
								+ session-&gt;wrapper-&gt;netagent.netagent_data_size;
	MALLOC(response, u_int8_t *, response_size, M_NETAGENT, M_WAITOK);
	<span class="enscript-keyword">if</span> (response == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	cursor = response;
	cursor = netagent_buffer_write_message_header(cursor, NETAGENT_MESSAGE_TYPE_GET,
												  NETAGENT_MESSAGE_FLAGS_RESPONSE, message_id, 0,
												  response_size - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netagent_message_header));
	memcpy(cursor, &amp;session-&gt;wrapper-&gt;netagent, <span class="enscript-keyword">sizeof</span>(session-&gt;wrapper-&gt;netagent) +
		   session-&gt;wrapper-&gt;netagent.netagent_data_size);

	lck_rw_done(&amp;netagent_lock);

	<span class="enscript-keyword">if</span> (!netagent_send_ctl_data(session-&gt;control_unit, (u_int8_t *)response, response_size)) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to send response&quot;</span>);
	}
	FREE(response, M_NETAGENT);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">fail</span>:
	netagent_send_error_response(session, NETAGENT_MESSAGE_TYPE_GET, message_id, response_error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">netagent_handle_assert</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int32_t message_id,
					   u_int32_t payload_length, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> netagent_assertion *new_assertion = NULL;
	u_int32_t response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
	uuid_t netagent_uuid;
	uuid_clear(netagent_uuid);

	<span class="enscript-keyword">if</span> (session == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to find session&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-keyword">if</span> (payload_length &lt; <span class="enscript-keyword">sizeof</span>(uuid_t)) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Assert message size too small for uuid: (%d &lt; %d)&quot;</span>,
					payload_length, <span class="enscript-keyword">sizeof</span>(uuid_t));
		response_error = NETAGENT_MESSAGE_ERROR_INVALID_DATA;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	error = mbuf_copydata(packet, offset, <span class="enscript-keyword">sizeof</span>(uuid_t), &amp;netagent_uuid);
	<span class="enscript-keyword">if</span> (error) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to read uuid: %d&quot;</span>, error);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	MALLOC(new_assertion, <span class="enscript-type">struct</span> netagent_assertion *, <span class="enscript-keyword">sizeof</span>(*new_assertion), M_NETAGENT, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_assertion == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to allocate assertion&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	uuid_copy(new_assertion-&gt;asserted_uuid, netagent_uuid);

	lck_rw_lock_shared(&amp;netagent_lock);

	<span class="enscript-type">struct</span> netagent_wrapper *wrapper = netagent_find_agent_with_uuid(netagent_uuid);
	<span class="enscript-keyword">if</span> (wrapper == NULL) {
		lck_rw_done(&amp;netagent_lock);
		response_error = NETAGENT_MESSAGE_ERROR_NOT_REGISTERED;
		FREE(new_assertion, M_NETAGENT);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	error = netagent_send_trigger(wrapper, current_proc(), NETAGENT_TRIGGER_FLAG_USER, NETAGENT_MESSAGE_TYPE_TRIGGER_ASSERT);
	<span class="enscript-keyword">if</span> (error) {
		lck_rw_done(&amp;netagent_lock);
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to trigger assert agent: %d&quot;</span>, error);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		FREE(new_assertion, M_NETAGENT);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	LIST_INSERT_HEAD(&amp;session-&gt;assertion_list, new_assertion, assertion_chain);

	lck_rw_done(&amp;netagent_lock);

	NETAGENTLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Asserted agent&quot;</span>);
	netagent_send_success_response(session, NETAGENT_MESSAGE_TYPE_ASSERT, message_id);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">fail</span>:
	netagent_send_error_response(session, NETAGENT_MESSAGE_TYPE_ASSERT, message_id, response_error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">netagent_handle_unassert</span>(<span class="enscript-type">struct</span> netagent_session *session, u_int32_t message_id,
						 u_int32_t payload_length, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	<span class="enscript-type">int</span> error;
	u_int32_t response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
	uuid_t netagent_uuid;
	uuid_clear(netagent_uuid);

	<span class="enscript-keyword">if</span> (session == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to find session&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-keyword">if</span> (payload_length &lt; <span class="enscript-keyword">sizeof</span>(uuid_t)) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Unassert message size too small for uuid: (%d &lt; %d)&quot;</span>,
					payload_length, <span class="enscript-keyword">sizeof</span>(uuid_t));
		response_error = NETAGENT_MESSAGE_ERROR_INVALID_DATA;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	error = mbuf_copydata(packet, offset, <span class="enscript-keyword">sizeof</span>(uuid_t), &amp;netagent_uuid);
	<span class="enscript-keyword">if</span> (error) {
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to read uuid: %d&quot;</span>, error);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-type">struct</span> netagent_assertion *found_assertion = NULL;
	<span class="enscript-type">struct</span> netagent_assertion *search_assertion = NULL;
	LIST_FOREACH(search_assertion, &amp;session-&gt;assertion_list, assertion_chain) {
		<span class="enscript-keyword">if</span> (uuid_compare(search_assertion-&gt;asserted_uuid, netagent_uuid) == 0) {
			found_assertion = search_assertion;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (found_assertion == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Netagent uuid not previously asserted&quot;</span>);
		response_error = NETAGENT_MESSAGE_ERROR_INVALID_DATA;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	LIST_REMOVE(found_assertion, assertion_chain);
	FREE(found_assertion, M_NETAGENT);
	found_assertion = NULL;

	lck_rw_lock_shared(&amp;netagent_lock);

	<span class="enscript-type">struct</span> netagent_wrapper *wrapper = netagent_find_agent_with_uuid(netagent_uuid);
	<span class="enscript-keyword">if</span> (wrapper == NULL) {
		lck_rw_done(&amp;netagent_lock);
		response_error = NETAGENT_MESSAGE_ERROR_NOT_REGISTERED;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	error = netagent_send_trigger(wrapper, current_proc(), NETAGENT_TRIGGER_FLAG_USER, NETAGENT_MESSAGE_TYPE_TRIGGER_UNASSERT);
	<span class="enscript-keyword">if</span> (error) {
		lck_rw_done(&amp;netagent_lock);
		NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to trigger assert agent: %d&quot;</span>, error);
		response_error = NETAGENT_MESSAGE_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	lck_rw_done(&amp;netagent_lock);

	NETAGENTLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Unasserted agent&quot;</span>);
	netagent_send_success_response(session, NETAGENT_MESSAGE_TYPE_UNASSERT, message_id);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">fail</span>:
	netagent_send_error_response(session, NETAGENT_MESSAGE_TYPE_UNASSERT, message_id, response_error);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> netagent_wrapper *
<span class="enscript-function-name">netagent_find_agent_with_uuid</span>(uuid_t uuid)
{
	<span class="enscript-type">struct</span> netagent_wrapper *search_netagent = NULL;

	LIST_FOREACH(search_netagent, &amp;master_netagent_list, master_chain) {
		<span class="enscript-keyword">if</span> (uuid_compare(search_netagent-&gt;netagent.netagent_uuid, uuid) == 0) {
			<span class="enscript-keyword">return</span> (search_netagent);
		}
	}

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">netagent_post_updated_interfaces</span>(uuid_t uuid)
{
	<span class="enscript-type">struct</span> netagent_wrapper *wrapper = NULL;
	lck_rw_lock_shared(&amp;netagent_lock);
	wrapper = netagent_find_agent_with_uuid(uuid);
	lck_rw_done(&amp;netagent_lock);

	<span class="enscript-keyword">if</span> (wrapper != NULL) {
		netagent_post_event(uuid, KEV_NETAGENT_UPDATED_INTERFACES);
	} <span class="enscript-keyword">else</span> {
		NETAGENTLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Interface event with no associated agent&quot;</span>);
	}

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">netagent_ioctl</span>(u_long cmd, caddr_t data)
{
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(&amp;netagent_lock);
	<span class="enscript-keyword">switch</span> (cmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTDATA32</span>: {
			<span class="enscript-type">struct</span> netagent_req32 *ifsir32 = (<span class="enscript-type">struct</span> netagent_req32 *)(<span class="enscript-type">void</span> *)data;
			<span class="enscript-type">struct</span> netagent_wrapper *wrapper = netagent_find_agent_with_uuid(ifsir32-&gt;netagent_uuid);
			<span class="enscript-keyword">if</span> (wrapper == NULL) {
				error = ENOENT;
				<span class="enscript-keyword">break</span>;
			}
			uuid_copy(ifsir32-&gt;netagent_uuid, wrapper-&gt;netagent.netagent_uuid);
			memcpy(ifsir32-&gt;netagent_domain, wrapper-&gt;netagent.netagent_domain, <span class="enscript-keyword">sizeof</span>(ifsir32-&gt;netagent_domain));
			memcpy(ifsir32-&gt;netagent_type, wrapper-&gt;netagent.netagent_type, <span class="enscript-keyword">sizeof</span>(ifsir32-&gt;netagent_type));
			memcpy(ifsir32-&gt;netagent_desc, wrapper-&gt;netagent.netagent_desc, <span class="enscript-keyword">sizeof</span>(ifsir32-&gt;netagent_desc));
			ifsir32-&gt;netagent_flags = wrapper-&gt;netagent.netagent_flags;
			<span class="enscript-keyword">if</span> (ifsir32-&gt;netagent_data_size == 0) {
				<span class="enscript-comment">// First pass, client wants data size
</span>				ifsir32-&gt;netagent_data_size = wrapper-&gt;netagent.netagent_data_size;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifsir32-&gt;netagent_data != USER_ADDR_NULL &amp;&amp;
					   ifsir32-&gt;netagent_data_size == wrapper-&gt;netagent.netagent_data_size) {
				<span class="enscript-comment">// Second pass, client wants data buffer filled out
</span>				error = copyout(wrapper-&gt;netagent.netagent_data, ifsir32-&gt;netagent_data, wrapper-&gt;netagent.netagent_data_size);
			} <span class="enscript-keyword">else</span> {
				error = EINVAL;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTDATA64</span>: {
			<span class="enscript-type">struct</span> netagent_req64 *ifsir64 = (<span class="enscript-type">struct</span> netagent_req64 *)(<span class="enscript-type">void</span> *)data;
			<span class="enscript-type">struct</span> netagent_wrapper *wrapper = netagent_find_agent_with_uuid(ifsir64-&gt;netagent_uuid);
			<span class="enscript-keyword">if</span> (wrapper == NULL) {
				error = ENOENT;
				<span class="enscript-keyword">break</span>;
			}
			uuid_copy(ifsir64-&gt;netagent_uuid, wrapper-&gt;netagent.netagent_uuid);
			memcpy(ifsir64-&gt;netagent_domain, wrapper-&gt;netagent.netagent_domain, <span class="enscript-keyword">sizeof</span>(ifsir64-&gt;netagent_domain));
			memcpy(ifsir64-&gt;netagent_type, wrapper-&gt;netagent.netagent_type, <span class="enscript-keyword">sizeof</span>(ifsir64-&gt;netagent_type));
			memcpy(ifsir64-&gt;netagent_desc, wrapper-&gt;netagent.netagent_desc, <span class="enscript-keyword">sizeof</span>(ifsir64-&gt;netagent_desc));
			ifsir64-&gt;netagent_flags = wrapper-&gt;netagent.netagent_flags;
			<span class="enscript-keyword">if</span> (ifsir64-&gt;netagent_data_size == 0) {
				<span class="enscript-comment">// First pass, client wants data size
</span>				ifsir64-&gt;netagent_data_size = wrapper-&gt;netagent.netagent_data_size;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifsir64-&gt;netagent_data != USER_ADDR_NULL &amp;&amp;
					   ifsir64-&gt;netagent_data_size == wrapper-&gt;netagent.netagent_data_size) {
				<span class="enscript-comment">// Second pass, client wants data buffer filled out
</span>				error = copyout(wrapper-&gt;netagent.netagent_data, ifsir64-&gt;netagent_data, wrapper-&gt;netagent.netagent_data_size);
			} <span class="enscript-keyword">else</span> {
				error = EINVAL;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>: {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
	}
	lck_rw_done(&amp;netagent_lock);
	<span class="enscript-keyword">return</span> (error);
}

u_int32_t
<span class="enscript-function-name">netagent_get_flags</span>(uuid_t uuid)
{
	u_int32_t flags = 0;
	lck_rw_lock_shared(&amp;netagent_lock);
	<span class="enscript-type">struct</span> netagent_wrapper *wrapper = netagent_find_agent_with_uuid(uuid);
	<span class="enscript-keyword">if</span> (wrapper != NULL) {
		flags = wrapper-&gt;netagent.netagent_flags;
	} <span class="enscript-keyword">else</span> {
		NETAGENTLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Flags requested for invalid netagent&quot;</span>);
	}
	lck_rw_done(&amp;netagent_lock);

	<span class="enscript-keyword">return</span> (flags);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">netagent_kernel_trigger</span>(uuid_t uuid)
{
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(&amp;netagent_lock);
	<span class="enscript-type">struct</span> netagent_wrapper *wrapper = netagent_find_agent_with_uuid(uuid);
	<span class="enscript-keyword">if</span> (wrapper == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Requested netagent for kernel trigger could not be found&quot;</span>);
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> ((wrapper-&gt;netagent.netagent_flags &amp; NETAGENT_FLAG_KERNEL_ACTIVATED) == 0) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Requested netagent for kernel trigger is not kernel activated&quot;</span>);
		<span class="enscript-comment">// Agent does not accept kernel triggers
</span>		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> ((wrapper-&gt;netagent.netagent_flags &amp; NETAGENT_FLAG_ACTIVE)) {
		<span class="enscript-comment">// Agent already active
</span>		NETAGENTLOG0(LOG_INFO, <span class="enscript-string">&quot;Requested netagent for kernel trigger is already active&quot;</span>);
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = netagent_send_trigger(wrapper, current_proc(), NETAGENT_TRIGGER_FLAG_KERNEL, NETAGENT_MESSAGE_TYPE_TRIGGER);
	NETAGENTLOG((error ? LOG_ERR : LOG_INFO), <span class="enscript-string">&quot;Triggered netagent from kernel (error %d)&quot;</span>, error);
<span class="enscript-reference">done</span>:
	lck_rw_done(&amp;netagent_lock);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">netagent_trigger</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> netagent_trigger_args *uap, int32_t *retval)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">retval</span>)
	uuid_t agent_uuid;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (uap == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;uap == NULL&quot;</span>);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (uap-&gt;agent_uuid) {
		<span class="enscript-keyword">if</span> (uap-&gt;agent_uuidlen != <span class="enscript-keyword">sizeof</span>(uuid_t)) {
			NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;Incorrect length (got %d, expected %d)&quot;</span>,
						uap-&gt;agent_uuidlen, <span class="enscript-keyword">sizeof</span>(uuid_t));
			<span class="enscript-keyword">return</span> (ERANGE);
		}

		error = copyin(uap-&gt;agent_uuid, agent_uuid, <span class="enscript-keyword">sizeof</span>(uuid_t));
		<span class="enscript-keyword">if</span> (error) {
			NETAGENTLOG(LOG_ERR, <span class="enscript-string">&quot;copyin error (%d)&quot;</span>, error);
			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-keyword">if</span> (uuid_is_null(agent_uuid)) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Requested netagent UUID is empty&quot;</span>);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	lck_rw_lock_shared(&amp;netagent_lock);
	<span class="enscript-type">struct</span> netagent_wrapper *wrapper = netagent_find_agent_with_uuid(agent_uuid);
	<span class="enscript-keyword">if</span> (wrapper == NULL) {
		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Requested netagent UUID is not registered&quot;</span>);
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> ((wrapper-&gt;netagent.netagent_flags &amp; NETAGENT_FLAG_USER_ACTIVATED) == 0) {
		<span class="enscript-comment">// Agent does not accept triggers
</span>		NETAGENTLOG0(LOG_ERR, <span class="enscript-string">&quot;Requested netagent UUID is not eligible for triggering&quot;</span>);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> ((wrapper-&gt;netagent.netagent_flags &amp; NETAGENT_FLAG_ACTIVE)) {
		<span class="enscript-comment">// Agent already active
</span>		NETAGENTLOG0(LOG_INFO, <span class="enscript-string">&quot;Requested netagent UUID is already active&quot;</span>);
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = netagent_send_trigger(wrapper, p, NETAGENT_TRIGGER_FLAG_USER, NETAGENT_MESSAGE_TYPE_TRIGGER);
	NETAGENTLOG((error ? LOG_ERR : LOG_INFO), <span class="enscript-string">&quot;Triggered netagent (error %d)&quot;</span>, error);
<span class="enscript-reference">done</span>:
	lck_rw_done(&amp;netagent_lock);
	<span class="enscript-keyword">return</span> (error);
}
</pre>
<hr />
</body></html>