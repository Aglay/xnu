<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>if_loop.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">if_loop.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)if_loop.c	8.1 (Berkeley) 6/10/93
 * $FreeBSD: src/sys/net/if_loop.c,v 1.47.2.5 2001/07/03 11:01:41 ume Exp $
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2006 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

<span class="enscript-comment">/*
 * Loopback interface driver for protocol testing and timing.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;loop.h&quot;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NLOOP</span> &gt; 0

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NLOOP</span> != 1
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;More than one loopback interface is not supported.&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bpf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">INET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_protocol.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LOMTU</span>		16384
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LOSNDQ_MAXLEN</span>	256

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LO_BPF_TAP_OUT</span>(_m) {						\
	<span class="enscript-keyword">if</span> (lo_statics[0].bpf_callback != NULL) {			\
		bpf_tap_out(lo_ifp, DLT_NULL, _m,			\
		    &amp;((<span class="enscript-type">struct</span> loopback_header *)_m-&gt;m_pkthdr.pkt_hdr)-&gt;	\
		    protocol, <span class="enscript-keyword">sizeof</span> (u_int32_t));			\
	}								\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LO_BPF_TAP_OUT_MULTI</span>(_m) {					\
	<span class="enscript-keyword">if</span> (lo_statics[0].bpf_callback != NULL) {			\
		<span class="enscript-type">struct</span> mbuf *_n;					\
		<span class="enscript-keyword">for</span> (_n = _m; _n != NULL; _n = _n-&gt;m_nextpkt)		\
			LO_BPF_TAP_OUT(_n);				\
	}								\
}

<span class="enscript-type">struct</span> lo_statics_str {
	<span class="enscript-type">int</span>		bpf_mode;
	bpf_packet_func	bpf_callback;
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> lo_statics_str lo_statics[NLOOP];
<span class="enscript-type">static</span> <span class="enscript-type">int</span> lo_txstart = 0;

<span class="enscript-type">struct</span> ifnet *lo_ifp = NULL;

<span class="enscript-type">struct</span>	loopback_header {
	protocol_family_t	protocol;
};

<span class="enscript-comment">/* Local forward declerations */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">loopattach</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">lo_demux</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">char</span> *,
    protocol_family_t *);
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">lo_framer</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, u_int32_t *, u_int32_t *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">lo_add_proto</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_demux_desc *, u_int32_t);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">lo_del_proto</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">lo_output</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">lo_pre_enqueue</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">lo_start</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">lo_pre_output</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t, <span class="enscript-type">struct</span> mbuf **,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">void</span> *, <span class="enscript-type">char</span> *, <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">lo_input</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t, <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">lo_rtrequest</span>(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">lo_ioctl</span>(<span class="enscript-type">struct</span> ifnet *, u_long, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">lo_attach_proto</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">lo_reg_if_mods</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">lo_set_bpf_tap</span>(<span class="enscript-type">struct</span> ifnet *, bpf_tap_mode, bpf_packet_func);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_dequeue_max SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_sched_model SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_dequeue_scidx SYSCTL_HANDLER_ARGS;

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_link);

<span class="enscript-function-name">SYSCTL_NODE</span>(_net_link, OID_AUTO, loopback, CTLFLAG_RW | CTLFLAG_LOCKED, 0,
    <span class="enscript-string">&quot;loopback interface&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LO_BW_SLEEP</span>	10
<span class="enscript-type">static</span> u_int32_t lo_bw_sleep_usec = LO_BW_SLEEP;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_loopback, OID_AUTO, bw_sleep_usec,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;lo_bw_sleep_usec, LO_BW_SLEEP, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> u_int32_t lo_bw_measure = 0;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_loopback, OID_AUTO, bw_measure,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;lo_bw_measure, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> u_int32_t lo_dequeue_max = LOSNDQ_MAXLEN;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_loopback, OID_AUTO, max_dequeue,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;lo_dequeue_max, LOSNDQ_MAXLEN,
    sysctl_dequeue_max, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Maximum number of packets dequeued at a time&quot;</span>);

<span class="enscript-type">static</span> u_int32_t lo_sched_model = IFNET_SCHED_MODEL_NORMAL;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_loopback, OID_AUTO, sched_model,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;lo_sched_model,
    IFNET_SCHED_MODEL_NORMAL, sysctl_sched_model, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Scheduling model&quot;</span>);

<span class="enscript-type">static</span> u_int32_t lo_dequeue_sc = MBUF_SC_BE;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> lo_dequeue_scidx = MBUF_SCIDX(MBUF_SC_BE);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_loopback, OID_AUTO, dequeue_sc,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;lo_dequeue_scidx,
    MBUF_SC_BE, sysctl_dequeue_scidx, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Dequeue a specific SC index&quot;</span>);

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">lo_demux</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">char</span> *frame_header,
    protocol_family_t *protocol_family)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">m</span>)
	<span class="enscript-type">struct</span> loopback_header *header =
	    (<span class="enscript-type">struct</span> loopback_header *)(<span class="enscript-type">void</span> *)frame_header;

	*protocol_family = header-&gt;protocol;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">lo_framer</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf **m, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *dest,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *dest_linkaddr, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *frame_type,
    u_int32_t *prepend_len, u_int32_t *postpend_len)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">dest</span>, <span class="enscript-variable-name">dest_linkaddr</span>)
	<span class="enscript-type">struct</span> loopback_header  *header;

	M_PREPEND(*m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> loopback_header), M_WAITOK, 1);
	<span class="enscript-keyword">if</span> (*m == NULL) {
		<span class="enscript-comment">/* Tell caller not to try to free passed-in mbuf */</span>
		<span class="enscript-keyword">return</span> (EJUSTRETURN);
	}

	<span class="enscript-keyword">if</span> (prepend_len != NULL)
		*prepend_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> loopback_header);
	<span class="enscript-keyword">if</span> (postpend_len != NULL)
		*postpend_len = 0;

	header = mtod(*m, <span class="enscript-type">struct</span> loopback_header *);
	bcopy(frame_type, &amp;header-&gt;protocol, <span class="enscript-keyword">sizeof</span> (u_int32_t));
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">lo_add_proto</span>(<span class="enscript-type">struct</span> ifnet *interface, protocol_family_t protocol_family,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_demux_desc *demux_array, u_int32_t demux_count)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">interface</span>, <span class="enscript-variable-name">protocol_family</span>, <span class="enscript-variable-name">demux_array</span>, <span class="enscript-variable-name">demux_count</span>)
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">lo_del_proto</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t protocol)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">protocol</span>)
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Output callback.
 *
 * This routine is called only when lo_txstart is disabled.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">lo_output</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m_list)
{
	<span class="enscript-type">struct</span> mbuf *m, *m_tail = NULL;
	<span class="enscript-type">struct</span> ifnet_stat_increment_param s;
	u_int32_t cnt = 0, len = 0;

	bzero(&amp;s, <span class="enscript-keyword">sizeof</span>(s));

	<span class="enscript-keyword">for</span> (m = m_list; m; m = m-&gt;m_nextpkt) {
		VERIFY(m-&gt;m_flags &amp; M_PKTHDR);
		cnt++;
		len += m-&gt;m_pkthdr.len;

		<span class="enscript-comment">/*
		 * Don't overwrite the rcvif field if it is in use.
		 *  This is used to match multicast packets, sent looping
		 *  back, with the appropriate group record on input.
		 */</span>
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.rcvif == NULL)
			m-&gt;m_pkthdr.rcvif = ifp;

		m-&gt;m_pkthdr.pkt_flags |= PKTF_LOOP;
		m-&gt;m_pkthdr.pkt_hdr = mtod(m, <span class="enscript-type">char</span> *);

		<span class="enscript-comment">/* loopback checksums are always OK */</span>
		m-&gt;m_pkthdr.csum_data = 0xffff;
		m-&gt;m_pkthdr.csum_flags =
		    CSUM_DATA_VALID | CSUM_PSEUDO_HDR |
		    CSUM_IP_CHECKED | CSUM_IP_VALID;

		m_adj(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> loopback_header));

		LO_BPF_TAP_OUT(m);
		<span class="enscript-keyword">if</span> (m-&gt;m_nextpkt == NULL) {
			m_tail = m;
		}
	}

	s.packets_in = cnt;
	s.packets_out = cnt;
	s.bytes_in = len;
	s.bytes_out = len;

	<span class="enscript-keyword">return</span> (ifnet_input_extended(ifp, m_list, m_tail, &amp;s));
}

<span class="enscript-comment">/*
 * Pre-enqueue callback.
 *
 * This routine is called only when lo_txstart is enabled.
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">lo_pre_enqueue</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m0)
{
	<span class="enscript-type">struct</span> mbuf *m = m0, *n;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">while</span> (m != NULL) {
		VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

		n = m-&gt;m_nextpkt;
		m-&gt;m_nextpkt = NULL;

		<span class="enscript-comment">/*
		 * Don't overwrite the rcvif field if it is in use.
		 *  This is used to match multicast packets, sent looping
		 *  back, with the appropriate group record on input.
		 */</span>
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.rcvif == NULL)
			m-&gt;m_pkthdr.rcvif = ifp;

		m-&gt;m_pkthdr.pkt_flags |= PKTF_LOOP;
		m-&gt;m_pkthdr.pkt_hdr = mtod(m, <span class="enscript-type">char</span> *);

		<span class="enscript-comment">/* loopback checksums are always OK */</span>
		m-&gt;m_pkthdr.csum_data = 0xffff;
		m-&gt;m_pkthdr.csum_flags =
		    CSUM_DATA_VALID | CSUM_PSEUDO_HDR |
		    CSUM_IP_CHECKED | CSUM_IP_VALID;

		m_adj(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> loopback_header));

		<span class="enscript-comment">/*
		 * Let the callee free it in case of error,
		 * and perform any necessary accounting.
		 */</span>
		(<span class="enscript-type">void</span>) ifnet_enqueue(ifp, m);

		m = n;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Start output callback.
 *
 * This routine is invoked by the start worker thread; because we never call
 * it directly, there is no need do deploy any serialization mechanism other
 * than what's already used by the worker thread, i.e. this is already single
 * threaded.
 *
 * This routine is called only when lo_txstart is enabled.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lo_start</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> ifnet_stat_increment_param s;

	bzero(&amp;s, <span class="enscript-keyword">sizeof</span> (s));

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-type">struct</span> mbuf *m = NULL, *m_tail = NULL;
		u_int32_t cnt, len = 0;
		<span class="enscript-type">int</span> sleep_chan = 0;
		<span class="enscript-type">struct</span> timespec ts;

		<span class="enscript-keyword">if</span> (lo_sched_model == IFNET_SCHED_MODEL_NORMAL) {
			<span class="enscript-keyword">if</span> (ifnet_dequeue_multi(ifp, lo_dequeue_max, &amp;m,
			    &amp;m_tail, &amp;cnt, &amp;len) != 0)
				<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (ifnet_dequeue_service_class_multi(ifp,
			    lo_dequeue_sc, lo_dequeue_max, &amp;m,
			    &amp;m_tail, &amp;cnt, &amp;len) != 0)
				<span class="enscript-keyword">break</span>;
		}

		LO_BPF_TAP_OUT_MULTI(m);

		<span class="enscript-keyword">if</span> (lo_bw_measure) {
			<span class="enscript-keyword">if</span> (cnt &gt;= if_bw_measure_size)
				ifnet_transmit_burst_start(ifp, m);
			<span class="enscript-keyword">if</span> (lo_bw_sleep_usec &gt; 0) {
				bzero(&amp;ts, <span class="enscript-keyword">sizeof</span>(ts));
				ts.tv_nsec = (lo_bw_sleep_usec &lt;&lt; 10) * cnt;

				<span class="enscript-comment">/* Add msleep with timeout */</span>
				(<span class="enscript-type">void</span>) msleep(&amp;sleep_chan, NULL,
				    PSOCK, <span class="enscript-string">&quot;lo_start&quot;</span>, &amp;ts);
			}
			<span class="enscript-keyword">if</span> (cnt &gt;= if_bw_measure_size)
				ifnet_transmit_burst_end(ifp, m_tail);
		}

		<span class="enscript-comment">/* stats are required for extended variant */</span>
		s.packets_in = cnt;
		s.packets_out = cnt;
		s.bytes_in = len;
		s.bytes_out = len;

		(<span class="enscript-type">void</span>) ifnet_input_extended(ifp, m, m_tail, &amp;s);
	}
}

<span class="enscript-comment">/*
 * This is a common pre-output route used by INET and INET6. This could
 * (should?) be split into separate pre-output routines for each protocol.
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">lo_pre_output</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t protocol_family,
    <span class="enscript-type">struct</span> mbuf **m, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">void</span> *route, <span class="enscript-type">char</span> *frame_type,
    <span class="enscript-type">char</span> *dst_addr)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">dst</span>, <span class="enscript-variable-name">dst_addr</span>)
	<span class="enscript-type">struct</span> rtentry *rt = route;

	VERIFY((*m)-&gt;m_flags &amp; M_PKTHDR);

	(*m)-&gt;m_flags |= M_LOOP;

	<span class="enscript-keyword">if</span> (rt != NULL) {
		u_int32_t rt_flags = rt-&gt;rt_flags;
		<span class="enscript-keyword">if</span> (rt_flags &amp; (RTF_REJECT | RTF_BLACKHOLE)) {
			<span class="enscript-keyword">if</span> (rt_flags &amp; RTF_BLACKHOLE) {
				m_freem(*m);
				<span class="enscript-keyword">return</span> (EJUSTRETURN);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">return</span> ((rt_flags &amp; RTF_HOST) ?
				    EHOSTUNREACH : ENETUNREACH);
			}
		}
	}

	bcopy(&amp;protocol_family, frame_type, <span class="enscript-keyword">sizeof</span> (protocol_family));

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 *  lo_input - This should work for all attached protocols that use the
 *             ifq/schednetisr input mechanism.
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">lo_input</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t protocol_family, <span class="enscript-type">struct</span> mbuf *m)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">protocol_family</span>)
	<span class="enscript-keyword">if</span> (proto_input(protocol_family, m) != 0)
		m_freem(m);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lo_rtrequest</span>(<span class="enscript-type">int</span> cmd, <span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> sockaddr *sa)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cmd</span>, <span class="enscript-variable-name">sa</span>)
	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK_ASSERT_HELD(rt);
		rt-&gt;rt_rmx.rmx_mtu = rt-&gt;rt_ifp-&gt;if_mtu; <span class="enscript-comment">/* for ISO */</span>
		<span class="enscript-comment">/*
		 * For optimal performance, the send and receive buffers
		 * should be at least twice the MTU plus a little more for
		 * overhead.
		 */</span>
		rt-&gt;rt_rmx.rmx_recvpipe = rt-&gt;rt_rmx.rmx_sendpipe = 3 * LOMTU;
	}
}

<span class="enscript-comment">/*
 * Process an ioctl request.
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">lo_ioctl</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, <span class="enscript-type">void</span> *data)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFADDR</span>: {		<span class="enscript-comment">/* struct ifaddr pointer */</span>
		<span class="enscript-type">struct</span> ifaddr *ifa = data;

		ifnet_set_flags(ifp, IFF_UP|IFF_RUNNING, IFF_UP|IFF_RUNNING);
		IFA_LOCK_SPIN(ifa);
		ifa-&gt;ifa_rtrequest = lo_rtrequest;
		IFA_UNLOCK(ifa);
		<span class="enscript-comment">/*
		 * Everything else is done at a higher level.
		 */</span>
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCADDMULTI</span>:		<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDELMULTI</span>: {		<span class="enscript-comment">/* struct ifreq */</span>
		<span class="enscript-type">struct</span> ifreq *ifr = data;

		<span class="enscript-keyword">if</span> (ifr == NULL) {
			error = EAFNOSUPPORT;		<span class="enscript-comment">/* XXX */</span>
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">switch</span> (ifr-&gt;ifr_addr.sa_family) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>

		<span class="enscript-reference">default</span>:
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMTU</span>: {		<span class="enscript-comment">/* struct ifreq */</span>
		<span class="enscript-type">struct</span> ifreq *ifr = data;

		bcopy(&amp;ifr-&gt;ifr_mtu, &amp;ifp-&gt;if_mtu, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFFLAGS</span>:		<span class="enscript-comment">/* struct ifreq */</span>
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EOPNOTSUPP;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NLOOP &gt; 0 */</span>


<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">lo_attach_proto</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t protocol_family)
{
	<span class="enscript-type">struct</span> ifnet_attach_proto_param_v2	proto;
	errno_t							result = 0;

	bzero(&amp;proto, <span class="enscript-keyword">sizeof</span> (proto));
	proto.input = lo_input;
	proto.pre_output = lo_pre_output;

	result = ifnet_attach_protocol_v2(ifp, protocol_family, &amp;proto);

	<span class="enscript-keyword">if</span> (result &amp;&amp; result != EEXIST) {
		printf(<span class="enscript-string">&quot;lo_attach_proto: ifnet_attach_protocol for %u &quot;</span>
		    <span class="enscript-string">&quot;returned=%d\n&quot;</span>, protocol_family, result);
	}

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lo_reg_if_mods</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* Register protocol registration functions */</span>
	<span class="enscript-keyword">if</span> ((error = proto_register_plumber(PF_INET,
	    APPLE_IF_FAM_LOOPBACK, lo_attach_proto, NULL)) != 0)
		printf(<span class="enscript-string">&quot;proto_register_plumber failed for AF_INET &quot;</span>
		    <span class="enscript-string">&quot;error=%d\n&quot;</span>, error);

	<span class="enscript-keyword">if</span> ((error = proto_register_plumber(PF_INET6,
	    APPLE_IF_FAM_LOOPBACK, lo_attach_proto, NULL)) != 0)
		printf(<span class="enscript-string">&quot;proto_register_plumber failed for AF_INET6 &quot;</span>
		    <span class="enscript-string">&quot;error=%d\n&quot;</span>, error);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">lo_set_bpf_tap</span>(<span class="enscript-type">struct</span> ifnet *ifp, bpf_tap_mode mode,
    bpf_packet_func bpf_callback)
{
	VERIFY(ifp == lo_ifp);

	lo_statics[0].bpf_mode = mode;

	<span class="enscript-keyword">switch</span> (mode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BPF_TAP_DISABLE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BPF_TAP_INPUT</span>:
			lo_statics[0].bpf_callback = NULL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BPF_TAP_OUTPUT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BPF_TAP_INPUT_OUTPUT</span>:
			lo_statics[0].bpf_callback = bpf_callback;
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">loopattach</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> ifnet_init_eparams lo_init;
	errno_t	result = 0;

	PE_parse_boot_argn(<span class="enscript-string">&quot;lo_txstart&quot;</span>, &amp;lo_txstart, <span class="enscript-keyword">sizeof</span> (lo_txstart));

	lo_reg_if_mods();

	lo_statics[0].bpf_callback = NULL;
	lo_statics[0].bpf_mode = BPF_TAP_DISABLE;

	bzero(&amp;lo_init, <span class="enscript-keyword">sizeof</span> (lo_init));
	lo_init.ver			= IFNET_INIT_CURRENT_VERSION;
	lo_init.len			= <span class="enscript-keyword">sizeof</span> (lo_init);
	lo_init.sndq_maxlen		= LOSNDQ_MAXLEN;
	<span class="enscript-keyword">if</span> (lo_txstart) {
		lo_init.flags		= 0;
		lo_init.pre_enqueue	= lo_pre_enqueue;
		lo_init.start		= lo_start;
		lo_init.output_sched_model = lo_sched_model;
	} <span class="enscript-keyword">else</span> {
		lo_init.flags		= IFNET_INIT_LEGACY;
		lo_init.output		= lo_output;
	}
	lo_init.name			= <span class="enscript-string">&quot;lo&quot;</span>;
	lo_init.unit			= 0;
	lo_init.family			= IFNET_FAMILY_LOOPBACK;
	lo_init.type			= IFT_LOOP;
	lo_init.demux			= lo_demux;
	lo_init.add_proto		= lo_add_proto;
	lo_init.del_proto		= lo_del_proto;
	lo_init.framer_extended		= lo_framer;
	lo_init.softc			= &amp;lo_statics[0];
	lo_init.ioctl			= lo_ioctl;
	lo_init.set_bpf_tap		= lo_set_bpf_tap;

	result = ifnet_allocate_extended(&amp;lo_init, &amp;lo_ifp);
	<span class="enscript-keyword">if</span> (result != 0) {
		panic(<span class="enscript-string">&quot;%s: couldn't allocate loopback ifnet (%d)\n&quot;</span>,
		    __func__, result);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	ifnet_set_mtu(lo_ifp, LOMTU);
	ifnet_set_flags(lo_ifp, IFF_LOOPBACK | IFF_MULTICAST,
	    IFF_LOOPBACK | IFF_MULTICAST);
	ifnet_set_offload(lo_ifp,
	    IFNET_CSUM_IP | IFNET_CSUM_TCP | IFNET_CSUM_UDP |
	    IFNET_CSUM_TCPIPV6 | IFNET_CSUM_UDPIPV6 | IFNET_IPV6_FRAGMENT |
	    IFNET_CSUM_FRAGMENT | IFNET_IP_FRAGMENT | IFNET_MULTIPAGES);
	ifnet_set_hdrlen(lo_ifp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> loopback_header));
	ifnet_set_eflags(lo_ifp, IFEF_SENDLIST, IFEF_SENDLIST);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	mac_ifnet_label_init(ifp);
#<span class="enscript-reference">endif</span>

	result = ifnet_attach(lo_ifp, NULL);
	<span class="enscript-keyword">if</span> (result != 0) {
		panic(<span class="enscript-string">&quot;%s: couldn't attach loopback ifnet (%d)\n&quot;</span>,
		    __func__, result);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	bpfattach(lo_ifp, DLT_NULL, <span class="enscript-keyword">sizeof</span> (u_int32_t));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_dequeue_max SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	u_int32_t i;
	<span class="enscript-type">int</span> err;

	i = lo_dequeue_max;

	err = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (i &lt; 1)
		i = 1;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (i &gt; LOSNDQ_MAXLEN)
		i = LOSNDQ_MAXLEN;

	lo_dequeue_max = i;

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_sched_model SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	u_int32_t i;
	<span class="enscript-type">int</span> err;

	i = lo_sched_model;

	err = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">switch</span> (i) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFNET_SCHED_MODEL_NORMAL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFNET_SCHED_MODEL_DRIVER_MANAGED</span>:
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		err = EINVAL;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (err == 0 &amp;&amp; (err = ifnet_set_output_sched_model(lo_ifp, i)) == 0)
		lo_sched_model = i;

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_dequeue_scidx SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	u_int32_t i;
	<span class="enscript-type">int</span> err;

	i = lo_dequeue_scidx;

	err = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (!MBUF_VALID_SCIDX(i))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (lo_sched_model != IFNET_SCHED_MODEL_DRIVER_MANAGED)
		<span class="enscript-keyword">return</span> (ENODEV);

	lo_dequeue_sc = m_service_class_from_idx(i);
	lo_dequeue_scidx = MBUF_SCIDX(lo_dequeue_sc);

	<span class="enscript-keyword">return</span> (err);
}
</pre>
<hr />
</body></html>