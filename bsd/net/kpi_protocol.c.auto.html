<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kpi_protocol.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kpi_protocol.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kpi_protocol.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">proto_input_run</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*attach_t)(<span class="enscript-type">struct</span> ifnet *ifp, uint32_t protocol_family);
<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*detach_t)(<span class="enscript-type">struct</span> ifnet *ifp, uint32_t protocol_family);

<span class="enscript-type">struct</span> proto_input_entry {
	<span class="enscript-type">struct</span> proto_input_entry	*next;
	<span class="enscript-type">int</span>				detach;
	<span class="enscript-type">struct</span> domain			*domain;
	<span class="enscript-type">int</span>				hash;
	<span class="enscript-type">int</span>				chain;

	protocol_family_t		protocol;
	proto_input_handler		input;
	proto_input_detached_handler	detached;

	mbuf_t				inject_first;
	mbuf_t				inject_last;

	<span class="enscript-type">struct</span> proto_input_entry	*input_next;
	mbuf_t				input_first;
	mbuf_t				input_last;
};


<span class="enscript-type">struct</span> proto_family_str {
	TAILQ_ENTRY(proto_family_str)	proto_fam_next;
	protocol_family_t		proto_family;
	ifnet_family_t			if_family;
	proto_plumb_handler		attach_proto;
	proto_unplumb_handler		detach_proto;
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> proto_input_entry *proto_hash[PROTO_HASH_SLOTS];
<span class="enscript-type">static</span> <span class="enscript-type">int</span> proto_total_waiting = 0;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> proto_input_entry	*proto_input_add_list = NULL;
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, proto_family_mutex_data);
<span class="enscript-type">static</span> lck_mtx_t *proto_family_mutex = &amp;proto_family_mutex_data;
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(, proto_family_str) proto_family_head =
    TAILQ_HEAD_INITIALIZER(proto_family_head);

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">proto_kpi_init</span>(<span class="enscript-type">void</span>)
{
	lck_grp_attr_t	*grp_attrib = NULL;
	lck_attr_t	*lck_attrib = NULL;
	lck_grp_t	*lck_group = NULL;

	<span class="enscript-comment">/* Allocate a mtx lock */</span>
	grp_attrib = lck_grp_attr_alloc_init();
	lck_group = lck_grp_alloc_init(<span class="enscript-string">&quot;protocol kpi&quot;</span>, grp_attrib);
	lck_grp_attr_free(grp_attrib);
	lck_attrib = lck_attr_alloc_init();
	lck_mtx_init(proto_family_mutex, lck_group, lck_attrib);
	lck_grp_free(lck_group);
	lck_attr_free(lck_attrib);

	bzero(proto_hash, <span class="enscript-keyword">sizeof</span> (proto_hash));
}

__private_extern__ errno_t
<span class="enscript-function-name">proto_register_input</span>(protocol_family_t protocol, proto_input_handler input,
    proto_input_detached_handler detached, <span class="enscript-type">int</span>	chains)
{
	<span class="enscript-type">struct</span> proto_input_entry *entry;
	<span class="enscript-type">struct</span> dlil_threading_info *inp = dlil_main_input_thread;
	<span class="enscript-type">struct</span> domain *dp;
	domain_guard_t guard;

	entry = _MALLOC(<span class="enscript-keyword">sizeof</span> (*entry), M_IFADDR, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (entry == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	entry-&gt;protocol = protocol;
	entry-&gt;input = input;
	entry-&gt;detached = detached;
	entry-&gt;hash = proto_hash_value(protocol);
	entry-&gt;chain = chains;

	guard = domain_guard_deploy();
	TAILQ_FOREACH(dp, &amp;domains, dom_entry) {
		<span class="enscript-keyword">if</span> (dp-&gt;dom_family == (<span class="enscript-type">int</span>)protocol)
			<span class="enscript-keyword">break</span>;
	}
	domain_guard_release(guard);
	<span class="enscript-keyword">if</span> (dp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	entry-&gt;domain = dp;

	lck_mtx_lock(&amp;inp-&gt;input_lck);
	entry-&gt;next = proto_input_add_list;
	proto_input_add_list = entry;

	inp-&gt;input_waiting |= DLIL_PROTO_REGISTER;
	<span class="enscript-keyword">if</span> ((inp-&gt;input_waiting &amp; DLIL_INPUT_RUNNING) == 0)
		wakeup((caddr_t)&amp;inp-&gt;input_waiting);
	lck_mtx_unlock(&amp;inp-&gt;input_lck);

	<span class="enscript-keyword">return</span> (0);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">proto_unregister_input</span>(protocol_family_t protocol)
{
	<span class="enscript-type">struct</span> proto_input_entry *entry = NULL;

	<span class="enscript-keyword">for</span> (entry = proto_hash[proto_hash_value(protocol)]; entry != NULL;
	    entry = entry-&gt;next) {
		<span class="enscript-keyword">if</span> (entry-&gt;protocol == protocol)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (entry != NULL)
		entry-&gt;detach = 1;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">proto_delayed_attach</span>(<span class="enscript-type">struct</span> proto_input_entry *entry)
{
	<span class="enscript-type">struct</span> proto_input_entry *next_entry;

	<span class="enscript-keyword">for</span> (next_entry = entry-&gt;next; entry != NULL; entry = next_entry) {
		<span class="enscript-type">struct</span> proto_input_entry *exist;
		<span class="enscript-type">int</span> hash_slot;

		hash_slot = proto_hash_value(entry-&gt;protocol);
		next_entry = entry-&gt;next;

		<span class="enscript-keyword">for</span> (exist = proto_hash[hash_slot]; exist != NULL;
		    exist = exist-&gt;next) {
			<span class="enscript-keyword">if</span> (exist-&gt;protocol == entry-&gt;protocol)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* If the entry already exists, call detached and dispose */</span>
		<span class="enscript-keyword">if</span> (exist != NULL) {
			<span class="enscript-keyword">if</span> (entry-&gt;detached)
				entry-&gt;detached(entry-&gt;protocol);
			FREE(entry, M_IFADDR);
		} <span class="enscript-keyword">else</span> {
			entry-&gt;next = proto_hash[hash_slot];
			proto_hash[hash_slot] = entry;
		}
	}
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">proto_input_run</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> proto_input_entry *entry;
	<span class="enscript-type">struct</span> dlil_threading_info *inp = dlil_main_input_thread;
	mbuf_t packet_list;
	<span class="enscript-type">int</span> i, locked = 0;

	lck_mtx_assert(&amp;inp-&gt;input_lck, LCK_MTX_ASSERT_NOTOWNED);

	<span class="enscript-keyword">if</span> (inp-&gt;input_waiting &amp; DLIL_PROTO_REGISTER) {
		lck_mtx_lock_spin(&amp;inp-&gt;input_lck);
		entry = proto_input_add_list;
		proto_input_add_list = NULL;
		inp-&gt;input_waiting &amp;= ~DLIL_PROTO_REGISTER;
		lck_mtx_unlock(&amp;inp-&gt;input_lck);
		proto_delayed_attach(entry);
	}

	<span class="enscript-comment">/*
	 * Move everything from the lock protected list to the thread
	 * specific list.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; proto_total_waiting != 0 &amp;&amp; i &lt; PROTO_HASH_SLOTS; i++) {
		<span class="enscript-keyword">for</span> (entry = proto_hash[i];
		    entry != NULL &amp;&amp; proto_total_waiting; entry = entry-&gt;next) {
			<span class="enscript-keyword">if</span> (entry-&gt;inject_first != NULL) {
				lck_mtx_lock_spin(&amp;inp-&gt;input_lck);
				inp-&gt;input_waiting &amp;= ~DLIL_PROTO_WAITING;

				packet_list = entry-&gt;inject_first;

				entry-&gt;inject_first = NULL;
				entry-&gt;inject_last = NULL;
				proto_total_waiting--;

				lck_mtx_unlock(&amp;inp-&gt;input_lck);

				<span class="enscript-keyword">if</span> (entry-&gt;domain != NULL &amp;&amp; !(entry-&gt;domain-&gt;
				    dom_flags &amp; DOM_REENTRANT)) {
					lck_mtx_lock(entry-&gt;domain-&gt;dom_mtx);
					locked = 1;
				}

				<span class="enscript-keyword">if</span> (entry-&gt;chain) {
					entry-&gt;input(entry-&gt;protocol,
					    packet_list);
				} <span class="enscript-keyword">else</span> {
					mbuf_t	packet;

					<span class="enscript-keyword">for</span> (packet = packet_list;
					    packet != NULL;
					    packet = packet_list) {
						packet_list =
						    mbuf_nextpkt(packet);
						mbuf_setnextpkt(packet, NULL);
						entry-&gt;input(entry-&gt;protocol,
						    packet);
					}
				}
				<span class="enscript-keyword">if</span> (locked) {
					locked = 0;
					lck_mtx_unlock(entry-&gt;domain-&gt;dom_mtx);
				}
			}
		}
	}
}

errno_t
<span class="enscript-function-name">proto_input</span>(protocol_family_t protocol, mbuf_t packet_list)
{
	<span class="enscript-type">struct</span> proto_input_entry *entry;
	errno_t locked = 0, result = 0;

	<span class="enscript-keyword">for</span> (entry = proto_hash[proto_hash_value(protocol)]; entry != NULL;
	    entry = entry-&gt;next) {
		<span class="enscript-keyword">if</span> (entry-&gt;protocol == protocol)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (entry-&gt;domain &amp;&amp; !(entry-&gt;domain-&gt;dom_flags &amp; DOM_REENTRANT)) {
		lck_mtx_lock(entry-&gt;domain-&gt;dom_mtx);
		locked = 1;
	}

	<span class="enscript-keyword">if</span> (entry-&gt;chain) {
		entry-&gt;input(entry-&gt;protocol, packet_list);
	} <span class="enscript-keyword">else</span> {
		mbuf_t	packet;

		<span class="enscript-keyword">for</span> (packet = packet_list; packet != NULL;
		    packet = packet_list) {
			packet_list = mbuf_nextpkt(packet);
			mbuf_setnextpkt(packet, NULL);
			entry-&gt;input(entry-&gt;protocol, packet);
		}
	}

	<span class="enscript-keyword">if</span> (locked) {
		lck_mtx_unlock(entry-&gt;domain-&gt;dom_mtx);
	}
	<span class="enscript-keyword">return</span> (result);
}

errno_t
<span class="enscript-function-name">proto_inject</span>(protocol_family_t protocol, mbuf_t packet_list)
{
	<span class="enscript-type">struct</span> proto_input_entry *entry;
	mbuf_t last_packet;
	<span class="enscript-type">int</span> hash_slot = proto_hash_value(protocol);
	<span class="enscript-type">struct</span> dlil_threading_info *inp = dlil_main_input_thread;

	<span class="enscript-keyword">for</span> (last_packet = packet_list; mbuf_nextpkt(last_packet) != NULL;
	    last_packet = mbuf_nextpkt(last_packet))
		<span class="enscript-comment">/* find the last packet */</span>;

	<span class="enscript-keyword">for</span> (entry = proto_hash[hash_slot]; entry != NULL;
	    entry = entry-&gt;next) {
		<span class="enscript-keyword">if</span> (entry-&gt;protocol == protocol)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (entry != NULL) {
		lck_mtx_lock(&amp;inp-&gt;input_lck);
		<span class="enscript-keyword">if</span> (entry-&gt;inject_first == NULL) {
			proto_total_waiting++;
			inp-&gt;input_waiting |= DLIL_PROTO_WAITING;
			entry-&gt;inject_first = packet_list;
		} <span class="enscript-keyword">else</span> {
			mbuf_setnextpkt(entry-&gt;inject_last, packet_list);
		}
		entry-&gt;inject_last = last_packet;
		<span class="enscript-keyword">if</span> ((inp-&gt;input_waiting &amp; DLIL_INPUT_RUNNING) == 0) {
			wakeup((caddr_t)&amp;inp-&gt;input_waiting);
		}
		lck_mtx_unlock(&amp;inp-&gt;input_lck);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (ENOENT);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> proto_family_str *
<span class="enscript-function-name">proto_plumber_find</span>(protocol_family_t proto_family, ifnet_family_t if_family)
{
	<span class="enscript-type">struct</span> proto_family_str  *mod = NULL;

	TAILQ_FOREACH(mod, &amp;proto_family_head, proto_fam_next) {
		<span class="enscript-keyword">if</span> ((mod-&gt;proto_family == (proto_family &amp; 0xffff)) &amp;&amp;
		    (mod-&gt;if_family == (if_family &amp; 0xffff)))
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (mod);
}

errno_t
<span class="enscript-function-name">proto_register_plumber</span>(protocol_family_t protocol_family,
    ifnet_family_t interface_family, proto_plumb_handler attach,
    proto_unplumb_handler detach)
{
	<span class="enscript-type">struct</span> proto_family_str *proto_family;

	<span class="enscript-keyword">if</span> (attach == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	lck_mtx_lock(proto_family_mutex);

	TAILQ_FOREACH(proto_family, &amp;proto_family_head, proto_fam_next) {
		<span class="enscript-keyword">if</span> (proto_family-&gt;proto_family == protocol_family &amp;&amp;
		    proto_family-&gt;if_family == interface_family) {
			lck_mtx_unlock(proto_family_mutex);
			<span class="enscript-keyword">return</span> (EEXIST);
		}
	}

	proto_family = (<span class="enscript-type">struct</span> proto_family_str *)
	    _MALLOC(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> proto_family_str), M_IFADDR,
	    M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (!proto_family) {
		lck_mtx_unlock(proto_family_mutex);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	proto_family-&gt;proto_family	= protocol_family;
	proto_family-&gt;if_family		= interface_family &amp; 0xffff;
	proto_family-&gt;attach_proto	= attach;
	proto_family-&gt;detach_proto	= detach;

	TAILQ_INSERT_TAIL(&amp;proto_family_head, proto_family, proto_fam_next);
	lck_mtx_unlock(proto_family_mutex);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">proto_unregister_plumber</span>(protocol_family_t protocol_family,
    ifnet_family_t interface_family)
{
	<span class="enscript-type">struct</span> proto_family_str  *proto_family;

	lck_mtx_lock(proto_family_mutex);

	proto_family = proto_plumber_find(protocol_family, interface_family);
	<span class="enscript-keyword">if</span> (proto_family == NULL) {
		lck_mtx_unlock(proto_family_mutex);
		<span class="enscript-keyword">return</span>;
	}

	TAILQ_REMOVE(&amp;proto_family_head, proto_family, proto_fam_next);
	FREE(proto_family, M_IFADDR);

	lck_mtx_unlock(proto_family_mutex);
}

__private_extern__ errno_t
<span class="enscript-function-name">proto_plumb</span>(protocol_family_t protocol_family, ifnet_t ifp)
{
	<span class="enscript-type">struct</span> proto_family_str  *proto_family;
	<span class="enscript-type">int</span> ret = 0;

	lck_mtx_lock(proto_family_mutex);
	proto_family = proto_plumber_find(protocol_family, ifp-&gt;if_family);
	<span class="enscript-keyword">if</span> (proto_family == NULL) {
		lck_mtx_unlock(proto_family_mutex);
		<span class="enscript-keyword">return</span> (ENXIO);
	}

	ret = proto_family-&gt;attach_proto(ifp, protocol_family);

	lck_mtx_unlock(proto_family_mutex);
	<span class="enscript-keyword">return</span> (ret);
}


__private_extern__ errno_t
<span class="enscript-function-name">proto_unplumb</span>(protocol_family_t protocol_family, ifnet_t ifp)
{
	<span class="enscript-type">struct</span> proto_family_str  *proto_family;
	<span class="enscript-type">int</span> ret = 0;

	lck_mtx_lock(proto_family_mutex);

	proto_family = proto_plumber_find(protocol_family, ifp-&gt;if_family);
	<span class="enscript-keyword">if</span> (proto_family != NULL &amp;&amp; proto_family-&gt;detach_proto)
		proto_family-&gt;detach_proto(ifp, protocol_family);
	<span class="enscript-keyword">else</span>
		ret = ifnet_detach_protocol(ifp, protocol_family);

	lck_mtx_unlock(proto_family_mutex);
	<span class="enscript-keyword">return</span> (ret);
}
</pre>
<hr />
</body></html>