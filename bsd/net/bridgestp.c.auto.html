<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>bridgestp.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">bridgestp.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*	$NetBSD: bridgestp.c,v 1.5 2003/11/28 08:56:48 keihan Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (c) 2009-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 2000 Jason L. Wright (<a href="mailto:jason@thought.net">jason@thought.net</a>)
 * Copyright (c) 2006 Andrew Thompson (<a href="mailto:thompsa@FreeBSD.org">thompsa@FreeBSD.org</a>)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * OpenBSD: bridgestp.c,v 1.5 2001/03/22 03:48:29 jason Exp
 */</span>

<span class="enscript-comment">/*
 * Implementation of the spanning tree protocol as defined in
 * ISO/IEC 802.1D-2004, June 9, 2004.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
<span class="enscript-comment">//__FBSDID(&quot;$FreeBSD$&quot;);
</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
<span class="enscript-comment">//#include &lt;sys/callout.h&gt;
</span><span class="enscript-comment">//#include &lt;sys/module.h&gt;
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
<span class="enscript-comment">//#include &lt;sys/mutex.h&gt;
</span><span class="enscript-comment">//#include &lt;sys/taskqueue.h&gt;
</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_llc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_media.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_interface.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/if_ether.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bridgestp.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, bstp_task_mtx_data);
<span class="enscript-type">static</span> lck_mtx_t		*bstp_task_mtx = &amp;bstp_task_mtx_data;
<span class="enscript-type">static</span> lck_grp_t 		*bstp_task_grp = NULL;
<span class="enscript-type">static</span> lck_attr_t 		*bstp_task_attr = NULL;
<span class="enscript-type">static</span> thread_t			bstp_task_thread;
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(bstp_task_queue, bstp_task) 
						bstp_task_queue = TAILQ_HEAD_INITIALIZER(bstp_task_queue);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> bstp_task *bstp_task_queue_running = NULL;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bstp_create_task_thread</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bstp_task_thread_func</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bstp_task_enqueue</span>(<span class="enscript-type">struct</span> bstp_task *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bstp_task_drain</span>(<span class="enscript-type">struct</span> bstp_task *);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">BSTP_TASK_INIT</span>(bt, func, context) do { \
	(bt)-&gt;bt_count = 0; \
	(bt)-&gt;bt_func = func; \
	(bt)-&gt;bt_context = context; \
} <span class="enscript-keyword">while</span>(0)



#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BSTP_LOCK_INIT</span>(_bs)		(_bs)-&gt;bs_mtx = lck_mtx_alloc_init(bstp_lock_grp, bstp_lock_attr)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BSTP_LOCK_DESTROY</span>(_bs)	lck_mtx_free((_bs)-&gt;bs_mtx, bstp_lock_grp)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BSTP_LOCK</span>(_bs)			lck_mtx_lock((_bs)-&gt;bs_mtx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BSTP_UNLOCK</span>(_bs)		lck_mtx_unlock((_bs)-&gt;bs_mtx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BSTP_LOCK_ASSERT</span>(_bs)	lck_mtx_assert((_bs)-&gt;bs_mtx, LCK_MTX_ASSERT_OWNED)


#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">BRIDGESTP_DEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DPRINTF</span>(fmt, arg...)	printf(<span class="enscript-string">&quot;bstp: &quot;</span> fmt, ##arg)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DPRINTF</span>(fmt, arg...)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PV2ADDR</span>(pv, eaddr)	do {		\
	eaddr[0] = pv &gt;&gt; 40;			\
	eaddr[1] = pv &gt;&gt; 32;			\
	eaddr[2] = pv &gt;&gt; 24;			\
	eaddr[3] = pv &gt;&gt; 16;			\
	eaddr[4] = pv &gt;&gt; 8;			\
	eaddr[5] = pv &gt;&gt; 0;			\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INFO_BETTER</span>	1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INFO_SAME</span>	0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INFO_WORSE</span>	-1

<span class="enscript-function-name">LIST_HEAD</span>(, bstp_state) bstp_list;
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, bstp_list_mtx_data);
<span class="enscript-type">static</span> lck_mtx_t		*bstp_list_mtx = &amp;bstp_list_mtx_data;
<span class="enscript-type">static</span> lck_grp_t 		*bstp_lock_grp = NULL;
<span class="enscript-type">static</span> lck_attr_t 		*bstp_lock_attr = NULL;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_transmit(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_transmit_bpdu(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_transmit_tcn(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_decode_bpdu(<span class="enscript-type">struct</span> bstp_port *, <span class="enscript-type">struct</span> bstp_cbpdu *,
		    <span class="enscript-type">struct</span> bstp_config_unit *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_send_bpdu(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *,
		    <span class="enscript-type">struct</span> bstp_cbpdu *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_enqueue(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bstp_pdu_flags(<span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_received_stp(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *,
		    <span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> bstp_tbpdu *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_received_rstp(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *,
		    <span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> bstp_tbpdu *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_received_tcn(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *,
		    <span class="enscript-type">struct</span> bstp_tcn_unit *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_received_bpdu(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *,
		    <span class="enscript-type">struct</span> bstp_config_unit *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bstp_pdu_rcvtype(<span class="enscript-type">struct</span> bstp_port *, <span class="enscript-type">struct</span> bstp_config_unit *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bstp_pdu_bettersame(<span class="enscript-type">struct</span> bstp_port *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bstp_info_cmp(<span class="enscript-type">struct</span> bstp_pri_vector *,
		    <span class="enscript-type">struct</span> bstp_pri_vector *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bstp_info_superior(<span class="enscript-type">struct</span> bstp_pri_vector *,
		    <span class="enscript-type">struct</span> bstp_pri_vector *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_assign_roles(<span class="enscript-type">struct</span> bstp_state *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_update_roles(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_update_state(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_update_tc(<span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_update_info(<span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_set_other_tcprop(<span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_set_all_reroot(<span class="enscript-type">struct</span> bstp_state *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_set_all_sync(<span class="enscript-type">struct</span> bstp_state *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_set_port_state(<span class="enscript-type">struct</span> bstp_port *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_set_port_role(<span class="enscript-type">struct</span> bstp_port *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_set_port_proto(<span class="enscript-type">struct</span> bstp_port *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_set_port_tc(<span class="enscript-type">struct</span> bstp_port *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_set_timer_tc(<span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_set_timer_msgage(<span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bstp_rerooted(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> uint32_t	bstp_calc_path_cost(<span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_notify_state(<span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_notify_rtage(<span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_ifupdstatus(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_enable_port(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_disable_port(<span class="enscript-type">struct</span> bstp_state *, <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_tick(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_timer_start(<span class="enscript-type">struct</span> bstp_timer *, uint16_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_timer_stop(<span class="enscript-type">struct</span> bstp_timer *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_timer_latch(<span class="enscript-type">struct</span> bstp_timer *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bstp_timer_expired(<span class="enscript-type">struct</span> bstp_timer *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_hello_timer_expiry(<span class="enscript-type">struct</span> bstp_state *,
		    <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_message_age_expiry(<span class="enscript-type">struct</span> bstp_state *,
		    <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_migrate_delay_expiry(<span class="enscript-type">struct</span> bstp_state *,
		    <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_edge_delay_expiry(<span class="enscript-type">struct</span> bstp_state *,
		    <span class="enscript-type">struct</span> bstp_port *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bstp_addr_cmp(<span class="enscript-type">const</span> uint8_t *, <span class="enscript-type">const</span> uint8_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bstp_same_bridgeid(uint64_t, uint64_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bstp_reinit(<span class="enscript-type">struct</span> bstp_state *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_transmit</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-keyword">if</span> (bs-&gt;bs_running == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * a PDU can only be sent if we have tx quota left and the
	 * hello timer is running.
	 */</span>
	<span class="enscript-keyword">if</span> (bp-&gt;bp_hello_timer.active == 0) {
		<span class="enscript-comment">/* Test if it needs to be reset */</span>
		bstp_hello_timer_expiry(bs, bp);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (bp-&gt;bp_txcount &gt; bs-&gt;bs_txholdcount)
		<span class="enscript-comment">/* Ran out of karma */</span>
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (bp-&gt;bp_protover == BSTP_PROTO_RSTP) {
		bstp_transmit_bpdu(bs, bp);
		bp-&gt;bp_tc_ack = 0;
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* STP */</span>
		<span class="enscript-keyword">switch</span> (bp-&gt;bp_role) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_DESIGNATED</span>:
				bstp_transmit_bpdu(bs, bp);
				bp-&gt;bp_tc_ack = 0;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_ROOT</span>:
				bstp_transmit_tcn(bs, bp);
				<span class="enscript-keyword">break</span>;
		}
	}
	bstp_timer_start(&amp;bp-&gt;bp_hello_timer, bp-&gt;bp_desg_htime);
	bp-&gt;bp_flags &amp;= ~BSTP_PORT_NEWINFO;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_transmit_bpdu</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-type">struct</span> bstp_cbpdu bpdu;

	BSTP_LOCK_ASSERT(bs);

	bpdu.cbu_rootpri = htons(bp-&gt;bp_desg_pv.pv_root_id &gt;&gt; 48);
	PV2ADDR(bp-&gt;bp_desg_pv.pv_root_id, bpdu.cbu_rootaddr);

	bpdu.cbu_rootpathcost = htonl(bp-&gt;bp_desg_pv.pv_cost);

	bpdu.cbu_bridgepri = htons(bp-&gt;bp_desg_pv.pv_dbridge_id &gt;&gt; 48);
	PV2ADDR(bp-&gt;bp_desg_pv.pv_dbridge_id, bpdu.cbu_bridgeaddr);

	bpdu.cbu_portid = htons(bp-&gt;bp_port_id);
	bpdu.cbu_messageage = htons(bp-&gt;bp_desg_msg_age);
	bpdu.cbu_maxage = htons(bp-&gt;bp_desg_max_age);
	bpdu.cbu_hellotime = htons(bp-&gt;bp_desg_htime);
	bpdu.cbu_forwarddelay = htons(bp-&gt;bp_desg_fdelay);

	bpdu.cbu_flags = bstp_pdu_flags(bp);

	<span class="enscript-keyword">switch</span> (bp-&gt;bp_protover) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_STP</span>:
			bpdu.cbu_bpdutype = BSTP_MSGTYPE_CFG;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_RSTP</span>:
			bpdu.cbu_bpdutype = BSTP_MSGTYPE_RSTP;
			<span class="enscript-keyword">break</span>;
	}

	bstp_send_bpdu(bs, bp, &amp;bpdu);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_transmit_tcn</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-type">struct</span> bstp_tbpdu bpdu;
	<span class="enscript-type">struct</span> ifnet *ifp = bp-&gt;bp_ifp;
	<span class="enscript-type">struct</span> ether_header *eh;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> touched = bs ? 1 : 0;
	
	touched++;

	KASSERT(bp == bs-&gt;bs_root_port, (<span class="enscript-string">&quot;%s: bad root port\n&quot;</span>, __func__));

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_RUNNING) == 0)
		<span class="enscript-keyword">return</span>;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span>;

	m-&gt;m_pkthdr.rcvif = ifp;
	m-&gt;m_pkthdr.len = <span class="enscript-keyword">sizeof</span>(*eh) + <span class="enscript-keyword">sizeof</span>(bpdu);
	m-&gt;m_len = m-&gt;m_pkthdr.len;

	eh = mtod(m, <span class="enscript-type">struct</span> ether_header *);

	memcpy(eh-&gt;ether_shost, IF_LLADDR(ifp), ETHER_ADDR_LEN);
	memcpy(eh-&gt;ether_dhost, bstp_etheraddr, ETHER_ADDR_LEN);
	eh-&gt;ether_type = htons(<span class="enscript-keyword">sizeof</span>(bpdu));

	bpdu.tbu_ssap = bpdu.tbu_dsap = LLC_8021D_LSAP;
	bpdu.tbu_ctl = LLC_UI;
	bpdu.tbu_protoid = 0;
	bpdu.tbu_protover = 0;
	bpdu.tbu_bpdutype = BSTP_MSGTYPE_TCN;

	memcpy(mtod(m, caddr_t) + <span class="enscript-keyword">sizeof</span>(*eh), &amp;bpdu, <span class="enscript-keyword">sizeof</span>(bpdu));

	bp-&gt;bp_txcount++;
	bstp_enqueue(ifp, m);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_decode_bpdu</span>(<span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">struct</span> bstp_cbpdu *cpdu,
    <span class="enscript-type">struct</span> bstp_config_unit *cu)
{
	<span class="enscript-type">int</span> flags;

	cu-&gt;cu_pv.pv_root_id =
	    (((uint64_t)ntohs(cpdu-&gt;cbu_rootpri)) &lt;&lt; 48) |
	    (((uint64_t)cpdu-&gt;cbu_rootaddr[0]) &lt;&lt; 40) |
	    (((uint64_t)cpdu-&gt;cbu_rootaddr[1]) &lt;&lt; 32) |
	    (((uint64_t)cpdu-&gt;cbu_rootaddr[2]) &lt;&lt; 24) |
	    (((uint64_t)cpdu-&gt;cbu_rootaddr[3]) &lt;&lt; 16) |
	    (((uint64_t)cpdu-&gt;cbu_rootaddr[4]) &lt;&lt; 8) |
	    (((uint64_t)cpdu-&gt;cbu_rootaddr[5]) &lt;&lt; 0);

	cu-&gt;cu_pv.pv_dbridge_id =
	    (((uint64_t)ntohs(cpdu-&gt;cbu_bridgepri)) &lt;&lt; 48) |
	    (((uint64_t)cpdu-&gt;cbu_bridgeaddr[0]) &lt;&lt; 40) |
	    (((uint64_t)cpdu-&gt;cbu_bridgeaddr[1]) &lt;&lt; 32) |
	    (((uint64_t)cpdu-&gt;cbu_bridgeaddr[2]) &lt;&lt; 24) |
	    (((uint64_t)cpdu-&gt;cbu_bridgeaddr[3]) &lt;&lt; 16) |
	    (((uint64_t)cpdu-&gt;cbu_bridgeaddr[4]) &lt;&lt; 8) |
	    (((uint64_t)cpdu-&gt;cbu_bridgeaddr[5]) &lt;&lt; 0);

	cu-&gt;cu_pv.pv_cost = ntohl(cpdu-&gt;cbu_rootpathcost);
	cu-&gt;cu_message_age = ntohs(cpdu-&gt;cbu_messageage);
	cu-&gt;cu_max_age = ntohs(cpdu-&gt;cbu_maxage);
	cu-&gt;cu_hello_time = ntohs(cpdu-&gt;cbu_hellotime);
	cu-&gt;cu_forward_delay = ntohs(cpdu-&gt;cbu_forwarddelay);
	cu-&gt;cu_pv.pv_dport_id = ntohs(cpdu-&gt;cbu_portid);
	cu-&gt;cu_pv.pv_port_id = bp-&gt;bp_port_id;
	cu-&gt;cu_message_type = cpdu-&gt;cbu_bpdutype;

	<span class="enscript-comment">/* Strip off unused flags in STP mode */</span>
	flags = cpdu-&gt;cbu_flags;
	<span class="enscript-keyword">switch</span> (cpdu-&gt;cbu_protover) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_STP</span>:
			flags &amp;= BSTP_PDU_STPMASK;
			<span class="enscript-comment">/* A STP BPDU explicitly conveys a Designated Port */</span>
			cu-&gt;cu_role = BSTP_ROLE_DESIGNATED;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_RSTP</span>:
			flags &amp;= BSTP_PDU_RSTPMASK;
			<span class="enscript-keyword">break</span>;
	}

	cu-&gt;cu_topology_change_ack =
		(flags &amp; BSTP_PDU_F_TCA) ? 1 : 0;
	cu-&gt;cu_proposal =
		(flags &amp; BSTP_PDU_F_P) ? 1 : 0;
	cu-&gt;cu_agree =
		(flags &amp; BSTP_PDU_F_A) ? 1 : 0;
	cu-&gt;cu_learning =
		(flags &amp; BSTP_PDU_F_L) ? 1 : 0;
	cu-&gt;cu_forwarding =
		(flags &amp; BSTP_PDU_F_F) ? 1 : 0;
	cu-&gt;cu_topology_change =
		(flags &amp; BSTP_PDU_F_TC) ? 1 : 0;

	<span class="enscript-keyword">switch</span> ((flags &amp; BSTP_PDU_PRMASK) &gt;&gt; BSTP_PDU_PRSHIFT) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PDU_F_ROOT</span>:
			cu-&gt;cu_role = BSTP_ROLE_ROOT;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PDU_F_ALT</span>:
			cu-&gt;cu_role = BSTP_ROLE_ALTERNATE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PDU_F_DESG</span>:
			cu-&gt;cu_role = BSTP_ROLE_DESIGNATED;
			<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_send_bpdu</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp,
    <span class="enscript-type">struct</span> bstp_cbpdu *bpdu)
{
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> ether_header *eh;

	BSTP_LOCK_ASSERT(bs);

	ifp = bp-&gt;bp_ifp;

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_RUNNING) == 0)
		<span class="enscript-keyword">return</span>;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span>;

	eh = mtod(m, <span class="enscript-type">struct</span> ether_header *);

	bpdu-&gt;cbu_ssap = bpdu-&gt;cbu_dsap = LLC_8021D_LSAP;
	bpdu-&gt;cbu_ctl = LLC_UI;
	bpdu-&gt;cbu_protoid = htons(BSTP_PROTO_ID);

	memcpy(eh-&gt;ether_shost, IF_LLADDR(ifp), ETHER_ADDR_LEN);
	memcpy(eh-&gt;ether_dhost, bstp_etheraddr, ETHER_ADDR_LEN);

	<span class="enscript-keyword">switch</span> (bpdu-&gt;cbu_bpdutype) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_MSGTYPE_CFG</span>:
			bpdu-&gt;cbu_protover = BSTP_PROTO_STP;
			m-&gt;m_pkthdr.len = <span class="enscript-keyword">sizeof</span>(*eh) + BSTP_BPDU_STP_LEN;
			eh-&gt;ether_type = htons(BSTP_BPDU_STP_LEN);
			memcpy(mtod(m, caddr_t) + <span class="enscript-keyword">sizeof</span>(*eh), bpdu,
			    BSTP_BPDU_STP_LEN);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_MSGTYPE_RSTP</span>:
			bpdu-&gt;cbu_protover = BSTP_PROTO_RSTP;
			bpdu-&gt;cbu_versionlen = htons(0);
			m-&gt;m_pkthdr.len = <span class="enscript-keyword">sizeof</span>(*eh) + BSTP_BPDU_RSTP_LEN;
			eh-&gt;ether_type = htons(BSTP_BPDU_RSTP_LEN);
			memcpy(mtod(m, caddr_t) + <span class="enscript-keyword">sizeof</span>(*eh), bpdu,
			    BSTP_BPDU_RSTP_LEN);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;not implemented&quot;</span>);
	}
	m-&gt;m_pkthdr.rcvif = ifp;
	m-&gt;m_len = m-&gt;m_pkthdr.len;

	bp-&gt;bp_txcount++;
	bstp_enqueue(ifp, m);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_enqueue</span>(<span class="enscript-type">struct</span> ifnet *dst_ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	errno_t error = 0;
	u_int32_t len = m-&gt;m_pkthdr.len;
	
	m-&gt;m_flags |= M_PROTO1; <span class="enscript-comment">//set to avoid loops 
</span>	
	error = ifnet_output_raw(dst_ifp, 0, m);
	<span class="enscript-keyword">if</span> (error == 0) {
		(<span class="enscript-type">void</span>) ifnet_stat_increment_out(dst_ifp, 1, len, 0);
	} <span class="enscript-keyword">else</span> {
		(<span class="enscript-type">void</span>) ifnet_stat_increment_out(dst_ifp, 0, 0, 1);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_pdu_flags</span>(<span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-type">int</span> flags = 0;

	<span class="enscript-keyword">if</span> (bp-&gt;bp_proposing &amp;&amp; bp-&gt;bp_state != BSTP_IFSTATE_FORWARDING)
		flags |= BSTP_PDU_F_P;

	<span class="enscript-keyword">if</span> (bp-&gt;bp_agree)
		flags |= BSTP_PDU_F_A;

	<span class="enscript-keyword">if</span> (bp-&gt;bp_tc_timer.active)
		flags |= BSTP_PDU_F_TC;

	<span class="enscript-keyword">if</span> (bp-&gt;bp_tc_ack)
		flags |= BSTP_PDU_F_TCA;

	<span class="enscript-keyword">switch</span> (bp-&gt;bp_state) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_IFSTATE_LEARNING</span>:
			flags |= BSTP_PDU_F_L;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_IFSTATE_FORWARDING</span>:
			flags |= (BSTP_PDU_F_L | BSTP_PDU_F_F);
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">switch</span> (bp-&gt;bp_role) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_ROOT</span>:
			flags |=
				(BSTP_PDU_F_ROOT &lt;&lt; BSTP_PDU_PRSHIFT);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_ALTERNATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_BACKUP</span>:	<span class="enscript-comment">/* fall through */</span>
			flags |=
				(BSTP_PDU_F_ALT &lt;&lt; BSTP_PDU_PRSHIFT);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_DESIGNATED</span>:
			flags |=
				(BSTP_PDU_F_DESG &lt;&lt; BSTP_PDU_PRSHIFT);
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* Strip off unused flags in either mode */</span>
	<span class="enscript-keyword">switch</span> (bp-&gt;bp_protover) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_STP</span>:
			flags &amp;= BSTP_PDU_STPMASK;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_RSTP</span>:
			flags &amp;= BSTP_PDU_RSTPMASK;
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (flags);
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">bstp_input</span>(<span class="enscript-type">struct</span> bstp_port *bp, __unused <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;
	<span class="enscript-type">struct</span> ether_header *eh;
	<span class="enscript-type">struct</span> bstp_tbpdu tpdu;
	uint16_t len;

	<span class="enscript-keyword">if</span> (bp-&gt;bp_active == 0) {
		m_freem(m);
		<span class="enscript-keyword">return</span> (NULL);
	}

	BSTP_LOCK(bs);

	eh = mtod(m, <span class="enscript-type">struct</span> ether_header *);

	len = ntohs(eh-&gt;ether_type);
	<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(tpdu))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	m_adj(m, ETHER_HDR_LEN);

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &gt; len)
		m_adj(m, len - m-&gt;m_pkthdr.len);
	<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(tpdu) &amp;&amp;
	    (m = m_pullup(m, <span class="enscript-keyword">sizeof</span>(tpdu))) == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	memcpy(&amp;tpdu, mtod(m, caddr_t), <span class="enscript-keyword">sizeof</span>(tpdu));

	<span class="enscript-comment">/* basic packet checks */</span>
	<span class="enscript-keyword">if</span> (tpdu.tbu_dsap != LLC_8021D_LSAP ||
	    tpdu.tbu_ssap != LLC_8021D_LSAP ||
	    tpdu.tbu_ctl != LLC_UI)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> (tpdu.tbu_protoid != BSTP_PROTO_ID)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * We can treat later versions of the PDU as the same as the maximum
	 * version we implement. All additional parameters/flags are ignored.
	 */</span>
	<span class="enscript-keyword">if</span> (tpdu.tbu_protover &gt; BSTP_PROTO_MAX)
		tpdu.tbu_protover = BSTP_PROTO_MAX;

	<span class="enscript-keyword">if</span> (tpdu.tbu_protover != bp-&gt;bp_protover) {
		<span class="enscript-comment">/*
		 * Wait for the migration delay timer to expire before changing
		 * protocol version to avoid flip-flops.
		 */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;bp_flags &amp; BSTP_PORT_CANMIGRATE)
			bstp_set_port_proto(bp, tpdu.tbu_protover);
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Clear operedge upon receiving a PDU on the port */</span>
	bp-&gt;bp_operedge = 0;
	bstp_timer_start(&amp;bp-&gt;bp_edge_delay_timer,
	    BSTP_DEFAULT_MIGRATE_DELAY);

	<span class="enscript-keyword">switch</span> (tpdu.tbu_protover) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_STP</span>:
			bstp_received_stp(bs, bp, &amp;m, &amp;tpdu);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_RSTP</span>:
			bstp_received_rstp(bs, bp, &amp;m, &amp;tpdu);
			<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">out</span>:
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">if</span> (m)
		m_freem(m);
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_received_stp</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp,
    <span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">struct</span> bstp_tbpdu *tpdu)
{
	<span class="enscript-type">struct</span> bstp_cbpdu cpdu;
	<span class="enscript-type">struct</span> bstp_config_unit *cu = &amp;bp-&gt;bp_msg_cu;
	<span class="enscript-type">struct</span> bstp_tcn_unit tu;

	<span class="enscript-keyword">switch</span> (tpdu-&gt;tbu_bpdutype) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_MSGTYPE_TCN</span>:
		tu.tu_message_type = tpdu-&gt;tbu_bpdutype;
		bstp_received_tcn(bs, bp, &amp;tu);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_MSGTYPE_CFG</span>:
		<span class="enscript-keyword">if</span> ((*mp)-&gt;m_len &lt; BSTP_BPDU_STP_LEN &amp;&amp;
		    (*mp = m_pullup(*mp, BSTP_BPDU_STP_LEN)) == NULL)
			<span class="enscript-keyword">return</span>;
		memcpy(&amp;cpdu, mtod(*mp, caddr_t), BSTP_BPDU_STP_LEN);

		bstp_decode_bpdu(bp, &amp;cpdu, cu);
		bstp_received_bpdu(bs, bp, cu);
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_received_rstp</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp,
    <span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">struct</span> bstp_tbpdu *tpdu)
{
	<span class="enscript-type">struct</span> bstp_cbpdu cpdu;
	<span class="enscript-type">struct</span> bstp_config_unit *cu = &amp;bp-&gt;bp_msg_cu;

	<span class="enscript-keyword">if</span> (tpdu-&gt;tbu_bpdutype != BSTP_MSGTYPE_RSTP)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ((*mp)-&gt;m_len &lt; BSTP_BPDU_RSTP_LEN &amp;&amp;
	    (*mp = m_pullup(*mp, BSTP_BPDU_RSTP_LEN)) == NULL)
		<span class="enscript-keyword">return</span>;
	memcpy(&amp;cpdu, mtod(*mp, caddr_t), BSTP_BPDU_RSTP_LEN);

	bstp_decode_bpdu(bp, &amp;cpdu, cu);
	bstp_received_bpdu(bs, bp, cu);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_received_tcn</span>(__unused <span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp,
    __unused <span class="enscript-type">struct</span> bstp_tcn_unit *tcn)
{
	bp-&gt;bp_rcvdtcn = 1;
	bstp_update_tc(bp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_received_bpdu</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp,
    <span class="enscript-type">struct</span> bstp_config_unit *cu)
{
	<span class="enscript-type">int</span> type;

	BSTP_LOCK_ASSERT(bs);

	<span class="enscript-comment">/* We need to have transitioned to INFO_MINE before proceeding */</span>
	<span class="enscript-keyword">switch</span> (bp-&gt;bp_infois) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_INFO_DISABLED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_INFO_AGED</span>:
			<span class="enscript-keyword">return</span>;
	}

	type = bstp_pdu_rcvtype(bp, cu);

	<span class="enscript-keyword">switch</span> (type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PDU_SUPERIOR</span>:
			bs-&gt;bs_allsynced = 0;
			bp-&gt;bp_agreed = 0;
			bp-&gt;bp_proposing = 0;

			<span class="enscript-keyword">if</span> (cu-&gt;cu_proposal &amp;&amp; cu-&gt;cu_forwarding == 0)
				bp-&gt;bp_proposed = 1;
			<span class="enscript-keyword">if</span> (cu-&gt;cu_topology_change)
				bp-&gt;bp_rcvdtc = 1;
			<span class="enscript-keyword">if</span> (cu-&gt;cu_topology_change_ack)
				bp-&gt;bp_rcvdtca = 1;

			<span class="enscript-keyword">if</span> (bp-&gt;bp_agree &amp;&amp;
			    !bstp_pdu_bettersame(bp, BSTP_INFO_RECEIVED))
				bp-&gt;bp_agree = 0;

			<span class="enscript-comment">/* copy the received priority and timers to the port */</span>
			bp-&gt;bp_port_pv = cu-&gt;cu_pv;
			bp-&gt;bp_port_msg_age = cu-&gt;cu_message_age;
			bp-&gt;bp_port_max_age = cu-&gt;cu_max_age;
			bp-&gt;bp_port_fdelay = cu-&gt;cu_forward_delay;
			bp-&gt;bp_port_htime =
				(cu-&gt;cu_hello_time &gt; BSTP_MIN_HELLO_TIME ?
				 cu-&gt;cu_hello_time : BSTP_MIN_HELLO_TIME);

			<span class="enscript-comment">/* set expiry for the new info */</span>
			bstp_set_timer_msgage(bp);

			bp-&gt;bp_infois = BSTP_INFO_RECEIVED;
			bstp_assign_roles(bs);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PDU_REPEATED</span>:
			<span class="enscript-keyword">if</span> (cu-&gt;cu_proposal &amp;&amp; cu-&gt;cu_forwarding == 0)
				bp-&gt;bp_proposed = 1;
			<span class="enscript-keyword">if</span> (cu-&gt;cu_topology_change)
				bp-&gt;bp_rcvdtc = 1;
			<span class="enscript-keyword">if</span> (cu-&gt;cu_topology_change_ack)
				bp-&gt;bp_rcvdtca = 1;

			<span class="enscript-comment">/* rearm the age timer */</span>
			bstp_set_timer_msgage(bp);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PDU_INFERIOR</span>:
			<span class="enscript-keyword">if</span> (cu-&gt;cu_learning) {
				bp-&gt;bp_agreed = 1;
				bp-&gt;bp_proposing = 0;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PDU_INFERIORALT</span>:
			<span class="enscript-comment">/*
			 * only point to point links are allowed fast
			 * transitions to forwarding.
			 */</span>
			<span class="enscript-keyword">if</span> (cu-&gt;cu_agree &amp;&amp; bp-&gt;bp_ptp_link) {
				bp-&gt;bp_agreed = 1;
				bp-&gt;bp_proposing = 0;
			} <span class="enscript-keyword">else</span>
				bp-&gt;bp_agreed = 0;

			<span class="enscript-keyword">if</span> (cu-&gt;cu_topology_change)
				bp-&gt;bp_rcvdtc = 1;
			<span class="enscript-keyword">if</span> (cu-&gt;cu_topology_change_ack)
				bp-&gt;bp_rcvdtca = 1;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PDU_OTHER</span>:
			<span class="enscript-keyword">return</span>;	<span class="enscript-comment">/* do nothing */</span>
	}
	<span class="enscript-comment">/* update the state machines with the new data */</span>
	bstp_update_state(bs, bp);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_pdu_rcvtype</span>(<span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">struct</span> bstp_config_unit *cu)
{
	<span class="enscript-type">int</span> type;

	<span class="enscript-comment">/* default return type */</span>
	type = BSTP_PDU_OTHER;

	<span class="enscript-keyword">switch</span> (cu-&gt;cu_role) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_DESIGNATED</span>:
		<span class="enscript-keyword">if</span> (bstp_info_superior(&amp;bp-&gt;bp_port_pv, &amp;cu-&gt;cu_pv))
			<span class="enscript-comment">/* bpdu priority is superior */</span>
			type = BSTP_PDU_SUPERIOR;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bstp_info_cmp(&amp;bp-&gt;bp_port_pv, &amp;cu-&gt;cu_pv) ==
		    INFO_SAME) {
			<span class="enscript-keyword">if</span> (bp-&gt;bp_port_msg_age != cu-&gt;cu_message_age ||
			    bp-&gt;bp_port_max_age != cu-&gt;cu_max_age ||
			    bp-&gt;bp_port_fdelay != cu-&gt;cu_forward_delay ||
			    bp-&gt;bp_port_htime != cu-&gt;cu_hello_time)
				<span class="enscript-comment">/* bpdu priority is equal and timers differ */</span>
				type = BSTP_PDU_SUPERIOR;
			<span class="enscript-keyword">else</span>
				<span class="enscript-comment">/* bpdu is equal */</span>
				type = BSTP_PDU_REPEATED;
		} <span class="enscript-keyword">else</span>
			<span class="enscript-comment">/* bpdu priority is worse */</span>
			type = BSTP_PDU_INFERIOR;

		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_ROOT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_ALTERNATE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_BACKUP</span>:
		<span class="enscript-keyword">if</span> (bstp_info_cmp(&amp;bp-&gt;bp_port_pv, &amp;cu-&gt;cu_pv) &lt;= INFO_SAME)
			<span class="enscript-comment">/*
			 * not a designated port and priority is the same or
			 * worse
			 */</span>
			type = BSTP_PDU_INFERIORALT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (type);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_pdu_bettersame</span>(<span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">int</span> newinfo)
{
	<span class="enscript-keyword">if</span> (newinfo == BSTP_INFO_RECEIVED &amp;&amp;
	    bp-&gt;bp_infois == BSTP_INFO_RECEIVED &amp;&amp;
	    bstp_info_cmp(&amp;bp-&gt;bp_port_pv, &amp;bp-&gt;bp_msg_cu.cu_pv) &gt;= INFO_SAME)
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">if</span> (newinfo == BSTP_INFO_MINE &amp;&amp;
	    bp-&gt;bp_infois == BSTP_INFO_MINE &amp;&amp;
	    bstp_info_cmp(&amp;bp-&gt;bp_port_pv, &amp;bp-&gt;bp_desg_pv) &gt;= INFO_SAME)
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_info_cmp</span>(<span class="enscript-type">struct</span> bstp_pri_vector *pv,
    <span class="enscript-type">struct</span> bstp_pri_vector *cpv)
{
	<span class="enscript-keyword">if</span> (cpv-&gt;pv_root_id &lt; pv-&gt;pv_root_id)
		<span class="enscript-keyword">return</span> (INFO_BETTER);
	<span class="enscript-keyword">if</span> (cpv-&gt;pv_root_id &gt; pv-&gt;pv_root_id)
		<span class="enscript-keyword">return</span> (INFO_WORSE);

	<span class="enscript-keyword">if</span> (cpv-&gt;pv_cost &lt; pv-&gt;pv_cost)
		<span class="enscript-keyword">return</span> (INFO_BETTER);
	<span class="enscript-keyword">if</span> (cpv-&gt;pv_cost &gt; pv-&gt;pv_cost)
		<span class="enscript-keyword">return</span> (INFO_WORSE);

	<span class="enscript-keyword">if</span> (cpv-&gt;pv_dbridge_id &lt; pv-&gt;pv_dbridge_id)
		<span class="enscript-keyword">return</span> (INFO_BETTER);
	<span class="enscript-keyword">if</span> (cpv-&gt;pv_dbridge_id &gt; pv-&gt;pv_dbridge_id)
		<span class="enscript-keyword">return</span> (INFO_WORSE);

	<span class="enscript-keyword">if</span> (cpv-&gt;pv_dport_id &lt; pv-&gt;pv_dport_id)
		<span class="enscript-keyword">return</span> (INFO_BETTER);
	<span class="enscript-keyword">if</span> (cpv-&gt;pv_dport_id &gt; pv-&gt;pv_dport_id)
		<span class="enscript-keyword">return</span> (INFO_WORSE);

	<span class="enscript-keyword">return</span> (INFO_SAME);
}

<span class="enscript-comment">/*
 * This message priority vector is superior to the port priority vector and
 * will replace it if, and only if, the message priority vector is better than
 * the port priority vector, or the message has been transmitted from the same
 * designated bridge and designated port as the port priority vector.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_info_superior</span>(<span class="enscript-type">struct</span> bstp_pri_vector *pv,
    <span class="enscript-type">struct</span> bstp_pri_vector *cpv)
{
	<span class="enscript-keyword">if</span> (bstp_info_cmp(pv, cpv) == INFO_BETTER ||
	    (bstp_same_bridgeid(pv-&gt;pv_dbridge_id, cpv-&gt;pv_dbridge_id) &amp;&amp;
	    (cpv-&gt;pv_dport_id &amp; 0xfff) == (pv-&gt;pv_dport_id &amp; 0xfff)))
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_assign_roles</span>(<span class="enscript-type">struct</span> bstp_state *bs)
{
	<span class="enscript-type">struct</span> bstp_port *bp, *rbp = NULL;
	<span class="enscript-type">struct</span> bstp_pri_vector pv;

	<span class="enscript-comment">/* default to our priority vector */</span>
	bs-&gt;bs_root_pv = bs-&gt;bs_bridge_pv;
	bs-&gt;bs_root_msg_age = 0;
	bs-&gt;bs_root_max_age = bs-&gt;bs_bridge_max_age;
	bs-&gt;bs_root_fdelay = bs-&gt;bs_bridge_fdelay;
	bs-&gt;bs_root_htime = bs-&gt;bs_bridge_htime;
	bs-&gt;bs_root_port = NULL;

	<span class="enscript-comment">/* check if any recieved info supersedes us */</span>
	LIST_FOREACH(bp, &amp;bs-&gt;bs_bplist, bp_next) {
		<span class="enscript-keyword">if</span> (bp-&gt;bp_infois != BSTP_INFO_RECEIVED)
			<span class="enscript-keyword">continue</span>;

		pv = bp-&gt;bp_port_pv;
		pv.pv_cost += bp-&gt;bp_path_cost;

		<span class="enscript-comment">/*
		 * The root priority vector is the best of the set comprising
		 * the bridge priority vector plus all root path priority
		 * vectors whose bridge address is not equal to us.
		 */</span>
		<span class="enscript-keyword">if</span> (bstp_same_bridgeid(pv.pv_dbridge_id,
		    bs-&gt;bs_bridge_pv.pv_dbridge_id) == 0 &amp;&amp;
		    bstp_info_cmp(&amp;bs-&gt;bs_root_pv, &amp;pv) == INFO_BETTER) {
			<span class="enscript-comment">/* the port vector replaces the root */</span>
			bs-&gt;bs_root_pv = pv;
			bs-&gt;bs_root_msg_age = bp-&gt;bp_port_msg_age +
			    BSTP_MESSAGE_AGE_INCR;
			bs-&gt;bs_root_max_age = bp-&gt;bp_port_max_age;
			bs-&gt;bs_root_fdelay = bp-&gt;bp_port_fdelay;
			bs-&gt;bs_root_htime = bp-&gt;bp_port_htime;
			rbp = bp;
		}
	}

	LIST_FOREACH(bp, &amp;bs-&gt;bs_bplist, bp_next) {
		<span class="enscript-comment">/* calculate the port designated vector */</span>
		bp-&gt;bp_desg_pv.pv_root_id = bs-&gt;bs_root_pv.pv_root_id;
		bp-&gt;bp_desg_pv.pv_cost = bs-&gt;bs_root_pv.pv_cost;
		bp-&gt;bp_desg_pv.pv_dbridge_id = bs-&gt;bs_bridge_pv.pv_dbridge_id;
		bp-&gt;bp_desg_pv.pv_dport_id = bp-&gt;bp_port_id;
		bp-&gt;bp_desg_pv.pv_port_id = bp-&gt;bp_port_id;

		<span class="enscript-comment">/* calculate designated times */</span>
		bp-&gt;bp_desg_msg_age = bs-&gt;bs_root_msg_age;
		bp-&gt;bp_desg_max_age = bs-&gt;bs_root_max_age;
		bp-&gt;bp_desg_fdelay = bs-&gt;bs_root_fdelay;
		bp-&gt;bp_desg_htime = bs-&gt;bs_bridge_htime;


		<span class="enscript-keyword">switch</span> (bp-&gt;bp_infois) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_INFO_DISABLED</span>:
			bstp_set_port_role(bp, BSTP_ROLE_DISABLED);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_INFO_AGED</span>:
			bstp_set_port_role(bp, BSTP_ROLE_DESIGNATED);
			bstp_update_info(bp);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_INFO_MINE</span>:
			bstp_set_port_role(bp, BSTP_ROLE_DESIGNATED);
			<span class="enscript-comment">/* update the port info if stale */</span>
			<span class="enscript-keyword">if</span> (bstp_info_cmp(&amp;bp-&gt;bp_port_pv,
			    &amp;bp-&gt;bp_desg_pv) != INFO_SAME ||
			    (rbp != NULL &amp;&amp;
			    (bp-&gt;bp_port_msg_age != rbp-&gt;bp_port_msg_age ||
			    bp-&gt;bp_port_max_age != rbp-&gt;bp_port_max_age ||
			    bp-&gt;bp_port_fdelay != rbp-&gt;bp_port_fdelay ||
			    bp-&gt;bp_port_htime != rbp-&gt;bp_port_htime)))
				bstp_update_info(bp);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_INFO_RECEIVED</span>:
			<span class="enscript-keyword">if</span> (bp == rbp) {
				<span class="enscript-comment">/*
				 * root priority is derived from this
				 * port, make it the root port.
				 */</span>
				bstp_set_port_role(bp, BSTP_ROLE_ROOT);
				bs-&gt;bs_root_port = bp;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bstp_info_cmp(&amp;bp-&gt;bp_port_pv,
				    &amp;bp-&gt;bp_desg_pv) == INFO_BETTER) {
				<span class="enscript-comment">/*
				 * the port priority is lower than the root
				 * port.
				 */</span>
				bstp_set_port_role(bp, BSTP_ROLE_DESIGNATED);
				bstp_update_info(bp);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (bstp_same_bridgeid(
				    bp-&gt;bp_port_pv.pv_dbridge_id,
				    bs-&gt;bs_bridge_pv.pv_dbridge_id)) {
					<span class="enscript-comment">/*
					 * the designated bridge refers to
					 * another port on this bridge.
					 */</span>
					bstp_set_port_role(bp,
					    BSTP_ROLE_BACKUP);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * the port is an inferior path to the
					 * root bridge.
					 */</span>
					bstp_set_port_role(bp,
					    BSTP_ROLE_ALTERNATE);
				}
			}
			<span class="enscript-keyword">break</span>;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_update_state</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-type">struct</span> bstp_port *bp2;
	<span class="enscript-type">int</span> synced;

	BSTP_LOCK_ASSERT(bs);

	<span class="enscript-comment">/* check if all the ports have syncronised again */</span>
	<span class="enscript-keyword">if</span> (!bs-&gt;bs_allsynced) {
		synced = 1;
		LIST_FOREACH(bp2, &amp;bs-&gt;bs_bplist, bp_next) {
			<span class="enscript-keyword">if</span> (!(bp2-&gt;bp_synced ||
			     bp2-&gt;bp_role == BSTP_ROLE_ROOT)) {
				synced = 0;
				<span class="enscript-keyword">break</span>;
			}
		}
		bs-&gt;bs_allsynced = synced;
	}

	bstp_update_roles(bs, bp);
	bstp_update_tc(bp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_update_roles</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-keyword">switch</span> (bp-&gt;bp_role) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_DISABLED</span>:
		<span class="enscript-comment">/* Clear any flags if set */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;bp_sync || !bp-&gt;bp_synced || bp-&gt;bp_reroot) {
			bp-&gt;bp_sync = 0;
			bp-&gt;bp_synced = 1;
			bp-&gt;bp_reroot = 0;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_ALTERNATE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_BACKUP</span>:
		<span class="enscript-keyword">if</span> ((bs-&gt;bs_allsynced &amp;&amp; !bp-&gt;bp_agree) ||
		    (bp-&gt;bp_proposed &amp;&amp; bp-&gt;bp_agree)) {
			bp-&gt;bp_proposed = 0;
			bp-&gt;bp_agree = 1;
			bp-&gt;bp_flags |= BSTP_PORT_NEWINFO;
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; ALTERNATE_AGREED\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);
		}

		<span class="enscript-keyword">if</span> (bp-&gt;bp_proposed &amp;&amp; !bp-&gt;bp_agree) {
			bstp_set_all_sync(bs);
			bp-&gt;bp_proposed = 0;
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; ALTERNATE_PROPOSED\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);
		}

		<span class="enscript-comment">/* Clear any flags if set */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;bp_sync || !bp-&gt;bp_synced || bp-&gt;bp_reroot) {
			bp-&gt;bp_sync = 0;
			bp-&gt;bp_synced = 1;
			bp-&gt;bp_reroot = 0;
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; ALTERNATE_PORT\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_ROOT</span>:
		<span class="enscript-keyword">if</span> (bp-&gt;bp_state != BSTP_IFSTATE_FORWARDING &amp;&amp; !bp-&gt;bp_reroot) {
			bstp_set_all_reroot(bs);
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; ROOT_REROOT\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
		}

		<span class="enscript-keyword">if</span> ((bs-&gt;bs_allsynced &amp;&amp; !bp-&gt;bp_agree) ||
		    (bp-&gt;bp_proposed &amp;&amp; bp-&gt;bp_agree)) {
			bp-&gt;bp_proposed = 0;
			bp-&gt;bp_sync = 0;
			bp-&gt;bp_agree = 1;
			bp-&gt;bp_flags |= BSTP_PORT_NEWINFO;
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; ROOT_AGREED\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
		}

		<span class="enscript-keyword">if</span> (bp-&gt;bp_proposed &amp;&amp; !bp-&gt;bp_agree) {
			bstp_set_all_sync(bs);
			bp-&gt;bp_proposed = 0;
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; ROOT_PROPOSED\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
		}

		<span class="enscript-keyword">if</span> (bp-&gt;bp_state != BSTP_IFSTATE_FORWARDING &amp;&amp;
		    (bp-&gt;bp_forward_delay_timer.active == 0 ||
		    (bstp_rerooted(bs, bp) &amp;&amp;
		    bp-&gt;bp_recent_backup_timer.active == 0 &amp;&amp;
		    bp-&gt;bp_protover == BSTP_PROTO_RSTP))) {
			<span class="enscript-keyword">switch</span> (bp-&gt;bp_state) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_IFSTATE_DISCARDING</span>:
				bstp_set_port_state(bp, BSTP_IFSTATE_LEARNING);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_IFSTATE_LEARNING</span>:
				bstp_set_port_state(bp,
				    BSTP_IFSTATE_FORWARDING);
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (bp-&gt;bp_state == BSTP_IFSTATE_FORWARDING &amp;&amp; bp-&gt;bp_reroot) {
			bp-&gt;bp_reroot = 0;
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; ROOT_REROOTED\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_DESIGNATED</span>:
		<span class="enscript-keyword">if</span> (bp-&gt;bp_recent_root_timer.active == 0 &amp;&amp; bp-&gt;bp_reroot) {
			bp-&gt;bp_reroot = 0;
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; DESIGNATED_RETIRED\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);
		}

		<span class="enscript-keyword">if</span> ((bp-&gt;bp_state == BSTP_IFSTATE_DISCARDING &amp;&amp;
		    !bp-&gt;bp_synced) || (bp-&gt;bp_agreed &amp;&amp; !bp-&gt;bp_synced) ||
		    (bp-&gt;bp_operedge &amp;&amp; !bp-&gt;bp_synced) ||
		    (bp-&gt;bp_sync &amp;&amp; bp-&gt;bp_synced)) {
			bstp_timer_stop(&amp;bp-&gt;bp_recent_root_timer);
			bp-&gt;bp_synced = 1;
			bp-&gt;bp_sync = 0;
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; DESIGNATED_SYNCED\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);
		}

		<span class="enscript-keyword">if</span> (bp-&gt;bp_state != BSTP_IFSTATE_FORWARDING &amp;&amp;
		    !bp-&gt;bp_agreed &amp;&amp; !bp-&gt;bp_proposing &amp;&amp;
		    !bp-&gt;bp_operedge) {
			bp-&gt;bp_proposing = 1;
			bp-&gt;bp_flags |= BSTP_PORT_NEWINFO;
			bstp_timer_start(&amp;bp-&gt;bp_edge_delay_timer,
			    (bp-&gt;bp_ptp_link ? BSTP_DEFAULT_MIGRATE_DELAY :
			     bp-&gt;bp_desg_max_age));
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; DESIGNATED_PROPOSE\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);
		}

		<span class="enscript-keyword">if</span> (bp-&gt;bp_state != BSTP_IFSTATE_FORWARDING &amp;&amp;
		    (bp-&gt;bp_forward_delay_timer.active == 0 || bp-&gt;bp_agreed ||
		    bp-&gt;bp_operedge) &amp;&amp;
		    (bp-&gt;bp_recent_root_timer.active == 0 || !bp-&gt;bp_reroot) &amp;&amp;
		    !bp-&gt;bp_sync) {
#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">BRIDGESTP_DEBUG</span>
			<span class="enscript-keyword">if</span> (bp-&gt;bp_agreed)
				DPRINTF(<span class="enscript-string">&quot;%s -&gt; AGREED\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP_DEBUG */</span>
			<span class="enscript-comment">/*
			 * If agreed|operedge then go straight to forwarding,
			 * otherwise follow discard -&gt; learn -&gt; forward.
			 */</span>
			<span class="enscript-keyword">if</span> (bp-&gt;bp_agreed || bp-&gt;bp_operedge ||
			    bp-&gt;bp_state == BSTP_IFSTATE_LEARNING) {
				bstp_set_port_state(bp,
				    BSTP_IFSTATE_FORWARDING);
				bp-&gt;bp_agreed = bp-&gt;bp_protover;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bp-&gt;bp_state == BSTP_IFSTATE_DISCARDING)
				bstp_set_port_state(bp, BSTP_IFSTATE_LEARNING);
		}

		<span class="enscript-keyword">if</span> (((bp-&gt;bp_sync &amp;&amp; !bp-&gt;bp_synced) ||
		    (bp-&gt;bp_reroot &amp;&amp; bp-&gt;bp_recent_root_timer.active) ||
		    (bp-&gt;bp_flags &amp; BSTP_PORT_DISPUTED)) &amp;&amp; !bp-&gt;bp_operedge &amp;&amp;
		    bp-&gt;bp_state != BSTP_IFSTATE_DISCARDING) {
			bstp_set_port_state(bp, BSTP_IFSTATE_DISCARDING);
			bp-&gt;bp_flags &amp;= ~BSTP_PORT_DISPUTED;
			bstp_timer_start(&amp;bp-&gt;bp_forward_delay_timer,
			    bp-&gt;bp_protover == BSTP_PROTO_RSTP ?
			    bp-&gt;bp_desg_htime : bp-&gt;bp_desg_fdelay);
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; DESIGNATED_DISCARD\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (bp-&gt;bp_flags &amp; BSTP_PORT_NEWINFO)
		bstp_transmit(bs, bp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_update_tc</span>(<span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-keyword">switch</span> (bp-&gt;bp_tcstate) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_ACTIVE</span>:
			<span class="enscript-keyword">if</span> ((bp-&gt;bp_role != BSTP_ROLE_DESIGNATED &amp;&amp;
			    bp-&gt;bp_role != BSTP_ROLE_ROOT) || bp-&gt;bp_operedge)
				bstp_set_port_tc(bp, BSTP_TCSTATE_LEARNING);

			<span class="enscript-keyword">if</span> (bp-&gt;bp_rcvdtcn)
				bstp_set_port_tc(bp, BSTP_TCSTATE_TCN);
			<span class="enscript-keyword">if</span> (bp-&gt;bp_rcvdtc)
				bstp_set_port_tc(bp, BSTP_TCSTATE_TC);

			<span class="enscript-keyword">if</span> (bp-&gt;bp_tc_prop &amp;&amp; !bp-&gt;bp_operedge)
				bstp_set_port_tc(bp, BSTP_TCSTATE_PROPAG);

			<span class="enscript-keyword">if</span> (bp-&gt;bp_rcvdtca)
				bstp_set_port_tc(bp, BSTP_TCSTATE_ACK);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_INACTIVE</span>:
			<span class="enscript-keyword">if</span> ((bp-&gt;bp_state == BSTP_IFSTATE_LEARNING ||
			    bp-&gt;bp_state == BSTP_IFSTATE_FORWARDING) &amp;&amp;
			    bp-&gt;bp_fdbflush == 0)
				bstp_set_port_tc(bp, BSTP_TCSTATE_LEARNING);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_LEARNING</span>:
			<span class="enscript-keyword">if</span> (bp-&gt;bp_rcvdtc || bp-&gt;bp_rcvdtcn || bp-&gt;bp_rcvdtca ||
			    bp-&gt;bp_tc_prop)
				bstp_set_port_tc(bp, BSTP_TCSTATE_LEARNING);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bp-&gt;bp_role != BSTP_ROLE_DESIGNATED &amp;&amp;
				 bp-&gt;bp_role != BSTP_ROLE_ROOT &amp;&amp;
				 bp-&gt;bp_state == BSTP_IFSTATE_DISCARDING)
				bstp_set_port_tc(bp, BSTP_TCSTATE_INACTIVE);

			<span class="enscript-keyword">if</span> ((bp-&gt;bp_role == BSTP_ROLE_DESIGNATED ||
			    bp-&gt;bp_role == BSTP_ROLE_ROOT) &amp;&amp;
			    bp-&gt;bp_state == BSTP_IFSTATE_FORWARDING &amp;&amp;
			    !bp-&gt;bp_operedge)
				bstp_set_port_tc(bp, BSTP_TCSTATE_DETECTED);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* these are transient states and go straight back to ACTIVE */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_DETECTED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_TCN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_TC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_PROPAG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_ACK</span>:
			DPRINTF(<span class="enscript-string">&quot;Invalid TC state for %s\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);
			<span class="enscript-keyword">break</span>;
	}

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_update_info</span>(<span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	bp-&gt;bp_proposing = 0;
	bp-&gt;bp_proposed = 0;

	<span class="enscript-keyword">if</span> (bp-&gt;bp_agreed &amp;&amp; !bstp_pdu_bettersame(bp, BSTP_INFO_MINE))
		bp-&gt;bp_agreed = 0;

	<span class="enscript-keyword">if</span> (bp-&gt;bp_synced &amp;&amp; !bp-&gt;bp_agreed) {
		bp-&gt;bp_synced = 0;
		bs-&gt;bs_allsynced = 0;
	}

	<span class="enscript-comment">/* copy the designated pv to the port */</span>
	bp-&gt;bp_port_pv = bp-&gt;bp_desg_pv;
	bp-&gt;bp_port_msg_age = bp-&gt;bp_desg_msg_age;
	bp-&gt;bp_port_max_age = bp-&gt;bp_desg_max_age;
	bp-&gt;bp_port_fdelay = bp-&gt;bp_desg_fdelay;
	bp-&gt;bp_port_htime = bp-&gt;bp_desg_htime;
	bp-&gt;bp_infois = BSTP_INFO_MINE;

	<span class="enscript-comment">/* Set transmit flag but do not immediately send */</span>
	bp-&gt;bp_flags |= BSTP_PORT_NEWINFO;
}

<span class="enscript-comment">/* set tcprop on every port other than the caller */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_set_other_tcprop</span>(<span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;
	<span class="enscript-type">struct</span> bstp_port *bp2;

	BSTP_LOCK_ASSERT(bs);

	LIST_FOREACH(bp2, &amp;bs-&gt;bs_bplist, bp_next) {
		<span class="enscript-keyword">if</span> (bp2 == bp)
			<span class="enscript-keyword">continue</span>;
		bp2-&gt;bp_tc_prop = 1;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_set_all_reroot</span>(<span class="enscript-type">struct</span> bstp_state *bs)
{
	<span class="enscript-type">struct</span> bstp_port *bp;

	BSTP_LOCK_ASSERT(bs);

	LIST_FOREACH(bp, &amp;bs-&gt;bs_bplist, bp_next)
		bp-&gt;bp_reroot = 1;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_set_all_sync</span>(<span class="enscript-type">struct</span> bstp_state *bs)
{
	<span class="enscript-type">struct</span> bstp_port *bp;

	BSTP_LOCK_ASSERT(bs);

	LIST_FOREACH(bp, &amp;bs-&gt;bs_bplist, bp_next) {
		bp-&gt;bp_sync = 1;
		bp-&gt;bp_synced = 0;	<span class="enscript-comment">/* Not explicit in spec */</span>
	}

	bs-&gt;bs_allsynced = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_set_port_state</span>(<span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">int</span> state)
{
	<span class="enscript-keyword">if</span> (bp-&gt;bp_state == state)
		<span class="enscript-keyword">return</span>;

	bp-&gt;bp_state = state;

	<span class="enscript-keyword">switch</span> (bp-&gt;bp_state) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_IFSTATE_DISCARDING</span>:
			DPRINTF(<span class="enscript-string">&quot;state changed to DISCARDING on %s\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_IFSTATE_LEARNING</span>:
			DPRINTF(<span class="enscript-string">&quot;state changed to LEARNING on %s\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);

			bstp_timer_start(&amp;bp-&gt;bp_forward_delay_timer,
			    bp-&gt;bp_protover == BSTP_PROTO_RSTP ?
			    bp-&gt;bp_desg_htime : bp-&gt;bp_desg_fdelay);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_IFSTATE_FORWARDING</span>:
			DPRINTF(<span class="enscript-string">&quot;state changed to FORWARDING on %s\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);

			bstp_timer_stop(&amp;bp-&gt;bp_forward_delay_timer);
			<span class="enscript-comment">/* Record that we enabled forwarding */</span>
			bp-&gt;bp_forward_transitions++;
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* notify the parent bridge */</span>
	bstp_task_enqueue(&amp;bp-&gt;bp_statetask);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_set_port_role</span>(<span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">int</span> role)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	<span class="enscript-keyword">if</span> (bp-&gt;bp_role == role)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* perform pre-change tasks */</span>
	<span class="enscript-keyword">switch</span> (bp-&gt;bp_role) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_DISABLED</span>:
			bstp_timer_start(&amp;bp-&gt;bp_forward_delay_timer,
			    bp-&gt;bp_desg_max_age);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_BACKUP</span>:
			bstp_timer_start(&amp;bp-&gt;bp_recent_backup_timer,
			    bp-&gt;bp_desg_htime * 2);
			<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_ALTERNATE</span>:
			bstp_timer_start(&amp;bp-&gt;bp_forward_delay_timer,
			    bp-&gt;bp_desg_fdelay);
			bp-&gt;bp_sync = 0;
			bp-&gt;bp_synced = 1;
			bp-&gt;bp_reroot = 0;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_ROOT</span>:
			bstp_timer_start(&amp;bp-&gt;bp_recent_root_timer,
			    BSTP_DEFAULT_FORWARD_DELAY);
			<span class="enscript-keyword">break</span>;
	}

	bp-&gt;bp_role = role;
	<span class="enscript-comment">/* clear values not carried between roles */</span>
	bp-&gt;bp_proposing = 0;
	bs-&gt;bs_allsynced = 0;

	<span class="enscript-comment">/* initialise the new role */</span>
	<span class="enscript-keyword">switch</span> (bp-&gt;bp_role) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_DISABLED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_ALTERNATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_BACKUP</span>:
			DPRINTF(<span class="enscript-string">&quot;%s role -&gt; ALT/BACK/DISABLED\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);
			bstp_set_port_state(bp, BSTP_IFSTATE_DISCARDING);
			bstp_timer_stop(&amp;bp-&gt;bp_recent_root_timer);
			bstp_timer_latch(&amp;bp-&gt;bp_forward_delay_timer);
			bp-&gt;bp_sync = 0;
			bp-&gt;bp_synced = 1;
			bp-&gt;bp_reroot = 0;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_ROOT</span>:
			DPRINTF(<span class="enscript-string">&quot;%s role -&gt; ROOT\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);
			bstp_set_port_state(bp, BSTP_IFSTATE_DISCARDING);
			bstp_timer_latch(&amp;bp-&gt;bp_recent_root_timer);
			bp-&gt;bp_proposing = 0;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_ROLE_DESIGNATED</span>:
			DPRINTF(<span class="enscript-string">&quot;%s role -&gt; DESIGNATED\n&quot;</span>,
			    bp-&gt;bp_ifp-&gt;if_xname);
			bstp_timer_start(&amp;bp-&gt;bp_hello_timer,
			    bp-&gt;bp_desg_htime);
			bp-&gt;bp_agree = 0;
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* let the TC state know that the role changed */</span>
	bstp_update_tc(bp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_set_port_proto</span>(<span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">int</span> proto)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	<span class="enscript-comment">/* supported protocol versions */</span>
	<span class="enscript-keyword">switch</span> (proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_STP</span>:
			<span class="enscript-comment">/* we can downgrade protocols only */</span>
			bstp_timer_stop(&amp;bp-&gt;bp_migrate_delay_timer);
			<span class="enscript-comment">/* clear unsupported features */</span>
			bp-&gt;bp_operedge = 0;
			<span class="enscript-comment">/* STP compat mode only uses 16 bits of the 32 */</span>
			<span class="enscript-keyword">if</span> (bp-&gt;bp_path_cost &gt; 65535)
				bp-&gt;bp_path_cost = 65535;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_RSTP</span>:
			bstp_timer_start(&amp;bp-&gt;bp_migrate_delay_timer,
			    bs-&gt;bs_migration_delay);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			DPRINTF(<span class="enscript-string">&quot;Unsupported STP version %d\n&quot;</span>, proto);
			<span class="enscript-keyword">return</span>;
	}

	bp-&gt;bp_protover = proto;
	bp-&gt;bp_flags &amp;= ~BSTP_PORT_CANMIGRATE;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_set_port_tc</span>(<span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">int</span> state)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	bp-&gt;bp_tcstate = state;

	<span class="enscript-comment">/* initialise the new state */</span>
	<span class="enscript-keyword">switch</span> (bp-&gt;bp_tcstate) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_ACTIVE</span>:
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; TC_ACTIVE\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
			<span class="enscript-comment">/* nothing to do */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_INACTIVE</span>:
			bstp_timer_stop(&amp;bp-&gt;bp_tc_timer);
			<span class="enscript-comment">/* flush routes on the parent bridge */</span>
			bp-&gt;bp_fdbflush = 1;
			bstp_task_enqueue(&amp;bp-&gt;bp_rtagetask);
			bp-&gt;bp_tc_ack = 0;
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; TC_INACTIVE\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_LEARNING</span>:
			bp-&gt;bp_rcvdtc = 0;
			bp-&gt;bp_rcvdtcn = 0;
			bp-&gt;bp_rcvdtca = 0;
			bp-&gt;bp_tc_prop = 0;
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; TC_LEARNING\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_DETECTED</span>:
			bstp_set_timer_tc(bp);
			bstp_set_other_tcprop(bp);
			<span class="enscript-comment">/* send out notification */</span>
			bp-&gt;bp_flags |= BSTP_PORT_NEWINFO;
			bstp_transmit(bs, bp);
			<span class="enscript-comment">/* reviewed for getmicrotime usage */</span>
			getmicrotime(&amp;bs-&gt;bs_last_tc_time);
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; TC_DETECTED\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
			bp-&gt;bp_tcstate = BSTP_TCSTATE_ACTIVE; <span class="enscript-comment">/* UCT */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_TCN</span>:
			bstp_set_timer_tc(bp);
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; TC_TCN\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
			<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_TC</span>:
			bp-&gt;bp_rcvdtc = 0;
			bp-&gt;bp_rcvdtcn = 0;
			<span class="enscript-keyword">if</span> (bp-&gt;bp_role == BSTP_ROLE_DESIGNATED)
				bp-&gt;bp_tc_ack = 1;

			bstp_set_other_tcprop(bp);
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; TC_TC\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
			bp-&gt;bp_tcstate = BSTP_TCSTATE_ACTIVE; <span class="enscript-comment">/* UCT */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_PROPAG</span>:
			<span class="enscript-comment">/* flush routes on the parent bridge */</span>
			bp-&gt;bp_fdbflush = 1;
			bstp_task_enqueue(&amp;bp-&gt;bp_rtagetask);
			bp-&gt;bp_tc_prop = 0;
			bstp_set_timer_tc(bp);
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; TC_PROPAG\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
			bp-&gt;bp_tcstate = BSTP_TCSTATE_ACTIVE; <span class="enscript-comment">/* UCT */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_TCSTATE_ACK</span>:
			bstp_timer_stop(&amp;bp-&gt;bp_tc_timer);
			bp-&gt;bp_rcvdtca = 0;
			DPRINTF(<span class="enscript-string">&quot;%s -&gt; TC_ACK\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
			bp-&gt;bp_tcstate = BSTP_TCSTATE_ACTIVE; <span class="enscript-comment">/* UCT */</span>
			<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_set_timer_tc</span>(<span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	<span class="enscript-keyword">if</span> (bp-&gt;bp_tc_timer.active)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">switch</span> (bp-&gt;bp_protover) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_RSTP</span>:
			bstp_timer_start(&amp;bp-&gt;bp_tc_timer,
			    bp-&gt;bp_desg_htime + BSTP_TICK_VAL);
			bp-&gt;bp_flags |= BSTP_PORT_NEWINFO;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_STP</span>:
			bstp_timer_start(&amp;bp-&gt;bp_tc_timer,
			    bs-&gt;bs_root_max_age + bs-&gt;bs_root_fdelay);
			<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_set_timer_msgage</span>(<span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-keyword">if</span> (bp-&gt;bp_port_msg_age + BSTP_MESSAGE_AGE_INCR &lt;=
	    bp-&gt;bp_port_max_age) {
		bstp_timer_start(&amp;bp-&gt;bp_message_age_timer,
		    bp-&gt;bp_port_htime * 3);
	} <span class="enscript-keyword">else</span>
		<span class="enscript-comment">/* expires immediately */</span>
		bstp_timer_start(&amp;bp-&gt;bp_message_age_timer, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_rerooted</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-type">struct</span> bstp_port *bp2;
	<span class="enscript-type">int</span> rr_set = 0;

	LIST_FOREACH(bp2, &amp;bs-&gt;bs_bplist, bp_next) {
		<span class="enscript-keyword">if</span> (bp2 == bp)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (bp2-&gt;bp_recent_root_timer.active) {
			rr_set = 1;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> (!rr_set);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_set_htime</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">int</span> t)
{
	<span class="enscript-comment">/* convert seconds to ticks */</span>
	t *=  BSTP_TICK_VAL;

	<span class="enscript-comment">/* value can only be changed in leagacy stp mode */</span>
	<span class="enscript-keyword">if</span> (bs-&gt;bs_protover != BSTP_PROTO_STP)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-keyword">if</span> (t &lt; BSTP_MIN_HELLO_TIME || t &gt; BSTP_MAX_HELLO_TIME)
		<span class="enscript-keyword">return</span> (EINVAL);

	BSTP_LOCK(bs);
	bs-&gt;bs_bridge_htime = t;
	bstp_reinit(bs);
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_set_fdelay</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">int</span> t)
{
	<span class="enscript-comment">/* convert seconds to ticks */</span>
	t *= BSTP_TICK_VAL;

	<span class="enscript-keyword">if</span> (t &lt; BSTP_MIN_FORWARD_DELAY || t &gt; BSTP_MAX_FORWARD_DELAY)
		<span class="enscript-keyword">return</span> (EINVAL);

	BSTP_LOCK(bs);
	bs-&gt;bs_bridge_fdelay = t;
	bstp_reinit(bs);
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_set_maxage</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">int</span> t)
{
	<span class="enscript-comment">/* convert seconds to ticks */</span>
	t *= BSTP_TICK_VAL;

	<span class="enscript-keyword">if</span> (t &lt; BSTP_MIN_MAX_AGE || t &gt; BSTP_MAX_MAX_AGE)
		<span class="enscript-keyword">return</span> (EINVAL);

	BSTP_LOCK(bs);
	bs-&gt;bs_bridge_max_age = t;
	bstp_reinit(bs);
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_set_holdcount</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">int</span> count)
{
	<span class="enscript-type">struct</span> bstp_port *bp;

	<span class="enscript-keyword">if</span> (count &lt; BSTP_MIN_HOLD_COUNT ||
	    count &gt; BSTP_MAX_HOLD_COUNT)
		<span class="enscript-keyword">return</span> (EINVAL);

	BSTP_LOCK(bs);
	bs-&gt;bs_txholdcount = count;
	LIST_FOREACH(bp, &amp;bs-&gt;bs_bplist, bp_next)
		bp-&gt;bp_txcount = 0;
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_set_protocol</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">int</span> proto)
{
	<span class="enscript-type">struct</span> bstp_port *bp;

	<span class="enscript-keyword">switch</span> (proto) {
		<span class="enscript-comment">/* Supported protocol versions */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_STP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_RSTP</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (EINVAL);
	}

	BSTP_LOCK(bs);
	bs-&gt;bs_protover = proto;
	bs-&gt;bs_bridge_htime = BSTP_DEFAULT_HELLO_TIME;
	LIST_FOREACH(bp, &amp;bs-&gt;bs_bplist, bp_next) {
		<span class="enscript-comment">/* reinit state */</span>
		bp-&gt;bp_infois = BSTP_INFO_DISABLED;
		bp-&gt;bp_txcount = 0;
		bstp_set_port_proto(bp, bs-&gt;bs_protover);
		bstp_set_port_role(bp, BSTP_ROLE_DISABLED);
		bstp_set_port_tc(bp, BSTP_TCSTATE_INACTIVE);
		bstp_timer_stop(&amp;bp-&gt;bp_recent_backup_timer);
	}
	bstp_reinit(bs);
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_set_priority</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">int</span> pri)
{
	<span class="enscript-keyword">if</span> (pri &lt; 0 || pri &gt; BSTP_MAX_PRIORITY)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* Limit to steps of 4096 */</span>
	pri -= pri % 4096;

	BSTP_LOCK(bs);
	bs-&gt;bs_bridge_priority = pri;
	bstp_reinit(bs);
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_set_port_priority</span>(<span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">int</span> pri)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	<span class="enscript-keyword">if</span> (pri &lt; 0 || pri &gt; BSTP_MAX_PORT_PRIORITY)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* Limit to steps of 16 */</span>
	pri -= pri % 16;

	BSTP_LOCK(bs);
	bp-&gt;bp_priority = pri;
	bstp_reinit(bs);
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_set_path_cost</span>(<span class="enscript-type">struct</span> bstp_port *bp, uint32_t path_cost)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	<span class="enscript-keyword">if</span> (path_cost &gt; BSTP_MAX_PATH_COST)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* STP compat mode only uses 16 bits of the 32 */</span>
	<span class="enscript-keyword">if</span> (bp-&gt;bp_protover == BSTP_PROTO_STP &amp;&amp; path_cost &gt; 65535)
		path_cost = 65535;

	BSTP_LOCK(bs);

	<span class="enscript-keyword">if</span> (path_cost == 0) {	<span class="enscript-comment">/* use auto */</span>
		bp-&gt;bp_flags &amp;= ~BSTP_PORT_ADMCOST;
		bp-&gt;bp_path_cost = bstp_calc_path_cost(bp);
	} <span class="enscript-keyword">else</span> {
		bp-&gt;bp_path_cost = path_cost;
		bp-&gt;bp_flags |= BSTP_PORT_ADMCOST;
	}
	bstp_reinit(bs);
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_set_edge</span>(<span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">int</span> set)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	BSTP_LOCK(bs);
	<span class="enscript-keyword">if</span> ((bp-&gt;bp_operedge = set) == 0)
		bp-&gt;bp_flags &amp;= ~BSTP_PORT_ADMEDGE;
	<span class="enscript-keyword">else</span>
		bp-&gt;bp_flags |= BSTP_PORT_ADMEDGE;
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_set_autoedge</span>(<span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">int</span> set)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	BSTP_LOCK(bs);
	<span class="enscript-keyword">if</span> (set) {
		bp-&gt;bp_flags |= BSTP_PORT_AUTOEDGE;
		<span class="enscript-comment">/* we may be able to transition straight to edge */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;bp_edge_delay_timer.active == 0)
			bstp_edge_delay_expiry(bs, bp);
	} <span class="enscript-keyword">else</span>
		bp-&gt;bp_flags &amp;= ~BSTP_PORT_AUTOEDGE;
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_set_ptp</span>(<span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">int</span> set)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	BSTP_LOCK(bs);
	bp-&gt;bp_ptp_link = set;
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_set_autoptp</span>(<span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">int</span> set)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	BSTP_LOCK(bs);
	<span class="enscript-keyword">if</span> (set) {
		bp-&gt;bp_flags |= BSTP_PORT_AUTOPTP;
		<span class="enscript-keyword">if</span> (bp-&gt;bp_role != BSTP_ROLE_DISABLED)
			bstp_ifupdstatus(bs, bp);
	} <span class="enscript-keyword">else</span>
		bp-&gt;bp_flags &amp;= ~BSTP_PORT_AUTOPTP;
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Calculate the path cost according to the link speed.
 */</span>
<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">bstp_calc_path_cost</span>(<span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-type">struct</span> ifnet *ifp = bp-&gt;bp_ifp;
	uint32_t path_cost;

	<span class="enscript-comment">/* If the priority has been manually set then retain the value */</span>
	<span class="enscript-keyword">if</span> (bp-&gt;bp_flags &amp; BSTP_PORT_ADMCOST)
		<span class="enscript-keyword">return</span> bp-&gt;bp_path_cost;

	<span class="enscript-keyword">if</span> (bp-&gt;bp_if_link_state == LINK_STATE_DOWN) {
		<span class="enscript-comment">/* Recalc when the link comes up again */</span>
		bp-&gt;bp_flags |= BSTP_PORT_PNDCOST;
		<span class="enscript-keyword">return</span> (BSTP_DEFAULT_PATH_COST);
	}

	<span class="enscript-keyword">if</span> (ifp-&gt;if_baudrate &lt; 1000)
		<span class="enscript-keyword">return</span> (BSTP_DEFAULT_PATH_COST);

 	<span class="enscript-comment">/* formula from section 17.14, IEEE Std 802.1D-2004 */</span>
	path_cost = 20000000000ULL / (ifp-&gt;if_baudrate / 1000);

	<span class="enscript-keyword">if</span> (path_cost &gt; BSTP_MAX_PATH_COST)
		path_cost = BSTP_MAX_PATH_COST;

	<span class="enscript-comment">/* STP compat mode only uses 16 bits of the 32 */</span>
	<span class="enscript-keyword">if</span> (bp-&gt;bp_protover == BSTP_PROTO_STP &amp;&amp; path_cost &gt; 65535)
		path_cost = 65535;

	<span class="enscript-keyword">return</span> (path_cost);
}

<span class="enscript-comment">/*
 * Notify the bridge that a port state has changed, we need to do this from a
 * taskqueue to avoid a LOR.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_notify_state</span>(<span class="enscript-type">void</span> *arg, __unused <span class="enscript-type">int</span> pending)
{
	<span class="enscript-type">struct</span> bstp_port *bp = (<span class="enscript-type">struct</span> bstp_port *)arg;
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	<span class="enscript-keyword">if</span> (bp-&gt;bp_active == 1 &amp;&amp; bs-&gt;bs_state_cb != NULL)
		(*bs-&gt;bs_state_cb)(bp-&gt;bp_ifp, bp-&gt;bp_state);
}

<span class="enscript-comment">/*
 * Flush the routes on the bridge port, we need to do this from a
 * taskqueue to avoid a LOR.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_notify_rtage</span>(<span class="enscript-type">void</span> *arg, __unused <span class="enscript-type">int</span> pending)
{
	<span class="enscript-type">struct</span> bstp_port *bp = (<span class="enscript-type">struct</span> bstp_port *)arg;
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;
	<span class="enscript-type">int</span> age = 0;

	BSTP_LOCK(bs);
	<span class="enscript-keyword">switch</span> (bp-&gt;bp_protover) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_STP</span>:
			<span class="enscript-comment">/* convert to seconds */</span>
			age = bp-&gt;bp_desg_fdelay / BSTP_TICK_VAL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BSTP_PROTO_RSTP</span>:
			age = 0;
			<span class="enscript-keyword">break</span>;
	}
	BSTP_UNLOCK(bs);

	<span class="enscript-keyword">if</span> (bp-&gt;bp_active == 1 &amp;&amp; bs-&gt;bs_rtage_cb != NULL)
		(*bs-&gt;bs_rtage_cb)(bp-&gt;bp_ifp, age);

	<span class="enscript-comment">/* flush is complete */</span>
	BSTP_LOCK(bs);
	bp-&gt;bp_fdbflush = 0;
	BSTP_UNLOCK(bs);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_linkstate</span>(<span class="enscript-type">struct</span> ifnet *ifp, __unused <span class="enscript-type">int</span> state)
{
	<span class="enscript-type">struct</span> bstp_state *bs;
	<span class="enscript-type">struct</span> bstp_port *bp;

	<span class="enscript-comment">/* search for the stp port */</span>
	lck_mtx_lock(bstp_list_mtx);
	LIST_FOREACH(bs, &amp;bstp_list, bs_list) {
		BSTP_LOCK(bs);
		LIST_FOREACH(bp, &amp;bs-&gt;bs_bplist, bp_next) {
			<span class="enscript-keyword">if</span> (bp-&gt;bp_ifp == ifp) {
				bstp_ifupdstatus(bs, bp);
				bstp_update_state(bs, bp);
				<span class="enscript-comment">/* it only exists once so return */</span>
				BSTP_UNLOCK(bs);
				lck_mtx_unlock(bstp_list_mtx);
				<span class="enscript-keyword">return</span>;
			}
		}
		BSTP_UNLOCK(bs);
	}
	lck_mtx_unlock(bstp_list_mtx);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_ifupdstatus</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-type">struct</span> ifnet *ifp = bp-&gt;bp_ifp;
	<span class="enscript-type">struct</span> ifmediareq ifmr;
	<span class="enscript-type">int</span> error = 0;

	BSTP_LOCK_ASSERT(bs);

	bzero((<span class="enscript-type">char</span> *)&amp;ifmr, <span class="enscript-keyword">sizeof</span>(ifmr));
	error = (*ifp-&gt;if_ioctl)(ifp, SIOCGIFMEDIA, (caddr_t)&amp;ifmr);

	<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; (ifp-&gt;if_flags &amp; IFF_UP)) {
		<span class="enscript-keyword">if</span> (ifmr.ifm_status &amp; IFM_ACTIVE) {
			<span class="enscript-comment">/* A full-duplex link is assumed to be point to point */</span>
			<span class="enscript-keyword">if</span> (bp-&gt;bp_flags &amp; BSTP_PORT_AUTOPTP) {
				bp-&gt;bp_ptp_link =
				    ifmr.ifm_active &amp; IFM_FDX ? 1 : 0;
			}

			<span class="enscript-comment">/* Calc the cost if the link was down previously */</span>
			<span class="enscript-keyword">if</span> (bp-&gt;bp_flags &amp; BSTP_PORT_PNDCOST) {
				bp-&gt;bp_path_cost = bstp_calc_path_cost(bp);
				bp-&gt;bp_flags &amp;= ~BSTP_PORT_PNDCOST;
			}

			<span class="enscript-keyword">if</span> (bp-&gt;bp_role == BSTP_ROLE_DISABLED)
				bstp_enable_port(bs, bp);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (bp-&gt;bp_role != BSTP_ROLE_DISABLED) {
				bstp_disable_port(bs, bp);
				<span class="enscript-keyword">if</span> ((bp-&gt;bp_flags &amp; BSTP_PORT_ADMEDGE) &amp;&amp;
				    bp-&gt;bp_protover == BSTP_PROTO_RSTP)
					bp-&gt;bp_operedge = 1;
			}
		}
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (bp-&gt;bp_infois != BSTP_INFO_DISABLED)
		bstp_disable_port(bs, bp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_enable_port</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	bp-&gt;bp_infois = BSTP_INFO_AGED;
	bstp_assign_roles(bs);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_disable_port</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	bp-&gt;bp_infois = BSTP_INFO_DISABLED;
	bstp_assign_roles(bs);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_tick</span>(<span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> bstp_state *bs = arg;
	<span class="enscript-type">struct</span> bstp_port *bp;
	<span class="enscript-type">struct</span> timespec ts;

	BSTP_LOCK(bs);

	<span class="enscript-keyword">if</span> (bs-&gt;bs_running == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* slow timer to catch missed link events */</span>
	<span class="enscript-keyword">if</span> (bstp_timer_expired(&amp;bs-&gt;bs_link_timer)) {
		LIST_FOREACH(bp, &amp;bs-&gt;bs_bplist, bp_next)
			bstp_ifupdstatus(bs, bp);
		bstp_timer_start(&amp;bs-&gt;bs_link_timer, BSTP_LINK_TIMER);
	}

	LIST_FOREACH(bp, &amp;bs-&gt;bs_bplist, bp_next) {
		<span class="enscript-comment">/* no events need to happen for these */</span>
		bstp_timer_expired(&amp;bp-&gt;bp_tc_timer);
		bstp_timer_expired(&amp;bp-&gt;bp_recent_root_timer);
		bstp_timer_expired(&amp;bp-&gt;bp_forward_delay_timer);
		bstp_timer_expired(&amp;bp-&gt;bp_recent_backup_timer);

		<span class="enscript-keyword">if</span> (bstp_timer_expired(&amp;bp-&gt;bp_hello_timer))
			bstp_hello_timer_expiry(bs, bp);

		<span class="enscript-keyword">if</span> (bstp_timer_expired(&amp;bp-&gt;bp_message_age_timer))
			bstp_message_age_expiry(bs, bp);

		<span class="enscript-keyword">if</span> (bstp_timer_expired(&amp;bp-&gt;bp_migrate_delay_timer))
			bstp_migrate_delay_expiry(bs, bp);

		<span class="enscript-keyword">if</span> (bstp_timer_expired(&amp;bp-&gt;bp_edge_delay_timer))
			bstp_edge_delay_expiry(bs, bp);

		<span class="enscript-comment">/* update the various state machines for the port */</span>
		bstp_update_state(bs, bp);

		<span class="enscript-keyword">if</span> (bp-&gt;bp_txcount &gt; 0)
			bp-&gt;bp_txcount--;
	}

	BSTP_UNLOCK(bs);

	ts.tv_sec = 1;
	ts.tv_nsec = 0;
	bsd_timeout(bstp_tick, bs, &amp;ts);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_timer_start</span>(<span class="enscript-type">struct</span> bstp_timer *t, uint16_t v)
{
	t-&gt;value = v;
	t-&gt;active = 1;
	t-&gt;latched = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_timer_stop</span>(<span class="enscript-type">struct</span> bstp_timer *t)
{
	t-&gt;value = 0;
	t-&gt;active = 0;
	t-&gt;latched = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_timer_latch</span>(<span class="enscript-type">struct</span> bstp_timer *t)
{
	t-&gt;latched = 1;
	t-&gt;active = 1;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_timer_expired</span>(<span class="enscript-type">struct</span> bstp_timer *t)
{
	<span class="enscript-keyword">if</span> (t-&gt;active == 0 || t-&gt;latched)
		<span class="enscript-keyword">return</span> (0);
	t-&gt;value -= BSTP_TICK_VAL;
	<span class="enscript-keyword">if</span> (t-&gt;value &lt;= 0) {
		bstp_timer_stop(t);
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_hello_timer_expiry</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-keyword">if</span> ((bp-&gt;bp_flags &amp; BSTP_PORT_NEWINFO) ||
	    bp-&gt;bp_role == BSTP_ROLE_DESIGNATED ||
	    (bp-&gt;bp_role == BSTP_ROLE_ROOT &amp;&amp;
	     bp-&gt;bp_tc_timer.active == 1)) {
		bstp_timer_start(&amp;bp-&gt;bp_hello_timer, bp-&gt;bp_desg_htime);
		bp-&gt;bp_flags |= BSTP_PORT_NEWINFO;
		bstp_transmit(bs, bp);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_message_age_expiry</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-keyword">if</span> (bp-&gt;bp_infois == BSTP_INFO_RECEIVED) {
		bp-&gt;bp_infois = BSTP_INFO_AGED;
		bstp_assign_roles(bs);
		DPRINTF(<span class="enscript-string">&quot;aged info on %s\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_migrate_delay_expiry</span>(__unused <span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	bp-&gt;bp_flags |= BSTP_PORT_CANMIGRATE;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_edge_delay_expiry</span>(__unused <span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-keyword">if</span> ((bp-&gt;bp_flags &amp; BSTP_PORT_AUTOEDGE) &amp;&amp;
	    bp-&gt;bp_protover == BSTP_PROTO_RSTP &amp;&amp; bp-&gt;bp_proposing &amp;&amp;
	    bp-&gt;bp_role == BSTP_ROLE_DESIGNATED) {
		bp-&gt;bp_operedge = 1;
		DPRINTF(<span class="enscript-string">&quot;%s -&gt; edge port\n&quot;</span>, bp-&gt;bp_ifp-&gt;if_xname);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_addr_cmp</span>(<span class="enscript-type">const</span> uint8_t *a, <span class="enscript-type">const</span> uint8_t *b)
{
	<span class="enscript-type">int</span> i, d;

	<span class="enscript-keyword">for</span> (i = 0, d = 0; i &lt; ETHER_ADDR_LEN &amp;&amp; d == 0; i++) {
		d = ((<span class="enscript-type">int</span>)a[i]) - ((<span class="enscript-type">int</span>)b[i]);
	}

	<span class="enscript-keyword">return</span> (d);
}

<span class="enscript-comment">/*
 * compare the bridge address component of the bridgeid
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_same_bridgeid</span>(uint64_t id1, uint64_t id2)
{
	u_char addr1[ETHER_ADDR_LEN];
	u_char addr2[ETHER_ADDR_LEN];

	PV2ADDR(id1, addr1);
	PV2ADDR(id2, addr2);

	<span class="enscript-keyword">if</span> (bstp_addr_cmp(addr1, addr2) == 0)
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_reinit</span>(<span class="enscript-type">struct</span> bstp_state *bs)
{
	<span class="enscript-type">struct</span> bstp_port *bp;
	<span class="enscript-type">struct</span> ifnet *ifp, *mif;
	u_char *e_addr;
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> u_char llzero[ETHER_ADDR_LEN];	<span class="enscript-comment">/* 00:00:00:00:00:00 */</span>

	BSTP_LOCK_ASSERT(bs);

	mif = NULL;
	<span class="enscript-comment">/*
	 * Search through the Ethernet adapters and find the one with the
	 * lowest value. The adapter which we take the MAC address from does
	 * not need to be part of the bridge, it just needs to be a unique
	 * value.
	 */</span>
	ifnet_head_lock_shared();
	TAILQ_FOREACH(ifp, &amp;ifnet_head, if_link) {
		<span class="enscript-keyword">if</span> (ifp-&gt;if_type != IFT_ETHER)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (bstp_addr_cmp(IF_LLADDR(ifp), llzero) == 0)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (mif == NULL) {
			mif = ifp;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (bstp_addr_cmp(IF_LLADDR(ifp), IF_LLADDR(mif)) &lt; 0) {
			mif = ifp;
			<span class="enscript-keyword">continue</span>;
		}
	}
	ifnet_head_done();

	<span class="enscript-keyword">if</span> (LIST_EMPTY(&amp;bs-&gt;bs_bplist) || mif == NULL) {
		<span class="enscript-comment">/* Set the bridge and root id (lower bits) to zero */</span>
		bs-&gt;bs_bridge_pv.pv_dbridge_id =
		    ((uint64_t)bs-&gt;bs_bridge_priority) &lt;&lt; 48;
		bs-&gt;bs_bridge_pv.pv_root_id = bs-&gt;bs_bridge_pv.pv_dbridge_id;
		bs-&gt;bs_root_pv = bs-&gt;bs_bridge_pv;
		<span class="enscript-comment">/* Disable any remaining ports, they will have no MAC address */</span>
		LIST_FOREACH(bp, &amp;bs-&gt;bs_bplist, bp_next) {
			bp-&gt;bp_infois = BSTP_INFO_DISABLED;
			bstp_set_port_role(bp, BSTP_ROLE_DISABLED);
		}
		bsd_untimeout(bstp_tick, bs);
		<span class="enscript-keyword">return</span>;
	}

	e_addr = IF_LLADDR(mif);
	bs-&gt;bs_bridge_pv.pv_dbridge_id =
	    (((uint64_t)bs-&gt;bs_bridge_priority) &lt;&lt; 48) |
	    (((uint64_t)e_addr[0]) &lt;&lt; 40) |
	    (((uint64_t)e_addr[1]) &lt;&lt; 32) |
	    (((uint64_t)e_addr[2]) &lt;&lt; 24) |
	    (((uint64_t)e_addr[3]) &lt;&lt; 16) |
	    (((uint64_t)e_addr[4]) &lt;&lt; 8) |
	    (((uint64_t)e_addr[5]));

	bs-&gt;bs_bridge_pv.pv_root_id = bs-&gt;bs_bridge_pv.pv_dbridge_id;
	bs-&gt;bs_bridge_pv.pv_cost = 0;
	bs-&gt;bs_bridge_pv.pv_dport_id = 0;
	bs-&gt;bs_bridge_pv.pv_port_id = 0;

	<span class="enscript-keyword">if</span> (bs-&gt;bs_running)
		bsd_untimeout(bstp_tick, bs);

	LIST_FOREACH(bp, &amp;bs-&gt;bs_bplist, bp_next) {
		bp-&gt;bp_port_id = (bp-&gt;bp_priority &lt;&lt; 8) |
		    (bp-&gt;bp_ifp-&gt;if_index  &amp; 0xfff);
		bstp_ifupdstatus(bs, bp);
	}

	bstp_assign_roles(bs);
	bstp_timer_start(&amp;bs-&gt;bs_link_timer, BSTP_LINK_TIMER);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_attach</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_cb_ops *cb)
{
	BSTP_LOCK_INIT(bs);
	LIST_INIT(&amp;bs-&gt;bs_bplist);

	bs-&gt;bs_bridge_max_age = BSTP_DEFAULT_MAX_AGE;
	bs-&gt;bs_bridge_htime = BSTP_DEFAULT_HELLO_TIME;
	bs-&gt;bs_bridge_fdelay = BSTP_DEFAULT_FORWARD_DELAY;
	bs-&gt;bs_bridge_priority = BSTP_DEFAULT_BRIDGE_PRIORITY;
	bs-&gt;bs_hold_time = BSTP_DEFAULT_HOLD_TIME;
	bs-&gt;bs_migration_delay = BSTP_DEFAULT_MIGRATE_DELAY;
	bs-&gt;bs_txholdcount = BSTP_DEFAULT_HOLD_COUNT;
	bs-&gt;bs_protover = BSTP_PROTO_RSTP;
	bs-&gt;bs_state_cb = cb-&gt;bcb_state;
	bs-&gt;bs_rtage_cb = cb-&gt;bcb_rtage;

	<span class="enscript-comment">/* reviewed for getmicrotime usage */</span>
	getmicrotime(&amp;bs-&gt;bs_last_tc_time);

	lck_mtx_lock(bstp_list_mtx);
	LIST_INSERT_HEAD(&amp;bstp_list, bs, bs_list);
	lck_mtx_unlock(bstp_list_mtx);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_detach</span>(<span class="enscript-type">struct</span> bstp_state *bs)
{
	KASSERT(LIST_EMPTY(&amp;bs-&gt;bs_bplist), (<span class="enscript-string">&quot;bstp still active&quot;</span>));

	lck_mtx_lock(bstp_list_mtx);
	LIST_REMOVE(bs, bs_list);
	lck_mtx_unlock(bstp_list_mtx);
	bsd_untimeout(bstp_tick, bs);
	BSTP_LOCK_DESTROY(bs);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_init</span>(<span class="enscript-type">struct</span> bstp_state *bs)
{
	<span class="enscript-type">struct</span> timespec ts;

	ts.tv_sec = 1;
	ts.tv_nsec = 0;

	BSTP_LOCK(bs);
	bsd_timeout(bstp_tick, bs, &amp;ts);
	bs-&gt;bs_running = 1;
	bstp_reinit(bs);
	BSTP_UNLOCK(bs);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_stop</span>(<span class="enscript-type">struct</span> bstp_state *bs)
{
	<span class="enscript-type">struct</span> bstp_port *bp;

	BSTP_LOCK(bs);

	LIST_FOREACH(bp, &amp;bs-&gt;bs_bplist, bp_next)
		bstp_set_port_state(bp, BSTP_IFSTATE_DISCARDING);

	bs-&gt;bs_running = 0;
	bsd_untimeout(bstp_tick, bs);
	BSTP_UNLOCK(bs);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_create</span>(<span class="enscript-type">struct</span> bstp_state *bs, <span class="enscript-type">struct</span> bstp_port *bp, <span class="enscript-type">struct</span> ifnet *ifp)
{
	bzero(bp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bstp_port));

	BSTP_LOCK(bs);
	bp-&gt;bp_ifp = ifp;
	bp-&gt;bp_bs = bs;
	bp-&gt;bp_priority = BSTP_DEFAULT_PORT_PRIORITY;
	BSTP_TASK_INIT(&amp;bp-&gt;bp_statetask, bstp_notify_state, bp);
	BSTP_TASK_INIT(&amp;bp-&gt;bp_rtagetask, bstp_notify_rtage, bp);

	<span class="enscript-comment">/* Init state */</span>
	bp-&gt;bp_infois = BSTP_INFO_DISABLED;
	bp-&gt;bp_flags = BSTP_PORT_AUTOEDGE|BSTP_PORT_AUTOPTP;
	bstp_set_port_state(bp, BSTP_IFSTATE_DISCARDING);
	bstp_set_port_proto(bp, bs-&gt;bs_protover);
	bstp_set_port_role(bp, BSTP_ROLE_DISABLED);
	bstp_set_port_tc(bp, BSTP_TCSTATE_INACTIVE);
	bp-&gt;bp_path_cost = bstp_calc_path_cost(bp);
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bstp_enable</span>(<span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;
	<span class="enscript-type">struct</span> ifnet *ifp = bp-&gt;bp_ifp;

	KASSERT(bp-&gt;bp_active == 0, (<span class="enscript-string">&quot;already a bstp member&quot;</span>));

	<span class="enscript-keyword">switch</span> (ifp-&gt;if_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ETHER</span>:	<span class="enscript-comment">/* These can do spanning tree. */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* Nothing else can. */</span>
			<span class="enscript-keyword">return</span> (EINVAL);
	}

	BSTP_LOCK(bs);
	LIST_INSERT_HEAD(&amp;bs-&gt;bs_bplist, bp, bp_next);
	bp-&gt;bp_active = 1;
	bp-&gt;bp_flags |= BSTP_PORT_NEWINFO;
	bstp_reinit(bs);
	bstp_update_roles(bs, bp);
	BSTP_UNLOCK(bs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_disable</span>(<span class="enscript-type">struct</span> bstp_port *bp)
{
	<span class="enscript-type">struct</span> bstp_state *bs = bp-&gt;bp_bs;

	KASSERT(bp-&gt;bp_active == 1, (<span class="enscript-string">&quot;not a bstp member&quot;</span>));

	BSTP_LOCK(bs);
	bstp_disable_port(bs, bp);
	LIST_REMOVE(bp, bp_next);
	bp-&gt;bp_active = 0;
	bstp_reinit(bs);
	BSTP_UNLOCK(bs);
}

<span class="enscript-comment">/*
 * The bstp_port structure is about to be freed by the parent bridge.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_destroy</span>(<span class="enscript-type">struct</span> bstp_port *bp)
{
	KASSERT(bp-&gt;bp_active == 0, (<span class="enscript-string">&quot;port is still attached&quot;</span>));
	bstp_task_drain(&amp;bp-&gt;bp_statetask);
	bstp_task_drain(&amp;bp-&gt;bp_rtagetask);
}


__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_sys_init</span>(<span class="enscript-type">void</span>)
{
	lck_grp_attr_t *lck_grp_attr = NULL;

	lck_grp_attr = lck_grp_attr_alloc_init();
	bstp_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;bstp&quot;</span>, lck_grp_attr);
	bstp_lock_attr = lck_attr_alloc_init();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	lck_attr_setdebug(bstp_lock_attr);
#<span class="enscript-reference">endif</span>
	lck_mtx_init(bstp_list_mtx, bstp_lock_grp, bstp_lock_attr);
	lck_grp_attr_free(lck_grp_attr);

	LIST_INIT(&amp;bstp_list);

	bstp_create_task_thread();
}



<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_create_task_thread</span>(<span class="enscript-type">void</span>)
{
	kern_return_t error;
	
	lck_grp_attr_t *lck_grp_attr = NULL;

	lck_grp_attr = lck_grp_attr_alloc_init();
	bstp_task_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;bstp_task&quot;</span>, lck_grp_attr);
	bstp_task_attr = lck_attr_alloc_init();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	lck_attr_setdebug(bstp_task_attr);
#<span class="enscript-reference">endif</span>
	lck_mtx_init(bstp_task_mtx, bstp_lock_grp, bstp_lock_attr);
	lck_grp_attr_free(lck_grp_attr);

	error = kernel_thread_start((thread_continue_t)bstp_task_thread_func, NULL, &amp;bstp_task_thread);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_task_thread_func</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> bstp_task *bt, *tvar;

	lck_mtx_lock(bstp_task_mtx);
	
	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">while</span>(TAILQ_EMPTY(&amp;bstp_task_queue)) {
			wakeup(&amp;bstp_task_queue_running);
			msleep(&amp;bstp_task_queue, bstp_task_mtx, PZERO, <span class="enscript-string">&quot;bstp_task_queue&quot;</span>, NULL);
		}
	
		TAILQ_FOREACH_SAFE(bt, &amp;bstp_task_queue, bt_next, tvar) {	
			<span class="enscript-type">int</span> count = bt-&gt;bt_count;
	
			bt-&gt;bt_count = 0;
		
			bstp_task_queue_running = bt;
			lck_mtx_unlock(bstp_task_mtx);
			
			(*bt-&gt;bt_func)(bt-&gt;bt_context, count);
			
			lck_mtx_lock(bstp_task_mtx);
			bstp_task_queue_running = NULL;

			<span class="enscript-keyword">if</span> (bt-&gt;bt_count == 0)
				TAILQ_REMOVE(&amp;bstp_task_queue, bt, bt_next); 
		}
	} <span class="enscript-keyword">while</span> (1);
	
	<span class="enscript-comment">/* UNREACHED */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_task_enqueue</span>(<span class="enscript-type">struct</span> bstp_task *bt)
{
	lck_mtx_lock(bstp_task_mtx);

	<span class="enscript-keyword">if</span> (bt-&gt;bt_count) {
		bt-&gt;bt_count++;
		lck_mtx_unlock(bstp_task_mtx);
		wakeup(&amp;bstp_task_queue);
		<span class="enscript-keyword">return</span>;
	}
	
	bt-&gt;bt_count = 1;
	TAILQ_INSERT_TAIL(&amp;bstp_task_queue, bt, bt_next);
	
	lck_mtx_unlock(bstp_task_mtx);
	
	wakeup(&amp;bstp_task_queue);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bstp_task_drain</span>(<span class="enscript-type">struct</span> bstp_task *bt)
{
	lck_mtx_lock(bstp_task_mtx);

	<span class="enscript-keyword">while</span> (bt-&gt;bt_count != 0 || bstp_task_queue_running == bt) {
		wakeup(&amp;bstp_task_queue);
		msleep(&amp;bstp_task_queue_running, bstp_task_mtx, PZERO, <span class="enscript-string">&quot;bstp_task_queue&quot;</span>, NULL);
	}
	lck_mtx_unlock(bstp_task_mtx);
}


</pre>
<hr />
</body></html>