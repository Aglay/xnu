<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>pf_ioctl.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">pf_ioctl.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$apfw: git commit b6bf13f8321283cd7ee82b1795e86506084b1b95 $ */</span>
<span class="enscript-comment">/*	$OpenBSD: pf_ioctl.c,v 1.175 2007/02/26 22:47:43 deraadt Exp $ */</span>

<span class="enscript-comment">/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002,2003 Henning Brauer
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/endian.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_icmp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/if_ether.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_dummynet.h&gt;</span>
#<span class="enscript-reference">else</span>
<span class="enscript-type">struct</span> ip_fw_args;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/md5.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfvar.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_pfsync.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PFLOG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_pflog.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFLOG */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/altq/altq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/altq/altq_cbq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/classq_red.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/classq_rio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/classq_blue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/classq_sfb.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pfdetach</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfopen</span>(dev_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfclose</span>(dev_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl</span>(dev_t, u_long, caddr_t, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_table</span>(u_long, <span class="enscript-type">struct</span> pfioc_table_32 *,
    <span class="enscript-type">struct</span> pfioc_table_64 *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_tokens</span>(u_long, <span class="enscript-type">struct</span> pfioc_tokens_32 *,
    <span class="enscript-type">struct</span> pfioc_tokens_64 *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_rule</span>(u_long, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> pfioc_rule *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_state_kill</span>(u_long, <span class="enscript-type">struct</span> pfioc_state_kill *,
    <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_state</span>(u_long, <span class="enscript-type">struct</span> pfioc_state *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_states</span>(u_long, <span class="enscript-type">struct</span> pfioc_states_32 *,
    <span class="enscript-type">struct</span> pfioc_states_64 *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_natlook</span>(u_long, <span class="enscript-type">struct</span> pfioc_natlook *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_tm</span>(u_long, <span class="enscript-type">struct</span> pfioc_tm *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_limit</span>(u_long, <span class="enscript-type">struct</span> pfioc_limit *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_pooladdr</span>(u_long, <span class="enscript-type">struct</span> pfioc_pooladdr *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_ruleset</span>(u_long, <span class="enscript-type">struct</span> pfioc_ruleset *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_trans</span>(u_long, <span class="enscript-type">struct</span> pfioc_trans_32 *,
    <span class="enscript-type">struct</span> pfioc_trans_64 *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_src_nodes</span>(u_long, <span class="enscript-type">struct</span> pfioc_src_nodes_32 *,
    <span class="enscript-type">struct</span> pfioc_src_nodes_64 *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_src_node_kill</span>(u_long, <span class="enscript-type">struct</span> pfioc_src_node_kill *,
    <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pfioctl_ioc_iface</span>(u_long, <span class="enscript-type">struct</span> pfioc_iface_32 *,
    <span class="enscript-type">struct</span> pfioc_iface_64 *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pf_pool *<span class="enscript-function-name">pf_get_pool</span>(<span class="enscript-type">char</span> *, u_int32_t, u_int8_t, u_int32_t,
    u_int8_t, u_int8_t, u_int8_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_mv_pool</span>(<span class="enscript-type">struct</span> pf_palist *, <span class="enscript-type">struct</span> pf_palist *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_empty_pool</span>(<span class="enscript-type">struct</span> pf_palist *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_begin_altq</span>(u_int32_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_rollback_altq</span>(u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_commit_altq</span>(u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_enable_altq</span>(<span class="enscript-type">struct</span> pf_altq *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_disable_altq</span>(<span class="enscript-type">struct</span> pf_altq *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_altq_copyin</span>(<span class="enscript-type">struct</span> pf_altq *, <span class="enscript-type">struct</span> pf_altq *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_altq_copyout</span>(<span class="enscript-type">struct</span> pf_altq *, <span class="enscript-type">struct</span> pf_altq *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_begin_rules</span>(u_int32_t *, <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_rollback_rules</span>(u_int32_t, <span class="enscript-type">int</span>, <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_setup_pfsync_matching</span>(<span class="enscript-type">struct</span> pf_ruleset *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_hash_rule</span>(MD5_CTX *, <span class="enscript-type">struct</span> pf_rule *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_hash_rule_addr</span>(MD5_CTX *, <span class="enscript-type">struct</span> pf_rule_addr *, u_int8_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_commit_rules</span>(u_int32_t, <span class="enscript-type">int</span>, <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_rule_copyin</span>(<span class="enscript-type">struct</span> pf_rule *, <span class="enscript-type">struct</span> pf_rule *, <span class="enscript-type">struct</span> proc *,
    <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_rule_copyout</span>(<span class="enscript-type">struct</span> pf_rule *, <span class="enscript-type">struct</span> pf_rule *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_state_export</span>(<span class="enscript-type">struct</span> pfsync_state *, <span class="enscript-type">struct</span> pf_state_key *,
    <span class="enscript-type">struct</span> pf_state *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_state_import</span>(<span class="enscript-type">struct</span> pfsync_state *, <span class="enscript-type">struct</span> pf_state_key *,
    <span class="enscript-type">struct</span> pf_state *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_pooladdr_copyin</span>(<span class="enscript-type">struct</span> pf_pooladdr *, <span class="enscript-type">struct</span> pf_pooladdr *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_pooladdr_copyout</span>(<span class="enscript-type">struct</span> pf_pooladdr *, <span class="enscript-type">struct</span> pf_pooladdr *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_expire_states_and_src_nodes</span>(<span class="enscript-type">struct</span> pf_rule *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_delete_rule_from_ruleset</span>(<span class="enscript-type">struct</span> pf_ruleset *,
    <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> pf_rule *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_addrwrap_setup</span>(<span class="enscript-type">struct</span> pf_addr_wrap *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_rule_setup</span>(<span class="enscript-type">struct</span> pfioc_rule *, <span class="enscript-type">struct</span> pf_rule *,
    <span class="enscript-type">struct</span> pf_ruleset *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_delete_rule_by_owner</span>(<span class="enscript-type">char</span> *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_delete_rule_by_ticket</span>(<span class="enscript-type">struct</span> pfioc_rule *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_ruleset_cleanup</span>(<span class="enscript-type">struct</span> pf_ruleset *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_deleterule_anchor_step_out</span>(<span class="enscript-type">struct</span> pf_ruleset **,
    <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> pf_rule **);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PF_CDEV_MAJOR</span>	(-1)

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cdevsw pf_cdevsw = {
	<span class="enscript-comment">/* open */</span>	pfopen,
	<span class="enscript-comment">/* close */</span>	pfclose,
	<span class="enscript-comment">/* read */</span>	eno_rdwrt,
	<span class="enscript-comment">/* write */</span>	eno_rdwrt,
	<span class="enscript-comment">/* ioctl */</span>	pfioctl,
	<span class="enscript-comment">/* stop */</span>	eno_stop,
	<span class="enscript-comment">/* reset */</span>	eno_reset,
	<span class="enscript-comment">/* tty */</span>	NULL,
	<span class="enscript-comment">/* select */</span>	eno_select,
	<span class="enscript-comment">/* mmap */</span>	eno_mmap,
	<span class="enscript-comment">/* strategy */</span>	eno_strat,
	<span class="enscript-comment">/* getc */</span>	eno_getc,
	<span class="enscript-comment">/* putc */</span>	eno_putc,
	<span class="enscript-comment">/* type */</span>	0
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_attach_hooks</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/* currently unused along with pfdetach() */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pf_detach_hooks</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * This is set during DIOCSTART/DIOCSTOP with pf_perim_lock held as writer,
 * and used in pf_af_hook() for performance optimization, such that packets
 * will enter pf_test() or pf_test6() only when PF is running.
 */</span>
<span class="enscript-type">int</span> pf_is_enabled = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
u_int32_t altq_allowed = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

u_int32_t pf_hash_seed;
int16_t pf_nat64_configured = 0;

<span class="enscript-comment">/*
 * These are the pf enabled reference counting variables
 */</span>
<span class="enscript-type">static</span> u_int64_t pf_enabled_ref_count;
<span class="enscript-type">static</span> u_int32_t nr_tokens = 0;
<span class="enscript-type">static</span> u_int64_t pffwrules;
<span class="enscript-type">static</span> u_int32_t pfdevcnt;

<span class="enscript-function-name">SLIST_HEAD</span>(list_head, pfioc_kernel_token);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> list_head token_list_head;

<span class="enscript-type">struct</span> pf_rule		 pf_default_rule;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_altq_running;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TAGID_MAX</span>	 50000
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">PF_ALTQ</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(pf_tags, pf_tagname)	pf_tags =
    TAILQ_HEAD_INITIALIZER(pf_tags);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* PF_ALTQ */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(pf_tags, pf_tagname)
    pf_tags = TAILQ_HEAD_INITIALIZER(pf_tags),
    pf_qids = TAILQ_HEAD_INITIALIZER(pf_qids);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">PF_QNAME_SIZE</span> != <span class="enscript-variable-name">PF_TAG_NAME_SIZE</span>)
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">PF_QNAME_SIZE</span> <span class="enscript-variable-name">must</span> <span class="enscript-variable-name">be</span> <span class="enscript-variable-name">equal</span> <span class="enscript-variable-name">to</span> <span class="enscript-variable-name">PF_TAG_NAME_SIZE</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> u_int16_t	 tagname2tag(<span class="enscript-type">struct</span> pf_tags *, <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 tag2tagname(<span class="enscript-type">struct</span> pf_tags *, u_int16_t, <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 tag_unref(<span class="enscript-type">struct</span> pf_tags *, u_int16_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_rtlabel_add(<span class="enscript-type">struct</span> pf_addr_wrap *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_rtlabel_remove(<span class="enscript-type">struct</span> pf_addr_wrap *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_rtlabel_copyout(<span class="enscript-type">struct</span> pf_addr_wrap *);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_inet_hook</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">int</span>,
    <span class="enscript-type">struct</span> ip_fw_args *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pf_inet6_hook</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">int</span>,
    <span class="enscript-type">struct</span> ip_fw_args *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DPFPRINTF</span>(n, x) if (pf_status.debug &gt;= (n)) printf x

<span class="enscript-comment">/*
 * Helper macros for ioctl structures which vary in size (32-bit vs. 64-bit)
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PFIOCX_STRUCT_DECL</span>(s)						\
<span class="enscript-type">struct</span> {								\
	<span class="enscript-type">union</span> {								\
		<span class="enscript-type">struct</span> s##_32	_s##_32;				\
		<span class="enscript-type">struct</span> s##_64	_s##_64;				\
	} _u;								\
} *s##_un = NULL							\

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PFIOCX_STRUCT_BEGIN</span>(a, s, _action) {				\
	VERIFY(s##_un == NULL);						\
	s##_un = _MALLOC(<span class="enscript-keyword">sizeof</span> (*s##_un), M_TEMP, M_WAITOK|M_ZERO);	\
	<span class="enscript-keyword">if</span> (s##_un == NULL) {						\
		_action							\
	} <span class="enscript-keyword">else</span> {							\
		<span class="enscript-keyword">if</span> (p64)						\
			bcopy(a, &amp;s##_un-&gt;_u._s##_64,			\
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> s##_64));			\
		<span class="enscript-keyword">else</span>							\
			bcopy(a, &amp;s##_un-&gt;_u._s##_32,			\
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> s##_32));			\
	}								\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PFIOCX_STRUCT_END</span>(s, a) {					\
	VERIFY(s##_un != NULL);						\
	<span class="enscript-keyword">if</span> (p64)							\
		bcopy(&amp;s##_un-&gt;_u._s##_64, a, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> s##_64));	\
	<span class="enscript-keyword">else</span>								\
		bcopy(&amp;s##_un-&gt;_u._s##_32, a, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> s##_32));	\
	_FREE(s##_un, M_TEMP);						\
	s##_un = NULL;							\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PFIOCX_STRUCT_ADDR32</span>(s)		(&amp;s##_un-&gt;_u._s##_32)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PFIOCX_STRUCT_ADDR64</span>(s)		(&amp;s##_un-&gt;_u._s##_64)

<span class="enscript-comment">/*
 * Helper macros for regular ioctl structures.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PFIOC_STRUCT_BEGIN</span>(a, v, _action) {				\
	VERIFY((v) == NULL);						\
	(v) = _MALLOC(<span class="enscript-keyword">sizeof</span> (*(v)), M_TEMP, M_WAITOK|M_ZERO);		\
	<span class="enscript-keyword">if</span> ((v) == NULL) {						\
		_action							\
	} <span class="enscript-keyword">else</span> {							\
		bcopy(a, v, <span class="enscript-keyword">sizeof</span> (*(v)));				\
	}								\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PFIOC_STRUCT_END</span>(v, a) {					\
	VERIFY((v) != NULL);						\
	bcopy(v, a, <span class="enscript-keyword">sizeof</span> (*(v)));					\
	_FREE(v, M_TEMP);						\
	(v) = NULL;							\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PFIOC_STRUCT_ADDR32</span>(s)		(&amp;s##_un-&gt;_u._s##_32)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PFIOC_STRUCT_ADDR64</span>(s)		(&amp;s##_un-&gt;_u._s##_64)

<span class="enscript-type">static</span> lck_attr_t *pf_perim_lock_attr;
<span class="enscript-type">static</span> lck_grp_t *pf_perim_lock_grp;
<span class="enscript-type">static</span> lck_grp_attr_t *pf_perim_lock_grp_attr;

<span class="enscript-type">static</span> lck_attr_t *pf_lock_attr;
<span class="enscript-type">static</span> lck_grp_t *pf_lock_grp;
<span class="enscript-type">static</span> lck_grp_attr_t *pf_lock_grp_attr;

<span class="enscript-type">struct</span> thread *pf_purge_thread;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pfi_kifaddr_update</span>(<span class="enscript-type">void</span> *);

<span class="enscript-comment">/* pf enable ref-counting helper functions */</span>
<span class="enscript-type">static</span> u_int64_t		generate_token(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>			remove_token(<span class="enscript-type">struct</span> pfioc_remove_token *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>			invalidate_all_tokens(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> u_int64_t
<span class="enscript-function-name">generate_token</span>(<span class="enscript-type">struct</span> proc *p)
{
	u_int64_t token_value;
	<span class="enscript-type">struct</span> pfioc_kernel_token *new_token;

	new_token = _MALLOC(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfioc_kernel_token), M_TEMP,
	    M_WAITOK|M_ZERO);

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (new_token == NULL) {
		<span class="enscript-comment">/* malloc failed! bail! */</span>
		printf(<span class="enscript-string">&quot;%s: unable to allocate pf token structure!&quot;</span>, __func__);
		<span class="enscript-keyword">return</span> (0);
	}

	token_value = VM_KERNEL_ADDRPERM((u_int64_t)(uintptr_t)new_token);

	new_token-&gt;token.token_value = token_value;
	new_token-&gt;token.pid = proc_pid(p);
	proc_name(new_token-&gt;token.pid, new_token-&gt;token.proc_name,
	    <span class="enscript-keyword">sizeof</span> (new_token-&gt;token.proc_name));
	new_token-&gt;token.timestamp = pf_calendar_time_second();

	SLIST_INSERT_HEAD(&amp;token_list_head, new_token, next);
	nr_tokens++;

	<span class="enscript-keyword">return</span> (token_value);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">remove_token</span>(<span class="enscript-type">struct</span> pfioc_remove_token *tok)
{
	<span class="enscript-type">struct</span> pfioc_kernel_token *entry, *tmp;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	SLIST_FOREACH_SAFE(entry, &amp;token_list_head, next, tmp) {
		<span class="enscript-keyword">if</span> (tok-&gt;token_value == entry-&gt;token.token_value) {
			SLIST_REMOVE(&amp;token_list_head, entry,
			    pfioc_kernel_token, next);
			_FREE(entry, M_TEMP);
			nr_tokens--;
			<span class="enscript-keyword">return</span> (0);    <span class="enscript-comment">/* success */</span>
		}
	}

	printf(<span class="enscript-string">&quot;pf : remove failure\n&quot;</span>);
	<span class="enscript-keyword">return</span> (ESRCH);    <span class="enscript-comment">/* failure */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">invalidate_all_tokens</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> pfioc_kernel_token *entry, *tmp;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	SLIST_FOREACH_SAFE(entry, &amp;token_list_head, next, tmp) {
		SLIST_REMOVE(&amp;token_list_head, entry, pfioc_kernel_token, next);
		_FREE(entry, M_TEMP);
	}

	nr_tokens = 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pfinit</span>(<span class="enscript-type">void</span>)
{
	u_int32_t *t = pf_default_rule.timeout;
	<span class="enscript-type">int</span> maj;

	pf_perim_lock_grp_attr = lck_grp_attr_alloc_init();
	pf_perim_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;pf_perim&quot;</span>,
	    pf_perim_lock_grp_attr);
	pf_perim_lock_attr = lck_attr_alloc_init();
	lck_rw_init(pf_perim_lock, pf_perim_lock_grp, pf_perim_lock_attr);

	pf_lock_grp_attr = lck_grp_attr_alloc_init();
	pf_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;pf&quot;</span>, pf_lock_grp_attr);
	pf_lock_attr = lck_attr_alloc_init();
	lck_mtx_init(pf_lock, pf_lock_grp, pf_lock_attr);

	pool_init(&amp;pf_rule_pl, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_rule), 0, 0, 0, <span class="enscript-string">&quot;pfrulepl&quot;</span>,
	    NULL);
	pool_init(&amp;pf_src_tree_pl, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_src_node), 0, 0, 0,
	    <span class="enscript-string">&quot;pfsrctrpl&quot;</span>, NULL);
	pool_init(&amp;pf_state_pl, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_state), 0, 0, 0, <span class="enscript-string">&quot;pfstatepl&quot;</span>,
	    NULL);
	pool_init(&amp;pf_state_key_pl, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_state_key), 0, 0, 0,
	    <span class="enscript-string">&quot;pfstatekeypl&quot;</span>, NULL);
	pool_init(&amp;pf_app_state_pl, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_app_state), 0, 0, 0,
	    <span class="enscript-string">&quot;pfappstatepl&quot;</span>, NULL);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	pool_init(&amp;pf_altq_pl, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_altq), 0, 0, 0, <span class="enscript-string">&quot;pfaltqpl&quot;</span>,
	    NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
	pool_init(&amp;pf_pooladdr_pl, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pooladdr), 0, 0, 0,
	    <span class="enscript-string">&quot;pfpooladdrpl&quot;</span>, NULL);
	pfr_initialize();
	pfi_initialize();
	pf_osfp_initialize();

	pool_sethardlimit(pf_pool_limits[PF_LIMIT_STATES].pp,
	    pf_pool_limits[PF_LIMIT_STATES].limit, NULL, 0);

	<span class="enscript-keyword">if</span> (max_mem &lt;= 256*1024*1024)
		pf_pool_limits[PF_LIMIT_TABLE_ENTRIES].limit =
		    PFR_KENTRY_HIWAT_SMALL;

	RB_INIT(&amp;tree_src_tracking);
	RB_INIT(&amp;pf_anchors);
	pf_init_ruleset(&amp;pf_main_ruleset);
	TAILQ_INIT(&amp;pf_pabuf);
	TAILQ_INIT(&amp;state_list);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	TAILQ_INIT(&amp;pf_altqs[0]);
	TAILQ_INIT(&amp;pf_altqs[1]);
	pf_altqs_active = &amp;pf_altqs[0];
	pf_altqs_inactive = &amp;pf_altqs[1];

	PE_parse_boot_argn(<span class="enscript-string">&quot;altq&quot;</span>, &amp;altq_allowed, <span class="enscript-keyword">sizeof</span> (altq_allowed));

	_CASSERT(ALTRQ_PURGE == CLASSQRQ_PURGE);
	_CASSERT(ALTRQ_PURGE_SC == CLASSQRQ_PURGE_SC);
	_CASSERT(ALTRQ_EVENT == CLASSQRQ_EVENT);

	_CASSERT(ALTDQ_REMOVE == CLASSQDQ_REMOVE);
	_CASSERT(ALTDQ_POLL == CLASSQDQ_POLL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

	_CASSERT((SC_BE &amp; SCIDX_MASK) == SCIDX_BE);
	_CASSERT((SC_BK_SYS &amp; SCIDX_MASK) == SCIDX_BK_SYS);
	_CASSERT((SC_BK &amp; SCIDX_MASK) == SCIDX_BK);
	_CASSERT((SC_RD &amp; SCIDX_MASK) == SCIDX_RD);
	_CASSERT((SC_OAM &amp; SCIDX_MASK) == SCIDX_OAM);
	_CASSERT((SC_AV &amp; SCIDX_MASK) == SCIDX_AV);
	_CASSERT((SC_RV &amp; SCIDX_MASK) == SCIDX_RV);
	_CASSERT((SC_VI &amp; SCIDX_MASK) == SCIDX_VI);
	_CASSERT((SC_VO &amp; SCIDX_MASK) == SCIDX_VO);
	_CASSERT((SC_CTL &amp; SCIDX_MASK) == SCIDX_CTL);

	<span class="enscript-comment">/* default rule should never be garbage collected */</span>
	pf_default_rule.entries.tqe_prev = &amp;pf_default_rule.entries.tqe_next;
	pf_default_rule.action = PF_PASS;
	pf_default_rule.nr = -1;
	pf_default_rule.rtableid = IFSCOPE_NONE;

	<span class="enscript-comment">/* initialize default timeouts */</span>
	t[PFTM_TCP_FIRST_PACKET] = PFTM_TCP_FIRST_PACKET_VAL;
	t[PFTM_TCP_OPENING] = PFTM_TCP_OPENING_VAL;
	t[PFTM_TCP_ESTABLISHED] = PFTM_TCP_ESTABLISHED_VAL;
	t[PFTM_TCP_CLOSING] = PFTM_TCP_CLOSING_VAL;
	t[PFTM_TCP_FIN_WAIT] = PFTM_TCP_FIN_WAIT_VAL;
	t[PFTM_TCP_CLOSED] = PFTM_TCP_CLOSED_VAL;
	t[PFTM_UDP_FIRST_PACKET] = PFTM_UDP_FIRST_PACKET_VAL;
	t[PFTM_UDP_SINGLE] = PFTM_UDP_SINGLE_VAL;
	t[PFTM_UDP_MULTIPLE] = PFTM_UDP_MULTIPLE_VAL;
	t[PFTM_ICMP_FIRST_PACKET] = PFTM_ICMP_FIRST_PACKET_VAL;
	t[PFTM_ICMP_ERROR_REPLY] = PFTM_ICMP_ERROR_REPLY_VAL;
	t[PFTM_GREv1_FIRST_PACKET] = PFTM_GREv1_FIRST_PACKET_VAL;
	t[PFTM_GREv1_INITIATING] = PFTM_GREv1_INITIATING_VAL;
	t[PFTM_GREv1_ESTABLISHED] = PFTM_GREv1_ESTABLISHED_VAL;
	t[PFTM_ESP_FIRST_PACKET] = PFTM_ESP_FIRST_PACKET_VAL;
	t[PFTM_ESP_INITIATING] = PFTM_ESP_INITIATING_VAL;
	t[PFTM_ESP_ESTABLISHED] = PFTM_ESP_ESTABLISHED_VAL;
	t[PFTM_OTHER_FIRST_PACKET] = PFTM_OTHER_FIRST_PACKET_VAL;
	t[PFTM_OTHER_SINGLE] = PFTM_OTHER_SINGLE_VAL;
	t[PFTM_OTHER_MULTIPLE] = PFTM_OTHER_MULTIPLE_VAL;
	t[PFTM_FRAG] = PFTM_FRAG_VAL;
	t[PFTM_INTERVAL] = PFTM_INTERVAL_VAL;
	t[PFTM_SRC_NODE] = PFTM_SRC_NODE_VAL;
	t[PFTM_TS_DIFF] = PFTM_TS_DIFF_VAL;
	t[PFTM_ADAPTIVE_START] = PFSTATE_ADAPT_START;
	t[PFTM_ADAPTIVE_END] = PFSTATE_ADAPT_END;

	pf_normalize_init();
	bzero(&amp;pf_status, <span class="enscript-keyword">sizeof</span> (pf_status));
	pf_status.debug = PF_DEBUG_URGENT;
	pf_hash_seed = RandomULong();

	<span class="enscript-comment">/* XXX do our best to avoid a conflict */</span>
	pf_status.hostid = random();

	<span class="enscript-keyword">if</span> (kernel_thread_start(pf_purge_thread_fn, NULL,
	    &amp;pf_purge_thread) != 0) {
		printf(<span class="enscript-string">&quot;%s: unable to start purge thread!&quot;</span>, __func__);
		<span class="enscript-keyword">return</span>;
	}

	maj = cdevsw_add(PF_CDEV_MAJOR, &amp;pf_cdevsw);
	<span class="enscript-keyword">if</span> (maj == -1) {
		printf(<span class="enscript-string">&quot;%s: failed to allocate major number!\n&quot;</span>, __func__);
		<span class="enscript-keyword">return</span>;
	}
	(<span class="enscript-type">void</span>) devfs_make_node(makedev(maj, PFDEV_PF), DEVFS_CHAR,
	    UID_ROOT, GID_WHEEL, 0600, <span class="enscript-string">&quot;pf&quot;</span>, 0);

	(<span class="enscript-type">void</span>) devfs_make_node(makedev(maj, PFDEV_PFM), DEVFS_CHAR,
	    UID_ROOT, GID_WHEEL, 0600, <span class="enscript-string">&quot;pfm&quot;</span>, 0);

	pf_attach_hooks();
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pfdetach</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> pf_anchor	*anchor;
	<span class="enscript-type">struct</span> pf_state		*state;
	<span class="enscript-type">struct</span> pf_src_node	*node;
	<span class="enscript-type">struct</span> pfioc_table	pt;
	u_int32_t		ticket;
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">char</span>			r = <span class="enscript-string">'\0'</span>;

	pf_detach_hooks();

	pf_status.running = 0;
	wakeup(pf_purge_thread_fn);

	<span class="enscript-comment">/* clear the rulesets */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; PF_RULESET_MAX; i++)
		<span class="enscript-keyword">if</span> (pf_begin_rules(&amp;ticket, i, &amp;r) == 0)
				pf_commit_rules(ticket, i, &amp;r);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">if</span> (pf_begin_altq(&amp;ticket) == 0)
		pf_commit_altq(ticket);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

	<span class="enscript-comment">/* clear states */</span>
	RB_FOREACH(state, pf_state_tree_id, &amp;tree_id) {
		state-&gt;timeout = PFTM_PURGE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
		state-&gt;sync_flags = PFSTATE_NOSYNC;
#<span class="enscript-reference">endif</span>
	}
	pf_purge_expired_states(pf_status.states);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
	pfsync_clear_states(pf_status.hostid, NULL);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* clear source nodes */</span>
	RB_FOREACH(state, pf_state_tree_id, &amp;tree_id) {
		state-&gt;src_node = NULL;
		state-&gt;nat_src_node = NULL;
	}
	RB_FOREACH(node, pf_src_tree, &amp;tree_src_tracking) {
		node-&gt;expire = 1;
		node-&gt;states = 0;
	}
	pf_purge_expired_src_nodes();

	<span class="enscript-comment">/* clear tables */</span>
	memset(&amp;pt, <span class="enscript-string">'\0'</span>, <span class="enscript-keyword">sizeof</span> (pt));
	pfr_clr_tables(&amp;pt.pfrio_table, &amp;pt.pfrio_ndel, pt.pfrio_flags);

	<span class="enscript-comment">/* destroy anchors */</span>
	<span class="enscript-keyword">while</span> ((anchor = RB_MIN(pf_anchor_global, &amp;pf_anchors)) != NULL) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; PF_RULESET_MAX; i++)
			<span class="enscript-keyword">if</span> (pf_begin_rules(&amp;ticket, i, anchor-&gt;name) == 0)
				pf_commit_rules(ticket, i, anchor-&gt;name);
	}

	<span class="enscript-comment">/* destroy main ruleset */</span>
	pf_remove_if_empty_ruleset(&amp;pf_main_ruleset);

	<span class="enscript-comment">/* destroy the pools */</span>
	pool_destroy(&amp;pf_pooladdr_pl);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	pool_destroy(&amp;pf_altq_pl);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
	pool_destroy(&amp;pf_state_pl);
	pool_destroy(&amp;pf_rule_pl);
	pool_destroy(&amp;pf_src_tree_pl);

	<span class="enscript-comment">/* destroy subsystems */</span>
	pf_normalize_destroy();
	pf_osfp_destroy();
	pfr_destroy();
	pfi_destroy();
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfopen</span>(dev_t dev, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> fmt, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">flags</span>, <span class="enscript-variable-name">fmt</span>, <span class="enscript-variable-name">p</span>)
	<span class="enscript-keyword">if</span> (minor(dev) &gt;= PFDEV_MAX)
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (minor(dev) == PFDEV_PFM) {
		lck_mtx_lock(pf_lock);
		<span class="enscript-keyword">if</span> (pfdevcnt != 0) {
			lck_mtx_unlock(pf_lock);
			<span class="enscript-keyword">return</span> (EBUSY);
		}
		pfdevcnt++;
		lck_mtx_unlock(pf_lock);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfclose</span>(dev_t dev, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> fmt, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">flags</span>, <span class="enscript-variable-name">fmt</span>, <span class="enscript-variable-name">p</span>)
	<span class="enscript-keyword">if</span> (minor(dev) &gt;= PFDEV_MAX)
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (minor(dev) == PFDEV_PFM) {
		lck_mtx_lock(pf_lock);
		VERIFY(pfdevcnt &gt; 0);
		pfdevcnt--;
		lck_mtx_unlock(pf_lock);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pf_pool *
<span class="enscript-function-name">pf_get_pool</span>(<span class="enscript-type">char</span> *anchor, u_int32_t ticket, u_int8_t rule_action,
    u_int32_t rule_number, u_int8_t r_last, u_int8_t active,
    u_int8_t check_ticket)
{
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset;
	<span class="enscript-type">struct</span> pf_rule		*rule;
	<span class="enscript-type">int</span>			 rs_num;

	ruleset = pf_find_ruleset(anchor);
	<span class="enscript-keyword">if</span> (ruleset == NULL)
		<span class="enscript-keyword">return</span> (NULL);
	rs_num = pf_get_ruleset_number(rule_action);
	<span class="enscript-keyword">if</span> (rs_num &gt;= PF_RULESET_MAX)
		<span class="enscript-keyword">return</span> (NULL);
	<span class="enscript-keyword">if</span> (active) {
		<span class="enscript-keyword">if</span> (check_ticket &amp;&amp; ticket !=
		    ruleset-&gt;rules[rs_num].active.ticket)
			<span class="enscript-keyword">return</span> (NULL);
		<span class="enscript-keyword">if</span> (r_last)
			rule = TAILQ_LAST(ruleset-&gt;rules[rs_num].active.ptr,
			    pf_rulequeue);
		<span class="enscript-keyword">else</span>
			rule = TAILQ_FIRST(ruleset-&gt;rules[rs_num].active.ptr);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (check_ticket &amp;&amp; ticket !=
		    ruleset-&gt;rules[rs_num].inactive.ticket)
			<span class="enscript-keyword">return</span> (NULL);
		<span class="enscript-keyword">if</span> (r_last)
			rule = TAILQ_LAST(ruleset-&gt;rules[rs_num].inactive.ptr,
			    pf_rulequeue);
		<span class="enscript-keyword">else</span>
			rule = TAILQ_FIRST(ruleset-&gt;rules[rs_num].inactive.ptr);
	}
	<span class="enscript-keyword">if</span> (!r_last) {
		<span class="enscript-keyword">while</span> ((rule != NULL) &amp;&amp; (rule-&gt;nr != rule_number))
			rule = TAILQ_NEXT(rule, entries);
	}
	<span class="enscript-keyword">if</span> (rule == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">return</span> (&amp;rule-&gt;rpool);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_mv_pool</span>(<span class="enscript-type">struct</span> pf_palist *poola, <span class="enscript-type">struct</span> pf_palist *poolb)
{
	<span class="enscript-type">struct</span> pf_pooladdr	*mv_pool_pa;

	<span class="enscript-keyword">while</span> ((mv_pool_pa = TAILQ_FIRST(poola)) != NULL) {
		TAILQ_REMOVE(poola, mv_pool_pa, entries);
		TAILQ_INSERT_TAIL(poolb, mv_pool_pa, entries);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_empty_pool</span>(<span class="enscript-type">struct</span> pf_palist *poola)
{
	<span class="enscript-type">struct</span> pf_pooladdr	*empty_pool_pa;

	<span class="enscript-keyword">while</span> ((empty_pool_pa = TAILQ_FIRST(poola)) != NULL) {
		pfi_dynaddr_remove(&amp;empty_pool_pa-&gt;addr);
		pf_tbladdr_remove(&amp;empty_pool_pa-&gt;addr);
		pfi_kif_unref(empty_pool_pa-&gt;kif, PFI_KIF_REF_RULE);
		TAILQ_REMOVE(poola, empty_pool_pa, entries);
		pool_put(&amp;pf_pooladdr_pl, empty_pool_pa);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_rm_rule</span>(<span class="enscript-type">struct</span> pf_rulequeue *rulequeue, <span class="enscript-type">struct</span> pf_rule *rule)
{
	<span class="enscript-keyword">if</span> (rulequeue != NULL) {
		<span class="enscript-keyword">if</span> (rule-&gt;states &lt;= 0) {
			<span class="enscript-comment">/*
			 * XXX - we need to remove the table *before* detaching
			 * the rule to make sure the table code does not delete
			 * the anchor under our feet.
			 */</span>
			pf_tbladdr_remove(&amp;rule-&gt;src.addr);
			pf_tbladdr_remove(&amp;rule-&gt;dst.addr);
			<span class="enscript-keyword">if</span> (rule-&gt;overload_tbl)
				pfr_detach_table(rule-&gt;overload_tbl);
		}
		TAILQ_REMOVE(rulequeue, rule, entries);
		rule-&gt;entries.tqe_prev = NULL;
		rule-&gt;nr = -1;
	}

	<span class="enscript-keyword">if</span> (rule-&gt;states &gt; 0 || rule-&gt;src_nodes &gt; 0 ||
	    rule-&gt;entries.tqe_prev != NULL)
		<span class="enscript-keyword">return</span>;
	pf_tag_unref(rule-&gt;tag);
	pf_tag_unref(rule-&gt;match_tag);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">if</span> (altq_allowed) {
		<span class="enscript-keyword">if</span> (rule-&gt;pqid != rule-&gt;qid)
			pf_qid_unref(rule-&gt;pqid);
		pf_qid_unref(rule-&gt;qid);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
	pf_rtlabel_remove(&amp;rule-&gt;src.addr);
	pf_rtlabel_remove(&amp;rule-&gt;dst.addr);
	pfi_dynaddr_remove(&amp;rule-&gt;src.addr);
	pfi_dynaddr_remove(&amp;rule-&gt;dst.addr);
	<span class="enscript-keyword">if</span> (rulequeue == NULL) {
		pf_tbladdr_remove(&amp;rule-&gt;src.addr);
		pf_tbladdr_remove(&amp;rule-&gt;dst.addr);
		<span class="enscript-keyword">if</span> (rule-&gt;overload_tbl)
			pfr_detach_table(rule-&gt;overload_tbl);
	}
	pfi_kif_unref(rule-&gt;kif, PFI_KIF_REF_RULE);
	pf_anchor_remove(rule);
	pf_empty_pool(&amp;rule-&gt;rpool.list);
	pool_put(&amp;pf_rule_pl, rule);
}

<span class="enscript-type">static</span> u_int16_t
<span class="enscript-function-name">tagname2tag</span>(<span class="enscript-type">struct</span> pf_tags *head, <span class="enscript-type">char</span> *tagname)
{
	<span class="enscript-type">struct</span> pf_tagname	*tag, *p = NULL;
	u_int16_t		 new_tagid = 1;

	TAILQ_FOREACH(tag, head, entries)
		<span class="enscript-keyword">if</span> (strcmp(tagname, tag-&gt;name) == 0) {
			tag-&gt;ref++;
			<span class="enscript-keyword">return</span> (tag-&gt;tag);
		}

	<span class="enscript-comment">/*
	 * to avoid fragmentation, we do a linear search from the beginning
	 * and take the first free slot we find. if there is none or the list
	 * is empty, append a new entry at the end.
	 */</span>

	<span class="enscript-comment">/* new entry */</span>
	<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(head))
		<span class="enscript-keyword">for</span> (p = TAILQ_FIRST(head); p != NULL &amp;&amp;
		    p-&gt;tag == new_tagid; p = TAILQ_NEXT(p, entries))
			new_tagid = p-&gt;tag + 1;

	<span class="enscript-keyword">if</span> (new_tagid &gt; TAGID_MAX)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* allocate and fill new struct pf_tagname */</span>
	tag = _MALLOC(<span class="enscript-keyword">sizeof</span> (*tag), M_TEMP, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (tag == NULL)
		<span class="enscript-keyword">return</span> (0);
	strlcpy(tag-&gt;name, tagname, <span class="enscript-keyword">sizeof</span> (tag-&gt;name));
	tag-&gt;tag = new_tagid;
	tag-&gt;ref++;

	<span class="enscript-keyword">if</span> (p != NULL)	<span class="enscript-comment">/* insert new entry before p */</span>
		TAILQ_INSERT_BEFORE(p, tag, entries);
	<span class="enscript-keyword">else</span>	<span class="enscript-comment">/* either list empty or no free slot in between */</span>
		TAILQ_INSERT_TAIL(head, tag, entries);

	<span class="enscript-keyword">return</span> (tag-&gt;tag);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tag2tagname</span>(<span class="enscript-type">struct</span> pf_tags *head, u_int16_t tagid, <span class="enscript-type">char</span> *p)
{
	<span class="enscript-type">struct</span> pf_tagname	*tag;

	TAILQ_FOREACH(tag, head, entries)
		<span class="enscript-keyword">if</span> (tag-&gt;tag == tagid) {
			strlcpy(p, tag-&gt;name, PF_TAG_NAME_SIZE);
			<span class="enscript-keyword">return</span>;
		}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tag_unref</span>(<span class="enscript-type">struct</span> pf_tags *head, u_int16_t tag)
{
	<span class="enscript-type">struct</span> pf_tagname	*p, *next;

	<span class="enscript-keyword">if</span> (tag == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">for</span> (p = TAILQ_FIRST(head); p != NULL; p = next) {
		next = TAILQ_NEXT(p, entries);
		<span class="enscript-keyword">if</span> (tag == p-&gt;tag) {
			<span class="enscript-keyword">if</span> (--p-&gt;ref == 0) {
				TAILQ_REMOVE(head, p, entries);
				_FREE(p, M_TEMP);
			}
			<span class="enscript-keyword">break</span>;
		}
	}
}

u_int16_t
<span class="enscript-function-name">pf_tagname2tag</span>(<span class="enscript-type">char</span> *tagname)
{
	<span class="enscript-keyword">return</span> (tagname2tag(&amp;pf_tags, tagname));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_tag2tagname</span>(u_int16_t tagid, <span class="enscript-type">char</span> *p)
{
	tag2tagname(&amp;pf_tags, tagid, p);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_tag_ref</span>(u_int16_t tag)
{
	<span class="enscript-type">struct</span> pf_tagname *t;

	TAILQ_FOREACH(t, &amp;pf_tags, entries)
		<span class="enscript-keyword">if</span> (t-&gt;tag == tag)
			<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">if</span> (t != NULL)
		t-&gt;ref++;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_tag_unref</span>(u_int16_t tag)
{
	tag_unref(&amp;pf_tags, tag);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_rtlabel_add</span>(<span class="enscript-type">struct</span> pf_addr_wrap *a)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">a</span>)
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_rtlabel_remove</span>(<span class="enscript-type">struct</span> pf_addr_wrap *a)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">a</span>)
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_rtlabel_copyout</span>(<span class="enscript-type">struct</span> pf_addr_wrap *a)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">a</span>)
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
u_int32_t
<span class="enscript-function-name">pf_qname2qid</span>(<span class="enscript-type">char</span> *qname)
{
	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">return</span> ((u_int32_t)tagname2tag(&amp;pf_qids, qname));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_qid2qname</span>(u_int32_t qid, <span class="enscript-type">char</span> *p)
{
	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	tag2tagname(&amp;pf_qids, (u_int16_t)qid, p);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_qid_unref</span>(u_int32_t qid)
{
	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	tag_unref(&amp;pf_qids, (u_int16_t)qid);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_begin_altq</span>(u_int32_t *ticket)
{
	<span class="enscript-type">struct</span> pf_altq	*altq;
	<span class="enscript-type">int</span>		 error = 0;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* Purge the old altq list */</span>
	<span class="enscript-keyword">while</span> ((altq = TAILQ_FIRST(pf_altqs_inactive)) != NULL) {
		TAILQ_REMOVE(pf_altqs_inactive, altq, entries);
		<span class="enscript-keyword">if</span> (altq-&gt;qname[0] == <span class="enscript-string">'\0'</span>) {
			<span class="enscript-comment">/* detach and destroy the discipline */</span>
			error = altq_remove(altq);
		} <span class="enscript-keyword">else</span>
			pf_qid_unref(altq-&gt;qid);
		pool_put(&amp;pf_altq_pl, altq);
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	*ticket = ++ticket_altqs_inactive;
	altqs_inactive_open = 1;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_rollback_altq</span>(u_int32_t ticket)
{
	<span class="enscript-type">struct</span> pf_altq	*altq;
	<span class="enscript-type">int</span>		 error = 0;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!altqs_inactive_open || ticket != ticket_altqs_inactive)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-comment">/* Purge the old altq list */</span>
	<span class="enscript-keyword">while</span> ((altq = TAILQ_FIRST(pf_altqs_inactive)) != NULL) {
		TAILQ_REMOVE(pf_altqs_inactive, altq, entries);
		<span class="enscript-keyword">if</span> (altq-&gt;qname[0] == <span class="enscript-string">'\0'</span>) {
			<span class="enscript-comment">/* detach and destroy the discipline */</span>
			error = altq_remove(altq);
		} <span class="enscript-keyword">else</span>
			pf_qid_unref(altq-&gt;qid);
		pool_put(&amp;pf_altq_pl, altq);
	}
	altqs_inactive_open = 0;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_commit_altq</span>(u_int32_t ticket)
{
	<span class="enscript-type">struct</span> pf_altqqueue	*old_altqs;
	<span class="enscript-type">struct</span> pf_altq		*altq;
	<span class="enscript-type">int</span>			 err, error = 0;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!altqs_inactive_open || ticket != ticket_altqs_inactive)
		<span class="enscript-keyword">return</span> (EBUSY);

	<span class="enscript-comment">/* swap altqs, keep the old. */</span>
	old_altqs = pf_altqs_active;
	pf_altqs_active = pf_altqs_inactive;
	pf_altqs_inactive = old_altqs;
	ticket_altqs_active = ticket_altqs_inactive;

	<span class="enscript-comment">/* Attach new disciplines */</span>
	TAILQ_FOREACH(altq, pf_altqs_active, entries) {
		<span class="enscript-keyword">if</span> (altq-&gt;qname[0] == <span class="enscript-string">'\0'</span>) {
			<span class="enscript-comment">/* attach the discipline */</span>
			error = altq_pfattach(altq);
			<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; pf_altq_running)
				error = pf_enable_altq(altq);
			<span class="enscript-keyword">if</span> (error != 0) {
				<span class="enscript-keyword">return</span> (error);
			}
		}
	}

	<span class="enscript-comment">/* Purge the old altq list */</span>
	<span class="enscript-keyword">while</span> ((altq = TAILQ_FIRST(pf_altqs_inactive)) != NULL) {
		TAILQ_REMOVE(pf_altqs_inactive, altq, entries);
		<span class="enscript-keyword">if</span> (altq-&gt;qname[0] == <span class="enscript-string">'\0'</span>) {
			<span class="enscript-comment">/* detach and destroy the discipline */</span>
			<span class="enscript-keyword">if</span> (pf_altq_running)
				error = pf_disable_altq(altq);
			err = altq_pfdetach(altq);
			<span class="enscript-keyword">if</span> (err != 0 &amp;&amp; error == 0)
				error = err;
			err = altq_remove(altq);
			<span class="enscript-keyword">if</span> (err != 0 &amp;&amp; error == 0)
				error = err;
		} <span class="enscript-keyword">else</span>
			pf_qid_unref(altq-&gt;qid);
		pool_put(&amp;pf_altq_pl, altq);
	}

	altqs_inactive_open = 0;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_enable_altq</span>(<span class="enscript-type">struct</span> pf_altq *altq)
{
	<span class="enscript-type">struct</span> ifnet		*ifp;
	<span class="enscript-type">struct</span> ifclassq		*ifq;
	<span class="enscript-type">int</span>			 error = 0;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> ((ifp = ifunit(altq-&gt;ifname)) == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifq = &amp;ifp-&gt;if_snd;
	IFCQ_LOCK(ifq);
	<span class="enscript-keyword">if</span> (IFCQ_ALTQ(ifq)-&gt;altq_type != ALTQT_NONE)
		error = altq_enable(IFCQ_ALTQ(ifq));

	<span class="enscript-comment">/* set or clear tokenbucket regulator */</span>
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; ifp != NULL &amp;&amp; ALTQ_IS_ENABLED(IFCQ_ALTQ(ifq))) {
		<span class="enscript-type">struct</span> tb_profile tb = { 0, 0, 0 };

		<span class="enscript-keyword">if</span> (altq-&gt;aflags &amp; PF_ALTQF_TBR) {
			<span class="enscript-keyword">if</span> (altq-&gt;bwtype != PF_ALTQ_BW_ABSOLUTE &amp;&amp;
			    altq-&gt;bwtype != PF_ALTQ_BW_PERCENT) {
				error = EINVAL;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (altq-&gt;bwtype == PF_ALTQ_BW_ABSOLUTE)
					tb.rate = altq-&gt;ifbandwidth;
				<span class="enscript-keyword">else</span>
					tb.percent = altq-&gt;ifbandwidth;
				tb.depth = altq-&gt;tbrsize;
				error = ifclassq_tbr_set(ifq, &amp;tb, TRUE);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq)) {
			error = ifclassq_tbr_set(ifq, &amp;tb, TRUE);
		}
	}
	IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_disable_altq</span>(<span class="enscript-type">struct</span> pf_altq *altq)
{
	<span class="enscript-type">struct</span> ifnet		*ifp;
	<span class="enscript-type">struct</span> ifclassq		*ifq;
	<span class="enscript-type">int</span>			 error;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> ((ifp = ifunit(altq-&gt;ifname)) == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/*
	 * when the discipline is no longer referenced, it was overridden
	 * by a new one.  if so, just return.
	 */</span>
	ifq = &amp;ifp-&gt;if_snd;
	IFCQ_LOCK(ifq);
	<span class="enscript-keyword">if</span> (altq-&gt;altq_disc != IFCQ_ALTQ(ifq)-&gt;altq_disc) {
		IFCQ_UNLOCK(ifq);
		<span class="enscript-keyword">return</span> (0);
	}

	error = altq_disable(IFCQ_ALTQ(ifq));

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; IFCQ_TBR_IS_ENABLED(ifq)) {
		<span class="enscript-comment">/* clear tokenbucket regulator */</span>
		<span class="enscript-type">struct</span> tb_profile  tb = { 0, 0, 0 };
		error = ifclassq_tbr_set(ifq, &amp;tb, TRUE);
	}
	IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_altq_copyin</span>(<span class="enscript-type">struct</span> pf_altq *src, <span class="enscript-type">struct</span> pf_altq *dst)
{
	bcopy(src, dst, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_altq));

	dst-&gt;ifname[<span class="enscript-keyword">sizeof</span> (dst-&gt;ifname) - 1] = <span class="enscript-string">'\0'</span>;
	dst-&gt;qname[<span class="enscript-keyword">sizeof</span> (dst-&gt;qname) - 1] = <span class="enscript-string">'\0'</span>;
	dst-&gt;parent[<span class="enscript-keyword">sizeof</span> (dst-&gt;parent) - 1] = <span class="enscript-string">'\0'</span>;
	dst-&gt;altq_disc = NULL;
	dst-&gt;entries.tqe_next = NULL;
	dst-&gt;entries.tqe_prev = NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_altq_copyout</span>(<span class="enscript-type">struct</span> pf_altq *src, <span class="enscript-type">struct</span> pf_altq *dst)
{
	<span class="enscript-type">struct</span> pf_altq pa;

	bcopy(src, &amp;pa, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_altq));
	pa.altq_disc = NULL;
	pa.entries.tqe_next = NULL;
	pa.entries.tqe_prev = NULL;
	bcopy(&amp;pa, dst, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_altq));
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_begin_rules</span>(u_int32_t *ticket, <span class="enscript-type">int</span> rs_num, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *anchor)
{
	<span class="enscript-type">struct</span> pf_ruleset	*rs;
	<span class="enscript-type">struct</span> pf_rule		*rule;

	<span class="enscript-keyword">if</span> (rs_num &lt; 0 || rs_num &gt;= PF_RULESET_MAX)
		<span class="enscript-keyword">return</span> (EINVAL);
	rs = pf_find_or_create_ruleset(anchor);
	<span class="enscript-keyword">if</span> (rs == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">while</span> ((rule = TAILQ_FIRST(rs-&gt;rules[rs_num].inactive.ptr)) != NULL) {
		pf_rm_rule(rs-&gt;rules[rs_num].inactive.ptr, rule);
		rs-&gt;rules[rs_num].inactive.rcount--;
	}
	*ticket = ++rs-&gt;rules[rs_num].inactive.ticket;
	rs-&gt;rules[rs_num].inactive.open = 1;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_rollback_rules</span>(u_int32_t ticket, <span class="enscript-type">int</span> rs_num, <span class="enscript-type">char</span> *anchor)
{
	<span class="enscript-type">struct</span> pf_ruleset	*rs;
	<span class="enscript-type">struct</span> pf_rule		*rule;

	<span class="enscript-keyword">if</span> (rs_num &lt; 0 || rs_num &gt;= PF_RULESET_MAX)
		<span class="enscript-keyword">return</span> (EINVAL);
	rs = pf_find_ruleset(anchor);
	<span class="enscript-keyword">if</span> (rs == NULL || !rs-&gt;rules[rs_num].inactive.open ||
	    rs-&gt;rules[rs_num].inactive.ticket != ticket)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">while</span> ((rule = TAILQ_FIRST(rs-&gt;rules[rs_num].inactive.ptr)) != NULL) {
		pf_rm_rule(rs-&gt;rules[rs_num].inactive.ptr, rule);
		rs-&gt;rules[rs_num].inactive.rcount--;
	}
	rs-&gt;rules[rs_num].inactive.open = 0;
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PF_MD5_UPD</span>(st, elm)						\
	MD5Update(ctx, (u_int8_t *)&amp;(st)-&gt;elm, <span class="enscript-keyword">sizeof</span> ((st)-&gt;elm))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PF_MD5_UPD_STR</span>(st, elm)						\
	MD5Update(ctx, (u_int8_t *)(st)-&gt;elm, strlen((st)-&gt;elm))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PF_MD5_UPD_HTONL</span>(st, elm, stor) do {				\
	(stor) = htonl((st)-&gt;elm);					\
	MD5Update(ctx, (u_int8_t *)&amp;(stor), <span class="enscript-keyword">sizeof</span> (u_int32_t));	\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PF_MD5_UPD_HTONS</span>(st, elm, stor) do {				\
	(stor) = htons((st)-&gt;elm);					\
	MD5Update(ctx, (u_int8_t *)&amp;(stor), <span class="enscript-keyword">sizeof</span> (u_int16_t));	\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_hash_rule_addr</span>(MD5_CTX *ctx, <span class="enscript-type">struct</span> pf_rule_addr *pfr, u_int8_t proto)
{
	PF_MD5_UPD(pfr, addr.type);
	<span class="enscript-keyword">switch</span> (pfr-&gt;addr.type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_ADDR_DYNIFTL</span>:
		PF_MD5_UPD(pfr, addr.v.ifname);
		PF_MD5_UPD(pfr, addr.iflags);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_ADDR_TABLE</span>:
		PF_MD5_UPD(pfr, addr.v.tblname);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_ADDR_ADDRMASK</span>:
		<span class="enscript-comment">/* XXX ignore af? */</span>
		PF_MD5_UPD(pfr, addr.v.a.addr.addr32);
		PF_MD5_UPD(pfr, addr.v.a.mask.addr32);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_ADDR_RTLABEL</span>:
		PF_MD5_UPD(pfr, addr.v.rtlabelname);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">switch</span> (proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		PF_MD5_UPD(pfr, xport.range.port[0]);
		PF_MD5_UPD(pfr, xport.range.port[1]);
		PF_MD5_UPD(pfr, xport.range.op);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	PF_MD5_UPD(pfr, neg);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_hash_rule</span>(MD5_CTX *ctx, <span class="enscript-type">struct</span> pf_rule *rule)
{
	u_int16_t x;
	u_int32_t y;

	pf_hash_rule_addr(ctx, &amp;rule-&gt;src, rule-&gt;proto);
	pf_hash_rule_addr(ctx, &amp;rule-&gt;dst, rule-&gt;proto);
	PF_MD5_UPD_STR(rule, label);
	PF_MD5_UPD_STR(rule, ifname);
	PF_MD5_UPD_STR(rule, match_tagname);
	PF_MD5_UPD_HTONS(rule, match_tag, x); <span class="enscript-comment">/* dup? */</span>
	PF_MD5_UPD_HTONL(rule, os_fingerprint, y);
	PF_MD5_UPD_HTONL(rule, prob, y);
	PF_MD5_UPD_HTONL(rule, uid.uid[0], y);
	PF_MD5_UPD_HTONL(rule, uid.uid[1], y);
	PF_MD5_UPD(rule, uid.op);
	PF_MD5_UPD_HTONL(rule, gid.gid[0], y);
	PF_MD5_UPD_HTONL(rule, gid.gid[1], y);
	PF_MD5_UPD(rule, gid.op);
	PF_MD5_UPD_HTONL(rule, rule_flag, y);
	PF_MD5_UPD(rule, action);
	PF_MD5_UPD(rule, direction);
	PF_MD5_UPD(rule, af);
	PF_MD5_UPD(rule, quick);
	PF_MD5_UPD(rule, ifnot);
	PF_MD5_UPD(rule, match_tag_not);
	PF_MD5_UPD(rule, natpass);
	PF_MD5_UPD(rule, keep_state);
	PF_MD5_UPD(rule, proto);
	PF_MD5_UPD(rule, type);
	PF_MD5_UPD(rule, code);
	PF_MD5_UPD(rule, flags);
	PF_MD5_UPD(rule, flagset);
	PF_MD5_UPD(rule, allow_opts);
	PF_MD5_UPD(rule, rt);
	PF_MD5_UPD(rule, tos);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_commit_rules</span>(u_int32_t ticket, <span class="enscript-type">int</span> rs_num, <span class="enscript-type">char</span> *anchor)
{
	<span class="enscript-type">struct</span> pf_ruleset	*rs;
	<span class="enscript-type">struct</span> pf_rule		*rule, **old_array, *r;
	<span class="enscript-type">struct</span> pf_rulequeue	*old_rules;
	<span class="enscript-type">int</span>			 error;
	u_int32_t		 old_rcount;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (rs_num &lt; 0 || rs_num &gt;= PF_RULESET_MAX)
		<span class="enscript-keyword">return</span> (EINVAL);
	rs = pf_find_ruleset(anchor);
	<span class="enscript-keyword">if</span> (rs == NULL || !rs-&gt;rules[rs_num].inactive.open ||
	    ticket != rs-&gt;rules[rs_num].inactive.ticket)
		<span class="enscript-keyword">return</span> (EBUSY);

	<span class="enscript-comment">/* Calculate checksum for the main ruleset */</span>
	<span class="enscript-keyword">if</span> (rs == &amp;pf_main_ruleset) {
		error = pf_setup_pfsync_matching(rs);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* Swap rules, keep the old. */</span>
	old_rules = rs-&gt;rules[rs_num].active.ptr;
	old_rcount = rs-&gt;rules[rs_num].active.rcount;
	old_array = rs-&gt;rules[rs_num].active.ptr_array;

	<span class="enscript-keyword">if</span>(old_rcount != 0) {
		r = TAILQ_FIRST(rs-&gt;rules[rs_num].active.ptr);
		<span class="enscript-keyword">while</span> (r) {
			<span class="enscript-keyword">if</span> (r-&gt;rule_flag &amp; PFRULE_PFM)
				pffwrules--;
			r = TAILQ_NEXT(r, entries);
		}
	}


	rs-&gt;rules[rs_num].active.ptr =
	    rs-&gt;rules[rs_num].inactive.ptr;
	rs-&gt;rules[rs_num].active.ptr_array =
	    rs-&gt;rules[rs_num].inactive.ptr_array;
	rs-&gt;rules[rs_num].active.rcount =
	    rs-&gt;rules[rs_num].inactive.rcount;
	rs-&gt;rules[rs_num].inactive.ptr = old_rules;
	rs-&gt;rules[rs_num].inactive.ptr_array = old_array;
	rs-&gt;rules[rs_num].inactive.rcount = old_rcount;

	rs-&gt;rules[rs_num].active.ticket =
	    rs-&gt;rules[rs_num].inactive.ticket;
	pf_calc_skip_steps(rs-&gt;rules[rs_num].active.ptr);


	<span class="enscript-comment">/* Purge the old rule list. */</span>
	<span class="enscript-keyword">while</span> ((rule = TAILQ_FIRST(old_rules)) != NULL)
		pf_rm_rule(old_rules, rule);
	<span class="enscript-keyword">if</span> (rs-&gt;rules[rs_num].inactive.ptr_array)
		_FREE(rs-&gt;rules[rs_num].inactive.ptr_array, M_TEMP);
	rs-&gt;rules[rs_num].inactive.ptr_array = NULL;
	rs-&gt;rules[rs_num].inactive.rcount = 0;
	rs-&gt;rules[rs_num].inactive.open = 0;
	pf_remove_if_empty_ruleset(rs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_rule_copyin</span>(<span class="enscript-type">struct</span> pf_rule *src, <span class="enscript-type">struct</span> pf_rule *dst, <span class="enscript-type">struct</span> proc *p,
    <span class="enscript-type">int</span> minordev)
{
	bcopy(src, dst, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_rule));

	dst-&gt;label[<span class="enscript-keyword">sizeof</span> (dst-&gt;label) - 1] = <span class="enscript-string">'\0'</span>;
	dst-&gt;ifname[<span class="enscript-keyword">sizeof</span> (dst-&gt;ifname) - 1] = <span class="enscript-string">'\0'</span>;
	dst-&gt;qname[<span class="enscript-keyword">sizeof</span> (dst-&gt;qname) - 1] = <span class="enscript-string">'\0'</span>;
	dst-&gt;pqname[<span class="enscript-keyword">sizeof</span> (dst-&gt;pqname) - 1] = <span class="enscript-string">'\0'</span>;
	dst-&gt;tagname[<span class="enscript-keyword">sizeof</span> (dst-&gt;tagname) - 1] = <span class="enscript-string">'\0'</span>;
	dst-&gt;match_tagname[<span class="enscript-keyword">sizeof</span> (dst-&gt;match_tagname) - 1] = <span class="enscript-string">'\0'</span>;
	dst-&gt;overload_tblname[<span class="enscript-keyword">sizeof</span> (dst-&gt;overload_tblname) - 1] = <span class="enscript-string">'\0'</span>;

	dst-&gt;cuid = kauth_cred_getuid(p-&gt;p_ucred);
	dst-&gt;cpid = p-&gt;p_pid;

	dst-&gt;anchor = NULL;
	dst-&gt;kif = NULL;
	dst-&gt;overload_tbl = NULL;

	TAILQ_INIT(&amp;dst-&gt;rpool.list);
	dst-&gt;rpool.cur = NULL;

	<span class="enscript-comment">/* initialize refcounting */</span>
	dst-&gt;states = 0;
	dst-&gt;src_nodes = 0;

	dst-&gt;entries.tqe_prev = NULL;
	dst-&gt;entries.tqe_next = NULL;
	<span class="enscript-keyword">if</span> ((uint8_t)minordev == PFDEV_PFM)
		dst-&gt;rule_flag |= PFRULE_PFM;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_rule_copyout</span>(<span class="enscript-type">struct</span> pf_rule *src, <span class="enscript-type">struct</span> pf_rule *dst)
{
	bcopy(src, dst, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_rule));

	dst-&gt;anchor = NULL;
	dst-&gt;kif = NULL;
	dst-&gt;overload_tbl = NULL;

	TAILQ_INIT(&amp;dst-&gt;rpool.list);
	dst-&gt;rpool.cur = NULL;

	dst-&gt;entries.tqe_prev = NULL;
	dst-&gt;entries.tqe_next = NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_state_export</span>(<span class="enscript-type">struct</span> pfsync_state *sp, <span class="enscript-type">struct</span> pf_state_key *sk,
    <span class="enscript-type">struct</span> pf_state *s)
{
	uint64_t secs = pf_time_second();
	bzero(sp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfsync_state));

	<span class="enscript-comment">/* copy from state key */</span>
	sp-&gt;lan.addr = sk-&gt;lan.addr;
	sp-&gt;lan.xport = sk-&gt;lan.xport;
	sp-&gt;gwy.addr = sk-&gt;gwy.addr;
	sp-&gt;gwy.xport = sk-&gt;gwy.xport;
	sp-&gt;ext_lan.addr = sk-&gt;ext_lan.addr;
	sp-&gt;ext_lan.xport = sk-&gt;ext_lan.xport;
	sp-&gt;ext_gwy.addr = sk-&gt;ext_gwy.addr;
	sp-&gt;ext_gwy.xport = sk-&gt;ext_gwy.xport;
	sp-&gt;proto_variant = sk-&gt;proto_variant;
	sp-&gt;tag = s-&gt;tag;
	sp-&gt;proto = sk-&gt;proto;
	sp-&gt;af_lan = sk-&gt;af_lan;
	sp-&gt;af_gwy = sk-&gt;af_gwy;
	sp-&gt;direction = sk-&gt;direction;
	sp-&gt;flowhash = sk-&gt;flowhash;

	<span class="enscript-comment">/* copy from state */</span>
	memcpy(&amp;sp-&gt;id, &amp;s-&gt;id, <span class="enscript-keyword">sizeof</span> (sp-&gt;id));
	sp-&gt;creatorid = s-&gt;creatorid;
	strlcpy(sp-&gt;ifname, s-&gt;kif-&gt;pfik_name, <span class="enscript-keyword">sizeof</span> (sp-&gt;ifname));
	pf_state_peer_to_pfsync(&amp;s-&gt;src, &amp;sp-&gt;src);
	pf_state_peer_to_pfsync(&amp;s-&gt;dst, &amp;sp-&gt;dst);

	sp-&gt;rule = s-&gt;rule.ptr-&gt;nr;
	sp-&gt;nat_rule = (s-&gt;nat_rule.ptr == NULL) ?
	    (<span class="enscript-type">unsigned</span>)-1 : s-&gt;nat_rule.ptr-&gt;nr;
	sp-&gt;anchor = (s-&gt;anchor.ptr == NULL) ?
	    (<span class="enscript-type">unsigned</span>)-1 : s-&gt;anchor.ptr-&gt;nr;

	pf_state_counter_to_pfsync(s-&gt;bytes[0], sp-&gt;bytes[0]);
	pf_state_counter_to_pfsync(s-&gt;bytes[1], sp-&gt;bytes[1]);
	pf_state_counter_to_pfsync(s-&gt;packets[0], sp-&gt;packets[0]);
	pf_state_counter_to_pfsync(s-&gt;packets[1], sp-&gt;packets[1]);
	sp-&gt;creation = secs - s-&gt;creation;
	sp-&gt;expire = pf_state_expires(s);
	sp-&gt;log = s-&gt;log;
	sp-&gt;allow_opts = s-&gt;allow_opts;
	sp-&gt;timeout = s-&gt;timeout;

	<span class="enscript-keyword">if</span> (s-&gt;src_node)
		sp-&gt;sync_flags |= PFSYNC_FLAG_SRCNODE;
	<span class="enscript-keyword">if</span> (s-&gt;nat_src_node)
		sp-&gt;sync_flags |= PFSYNC_FLAG_NATSRCNODE;

	<span class="enscript-keyword">if</span> (sp-&gt;expire &gt; secs)
		sp-&gt;expire -= secs;
	<span class="enscript-keyword">else</span>
		sp-&gt;expire = 0;

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_state_import</span>(<span class="enscript-type">struct</span> pfsync_state *sp, <span class="enscript-type">struct</span> pf_state_key *sk,
    <span class="enscript-type">struct</span> pf_state *s)
{
	<span class="enscript-comment">/* copy to state key */</span>
	sk-&gt;lan.addr = sp-&gt;lan.addr;
	sk-&gt;lan.xport = sp-&gt;lan.xport;
	sk-&gt;gwy.addr = sp-&gt;gwy.addr;
	sk-&gt;gwy.xport = sp-&gt;gwy.xport;
	sk-&gt;ext_lan.addr = sp-&gt;ext_lan.addr;
	sk-&gt;ext_lan.xport = sp-&gt;ext_lan.xport;
	sk-&gt;ext_gwy.addr = sp-&gt;ext_gwy.addr;
	sk-&gt;ext_gwy.xport = sp-&gt;ext_gwy.xport;
	sk-&gt;proto_variant = sp-&gt;proto_variant;
	s-&gt;tag = sp-&gt;tag;
	sk-&gt;proto = sp-&gt;proto;
	sk-&gt;af_lan = sp-&gt;af_lan;
	sk-&gt;af_gwy = sp-&gt;af_gwy;
	sk-&gt;direction = sp-&gt;direction;
	sk-&gt;flowhash = pf_calc_state_key_flowhash(sk);

	<span class="enscript-comment">/* copy to state */</span>
	memcpy(&amp;s-&gt;id, &amp;sp-&gt;id, <span class="enscript-keyword">sizeof</span> (sp-&gt;id));
	s-&gt;creatorid = sp-&gt;creatorid;
	pf_state_peer_from_pfsync(&amp;sp-&gt;src, &amp;s-&gt;src);
	pf_state_peer_from_pfsync(&amp;sp-&gt;dst, &amp;s-&gt;dst);

	s-&gt;rule.ptr = &amp;pf_default_rule;
	s-&gt;nat_rule.ptr = NULL;
	s-&gt;anchor.ptr = NULL;
	s-&gt;rt_kif = NULL;
	s-&gt;creation = pf_time_second();
	s-&gt;expire = pf_time_second();
	<span class="enscript-keyword">if</span> (sp-&gt;expire &gt; 0)
		s-&gt;expire -= pf_default_rule.timeout[sp-&gt;timeout] - sp-&gt;expire;
	s-&gt;pfsync_time = 0;
	s-&gt;packets[0] = s-&gt;packets[1] = 0;
	s-&gt;bytes[0] = s-&gt;bytes[1] = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_pooladdr_copyin</span>(<span class="enscript-type">struct</span> pf_pooladdr *src, <span class="enscript-type">struct</span> pf_pooladdr *dst)
{
	bcopy(src, dst, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pooladdr));

	dst-&gt;entries.tqe_prev = NULL;
	dst-&gt;entries.tqe_next = NULL;
	dst-&gt;ifname[<span class="enscript-keyword">sizeof</span> (dst-&gt;ifname) - 1] = <span class="enscript-string">'\0'</span>;
	dst-&gt;kif = NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_pooladdr_copyout</span>(<span class="enscript-type">struct</span> pf_pooladdr *src, <span class="enscript-type">struct</span> pf_pooladdr *dst)
{
	bcopy(src, dst, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pooladdr));

	dst-&gt;entries.tqe_prev = NULL;
	dst-&gt;entries.tqe_next = NULL;
	dst-&gt;kif = NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_setup_pfsync_matching</span>(<span class="enscript-type">struct</span> pf_ruleset *rs)
{
	MD5_CTX			 ctx;
	<span class="enscript-type">struct</span> pf_rule		*rule;
	<span class="enscript-type">int</span>			 rs_cnt;
	u_int8_t		 digest[PF_MD5_DIGEST_LENGTH];

	MD5Init(&amp;ctx);
	<span class="enscript-keyword">for</span> (rs_cnt = 0; rs_cnt &lt; PF_RULESET_MAX; rs_cnt++) {
		<span class="enscript-comment">/* XXX PF_RULESET_SCRUB as well? */</span>
		<span class="enscript-keyword">if</span> (rs_cnt == PF_RULESET_SCRUB)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (rs-&gt;rules[rs_cnt].inactive.ptr_array)
			_FREE(rs-&gt;rules[rs_cnt].inactive.ptr_array, M_TEMP);
		rs-&gt;rules[rs_cnt].inactive.ptr_array = NULL;

		<span class="enscript-keyword">if</span> (rs-&gt;rules[rs_cnt].inactive.rcount) {
			rs-&gt;rules[rs_cnt].inactive.ptr_array =
			    _MALLOC(<span class="enscript-keyword">sizeof</span> (caddr_t) *
			    rs-&gt;rules[rs_cnt].inactive.rcount,
			    M_TEMP, M_WAITOK);

			<span class="enscript-keyword">if</span> (!rs-&gt;rules[rs_cnt].inactive.ptr_array)
				<span class="enscript-keyword">return</span> (ENOMEM);
		}

		TAILQ_FOREACH(rule, rs-&gt;rules[rs_cnt].inactive.ptr,
		    entries) {
			pf_hash_rule(&amp;ctx, rule);
			(rs-&gt;rules[rs_cnt].inactive.ptr_array)[rule-&gt;nr] = rule;
		}
	}

	MD5Final(digest, &amp;ctx);
	memcpy(pf_status.pf_chksum, digest, <span class="enscript-keyword">sizeof</span> (pf_status.pf_chksum));
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_start</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	VERIFY(pf_is_enabled == 0);

	pf_is_enabled = 1;
	pf_status.running = 1;
	pf_status.since = pf_calendar_time_second();
	<span class="enscript-keyword">if</span> (pf_status.stateid == 0) {
		pf_status.stateid = pf_time_second();
		pf_status.stateid = pf_status.stateid &lt;&lt; 32;
	}
	wakeup(pf_purge_thread_fn);
	DPFPRINTF(PF_DEBUG_MISC, (<span class="enscript-string">&quot;pf: started\n&quot;</span>));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_stop</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	VERIFY(pf_is_enabled);

	pf_status.running = 0;
	pf_is_enabled = 0;
	pf_status.since = pf_calendar_time_second();
	wakeup(pf_purge_thread_fn);
	DPFPRINTF(PF_DEBUG_MISC, (<span class="enscript-string">&quot;pf: stopped\n&quot;</span>));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl</span>(dev_t dev, u_long cmd, caddr_t addr, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dev</span>)
	<span class="enscript-type">int</span> p64 = proc_is64bit(p);
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> minordev = minor(dev);

	<span class="enscript-keyword">if</span> (kauth_cred_issuser(kauth_cred_get()) == 0)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-comment">/* XXX keep in sync with switch() below */</span>
	<span class="enscript-keyword">if</span> (securelevel &gt; 1)
		<span class="enscript-keyword">switch</span> (cmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETSTATUSIF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATUS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRSTATUS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCNATLOOK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETDEBUG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCINSERTRULE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCDELETERULE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETTIMEOUT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRRULECTRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETLIMIT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETALTQS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETALTQ</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETQSTATS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULESETS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULESET</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETTABLES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETTSTATS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRTSTATS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRADDADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRDELADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRSETADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETASTATS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRASTATS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRTSTADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCOSFPGET</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSRCNODES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRSRCNODES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCIGETIFACES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGIFSPEED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETIFFLAG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRIFFLAG</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRTABLES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRADDTABLES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRDELTABLES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRSETTFLAGS</span>: {
			<span class="enscript-type">int</span> pfrio_flags;

			bcopy(&amp;((<span class="enscript-type">struct</span> pfioc_table *)(<span class="enscript-type">void</span> *)addr)-&gt;
			    pfrio_flags, &amp;pfrio_flags, <span class="enscript-keyword">sizeof</span> (pfrio_flags));

			<span class="enscript-keyword">if</span> (pfrio_flags &amp; PFR_FLAG_DUMMY)
				<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* dummy operation ok */</span>
			<span class="enscript-keyword">return</span> (EPERM);
		}
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (EPERM);
		}

	<span class="enscript-keyword">if</span> (!(flags &amp; FWRITE))
		<span class="enscript-keyword">switch</span> (cmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTART</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTARTREF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTOP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTOPREF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTARTERS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATUS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCINSERTRULE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCDELETERULE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETTIMEOUT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETLIMIT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETALTQS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETALTQ</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETQSTATS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULESETS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULESET</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCNATLOOK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETTABLES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETTSTATS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETASTATS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRTSTADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCOSFPGET</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSRCNODES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCIGETIFACES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGIFSPEED</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRTABLES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRADDTABLES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRDELTABLES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRTSTATS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRADDADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRDELADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRSETADDRS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRSETTFLAGS</span>: {
			<span class="enscript-type">int</span> pfrio_flags;

			bcopy(&amp;((<span class="enscript-type">struct</span> pfioc_table *)(<span class="enscript-type">void</span> *)addr)-&gt;
			    pfrio_flags, &amp;pfrio_flags, <span class="enscript-keyword">sizeof</span> (pfrio_flags));

			<span class="enscript-keyword">if</span> (pfrio_flags &amp; PFR_FLAG_DUMMY) {
				flags |= FWRITE; <span class="enscript-comment">/* need write lock for dummy */</span>
				<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* dummy operation ok */</span>
			}
			<span class="enscript-keyword">return</span> (EACCES);
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULE</span>: {
			u_int32_t action;

			bcopy(&amp;((<span class="enscript-type">struct</span> pfioc_rule *)(<span class="enscript-type">void</span> *)addr)-&gt;action,
			    &amp;action, <span class="enscript-keyword">sizeof</span> (action));

			<span class="enscript-keyword">if</span> (action == PF_GET_CLR_CNTR)
				<span class="enscript-keyword">return</span> (EACCES);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (EACCES);
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTARTALTQ</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTOPALTQ</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCADDALTQ</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETALTQS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETALTQ</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCHANGEALTQ</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETQSTATS</span>:
		<span class="enscript-comment">/* fail if ALTQ is disabled */</span>
		<span class="enscript-keyword">if</span> (!altq_allowed)
			<span class="enscript-keyword">return</span> (ENODEV);
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

	<span class="enscript-keyword">if</span> (flags &amp; FWRITE)
		lck_rw_lock_exclusive(pf_perim_lock);
	<span class="enscript-keyword">else</span>
		lck_rw_lock_shared(pf_perim_lock);

	lck_mtx_lock(pf_lock);

	<span class="enscript-keyword">switch</span> (cmd) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTART</span>:
		<span class="enscript-keyword">if</span> (pf_status.running) {
			<span class="enscript-comment">/*
			 * Increment the reference for a simple -e enable, so
			 * that even if other processes drop their references,
			 * pf will still be available to processes that turned
			 * it on without taking a reference
			 */</span>
			<span class="enscript-keyword">if</span> (nr_tokens == pf_enabled_ref_count) {
				pf_enabled_ref_count++;
				VERIFY(pf_enabled_ref_count != 0);
			}
			error = EEXIST;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pf_purge_thread == NULL) {
			error = ENOMEM;
		} <span class="enscript-keyword">else</span> {
			pf_start();
			pf_enabled_ref_count++;
			VERIFY(pf_enabled_ref_count != 0);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTARTREF</span>:		<span class="enscript-comment">/* u_int64_t */</span>
		<span class="enscript-keyword">if</span> (pf_purge_thread == NULL) {
			error = ENOMEM;
		} <span class="enscript-keyword">else</span> {
			u_int64_t token;

			<span class="enscript-comment">/* small enough to be on stack */</span>
			<span class="enscript-keyword">if</span> ((token = generate_token(p)) != 0) {
				<span class="enscript-keyword">if</span> (pf_is_enabled == 0) {
					pf_start();
				}
				pf_enabled_ref_count++;
				VERIFY(pf_enabled_ref_count != 0);
			} <span class="enscript-keyword">else</span> {
				error = ENOMEM;
				DPFPRINTF(PF_DEBUG_URGENT,
				    (<span class="enscript-string">&quot;pf: unable to generate token\n&quot;</span>));
			}
			bcopy(&amp;token, addr, <span class="enscript-keyword">sizeof</span> (token));
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTOP</span>:
		<span class="enscript-keyword">if</span> (!pf_status.running) {
			error = ENOENT;
		} <span class="enscript-keyword">else</span> {
			pf_stop();
			pf_enabled_ref_count = 0;
			invalidate_all_tokens();
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTOPREF</span>:		<span class="enscript-comment">/* struct pfioc_remove_token */</span>
		<span class="enscript-keyword">if</span> (!pf_status.running) {
			error = ENOENT;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> pfioc_remove_token pfrt;

			<span class="enscript-comment">/* small enough to be on stack */</span>
			bcopy(addr, &amp;pfrt, <span class="enscript-keyword">sizeof</span> (pfrt));
			<span class="enscript-keyword">if</span> ((error = remove_token(&amp;pfrt)) == 0) {
				VERIFY(pf_enabled_ref_count != 0);
				pf_enabled_ref_count--;
				<span class="enscript-comment">/* return currently held references */</span>
				pfrt.refcount = pf_enabled_ref_count;
				DPFPRINTF(PF_DEBUG_MISC,
				    (<span class="enscript-string">&quot;pf: enabled refcount decremented\n&quot;</span>));
			} <span class="enscript-keyword">else</span> {
				error = EINVAL;
				DPFPRINTF(PF_DEBUG_URGENT,
				    (<span class="enscript-string">&quot;pf: token mismatch\n&quot;</span>));
			}
			bcopy(&amp;pfrt, addr, <span class="enscript-keyword">sizeof</span> (pfrt));

			<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; pf_enabled_ref_count == 0)
				pf_stop();
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTARTERS</span>: {		<span class="enscript-comment">/* struct pfioc_tokens */</span>
		PFIOCX_STRUCT_DECL(pfioc_tokens);

		PFIOCX_STRUCT_BEGIN(addr, pfioc_tokens, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		error = pfioctl_ioc_tokens(cmd,
		    PFIOCX_STRUCT_ADDR32(pfioc_tokens),
		    PFIOCX_STRUCT_ADDR64(pfioc_tokens), p);
		PFIOCX_STRUCT_END(pfioc_tokens, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCADDRULE</span>:		<span class="enscript-comment">/* struct pfioc_rule */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULES</span>:		<span class="enscript-comment">/* struct pfioc_rule */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULE</span>:		<span class="enscript-comment">/* struct pfioc_rule */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCHANGERULE</span>:		<span class="enscript-comment">/* struct pfioc_rule */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCINSERTRULE</span>:		<span class="enscript-comment">/* struct pfioc_rule */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCDELETERULE</span>: {		<span class="enscript-comment">/* struct pfioc_rule */</span>
		<span class="enscript-type">struct</span> pfioc_rule *pr = NULL;

		PFIOC_STRUCT_BEGIN(addr, pr, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		error = pfioctl_ioc_rule(cmd, minordev, pr, p);
		PFIOC_STRUCT_END(pr, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRSTATES</span>:		<span class="enscript-comment">/* struct pfioc_state_kill */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCKILLSTATES</span>: {		<span class="enscript-comment">/* struct pfioc_state_kill */</span>
		<span class="enscript-type">struct</span> pfioc_state_kill *psk = NULL;

		PFIOC_STRUCT_BEGIN(addr, psk, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		error = pfioctl_ioc_state_kill(cmd, psk, p);
		PFIOC_STRUCT_END(psk, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCADDSTATE</span>:		<span class="enscript-comment">/* struct pfioc_state */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATE</span>: {		<span class="enscript-comment">/* struct pfioc_state */</span>
		<span class="enscript-type">struct</span> pfioc_state *ps = NULL;

		PFIOC_STRUCT_BEGIN(addr, ps, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		error = pfioctl_ioc_state(cmd, ps, p);
		PFIOC_STRUCT_END(ps, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATES</span>: {		<span class="enscript-comment">/* struct pfioc_states */</span>
		PFIOCX_STRUCT_DECL(pfioc_states);

		PFIOCX_STRUCT_BEGIN(addr, pfioc_states, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		error = pfioctl_ioc_states(cmd,
		    PFIOCX_STRUCT_ADDR32(pfioc_states),
		    PFIOCX_STRUCT_ADDR64(pfioc_states), p);
		PFIOCX_STRUCT_END(pfioc_states, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATUS</span>: {		<span class="enscript-comment">/* struct pf_status */</span>
		<span class="enscript-type">struct</span> pf_status *s = NULL;

		PFIOC_STRUCT_BEGIN(&amp;pf_status, s, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		pfi_update_status(s-&gt;ifname, s);
		PFIOC_STRUCT_END(s, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETSTATUSIF</span>: {		<span class="enscript-comment">/* struct pfioc_if */</span>
		<span class="enscript-type">struct</span> pfioc_if	*pi = (<span class="enscript-type">struct</span> pfioc_if *)(<span class="enscript-type">void</span> *)addr;

		<span class="enscript-comment">/* OK for unaligned accesses */</span>
		<span class="enscript-keyword">if</span> (pi-&gt;ifname[0] == 0) {
			bzero(pf_status.ifname, IFNAMSIZ);
			<span class="enscript-keyword">break</span>;
		}
		strlcpy(pf_status.ifname, pi-&gt;ifname, IFNAMSIZ);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRSTATUS</span>: {
		bzero(pf_status.counters, <span class="enscript-keyword">sizeof</span> (pf_status.counters));
		bzero(pf_status.fcounters, <span class="enscript-keyword">sizeof</span> (pf_status.fcounters));
		bzero(pf_status.scounters, <span class="enscript-keyword">sizeof</span> (pf_status.scounters));
		pf_status.since = pf_calendar_time_second();
		<span class="enscript-keyword">if</span> (*pf_status.ifname)
			pfi_update_status(pf_status.ifname, NULL);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCNATLOOK</span>: {		<span class="enscript-comment">/* struct pfioc_natlook */</span>
		<span class="enscript-type">struct</span> pfioc_natlook *pnl = NULL;

		PFIOC_STRUCT_BEGIN(addr, pnl, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		error = pfioctl_ioc_natlook(cmd, pnl, p);
		PFIOC_STRUCT_END(pnl, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETTIMEOUT</span>:		<span class="enscript-comment">/* struct pfioc_tm */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETTIMEOUT</span>: {		<span class="enscript-comment">/* struct pfioc_tm */</span>
		<span class="enscript-type">struct</span> pfioc_tm	pt;

		<span class="enscript-comment">/* small enough to be on stack */</span>
		bcopy(addr, &amp;pt, <span class="enscript-keyword">sizeof</span> (pt));
		error = pfioctl_ioc_tm(cmd, &amp;pt, p);
		bcopy(&amp;pt, addr, <span class="enscript-keyword">sizeof</span> (pt));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETLIMIT</span>:		<span class="enscript-comment">/* struct pfioc_limit */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETLIMIT</span>: {		<span class="enscript-comment">/* struct pfioc_limit */</span>
		<span class="enscript-type">struct</span> pfioc_limit pl;

		<span class="enscript-comment">/* small enough to be on stack */</span>
		bcopy(addr, &amp;pl, <span class="enscript-keyword">sizeof</span> (pl));
		error = pfioctl_ioc_limit(cmd, &amp;pl, p);
		bcopy(&amp;pl, addr, <span class="enscript-keyword">sizeof</span> (pl));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETDEBUG</span>: {		<span class="enscript-comment">/* u_int32_t */</span>
		bcopy(addr, &amp;pf_status.debug, <span class="enscript-keyword">sizeof</span> (u_int32_t));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRRULECTRS</span>: {
		<span class="enscript-comment">/* obsoleted by DIOCGETRULE with action=PF_GET_CLR_CNTR */</span>
		<span class="enscript-type">struct</span> pf_ruleset	*ruleset = &amp;pf_main_ruleset;
		<span class="enscript-type">struct</span> pf_rule		*rule;

		TAILQ_FOREACH(rule,
		    ruleset-&gt;rules[PF_RULESET_FILTER].active.ptr, entries) {
			rule-&gt;evaluations = 0;
			rule-&gt;packets[0] = rule-&gt;packets[1] = 0;
			rule-&gt;bytes[0] = rule-&gt;bytes[1] = 0;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGIFSPEED</span>: {
		<span class="enscript-type">struct</span> pf_ifspeed *psp = (<span class="enscript-type">struct</span> pf_ifspeed *)(<span class="enscript-type">void</span> *)addr;
		<span class="enscript-type">struct</span> pf_ifspeed ps;
		<span class="enscript-type">struct</span> ifnet *ifp;
		u_int64_t baudrate;

		<span class="enscript-keyword">if</span> (psp-&gt;ifname[0] != <span class="enscript-string">'\0'</span>) {
			<span class="enscript-comment">/* Can we completely trust user-land? */</span>
			strlcpy(ps.ifname, psp-&gt;ifname, IFNAMSIZ);
			ps.ifname[IFNAMSIZ - 1] = <span class="enscript-string">'\0'</span>;
			ifp = ifunit(ps.ifname);
			<span class="enscript-keyword">if</span> (ifp != NULL) {
				baudrate = ifp-&gt;if_output_bw.max_bw;
				bcopy(&amp;baudrate, &amp;psp-&gt;baudrate,
				    <span class="enscript-keyword">sizeof</span> (baudrate));
			} <span class="enscript-keyword">else</span> {
				error = EINVAL;
			}
		} <span class="enscript-keyword">else</span> {
			error = EINVAL;
		}
		<span class="enscript-keyword">break</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTARTALTQ</span>: {
		<span class="enscript-type">struct</span> pf_altq		*altq;

		VERIFY(altq_allowed);
		<span class="enscript-comment">/* enable all altq interfaces on active list */</span>
		TAILQ_FOREACH(altq, pf_altqs_active, entries) {
			<span class="enscript-keyword">if</span> (altq-&gt;qname[0] == <span class="enscript-string">'\0'</span>) {
				error = pf_enable_altq(altq);
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (error == 0)
			pf_altq_running = 1;
		DPFPRINTF(PF_DEBUG_MISC, (<span class="enscript-string">&quot;altq: started\n&quot;</span>));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTOPALTQ</span>: {
		<span class="enscript-type">struct</span> pf_altq		*altq;

		VERIFY(altq_allowed);
		<span class="enscript-comment">/* disable all altq interfaces on active list */</span>
		TAILQ_FOREACH(altq, pf_altqs_active, entries) {
			<span class="enscript-keyword">if</span> (altq-&gt;qname[0] == <span class="enscript-string">'\0'</span>) {
				error = pf_disable_altq(altq);
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (error == 0)
			pf_altq_running = 0;
		DPFPRINTF(PF_DEBUG_MISC, (<span class="enscript-string">&quot;altq: stopped\n&quot;</span>));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCADDALTQ</span>: {		<span class="enscript-comment">/* struct pfioc_altq */</span>
		<span class="enscript-type">struct</span> pfioc_altq	*pa = (<span class="enscript-type">struct</span> pfioc_altq *)(<span class="enscript-type">void</span> *)addr;
		<span class="enscript-type">struct</span> pf_altq		*altq, *a;
		u_int32_t		ticket;

		VERIFY(altq_allowed);
		bcopy(&amp;pa-&gt;ticket, &amp;ticket, <span class="enscript-keyword">sizeof</span> (ticket));
		<span class="enscript-keyword">if</span> (ticket != ticket_altqs_inactive) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		altq = pool_get(&amp;pf_altq_pl, PR_WAITOK);
		<span class="enscript-keyword">if</span> (altq == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">break</span>;
		}
		pf_altq_copyin(&amp;pa-&gt;altq, altq);

		<span class="enscript-comment">/*
		 * if this is for a queue, find the discipline and
		 * copy the necessary fields
		 */</span>
		<span class="enscript-keyword">if</span> (altq-&gt;qname[0] != <span class="enscript-string">'\0'</span>) {
			<span class="enscript-keyword">if</span> ((altq-&gt;qid = pf_qname2qid(altq-&gt;qname)) == 0) {
				error = EBUSY;
				pool_put(&amp;pf_altq_pl, altq);
				<span class="enscript-keyword">break</span>;
			}
			altq-&gt;altq_disc = NULL;
			TAILQ_FOREACH(a, pf_altqs_inactive, entries) {
				<span class="enscript-keyword">if</span> (strncmp(a-&gt;ifname, altq-&gt;ifname,
				    IFNAMSIZ) == 0 &amp;&amp; a-&gt;qname[0] == <span class="enscript-string">'\0'</span>) {
					altq-&gt;altq_disc = a-&gt;altq_disc;
					<span class="enscript-keyword">break</span>;
				}
			}
		}

		error = altq_add(altq);
		<span class="enscript-keyword">if</span> (error) {
			pool_put(&amp;pf_altq_pl, altq);
			<span class="enscript-keyword">break</span>;
		}

		TAILQ_INSERT_TAIL(pf_altqs_inactive, altq, entries);
		pf_altq_copyout(altq, &amp;pa-&gt;altq);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETALTQS</span>: {
		<span class="enscript-type">struct</span> pfioc_altq	*pa = (<span class="enscript-type">struct</span> pfioc_altq *)(<span class="enscript-type">void</span> *)addr;
		<span class="enscript-type">struct</span> pf_altq		*altq;
		u_int32_t		nr;

		VERIFY(altq_allowed);
		nr = 0;
		TAILQ_FOREACH(altq, pf_altqs_active, entries)
			nr++;
		bcopy(&amp;nr, &amp;pa-&gt;nr, <span class="enscript-keyword">sizeof</span> (nr));
		bcopy(&amp;ticket_altqs_active, &amp;pa-&gt;ticket, <span class="enscript-keyword">sizeof</span> (pa-&gt;ticket));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETALTQ</span>: {
		<span class="enscript-type">struct</span> pfioc_altq	*pa = (<span class="enscript-type">struct</span> pfioc_altq *)(<span class="enscript-type">void</span> *)addr;
		<span class="enscript-type">struct</span> pf_altq		*altq;
		u_int32_t		 nr, pa_nr, ticket;

		VERIFY(altq_allowed);
		bcopy(&amp;pa-&gt;ticket, &amp;ticket, <span class="enscript-keyword">sizeof</span> (ticket));
		<span class="enscript-keyword">if</span> (ticket != ticket_altqs_active) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		bcopy(&amp;pa-&gt;nr, &amp;pa_nr, <span class="enscript-keyword">sizeof</span> (pa_nr));
		nr = 0;
		altq = TAILQ_FIRST(pf_altqs_active);
		<span class="enscript-keyword">while</span> ((altq != NULL) &amp;&amp; (nr &lt; pa_nr)) {
			altq = TAILQ_NEXT(altq, entries);
			nr++;
		}
		<span class="enscript-keyword">if</span> (altq == NULL) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		pf_altq_copyout(altq, &amp;pa-&gt;altq);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCHANGEALTQ</span>:
		VERIFY(altq_allowed);
		<span class="enscript-comment">/* CHANGEALTQ not supported yet! */</span>
		error = ENODEV;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETQSTATS</span>: {
		<span class="enscript-type">struct</span> pfioc_qstats *pq = (<span class="enscript-type">struct</span> pfioc_qstats *)(<span class="enscript-type">void</span> *)addr;
		<span class="enscript-type">struct</span> pf_altq		*altq;
		u_int32_t		 nr, pq_nr, ticket;
		<span class="enscript-type">int</span>			 nbytes;

		VERIFY(altq_allowed);
		bcopy(&amp;pq-&gt;ticket, &amp;ticket, <span class="enscript-keyword">sizeof</span> (ticket));
		<span class="enscript-keyword">if</span> (ticket != ticket_altqs_active) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		bcopy(&amp;pq-&gt;nr, &amp;pq_nr, <span class="enscript-keyword">sizeof</span> (pq_nr));
		nr = 0;
		altq = TAILQ_FIRST(pf_altqs_active);
		<span class="enscript-keyword">while</span> ((altq != NULL) &amp;&amp; (nr &lt; pq_nr)) {
			altq = TAILQ_NEXT(altq, entries);
			nr++;
		}
		<span class="enscript-keyword">if</span> (altq == NULL) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		bcopy(&amp;pq-&gt;nbytes, &amp;nbytes, <span class="enscript-keyword">sizeof</span> (nbytes));
		error = altq_getqstats(altq, pq-&gt;buf, &amp;nbytes);
		<span class="enscript-keyword">if</span> (error == 0) {
			pq-&gt;scheduler = altq-&gt;scheduler;
			bcopy(&amp;nbytes, &amp;pq-&gt;nbytes, <span class="enscript-keyword">sizeof</span> (nbytes));
		}
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCBEGINADDRS</span>:		<span class="enscript-comment">/* struct pfioc_pooladdr */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCADDADDR</span>:		<span class="enscript-comment">/* struct pfioc_pooladdr */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETADDRS</span>:		<span class="enscript-comment">/* struct pfioc_pooladdr */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETADDR</span>:		<span class="enscript-comment">/* struct pfioc_pooladdr */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCHANGEADDR</span>: {		<span class="enscript-comment">/* struct pfioc_pooladdr */</span>
		<span class="enscript-type">struct</span> pfioc_pooladdr *pp = NULL;

		PFIOC_STRUCT_BEGIN(addr, pp, error = ENOMEM; <span class="enscript-keyword">break</span>;)
		error = pfioctl_ioc_pooladdr(cmd, pp, p);
		PFIOC_STRUCT_END(pp, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULESETS</span>:		<span class="enscript-comment">/* struct pfioc_ruleset */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULESET</span>: {		<span class="enscript-comment">/* struct pfioc_ruleset */</span>
		<span class="enscript-type">struct</span> pfioc_ruleset *pr = NULL;

		PFIOC_STRUCT_BEGIN(addr, pr, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		error = pfioctl_ioc_ruleset(cmd, pr, p);
		PFIOC_STRUCT_END(pr, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRTABLES</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRADDTABLES</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRDELTABLES</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETTABLES</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETTSTATS</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRTSTATS</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRSETTFLAGS</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRADDRS</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRADDADDRS</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRDELADDRS</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRSETADDRS</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETADDRS</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETASTATS</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRASTATS</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRTSTADDRS</span>:		<span class="enscript-comment">/* struct pfioc_table */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRINADEFINE</span>: {		<span class="enscript-comment">/* struct pfioc_table */</span>
		PFIOCX_STRUCT_DECL(pfioc_table);

		PFIOCX_STRUCT_BEGIN(addr, pfioc_table, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		error = pfioctl_ioc_table(cmd,
		    PFIOCX_STRUCT_ADDR32(pfioc_table),
		    PFIOCX_STRUCT_ADDR64(pfioc_table), p);
		PFIOCX_STRUCT_END(pfioc_table, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCOSFPADD</span>:		<span class="enscript-comment">/* struct pf_osfp_ioctl */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCOSFPGET</span>: {		<span class="enscript-comment">/* struct pf_osfp_ioctl */</span>
		<span class="enscript-type">struct</span> pf_osfp_ioctl *io = NULL;

		PFIOC_STRUCT_BEGIN(addr, io, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		<span class="enscript-keyword">if</span> (cmd == DIOCOSFPADD) {
			error = pf_osfp_add(io);
		} <span class="enscript-keyword">else</span> {
			VERIFY(cmd == DIOCOSFPGET);
			error = pf_osfp_get(io);
		}
		PFIOC_STRUCT_END(io, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCXBEGIN</span>:		<span class="enscript-comment">/* struct pfioc_trans */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCXROLLBACK</span>:		<span class="enscript-comment">/* struct pfioc_trans */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCXCOMMIT</span>: {		<span class="enscript-comment">/* struct pfioc_trans */</span>
		PFIOCX_STRUCT_DECL(pfioc_trans);

		PFIOCX_STRUCT_BEGIN(addr, pfioc_trans, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		error = pfioctl_ioc_trans(cmd,
		    PFIOCX_STRUCT_ADDR32(pfioc_trans),
		    PFIOCX_STRUCT_ADDR64(pfioc_trans), p);
		PFIOCX_STRUCT_END(pfioc_trans, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSRCNODES</span>: {		<span class="enscript-comment">/* struct pfioc_src_nodes */</span>
		PFIOCX_STRUCT_DECL(pfioc_src_nodes);

		PFIOCX_STRUCT_BEGIN(addr, pfioc_src_nodes,
		    error = ENOMEM; <span class="enscript-keyword">break</span>;);
		error = pfioctl_ioc_src_nodes(cmd,
		    PFIOCX_STRUCT_ADDR32(pfioc_src_nodes),
		    PFIOCX_STRUCT_ADDR64(pfioc_src_nodes), p);
		PFIOCX_STRUCT_END(pfioc_src_nodes, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRSRCNODES</span>: {
		<span class="enscript-type">struct</span> pf_src_node	*n;
		<span class="enscript-type">struct</span> pf_state		*state;

		RB_FOREACH(state, pf_state_tree_id, &amp;tree_id) {
			state-&gt;src_node = NULL;
			state-&gt;nat_src_node = NULL;
		}
		RB_FOREACH(n, pf_src_tree, &amp;tree_src_tracking) {
			n-&gt;expire = 1;
			n-&gt;states = 0;
		}
		pf_purge_expired_src_nodes();
		pf_status.src_nodes = 0;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCKILLSRCNODES</span>: {	<span class="enscript-comment">/* struct pfioc_src_node_kill */</span>
		<span class="enscript-type">struct</span> pfioc_src_node_kill *psnk = NULL;

		PFIOC_STRUCT_BEGIN(addr, psnk, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		error = pfioctl_ioc_src_node_kill(cmd, psnk, p);
		PFIOC_STRUCT_END(psnk, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETHOSTID</span>: {		<span class="enscript-comment">/* u_int32_t */</span>
		u_int32_t hid;

		<span class="enscript-comment">/* small enough to be on stack */</span>
		bcopy(addr, &amp;hid, <span class="enscript-keyword">sizeof</span> (hid));
		<span class="enscript-keyword">if</span> (hid == 0)
			pf_status.hostid = random();
		<span class="enscript-keyword">else</span>
			pf_status.hostid = hid;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCOSFPFLUSH</span>:
		pf_osfp_flush();
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCIGETIFACES</span>:		<span class="enscript-comment">/* struct pfioc_iface */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETIFFLAG</span>:		<span class="enscript-comment">/* struct pfioc_iface */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRIFFLAG</span>: {		<span class="enscript-comment">/* struct pfioc_iface */</span>
		PFIOCX_STRUCT_DECL(pfioc_iface);

		PFIOCX_STRUCT_BEGIN(addr, pfioc_iface, error = ENOMEM; <span class="enscript-keyword">break</span>;);
		error = pfioctl_ioc_iface(cmd,
		    PFIOCX_STRUCT_ADDR32(pfioc_iface),
		    PFIOCX_STRUCT_ADDR64(pfioc_iface), p);
		PFIOCX_STRUCT_END(pfioc_iface, addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		error = ENODEV;
		<span class="enscript-keyword">break</span>;
	}

	lck_mtx_unlock(pf_lock);
	lck_rw_done(pf_perim_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_table</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_table_32 *io32,
    <span class="enscript-type">struct</span> pfioc_table_64 *io64, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> p64 = proc_is64bit(p);
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (!p64)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">struct32</span>;

	<span class="enscript-comment">/*
	 * 64-bit structure processing
	 */</span>
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRTABLES</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != 0) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io64-&gt;pfrio_table);
		error = pfr_clr_tables(&amp;io64-&gt;pfrio_table, &amp;io64-&gt;pfrio_ndel,
		    io64-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRADDTABLES</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_table)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		error = pfr_add_tables(io64-&gt;pfrio_buffer, io64-&gt;pfrio_size,
		    &amp;io64-&gt;pfrio_nadd, io64-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRDELTABLES</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_table)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		error = pfr_del_tables(io64-&gt;pfrio_buffer, io64-&gt;pfrio_size,
		    &amp;io64-&gt;pfrio_ndel, io64-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETTABLES</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_table)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io64-&gt;pfrio_table);
		error = pfr_get_tables(&amp;io64-&gt;pfrio_table, io64-&gt;pfrio_buffer,
		    &amp;io64-&gt;pfrio_size, io64-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETTSTATS</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_tstats)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io64-&gt;pfrio_table);
		error = pfr_get_tstats(&amp;io64-&gt;pfrio_table, io64-&gt;pfrio_buffer,
		    &amp;io64-&gt;pfrio_size, io64-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRTSTATS</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_table)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		error = pfr_clr_tstats(io64-&gt;pfrio_buffer, io64-&gt;pfrio_size,
		    &amp;io64-&gt;pfrio_nzero, io64-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRSETTFLAGS</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_table)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		error = pfr_set_tflags(io64-&gt;pfrio_buffer, io64-&gt;pfrio_size,
		    io64-&gt;pfrio_setflag, io64-&gt;pfrio_clrflag,
		    &amp;io64-&gt;pfrio_nchange, &amp;io64-&gt;pfrio_ndel,
		    io64-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRADDRS</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != 0) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io64-&gt;pfrio_table);
		error = pfr_clr_addrs(&amp;io64-&gt;pfrio_table, &amp;io64-&gt;pfrio_ndel,
		    io64-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRADDADDRS</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io64-&gt;pfrio_table);
		error = pfr_add_addrs(&amp;io64-&gt;pfrio_table, io64-&gt;pfrio_buffer,
		    io64-&gt;pfrio_size, &amp;io64-&gt;pfrio_nadd, io64-&gt;pfrio_flags |
		    PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRDELADDRS</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io64-&gt;pfrio_table);
		error = pfr_del_addrs(&amp;io64-&gt;pfrio_table, io64-&gt;pfrio_buffer,
		    io64-&gt;pfrio_size, &amp;io64-&gt;pfrio_ndel, io64-&gt;pfrio_flags |
		    PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRSETADDRS</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io64-&gt;pfrio_table);
		error = pfr_set_addrs(&amp;io64-&gt;pfrio_table, io64-&gt;pfrio_buffer,
		    io64-&gt;pfrio_size, &amp;io64-&gt;pfrio_size2, &amp;io64-&gt;pfrio_nadd,
		    &amp;io64-&gt;pfrio_ndel, &amp;io64-&gt;pfrio_nchange, io64-&gt;pfrio_flags |
		    PFR_FLAG_USERIOCTL, 0);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETADDRS</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io64-&gt;pfrio_table);
		error = pfr_get_addrs(&amp;io64-&gt;pfrio_table, io64-&gt;pfrio_buffer,
		    &amp;io64-&gt;pfrio_size, io64-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETASTATS</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_astats)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io64-&gt;pfrio_table);
		error = pfr_get_astats(&amp;io64-&gt;pfrio_table, io64-&gt;pfrio_buffer,
		    &amp;io64-&gt;pfrio_size, io64-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRASTATS</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io64-&gt;pfrio_table);
		error = pfr_clr_astats(&amp;io64-&gt;pfrio_table, io64-&gt;pfrio_buffer,
		    io64-&gt;pfrio_size, &amp;io64-&gt;pfrio_nzero, io64-&gt;pfrio_flags |
		    PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRTSTADDRS</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io64-&gt;pfrio_table);
		error = pfr_tst_addrs(&amp;io64-&gt;pfrio_table, io64-&gt;pfrio_buffer,
		    io64-&gt;pfrio_size, &amp;io64-&gt;pfrio_nmatch, io64-&gt;pfrio_flags |
		    PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRINADEFINE</span>:
		<span class="enscript-keyword">if</span> (io64-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io64-&gt;pfrio_table);
		error = pfr_ina_define(&amp;io64-&gt;pfrio_table, io64-&gt;pfrio_buffer,
		    io64-&gt;pfrio_size, &amp;io64-&gt;pfrio_nadd, &amp;io64-&gt;pfrio_naddr,
		    io64-&gt;pfrio_ticket, io64-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

<span class="enscript-reference">struct32</span>:
	<span class="enscript-comment">/*
	 * 32-bit structure processing
	 */</span>
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRTABLES</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != 0) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io32-&gt;pfrio_table);
		error = pfr_clr_tables(&amp;io32-&gt;pfrio_table, &amp;io32-&gt;pfrio_ndel,
		    io32-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRADDTABLES</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_table)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		error = pfr_add_tables(io32-&gt;pfrio_buffer, io32-&gt;pfrio_size,
		    &amp;io32-&gt;pfrio_nadd, io32-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRDELTABLES</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_table)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		error = pfr_del_tables(io32-&gt;pfrio_buffer, io32-&gt;pfrio_size,
		    &amp;io32-&gt;pfrio_ndel, io32-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETTABLES</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_table)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io32-&gt;pfrio_table);
		error = pfr_get_tables(&amp;io32-&gt;pfrio_table, io32-&gt;pfrio_buffer,
		    &amp;io32-&gt;pfrio_size, io32-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETTSTATS</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_tstats)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io32-&gt;pfrio_table);
		error = pfr_get_tstats(&amp;io32-&gt;pfrio_table, io32-&gt;pfrio_buffer,
		    &amp;io32-&gt;pfrio_size, io32-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRTSTATS</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_table)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		error = pfr_clr_tstats(io32-&gt;pfrio_buffer, io32-&gt;pfrio_size,
		    &amp;io32-&gt;pfrio_nzero, io32-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRSETTFLAGS</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_table)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		error = pfr_set_tflags(io32-&gt;pfrio_buffer, io32-&gt;pfrio_size,
		    io32-&gt;pfrio_setflag, io32-&gt;pfrio_clrflag,
		    &amp;io32-&gt;pfrio_nchange, &amp;io32-&gt;pfrio_ndel,
		    io32-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRADDRS</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != 0) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io32-&gt;pfrio_table);
		error = pfr_clr_addrs(&amp;io32-&gt;pfrio_table, &amp;io32-&gt;pfrio_ndel,
		    io32-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRADDADDRS</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io32-&gt;pfrio_table);
		error = pfr_add_addrs(&amp;io32-&gt;pfrio_table, io32-&gt;pfrio_buffer,
		    io32-&gt;pfrio_size, &amp;io32-&gt;pfrio_nadd, io32-&gt;pfrio_flags |
		    PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRDELADDRS</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io32-&gt;pfrio_table);
		error = pfr_del_addrs(&amp;io32-&gt;pfrio_table, io32-&gt;pfrio_buffer,
		    io32-&gt;pfrio_size, &amp;io32-&gt;pfrio_ndel, io32-&gt;pfrio_flags |
		    PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRSETADDRS</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io32-&gt;pfrio_table);
		error = pfr_set_addrs(&amp;io32-&gt;pfrio_table, io32-&gt;pfrio_buffer,
		    io32-&gt;pfrio_size, &amp;io32-&gt;pfrio_size2, &amp;io32-&gt;pfrio_nadd,
		    &amp;io32-&gt;pfrio_ndel, &amp;io32-&gt;pfrio_nchange, io32-&gt;pfrio_flags |
		    PFR_FLAG_USERIOCTL, 0);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETADDRS</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io32-&gt;pfrio_table);
		error = pfr_get_addrs(&amp;io32-&gt;pfrio_table, io32-&gt;pfrio_buffer,
		    &amp;io32-&gt;pfrio_size, io32-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETASTATS</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_astats)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io32-&gt;pfrio_table);
		error = pfr_get_astats(&amp;io32-&gt;pfrio_table, io32-&gt;pfrio_buffer,
		    &amp;io32-&gt;pfrio_size, io32-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRASTATS</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io32-&gt;pfrio_table);
		error = pfr_clr_astats(&amp;io32-&gt;pfrio_table, io32-&gt;pfrio_buffer,
		    io32-&gt;pfrio_size, &amp;io32-&gt;pfrio_nzero, io32-&gt;pfrio_flags |
		    PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRTSTADDRS</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io32-&gt;pfrio_table);
		error = pfr_tst_addrs(&amp;io32-&gt;pfrio_table, io32-&gt;pfrio_buffer,
		    io32-&gt;pfrio_size, &amp;io32-&gt;pfrio_nmatch, io32-&gt;pfrio_flags |
		    PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRINADEFINE</span>:
		<span class="enscript-keyword">if</span> (io32-&gt;pfrio_esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfr_addr)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		pfr_table_copyin_cleanup(&amp;io32-&gt;pfrio_table);
		error = pfr_ina_define(&amp;io32-&gt;pfrio_table, io32-&gt;pfrio_buffer,
		    io32-&gt;pfrio_size, &amp;io32-&gt;pfrio_nadd, &amp;io32-&gt;pfrio_naddr,
		    io32-&gt;pfrio_ticket, io32-&gt;pfrio_flags | PFR_FLAG_USERIOCTL);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_tokens</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_tokens_32 *tok32,
    <span class="enscript-type">struct</span> pfioc_tokens_64 *tok64, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> pfioc_token *tokens;
	<span class="enscript-type">struct</span> pfioc_kernel_token *entry, *tmp;
	user_addr_t token_buf;
	<span class="enscript-type">int</span> ocnt, cnt, error = 0, p64 = proc_is64bit(p);
	<span class="enscript-type">char</span> *ptr;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTARTERS</span>: {
		<span class="enscript-type">int</span> size;

		<span class="enscript-keyword">if</span> (nr_tokens == 0) {
			error = ENOENT;
			<span class="enscript-keyword">break</span>;
		}

		size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfioc_token) * nr_tokens;
		ocnt = cnt = (p64 ? tok64-&gt;size : tok32-&gt;size);
		<span class="enscript-keyword">if</span> (cnt == 0) {
			<span class="enscript-keyword">if</span> (p64)
				tok64-&gt;size = size;
			<span class="enscript-keyword">else</span>
				tok32-&gt;size = size;
			<span class="enscript-keyword">break</span>;
		}

		token_buf = (p64 ? tok64-&gt;pgt_buf : tok32-&gt;pgt_buf);
		tokens = _MALLOC(size, M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (tokens == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">break</span>;
		}

		ptr = (<span class="enscript-type">void</span> *)tokens;
		SLIST_FOREACH_SAFE(entry, &amp;token_list_head, next, tmp) {
			<span class="enscript-type">struct</span> pfioc_token *t;

			<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>)cnt &lt; <span class="enscript-keyword">sizeof</span> (*tokens))
				<span class="enscript-keyword">break</span>;    <span class="enscript-comment">/* no more buffer space left */</span>

			t = (<span class="enscript-type">struct</span> pfioc_token *)(<span class="enscript-type">void</span> *)ptr;
			t-&gt;token_value	= entry-&gt;token.token_value;
			t-&gt;timestamp	= entry-&gt;token.timestamp;
			t-&gt;pid		= entry-&gt;token.pid;
			bcopy(entry-&gt;token.proc_name, t-&gt;proc_name,
			    PFTOK_PROCNAME_LEN);
			ptr += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfioc_token);

			cnt -= <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfioc_token);
		}

		<span class="enscript-keyword">if</span> (cnt &lt; ocnt)
			error = copyout(tokens, token_buf, ocnt - cnt);

		<span class="enscript-keyword">if</span> (p64)
			tok64-&gt;size = ocnt - cnt;
		<span class="enscript-keyword">else</span>
			tok32-&gt;size = ocnt - cnt;

		_FREE(tokens, M_TEMP);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_expire_states_and_src_nodes</span>(<span class="enscript-type">struct</span> pf_rule *rule)
{
	<span class="enscript-type">struct</span> pf_state		*state;
	<span class="enscript-type">struct</span> pf_src_node	*sn;
	<span class="enscript-type">int</span>			 killed = 0;

	<span class="enscript-comment">/* expire the states */</span>
	state = TAILQ_FIRST(&amp;state_list);
	<span class="enscript-keyword">while</span> (state) {
		<span class="enscript-keyword">if</span> (state-&gt;rule.ptr == rule)
			state-&gt;timeout = PFTM_PURGE;
		state = TAILQ_NEXT(state, entry_list);
	}
	pf_purge_expired_states(pf_status.states);

	<span class="enscript-comment">/* expire the src_nodes */</span>
	RB_FOREACH(sn, pf_src_tree, &amp;tree_src_tracking) {
		<span class="enscript-keyword">if</span> (sn-&gt;rule.ptr != rule)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (sn-&gt;states != 0) {
			RB_FOREACH(state, pf_state_tree_id,
			    &amp;tree_id) {
				<span class="enscript-keyword">if</span> (state-&gt;src_node == sn)
					state-&gt;src_node = NULL;
				<span class="enscript-keyword">if</span> (state-&gt;nat_src_node == sn)
					state-&gt;nat_src_node = NULL;
			}
			sn-&gt;states = 0;
		}
		sn-&gt;expire = 1;
		killed++;
	}
	<span class="enscript-keyword">if</span> (killed)
		pf_purge_expired_src_nodes();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_delete_rule_from_ruleset</span>(<span class="enscript-type">struct</span> pf_ruleset *ruleset, <span class="enscript-type">int</span> rs_num,
    <span class="enscript-type">struct</span> pf_rule *rule)
{
	<span class="enscript-type">struct</span> pf_rule *r;
	<span class="enscript-type">int</span> nr = 0;

	pf_expire_states_and_src_nodes(rule);

	pf_rm_rule(ruleset-&gt;rules[rs_num].active.ptr, rule);
	<span class="enscript-keyword">if</span> (ruleset-&gt;rules[rs_num].active.rcount-- == 0)
		panic(<span class="enscript-string">&quot;%s: rcount value broken!&quot;</span>, __func__);
	r = TAILQ_FIRST(ruleset-&gt;rules[rs_num].active.ptr);

	<span class="enscript-keyword">while</span> (r) {
		r-&gt;nr = nr++;
		r = TAILQ_NEXT(r, entries);
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_ruleset_cleanup</span>(<span class="enscript-type">struct</span> pf_ruleset *ruleset, <span class="enscript-type">int</span> rs)
{
	pf_calc_skip_steps(ruleset-&gt;rules[rs].active.ptr);
	ruleset-&gt;rules[rs].active.ticket =
	    ++ruleset-&gt;rules[rs].inactive.ticket;
}

<span class="enscript-comment">/*
 * req_dev encodes the PF interface. Currently, possible values are
 * 0 or PFRULE_PFM
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_delete_rule_by_ticket</span>(<span class="enscript-type">struct</span> pfioc_rule *pr, u_int32_t req_dev)
{
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset;
	<span class="enscript-type">struct</span> pf_rule		*rule = NULL;
	<span class="enscript-type">int</span>			 is_anchor;
	<span class="enscript-type">int</span>			 error;
	<span class="enscript-type">int</span>			 i;

	is_anchor = (pr-&gt;anchor_call[0] != <span class="enscript-string">'\0'</span>);
	<span class="enscript-keyword">if</span> ((ruleset = pf_find_ruleset_with_owner(pr-&gt;anchor,
	    pr-&gt;rule.owner, is_anchor, &amp;error)) == NULL)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; PF_RULESET_MAX &amp;&amp; rule == NULL; i++) {
		rule = TAILQ_FIRST(ruleset-&gt;rules[i].active.ptr);
		<span class="enscript-keyword">while</span> (rule &amp;&amp; (rule-&gt;ticket != pr-&gt;rule.ticket))
			rule = TAILQ_NEXT(rule, entries);
	}
	<span class="enscript-keyword">if</span> (rule == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);
	<span class="enscript-keyword">else</span> 
		i--;

	<span class="enscript-keyword">if</span> (strcmp(rule-&gt;owner, pr-&gt;rule.owner))
		<span class="enscript-keyword">return</span> (EACCES);

<span class="enscript-reference">delete_rule</span>:
	<span class="enscript-keyword">if</span> (rule-&gt;anchor &amp;&amp; (ruleset != &amp;pf_main_ruleset) &amp;&amp;
	    ((strcmp(ruleset-&gt;anchor-&gt;owner, <span class="enscript-string">&quot;&quot;</span>)) == 0) &amp;&amp;
	    ((ruleset-&gt;rules[i].active.rcount - 1) == 0)) {
		<span class="enscript-comment">/* set rule &amp; ruleset to parent and repeat */</span>
		<span class="enscript-type">struct</span> pf_rule *delete_rule = rule;
		<span class="enscript-type">struct</span> pf_ruleset *delete_ruleset = ruleset;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">parent_ruleset</span>		ruleset-&gt;anchor-&gt;parent-&gt;ruleset
		<span class="enscript-keyword">if</span> (ruleset-&gt;anchor-&gt;parent == NULL)
			ruleset = &amp;pf_main_ruleset;
		<span class="enscript-keyword">else</span>
			ruleset = &amp;parent_ruleset;

		rule = TAILQ_FIRST(ruleset-&gt;rules[i].active.ptr);
		<span class="enscript-keyword">while</span> (rule &amp;&amp;
		    (rule-&gt;anchor != delete_ruleset-&gt;anchor))
			rule = TAILQ_NEXT(rule, entries);
		<span class="enscript-keyword">if</span> (rule == NULL)
			panic(<span class="enscript-string">&quot;%s: rule not found!&quot;</span>, __func__);

		<span class="enscript-comment">/* 
		 * if reqest device != rule's device, bail :
		 * with error if ticket matches;
		 * without error if ticket doesn't match (i.e. its just cleanup)
		 */</span>
		<span class="enscript-keyword">if</span> ((rule-&gt;rule_flag &amp; PFRULE_PFM) ^ req_dev) {
			<span class="enscript-keyword">if</span> (rule-&gt;ticket != pr-&gt;rule.ticket) {
				<span class="enscript-keyword">return</span> (0);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">return</span> EACCES;
			}
		}

		<span class="enscript-keyword">if</span> (delete_rule-&gt;rule_flag &amp; PFRULE_PFM) {
			pffwrules--;
		}

		pf_delete_rule_from_ruleset(delete_ruleset,
		    i, delete_rule);
		delete_ruleset-&gt;rules[i].active.ticket =
		    ++delete_ruleset-&gt;rules[i].inactive.ticket;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">delete_rule</span>;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* 
		 * process deleting rule only if device that added the
		 * rule matches device that issued the request
		 */</span>
		<span class="enscript-keyword">if</span> ((rule-&gt;rule_flag &amp; PFRULE_PFM) ^ req_dev)
			<span class="enscript-keyword">return</span> EACCES;
		<span class="enscript-keyword">if</span> (rule-&gt;rule_flag &amp; PFRULE_PFM)
			pffwrules--;
		pf_delete_rule_from_ruleset(ruleset, i,
		    rule);
		pf_ruleset_cleanup(ruleset, i);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * req_dev encodes the PF interface. Currently, possible values are
 * 0 or PFRULE_PFM
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_delete_rule_by_owner</span>(<span class="enscript-type">char</span> *owner, u_int32_t req_dev)
{
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset;
	<span class="enscript-type">struct</span> pf_rule		*rule, *next;
	<span class="enscript-type">int</span>			 deleted = 0;

	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> rs = 0; rs &lt; PF_RULESET_MAX; rs++) {
		rule = TAILQ_FIRST(pf_main_ruleset.rules[rs].active.ptr);
		ruleset = &amp;pf_main_ruleset;
		<span class="enscript-keyword">while</span> (rule) {
			next = TAILQ_NEXT(rule, entries);
			<span class="enscript-comment">/* 
			 * process deleting rule only if device that added the
			 * rule matches device that issued the request
			 */</span>
			<span class="enscript-keyword">if</span> ((rule-&gt;rule_flag &amp; PFRULE_PFM) ^ req_dev) {
				rule = next;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (rule-&gt;anchor) {
				<span class="enscript-keyword">if</span> (((strcmp(rule-&gt;owner, owner)) == 0) ||
				    ((strcmp(rule-&gt;owner, <span class="enscript-string">&quot;&quot;</span>)) == 0)) {
					<span class="enscript-keyword">if</span> (rule-&gt;anchor-&gt;ruleset.rules[rs].active.rcount &gt; 0) {
						<span class="enscript-keyword">if</span> (deleted) {
							pf_ruleset_cleanup(ruleset, rs);
							deleted = 0;
						}
						<span class="enscript-comment">/* step into anchor */</span>
						ruleset =
						    &amp;rule-&gt;anchor-&gt;ruleset;
						rule = TAILQ_FIRST(ruleset-&gt;rules[rs].active.ptr);
						<span class="enscript-keyword">continue</span>;
					} <span class="enscript-keyword">else</span> {
						<span class="enscript-keyword">if</span> (rule-&gt;rule_flag &amp;
						    PFRULE_PFM)
							pffwrules--;
						pf_delete_rule_from_ruleset(ruleset, rs, rule);
						deleted = 1;
						rule = next;
					}
				} <span class="enscript-keyword">else</span>
					rule = next;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (((strcmp(rule-&gt;owner, owner)) == 0)) {
					<span class="enscript-comment">/* delete rule */</span>
					<span class="enscript-keyword">if</span> (rule-&gt;rule_flag &amp; PFRULE_PFM)
						pffwrules--;
					pf_delete_rule_from_ruleset(ruleset,
					    rs, rule);
					deleted = 1;
				}
				rule = next;
			}
			<span class="enscript-keyword">if</span> (rule == NULL) {
				<span class="enscript-keyword">if</span> (deleted) {
					pf_ruleset_cleanup(ruleset, rs);
					deleted = 0;
				}
				<span class="enscript-keyword">if</span> (ruleset != &amp;pf_main_ruleset)
					pf_deleterule_anchor_step_out(&amp;ruleset,
					    rs, &amp;rule);
			}
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_deleterule_anchor_step_out</span>(<span class="enscript-type">struct</span> pf_ruleset **ruleset_ptr,
    <span class="enscript-type">int</span> rs, <span class="enscript-type">struct</span> pf_rule **rule_ptr)
{
	<span class="enscript-type">struct</span> pf_ruleset *ruleset = *ruleset_ptr;
	<span class="enscript-type">struct</span> pf_rule *rule = *rule_ptr;

	<span class="enscript-comment">/* step out of anchor */</span>
	<span class="enscript-type">struct</span> pf_ruleset *rs_copy = ruleset;
	ruleset = ruleset-&gt;anchor-&gt;parent?
	    &amp;ruleset-&gt;anchor-&gt;parent-&gt;ruleset:&amp;pf_main_ruleset;

	rule = TAILQ_FIRST(ruleset-&gt;rules[rs].active.ptr);
	<span class="enscript-keyword">while</span> (rule &amp;&amp; (rule-&gt;anchor != rs_copy-&gt;anchor))
		rule = TAILQ_NEXT(rule, entries);
	<span class="enscript-keyword">if</span> (rule == NULL)
		panic(<span class="enscript-string">&quot;%s: parent rule of anchor not found!&quot;</span>, __func__);
	<span class="enscript-keyword">if</span> (rule-&gt;anchor-&gt;ruleset.rules[rs].active.rcount &gt; 0)
		rule = TAILQ_NEXT(rule, entries);

	*ruleset_ptr = ruleset;
	*rule_ptr = rule;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_addrwrap_setup</span>(<span class="enscript-type">struct</span> pf_addr_wrap *aw)
{
	VERIFY(aw);
	bzero(&amp;aw-&gt;p, <span class="enscript-keyword">sizeof</span> aw-&gt;p);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_rule_setup</span>(<span class="enscript-type">struct</span> pfioc_rule *pr, <span class="enscript-type">struct</span> pf_rule *rule,
    <span class="enscript-type">struct</span> pf_ruleset *ruleset) {
	<span class="enscript-type">struct</span> pf_pooladdr 	*apa;
	<span class="enscript-type">int</span>			 error = 0;

	<span class="enscript-keyword">if</span> (rule-&gt;ifname[0]) {
		rule-&gt;kif = pfi_kif_get(rule-&gt;ifname);
		<span class="enscript-keyword">if</span> (rule-&gt;kif == NULL) {
			pool_put(&amp;pf_rule_pl, rule);
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		pfi_kif_ref(rule-&gt;kif, PFI_KIF_REF_RULE);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-comment">/* set queue IDs */</span>
	<span class="enscript-keyword">if</span> (altq_allowed &amp;&amp; rule-&gt;qname[0] != <span class="enscript-string">'\0'</span>) {
		<span class="enscript-keyword">if</span> ((rule-&gt;qid = pf_qname2qid(rule-&gt;qname)) == 0)
			error = EBUSY;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rule-&gt;pqname[0] != <span class="enscript-string">'\0'</span>) {
			<span class="enscript-keyword">if</span> ((rule-&gt;pqid =
			    pf_qname2qid(rule-&gt;pqname)) == 0)
				error = EBUSY;
		} <span class="enscript-keyword">else</span>
			rule-&gt;pqid = rule-&gt;qid;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
	<span class="enscript-keyword">if</span> (rule-&gt;tagname[0])
		<span class="enscript-keyword">if</span> ((rule-&gt;tag = pf_tagname2tag(rule-&gt;tagname)) == 0)
			error = EBUSY;
	<span class="enscript-keyword">if</span> (rule-&gt;match_tagname[0])
		<span class="enscript-keyword">if</span> ((rule-&gt;match_tag =
		    pf_tagname2tag(rule-&gt;match_tagname)) == 0)
			error = EBUSY;
	<span class="enscript-keyword">if</span> (rule-&gt;rt &amp;&amp; !rule-&gt;direction)
		error = EINVAL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PFLOG</span>
	<span class="enscript-keyword">if</span> (!rule-&gt;log)
		rule-&gt;logif = 0;
	<span class="enscript-keyword">if</span> (rule-&gt;logif &gt;= PFLOGIFS_MAX)
		error = EINVAL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFLOG */</span>
	pf_addrwrap_setup(&amp;rule-&gt;src.addr);
	pf_addrwrap_setup(&amp;rule-&gt;dst.addr);
	<span class="enscript-keyword">if</span> (pf_rtlabel_add(&amp;rule-&gt;src.addr) ||
	    pf_rtlabel_add(&amp;rule-&gt;dst.addr))
		error = EBUSY;
	<span class="enscript-keyword">if</span> (pfi_dynaddr_setup(&amp;rule-&gt;src.addr, rule-&gt;af))
		error = EINVAL;
	<span class="enscript-keyword">if</span> (pfi_dynaddr_setup(&amp;rule-&gt;dst.addr, rule-&gt;af))
		error = EINVAL;
	<span class="enscript-keyword">if</span> (pf_tbladdr_setup(ruleset, &amp;rule-&gt;src.addr))
		error = EINVAL;
	<span class="enscript-keyword">if</span> (pf_tbladdr_setup(ruleset, &amp;rule-&gt;dst.addr))
		error = EINVAL;
	<span class="enscript-keyword">if</span> (pf_anchor_setup(rule, ruleset, pr-&gt;anchor_call))
		error = EINVAL;
	TAILQ_FOREACH(apa, &amp;pf_pabuf, entries)
		<span class="enscript-keyword">if</span> (pf_tbladdr_setup(ruleset, &amp;apa-&gt;addr))
			error = EINVAL;

	<span class="enscript-keyword">if</span> (rule-&gt;overload_tblname[0]) {
		<span class="enscript-keyword">if</span> ((rule-&gt;overload_tbl = pfr_attach_table(ruleset,
		    rule-&gt;overload_tblname)) == NULL)
			error = EINVAL;
		<span class="enscript-keyword">else</span>
			rule-&gt;overload_tbl-&gt;pfrkt_flags |=
			    PFR_TFLAG_ACTIVE;
	}

	pf_mv_pool(&amp;pf_pabuf, &amp;rule-&gt;rpool.list);

	<span class="enscript-keyword">if</span> (((((rule-&gt;action == PF_NAT) || (rule-&gt;action == PF_RDR) ||
	    (rule-&gt;action == PF_BINAT) || (rule-&gt;action == PF_NAT64)) &amp;&amp;
	    rule-&gt;anchor == NULL) ||
	    (rule-&gt;rt &gt; PF_FASTROUTE)) &amp;&amp;
	    (TAILQ_FIRST(&amp;rule-&gt;rpool.list) == NULL))
		error = EINVAL;

	<span class="enscript-keyword">if</span> (error) {
		pf_rm_rule(NULL, rule);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-comment">/* For a NAT64 rule the rule's address family is AF_INET6 whereas
	 * the address pool's family will be AF_INET
	 */</span>
	rule-&gt;rpool.af = (rule-&gt;action == PF_NAT64) ? AF_INET: rule-&gt;af;
	rule-&gt;rpool.cur = TAILQ_FIRST(&amp;rule-&gt;rpool.list);
	rule-&gt;evaluations = rule-&gt;packets[0] = rule-&gt;packets[1] =
	    rule-&gt;bytes[0] = rule-&gt;bytes[1] = 0;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_rule</span>(u_long cmd, <span class="enscript-type">int</span> minordev, <span class="enscript-type">struct</span> pfioc_rule *pr, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error = 0;
	u_int32_t req_dev = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCADDRULE</span>: {
		<span class="enscript-type">struct</span> pf_ruleset	*ruleset;
		<span class="enscript-type">struct</span> pf_rule		*rule, *tail;
		<span class="enscript-type">int</span>			rs_num;

		pr-&gt;anchor[<span class="enscript-keyword">sizeof</span> (pr-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
		pr-&gt;anchor_call[<span class="enscript-keyword">sizeof</span> (pr-&gt;anchor_call) - 1] = <span class="enscript-string">'\0'</span>;
		ruleset = pf_find_ruleset(pr-&gt;anchor);
		<span class="enscript-keyword">if</span> (ruleset == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		rs_num = pf_get_ruleset_number(pr-&gt;rule.action);
		<span class="enscript-keyword">if</span> (rs_num &gt;= PF_RULESET_MAX) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (pr-&gt;rule.return_icmp &gt;&gt; 8 &gt; ICMP_MAXTYPE) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (pr-&gt;ticket != ruleset-&gt;rules[rs_num].inactive.ticket) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (pr-&gt;pool_ticket != ticket_pabuf) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		rule = pool_get(&amp;pf_rule_pl, PR_WAITOK);
		<span class="enscript-keyword">if</span> (rule == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">break</span>;
		}
		pf_rule_copyin(&amp;pr-&gt;rule, rule, p, minordev);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">if</span> (rule-&gt;af == AF_INET) {
			pool_put(&amp;pf_rule_pl, rule);
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (rule-&gt;af == AF_INET6) {
			pool_put(&amp;pf_rule_pl, rule);
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		tail = TAILQ_LAST(ruleset-&gt;rules[rs_num].inactive.ptr,
		    pf_rulequeue);
		<span class="enscript-keyword">if</span> (tail)
			rule-&gt;nr = tail-&gt;nr + 1;
		<span class="enscript-keyword">else</span>
			rule-&gt;nr = 0;

		<span class="enscript-keyword">if</span> ((error = pf_rule_setup(pr, rule, ruleset)))
			<span class="enscript-keyword">break</span>;

		TAILQ_INSERT_TAIL(ruleset-&gt;rules[rs_num].inactive.ptr,
		    rule, entries);
		ruleset-&gt;rules[rs_num].inactive.rcount++;
		<span class="enscript-keyword">if</span> (rule-&gt;rule_flag &amp; PFRULE_PFM)
			pffwrules++;

		<span class="enscript-keyword">if</span> (rule-&gt;action == PF_NAT64)
			atomic_add_16(&amp;pf_nat64_configured, 1);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULES</span>: {
		<span class="enscript-type">struct</span> pf_ruleset	*ruleset;
		<span class="enscript-type">struct</span> pf_rule		*tail;
		<span class="enscript-type">int</span>			 rs_num;

		pr-&gt;anchor[<span class="enscript-keyword">sizeof</span> (pr-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
		pr-&gt;anchor_call[<span class="enscript-keyword">sizeof</span> (pr-&gt;anchor_call) - 1] = <span class="enscript-string">'\0'</span>;
		ruleset = pf_find_ruleset(pr-&gt;anchor);
		<span class="enscript-keyword">if</span> (ruleset == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		rs_num = pf_get_ruleset_number(pr-&gt;rule.action);
		<span class="enscript-keyword">if</span> (rs_num &gt;= PF_RULESET_MAX) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		tail = TAILQ_LAST(ruleset-&gt;rules[rs_num].active.ptr,
		    pf_rulequeue);
		<span class="enscript-keyword">if</span> (tail)
			pr-&gt;nr = tail-&gt;nr + 1;
		<span class="enscript-keyword">else</span>
			pr-&gt;nr = 0;
		pr-&gt;ticket = ruleset-&gt;rules[rs_num].active.ticket;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULE</span>: {
		<span class="enscript-type">struct</span> pf_ruleset	*ruleset;
		<span class="enscript-type">struct</span> pf_rule		*rule;
		<span class="enscript-type">int</span>			 rs_num, i;

		pr-&gt;anchor[<span class="enscript-keyword">sizeof</span> (pr-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
		pr-&gt;anchor_call[<span class="enscript-keyword">sizeof</span> (pr-&gt;anchor_call) - 1] = <span class="enscript-string">'\0'</span>;
		ruleset = pf_find_ruleset(pr-&gt;anchor);
		<span class="enscript-keyword">if</span> (ruleset == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		rs_num = pf_get_ruleset_number(pr-&gt;rule.action);
		<span class="enscript-keyword">if</span> (rs_num &gt;= PF_RULESET_MAX) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (pr-&gt;ticket != ruleset-&gt;rules[rs_num].active.ticket) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		rule = TAILQ_FIRST(ruleset-&gt;rules[rs_num].active.ptr);
		<span class="enscript-keyword">while</span> ((rule != NULL) &amp;&amp; (rule-&gt;nr != pr-&gt;nr))
			rule = TAILQ_NEXT(rule, entries);
		<span class="enscript-keyword">if</span> (rule == NULL) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		pf_rule_copyout(rule, &amp;pr-&gt;rule);
		<span class="enscript-keyword">if</span> (pf_anchor_copyout(ruleset, rule, pr)) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		pfi_dynaddr_copyout(&amp;pr-&gt;rule.src.addr);
		pfi_dynaddr_copyout(&amp;pr-&gt;rule.dst.addr);
		pf_tbladdr_copyout(&amp;pr-&gt;rule.src.addr);
		pf_tbladdr_copyout(&amp;pr-&gt;rule.dst.addr);
		pf_rtlabel_copyout(&amp;pr-&gt;rule.src.addr);
		pf_rtlabel_copyout(&amp;pr-&gt;rule.dst.addr);
		<span class="enscript-keyword">for</span> (i = 0; i &lt; PF_SKIP_COUNT; ++i)
			<span class="enscript-keyword">if</span> (rule-&gt;skip[i].ptr == NULL)
				pr-&gt;rule.skip[i].nr = -1;
			<span class="enscript-keyword">else</span>
				pr-&gt;rule.skip[i].nr =
				    rule-&gt;skip[i].ptr-&gt;nr;

		<span class="enscript-keyword">if</span> (pr-&gt;action == PF_GET_CLR_CNTR) {
			rule-&gt;evaluations = 0;
			rule-&gt;packets[0] = rule-&gt;packets[1] = 0;
			rule-&gt;bytes[0] = rule-&gt;bytes[1] = 0;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCHANGERULE</span>: {
		<span class="enscript-type">struct</span> pfioc_rule	*pcr = pr;
		<span class="enscript-type">struct</span> pf_ruleset	*ruleset;
		<span class="enscript-type">struct</span> pf_rule		*oldrule = NULL, *newrule = NULL;
		<span class="enscript-type">struct</span> pf_pooladdr	*pa;
		u_int32_t		 nr = 0;
		<span class="enscript-type">int</span>			 rs_num;

		<span class="enscript-keyword">if</span> (!(pcr-&gt;action == PF_CHANGE_REMOVE ||
		    pcr-&gt;action == PF_CHANGE_GET_TICKET) &amp;&amp;
		    pcr-&gt;pool_ticket != ticket_pabuf) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (pcr-&gt;action &lt; PF_CHANGE_ADD_HEAD ||
		    pcr-&gt;action &gt; PF_CHANGE_GET_TICKET) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		pcr-&gt;anchor[<span class="enscript-keyword">sizeof</span> (pcr-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
		pcr-&gt;anchor_call[<span class="enscript-keyword">sizeof</span> (pcr-&gt;anchor_call) - 1] = <span class="enscript-string">'\0'</span>;
		ruleset = pf_find_ruleset(pcr-&gt;anchor);
		<span class="enscript-keyword">if</span> (ruleset == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		rs_num = pf_get_ruleset_number(pcr-&gt;rule.action);
		<span class="enscript-keyword">if</span> (rs_num &gt;= PF_RULESET_MAX) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (pcr-&gt;action == PF_CHANGE_GET_TICKET) {
			pcr-&gt;ticket = ++ruleset-&gt;rules[rs_num].active.ticket;
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (pcr-&gt;ticket !=
			    ruleset-&gt;rules[rs_num].active.ticket) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (pcr-&gt;rule.return_icmp &gt;&gt; 8 &gt; ICMP_MAXTYPE) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (pcr-&gt;action != PF_CHANGE_REMOVE) {
			newrule = pool_get(&amp;pf_rule_pl, PR_WAITOK);
			<span class="enscript-keyword">if</span> (newrule == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">break</span>;
			}
			pf_rule_copyin(&amp;pcr-&gt;rule, newrule, p, minordev);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">INET</span>
			<span class="enscript-keyword">if</span> (newrule-&gt;af == AF_INET) {
				pool_put(&amp;pf_rule_pl, newrule);
				error = EAFNOSUPPORT;
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (newrule-&gt;af == AF_INET6) {
				pool_put(&amp;pf_rule_pl, newrule);
				error = EAFNOSUPPORT;
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			<span class="enscript-keyword">if</span> (newrule-&gt;ifname[0]) {
				newrule-&gt;kif = pfi_kif_get(newrule-&gt;ifname);
				<span class="enscript-keyword">if</span> (newrule-&gt;kif == NULL) {
					pool_put(&amp;pf_rule_pl, newrule);
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				}
				pfi_kif_ref(newrule-&gt;kif, PFI_KIF_REF_RULE);
			} <span class="enscript-keyword">else</span>
				newrule-&gt;kif = NULL;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
			<span class="enscript-comment">/* set queue IDs */</span>
			<span class="enscript-keyword">if</span> (altq_allowed &amp;&amp; newrule-&gt;qname[0] != <span class="enscript-string">'\0'</span>) {
				<span class="enscript-keyword">if</span> ((newrule-&gt;qid =
				    pf_qname2qid(newrule-&gt;qname)) == 0)
					error = EBUSY;
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (newrule-&gt;pqname[0] != <span class="enscript-string">'\0'</span>) {
					<span class="enscript-keyword">if</span> ((newrule-&gt;pqid =
					    pf_qname2qid(newrule-&gt;pqname)) == 0)
						error = EBUSY;
				} <span class="enscript-keyword">else</span>
					newrule-&gt;pqid = newrule-&gt;qid;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
			<span class="enscript-keyword">if</span> (newrule-&gt;tagname[0])
				<span class="enscript-keyword">if</span> ((newrule-&gt;tag =
				    pf_tagname2tag(newrule-&gt;tagname)) == 0)
					error = EBUSY;
			<span class="enscript-keyword">if</span> (newrule-&gt;match_tagname[0])
				<span class="enscript-keyword">if</span> ((newrule-&gt;match_tag = pf_tagname2tag(
				    newrule-&gt;match_tagname)) == 0)
					error = EBUSY;
			<span class="enscript-keyword">if</span> (newrule-&gt;rt &amp;&amp; !newrule-&gt;direction)
				error = EINVAL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PFLOG</span>
			<span class="enscript-keyword">if</span> (!newrule-&gt;log)
				newrule-&gt;logif = 0;
			<span class="enscript-keyword">if</span> (newrule-&gt;logif &gt;= PFLOGIFS_MAX)
				error = EINVAL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFLOG */</span>
			pf_addrwrap_setup(&amp;newrule-&gt;src.addr);
			pf_addrwrap_setup(&amp;newrule-&gt;dst.addr);
			<span class="enscript-keyword">if</span> (pf_rtlabel_add(&amp;newrule-&gt;src.addr) ||
			    pf_rtlabel_add(&amp;newrule-&gt;dst.addr))
				error = EBUSY;
			<span class="enscript-keyword">if</span> (pfi_dynaddr_setup(&amp;newrule-&gt;src.addr, newrule-&gt;af))
				error = EINVAL;
			<span class="enscript-keyword">if</span> (pfi_dynaddr_setup(&amp;newrule-&gt;dst.addr, newrule-&gt;af))
				error = EINVAL;
			<span class="enscript-keyword">if</span> (pf_tbladdr_setup(ruleset, &amp;newrule-&gt;src.addr))
				error = EINVAL;
			<span class="enscript-keyword">if</span> (pf_tbladdr_setup(ruleset, &amp;newrule-&gt;dst.addr))
				error = EINVAL;
			<span class="enscript-keyword">if</span> (pf_anchor_setup(newrule, ruleset, pcr-&gt;anchor_call))
				error = EINVAL;
			TAILQ_FOREACH(pa, &amp;pf_pabuf, entries)
				<span class="enscript-keyword">if</span> (pf_tbladdr_setup(ruleset, &amp;pa-&gt;addr))
					error = EINVAL;

			<span class="enscript-keyword">if</span> (newrule-&gt;overload_tblname[0]) {
				<span class="enscript-keyword">if</span> ((newrule-&gt;overload_tbl = pfr_attach_table(
				    ruleset, newrule-&gt;overload_tblname)) ==
				    NULL)
					error = EINVAL;
				<span class="enscript-keyword">else</span>
					newrule-&gt;overload_tbl-&gt;pfrkt_flags |=
					    PFR_TFLAG_ACTIVE;
			}

			pf_mv_pool(&amp;pf_pabuf, &amp;newrule-&gt;rpool.list);
			<span class="enscript-keyword">if</span> (((((newrule-&gt;action == PF_NAT) ||
			    (newrule-&gt;action == PF_RDR) ||
			    (newrule-&gt;action == PF_BINAT) ||
			    (newrule-&gt;rt &gt; PF_FASTROUTE)) &amp;&amp;
			    !newrule-&gt;anchor)) &amp;&amp;
			    (TAILQ_FIRST(&amp;newrule-&gt;rpool.list) == NULL))
				error = EINVAL;

			<span class="enscript-keyword">if</span> (error) {
				pf_rm_rule(NULL, newrule);
				<span class="enscript-keyword">break</span>;
			}
			newrule-&gt;rpool.cur = TAILQ_FIRST(&amp;newrule-&gt;rpool.list);
			newrule-&gt;evaluations = 0;
			newrule-&gt;packets[0] = newrule-&gt;packets[1] = 0;
			newrule-&gt;bytes[0] = newrule-&gt;bytes[1] = 0;
		}
		pf_empty_pool(&amp;pf_pabuf);

		<span class="enscript-keyword">if</span> (pcr-&gt;action == PF_CHANGE_ADD_HEAD)
			oldrule = TAILQ_FIRST(
			    ruleset-&gt;rules[rs_num].active.ptr);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pcr-&gt;action == PF_CHANGE_ADD_TAIL)
			oldrule = TAILQ_LAST(
			    ruleset-&gt;rules[rs_num].active.ptr, pf_rulequeue);
		<span class="enscript-keyword">else</span> {
			oldrule = TAILQ_FIRST(
			    ruleset-&gt;rules[rs_num].active.ptr);
			<span class="enscript-keyword">while</span> ((oldrule != NULL) &amp;&amp; (oldrule-&gt;nr != pcr-&gt;nr))
				oldrule = TAILQ_NEXT(oldrule, entries);
			<span class="enscript-keyword">if</span> (oldrule == NULL) {
				<span class="enscript-keyword">if</span> (newrule != NULL)
					pf_rm_rule(NULL, newrule);
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (pcr-&gt;action == PF_CHANGE_REMOVE) {
			pf_rm_rule(ruleset-&gt;rules[rs_num].active.ptr, oldrule);
			ruleset-&gt;rules[rs_num].active.rcount--;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (oldrule == NULL)
				TAILQ_INSERT_TAIL(
				    ruleset-&gt;rules[rs_num].active.ptr,
				    newrule, entries);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pcr-&gt;action == PF_CHANGE_ADD_HEAD ||
			    pcr-&gt;action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldrule, newrule, entries);
			<span class="enscript-keyword">else</span>
				TAILQ_INSERT_AFTER(
				    ruleset-&gt;rules[rs_num].active.ptr,
				    oldrule, newrule, entries);
			ruleset-&gt;rules[rs_num].active.rcount++;
		}

		nr = 0;
		TAILQ_FOREACH(oldrule,
		    ruleset-&gt;rules[rs_num].active.ptr, entries)
			oldrule-&gt;nr = nr++;

		ruleset-&gt;rules[rs_num].active.ticket++;

		pf_calc_skip_steps(ruleset-&gt;rules[rs_num].active.ptr);
		pf_remove_if_empty_ruleset(ruleset);

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCINSERTRULE</span>: {
		<span class="enscript-type">struct</span> pf_ruleset	*ruleset;
		<span class="enscript-type">struct</span> pf_rule		*rule, *tail, *r;
		<span class="enscript-type">int</span>			rs_num;
		<span class="enscript-type">int</span>			is_anchor;

		pr-&gt;anchor[<span class="enscript-keyword">sizeof</span> (pr-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
		pr-&gt;anchor_call[<span class="enscript-keyword">sizeof</span> (pr-&gt;anchor_call) - 1] = <span class="enscript-string">'\0'</span>;
		is_anchor = (pr-&gt;anchor_call[0] != <span class="enscript-string">'\0'</span>);

		<span class="enscript-keyword">if</span> ((ruleset = pf_find_ruleset_with_owner(pr-&gt;anchor,
		    pr-&gt;rule.owner, is_anchor, &amp;error)) == NULL)
			<span class="enscript-keyword">break</span>;

		rs_num = pf_get_ruleset_number(pr-&gt;rule.action);
		<span class="enscript-keyword">if</span> (rs_num &gt;= PF_RULESET_MAX) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (pr-&gt;rule.return_icmp &gt;&gt; 8 &gt; ICMP_MAXTYPE) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* make sure this anchor rule doesn't exist already */</span>
		<span class="enscript-keyword">if</span> (is_anchor) {
			r = TAILQ_FIRST(ruleset-&gt;rules[rs_num].active.ptr);
			<span class="enscript-keyword">while</span> (r) {
				<span class="enscript-keyword">if</span> (r-&gt;anchor &amp;&amp;
				    ((strcmp(r-&gt;anchor-&gt;name,
				    pr-&gt;anchor_call)) == 0)) {
					<span class="enscript-keyword">if</span> (((strcmp(pr-&gt;rule.owner,
					    r-&gt;owner)) == 0) ||
					    ((strcmp(r-&gt;owner, <span class="enscript-string">&quot;&quot;</span>)) == 0))
						error = EEXIST;
					<span class="enscript-keyword">else</span>
						error = EPERM;
					<span class="enscript-keyword">break</span>;
				}
				r = TAILQ_NEXT(r, entries);
			}
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">return</span> (error);
		}

		rule = pool_get(&amp;pf_rule_pl, PR_WAITOK);
		<span class="enscript-keyword">if</span> (rule == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">break</span>;
		}
		pf_rule_copyin(&amp;pr-&gt;rule, rule, p, minordev);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">if</span> (rule-&gt;af == AF_INET) {
			pool_put(&amp;pf_rule_pl, rule);
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (rule-&gt;af == AF_INET6) {
			pool_put(&amp;pf_rule_pl, rule);
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">break</span>;
		}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		r = TAILQ_FIRST(ruleset-&gt;rules[rs_num].active.ptr);
		<span class="enscript-keyword">while</span> ((r != NULL) &amp;&amp; (rule-&gt;priority &gt;= (<span class="enscript-type">unsigned</span>)r-&gt;priority))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">if</span> (r == NULL) {
			<span class="enscript-keyword">if</span> ((tail =
			    TAILQ_LAST(ruleset-&gt;rules[rs_num].active.ptr,
			    pf_rulequeue)) != NULL)
				rule-&gt;nr = tail-&gt;nr + 1;
			<span class="enscript-keyword">else</span>
				rule-&gt;nr = 0;
		} <span class="enscript-keyword">else</span> {
			rule-&gt;nr = r-&gt;nr;
		}

		<span class="enscript-keyword">if</span> ((error = pf_rule_setup(pr, rule, ruleset)))
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (rule-&gt;anchor != NULL)
			strlcpy(rule-&gt;anchor-&gt;owner, rule-&gt;owner,
			    PF_OWNER_NAME_SIZE);

		<span class="enscript-keyword">if</span> (r) {
			TAILQ_INSERT_BEFORE(r, rule, entries);
			<span class="enscript-keyword">while</span> (r &amp;&amp; ++r-&gt;nr)
				r = TAILQ_NEXT(r, entries);
		} <span class="enscript-keyword">else</span>
			TAILQ_INSERT_TAIL(ruleset-&gt;rules[rs_num].active.ptr,
			    rule, entries);
		ruleset-&gt;rules[rs_num].active.rcount++;

		<span class="enscript-comment">/* Calculate checksum for the main ruleset */</span>
		<span class="enscript-keyword">if</span> (ruleset == &amp;pf_main_ruleset)
			error = pf_setup_pfsync_matching(ruleset);

		pf_ruleset_cleanup(ruleset, rs_num);
		rule-&gt;ticket = VM_KERNEL_ADDRPERM((u_int64_t)(uintptr_t)rule);

		pr-&gt;rule.ticket = rule-&gt;ticket;
		pf_rule_copyout(rule, &amp;pr-&gt;rule);
		<span class="enscript-keyword">if</span> (rule-&gt;rule_flag &amp; PFRULE_PFM)
			pffwrules++;
		<span class="enscript-keyword">if</span> (rule-&gt;action == PF_NAT64)
			atomic_add_16(&amp;pf_nat64_configured, 1);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCDELETERULE</span>: {
		pr-&gt;anchor[<span class="enscript-keyword">sizeof</span> (pr-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
		pr-&gt;anchor_call[<span class="enscript-keyword">sizeof</span> (pr-&gt;anchor_call) - 1] = <span class="enscript-string">'\0'</span>;

		<span class="enscript-keyword">if</span> (pr-&gt;rule.return_icmp &gt;&gt; 8 &gt; ICMP_MAXTYPE) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* get device through which request is made */</span>
		<span class="enscript-keyword">if</span> ((uint8_t)minordev == PFDEV_PFM)
			req_dev |= PFRULE_PFM;

		<span class="enscript-keyword">if</span> (pr-&gt;rule.ticket) {
			<span class="enscript-keyword">if</span> ((error = pf_delete_rule_by_ticket(pr, req_dev)))
				<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span>
			pf_delete_rule_by_owner(pr-&gt;rule.owner, req_dev);
		pr-&gt;nr = pffwrules;
		<span class="enscript-keyword">if</span> (pr-&gt;rule.action == PF_NAT64)
			atomic_add_16(&amp;pf_nat64_configured, -1);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_state_kill</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_state_kill *psk, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span> error = 0;

	psk-&gt;psk_ifname[<span class="enscript-keyword">sizeof</span> (psk-&gt;psk_ifname) - 1] = <span class="enscript-string">'\0'</span>;
	psk-&gt;psk_ownername[<span class="enscript-keyword">sizeof</span>(psk-&gt;psk_ownername) - 1] = <span class="enscript-string">'\0'</span>;

	bool ifname_matched = true;
	bool owner_matched = true;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRSTATES</span>: {
		<span class="enscript-type">struct</span> pf_state		*s, *nexts;
		<span class="enscript-type">int</span>			 killed = 0;

		<span class="enscript-keyword">for</span> (s = RB_MIN(pf_state_tree_id, &amp;tree_id); s; s = nexts) {
			nexts = RB_NEXT(pf_state_tree_id, &amp;tree_id, s);
			<span class="enscript-comment">/*
			 * Purge all states only when neither ifname
			 * or owner is provided. If any of these are provided
			 * we purge only the states with meta data that match
			 */</span>
			bool unlink_state = false;
			ifname_matched = true;
			owner_matched = true;

			<span class="enscript-keyword">if</span> (psk-&gt;psk_ifname[0] &amp;&amp;
			    strcmp(psk-&gt;psk_ifname, s-&gt;kif-&gt;pfik_name)) {
				ifname_matched = false;
			}

			<span class="enscript-keyword">if</span> (psk-&gt;psk_ownername[0] &amp;&amp;
			    ((NULL == s-&gt;rule.ptr) ||
			     strcmp(psk-&gt;psk_ownername, s-&gt;rule.ptr-&gt;owner))) {
				owner_matched = false;
			}

			unlink_state = ifname_matched &amp;&amp; owner_matched;

			<span class="enscript-keyword">if</span> (unlink_state) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
				<span class="enscript-comment">/* don't send out individual delete messages */</span>
				s-&gt;sync_flags = PFSTATE_NOSYNC;
#<span class="enscript-reference">endif</span>
				pf_unlink_state(s);
				killed++;
			}
		}
		psk-&gt;psk_af = killed;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
		pfsync_clear_states(pf_status.hostid, psk-&gt;psk_ifname);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCKILLSTATES</span>: {
		<span class="enscript-type">struct</span> pf_state		*s, *nexts;
		<span class="enscript-type">struct</span> pf_state_key	*sk;
		<span class="enscript-type">struct</span> pf_state_host	*src, *dst;
		<span class="enscript-type">int</span>			 killed = 0;

		<span class="enscript-keyword">for</span> (s = RB_MIN(pf_state_tree_id, &amp;tree_id); s;
		    s = nexts) {
			nexts = RB_NEXT(pf_state_tree_id, &amp;tree_id, s);
			sk = s-&gt;state_key;
			ifname_matched = true;
			owner_matched = true;

			<span class="enscript-keyword">if</span> (psk-&gt;psk_ifname[0] &amp;&amp;
			    strcmp(psk-&gt;psk_ifname, s-&gt;kif-&gt;pfik_name)) {
				ifname_matched = false;
			}

			<span class="enscript-keyword">if</span> (psk-&gt;psk_ownername[0] &amp;&amp;
			    ((NULL == s-&gt;rule.ptr) ||
			     strcmp(psk-&gt;psk_ownername, s-&gt;rule.ptr-&gt;owner))) {
				owner_matched = false;
			}

			<span class="enscript-keyword">if</span> (sk-&gt;direction == PF_OUT) {
				src = &amp;sk-&gt;lan;
				dst = &amp;sk-&gt;ext_lan;
			} <span class="enscript-keyword">else</span> {
				src = &amp;sk-&gt;ext_lan;
				dst = &amp;sk-&gt;lan;
			}
			<span class="enscript-keyword">if</span> ((!psk-&gt;psk_af || sk-&gt;af_lan == psk-&gt;psk_af) &amp;&amp;
			    (!psk-&gt;psk_proto || psk-&gt;psk_proto == sk-&gt;proto) &amp;&amp;
			    PF_MATCHA(psk-&gt;psk_src.neg,
			    &amp;psk-&gt;psk_src.addr.v.a.addr,
			    &amp;psk-&gt;psk_src.addr.v.a.mask,
			    &amp;src-&gt;addr, sk-&gt;af_lan) &amp;&amp;
			    PF_MATCHA(psk-&gt;psk_dst.neg,
			    &amp;psk-&gt;psk_dst.addr.v.a.addr,
			    &amp;psk-&gt;psk_dst.addr.v.a.mask,
			    &amp;dst-&gt;addr, sk-&gt;af_lan) &amp;&amp;
			    (pf_match_xport(psk-&gt;psk_proto,
			    psk-&gt;psk_proto_variant, &amp;psk-&gt;psk_src.xport,
			    &amp;src-&gt;xport)) &amp;&amp;
			    (pf_match_xport(psk-&gt;psk_proto,
			    psk-&gt;psk_proto_variant, &amp;psk-&gt;psk_dst.xport,
			    &amp;dst-&gt;xport)) &amp;&amp;
			    ifname_matched &amp;&amp;
			    owner_matched) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
				<span class="enscript-comment">/* send immediate delete of state */</span>
				pfsync_delete_state(s);
				s-&gt;sync_flags |= PFSTATE_NOSYNC;
#<span class="enscript-reference">endif</span>
				pf_unlink_state(s);
				killed++;
			}
		}
		psk-&gt;psk_af = killed;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_state</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_state *ps, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCADDSTATE</span>: {
		<span class="enscript-type">struct</span> pfsync_state	*sp = &amp;ps-&gt;state;
		<span class="enscript-type">struct</span> pf_state		*s;
		<span class="enscript-type">struct</span> pf_state_key	*sk;
		<span class="enscript-type">struct</span> pfi_kif		*kif;

		<span class="enscript-keyword">if</span> (sp-&gt;timeout &gt;= PFTM_MAX) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		s = pool_get(&amp;pf_state_pl, PR_WAITOK);
		<span class="enscript-keyword">if</span> (s == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">break</span>;
		}
		bzero(s, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_state));
		<span class="enscript-keyword">if</span> ((sk = pf_alloc_state_key(s, NULL)) == NULL) {
			pool_put(&amp;pf_state_pl, s);
			error = ENOMEM;
			<span class="enscript-keyword">break</span>;
		}
		pf_state_import(sp, sk, s);
		kif = pfi_kif_get(sp-&gt;ifname);
		<span class="enscript-keyword">if</span> (kif == NULL) {
			pool_put(&amp;pf_state_pl, s);
			pool_put(&amp;pf_state_key_pl, sk);
			error = ENOENT;
			<span class="enscript-keyword">break</span>;
		}
		TAILQ_INIT(&amp;s-&gt;unlink_hooks);
		s-&gt;state_key-&gt;app_state = 0;
		<span class="enscript-keyword">if</span> (pf_insert_state(kif, s)) {
			pfi_kif_unref(kif, PFI_KIF_REF_NONE);
			pool_put(&amp;pf_state_pl, s);
			error = EEXIST;
			<span class="enscript-keyword">break</span>;
		}
		pf_default_rule.states++;
		VERIFY(pf_default_rule.states != 0);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATE</span>: {
		<span class="enscript-type">struct</span> pf_state		*s;
		<span class="enscript-type">struct</span> pf_state_cmp	 id_key;

		bcopy(ps-&gt;state.id, &amp;id_key.id, <span class="enscript-keyword">sizeof</span> (id_key.id));
		id_key.creatorid = ps-&gt;state.creatorid;

		s = pf_find_state_byid(&amp;id_key);
		<span class="enscript-keyword">if</span> (s == NULL) {
			error = ENOENT;
			<span class="enscript-keyword">break</span>;
		}

		pf_state_export(&amp;ps-&gt;state, s-&gt;state_key, s);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_states</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_states_32 *ps32,
    <span class="enscript-type">struct</span> pfioc_states_64 *ps64, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> p64 = proc_is64bit(p);
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATES</span>: {		<span class="enscript-comment">/* struct pfioc_states */</span>
		<span class="enscript-type">struct</span> pf_state		*state;
		<span class="enscript-type">struct</span> pfsync_state	*pstore;
		user_addr_t		 buf;
		u_int32_t		 nr = 0;
		<span class="enscript-type">int</span>			 len, size;

		len = (p64 ? ps64-&gt;ps_len : ps32-&gt;ps_len);
		<span class="enscript-keyword">if</span> (len == 0) {
			size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfsync_state) * pf_status.states;
			<span class="enscript-keyword">if</span> (p64)
				ps64-&gt;ps_len = size;
			<span class="enscript-keyword">else</span>
				ps32-&gt;ps_len = size;
			<span class="enscript-keyword">break</span>;
		}

		pstore = _MALLOC(<span class="enscript-keyword">sizeof</span> (*pstore), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (pstore == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">break</span>;
		}
		buf = (p64 ? ps64-&gt;ps_buf : ps32-&gt;ps_buf);

		state = TAILQ_FIRST(&amp;state_list);
		<span class="enscript-keyword">while</span> (state) {
			<span class="enscript-keyword">if</span> (state-&gt;timeout != PFTM_UNLINKED) {
				<span class="enscript-keyword">if</span> ((nr + 1) * <span class="enscript-keyword">sizeof</span> (*pstore) &gt; (<span class="enscript-type">unsigned</span>)len)
					<span class="enscript-keyword">break</span>;

				pf_state_export(pstore,
				    state-&gt;state_key, state);
				error = copyout(pstore, buf, <span class="enscript-keyword">sizeof</span> (*pstore));
				<span class="enscript-keyword">if</span> (error) {
					_FREE(pstore, M_TEMP);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				}
				buf += <span class="enscript-keyword">sizeof</span> (*pstore);
				nr++;
			}
			state = TAILQ_NEXT(state, entry_list);
		}

		size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfsync_state) * nr;
		<span class="enscript-keyword">if</span> (p64)
			ps64-&gt;ps_len = size;
		<span class="enscript-keyword">else</span>
			ps32-&gt;ps_len = size;

		_FREE(pstore, M_TEMP);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_natlook</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_natlook *pnl, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCNATLOOK</span>: {
		<span class="enscript-type">struct</span> pf_state_key	*sk;
		<span class="enscript-type">struct</span> pf_state		*state;
		<span class="enscript-type">struct</span> pf_state_key_cmp	 key;
		<span class="enscript-type">int</span>			 m = 0, direction = pnl-&gt;direction;

		key.proto = pnl-&gt;proto;
		key.proto_variant = pnl-&gt;proto_variant;

		<span class="enscript-keyword">if</span> (!pnl-&gt;proto ||
		    PF_AZERO(&amp;pnl-&gt;saddr, pnl-&gt;af) ||
		    PF_AZERO(&amp;pnl-&gt;daddr, pnl-&gt;af) ||
		    ((pnl-&gt;proto == IPPROTO_TCP ||
		    pnl-&gt;proto == IPPROTO_UDP) &amp;&amp;
		    (!pnl-&gt;dxport.port || !pnl-&gt;sxport.port)))
			error = EINVAL;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * userland gives us source and dest of connection,
			 * reverse the lookup so we ask for what happens with
			 * the return traffic, enabling us to find it in the
			 * state tree.
			 */</span>
			<span class="enscript-keyword">if</span> (direction == PF_IN) {
				key.af_gwy = pnl-&gt;af;
				PF_ACPY(&amp;key.ext_gwy.addr, &amp;pnl-&gt;daddr,
					pnl-&gt;af);
				memcpy(&amp;key.ext_gwy.xport, &amp;pnl-&gt;dxport,
				    <span class="enscript-keyword">sizeof</span> (key.ext_gwy.xport));
				PF_ACPY(&amp;key.gwy.addr, &amp;pnl-&gt;saddr, pnl-&gt;af);
				memcpy(&amp;key.gwy.xport, &amp;pnl-&gt;sxport,
				    <span class="enscript-keyword">sizeof</span> (key.gwy.xport));
				state = pf_find_state_all(&amp;key, PF_IN, &amp;m);
			} <span class="enscript-keyword">else</span> {
				key.af_lan = pnl-&gt;af;
				PF_ACPY(&amp;key.lan.addr, &amp;pnl-&gt;daddr, pnl-&gt;af);
				memcpy(&amp;key.lan.xport, &amp;pnl-&gt;dxport,
				    <span class="enscript-keyword">sizeof</span> (key.lan.xport));
				PF_ACPY(&amp;key.ext_lan.addr, &amp;pnl-&gt;saddr,
					pnl-&gt;af);
				memcpy(&amp;key.ext_lan.xport, &amp;pnl-&gt;sxport,
				    <span class="enscript-keyword">sizeof</span> (key.ext_lan.xport));
				state = pf_find_state_all(&amp;key, PF_OUT, &amp;m);
			}
			<span class="enscript-keyword">if</span> (m &gt; 1)
				error = E2BIG;	<span class="enscript-comment">/* more than one state */</span>
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (state != NULL) {
				sk = state-&gt;state_key;
				<span class="enscript-keyword">if</span> (direction == PF_IN) {
					PF_ACPY(&amp;pnl-&gt;rsaddr, &amp;sk-&gt;lan.addr,
					    sk-&gt;af_lan);
					memcpy(&amp;pnl-&gt;rsxport, &amp;sk-&gt;lan.xport,
					    <span class="enscript-keyword">sizeof</span> (pnl-&gt;rsxport));
					PF_ACPY(&amp;pnl-&gt;rdaddr, &amp;pnl-&gt;daddr,
					    pnl-&gt;af);
					memcpy(&amp;pnl-&gt;rdxport, &amp;pnl-&gt;dxport,
					    <span class="enscript-keyword">sizeof</span> (pnl-&gt;rdxport));
				} <span class="enscript-keyword">else</span> {
					PF_ACPY(&amp;pnl-&gt;rdaddr, &amp;sk-&gt;gwy.addr,
					    sk-&gt;af_gwy);
					memcpy(&amp;pnl-&gt;rdxport, &amp;sk-&gt;gwy.xport,
					    <span class="enscript-keyword">sizeof</span> (pnl-&gt;rdxport));
					PF_ACPY(&amp;pnl-&gt;rsaddr, &amp;pnl-&gt;saddr,
					    pnl-&gt;af);
					memcpy(&amp;pnl-&gt;rsxport, &amp;pnl-&gt;sxport,
					    <span class="enscript-keyword">sizeof</span> (pnl-&gt;rsxport));
				}
			} <span class="enscript-keyword">else</span>
				error = ENOENT;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_tm</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_tm *pt, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETTIMEOUT</span>: {
		<span class="enscript-type">int</span> old;

		<span class="enscript-keyword">if</span> (pt-&gt;timeout &lt; 0 || pt-&gt;timeout &gt;= PFTM_MAX ||
		    pt-&gt;seconds &lt; 0) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		old = pf_default_rule.timeout[pt-&gt;timeout];
		<span class="enscript-keyword">if</span> (pt-&gt;timeout == PFTM_INTERVAL &amp;&amp; pt-&gt;seconds == 0)
			pt-&gt;seconds = 1;
		pf_default_rule.timeout[pt-&gt;timeout] = pt-&gt;seconds;
		<span class="enscript-keyword">if</span> (pt-&gt;timeout == PFTM_INTERVAL &amp;&amp; pt-&gt;seconds &lt; old)
			wakeup(pf_purge_thread_fn);
		pt-&gt;seconds = old;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETTIMEOUT</span>: {
		<span class="enscript-keyword">if</span> (pt-&gt;timeout &lt; 0 || pt-&gt;timeout &gt;= PFTM_MAX) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		pt-&gt;seconds = pf_default_rule.timeout[pt-&gt;timeout];
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_limit</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_limit *pl, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETLIMIT</span>: {

		<span class="enscript-keyword">if</span> (pl-&gt;index &lt; 0 || pl-&gt;index &gt;= PF_LIMIT_MAX) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		pl-&gt;limit = pf_pool_limits[pl-&gt;index].limit;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETLIMIT</span>: {
		<span class="enscript-type">int</span> old_limit;

		<span class="enscript-keyword">if</span> (pl-&gt;index &lt; 0 || pl-&gt;index &gt;= PF_LIMIT_MAX ||
		    pf_pool_limits[pl-&gt;index].pp == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		pool_sethardlimit(pf_pool_limits[pl-&gt;index].pp,
		    pl-&gt;limit, NULL, 0);
		old_limit = pf_pool_limits[pl-&gt;index].limit;
		pf_pool_limits[pl-&gt;index].limit = pl-&gt;limit;
		pl-&gt;limit = old_limit;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_pooladdr</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_pooladdr *pp, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">struct</span> pf_pooladdr *pa = NULL;
	<span class="enscript-type">struct</span> pf_pool *pool = NULL;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCBEGINADDRS</span>: {
		pf_empty_pool(&amp;pf_pabuf);
		pp-&gt;ticket = ++ticket_pabuf;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCADDADDR</span>: {
		pp-&gt;anchor[<span class="enscript-keyword">sizeof</span> (pp-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
		<span class="enscript-keyword">if</span> (pp-&gt;ticket != ticket_pabuf) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">if</span> (pp-&gt;af == AF_INET) {
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (pp-&gt;af == AF_INET6) {
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">if</span> (pp-&gt;addr.addr.type != PF_ADDR_ADDRMASK &amp;&amp;
		    pp-&gt;addr.addr.type != PF_ADDR_DYNIFTL &amp;&amp;
		    pp-&gt;addr.addr.type != PF_ADDR_TABLE) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		pa = pool_get(&amp;pf_pooladdr_pl, PR_WAITOK);
		<span class="enscript-keyword">if</span> (pa == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">break</span>;
		}
		pf_pooladdr_copyin(&amp;pp-&gt;addr, pa);
		<span class="enscript-keyword">if</span> (pa-&gt;ifname[0]) {
			pa-&gt;kif = pfi_kif_get(pa-&gt;ifname);
			<span class="enscript-keyword">if</span> (pa-&gt;kif == NULL) {
				pool_put(&amp;pf_pooladdr_pl, pa);
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			pfi_kif_ref(pa-&gt;kif, PFI_KIF_REF_RULE);
		}
		pf_addrwrap_setup(&amp;pa-&gt;addr);
		<span class="enscript-keyword">if</span> (pfi_dynaddr_setup(&amp;pa-&gt;addr, pp-&gt;af)) {
			pfi_dynaddr_remove(&amp;pa-&gt;addr);
			pfi_kif_unref(pa-&gt;kif, PFI_KIF_REF_RULE);
			pool_put(&amp;pf_pooladdr_pl, pa);
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		TAILQ_INSERT_TAIL(&amp;pf_pabuf, pa, entries);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETADDRS</span>: {
		pp-&gt;nr = 0;
		pp-&gt;anchor[<span class="enscript-keyword">sizeof</span> (pp-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
		pool = pf_get_pool(pp-&gt;anchor, pp-&gt;ticket, pp-&gt;r_action,
		    pp-&gt;r_num, 0, 1, 0);
		<span class="enscript-keyword">if</span> (pool == NULL) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		TAILQ_FOREACH(pa, &amp;pool-&gt;list, entries)
			pp-&gt;nr++;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETADDR</span>: {
		u_int32_t		 nr = 0;

		pp-&gt;anchor[<span class="enscript-keyword">sizeof</span> (pp-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
		pool = pf_get_pool(pp-&gt;anchor, pp-&gt;ticket, pp-&gt;r_action,
		    pp-&gt;r_num, 0, 1, 1);
		<span class="enscript-keyword">if</span> (pool == NULL) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		pa = TAILQ_FIRST(&amp;pool-&gt;list);
		<span class="enscript-keyword">while</span> ((pa != NULL) &amp;&amp; (nr &lt; pp-&gt;nr)) {
			pa = TAILQ_NEXT(pa, entries);
			nr++;
		}
		<span class="enscript-keyword">if</span> (pa == NULL) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		pf_pooladdr_copyout(pa, &amp;pp-&gt;addr);
		pfi_dynaddr_copyout(&amp;pp-&gt;addr.addr);
		pf_tbladdr_copyout(&amp;pp-&gt;addr.addr);
		pf_rtlabel_copyout(&amp;pp-&gt;addr.addr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCHANGEADDR</span>: {
		<span class="enscript-type">struct</span> pfioc_pooladdr	*pca = pp;
		<span class="enscript-type">struct</span> pf_pooladdr	*oldpa = NULL, *newpa = NULL;
		<span class="enscript-type">struct</span> pf_ruleset	*ruleset;

		<span class="enscript-keyword">if</span> (pca-&gt;action &lt; PF_CHANGE_ADD_HEAD ||
		    pca-&gt;action &gt; PF_CHANGE_REMOVE) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (pca-&gt;addr.addr.type != PF_ADDR_ADDRMASK &amp;&amp;
		    pca-&gt;addr.addr.type != PF_ADDR_DYNIFTL &amp;&amp;
		    pca-&gt;addr.addr.type != PF_ADDR_TABLE) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}

		pca-&gt;anchor[<span class="enscript-keyword">sizeof</span> (pca-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
		ruleset = pf_find_ruleset(pca-&gt;anchor);
		<span class="enscript-keyword">if</span> (ruleset == NULL) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		pool = pf_get_pool(pca-&gt;anchor, pca-&gt;ticket, pca-&gt;r_action,
		    pca-&gt;r_num, pca-&gt;r_last, 1, 1);
		<span class="enscript-keyword">if</span> (pool == NULL) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (pca-&gt;action != PF_CHANGE_REMOVE) {
			newpa = pool_get(&amp;pf_pooladdr_pl, PR_WAITOK);
			<span class="enscript-keyword">if</span> (newpa == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">break</span>;
			}
			pf_pooladdr_copyin(&amp;pca-&gt;addr, newpa);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">INET</span>
			<span class="enscript-keyword">if</span> (pca-&gt;af == AF_INET) {
				pool_put(&amp;pf_pooladdr_pl, newpa);
				error = EAFNOSUPPORT;
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (pca-&gt;af == AF_INET6) {
				pool_put(&amp;pf_pooladdr_pl, newpa);
				error = EAFNOSUPPORT;
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			<span class="enscript-keyword">if</span> (newpa-&gt;ifname[0]) {
				newpa-&gt;kif = pfi_kif_get(newpa-&gt;ifname);
				<span class="enscript-keyword">if</span> (newpa-&gt;kif == NULL) {
					pool_put(&amp;pf_pooladdr_pl, newpa);
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				}
				pfi_kif_ref(newpa-&gt;kif, PFI_KIF_REF_RULE);
			} <span class="enscript-keyword">else</span>
				newpa-&gt;kif = NULL;
			pf_addrwrap_setup(&amp;newpa-&gt;addr);
			<span class="enscript-keyword">if</span> (pfi_dynaddr_setup(&amp;newpa-&gt;addr, pca-&gt;af) ||
			    pf_tbladdr_setup(ruleset, &amp;newpa-&gt;addr)) {
				pfi_dynaddr_remove(&amp;newpa-&gt;addr);
				pfi_kif_unref(newpa-&gt;kif, PFI_KIF_REF_RULE);
				pool_put(&amp;pf_pooladdr_pl, newpa);
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (pca-&gt;action == PF_CHANGE_ADD_HEAD)
			oldpa = TAILQ_FIRST(&amp;pool-&gt;list);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pca-&gt;action == PF_CHANGE_ADD_TAIL)
			oldpa = TAILQ_LAST(&amp;pool-&gt;list, pf_palist);
		<span class="enscript-keyword">else</span> {
			<span class="enscript-type">int</span>	i = 0;

			oldpa = TAILQ_FIRST(&amp;pool-&gt;list);
			<span class="enscript-keyword">while</span> ((oldpa != NULL) &amp;&amp; (i &lt; (<span class="enscript-type">int</span>)pca-&gt;nr)) {
				oldpa = TAILQ_NEXT(oldpa, entries);
				i++;
			}
			<span class="enscript-keyword">if</span> (oldpa == NULL) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (pca-&gt;action == PF_CHANGE_REMOVE) {
			TAILQ_REMOVE(&amp;pool-&gt;list, oldpa, entries);
			pfi_dynaddr_remove(&amp;oldpa-&gt;addr);
			pf_tbladdr_remove(&amp;oldpa-&gt;addr);
			pfi_kif_unref(oldpa-&gt;kif, PFI_KIF_REF_RULE);
			pool_put(&amp;pf_pooladdr_pl, oldpa);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (oldpa == NULL)
				TAILQ_INSERT_TAIL(&amp;pool-&gt;list, newpa, entries);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pca-&gt;action == PF_CHANGE_ADD_HEAD ||
			    pca-&gt;action == PF_CHANGE_ADD_BEFORE)
				TAILQ_INSERT_BEFORE(oldpa, newpa, entries);
			<span class="enscript-keyword">else</span>
				TAILQ_INSERT_AFTER(&amp;pool-&gt;list, oldpa,
				    newpa, entries);
		}

		pool-&gt;cur = TAILQ_FIRST(&amp;pool-&gt;list);
		PF_ACPY(&amp;pool-&gt;counter, &amp;pool-&gt;cur-&gt;addr.v.a.addr,
		    pca-&gt;af);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_ruleset</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_ruleset *pr, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULESETS</span>: {
		<span class="enscript-type">struct</span> pf_ruleset	*ruleset;
		<span class="enscript-type">struct</span> pf_anchor	*anchor;

		pr-&gt;path[<span class="enscript-keyword">sizeof</span> (pr-&gt;path) - 1] = <span class="enscript-string">'\0'</span>;
		pr-&gt;name[<span class="enscript-keyword">sizeof</span> (pr-&gt;name) - 1] = <span class="enscript-string">'\0'</span>;
		<span class="enscript-keyword">if</span> ((ruleset = pf_find_ruleset(pr-&gt;path)) == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		pr-&gt;nr = 0;
		<span class="enscript-keyword">if</span> (ruleset-&gt;anchor == NULL) {
			<span class="enscript-comment">/* XXX kludge for pf_main_ruleset */</span>
			RB_FOREACH(anchor, pf_anchor_global, &amp;pf_anchors)
				<span class="enscript-keyword">if</span> (anchor-&gt;parent == NULL)
					pr-&gt;nr++;
		} <span class="enscript-keyword">else</span> {
			RB_FOREACH(anchor, pf_anchor_node,
			    &amp;ruleset-&gt;anchor-&gt;children)
				pr-&gt;nr++;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULESET</span>: {
		<span class="enscript-type">struct</span> pf_ruleset	*ruleset;
		<span class="enscript-type">struct</span> pf_anchor	*anchor;
		u_int32_t		 nr = 0;

		pr-&gt;path[<span class="enscript-keyword">sizeof</span> (pr-&gt;path) - 1] = <span class="enscript-string">'\0'</span>;
		<span class="enscript-keyword">if</span> ((ruleset = pf_find_ruleset(pr-&gt;path)) == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		pr-&gt;name[0] = 0;
		<span class="enscript-keyword">if</span> (ruleset-&gt;anchor == NULL) {
			<span class="enscript-comment">/* XXX kludge for pf_main_ruleset */</span>
			RB_FOREACH(anchor, pf_anchor_global, &amp;pf_anchors)
				<span class="enscript-keyword">if</span> (anchor-&gt;parent == NULL &amp;&amp; nr++ == pr-&gt;nr) {
					strlcpy(pr-&gt;name, anchor-&gt;name,
					    <span class="enscript-keyword">sizeof</span> (pr-&gt;name));
					<span class="enscript-keyword">break</span>;
				}
		} <span class="enscript-keyword">else</span> {
			RB_FOREACH(anchor, pf_anchor_node,
			    &amp;ruleset-&gt;anchor-&gt;children)
				<span class="enscript-keyword">if</span> (nr++ == pr-&gt;nr) {
					strlcpy(pr-&gt;name, anchor-&gt;name,
					    <span class="enscript-keyword">sizeof</span> (pr-&gt;name));
					<span class="enscript-keyword">break</span>;
				}
		}
		<span class="enscript-keyword">if</span> (!pr-&gt;name[0])
			error = EBUSY;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_trans</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_trans_32 *io32,
    <span class="enscript-type">struct</span> pfioc_trans_64 *io64, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> p64 = proc_is64bit(p);
	<span class="enscript-type">int</span> error = 0, esize, size;
	user_addr_t buf;

	esize = (p64 ? io64-&gt;esize : io32-&gt;esize);
	size = (p64 ? io64-&gt;size : io32-&gt;size);
	buf = (p64 ? io64-&gt;array : io32-&gt;array);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCXBEGIN</span>: {
		<span class="enscript-type">struct</span> pfioc_trans_e	*ioe;
		<span class="enscript-type">struct</span> pfr_table	*table;
		<span class="enscript-type">int</span>			 i;

		<span class="enscript-keyword">if</span> (esize != <span class="enscript-keyword">sizeof</span> (*ioe)) {
			error = ENODEV;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		ioe = _MALLOC(<span class="enscript-keyword">sizeof</span> (*ioe), M_TEMP, M_WAITOK);
		table = _MALLOC(<span class="enscript-keyword">sizeof</span> (*table), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">for</span> (i = 0; i &lt; size; i++, buf += <span class="enscript-keyword">sizeof</span> (*ioe)) {
			<span class="enscript-keyword">if</span> (copyin(buf, ioe, <span class="enscript-keyword">sizeof</span> (*ioe))) {
				_FREE(table, M_TEMP);
				_FREE(ioe, M_TEMP);
				error = EFAULT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			ioe-&gt;anchor[<span class="enscript-keyword">sizeof</span> (ioe-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
			<span class="enscript-keyword">switch</span> (ioe-&gt;rs_num) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_RULESET_ALTQ</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
				<span class="enscript-keyword">if</span> (altq_allowed) {
					<span class="enscript-keyword">if</span> (ioe-&gt;anchor[0]) {
						_FREE(table, M_TEMP);
						_FREE(ioe, M_TEMP);
						error = EINVAL;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
					}
					error = pf_begin_altq(&amp;ioe-&gt;ticket);
					<span class="enscript-keyword">if</span> (error != 0) {
						_FREE(table, M_TEMP);
						_FREE(ioe, M_TEMP);
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
					}
				}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_RULESET_TABLE</span>:
				bzero(table, <span class="enscript-keyword">sizeof</span> (*table));
				strlcpy(table-&gt;pfrt_anchor, ioe-&gt;anchor,
				    <span class="enscript-keyword">sizeof</span> (table-&gt;pfrt_anchor));
				<span class="enscript-keyword">if</span> ((error = pfr_ina_begin(table,
				    &amp;ioe-&gt;ticket, NULL, 0))) {
					_FREE(table, M_TEMP);
					_FREE(ioe, M_TEMP);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">if</span> ((error = pf_begin_rules(&amp;ioe-&gt;ticket,
				    ioe-&gt;rs_num, ioe-&gt;anchor))) {
					_FREE(table, M_TEMP);
					_FREE(ioe, M_TEMP);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (copyout(ioe, buf, <span class="enscript-keyword">sizeof</span> (*ioe))) {
				_FREE(table, M_TEMP);
				_FREE(ioe, M_TEMP);
				error = EFAULT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
		}
		_FREE(table, M_TEMP);
		_FREE(ioe, M_TEMP);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCXROLLBACK</span>: {
		<span class="enscript-type">struct</span> pfioc_trans_e	*ioe;
		<span class="enscript-type">struct</span> pfr_table	*table;
		<span class="enscript-type">int</span>			 i;

		<span class="enscript-keyword">if</span> (esize != <span class="enscript-keyword">sizeof</span> (*ioe)) {
			error = ENODEV;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		ioe = _MALLOC(<span class="enscript-keyword">sizeof</span> (*ioe), M_TEMP, M_WAITOK);
		table = _MALLOC(<span class="enscript-keyword">sizeof</span> (*table), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">for</span> (i = 0; i &lt; size; i++, buf += <span class="enscript-keyword">sizeof</span> (*ioe)) {
			<span class="enscript-keyword">if</span> (copyin(buf, ioe, <span class="enscript-keyword">sizeof</span> (*ioe))) {
				_FREE(table, M_TEMP);
				_FREE(ioe, M_TEMP);
				error = EFAULT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			ioe-&gt;anchor[<span class="enscript-keyword">sizeof</span> (ioe-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
			<span class="enscript-keyword">switch</span> (ioe-&gt;rs_num) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_RULESET_ALTQ</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
				<span class="enscript-keyword">if</span> (altq_allowed) {
					<span class="enscript-keyword">if</span> (ioe-&gt;anchor[0]) {
						_FREE(table, M_TEMP);
						_FREE(ioe, M_TEMP);
						error = EINVAL;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
					}
					error = pf_rollback_altq(ioe-&gt;ticket);
					<span class="enscript-keyword">if</span> (error != 0) {
						_FREE(table, M_TEMP);
						_FREE(ioe, M_TEMP);
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; <span class="enscript-comment">/* really bad */</span>
					}
				}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_RULESET_TABLE</span>:
				bzero(table, <span class="enscript-keyword">sizeof</span> (*table));
				strlcpy(table-&gt;pfrt_anchor, ioe-&gt;anchor,
				    <span class="enscript-keyword">sizeof</span> (table-&gt;pfrt_anchor));
				<span class="enscript-keyword">if</span> ((error = pfr_ina_rollback(table,
				    ioe-&gt;ticket, NULL, 0))) {
					_FREE(table, M_TEMP);
					_FREE(ioe, M_TEMP);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; <span class="enscript-comment">/* really bad */</span>
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">if</span> ((error = pf_rollback_rules(ioe-&gt;ticket,
				    ioe-&gt;rs_num, ioe-&gt;anchor))) {
					_FREE(table, M_TEMP);
					_FREE(ioe, M_TEMP);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; <span class="enscript-comment">/* really bad */</span>
				}
				<span class="enscript-keyword">break</span>;
			}
		}
		_FREE(table, M_TEMP);
		_FREE(ioe, M_TEMP);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCXCOMMIT</span>: {
		<span class="enscript-type">struct</span> pfioc_trans_e	*ioe;
		<span class="enscript-type">struct</span> pfr_table	*table;
		<span class="enscript-type">struct</span> pf_ruleset	*rs;
		user_addr_t		 _buf = buf;
		<span class="enscript-type">int</span>			 i;

		<span class="enscript-keyword">if</span> (esize != <span class="enscript-keyword">sizeof</span> (*ioe)) {
			error = ENODEV;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		ioe = _MALLOC(<span class="enscript-keyword">sizeof</span> (*ioe), M_TEMP, M_WAITOK);
		table = _MALLOC(<span class="enscript-keyword">sizeof</span> (*table), M_TEMP, M_WAITOK);
		<span class="enscript-comment">/* first makes sure everything will succeed */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; size; i++, buf += <span class="enscript-keyword">sizeof</span> (*ioe)) {
			<span class="enscript-keyword">if</span> (copyin(buf, ioe, <span class="enscript-keyword">sizeof</span> (*ioe))) {
				_FREE(table, M_TEMP);
				_FREE(ioe, M_TEMP);
				error = EFAULT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			ioe-&gt;anchor[<span class="enscript-keyword">sizeof</span> (ioe-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
			<span class="enscript-keyword">switch</span> (ioe-&gt;rs_num) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_RULESET_ALTQ</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
				<span class="enscript-keyword">if</span> (altq_allowed) {
					<span class="enscript-keyword">if</span> (ioe-&gt;anchor[0]) {
						_FREE(table, M_TEMP);
						_FREE(ioe, M_TEMP);
						error = EINVAL;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
					}
					<span class="enscript-keyword">if</span> (!altqs_inactive_open ||
					    ioe-&gt;ticket !=
					    ticket_altqs_inactive) {
						_FREE(table, M_TEMP);
						_FREE(ioe, M_TEMP);
						error = EBUSY;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
					}
				}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_RULESET_TABLE</span>:
				rs = pf_find_ruleset(ioe-&gt;anchor);
				<span class="enscript-keyword">if</span> (rs == NULL || !rs-&gt;topen || ioe-&gt;ticket !=
				    rs-&gt;tticket) {
					_FREE(table, M_TEMP);
					_FREE(ioe, M_TEMP);
					error = EBUSY;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">if</span> (ioe-&gt;rs_num &lt; 0 || ioe-&gt;rs_num &gt;=
				    PF_RULESET_MAX) {
					_FREE(table, M_TEMP);
					_FREE(ioe, M_TEMP);
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				}
				rs = pf_find_ruleset(ioe-&gt;anchor);
				<span class="enscript-keyword">if</span> (rs == NULL ||
				    !rs-&gt;rules[ioe-&gt;rs_num].inactive.open ||
				    rs-&gt;rules[ioe-&gt;rs_num].inactive.ticket !=
				    ioe-&gt;ticket) {
					_FREE(table, M_TEMP);
					_FREE(ioe, M_TEMP);
					error = EBUSY;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				}
				<span class="enscript-keyword">break</span>;
			}
		}
		buf = _buf;
		<span class="enscript-comment">/* now do the commit - no errors should happen here */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; size; i++, buf += <span class="enscript-keyword">sizeof</span> (*ioe)) {
			<span class="enscript-keyword">if</span> (copyin(buf, ioe, <span class="enscript-keyword">sizeof</span> (*ioe))) {
				_FREE(table, M_TEMP);
				_FREE(ioe, M_TEMP);
				error = EFAULT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			ioe-&gt;anchor[<span class="enscript-keyword">sizeof</span> (ioe-&gt;anchor) - 1] = <span class="enscript-string">'\0'</span>;
			<span class="enscript-keyword">switch</span> (ioe-&gt;rs_num) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_RULESET_ALTQ</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
				<span class="enscript-keyword">if</span> (altq_allowed &amp;&amp;
				    (error = pf_commit_altq(ioe-&gt;ticket))) {
					_FREE(table, M_TEMP);
					_FREE(ioe, M_TEMP);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; <span class="enscript-comment">/* really bad */</span>
				}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_RULESET_TABLE</span>:
				bzero(table, <span class="enscript-keyword">sizeof</span> (*table));
				strlcpy(table-&gt;pfrt_anchor, ioe-&gt;anchor,
				    <span class="enscript-keyword">sizeof</span> (table-&gt;pfrt_anchor));
				<span class="enscript-keyword">if</span> ((error = pfr_ina_commit(table, ioe-&gt;ticket,
				    NULL, NULL, 0))) {
					_FREE(table, M_TEMP);
					_FREE(ioe, M_TEMP);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; <span class="enscript-comment">/* really bad */</span>
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">if</span> ((error = pf_commit_rules(ioe-&gt;ticket,
				    ioe-&gt;rs_num, ioe-&gt;anchor))) {
					_FREE(table, M_TEMP);
					_FREE(ioe, M_TEMP);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>; <span class="enscript-comment">/* really bad */</span>
				}
				<span class="enscript-keyword">break</span>;
			}
		}
		_FREE(table, M_TEMP);
		_FREE(ioe, M_TEMP);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_src_nodes</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_src_nodes_32 *psn32,
    <span class="enscript-type">struct</span> pfioc_src_nodes_64 *psn64, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> p64 = proc_is64bit(p);
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSRCNODES</span>: {
		<span class="enscript-type">struct</span> pf_src_node	*n, *pstore;
		user_addr_t		 buf;
		u_int32_t		 nr = 0;
		<span class="enscript-type">int</span>			 space, size;

		space = (p64 ? psn64-&gt;psn_len : psn32-&gt;psn_len);
		<span class="enscript-keyword">if</span> (space == 0) {
			RB_FOREACH(n, pf_src_tree, &amp;tree_src_tracking)
				nr++;

			size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_src_node) * nr;
			<span class="enscript-keyword">if</span> (p64)
				psn64-&gt;psn_len = size;
			<span class="enscript-keyword">else</span>
				psn32-&gt;psn_len = size;
			<span class="enscript-keyword">break</span>;
		}

		pstore = _MALLOC(<span class="enscript-keyword">sizeof</span> (*pstore), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (pstore == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">break</span>;
		}
		buf = (p64 ? psn64-&gt;psn_buf : psn32-&gt;psn_buf);

		RB_FOREACH(n, pf_src_tree, &amp;tree_src_tracking) {
			uint64_t secs = pf_time_second(), diff;

			<span class="enscript-keyword">if</span> ((nr + 1) * <span class="enscript-keyword">sizeof</span> (*pstore) &gt; (<span class="enscript-type">unsigned</span>)space)
				<span class="enscript-keyword">break</span>;

			bcopy(n, pstore, <span class="enscript-keyword">sizeof</span> (*pstore));
			<span class="enscript-keyword">if</span> (n-&gt;rule.ptr != NULL)
				pstore-&gt;rule.nr = n-&gt;rule.ptr-&gt;nr;
			pstore-&gt;creation = secs - pstore-&gt;creation;
			<span class="enscript-keyword">if</span> (pstore-&gt;expire &gt; secs)
				pstore-&gt;expire -= secs;
			<span class="enscript-keyword">else</span>
				pstore-&gt;expire = 0;

			<span class="enscript-comment">/* adjust the connection rate estimate */</span>
			diff = secs - n-&gt;conn_rate.last;
			<span class="enscript-keyword">if</span> (diff &gt;= n-&gt;conn_rate.seconds)
				pstore-&gt;conn_rate.count = 0;
			<span class="enscript-keyword">else</span>
				pstore-&gt;conn_rate.count -=
				    n-&gt;conn_rate.count * diff /
				    n-&gt;conn_rate.seconds;

			_RB_PARENT(pstore, entry) = NULL;
			RB_LEFT(pstore, entry) = RB_RIGHT(pstore, entry) = NULL;
			pstore-&gt;kif = NULL;

			error = copyout(pstore, buf, <span class="enscript-keyword">sizeof</span> (*pstore));
			<span class="enscript-keyword">if</span> (error) {
				_FREE(pstore, M_TEMP);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			buf += <span class="enscript-keyword">sizeof</span> (*pstore);
			nr++;
		}

		size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_src_node) * nr;
		<span class="enscript-keyword">if</span> (p64)
			psn64-&gt;psn_len = size;
		<span class="enscript-keyword">else</span>
			psn32-&gt;psn_len = size;

		_FREE(pstore, M_TEMP);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">return</span> (error);

}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_src_node_kill</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_src_node_kill *psnk,
    <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCKILLSRCNODES</span>: {
		<span class="enscript-type">struct</span> pf_src_node	*sn;
		<span class="enscript-type">struct</span> pf_state		*s;
		<span class="enscript-type">int</span>			killed = 0;

		RB_FOREACH(sn, pf_src_tree, &amp;tree_src_tracking) {
			<span class="enscript-keyword">if</span> (PF_MATCHA(psnk-&gt;psnk_src.neg,
			    &amp;psnk-&gt;psnk_src.addr.v.a.addr,
			    &amp;psnk-&gt;psnk_src.addr.v.a.mask,
			    &amp;sn-&gt;addr, sn-&gt;af) &amp;&amp;
			    PF_MATCHA(psnk-&gt;psnk_dst.neg,
			    &amp;psnk-&gt;psnk_dst.addr.v.a.addr,
			    &amp;psnk-&gt;psnk_dst.addr.v.a.mask,
			    &amp;sn-&gt;raddr, sn-&gt;af)) {
				<span class="enscript-comment">/* Handle state to src_node linkage */</span>
				<span class="enscript-keyword">if</span> (sn-&gt;states != 0) {
					RB_FOREACH(s, pf_state_tree_id,
					    &amp;tree_id) {
						<span class="enscript-keyword">if</span> (s-&gt;src_node == sn)
							s-&gt;src_node = NULL;
						<span class="enscript-keyword">if</span> (s-&gt;nat_src_node == sn)
							s-&gt;nat_src_node = NULL;
					}
					sn-&gt;states = 0;
				}
				sn-&gt;expire = 1;
				killed++;
			}
		}

		<span class="enscript-keyword">if</span> (killed &gt; 0)
			pf_purge_expired_src_nodes();

		psnk-&gt;psnk_af = killed;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pfioctl_ioc_iface</span>(u_long cmd, <span class="enscript-type">struct</span> pfioc_iface_32 *io32,
    <span class="enscript-type">struct</span> pfioc_iface_64 *io64, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> p64 = proc_is64bit(p);
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCIGETIFACES</span>: {
		user_addr_t buf;
		<span class="enscript-type">int</span> esize;

		buf = (p64 ? io64-&gt;pfiio_buffer : io32-&gt;pfiio_buffer);
		esize = (p64 ? io64-&gt;pfiio_esize : io32-&gt;pfiio_esize);

		<span class="enscript-comment">/* esize must be that of the user space version of pfi_kif */</span>
		<span class="enscript-keyword">if</span> (esize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pfi_uif)) {
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (p64)
			io64-&gt;pfiio_name[<span class="enscript-keyword">sizeof</span> (io64-&gt;pfiio_name) - 1] = <span class="enscript-string">'\0'</span>;
		<span class="enscript-keyword">else</span>
			io32-&gt;pfiio_name[<span class="enscript-keyword">sizeof</span> (io32-&gt;pfiio_name) - 1] = <span class="enscript-string">'\0'</span>;
		error = pfi_get_ifaces(
		    p64 ? io64-&gt;pfiio_name : io32-&gt;pfiio_name, buf,
		    p64 ? &amp;io64-&gt;pfiio_size : &amp;io32-&gt;pfiio_size);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETIFFLAG</span>: {
		<span class="enscript-keyword">if</span> (p64)
			io64-&gt;pfiio_name[<span class="enscript-keyword">sizeof</span> (io64-&gt;pfiio_name) - 1] = <span class="enscript-string">'\0'</span>;
		<span class="enscript-keyword">else</span>
			io32-&gt;pfiio_name[<span class="enscript-keyword">sizeof</span> (io32-&gt;pfiio_name) - 1] = <span class="enscript-string">'\0'</span>;

		error = pfi_set_flags(
		    p64 ? io64-&gt;pfiio_name : io32-&gt;pfiio_name,
		    p64 ? io64-&gt;pfiio_flags : io32-&gt;pfiio_flags);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRIFFLAG</span>: {
		<span class="enscript-keyword">if</span> (p64)
			io64-&gt;pfiio_name[<span class="enscript-keyword">sizeof</span> (io64-&gt;pfiio_name) - 1] = <span class="enscript-string">'\0'</span>;
		<span class="enscript-keyword">else</span>
			io32-&gt;pfiio_name[<span class="enscript-keyword">sizeof</span> (io32-&gt;pfiio_name) - 1] = <span class="enscript-string">'\0'</span>;

		error = pfi_clear_flags(
		    p64 ? io64-&gt;pfiio_name : io32-&gt;pfiio_name,
		    p64 ? io64-&gt;pfiio_flags : io32-&gt;pfiio_flags);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_af_hook</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf **mppn, <span class="enscript-type">struct</span> mbuf **mp,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> af, <span class="enscript-type">int</span> input, <span class="enscript-type">struct</span> ip_fw_args *fwa)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> mbuf *nextpkt;
	net_thread_marks_t marks;
	<span class="enscript-type">struct</span> ifnet * pf_ifp = ifp;

	marks = net_thread_marks_push(NET_THREAD_HELD_PF);

	<span class="enscript-keyword">if</span> (marks != net_thread_marks_none) {
		lck_rw_lock_shared(pf_perim_lock);
		<span class="enscript-keyword">if</span> (!pf_is_enabled)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		lck_mtx_lock(pf_lock);
	}

	<span class="enscript-keyword">if</span> (mppn != NULL &amp;&amp; *mppn != NULL)
		VERIFY(*mppn == *mp);
	<span class="enscript-keyword">if</span> ((nextpkt = (*mp)-&gt;m_nextpkt) != NULL)
		(*mp)-&gt;m_nextpkt = NULL;

        <span class="enscript-comment">/*
         * For packets destined to locally hosted IP address
         * ip_output_list sets Mbuf's pkt header's rcvif to
         * the interface hosting the IP address.
         * While on the output path ifp passed to pf_af_hook
         * to such local communication is the loopback interface,
         * the input path derives ifp from mbuf packet header's
         * rcvif.
         * This asymmetry caues issues with PF.
         * To handle that case, we have a limited change here to
         * pass interface as loopback if packets are looped in.
         */</span>
	<span class="enscript-keyword">if</span> (input &amp;&amp; ((*mp)-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) {
		pf_ifp = lo_ifp;
	}

	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
		error = pf_inet_hook(pf_ifp, mp, input, fwa);
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		error = pf_inet6_hook(pf_ifp, mp, input, fwa);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* When packet valid, link to the next packet */</span>
	<span class="enscript-keyword">if</span> (*mp != NULL &amp;&amp; nextpkt != NULL) {
		<span class="enscript-type">struct</span> mbuf *m = *mp;
		<span class="enscript-keyword">while</span> (m-&gt;m_nextpkt != NULL)
			m = m-&gt;m_nextpkt;
		m-&gt;m_nextpkt = nextpkt;
	}
	<span class="enscript-comment">/* Fix up linkage of previous packet in the chain */</span>
	<span class="enscript-keyword">if</span> (mppn != NULL) {
		<span class="enscript-keyword">if</span> (*mp != NULL)
			*mppn = *mp;
		<span class="enscript-keyword">else</span>
			*mppn = nextpkt;
	}

	<span class="enscript-keyword">if</span> (marks != net_thread_marks_none)
		lck_mtx_unlock(pf_lock);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (marks != net_thread_marks_none)
		lck_rw_done(pf_perim_lock);

	net_thread_marks_pop(marks);
	<span class="enscript-keyword">return</span> (error);
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_inet_hook</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">int</span> input,
    <span class="enscript-type">struct</span> ip_fw_args *fwa)
{
	<span class="enscript-type">struct</span> mbuf *m = *mp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/*
	 * If the packet is outbound, is originated locally, is flagged for
	 * delayed UDP/TCP checksum calculation, and is about to be processed
	 * for an interface that doesn't support the appropriate checksum
	 * offloading, then calculated the checksum here so that PF can adjust
	 * it properly.
	 */</span>
	<span class="enscript-keyword">if</span> (!input &amp;&amp; m-&gt;m_pkthdr.rcvif == NULL) {
		<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> mask = CSUM_DELAY_DATA;
		<span class="enscript-type">const</span> <span class="enscript-type">int</span> flags = m-&gt;m_pkthdr.csum_flags &amp;
		    ~IF_HWASSIST_CSUM_FLAGS(ifp-&gt;if_hwassist);

		<span class="enscript-keyword">if</span> (flags &amp; mask) {
			in_delayed_cksum(m);
			m-&gt;m_pkthdr.csum_flags &amp;= ~mask;
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	HTONS(ip-&gt;ip_len);
	HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (pf_test(input ? PF_IN : PF_OUT, ifp, mp, NULL, fwa) != PF_PASS) {
		<span class="enscript-keyword">if</span> (*mp != NULL) {
			m_freem(*mp);
			*mp = NULL;
			error = EHOSTUNREACH;
		} <span class="enscript-keyword">else</span> {
			error = ENOBUFS;
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (*mp != NULL) {
			ip = mtod(*mp, <span class="enscript-type">struct</span> ip *);
			NTOHS(ip-&gt;ip_len);
			NTOHS(ip-&gt;ip_off);
		}
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_inet6_hook</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">int</span> input,
    <span class="enscript-type">struct</span> ip_fw_args *fwa)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/*
	 * If the packet is outbound, is originated locally, is flagged for
	 * delayed UDP/TCP checksum calculation, and is about to be processed
	 * for an interface that doesn't support the appropriate checksum
	 * offloading, then calculated the checksum here so that PF can adjust
	 * it properly.
	 */</span>
	<span class="enscript-keyword">if</span> (!input &amp;&amp; (*mp)-&gt;m_pkthdr.rcvif == NULL) {
		<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> mask = CSUM_DELAY_IPV6_DATA;
		<span class="enscript-type">const</span> <span class="enscript-type">int</span> flags = (*mp)-&gt;m_pkthdr.csum_flags &amp;
		    ~IF_HWASSIST_CSUM_FLAGS(ifp-&gt;if_hwassist);

		<span class="enscript-keyword">if</span> (flags &amp; mask) {
			<span class="enscript-comment">/*
			 * Checksum offload should not have been enabled
			 * when extension headers exist, thus 0 for optlen.
			 */</span>
			in6_delayed_cksum(*mp);
			(*mp)-&gt;m_pkthdr.csum_flags &amp;= ~mask;
		}
	}

	<span class="enscript-keyword">if</span> (pf_test6(input ? PF_IN : PF_OUT, ifp, mp, NULL, fwa) != PF_PASS) {
		<span class="enscript-keyword">if</span> (*mp != NULL) {
			m_freem(*mp);
			*mp = NULL;
			error = EHOSTUNREACH;
		} <span class="enscript-keyword">else</span> {
			error = ENOBUFS;
		}
	}
	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_ifaddr_hook</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> pfi_kif *kif = ifp-&gt;if_pf_kif;

	<span class="enscript-keyword">if</span> (kif != NULL) {
		lck_rw_lock_shared(pf_perim_lock);
		lck_mtx_lock(pf_lock);

		pfi_kifaddr_update(kif);

		lck_mtx_unlock(pf_lock);
		lck_rw_done(pf_perim_lock);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Caller acquires dlil lock as writer (exclusive)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_ifnet_hook</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> attach)
{
	lck_rw_lock_shared(pf_perim_lock);
	lck_mtx_lock(pf_lock);
	<span class="enscript-keyword">if</span> (attach)
		pfi_attach_ifnet(ifp);
	<span class="enscript-keyword">else</span>
		pfi_detach_ifnet(ifp);
	lck_mtx_unlock(pf_lock);
	lck_rw_done(pf_perim_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_attach_hooks</span>(<span class="enscript-type">void</span>)
{
	ifnet_head_lock_shared();
	<span class="enscript-comment">/*
	 * Check against ifnet_addrs[] before proceeding, in case this
	 * is called very early on, e.g. during dlil_init() before any
	 * network interface is attached.
	 */</span>
	<span class="enscript-keyword">if</span> (ifnet_addrs != NULL) {
		<span class="enscript-type">int</span> i;

		<span class="enscript-keyword">for</span> (i = 0; i &lt;= if_index; i++) {
			<span class="enscript-type">struct</span> ifnet *ifp = ifindex2ifnet[i];
			<span class="enscript-keyword">if</span> (ifp != NULL) {
				pfi_attach_ifnet(ifp);
			}
		}
	}
	ifnet_head_done();
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/* currently unused along with pfdetach() */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_detach_hooks</span>(<span class="enscript-type">void</span>)
{
	ifnet_head_lock_shared();
	<span class="enscript-keyword">if</span> (ifnet_addrs != NULL) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt;= if_index; i++) {
			<span class="enscript-type">int</span> i;

			<span class="enscript-type">struct</span> ifnet *ifp = ifindex2ifnet[i];
			<span class="enscript-keyword">if</span> (ifp != NULL &amp;&amp; ifp-&gt;if_pf_kif != NULL) {
				pfi_detach_ifnet(ifp);
			}
		}
	}
	ifnet_head_done();
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * 'D' group ioctls.
 *
 * The switch statement below does nothing at runtime, as it serves as a
 * compile time check to ensure that all of the socket 'D' ioctls (those
 * in the 'D' group going thru soo_ioctl) that are made available by the
 * networking stack is unique.  This works as long as this routine gets
 * updated each time a new interface ioctl gets added.
 *
 * Any failures at compile time indicates duplicated ioctl values.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((unused)) <span class="enscript-type">void</span>
<span class="enscript-function-name">pfioctl_cassert</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * This is equivalent to _CASSERT() and the compiler wouldn't
	 * generate any instructions, thus for compile time only.
	 */</span>
	<span class="enscript-keyword">switch</span> ((u_long)0) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:

	<span class="enscript-comment">/* bsd/net/pfvar.h */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTART</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTOP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCADDRULE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTARTERS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTARTREF</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTOPREF</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRSTATES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETSTATUSIF</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATUS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRSTATUS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCNATLOOK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETDEBUG</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSTATES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCHANGERULE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCINSERTRULE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCDELETERULE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETTIMEOUT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETTIMEOUT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCADDSTATE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRRULECTRS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETLIMIT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETLIMIT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCKILLSTATES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTARTALTQ</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSTOPALTQ</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCADDALTQ</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETALTQS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETALTQ</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCHANGEALTQ</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETQSTATS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCBEGINADDRS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCADDADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETADDRS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCHANGEADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULESETS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETRULESET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRTABLES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRADDTABLES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRDELTABLES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETTABLES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETTSTATS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRTSTATS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRADDRS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRADDADDRS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRDELADDRS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRSETADDRS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETADDRS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRGETASTATS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRCLRASTATS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRTSTADDRS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRSETTFLAGS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCRINADEFINE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCOSFPFLUSH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCOSFPADD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCOSFPGET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCXBEGIN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCXCOMMIT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCXROLLBACK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGETSRCNODES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRSRCNODES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETHOSTID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCIGETIFACES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCSETIFFLAG</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCCLRIFFLAG</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCKILLSRCNODES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIOCGIFSPEED</span>:
		;
	}
}
</pre>
<hr />
</body></html>