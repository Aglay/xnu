<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>necp.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">necp.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2013-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSMalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_control.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_uuid_policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/flowhash.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/network_agent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/necp.h&gt;</span>

<span class="enscript-comment">/*
 * NECP - Network Extension Control Policy database
 * ------------------------------------------------
 * The goal of this module is to allow clients connecting via a
 * kernel control socket to create high-level policy sessions, which
 * are ingested into low-level kernel policies that control and tag
 * traffic at the application, socket, and IP layers.
 *
 * ------------------------------------------------
 * Sessions
 * ------------------------------------------------
 * Each session owns a list of session policies, each of which can
 * specify any combination of conditions and a single result. Each
 * session also has a priority level (such as High, Default, or Low)
 * which is requested by the client. Based on the requested level,
 * a session order value is assigned to the session, which will be used
 * to sort kernel policies generated by the session. The session client
 * can specify the sub-order for each policy it creates which will be
 * used to further sort the kernel policies.
 *
 *  Kernel Control Socket --&gt; 1 necp_session --&gt; list of necp_session_policy structs
 *
 * ------------------------------------------------
 * Kernel Policies
 * ------------------------------------------------
 * Whenever a session send the Apply command, its policies are ingested
 * and generate kernel policies. There are two phases of kernel policy
 * ingestion.
 *
 * 1. The session policy is parsed to create kernel policies at the socket
 *	  and IP layers, when applicable. For example, a policy that requires
 *    all traffic from App1 to Pass will generate a socket kernel policy to
 *    match App1 and mark packets with ID1, and also an IP policy to match
 *    ID1 and let the packet pass. This is handled in necp_apply_policy. The
 *    resulting kernel policies are added to the global socket and IP layer
 *    policy lists.
 *  necp_session_policy --&gt; necp_kernel_socket_policy and necp_kernel_ip_output_policy
 *                                      ||                             ||
 *                                      \/                             \/
 *                          necp_kernel_socket_policies   necp_kernel_ip_output_policies
 *
 * 2. Once the global lists of kernel policies have been filled out, each
 *    list is traversed to create optimized sub-lists (&quot;Maps&quot;) which are used during
 *    data-path evaluation. IP policies are sent into necp_kernel_ip_output_policies_map,
 *    which hashes incoming packets based on marked socket-layer policies, and removes
 *    duplicate or overlapping polcies. Socket policies are sent into two maps,
 *    necp_kernel_socket_policies_map and necp_kernel_socket_policies_app_layer_map.
 *    The app layer map is used for policy checks coming in from user space, and is one
 *    list with duplicate and overlapping policies removed. The socket map hashes based
 *    on app UUID, and removes duplicate and overlapping policies.
 *  necp_kernel_socket_policy --&gt; necp_kernel_socket_policies_app_layer_map
 *                            |-&gt; necp_kernel_socket_policies_map
 *
 *  necp_kernel_ip_output_policies --&gt; necp_kernel_ip_output_policies_map
 *
 * ------------------------------------------------
 * Drop All Level
 * ------------------------------------------------
 * The Drop All Level is a sysctl that controls the level at which policies are allowed
 * to override a global drop rule. If the value is 0, no drop rule is applied. If the value
 * is 1, all traffic is dropped. If the value is greater than 1, all kernel policies created
 * by a session with a priority level better than (numerically less than) the
 * Drop All Level will allow matching traffic to not be dropped. The Drop All Level is
 * dynamically interpreted into necp_drop_all_order, which specifies the equivalent assigned
 * session orders to be dropped.
 */</span>

u_int32_t necp_drop_all_order = 0;
u_int32_t necp_drop_all_level = 0;

u_int32_t necp_pass_loopback = 1; <span class="enscript-comment">// 0=Off, 1=On
</span>u_int32_t necp_pass_keepalives = 1; <span class="enscript-comment">// 0=Off, 1=On
</span>
u_int32_t necp_debug = 0; <span class="enscript-comment">// 0=None, 1=Basic, 2=EveryMatch
</span>
u_int32_t necp_session_count = 0;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NECPLOG</span>(level, format, ...) do {											\
	log((level &gt; LOG_NOTICE ? LOG_NOTICE : level), <span class="enscript-string">&quot;%s: &quot;</span> format <span class="enscript-string">&quot;\n&quot;</span>, __FUNCTION__, __VA_ARGS__); 	\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NECPLOG0</span>(level, msg) do {											\
	log((level &gt; LOG_NOTICE ? LOG_NOTICE : level), <span class="enscript-string">&quot;%s: %s\n&quot;</span>, __FUNCTION__, msg); 	\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_INSERT_SORTED_ASCENDING</span>(head, elm, field, sortfield, tmpelm) do {		\
	<span class="enscript-keyword">if</span> (LIST_EMPTY((head)) || (LIST_FIRST(head)-&gt;sortfield &gt;= (elm)-&gt;sortfield)) {	\
		LIST_INSERT_HEAD((head), elm, field);										\
	} <span class="enscript-keyword">else</span> {																		\
		LIST_FOREACH(tmpelm, head, field) {											\
			<span class="enscript-keyword">if</span> (LIST_NEXT(tmpelm, field) == NULL || LIST_NEXT(tmpelm, field)-&gt;sortfield &gt;= (elm)-&gt;sortfield) {	\
				LIST_INSERT_AFTER(tmpelm, elm, field);								\
				<span class="enscript-keyword">break</span>;																\
			}																		\
		}																			\
	}																				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_INSERT_SORTED_TWICE_ASCENDING</span>(head, elm, field, firstsortfield, secondsortfield, tmpelm) do {	\
	<span class="enscript-keyword">if</span> (LIST_EMPTY((head)) || (LIST_FIRST(head)-&gt;firstsortfield &gt; (elm)-&gt;firstsortfield) || ((LIST_FIRST(head)-&gt;firstsortfield == (elm)-&gt;firstsortfield) &amp;&amp; (LIST_FIRST(head)-&gt;secondsortfield &gt;= (elm)-&gt;secondsortfield))) {														\
		LIST_INSERT_HEAD((head), elm, field);										\
	} <span class="enscript-keyword">else</span> {																		\
		LIST_FOREACH(tmpelm, head, field) {											\
			<span class="enscript-keyword">if</span> (LIST_NEXT(tmpelm, field) == NULL || (LIST_NEXT(tmpelm, field)-&gt;firstsortfield &gt; (elm)-&gt;firstsortfield) || ((LIST_NEXT(tmpelm, field)-&gt;firstsortfield == (elm)-&gt;firstsortfield) &amp;&amp; (LIST_NEXT(tmpelm, field)-&gt;secondsortfield &gt;= (elm)-&gt;secondsortfield))) {		\
				LIST_INSERT_AFTER(tmpelm, elm, field);								\
				<span class="enscript-keyword">break</span>;																\
			}																		\
		}																			\
	}																				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_INSERT_SORTED_THRICE_ASCENDING</span>(head, elm, field, firstsortfield, secondsortfield, thirdsortfield, tmpelm) do { \
	<span class="enscript-keyword">if</span> (LIST_EMPTY((head)) || (LIST_FIRST(head)-&gt;firstsortfield &gt; (elm)-&gt;firstsortfield) || ((LIST_FIRST(head)-&gt;firstsortfield == (elm)-&gt;firstsortfield) &amp;&amp; (LIST_FIRST(head)-&gt;secondsortfield &gt;= (elm)-&gt;secondsortfield)) || ((LIST_FIRST(head)-&gt;firstsortfield == (elm)-&gt;firstsortfield) &amp;&amp; (LIST_FIRST(head)-&gt;secondsortfield == (elm)-&gt;secondsortfield) &amp;&amp; (LIST_FIRST(head)-&gt;thirdsortfield &gt;= (elm)-&gt;thirdsortfield))) {															\
		LIST_INSERT_HEAD((head), elm, field);										\
	} <span class="enscript-keyword">else</span> {																		\
		LIST_FOREACH(tmpelm, head, field) {											\
			<span class="enscript-keyword">if</span> (LIST_NEXT(tmpelm, field) == NULL || (LIST_NEXT(tmpelm, field)-&gt;firstsortfield &gt; (elm)-&gt;firstsortfield) || ((LIST_NEXT(tmpelm, field)-&gt;firstsortfield == (elm)-&gt;firstsortfield) &amp;&amp; (LIST_NEXT(tmpelm, field)-&gt;secondsortfield &gt;= (elm)-&gt;secondsortfield)) || ((LIST_NEXT(tmpelm, field)-&gt;firstsortfield == (elm)-&gt;firstsortfield) &amp;&amp; (LIST_NEXT(tmpelm, field)-&gt;secondsortfield == (elm)-&gt;secondsortfield) &amp;&amp; (LIST_NEXT(tmpelm, field)-&gt;thirdsortfield &gt;= (elm)-&gt;thirdsortfield)))	{ \
				LIST_INSERT_AFTER(tmpelm, elm, field);								\
				<span class="enscript-keyword">break</span>;																\
			}																		\
		}																			\
	}																				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_ALL_INTERFACES</span>	0x00001
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_BOUND_INTERFACE</span>	0x00002
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_PROTOCOL</span>			0x00004
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_LOCAL_START</span>		0x00008
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_LOCAL_END</span>			0x00010
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_LOCAL_PREFIX</span>		0x00020
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_REMOTE_START</span>		0x00040
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_REMOTE_END</span>		0x00080
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_REMOTE_PREFIX</span>		0x00100
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_APP_ID</span>			0x00200
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_REAL_APP_ID</span>		0x00400
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_DOMAIN</span>			0x00800
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_ACCOUNT_ID</span>		0x01000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_POLICY_ID</span>			0x02000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_PID</span>				0x04000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_UID</span>				0x08000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_CONDITION_LAST_INTERFACE</span>	0x10000			// Only set from packets looping between interfaces
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NECP_KERNEL_CONDITION_TRAFFIC_CLASS</span>		0x20000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NECP_KERNEL_CONDITION_ENTITLEMENT</span>		0x40000

<span class="enscript-type">struct</span> necp_service_registration {
	LIST_ENTRY(necp_service_registration)	session_chain;
	LIST_ENTRY(necp_service_registration)	kernel_chain;
	u_int32_t								service_id;
};

<span class="enscript-type">struct</span> necp_session {
	u_int32_t					control_unit;
	u_int32_t					session_priority; <span class="enscript-comment">// Descriptive priority rating
</span>	u_int32_t					session_order;

	bool						proc_locked; <span class="enscript-comment">// Messages must come from proc_uuid
</span>	uuid_t						proc_uuid;
	<span class="enscript-type">int</span>							proc_pid;

	bool						dirty;
	LIST_HEAD(_policies, necp_session_policy) policies;

	LIST_HEAD(_services, necp_service_registration) services;
};

<span class="enscript-type">struct</span> necp_socket_info {
	pid_t pid;
	uid_t uid;
	<span class="enscript-type">union</span> necp_sockaddr_union local_addr;
	<span class="enscript-type">union</span> necp_sockaddr_union remote_addr;
	u_int32_t bound_interface_index;
	u_int32_t traffic_class;
	u_int16_t protocol;
	u_int32_t application_id;
	u_int32_t real_application_id;
	u_int32_t account_id;
	<span class="enscript-type">char</span> *domain;
	errno_t cred_result;
};

<span class="enscript-type">static</span> kern_ctl_ref	necp_kctlref;
<span class="enscript-type">static</span> u_int32_t	necp_family;
<span class="enscript-type">static</span> OSMallocTag	necp_malloc_tag;
<span class="enscript-type">static</span>	lck_grp_attr_t	*necp_kernel_policy_grp_attr	= NULL;
<span class="enscript-type">static</span>	lck_attr_t		*necp_kernel_policy_mtx_attr	= NULL;
<span class="enscript-type">static</span>	lck_grp_t		*necp_kernel_policy_mtx_grp		= NULL;
<span class="enscript-function-name">decl_lck_rw_data</span>(<span class="enscript-type">static</span>, necp_kernel_policy_lock);

<span class="enscript-type">static</span>	lck_grp_attr_t	*necp_route_rule_grp_attr	= NULL;
<span class="enscript-type">static</span>	lck_attr_t		*necp_route_rule_mtx_attr	= NULL;
<span class="enscript-type">static</span>	lck_grp_t		*necp_route_rule_mtx_grp	= NULL;
<span class="enscript-function-name">decl_lck_rw_data</span>(<span class="enscript-type">static</span>, necp_route_rule_lock);

<span class="enscript-type">static</span> necp_policy_id necp_last_policy_id = 0;
<span class="enscript-type">static</span> necp_kernel_policy_id necp_last_kernel_policy_id = 0;
<span class="enscript-type">static</span> u_int32_t necp_last_uuid_id = 0;
<span class="enscript-type">static</span> u_int32_t necp_last_string_id = 0;
<span class="enscript-type">static</span> u_int32_t necp_last_route_rule_id = 0;
<span class="enscript-type">static</span> u_int32_t necp_last_aggregate_route_rule_id = 0;

<span class="enscript-comment">/*
 * On modification, invalidate cached lookups by bumping the generation count.
 * Other calls will need to take the slowpath of taking
 * the subsystem lock.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">volatile</span> int32_t necp_kernel_socket_policies_gencount;
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BUMP_KERNEL_SOCKET_POLICIES_GENERATION_COUNT</span>() do {							\
	<span class="enscript-keyword">if</span> (OSIncrementAtomic(&amp;necp_kernel_socket_policies_gencount) == (INT32_MAX - 1)) {	\
		necp_kernel_socket_policies_gencount = 1;										\
	}																				\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">static</span> u_int32_t necp_kernel_application_policies_condition_mask;
<span class="enscript-type">static</span> size_t necp_kernel_application_policies_count;
<span class="enscript-type">static</span> u_int32_t necp_kernel_socket_policies_condition_mask;
<span class="enscript-type">static</span> size_t necp_kernel_socket_policies_count;
<span class="enscript-type">static</span> size_t necp_kernel_socket_policies_non_app_count;
<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(_necpkernelsocketconnectpolicies, necp_kernel_socket_policy) necp_kernel_socket_policies;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_SOCKET_POLICIES_MAP_NUM_APP_ID_BUCKETS</span> 5
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NECP_SOCKET_MAP_APP_ID_TO_BUCKET</span>(appid) (appid ? (appid%(NECP_KERNEL_SOCKET_POLICIES_MAP_NUM_APP_ID_BUCKETS - 1) + 1) : 0)
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_kernel_socket_policy **necp_kernel_socket_policies_map[NECP_KERNEL_SOCKET_POLICIES_MAP_NUM_APP_ID_BUCKETS];
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_kernel_socket_policy **necp_kernel_socket_policies_app_layer_map;
<span class="enscript-comment">/*
 * A note on policy 'maps': these are used for boosting efficiency when matching policies. For each dimension of the map,
 * such as an ID, the 0 bucket is reserved for sockets/packets that do not have this parameter, while the other
 * buckets lead to an array of policy pointers that form the list applicable when the (parameter%(NUM_BUCKETS - 1) + 1) == bucket_index.
 *
 * For example, a packet with policy ID of 7, when there are 4 ID buckets, will map to bucket (7%3 + 1) = 2.
 */</span>

<span class="enscript-type">static</span> u_int32_t necp_kernel_ip_output_policies_condition_mask;
<span class="enscript-type">static</span> size_t necp_kernel_ip_output_policies_count;
<span class="enscript-type">static</span> size_t necp_kernel_ip_output_policies_non_id_count;
<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(_necpkernelipoutputpolicies, necp_kernel_ip_output_policy) necp_kernel_ip_output_policies;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_IP_OUTPUT_POLICIES_MAP_NUM_ID_BUCKETS</span> 5
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NECP_IP_OUTPUT_MAP_ID_TO_BUCKET</span>(id) (id ? (id%(NECP_KERNEL_IP_OUTPUT_POLICIES_MAP_NUM_ID_BUCKETS - 1) + 1) : 0)
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_kernel_ip_output_policy **necp_kernel_ip_output_policies_map[NECP_KERNEL_IP_OUTPUT_POLICIES_MAP_NUM_ID_BUCKETS];

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_session *<span class="enscript-function-name">necp_create_session</span>(u_int32_t control_unit);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_delete_session</span>(<span class="enscript-type">struct</span> necp_session *session);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_handle_policy_add</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_handle_policy_get</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_handle_policy_delete</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_handle_policy_apply_all</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_handle_policy_list_all</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_handle_policy_delete_all</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_handle_set_session_priority</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_handle_lock_session_to_proc</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_handle_register_service</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_handle_unregister_service</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_session_policy *<span class="enscript-function-name">necp_policy_create</span>(<span class="enscript-type">struct</span> necp_session *session, necp_policy_order order, u_int8_t *conditions_array, u_int32_t conditions_array_size, u_int8_t *route_rules_array, u_int32_t route_rules_array_size, u_int8_t *result, u_int32_t result_size);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_session_policy *<span class="enscript-function-name">necp_policy_find</span>(<span class="enscript-type">struct</span> necp_session *session, necp_policy_id policy_id);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_policy_mark_for_deletion</span>(<span class="enscript-type">struct</span> necp_session *session, <span class="enscript-type">struct</span> necp_session_policy *policy);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_policy_mark_all_for_deletion</span>(<span class="enscript-type">struct</span> necp_session *session);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_policy_delete</span>(<span class="enscript-type">struct</span> necp_session *session, <span class="enscript-type">struct</span> necp_session_policy *policy);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_policy_apply_all</span>(<span class="enscript-type">struct</span> necp_session *session);

<span class="enscript-type">static</span> necp_kernel_policy_id <span class="enscript-function-name">necp_kernel_socket_policy_add</span>(necp_policy_id parent_policy_id, necp_policy_order order, u_int32_t session_order, <span class="enscript-type">int</span> session_pid, u_int32_t condition_mask, u_int32_t condition_negated_mask, necp_app_id cond_app_id, necp_app_id cond_real_app_id, u_int32_t cond_account_id, <span class="enscript-type">char</span> *domain, pid_t cond_pid, uid_t cond_uid, ifnet_t cond_bound_interface, <span class="enscript-type">struct</span> necp_policy_condition_tc_range cond_traffic_class, u_int16_t cond_protocol, <span class="enscript-type">union</span> necp_sockaddr_union *cond_local_start, <span class="enscript-type">union</span> necp_sockaddr_union *cond_local_end, u_int8_t cond_local_prefix, <span class="enscript-type">union</span> necp_sockaddr_union *cond_remote_start, <span class="enscript-type">union</span> necp_sockaddr_union *cond_remote_end, u_int8_t cond_remote_prefix, necp_kernel_policy_result result, necp_kernel_policy_result_parameter result_parameter);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_kernel_socket_policy_delete</span>(necp_kernel_policy_id policy_id);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_kernel_socket_policies_reprocess</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_kernel_socket_policies_update_uuid_table</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> inline <span class="enscript-type">struct</span> necp_kernel_socket_policy *<span class="enscript-function-name">necp_socket_find_policy_match_with_info_locked</span>(<span class="enscript-type">struct</span> necp_kernel_socket_policy **policy_search_array, <span class="enscript-type">struct</span> necp_socket_info *info, necp_kernel_policy_filter *return_filter, u_int32_t *return_route_rule_id, necp_kernel_policy_result *return_service_action, necp_kernel_policy_service *return_service, u_int32_t *return_netagent_array, size_t netagent_array_count);

<span class="enscript-type">static</span> necp_kernel_policy_id <span class="enscript-function-name">necp_kernel_ip_output_policy_add</span>(necp_policy_id parent_policy_id, necp_policy_order order, necp_policy_order suborder, u_int32_t session_order, <span class="enscript-type">int</span> session_pid, u_int32_t condition_mask, u_int32_t condition_negated_mask, necp_kernel_policy_id cond_policy_id, ifnet_t cond_bound_interface, u_int32_t cond_last_interface_index, u_int16_t cond_protocol, <span class="enscript-type">union</span> necp_sockaddr_union *cond_local_start, <span class="enscript-type">union</span> necp_sockaddr_union *cond_local_end, u_int8_t cond_local_prefix, <span class="enscript-type">union</span> necp_sockaddr_union *cond_remote_start, <span class="enscript-type">union</span> necp_sockaddr_union *cond_remote_end, u_int8_t cond_remote_prefix, necp_kernel_policy_result result, necp_kernel_policy_result_parameter result_parameter);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_kernel_ip_output_policy_delete</span>(necp_kernel_policy_id policy_id);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_kernel_ip_output_policies_reprocess</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_is_addr_in_range</span>(<span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">struct</span> sockaddr *range_start, <span class="enscript-type">struct</span> sockaddr *range_end);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_is_range_in_range</span>(<span class="enscript-type">struct</span> sockaddr *inner_range_start, <span class="enscript-type">struct</span> sockaddr *inner_range_end, <span class="enscript-type">struct</span> sockaddr *range_start, <span class="enscript-type">struct</span> sockaddr *range_end);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_is_addr_in_subnet</span>(<span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">struct</span> sockaddr *subnet_addr, u_int8_t subnet_prefix);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">necp_addr_compare</span>(<span class="enscript-type">struct</span> sockaddr *sa1, <span class="enscript-type">struct</span> sockaddr *sa2, <span class="enscript-type">int</span> check_port);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_buffer_compare_with_bit_prefix</span>(u_int8_t *p1, u_int8_t *p2, u_int32_t bits);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_is_loopback</span>(<span class="enscript-type">struct</span> sockaddr *local_addr, <span class="enscript-type">struct</span> sockaddr *remote_addr, <span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> mbuf *packet);

<span class="enscript-type">struct</span> necp_uuid_id_mapping {
	LIST_ENTRY(necp_uuid_id_mapping) chain;
	uuid_t		uuid;
	u_int32_t	id;
	u_int32_t	refcount;
	u_int32_t	table_refcount; <span class="enscript-comment">// Add to UUID policy table count
</span>};
<span class="enscript-type">static</span> size_t necp_num_uuid_app_id_mappings;
<span class="enscript-type">static</span> bool necp_uuid_app_id_mappings_dirty;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_UUID_APP_ID_HASH_SIZE</span> 64
<span class="enscript-type">static</span> u_long necp_uuid_app_id_hash_mask;
<span class="enscript-type">static</span> u_long necp_uuid_app_id_hash_num_buckets;
<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(necp_uuid_id_mapping_head, necp_uuid_id_mapping) *necp_uuid_app_id_hashtbl, necp_uuid_service_id_list; <span class="enscript-comment">// App map is real hash table, service map is just mapping
</span>#<span class="enscript-reference">define</span>	<span class="enscript-function-name">APPUUIDHASH</span>(uuid) (&amp;necp_uuid_app_id_hashtbl[uuid[0] &amp; necp_uuid_app_id_hash_mask]) // Assume first byte of UUIDs are evenly distributed
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">necp_create_uuid_app_id_mapping</span>(uuid_t uuid, bool *allocated_mapping, bool uuid_policy_table);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_remove_uuid_app_id_mapping</span>(uuid_t uuid, bool *removed_mapping, bool uuid_policy_table);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_uuid_id_mapping *<span class="enscript-function-name">necp_uuid_lookup_service_id_locked</span>(uuid_t uuid);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_uuid_id_mapping *<span class="enscript-function-name">necp_uuid_lookup_uuid_with_service_id_locked</span>(u_int32_t local_id);
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">necp_create_uuid_service_id_mapping</span>(uuid_t uuid);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_remove_uuid_service_id_mapping</span>(uuid_t uuid);

<span class="enscript-type">struct</span> necp_string_id_mapping {
	LIST_ENTRY(necp_string_id_mapping) chain;
	<span class="enscript-type">char</span>		*string;
	necp_app_id	id;
	u_int32_t	refcount;
};
<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(necp_string_id_mapping_list, necp_string_id_mapping) necp_account_id_list;
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">necp_create_string_to_id_mapping</span>(<span class="enscript-type">struct</span> necp_string_id_mapping_list *list, <span class="enscript-type">char</span> *domain);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_remove_string_to_id_mapping</span>(<span class="enscript-type">struct</span> necp_string_id_mapping_list *list, <span class="enscript-type">char</span> *domain);

<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(_necp_kernel_service_list, necp_service_registration) necp_registered_service_list;

<span class="enscript-type">static</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">necp_create_trimmed_domain</span>(<span class="enscript-type">char</span> *string, size_t length);
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">necp_count_dots</span>(<span class="enscript-type">char</span> *string, size_t length);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ROUTE_RULE_IS_AGGREGATE</span>(ruleid) (ruleid &gt; UINT16_MAX)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_ROUTE_RULE_INTERFACES</span> 10
<span class="enscript-type">struct</span> necp_route_rule {
	LIST_ENTRY(necp_route_rule) chain;
	u_int32_t	id;
	u_int32_t	default_action;
	u_int8_t	cellular_action;
	u_int8_t	wifi_action;
	u_int8_t	wired_action;
	u_int8_t	expensive_action;
	u_int		exception_if_indices[MAX_ROUTE_RULE_INTERFACES];
	u_int8_t	exception_if_actions[MAX_ROUTE_RULE_INTERFACES];
	u_int32_t	refcount;
};
<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(necp_route_rule_list, necp_route_rule) necp_route_rules;
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">necp_create_route_rule</span>(<span class="enscript-type">struct</span> necp_route_rule_list *list, u_int8_t *route_rules_array, u_int32_t route_rules_array_size);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_remove_route_rule</span>(<span class="enscript-type">struct</span> necp_route_rule_list *list, u_int32_t route_rule_id);
<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_route_is_allowed</span>(<span class="enscript-type">struct</span> rtentry *route, ifnet_t interface, u_int32_t route_rule_id, bool *cellular_denied);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_route_rule *<span class="enscript-function-name">necp_lookup_route_rule_locked</span>(<span class="enscript-type">struct</span> necp_route_rule_list *list, u_int32_t route_rule_id);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_AGGREGATE_ROUTE_RULES</span> 16
<span class="enscript-type">struct</span> necp_aggregate_route_rule {
	LIST_ENTRY(necp_aggregate_route_rule) chain;
	u_int32_t	id;
	u_int32_t	rule_ids[MAX_AGGREGATE_ROUTE_RULES];
};
<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(necp_aggregate_route_rule_list, necp_aggregate_route_rule) necp_aggregate_route_rules;
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">necp_create_aggregate_route_rule</span>(u_int32_t *rule_ids);

<span class="enscript-comment">// Sysctl definitions
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_handle_necp_level SYSCTL_HANDLER_ARGS;

<span class="enscript-function-name">SYSCTL_NODE</span>(_net, OID_AUTO, necp, CTLFLAG_RW | CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;NECP&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_necp, NECPCTL_PASS_LOOPBACK, pass_loopback, CTLFLAG_LOCKED | CTLFLAG_RW, &amp;necp_pass_loopback, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_necp, NECPCTL_PASS_KEEPALIVES, pass_keepalives, CTLFLAG_LOCKED | CTLFLAG_RW, &amp;necp_pass_keepalives, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_necp, NECPCTL_DEBUG, debug, CTLFLAG_LOCKED | CTLFLAG_RW, &amp;necp_debug, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_necp, NECPCTL_DROP_ALL_LEVEL, drop_all_level, CTLTYPE_INT | CTLFLAG_LOCKED | CTLFLAG_RW, &amp;necp_drop_all_level, 0, &amp;sysctl_handle_necp_level, <span class="enscript-string">&quot;IU&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_LONG</span>(_net_necp, NECPCTL_SOCKET_POLICY_COUNT, socket_policy_count, CTLFLAG_LOCKED | CTLFLAG_RD, &amp;necp_kernel_socket_policies_count, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_LONG</span>(_net_necp, NECPCTL_SOCKET_NON_APP_POLICY_COUNT, socket_non_app_policy_count, CTLFLAG_LOCKED | CTLFLAG_RD, &amp;necp_kernel_socket_policies_non_app_count, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_LONG</span>(_net_necp, NECPCTL_IP_POLICY_COUNT, ip_policy_count, CTLFLAG_LOCKED | CTLFLAG_RD, &amp;necp_kernel_ip_output_policies_count, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_necp, NECPCTL_SESSION_COUNT, session_count, CTLFLAG_LOCKED | CTLFLAG_RD, &amp;necp_session_count, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">// Session order allocation
</span><span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">necp_allocate_new_session_order</span>(u_int32_t priority, u_int32_t control_unit)
{
	u_int32_t new_order = 0;

	<span class="enscript-comment">// For now, just allocate 1000 orders for each priority
</span>	<span class="enscript-keyword">if</span> (priority == NECP_SESSION_PRIORITY_UNKNOWN || priority &gt; NECP_SESSION_NUM_PRIORITIES) {
		priority = NECP_SESSION_PRIORITY_DEFAULT;
	}

	<span class="enscript-comment">// Use the control unit to decide the offset into the priority list
</span>	new_order = (control_unit) + ((priority - 1) * 1000);

	<span class="enscript-keyword">return</span> (new_order);
}

<span class="enscript-type">static</span> inline u_int32_t
<span class="enscript-function-name">necp_get_first_order_for_priority</span>(u_int32_t priority)
{
	<span class="enscript-keyword">return</span> (((priority - 1) * 1000) + 1);
}

<span class="enscript-comment">// Sysctl handler
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_handle_necp_level SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error = sysctl_handle_int(oidp, oidp-&gt;oid_arg1, oidp-&gt;oid_arg2, req);
	<span class="enscript-keyword">if</span> (necp_drop_all_level == 0) {
		necp_drop_all_order = 0;
	} <span class="enscript-keyword">else</span> {
		necp_drop_all_order = necp_get_first_order_for_priority(necp_drop_all_level);
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">// Kernel Control functions
</span><span class="enscript-type">static</span> errno_t <span class="enscript-function-name">necp_register_control</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">necp_ctl_connect</span>(kern_ctl_ref kctlref, <span class="enscript-type">struct</span> sockaddr_ctl *sac, <span class="enscript-type">void</span> **unitinfo);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">necp_ctl_disconnect</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">necp_ctl_send</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, mbuf_t m, <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">necp_ctl_rcvd</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">necp_ctl_getopt</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, <span class="enscript-type">int</span> opt, <span class="enscript-type">void</span> *data, size_t *len);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">necp_ctl_setopt</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, <span class="enscript-type">int</span> opt, <span class="enscript-type">void</span> *data, size_t len);

<span class="enscript-type">static</span> bool <span class="enscript-function-name">necp_send_ctl_data</span>(<span class="enscript-type">struct</span> necp_session *session, u_int8_t *buffer, size_t buffer_size);

errno_t
<span class="enscript-function-name">necp_init</span>(<span class="enscript-type">void</span>)
{
	errno_t result = 0;

	result = necp_register_control();
	<span class="enscript-keyword">if</span> (result != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	necp_kernel_policy_grp_attr = lck_grp_attr_alloc_init();
	<span class="enscript-keyword">if</span> (necp_kernel_policy_grp_attr == NULL) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;lck_grp_attr_alloc_init failed&quot;</span>);
		result = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	necp_kernel_policy_mtx_grp = lck_grp_alloc_init(NECP_CONTROL_NAME, necp_kernel_policy_grp_attr);
	<span class="enscript-keyword">if</span> (necp_kernel_policy_mtx_grp == NULL) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;lck_grp_alloc_init failed&quot;</span>);
		result = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	necp_kernel_policy_mtx_attr = lck_attr_alloc_init();
	<span class="enscript-keyword">if</span> (necp_kernel_policy_mtx_attr == NULL) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;lck_attr_alloc_init failed&quot;</span>);
		result = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	lck_rw_init(&amp;necp_kernel_policy_lock, necp_kernel_policy_mtx_grp, necp_kernel_policy_mtx_attr);

	necp_route_rule_grp_attr = lck_grp_attr_alloc_init();
	<span class="enscript-keyword">if</span> (necp_route_rule_grp_attr == NULL) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;lck_grp_attr_alloc_init failed&quot;</span>);
		result = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	necp_route_rule_mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;necp_route_rule&quot;</span>, necp_route_rule_grp_attr);
	<span class="enscript-keyword">if</span> (necp_route_rule_mtx_grp == NULL) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;lck_grp_alloc_init failed&quot;</span>);
		result = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	necp_route_rule_mtx_attr = lck_attr_alloc_init();
	<span class="enscript-keyword">if</span> (necp_route_rule_mtx_attr == NULL) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;lck_attr_alloc_init failed&quot;</span>);
		result = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	lck_rw_init(&amp;necp_route_rule_lock, necp_route_rule_mtx_grp, necp_route_rule_mtx_attr);

	LIST_INIT(&amp;necp_kernel_socket_policies);
	LIST_INIT(&amp;necp_kernel_ip_output_policies);

	LIST_INIT(&amp;necp_account_id_list);

	LIST_INIT(&amp;necp_uuid_service_id_list);

	LIST_INIT(&amp;necp_registered_service_list);

	LIST_INIT(&amp;necp_route_rules);
	LIST_INIT(&amp;necp_aggregate_route_rules);

	necp_uuid_app_id_hashtbl = hashinit(NECP_UUID_APP_ID_HASH_SIZE, M_NECP, &amp;necp_uuid_app_id_hash_mask);
	necp_uuid_app_id_hash_num_buckets = necp_uuid_app_id_hash_mask + 1;
	necp_num_uuid_app_id_mappings = 0;
	necp_uuid_app_id_mappings_dirty = FALSE;

	necp_kernel_application_policies_condition_mask = 0;
	necp_kernel_socket_policies_condition_mask = 0;
	necp_kernel_ip_output_policies_condition_mask = 0;

	necp_kernel_application_policies_count = 0;
	necp_kernel_socket_policies_count = 0;
	necp_kernel_socket_policies_non_app_count = 0;
	necp_kernel_ip_output_policies_count = 0;
	necp_kernel_ip_output_policies_non_id_count = 0;

	necp_last_policy_id = 0;
	necp_last_kernel_policy_id = 0;
	necp_last_uuid_id = 0;
	necp_last_string_id = 0;
	necp_last_route_rule_id = 0;
	necp_last_aggregate_route_rule_id = 0;

	necp_kernel_socket_policies_gencount = 1;

	memset(&amp;necp_kernel_socket_policies_map, 0, <span class="enscript-keyword">sizeof</span>(necp_kernel_socket_policies_map));
	memset(&amp;necp_kernel_ip_output_policies_map, 0, <span class="enscript-keyword">sizeof</span>(necp_kernel_ip_output_policies_map));
	necp_kernel_socket_policies_app_layer_map = NULL;

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (result != 0) {
		<span class="enscript-keyword">if</span> (necp_kernel_policy_mtx_attr != NULL) {
			lck_attr_free(necp_kernel_policy_mtx_attr);
			necp_kernel_policy_mtx_attr = NULL;
		}
		<span class="enscript-keyword">if</span> (necp_kernel_policy_mtx_grp != NULL) {
			lck_grp_free(necp_kernel_policy_mtx_grp);
			necp_kernel_policy_mtx_grp = NULL;
		}
		<span class="enscript-keyword">if</span> (necp_kernel_policy_grp_attr != NULL) {
			lck_grp_attr_free(necp_kernel_policy_grp_attr);
			necp_kernel_policy_grp_attr = NULL;
		}
		<span class="enscript-keyword">if</span> (necp_route_rule_mtx_attr != NULL) {
			lck_attr_free(necp_route_rule_mtx_attr);
			necp_route_rule_mtx_attr = NULL;
		}
		<span class="enscript-keyword">if</span> (necp_route_rule_mtx_grp != NULL) {
			lck_grp_free(necp_route_rule_mtx_grp);
			necp_route_rule_mtx_grp = NULL;
		}
		<span class="enscript-keyword">if</span> (necp_route_rule_grp_attr != NULL) {
			lck_grp_attr_free(necp_route_rule_grp_attr);
			necp_route_rule_grp_attr = NULL;
		}
		<span class="enscript-keyword">if</span> (necp_kctlref != NULL) {
			ctl_deregister(necp_kctlref);
			necp_kctlref = NULL;
		}
	}
	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">necp_register_control</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> kern_ctl_reg	kern_ctl;
	errno_t				result = 0;

	<span class="enscript-comment">// Create a tag to allocate memory
</span>	necp_malloc_tag = OSMalloc_Tagalloc(NECP_CONTROL_NAME, OSMT_DEFAULT);

	<span class="enscript-comment">// Find a unique value for our interface family
</span>	result = mbuf_tag_id_find(NECP_CONTROL_NAME, &amp;necp_family);
	<span class="enscript-keyword">if</span> (result != 0) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;mbuf_tag_id_find_internal failed: %d&quot;</span>, result);
		<span class="enscript-keyword">return</span> (result);
	}

	bzero(&amp;kern_ctl, <span class="enscript-keyword">sizeof</span>(kern_ctl));
	strlcpy(kern_ctl.ctl_name, NECP_CONTROL_NAME, <span class="enscript-keyword">sizeof</span>(kern_ctl.ctl_name));
	kern_ctl.ctl_name[<span class="enscript-keyword">sizeof</span>(kern_ctl.ctl_name) - 1] = 0;
	kern_ctl.ctl_flags = CTL_FLAG_PRIVILEGED; <span class="enscript-comment">// Require root
</span>	kern_ctl.ctl_sendsize = 64 * 1024;
	kern_ctl.ctl_recvsize = 64 * 1024;
	kern_ctl.ctl_connect = necp_ctl_connect;
	kern_ctl.ctl_disconnect = necp_ctl_disconnect;
	kern_ctl.ctl_send = necp_ctl_send;
	kern_ctl.ctl_rcvd = necp_ctl_rcvd;
	kern_ctl.ctl_setopt = necp_ctl_setopt;
	kern_ctl.ctl_getopt = necp_ctl_getopt;

	result = ctl_register(&amp;kern_ctl, &amp;necp_kctlref);
	<span class="enscript-keyword">if</span> (result != 0) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;ctl_register failed: %d&quot;</span>, result);
		<span class="enscript-keyword">return</span> (result);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_post_change_event</span>(<span class="enscript-type">struct</span> kev_necp_policies_changed_data *necp_event_data)
{
	<span class="enscript-type">struct</span> kev_msg ev_msg;
	memset(&amp;ev_msg, 0, <span class="enscript-keyword">sizeof</span>(ev_msg));

	ev_msg.vendor_code	= KEV_VENDOR_APPLE;
	ev_msg.kev_class	= KEV_NETWORK_CLASS;
	ev_msg.kev_subclass	= KEV_NECP_SUBCLASS;
	ev_msg.event_code	= KEV_NECP_POLICIES_CHANGED;

	ev_msg.dv[0].data_ptr	 = necp_event_data;
	ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span>(necp_event_data-&gt;changed_count);
	ev_msg.dv[1].data_length = 0;

	kev_post_msg(&amp;ev_msg);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">necp_ctl_connect</span>(kern_ctl_ref kctlref, <span class="enscript-type">struct</span> sockaddr_ctl *sac, <span class="enscript-type">void</span> **unitinfo)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>)
	*unitinfo = necp_create_session(sac-&gt;sc_unit);
	<span class="enscript-keyword">if</span> (*unitinfo == NULL) {
		<span class="enscript-comment">// Could not allocate session
</span>		<span class="enscript-keyword">return</span> (ENOBUFS);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">necp_ctl_disconnect</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">unit</span>)
	<span class="enscript-type">struct</span> necp_session *session = (<span class="enscript-type">struct</span> necp_session *)unitinfo;
	<span class="enscript-keyword">if</span> (session != NULL) {
		necp_policy_mark_all_for_deletion(session);
		necp_policy_apply_all(session);
		necp_delete_session((<span class="enscript-type">struct</span> necp_session *)unitinfo);
	}

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">// Message handling
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">necp_packet_find_tlv</span>(mbuf_t packet, <span class="enscript-type">int</span> offset, u_int8_t type, <span class="enscript-type">int</span> *err, <span class="enscript-type">int</span> next)
{
	size_t	cursor			= offset;
	<span class="enscript-type">int</span>		error			= 0;
	u_int32_t	curr_length;
	u_int8_t	curr_type;

	*err = 0;

	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (!next) {
			error = mbuf_copydata(packet, cursor, <span class="enscript-keyword">sizeof</span>(curr_type), &amp;curr_type);
			<span class="enscript-keyword">if</span> (error) {
				*err = ENOENT;
				<span class="enscript-keyword">return</span> (-1);
			}
		} <span class="enscript-keyword">else</span> {
			next = 0;
			curr_type = NECP_TLV_NIL;
		}

		<span class="enscript-keyword">if</span> (curr_type != type) {
			cursor += <span class="enscript-keyword">sizeof</span>(curr_type);
			error = mbuf_copydata(packet, cursor, <span class="enscript-keyword">sizeof</span>(curr_length), &amp;curr_length);
			<span class="enscript-keyword">if</span> (error) {
				*err = error;
				<span class="enscript-keyword">return</span> (-1);
			}
			cursor += (<span class="enscript-keyword">sizeof</span>(curr_length) + curr_length);
		}
	} <span class="enscript-keyword">while</span> (curr_type != type);

	<span class="enscript-keyword">return</span> (cursor);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">necp_packet_get_tlv_at_offset</span>(mbuf_t packet, <span class="enscript-type">int</span> tlv_offset, u_int32_t buff_len, <span class="enscript-type">void</span> *buff, u_int32_t *value_size)
{
	<span class="enscript-type">int</span>			error	= 0;
	u_int32_t	length;

	<span class="enscript-keyword">if</span> (tlv_offset &lt; 0) {
		<span class="enscript-keyword">return</span> (error);
	}

	error = mbuf_copydata(packet, tlv_offset + <span class="enscript-keyword">sizeof</span>(u_int8_t), <span class="enscript-keyword">sizeof</span>(length), &amp;length);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (value_size != NULL) {
		*value_size = length;
	}

	<span class="enscript-keyword">if</span> (buff != NULL &amp;&amp; buff_len &gt; 0) {
		u_int32_t to_copy = (length &lt; buff_len) ? length : buff_len;
		error = mbuf_copydata(packet, tlv_offset + <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(length), to_copy, buff);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">necp_packet_get_tlv</span>(mbuf_t packet, <span class="enscript-type">int</span> offset, u_int8_t type, u_int32_t buff_len, <span class="enscript-type">void</span> *buff, u_int32_t *value_size)
{
	<span class="enscript-type">int</span>		error		= 0;
	<span class="enscript-type">int</span>		tlv_offset;

	tlv_offset = necp_packet_find_tlv(packet, offset, type, &amp;error, 0);
	<span class="enscript-keyword">if</span> (tlv_offset &lt; 0) {
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">return</span> (necp_packet_get_tlv_at_offset(packet, tlv_offset, buff_len, buff, value_size));
}

<span class="enscript-type">static</span> u_int8_t *
<span class="enscript-function-name">necp_buffer_write_packet_header</span>(u_int8_t *buffer, u_int8_t packet_type, u_int8_t flags, u_int32_t message_id)
{
	((<span class="enscript-type">struct</span> necp_packet_header *)(<span class="enscript-type">void</span> *)buffer)-&gt;packet_type = packet_type;
	((<span class="enscript-type">struct</span> necp_packet_header *)(<span class="enscript-type">void</span> *)buffer)-&gt;flags = flags;
	((<span class="enscript-type">struct</span> necp_packet_header *)(<span class="enscript-type">void</span> *)buffer)-&gt;message_id = message_id;
	<span class="enscript-keyword">return</span> (buffer + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_packet_header));
}

<span class="enscript-type">static</span> u_int8_t *
<span class="enscript-function-name">necp_buffer_write_tlv</span>(u_int8_t *buffer, u_int8_t type, u_int32_t length, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *value)
{
	*(u_int8_t *)(buffer) = type;
	*(u_int32_t *)(<span class="enscript-type">void</span> *)(buffer + <span class="enscript-keyword">sizeof</span>(type)) = length;
	<span class="enscript-keyword">if</span> (length &gt; 0) {
		memcpy((u_int8_t *)(buffer + <span class="enscript-keyword">sizeof</span>(type) + <span class="enscript-keyword">sizeof</span>(length)), value, length);
	}

	<span class="enscript-keyword">return</span> ((u_int8_t *)(buffer + <span class="enscript-keyword">sizeof</span>(type) + <span class="enscript-keyword">sizeof</span>(length) + length));
}

<span class="enscript-type">static</span> u_int8_t
<span class="enscript-function-name">necp_buffer_get_tlv_type</span>(u_int8_t *buffer, <span class="enscript-type">int</span> tlv_offset)
{
	u_int8_t *type = NULL;

	<span class="enscript-keyword">if</span> (buffer == NULL) {
		<span class="enscript-keyword">return</span> (0);
	}

	type = (u_int8_t *)((u_int8_t *)buffer + tlv_offset);
	<span class="enscript-keyword">return</span> (type ? *type : 0);
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">necp_buffer_get_tlv_length</span>(u_int8_t *buffer, <span class="enscript-type">int</span> tlv_offset)
{
	u_int32_t *length = NULL;

	<span class="enscript-keyword">if</span> (buffer == NULL) {
		<span class="enscript-keyword">return</span> (0);
	}

	length = (u_int32_t *)(<span class="enscript-type">void</span> *)((u_int8_t *)buffer + tlv_offset + <span class="enscript-keyword">sizeof</span>(u_int8_t));
	<span class="enscript-keyword">return</span> (length ? *length : 0);
}

<span class="enscript-type">static</span> u_int8_t *
<span class="enscript-function-name">necp_buffer_get_tlv_value</span>(u_int8_t *buffer, <span class="enscript-type">int</span> tlv_offset, u_int32_t *value_size)
{
	u_int8_t *value = NULL;
	u_int32_t length = necp_buffer_get_tlv_length(buffer, tlv_offset);
	<span class="enscript-keyword">if</span> (length == 0) {
		<span class="enscript-keyword">return</span> (value);
	}

	<span class="enscript-keyword">if</span> (value_size) {
		*value_size = length;
	}

	value = (u_int8_t *)((u_int8_t *)buffer + tlv_offset + <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t));
	<span class="enscript-keyword">return</span> (value);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">necp_buffer_find_tlv</span>(u_int8_t *buffer, u_int32_t buffer_length, <span class="enscript-type">int</span> offset, u_int8_t type, <span class="enscript-type">int</span> next)
{
	<span class="enscript-keyword">if</span> (offset &lt; 0) {
		<span class="enscript-keyword">return</span> (-1);
	}
	<span class="enscript-type">int</span> cursor = offset;
	<span class="enscript-type">int</span> next_cursor;
	u_int32_t curr_length;
	u_int8_t curr_type;

	<span class="enscript-keyword">while</span> (TRUE) {
		<span class="enscript-keyword">if</span> ((((u_int32_t)cursor) + <span class="enscript-keyword">sizeof</span>(curr_type) + <span class="enscript-keyword">sizeof</span>(curr_length)) &gt; buffer_length) {
			<span class="enscript-keyword">return</span> (-1);
		}
		<span class="enscript-keyword">if</span> (!next) {
			curr_type = necp_buffer_get_tlv_type(buffer, cursor);
		} <span class="enscript-keyword">else</span> {
			next = 0;
			curr_type = NECP_TLV_NIL;
		}
		curr_length = necp_buffer_get_tlv_length(buffer, cursor);
		next_cursor = (cursor + <span class="enscript-keyword">sizeof</span>(curr_type) + <span class="enscript-keyword">sizeof</span>(curr_length) + curr_length);
		<span class="enscript-keyword">if</span> (curr_type == type) {
			<span class="enscript-comment">// check if entire TLV fits inside buffer
</span>			<span class="enscript-keyword">if</span> (((u_int32_t)next_cursor) &lt;= buffer_length) {
				<span class="enscript-keyword">return</span> (cursor);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">return</span> (-1);
			}
		}
		cursor = next_cursor;
	}
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_send_ctl_data</span>(<span class="enscript-type">struct</span> necp_session *session, u_int8_t *buffer, size_t buffer_size)
{
	<span class="enscript-type">int</span>		error;

	<span class="enscript-keyword">if</span> (necp_kctlref == NULL || session == NULL || buffer == NULL || buffer_size == 0) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	error = ctl_enqueuedata(necp_kctlref, session-&gt;control_unit, buffer, buffer_size, CTL_DATA_EOR);

	<span class="enscript-keyword">return</span> (error == 0);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_send_success_response</span>(<span class="enscript-type">struct</span> necp_session *session, u_int8_t packet_type, u_int32_t message_id)
{
	bool success = TRUE;
	u_int8_t *response = NULL;
	u_int8_t *cursor = NULL;
	size_t response_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_packet_header) + <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t);
	MALLOC(response, u_int8_t *, response_size, M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (response == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}
	cursor = response;
	cursor = necp_buffer_write_packet_header(cursor, packet_type, NECP_PACKET_FLAGS_RESPONSE, message_id);
	cursor = necp_buffer_write_tlv(cursor, NECP_TLV_NIL, 0, NULL);

	<span class="enscript-keyword">if</span> (!(success = necp_send_ctl_data(session, (u_int8_t *)response, response_size))) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to send response&quot;</span>);
	}

	FREE(response, M_NECP);
	<span class="enscript-keyword">return</span> (success);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_send_error_response</span>(<span class="enscript-type">struct</span> necp_session *session, u_int8_t packet_type, u_int32_t message_id, u_int32_t error)
{
	bool success = TRUE;
	u_int8_t *response = NULL;
	u_int8_t *cursor = NULL;
	size_t response_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_packet_header) + <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t);
	MALLOC(response, u_int8_t *, response_size, M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (response == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}
	cursor = response;
	cursor = necp_buffer_write_packet_header(cursor, packet_type, NECP_PACKET_FLAGS_RESPONSE, message_id);
	cursor = necp_buffer_write_tlv(cursor, NECP_TLV_ERROR, <span class="enscript-keyword">sizeof</span>(error), &amp;error);

	<span class="enscript-keyword">if</span> (!(success = necp_send_ctl_data(session, (u_int8_t *)response, response_size))) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to send response&quot;</span>);
	}

	FREE(response, M_NECP);
	<span class="enscript-keyword">return</span> (success);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_send_policy_id_response</span>(<span class="enscript-type">struct</span> necp_session *session, u_int8_t packet_type, u_int32_t message_id, necp_policy_id policy_id)
{
	bool success = TRUE;
	u_int8_t *response = NULL;
	u_int8_t *cursor = NULL;
	size_t response_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_packet_header) + <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t);
	MALLOC(response, u_int8_t *, response_size, M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (response == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}
	cursor = response;
	cursor = necp_buffer_write_packet_header(cursor, packet_type, NECP_PACKET_FLAGS_RESPONSE, message_id);
	cursor = necp_buffer_write_tlv(cursor, NECP_TLV_POLICY_ID, <span class="enscript-keyword">sizeof</span>(policy_id), &amp;policy_id);

	<span class="enscript-keyword">if</span> (!(success = necp_send_ctl_data(session, (u_int8_t *)response, response_size))) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to send response&quot;</span>);
	}

	FREE(response, M_NECP);
	<span class="enscript-keyword">return</span> (success);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">necp_ctl_send</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, mbuf_t packet, <span class="enscript-type">int</span> flags)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">unit</span>, <span class="enscript-variable-name">flags</span>)
	<span class="enscript-type">struct</span> necp_session *session = (<span class="enscript-type">struct</span> necp_session *)unitinfo;
	<span class="enscript-type">struct</span> necp_packet_header header;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (session == NULL) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Got a NULL session&quot;</span>);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (mbuf_pkthdr_len(packet) &lt; <span class="enscript-keyword">sizeof</span>(header)) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Got a bad packet, length (%lu) &lt; sizeof header (%lu)&quot;</span>, mbuf_pkthdr_len(packet), <span class="enscript-keyword">sizeof</span>(header));
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = mbuf_copydata(packet, 0, <span class="enscript-keyword">sizeof</span>(header), &amp;header);
	<span class="enscript-keyword">if</span> (error) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;mbuf_copydata failed for the header: %d&quot;</span>, error);
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (session-&gt;proc_locked) {
		<span class="enscript-comment">// Verify that the calling process is allowed to send messages
</span>		uuid_t proc_uuid;
		proc_getexecutableuuid(current_proc(), proc_uuid, <span class="enscript-keyword">sizeof</span>(proc_uuid));
		<span class="enscript-keyword">if</span> (uuid_compare(proc_uuid, session-&gt;proc_uuid) != 0) {
			necp_send_error_response(session, header.packet_type, header.message_id, NECP_ERROR_INVALID_PROCESS);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// If not locked, update the proc_uuid and proc_pid of the session
</span>		proc_getexecutableuuid(current_proc(), session-&gt;proc_uuid, <span class="enscript-keyword">sizeof</span>(session-&gt;proc_uuid));
		session-&gt;proc_pid = proc_pid(current_proc());
	}

	<span class="enscript-keyword">switch</span> (header.packet_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_PACKET_TYPE_POLICY_ADD</span>: {
			necp_handle_policy_add(session, header.message_id, packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_PACKET_TYPE_POLICY_GET</span>: {
			necp_handle_policy_get(session, header.message_id, packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_PACKET_TYPE_POLICY_DELETE</span>: {
			necp_handle_policy_delete(session, header.message_id, packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_PACKET_TYPE_POLICY_APPLY_ALL</span>: {
			necp_handle_policy_apply_all(session, header.message_id, packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_PACKET_TYPE_POLICY_LIST_ALL</span>: {
			necp_handle_policy_list_all(session, header.message_id, packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_PACKET_TYPE_POLICY_DELETE_ALL</span>: {
			necp_handle_policy_delete_all(session, header.message_id, packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_PACKET_TYPE_SET_SESSION_PRIORITY</span>: {
			necp_handle_set_session_priority(session, header.message_id, packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_PACKET_TYPE_LOCK_SESSION_TO_PROC</span>: {
			necp_handle_lock_session_to_proc(session, header.message_id, packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_PACKET_TYPE_REGISTER_SERVICE</span>: {
			necp_handle_register_service(session, header.message_id, packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_PACKET_TYPE_UNREGISTER_SERVICE</span>: {
			necp_handle_unregister_service(session, header.message_id, packet, <span class="enscript-keyword">sizeof</span>(header));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>: {
			NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Received unknown message type %d&quot;</span>, header.packet_type);
			necp_send_error_response(session, header.packet_type, header.message_id, NECP_ERROR_UNKNOWN_PACKET_TYPE);
			<span class="enscript-keyword">break</span>;
		}
	}

<span class="enscript-reference">done</span>:
	mbuf_freem(packet);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_ctl_rcvd</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, <span class="enscript-type">int</span> flags)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">unit</span>, <span class="enscript-variable-name">unitinfo</span>, <span class="enscript-variable-name">flags</span>)
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">necp_ctl_getopt</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, <span class="enscript-type">int</span> opt, <span class="enscript-type">void</span> *data, size_t *len)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">unit</span>, <span class="enscript-variable-name">unitinfo</span>, <span class="enscript-variable-name">opt</span>, <span class="enscript-variable-name">data</span>, <span class="enscript-variable-name">len</span>)
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">necp_ctl_setopt</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">void</span> *unitinfo, <span class="enscript-type">int</span> opt, <span class="enscript-type">void</span> *data, size_t len)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">unit</span>, <span class="enscript-variable-name">unitinfo</span>, <span class="enscript-variable-name">opt</span>, <span class="enscript-variable-name">data</span>, <span class="enscript-variable-name">len</span>)
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">// Session Management
</span><span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_session *
<span class="enscript-function-name">necp_create_session</span>(u_int32_t control_unit)
{
	<span class="enscript-type">struct</span> necp_session *new_session = NULL;

	MALLOC(new_session, <span class="enscript-type">struct</span> necp_session *, <span class="enscript-keyword">sizeof</span>(*new_session), M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_session == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (necp_debug) {
		NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Create NECP session, control unit %d&quot;</span>, control_unit);
	}
	memset(new_session, 0, <span class="enscript-keyword">sizeof</span>(*new_session));
	new_session-&gt;session_priority = NECP_SESSION_PRIORITY_UNKNOWN;
	new_session-&gt;session_order = necp_allocate_new_session_order(new_session-&gt;session_priority, control_unit);
	new_session-&gt;control_unit = control_unit;
	new_session-&gt;dirty = FALSE;
	LIST_INIT(&amp;new_session-&gt;policies);

	lck_rw_lock_exclusive(&amp;necp_kernel_policy_lock);
	necp_session_count++;
	lck_rw_done(&amp;necp_kernel_policy_lock);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (new_session);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_delete_session</span>(<span class="enscript-type">struct</span> necp_session *session)
{
	<span class="enscript-keyword">if</span> (session != NULL) {
		<span class="enscript-type">struct</span> necp_service_registration *service = NULL;
		<span class="enscript-type">struct</span> necp_service_registration *temp_service = NULL;
		LIST_FOREACH_SAFE(service, &amp;session-&gt;services, session_chain, temp_service) {
			LIST_REMOVE(service, session_chain);
			lck_rw_lock_exclusive(&amp;necp_kernel_policy_lock);
			LIST_REMOVE(service, kernel_chain);
			lck_rw_done(&amp;necp_kernel_policy_lock);
			FREE(service, M_NECP);
		}
		<span class="enscript-keyword">if</span> (necp_debug) {
			NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Deleted NECP session&quot;</span>);
		}
		FREE(session, M_NECP);

		lck_rw_lock_exclusive(&amp;necp_kernel_policy_lock);
		necp_session_count--;
		lck_rw_done(&amp;necp_kernel_policy_lock);
	}
}

<span class="enscript-comment">// Session Policy Management
</span><span class="enscript-type">static</span> inline u_int8_t
<span class="enscript-function-name">necp_policy_result_get_type_from_buffer</span>(u_int8_t *buffer, u_int32_t length)
{
	<span class="enscript-keyword">return</span> ((buffer &amp;&amp; length &gt;= <span class="enscript-keyword">sizeof</span>(u_int8_t)) ? buffer[0] : 0);
}

<span class="enscript-type">static</span> inline u_int32_t
<span class="enscript-function-name">necp_policy_result_get_parameter_length_from_buffer</span>(u_int8_t *buffer, u_int32_t length)
{
	<span class="enscript-keyword">return</span> ((buffer &amp;&amp; length &gt; <span class="enscript-keyword">sizeof</span>(u_int8_t)) ? (length - <span class="enscript-keyword">sizeof</span>(u_int8_t)) : 0);
}

<span class="enscript-type">static</span> inline u_int8_t *
<span class="enscript-function-name">necp_policy_result_get_parameter_pointer_from_buffer</span>(u_int8_t *buffer, u_int32_t length)
{
	<span class="enscript-keyword">return</span> ((buffer &amp;&amp; length &gt; <span class="enscript-keyword">sizeof</span>(u_int8_t)) ? (buffer + <span class="enscript-keyword">sizeof</span>(u_int8_t)) : NULL);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_policy_result_requires_route_rules</span>(u_int8_t *buffer, u_int32_t length)
{
	u_int8_t type = necp_policy_result_get_type_from_buffer(buffer, length);
	<span class="enscript-keyword">if</span> (type == NECP_POLICY_RESULT_ROUTE_RULES) {
		<span class="enscript-keyword">return</span> (TRUE);
	}
	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_policy_result_is_valid</span>(u_int8_t *buffer, u_int32_t length)
{
	bool validated = FALSE;
	u_int8_t type = necp_policy_result_get_type_from_buffer(buffer, length);
	u_int32_t parameter_length = necp_policy_result_get_parameter_length_from_buffer(buffer, length);
	<span class="enscript-keyword">switch</span> (type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_PASS</span>: {
			validated = TRUE;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_SKIP</span>: {
			<span class="enscript-keyword">if</span> (parameter_length &gt;= <span class="enscript-keyword">sizeof</span>(u_int32_t)) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_DROP</span>: {
			validated = TRUE;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_SOCKET_DIVERT</span>: {
			<span class="enscript-keyword">if</span> (parameter_length &gt;= <span class="enscript-keyword">sizeof</span>(u_int32_t)) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_SOCKET_SCOPED</span>: {
			<span class="enscript-keyword">if</span> (parameter_length &gt; 0) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_IP_TUNNEL</span>: {
			<span class="enscript-keyword">if</span> (parameter_length &gt; <span class="enscript-keyword">sizeof</span>(u_int32_t)) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_SOCKET_FILTER</span>: {
			<span class="enscript-keyword">if</span> (parameter_length &gt;= <span class="enscript-keyword">sizeof</span>(u_int32_t)) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_ROUTE_RULES</span>: {
			validated = TRUE;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_TRIGGER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_TRIGGER_IF_NEEDED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_TRIGGER_SCOPED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_NO_TRIGGER_SCOPED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_USE_NETAGENT</span>: {
			<span class="enscript-keyword">if</span> (parameter_length &gt;= <span class="enscript-keyword">sizeof</span>(uuid_t)) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>: {
			validated = FALSE;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (necp_debug) {
		NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Policy result type %d, valid %d&quot;</span>, type, validated);
	}

	<span class="enscript-keyword">return</span> (validated);
}

<span class="enscript-type">static</span> inline u_int8_t
<span class="enscript-function-name">necp_policy_condition_get_type_from_buffer</span>(u_int8_t *buffer, u_int32_t length)
{
	<span class="enscript-keyword">return</span> ((buffer &amp;&amp; length &gt;= <span class="enscript-keyword">sizeof</span>(u_int8_t)) ? buffer[0] : 0);
}

<span class="enscript-type">static</span> inline u_int8_t
<span class="enscript-function-name">necp_policy_condition_get_flags_from_buffer</span>(u_int8_t *buffer, u_int32_t length)
{
	<span class="enscript-keyword">return</span> ((buffer &amp;&amp; length &gt;= (2 * <span class="enscript-keyword">sizeof</span>(u_int8_t))) ? buffer[1] : 0);
}

<span class="enscript-type">static</span> inline u_int32_t
<span class="enscript-function-name">necp_policy_condition_get_value_length_from_buffer</span>(u_int8_t *buffer, u_int32_t length)
{
	<span class="enscript-keyword">return</span> ((buffer &amp;&amp; length &gt;= (2 * <span class="enscript-keyword">sizeof</span>(u_int8_t))) ? (length - (2 * <span class="enscript-keyword">sizeof</span>(u_int8_t))) : 0);
}

<span class="enscript-type">static</span> inline u_int8_t *
<span class="enscript-function-name">necp_policy_condition_get_value_pointer_from_buffer</span>(u_int8_t *buffer, u_int32_t length)
{
	<span class="enscript-keyword">return</span> ((buffer &amp;&amp; length &gt; (2 * <span class="enscript-keyword">sizeof</span>(u_int8_t))) ? (buffer + (2 * <span class="enscript-keyword">sizeof</span>(u_int8_t))) : NULL);
}

<span class="enscript-type">static</span> inline bool
<span class="enscript-function-name">necp_policy_condition_is_default</span>(u_int8_t *buffer, u_int32_t length)
{
	<span class="enscript-keyword">return</span> (necp_policy_condition_get_type_from_buffer(buffer, length) == NECP_POLICY_CONDITION_DEFAULT);
}

<span class="enscript-type">static</span> inline bool
<span class="enscript-function-name">necp_policy_condition_is_application</span>(u_int8_t *buffer, u_int32_t length)
{
	<span class="enscript-keyword">return</span> (necp_policy_condition_get_type_from_buffer(buffer, length) == NECP_POLICY_CONDITION_APPLICATION);
}

<span class="enscript-type">static</span> inline bool
<span class="enscript-function-name">necp_policy_condition_requires_application</span>(u_int8_t *buffer, u_int32_t length)
{
	u_int8_t type = necp_policy_condition_get_type_from_buffer(buffer, length);
	<span class="enscript-keyword">return</span> (type == NECP_POLICY_CONDITION_REAL_APPLICATION ||
			type == NECP_POLICY_CONDITION_ENTITLEMENT);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_policy_condition_is_valid</span>(u_int8_t *buffer, u_int32_t length, u_int8_t policy_result_type)
{
	bool validated = FALSE;
	bool result_cannot_have_ip_layer = (policy_result_type == NECP_POLICY_RESULT_SOCKET_DIVERT ||
										policy_result_type == NECP_POLICY_RESULT_SOCKET_FILTER ||
										policy_result_type == NECP_POLICY_RESULT_TRIGGER ||
										policy_result_type == NECP_POLICY_RESULT_TRIGGER_IF_NEEDED ||
										policy_result_type == NECP_POLICY_RESULT_TRIGGER_SCOPED ||
										policy_result_type == NECP_POLICY_RESULT_NO_TRIGGER_SCOPED ||
										policy_result_type == NECP_POLICY_RESULT_SOCKET_SCOPED ||
										policy_result_type == NECP_POLICY_RESULT_ROUTE_RULES ||
										policy_result_type == NECP_POLICY_RESULT_USE_NETAGENT) ? TRUE : FALSE;
	u_int32_t condition_length = necp_policy_condition_get_value_length_from_buffer(buffer, length);
	u_int8_t *condition_value = necp_policy_condition_get_value_pointer_from_buffer(buffer, length);
	u_int8_t type = necp_policy_condition_get_type_from_buffer(buffer, length);
	u_int8_t flags = necp_policy_condition_get_flags_from_buffer(buffer, length);
	<span class="enscript-keyword">switch</span> (type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_APPLICATION</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_REAL_APPLICATION</span>: {
			<span class="enscript-keyword">if</span> (!(flags &amp; NECP_POLICY_CONDITION_FLAGS_NEGATIVE) &amp;&amp;
				condition_length &gt;= <span class="enscript-keyword">sizeof</span>(uuid_t) &amp;&amp;
				condition_value != NULL &amp;&amp;
				!uuid_is_null(condition_value)) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_DOMAIN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_ACCOUNT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_BOUND_INTERFACE</span>: {
			<span class="enscript-keyword">if</span> (condition_length &gt; 0) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_TRAFFIC_CLASS</span>: {
			<span class="enscript-keyword">if</span> (condition_length &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_policy_condition_tc_range)) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_DEFAULT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_ALL_INTERFACES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_ENTITLEMENT</span>: {
			<span class="enscript-keyword">if</span> (!(flags &amp; NECP_POLICY_CONDITION_FLAGS_NEGATIVE)) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_IP_PROTOCOL</span>: {
			<span class="enscript-keyword">if</span> (condition_length &gt;= <span class="enscript-keyword">sizeof</span>(u_int16_t)) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_PID</span>: {
			<span class="enscript-keyword">if</span> (condition_length &gt;= <span class="enscript-keyword">sizeof</span>(pid_t) &amp;&amp;
				condition_value != NULL &amp;&amp;
				*((pid_t *)(<span class="enscript-type">void</span> *)condition_value) != 0) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_UID</span>: {
			<span class="enscript-keyword">if</span> (condition_length &gt;= <span class="enscript-keyword">sizeof</span>(uid_t)) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_LOCAL_ADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_REMOTE_ADDR</span>: {
			<span class="enscript-keyword">if</span> (!result_cannot_have_ip_layer &amp;&amp; condition_length &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_policy_condition_addr)) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_LOCAL_ADDR_RANGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_REMOTE_ADDR_RANGE</span>: {
			<span class="enscript-keyword">if</span> (!result_cannot_have_ip_layer &amp;&amp; condition_length &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_policy_condition_addr_range)) {
				validated = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>: {
			validated = FALSE;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (necp_debug) {
		NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Policy condition type %d, valid %d&quot;</span>, type, validated);
	}

	<span class="enscript-keyword">return</span> (validated);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_policy_route_rule_is_default</span>(u_int8_t *buffer, u_int32_t length)
{
	<span class="enscript-keyword">return</span> (necp_policy_condition_get_value_length_from_buffer(buffer, length) == 0 &amp;&amp;
			necp_policy_condition_get_flags_from_buffer(buffer, length) == 0);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_policy_route_rule_is_valid</span>(u_int8_t *buffer, u_int32_t length)
{
	bool validated = FALSE;
	u_int8_t type = necp_policy_condition_get_type_from_buffer(buffer, length);
	<span class="enscript-keyword">switch</span> (type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_ROUTE_RULE_ALLOW_INTERFACE</span>: {
			validated = TRUE;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_ROUTE_RULE_DENY_INTERFACE</span>: {
			validated = TRUE;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>: {
			validated = FALSE;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (necp_debug) {
		NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Policy route rule type %d, valid %d&quot;</span>, type, validated);
	}

	<span class="enscript-keyword">return</span> (validated);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_handle_set_session_priority</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> necp_session_policy *policy = NULL;
	<span class="enscript-type">struct</span> necp_session_policy *temp_policy = NULL;
	u_int32_t response_error = NECP_ERROR_INTERNAL;
	u_int32_t requested_session_priority = NECP_SESSION_PRIORITY_UNKNOWN;

	<span class="enscript-comment">// Read policy id
</span>	error = necp_packet_get_tlv(packet, offset, NECP_TLV_SESSION_PRIORITY, <span class="enscript-keyword">sizeof</span>(requested_session_priority), &amp;requested_session_priority, NULL);
	<span class="enscript-keyword">if</span> (error) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to get session priority: %d&quot;</span>, error);
		response_error = NECP_ERROR_INVALID_TLV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-keyword">if</span> (session == NULL) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to find session&quot;</span>);
		response_error = NECP_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">// Enforce special session priorities with entitlements
</span>	<span class="enscript-keyword">if</span> (requested_session_priority == NECP_SESSION_PRIORITY_CONTROL ||
		requested_session_priority == NECP_SESSION_PRIORITY_PRIVILEGED_TUNNEL) {
		errno_t cred_result = priv_check_cred(kauth_cred_get(), PRIV_NET_PRIVILEGED_NECP_POLICIES, 0);
		<span class="enscript-keyword">if</span> (cred_result != 0) {
			NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Session does not hold necessary entitlement to claim priority level %d&quot;</span>, requested_session_priority);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
	}

	<span class="enscript-keyword">if</span> (session-&gt;session_priority != requested_session_priority) {
		session-&gt;session_priority = requested_session_priority;
		session-&gt;session_order = necp_allocate_new_session_order(session-&gt;session_priority, session-&gt;control_unit);
		session-&gt;dirty = TRUE;

		<span class="enscript-comment">// Mark all policies as needing updates
</span>		LIST_FOREACH_SAFE(policy, &amp;session-&gt;policies, chain, temp_policy) {
			policy-&gt;pending_update = TRUE;
		}
	}

	necp_send_success_response(session, NECP_PACKET_TYPE_SET_SESSION_PRIORITY, message_id);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">fail</span>:
	necp_send_error_response(session, NECP_PACKET_TYPE_SET_SESSION_PRIORITY, message_id, response_error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_handle_lock_session_to_proc</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">packet</span>, <span class="enscript-variable-name">offset</span>)
	<span class="enscript-comment">// proc_uuid already filled out
</span>	session-&gt;proc_locked = TRUE;
	necp_send_success_response(session, NECP_PACKET_TYPE_LOCK_SESSION_TO_PROC, message_id);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_handle_register_service</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> necp_service_registration *new_service = NULL;
	u_int32_t response_error = NECP_ERROR_INTERNAL;
	uuid_t service_uuid;
	uuid_clear(service_uuid);

	<span class="enscript-keyword">if</span> (session == NULL) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to find session&quot;</span>);
		response_error = NECP_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">// Enforce entitlements
</span>	errno_t cred_result = priv_check_cred(kauth_cred_get(), PRIV_NET_PRIVILEGED_NECP_POLICIES, 0);
	<span class="enscript-keyword">if</span> (cred_result != 0) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Session does not hold necessary entitlement to register service&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">// Read service uuid
</span>	error = necp_packet_get_tlv(packet, offset, NECP_TLV_SERVICE_UUID, <span class="enscript-keyword">sizeof</span>(uuid_t), service_uuid, NULL);
	<span class="enscript-keyword">if</span> (error) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to get service UUID: %d&quot;</span>, error);
		response_error = NECP_ERROR_INVALID_TLV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	MALLOC(new_service, <span class="enscript-type">struct</span> necp_service_registration *, <span class="enscript-keyword">sizeof</span>(*new_service), M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_service == NULL) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to allocate service registration&quot;</span>);
		response_error = NECP_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	
	lck_rw_lock_exclusive(&amp;necp_kernel_policy_lock);
	memset(new_service, 0, <span class="enscript-keyword">sizeof</span>(*new_service));
	new_service-&gt;service_id = necp_create_uuid_service_id_mapping(service_uuid);
	LIST_INSERT_HEAD(&amp;session-&gt;services, new_service, session_chain);
	LIST_INSERT_HEAD(&amp;necp_registered_service_list, new_service, kernel_chain);
	lck_rw_done(&amp;necp_kernel_policy_lock);

	necp_send_success_response(session, NECP_PACKET_TYPE_REGISTER_SERVICE, message_id);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">fail</span>:
	necp_send_error_response(session, NECP_PACKET_TYPE_REGISTER_SERVICE, message_id, response_error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_handle_unregister_service</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> necp_service_registration *service = NULL;
	<span class="enscript-type">struct</span> necp_service_registration *temp_service = NULL;
	u_int32_t response_error = NECP_ERROR_INTERNAL;
	<span class="enscript-type">struct</span> necp_uuid_id_mapping *mapping = NULL;
	uuid_t service_uuid;
	uuid_clear(service_uuid);

	<span class="enscript-keyword">if</span> (session == NULL) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to find session&quot;</span>);
		response_error = NECP_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">// Read service uuid
</span>	error = necp_packet_get_tlv(packet, offset, NECP_TLV_SERVICE_UUID, <span class="enscript-keyword">sizeof</span>(uuid_t), service_uuid, NULL);
	<span class="enscript-keyword">if</span> (error) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to get service UUID: %d&quot;</span>, error);
		response_error = NECP_ERROR_INVALID_TLV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">// Mark remove all matching services for this session
</span>	lck_rw_lock_exclusive(&amp;necp_kernel_policy_lock);
	mapping = necp_uuid_lookup_service_id_locked(service_uuid);
	<span class="enscript-keyword">if</span> (mapping != NULL) {
		LIST_FOREACH_SAFE(service, &amp;session-&gt;services, session_chain, temp_service) {
			<span class="enscript-keyword">if</span> (service-&gt;service_id == mapping-&gt;id) {
				LIST_REMOVE(service, session_chain);
				LIST_REMOVE(service, kernel_chain);
				FREE(service, M_NECP);
			}
		}
		necp_remove_uuid_service_id_mapping(service_uuid);
	}
	lck_rw_done(&amp;necp_kernel_policy_lock);

	necp_send_success_response(session, NECP_PACKET_TYPE_UNREGISTER_SERVICE, message_id);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">fail</span>:
	necp_send_error_response(session, NECP_PACKET_TYPE_UNREGISTER_SERVICE, message_id, response_error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_handle_policy_add</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	bool has_default_condition = FALSE;
	bool has_non_default_condition = FALSE;
	bool has_application_condition = FALSE;
	bool requires_application_condition = FALSE;
	u_int8_t *conditions_array = NULL;
	u_int32_t conditions_array_size = 0;
	<span class="enscript-type">int</span> conditions_array_cursor;

	bool has_default_route_rule = FALSE;
	u_int8_t *route_rules_array = NULL;
	u_int32_t route_rules_array_size = 0;
	<span class="enscript-type">int</span> route_rules_array_cursor;

	<span class="enscript-type">int</span> cursor;
	<span class="enscript-type">int</span> error = 0;
	u_int32_t response_error = NECP_ERROR_INTERNAL;

	necp_policy_order order = 0;
	<span class="enscript-type">struct</span> necp_session_policy *policy = NULL;
	u_int8_t *policy_result = NULL;
	u_int32_t policy_result_size = 0;

	<span class="enscript-comment">// Read policy order
</span>	error = necp_packet_get_tlv(packet, offset, NECP_TLV_POLICY_ORDER, <span class="enscript-keyword">sizeof</span>(order), &amp;order, NULL);
	<span class="enscript-keyword">if</span> (error) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to get policy order: %d&quot;</span>, error);
		response_error = NECP_ERROR_INVALID_TLV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">// Read policy result
</span>	cursor = necp_packet_find_tlv(packet, offset, NECP_TLV_POLICY_RESULT, &amp;error, 0);
	error = necp_packet_get_tlv_at_offset(packet, cursor, 0, NULL, &amp;policy_result_size);
	<span class="enscript-keyword">if</span> (error || policy_result_size == 0) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to get policy result length: %d&quot;</span>, error);
		response_error = NECP_ERROR_INVALID_TLV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	MALLOC(policy_result, u_int8_t *, policy_result_size, M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (policy_result == NULL) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to allocate a policy result buffer (size %d)&quot;</span>, policy_result_size);
		response_error = NECP_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	error = necp_packet_get_tlv_at_offset(packet, cursor, policy_result_size, policy_result, NULL);
	<span class="enscript-keyword">if</span> (error) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to get policy result: %d&quot;</span>, error);
		response_error = NECP_ERROR_POLICY_RESULT_INVALID;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	<span class="enscript-keyword">if</span> (!necp_policy_result_is_valid(policy_result, policy_result_size)) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to validate policy result&quot;</span>);
		response_error = NECP_ERROR_POLICY_RESULT_INVALID;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-keyword">if</span> (necp_policy_result_requires_route_rules(policy_result, policy_result_size)) {
		<span class="enscript-comment">// Read route rules conditions
</span>		<span class="enscript-keyword">for</span> (cursor = necp_packet_find_tlv(packet, offset, NECP_TLV_ROUTE_RULE, &amp;error, 0);
			 cursor &gt;= 0;
			 cursor = necp_packet_find_tlv(packet, cursor, NECP_TLV_ROUTE_RULE, &amp;error, 1)) {
			u_int32_t route_rule_size = 0;
			necp_packet_get_tlv_at_offset(packet, cursor, 0, NULL, &amp;route_rule_size);
			<span class="enscript-keyword">if</span> (route_rule_size &gt; 0) {
				route_rules_array_size += (<span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + route_rule_size);
			}
		}

		<span class="enscript-keyword">if</span> (route_rules_array_size == 0) {
			NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to get policy route rules&quot;</span>);
			response_error = NECP_ERROR_INVALID_TLV;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}

		MALLOC(route_rules_array, u_int8_t *, route_rules_array_size, M_NECP, M_WAITOK);
		<span class="enscript-keyword">if</span> (route_rules_array == NULL) {
			NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to allocate a policy route rules array (size %d)&quot;</span>, route_rules_array_size);
			response_error = NECP_ERROR_INTERNAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}

		route_rules_array_cursor = 0;
		<span class="enscript-keyword">for</span> (cursor = necp_packet_find_tlv(packet, offset, NECP_TLV_ROUTE_RULE, &amp;error, 0);
			 cursor &gt;= 0;
			 cursor = necp_packet_find_tlv(packet, cursor, NECP_TLV_ROUTE_RULE, &amp;error, 1)) {
			u_int8_t route_rule_type = NECP_TLV_ROUTE_RULE;
			u_int32_t route_rule_size = 0;
			necp_packet_get_tlv_at_offset(packet, cursor, 0, NULL, &amp;route_rule_size);
			<span class="enscript-keyword">if</span> (route_rule_size &gt; 0 &amp;&amp; route_rule_size &lt;= (route_rules_array_size - route_rules_array_cursor)) {
				<span class="enscript-comment">// Add type
</span>				memcpy((route_rules_array + route_rules_array_cursor), &amp;route_rule_type, <span class="enscript-keyword">sizeof</span>(route_rule_type));
				route_rules_array_cursor += <span class="enscript-keyword">sizeof</span>(route_rule_type);

				<span class="enscript-comment">// Add length
</span>				memcpy((route_rules_array + route_rules_array_cursor), &amp;route_rule_size, <span class="enscript-keyword">sizeof</span>(route_rule_size));
				route_rules_array_cursor += <span class="enscript-keyword">sizeof</span>(route_rule_size);

				<span class="enscript-comment">// Add value
</span>				necp_packet_get_tlv_at_offset(packet, cursor, route_rule_size, (route_rules_array + route_rules_array_cursor), NULL);

				<span class="enscript-keyword">if</span> (!necp_policy_route_rule_is_valid((route_rules_array + route_rules_array_cursor), route_rule_size)) {
					NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to validate policy route rule&quot;</span>);
					response_error = NECP_ERROR_ROUTE_RULES_INVALID;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				}

				<span class="enscript-keyword">if</span> (necp_policy_route_rule_is_default((route_rules_array + route_rules_array_cursor), route_rule_size)) {
					<span class="enscript-keyword">if</span> (has_default_route_rule) {
						NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to validate route rule; contained multiple default route rules&quot;</span>);
						response_error = NECP_ERROR_ROUTE_RULES_INVALID;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
					}
					has_default_route_rule = TRUE;
				}

				route_rules_array_cursor += route_rule_size;
			}
		}
	}

	<span class="enscript-comment">// Read policy conditions
</span>	<span class="enscript-keyword">for</span> (cursor = necp_packet_find_tlv(packet, offset, NECP_TLV_POLICY_CONDITION, &amp;error, 0);
		cursor &gt;= 0;
		cursor = necp_packet_find_tlv(packet, cursor, NECP_TLV_POLICY_CONDITION, &amp;error, 1)) {
		u_int32_t condition_size = 0;
		necp_packet_get_tlv_at_offset(packet, cursor, 0, NULL, &amp;condition_size);

		<span class="enscript-keyword">if</span> (condition_size &gt; 0) {
			conditions_array_size += (<span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + condition_size);
		}
	}

	<span class="enscript-keyword">if</span> (conditions_array_size == 0) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to get policy conditions&quot;</span>);
		response_error = NECP_ERROR_INVALID_TLV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	MALLOC(conditions_array, u_int8_t *, conditions_array_size, M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (conditions_array == NULL) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to allocate a policy conditions array (size %d)&quot;</span>, conditions_array_size);
		response_error = NECP_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	conditions_array_cursor = 0;
	<span class="enscript-keyword">for</span> (cursor = necp_packet_find_tlv(packet, offset, NECP_TLV_POLICY_CONDITION, &amp;error, 0);
		cursor &gt;= 0;
		cursor = necp_packet_find_tlv(packet, cursor, NECP_TLV_POLICY_CONDITION, &amp;error, 1)) {
		u_int8_t condition_type = NECP_TLV_POLICY_CONDITION;
		u_int32_t condition_size = 0;
		necp_packet_get_tlv_at_offset(packet, cursor, 0, NULL, &amp;condition_size);
		<span class="enscript-keyword">if</span> (condition_size &gt; 0 &amp;&amp; condition_size &lt;= (conditions_array_size - conditions_array_cursor)) {
			<span class="enscript-comment">// Add type
</span>			memcpy((conditions_array + conditions_array_cursor), &amp;condition_type, <span class="enscript-keyword">sizeof</span>(condition_type));
			conditions_array_cursor += <span class="enscript-keyword">sizeof</span>(condition_type);

			<span class="enscript-comment">// Add length
</span>			memcpy((conditions_array + conditions_array_cursor), &amp;condition_size, <span class="enscript-keyword">sizeof</span>(condition_size));
			conditions_array_cursor += <span class="enscript-keyword">sizeof</span>(condition_size);

			<span class="enscript-comment">// Add value
</span>			necp_packet_get_tlv_at_offset(packet, cursor, condition_size, (conditions_array + conditions_array_cursor), NULL);
			<span class="enscript-keyword">if</span> (!necp_policy_condition_is_valid((conditions_array + conditions_array_cursor), condition_size, necp_policy_result_get_type_from_buffer(policy_result, policy_result_size))) {
				NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to validate policy condition&quot;</span>);
				response_error = NECP_ERROR_POLICY_CONDITIONS_INVALID;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}

			<span class="enscript-keyword">if</span> (necp_policy_condition_is_default((conditions_array + conditions_array_cursor), condition_size)) {
				has_default_condition = TRUE;
			} <span class="enscript-keyword">else</span> {
				has_non_default_condition = TRUE;
			}
			<span class="enscript-keyword">if</span> (has_default_condition &amp;&amp; has_non_default_condition) {
				NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to validate conditions; contained default and non-default conditions&quot;</span>);
				response_error = NECP_ERROR_POLICY_CONDITIONS_INVALID;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			
			<span class="enscript-keyword">if</span> (necp_policy_condition_is_application((conditions_array + conditions_array_cursor), condition_size)) {
				has_application_condition = TRUE;
			}
			
			<span class="enscript-keyword">if</span> (necp_policy_condition_requires_application((conditions_array + conditions_array_cursor), condition_size)) {
				requires_application_condition = TRUE;
			}

			conditions_array_cursor += condition_size;
		}
	}
	
	<span class="enscript-keyword">if</span> (requires_application_condition &amp;&amp; !has_application_condition) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to validate conditions; did not contain application condition&quot;</span>);
		response_error = NECP_ERROR_POLICY_CONDITIONS_INVALID;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-keyword">if</span> ((policy = necp_policy_create(session, order, conditions_array, conditions_array_size, route_rules_array, route_rules_array_size, policy_result, policy_result_size)) == NULL) {
		response_error = NECP_ERROR_INTERNAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	necp_send_policy_id_response(session, NECP_PACKET_TYPE_POLICY_ADD, message_id, policy-&gt;id);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (policy_result != NULL) {
		FREE(policy_result, M_NECP);
	}
	<span class="enscript-keyword">if</span> (conditions_array != NULL) {
		FREE(conditions_array, M_NECP);
	}
	<span class="enscript-keyword">if</span> (route_rules_array != NULL) {
		FREE(route_rules_array, M_NECP);
	}

	necp_send_error_response(session, NECP_PACKET_TYPE_POLICY_ADD, message_id, response_error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_handle_policy_get</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">offset</span>)
	<span class="enscript-type">int</span> error;
	u_int8_t *response = NULL;
	u_int8_t *cursor = NULL;
	u_int32_t response_error = NECP_ERROR_INTERNAL;
	necp_policy_id policy_id = 0;
	u_int32_t order_tlv_size = 0;
	u_int32_t result_tlv_size = 0;
	u_int32_t response_size = 0;

	<span class="enscript-type">struct</span> necp_session_policy *policy = NULL;

	<span class="enscript-comment">// Read policy id
</span>	error = necp_packet_get_tlv(packet, offset, NECP_TLV_POLICY_ID, <span class="enscript-keyword">sizeof</span>(policy_id), &amp;policy_id, NULL);
	<span class="enscript-keyword">if</span> (error) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to get policy id: %d&quot;</span>, error);
		response_error = NECP_ERROR_INVALID_TLV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	policy = necp_policy_find(session, policy_id);
	<span class="enscript-keyword">if</span> (policy == NULL || policy-&gt;pending_deletion) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to find policy with id %d&quot;</span>, policy_id);
		response_error = NECP_ERROR_POLICY_ID_NOT_FOUND;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	order_tlv_size = <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + <span class="enscript-keyword">sizeof</span>(necp_policy_order);
	result_tlv_size = (policy-&gt;result_size ? (<span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + policy-&gt;result_size) : 0);
	response_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_packet_header) + order_tlv_size + result_tlv_size + policy-&gt;conditions_size;
	MALLOC(response, u_int8_t *, response_size, M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (response == NULL) {
		necp_send_error_response(session, NECP_PACKET_TYPE_POLICY_LIST_ALL, message_id, NECP_ERROR_INTERNAL);
		<span class="enscript-keyword">return</span>;
	}

	cursor = response;
	cursor = necp_buffer_write_packet_header(cursor, NECP_PACKET_TYPE_POLICY_GET, NECP_PACKET_FLAGS_RESPONSE, message_id);
	cursor = necp_buffer_write_tlv(cursor, NECP_TLV_POLICY_ORDER, <span class="enscript-keyword">sizeof</span>(necp_policy_order), &amp;policy-&gt;order);

	<span class="enscript-keyword">if</span> (result_tlv_size) {
		cursor = necp_buffer_write_tlv(cursor, NECP_TLV_POLICY_RESULT, policy-&gt;result_size, &amp;policy-&gt;result);
	}
	<span class="enscript-keyword">if</span> (policy-&gt;conditions_size) {
		memcpy(((u_int8_t *)(<span class="enscript-type">void</span> *)(cursor)), policy-&gt;conditions, policy-&gt;conditions_size);
	}

	<span class="enscript-keyword">if</span> (!necp_send_ctl_data(session, (u_int8_t *)response, response_size)) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to send response&quot;</span>);
	}

	FREE(response, M_NECP);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">fail</span>:
	necp_send_error_response(session, NECP_PACKET_TYPE_POLICY_GET, message_id, response_error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_handle_policy_delete</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	<span class="enscript-type">int</span> error;
	u_int32_t response_error = NECP_ERROR_INTERNAL;
	necp_policy_id policy_id = 0;

	<span class="enscript-type">struct</span> necp_session_policy *policy = NULL;

	<span class="enscript-comment">// Read policy id
</span>	error = necp_packet_get_tlv(packet, offset, NECP_TLV_POLICY_ID, <span class="enscript-keyword">sizeof</span>(policy_id), &amp;policy_id, NULL);
	<span class="enscript-keyword">if</span> (error) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to get policy id: %d&quot;</span>, error);
		response_error = NECP_ERROR_INVALID_TLV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	policy = necp_policy_find(session, policy_id);
	<span class="enscript-keyword">if</span> (policy == NULL || policy-&gt;pending_deletion) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to find policy with id %d&quot;</span>, policy_id);
		response_error = NECP_ERROR_POLICY_ID_NOT_FOUND;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	necp_policy_mark_for_deletion(session, policy);

	necp_send_success_response(session, NECP_PACKET_TYPE_POLICY_DELETE, message_id);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">fail</span>:
	necp_send_error_response(session, NECP_PACKET_TYPE_POLICY_DELETE, message_id, response_error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_handle_policy_apply_all</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">packet</span>, <span class="enscript-variable-name">offset</span>)
	necp_policy_apply_all(session);
	necp_send_success_response(session, NECP_PACKET_TYPE_POLICY_APPLY_ALL, message_id);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_handle_policy_list_all</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">packet</span>, <span class="enscript-variable-name">offset</span>)
	u_int32_t tlv_size = (<span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t));
	u_int32_t response_size = 0;
	u_int8_t *response = NULL;
	u_int8_t *cursor = NULL;
	<span class="enscript-type">int</span> num_policies = 0;
	<span class="enscript-type">int</span> cur_policy_index = 0;
	<span class="enscript-type">struct</span> necp_session_policy *policy;

	LIST_FOREACH(policy, &amp;session-&gt;policies, chain) {
		<span class="enscript-keyword">if</span> (!policy-&gt;pending_deletion) {
			num_policies++;
		}
	}

	<span class="enscript-comment">// Create a response with one Policy ID TLV for each policy
</span>	response_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_packet_header) + num_policies * tlv_size;
	MALLOC(response, u_int8_t *, response_size, M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (response == NULL) {
		necp_send_error_response(session, NECP_PACKET_TYPE_POLICY_LIST_ALL, message_id, NECP_ERROR_INTERNAL);
		<span class="enscript-keyword">return</span>;
	}

	cursor = response;
	cursor = necp_buffer_write_packet_header(cursor, NECP_PACKET_TYPE_POLICY_LIST_ALL, NECP_PACKET_FLAGS_RESPONSE, message_id);

	LIST_FOREACH(policy, &amp;session-&gt;policies, chain) {
		<span class="enscript-keyword">if</span> (!policy-&gt;pending_deletion &amp;&amp; cur_policy_index &lt; num_policies) {
			cursor = necp_buffer_write_tlv(cursor, NECP_TLV_POLICY_ID, <span class="enscript-keyword">sizeof</span>(u_int32_t), &amp;policy-&gt;id);
			cur_policy_index++;
		}
	}

	<span class="enscript-keyword">if</span> (!necp_send_ctl_data(session, (u_int8_t *)response, response_size)) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to send response&quot;</span>);
	}

	FREE(response, M_NECP);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_handle_policy_delete_all</span>(<span class="enscript-type">struct</span> necp_session *session, u_int32_t message_id, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">packet</span>, <span class="enscript-variable-name">offset</span>)
	necp_policy_mark_all_for_deletion(session);
	necp_send_success_response(session, NECP_PACKET_TYPE_POLICY_DELETE_ALL, message_id);
}

<span class="enscript-type">static</span> necp_policy_id
<span class="enscript-function-name">necp_policy_get_new_id</span>(<span class="enscript-type">void</span>)
{
	necp_policy_id newid = 0;

	lck_rw_lock_exclusive(&amp;necp_kernel_policy_lock);

	necp_last_policy_id++;
	<span class="enscript-keyword">if</span> (necp_last_policy_id &lt; 1) {
		necp_last_policy_id = 1;
	}

	newid = necp_last_policy_id;
	lck_rw_done(&amp;necp_kernel_policy_lock);

	<span class="enscript-keyword">if</span> (newid == 0) {
		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Allocate policy id failed.\n&quot;</span>);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (newid);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_session_policy *
<span class="enscript-function-name">necp_policy_create</span>(<span class="enscript-type">struct</span> necp_session *session, necp_policy_order order, u_int8_t *conditions_array, u_int32_t conditions_array_size, u_int8_t *route_rules_array, u_int32_t route_rules_array_size, u_int8_t *result, u_int32_t result_size)
{
	<span class="enscript-type">struct</span> necp_session_policy *new_policy = NULL;
	<span class="enscript-type">struct</span> necp_session_policy *tmp_policy = NULL;

	<span class="enscript-keyword">if</span> (session == NULL || conditions_array == NULL || result == NULL || result_size == 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	MALLOC_ZONE(new_policy, <span class="enscript-type">struct</span> necp_session_policy *, <span class="enscript-keyword">sizeof</span>(*new_policy), M_NECP_SESSION_POLICY, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_policy == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	memset(new_policy, 0, <span class="enscript-keyword">sizeof</span>(*new_policy));
	new_policy-&gt;applied = FALSE;
	new_policy-&gt;pending_deletion = FALSE;
	new_policy-&gt;pending_update = FALSE;
	new_policy-&gt;order = order;
	new_policy-&gt;conditions = conditions_array;
	new_policy-&gt;conditions_size = conditions_array_size;
	new_policy-&gt;route_rules = route_rules_array;
	new_policy-&gt;route_rules_size = route_rules_array_size;
	new_policy-&gt;result = result;
	new_policy-&gt;result_size = result_size;
	new_policy-&gt;id = necp_policy_get_new_id();

	LIST_INSERT_SORTED_ASCENDING(&amp;session-&gt;policies, new_policy, chain, order, tmp_policy);

	session-&gt;dirty = TRUE;

	<span class="enscript-keyword">if</span> (necp_debug) {
		NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Created NECP policy, order %d&quot;</span>, order);
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (new_policy);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_session_policy *
<span class="enscript-function-name">necp_policy_find</span>(<span class="enscript-type">struct</span> necp_session *session, necp_policy_id policy_id)
{
	<span class="enscript-type">struct</span> necp_session_policy *policy = NULL;
	<span class="enscript-keyword">if</span> (policy_id == 0) {
		<span class="enscript-keyword">return</span> (NULL);
	}

	LIST_FOREACH(policy, &amp;session-&gt;policies, chain) {
		<span class="enscript-keyword">if</span> (policy-&gt;id == policy_id) {
			<span class="enscript-keyword">return</span> (policy);
		}
	}

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> inline u_int8_t
<span class="enscript-function-name">necp_policy_get_result_type</span>(<span class="enscript-type">struct</span> necp_session_policy *policy)
{
	<span class="enscript-keyword">return</span> (policy ? necp_policy_result_get_type_from_buffer(policy-&gt;result, policy-&gt;result_size) : 0);
}

<span class="enscript-type">static</span> inline u_int32_t
<span class="enscript-function-name">necp_policy_get_result_parameter_length</span>(<span class="enscript-type">struct</span> necp_session_policy *policy)
{
	<span class="enscript-keyword">return</span> (policy ? necp_policy_result_get_parameter_length_from_buffer(policy-&gt;result, policy-&gt;result_size) : 0);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_policy_get_result_parameter</span>(<span class="enscript-type">struct</span> necp_session_policy *policy, u_int8_t *parameter_buffer, u_int32_t parameter_buffer_length)
{
	<span class="enscript-keyword">if</span> (policy) {
		u_int32_t parameter_length = necp_policy_result_get_parameter_length_from_buffer(policy-&gt;result, policy-&gt;result_size);
		<span class="enscript-keyword">if</span> (parameter_buffer_length &gt;= parameter_length) {
			u_int8_t *parameter = necp_policy_result_get_parameter_pointer_from_buffer(policy-&gt;result, policy-&gt;result_size);
			<span class="enscript-keyword">if</span> (parameter &amp;&amp; parameter_buffer) {
				memcpy(parameter_buffer, parameter, parameter_length);
				<span class="enscript-keyword">return</span> (TRUE);
			}
		}
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_policy_mark_for_deletion</span>(<span class="enscript-type">struct</span> necp_session *session, <span class="enscript-type">struct</span> necp_session_policy *policy)
{
	<span class="enscript-keyword">if</span> (session == NULL || policy == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	policy-&gt;pending_deletion = TRUE;
	session-&gt;dirty = TRUE;

	<span class="enscript-keyword">if</span> (necp_debug) {
		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Marked NECP policy for removal&quot;</span>);
	}
	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_policy_mark_all_for_deletion</span>(<span class="enscript-type">struct</span> necp_session *session)
{
	<span class="enscript-type">struct</span> necp_session_policy *policy = NULL;
	<span class="enscript-type">struct</span> necp_session_policy *temp_policy = NULL;

	LIST_FOREACH_SAFE(policy, &amp;session-&gt;policies, chain, temp_policy) {
		necp_policy_mark_for_deletion(session, policy);
	}

	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_policy_delete</span>(<span class="enscript-type">struct</span> necp_session *session, <span class="enscript-type">struct</span> necp_session_policy *policy)
{
	<span class="enscript-keyword">if</span> (session == NULL || policy == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	LIST_REMOVE(policy, chain);

	<span class="enscript-keyword">if</span> (policy-&gt;result) {
		FREE(policy-&gt;result, M_NECP);
		policy-&gt;result = NULL;
	}

	<span class="enscript-keyword">if</span> (policy-&gt;conditions) {
		FREE(policy-&gt;conditions, M_NECP);
		policy-&gt;conditions = NULL;
	}

	FREE_ZONE(policy, <span class="enscript-keyword">sizeof</span>(*policy), M_NECP_SESSION_POLICY);

	<span class="enscript-keyword">if</span> (necp_debug) {
		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Removed NECP policy&quot;</span>);
	}
	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_policy_unapply</span>(<span class="enscript-type">struct</span> necp_session_policy *policy)
{
	<span class="enscript-type">int</span> i = 0;
	<span class="enscript-keyword">if</span> (policy == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	<span class="enscript-comment">// Release local uuid mappings
</span>	<span class="enscript-keyword">if</span> (!uuid_is_null(policy-&gt;applied_app_uuid)) {
		bool removed_mapping = FALSE;
		<span class="enscript-keyword">if</span> (necp_remove_uuid_app_id_mapping(policy-&gt;applied_app_uuid, &amp;removed_mapping, TRUE) &amp;&amp; removed_mapping) {
			necp_uuid_app_id_mappings_dirty = TRUE;
			necp_num_uuid_app_id_mappings--;
		}
		uuid_clear(policy-&gt;applied_app_uuid);
	}
	<span class="enscript-keyword">if</span> (!uuid_is_null(policy-&gt;applied_real_app_uuid)) {
		necp_remove_uuid_app_id_mapping(policy-&gt;applied_real_app_uuid, NULL, FALSE);
		uuid_clear(policy-&gt;applied_real_app_uuid);
	}
	<span class="enscript-keyword">if</span> (!uuid_is_null(policy-&gt;applied_result_uuid)) {
		necp_remove_uuid_service_id_mapping(policy-&gt;applied_result_uuid);
		uuid_clear(policy-&gt;applied_result_uuid);
	}

	<span class="enscript-comment">// Release string mappings
</span>	<span class="enscript-keyword">if</span> (policy-&gt;applied_account != NULL) {
		necp_remove_string_to_id_mapping(&amp;necp_account_id_list, policy-&gt;applied_account);
		FREE(policy-&gt;applied_account, M_NECP);
		policy-&gt;applied_account = NULL;
	}

	<span class="enscript-comment">// Release route rule
</span>	<span class="enscript-keyword">if</span> (policy-&gt;applied_route_rules_id != 0) {
		necp_remove_route_rule(&amp;necp_route_rules, policy-&gt;applied_route_rules_id);
		policy-&gt;applied_route_rules_id = 0;
	}

	<span class="enscript-comment">// Remove socket policies
</span>	<span class="enscript-keyword">for</span> (i = 0; i &lt; MAX_KERNEL_SOCKET_POLICIES; i++) {
		<span class="enscript-keyword">if</span> (policy-&gt;kernel_socket_policies[i] != 0) {
			necp_kernel_socket_policy_delete(policy-&gt;kernel_socket_policies[i]);
			policy-&gt;kernel_socket_policies[i] = 0;
		}
	}

	<span class="enscript-comment">// Remove IP output policies
</span>	<span class="enscript-keyword">for</span> (i = 0; i &lt; MAX_KERNEL_IP_OUTPUT_POLICIES; i++) {
		<span class="enscript-keyword">if</span> (policy-&gt;kernel_ip_output_policies[i] != 0) {
			necp_kernel_ip_output_policy_delete(policy-&gt;kernel_ip_output_policies[i]);
			policy-&gt;kernel_ip_output_policies[i] = 0;
		}
	}

	policy-&gt;applied = FALSE;

	<span class="enscript-keyword">return</span> (TRUE);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_POLICY_SUBORDER_ID_TUNNEL_CONDITION</span>			0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_POLICY_SUBORDER_NON_ID_TUNNEL_CONDITION</span>		1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_POLICY_SUBORDER_ID_CONDITION</span>				2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_POLICY_SUBORDER_NON_ID_CONDITIONS</span>			3
<span class="enscript-type">struct</span> necp_policy_result_ip_tunnel {
	u_int32_t secondary_result;
	<span class="enscript-type">char</span> interface_name[IFXNAMSIZ];
} __attribute__((__packed__));

<span class="enscript-type">struct</span> necp_policy_result_service {
	uuid_t identifier;
	u_int32_t data;
} __attribute__((__packed__));

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_policy_apply</span>(<span class="enscript-type">struct</span> necp_session *session, <span class="enscript-type">struct</span> necp_session_policy *policy)
{
	bool socket_only_conditions = FALSE;
	bool socket_ip_conditions = FALSE;

	bool socket_layer_non_id_conditions = FALSE;
	bool ip_output_layer_non_id_conditions = FALSE;
	bool ip_output_layer_id_condition = FALSE;
	bool ip_output_layer_tunnel_condition_from_id = FALSE;
	bool ip_output_layer_tunnel_condition_from_non_id = FALSE;
	necp_kernel_policy_id cond_ip_output_layer_id = NECP_KERNEL_POLICY_ID_NONE;

	u_int32_t master_condition_mask = 0;
	u_int32_t master_condition_negated_mask = 0;
	ifnet_t cond_bound_interface = NULL;
	u_int32_t cond_account_id = 0;
	<span class="enscript-type">char</span> *cond_domain = NULL;
	pid_t cond_pid = 0;
	uid_t cond_uid = 0;
	necp_app_id cond_app_id = 0;
	necp_app_id cond_real_app_id = 0;
	<span class="enscript-type">struct</span> necp_policy_condition_tc_range cond_traffic_class;
	cond_traffic_class.start_tc = 0;
	cond_traffic_class.end_tc = 0;
	u_int16_t cond_protocol = 0;
	<span class="enscript-type">union</span> necp_sockaddr_union cond_local_start;
	<span class="enscript-type">union</span> necp_sockaddr_union cond_local_end;
	u_int8_t cond_local_prefix = 0;
	<span class="enscript-type">union</span> necp_sockaddr_union cond_remote_start;
	<span class="enscript-type">union</span> necp_sockaddr_union cond_remote_end;
	u_int8_t cond_remote_prefix = 0;
	u_int32_t offset = 0;
	u_int8_t ultimate_result = 0;
	u_int32_t secondary_result = 0;
	necp_kernel_policy_result_parameter secondary_result_parameter;
	memset(&amp;secondary_result_parameter, 0, <span class="enscript-keyword">sizeof</span>(secondary_result_parameter));
	u_int32_t cond_last_interface_index = 0;
	necp_kernel_policy_result_parameter ultimate_result_parameter;
	memset(&amp;ultimate_result_parameter, 0, <span class="enscript-keyword">sizeof</span>(ultimate_result_parameter));

	<span class="enscript-keyword">if</span> (policy == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	<span class="enscript-comment">// Process conditions
</span>	<span class="enscript-keyword">while</span> (offset &lt; policy-&gt;conditions_size) {
		u_int32_t length = 0;
		u_int8_t *value = necp_buffer_get_tlv_value(policy-&gt;conditions, offset, &amp;length);

		u_int8_t condition_type = necp_policy_condition_get_type_from_buffer(value, length);
		u_int8_t condition_flags = necp_policy_condition_get_flags_from_buffer(value, length);
		bool condition_is_negative = condition_flags &amp; NECP_POLICY_CONDITION_FLAGS_NEGATIVE;
		u_int32_t condition_length = necp_policy_condition_get_value_length_from_buffer(value, length);
		u_int8_t *condition_value = necp_policy_condition_get_value_pointer_from_buffer(value, length);
		<span class="enscript-keyword">switch</span> (condition_type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_DEFAULT</span>: {
				socket_ip_conditions = TRUE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_ALL_INTERFACES</span>: {
				master_condition_mask |= NECP_KERNEL_CONDITION_ALL_INTERFACES;
				socket_ip_conditions = TRUE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_ENTITLEMENT</span>: {
				master_condition_mask |= NECP_KERNEL_CONDITION_ENTITLEMENT;
				socket_only_conditions = TRUE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_DOMAIN</span>: {
				<span class="enscript-comment">// Make sure there is only one such rule
</span>				<span class="enscript-keyword">if</span> (condition_length &gt; 0 &amp;&amp; cond_domain == NULL) {
					cond_domain = necp_create_trimmed_domain((<span class="enscript-type">char</span> *)condition_value, condition_length);
					<span class="enscript-keyword">if</span> (cond_domain != NULL) {
						master_condition_mask |= NECP_KERNEL_CONDITION_DOMAIN;
						<span class="enscript-keyword">if</span> (condition_is_negative) {
							master_condition_negated_mask |= NECP_KERNEL_CONDITION_DOMAIN;
						}
						socket_only_conditions = TRUE;
					}
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_ACCOUNT</span>: {
				<span class="enscript-comment">// Make sure there is only one such rule
</span>				<span class="enscript-keyword">if</span> (condition_length &gt; 0 &amp;&amp; cond_account_id == 0 &amp;&amp; policy-&gt;applied_account == NULL) {
					<span class="enscript-type">char</span> *string = NULL;
					MALLOC(string, <span class="enscript-type">char</span> *, condition_length + 1, M_NECP, M_WAITOK);
					<span class="enscript-keyword">if</span> (string != NULL) {
						memcpy(string, condition_value, condition_length);
						string[condition_length] = 0;
						cond_account_id = necp_create_string_to_id_mapping(&amp;necp_account_id_list, string);
						<span class="enscript-keyword">if</span> (cond_account_id != 0) {
							policy-&gt;applied_account = string; <span class="enscript-comment">// Save the string in parent policy
</span>							master_condition_mask |= NECP_KERNEL_CONDITION_ACCOUNT_ID;
							<span class="enscript-keyword">if</span> (condition_is_negative) {
								master_condition_negated_mask |= NECP_KERNEL_CONDITION_ACCOUNT_ID;
							}
							socket_only_conditions = TRUE;
						} <span class="enscript-keyword">else</span> {
							FREE(string, M_NECP);
						}
					}
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_APPLICATION</span>: {
				<span class="enscript-comment">// Make sure there is only one such rule, because we save the uuid in the policy
</span>				<span class="enscript-keyword">if</span> (condition_length &gt;= <span class="enscript-keyword">sizeof</span>(uuid_t) &amp;&amp; cond_app_id == 0) {
					bool allocated_mapping = FALSE;
					uuid_t application_uuid;
					memcpy(application_uuid, condition_value, <span class="enscript-keyword">sizeof</span>(uuid_t));
					cond_app_id = necp_create_uuid_app_id_mapping(application_uuid, &amp;allocated_mapping, TRUE);
					<span class="enscript-keyword">if</span> (cond_app_id != 0) {
						<span class="enscript-keyword">if</span> (allocated_mapping) {
							necp_uuid_app_id_mappings_dirty = TRUE;
							necp_num_uuid_app_id_mappings++;
						}
						uuid_copy(policy-&gt;applied_app_uuid, application_uuid);
						master_condition_mask |= NECP_KERNEL_CONDITION_APP_ID;
						<span class="enscript-keyword">if</span> (condition_is_negative) {
							master_condition_negated_mask |= NECP_KERNEL_CONDITION_APP_ID;
						}
						socket_only_conditions = TRUE;
					}
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_REAL_APPLICATION</span>: {
				<span class="enscript-comment">// Make sure there is only one such rule, because we save the uuid in the policy
</span>				<span class="enscript-keyword">if</span> (condition_length &gt;= <span class="enscript-keyword">sizeof</span>(uuid_t) &amp;&amp; cond_real_app_id == 0) {
					uuid_t real_application_uuid;
					memcpy(real_application_uuid, condition_value, <span class="enscript-keyword">sizeof</span>(uuid_t));
					cond_real_app_id = necp_create_uuid_app_id_mapping(real_application_uuid, NULL, FALSE);
					<span class="enscript-keyword">if</span> (cond_real_app_id != 0) {
						uuid_copy(policy-&gt;applied_real_app_uuid, real_application_uuid);
						master_condition_mask |= NECP_KERNEL_CONDITION_REAL_APP_ID;
						<span class="enscript-keyword">if</span> (condition_is_negative) {
							master_condition_negated_mask |= NECP_KERNEL_CONDITION_REAL_APP_ID;
						}
						socket_only_conditions = TRUE;
					}
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_PID</span>: {
				<span class="enscript-keyword">if</span> (condition_length &gt;= <span class="enscript-keyword">sizeof</span>(pid_t)) {
					master_condition_mask |= NECP_KERNEL_CONDITION_PID;
					<span class="enscript-keyword">if</span> (condition_is_negative) {
						master_condition_negated_mask |= NECP_KERNEL_CONDITION_PID;
					}
					memcpy(&amp;cond_pid, condition_value, <span class="enscript-keyword">sizeof</span>(cond_pid));
					socket_only_conditions = TRUE;
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_UID</span>: {
				<span class="enscript-keyword">if</span> (condition_length &gt;= <span class="enscript-keyword">sizeof</span>(uid_t)) {
					master_condition_mask |= NECP_KERNEL_CONDITION_UID;
					<span class="enscript-keyword">if</span> (condition_is_negative) {
						master_condition_negated_mask |= NECP_KERNEL_CONDITION_UID;
					}
					memcpy(&amp;cond_uid, condition_value, <span class="enscript-keyword">sizeof</span>(cond_uid));
					socket_only_conditions = TRUE;
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_TRAFFIC_CLASS</span>: {
				<span class="enscript-keyword">if</span> (condition_length &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_policy_condition_tc_range)) {
					master_condition_mask |= NECP_KERNEL_CONDITION_TRAFFIC_CLASS;
					<span class="enscript-keyword">if</span> (condition_is_negative) {
						master_condition_negated_mask |= NECP_KERNEL_CONDITION_TRAFFIC_CLASS;
					}
					memcpy(&amp;cond_traffic_class, condition_value, <span class="enscript-keyword">sizeof</span>(cond_traffic_class));
					socket_only_conditions = TRUE;
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_BOUND_INTERFACE</span>: {
				<span class="enscript-keyword">if</span> (condition_length &lt;= IFXNAMSIZ &amp;&amp; condition_length &gt; 0) {
					<span class="enscript-type">char</span> interface_name[IFXNAMSIZ];
					memcpy(interface_name, condition_value, condition_length);
					interface_name[condition_length - 1] = 0; <span class="enscript-comment">// Make sure the string is NULL terminated
</span>					<span class="enscript-keyword">if</span> (ifnet_find_by_name(interface_name, &amp;cond_bound_interface) == 0) {
						master_condition_mask |= NECP_KERNEL_CONDITION_BOUND_INTERFACE;
						<span class="enscript-keyword">if</span> (condition_is_negative) {
							master_condition_negated_mask |= NECP_KERNEL_CONDITION_BOUND_INTERFACE;
						}
					}
					socket_ip_conditions = TRUE;
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_IP_PROTOCOL</span>: {
				<span class="enscript-keyword">if</span> (condition_length &gt;= <span class="enscript-keyword">sizeof</span>(u_int16_t)) {
					master_condition_mask |= NECP_KERNEL_CONDITION_PROTOCOL;
					<span class="enscript-keyword">if</span> (condition_is_negative) {
						master_condition_negated_mask |= NECP_KERNEL_CONDITION_PROTOCOL;
					}
					memcpy(&amp;cond_protocol, condition_value, <span class="enscript-keyword">sizeof</span>(cond_protocol));
					socket_ip_conditions = TRUE;
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_LOCAL_ADDR</span>: {
				<span class="enscript-type">struct</span> necp_policy_condition_addr *address_struct = (<span class="enscript-type">struct</span> necp_policy_condition_addr *)(<span class="enscript-type">void</span> *)condition_value;
				cond_local_prefix = address_struct-&gt;prefix;
				memcpy(&amp;cond_local_start, &amp;address_struct-&gt;address, <span class="enscript-keyword">sizeof</span>(address_struct-&gt;address));
				master_condition_mask |= NECP_KERNEL_CONDITION_LOCAL_START;
				master_condition_mask |= NECP_KERNEL_CONDITION_LOCAL_PREFIX;
				<span class="enscript-keyword">if</span> (condition_is_negative) {
					master_condition_negated_mask |= NECP_KERNEL_CONDITION_LOCAL_START;
					master_condition_negated_mask |= NECP_KERNEL_CONDITION_LOCAL_PREFIX;
				}
				socket_ip_conditions = TRUE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_REMOTE_ADDR</span>: {
				<span class="enscript-type">struct</span> necp_policy_condition_addr *address_struct = (<span class="enscript-type">struct</span> necp_policy_condition_addr *)(<span class="enscript-type">void</span> *)condition_value;
				cond_remote_prefix = address_struct-&gt;prefix;
				memcpy(&amp;cond_remote_start, &amp;address_struct-&gt;address, <span class="enscript-keyword">sizeof</span>(address_struct-&gt;address));
				master_condition_mask |= NECP_KERNEL_CONDITION_REMOTE_START;
				master_condition_mask |= NECP_KERNEL_CONDITION_REMOTE_PREFIX;
				<span class="enscript-keyword">if</span> (condition_is_negative) {
					master_condition_negated_mask |= NECP_KERNEL_CONDITION_REMOTE_START;
					master_condition_negated_mask |= NECP_KERNEL_CONDITION_REMOTE_PREFIX;
				}
				socket_ip_conditions = TRUE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_LOCAL_ADDR_RANGE</span>: {
				<span class="enscript-type">struct</span> necp_policy_condition_addr_range *address_struct = (<span class="enscript-type">struct</span> necp_policy_condition_addr_range *)(<span class="enscript-type">void</span> *)condition_value;
				memcpy(&amp;cond_local_start, &amp;address_struct-&gt;start_address, <span class="enscript-keyword">sizeof</span>(address_struct-&gt;start_address));
				memcpy(&amp;cond_local_end, &amp;address_struct-&gt;end_address, <span class="enscript-keyword">sizeof</span>(address_struct-&gt;end_address));
				master_condition_mask |= NECP_KERNEL_CONDITION_LOCAL_START;
				master_condition_mask |= NECP_KERNEL_CONDITION_LOCAL_END;
				<span class="enscript-keyword">if</span> (condition_is_negative) {
					master_condition_negated_mask |= NECP_KERNEL_CONDITION_LOCAL_START;
					master_condition_negated_mask |= NECP_KERNEL_CONDITION_LOCAL_END;
				}
				socket_ip_conditions = TRUE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_REMOTE_ADDR_RANGE</span>: {
				<span class="enscript-type">struct</span> necp_policy_condition_addr_range *address_struct = (<span class="enscript-type">struct</span> necp_policy_condition_addr_range *)(<span class="enscript-type">void</span> *)condition_value;
				memcpy(&amp;cond_remote_start, &amp;address_struct-&gt;start_address, <span class="enscript-keyword">sizeof</span>(address_struct-&gt;start_address));
				memcpy(&amp;cond_remote_end, &amp;address_struct-&gt;end_address, <span class="enscript-keyword">sizeof</span>(address_struct-&gt;end_address));
				master_condition_mask |= NECP_KERNEL_CONDITION_REMOTE_START;
				master_condition_mask |= NECP_KERNEL_CONDITION_REMOTE_END;
				<span class="enscript-keyword">if</span> (condition_is_negative) {
					master_condition_negated_mask |= NECP_KERNEL_CONDITION_REMOTE_START;
					master_condition_negated_mask |= NECP_KERNEL_CONDITION_REMOTE_END;
				}
				socket_ip_conditions = TRUE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-reference">default</span>: {
				<span class="enscript-keyword">break</span>;
			}
		}

		offset += <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + length;
	}

	<span class="enscript-comment">// Process result
</span>	ultimate_result = necp_policy_get_result_type(policy);
	<span class="enscript-keyword">switch</span> (ultimate_result) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_PASS</span>: {
			<span class="enscript-keyword">if</span> (socket_only_conditions) { <span class="enscript-comment">// socket_ip_conditions can be TRUE or FALSE
</span>				socket_layer_non_id_conditions = TRUE;
				ip_output_layer_id_condition = TRUE;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (socket_ip_conditions) {
				socket_layer_non_id_conditions = TRUE;
				ip_output_layer_id_condition = TRUE;
				ip_output_layer_non_id_conditions = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_DROP</span>: {
			<span class="enscript-keyword">if</span> (socket_only_conditions) { <span class="enscript-comment">// socket_ip_conditions can be TRUE or FALSE
</span>				socket_layer_non_id_conditions = TRUE;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (socket_ip_conditions) {
				socket_layer_non_id_conditions = TRUE;
				ip_output_layer_non_id_conditions = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_SKIP</span>: {
			u_int32_t skip_policy_order = 0;
			<span class="enscript-keyword">if</span> (necp_policy_get_result_parameter(policy, (u_int8_t *)&amp;skip_policy_order, <span class="enscript-keyword">sizeof</span>(skip_policy_order))) {
				ultimate_result_parameter.skip_policy_order = skip_policy_order;
			}

			<span class="enscript-keyword">if</span> (socket_only_conditions) { <span class="enscript-comment">// socket_ip_conditions can be TRUE or FALSE
</span>				socket_layer_non_id_conditions = TRUE;
				ip_output_layer_id_condition = TRUE;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (socket_ip_conditions) {
				socket_layer_non_id_conditions = TRUE;
				ip_output_layer_non_id_conditions = TRUE;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_SOCKET_DIVERT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_SOCKET_FILTER</span>: {
			u_int32_t control_unit = 0;
			<span class="enscript-keyword">if</span> (necp_policy_get_result_parameter(policy, (u_int8_t *)&amp;control_unit, <span class="enscript-keyword">sizeof</span>(control_unit))) {
				ultimate_result_parameter.flow_divert_control_unit = control_unit;
			}
			socket_layer_non_id_conditions = TRUE;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_IP_TUNNEL</span>: {
			<span class="enscript-type">struct</span> necp_policy_result_ip_tunnel tunnel_parameters;
			u_int32_t tunnel_parameters_length = necp_policy_get_result_parameter_length(policy);
			<span class="enscript-keyword">if</span> (tunnel_parameters_length &gt; <span class="enscript-keyword">sizeof</span>(u_int32_t) &amp;&amp;
				tunnel_parameters_length &lt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_policy_result_ip_tunnel) &amp;&amp;
				necp_policy_get_result_parameter(policy, (u_int8_t *)&amp;tunnel_parameters, <span class="enscript-keyword">sizeof</span>(tunnel_parameters))) {
				ifnet_t tunnel_interface = NULL;
				tunnel_parameters.interface_name[tunnel_parameters_length - <span class="enscript-keyword">sizeof</span>(u_int32_t) - 1] = 0; <span class="enscript-comment">// Make sure the string is NULL terminated
</span>				<span class="enscript-keyword">if</span> (ifnet_find_by_name(tunnel_parameters.interface_name, &amp;tunnel_interface) == 0) {
					ultimate_result_parameter.tunnel_interface_index = tunnel_interface-&gt;if_index;
				}

				secondary_result = tunnel_parameters.secondary_result;
				<span class="enscript-keyword">if</span> (secondary_result) {
					cond_last_interface_index = ultimate_result_parameter.tunnel_interface_index;
				}
			}

			<span class="enscript-keyword">if</span> (socket_only_conditions) { <span class="enscript-comment">// socket_ip_conditions can be TRUE or FALSE
</span>				socket_layer_non_id_conditions = TRUE;
				ip_output_layer_id_condition = TRUE;
				<span class="enscript-keyword">if</span> (secondary_result) {
					ip_output_layer_tunnel_condition_from_id = TRUE;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (socket_ip_conditions) {
				socket_layer_non_id_conditions = TRUE;
				ip_output_layer_id_condition = TRUE;
				ip_output_layer_non_id_conditions = TRUE;
				<span class="enscript-keyword">if</span> (secondary_result) {
					ip_output_layer_tunnel_condition_from_id = TRUE;
					ip_output_layer_tunnel_condition_from_non_id = TRUE;
				}
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_TRIGGER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_TRIGGER_IF_NEEDED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_TRIGGER_SCOPED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_NO_TRIGGER_SCOPED</span>: {
			<span class="enscript-type">struct</span> necp_policy_result_service service_parameters;
			u_int32_t service_result_length = necp_policy_get_result_parameter_length(policy);
			bool has_extra_service_data = FALSE;
			<span class="enscript-keyword">if</span> (service_result_length &gt;= (<span class="enscript-keyword">sizeof</span>(service_parameters))) {
				has_extra_service_data = TRUE;
			}
			<span class="enscript-keyword">if</span> (necp_policy_get_result_parameter(policy, (u_int8_t *)&amp;service_parameters, <span class="enscript-keyword">sizeof</span>(service_parameters))) {
				ultimate_result_parameter.service.identifier = necp_create_uuid_service_id_mapping(service_parameters.identifier);
				<span class="enscript-keyword">if</span> (ultimate_result_parameter.service.identifier != 0) {
					uuid_copy(policy-&gt;applied_result_uuid, service_parameters.identifier);
					socket_layer_non_id_conditions = TRUE;
					<span class="enscript-keyword">if</span> (has_extra_service_data) {
						ultimate_result_parameter.service.data = service_parameters.data;
					} <span class="enscript-keyword">else</span> {
						ultimate_result_parameter.service.data = 0;
					}
				}
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_USE_NETAGENT</span>: {
			uuid_t netagent_uuid;
			<span class="enscript-keyword">if</span> (necp_policy_get_result_parameter(policy, (u_int8_t *)&amp;netagent_uuid, <span class="enscript-keyword">sizeof</span>(netagent_uuid))) {
				ultimate_result_parameter.netagent_id = necp_create_uuid_service_id_mapping(netagent_uuid);
				<span class="enscript-keyword">if</span> (ultimate_result_parameter.netagent_id != 0) {
					uuid_copy(policy-&gt;applied_result_uuid, netagent_uuid);
					socket_layer_non_id_conditions = TRUE;
				}
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_SOCKET_SCOPED</span>: {
			u_int32_t interface_name_length = necp_policy_get_result_parameter_length(policy);
			<span class="enscript-keyword">if</span> (interface_name_length &lt;= IFXNAMSIZ &amp;&amp; interface_name_length &gt; 0) {
				<span class="enscript-type">char</span> interface_name[IFXNAMSIZ];
				ifnet_t scope_interface = NULL;
				necp_policy_get_result_parameter(policy, (u_int8_t *)interface_name, interface_name_length);
				interface_name[interface_name_length - 1] = 0; <span class="enscript-comment">// Make sure the string is NULL terminated
</span>				<span class="enscript-keyword">if</span> (ifnet_find_by_name(interface_name, &amp;scope_interface) == 0) {
					ultimate_result_parameter.scoped_interface_index = scope_interface-&gt;if_index;
					socket_layer_non_id_conditions = TRUE;
				}
			}
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_ROUTE_RULES</span>: {
			<span class="enscript-keyword">if</span> (policy-&gt;route_rules != NULL &amp;&amp; policy-&gt;route_rules_size &gt; 0) {
				u_int32_t route_rule_id = necp_create_route_rule(&amp;necp_route_rules, policy-&gt;route_rules, policy-&gt;route_rules_size);
				<span class="enscript-keyword">if</span> (route_rule_id &gt; 0) {
					policy-&gt;applied_route_rules_id = route_rule_id;
					ultimate_result_parameter.route_rule_id = route_rule_id;
					socket_layer_non_id_conditions = TRUE;
				}
			}
		}
		<span class="enscript-reference">default</span>: {
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (socket_layer_non_id_conditions) {
		necp_kernel_policy_id policy_id = necp_kernel_socket_policy_add(policy-&gt;id, policy-&gt;order, session-&gt;session_order, session-&gt;proc_pid, master_condition_mask, master_condition_negated_mask, cond_app_id, cond_real_app_id, cond_account_id, cond_domain, cond_pid, cond_uid, cond_bound_interface, cond_traffic_class, cond_protocol, &amp;cond_local_start, &amp;cond_local_end, cond_local_prefix, &amp;cond_remote_start, &amp;cond_remote_end, cond_remote_prefix, ultimate_result, ultimate_result_parameter);

		<span class="enscript-keyword">if</span> (policy_id == 0) {
			NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Error applying socket kernel policy&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}

		cond_ip_output_layer_id = policy_id;
		policy-&gt;kernel_socket_policies[0] = policy_id;
	}

	<span class="enscript-keyword">if</span> (ip_output_layer_non_id_conditions) {
		necp_kernel_policy_id policy_id = necp_kernel_ip_output_policy_add(policy-&gt;id, policy-&gt;order, NECP_KERNEL_POLICY_SUBORDER_NON_ID_CONDITIONS, session-&gt;session_order, session-&gt;proc_pid, master_condition_mask, master_condition_negated_mask, NECP_KERNEL_POLICY_ID_NONE, cond_bound_interface, 0, cond_protocol, &amp;cond_local_start, &amp;cond_local_end, cond_local_prefix, &amp;cond_remote_start, &amp;cond_remote_end, cond_remote_prefix, ultimate_result, ultimate_result_parameter);

		<span class="enscript-keyword">if</span> (policy_id == 0) {
			NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Error applying IP output kernel policy&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}

		policy-&gt;kernel_ip_output_policies[NECP_KERNEL_POLICY_SUBORDER_NON_ID_CONDITIONS] = policy_id;
	}

	<span class="enscript-keyword">if</span> (ip_output_layer_id_condition) {
		necp_kernel_policy_id policy_id = necp_kernel_ip_output_policy_add(policy-&gt;id, policy-&gt;order, NECP_KERNEL_POLICY_SUBORDER_ID_CONDITION, session-&gt;session_order, session-&gt;proc_pid, NECP_KERNEL_CONDITION_POLICY_ID | NECP_KERNEL_CONDITION_ALL_INTERFACES, 0, cond_ip_output_layer_id, NULL, 0, 0, NULL, NULL, 0, NULL, NULL, 0, ultimate_result, ultimate_result_parameter);

		<span class="enscript-keyword">if</span> (policy_id == 0) {
			NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Error applying IP output kernel policy&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}

		policy-&gt;kernel_ip_output_policies[NECP_KERNEL_POLICY_SUBORDER_ID_CONDITION] = policy_id;
	}

	<span class="enscript-comment">// Extra policies for IP Output tunnels for when packets loop back
</span>	<span class="enscript-keyword">if</span> (ip_output_layer_tunnel_condition_from_id) {
		necp_kernel_policy_id policy_id = necp_kernel_ip_output_policy_add(policy-&gt;id, policy-&gt;order, NECP_KERNEL_POLICY_SUBORDER_NON_ID_TUNNEL_CONDITION, session-&gt;session_order, session-&gt;proc_pid, NECP_KERNEL_CONDITION_POLICY_ID | NECP_KERNEL_CONDITION_LAST_INTERFACE | NECP_KERNEL_CONDITION_ALL_INTERFACES, 0, policy-&gt;kernel_ip_output_policies[NECP_KERNEL_POLICY_SUBORDER_NON_ID_CONDITIONS], NULL, cond_last_interface_index, 0, NULL, NULL, 0, NULL, NULL, 0, secondary_result, secondary_result_parameter);

		<span class="enscript-keyword">if</span> (policy_id == 0) {
			NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Error applying IP output kernel policy&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}

		policy-&gt;kernel_ip_output_policies[NECP_KERNEL_POLICY_SUBORDER_NON_ID_TUNNEL_CONDITION] = policy_id;
	}

	<span class="enscript-keyword">if</span> (ip_output_layer_tunnel_condition_from_id) {
		necp_kernel_policy_id policy_id = necp_kernel_ip_output_policy_add(policy-&gt;id, policy-&gt;order, NECP_KERNEL_POLICY_SUBORDER_ID_TUNNEL_CONDITION, session-&gt;session_order, session-&gt;proc_pid, NECP_KERNEL_CONDITION_POLICY_ID | NECP_KERNEL_CONDITION_LAST_INTERFACE | NECP_KERNEL_CONDITION_ALL_INTERFACES, 0, policy-&gt;kernel_ip_output_policies[NECP_KERNEL_POLICY_SUBORDER_ID_CONDITION], NULL, cond_last_interface_index, 0, NULL, NULL, 0, NULL, NULL, 0, secondary_result, secondary_result_parameter);

		<span class="enscript-keyword">if</span> (policy_id == 0) {
			NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Error applying IP output kernel policy&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}

		policy-&gt;kernel_ip_output_policies[NECP_KERNEL_POLICY_SUBORDER_ID_TUNNEL_CONDITION] = policy_id;
	}

	policy-&gt;applied = TRUE;
	policy-&gt;pending_update = FALSE;
	<span class="enscript-keyword">return</span> (TRUE);

<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_policy_apply_all</span>(<span class="enscript-type">struct</span> necp_session *session)
{
	<span class="enscript-type">struct</span> necp_session_policy *policy = NULL;
	<span class="enscript-type">struct</span> necp_session_policy *temp_policy = NULL;
	<span class="enscript-type">struct</span> kev_necp_policies_changed_data kev_data;
	kev_data.changed_count = 0;

	lck_rw_lock_exclusive(&amp;necp_kernel_policy_lock);

	<span class="enscript-comment">// Remove exisiting applied policies
</span>	<span class="enscript-keyword">if</span> (session-&gt;dirty) {
		LIST_FOREACH_SAFE(policy, &amp;session-&gt;policies, chain, temp_policy) {
			<span class="enscript-keyword">if</span> (policy-&gt;pending_deletion) {
				<span class="enscript-keyword">if</span> (policy-&gt;applied) {
					necp_policy_unapply(policy);
				}
				<span class="enscript-comment">// Delete the policy
</span>				necp_policy_delete(session, policy);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!policy-&gt;applied) {
				necp_policy_apply(session, policy);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (policy-&gt;pending_update) {
				<span class="enscript-comment">// Must have been applied, but needs an update. Remove and re-add.
</span>				necp_policy_unapply(policy);
				necp_policy_apply(session, policy);
			}
		}

		necp_kernel_socket_policies_update_uuid_table();
		necp_kernel_socket_policies_reprocess();
		necp_kernel_ip_output_policies_reprocess();

		<span class="enscript-comment">// Clear dirty bit flags
</span>		session-&gt;dirty = FALSE;
	}

	lck_rw_done(&amp;necp_kernel_policy_lock);

	necp_post_change_event(&amp;kev_data);

	<span class="enscript-keyword">if</span> (necp_debug) {
		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Applied NECP policies&quot;</span>);
	}
}

<span class="enscript-comment">// Kernel Policy Management
</span><span class="enscript-comment">// ---------------------
</span><span class="enscript-comment">// Kernel policies are derived from session policies
</span><span class="enscript-type">static</span> necp_kernel_policy_id
<span class="enscript-function-name">necp_kernel_policy_get_new_id</span>(<span class="enscript-type">void</span>)
{
	necp_kernel_policy_id newid = NECP_KERNEL_POLICY_ID_NONE;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	necp_last_kernel_policy_id++;
	<span class="enscript-keyword">if</span> (necp_last_kernel_policy_id &lt; NECP_KERNEL_POLICY_ID_FIRST_VALID) {
		necp_last_kernel_policy_id = NECP_KERNEL_POLICY_ID_FIRST_VALID;
	}

	newid = necp_last_kernel_policy_id;
	<span class="enscript-keyword">if</span> (newid == NECP_KERNEL_POLICY_ID_NONE) {
		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Allocate kernel policy id failed.\n&quot;</span>);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (newid);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_VALID_SOCKET_CONDITIONS</span> (NECP_KERNEL_CONDITION_APP_ID | NECP_KERNEL_CONDITION_REAL_APP_ID | NECP_KERNEL_CONDITION_DOMAIN | NECP_KERNEL_CONDITION_ACCOUNT_ID | NECP_KERNEL_CONDITION_PID | NECP_KERNEL_CONDITION_UID | NECP_KERNEL_CONDITION_ALL_INTERFACES | NECP_KERNEL_CONDITION_BOUND_INTERFACE | NECP_KERNEL_CONDITION_TRAFFIC_CLASS | NECP_KERNEL_CONDITION_PROTOCOL | NECP_KERNEL_CONDITION_LOCAL_START | NECP_KERNEL_CONDITION_LOCAL_END | NECP_KERNEL_CONDITION_LOCAL_PREFIX | NECP_KERNEL_CONDITION_REMOTE_START | NECP_KERNEL_CONDITION_REMOTE_END | NECP_KERNEL_CONDITION_REMOTE_PREFIX | NECP_KERNEL_CONDITION_ENTITLEMENT)
<span class="enscript-type">static</span> necp_kernel_policy_id
<span class="enscript-function-name">necp_kernel_socket_policy_add</span>(necp_policy_id parent_policy_id, necp_policy_order order, u_int32_t session_order, <span class="enscript-type">int</span> session_pid, u_int32_t condition_mask, u_int32_t condition_negated_mask, necp_app_id cond_app_id, necp_app_id cond_real_app_id, u_int32_t cond_account_id, <span class="enscript-type">char</span> *cond_domain, pid_t cond_pid, uid_t cond_uid, ifnet_t cond_bound_interface, <span class="enscript-type">struct</span> necp_policy_condition_tc_range cond_traffic_class, u_int16_t cond_protocol, <span class="enscript-type">union</span> necp_sockaddr_union *cond_local_start, <span class="enscript-type">union</span> necp_sockaddr_union *cond_local_end, u_int8_t cond_local_prefix, <span class="enscript-type">union</span> necp_sockaddr_union *cond_remote_start, <span class="enscript-type">union</span> necp_sockaddr_union *cond_remote_end, u_int8_t cond_remote_prefix, necp_kernel_policy_result result, necp_kernel_policy_result_parameter result_parameter)
{
	<span class="enscript-type">struct</span> necp_kernel_socket_policy *new_kernel_policy = NULL;
	<span class="enscript-type">struct</span> necp_kernel_socket_policy *tmp_kernel_policy = NULL;

	MALLOC_ZONE(new_kernel_policy, <span class="enscript-type">struct</span> necp_kernel_socket_policy *, <span class="enscript-keyword">sizeof</span>(*new_kernel_policy), M_NECP_SOCKET_POLICY, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_kernel_policy == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	memset(new_kernel_policy, 0, <span class="enscript-keyword">sizeof</span>(*new_kernel_policy));
	new_kernel_policy-&gt;parent_policy_id = parent_policy_id;
	new_kernel_policy-&gt;id = necp_kernel_policy_get_new_id();
	new_kernel_policy-&gt;order = order;
	new_kernel_policy-&gt;session_order = session_order;
	new_kernel_policy-&gt;session_pid = session_pid;

	<span class="enscript-comment">// Sanitize condition mask
</span>	new_kernel_policy-&gt;condition_mask = (condition_mask &amp; NECP_KERNEL_VALID_SOCKET_CONDITIONS);
	<span class="enscript-keyword">if</span> ((new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ALL_INTERFACES) &amp;&amp; (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_BOUND_INTERFACE)) {
		new_kernel_policy-&gt;condition_mask &amp;= ~NECP_KERNEL_CONDITION_BOUND_INTERFACE;
	}
	<span class="enscript-keyword">if</span> ((new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REAL_APP_ID) &amp;&amp; !(new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_APP_ID)) {
		new_kernel_policy-&gt;condition_mask &amp;= ~NECP_KERNEL_CONDITION_REAL_APP_ID;
	}
	<span class="enscript-keyword">if</span> ((new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ENTITLEMENT) &amp;&amp; !(new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_APP_ID)) {
		new_kernel_policy-&gt;condition_mask &amp;= ~NECP_KERNEL_CONDITION_ENTITLEMENT;
	}
	<span class="enscript-keyword">if</span> ((new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_END) &amp;&amp; (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_PREFIX)) {
		new_kernel_policy-&gt;condition_mask &amp;= ~NECP_KERNEL_CONDITION_LOCAL_PREFIX;
	}
	<span class="enscript-keyword">if</span> ((new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_END) &amp;&amp; (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_PREFIX)) {
		new_kernel_policy-&gt;condition_mask &amp;= ~NECP_KERNEL_CONDITION_REMOTE_PREFIX;
	}
	new_kernel_policy-&gt;condition_negated_mask = condition_negated_mask &amp; new_kernel_policy-&gt;condition_mask;

	<span class="enscript-comment">// Set condition values
</span>	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_APP_ID) {
		new_kernel_policy-&gt;cond_app_id = cond_app_id;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REAL_APP_ID) {
		new_kernel_policy-&gt;cond_real_app_id = cond_real_app_id;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ACCOUNT_ID) {
		new_kernel_policy-&gt;cond_account_id = cond_account_id;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_DOMAIN) {
		new_kernel_policy-&gt;cond_domain = cond_domain;
		new_kernel_policy-&gt;cond_domain_dot_count = necp_count_dots(cond_domain, strlen(cond_domain));
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_PID) {
		new_kernel_policy-&gt;cond_pid = cond_pid;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_UID) {
		new_kernel_policy-&gt;cond_uid = cond_uid;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_BOUND_INTERFACE) {
		<span class="enscript-keyword">if</span> (cond_bound_interface) {
			ifnet_reference(cond_bound_interface);
		}
		new_kernel_policy-&gt;cond_bound_interface = cond_bound_interface;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_TRAFFIC_CLASS) {
		new_kernel_policy-&gt;cond_traffic_class = cond_traffic_class;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_PROTOCOL) {
		new_kernel_policy-&gt;cond_protocol = cond_protocol;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_START) {
		memcpy(&amp;new_kernel_policy-&gt;cond_local_start, cond_local_start, cond_local_start-&gt;sa.sa_len);
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_END) {
		memcpy(&amp;new_kernel_policy-&gt;cond_local_end, cond_local_end, cond_local_end-&gt;sa.sa_len);
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_PREFIX) {
		new_kernel_policy-&gt;cond_local_prefix = cond_local_prefix;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_START) {
		memcpy(&amp;new_kernel_policy-&gt;cond_remote_start, cond_remote_start, cond_remote_start-&gt;sa.sa_len);
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_END) {
		memcpy(&amp;new_kernel_policy-&gt;cond_remote_end, cond_remote_end, cond_remote_end-&gt;sa.sa_len);
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_PREFIX) {
		new_kernel_policy-&gt;cond_remote_prefix = cond_remote_prefix;
	}

	new_kernel_policy-&gt;result = result;
	memcpy(&amp;new_kernel_policy-&gt;result_parameter, &amp;result_parameter, <span class="enscript-keyword">sizeof</span>(result_parameter));

	<span class="enscript-keyword">if</span> (necp_debug) {
		NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Added kernel policy: socket, id=%d, mask=%x\n&quot;</span>, new_kernel_policy-&gt;id, new_kernel_policy-&gt;condition_mask);
	}
	LIST_INSERT_SORTED_TWICE_ASCENDING(&amp;necp_kernel_socket_policies, new_kernel_policy, chain, session_order, order, tmp_kernel_policy);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (new_kernel_policy ? new_kernel_policy-&gt;id : 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_kernel_socket_policy *
<span class="enscript-function-name">necp_kernel_socket_policy_find</span>(necp_kernel_policy_id policy_id)
{
	<span class="enscript-type">struct</span> necp_kernel_socket_policy *kernel_policy = NULL;
	<span class="enscript-type">struct</span> necp_kernel_socket_policy *tmp_kernel_policy = NULL;

	<span class="enscript-keyword">if</span> (policy_id == 0) {
		<span class="enscript-keyword">return</span> (NULL);
	}

	LIST_FOREACH_SAFE(kernel_policy, &amp;necp_kernel_socket_policies, chain, tmp_kernel_policy) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;id == policy_id) {
			<span class="enscript-keyword">return</span> (kernel_policy);
		}
	}

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_kernel_socket_policy_delete</span>(necp_kernel_policy_id policy_id)
{
	<span class="enscript-type">struct</span> necp_kernel_socket_policy *policy = NULL;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	policy = necp_kernel_socket_policy_find(policy_id);
	<span class="enscript-keyword">if</span> (policy) {
		LIST_REMOVE(policy, chain);

		<span class="enscript-keyword">if</span> (policy-&gt;cond_bound_interface) {
			ifnet_release(policy-&gt;cond_bound_interface);
			policy-&gt;cond_bound_interface = NULL;
		}
		
		<span class="enscript-keyword">if</span> (policy-&gt;cond_domain) {
			FREE(policy-&gt;cond_domain, M_NECP);
			policy-&gt;cond_domain = NULL;
		}

		FREE_ZONE(policy, <span class="enscript-keyword">sizeof</span>(*policy), M_NECP_SOCKET_POLICY);
		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_RESULT_STRING_LEN</span> 64
<span class="enscript-type">static</span> inline <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">necp_get_result_description</span>(<span class="enscript-type">char</span> *result_string, necp_kernel_policy_result result, necp_kernel_policy_result_parameter result_parameter)
{
	uuid_string_t uuid_string;
	<span class="enscript-keyword">switch</span> (result) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_NONE</span>: {
			<span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;None&quot;</span>);
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_PASS</span>: {
			<span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;Pass&quot;</span>);
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_SKIP</span>: {
			<span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;Skip&quot;</span>);
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_DROP</span>: {
			<span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;Drop&quot;</span>);
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_SOCKET_DIVERT</span>: {
			snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;SocketDivert (%d)&quot;</span>, result_parameter.flow_divert_control_unit);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_SOCKET_FILTER</span>: {
			snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;SocketFilter (%d)&quot;</span>, result_parameter.filter_control_unit);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_IP_TUNNEL</span>: {
			ifnet_t interface = ifindex2ifnet[result_parameter.tunnel_interface_index];
			snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;IPTunnel (%s%d)&quot;</span>, ifnet_name(interface), ifnet_unit(interface));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_IP_FILTER</span>: {
			<span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;IPFilter&quot;</span>);
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_SOCKET_SCOPED</span>: {
			ifnet_t interface = ifindex2ifnet[result_parameter.scoped_interface_index];
			snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;SocketScoped (%s%d)&quot;</span>, ifnet_name(interface), ifnet_unit(interface));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_ROUTE_RULES</span>: {
			<span class="enscript-type">int</span> index = 0;
			<span class="enscript-type">char</span> interface_names[IFXNAMSIZ][MAX_ROUTE_RULE_INTERFACES];
			<span class="enscript-type">struct</span> necp_route_rule *route_rule = necp_lookup_route_rule_locked(&amp;necp_route_rules, result_parameter.route_rule_id);
			<span class="enscript-keyword">if</span> (route_rule != NULL) {
				bool default_drop = (route_rule-&gt;default_action == NECP_ROUTE_RULE_DENY_INTERFACE);
				<span class="enscript-keyword">for</span> (index = 0; index &lt; MAX_ROUTE_RULE_INTERFACES; index++) {
					<span class="enscript-keyword">if</span> (route_rule-&gt;exception_if_indices[index] != 0) {
						ifnet_t interface = ifindex2ifnet[route_rule-&gt;exception_if_indices[index]];
						snprintf(interface_names[index], IFXNAMSIZ, <span class="enscript-string">&quot;%s%d&quot;</span>, ifnet_name(interface), ifnet_unit(interface));
					} <span class="enscript-keyword">else</span> {
						memset(interface_names[index], 0, IFXNAMSIZ);
					}
				}
				<span class="enscript-keyword">if</span> (default_drop) {
					snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;RouteRules (Only %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s)&quot;</span>,
							 (route_rule-&gt;cellular_action == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot;Cell &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;wifi_action == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot;WiFi &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;wired_action == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot;Wired &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;expensive_action == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot;Exp &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[0] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? interface_names[0] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[0] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot; &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[1] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? interface_names[1] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[1] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot; &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[2] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? interface_names[2] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[2] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot; &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[3] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? interface_names[3] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[3] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot; &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[4] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? interface_names[4] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[4] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot; &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[5] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? interface_names[5] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[5] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot; &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[6] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? interface_names[6] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[6] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot; &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[7] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? interface_names[7] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[7] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot; &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[8] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? interface_names[8] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[8] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? <span class="enscript-string">&quot; &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[9] == NECP_ROUTE_RULE_ALLOW_INTERFACE) ? interface_names[9] : <span class="enscript-string">&quot;&quot;</span>);
				} <span class="enscript-keyword">else</span> {
					snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;RouteRules (%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s)&quot;</span>,
							 (route_rule-&gt;cellular_action == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!Cell &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;wifi_action == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!WiFi &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;wired_action == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!Wired &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;expensive_action == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!Exp &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[0] == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[0] == NECP_ROUTE_RULE_DENY_INTERFACE) ? interface_names[0] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[1] == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[1] == NECP_ROUTE_RULE_DENY_INTERFACE) ? interface_names[1] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[2] == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[2] == NECP_ROUTE_RULE_DENY_INTERFACE) ? interface_names[2] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[3] == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[3] == NECP_ROUTE_RULE_DENY_INTERFACE) ? interface_names[3] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[4] == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[4] == NECP_ROUTE_RULE_DENY_INTERFACE) ? interface_names[4] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[5] == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[5] == NECP_ROUTE_RULE_DENY_INTERFACE) ? interface_names[5] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[6] == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[6] == NECP_ROUTE_RULE_DENY_INTERFACE) ? interface_names[6] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[7] == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[7] == NECP_ROUTE_RULE_DENY_INTERFACE) ? interface_names[7] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[8] == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[8] == NECP_ROUTE_RULE_DENY_INTERFACE) ? interface_names[8] : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[9] == NECP_ROUTE_RULE_DENY_INTERFACE) ? <span class="enscript-string">&quot;!&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
							 (route_rule-&gt;exception_if_actions[9] == NECP_ROUTE_RULE_DENY_INTERFACE) ? interface_names[9] : <span class="enscript-string">&quot;&quot;</span>);
				}
			} <span class="enscript-keyword">else</span> {
				snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;RouteRules (Unknown)&quot;</span>);
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_USE_NETAGENT</span>: {
			bool found_mapping = FALSE;
			<span class="enscript-type">struct</span> necp_uuid_id_mapping *mapping = necp_uuid_lookup_uuid_with_service_id_locked(result_parameter.netagent_id);
			<span class="enscript-keyword">if</span> (mapping != NULL) {
				uuid_unparse(mapping-&gt;uuid, uuid_string);
				found_mapping = TRUE;
			}
			snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;UseNetAgent (%s)&quot;</span>, found_mapping ? uuid_string : <span class="enscript-string">&quot;Unknown&quot;</span>);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_TRIGGER</span>: {
			bool found_mapping = FALSE;
			<span class="enscript-type">struct</span> necp_uuid_id_mapping *mapping = necp_uuid_lookup_uuid_with_service_id_locked(result_parameter.service.identifier);
			<span class="enscript-keyword">if</span> (mapping != NULL) {
				uuid_unparse(mapping-&gt;uuid, uuid_string);
				found_mapping = TRUE;
			}
			snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;Trigger (%s.%d)&quot;</span>, found_mapping ? uuid_string : <span class="enscript-string">&quot;Unknown&quot;</span>, result_parameter.service.data);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_TRIGGER_IF_NEEDED</span>: {
			bool found_mapping = FALSE;
			<span class="enscript-type">struct</span> necp_uuid_id_mapping *mapping = necp_uuid_lookup_uuid_with_service_id_locked(result_parameter.service.identifier);
			<span class="enscript-keyword">if</span> (mapping != NULL) {
				uuid_unparse(mapping-&gt;uuid, uuid_string);
				found_mapping = TRUE;
			}
			snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;TriggerIfNeeded (%s.%d)&quot;</span>, found_mapping ? uuid_string : <span class="enscript-string">&quot;Unknown&quot;</span>, result_parameter.service.data);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_TRIGGER_SCOPED</span>: {
			bool found_mapping = FALSE;
			<span class="enscript-type">struct</span> necp_uuid_id_mapping *mapping = necp_uuid_lookup_uuid_with_service_id_locked(result_parameter.service.identifier);
			<span class="enscript-keyword">if</span> (mapping != NULL) {
				uuid_unparse(mapping-&gt;uuid, uuid_string);
				found_mapping = TRUE;
			}
			snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;TriggerScoped (%s.%d)&quot;</span>, found_mapping ? uuid_string : <span class="enscript-string">&quot;Unknown&quot;</span>, result_parameter.service.data);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_RESULT_NO_TRIGGER_SCOPED</span>: {
			bool found_mapping = FALSE;
			<span class="enscript-type">struct</span> necp_uuid_id_mapping *mapping = necp_uuid_lookup_uuid_with_service_id_locked(result_parameter.service.identifier);
			<span class="enscript-keyword">if</span> (mapping != NULL) {
				uuid_unparse(mapping-&gt;uuid, uuid_string);
				found_mapping = TRUE;
			}
			snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;NoTriggerScoped (%s.%d)&quot;</span>, found_mapping ? uuid_string : <span class="enscript-string">&quot;Unknown&quot;</span>, result_parameter.service.data);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>: {
			snprintf(result_string, MAX_RESULT_STRING_LEN, <span class="enscript-string">&quot;Unknown %d (%d)&quot;</span>, result, result_parameter.tunnel_interface_index);
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> (result_string);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_kernel_socket_policies_dump_all</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (necp_debug) {
		<span class="enscript-type">struct</span> necp_kernel_socket_policy *policy = NULL;
		<span class="enscript-type">int</span> policy_i;
		<span class="enscript-type">int</span> app_i;
		<span class="enscript-type">char</span> result_string[MAX_RESULT_STRING_LEN];
		<span class="enscript-type">char</span> proc_name_string[MAXCOMLEN + 1];
		memset(result_string, 0, MAX_RESULT_STRING_LEN);
		memset(proc_name_string, 0, MAXCOMLEN + 1);

		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;NECP Application Policies:\n&quot;</span>);
		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;-----------\n&quot;</span>);
		<span class="enscript-keyword">for</span> (policy_i = 0; necp_kernel_socket_policies_app_layer_map != NULL &amp;&amp; necp_kernel_socket_policies_app_layer_map[policy_i] != NULL; policy_i++) {
			policy = necp_kernel_socket_policies_app_layer_map[policy_i];
			proc_name(policy-&gt;session_pid, proc_name_string, MAXCOMLEN);
			NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;\t%3d. Policy ID: %5d\tProcess: %10.10s\tOrder: %04d.%04d\tMask: %5x\tResult: %s\n&quot;</span>, policy_i, policy-&gt;id, proc_name_string, policy-&gt;session_order, policy-&gt;order, policy-&gt;condition_mask, necp_get_result_description(result_string, policy-&gt;result, policy-&gt;result_parameter));
		}
		<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_app_layer_map[0] != NULL) {
			NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;-----------\n&quot;</span>);
		}

		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;NECP Socket Policies:\n&quot;</span>);
		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;-----------\n&quot;</span>);
		<span class="enscript-keyword">for</span> (app_i = 0; app_i &lt; NECP_KERNEL_SOCKET_POLICIES_MAP_NUM_APP_ID_BUCKETS; app_i++) {
			NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;\tApp Bucket: %d\n&quot;</span>, app_i);
			<span class="enscript-keyword">for</span> (policy_i = 0; necp_kernel_socket_policies_map[app_i] != NULL &amp;&amp; (necp_kernel_socket_policies_map[app_i])[policy_i] != NULL; policy_i++) {
				policy = (necp_kernel_socket_policies_map[app_i])[policy_i];
				proc_name(policy-&gt;session_pid, proc_name_string, MAXCOMLEN);
				NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;\t%3d. Policy ID: %5d\tProcess: %10.10s\tOrder: %04d.%04d\tMask: %5x\tResult: %s\n&quot;</span>, policy_i, policy-&gt;id, proc_name_string, policy-&gt;session_order, policy-&gt;order, policy-&gt;condition_mask, necp_get_result_description(result_string, policy-&gt;result, policy-&gt;result_parameter));
			}
			NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;-----------\n&quot;</span>);
		}
	}
}

<span class="enscript-type">static</span> inline bool
<span class="enscript-function-name">necp_kernel_socket_result_is_trigger_service_type</span>(<span class="enscript-type">struct</span> necp_kernel_socket_policy *kernel_policy)
{
	<span class="enscript-keyword">return</span> (kernel_policy-&gt;result &gt;= NECP_KERNEL_POLICY_RESULT_TRIGGER &amp;&amp; kernel_policy-&gt;result &lt;= NECP_KERNEL_POLICY_RESULT_NO_TRIGGER_SCOPED);
}

<span class="enscript-type">static</span> inline bool
<span class="enscript-function-name">necp_kernel_socket_policy_results_overlap</span>(<span class="enscript-type">struct</span> necp_kernel_socket_policy *upper_policy, <span class="enscript-type">struct</span> necp_kernel_socket_policy *lower_policy)
{
	<span class="enscript-keyword">if</span> (upper_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_DROP) {
		<span class="enscript-comment">// Drop always cancels out lower policies
</span>		<span class="enscript-keyword">return</span> (TRUE);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (upper_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_SOCKET_FILTER ||
			   upper_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_ROUTE_RULES ||
			   upper_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_USE_NETAGENT) {
		<span class="enscript-comment">// Filters and route rules never cancel out lower policies
</span>		<span class="enscript-keyword">return</span> (FALSE);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (necp_kernel_socket_result_is_trigger_service_type(upper_policy)) {
		<span class="enscript-comment">// Trigger/Scoping policies can overlap one another, but not other results
</span>		<span class="enscript-keyword">return</span> (necp_kernel_socket_result_is_trigger_service_type(lower_policy));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (upper_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_SKIP) {
		<span class="enscript-keyword">if</span> (upper_policy-&gt;session_order != lower_policy-&gt;session_order) {
			<span class="enscript-comment">// A skip cannot override a policy of a different session
</span>			<span class="enscript-keyword">return</span> (FALSE);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (upper_policy-&gt;result_parameter.skip_policy_order == 0 ||
				lower_policy-&gt;order &gt;= upper_policy-&gt;result_parameter.skip_policy_order) {
				<span class="enscript-comment">// This policy is beyond the skip
</span>				<span class="enscript-keyword">return</span> (FALSE);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// This policy is inside the skip
</span>				<span class="enscript-keyword">return</span> (TRUE);
			}
		}
	}

	<span class="enscript-comment">// A hard pass, flow divert, tunnel, or scope will currently block out lower policies
</span>	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_kernel_socket_policy_is_unnecessary</span>(<span class="enscript-type">struct</span> necp_kernel_socket_policy *policy, <span class="enscript-type">struct</span> necp_kernel_socket_policy **policy_array, <span class="enscript-type">int</span> valid_indices)
{
	bool can_skip = FALSE;
	u_int32_t highest_skip_session_order = 0;
	u_int32_t highest_skip_order = 0;
	<span class="enscript-type">int</span> i;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; valid_indices; i++) {
		<span class="enscript-type">struct</span> necp_kernel_socket_policy *compared_policy = policy_array[i];

		<span class="enscript-comment">// For policies in a skip window, we can't mark conflicting policies as unnecessary
</span>		<span class="enscript-keyword">if</span> (can_skip) {
			<span class="enscript-keyword">if</span> (highest_skip_session_order != compared_policy-&gt;session_order ||
				(highest_skip_order != 0 &amp;&amp; compared_policy-&gt;order &gt;= highest_skip_order)) {
				<span class="enscript-comment">// If we've moved on to the next session, or passed the skip window
</span>				highest_skip_session_order = 0;
				highest_skip_order = 0;
				can_skip = FALSE;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// If this policy is also a skip, in can increase the skip window
</span>				<span class="enscript-keyword">if</span> (compared_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_SKIP) {
					<span class="enscript-keyword">if</span> (compared_policy-&gt;result_parameter.skip_policy_order &gt; highest_skip_order) {
						highest_skip_order = compared_policy-&gt;result_parameter.skip_policy_order;
					}
				}
				<span class="enscript-keyword">continue</span>;
			}
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_SKIP) {
			<span class="enscript-comment">// This policy is a skip. Set the skip window accordingly
</span>			can_skip = TRUE;
			highest_skip_session_order = compared_policy-&gt;session_order;
			highest_skip_order = compared_policy-&gt;result_parameter.skip_policy_order;
		}

		<span class="enscript-comment">// The result of the compared policy must be able to block out this policy result
</span>		<span class="enscript-keyword">if</span> (!necp_kernel_socket_policy_results_overlap(compared_policy, policy)) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">// If new policy matches All Interfaces, compared policy must also
</span>		<span class="enscript-keyword">if</span> ((policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ALL_INTERFACES) &amp;&amp; !(compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ALL_INTERFACES)) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">// Default makes lower policies unecessary always
</span>		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask == 0) {
			<span class="enscript-keyword">return</span> (TRUE);
		}

		<span class="enscript-comment">// Compared must be more general than policy, and include only conditions within policy
</span>		<span class="enscript-keyword">if</span> ((policy-&gt;condition_mask &amp; compared_policy-&gt;condition_mask) != compared_policy-&gt;condition_mask) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">// Negative conditions must match for the overlapping conditions
</span>		<span class="enscript-keyword">if</span> ((policy-&gt;condition_negated_mask &amp; compared_policy-&gt;condition_mask) != (compared_policy-&gt;condition_negated_mask &amp; compared_policy-&gt;condition_mask)) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_DOMAIN &amp;&amp;
			strcmp(compared_policy-&gt;cond_domain, policy-&gt;cond_domain) != 0) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ACCOUNT_ID &amp;&amp;
			compared_policy-&gt;cond_account_id != policy-&gt;cond_account_id) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_POLICY_ID &amp;&amp;
			compared_policy-&gt;cond_policy_id != policy-&gt;cond_policy_id) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_APP_ID &amp;&amp;
			compared_policy-&gt;cond_app_id != policy-&gt;cond_app_id) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REAL_APP_ID &amp;&amp;
			compared_policy-&gt;cond_real_app_id != policy-&gt;cond_real_app_id) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_PID &amp;&amp;
			compared_policy-&gt;cond_pid != policy-&gt;cond_pid) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_UID &amp;&amp;
			compared_policy-&gt;cond_uid != policy-&gt;cond_uid) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_BOUND_INTERFACE &amp;&amp;
			compared_policy-&gt;cond_bound_interface != policy-&gt;cond_bound_interface) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_PROTOCOL &amp;&amp;
			compared_policy-&gt;cond_protocol != policy-&gt;cond_protocol) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_TRAFFIC_CLASS &amp;&amp;
			!(compared_policy-&gt;cond_traffic_class.start_tc &lt;= policy-&gt;cond_traffic_class.start_tc &amp;&amp;
			  compared_policy-&gt;cond_traffic_class.end_tc &gt;= policy-&gt;cond_traffic_class.end_tc)) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_START) {
			<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_END) {
				<span class="enscript-keyword">if</span> (!necp_is_range_in_range((<span class="enscript-type">struct</span> sockaddr *)&amp;policy-&gt;cond_local_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;policy-&gt;cond_local_end, (<span class="enscript-type">struct</span> sockaddr *)&amp;compared_policy-&gt;cond_local_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;compared_policy-&gt;cond_local_end)) {
					<span class="enscript-keyword">continue</span>;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_PREFIX) {
				<span class="enscript-keyword">if</span> (compared_policy-&gt;cond_local_prefix &gt; policy-&gt;cond_local_prefix ||
					!necp_is_addr_in_subnet((<span class="enscript-type">struct</span> sockaddr *)&amp;policy-&gt;cond_local_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;compared_policy-&gt;cond_local_start, compared_policy-&gt;cond_local_prefix)) {
					<span class="enscript-keyword">continue</span>;
				}
			}
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_START) {
			<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_END) {
				<span class="enscript-keyword">if</span> (!necp_is_range_in_range((<span class="enscript-type">struct</span> sockaddr *)&amp;policy-&gt;cond_remote_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;policy-&gt;cond_remote_end, (<span class="enscript-type">struct</span> sockaddr *)&amp;compared_policy-&gt;cond_remote_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;compared_policy-&gt;cond_remote_end)) {
					<span class="enscript-keyword">continue</span>;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_PREFIX) {
				<span class="enscript-keyword">if</span> (compared_policy-&gt;cond_remote_prefix &gt; policy-&gt;cond_remote_prefix ||
					!necp_is_addr_in_subnet((<span class="enscript-type">struct</span> sockaddr *)&amp;policy-&gt;cond_remote_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;compared_policy-&gt;cond_remote_start, compared_policy-&gt;cond_remote_prefix)) {
					<span class="enscript-keyword">continue</span>;
				}
			}
		}

		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_kernel_socket_policies_reprocess</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> app_i;
	<span class="enscript-type">int</span> bucket_allocation_counts[NECP_KERNEL_SOCKET_POLICIES_MAP_NUM_APP_ID_BUCKETS];
	<span class="enscript-type">int</span> bucket_current_free_index[NECP_KERNEL_SOCKET_POLICIES_MAP_NUM_APP_ID_BUCKETS];
	<span class="enscript-type">int</span> app_layer_allocation_count = 0;
	<span class="enscript-type">int</span> app_layer_current_free_index = 0;
	<span class="enscript-type">struct</span> necp_kernel_socket_policy *kernel_policy = NULL;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	<span class="enscript-comment">// Reset mask to 0
</span>	necp_kernel_application_policies_condition_mask = 0;
	necp_kernel_socket_policies_condition_mask = 0;
	necp_kernel_application_policies_count = 0;
	necp_kernel_socket_policies_count = 0;
	necp_kernel_socket_policies_non_app_count = 0;

	<span class="enscript-comment">// Reset all maps to NULL
</span>	<span class="enscript-keyword">for</span> (app_i = 0; app_i &lt; NECP_KERNEL_SOCKET_POLICIES_MAP_NUM_APP_ID_BUCKETS; app_i++) {
		<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_map[app_i] != NULL) {
			FREE(necp_kernel_socket_policies_map[app_i], M_NECP);
			necp_kernel_socket_policies_map[app_i] = NULL;
		}

		<span class="enscript-comment">// Init counts
</span>		bucket_allocation_counts[app_i] = 0;
	}
	<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_app_layer_map != NULL) {
		FREE(necp_kernel_socket_policies_app_layer_map, M_NECP);
		necp_kernel_socket_policies_app_layer_map = NULL;
	}

	<span class="enscript-comment">// Create masks and counts
</span>	LIST_FOREACH(kernel_policy, &amp;necp_kernel_socket_policies, chain) {
		<span class="enscript-comment">// App layer mask/count
</span>		necp_kernel_application_policies_condition_mask |= kernel_policy-&gt;condition_mask;
		necp_kernel_application_policies_count++;
		app_layer_allocation_count++;

		<span class="enscript-comment">// Update socket layer bucket mask/counts
</span>		necp_kernel_socket_policies_condition_mask |= kernel_policy-&gt;condition_mask;
		necp_kernel_socket_policies_count++;

		<span class="enscript-keyword">if</span> (!(kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_APP_ID) ||
			kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_APP_ID) {
			necp_kernel_socket_policies_non_app_count++;
			<span class="enscript-keyword">for</span> (app_i = 0; app_i &lt; NECP_KERNEL_SOCKET_POLICIES_MAP_NUM_APP_ID_BUCKETS; app_i++) {
				bucket_allocation_counts[app_i]++;
			}
		} <span class="enscript-keyword">else</span> {
			bucket_allocation_counts[NECP_SOCKET_MAP_APP_ID_TO_BUCKET(kernel_policy-&gt;cond_app_id)]++;
		}
	}

	<span class="enscript-comment">// Allocate maps
</span>	<span class="enscript-keyword">for</span> (app_i = 0; app_i &lt; NECP_KERNEL_SOCKET_POLICIES_MAP_NUM_APP_ID_BUCKETS; app_i++) {
		<span class="enscript-keyword">if</span> (bucket_allocation_counts[app_i] &gt; 0) {
			<span class="enscript-comment">// Allocate a NULL-terminated array of policy pointers for each bucket
</span>			MALLOC(necp_kernel_socket_policies_map[app_i], <span class="enscript-type">struct</span> necp_kernel_socket_policy **, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_kernel_socket_policy *) * (bucket_allocation_counts[app_i] + 1), M_NECP, M_WAITOK);
			<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_map[app_i] == NULL) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}

			<span class="enscript-comment">// Initialize the first entry to NULL
</span>			(necp_kernel_socket_policies_map[app_i])[0] = NULL;
		}
		bucket_current_free_index[app_i] = 0;
	}
	MALLOC(necp_kernel_socket_policies_app_layer_map, <span class="enscript-type">struct</span> necp_kernel_socket_policy **, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_kernel_socket_policy *) * (app_layer_allocation_count + 1), M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_app_layer_map == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	necp_kernel_socket_policies_app_layer_map[0] = NULL;

	<span class="enscript-comment">// Fill out maps
</span>	LIST_FOREACH(kernel_policy, &amp;necp_kernel_socket_policies, chain) {
		<span class="enscript-comment">// Insert pointers into map
</span>		<span class="enscript-keyword">if</span> (!(kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_APP_ID) ||
			kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_APP_ID) {
			<span class="enscript-keyword">for</span> (app_i = 0; app_i &lt; NECP_KERNEL_SOCKET_POLICIES_MAP_NUM_APP_ID_BUCKETS; app_i++) {
				<span class="enscript-keyword">if</span> (!necp_kernel_socket_policy_is_unnecessary(kernel_policy, necp_kernel_socket_policies_map[app_i], bucket_current_free_index[app_i])) {
					(necp_kernel_socket_policies_map[app_i])[(bucket_current_free_index[app_i])] = kernel_policy;
					bucket_current_free_index[app_i]++;
					(necp_kernel_socket_policies_map[app_i])[(bucket_current_free_index[app_i])] = NULL;
				}
			}
		} <span class="enscript-keyword">else</span> {
			app_i = NECP_SOCKET_MAP_APP_ID_TO_BUCKET(kernel_policy-&gt;cond_app_id);
			<span class="enscript-keyword">if</span> (!necp_kernel_socket_policy_is_unnecessary(kernel_policy, necp_kernel_socket_policies_map[app_i], bucket_current_free_index[app_i])) {
				(necp_kernel_socket_policies_map[app_i])[(bucket_current_free_index[app_i])] = kernel_policy;
				bucket_current_free_index[app_i]++;
				(necp_kernel_socket_policies_map[app_i])[(bucket_current_free_index[app_i])] = NULL;
			}
		}

		<span class="enscript-keyword">if</span> (!necp_kernel_socket_policy_is_unnecessary(kernel_policy, necp_kernel_socket_policies_app_layer_map, app_layer_current_free_index)) {
			necp_kernel_socket_policies_app_layer_map[app_layer_current_free_index] = kernel_policy;
			app_layer_current_free_index++;
			necp_kernel_socket_policies_app_layer_map[app_layer_current_free_index] = NULL;
		}
	}
	necp_kernel_socket_policies_dump_all();
	BUMP_KERNEL_SOCKET_POLICIES_GENERATION_COUNT();
	<span class="enscript-keyword">return</span> (TRUE);

<span class="enscript-reference">fail</span>:
	<span class="enscript-comment">// Free memory, reset masks to 0
</span>	necp_kernel_application_policies_condition_mask = 0;
	necp_kernel_socket_policies_condition_mask = 0;
	necp_kernel_application_policies_count = 0;
	necp_kernel_socket_policies_count = 0;
	necp_kernel_socket_policies_non_app_count = 0;
	<span class="enscript-keyword">for</span> (app_i = 0; app_i &lt; NECP_KERNEL_SOCKET_POLICIES_MAP_NUM_APP_ID_BUCKETS; app_i++) {
		<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_map[app_i] != NULL) {
			FREE(necp_kernel_socket_policies_map[app_i], M_NECP);
			necp_kernel_socket_policies_map[app_i] = NULL;
		}
	}
	<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_app_layer_map != NULL) {
		FREE(necp_kernel_socket_policies_app_layer_map, M_NECP);
		necp_kernel_socket_policies_app_layer_map = NULL;
	}
	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">necp_get_new_string_id</span>(<span class="enscript-type">void</span>)
{
	u_int32_t newid = 0;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	necp_last_string_id++;
	<span class="enscript-keyword">if</span> (necp_last_string_id &lt; 1) {
		necp_last_string_id = 1;
	}

	newid = necp_last_string_id;
	<span class="enscript-keyword">if</span> (newid == 0) {
		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Allocate string id failed.\n&quot;</span>);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (newid);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_string_id_mapping *
<span class="enscript-function-name">necp_lookup_string_to_id_locked</span>(<span class="enscript-type">struct</span> necp_string_id_mapping_list *list, <span class="enscript-type">char</span> *string)
{
	<span class="enscript-type">struct</span> necp_string_id_mapping *searchentry = NULL;
	<span class="enscript-type">struct</span> necp_string_id_mapping *foundentry = NULL;

	LIST_FOREACH(searchentry, list, chain) {
		<span class="enscript-keyword">if</span> (strcmp(searchentry-&gt;string, string) == 0) {
			foundentry = searchentry;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (foundentry);
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">necp_create_string_to_id_mapping</span>(<span class="enscript-type">struct</span> necp_string_id_mapping_list *list, <span class="enscript-type">char</span> *string)
{
	u_int32_t string_id = 0;
	<span class="enscript-type">struct</span> necp_string_id_mapping *existing_mapping = NULL;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	existing_mapping = necp_lookup_string_to_id_locked(list, string);
	<span class="enscript-keyword">if</span> (existing_mapping != NULL) {
		string_id = existing_mapping-&gt;id;
		existing_mapping-&gt;refcount++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> necp_string_id_mapping *new_mapping = NULL;
		MALLOC(new_mapping, <span class="enscript-type">struct</span> necp_string_id_mapping *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_string_id_mapping), M_NECP, M_WAITOK);
		<span class="enscript-keyword">if</span> (new_mapping != NULL) {
			memset(new_mapping, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_string_id_mapping));

			size_t length = strlen(string) + 1;
			MALLOC(new_mapping-&gt;string, <span class="enscript-type">char</span> *, length, M_NECP, M_WAITOK);
			<span class="enscript-keyword">if</span> (new_mapping-&gt;string != NULL) {
				memcpy(new_mapping-&gt;string, string, length);
				new_mapping-&gt;id = necp_get_new_string_id();
				new_mapping-&gt;refcount = 1;
				LIST_INSERT_HEAD(list, new_mapping, chain);
				string_id = new_mapping-&gt;id;
			} <span class="enscript-keyword">else</span> {
				FREE(new_mapping, M_NECP);
				new_mapping = NULL;
			}
		}
	}
	<span class="enscript-keyword">return</span> (string_id);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_remove_string_to_id_mapping</span>(<span class="enscript-type">struct</span> necp_string_id_mapping_list *list, <span class="enscript-type">char</span> *string)
{
	<span class="enscript-type">struct</span> necp_string_id_mapping *existing_mapping = NULL;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	existing_mapping = necp_lookup_string_to_id_locked(list, string);
	<span class="enscript-keyword">if</span> (existing_mapping != NULL) {
		<span class="enscript-keyword">if</span> (--existing_mapping-&gt;refcount == 0) {
			LIST_REMOVE(existing_mapping, chain);
			FREE(existing_mapping-&gt;string, M_NECP);
			FREE(existing_mapping, M_NECP);
		}
		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">necp_get_new_route_rule_id</span>(<span class="enscript-type">void</span>)
{
	u_int32_t newid = 0;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	necp_last_route_rule_id++;
	<span class="enscript-keyword">if</span> (necp_last_route_rule_id &lt; 1 || necp_last_route_rule_id &gt; UINT16_MAX) {
		necp_last_route_rule_id = 1;
	}

	newid = necp_last_route_rule_id;
	<span class="enscript-keyword">if</span> (newid == 0) {
		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Allocate route rule id failed.\n&quot;</span>);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (newid);
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">necp_get_new_aggregate_route_rule_id</span>(<span class="enscript-type">void</span>)
{
	u_int32_t newid = 0;

	lck_rw_assert(&amp;necp_route_rule_lock, LCK_RW_ASSERT_EXCLUSIVE);

	necp_last_aggregate_route_rule_id++;
	<span class="enscript-keyword">if</span> (necp_last_aggregate_route_rule_id &lt;= UINT16_MAX) {
		necp_last_aggregate_route_rule_id = UINT16_MAX + 1;
	}

	newid = necp_last_aggregate_route_rule_id;
	<span class="enscript-keyword">if</span> (newid == 0) {
		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Allocate aggregate route rule id failed.\n&quot;</span>);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (newid);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_route_rule *
<span class="enscript-function-name">necp_lookup_route_rule_locked</span>(<span class="enscript-type">struct</span> necp_route_rule_list *list, u_int32_t route_rule_id)
{
	<span class="enscript-type">struct</span> necp_route_rule *searchentry = NULL;
	<span class="enscript-type">struct</span> necp_route_rule *foundentry = NULL;

	LIST_FOREACH(searchentry, list, chain) {
		<span class="enscript-keyword">if</span> (searchentry-&gt;id == route_rule_id) {
			foundentry = searchentry;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (foundentry);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_route_rule *
<span class="enscript-function-name">necp_lookup_route_rule_by_contents_locked</span>(<span class="enscript-type">struct</span> necp_route_rule_list *list, u_int32_t default_action, u_int8_t cellular_action, u_int8_t wifi_action, u_int8_t wired_action, u_int8_t expensive_action, u_int32_t *if_indices, u_int8_t *if_actions)
{
	<span class="enscript-type">struct</span> necp_route_rule *searchentry = NULL;
	<span class="enscript-type">struct</span> necp_route_rule *foundentry = NULL;

	LIST_FOREACH(searchentry, list, chain) {
		<span class="enscript-keyword">if</span> (searchentry-&gt;default_action == default_action &amp;&amp;
			searchentry-&gt;cellular_action == cellular_action &amp;&amp;
			searchentry-&gt;wifi_action == wifi_action &amp;&amp;
			searchentry-&gt;wired_action == wired_action &amp;&amp;
			searchentry-&gt;expensive_action == expensive_action) {
			bool match_failed = FALSE;
			size_t index_a = 0;
			size_t index_b = 0;
			size_t count_a = 0;
			size_t count_b = 0;
			<span class="enscript-keyword">for</span> (index_a = 0; index_a &lt; MAX_ROUTE_RULE_INTERFACES; index_a++) {
				bool found_index = FALSE;
				<span class="enscript-keyword">if</span> (searchentry-&gt;exception_if_indices[index_a] == 0) {
					<span class="enscript-keyword">break</span>;
				}
				count_a++;
				<span class="enscript-keyword">for</span> (index_b = 0; index_b &lt; MAX_ROUTE_RULE_INTERFACES; index_b++) {
					<span class="enscript-keyword">if</span> (if_indices[index_b] == 0) {
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">if</span> (index_b &gt;= count_b) {
						count_b = index_b + 1;
					}
					<span class="enscript-keyword">if</span> (searchentry-&gt;exception_if_indices[index_a] == if_indices[index_b] &amp;&amp;
						searchentry-&gt;exception_if_actions[index_a] == if_actions[index_b]) {
						found_index = TRUE;
						<span class="enscript-keyword">break</span>;
					}
				}
				<span class="enscript-keyword">if</span> (!found_index) {
					match_failed = TRUE;
					<span class="enscript-keyword">break</span>;
				}
			}
			<span class="enscript-keyword">if</span> (!match_failed &amp;&amp; count_a == count_b) {
				foundentry = searchentry;
				<span class="enscript-keyword">break</span>;
			}
		}
	}

	<span class="enscript-keyword">return</span> (foundentry);
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">necp_create_route_rule</span>(<span class="enscript-type">struct</span> necp_route_rule_list *list, u_int8_t *route_rules_array, u_int32_t route_rules_array_size)
{
	size_t offset = 0;
	u_int32_t route_rule_id = 0;
	<span class="enscript-type">struct</span> necp_route_rule *existing_rule = NULL;
	u_int32_t default_action = NECP_ROUTE_RULE_ALLOW_INTERFACE;
	u_int8_t cellular_action = NECP_ROUTE_RULE_NONE;
	u_int8_t wifi_action = NECP_ROUTE_RULE_NONE;
	u_int8_t wired_action = NECP_ROUTE_RULE_NONE;
	u_int8_t expensive_action = NECP_ROUTE_RULE_NONE;
	u_int32_t if_indices[MAX_ROUTE_RULE_INTERFACES];
	size_t num_valid_indices = 0;
	memset(&amp;if_indices, 0, <span class="enscript-keyword">sizeof</span>(if_indices));
	u_int8_t if_actions[MAX_ROUTE_RULE_INTERFACES];
	memset(&amp;if_actions, 0, <span class="enscript-keyword">sizeof</span>(if_actions));

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	<span class="enscript-keyword">if</span> (route_rules_array == NULL || route_rules_array_size == 0) {
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">// Process rules
</span>	<span class="enscript-keyword">while</span> (offset &lt; route_rules_array_size) {
		ifnet_t rule_interface = NULL;
		<span class="enscript-type">char</span> interface_name[IFXNAMSIZ];
		u_int32_t length = 0;
		u_int8_t *value = necp_buffer_get_tlv_value(route_rules_array, offset, &amp;length);

		u_int8_t rule_type = necp_policy_condition_get_type_from_buffer(value, length);
		u_int8_t rule_flags = necp_policy_condition_get_flags_from_buffer(value, length);
		u_int32_t rule_length = necp_policy_condition_get_value_length_from_buffer(value, length);
		u_int8_t *rule_value = necp_policy_condition_get_value_pointer_from_buffer(value, length);

		<span class="enscript-keyword">if</span> (rule_type == NECP_ROUTE_RULE_NONE) {
			<span class="enscript-comment">// Don't allow an explicit rule to be None action
</span>			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (rule_length == 0) {
			<span class="enscript-keyword">if</span> (rule_flags &amp; NECP_ROUTE_RULE_FLAG_CELLULAR) {
				cellular_action = rule_type;
			}
			<span class="enscript-keyword">if</span> (rule_flags &amp; NECP_ROUTE_RULE_FLAG_WIFI) {
				wifi_action = rule_type;
			}
			<span class="enscript-keyword">if</span> (rule_flags &amp; NECP_ROUTE_RULE_FLAG_WIRED) {
				wired_action = rule_type;
			}
			<span class="enscript-keyword">if</span> (rule_flags &amp; NECP_ROUTE_RULE_FLAG_EXPENSIVE) {
				expensive_action = rule_type;
			}
			<span class="enscript-keyword">if</span> (rule_flags == 0) {
				default_action = rule_type;
			}
			offset += <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + length;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (num_valid_indices &gt;= MAX_ROUTE_RULE_INTERFACES) {
			offset += <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + length;
			<span class="enscript-keyword">continue</span>;
		}

		memcpy(interface_name, rule_value, rule_length);
		interface_name[length - 1] = 0; <span class="enscript-comment">// Make sure the string is NULL terminated
</span>		<span class="enscript-keyword">if</span> (ifnet_find_by_name(interface_name, &amp;rule_interface) == 0) {
			if_actions[num_valid_indices] = rule_type;
			if_indices[num_valid_indices++] = rule_interface-&gt;if_index;
		}

		offset += <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + length;
	}

	existing_rule = necp_lookup_route_rule_by_contents_locked(list, default_action, cellular_action, wifi_action, wired_action, expensive_action, if_indices, if_actions);
	<span class="enscript-keyword">if</span> (existing_rule != NULL) {
		route_rule_id = existing_rule-&gt;id;
		existing_rule-&gt;refcount++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> necp_route_rule *new_rule = NULL;
		MALLOC(new_rule, <span class="enscript-type">struct</span> necp_route_rule *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_route_rule), M_NECP, M_WAITOK);
		<span class="enscript-keyword">if</span> (new_rule != NULL) {
			memset(new_rule, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_route_rule));
			route_rule_id = new_rule-&gt;id = necp_get_new_route_rule_id();
			new_rule-&gt;default_action = default_action;
			new_rule-&gt;cellular_action = cellular_action;
			new_rule-&gt;wifi_action = wifi_action;
			new_rule-&gt;wired_action = wired_action;
			new_rule-&gt;expensive_action = expensive_action;
			memcpy(&amp;new_rule-&gt;exception_if_indices, &amp;if_indices, <span class="enscript-keyword">sizeof</span>(if_indices));
			memcpy(&amp;new_rule-&gt;exception_if_actions, &amp;if_actions, <span class="enscript-keyword">sizeof</span>(if_actions));
			new_rule-&gt;refcount = 1;
			LIST_INSERT_HEAD(list, new_rule, chain);
		}
	}
	<span class="enscript-keyword">return</span> (route_rule_id);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_remove_aggregate_route_rule_for_id</span>(u_int32_t rule_id)
{
	<span class="enscript-keyword">if</span> (rule_id) {
		lck_rw_lock_exclusive(&amp;necp_route_rule_lock);

		<span class="enscript-type">struct</span> necp_aggregate_route_rule *existing_rule = NULL;
		<span class="enscript-type">struct</span> necp_aggregate_route_rule *tmp_rule = NULL;

		LIST_FOREACH_SAFE(existing_rule, &amp;necp_aggregate_route_rules, chain, tmp_rule) {
			<span class="enscript-type">int</span> index = 0;
			<span class="enscript-keyword">for</span> (index = 0; index &lt; MAX_AGGREGATE_ROUTE_RULES; index++) {
				u_int32_t route_rule_id = existing_rule-&gt;rule_ids[index];
				<span class="enscript-keyword">if</span> (route_rule_id == rule_id) {
					LIST_REMOVE(existing_rule, chain);
					FREE(existing_rule, M_NECP);
					<span class="enscript-keyword">break</span>;
				}
			}
		}

		lck_rw_done(&amp;necp_route_rule_lock);
	}
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_remove_route_rule</span>(<span class="enscript-type">struct</span> necp_route_rule_list *list, u_int32_t route_rule_id)
{
	<span class="enscript-type">struct</span> necp_route_rule *existing_rule = NULL;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	existing_rule = necp_lookup_route_rule_locked(list, route_rule_id);
	<span class="enscript-keyword">if</span> (existing_rule != NULL) {
		<span class="enscript-keyword">if</span> (--existing_rule-&gt;refcount == 0) {
			necp_remove_aggregate_route_rule_for_id(existing_rule-&gt;id);
			LIST_REMOVE(existing_rule, chain);
			FREE(existing_rule, M_NECP);
		}
		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_aggregate_route_rule *
<span class="enscript-function-name">necp_lookup_aggregate_route_rule_locked</span>(u_int32_t route_rule_id)
{
	<span class="enscript-type">struct</span> necp_aggregate_route_rule *searchentry = NULL;
	<span class="enscript-type">struct</span> necp_aggregate_route_rule *foundentry = NULL;

	lck_rw_lock_shared(&amp;necp_route_rule_lock);

	LIST_FOREACH(searchentry, &amp;necp_aggregate_route_rules, chain) {
		<span class="enscript-keyword">if</span> (searchentry-&gt;id == route_rule_id) {
			foundentry = searchentry;
			<span class="enscript-keyword">break</span>;
		}
	}

	lck_rw_done(&amp;necp_route_rule_lock);

	<span class="enscript-keyword">return</span> (foundentry);
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">necp_create_aggregate_route_rule</span>(u_int32_t *rule_ids)
{
	u_int32_t aggregate_route_rule_id = 0;
	<span class="enscript-type">struct</span> necp_aggregate_route_rule *new_rule = NULL;
	<span class="enscript-type">struct</span> necp_aggregate_route_rule *existing_rule = NULL;

	LIST_FOREACH(existing_rule, &amp;necp_aggregate_route_rules, chain) {
		<span class="enscript-keyword">if</span> (memcmp(existing_rule-&gt;rule_ids, rule_ids, (<span class="enscript-keyword">sizeof</span>(u_int32_t) * MAX_AGGREGATE_ROUTE_RULES)) == 0) {
			<span class="enscript-keyword">return</span> (existing_rule-&gt;id);
		}
	}

	lck_rw_lock_exclusive(&amp;necp_route_rule_lock);

	LIST_FOREACH(existing_rule, &amp;necp_aggregate_route_rules, chain) {
		<span class="enscript-comment">// Re-check, in case something else created the rule while we are waiting to lock
</span>		<span class="enscript-keyword">if</span> (memcmp(existing_rule-&gt;rule_ids, rule_ids, (<span class="enscript-keyword">sizeof</span>(u_int32_t) * MAX_AGGREGATE_ROUTE_RULES)) == 0) {
			lck_rw_done(&amp;necp_route_rule_lock);
			<span class="enscript-keyword">return</span> (existing_rule-&gt;id);
		}
	}

	MALLOC(new_rule, <span class="enscript-type">struct</span> necp_aggregate_route_rule *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_aggregate_route_rule), M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_rule != NULL) {
		memset(new_rule, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_aggregate_route_rule));
		aggregate_route_rule_id = new_rule-&gt;id = necp_get_new_aggregate_route_rule_id();
		new_rule-&gt;id = aggregate_route_rule_id;
		memcpy(new_rule-&gt;rule_ids, rule_ids, (<span class="enscript-keyword">sizeof</span>(u_int32_t) * MAX_AGGREGATE_ROUTE_RULES));
		LIST_INSERT_HEAD(&amp;necp_aggregate_route_rules, new_rule, chain);
	}
	lck_rw_done(&amp;necp_route_rule_lock);

	<span class="enscript-keyword">return</span> (aggregate_route_rule_id);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NECP_NULL_SERVICE_ID</span> 1
<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">necp_get_new_uuid_id</span>(<span class="enscript-type">void</span>)
{
	u_int32_t newid = 0;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	necp_last_uuid_id++;
	<span class="enscript-keyword">if</span> (necp_last_uuid_id &lt; (NECP_NULL_SERVICE_ID + 1)) {
		necp_last_uuid_id = (NECP_NULL_SERVICE_ID + 1);
	}

	newid = necp_last_uuid_id;
	<span class="enscript-keyword">if</span> (newid == 0) {
		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Allocate uuid id failed.\n&quot;</span>);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (newid);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_uuid_id_mapping *
<span class="enscript-function-name">necp_uuid_lookup_app_id_locked</span>(uuid_t uuid)
{
	<span class="enscript-type">struct</span> necp_uuid_id_mapping *searchentry = NULL;
	<span class="enscript-type">struct</span> necp_uuid_id_mapping *foundentry = NULL;

	LIST_FOREACH(searchentry, APPUUIDHASH(uuid), chain) {
		<span class="enscript-keyword">if</span> (uuid_compare(searchentry-&gt;uuid, uuid) == 0) {
			foundentry = searchentry;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (foundentry);
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">necp_create_uuid_app_id_mapping</span>(uuid_t uuid, bool *allocated_mapping, bool uuid_policy_table)
{
	u_int32_t local_id = 0;
	<span class="enscript-type">struct</span> necp_uuid_id_mapping *existing_mapping = NULL;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	<span class="enscript-keyword">if</span> (allocated_mapping) {
		*allocated_mapping = FALSE;
	}

	existing_mapping = necp_uuid_lookup_app_id_locked(uuid);
	<span class="enscript-keyword">if</span> (existing_mapping != NULL) {
		local_id = existing_mapping-&gt;id;
		existing_mapping-&gt;refcount++;
		<span class="enscript-keyword">if</span> (uuid_policy_table) {
			existing_mapping-&gt;table_refcount++;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> necp_uuid_id_mapping *new_mapping = NULL;
		MALLOC(new_mapping, <span class="enscript-type">struct</span> necp_uuid_id_mapping *, <span class="enscript-keyword">sizeof</span>(*new_mapping), M_NECP, M_WAITOK);
		<span class="enscript-keyword">if</span> (new_mapping != NULL) {
			uuid_copy(new_mapping-&gt;uuid, uuid);
			new_mapping-&gt;id = necp_get_new_uuid_id();
			new_mapping-&gt;refcount = 1;
			<span class="enscript-keyword">if</span> (uuid_policy_table) {
				new_mapping-&gt;table_refcount = 1;
			} <span class="enscript-keyword">else</span> {
				new_mapping-&gt;table_refcount = 0;
			}

			LIST_INSERT_HEAD(APPUUIDHASH(uuid), new_mapping, chain);

			<span class="enscript-keyword">if</span> (allocated_mapping) {
				*allocated_mapping = TRUE;
			}

			local_id = new_mapping-&gt;id;
		}
	}

	<span class="enscript-keyword">return</span> (local_id);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_remove_uuid_app_id_mapping</span>(uuid_t uuid, bool *removed_mapping, bool uuid_policy_table)
{
	<span class="enscript-type">struct</span> necp_uuid_id_mapping *existing_mapping = NULL;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	<span class="enscript-keyword">if</span> (removed_mapping) {
		*removed_mapping = FALSE;
	}

	existing_mapping = necp_uuid_lookup_app_id_locked(uuid);
	<span class="enscript-keyword">if</span> (existing_mapping != NULL) {
		<span class="enscript-keyword">if</span> (uuid_policy_table) {
			existing_mapping-&gt;table_refcount--;
		}
		<span class="enscript-keyword">if</span> (--existing_mapping-&gt;refcount == 0) {
			LIST_REMOVE(existing_mapping, chain);
			FREE(existing_mapping, M_NECP);
			<span class="enscript-keyword">if</span> (removed_mapping) {
				*removed_mapping = TRUE;
			}
		}
		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_uuid_id_mapping *
<span class="enscript-function-name">necp_uuid_get_null_service_id_mapping</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_uuid_id_mapping null_mapping;
	uuid_clear(null_mapping.uuid);
	null_mapping.id = NECP_NULL_SERVICE_ID;
	
	<span class="enscript-keyword">return</span> (&amp;null_mapping);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_uuid_id_mapping *
<span class="enscript-function-name">necp_uuid_lookup_service_id_locked</span>(uuid_t uuid)
{
	<span class="enscript-type">struct</span> necp_uuid_id_mapping *searchentry = NULL;
	<span class="enscript-type">struct</span> necp_uuid_id_mapping *foundentry = NULL;
	
	<span class="enscript-keyword">if</span> (uuid_is_null(uuid)) {
		<span class="enscript-keyword">return</span> necp_uuid_get_null_service_id_mapping();
	}
	
	LIST_FOREACH(searchentry, &amp;necp_uuid_service_id_list, chain) {
		<span class="enscript-keyword">if</span> (uuid_compare(searchentry-&gt;uuid, uuid) == 0) {
			foundentry = searchentry;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (foundentry);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_uuid_id_mapping *
<span class="enscript-function-name">necp_uuid_lookup_uuid_with_service_id_locked</span>(u_int32_t local_id)
{
	<span class="enscript-type">struct</span> necp_uuid_id_mapping *searchentry = NULL;
	<span class="enscript-type">struct</span> necp_uuid_id_mapping *foundentry = NULL;
	
	<span class="enscript-keyword">if</span> (local_id == NECP_NULL_SERVICE_ID) {
		<span class="enscript-keyword">return</span> necp_uuid_get_null_service_id_mapping();
	}
	
	LIST_FOREACH(searchentry, &amp;necp_uuid_service_id_list, chain) {
		<span class="enscript-keyword">if</span> (searchentry-&gt;id == local_id) {
			foundentry = searchentry;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (foundentry);
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">necp_create_uuid_service_id_mapping</span>(uuid_t uuid)
{
	u_int32_t local_id = 0;
	<span class="enscript-type">struct</span> necp_uuid_id_mapping *existing_mapping = NULL;
	
	<span class="enscript-keyword">if</span> (uuid_is_null(uuid)) {
		<span class="enscript-keyword">return</span> (NECP_NULL_SERVICE_ID);
	}
	
	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	existing_mapping = necp_uuid_lookup_service_id_locked(uuid);
	<span class="enscript-keyword">if</span> (existing_mapping != NULL) {
		local_id = existing_mapping-&gt;id;
		existing_mapping-&gt;refcount++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> necp_uuid_id_mapping *new_mapping = NULL;
		MALLOC(new_mapping, <span class="enscript-type">struct</span> necp_uuid_id_mapping *, <span class="enscript-keyword">sizeof</span>(*new_mapping), M_NECP, M_WAITOK);
		<span class="enscript-keyword">if</span> (new_mapping != NULL) {
			uuid_copy(new_mapping-&gt;uuid, uuid);
			new_mapping-&gt;id = necp_get_new_uuid_id();
			new_mapping-&gt;refcount = 1;

			LIST_INSERT_HEAD(&amp;necp_uuid_service_id_list, new_mapping, chain);

			local_id = new_mapping-&gt;id;
		}
	}

	<span class="enscript-keyword">return</span> (local_id);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_remove_uuid_service_id_mapping</span>(uuid_t uuid)
{
	<span class="enscript-type">struct</span> necp_uuid_id_mapping *existing_mapping = NULL;
	
	<span class="enscript-keyword">if</span> (uuid_is_null(uuid)) {
		<span class="enscript-keyword">return</span> (TRUE);
	}
	
	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	existing_mapping = necp_uuid_lookup_app_id_locked(uuid);
	<span class="enscript-keyword">if</span> (existing_mapping != NULL) {
		<span class="enscript-keyword">if</span> (--existing_mapping-&gt;refcount == 0) {
			LIST_REMOVE(existing_mapping, chain);
			FREE(existing_mapping, M_NECP);
		}
		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">return</span> (FALSE);
}


<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_kernel_socket_policies_update_uuid_table</span>(<span class="enscript-type">void</span>)
{
	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	<span class="enscript-keyword">if</span> (necp_uuid_app_id_mappings_dirty) {
		<span class="enscript-keyword">if</span> (proc_uuid_policy_kernel(PROC_UUID_POLICY_OPERATION_CLEAR, NULL, PROC_UUID_NECP_APP_POLICY) &lt; 0) {
			NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Error clearing uuids from policy table\n&quot;</span>);
			<span class="enscript-keyword">return</span> (FALSE);
		}

		<span class="enscript-keyword">if</span> (necp_num_uuid_app_id_mappings &gt; 0) {
			<span class="enscript-type">struct</span> necp_uuid_id_mapping_head *uuid_list_head = NULL;
			<span class="enscript-keyword">for</span> (uuid_list_head = &amp;necp_uuid_app_id_hashtbl[necp_uuid_app_id_hash_num_buckets - 1]; uuid_list_head &gt;= necp_uuid_app_id_hashtbl; uuid_list_head--) {
				<span class="enscript-type">struct</span> necp_uuid_id_mapping *mapping = NULL;
				LIST_FOREACH(mapping, uuid_list_head, chain) {
					<span class="enscript-keyword">if</span> (mapping-&gt;table_refcount &gt; 0 &amp;&amp;
						proc_uuid_policy_kernel(PROC_UUID_POLICY_OPERATION_ADD, mapping-&gt;uuid, PROC_UUID_NECP_APP_POLICY) &lt; 0) {
						NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;Error adding uuid to policy table\n&quot;</span>);
					}
				}
			}
		}

		necp_uuid_app_id_mappings_dirty = FALSE;
	}

	<span class="enscript-keyword">return</span> (TRUE);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_VALID_IP_OUTPUT_CONDITIONS</span> (NECP_KERNEL_CONDITION_ALL_INTERFACES | NECP_KERNEL_CONDITION_BOUND_INTERFACE | NECP_KERNEL_CONDITION_PROTOCOL | NECP_KERNEL_CONDITION_LOCAL_START | NECP_KERNEL_CONDITION_LOCAL_END | NECP_KERNEL_CONDITION_LOCAL_PREFIX | NECP_KERNEL_CONDITION_REMOTE_START | NECP_KERNEL_CONDITION_REMOTE_END | NECP_KERNEL_CONDITION_REMOTE_PREFIX | NECP_KERNEL_CONDITION_POLICY_ID | NECP_KERNEL_CONDITION_LAST_INTERFACE)
<span class="enscript-type">static</span> necp_kernel_policy_id
<span class="enscript-function-name">necp_kernel_ip_output_policy_add</span>(necp_policy_id parent_policy_id, necp_policy_order order, necp_policy_order suborder, u_int32_t session_order, <span class="enscript-type">int</span> session_pid, u_int32_t condition_mask, u_int32_t condition_negated_mask, necp_kernel_policy_id cond_policy_id, ifnet_t cond_bound_interface, u_int32_t cond_last_interface_index, u_int16_t cond_protocol, <span class="enscript-type">union</span> necp_sockaddr_union *cond_local_start, <span class="enscript-type">union</span> necp_sockaddr_union *cond_local_end, u_int8_t cond_local_prefix, <span class="enscript-type">union</span> necp_sockaddr_union *cond_remote_start, <span class="enscript-type">union</span> necp_sockaddr_union *cond_remote_end, u_int8_t cond_remote_prefix, necp_kernel_policy_result result, necp_kernel_policy_result_parameter result_parameter)
{
	<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *new_kernel_policy = NULL;
	<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *tmp_kernel_policy = NULL;

	MALLOC_ZONE(new_kernel_policy, <span class="enscript-type">struct</span> necp_kernel_ip_output_policy *, <span class="enscript-keyword">sizeof</span>(*new_kernel_policy), M_NECP_IP_POLICY, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_kernel_policy == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	memset(new_kernel_policy, 0, <span class="enscript-keyword">sizeof</span>(*new_kernel_policy));
	new_kernel_policy-&gt;parent_policy_id = parent_policy_id;
	new_kernel_policy-&gt;id = necp_kernel_policy_get_new_id();
	new_kernel_policy-&gt;suborder = suborder;
	new_kernel_policy-&gt;order = order;
	new_kernel_policy-&gt;session_order = session_order;
	new_kernel_policy-&gt;session_pid = session_pid;

	<span class="enscript-comment">// Sanitize condition mask
</span>	new_kernel_policy-&gt;condition_mask = (condition_mask &amp; NECP_KERNEL_VALID_IP_OUTPUT_CONDITIONS);
	<span class="enscript-keyword">if</span> ((new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ALL_INTERFACES) &amp;&amp; (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_BOUND_INTERFACE)) {
		new_kernel_policy-&gt;condition_mask &amp;= ~NECP_KERNEL_CONDITION_BOUND_INTERFACE;
	}
	<span class="enscript-keyword">if</span> ((new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_END) &amp;&amp; (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_PREFIX)) {
		new_kernel_policy-&gt;condition_mask &amp;= ~NECP_KERNEL_CONDITION_LOCAL_PREFIX;
	}
	<span class="enscript-keyword">if</span> ((new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_END) &amp;&amp; (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_PREFIX)) {
		new_kernel_policy-&gt;condition_mask &amp;= ~NECP_KERNEL_CONDITION_REMOTE_PREFIX;
	}
	new_kernel_policy-&gt;condition_negated_mask = condition_negated_mask &amp; new_kernel_policy-&gt;condition_mask;

	<span class="enscript-comment">// Set condition values
</span>	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_POLICY_ID) {
		new_kernel_policy-&gt;cond_policy_id = cond_policy_id;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_BOUND_INTERFACE) {
		<span class="enscript-keyword">if</span> (cond_bound_interface) {
			ifnet_reference(cond_bound_interface);
		}
		new_kernel_policy-&gt;cond_bound_interface = cond_bound_interface;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LAST_INTERFACE) {
		new_kernel_policy-&gt;cond_last_interface_index = cond_last_interface_index;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_PROTOCOL) {
		new_kernel_policy-&gt;cond_protocol = cond_protocol;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_START) {
		memcpy(&amp;new_kernel_policy-&gt;cond_local_start, cond_local_start, cond_local_start-&gt;sa.sa_len);
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_END) {
		memcpy(&amp;new_kernel_policy-&gt;cond_local_end, cond_local_end, cond_local_end-&gt;sa.sa_len);
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_PREFIX) {
		new_kernel_policy-&gt;cond_local_prefix = cond_local_prefix;
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_START) {
		memcpy(&amp;new_kernel_policy-&gt;cond_remote_start, cond_remote_start, cond_remote_start-&gt;sa.sa_len);
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_END) {
		memcpy(&amp;new_kernel_policy-&gt;cond_remote_end, cond_remote_end, cond_remote_end-&gt;sa.sa_len);
	}
	<span class="enscript-keyword">if</span> (new_kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_PREFIX) {
		new_kernel_policy-&gt;cond_remote_prefix = cond_remote_prefix;
	}

	new_kernel_policy-&gt;result = result;
	memcpy(&amp;new_kernel_policy-&gt;result_parameter, &amp;result_parameter, <span class="enscript-keyword">sizeof</span>(result_parameter));

	<span class="enscript-keyword">if</span> (necp_debug) {
		NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Added kernel policy: ip output, id=%d, mask=%x\n&quot;</span>, new_kernel_policy-&gt;id, new_kernel_policy-&gt;condition_mask);
	}
	LIST_INSERT_SORTED_THRICE_ASCENDING(&amp;necp_kernel_ip_output_policies, new_kernel_policy, chain, session_order, order, suborder, tmp_kernel_policy);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (new_kernel_policy ? new_kernel_policy-&gt;id : 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> necp_kernel_ip_output_policy *
<span class="enscript-function-name">necp_kernel_ip_output_policy_find</span>(necp_kernel_policy_id policy_id)
{
	<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *kernel_policy = NULL;
	<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *tmp_kernel_policy = NULL;

	<span class="enscript-keyword">if</span> (policy_id == 0) {
		<span class="enscript-keyword">return</span> (NULL);
	}

	LIST_FOREACH_SAFE(kernel_policy, &amp;necp_kernel_ip_output_policies, chain, tmp_kernel_policy) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;id == policy_id) {
			<span class="enscript-keyword">return</span> (kernel_policy);
		}
	}

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_kernel_ip_output_policy_delete</span>(necp_kernel_policy_id policy_id)
{
	<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *policy = NULL;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	policy = necp_kernel_ip_output_policy_find(policy_id);
	<span class="enscript-keyword">if</span> (policy) {
		LIST_REMOVE(policy, chain);

		<span class="enscript-keyword">if</span> (policy-&gt;cond_bound_interface) {
			ifnet_release(policy-&gt;cond_bound_interface);
			policy-&gt;cond_bound_interface = NULL;
		}

		FREE_ZONE(policy, <span class="enscript-keyword">sizeof</span>(*policy), M_NECP_IP_POLICY);
		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_kernel_ip_output_policies_dump_all</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (necp_debug) {
		<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *policy = NULL;
		<span class="enscript-type">int</span> policy_i;
		<span class="enscript-type">int</span> id_i;
		<span class="enscript-type">char</span> result_string[MAX_RESULT_STRING_LEN];
		<span class="enscript-type">char</span> proc_name_string[MAXCOMLEN + 1];
		memset(result_string, 0, MAX_RESULT_STRING_LEN);
		memset(proc_name_string, 0, MAXCOMLEN + 1);

		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;NECP IP Output Policies:\n&quot;</span>);
		NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;-----------\n&quot;</span>);
		<span class="enscript-keyword">for</span> (id_i = 0; id_i &lt; NECP_KERNEL_IP_OUTPUT_POLICIES_MAP_NUM_ID_BUCKETS; id_i++) {
			NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot; ID Bucket: %d\n&quot;</span>, id_i);
			<span class="enscript-keyword">for</span> (policy_i = 0; necp_kernel_ip_output_policies_map[id_i] != NULL &amp;&amp; (necp_kernel_ip_output_policies_map[id_i])[policy_i] != NULL; policy_i++) {
				policy = (necp_kernel_ip_output_policies_map[id_i])[policy_i];
				proc_name(policy-&gt;session_pid, proc_name_string, MAXCOMLEN);
				NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;\t%3d. Policy ID: %5d\tProcess: %10.10s\tOrder: %04d.%04d.%d\tMask: %5x\tResult: %s\n&quot;</span>, policy_i, policy-&gt;id, proc_name_string, policy-&gt;session_order, policy-&gt;order, policy-&gt;suborder, policy-&gt;condition_mask, necp_get_result_description(result_string, policy-&gt;result, policy-&gt;result_parameter));
			}
			NECPLOG0(LOG_DEBUG, <span class="enscript-string">&quot;-----------\n&quot;</span>);
		}
	}
}

<span class="enscript-type">static</span> inline bool
<span class="enscript-function-name">necp_kernel_ip_output_policy_results_overlap</span>(<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *upper_policy, <span class="enscript-type">struct</span> necp_kernel_ip_output_policy *lower_policy)
{
	<span class="enscript-keyword">if</span> (upper_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_SKIP) {
		<span class="enscript-keyword">if</span> (upper_policy-&gt;session_order != lower_policy-&gt;session_order) {
			<span class="enscript-comment">// A skip cannot override a policy of a different session
</span>			<span class="enscript-keyword">return</span> (FALSE);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (upper_policy-&gt;result_parameter.skip_policy_order == 0 ||
				lower_policy-&gt;order &gt;= upper_policy-&gt;result_parameter.skip_policy_order) {
				<span class="enscript-comment">// This policy is beyond the skip
</span>				<span class="enscript-keyword">return</span> (FALSE);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// This policy is inside the skip
</span>				<span class="enscript-keyword">return</span> (TRUE);
			}
		}
	}

	<span class="enscript-comment">// All other IP Output policy results (drop, tunnel, hard pass) currently overlap
</span>	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_kernel_ip_output_policy_is_unnecessary</span>(<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *policy, <span class="enscript-type">struct</span> necp_kernel_ip_output_policy **policy_array, <span class="enscript-type">int</span> valid_indices)
{
	bool can_skip = FALSE;
	u_int32_t highest_skip_session_order = 0;
	u_int32_t highest_skip_order = 0;
	<span class="enscript-type">int</span> i;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; valid_indices; i++) {
		<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *compared_policy = policy_array[i];

		<span class="enscript-comment">// For policies in a skip window, we can't mark conflicting policies as unnecessary
</span>		<span class="enscript-keyword">if</span> (can_skip) {
			<span class="enscript-keyword">if</span> (highest_skip_session_order != compared_policy-&gt;session_order ||
				(highest_skip_order != 0 &amp;&amp; compared_policy-&gt;order &gt;= highest_skip_order)) {
				<span class="enscript-comment">// If we've moved on to the next session, or passed the skip window
</span>				highest_skip_session_order = 0;
				highest_skip_order = 0;
				can_skip = FALSE;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// If this policy is also a skip, in can increase the skip window
</span>				<span class="enscript-keyword">if</span> (compared_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_SKIP) {
					<span class="enscript-keyword">if</span> (compared_policy-&gt;result_parameter.skip_policy_order &gt; highest_skip_order) {
						highest_skip_order = compared_policy-&gt;result_parameter.skip_policy_order;
					}
				}
				<span class="enscript-keyword">continue</span>;
			}
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_SKIP) {
			<span class="enscript-comment">// This policy is a skip. Set the skip window accordingly
</span>			can_skip = TRUE;
			highest_skip_session_order = compared_policy-&gt;session_order;
			highest_skip_order = compared_policy-&gt;result_parameter.skip_policy_order;
		}

		<span class="enscript-comment">// The result of the compared policy must be able to block out this policy result
</span>		<span class="enscript-keyword">if</span> (!necp_kernel_ip_output_policy_results_overlap(compared_policy, policy)) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">// If new policy matches All Interfaces, compared policy must also
</span>		<span class="enscript-keyword">if</span> ((policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ALL_INTERFACES) &amp;&amp; !(compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ALL_INTERFACES)) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">// Default makes lower policies unecessary always
</span>		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask == 0) {
			<span class="enscript-keyword">return</span> (TRUE);
		}

		<span class="enscript-comment">// Compared must be more general than policy, and include only conditions within policy
</span>		<span class="enscript-keyword">if</span> ((policy-&gt;condition_mask &amp; compared_policy-&gt;condition_mask) != compared_policy-&gt;condition_mask) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">// Negative conditions must match for the overlapping conditions
</span>		<span class="enscript-keyword">if</span> ((policy-&gt;condition_negated_mask &amp; compared_policy-&gt;condition_mask) != (compared_policy-&gt;condition_negated_mask &amp; compared_policy-&gt;condition_mask)) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_POLICY_ID &amp;&amp;
			compared_policy-&gt;cond_policy_id != policy-&gt;cond_policy_id) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_BOUND_INTERFACE &amp;&amp;
			compared_policy-&gt;cond_bound_interface != policy-&gt;cond_bound_interface) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_PROTOCOL &amp;&amp;
			compared_policy-&gt;cond_protocol != policy-&gt;cond_protocol) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_START) {
			<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_END) {
				<span class="enscript-keyword">if</span> (!necp_is_range_in_range((<span class="enscript-type">struct</span> sockaddr *)&amp;policy-&gt;cond_local_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;policy-&gt;cond_local_end, (<span class="enscript-type">struct</span> sockaddr *)&amp;compared_policy-&gt;cond_local_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;compared_policy-&gt;cond_local_end)) {
					<span class="enscript-keyword">continue</span>;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_PREFIX) {
				<span class="enscript-keyword">if</span> (compared_policy-&gt;cond_local_prefix &gt; policy-&gt;cond_local_prefix ||
					!necp_is_addr_in_subnet((<span class="enscript-type">struct</span> sockaddr *)&amp;policy-&gt;cond_local_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;compared_policy-&gt;cond_local_start, compared_policy-&gt;cond_local_prefix)) {
					<span class="enscript-keyword">continue</span>;
				}
			}
		}

		<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_START) {
			<span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_END) {
				<span class="enscript-keyword">if</span> (!necp_is_range_in_range((<span class="enscript-type">struct</span> sockaddr *)&amp;policy-&gt;cond_remote_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;policy-&gt;cond_remote_end, (<span class="enscript-type">struct</span> sockaddr *)&amp;compared_policy-&gt;cond_remote_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;compared_policy-&gt;cond_remote_end)) {
					<span class="enscript-keyword">continue</span>;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (compared_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_PREFIX) {
				<span class="enscript-keyword">if</span> (compared_policy-&gt;cond_remote_prefix &gt; policy-&gt;cond_remote_prefix ||
					!necp_is_addr_in_subnet((<span class="enscript-type">struct</span> sockaddr *)&amp;policy-&gt;cond_remote_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;compared_policy-&gt;cond_remote_start, compared_policy-&gt;cond_remote_prefix)) {
					<span class="enscript-keyword">continue</span>;
				}
			}
		}

		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_kernel_ip_output_policies_reprocess</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> bucket_allocation_counts[NECP_KERNEL_IP_OUTPUT_POLICIES_MAP_NUM_ID_BUCKETS];
	<span class="enscript-type">int</span> bucket_current_free_index[NECP_KERNEL_IP_OUTPUT_POLICIES_MAP_NUM_ID_BUCKETS];
	<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *kernel_policy = NULL;

	lck_rw_assert(&amp;necp_kernel_policy_lock, LCK_RW_ASSERT_EXCLUSIVE);

	<span class="enscript-comment">// Reset mask to 0
</span>	necp_kernel_ip_output_policies_condition_mask = 0;
	necp_kernel_ip_output_policies_count = 0;
	necp_kernel_ip_output_policies_non_id_count = 0;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; NECP_KERNEL_IP_OUTPUT_POLICIES_MAP_NUM_ID_BUCKETS; i++) {
		<span class="enscript-keyword">if</span> (necp_kernel_ip_output_policies_map[i] != NULL) {
			FREE(necp_kernel_ip_output_policies_map[i], M_NECP);
			necp_kernel_ip_output_policies_map[i] = NULL;
		}

		<span class="enscript-comment">// Init counts
</span>		bucket_allocation_counts[i] = 0;
	}

	LIST_FOREACH(kernel_policy, &amp;necp_kernel_ip_output_policies, chain) {
		<span class="enscript-comment">// Update mask
</span>		necp_kernel_ip_output_policies_condition_mask |= kernel_policy-&gt;condition_mask;
		necp_kernel_ip_output_policies_count++;

		<span class="enscript-comment">// Update bucket counts
</span>		<span class="enscript-keyword">if</span> (!(kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_POLICY_ID)) {
			necp_kernel_ip_output_policies_non_id_count++;
			<span class="enscript-keyword">for</span> (i = 0; i &lt; NECP_KERNEL_IP_OUTPUT_POLICIES_MAP_NUM_ID_BUCKETS; i++) {
				bucket_allocation_counts[i]++;
			}
		} <span class="enscript-keyword">else</span> {
			bucket_allocation_counts[NECP_IP_OUTPUT_MAP_ID_TO_BUCKET(kernel_policy-&gt;cond_policy_id)]++;
		}
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt; NECP_KERNEL_IP_OUTPUT_POLICIES_MAP_NUM_ID_BUCKETS; i++) {
		<span class="enscript-keyword">if</span> (bucket_allocation_counts[i] &gt; 0) {
			<span class="enscript-comment">// Allocate a NULL-terminated array of policy pointers for each bucket
</span>			MALLOC(necp_kernel_ip_output_policies_map[i], <span class="enscript-type">struct</span> necp_kernel_ip_output_policy **, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *) * (bucket_allocation_counts[i] + 1), M_NECP, M_WAITOK);
			<span class="enscript-keyword">if</span> (necp_kernel_ip_output_policies_map[i] == NULL) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}

			<span class="enscript-comment">// Initialize the first entry to NULL
</span>			(necp_kernel_ip_output_policies_map[i])[0] = NULL;
		}
		bucket_current_free_index[i] = 0;
	}

	LIST_FOREACH(kernel_policy, &amp;necp_kernel_ip_output_policies, chain) {
		<span class="enscript-comment">// Insert pointers into map
</span>		<span class="enscript-keyword">if</span> (!(kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_POLICY_ID)) {
			<span class="enscript-keyword">for</span> (i = 0; i &lt; NECP_KERNEL_IP_OUTPUT_POLICIES_MAP_NUM_ID_BUCKETS; i++) {
				<span class="enscript-keyword">if</span> (!necp_kernel_ip_output_policy_is_unnecessary(kernel_policy, necp_kernel_ip_output_policies_map[i], bucket_current_free_index[i])) {
					(necp_kernel_ip_output_policies_map[i])[(bucket_current_free_index[i])] = kernel_policy;
					bucket_current_free_index[i]++;
					(necp_kernel_ip_output_policies_map[i])[(bucket_current_free_index[i])] = NULL;
				}
			}
		} <span class="enscript-keyword">else</span> {
			i = NECP_IP_OUTPUT_MAP_ID_TO_BUCKET(kernel_policy-&gt;cond_policy_id);
			<span class="enscript-keyword">if</span> (!necp_kernel_ip_output_policy_is_unnecessary(kernel_policy, necp_kernel_ip_output_policies_map[i], bucket_current_free_index[i])) {
				(necp_kernel_ip_output_policies_map[i])[(bucket_current_free_index[i])] = kernel_policy;
				bucket_current_free_index[i]++;
				(necp_kernel_ip_output_policies_map[i])[(bucket_current_free_index[i])] = NULL;
			}
		}
	}
	necp_kernel_ip_output_policies_dump_all();
	<span class="enscript-keyword">return</span> (TRUE);

<span class="enscript-reference">fail</span>:
	<span class="enscript-comment">// Free memory, reset mask to 0
</span>	necp_kernel_ip_output_policies_condition_mask = 0;
	necp_kernel_ip_output_policies_count = 0;
	necp_kernel_ip_output_policies_non_id_count = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; NECP_KERNEL_IP_OUTPUT_POLICIES_MAP_NUM_ID_BUCKETS; i++) {
		<span class="enscript-keyword">if</span> (necp_kernel_ip_output_policies_map[i] != NULL) {
			FREE(necp_kernel_ip_output_policies_map[i], M_NECP);
			necp_kernel_ip_output_policies_map[i] = NULL;
		}
	}
	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-comment">// Outbound Policy Matching
</span><span class="enscript-comment">// ---------------------
</span><span class="enscript-type">struct</span> substring {
	<span class="enscript-type">char</span> *string;
	size_t length;
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> substring
<span class="enscript-function-name">necp_trim_dots_and_stars</span>(<span class="enscript-type">char</span> *string, size_t length)
{
	<span class="enscript-type">struct</span> substring sub;
	sub.string = string;
	sub.length = string ? length : 0;

	<span class="enscript-keyword">while</span> (sub.length &amp;&amp; (sub.string[0] == <span class="enscript-string">'.'</span> || sub.string[0] == <span class="enscript-string">'*'</span>)) {
		sub.string++;
		sub.length--;
	}

	<span class="enscript-keyword">while</span> (sub.length &amp;&amp; (sub.string[sub.length - 1] == <span class="enscript-string">'.'</span> || sub.string[sub.length - 1] == <span class="enscript-string">'*'</span>)) {
		sub.length--;
	}

	<span class="enscript-keyword">return</span> (sub);
}

<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">necp_create_trimmed_domain</span>(<span class="enscript-type">char</span> *string, size_t length)
{
	<span class="enscript-type">char</span> *trimmed_domain = NULL;
	<span class="enscript-type">struct</span> substring sub = necp_trim_dots_and_stars(string, length);

	MALLOC(trimmed_domain, <span class="enscript-type">char</span> *, sub.length + 1, M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (trimmed_domain == NULL) {
		<span class="enscript-keyword">return</span> (NULL);
	}

	memcpy(trimmed_domain, sub.string, sub.length);
	trimmed_domain[sub.length] = 0;

	<span class="enscript-keyword">return</span> (trimmed_domain);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">necp_count_dots</span>(<span class="enscript-type">char</span> *string, size_t length)
{
	<span class="enscript-type">int</span> dot_count = 0;
	size_t i = 0;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; length; i++) {
		<span class="enscript-keyword">if</span> (string[i] == <span class="enscript-string">'.'</span>) {
			dot_count++;
		}
	}

	<span class="enscript-keyword">return</span> (dot_count);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_check_suffix</span>(<span class="enscript-type">struct</span> substring parent, <span class="enscript-type">struct</span> substring suffix, bool require_dot_before_suffix)
{
	<span class="enscript-keyword">if</span> (parent.length &lt;= suffix.length) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	size_t length_difference = (parent.length - suffix.length);

	<span class="enscript-keyword">if</span> (require_dot_before_suffix) {
		<span class="enscript-keyword">if</span> (((<span class="enscript-type">char</span> *)(parent.string + length_difference - 1))[0] != <span class="enscript-string">'.'</span>) {
			<span class="enscript-keyword">return</span> (FALSE);
		}
	}

	<span class="enscript-keyword">return</span> (memcmp(parent.string + length_difference, suffix.string, suffix.length) == 0);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_hostname_matches_domain</span>(<span class="enscript-type">struct</span> substring hostname_substring, u_int8_t hostname_dot_count, <span class="enscript-type">char</span> *domain, u_int8_t domain_dot_count)
{
	<span class="enscript-keyword">if</span> (hostname_substring.string == NULL || domain == NULL) {
		<span class="enscript-keyword">return</span> (hostname_substring.string == domain);
	}

	<span class="enscript-type">struct</span> substring domain_substring;
	domain_substring.string = domain;
	domain_substring.length = strlen(domain);

	<span class="enscript-keyword">if</span> (hostname_dot_count == domain_dot_count) {
		<span class="enscript-keyword">if</span> (hostname_substring.length == domain_substring.length &amp;&amp;
			memcmp(hostname_substring.string, domain_substring.string, hostname_substring.length) == 0) {
			<span class="enscript-keyword">return</span> (TRUE);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (domain_dot_count &lt; hostname_dot_count) {
		<span class="enscript-keyword">if</span> (necp_check_suffix(hostname_substring, domain_substring, TRUE)) {
			<span class="enscript-keyword">return</span> (TRUE);
		}
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NECP_KERNEL_ADDRESS_TYPE_CONDITIONS</span> (NECP_KERNEL_CONDITION_LOCAL_START | NECP_KERNEL_CONDITION_LOCAL_END | NECP_KERNEL_CONDITION_LOCAL_PREFIX | NECP_KERNEL_CONDITION_REMOTE_START | NECP_KERNEL_CONDITION_REMOTE_END | NECP_KERNEL_CONDITION_REMOTE_PREFIX)
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_application_fillout_info_locked</span>(uuid_t application_uuid, uuid_t real_application_uuid, <span class="enscript-type">char</span> *account, <span class="enscript-type">char</span> *domain, pid_t pid, uid_t uid, u_int16_t protocol, u_int32_t bound_interface_index, u_int32_t traffic_class, <span class="enscript-type">union</span> necp_sockaddr_union *local_addr, <span class="enscript-type">union</span> necp_sockaddr_union *remote_addr, <span class="enscript-type">struct</span> necp_socket_info *info)
{
	memset(info, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_socket_info));

	info-&gt;pid = pid;
	info-&gt;uid = uid;
	info-&gt;protocol = protocol;
	info-&gt;bound_interface_index = bound_interface_index;
	info-&gt;traffic_class = traffic_class;
	info-&gt;cred_result = 0; <span class="enscript-comment">// Don't check the entitlement here, only in the socket layer
</span>
	<span class="enscript-keyword">if</span> (necp_kernel_application_policies_condition_mask &amp; NECP_KERNEL_CONDITION_APP_ID &amp;&amp; !uuid_is_null(application_uuid)) {
		<span class="enscript-type">struct</span> necp_uuid_id_mapping *existing_mapping = necp_uuid_lookup_app_id_locked(application_uuid);
		<span class="enscript-keyword">if</span> (existing_mapping) {
			info-&gt;application_id = existing_mapping-&gt;id;
		}
	}

	<span class="enscript-keyword">if</span> (necp_kernel_application_policies_condition_mask &amp; NECP_KERNEL_CONDITION_REAL_APP_ID &amp;&amp; !uuid_is_null(real_application_uuid)) {
		<span class="enscript-keyword">if</span> (uuid_compare(application_uuid, real_application_uuid) == 0) {
			info-&gt;real_application_id = info-&gt;application_id;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> necp_uuid_id_mapping *existing_mapping = necp_uuid_lookup_app_id_locked(real_application_uuid);
			<span class="enscript-keyword">if</span> (existing_mapping) {
				info-&gt;real_application_id = existing_mapping-&gt;id;
			}
		}
	}

	<span class="enscript-keyword">if</span> (necp_kernel_application_policies_condition_mask &amp; NECP_KERNEL_CONDITION_ACCOUNT_ID &amp;&amp; account != NULL) {
		<span class="enscript-type">struct</span> necp_string_id_mapping *existing_mapping = necp_lookup_string_to_id_locked(&amp;necp_account_id_list, account);
		<span class="enscript-keyword">if</span> (existing_mapping) {
			info-&gt;account_id = existing_mapping-&gt;id;
		}
	}

	<span class="enscript-keyword">if</span> (necp_kernel_application_policies_condition_mask &amp; NECP_KERNEL_CONDITION_DOMAIN) {
		info-&gt;domain = domain;
	}

	<span class="enscript-keyword">if</span> (necp_kernel_application_policies_condition_mask &amp; NECP_KERNEL_ADDRESS_TYPE_CONDITIONS) {
		<span class="enscript-keyword">if</span> (local_addr &amp;&amp; local_addr-&gt;sa.sa_len &gt; 0) {
			memcpy(&amp;info-&gt;local_addr, local_addr, local_addr-&gt;sa.sa_len);
		}
		<span class="enscript-keyword">if</span> (remote_addr &amp;&amp; remote_addr-&gt;sa.sa_len &gt; 0) {
			memcpy(&amp;info-&gt;remote_addr, remote_addr, remote_addr-&gt;sa.sa_len);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_send_application_cell_denied_event</span>(pid_t pid, uuid_t proc_uuid)
{
	<span class="enscript-type">struct</span> kev_netpolicy_ifdenied ev_ifdenied;

	bzero(&amp;ev_ifdenied, <span class="enscript-keyword">sizeof</span>(ev_ifdenied));

	ev_ifdenied.ev_data.epid = pid;
	uuid_copy(ev_ifdenied.ev_data.euuid, proc_uuid);

	netpolicy_post_msg(KEV_NETPOLICY_IFDENIED, &amp;ev_ifdenied.ev_data, <span class="enscript-keyword">sizeof</span>(ev_ifdenied));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">necp_application_find_policy_match_internal</span>(u_int8_t *parameters, u_int32_t parameters_size, <span class="enscript-type">struct</span> necp_aggregate_result *returned_result)
{
	<span class="enscript-type">int</span> error = 0;
	size_t offset = 0;

	<span class="enscript-type">struct</span> necp_kernel_socket_policy *matched_policy = NULL;
	<span class="enscript-type">struct</span> necp_socket_info info;
	necp_kernel_policy_filter filter_control_unit = 0;
	u_int32_t route_rule_id = 0;
	necp_kernel_policy_result service_action = 0;
	necp_kernel_policy_service service = { 0, 0 };

	pid_t pid = 0;
	uid_t uid = 0;
	u_int16_t protocol = 0;
	u_int32_t bound_interface_index = 0;
	u_int32_t traffic_class = 0;
	<span class="enscript-type">union</span> necp_sockaddr_union local_addr;
	<span class="enscript-type">union</span> necp_sockaddr_union remote_addr;
	bool no_remote_addr = FALSE;

	memset(&amp;local_addr, 0, <span class="enscript-keyword">sizeof</span>(local_addr));
	memset(&amp;remote_addr, 0, <span class="enscript-keyword">sizeof</span>(remote_addr));
	uuid_t application_uuid;
	uuid_clear(application_uuid);
	uuid_t real_application_uuid;
	uuid_clear(real_application_uuid);
	<span class="enscript-type">char</span> *domain = NULL;
	<span class="enscript-type">char</span> *account = NULL;

	u_int32_t netagent_ids[NECP_MAX_NETAGENTS];
	memset(&amp;netagent_ids, 0, <span class="enscript-keyword">sizeof</span>(netagent_ids));
	<span class="enscript-type">int</span> netagent_cursor;

	<span class="enscript-keyword">if</span> (returned_result == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	memset(returned_result, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_aggregate_result));

	lck_rw_lock_shared(&amp;necp_kernel_policy_lock);
	<span class="enscript-keyword">if</span> (necp_kernel_application_policies_count == 0) {
		<span class="enscript-keyword">if</span> (necp_drop_all_order &gt; 0) {
			returned_result-&gt;routing_result = NECP_KERNEL_POLICY_RESULT_DROP;
			lck_rw_done(&amp;necp_kernel_policy_lock);
			<span class="enscript-keyword">return</span> (0);
		}
	}
	lck_rw_done(&amp;necp_kernel_policy_lock);

	<span class="enscript-keyword">while</span> ((offset + <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t)) &lt;= parameters_size) {
		u_int8_t type = necp_buffer_get_tlv_type(parameters, offset);
		u_int32_t length = necp_buffer_get_tlv_length(parameters, offset);

		<span class="enscript-keyword">if</span> (length &gt; 0 &amp;&amp; (offset + <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + length) &lt;= parameters_size) {
			u_int8_t *value = necp_buffer_get_tlv_value(parameters, offset, NULL);
			<span class="enscript-keyword">if</span> (value != NULL) {
				<span class="enscript-keyword">switch</span> (type) {
					<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_APPLICATION</span>: {
						<span class="enscript-keyword">if</span> (length &gt;= <span class="enscript-keyword">sizeof</span>(uuid_t)) {
							uuid_copy(application_uuid, value);
						}
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_REAL_APPLICATION</span>: {
						<span class="enscript-keyword">if</span> (length &gt;= <span class="enscript-keyword">sizeof</span>(uuid_t)) {
							uuid_copy(real_application_uuid, value);
						}
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_DOMAIN</span>: {
						domain = (<span class="enscript-type">char</span> *)value;
						domain[length - 1] = 0;
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_ACCOUNT</span>: {
						account = (<span class="enscript-type">char</span> *)value;
						account[length - 1] = 0;
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_TRAFFIC_CLASS</span>: {
						<span class="enscript-keyword">if</span> (length &gt;= <span class="enscript-keyword">sizeof</span>(u_int32_t)) {
							memcpy(&amp;traffic_class, value, <span class="enscript-keyword">sizeof</span>(u_int32_t));
						}
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_PID</span>: {
						<span class="enscript-keyword">if</span> (length &gt;= <span class="enscript-keyword">sizeof</span>(pid_t)) {
							memcpy(&amp;pid, value, <span class="enscript-keyword">sizeof</span>(pid_t));
						}
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_UID</span>: {
						<span class="enscript-keyword">if</span> (length &gt;= <span class="enscript-keyword">sizeof</span>(uid_t)) {
							memcpy(&amp;uid, value, <span class="enscript-keyword">sizeof</span>(uid_t));
						}
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_IP_PROTOCOL</span>: {
						<span class="enscript-keyword">if</span> (length &gt;= <span class="enscript-keyword">sizeof</span>(u_int16_t)) {
							memcpy(&amp;protocol, value, <span class="enscript-keyword">sizeof</span>(u_int16_t));
						}
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_BOUND_INTERFACE</span>: {
						<span class="enscript-keyword">if</span> (length &lt;= IFXNAMSIZ &amp;&amp; length &gt; 0) {
							ifnet_t bound_interface = NULL;
							<span class="enscript-type">char</span> interface_name[IFXNAMSIZ];
							memcpy(interface_name, value, length);
							interface_name[length - 1] = 0; <span class="enscript-comment">// Make sure the string is NULL terminated
</span>							<span class="enscript-keyword">if</span> (ifnet_find_by_name(interface_name, &amp;bound_interface) == 0) {
								bound_interface_index = bound_interface-&gt;if_index;
							}
						}
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_LOCAL_ADDR</span>: {
						<span class="enscript-keyword">if</span> (length &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_policy_condition_addr)) {
							<span class="enscript-type">struct</span> necp_policy_condition_addr *address_struct = (<span class="enscript-type">struct</span> necp_policy_condition_addr *)(<span class="enscript-type">void</span> *)value;
							memcpy(&amp;local_addr, &amp;address_struct-&gt;address, <span class="enscript-keyword">sizeof</span>(address_struct-&gt;address));
						}
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_POLICY_CONDITION_REMOTE_ADDR</span>: {
						<span class="enscript-keyword">if</span> (length &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_policy_condition_addr)) {
							<span class="enscript-type">struct</span> necp_policy_condition_addr *address_struct = (<span class="enscript-type">struct</span> necp_policy_condition_addr *)(<span class="enscript-type">void</span> *)value;
							memcpy(&amp;remote_addr, &amp;address_struct-&gt;address, <span class="enscript-keyword">sizeof</span>(address_struct-&gt;address));
						}
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-reference">default</span>: {
						<span class="enscript-keyword">break</span>;
					}
				}
			}
		}

		offset += <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + length;
	}

	<span class="enscript-comment">// Lock
</span>	lck_rw_lock_shared(&amp;necp_kernel_policy_lock);

	necp_application_fillout_info_locked(application_uuid, real_application_uuid, account, domain, pid, uid, protocol, bound_interface_index, traffic_class, &amp;local_addr, &amp;remote_addr, &amp;info);
	matched_policy = necp_socket_find_policy_match_with_info_locked(necp_kernel_socket_policies_app_layer_map, &amp;info, &amp;filter_control_unit, &amp;route_rule_id, &amp;service_action, &amp;service, netagent_ids, NECP_MAX_NETAGENTS);
	<span class="enscript-keyword">if</span> (matched_policy) {
		returned_result-&gt;policy_id = matched_policy-&gt;id;
		returned_result-&gt;routing_result = matched_policy-&gt;result;
		memcpy(&amp;returned_result-&gt;routing_result_parameter, &amp;matched_policy-&gt;result_parameter, <span class="enscript-keyword">sizeof</span>(returned_result-&gt;routing_result_parameter));
	} <span class="enscript-keyword">else</span> {
		returned_result-&gt;policy_id = 0;
		returned_result-&gt;routing_result = NECP_KERNEL_POLICY_RESULT_NONE;
	}
	returned_result-&gt;filter_control_unit = filter_control_unit;
	returned_result-&gt;service_action = service_action;

	<span class="enscript-comment">// Handle trigger service
</span>	<span class="enscript-keyword">if</span> (service.identifier != 0) {
		<span class="enscript-type">struct</span> necp_uuid_id_mapping *mapping = necp_uuid_lookup_uuid_with_service_id_locked(service.identifier);
		<span class="enscript-keyword">if</span> (mapping != NULL) {
			<span class="enscript-type">struct</span> necp_service_registration *service_registration = NULL;
			uuid_copy(returned_result-&gt;service_uuid, mapping-&gt;uuid);
			returned_result-&gt;service_data = service.data;
			<span class="enscript-keyword">if</span> (service.identifier == NECP_NULL_SERVICE_ID) {
				<span class="enscript-comment">// NULL service is always 'registered'
</span>				returned_result-&gt;service_flags |= NECP_SERVICE_FLAGS_REGISTERED;
			} <span class="enscript-keyword">else</span> {
				LIST_FOREACH(service_registration, &amp;necp_registered_service_list, kernel_chain) {
					<span class="enscript-keyword">if</span> (service.identifier == service_registration-&gt;service_id) {
						returned_result-&gt;service_flags |= NECP_SERVICE_FLAGS_REGISTERED;
						<span class="enscript-keyword">break</span>;
					}
				}
			}
		}
	}

	<span class="enscript-comment">// Handle netagents
</span>	<span class="enscript-keyword">for</span> (netagent_cursor = 0; netagent_cursor &lt; NECP_MAX_NETAGENTS; netagent_cursor++) {
		<span class="enscript-type">struct</span> necp_uuid_id_mapping *mapping = NULL;
		u_int32_t netagent_id = netagent_ids[netagent_cursor];
		<span class="enscript-keyword">if</span> (netagent_id == 0) {
			<span class="enscript-keyword">break</span>;
		}
		mapping = necp_uuid_lookup_uuid_with_service_id_locked(netagent_id);
		<span class="enscript-keyword">if</span> (mapping != NULL) {
			uuid_copy(returned_result-&gt;netagents[netagent_cursor], mapping-&gt;uuid);
			returned_result-&gt;netagent_flags[netagent_cursor] = netagent_get_flags(mapping-&gt;uuid);
		}
	}

	<span class="enscript-comment">// Do routing evaluation
</span>	u_int output_bound_interface = bound_interface_index;
	<span class="enscript-keyword">if</span> (returned_result-&gt;routing_result == NECP_KERNEL_POLICY_RESULT_SOCKET_SCOPED) {
		output_bound_interface = returned_result-&gt;routing_result_parameter.scoped_interface_index;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (returned_result-&gt;routing_result == NECP_KERNEL_POLICY_RESULT_IP_TUNNEL) {
		output_bound_interface = returned_result-&gt;routing_result_parameter.tunnel_interface_index;
	}

	<span class="enscript-keyword">if</span> (remote_addr.sa.sa_len == 0) {
		no_remote_addr = TRUE;
		<span class="enscript-comment">// Default to 0.0.0.0:0
</span>		remote_addr.sa.sa_family = AF_INET;
		remote_addr.sa.sa_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
	}

	<span class="enscript-type">struct</span> rtentry *rt = NULL;
	rt = rtalloc1_scoped((<span class="enscript-type">struct</span> sockaddr *)&amp;remote_addr, 0, 0, output_bound_interface);

	<span class="enscript-keyword">if</span> (no_remote_addr &amp;&amp;
		(rt == NULL || rt-&gt;rt_ifp == NULL)) {
		<span class="enscript-comment">// Route lookup for default IPv4 failed, try IPv6
</span>
		<span class="enscript-comment">// Cleanup old route if necessary
</span>		<span class="enscript-keyword">if</span> (rt != NULL) {
			rtfree(rt);
			rt = NULL;
		}

		<span class="enscript-comment">// Reset address to ::
</span>		memset(&amp;remote_addr, 0, <span class="enscript-keyword">sizeof</span>(remote_addr));
		remote_addr.sa.sa_family = AF_INET6;
		remote_addr.sa.sa_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);

		<span class="enscript-comment">// Get route
</span>		rt = rtalloc1_scoped((<span class="enscript-type">struct</span> sockaddr *)&amp;remote_addr, 0, 0, output_bound_interface);
	}

	returned_result-&gt;routed_interface_index = 0;
	<span class="enscript-keyword">if</span> (rt != NULL &amp;&amp;
	    rt-&gt;rt_ifp != NULL) {
		returned_result-&gt;routed_interface_index = rt-&gt;rt_ifp-&gt;if_index;
		<span class="enscript-comment">/*
		 * For local addresses, we allow the interface scope to be
		 * either the loopback interface or the interface hosting the
		 * local address.
		 */</span>
		<span class="enscript-keyword">if</span> (bound_interface_index != IFSCOPE_NONE &amp;&amp;
		    rt-&gt;rt_ifa != NULL &amp;&amp; rt-&gt;rt_ifa-&gt;ifa_ifp &amp;&amp;
		    (output_bound_interface == lo_ifp-&gt;if_index ||
		    rt-&gt;rt_ifp-&gt;if_index == lo_ifp-&gt;if_index ||
		    rt-&gt;rt_ifa-&gt;ifa_ifp-&gt;if_index == bound_interface_index)) {
			<span class="enscript-type">struct</span> sockaddr_storage dst;
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope = bound_interface_index;

			<span class="enscript-comment">/*
			 * Transform dst into the internal routing table form
			 */</span>
			(<span class="enscript-type">void</span>) sa_copy((<span class="enscript-type">struct</span> sockaddr *)&amp;remote_addr,
					&amp;dst, &amp;ifscope);

			<span class="enscript-keyword">if</span> ((rt-&gt;rt_ifp-&gt;if_index == lo_ifp-&gt;if_index) ||
			    rt_ifa_is_dst((<span class="enscript-type">struct</span> sockaddr *)&amp;dst, rt-&gt;rt_ifa))
				returned_result-&gt;routed_interface_index =
					bound_interface_index;
		}
	}

	bool cellular_denied = FALSE;
	bool route_is_allowed = necp_route_is_allowed(rt, NULL, route_rule_id, &amp;cellular_denied);
	<span class="enscript-keyword">if</span> (!route_is_allowed) {
		<span class="enscript-comment">// If the route is blocked, treat the lookup as a drop
</span>		returned_result-&gt;routing_result = NECP_KERNEL_POLICY_RESULT_DROP;
		memset(&amp;returned_result-&gt;routing_result_parameter, 0, <span class="enscript-keyword">sizeof</span>(returned_result-&gt;routing_result_parameter));

		<span class="enscript-keyword">if</span> (cellular_denied) {
			necp_send_application_cell_denied_event(pid, application_uuid);
		}
	}

	<span class="enscript-keyword">if</span> (rt != NULL) {
		rtfree(rt);
		rt = NULL;
	}
	<span class="enscript-comment">// Unlock
</span>	lck_rw_done(&amp;necp_kernel_policy_lock);

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NECP_MAX_MATCH_POLICY_PARAMETER_SIZE</span> 1024

<span class="enscript-type">int</span>
<span class="enscript-function-name">necp_match_policy</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> necp_match_policy_args *uap, int32_t *retval)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">retval</span>)
	u_int8_t *parameters = NULL;
	<span class="enscript-type">struct</span> necp_aggregate_result returned_result;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (uap == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (uap-&gt;parameters == 0 || uap-&gt;parameters_size == 0 || uap-&gt;parameters_size &gt; NECP_MAX_MATCH_POLICY_PARAMETER_SIZE || uap-&gt;returned_result == 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	MALLOC(parameters, u_int8_t *, uap-&gt;parameters_size, M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (parameters == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">// Copy parameters in
</span>	copyin(uap-&gt;parameters, parameters, uap-&gt;parameters_size);

	error = necp_application_find_policy_match_internal(parameters, uap-&gt;parameters_size, &amp;returned_result);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">// Copy return value back
</span>	copyout(&amp;returned_result, uap-&gt;returned_result, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_aggregate_result));
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (parameters != NULL) {
		FREE(parameters, M_NECP);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_socket_check_policy</span>(<span class="enscript-type">struct</span> necp_kernel_socket_policy *kernel_policy, necp_app_id app_id, necp_app_id real_app_id, errno_t cred_result, u_int32_t account_id, <span class="enscript-type">struct</span> substring domain, u_int8_t domain_dot_count, pid_t pid, uid_t uid, u_int32_t bound_interface_index, u_int32_t traffic_class, u_int16_t protocol, <span class="enscript-type">union</span> necp_sockaddr_union *local, <span class="enscript-type">union</span> necp_sockaddr_union *remote)
{
	<span class="enscript-keyword">if</span> (!(kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ALL_INTERFACES)) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_BOUND_INTERFACE) {
			u_int32_t cond_bound_interface_index = kernel_policy-&gt;cond_bound_interface ? kernel_policy-&gt;cond_bound_interface-&gt;if_index : 0;
			<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_BOUND_INTERFACE) {
				<span class="enscript-keyword">if</span> (bound_interface_index == cond_bound_interface_index) {
					<span class="enscript-comment">// No match, matches forbidden interface
</span>					<span class="enscript-keyword">return</span> (FALSE);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (bound_interface_index != cond_bound_interface_index) {
					<span class="enscript-comment">// No match, does not match required interface
</span>					<span class="enscript-keyword">return</span> (FALSE);
				}
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (bound_interface_index != 0) {
				<span class="enscript-comment">// No match, requires a non-bound packet
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask == 0) {
		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_APP_ID) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_APP_ID) {
			<span class="enscript-keyword">if</span> (app_id == kernel_policy-&gt;cond_app_id) {
				<span class="enscript-comment">// No match, matches forbidden application
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (app_id != kernel_policy-&gt;cond_app_id) {
				<span class="enscript-comment">// No match, does not match required application
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REAL_APP_ID) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_REAL_APP_ID) {
			<span class="enscript-keyword">if</span> (real_app_id == kernel_policy-&gt;cond_real_app_id) {
				<span class="enscript-comment">// No match, matches forbidden application
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (real_app_id != kernel_policy-&gt;cond_real_app_id) {
				<span class="enscript-comment">// No match, does not match required application
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		}
	}
	
	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ENTITLEMENT) {
		<span class="enscript-keyword">if</span> (cred_result != 0) {
			<span class="enscript-comment">// Process is missing entitlement
</span>			<span class="enscript-keyword">return</span> (FALSE);
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_DOMAIN) {
		bool domain_matches = necp_hostname_matches_domain(domain, domain_dot_count, kernel_policy-&gt;cond_domain, kernel_policy-&gt;cond_domain_dot_count);
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_DOMAIN) {
			<span class="enscript-keyword">if</span> (domain_matches) {
				<span class="enscript-comment">// No match, matches forbidden domain
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (!domain_matches) {
				<span class="enscript-comment">// No match, does not match required domain
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ACCOUNT_ID) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_ACCOUNT_ID) {
			<span class="enscript-keyword">if</span> (account_id == kernel_policy-&gt;cond_account_id) {
				<span class="enscript-comment">// No match, matches forbidden account
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (account_id != kernel_policy-&gt;cond_account_id) {
				<span class="enscript-comment">// No match, does not match required account
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_PID) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_PID) {
			<span class="enscript-keyword">if</span> (pid == kernel_policy-&gt;cond_pid) {
				<span class="enscript-comment">// No match, matches forbidden pid
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (pid != kernel_policy-&gt;cond_pid) {
				<span class="enscript-comment">// No match, does not match required pid
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_UID) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_UID) {
			<span class="enscript-keyword">if</span> (uid == kernel_policy-&gt;cond_uid) {
				<span class="enscript-comment">// No match, matches forbidden uid
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (uid != kernel_policy-&gt;cond_uid) {
				<span class="enscript-comment">// No match, does not match required uid
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		}
	}
	
	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_TRAFFIC_CLASS) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_TRAFFIC_CLASS) {
			<span class="enscript-keyword">if</span> (traffic_class &gt;= kernel_policy-&gt;cond_traffic_class.start_tc &amp;&amp;
				traffic_class &lt;= kernel_policy-&gt;cond_traffic_class.end_tc) {
				<span class="enscript-comment">// No match, matches forbidden traffic class
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (traffic_class &lt; kernel_policy-&gt;cond_traffic_class.start_tc ||
				traffic_class &gt; kernel_policy-&gt;cond_traffic_class.end_tc) {
				<span class="enscript-comment">// No match, does not match required traffic class
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_PROTOCOL) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_PROTOCOL) {
			<span class="enscript-keyword">if</span> (protocol == kernel_policy-&gt;cond_protocol) {
				<span class="enscript-comment">// No match, matches forbidden protocol
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (protocol != kernel_policy-&gt;cond_protocol) {
				<span class="enscript-comment">// No match, does not match required protocol
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_START) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_END) {
			bool inRange = necp_is_addr_in_range((<span class="enscript-type">struct</span> sockaddr *)local, (<span class="enscript-type">struct</span> sockaddr *)&amp;kernel_policy-&gt;cond_local_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;kernel_policy-&gt;cond_local_end);
			<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_LOCAL_END) {
				<span class="enscript-keyword">if</span> (inRange) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (!inRange) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_PREFIX) {
			bool inSubnet = necp_is_addr_in_subnet((<span class="enscript-type">struct</span> sockaddr *)local, (<span class="enscript-type">struct</span> sockaddr *)&amp;kernel_policy-&gt;cond_local_start, kernel_policy-&gt;cond_local_prefix);
			<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_LOCAL_PREFIX) {
				<span class="enscript-keyword">if</span> (inSubnet) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (!inSubnet) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			}
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_START) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_END) {
			bool inRange = necp_is_addr_in_range((<span class="enscript-type">struct</span> sockaddr *)remote, (<span class="enscript-type">struct</span> sockaddr *)&amp;kernel_policy-&gt;cond_remote_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;kernel_policy-&gt;cond_remote_end);
			<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_REMOTE_END) {
				<span class="enscript-keyword">if</span> (inRange) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (!inRange) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_PREFIX) {
			bool inSubnet = necp_is_addr_in_subnet((<span class="enscript-type">struct</span> sockaddr *)remote, (<span class="enscript-type">struct</span> sockaddr *)&amp;kernel_policy-&gt;cond_remote_start, kernel_policy-&gt;cond_remote_prefix);
			<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_REMOTE_PREFIX) {
				<span class="enscript-keyword">if</span> (inSubnet) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (!inSubnet) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			}
		}
	}

	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> inline u_int32_t
<span class="enscript-function-name">necp_socket_calc_flowhash_locked</span>(<span class="enscript-type">struct</span> necp_socket_info *info)
{
	<span class="enscript-keyword">return</span> (net_flowhash(info, <span class="enscript-keyword">sizeof</span>(*info), necp_kernel_socket_policies_gencount));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">necp_socket_fillout_info_locked</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> sockaddr *override_local_addr, <span class="enscript-type">struct</span> sockaddr *override_remote_addr, u_int32_t override_bound_interface, <span class="enscript-type">struct</span> necp_socket_info *info)
{
	<span class="enscript-type">struct</span> socket *so = NULL;

	memset(info, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> necp_socket_info));

	so = inp-&gt;inp_socket;

	<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_condition_mask &amp; NECP_KERNEL_CONDITION_PID) {
		info-&gt;pid = ((so-&gt;so_flags &amp; SOF_DELEGATED) ? so-&gt;e_pid : so-&gt;last_pid);
	}

	<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_condition_mask &amp; NECP_KERNEL_CONDITION_UID) {
		info-&gt;uid = kauth_cred_getuid(so-&gt;so_cred);
	}
	
	<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_condition_mask &amp; NECP_KERNEL_CONDITION_TRAFFIC_CLASS) {
		info-&gt;traffic_class = so-&gt;so_traffic_class;
	}

	<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_condition_mask &amp; NECP_KERNEL_CONDITION_PROTOCOL) {
		<span class="enscript-keyword">if</span> (inp-&gt;inp_ip_p) {
			info-&gt;protocol = inp-&gt;inp_ip_p;
		} <span class="enscript-keyword">else</span> {
			info-&gt;protocol = SOCK_PROTO(so);
		}
	}

	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags2 &amp; INP2_WANT_APP_POLICY &amp;&amp; necp_kernel_socket_policies_condition_mask &amp; NECP_KERNEL_CONDITION_APP_ID) {
		<span class="enscript-type">struct</span> necp_uuid_id_mapping *existing_mapping = necp_uuid_lookup_app_id_locked(((so-&gt;so_flags &amp; SOF_DELEGATED) ? so-&gt;e_uuid : so-&gt;last_uuid));
		<span class="enscript-keyword">if</span> (existing_mapping) {
			info-&gt;application_id = existing_mapping-&gt;id;
		}

		<span class="enscript-keyword">if</span> (!(so-&gt;so_flags &amp; SOF_DELEGATED)) {
			info-&gt;real_application_id = info-&gt;application_id;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (necp_kernel_socket_policies_condition_mask &amp; NECP_KERNEL_CONDITION_REAL_APP_ID) {
			<span class="enscript-type">struct</span> necp_uuid_id_mapping *real_existing_mapping = necp_uuid_lookup_app_id_locked(so-&gt;last_uuid);
			<span class="enscript-keyword">if</span> (real_existing_mapping) {
				info-&gt;real_application_id = real_existing_mapping-&gt;id;
			}
		}
		
		<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_condition_mask &amp; NECP_KERNEL_CONDITION_ENTITLEMENT) {
			info-&gt;cred_result = priv_check_cred(so-&gt;so_cred, PRIV_NET_PRIVILEGED_NECP_MATCH, 0);
		}
	}

	<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_condition_mask &amp; NECP_KERNEL_CONDITION_ACCOUNT_ID &amp;&amp; inp-&gt;inp_necp_attributes.inp_account != NULL) {
		<span class="enscript-type">struct</span> necp_string_id_mapping *existing_mapping = necp_lookup_string_to_id_locked(&amp;necp_account_id_list, inp-&gt;inp_necp_attributes.inp_account);
		<span class="enscript-keyword">if</span> (existing_mapping) {
			info-&gt;account_id = existing_mapping-&gt;id;
		}
	}

	<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_condition_mask &amp; NECP_KERNEL_CONDITION_DOMAIN) {
		info-&gt;domain = inp-&gt;inp_necp_attributes.inp_domain;
	}

	<span class="enscript-keyword">if</span> (override_bound_interface) {
		info-&gt;bound_interface_index = override_bound_interface;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((inp-&gt;inp_flags &amp; INP_BOUND_IF) &amp;&amp; inp-&gt;inp_boundifp) {
			info-&gt;bound_interface_index = inp-&gt;inp_boundifp-&gt;if_index;
		}
	}

	<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_condition_mask &amp; NECP_KERNEL_ADDRESS_TYPE_CONDITIONS) {
		<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV4) {
			<span class="enscript-keyword">if</span> (override_local_addr) {
				memcpy(&amp;info-&gt;local_addr, override_local_addr, override_local_addr-&gt;sa_len);
			} <span class="enscript-keyword">else</span> {
				((<span class="enscript-type">struct</span> sockaddr_in *)&amp;info-&gt;local_addr)-&gt;sin_family = AF_INET;
				((<span class="enscript-type">struct</span> sockaddr_in *)&amp;info-&gt;local_addr)-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
				((<span class="enscript-type">struct</span> sockaddr_in *)&amp;info-&gt;local_addr)-&gt;sin_port = inp-&gt;inp_lport;
				memcpy(&amp;((<span class="enscript-type">struct</span> sockaddr_in *)&amp;info-&gt;local_addr)-&gt;sin_addr, &amp;inp-&gt;inp_laddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));
			}

			<span class="enscript-keyword">if</span> (override_remote_addr) {
				memcpy(&amp;info-&gt;remote_addr, override_remote_addr, override_remote_addr-&gt;sa_len);
			} <span class="enscript-keyword">else</span> {
				((<span class="enscript-type">struct</span> sockaddr_in *)&amp;info-&gt;remote_addr)-&gt;sin_family = AF_INET;
				((<span class="enscript-type">struct</span> sockaddr_in *)&amp;info-&gt;remote_addr)-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
				((<span class="enscript-type">struct</span> sockaddr_in *)&amp;info-&gt;remote_addr)-&gt;sin_port = inp-&gt;inp_fport;
				memcpy(&amp;((<span class="enscript-type">struct</span> sockaddr_in *)&amp;info-&gt;remote_addr)-&gt;sin_addr, &amp;inp-&gt;inp_faddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV6) {
			<span class="enscript-keyword">if</span> (override_local_addr) {
				memcpy(&amp;info-&gt;local_addr, override_local_addr, override_local_addr-&gt;sa_len);
			} <span class="enscript-keyword">else</span> {
				((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;info-&gt;local_addr)-&gt;sin6_family = AF_INET6;
				((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;info-&gt;local_addr)-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
				((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;info-&gt;local_addr)-&gt;sin6_port = inp-&gt;inp_lport;
				memcpy(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;info-&gt;local_addr)-&gt;sin6_addr, &amp;inp-&gt;in6p_laddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
			}

			<span class="enscript-keyword">if</span> (override_remote_addr) {
				memcpy(&amp;info-&gt;remote_addr, override_remote_addr, override_remote_addr-&gt;sa_len);
			} <span class="enscript-keyword">else</span> {
				((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;info-&gt;remote_addr)-&gt;sin6_family = AF_INET6;
				((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;info-&gt;remote_addr)-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
				((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;info-&gt;remote_addr)-&gt;sin6_port = inp-&gt;inp_fport;
				memcpy(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;info-&gt;remote_addr)-&gt;sin6_addr, &amp;inp-&gt;in6p_faddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
			}
		}
	}
}

<span class="enscript-type">static</span> inline <span class="enscript-type">struct</span> necp_kernel_socket_policy *
<span class="enscript-function-name">necp_socket_find_policy_match_with_info_locked</span>(<span class="enscript-type">struct</span> necp_kernel_socket_policy **policy_search_array, <span class="enscript-type">struct</span> necp_socket_info *info, necp_kernel_policy_filter *return_filter, u_int32_t *return_route_rule_id, necp_kernel_policy_result *return_service_action, necp_kernel_policy_service *return_service, u_int32_t *return_netagent_array, size_t netagent_array_count)
{
	<span class="enscript-type">struct</span> necp_kernel_socket_policy *matched_policy = NULL;
	u_int32_t skip_order = 0;
	u_int32_t skip_session_order = 0;
	u_int32_t route_rule_id_array[MAX_AGGREGATE_ROUTE_RULES];
	size_t route_rule_id_count = 0;
	<span class="enscript-type">int</span> i;
	size_t netagent_cursor = 0;

	<span class="enscript-comment">// Pre-process domain for quick matching
</span>	<span class="enscript-type">struct</span> substring domain_substring = necp_trim_dots_and_stars(info-&gt;domain, info-&gt;domain ? strlen(info-&gt;domain) : 0);
	u_int8_t domain_dot_count = necp_count_dots(domain_substring.string, domain_substring.length);

	<span class="enscript-keyword">if</span> (return_filter) {
		*return_filter = 0;
	}

	<span class="enscript-keyword">if</span> (return_route_rule_id) {
		*return_route_rule_id = 0;
	}

	<span class="enscript-keyword">if</span> (return_service_action) {
		*return_service_action = 0;
	}

	<span class="enscript-keyword">if</span> (return_service) {
		return_service-&gt;identifier = 0;
		return_service-&gt;data = 0;
	}

	<span class="enscript-keyword">if</span> (policy_search_array != NULL) {
		<span class="enscript-keyword">for</span> (i = 0; policy_search_array[i] != NULL; i++) {
			<span class="enscript-keyword">if</span> (necp_drop_all_order != 0 &amp;&amp; policy_search_array[i]-&gt;session_order &gt;= necp_drop_all_order) {
				<span class="enscript-comment">// We've hit a drop all rule
</span>				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (skip_session_order &amp;&amp; policy_search_array[i]-&gt;session_order &gt;= skip_session_order) {
				<span class="enscript-comment">// Done skipping
</span>				skip_order = 0;
				skip_session_order = 0;
			}
			<span class="enscript-keyword">if</span> (skip_order) {
				<span class="enscript-keyword">if</span> (policy_search_array[i]-&gt;order &lt; skip_order) {
					<span class="enscript-comment">// Skip this policy
</span>					<span class="enscript-keyword">continue</span>;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">// Done skipping
</span>					skip_order = 0;
					skip_session_order = 0;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (skip_session_order) {
				<span class="enscript-comment">// Skip this policy
</span>				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (necp_socket_check_policy(policy_search_array[i], info-&gt;application_id, info-&gt;real_application_id, info-&gt;cred_result, info-&gt;account_id, domain_substring, domain_dot_count, info-&gt;pid, info-&gt;uid, info-&gt;bound_interface_index, info-&gt;traffic_class, info-&gt;protocol, &amp;info-&gt;local_addr, &amp;info-&gt;remote_addr)) {
				<span class="enscript-keyword">if</span> (policy_search_array[i]-&gt;result == NECP_KERNEL_POLICY_RESULT_SOCKET_FILTER) {
					<span class="enscript-keyword">if</span> (return_filter &amp;&amp; *return_filter == 0) {
						*return_filter = policy_search_array[i]-&gt;result_parameter.filter_control_unit;
						<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
							NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Socket Policy: (Application %d Real Application %d BoundInterface %d Proto %d) Filter %d&quot;</span>, info-&gt;application_id, info-&gt;real_application_id, info-&gt;bound_interface_index, info-&gt;protocol, policy_search_array[i]-&gt;result_parameter.filter_control_unit);
						}
					}
					<span class="enscript-keyword">continue</span>;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (policy_search_array[i]-&gt;result == NECP_KERNEL_POLICY_RESULT_ROUTE_RULES) {
					<span class="enscript-keyword">if</span> (return_route_rule_id &amp;&amp; route_rule_id_count &lt; MAX_AGGREGATE_ROUTE_RULES) {
						route_rule_id_array[route_rule_id_count++] = policy_search_array[i]-&gt;result_parameter.route_rule_id;
						<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
							NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Socket Policy: (Application %d Real Application %d BoundInterface %d Proto %d) Route Rule %d&quot;</span>, info-&gt;application_id, info-&gt;real_application_id, info-&gt;bound_interface_index, info-&gt;protocol, policy_search_array[i]-&gt;result_parameter.route_rule_id);
						}
					}
					<span class="enscript-keyword">continue</span>;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (necp_kernel_socket_result_is_trigger_service_type(policy_search_array[i])) {
					<span class="enscript-keyword">if</span> (return_service_action &amp;&amp; *return_service_action == 0) {
						*return_service_action = policy_search_array[i]-&gt;result;
						<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
							NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Socket Policy: (Application %d Real Application %d BoundInterface %d Proto %d) Service Action %d&quot;</span>, info-&gt;application_id, info-&gt;real_application_id, info-&gt;bound_interface_index, info-&gt;protocol, policy_search_array[i]-&gt;result);
						}
					}
					<span class="enscript-keyword">if</span> (return_service &amp;&amp; return_service-&gt;identifier == 0) {
						return_service-&gt;identifier = policy_search_array[i]-&gt;result_parameter.service.identifier;
						return_service-&gt;data = policy_search_array[i]-&gt;result_parameter.service.data;
						<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
							NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Socket Policy: (Application %d Real Application %d BoundInterface %d Proto %d) Service ID %d Data %d&quot;</span>, info-&gt;application_id, info-&gt;real_application_id, info-&gt;bound_interface_index, info-&gt;protocol, policy_search_array[i]-&gt;result_parameter.service.identifier, policy_search_array[i]-&gt;result_parameter.service.data);
						}
					}
					<span class="enscript-keyword">continue</span>;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (policy_search_array[i]-&gt;result == NECP_KERNEL_POLICY_RESULT_USE_NETAGENT) {
					<span class="enscript-keyword">if</span> (return_netagent_array != NULL &amp;&amp;
						netagent_cursor &lt; netagent_array_count) {
						return_netagent_array[netagent_cursor] = policy_search_array[i]-&gt;result_parameter.netagent_id;
						netagent_cursor++;
						<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
							NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Socket Policy: (Application %d Real Application %d BoundInterface %d Proto %d) Use Netagent %d&quot;</span>, info-&gt;application_id, info-&gt;real_application_id, info-&gt;bound_interface_index, info-&gt;protocol, policy_search_array[i]-&gt;result_parameter.netagent_id);
						}
					}
					<span class="enscript-keyword">continue</span>;
				}

				<span class="enscript-comment">// Passed all tests, found a match
</span>				matched_policy = policy_search_array[i];
				<span class="enscript-keyword">if</span> (policy_search_array[i]-&gt;result == NECP_KERNEL_POLICY_RESULT_SKIP) {
					skip_order = policy_search_array[i]-&gt;result_parameter.skip_policy_order;
					skip_session_order = policy_search_array[i]-&gt;session_order + 1;
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">break</span>;
			}
		}
	}

	<span class="enscript-keyword">if</span> (route_rule_id_count == 1) {
		*return_route_rule_id = route_rule_id_array[0];
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (route_rule_id_count &gt; 1) {
		*return_route_rule_id = necp_create_aggregate_route_rule(route_rule_id_array);
	}
	<span class="enscript-keyword">return</span> (matched_policy);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_socket_uses_interface</span>(<span class="enscript-type">struct</span> inpcb *inp, u_int32_t interface_index)
{
	bool found_match = FALSE;
	errno_t result = 0;
	ifaddr_t *addresses = NULL;
	<span class="enscript-type">union</span> necp_sockaddr_union address_storage;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> family = AF_INET;
	ifnet_t interface = ifindex2ifnet[interface_index];
	
	<span class="enscript-keyword">if</span> (inp == NULL || interface == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}
	
	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV4) {
		family = AF_INET;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV6) {
		family = AF_INET6;
	}
	
	result = ifnet_get_address_list_family(interface, &amp;addresses, family);
	<span class="enscript-keyword">if</span> (result != 0) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to get address list for %s%d&quot;</span>, ifnet_name(interface), ifnet_unit(interface));
		<span class="enscript-keyword">return</span> (FALSE);
	}
	
	<span class="enscript-keyword">for</span> (i = 0; addresses[i] != NULL; i++) {
		<span class="enscript-keyword">if</span> (ifaddr_address(addresses[i], &amp;address_storage.sa, <span class="enscript-keyword">sizeof</span>(address_storage)) == 0) {
			<span class="enscript-keyword">if</span> (family == AF_INET) {
				<span class="enscript-keyword">if</span> (memcmp(&amp;address_storage.sin.sin_addr, &amp;inp-&gt;inp_laddr, <span class="enscript-keyword">sizeof</span>(inp-&gt;inp_laddr)) == 0) {
					found_match = TRUE;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (family == AF_INET6) {
				<span class="enscript-keyword">if</span> (memcmp(&amp;address_storage.sin6.sin6_addr, &amp;inp-&gt;in6p_laddr, <span class="enscript-keyword">sizeof</span>(inp-&gt;in6p_laddr)) == 0) {
					found_match = TRUE;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
			}
		}
	}
	
<span class="enscript-reference">done</span>:
	ifnet_free_address_list(addresses);
	addresses = NULL;
	<span class="enscript-keyword">return</span> (found_match);
}

<span class="enscript-type">static</span> inline bool
<span class="enscript-function-name">necp_socket_is_connected</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-keyword">return</span> (inp-&gt;inp_socket-&gt;so_state &amp; (SS_ISCONNECTING | SS_ISCONNECTED | SS_ISDISCONNECTING));
}

necp_kernel_policy_id
<span class="enscript-function-name">necp_socket_find_policy_match</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> sockaddr *override_local_addr, <span class="enscript-type">struct</span> sockaddr *override_remote_addr, u_int32_t override_bound_interface)
{
	<span class="enscript-type">struct</span> socket *so = NULL;
	necp_kernel_policy_filter filter_control_unit = 0;
	u_int32_t route_rule_id = 0;
	<span class="enscript-type">struct</span> necp_kernel_socket_policy *matched_policy = NULL;
	necp_kernel_policy_id matched_policy_id = NECP_KERNEL_POLICY_ID_NONE;
	necp_kernel_policy_result service_action = 0;
	necp_kernel_policy_service service = { 0, 0 };

	u_int32_t netagent_ids[NECP_MAX_NETAGENTS];
	memset(&amp;netagent_ids, 0, <span class="enscript-keyword">sizeof</span>(netagent_ids));
	<span class="enscript-type">int</span> netagent_cursor;

	<span class="enscript-type">struct</span> necp_socket_info info;

	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span> (NECP_KERNEL_POLICY_ID_NONE);
	}

	so = inp-&gt;inp_socket;

	<span class="enscript-comment">// Don't lock. Possible race condition, but we don't want the performance hit.
</span>	<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_count == 0 ||
		(!(inp-&gt;inp_flags2 &amp; INP2_WANT_APP_POLICY) &amp;&amp; necp_kernel_socket_policies_non_app_count == 0)) {
		<span class="enscript-keyword">if</span> (necp_drop_all_order &gt; 0) {
			inp-&gt;inp_policyresult.policy_id = NECP_KERNEL_POLICY_ID_NO_MATCH;
			inp-&gt;inp_policyresult.policy_gencount = 0;
			inp-&gt;inp_policyresult.flowhash = 0;
			inp-&gt;inp_policyresult.results.filter_control_unit = 0;
			inp-&gt;inp_policyresult.results.route_rule_id = 0;
			<span class="enscript-keyword">if</span> (necp_pass_loopback &gt; 0 &amp;&amp;
				necp_is_loopback(override_local_addr, override_remote_addr, inp, NULL)) {
				inp-&gt;inp_policyresult.results.result = NECP_KERNEL_POLICY_RESULT_PASS;
			} <span class="enscript-keyword">else</span> {
				inp-&gt;inp_policyresult.results.result = NECP_KERNEL_POLICY_RESULT_DROP;
			}
		}
		<span class="enscript-keyword">return</span> (NECP_KERNEL_POLICY_ID_NONE);
	}
	
	<span class="enscript-comment">// Check for loopback exception
</span>	<span class="enscript-keyword">if</span> (necp_pass_loopback &gt; 0 &amp;&amp;
		necp_is_loopback(override_local_addr, override_remote_addr, inp, NULL)) {
		<span class="enscript-comment">// Mark socket as a pass
</span>		inp-&gt;inp_policyresult.policy_id = NECP_KERNEL_POLICY_ID_NO_MATCH;
		inp-&gt;inp_policyresult.policy_gencount = 0;
		inp-&gt;inp_policyresult.flowhash = 0;
		inp-&gt;inp_policyresult.results.filter_control_unit = 0;
		inp-&gt;inp_policyresult.results.route_rule_id = 0;
		inp-&gt;inp_policyresult.results.result = NECP_KERNEL_POLICY_RESULT_PASS;
		<span class="enscript-keyword">return</span> (NECP_KERNEL_POLICY_ID_NONE);
	}

	<span class="enscript-comment">// Lock
</span>	lck_rw_lock_shared(&amp;necp_kernel_policy_lock);
	
	necp_socket_fillout_info_locked(inp, override_local_addr, override_remote_addr, override_bound_interface, &amp;info);

	<span class="enscript-comment">// Check info
</span>	u_int32_t flowhash = necp_socket_calc_flowhash_locked(&amp;info);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_policyresult.policy_id != NECP_KERNEL_POLICY_ID_NONE &amp;&amp;
		inp-&gt;inp_policyresult.policy_gencount == necp_kernel_socket_policies_gencount &amp;&amp;
		inp-&gt;inp_policyresult.flowhash == flowhash) {
		<span class="enscript-comment">// If already matched this socket on this generation of table, skip
</span>
		<span class="enscript-comment">// Unlock
</span>		lck_rw_done(&amp;necp_kernel_policy_lock);

		<span class="enscript-keyword">return</span> (inp-&gt;inp_policyresult.policy_id);
	}

	<span class="enscript-comment">// Match socket to policy
</span>	matched_policy = necp_socket_find_policy_match_with_info_locked(necp_kernel_socket_policies_map[NECP_SOCKET_MAP_APP_ID_TO_BUCKET(info.application_id)], &amp;info, &amp;filter_control_unit, &amp;route_rule_id, &amp;service_action, &amp;service, netagent_ids, NECP_MAX_NETAGENTS);
	<span class="enscript-comment">// If the socket matched a scoped service policy, mark as Drop if not registered.
</span>	<span class="enscript-comment">// This covers the cases in which a service is required (on demand) but hasn't started yet.
</span>	<span class="enscript-keyword">if</span> ((service_action == NECP_KERNEL_POLICY_RESULT_TRIGGER_SCOPED ||
		 service_action == NECP_KERNEL_POLICY_RESULT_NO_TRIGGER_SCOPED) &amp;&amp;
		service.identifier != 0 &amp;&amp;
		service.identifier != NECP_NULL_SERVICE_ID) {
		bool service_is_registered = FALSE;
		<span class="enscript-type">struct</span> necp_service_registration *service_registration = NULL;
		LIST_FOREACH(service_registration, &amp;necp_registered_service_list, kernel_chain) {
			<span class="enscript-keyword">if</span> (service.identifier == service_registration-&gt;service_id) {
				service_is_registered = TRUE;
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (!service_is_registered) {
			<span class="enscript-comment">// Mark socket as a drop if service is not registered
</span>			inp-&gt;inp_policyresult.policy_id = NECP_KERNEL_POLICY_ID_NO_MATCH;
			inp-&gt;inp_policyresult.policy_gencount = necp_kernel_socket_policies_gencount;
			inp-&gt;inp_policyresult.flowhash = flowhash;
			inp-&gt;inp_policyresult.results.filter_control_unit = 0;
			inp-&gt;inp_policyresult.results.route_rule_id = 0;
			inp-&gt;inp_policyresult.results.result = NECP_KERNEL_POLICY_RESULT_DROP;

			<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
				NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Socket Policy: (BoundInterface %d Proto %d) Dropping packet because service is not registered&quot;</span>, info.bound_interface_index, info.protocol);
			}

			<span class="enscript-comment">// Unlock
</span>			lck_rw_done(&amp;necp_kernel_policy_lock);
			<span class="enscript-keyword">return</span> (NECP_KERNEL_POLICY_ID_NONE);
		}
	}
	<span class="enscript-comment">// Verify netagents
</span>	<span class="enscript-keyword">for</span> (netagent_cursor = 0; netagent_cursor &lt; NECP_MAX_NETAGENTS; netagent_cursor++) {
		<span class="enscript-type">struct</span> necp_uuid_id_mapping *mapping = NULL;
		u_int32_t netagent_id = netagent_ids[netagent_cursor];
		<span class="enscript-keyword">if</span> (netagent_id == 0) {
			<span class="enscript-keyword">break</span>;
		}
		mapping = necp_uuid_lookup_uuid_with_service_id_locked(netagent_id);
		<span class="enscript-keyword">if</span> (mapping != NULL) {
			u_int32_t agent_flags = 0;
			agent_flags = netagent_get_flags(mapping-&gt;uuid);
			<span class="enscript-keyword">if</span> (agent_flags &amp; NETAGENT_FLAG_REGISTERED) {
				<span class="enscript-keyword">if</span> (agent_flags &amp; NETAGENT_FLAG_ACTIVE) {
					<span class="enscript-keyword">continue</span>;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((agent_flags &amp; NETAGENT_FLAG_VOLUNTARY) == 0) {
					<span class="enscript-keyword">if</span> (agent_flags &amp; NETAGENT_FLAG_KERNEL_ACTIVATED) {
						<span class="enscript-type">int</span> trigger_error = 0;
						trigger_error = netagent_kernel_trigger(mapping-&gt;uuid);
						<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
							NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Socket Policy: Triggering inactive agent, error %d&quot;</span>, trigger_error);
						}
					}

					<span class="enscript-comment">// Mark socket as a drop if required agent is not active
</span>					inp-&gt;inp_policyresult.policy_id = NECP_KERNEL_POLICY_ID_NO_MATCH;
					inp-&gt;inp_policyresult.policy_gencount = necp_kernel_socket_policies_gencount;
					inp-&gt;inp_policyresult.flowhash = flowhash;
					inp-&gt;inp_policyresult.results.filter_control_unit = 0;
					inp-&gt;inp_policyresult.results.route_rule_id = 0;
					inp-&gt;inp_policyresult.results.result = NECP_KERNEL_POLICY_RESULT_DROP;

					<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
						NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Socket Policy: (BoundInterface %d Proto %d) Dropping packet because agent is not active&quot;</span>, info.bound_interface_index, info.protocol);
					}

					<span class="enscript-comment">// Unlock
</span>					lck_rw_done(&amp;necp_kernel_policy_lock);
					<span class="enscript-keyword">return</span> (NECP_KERNEL_POLICY_ID_NONE);
				}
			}
		}
	}
	<span class="enscript-keyword">if</span> (matched_policy) {
		matched_policy_id = matched_policy-&gt;id;
		inp-&gt;inp_policyresult.policy_id = matched_policy-&gt;id;
		inp-&gt;inp_policyresult.policy_gencount = necp_kernel_socket_policies_gencount;
		inp-&gt;inp_policyresult.flowhash = flowhash;
		inp-&gt;inp_policyresult.results.filter_control_unit = filter_control_unit;
		inp-&gt;inp_policyresult.results.route_rule_id = route_rule_id;
		inp-&gt;inp_policyresult.results.result = matched_policy-&gt;result;
		memcpy(&amp;inp-&gt;inp_policyresult.results.result_parameter, &amp;matched_policy-&gt;result_parameter, <span class="enscript-keyword">sizeof</span>(matched_policy-&gt;result_parameter));

		<span class="enscript-keyword">if</span> (necp_socket_is_connected(inp) &amp;&amp;
			(matched_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_DROP ||
			(matched_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_IP_TUNNEL &amp;&amp; !necp_socket_uses_interface(inp, matched_policy-&gt;result_parameter.tunnel_interface_index)))) {
			<span class="enscript-keyword">if</span> (necp_debug) {
				NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Marking socket in state %d as defunct&quot;</span>, so-&gt;so_state);
			}
			sosetdefunct(current_proc(), so, SHUTDOWN_SOCKET_LEVEL_DISCONNECT_ALL, TRUE);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (necp_socket_is_connected(inp) &amp;&amp;
				   matched_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_IP_TUNNEL &amp;&amp;
				   info.protocol == IPPROTO_TCP) {
			<span class="enscript-comment">// Reset MSS on TCP socket if tunnel policy changes
</span>			tcp_mtudisc(inp, 0);
		}

		<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
			NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Socket Policy: %p (BoundInterface %d Proto %d) Policy %d Result %d Parameter %d&quot;</span>, inp-&gt;inp_socket, info.bound_interface_index, info.protocol, matched_policy-&gt;id, matched_policy-&gt;result, matched_policy-&gt;result_parameter.tunnel_interface_index);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (necp_drop_all_order &gt; 0) {
		<span class="enscript-comment">// Mark socket as a drop if set
</span>		inp-&gt;inp_policyresult.policy_id = NECP_KERNEL_POLICY_ID_NO_MATCH;
		inp-&gt;inp_policyresult.policy_gencount = necp_kernel_socket_policies_gencount;
		inp-&gt;inp_policyresult.flowhash = flowhash;
		inp-&gt;inp_policyresult.results.filter_control_unit = 0;
		inp-&gt;inp_policyresult.results.route_rule_id = 0;
		inp-&gt;inp_policyresult.results.result = NECP_KERNEL_POLICY_RESULT_DROP;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// Mark non-matching socket so we don't re-check it
</span>		inp-&gt;inp_policyresult.policy_id = NECP_KERNEL_POLICY_ID_NO_MATCH;
		inp-&gt;inp_policyresult.policy_gencount = necp_kernel_socket_policies_gencount;
		inp-&gt;inp_policyresult.flowhash = flowhash;
		inp-&gt;inp_policyresult.results.filter_control_unit = filter_control_unit; <span class="enscript-comment">// We may have matched a filter, so mark it!
</span>		inp-&gt;inp_policyresult.results.route_rule_id = route_rule_id; <span class="enscript-comment">// We may have matched a route rule, so mark it!
</span>		inp-&gt;inp_policyresult.results.result = NECP_KERNEL_POLICY_RESULT_NONE;
	}

	<span class="enscript-comment">// Unlock
</span>	lck_rw_done(&amp;necp_kernel_policy_lock);

	<span class="enscript-keyword">return</span> (matched_policy_id);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_ip_output_check_policy</span>(<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *kernel_policy, necp_kernel_policy_id socket_policy_id, u_int32_t bound_interface_index, u_int32_t last_interface_index, u_int16_t protocol, <span class="enscript-type">union</span> necp_sockaddr_union *local, <span class="enscript-type">union</span> necp_sockaddr_union *remote)
{
	<span class="enscript-keyword">if</span> (!(kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_ALL_INTERFACES)) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_BOUND_INTERFACE) {
			u_int32_t cond_bound_interface_index = kernel_policy-&gt;cond_bound_interface ? kernel_policy-&gt;cond_bound_interface-&gt;if_index : 0;
			<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_BOUND_INTERFACE) {
				<span class="enscript-keyword">if</span> (bound_interface_index == cond_bound_interface_index) {
					<span class="enscript-comment">// No match, matches forbidden interface
</span>					<span class="enscript-keyword">return</span> (FALSE);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (bound_interface_index != cond_bound_interface_index) {
					<span class="enscript-comment">// No match, does not match required interface
</span>					<span class="enscript-keyword">return</span> (FALSE);
				}
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (bound_interface_index != 0) {
				<span class="enscript-comment">// No match, requires a non-bound packet
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask == 0) {
		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_POLICY_ID) {
		<span class="enscript-keyword">if</span> (socket_policy_id != kernel_policy-&gt;cond_policy_id) {
			<span class="enscript-comment">// No match, does not match required id
</span>			<span class="enscript-keyword">return</span> (FALSE);
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LAST_INTERFACE) {
		<span class="enscript-keyword">if</span> (last_interface_index != kernel_policy-&gt;cond_last_interface_index) {
			<span class="enscript-keyword">return</span> (FALSE);
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_PROTOCOL) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_PROTOCOL) {
			<span class="enscript-keyword">if</span> (protocol == kernel_policy-&gt;cond_protocol) {
				<span class="enscript-comment">// No match, matches forbidden protocol
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (protocol != kernel_policy-&gt;cond_protocol) {
				<span class="enscript-comment">// No match, does not match required protocol
</span>				<span class="enscript-keyword">return</span> (FALSE);
			}
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_START) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_END) {
			bool inRange = necp_is_addr_in_range((<span class="enscript-type">struct</span> sockaddr *)local, (<span class="enscript-type">struct</span> sockaddr *)&amp;kernel_policy-&gt;cond_local_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;kernel_policy-&gt;cond_local_end);
			<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_LOCAL_END) {
				<span class="enscript-keyword">if</span> (inRange) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (!inRange) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_LOCAL_PREFIX) {
			bool inSubnet = necp_is_addr_in_subnet((<span class="enscript-type">struct</span> sockaddr *)local, (<span class="enscript-type">struct</span> sockaddr *)&amp;kernel_policy-&gt;cond_local_start, kernel_policy-&gt;cond_local_prefix);
			<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_LOCAL_PREFIX) {
				<span class="enscript-keyword">if</span> (inSubnet) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (!inSubnet) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			}
		}
	}

	<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_START) {
		<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_END) {
			bool inRange = necp_is_addr_in_range((<span class="enscript-type">struct</span> sockaddr *)remote, (<span class="enscript-type">struct</span> sockaddr *)&amp;kernel_policy-&gt;cond_remote_start, (<span class="enscript-type">struct</span> sockaddr *)&amp;kernel_policy-&gt;cond_remote_end);
			<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_REMOTE_END) {
				<span class="enscript-keyword">if</span> (inRange) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (!inRange) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_mask &amp; NECP_KERNEL_CONDITION_REMOTE_PREFIX) {
			bool inSubnet = necp_is_addr_in_subnet((<span class="enscript-type">struct</span> sockaddr *)remote, (<span class="enscript-type">struct</span> sockaddr *)&amp;kernel_policy-&gt;cond_remote_start, kernel_policy-&gt;cond_remote_prefix);
			<span class="enscript-keyword">if</span> (kernel_policy-&gt;condition_negated_mask &amp; NECP_KERNEL_CONDITION_REMOTE_PREFIX) {
				<span class="enscript-keyword">if</span> (inSubnet) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (!inSubnet) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			}
		}
	}

	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">struct</span> necp_kernel_ip_output_policy *
<span class="enscript-function-name">necp_ip_output_find_policy_match_locked</span>(necp_kernel_policy_id socket_policy_id, u_int32_t bound_interface_index, u_int32_t last_interface_index, u_int16_t protocol, <span class="enscript-type">union</span> necp_sockaddr_union *local_addr, <span class="enscript-type">union</span> necp_sockaddr_union *remote_addr)
{
	u_int32_t skip_order = 0;
	u_int32_t skip_session_order = 0;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *matched_policy = NULL;
	<span class="enscript-type">struct</span> necp_kernel_ip_output_policy **policy_search_array = necp_kernel_ip_output_policies_map[NECP_IP_OUTPUT_MAP_ID_TO_BUCKET(socket_policy_id)];
	<span class="enscript-keyword">if</span> (policy_search_array != NULL) {
		<span class="enscript-keyword">for</span> (i = 0; policy_search_array[i] != NULL; i++) {
			<span class="enscript-keyword">if</span> (necp_drop_all_order != 0 &amp;&amp; policy_search_array[i]-&gt;session_order &gt;= necp_drop_all_order) {
				<span class="enscript-comment">// We've hit a drop all rule
</span>				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (skip_session_order &amp;&amp; policy_search_array[i]-&gt;session_order &gt;= skip_session_order) {
				<span class="enscript-comment">// Done skipping
</span>				skip_order = 0;
				skip_session_order = 0;
			}
			<span class="enscript-keyword">if</span> (skip_order) {
				<span class="enscript-keyword">if</span> (policy_search_array[i]-&gt;order &lt; skip_order) {
					<span class="enscript-comment">// Skip this policy
</span>					<span class="enscript-keyword">continue</span>;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">// Done skipping
</span>					skip_order = 0;
					skip_session_order = 0;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (skip_session_order) {
				<span class="enscript-comment">// Skip this policy
</span>				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (necp_ip_output_check_policy(policy_search_array[i], socket_policy_id, bound_interface_index, last_interface_index, protocol, local_addr, remote_addr)) {
				<span class="enscript-comment">// Passed all tests, found a match
</span>				matched_policy = policy_search_array[i];

				<span class="enscript-keyword">if</span> (policy_search_array[i]-&gt;result == NECP_KERNEL_POLICY_RESULT_SKIP) {
					skip_order = policy_search_array[i]-&gt;result_parameter.skip_policy_order;
					skip_session_order = policy_search_array[i]-&gt;session_order + 1;
					<span class="enscript-keyword">continue</span>;
				}

				<span class="enscript-keyword">break</span>;
			}
		}
	}

	<span class="enscript-keyword">return</span> (matched_policy);
}

necp_kernel_policy_id
<span class="enscript-function-name">necp_ip_output_find_policy_match</span>(<span class="enscript-type">struct</span> mbuf *packet, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> ip_out_args *ipoa, necp_kernel_policy_result *result, necp_kernel_policy_result_parameter *result_parameter)
{
	<span class="enscript-type">struct</span> ip *ip = NULL;
	<span class="enscript-type">int</span> hlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
	necp_kernel_policy_id socket_policy_id = NECP_KERNEL_POLICY_ID_NONE;
	necp_kernel_policy_id matched_policy_id = NECP_KERNEL_POLICY_ID_NONE;
	<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *matched_policy = NULL;
	u_int16_t protocol = 0;
	u_int32_t bound_interface_index = 0;
	u_int32_t last_interface_index = 0;
	<span class="enscript-type">union</span> necp_sockaddr_union local_addr;
	<span class="enscript-type">union</span> necp_sockaddr_union remote_addr;

	<span class="enscript-keyword">if</span> (result) {
		*result = 0;
	}

	<span class="enscript-keyword">if</span> (result_parameter) {
		memset(result_parameter, 0, <span class="enscript-keyword">sizeof</span>(*result_parameter));
	}

	<span class="enscript-keyword">if</span> (packet == NULL) {
		<span class="enscript-keyword">return</span> (NECP_KERNEL_POLICY_ID_NONE);
	}
	
	socket_policy_id = necp_get_policy_id_from_packet(packet);

	<span class="enscript-comment">// Exit early for an empty list
</span>	<span class="enscript-comment">// Don't lock. Possible race condition, but we don't want the performance hit.
</span>	<span class="enscript-keyword">if</span> (necp_kernel_ip_output_policies_count == 0 ||
		((socket_policy_id == NECP_KERNEL_POLICY_ID_NONE) &amp;&amp; necp_kernel_ip_output_policies_non_id_count == 0)) {
		<span class="enscript-keyword">if</span> (necp_drop_all_order &gt; 0) {
			matched_policy_id = NECP_KERNEL_POLICY_ID_NO_MATCH;
			<span class="enscript-keyword">if</span> (result) {
				<span class="enscript-keyword">if</span> ((necp_pass_loopback &gt; 0 &amp;&amp;
					 necp_is_loopback(NULL, NULL, NULL, packet)) ||
					(necp_pass_keepalives &gt; 0 &amp;&amp;
					 necp_get_is_keepalive_from_packet(packet))) {
					*result = NECP_KERNEL_POLICY_RESULT_PASS;
				} <span class="enscript-keyword">else</span> {
					*result = NECP_KERNEL_POLICY_RESULT_DROP;
				}
			}
		}

		<span class="enscript-keyword">return</span> (matched_policy_id);
	}
	
	<span class="enscript-comment">// Check for loopback exception
</span>	<span class="enscript-keyword">if</span> ((necp_pass_loopback &gt; 0 &amp;&amp;
		 necp_is_loopback(NULL, NULL, NULL, packet)) ||
		(necp_pass_keepalives &gt; 0 &amp;&amp;
		 necp_get_is_keepalive_from_packet(packet))) {
		matched_policy_id = NECP_KERNEL_POLICY_ID_NO_MATCH;
		<span class="enscript-keyword">if</span> (result) {
			*result = NECP_KERNEL_POLICY_RESULT_PASS;
		}
		<span class="enscript-keyword">return</span> (matched_policy_id);
	}
	
	last_interface_index = necp_get_last_interface_index_from_packet(packet);

	<span class="enscript-comment">// Process packet to get relevant fields
</span>	ip = mtod(packet, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	hlen = _IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">else</span>
	hlen = ip-&gt;ip_hl &lt;&lt; 2;
#<span class="enscript-reference">endif</span>

	protocol = ip-&gt;ip_p;

	<span class="enscript-keyword">if</span> ((flags &amp; IP_OUTARGS) &amp;&amp; (ipoa != NULL) &amp;&amp;
		(ipoa-&gt;ipoa_flags &amp; IPOAF_BOUND_IF) &amp;&amp;
		ipoa-&gt;ipoa_boundif != IFSCOPE_NONE) {
		bound_interface_index = ipoa-&gt;ipoa_boundif;
	}

	local_addr.sin.sin_family = AF_INET;
	local_addr.sin.sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
	memcpy(&amp;local_addr.sin.sin_addr, &amp;ip-&gt;ip_src, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_src));

	remote_addr.sin.sin_family = AF_INET;
	remote_addr.sin.sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
	memcpy(&amp;((<span class="enscript-type">struct</span> sockaddr_in *)&amp;remote_addr)-&gt;sin_addr, &amp;ip-&gt;ip_dst, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_dst));

	<span class="enscript-keyword">switch</span> (protocol) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>: {
			<span class="enscript-type">struct</span> tcphdr th;
			<span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)(hlen + <span class="enscript-keyword">sizeof</span>(th)) &lt;= packet-&gt;m_pkthdr.len) {
				m_copydata(packet, hlen, <span class="enscript-keyword">sizeof</span>(th), (u_int8_t *)&amp;th);
				((<span class="enscript-type">struct</span> sockaddr_in *)&amp;local_addr)-&gt;sin_port = th.th_sport;
				((<span class="enscript-type">struct</span> sockaddr_in *)&amp;remote_addr)-&gt;sin_port = th.th_dport;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>: {
			<span class="enscript-type">struct</span> udphdr uh;
			<span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)(hlen + <span class="enscript-keyword">sizeof</span>(uh)) &lt;= packet-&gt;m_pkthdr.len) {
				m_copydata(packet, hlen, <span class="enscript-keyword">sizeof</span>(uh), (u_int8_t *)&amp;uh);
				((<span class="enscript-type">struct</span> sockaddr_in *)&amp;local_addr)-&gt;sin_port = uh.uh_sport;
				((<span class="enscript-type">struct</span> sockaddr_in *)&amp;remote_addr)-&gt;sin_port = uh.uh_dport;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>: {
			((<span class="enscript-type">struct</span> sockaddr_in *)&amp;local_addr)-&gt;sin_port = 0;
			((<span class="enscript-type">struct</span> sockaddr_in *)&amp;remote_addr)-&gt;sin_port = 0;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">// Match packet to policy
</span>	lck_rw_lock_shared(&amp;necp_kernel_policy_lock);
	matched_policy = necp_ip_output_find_policy_match_locked(socket_policy_id, bound_interface_index, last_interface_index, protocol, &amp;local_addr, &amp;remote_addr);
	<span class="enscript-keyword">if</span> (matched_policy) {
		matched_policy_id = matched_policy-&gt;id;
		<span class="enscript-keyword">if</span> (result) {
			*result = matched_policy-&gt;result;
		}

		<span class="enscript-keyword">if</span> (result_parameter) {
			memcpy(result_parameter, &amp;matched_policy-&gt;result_parameter, <span class="enscript-keyword">sizeof</span>(matched_policy-&gt;result_parameter));
		}

		<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
			NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;IP Output: (ID %d BoundInterface %d LastInterface %d Proto %d) Policy %d Result %d Parameter %d&quot;</span>, socket_policy_id, bound_interface_index, last_interface_index, protocol, matched_policy-&gt;id, matched_policy-&gt;result, matched_policy-&gt;result_parameter.tunnel_interface_index);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (necp_drop_all_order &gt; 0) {
		matched_policy_id = NECP_KERNEL_POLICY_ID_NO_MATCH;
		<span class="enscript-keyword">if</span> (result) {
			*result = NECP_KERNEL_POLICY_RESULT_DROP;
		}
	}

	lck_rw_done(&amp;necp_kernel_policy_lock);

	<span class="enscript-keyword">return</span> (matched_policy_id);
}

necp_kernel_policy_id
<span class="enscript-function-name">necp_ip6_output_find_policy_match</span>(<span class="enscript-type">struct</span> mbuf *packet, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> ip6_out_args *ip6oa, necp_kernel_policy_result *result, necp_kernel_policy_result_parameter *result_parameter)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = NULL;
	<span class="enscript-type">int</span> next = -1;
	<span class="enscript-type">int</span> offset = 0;
	necp_kernel_policy_id socket_policy_id = NECP_KERNEL_POLICY_ID_NONE;
	necp_kernel_policy_id matched_policy_id = NECP_KERNEL_POLICY_ID_NONE;
	<span class="enscript-type">struct</span> necp_kernel_ip_output_policy *matched_policy = NULL;
	u_int16_t protocol = 0;
	u_int32_t bound_interface_index = 0;
	u_int32_t last_interface_index = 0;
	<span class="enscript-type">union</span> necp_sockaddr_union local_addr;
	<span class="enscript-type">union</span> necp_sockaddr_union remote_addr;

	<span class="enscript-keyword">if</span> (result) {
		*result = 0;
	}

	<span class="enscript-keyword">if</span> (result_parameter) {
		memset(result_parameter, 0, <span class="enscript-keyword">sizeof</span>(*result_parameter));
	}

	<span class="enscript-keyword">if</span> (packet == NULL) {
		<span class="enscript-keyword">return</span> (NECP_KERNEL_POLICY_ID_NONE);
	}

	socket_policy_id = necp_get_policy_id_from_packet(packet);
	
	<span class="enscript-comment">// Exit early for an empty list
</span>	<span class="enscript-comment">// Don't lock. Possible race condition, but we don't want the performance hit.
</span>	<span class="enscript-keyword">if</span> (necp_kernel_ip_output_policies_count == 0 ||
		((socket_policy_id == NECP_KERNEL_POLICY_ID_NONE) &amp;&amp; necp_kernel_ip_output_policies_non_id_count == 0)) {
		<span class="enscript-keyword">if</span> (necp_drop_all_order &gt; 0) {
			matched_policy_id = NECP_KERNEL_POLICY_ID_NO_MATCH;
			<span class="enscript-keyword">if</span> (result) {
				<span class="enscript-keyword">if</span> ((necp_pass_loopback &gt; 0 &amp;&amp;
					 necp_is_loopback(NULL, NULL, NULL, packet)) ||
					(necp_pass_keepalives &gt; 0 &amp;&amp;
					 necp_get_is_keepalive_from_packet(packet))) {
					*result = NECP_KERNEL_POLICY_RESULT_PASS;
				} <span class="enscript-keyword">else</span> {
					*result = NECP_KERNEL_POLICY_RESULT_DROP;
				}
			}
		}

		<span class="enscript-keyword">return</span> (matched_policy_id);
	}
	
	<span class="enscript-comment">// Check for loopback exception
</span>	<span class="enscript-keyword">if</span> ((necp_pass_loopback &gt; 0 &amp;&amp;
		 necp_is_loopback(NULL, NULL, NULL, packet)) ||
		(necp_pass_keepalives &gt; 0 &amp;&amp;
		 necp_get_is_keepalive_from_packet(packet))) {
		matched_policy_id = NECP_KERNEL_POLICY_ID_NO_MATCH;
		<span class="enscript-keyword">if</span> (result) {
			*result = NECP_KERNEL_POLICY_RESULT_PASS;
		}
		<span class="enscript-keyword">return</span> (matched_policy_id);
	}
	
	last_interface_index = necp_get_last_interface_index_from_packet(packet);

	<span class="enscript-comment">// Process packet to get relevant fields
</span>	ip6 = mtod(packet, <span class="enscript-type">struct</span> ip6_hdr *);

	<span class="enscript-keyword">if</span> ((flags &amp; IPV6_OUTARGS) &amp;&amp; (ip6oa != NULL) &amp;&amp;
		(ip6oa-&gt;ip6oa_flags &amp; IP6OAF_BOUND_IF) &amp;&amp;
		ip6oa-&gt;ip6oa_boundif != IFSCOPE_NONE) {
		bound_interface_index = ip6oa-&gt;ip6oa_boundif;
	}

	((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;local_addr)-&gt;sin6_family = AF_INET6;
	((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;local_addr)-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	memcpy(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;local_addr)-&gt;sin6_addr, &amp;ip6-&gt;ip6_src, <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_src));

	((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;remote_addr)-&gt;sin6_family = AF_INET6;
	((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;remote_addr)-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	memcpy(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;remote_addr)-&gt;sin6_addr, &amp;ip6-&gt;ip6_dst, <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_dst));

	offset = ip6_lasthdr(packet, 0, IPPROTO_IPV6, &amp;next);
	<span class="enscript-keyword">if</span> (offset &gt;= 0 &amp;&amp; packet-&gt;m_pkthdr.len &gt;= offset) {
		protocol = next;
		<span class="enscript-keyword">switch</span> (protocol) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>: {
				<span class="enscript-type">struct</span> tcphdr th;
				<span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)(offset + <span class="enscript-keyword">sizeof</span>(th)) &lt;= packet-&gt;m_pkthdr.len) {
					m_copydata(packet, offset, <span class="enscript-keyword">sizeof</span>(th), (u_int8_t *)&amp;th);
					((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;local_addr)-&gt;sin6_port = th.th_sport;
					((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;remote_addr)-&gt;sin6_port = th.th_dport;
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>: {
				<span class="enscript-type">struct</span> udphdr uh;
				<span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)(offset + <span class="enscript-keyword">sizeof</span>(uh)) &lt;= packet-&gt;m_pkthdr.len) {
					m_copydata(packet, offset, <span class="enscript-keyword">sizeof</span>(uh), (u_int8_t *)&amp;uh);
					((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;local_addr)-&gt;sin6_port = uh.uh_sport;
					((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;remote_addr)-&gt;sin6_port = uh.uh_dport;
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-reference">default</span>: {
				((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;local_addr)-&gt;sin6_port = 0;
				((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;remote_addr)-&gt;sin6_port = 0;
				<span class="enscript-keyword">break</span>;
			}
		}
	}

	<span class="enscript-comment">// Match packet to policy
</span>	lck_rw_lock_shared(&amp;necp_kernel_policy_lock);
	matched_policy = necp_ip_output_find_policy_match_locked(socket_policy_id, bound_interface_index, last_interface_index, protocol, &amp;local_addr, &amp;remote_addr);
	<span class="enscript-keyword">if</span> (matched_policy) {
		matched_policy_id = matched_policy-&gt;id;
		<span class="enscript-keyword">if</span> (result) {
			*result = matched_policy-&gt;result;
		}

		<span class="enscript-keyword">if</span> (result_parameter) {
			memcpy(result_parameter, &amp;matched_policy-&gt;result_parameter, <span class="enscript-keyword">sizeof</span>(matched_policy-&gt;result_parameter));
		}

		<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
			NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;IP6 Output: (ID %d BoundInterface %d LastInterface %d Proto %d) Policy %d Result %d Parameter %d&quot;</span>, socket_policy_id, bound_interface_index, last_interface_index, protocol, matched_policy-&gt;id, matched_policy-&gt;result, matched_policy-&gt;result_parameter.tunnel_interface_index);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (necp_drop_all_order &gt; 0) {
		matched_policy_id = NECP_KERNEL_POLICY_ID_NO_MATCH;
		<span class="enscript-keyword">if</span> (result) {
			*result = NECP_KERNEL_POLICY_RESULT_DROP;
		}
	}

	lck_rw_done(&amp;necp_kernel_policy_lock);

	<span class="enscript-keyword">return</span> (matched_policy_id);
}

<span class="enscript-comment">// Utilities
</span><span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_is_addr_in_range</span>(<span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">struct</span> sockaddr *range_start, <span class="enscript-type">struct</span> sockaddr *range_end)
{
	<span class="enscript-type">int</span> cmp = 0;

	<span class="enscript-keyword">if</span> (addr == NULL || range_start == NULL || range_end == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-comment">/* Must be greater than or equal to start */</span>
	cmp = necp_addr_compare(addr, range_start, 1);
	<span class="enscript-keyword">if</span> (cmp != 0 &amp;&amp; cmp != 1) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-comment">/* Must be less than or equal to end */</span>
	cmp = necp_addr_compare(addr, range_end, 1);
	<span class="enscript-keyword">if</span> (cmp != 0 &amp;&amp; cmp != -1) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_is_range_in_range</span>(<span class="enscript-type">struct</span> sockaddr *inner_range_start, <span class="enscript-type">struct</span> sockaddr *inner_range_end, <span class="enscript-type">struct</span> sockaddr *range_start, <span class="enscript-type">struct</span> sockaddr *range_end)
{
	<span class="enscript-type">int</span> cmp = 0;

	<span class="enscript-keyword">if</span> (inner_range_start == NULL || inner_range_end == NULL || range_start == NULL || range_end == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-comment">/* Must be greater than or equal to start */</span>
	cmp = necp_addr_compare(inner_range_start, range_start, 1);
	<span class="enscript-keyword">if</span> (cmp != 0 &amp;&amp; cmp != 1) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-comment">/* Must be less than or equal to end */</span>
	cmp = necp_addr_compare(inner_range_end, range_end, 1);
	<span class="enscript-keyword">if</span> (cmp != 0 &amp;&amp; cmp != -1) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_is_addr_in_subnet</span>(<span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">struct</span> sockaddr *subnet_addr, u_int8_t subnet_prefix)
{
	<span class="enscript-keyword">if</span> (addr == NULL || subnet_addr == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-keyword">if</span> (addr-&gt;sa_family != subnet_addr-&gt;sa_family || addr-&gt;sa_len != subnet_addr-&gt;sa_len) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-keyword">switch</span> (addr-&gt;sa_family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
			<span class="enscript-keyword">if</span> (satosin(subnet_addr)-&gt;sin_port != 0 &amp;&amp;
				satosin(addr)-&gt;sin_port != satosin(subnet_addr)-&gt;sin_port) {
				<span class="enscript-keyword">return</span> (FALSE);
			}
			<span class="enscript-keyword">return</span> (necp_buffer_compare_with_bit_prefix((u_int8_t *)&amp;satosin(addr)-&gt;sin_addr, (u_int8_t *)&amp;satosin(subnet_addr)-&gt;sin_addr, subnet_prefix));
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
			<span class="enscript-keyword">if</span> (satosin6(subnet_addr)-&gt;sin6_port != 0 &amp;&amp;
				satosin6(addr)-&gt;sin6_port != satosin6(subnet_addr)-&gt;sin6_port) {
				<span class="enscript-keyword">return</span> (FALSE);
			}
			<span class="enscript-keyword">if</span> (satosin6(addr)-&gt;sin6_scope_id &amp;&amp;
				satosin6(subnet_addr)-&gt;sin6_scope_id &amp;&amp;
				satosin6(addr)-&gt;sin6_scope_id != satosin6(subnet_addr)-&gt;sin6_scope_id) {
				<span class="enscript-keyword">return</span> (FALSE);
			}
			<span class="enscript-keyword">return</span> (necp_buffer_compare_with_bit_prefix((u_int8_t *)&amp;satosin6(addr)-&gt;sin6_addr, (u_int8_t *)&amp;satosin6(subnet_addr)-&gt;sin6_addr, subnet_prefix));
		}
		<span class="enscript-reference">default</span>: {
			<span class="enscript-keyword">return</span> (FALSE);
		}
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-comment">/*
 * Return values:
 * -1: sa1 &lt; sa2
 * 0: sa1 == sa2
 * 1: sa1 &gt; sa2
 * 2: Not comparable or error
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">necp_addr_compare</span>(<span class="enscript-type">struct</span> sockaddr *sa1, <span class="enscript-type">struct</span> sockaddr *sa2, <span class="enscript-type">int</span> check_port)
{
	<span class="enscript-type">int</span> result = 0;
	<span class="enscript-type">int</span> port_result = 0;

	<span class="enscript-keyword">if</span> (sa1-&gt;sa_family != sa2-&gt;sa_family || sa1-&gt;sa_len != sa2-&gt;sa_len) {
		<span class="enscript-keyword">return</span> (2);
	}

	<span class="enscript-keyword">if</span> (sa1-&gt;sa_len == 0) {
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">switch</span> (sa1-&gt;sa_family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
			<span class="enscript-keyword">if</span> (sa1-&gt;sa_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in)) {
				<span class="enscript-keyword">return</span> (2);
			}

			result = memcmp(&amp;satosin(sa1)-&gt;sin_addr.s_addr, &amp;satosin(sa2)-&gt;sin_addr.s_addr, <span class="enscript-keyword">sizeof</span>(satosin(sa1)-&gt;sin_addr.s_addr));

			<span class="enscript-keyword">if</span> (check_port) {
				<span class="enscript-keyword">if</span> (satosin(sa1)-&gt;sin_port &lt; satosin(sa2)-&gt;sin_port) {
					port_result = -1;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (satosin(sa1)-&gt;sin_port &gt; satosin(sa2)-&gt;sin_port) {
					port_result = 1;
				}

				<span class="enscript-keyword">if</span> (result == 0) {
					result = port_result;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((result &gt; 0 &amp;&amp; port_result &lt; 0) || (result &lt; 0 &amp;&amp; port_result &gt; 0)) {
					<span class="enscript-keyword">return</span> (2);
				}
			}

			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
			<span class="enscript-keyword">if</span> (sa1-&gt;sa_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6)) {
				<span class="enscript-keyword">return</span> (2);
			}

			<span class="enscript-keyword">if</span> (satosin6(sa1)-&gt;sin6_scope_id != satosin6(sa2)-&gt;sin6_scope_id) {
				<span class="enscript-keyword">return</span> (2);
			}

			result = memcmp(&amp;satosin6(sa1)-&gt;sin6_addr.s6_addr[0], &amp;satosin6(sa2)-&gt;sin6_addr.s6_addr[0], <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));

			<span class="enscript-keyword">if</span> (check_port) {
				<span class="enscript-keyword">if</span> (satosin6(sa1)-&gt;sin6_port &lt; satosin6(sa2)-&gt;sin6_port) {
					port_result = -1;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (satosin6(sa1)-&gt;sin6_port &gt; satosin6(sa2)-&gt;sin6_port) {
					port_result = 1;
				}

				<span class="enscript-keyword">if</span> (result == 0) {
					result = port_result;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((result &gt; 0 &amp;&amp; port_result &lt; 0) || (result &lt; 0 &amp;&amp; port_result &gt; 0)) {
					<span class="enscript-keyword">return</span> (2);
				}
			}

			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>: {
			result = memcmp(sa1, sa2, sa1-&gt;sa_len);
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (result &lt; 0) {
		result = (-1);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result &gt; 0) {
		result = (1);
	}

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_buffer_compare_with_bit_prefix</span>(u_int8_t *p1, u_int8_t *p2, u_int32_t bits)
{
	u_int8_t mask;

	<span class="enscript-comment">/* Handle null pointers */</span>
	<span class="enscript-keyword">if</span> (p1 == NULL || p2 == NULL) {
		<span class="enscript-keyword">return</span> (p1 == p2);
	}

	<span class="enscript-keyword">while</span> (bits &gt;= 8) {
		<span class="enscript-keyword">if</span> (*p1++ != *p2++) {
			<span class="enscript-keyword">return</span> (FALSE);
		}
		bits -= 8;
	}

	<span class="enscript-keyword">if</span> (bits &gt; 0) {
		mask = ~((1&lt;&lt;(8-bits))-1);
		<span class="enscript-keyword">if</span> ((*p1 &amp; mask) != (*p2 &amp; mask)) {
			<span class="enscript-keyword">return</span> (FALSE);
		}
	}
	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-comment">// Socket operations
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NECP_MAX_SOCKET_ATTRIBUTE_STRING_LENGTH</span> 253

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_set_socket_attribute</span>(u_int8_t *buffer, size_t buffer_length, u_int8_t type, <span class="enscript-type">char</span> **buffer_p)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> cursor = 0;
	size_t string_size = 0;
	<span class="enscript-type">char</span> *local_string = NULL;
	u_int8_t *value = NULL;

	cursor = necp_buffer_find_tlv(buffer, buffer_length, 0, type, 0);
	<span class="enscript-keyword">if</span> (cursor &lt; 0) {
		<span class="enscript-comment">// This will clear out the parameter
</span>		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	string_size = necp_buffer_get_tlv_length(buffer, cursor);
	<span class="enscript-keyword">if</span> (string_size == 0 || string_size &gt; NECP_MAX_SOCKET_ATTRIBUTE_STRING_LENGTH) {
		<span class="enscript-comment">// This will clear out the parameter
</span>		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	MALLOC(local_string, <span class="enscript-type">char</span> *, string_size + 1, M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (local_string == NULL) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to allocate a socket attribute buffer (size %d)&quot;</span>, string_size);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	value = necp_buffer_get_tlv_value(buffer, cursor, NULL);
	<span class="enscript-keyword">if</span> (value == NULL) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Failed to get socket attribute&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	memcpy(local_string, value, string_size);
	local_string[string_size] = 0;

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (*buffer_p != NULL) {
		FREE(*buffer_p, M_NECP);
		*buffer_p = NULL;
	}

	*buffer_p = local_string;
	<span class="enscript-keyword">return</span> (0);
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (local_string != NULL) {
		FREE(local_string, M_NECP);
	}
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">necp_set_socket_attributes</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">int</span> error = 0;
	u_int8_t *buffer = NULL;
	<span class="enscript-type">struct</span> inpcb *inp = NULL;
    
    <span class="enscript-keyword">if</span> ((SOCK_DOM(so) != PF_INET
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
         &amp;&amp; SOCK_DOM(so) != PF_INET6
#<span class="enscript-reference">endif</span>
         )) {
        error = EINVAL;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    
	inp = sotoinpcb(so);

	size_t valsize = sopt-&gt;sopt_valsize;
	<span class="enscript-keyword">if</span> (valsize == 0 ||
		valsize &gt; ((<span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + NECP_MAX_SOCKET_ATTRIBUTE_STRING_LENGTH) * 2)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	MALLOC(buffer, u_int8_t *, valsize, M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (buffer == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = sooptcopyin(sopt, buffer, valsize, 0);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = necp_set_socket_attribute(buffer, valsize, NECP_TLV_ATTRIBUTE_DOMAIN, &amp;inp-&gt;inp_necp_attributes.inp_domain);
	<span class="enscript-keyword">if</span> (error) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Could not set domain TLV for socket attributes&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = necp_set_socket_attribute(buffer, valsize, NECP_TLV_ATTRIBUTE_ACCOUNT, &amp;inp-&gt;inp_necp_attributes.inp_account);
	<span class="enscript-keyword">if</span> (error) {
		NECPLOG0(LOG_ERR, <span class="enscript-string">&quot;Could not set account TLV for socket attributes&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (necp_debug) {
		NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Set on socket: Domain %s, Account %s&quot;</span>, inp-&gt;inp_necp_attributes.inp_domain, inp-&gt;inp_necp_attributes.inp_account);
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (buffer != NULL) {
		FREE(buffer, M_NECP);
	}

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">necp_get_socket_attributes</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">int</span> error = 0;
	u_int8_t *buffer = NULL;
	u_int8_t *cursor = NULL;
	size_t valsize = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	
	<span class="enscript-keyword">if</span> (inp-&gt;inp_necp_attributes.inp_domain != NULL) {
		valsize += <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + strlen(inp-&gt;inp_necp_attributes.inp_domain);
	}
	<span class="enscript-keyword">if</span> (inp-&gt;inp_necp_attributes.inp_account != NULL) {
		valsize += <span class="enscript-keyword">sizeof</span>(u_int8_t) + <span class="enscript-keyword">sizeof</span>(u_int32_t) + strlen(inp-&gt;inp_necp_attributes.inp_account);
	}
	<span class="enscript-keyword">if</span> (valsize == 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	MALLOC(buffer, u_int8_t *, valsize, M_NECP, M_WAITOK);
	<span class="enscript-keyword">if</span> (buffer == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	cursor = buffer;
	<span class="enscript-keyword">if</span> (inp-&gt;inp_necp_attributes.inp_domain != NULL) {
		cursor = necp_buffer_write_tlv(cursor, NECP_TLV_ATTRIBUTE_DOMAIN, strlen(inp-&gt;inp_necp_attributes.inp_domain), inp-&gt;inp_necp_attributes.inp_domain);
	}

	<span class="enscript-keyword">if</span> (inp-&gt;inp_necp_attributes.inp_account != NULL) {
		cursor = necp_buffer_write_tlv(cursor, NECP_TLV_ATTRIBUTE_ACCOUNT, strlen(inp-&gt;inp_necp_attributes.inp_account), inp-&gt;inp_necp_attributes.inp_account);
	}

	error = sooptcopyout(sopt, buffer, valsize);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (buffer != NULL) {
		FREE(buffer, M_NECP);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_route_is_allowed_inner</span>(<span class="enscript-type">struct</span> rtentry *route, <span class="enscript-type">struct</span> ifnet *ifp, u_int32_t route_rule_id, bool *cellular_denied)
{
	bool default_is_allowed = TRUE;
	u_int8_t type_aggregate_action = NECP_ROUTE_RULE_NONE;
	<span class="enscript-type">int</span> exception_index = 0;
	<span class="enscript-type">struct</span> ifnet *delegated_ifp = NULL;
	<span class="enscript-type">struct</span> necp_route_rule *route_rule = NULL;

	route_rule = necp_lookup_route_rule_locked(&amp;necp_route_rules, route_rule_id);
	<span class="enscript-keyword">if</span> (route_rule == NULL) {
		<span class="enscript-keyword">return</span> (TRUE);
	}

	default_is_allowed = (route_rule-&gt;default_action == NECP_ROUTE_RULE_DENY_INTERFACE) ? FALSE : TRUE;
	<span class="enscript-keyword">if</span> (ifp == NULL) {
		ifp = route-&gt;rt_ifp;
	}
	<span class="enscript-keyword">if</span> (ifp == NULL) {
		<span class="enscript-keyword">if</span> (necp_debug &gt; 1 &amp;&amp; !default_is_allowed) {
			NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Route Allowed: No interface for route, using default for Rule %d Allowed %d&quot;</span>, route_rule_id, default_is_allowed);
		}
		<span class="enscript-keyword">return</span> (default_is_allowed);
	}

	delegated_ifp = ifp-&gt;if_delegated.ifp;
	<span class="enscript-keyword">for</span> (exception_index = 0; exception_index &lt; MAX_ROUTE_RULE_INTERFACES; exception_index++) {
		<span class="enscript-keyword">if</span> (route_rule-&gt;exception_if_indices[exception_index] == 0) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (route_rule-&gt;exception_if_indices[exception_index] == ifp-&gt;if_index ||
			(delegated_ifp != NULL &amp;&amp; route_rule-&gt;exception_if_indices[exception_index] == delegated_ifp-&gt;if_index)) {
			<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
				NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Route Allowed: Interface match %d for Rule %d Allowed %d&quot;</span>, route_rule-&gt;exception_if_indices[exception_index], route_rule_id, ((route_rule-&gt;exception_if_actions[exception_index] == NECP_ROUTE_RULE_DENY_INTERFACE) ? FALSE : TRUE));
			}
			<span class="enscript-keyword">return</span> ((route_rule-&gt;exception_if_actions[exception_index] == NECP_ROUTE_RULE_DENY_INTERFACE) ? FALSE : TRUE);
		}
	}

	<span class="enscript-keyword">if</span> (route_rule-&gt;cellular_action != NECP_ROUTE_RULE_NONE &amp;&amp;
		IFNET_IS_CELLULAR(ifp)) {
		<span class="enscript-keyword">if</span> (cellular_denied != NULL) {
			<span class="enscript-comment">// Let clients know that cellular was blocked
</span>			*cellular_denied = TRUE;
		}
		<span class="enscript-keyword">if</span> (type_aggregate_action == NECP_ROUTE_RULE_NONE ||
			(type_aggregate_action == NECP_ROUTE_RULE_ALLOW_INTERFACE &amp;&amp;
			 route_rule-&gt;cellular_action == NECP_ROUTE_RULE_DENY_INTERFACE)) {
				<span class="enscript-comment">// Deny wins if there is a conflict
</span>				type_aggregate_action = route_rule-&gt;cellular_action;
			}
	}

	<span class="enscript-keyword">if</span> (route_rule-&gt;wifi_action != NECP_ROUTE_RULE_NONE &amp;&amp;
		IFNET_IS_WIFI(ifp)) {
		<span class="enscript-keyword">if</span> (type_aggregate_action == NECP_ROUTE_RULE_NONE ||
			(type_aggregate_action == NECP_ROUTE_RULE_ALLOW_INTERFACE &amp;&amp;
			 route_rule-&gt;wifi_action == NECP_ROUTE_RULE_DENY_INTERFACE)) {
				<span class="enscript-comment">// Deny wins if there is a conflict
</span>				type_aggregate_action = route_rule-&gt;wifi_action;
			}
	}

	<span class="enscript-keyword">if</span> (route_rule-&gt;wired_action != NECP_ROUTE_RULE_NONE &amp;&amp;
		IFNET_IS_WIRED(ifp)) {
		<span class="enscript-keyword">if</span> (type_aggregate_action == NECP_ROUTE_RULE_NONE ||
			(type_aggregate_action == NECP_ROUTE_RULE_ALLOW_INTERFACE &amp;&amp;
			 route_rule-&gt;wired_action == NECP_ROUTE_RULE_DENY_INTERFACE)) {
				<span class="enscript-comment">// Deny wins if there is a conflict
</span>				type_aggregate_action = route_rule-&gt;wired_action;
			}
	}

	<span class="enscript-keyword">if</span> (route_rule-&gt;expensive_action != NECP_ROUTE_RULE_NONE &amp;&amp;
		IFNET_IS_EXPENSIVE(ifp)) {
		<span class="enscript-keyword">if</span> (type_aggregate_action == NECP_ROUTE_RULE_NONE ||
			(type_aggregate_action == NECP_ROUTE_RULE_ALLOW_INTERFACE &amp;&amp;
			 route_rule-&gt;expensive_action == NECP_ROUTE_RULE_DENY_INTERFACE)) {
				<span class="enscript-comment">// Deny wins if there is a conflict
</span>				type_aggregate_action = route_rule-&gt;expensive_action;
			}
	}

	<span class="enscript-keyword">if</span> (type_aggregate_action != NECP_ROUTE_RULE_NONE) {
		<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
			NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Route Allowed: C:%d WF:%d W:%d E:%d for Rule %d Allowed %d&quot;</span>, route_rule-&gt;cellular_action, route_rule-&gt;wifi_action, route_rule-&gt;wired_action, route_rule-&gt;expensive_action, route_rule_id, ((type_aggregate_action == NECP_ROUTE_RULE_DENY_INTERFACE) ? FALSE : TRUE));
		}
		<span class="enscript-keyword">return</span> ((type_aggregate_action == NECP_ROUTE_RULE_DENY_INTERFACE) ? FALSE : TRUE);
	}

	<span class="enscript-keyword">if</span> (necp_debug &gt; 1 &amp;&amp; !default_is_allowed) {
		NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Route Allowed: Using default for Rule %d Allowed %d&quot;</span>, route_rule_id, default_is_allowed);
	}
	<span class="enscript-keyword">return</span> (default_is_allowed);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_route_is_allowed</span>(<span class="enscript-type">struct</span> rtentry *route, <span class="enscript-type">struct</span> ifnet *interface, u_int32_t route_rule_id, bool *cellular_denied)
{
	<span class="enscript-keyword">if</span> ((route == NULL &amp;&amp; interface == NULL) || route_rule_id == 0) {
		<span class="enscript-keyword">if</span> (necp_debug &gt; 1) {
			NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Route Allowed: no route or interface, Rule %d Allowed %d&quot;</span>, route_rule_id, TRUE);
		}
		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">if</span> (ROUTE_RULE_IS_AGGREGATE(route_rule_id)) {
		<span class="enscript-type">struct</span> necp_aggregate_route_rule *aggregate_route_rule = necp_lookup_aggregate_route_rule_locked(route_rule_id);
		<span class="enscript-keyword">if</span> (aggregate_route_rule != NULL) {
			<span class="enscript-type">int</span> index = 0;
			<span class="enscript-keyword">for</span> (index = 0; index &lt; MAX_AGGREGATE_ROUTE_RULES; index++) {
				u_int32_t sub_route_rule_id = aggregate_route_rule-&gt;rule_ids[index];
				<span class="enscript-keyword">if</span> (sub_route_rule_id == 0) {
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-keyword">if</span> (!necp_route_is_allowed_inner(route, interface, sub_route_rule_id, cellular_denied)) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (necp_route_is_allowed_inner(route, interface, route_rule_id, cellular_denied));
	}

	<span class="enscript-keyword">return</span> (TRUE);
}

bool
<span class="enscript-function-name">necp_packet_is_allowed_over_interface</span>(<span class="enscript-type">struct</span> mbuf *packet, <span class="enscript-type">struct</span> ifnet *interface)
{
	bool is_allowed = TRUE;
	u_int32_t route_rule_id = necp_get_route_rule_id_from_packet(packet);
	<span class="enscript-keyword">if</span> (route_rule_id != 0 &amp;&amp;
		interface != NULL) {
		lck_rw_lock_shared(&amp;necp_kernel_policy_lock);
		is_allowed = necp_route_is_allowed(NULL, interface, necp_get_route_rule_id_from_packet(packet), NULL);
		lck_rw_done(&amp;necp_kernel_policy_lock);
	}
	<span class="enscript-keyword">return</span> (is_allowed);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_netagents_allow_traffic</span>(u_int32_t *netagent_ids, size_t netagent_id_count)
{
	size_t netagent_cursor;
	<span class="enscript-keyword">for</span> (netagent_cursor = 0; netagent_cursor &lt; netagent_id_count; netagent_cursor++) {
		<span class="enscript-type">struct</span> necp_uuid_id_mapping *mapping = NULL;
		u_int32_t netagent_id = netagent_ids[netagent_cursor];
		<span class="enscript-keyword">if</span> (netagent_id == 0) {
			<span class="enscript-keyword">break</span>;
		}
		mapping = necp_uuid_lookup_uuid_with_service_id_locked(netagent_id);
		<span class="enscript-keyword">if</span> (mapping != NULL) {
			u_int32_t agent_flags = 0;
			agent_flags = netagent_get_flags(mapping-&gt;uuid);
			<span class="enscript-keyword">if</span> (agent_flags &amp; NETAGENT_FLAG_REGISTERED) {
				<span class="enscript-keyword">if</span> (agent_flags &amp; NETAGENT_FLAG_ACTIVE) {
					<span class="enscript-keyword">continue</span>;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((agent_flags &amp; NETAGENT_FLAG_VOLUNTARY) == 0) {
					<span class="enscript-keyword">return</span> (FALSE);
				}
			}
		}
	}
	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_socket_is_allowed_to_send_recv_internal</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> sockaddr *override_local_addr, <span class="enscript-type">struct</span> sockaddr *override_remote_addr, ifnet_t interface, necp_kernel_policy_id *return_policy_id, u_int32_t *return_route_rule_id)
{
	u_int32_t verifyifindex = interface ? interface-&gt;if_index : 0;
	bool allowed_to_receive = TRUE;
	<span class="enscript-type">struct</span> necp_socket_info info;
	u_int32_t flowhash = 0;
	necp_kernel_policy_result service_action = 0;
	necp_kernel_policy_service service = { 0, 0 };
	u_int32_t route_rule_id = 0;
	<span class="enscript-type">struct</span> rtentry *route = NULL;
	bool cellular_denied = FALSE;

	u_int32_t netagent_ids[NECP_MAX_NETAGENTS];
	memset(&amp;netagent_ids, 0, <span class="enscript-keyword">sizeof</span>(netagent_ids));

	<span class="enscript-keyword">if</span> (return_policy_id) {
		*return_policy_id = NECP_KERNEL_POLICY_ID_NONE;
	}
	<span class="enscript-keyword">if</span> (return_route_rule_id) {
		*return_route_rule_id = 0;
	}

	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	route = inp-&gt;inp_route.ro_rt;

	<span class="enscript-comment">// Don't lock. Possible race condition, but we don't want the performance hit.
</span>	<span class="enscript-keyword">if</span> (necp_kernel_socket_policies_count == 0 ||
		(!(inp-&gt;inp_flags2 &amp; INP2_WANT_APP_POLICY) &amp;&amp; necp_kernel_socket_policies_non_app_count == 0)) {
		<span class="enscript-keyword">if</span> (necp_drop_all_order &gt; 0) {
			<span class="enscript-keyword">if</span> (necp_pass_loopback &gt; 0 &amp;&amp;
				necp_is_loopback(override_local_addr, override_remote_addr, inp, NULL)) {
				allowed_to_receive = TRUE;
			} <span class="enscript-keyword">else</span> {
				allowed_to_receive = FALSE;
			}
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">// If this socket is connected, or we are not taking addresses into account, try to reuse last result
</span>	<span class="enscript-keyword">if</span> ((necp_socket_is_connected(inp) || (override_local_addr == NULL &amp;&amp; override_remote_addr == NULL)) &amp;&amp; inp-&gt;inp_policyresult.policy_id != NECP_KERNEL_POLICY_ID_NONE) {
		bool policies_have_changed = FALSE;
		bool route_allowed = TRUE;
		lck_rw_lock_shared(&amp;necp_kernel_policy_lock);
		<span class="enscript-keyword">if</span> (inp-&gt;inp_policyresult.policy_gencount != necp_kernel_socket_policies_gencount) {
			policies_have_changed = TRUE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (inp-&gt;inp_policyresult.results.route_rule_id != 0 &amp;&amp;
				!necp_route_is_allowed(route, interface, inp-&gt;inp_policyresult.results.route_rule_id, &amp;cellular_denied)) {
				route_allowed = FALSE;
			}
		}
		lck_rw_done(&amp;necp_kernel_policy_lock);

		<span class="enscript-keyword">if</span> (!policies_have_changed) {
			<span class="enscript-keyword">if</span> (!route_allowed ||
				inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_DROP ||
				inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_SOCKET_DIVERT ||
				(inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_IP_TUNNEL &amp;&amp; interface &amp;&amp;
				inp-&gt;inp_policyresult.results.result_parameter.tunnel_interface_index != verifyifindex)) {
					allowed_to_receive = FALSE;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (return_policy_id) {
						*return_policy_id = inp-&gt;inp_policyresult.policy_id;
					}
					<span class="enscript-keyword">if</span> (return_route_rule_id) {
						*return_route_rule_id = inp-&gt;inp_policyresult.results.route_rule_id;
					}
				}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	<span class="enscript-comment">// Check for loopback exception
</span>	<span class="enscript-keyword">if</span> (necp_pass_loopback &gt; 0 &amp;&amp;
		necp_is_loopback(override_local_addr, override_remote_addr, inp, NULL)) {
		allowed_to_receive = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">// Actually calculate policy result
</span>	lck_rw_lock_shared(&amp;necp_kernel_policy_lock);
	necp_socket_fillout_info_locked(inp, override_local_addr, override_remote_addr, 0, &amp;info);

	flowhash = necp_socket_calc_flowhash_locked(&amp;info);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_policyresult.policy_id != NECP_KERNEL_POLICY_ID_NONE &amp;&amp;
		inp-&gt;inp_policyresult.policy_gencount == necp_kernel_socket_policies_gencount &amp;&amp;
		inp-&gt;inp_policyresult.flowhash == flowhash) {
		<span class="enscript-keyword">if</span> (inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_DROP ||
			inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_SOCKET_DIVERT ||
			(inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_IP_TUNNEL &amp;&amp; interface &amp;&amp;
			inp-&gt;inp_policyresult.results.result_parameter.tunnel_interface_index != verifyifindex) ||
			(inp-&gt;inp_policyresult.results.route_rule_id != 0 &amp;&amp;
			 !necp_route_is_allowed(route, interface, inp-&gt;inp_policyresult.results.route_rule_id, &amp;cellular_denied))) {
			allowed_to_receive = FALSE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (return_policy_id) {
				*return_policy_id = inp-&gt;inp_policyresult.policy_id;
			}
			<span class="enscript-keyword">if</span> (return_route_rule_id) {
				*return_route_rule_id = inp-&gt;inp_policyresult.results.route_rule_id;
			}
		}
		lck_rw_done(&amp;necp_kernel_policy_lock);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-type">struct</span> necp_kernel_socket_policy *matched_policy = necp_socket_find_policy_match_with_info_locked(necp_kernel_socket_policies_map[NECP_SOCKET_MAP_APP_ID_TO_BUCKET(info.application_id)], &amp;info, NULL, &amp;route_rule_id, &amp;service_action, &amp;service, netagent_ids, NECP_MAX_NETAGENTS);
	<span class="enscript-keyword">if</span> (matched_policy != NULL) {
		<span class="enscript-keyword">if</span> (matched_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_DROP ||
			matched_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_SOCKET_DIVERT ||
			(matched_policy-&gt;result == NECP_KERNEL_POLICY_RESULT_IP_TUNNEL &amp;&amp; interface &amp;&amp;
			matched_policy-&gt;result_parameter.tunnel_interface_index != verifyifindex) ||
			((service_action == NECP_KERNEL_POLICY_RESULT_TRIGGER_SCOPED ||
			  service_action == NECP_KERNEL_POLICY_RESULT_NO_TRIGGER_SCOPED) &amp;&amp;
			 service.identifier != 0 &amp;&amp; service.identifier != NECP_NULL_SERVICE_ID) ||
			(route_rule_id != 0 &amp;&amp;
			 !necp_route_is_allowed(route, interface, route_rule_id, &amp;cellular_denied)) ||
			!necp_netagents_allow_traffic(netagent_ids, NECP_MAX_NETAGENTS)) {
			allowed_to_receive = FALSE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (return_policy_id) {
				*return_policy_id = matched_policy-&gt;id;
			}
			<span class="enscript-keyword">if</span> (return_route_rule_id) {
				*return_route_rule_id = route_rule_id;
			}
		}
		lck_rw_done(&amp;necp_kernel_policy_lock);

		<span class="enscript-keyword">if</span> (necp_debug &gt; 1 &amp;&amp; matched_policy-&gt;id != inp-&gt;inp_policyresult.policy_id) {
			NECPLOG(LOG_DEBUG, <span class="enscript-string">&quot;Socket Send/Recv Policy: Policy %d Allowed %d&quot;</span>, return_policy_id ? *return_policy_id : 0, allowed_to_receive);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (necp_drop_all_order &gt; 0) {
		allowed_to_receive = FALSE;
	}

	lck_rw_done(&amp;necp_kernel_policy_lock);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (!allowed_to_receive &amp;&amp; cellular_denied) {
		soevent(inp-&gt;inp_socket, (SO_FILT_HINT_LOCKED | SO_FILT_HINT_IFDENIED));
	}

	<span class="enscript-keyword">return</span> (allowed_to_receive);
}

bool
<span class="enscript-function-name">necp_socket_is_allowed_to_send_recv_v4</span>(<span class="enscript-type">struct</span> inpcb *inp, u_int16_t local_port, u_int16_t remote_port, <span class="enscript-type">struct</span> in_addr *local_addr, <span class="enscript-type">struct</span> in_addr *remote_addr, ifnet_t interface, necp_kernel_policy_id *return_policy_id, u_int32_t *return_route_rule_id)
{
	<span class="enscript-type">struct</span> sockaddr_in local;
	<span class="enscript-type">struct</span> sockaddr_in remote;
	local.sin_family = remote.sin_family = AF_INET;
	local.sin_len = remote.sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
	local.sin_port = local_port;
	remote.sin_port = remote_port;
	memcpy(&amp;local.sin_addr, local_addr, <span class="enscript-keyword">sizeof</span>(local.sin_addr));
	memcpy(&amp;remote.sin_addr, remote_addr, <span class="enscript-keyword">sizeof</span>(remote.sin_addr));

	<span class="enscript-keyword">return</span> (necp_socket_is_allowed_to_send_recv_internal(inp, (<span class="enscript-type">struct</span> sockaddr *)&amp;local, (<span class="enscript-type">struct</span> sockaddr *)&amp;remote, interface, return_policy_id, return_route_rule_id));
}

bool
<span class="enscript-function-name">necp_socket_is_allowed_to_send_recv_v6</span>(<span class="enscript-type">struct</span> inpcb *inp, u_int16_t local_port, u_int16_t remote_port, <span class="enscript-type">struct</span> in6_addr *local_addr, <span class="enscript-type">struct</span> in6_addr *remote_addr, ifnet_t interface, necp_kernel_policy_id *return_policy_id, u_int32_t *return_route_rule_id)
{
	<span class="enscript-type">struct</span> sockaddr_in6 local;
	<span class="enscript-type">struct</span> sockaddr_in6 remote;
	local.sin6_family = remote.sin6_family = AF_INET6;
	local.sin6_len = remote.sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	local.sin6_port = local_port;
	remote.sin6_port = remote_port;
	memcpy(&amp;local.sin6_addr, local_addr, <span class="enscript-keyword">sizeof</span>(local.sin6_addr));
	memcpy(&amp;remote.sin6_addr, remote_addr, <span class="enscript-keyword">sizeof</span>(remote.sin6_addr));

	<span class="enscript-keyword">return</span> (necp_socket_is_allowed_to_send_recv_internal(inp, (<span class="enscript-type">struct</span> sockaddr *)&amp;local, (<span class="enscript-type">struct</span> sockaddr *)&amp;remote, interface, return_policy_id, return_route_rule_id));
}

bool
<span class="enscript-function-name">necp_socket_is_allowed_to_send_recv</span>(<span class="enscript-type">struct</span> inpcb *inp, necp_kernel_policy_id *return_policy_id, u_int32_t *return_route_rule_id)
{
	<span class="enscript-keyword">return</span> (necp_socket_is_allowed_to_send_recv_internal(inp, NULL, NULL, NULL, return_policy_id, return_route_rule_id));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">necp_mark_packet_from_socket</span>(<span class="enscript-type">struct</span> mbuf *packet, <span class="enscript-type">struct</span> inpcb *inp, necp_kernel_policy_id policy_id, u_int32_t route_rule_id)
{
	<span class="enscript-keyword">if</span> (packet == NULL || inp == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">// Mark ID for Pass and IP Tunnel
</span>	<span class="enscript-keyword">if</span> (policy_id != NECP_KERNEL_POLICY_ID_NONE) {
		packet-&gt;m_pkthdr.necp_mtag.necp_policy_id = policy_id;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_PASS ||
		inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_IP_TUNNEL) {
		packet-&gt;m_pkthdr.necp_mtag.necp_policy_id = inp-&gt;inp_policyresult.policy_id;
	} <span class="enscript-keyword">else</span> {
		packet-&gt;m_pkthdr.necp_mtag.necp_policy_id = NECP_KERNEL_POLICY_ID_NONE;
	}
	packet-&gt;m_pkthdr.necp_mtag.necp_last_interface_index = 0;
	<span class="enscript-keyword">if</span> (route_rule_id != 0) {
		packet-&gt;m_pkthdr.necp_mtag.necp_route_rule_id = route_rule_id;
	} <span class="enscript-keyword">else</span> {
		packet-&gt;m_pkthdr.necp_mtag.necp_route_rule_id = inp-&gt;inp_policyresult.results.route_rule_id;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">necp_mark_packet_from_ip</span>(<span class="enscript-type">struct</span> mbuf *packet, necp_kernel_policy_id policy_id)
{
	<span class="enscript-keyword">if</span> (packet == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">// Mark ID for Pass and IP Tunnel
</span>	<span class="enscript-keyword">if</span> (policy_id != NECP_KERNEL_POLICY_ID_NONE) {
		packet-&gt;m_pkthdr.necp_mtag.necp_policy_id = policy_id;
	} <span class="enscript-keyword">else</span> {
		packet-&gt;m_pkthdr.necp_mtag.necp_policy_id = NECP_KERNEL_POLICY_ID_NONE;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">necp_mark_packet_from_interface</span>(<span class="enscript-type">struct</span> mbuf *packet, ifnet_t interface)
{
	<span class="enscript-keyword">if</span> (packet == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">// Mark ID for Pass and IP Tunnel
</span>	<span class="enscript-keyword">if</span> (interface != NULL) {
		packet-&gt;m_pkthdr.necp_mtag.necp_last_interface_index = interface-&gt;if_index;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">necp_mark_packet_as_keepalive</span>(<span class="enscript-type">struct</span> mbuf *packet, bool is_keepalive)
{
	<span class="enscript-keyword">if</span> (packet == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	
	<span class="enscript-keyword">if</span> (is_keepalive) {
		packet-&gt;m_pkthdr.pkt_flags |= PKTF_KEEPALIVE;
	} <span class="enscript-keyword">else</span> {
		packet-&gt;m_pkthdr.pkt_flags &amp;= ~PKTF_KEEPALIVE;
	}
	
	<span class="enscript-keyword">return</span> (0);
}

necp_kernel_policy_id
<span class="enscript-function-name">necp_get_policy_id_from_packet</span>(<span class="enscript-type">struct</span> mbuf *packet)
{
	<span class="enscript-keyword">if</span> (packet == NULL) {
		<span class="enscript-keyword">return</span> (NECP_KERNEL_POLICY_ID_NONE);
	}
	
	<span class="enscript-keyword">return</span> (packet-&gt;m_pkthdr.necp_mtag.necp_policy_id);
}

u_int32_t
<span class="enscript-function-name">necp_get_last_interface_index_from_packet</span>(<span class="enscript-type">struct</span> mbuf *packet)
{
	<span class="enscript-keyword">if</span> (packet == NULL) {
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (packet-&gt;m_pkthdr.necp_mtag.necp_last_interface_index);
}

u_int32_t
<span class="enscript-function-name">necp_get_route_rule_id_from_packet</span>(<span class="enscript-type">struct</span> mbuf *packet)
{
	<span class="enscript-keyword">if</span> (packet == NULL) {
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (packet-&gt;m_pkthdr.necp_mtag.necp_route_rule_id);
}

bool
<span class="enscript-function-name">necp_get_is_keepalive_from_packet</span>(<span class="enscript-type">struct</span> mbuf *packet)
{
	<span class="enscript-keyword">if</span> (packet == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}
	
	<span class="enscript-keyword">return</span> (packet-&gt;m_pkthdr.pkt_flags &amp; PKTF_KEEPALIVE);
}

u_int32_t
<span class="enscript-function-name">necp_socket_get_content_filter_control_unit</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">return</span> (inp-&gt;inp_policyresult.results.filter_control_unit);
}

bool
<span class="enscript-function-name">necp_socket_should_use_flow_divert</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-keyword">return</span> (inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_SOCKET_DIVERT);
}

u_int32_t
<span class="enscript-function-name">necp_socket_get_flow_divert_control_unit</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_SOCKET_DIVERT) {
		<span class="enscript-keyword">return</span> (inp-&gt;inp_policyresult.results.result_parameter.flow_divert_control_unit);
	}

	<span class="enscript-keyword">return</span> (0);
}

bool
<span class="enscript-function-name">necp_socket_should_rescope</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}
	
	<span class="enscript-keyword">return</span> (inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_SOCKET_SCOPED);
}

u_int
<span class="enscript-function-name">necp_socket_get_rescope_if_index</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span> (0);
	}
	
	<span class="enscript-keyword">if</span> (inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_SOCKET_SCOPED) {
		<span class="enscript-keyword">return</span> (inp-&gt;inp_policyresult.results.result_parameter.scoped_interface_index);
	}
	
	<span class="enscript-keyword">return</span> (0);
}

u_int32_t
<span class="enscript-function-name">necp_socket_get_effective_mtu</span>(<span class="enscript-type">struct</span> inpcb *inp, u_int32_t current_mtu)
{
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span> (current_mtu);
	}

	<span class="enscript-keyword">if</span> (inp-&gt;inp_policyresult.results.result == NECP_KERNEL_POLICY_RESULT_IP_TUNNEL &amp;&amp;
		(inp-&gt;inp_flags &amp; INP_BOUND_IF) &amp;&amp;
		inp-&gt;inp_boundifp) {

		u_int bound_interface_index = inp-&gt;inp_boundifp-&gt;if_index;
		u_int tunnel_interface_index = inp-&gt;inp_policyresult.results.result_parameter.tunnel_interface_index;

		<span class="enscript-comment">// The result is IP Tunnel, and is rescoping from one interface to another. Recalculate MTU.
</span>		<span class="enscript-keyword">if</span> (bound_interface_index != tunnel_interface_index) {
			ifnet_t tunnel_interface = NULL;

			ifnet_head_lock_shared();
			tunnel_interface = ifindex2ifnet[tunnel_interface_index];
			ifnet_head_done();

			<span class="enscript-keyword">if</span> (tunnel_interface != NULL) {
				u_int32_t direct_tunnel_mtu = tunnel_interface-&gt;if_mtu;
				u_int32_t delegate_tunnel_mtu = (tunnel_interface-&gt;if_delegated.ifp != NULL) ? tunnel_interface-&gt;if_delegated.ifp-&gt;if_mtu : 0;
				<span class="enscript-keyword">if</span> (delegate_tunnel_mtu != 0 &amp;&amp;
					strncmp(tunnel_interface-&gt;if_name, <span class="enscript-string">&quot;ipsec&quot;</span>, strlen(<span class="enscript-string">&quot;ipsec&quot;</span>)) == 0) {
						<span class="enscript-comment">// For ipsec interfaces, calculate the overhead from the delegate interface
</span>						u_int32_t tunnel_overhead = (u_int32_t)(esp_hdrsiz(NULL) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
						<span class="enscript-keyword">if</span> (delegate_tunnel_mtu &gt; tunnel_overhead) {
							delegate_tunnel_mtu -= tunnel_overhead;
						}

						<span class="enscript-keyword">if</span> (delegate_tunnel_mtu &lt; direct_tunnel_mtu) {
							<span class="enscript-comment">// If the (delegate - overhead) &lt; direct, return (delegate - overhead)
</span>							<span class="enscript-keyword">return</span> (delegate_tunnel_mtu);
						} <span class="enscript-keyword">else</span> {
							<span class="enscript-comment">// Otherwise return direct
</span>							<span class="enscript-keyword">return</span> (direct_tunnel_mtu);
						}
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">// For non-ipsec interfaces, just return the tunnel MTU
</span>					<span class="enscript-keyword">return</span> (direct_tunnel_mtu);
				}
			}
		}
	}

	<span class="enscript-comment">// By default, just return the MTU passed in
</span>	<span class="enscript-keyword">return</span> (current_mtu);
}

ifnet_t
<span class="enscript-function-name">necp_get_ifnet_from_result_parameter</span>(necp_kernel_policy_result_parameter *result_parameter)
{
	<span class="enscript-keyword">if</span> (result_parameter == NULL) {
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">return</span> (ifindex2ifnet[result_parameter-&gt;tunnel_interface_index]);
}

bool
<span class="enscript-function-name">necp_packet_can_rebind_to_ifnet</span>(<span class="enscript-type">struct</span> mbuf *packet, <span class="enscript-type">struct</span> ifnet *interface, <span class="enscript-type">struct</span> route *new_route, <span class="enscript-type">int</span> family)
{
	bool found_match = FALSE;
	errno_t result = 0;
	ifaddr_t *addresses = NULL;
	<span class="enscript-type">union</span> necp_sockaddr_union address_storage;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (packet == NULL || interface == NULL || new_route == NULL || (family != AF_INET &amp;&amp; family != AF_INET6)) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	result = ifnet_get_address_list_family(interface, &amp;addresses, family);
	<span class="enscript-keyword">if</span> (result != 0) {
		NECPLOG(LOG_ERR, <span class="enscript-string">&quot;Failed to get address list for %s%d&quot;</span>, ifnet_name(interface), ifnet_unit(interface));
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-keyword">for</span> (i = 0; addresses[i] != NULL; i++) {
		ROUTE_RELEASE(new_route);
		<span class="enscript-keyword">if</span> (ifaddr_address(addresses[i], &amp;address_storage.sa, <span class="enscript-keyword">sizeof</span>(address_storage)) == 0) {
			<span class="enscript-keyword">if</span> (family == AF_INET) {
				<span class="enscript-type">struct</span> ip *ip = mtod(packet, <span class="enscript-type">struct</span> ip *);
				<span class="enscript-keyword">if</span> (memcmp(&amp;address_storage.sin.sin_addr, &amp;ip-&gt;ip_src, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_src)) == 0) {
					<span class="enscript-type">struct</span> sockaddr_in *dst4 = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;new_route-&gt;ro_dst;
					dst4-&gt;sin_family = AF_INET;
					dst4-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
					dst4-&gt;sin_addr = ip-&gt;ip_dst;
					rtalloc_scoped(new_route, interface-&gt;if_index);
					<span class="enscript-keyword">if</span> (!ROUTE_UNUSABLE(new_route)) {
						found_match = TRUE;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
					}
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (family == AF_INET6) {
				<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(packet, <span class="enscript-type">struct</span> ip6_hdr *);
				<span class="enscript-keyword">if</span> (memcmp(&amp;address_storage.sin6.sin6_addr, &amp;ip6-&gt;ip6_src, <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_src)) == 0) {
					<span class="enscript-type">struct</span> sockaddr_in6 *dst6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)&amp;new_route-&gt;ro_dst;
					dst6-&gt;sin6_family = AF_INET6;
					dst6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
					dst6-&gt;sin6_addr = ip6-&gt;ip6_dst;
					rtalloc_scoped(new_route, interface-&gt;if_index);
					<span class="enscript-keyword">if</span> (!ROUTE_UNUSABLE(new_route)) {
						found_match = TRUE;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
					}
				}
			}
		}
	}

<span class="enscript-reference">done</span>:
	ifnet_free_address_list(addresses);
	addresses = NULL;
	<span class="enscript-keyword">return</span> (found_match);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_addr_is_loopback</span>(<span class="enscript-type">struct</span> sockaddr *address)
{
	<span class="enscript-keyword">if</span> (address == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}
	
	<span class="enscript-keyword">if</span> (address-&gt;sa_family == AF_INET) {
		<span class="enscript-keyword">return</span> (ntohl(((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)address)-&gt;sin_addr.s_addr) == INADDR_LOOPBACK);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (address-&gt;sa_family == AF_INET6) {
		<span class="enscript-keyword">return</span> IN6_IS_ADDR_LOOPBACK(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)address)-&gt;sin6_addr);
	}
	
	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> bool
<span class="enscript-function-name">necp_is_loopback</span>(<span class="enscript-type">struct</span> sockaddr *local_addr, <span class="enscript-type">struct</span> sockaddr *remote_addr, <span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> mbuf *packet)
{
	<span class="enscript-comment">// Note: This function only checks for the loopback addresses.
</span>	<span class="enscript-comment">// In the future, we may want to expand to also allow any traffic
</span>	<span class="enscript-comment">// going through the loopback interface, but until then, this
</span>	<span class="enscript-comment">// check is cheaper.
</span>
	<span class="enscript-keyword">if</span> (local_addr != NULL &amp;&amp; necp_addr_is_loopback(local_addr)) {
		<span class="enscript-keyword">return</span> (TRUE);
	}
	
	<span class="enscript-keyword">if</span> (remote_addr != NULL &amp;&amp; necp_addr_is_loopback(remote_addr)) {
		<span class="enscript-keyword">return</span> (TRUE);
	}
	
	<span class="enscript-keyword">if</span> (inp != NULL) {
		<span class="enscript-keyword">if</span> ((inp-&gt;inp_flags &amp; INP_BOUND_IF) &amp;&amp; inp-&gt;inp_boundifp &amp;&amp; (inp-&gt;inp_boundifp-&gt;if_flags &amp; IFF_LOOPBACK)) {
			<span class="enscript-keyword">return</span> (TRUE);
		}
		<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV4) {
			<span class="enscript-keyword">if</span> (ntohl(inp-&gt;inp_laddr.s_addr) == INADDR_LOOPBACK ||
				ntohl(inp-&gt;inp_faddr.s_addr) == INADDR_LOOPBACK) {
				<span class="enscript-keyword">return</span> (TRUE);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV6) {
			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LOOPBACK(&amp;inp-&gt;in6p_laddr) ||
				IN6_IS_ADDR_LOOPBACK(&amp;inp-&gt;in6p_faddr)) {
				<span class="enscript-keyword">return</span> (TRUE);
			}
		}
	}
	
	<span class="enscript-keyword">if</span> (packet != NULL) {
		<span class="enscript-type">struct</span> ip *ip = mtod(packet, <span class="enscript-type">struct</span> ip *);
		<span class="enscript-keyword">if</span> (ip-&gt;ip_v == 4) {
			<span class="enscript-keyword">if</span> (ntohl(ip-&gt;ip_src.s_addr) == INADDR_LOOPBACK) {
				<span class="enscript-keyword">return</span> (TRUE);
			}
			<span class="enscript-keyword">if</span> (ntohl(ip-&gt;ip_dst.s_addr) == INADDR_LOOPBACK) {
				<span class="enscript-keyword">return</span> (TRUE);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ip-&gt;ip_v == 6) {
			<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(packet, <span class="enscript-type">struct</span> ip6_hdr *);
			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LOOPBACK(&amp;ip6-&gt;ip6_src)) {
				<span class="enscript-keyword">return</span> (TRUE);
			}
			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LOOPBACK(&amp;ip6-&gt;ip6_dst)) {
				<span class="enscript-keyword">return</span> (TRUE);
			}
		}
	}
	
	<span class="enscript-keyword">return</span> (FALSE);
}
</pre>
<hr />
</body></html>