<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>pf_ruleset.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">pf_ruleset.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$apfw: pf_ruleset.c,v 1.2 2007/08/10 03:00:16 jhw Exp $ */</span>
<span class="enscript-comment">/*	$OpenBSD: pf_ruleset.c,v 1.1 2006/10/27 13:56:51 mcbride Exp $ */</span>

<span class="enscript-comment">/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002,2003 Henning Brauer
 * NAT64 - Copyright (c) 2010 Viagenie Inc. (<a href="http://www.viagenie.ca">http://www.viagenie.ca</a>)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfvar.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPFPRINTF</span>(format, x...)		\
	<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_NOISY)	\
		printf(format, ##x)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">rs_malloc</span>(x)		_MALLOC(x, M_TEMP, M_WAITOK)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">rs_free</span>(x)		_FREE(x, M_TEMP)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">strrchr</span>			_strrchr

<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">_strrchr</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *c, <span class="enscript-type">int</span> ch)
{
	<span class="enscript-type">char</span> *p = (<span class="enscript-type">char</span> *)(size_t)c, *save;

	<span class="enscript-keyword">for</span> (save = NULL; ; ++p) {
		<span class="enscript-keyword">if</span> (*p == ch)
			save = (<span class="enscript-type">char</span> *)p;
		<span class="enscript-keyword">if</span> (*p == <span class="enscript-string">'\0'</span>)
			<span class="enscript-keyword">return</span> (save);
	}
	<span class="enscript-comment">/* NOTREACHED */</span>
}

#<span class="enscript-reference">else</span>
<span class="enscript-comment">/* Userland equivalents so we can lend code to pfctl et al. */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;arpa/inet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">rs_malloc</span>(x)		 malloc(x)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">rs_free</span>(x)		 free(x)

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PFDEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stdarg.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPFPRINTF</span>(format, x...)	fprintf(stderr, format, ##x)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPFPRINTF</span>(format, x...)	((void)0)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFDEBUG */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>


<span class="enscript-type">struct</span> pf_anchor_global	 pf_anchors;
<span class="enscript-type">struct</span> pf_anchor	 pf_main_anchor;

<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span> <span class="enscript-function-name">pf_anchor_compare</span>(<span class="enscript-type">struct</span> pf_anchor *, <span class="enscript-type">struct</span> pf_anchor *);

<span class="enscript-function-name">RB_GENERATE</span>(pf_anchor_global, pf_anchor, entry_global, pf_anchor_compare);
<span class="enscript-function-name">RB_GENERATE</span>(pf_anchor_node, pf_anchor, entry_node, pf_anchor_compare);

<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_anchor_compare</span>(<span class="enscript-type">struct</span> pf_anchor *a, <span class="enscript-type">struct</span> pf_anchor *b)
{
	<span class="enscript-type">int</span> c = strcmp(a-&gt;path, b-&gt;path);

	<span class="enscript-keyword">return</span> (c ? (c &lt; 0 ? -1 : 1) : 0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_get_ruleset_number</span>(u_int8_t action)
{
	<span class="enscript-keyword">switch</span> (action) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_SCRUB</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NOSCRUB</span>:
		<span class="enscript-keyword">return</span> (PF_RULESET_SCRUB);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_PASS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_DROP</span>:
		<span class="enscript-keyword">return</span> (PF_RULESET_FILTER);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NONAT</span>:
		<span class="enscript-keyword">return</span> (PF_RULESET_NAT);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_BINAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NOBINAT</span>:
		<span class="enscript-keyword">return</span> (PF_RULESET_BINAT);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_RDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NORDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NAT64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NONAT64</span>:
		<span class="enscript-keyword">return</span> (PF_RULESET_RDR);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_DUMMYNET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NODUMMYNET</span>:
		<span class="enscript-keyword">return</span> (PF_RULESET_DUMMYNET);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (PF_RULESET_MAX);
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_init_ruleset</span>(<span class="enscript-type">struct</span> pf_ruleset *ruleset)
{
	<span class="enscript-type">int</span>	i;

	memset(ruleset, 0, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_ruleset));
	<span class="enscript-keyword">for</span> (i = 0; i &lt; PF_RULESET_MAX; i++) {
		TAILQ_INIT(&amp;ruleset-&gt;rules[i].queues[0]);
		TAILQ_INIT(&amp;ruleset-&gt;rules[i].queues[1]);
		ruleset-&gt;rules[i].active.ptr = &amp;ruleset-&gt;rules[i].queues[0];
		ruleset-&gt;rules[i].inactive.ptr = &amp;ruleset-&gt;rules[i].queues[1];
	}
}

<span class="enscript-type">struct</span> pf_anchor *
<span class="enscript-function-name">pf_find_anchor</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path)
{
	<span class="enscript-type">struct</span> pf_anchor	*key, *found;

	key = (<span class="enscript-type">struct</span> pf_anchor *)rs_malloc(<span class="enscript-keyword">sizeof</span> (*key));
	memset(key, 0, <span class="enscript-keyword">sizeof</span> (*key));
	strlcpy(key-&gt;path, path, <span class="enscript-keyword">sizeof</span> (key-&gt;path));
	found = RB_FIND(pf_anchor_global, &amp;pf_anchors, key);
	rs_free(key);
	<span class="enscript-keyword">return</span> (found);
}

<span class="enscript-type">struct</span> pf_ruleset *
<span class="enscript-function-name">pf_find_ruleset</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path)
{
	<span class="enscript-type">struct</span> pf_anchor	*anchor;

	<span class="enscript-keyword">while</span> (*path == <span class="enscript-string">'/'</span>)
		path++;
	<span class="enscript-keyword">if</span> (!*path)
		<span class="enscript-keyword">return</span> (&amp;pf_main_ruleset);
	anchor = pf_find_anchor(path);
	<span class="enscript-keyword">if</span> (anchor == NULL)
		<span class="enscript-keyword">return</span> (NULL);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (&amp;anchor-&gt;ruleset);
}

<span class="enscript-type">struct</span> pf_ruleset *
<span class="enscript-function-name">pf_find_ruleset_with_owner</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *owner, <span class="enscript-type">int</span> is_anchor,
    <span class="enscript-type">int</span> *error)
{
	<span class="enscript-type">struct</span> pf_anchor	*anchor;

	<span class="enscript-keyword">while</span> (*path == <span class="enscript-string">'/'</span>)
		path++;
	<span class="enscript-keyword">if</span> (!*path)
		<span class="enscript-keyword">return</span> (&amp;pf_main_ruleset);
	anchor = pf_find_anchor(path);
	<span class="enscript-keyword">if</span> (anchor == NULL) {
		*error = EINVAL;
		<span class="enscript-keyword">return</span> (NULL);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((owner &amp;&amp; (!strcmp(owner, anchor-&gt;owner)))
		    || (is_anchor &amp;&amp; !strcmp(anchor-&gt;owner, <span class="enscript-string">&quot;&quot;</span>)))
			<span class="enscript-keyword">return</span> (&amp;anchor-&gt;ruleset);
		*error = EPERM;
		<span class="enscript-keyword">return</span> NULL;
	}
}

<span class="enscript-type">struct</span> pf_ruleset *
<span class="enscript-function-name">pf_find_or_create_ruleset</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path)
{
	<span class="enscript-type">char</span>			*p, *q, *r;
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset;
	<span class="enscript-type">struct</span> pf_anchor	*anchor = 0, *dup, *parent = NULL;

	<span class="enscript-keyword">if</span> (path[0] == 0)
		<span class="enscript-keyword">return</span> (&amp;pf_main_ruleset);
	<span class="enscript-keyword">while</span> (*path == <span class="enscript-string">'/'</span>)
		path++;
	ruleset = pf_find_ruleset(path);
	<span class="enscript-keyword">if</span> (ruleset != NULL)
		<span class="enscript-keyword">return</span> (ruleset);
	p = (<span class="enscript-type">char</span> *)rs_malloc(MAXPATHLEN);
	bzero(p, MAXPATHLEN);
	strlcpy(p, path, MAXPATHLEN);
	<span class="enscript-keyword">while</span> (parent == NULL &amp;&amp; (q = strrchr(p, <span class="enscript-string">'/'</span>)) != NULL) {
		*q = 0;
		<span class="enscript-keyword">if</span> ((ruleset = pf_find_ruleset(p)) != NULL) {
			parent = ruleset-&gt;anchor;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span> (q == NULL)
		q = p;
	<span class="enscript-keyword">else</span>
		q++;
	strlcpy(p, path, MAXPATHLEN);
	<span class="enscript-keyword">if</span> (!*q) {
		rs_free(p);
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-keyword">while</span> ((r = strchr(q, <span class="enscript-string">'/'</span>)) != NULL || *q) {
		<span class="enscript-keyword">if</span> (r != NULL)
			*r = 0;
		<span class="enscript-keyword">if</span> (!*q || strlen(q) &gt;= PF_ANCHOR_NAME_SIZE ||
		    (parent != NULL &amp;&amp; strlen(parent-&gt;path) &gt;=
		    MAXPATHLEN - PF_ANCHOR_NAME_SIZE - 1)) {
			rs_free(p);
			<span class="enscript-keyword">return</span> (NULL);
		}
		anchor = (<span class="enscript-type">struct</span> pf_anchor *)rs_malloc(<span class="enscript-keyword">sizeof</span> (*anchor));
		<span class="enscript-keyword">if</span> (anchor == NULL) {
			rs_free(p);
			<span class="enscript-keyword">return</span> (NULL);
		}
		memset(anchor, 0, <span class="enscript-keyword">sizeof</span> (*anchor));
		RB_INIT(&amp;anchor-&gt;children);
		strlcpy(anchor-&gt;name, q, <span class="enscript-keyword">sizeof</span> (anchor-&gt;name));
		<span class="enscript-keyword">if</span> (parent != NULL) {
			strlcpy(anchor-&gt;path, parent-&gt;path,
			    <span class="enscript-keyword">sizeof</span> (anchor-&gt;path));
			strlcat(anchor-&gt;path, <span class="enscript-string">&quot;/&quot;</span>, <span class="enscript-keyword">sizeof</span> (anchor-&gt;path));
		}
		strlcat(anchor-&gt;path, anchor-&gt;name, <span class="enscript-keyword">sizeof</span> (anchor-&gt;path));
		<span class="enscript-keyword">if</span> ((dup = RB_INSERT(pf_anchor_global, &amp;pf_anchors, anchor)) !=
		    NULL) {
			printf(<span class="enscript-string">&quot;pf_find_or_create_ruleset: RB_INSERT1 &quot;</span>
			    <span class="enscript-string">&quot;'%s' '%s' collides with '%s' '%s'\n&quot;</span>,
			    anchor-&gt;path, anchor-&gt;name, dup-&gt;path, dup-&gt;name);
			rs_free(anchor);
			rs_free(p);
			<span class="enscript-keyword">return</span> (NULL);
		}
		<span class="enscript-keyword">if</span> (parent != NULL) {
			anchor-&gt;parent = parent;
			<span class="enscript-keyword">if</span> ((dup = RB_INSERT(pf_anchor_node, &amp;parent-&gt;children,
			    anchor)) != NULL) {
				printf(<span class="enscript-string">&quot;pf_find_or_create_ruleset: &quot;</span>
				    <span class="enscript-string">&quot;RB_INSERT2 '%s' '%s' collides with &quot;</span>
				    <span class="enscript-string">&quot;'%s' '%s'\n&quot;</span>, anchor-&gt;path, anchor-&gt;name,
				    dup-&gt;path, dup-&gt;name);
				RB_REMOVE(pf_anchor_global, &amp;pf_anchors,
				    anchor);
				rs_free(anchor);
				rs_free(p);
				<span class="enscript-keyword">return</span> (NULL);
			}
		}
		pf_init_ruleset(&amp;anchor-&gt;ruleset);
		anchor-&gt;ruleset.anchor = anchor;
		parent = anchor;
		<span class="enscript-keyword">if</span> (r != NULL)
			q = r + 1;
		<span class="enscript-keyword">else</span>
			*q = 0;
	}
	rs_free(p);
	<span class="enscript-keyword">return</span> (anchor ? &amp;anchor-&gt;ruleset : 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_remove_if_empty_ruleset</span>(<span class="enscript-type">struct</span> pf_ruleset *ruleset)
{
	<span class="enscript-type">struct</span> pf_anchor	*parent;
	<span class="enscript-type">int</span>			 i;

	<span class="enscript-keyword">while</span> (ruleset != NULL) {
		<span class="enscript-keyword">if</span> (ruleset == &amp;pf_main_ruleset || ruleset-&gt;anchor == NULL ||
		    !RB_EMPTY(&amp;ruleset-&gt;anchor-&gt;children) ||
		    ruleset-&gt;anchor-&gt;refcnt &gt; 0 || ruleset-&gt;tables &gt; 0 ||
		    ruleset-&gt;topen)
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; PF_RULESET_MAX; ++i)
			<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(ruleset-&gt;rules[i].active.ptr) ||
			    !TAILQ_EMPTY(ruleset-&gt;rules[i].inactive.ptr) ||
			    ruleset-&gt;rules[i].inactive.open)
				<span class="enscript-keyword">return</span>;
		RB_REMOVE(pf_anchor_global, &amp;pf_anchors, ruleset-&gt;anchor);
		<span class="enscript-keyword">if</span> ((parent = ruleset-&gt;anchor-&gt;parent) != NULL)
			RB_REMOVE(pf_anchor_node, &amp;parent-&gt;children,
			    ruleset-&gt;anchor);
		rs_free(ruleset-&gt;anchor);
		<span class="enscript-keyword">if</span> (parent == NULL)
			<span class="enscript-keyword">return</span>;
		ruleset = &amp;parent-&gt;ruleset;
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_anchor_setup</span>(<span class="enscript-type">struct</span> pf_rule *r, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> pf_ruleset *s,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	<span class="enscript-type">char</span>			*p, *path;
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset;

	r-&gt;anchor = NULL;
	r-&gt;anchor_relative = 0;
	r-&gt;anchor_wildcard = 0;
	<span class="enscript-keyword">if</span> (!name[0])
		<span class="enscript-keyword">return</span> (0);
	path = (<span class="enscript-type">char</span> *)rs_malloc(MAXPATHLEN);
	bzero(path, MAXPATHLEN);
	<span class="enscript-keyword">if</span> (name[0] == <span class="enscript-string">'/'</span>)
		strlcpy(path, name + 1, MAXPATHLEN);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* relative path */</span>
		r-&gt;anchor_relative = 1;
		<span class="enscript-keyword">if</span> (s-&gt;anchor == NULL || !s-&gt;anchor-&gt;path[0])
			path[0] = 0;
		<span class="enscript-keyword">else</span>
			strlcpy(path, s-&gt;anchor-&gt;path, MAXPATHLEN);
		<span class="enscript-keyword">while</span> (name[0] == <span class="enscript-string">'.'</span> &amp;&amp; name[1] == <span class="enscript-string">'.'</span> &amp;&amp; name[2] == <span class="enscript-string">'/'</span>) {
			<span class="enscript-keyword">if</span> (!path[0]) {
				printf(<span class="enscript-string">&quot;pf_anchor_setup: .. beyond root\n&quot;</span>);
				rs_free(path);
				<span class="enscript-keyword">return</span> (1);
			}
			<span class="enscript-keyword">if</span> ((p = strrchr(path, <span class="enscript-string">'/'</span>)) != NULL)
				*p = 0;
			<span class="enscript-keyword">else</span>
				path[0] = 0;
			r-&gt;anchor_relative++;
			name += 3;
		}
		<span class="enscript-keyword">if</span> (path[0])
			strlcat(path, <span class="enscript-string">&quot;/&quot;</span>, MAXPATHLEN);
		strlcat(path, name, MAXPATHLEN);
	}
	<span class="enscript-keyword">if</span> ((p = strrchr(path, <span class="enscript-string">'/'</span>)) != NULL &amp;&amp; strcmp(p, <span class="enscript-string">&quot;/*&quot;</span>) == 0) {
		r-&gt;anchor_wildcard = 1;
		*p = 0;
	}
	ruleset = pf_find_or_create_ruleset(path);
	rs_free(path);
	<span class="enscript-keyword">if</span> (ruleset == NULL || ruleset-&gt;anchor == NULL) {
		printf(<span class="enscript-string">&quot;pf_anchor_setup: ruleset\n&quot;</span>);
		<span class="enscript-keyword">return</span> (1);
	}
	r-&gt;anchor = ruleset-&gt;anchor;
	r-&gt;anchor-&gt;refcnt++;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_anchor_copyout</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> pf_ruleset *rs, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> pf_rule *r,
    <span class="enscript-type">struct</span> pfioc_rule *pr)
{
	pr-&gt;anchor_call[0] = 0;
	<span class="enscript-keyword">if</span> (r-&gt;anchor == NULL)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (!r-&gt;anchor_relative) {
		strlcpy(pr-&gt;anchor_call, <span class="enscript-string">&quot;/&quot;</span>, <span class="enscript-keyword">sizeof</span> (pr-&gt;anchor_call));
		strlcat(pr-&gt;anchor_call, r-&gt;anchor-&gt;path,
		    <span class="enscript-keyword">sizeof</span> (pr-&gt;anchor_call));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">char</span>	*a, *p;
		<span class="enscript-type">int</span>	 i;

		a = (<span class="enscript-type">char</span> *)rs_malloc(MAXPATHLEN);
		bzero(a, MAXPATHLEN);
		<span class="enscript-keyword">if</span> (rs-&gt;anchor == NULL)
			a[0] = 0;
		<span class="enscript-keyword">else</span>
			strlcpy(a, rs-&gt;anchor-&gt;path, MAXPATHLEN);
		<span class="enscript-keyword">for</span> (i = 1; i &lt; r-&gt;anchor_relative; ++i) {
			<span class="enscript-keyword">if</span> ((p = strrchr(a, <span class="enscript-string">'/'</span>)) == NULL)
				p = a;
			*p = 0;
			strlcat(pr-&gt;anchor_call, <span class="enscript-string">&quot;../&quot;</span>,
			    <span class="enscript-keyword">sizeof</span> (pr-&gt;anchor_call));
		}
		<span class="enscript-keyword">if</span> (strncmp(a, r-&gt;anchor-&gt;path, strlen(a))) {
			printf(<span class="enscript-string">&quot;pf_anchor_copyout: '%s' '%s'\n&quot;</span>, a,
			    r-&gt;anchor-&gt;path);
			rs_free(a);
			<span class="enscript-keyword">return</span> (1);
		}
		<span class="enscript-keyword">if</span> (strlen(r-&gt;anchor-&gt;path) &gt; strlen(a))
			strlcat(pr-&gt;anchor_call, r-&gt;anchor-&gt;path + (a[0] ?
			    strlen(a) + 1 : 0), <span class="enscript-keyword">sizeof</span> (pr-&gt;anchor_call));
		rs_free(a);
	}
	<span class="enscript-keyword">if</span> (r-&gt;anchor_wildcard)
		strlcat(pr-&gt;anchor_call, pr-&gt;anchor_call[0] ? <span class="enscript-string">&quot;/*&quot;</span> : <span class="enscript-string">&quot;*&quot;</span>,
		    <span class="enscript-keyword">sizeof</span> (pr-&gt;anchor_call));
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_anchor_remove</span>(<span class="enscript-type">struct</span> pf_rule *r)
{
	<span class="enscript-keyword">if</span> (r-&gt;anchor == NULL)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (r-&gt;anchor-&gt;refcnt &lt;= 0) {
		printf(<span class="enscript-string">&quot;pf_anchor_remove: broken refcount\n&quot;</span>);
		r-&gt;anchor = NULL;
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (!--r-&gt;anchor-&gt;refcnt)
		pf_remove_if_empty_ruleset(&amp;r-&gt;anchor-&gt;ruleset);
	r-&gt;anchor = NULL;
}
</pre>
<hr />
</body></html>