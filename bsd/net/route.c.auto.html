<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>route.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">route.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1980, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)route.c	8.2 (Berkeley) 11/15/93
 * $FreeBSD: src/sys/net/route.c,v 1.59.2.3 2001/07/29 19:18:02 ume Exp $
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Synchronization notes:
 *
 * Routing entries fall under two locking domains: the global routing table
 * lock (rnh_lock) and the per-entry lock (rt_lock); the latter is a mutex that
 * resides (statically defined) in the rtentry structure.
 *
 * The locking domains for routing are defined as follows:
 *
 * The global routing lock is used to serialize all accesses to the radix
 * trees defined by rt_tables[], as well as the tree of masks.  This includes
 * lookups, insertions and removals of nodes to/from the respective tree.
 * It is also used to protect certain fields in the route entry that aren't
 * often modified and/or require global serialization (more details below.)
 *
 * The per-route entry lock is used to serialize accesses to several routing
 * entry fields (more details below.)  Acquiring and releasing this lock is
 * done via RT_LOCK() and RT_UNLOCK() routines.
 *
 * In cases where both rnh_lock and rt_lock must be held, the former must be
 * acquired first in order to maintain lock ordering.  It is not a requirement
 * that rnh_lock be acquired first before rt_lock, but in case both must be
 * acquired in succession, the correct lock ordering must be followed.
 *
 * The fields of the rtentry structure are protected in the following way:
 *
 * rt_nodes[]
 *
 *	- Routing table lock (rnh_lock).
 *
 * rt_parent, rt_mask, rt_llinfo_free, rt_tree_genid
 *
 *	- Set once during creation and never changes; no locks to read.
 *
 * rt_flags, rt_genmask, rt_llinfo, rt_rmx, rt_refcnt, rt_gwroute
 *
 *	- Routing entry lock (rt_lock) for read/write access.
 *
 *	- Some values of rt_flags are either set once at creation time,
 *	  or aren't currently used, and thus checking against them can
 *	  be done without rt_lock: RTF_GATEWAY, RTF_HOST, RTF_DYNAMIC,
 *	  RTF_DONE,  RTF_XRESOLVE, RTF_STATIC, RTF_BLACKHOLE, RTF_ANNOUNCE,
 *	  RTF_USETRAILERS, RTF_WASCLONED, RTF_PINNED, RTF_LOCAL,
 *	  RTF_BROADCAST, RTF_MULTICAST, RTF_IFSCOPE, RTF_IFREF.
 *
 * rt_key, rt_gateway, rt_ifp, rt_ifa
 *
 *	- Always written/modified with both rnh_lock and rt_lock held.
 *
 *	- May be read freely with rnh_lock held, else must hold rt_lock
 *	  for read access; holding both locks for read is also okay.
 *
 *	- In the event rnh_lock is not acquired, or is not possible to be
 *	  acquired across the operation, setting RTF_CONDEMNED on a route
 *	  entry will prevent its rt_key, rt_gateway, rt_ifp and rt_ifa
 *	  from being modified.  This is typically done on a route that
 *	  has been chosen for a removal (from the tree) prior to dropping
 *	  the rt_lock, so that those values will remain the same until
 *	  the route is freed.
 *
 *	  When rnh_lock is held rt_setgate(), rt_setif(), and rtsetifa() are
 *	  single-threaded, thus exclusive.  This flag will also prevent the
 *	  route from being looked up via rt_lookup().
 *
 * rt_genid
 *
 *	- Assumes that 32-bit writes are atomic; no locks.
 *
 * rt_dlt, rt_output
 *
 *	- Currently unused; no locks.
 *
 * Operations on a route entry can be described as follows:
 *
 * CREATE an entry with reference count set to 0 as part of RTM_ADD/RESOLVE.
 *
 * INSERTION of an entry into the radix tree holds the rnh_lock, checks
 * for duplicates and then adds the entry.  rtrequest returns the entry
 * after bumping up the reference count to 1 (for the caller).
 *
 * LOOKUP of an entry holds the rnh_lock and bumps up the reference count
 * before returning; it is valid to also bump up the reference count using
 * RT_ADDREF after the lookup has returned an entry.
 *
 * REMOVAL of an entry from the radix tree holds the rnh_lock, removes the
 * entry but does not decrement the reference count.  Removal happens when
 * the route is explicitly deleted (RTM_DELETE) or when it is in the cached
 * state and it expires.  The route is said to be &quot;down&quot; when it is no
 * longer present in the tree.  Freeing the entry will happen on the last
 * reference release of such a &quot;down&quot; route.
 *
 * RT_ADDREF/RT_REMREF operates on the routing entry which increments/
 * decrements the reference count, rt_refcnt, atomically on the rtentry.
 * rt_refcnt is modified only using this routine.  The general rule is to
 * do RT_ADDREF in the function that is passing the entry as an argument,
 * in order to prevent the entry from being freed by the callee.
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">equal</span>(a1, a2) (bcmp((caddr_t)(a1), (caddr_t)(a2), (a1)-&gt;sa_len) == 0)

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kdp_set_gateway_mac</span>(<span class="enscript-type">void</span> *gatewaymac);

__private_extern__ <span class="enscript-type">struct</span> rtstat rtstat  = { 0, 0, 0, 0, 0 };
<span class="enscript-type">struct</span> radix_node_head *rt_tables[AF_MAX+1];

<span class="enscript-function-name">decl_lck_mtx_data</span>(, rnh_lock_data);	<span class="enscript-comment">/* global routing tables mutex */</span>
lck_mtx_t		*rnh_lock = &amp;rnh_lock_data;
<span class="enscript-type">static</span> lck_attr_t	*rnh_lock_attr;
<span class="enscript-type">static</span> lck_grp_t	*rnh_lock_grp;
<span class="enscript-type">static</span> lck_grp_attr_t	*rnh_lock_grp_attr;

<span class="enscript-comment">/* Lock group and attribute for routing entry locks */</span>
<span class="enscript-type">static</span> lck_attr_t	*rte_mtx_attr;
<span class="enscript-type">static</span> lck_grp_t	*rte_mtx_grp;
<span class="enscript-type">static</span> lck_grp_attr_t	*rte_mtx_grp_attr;

<span class="enscript-type">int</span> rttrash = 0;		<span class="enscript-comment">/* routes not in table but not freed */</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> rte_debug;

<span class="enscript-comment">/* Possible flags for rte_debug */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTD_DEBUG</span>	0x1	<span class="enscript-comment">/* enable or disable rtentry debug facility */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTD_TRACE</span>	0x2	<span class="enscript-comment">/* trace alloc, free, refcnt and lock */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTD_NO_FREE</span>	0x4	<span class="enscript-comment">/* don't free (good to catch corruptions) */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTE_NAME</span>		<span class="enscript-string">&quot;rtentry&quot;</span>	<span class="enscript-comment">/* name for zone and rt_lock */</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *rte_zone;			<span class="enscript-comment">/* special zone for rtentry */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTE_ZONE_MAX</span>		65536		<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTE_ZONE_NAME</span>		RTE_NAME	<span class="enscript-comment">/* name of rtentry zone */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTD_INUSE</span>		0xFEEDFACE	<span class="enscript-comment">/* entry is in use */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTD_FREED</span>		0xDEADBEEF	<span class="enscript-comment">/* entry is freed */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_SCOPE_ADDR_STR_LEN</span>	(MAX_IPv6_STR_LEN + 6)

<span class="enscript-comment">/* For gdb */</span>
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ctrace_stack_size = CTRACE_STACK_SIZE;
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ctrace_hist_size = CTRACE_HIST_SIZE;

<span class="enscript-comment">/*
 * Debug variant of rtentry structure.
 */</span>
<span class="enscript-type">struct</span> rtentry_dbg {
	<span class="enscript-type">struct</span> rtentry	rtd_entry;			<span class="enscript-comment">/* rtentry */</span>
	<span class="enscript-type">struct</span> rtentry	rtd_entry_saved;		<span class="enscript-comment">/* saved rtentry */</span>
	uint32_t	rtd_inuse;			<span class="enscript-comment">/* in use pattern */</span>
	uint16_t	rtd_refhold_cnt;		<span class="enscript-comment">/* # of rtref */</span>
	uint16_t	rtd_refrele_cnt;		<span class="enscript-comment">/* # of rtunref */</span>
	uint32_t	rtd_lock_cnt;			<span class="enscript-comment">/* # of locks */</span>
	uint32_t	rtd_unlock_cnt;			<span class="enscript-comment">/* # of unlocks */</span>
	<span class="enscript-comment">/*
	 * Alloc and free callers.
	 */</span>
	ctrace_t	rtd_alloc;
	ctrace_t	rtd_free;
	<span class="enscript-comment">/*
	 * Circular lists of rtref and rtunref callers.
	 */</span>
	ctrace_t	rtd_refhold[CTRACE_HIST_SIZE];
	ctrace_t	rtd_refrele[CTRACE_HIST_SIZE];
	<span class="enscript-comment">/*
	 * Circular lists of locks and unlocks.
	 */</span>
	ctrace_t	rtd_lock[CTRACE_HIST_SIZE];
	ctrace_t	rtd_unlock[CTRACE_HIST_SIZE];
	<span class="enscript-comment">/*
	 * Trash list linkage
	 */</span>
	TAILQ_ENTRY(rtentry_dbg) rtd_trash_link;
};

<span class="enscript-comment">/* List of trash route entries protected by rnh_lock */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(, rtentry_dbg) rttrash_head;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rte_lock_init</span>(<span class="enscript-type">struct</span> rtentry *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rte_lock_destroy</span>(<span class="enscript-type">struct</span> rtentry *);
<span class="enscript-type">static</span> inline <span class="enscript-type">struct</span> rtentry *<span class="enscript-function-name">rte_alloc_debug</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">rte_free_debug</span>(<span class="enscript-type">struct</span> rtentry *);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">rte_lock_debug</span>(<span class="enscript-type">struct</span> rtentry_dbg *);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">rte_unlock_debug</span>(<span class="enscript-type">struct</span> rtentry_dbg *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rt_maskedcopy</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *,
	    <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rtable_init</span>(<span class="enscript-type">void</span> **);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">rtref_audit</span>(<span class="enscript-type">struct</span> rtentry_dbg *);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">rtunref_audit</span>(<span class="enscript-type">struct</span> rtentry_dbg *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rtentry *<span class="enscript-function-name">rtalloc1_common_locked</span>(<span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">int</span>, uint32_t,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rtrequest_common_locked</span>(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rtentry **,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rtentry *<span class="enscript-function-name">rtalloc1_locked</span>(<span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">int</span>, uint32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rtalloc_ign_common_locked</span>(<span class="enscript-type">struct</span> route *, uint32_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">sin6_set_ifscope</span>(<span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">sin6_set_embedded_ifscope</span>(<span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> inline <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sin6_get_embedded_ifscope</span>(<span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr *<span class="enscript-function-name">ma_copy</span>(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">struct</span> sockaddr_storage *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr *<span class="enscript-function-name">sa_trim</span>(<span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> radix_node *<span class="enscript-function-name">node_lookup</span>(<span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> radix_node *<span class="enscript-function-name">node_lookup_default</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rtentry *<span class="enscript-function-name">rt_lookup_common</span>(boolean_t, boolean_t, <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> radix_node_head *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rn_match_ifscope</span>(<span class="enscript-type">struct</span> radix_node *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">ifa_ifwithroute_common_locked</span>(<span class="enscript-type">int</span>,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rtentry *<span class="enscript-function-name">rte_alloc</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rte_free</span>(<span class="enscript-type">struct</span> rtentry *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rtfree_common</span>(<span class="enscript-type">struct</span> rtentry *, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rte_if_ref</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rt_set_idleref</span>(<span class="enscript-type">struct</span> rtentry *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rt_clear_idleref</span>(<span class="enscript-type">struct</span> rtentry *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rt_str4</span>(<span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">char</span> *, uint32_t, <span class="enscript-type">char</span> *, uint32_t);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rt_str6</span>(<span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">char</span> *, uint32_t, <span class="enscript-type">char</span> *, uint32_t);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

uint32_t route_genid_inet = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
uint32_t route_genid_inet6 = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ASSERT_SINIFSCOPE</span>(sa) {						\
	<span class="enscript-keyword">if</span> ((sa)-&gt;sa_family != AF_INET ||				\
	    (sa)-&gt;sa_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in))			\
		panic(<span class="enscript-string">&quot;%s: bad sockaddr_in %p\n&quot;</span>, __func__, sa);	\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ASSERT_SIN6IFSCOPE</span>(sa) {					\
	<span class="enscript-keyword">if</span> ((sa)-&gt;sa_family != AF_INET6 ||				\
	    (sa)-&gt;sa_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6))		\
		panic(<span class="enscript-string">&quot;%s: bad sockaddr_in6 %p\n&quot;</span>, __func__, sa);	\
}

<span class="enscript-comment">/*
 * Argument to leaf-matching routine; at present it is scoped routing
 * specific but can be expanded in future to include other search filters.
 */</span>
<span class="enscript-type">struct</span> matchleaf_arg {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	ifscope;	<span class="enscript-comment">/* interface scope */</span>
};

<span class="enscript-comment">/*
 * For looking up the non-scoped default route (sockaddr instead
 * of sockaddr_in for convenience).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr sin_def = {
	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in), AF_INET, { 0, }
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr_in6 sin6_def = {
	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6), AF_INET6, 0, 0, IN6ADDR_ANY_INIT, 0
};

<span class="enscript-comment">/*
 * Interface index (scope) of the primary interface; determined at
 * the time when the default, non-scoped route gets added, changed
 * or deleted.  Protected by rnh_lock.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> primary_ifscope = IFSCOPE_NONE;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> primary6_ifscope = IFSCOPE_NONE;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INET_DEFAULT</span>(sa)	\
	((sa)-&gt;sa_family == AF_INET &amp;&amp; SIN(sa)-&gt;sin_addr.s_addr == 0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INET6_DEFAULT</span>(sa)						\
	((sa)-&gt;sa_family == AF_INET6 &amp;&amp;					\
	IN6_IS_ADDR_UNSPECIFIED(&amp;SIN6(sa)-&gt;sin6_addr))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SA_DEFAULT</span>(sa)	(INET_DEFAULT(sa) || INET6_DEFAULT(sa))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">RT</span>(r)		((struct rtentry *)r)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">RN</span>(r)		((struct radix_node *)r)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">RT_HOST</span>(r)	(RT(r)-&gt;rt_flags &amp; RTF_HOST)

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_route);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> rt_verbose;	<span class="enscript-comment">/* verbosity level (0 to disable) */</span>
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_route, OID_AUTO, verbose, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;rt_verbose, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rtable_init</span>(<span class="enscript-type">void</span> **table)
{
	<span class="enscript-type">struct</span> domain *dom;

	domain_proto_mtx_lock_assert_held();

	TAILQ_FOREACH(dom, &amp;domains, dom_entry) {
		<span class="enscript-keyword">if</span> (dom-&gt;dom_rtattach != NULL)
			dom-&gt;dom_rtattach(&amp;table[dom-&gt;dom_family],
			    dom-&gt;dom_rtoffset);
	}
}

<span class="enscript-comment">/*
 * Called by route_dinit().
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">route_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> size;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	_CASSERT(offsetof(<span class="enscript-type">struct</span> route, ro_rt) ==
	    offsetof(<span class="enscript-type">struct</span> route_in6, ro_rt));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> route, ro_srcia) ==
	    offsetof(<span class="enscript-type">struct</span> route_in6, ro_srcia));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> route, ro_flags) ==
	    offsetof(<span class="enscript-type">struct</span> route_in6, ro_flags));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> route, ro_dst) ==
	    offsetof(<span class="enscript-type">struct</span> route_in6, ro_dst));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	PE_parse_boot_argn(<span class="enscript-string">&quot;rte_debug&quot;</span>, &amp;rte_debug, <span class="enscript-keyword">sizeof</span> (rte_debug));
	<span class="enscript-keyword">if</span> (rte_debug != 0)
		rte_debug |= RTD_DEBUG;

	rnh_lock_grp_attr = lck_grp_attr_alloc_init();
	rnh_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;route&quot;</span>, rnh_lock_grp_attr);
	rnh_lock_attr = lck_attr_alloc_init();
	lck_mtx_init(rnh_lock, rnh_lock_grp, rnh_lock_attr);

	rte_mtx_grp_attr = lck_grp_attr_alloc_init();
	rte_mtx_grp = lck_grp_alloc_init(RTE_NAME, rte_mtx_grp_attr);
	rte_mtx_attr = lck_attr_alloc_init();

	lck_mtx_lock(rnh_lock);
	rn_init();	<span class="enscript-comment">/* initialize all zeroes, all ones, mask table */</span>
	lck_mtx_unlock(rnh_lock);
	rtable_init((<span class="enscript-type">void</span> **)rt_tables);

	<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_DEBUG)
		size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> rtentry_dbg);
	<span class="enscript-keyword">else</span>
		size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> rtentry);

	rte_zone = zinit(size, RTE_ZONE_MAX * size, 0, RTE_ZONE_NAME);
	<span class="enscript-keyword">if</span> (rte_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating rte_zone&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(rte_zone, Z_EXPAND, TRUE);
	zone_change(rte_zone, Z_CALLERACCT, FALSE);
	zone_change(rte_zone, Z_NOENCRYPT, TRUE);

	TAILQ_INIT(&amp;rttrash_head);
}

<span class="enscript-comment">/*
 * Given a route, determine whether or not it is the non-scoped default
 * route; dst typically comes from rt_key(rt) but may be coming from
 * a separate place when rt is in the process of being created.
 */</span>
boolean_t
<span class="enscript-function-name">rt_primary_default</span>(<span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> sockaddr *dst)
{
	<span class="enscript-keyword">return</span> (SA_DEFAULT(dst) &amp;&amp; !(rt-&gt;rt_flags &amp; RTF_IFSCOPE));
}

<span class="enscript-comment">/*
 * Set the ifscope of the primary interface; caller holds rnh_lock.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">set_primary_ifscope</span>(<span class="enscript-type">int</span> af, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-keyword">if</span> (af == AF_INET)
		primary_ifscope = ifscope;
	<span class="enscript-keyword">else</span>
		primary6_ifscope = ifscope;
}

<span class="enscript-comment">/*
 * Return the ifscope of the primary interface; caller holds rnh_lock.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">get_primary_ifscope</span>(<span class="enscript-type">int</span> af)
{
	<span class="enscript-keyword">return</span> (af == AF_INET ? primary_ifscope : primary6_ifscope);
}

<span class="enscript-comment">/*
 * Set the scope ID of a given a sockaddr_in.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">sin_set_ifscope</span>(<span class="enscript-type">struct</span> sockaddr *sa, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-comment">/* Caller must pass in sockaddr_in */</span>
	ASSERT_SINIFSCOPE(sa);

	SINIFSCOPE(sa)-&gt;sin_scope_id = ifscope;
}

<span class="enscript-comment">/*
 * Set the scope ID of given a sockaddr_in6.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">sin6_set_ifscope</span>(<span class="enscript-type">struct</span> sockaddr *sa, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-comment">/* Caller must pass in sockaddr_in6 */</span>
	ASSERT_SIN6IFSCOPE(sa);

	SIN6IFSCOPE(sa)-&gt;sin6_scope_id = ifscope;
}

<span class="enscript-comment">/*
 * Given a sockaddr_in, return the scope ID to the caller.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sin_get_ifscope</span>(<span class="enscript-type">struct</span> sockaddr *sa)
{
	<span class="enscript-comment">/* Caller must pass in sockaddr_in */</span>
	ASSERT_SINIFSCOPE(sa);

	<span class="enscript-keyword">return</span> (SINIFSCOPE(sa)-&gt;sin_scope_id);
}

<span class="enscript-comment">/*
 * Given a sockaddr_in6, return the scope ID to the caller.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sin6_get_ifscope</span>(<span class="enscript-type">struct</span> sockaddr *sa)
{
	<span class="enscript-comment">/* Caller must pass in sockaddr_in6 */</span>
	ASSERT_SIN6IFSCOPE(sa);

	<span class="enscript-keyword">return</span> (SIN6IFSCOPE(sa)-&gt;sin6_scope_id);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">sin6_set_embedded_ifscope</span>(<span class="enscript-type">struct</span> sockaddr *sa, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-comment">/* Caller must pass in sockaddr_in6 */</span>
	ASSERT_SIN6IFSCOPE(sa);
	VERIFY(IN6_IS_SCOPE_EMBED(&amp;(SIN6(sa)-&gt;sin6_addr)));

	SIN6(sa)-&gt;sin6_addr.s6_addr16[1] = htons(ifscope);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sin6_get_embedded_ifscope</span>(<span class="enscript-type">struct</span> sockaddr *sa)
{
	<span class="enscript-comment">/* Caller must pass in sockaddr_in6 */</span>
	ASSERT_SIN6IFSCOPE(sa);

	<span class="enscript-keyword">return</span> (ntohs(SIN6(sa)-&gt;sin6_addr.s6_addr16[1]));
}

<span class="enscript-comment">/*
 * Copy a sockaddr_{in,in6} src to a dst storage and set scope ID into dst.
 *
 * To clear the scope ID, pass is a NULL pifscope.  To set the scope ID, pass
 * in a non-NULL pifscope with non-zero ifscope.  Otherwise if pifscope is
 * non-NULL and ifscope is IFSCOPE_NONE, the existing scope ID is left intact.
 * In any case, the effective scope ID value is returned to the caller via
 * pifscope, if it is non-NULL.
 */</span>
<span class="enscript-type">struct</span> sockaddr *
<span class="enscript-function-name">sa_copy</span>(<span class="enscript-type">struct</span> sockaddr *src, <span class="enscript-type">struct</span> sockaddr_storage *dst,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *pifscope)
{
	<span class="enscript-type">int</span> af = src-&gt;sa_family;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope = (pifscope != NULL) ? *pifscope : IFSCOPE_NONE;

	VERIFY(af == AF_INET || af == AF_INET6);

	bzero(dst, <span class="enscript-keyword">sizeof</span> (*dst));

	<span class="enscript-keyword">if</span> (af == AF_INET) {
		bcopy(src, dst, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in));
		<span class="enscript-keyword">if</span> (pifscope == NULL || ifscope != IFSCOPE_NONE)
			sin_set_ifscope(SA(dst), ifscope);
	} <span class="enscript-keyword">else</span> {
		bcopy(src, dst, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6));
		<span class="enscript-keyword">if</span> (pifscope != NULL &amp;&amp;
		    IN6_IS_SCOPE_EMBED(&amp;SIN6(dst)-&gt;sin6_addr)) {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> eifscope;
			<span class="enscript-comment">/*
			 * If the address contains the embedded scope ID,
			 * use that as the value for sin6_scope_id as long
			 * the caller doesn't insist on clearing it (by
			 * passing NULL) or setting it.
			 */</span>
			eifscope = sin6_get_embedded_ifscope(SA(dst));
			<span class="enscript-keyword">if</span> (eifscope != IFSCOPE_NONE &amp;&amp; ifscope == IFSCOPE_NONE)
				ifscope = eifscope;
			<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE) {
				<span class="enscript-comment">/* Set ifscope from pifscope or eifscope */</span>
				sin6_set_ifscope(SA(dst), ifscope);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* If sin6_scope_id has a value, use that one */</span>
				ifscope = sin6_get_ifscope(SA(dst));
			}
			<span class="enscript-comment">/*
			 * If sin6_scope_id is set but the address doesn't
			 * contain the equivalent embedded value, set it.
			 */</span>
			<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE &amp;&amp; eifscope != ifscope)
				sin6_set_embedded_ifscope(SA(dst), ifscope);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pifscope == NULL || ifscope != IFSCOPE_NONE) {
			sin6_set_ifscope(SA(dst), ifscope);
		}
	}

	<span class="enscript-keyword">if</span> (pifscope != NULL) {
		*pifscope = (af == AF_INET) ? sin_get_ifscope(SA(dst)) :
		    sin6_get_ifscope(SA(dst));
	}

	<span class="enscript-keyword">return</span> (SA(dst));
}

<span class="enscript-comment">/*
 * Copy a mask from src to a dst storage and set scope ID into dst.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr *
<span class="enscript-function-name">ma_copy</span>(<span class="enscript-type">int</span> af, <span class="enscript-type">struct</span> sockaddr *src, <span class="enscript-type">struct</span> sockaddr_storage *dst,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	VERIFY(af == AF_INET || af == AF_INET6);

	bzero(dst, <span class="enscript-keyword">sizeof</span> (*dst));
	rt_maskedcopy(src, SA(dst), src);

	<span class="enscript-comment">/*
	 * The length of the mask sockaddr would need to be adjusted
	 * to cover the additional {sin,sin6}_ifscope field; when ifscope
	 * is IFSCOPE_NONE, we'd end up clearing the scope ID field on
	 * the destination mask in addition to extending the length
	 * of the sockaddr, as a side effect.  This is okay, as any
	 * trailing zeroes would be skipped by rn_addmask prior to
	 * inserting or looking up the mask in the mask tree.
	 */</span>
	<span class="enscript-keyword">if</span> (af == AF_INET) {
		SINIFSCOPE(dst)-&gt;sin_scope_id = ifscope;
		SINIFSCOPE(dst)-&gt;sin_len =
		    offsetof(<span class="enscript-type">struct</span> sockaddr_inifscope, sin_scope_id) +
		    <span class="enscript-keyword">sizeof</span> (SINIFSCOPE(dst)-&gt;sin_scope_id);
	} <span class="enscript-keyword">else</span> {
		SIN6IFSCOPE(dst)-&gt;sin6_scope_id = ifscope;
		SIN6IFSCOPE(dst)-&gt;sin6_len =
		    offsetof(<span class="enscript-type">struct</span> sockaddr_in6, sin6_scope_id) +
		    <span class="enscript-keyword">sizeof</span> (SIN6IFSCOPE(dst)-&gt;sin6_scope_id);
	}

	<span class="enscript-keyword">return</span> (SA(dst));
}

<span class="enscript-comment">/*
 * Trim trailing zeroes on a sockaddr and update its length.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr *
<span class="enscript-function-name">sa_trim</span>(<span class="enscript-type">struct</span> sockaddr *sa, <span class="enscript-type">int</span> skip)
{
	caddr_t cp, base = (caddr_t)sa + skip;

	<span class="enscript-keyword">if</span> (sa-&gt;sa_len &lt;= skip)
		<span class="enscript-keyword">return</span> (sa);

	<span class="enscript-keyword">for</span> (cp = base + (sa-&gt;sa_len - skip); cp &gt; base &amp;&amp; cp[-1] == 0; )
		cp--;

	sa-&gt;sa_len = (cp - base) + skip;
	<span class="enscript-keyword">if</span> (sa-&gt;sa_len &lt; skip) {
		<span class="enscript-comment">/* Must not happen, and if so, panic */</span>
		panic(<span class="enscript-string">&quot;%s: broken logic (sa_len %d &lt; skip %d )&quot;</span>, __func__,
		    sa-&gt;sa_len, skip);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;sa_len == skip) {
		<span class="enscript-comment">/* If we end up with all zeroes, then there's no mask */</span>
		sa-&gt;sa_len = 0;
	}

	<span class="enscript-keyword">return</span> (sa);
}

<span class="enscript-comment">/*
 * Called by rtm_msg{1,2} routines to &quot;scrub&quot; socket address structures of
 * kernel private information, so that clients of the routing socket will
 * not be confused by the presence of the information, or the side effect of
 * the increased length due to that.  The source sockaddr is not modified;
 * instead, the scrubbing happens on the destination sockaddr storage that
 * is passed in by the caller.
 *
 * Scrubbing entails:
 *   - removing embedded scope identifiers from network mask and destination
 *     IPv4 and IPv6 socket addresses
 *   - optionally removing global scope interface hardware addresses from
 *     link-layer interface addresses when the MAC framework check fails.
 */</span>
<span class="enscript-type">struct</span> sockaddr *
<span class="enscript-function-name">rtm_scrub</span>(<span class="enscript-type">int</span> type, <span class="enscript-type">int</span> idx, <span class="enscript-type">struct</span> sockaddr *hint, <span class="enscript-type">struct</span> sockaddr *sa,
    <span class="enscript-type">void</span> *buf, uint32_t buflen, kauth_cred_t *credp)
{
	<span class="enscript-type">struct</span> sockaddr_storage *ss = (<span class="enscript-type">struct</span> sockaddr_storage *)buf;
	<span class="enscript-type">struct</span> sockaddr *ret = sa;

	VERIFY(buf != NULL &amp;&amp; buflen &gt;= <span class="enscript-keyword">sizeof</span> (*ss));
	bzero(buf, buflen);

	<span class="enscript-keyword">switch</span> (idx) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTAX_DST</span>:
		<span class="enscript-comment">/*
		 * If this is for an AF_INET/AF_INET6 destination address,
		 * call sa_copy() to clear the scope ID field.
		 */</span>
		<span class="enscript-keyword">if</span> (sa-&gt;sa_family == AF_INET &amp;&amp;
		    SINIFSCOPE(sa)-&gt;sin_scope_id != IFSCOPE_NONE) {
			ret = sa_copy(sa, ss, NULL);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;sa_family == AF_INET6 &amp;&amp;
		    SIN6IFSCOPE(sa)-&gt;sin6_scope_id != IFSCOPE_NONE) {
			ret = sa_copy(sa, ss, NULL);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTAX_NETMASK</span>: {
		<span class="enscript-type">int</span> skip, af;
		<span class="enscript-comment">/*
		 * If this is for a mask, we can't tell whether or not there
		 * is an valid scope ID value, as the span of bytes between
		 * sa_len and the beginning of the mask (offset of sin_addr in
		 * the case of AF_INET, or sin6_addr for AF_INET6) may be
		 * filled with all-ones by rn_addmask(), and hence we cannot
		 * rely on sa_family.  Because of this, we use the sa_family
		 * of the hint sockaddr (RTAX_{DST,IFA}) as indicator as to
		 * whether or not the mask is to be treated as one for AF_INET
		 * or AF_INET6.  Clearing the scope ID field involves setting
		 * it to IFSCOPE_NONE followed by calling sa_trim() to trim
		 * trailing zeroes from the storage sockaddr, which reverses
		 * what was done earlier by ma_copy() on the source sockaddr.
		 */</span>
		<span class="enscript-keyword">if</span> (hint == NULL ||
		    ((af = hint-&gt;sa_family) != AF_INET &amp;&amp; af != AF_INET6))
			<span class="enscript-keyword">break</span>;	<span class="enscript-comment">/* nothing to do */</span>

		skip = (af == AF_INET) ?
		    offsetof(<span class="enscript-type">struct</span> sockaddr_in, sin_addr) :
		    offsetof(<span class="enscript-type">struct</span> sockaddr_in6, sin6_addr);

		<span class="enscript-keyword">if</span> (sa-&gt;sa_len &gt; skip &amp;&amp; sa-&gt;sa_len &lt;= <span class="enscript-keyword">sizeof</span> (*ss)) {
			bcopy(sa, ss, sa-&gt;sa_len);
			<span class="enscript-comment">/*
			 * Don't use {sin,sin6}_set_ifscope() as sa_family
			 * and sa_len for the netmask might not be set to
			 * the corresponding expected values of the hint.
			 */</span>
			<span class="enscript-keyword">if</span> (hint-&gt;sa_family == AF_INET)
				SINIFSCOPE(ss)-&gt;sin_scope_id = IFSCOPE_NONE;
			<span class="enscript-keyword">else</span>
				SIN6IFSCOPE(ss)-&gt;sin6_scope_id = IFSCOPE_NONE;
			ret = sa_trim(SA(ss), skip);

			<span class="enscript-comment">/*
			 * For AF_INET6 mask, set sa_len appropriately unless
			 * this is requested via systl_dumpentry(), in which
			 * case we return the raw value.
			 */</span>
			<span class="enscript-keyword">if</span> (hint-&gt;sa_family == AF_INET6 &amp;&amp;
			    type != RTM_GET &amp;&amp; type != RTM_GET2)
				SA(ret)-&gt;sa_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTAX_IFP</span>: {
		<span class="enscript-keyword">if</span> (sa-&gt;sa_family == AF_LINK &amp;&amp; credp) {
			<span class="enscript-type">struct</span> sockaddr_dl *sdl = SDL(buf);
			<span class="enscript-type">const</span> <span class="enscript-type">void</span> *bytes;
			size_t size;

			<span class="enscript-comment">/* caller should handle worst case: SOCK_MAXADDRLEN */</span>
			VERIFY(buflen &gt;= sa-&gt;sa_len);

			bcopy(sa, sdl, sa-&gt;sa_len);
			bytes = dlil_ifaddr_bytes(sdl, &amp;size, credp);
			<span class="enscript-keyword">if</span> (bytes != CONST_LLADDR(sdl)) {
				VERIFY(sdl-&gt;sdl_alen == size);
				bcopy(bytes, LLADDR(sdl), size);
			}
			ret = (<span class="enscript-type">struct</span> sockaddr *)sdl;
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/*
 * Callback leaf-matching routine for rn_matchaddr_args used
 * for looking up an exact match for a scoped route entry.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rn_match_ifscope</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)rn;
	<span class="enscript-type">struct</span> matchleaf_arg *ma = arg;
	<span class="enscript-type">int</span> af = rt_key(rt)-&gt;sa_family;

	<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_IFSCOPE) || (af != AF_INET &amp;&amp; af != AF_INET6))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span> (af == AF_INET ?
	    (SINIFSCOPE(rt_key(rt))-&gt;sin_scope_id == ma-&gt;ifscope) :
	    (SIN6IFSCOPE(rt_key(rt))-&gt;sin6_scope_id == ma-&gt;ifscope));
}

<span class="enscript-comment">/*
 * Atomically increment route generation counter
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">routegenid_update</span>(<span class="enscript-type">void</span>)
{
	routegenid_inet_update();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	routegenid_inet6_update();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">routegenid_inet_update</span>(<span class="enscript-type">void</span>)
{
	atomic_add_32(&amp;route_genid_inet, 1);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">routegenid_inet6_update</span>(<span class="enscript-type">void</span>)
{
	atomic_add_32(&amp;route_genid_inet6, 1);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-comment">/*
 * Packet routing routines.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rtalloc</span>(<span class="enscript-type">struct</span> route *ro)
{
	rtalloc_ign(ro, 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rtalloc_scoped</span>(<span class="enscript-type">struct</span> route *ro, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	rtalloc_scoped_ign(ro, 0, ifscope);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rtalloc_ign_common_locked</span>(<span class="enscript-type">struct</span> route *ro, uint32_t ignore,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">struct</span> rtentry *rt;

	<span class="enscript-keyword">if</span> ((rt = ro-&gt;ro_rt) != NULL) {
		RT_LOCK_SPIN(rt);
		<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp != NULL &amp;&amp; !ROUTE_UNUSABLE(ro)) {
			RT_UNLOCK(rt);
			<span class="enscript-keyword">return</span>;
		}
		RT_UNLOCK(rt);
		ROUTE_RELEASE_LOCKED(ro);	<span class="enscript-comment">/* rnh_lock already held */</span>
	}
	ro-&gt;ro_rt = rtalloc1_common_locked(&amp;ro-&gt;ro_dst, 1, ignore, ifscope);
	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL) {
		RT_GENID_SYNC(ro-&gt;ro_rt);
		RT_LOCK_ASSERT_NOTHELD(ro-&gt;ro_rt);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rtalloc_ign</span>(<span class="enscript-type">struct</span> route *ro, uint32_t ignore)
{
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);
	lck_mtx_lock(rnh_lock);
	rtalloc_ign_common_locked(ro, ignore, IFSCOPE_NONE);
	lck_mtx_unlock(rnh_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rtalloc_scoped_ign</span>(<span class="enscript-type">struct</span> route *ro, uint32_t ignore, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);
	lck_mtx_lock(rnh_lock);
	rtalloc_ign_common_locked(ro, ignore, ifscope);
	lck_mtx_unlock(rnh_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">rtalloc1_locked</span>(<span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">int</span> report, uint32_t ignflags)
{
	<span class="enscript-keyword">return</span> (rtalloc1_common_locked(dst, report, ignflags, IFSCOPE_NONE));
}

<span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">rtalloc1_scoped_locked</span>(<span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">int</span> report, uint32_t ignflags,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-keyword">return</span> (rtalloc1_common_locked(dst, report, ignflags, ifscope));
}

<span class="enscript-comment">/*
 * Look up the route that matches the address given
 * Or, at least try.. Create a cloned route if needed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">rtalloc1_common_locked</span>(<span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">int</span> report, uint32_t ignflags,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">struct</span> radix_node_head *rnh = rt_tables[dst-&gt;sa_family];
	<span class="enscript-type">struct</span> rtentry *rt, *newrt = NULL;
	<span class="enscript-type">struct</span> rt_addrinfo info;
	uint32_t nflags;
	<span class="enscript-type">int</span>  err = 0, msgtype = RTM_MISS;

	<span class="enscript-keyword">if</span> (rnh == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unreachable</span>;

	<span class="enscript-comment">/*
	 * Find the longest prefix or exact (in the scoped case) address match;
	 * callee adds a reference to entry and checks for root node as well
	 */</span>
	rt = rt_lookup(FALSE, dst, NULL, rnh, ifscope);
	<span class="enscript-keyword">if</span> (rt == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unreachable</span>;

	RT_LOCK_SPIN(rt);
	newrt = rt;
	nflags = rt-&gt;rt_flags &amp; ~ignflags;
	RT_UNLOCK(rt);
	<span class="enscript-keyword">if</span> (report &amp;&amp; (nflags &amp; (RTF_CLONING | RTF_PRCLONING))) {
		<span class="enscript-comment">/*
		 * We are apparently adding (report = 0 in delete).
		 * If it requires that it be cloned, do so.
		 * (This implies it wasn't a HOST route.)
		 */</span>
		err = rtrequest_locked(RTM_RESOLVE, dst, NULL, NULL, 0, &amp;newrt);
		<span class="enscript-keyword">if</span> (err) {
			<span class="enscript-comment">/*
			 * If the cloning didn't succeed, maybe what we
			 * have from lookup above will do.  Return that;
			 * no need to hold another reference since it's
			 * already done.
			 */</span>
			newrt = rt;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">miss</span>;
		}

		<span class="enscript-comment">/*
		 * We cloned it; drop the original route found during lookup.
		 * The resulted cloned route (newrt) would now have an extra
		 * reference held during rtrequest.
		 */</span>
		rtfree_locked(rt);

		<span class="enscript-comment">/*
		 * If the newly created cloned route is a direct host route
		 * then also check if it is to a router or not.
		 * If it is, then set the RTF_ROUTER flag on the host route
		 * for the gateway.
		 *
		 * XXX It is possible for the default route to be created post
		 * cloned route creation of router's IP.
		 * We can handle that corner case by special handing for RTM_ADD
		 * of default route.
		 */</span>
		<span class="enscript-keyword">if</span> ((newrt-&gt;rt_flags &amp; (RTF_HOST | RTF_LLINFO)) ==
		    (RTF_HOST | RTF_LLINFO)) {
			<span class="enscript-type">struct</span> rtentry *defrt = NULL;
			<span class="enscript-type">struct</span> sockaddr_storage def_key;

			bzero(&amp;def_key, <span class="enscript-keyword">sizeof</span>(def_key));
			def_key.ss_len = rt_key(newrt)-&gt;sa_len;
			def_key.ss_family = rt_key(newrt)-&gt;sa_family;

			defrt = rtalloc1_scoped_locked((<span class="enscript-type">struct</span> sockaddr *)&amp;def_key,
					0, 0, newrt-&gt;rt_ifp-&gt;if_index);

			<span class="enscript-keyword">if</span> (defrt) {
				<span class="enscript-keyword">if</span> (equal(rt_key(newrt), defrt-&gt;rt_gateway)) {
					newrt-&gt;rt_flags |= RTF_ROUTER;
				}
				rtfree_locked(defrt);
			}
		}

		<span class="enscript-keyword">if</span> ((rt = newrt) &amp;&amp; (rt-&gt;rt_flags &amp; RTF_XRESOLVE)) {
			<span class="enscript-comment">/*
			 * If the new route specifies it be
			 * externally resolved, then go do that.
			 */</span>
			msgtype = RTM_RESOLVE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">miss</span>;
		}
	}
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

<span class="enscript-reference">unreachable</span>:
	<span class="enscript-comment">/*
	 * Either we hit the root or couldn't find any match,
	 * Which basically means &quot;cant get there from here&quot;
	 */</span>
	rtstat.rts_unreach++;
<span class="enscript-reference">miss</span>:
	<span class="enscript-keyword">if</span> (report) {
		<span class="enscript-comment">/*
		 * If required, report the failure to the supervising
		 * Authorities.
		 * For a delete, this is not an error. (report == 0)
		 */</span>
		bzero((caddr_t)&amp;info, <span class="enscript-keyword">sizeof</span>(info));
		info.rti_info[RTAX_DST] = dst;
		rt_missmsg(msgtype, &amp;info, 0, err);
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (newrt);
}

<span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">rtalloc1</span>(<span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">int</span> report, uint32_t ignflags)
{
	<span class="enscript-type">struct</span> rtentry *entry;
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);
	lck_mtx_lock(rnh_lock);
	entry = rtalloc1_locked(dst, report, ignflags);
	lck_mtx_unlock(rnh_lock);
	<span class="enscript-keyword">return</span> (entry);
}

<span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">rtalloc1_scoped</span>(<span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">int</span> report, uint32_t ignflags,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">struct</span> rtentry *entry;
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);
	lck_mtx_lock(rnh_lock);
	entry = rtalloc1_scoped_locked(dst, report, ignflags, ifscope);
	lck_mtx_unlock(rnh_lock);
	<span class="enscript-keyword">return</span> (entry);
}

<span class="enscript-comment">/*
 * Remove a reference count from an rtentry.
 * If the count gets low enough, take it out of the routing table
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rtfree_locked</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	rtfree_common(rt, TRUE);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rtfree_common</span>(<span class="enscript-type">struct</span> rtentry *rt, boolean_t locked)
{
	<span class="enscript-type">struct</span> radix_node_head *rnh;

	lck_mtx_assert(rnh_lock, locked ?
	    LCK_MTX_ASSERT_OWNED : LCK_MTX_ASSERT_NOTOWNED);

	<span class="enscript-comment">/*
	 * Atomically decrement the reference count and if it reaches 0,
	 * and there is a close function defined, call the close function.
	 */</span>
	RT_LOCK_SPIN(rt);
	<span class="enscript-keyword">if</span> (rtunref(rt) &gt; 0) {
		RT_UNLOCK(rt);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * To avoid violating lock ordering, we must drop rt_lock before
	 * trying to acquire the global rnh_lock.  If we are called with
	 * rnh_lock held, then we already have exclusive access; otherwise
	 * we do the lock dance.
	 */</span>
	<span class="enscript-keyword">if</span> (!locked) {
		<span class="enscript-comment">/*
		 * Note that we check it again below after grabbing rnh_lock,
		 * since it is possible that another thread doing a lookup wins
		 * the race, grabs the rnh_lock first, and bumps up reference
		 * count in which case the route should be left alone as it is
		 * still in use.  It's also possible that another thread frees
		 * the route after we drop rt_lock; to prevent the route from
		 * being freed, we hold an extra reference.
		 */</span>
		RT_ADDREF_LOCKED(rt);
		RT_UNLOCK(rt);
		lck_mtx_lock(rnh_lock);
		RT_LOCK_SPIN(rt);
		<span class="enscript-keyword">if</span> (rtunref(rt) &gt; 0) {
			<span class="enscript-comment">/* We've lost the race, so abort */</span>
			RT_UNLOCK(rt);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	<span class="enscript-comment">/*
	 * We may be blocked on other lock(s) as part of freeing
	 * the entry below, so convert from spin to full mutex.
	 */</span>
	RT_CONVERT_LOCK(rt);

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* Negative refcnt must never happen */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_refcnt != 0) {
		panic(<span class="enscript-string">&quot;rt %p invalid refcnt %d&quot;</span>, rt, rt-&gt;rt_refcnt);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-comment">/* Idle refcnt must have been dropped during rtunref() */</span>
	VERIFY(!(rt-&gt;rt_flags &amp; RTF_IFREF));

	<span class="enscript-comment">/*
	 * find the tree for that address family
	 * Note: in the case of igmp packets, there might not be an rnh
	 */</span>
	rnh = rt_tables[rt_key(rt)-&gt;sa_family];

	<span class="enscript-comment">/*
	 * On last reference give the &quot;close method&quot; a chance to cleanup
	 * private state.  This also permits (for IPv4 and IPv6) a chance
	 * to decide if the routing table entry should be purged immediately
	 * or at a later time.  When an immediate purge is to happen the
	 * close routine typically issues RTM_DELETE which clears the RTF_UP
	 * flag on the entry so that the code below reclaims the storage.
	 */</span>
	<span class="enscript-keyword">if</span> (rnh != NULL &amp;&amp; rnh-&gt;rnh_close != NULL)
		rnh-&gt;rnh_close((<span class="enscript-type">struct</span> radix_node *)rt, rnh);

	<span class="enscript-comment">/*
	 * If we are no longer &quot;up&quot; (and ref == 0) then we can free the
	 * resources associated with the route.
	 */</span>
	<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_UP)) {
		<span class="enscript-type">struct</span> rtentry *rt_parent;
		<span class="enscript-type">struct</span> ifaddr *rt_ifa;

		<span class="enscript-keyword">if</span> (rt-&gt;rt_nodes-&gt;rn_flags &amp; (RNF_ACTIVE | RNF_ROOT)) {
			panic(<span class="enscript-string">&quot;rt %p freed while in radix tree\n&quot;</span>, rt);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		<span class="enscript-comment">/*
		 * the rtentry must have been removed from the routing table
		 * so it is represented in rttrash; remove that now.
		 */</span>
		(<span class="enscript-type">void</span>) OSDecrementAtomic(&amp;rttrash);
		<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_DEBUG) {
			TAILQ_REMOVE(&amp;rttrash_head, (<span class="enscript-type">struct</span> rtentry_dbg *)rt,
			    rtd_trash_link);
		}

		<span class="enscript-comment">/*
		 * release references on items we hold them on..
		 * e.g other routes and ifaddrs.
		 */</span>
		<span class="enscript-keyword">if</span> ((rt_parent = rt-&gt;rt_parent) != NULL)
			rt-&gt;rt_parent = NULL;

		<span class="enscript-keyword">if</span> ((rt_ifa = rt-&gt;rt_ifa) != NULL)
			rt-&gt;rt_ifa = NULL;

		<span class="enscript-comment">/*
		 * Now free any attached link-layer info.
		 */</span>
		<span class="enscript-keyword">if</span> (rt-&gt;rt_llinfo != NULL) {
			<span class="enscript-keyword">if</span> (rt-&gt;rt_llinfo_free != NULL)
				(*rt-&gt;rt_llinfo_free)(rt-&gt;rt_llinfo);
			<span class="enscript-keyword">else</span>
				R_Free(rt-&gt;rt_llinfo);
			rt-&gt;rt_llinfo = NULL;
		}

		<span class="enscript-comment">/*
		 * Route is no longer in the tree and refcnt is 0;
		 * we have exclusive access, so destroy it.
		 */</span>
		RT_UNLOCK(rt);

		<span class="enscript-keyword">if</span> (rt_parent != NULL)
			rtfree_locked(rt_parent);

		<span class="enscript-keyword">if</span> (rt_ifa != NULL)
			IFA_REMREF(rt_ifa);

		<span class="enscript-comment">/*
		 * The key is separately alloc'd so free it (see rt_setgate()).
		 * This also frees the gateway, as they are always malloc'd
		 * together.
		 */</span>
		R_Free(rt_key(rt));

		<span class="enscript-comment">/*
		 * Free any statistics that may have been allocated
		 */</span>
		nstat_route_detach(rt);

		<span class="enscript-comment">/*
		 * and the rtentry itself of course
		 */</span>
		rte_lock_destroy(rt);
		rte_free(rt);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * The &quot;close method&quot; has been called, but the route is
		 * still in the radix tree with zero refcnt, i.e. &quot;up&quot;
		 * and in the cached state.
		 */</span>
		RT_UNLOCK(rt);
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_unlock(rnh_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rtfree</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	rtfree_common(rt, FALSE);
}

<span class="enscript-comment">/*
 * Decrements the refcount but does not free the route when
 * the refcount reaches zero. Unless you have really good reason,
 * use rtfree not rtunref.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">rtunref</span>(<span class="enscript-type">struct</span> rtentry *p)
{
	RT_LOCK_ASSERT_HELD(p);

	<span class="enscript-keyword">if</span> (p-&gt;rt_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s(%p) bad refcnt\n&quot;</span>, __func__, p);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (--p-&gt;rt_refcnt == 0) {
		<span class="enscript-comment">/*
		 * Release any idle reference count held on the interface;
		 * if the route is eligible, still UP and the refcnt becomes
		 * non-zero at some point in future before it is purged from
		 * the routing table, rt_set_idleref() will undo this.
		 */</span>
		rt_clear_idleref(p);
	}

	<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_DEBUG)
		rtunref_audit((<span class="enscript-type">struct</span> rtentry_dbg *)p);

	<span class="enscript-comment">/* Return new value */</span>
	<span class="enscript-keyword">return</span> (p-&gt;rt_refcnt);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">rtunref_audit</span>(<span class="enscript-type">struct</span> rtentry_dbg *rte)
{
	uint16_t idx;

	<span class="enscript-keyword">if</span> (rte-&gt;rtd_inuse != RTD_INUSE) {
		panic(<span class="enscript-string">&quot;rtunref: on freed rte=%p\n&quot;</span>, rte);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	idx = atomic_add_16_ov(&amp;rte-&gt;rtd_refrele_cnt, 1) % CTRACE_HIST_SIZE;
	<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_TRACE)
		ctrace_record(&amp;rte-&gt;rtd_refrele[idx]);
}

<span class="enscript-comment">/*
 * Add a reference count from an rtentry.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rtref</span>(<span class="enscript-type">struct</span> rtentry *p)
{
	RT_LOCK_ASSERT_HELD(p);

	<span class="enscript-keyword">if</span> (++p-&gt;rt_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s(%p) bad refcnt\n&quot;</span>, __func__, p);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p-&gt;rt_refcnt == 1) {
		<span class="enscript-comment">/*
		 * Hold an idle reference count on the interface,
		 * if the route is eligible for it.
		 */</span>
		rt_set_idleref(p);
	}

	<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_DEBUG)
		rtref_audit((<span class="enscript-type">struct</span> rtentry_dbg *)p);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">rtref_audit</span>(<span class="enscript-type">struct</span> rtentry_dbg *rte)
{
	uint16_t idx;

	<span class="enscript-keyword">if</span> (rte-&gt;rtd_inuse != RTD_INUSE) {
		panic(<span class="enscript-string">&quot;rtref_audit: on freed rte=%p\n&quot;</span>, rte);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	idx = atomic_add_16_ov(&amp;rte-&gt;rtd_refhold_cnt, 1) % CTRACE_HIST_SIZE;
	<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_TRACE)
		ctrace_record(&amp;rte-&gt;rtd_refhold[idx]);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rtsetifa</span>(<span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> ifaddr *ifa)
{
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-keyword">if</span> (rt-&gt;rt_ifa == ifa)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Become a regular mutex, just in case */</span>
	RT_CONVERT_LOCK(rt);

	<span class="enscript-comment">/* Release the old ifa */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_ifa)
		IFA_REMREF(rt-&gt;rt_ifa);

	<span class="enscript-comment">/* Set rt_ifa */</span>
	rt-&gt;rt_ifa = ifa;

	<span class="enscript-comment">/* Take a reference to the ifa */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_ifa)
		IFA_ADDREF(rt-&gt;rt_ifa);
}

<span class="enscript-comment">/*
 * Force a routing table entry to the specified
 * destination to go through the given gateway.
 * Normally called as a result of a routing redirect
 * message from the network layer.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rtredirect</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">struct</span> sockaddr *gateway,
    <span class="enscript-type">struct</span> sockaddr *netmask, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> sockaddr *src,
    <span class="enscript-type">struct</span> rtentry **rtp)
{
	<span class="enscript-type">struct</span> rtentry *rt = NULL;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">short</span> *stat = 0;
	<span class="enscript-type">struct</span> rt_addrinfo info;
	<span class="enscript-type">struct</span> ifaddr *ifa = NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope = (ifp != NULL) ? ifp-&gt;if_index : IFSCOPE_NONE;
	<span class="enscript-type">struct</span> sockaddr_storage ss;
	<span class="enscript-type">int</span> af = src-&gt;sa_family;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);
	lck_mtx_lock(rnh_lock);

	<span class="enscript-comment">/*
	 * Transform src into the internal routing table form for
	 * comparison against rt_gateway below.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> ((af == AF_INET &amp;&amp; ip_doscopedroute) ||
	    (af == AF_INET6 &amp;&amp; ip6_doscopedroute))
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (af == AF_INET &amp;&amp; ip_doscopedroute)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
		src = sa_copy(src, &amp;ss, &amp;ifscope);

	<span class="enscript-comment">/*
	 * Verify the gateway is directly reachable; if scoped routing
	 * is enabled, verify that it is reachable from the interface
	 * where the ICMP redirect arrived on.
	 */</span>
	<span class="enscript-keyword">if</span> ((ifa = ifa_ifwithnet_scoped(gateway, ifscope)) == NULL) {
		error = ENETUNREACH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Lookup route to the destination (from the original IP header) */</span>
	rt = rtalloc1_scoped_locked(dst, 0, RTF_CLONING|RTF_PRCLONING, ifscope);
	<span class="enscript-keyword">if</span> (rt != NULL)
		RT_LOCK(rt);

	<span class="enscript-comment">/*
	 * If the redirect isn't from our current router for this dst,
	 * it's either old or wrong.  If it redirects us to ourselves,
	 * we have a routing loop, perhaps as a result of an interface
	 * going down recently.  Holding rnh_lock here prevents the
	 * possibility of rt_ifa/ifa's ifa_addr from changing (e.g.
	 * in_ifinit), so okay to access ifa_addr without locking.
	 */</span>
	<span class="enscript-keyword">if</span> (!(flags &amp; RTF_DONE) &amp;&amp; rt != NULL &amp;&amp;
	    (!equal(src, rt-&gt;rt_gateway) || !equal(rt-&gt;rt_ifa-&gt;ifa_addr,
	    ifa-&gt;ifa_addr))) {
		error = EINVAL;
	} <span class="enscript-keyword">else</span> {
		IFA_REMREF(ifa);
		<span class="enscript-keyword">if</span> ((ifa = ifa_ifwithaddr(gateway))) {
			IFA_REMREF(ifa);
			ifa = NULL;
			error = EHOSTUNREACH;
		}
	}

	<span class="enscript-keyword">if</span> (ifa) {
		IFA_REMREF(ifa);
		ifa = NULL;
	}

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (rt != NULL)
			RT_UNLOCK(rt);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Create a new entry if we just got back a wildcard entry
	 * or the the lookup failed.  This is necessary for hosts
	 * which use routing redirects generated by smart gateways
	 * to dynamically build the routing tables.
	 */</span>
	<span class="enscript-keyword">if</span> ((rt == NULL) || (rt_mask(rt) != NULL &amp;&amp; rt_mask(rt)-&gt;sa_len &lt; 2))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">create</span>;
	<span class="enscript-comment">/*
	 * Don't listen to the redirect if it's
	 * for a route to an interface.
	 */</span>
	RT_LOCK_ASSERT_HELD(rt);
	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_GATEWAY) {
		<span class="enscript-keyword">if</span> (((rt-&gt;rt_flags &amp; RTF_HOST) == 0) &amp;&amp; (flags &amp; RTF_HOST)) {
			<span class="enscript-comment">/*
			 * Changing from route to net =&gt; route to host.
			 * Create new route, rather than smashing route
			 * to net; similar to cloned routes, the newly
			 * created host route is scoped as well.
			 */</span>
<span class="enscript-reference">create</span>:
			<span class="enscript-keyword">if</span> (rt != NULL)
				RT_UNLOCK(rt);
			flags |=  RTF_GATEWAY | RTF_DYNAMIC;
			error = rtrequest_scoped_locked(RTM_ADD, dst,
			    gateway, netmask, flags, NULL, ifscope);
			stat = &amp;rtstat.rts_dynamic;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Smash the current notion of the gateway to
			 * this destination.  Should check about netmask!!!
			 */</span>
			rt-&gt;rt_flags |= RTF_MODIFIED;
			flags |= RTF_MODIFIED;
			stat = &amp;rtstat.rts_newgateway;
			<span class="enscript-comment">/*
			 * add the key and gateway (in one malloc'd chunk).
			 */</span>
			error = rt_setgate(rt, rt_key(rt), gateway);
			RT_UNLOCK(rt);
		}
	} <span class="enscript-keyword">else</span> {
		RT_UNLOCK(rt);
		error = EHOSTUNREACH;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK_ASSERT_NOTHELD(rt);
		<span class="enscript-keyword">if</span> (rtp &amp;&amp; !error)
			*rtp = rt;
		<span class="enscript-keyword">else</span>
			rtfree_locked(rt);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error) {
		rtstat.rts_badredirect++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (stat != NULL)
			(*stat)++;

		<span class="enscript-keyword">if</span> (af == AF_INET)
			routegenid_inet_update();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (af == AF_INET6)
			routegenid_inet6_update();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
	lck_mtx_unlock(rnh_lock);
	bzero((caddr_t)&amp;info, <span class="enscript-keyword">sizeof</span>(info));
	info.rti_info[RTAX_DST] = dst;
	info.rti_info[RTAX_GATEWAY] = gateway;
	info.rti_info[RTAX_NETMASK] = netmask;
	info.rti_info[RTAX_AUTHOR] = src;
	rt_missmsg(RTM_REDIRECT, &amp;info, flags, error);
}

<span class="enscript-comment">/*
* Routing table ioctl interface.
*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">rtioctl</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> req, caddr_t data, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">req</span>, <span class="enscript-variable-name">data</span>)
	<span class="enscript-keyword">return</span> (ENXIO);
}

<span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifa_ifwithroute</span>(
	<span class="enscript-type">int</span> flags,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr	*dst,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *gateway)
{
	<span class="enscript-type">struct</span> ifaddr *ifa;

	lck_mtx_lock(rnh_lock);
	ifa = ifa_ifwithroute_locked(flags, dst, gateway);
	lck_mtx_unlock(rnh_lock);

	<span class="enscript-keyword">return</span> (ifa);
}

<span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifa_ifwithroute_locked</span>(<span class="enscript-type">int</span> flags, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *dst,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *gateway)
{
	<span class="enscript-keyword">return</span> (ifa_ifwithroute_common_locked((flags &amp; ~RTF_IFSCOPE), dst,
	    gateway, IFSCOPE_NONE));
}

<span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifa_ifwithroute_scoped_locked</span>(<span class="enscript-type">int</span> flags, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *dst,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *gateway, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE)
		flags |= RTF_IFSCOPE;
	<span class="enscript-keyword">else</span>
		flags &amp;= ~RTF_IFSCOPE;

	<span class="enscript-keyword">return</span> (ifa_ifwithroute_common_locked(flags, dst, gateway, ifscope));
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifa_ifwithroute_common_locked</span>(<span class="enscript-type">int</span> flags, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *dst,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *gw, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">struct</span> ifaddr *ifa = NULL;
	<span class="enscript-type">struct</span> rtentry *rt = NULL;
	<span class="enscript-type">struct</span> sockaddr_storage dst_ss, gw_ss;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/*
	 * Just in case the sockaddr passed in by the caller
	 * contains a scope ID, make sure to clear it since
	 * interface addresses aren't scoped.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (dst != NULL &amp;&amp;
	    ((dst-&gt;sa_family == AF_INET &amp;&amp; ip_doscopedroute) ||
	    (dst-&gt;sa_family == AF_INET6 &amp;&amp; ip6_doscopedroute)))
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (dst != NULL &amp;&amp; dst-&gt;sa_family == AF_INET &amp;&amp; ip_doscopedroute)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
		dst = sa_copy(SA((uintptr_t)dst), &amp;dst_ss, NULL);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (gw != NULL &amp;&amp;
	    ((gw-&gt;sa_family == AF_INET &amp;&amp; ip_doscopedroute) ||
	    (gw-&gt;sa_family == AF_INET6 &amp;&amp; ip6_doscopedroute)))
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (gw != NULL &amp;&amp; gw-&gt;sa_family == AF_INET &amp;&amp; ip_doscopedroute)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
		gw = sa_copy(SA((uintptr_t)gw), &amp;gw_ss, NULL);

	<span class="enscript-keyword">if</span> (!(flags &amp; RTF_GATEWAY)) {
		<span class="enscript-comment">/*
		 * If we are adding a route to an interface,
		 * and the interface is a pt to pt link
		 * we should search for the destination
		 * as our clue to the interface.  Otherwise
		 * we can use the local address.
		 */</span>
		<span class="enscript-keyword">if</span> (flags &amp; RTF_HOST) {
			ifa = ifa_ifwithdstaddr(dst);
		}
		<span class="enscript-keyword">if</span> (ifa == NULL)
			ifa = ifa_ifwithaddr_scoped(gw, ifscope);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * If we are adding a route to a remote net
		 * or host, the gateway may still be on the
		 * other end of a pt to pt link.
		 */</span>
		ifa = ifa_ifwithdstaddr(gw);
	}
	<span class="enscript-keyword">if</span> (ifa == NULL)
		ifa = ifa_ifwithnet_scoped(gw, ifscope);
	<span class="enscript-keyword">if</span> (ifa == NULL) {
		<span class="enscript-comment">/* Workaround to avoid gcc warning regarding const variable */</span>
		rt = rtalloc1_scoped_locked((<span class="enscript-type">struct</span> sockaddr *)(size_t)dst,
		    0, 0, ifscope);
		<span class="enscript-keyword">if</span> (rt != NULL) {
			RT_LOCK_SPIN(rt);
			ifa = rt-&gt;rt_ifa;
			<span class="enscript-keyword">if</span> (ifa != NULL) {
				<span class="enscript-comment">/* Become a regular mutex */</span>
				RT_CONVERT_LOCK(rt);
				IFA_ADDREF(ifa);
			}
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
			rt = NULL;
		}
	}
	<span class="enscript-comment">/*
	 * Holding rnh_lock here prevents the possibility of ifa from
	 * changing (e.g. in_ifinit), so it is safe to access its
	 * ifa_addr (here and down below) without locking.
	 */</span>
	<span class="enscript-keyword">if</span> (ifa != NULL &amp;&amp; ifa-&gt;ifa_addr-&gt;sa_family != dst-&gt;sa_family) {
		<span class="enscript-type">struct</span> ifaddr *newifa;
		<span class="enscript-comment">/* Callee adds reference to newifa upon success */</span>
		newifa = ifaof_ifpforaddr(dst, ifa-&gt;ifa_ifp);
		<span class="enscript-keyword">if</span> (newifa != NULL) {
			IFA_REMREF(ifa);
			ifa = newifa;
		}
	}
	<span class="enscript-comment">/*
	 * If we are adding a gateway, it is quite possible that the
	 * routing table has a static entry in place for the gateway,
	 * that may not agree with info garnered from the interfaces.
	 * The routing table should carry more precedence than the
	 * interfaces in this matter.  Must be careful not to stomp
	 * on new entries from rtinit, hence (ifa-&gt;ifa_addr != gw).
	 */</span>
	<span class="enscript-keyword">if</span> ((ifa == NULL ||
	    !equal(ifa-&gt;ifa_addr, (<span class="enscript-type">struct</span> sockaddr *)(size_t)gw)) &amp;&amp;
	    (rt = rtalloc1_scoped_locked((<span class="enscript-type">struct</span> sockaddr *)(size_t)gw,
	    0, 0, ifscope)) != NULL) {
		<span class="enscript-keyword">if</span> (ifa != NULL)
			IFA_REMREF(ifa);
		RT_LOCK_SPIN(rt);
		ifa = rt-&gt;rt_ifa;
		<span class="enscript-keyword">if</span> (ifa != NULL) {
			<span class="enscript-comment">/* Become a regular mutex */</span>
			RT_CONVERT_LOCK(rt);
			IFA_ADDREF(ifa);
		}
		RT_REMREF_LOCKED(rt);
		RT_UNLOCK(rt);
	}
	<span class="enscript-comment">/*
	 * If an interface scope was specified, the interface index of
	 * the found ifaddr must be equivalent to that of the scope;
	 * otherwise there is no match.
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; RTF_IFSCOPE) &amp;&amp;
	    ifa != NULL &amp;&amp; ifa-&gt;ifa_ifp-&gt;if_index != ifscope) {
		IFA_REMREF(ifa);
		ifa = NULL;
	}

	<span class="enscript-keyword">return</span> (ifa);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rt_fixdelete</span>(<span class="enscript-type">struct</span> radix_node *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rt_fixchange</span>(<span class="enscript-type">struct</span> radix_node *, <span class="enscript-type">void</span> *);

<span class="enscript-type">struct</span> rtfc_arg {
	<span class="enscript-type">struct</span> rtentry *rt0;
	<span class="enscript-type">struct</span> radix_node_head *rnh;
};

<span class="enscript-type">int</span>
<span class="enscript-function-name">rtrequest_locked</span>(<span class="enscript-type">int</span> req, <span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">struct</span> sockaddr *gateway,
    <span class="enscript-type">struct</span> sockaddr *netmask, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> rtentry **ret_nrt)
{
	<span class="enscript-keyword">return</span> (rtrequest_common_locked(req, dst, gateway, netmask,
	    (flags &amp; ~RTF_IFSCOPE), ret_nrt, IFSCOPE_NONE));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">rtrequest_scoped_locked</span>(<span class="enscript-type">int</span> req, <span class="enscript-type">struct</span> sockaddr *dst,
    <span class="enscript-type">struct</span> sockaddr *gateway, <span class="enscript-type">struct</span> sockaddr *netmask, <span class="enscript-type">int</span> flags,
    <span class="enscript-type">struct</span> rtentry **ret_nrt, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE)
		flags |= RTF_IFSCOPE;
	<span class="enscript-keyword">else</span>
		flags &amp;= ~RTF_IFSCOPE;

	<span class="enscript-keyword">return</span> (rtrequest_common_locked(req, dst, gateway, netmask,
	    flags, ret_nrt, ifscope));
}

<span class="enscript-comment">/*
 * Do appropriate manipulations of a routing tree given all the bits of
 * info needed.
 *
 * Storing the scope ID in the radix key is an internal job that should be
 * left to routines in this module.  Callers should specify the scope value
 * to the &quot;scoped&quot; variants of route routines instead of manipulating the
 * key itself.  This is typically done when creating a scoped route, e.g.
 * rtrequest(RTM_ADD).  Once such a route is created and marked with the
 * RTF_IFSCOPE flag, callers can simply use its rt_key(rt) to clone it
 * (RTM_RESOLVE) or to remove it (RTM_DELETE).  An exception to this is
 * during certain routing socket operations where the search key might be
 * derived from the routing message itself, in which case the caller must
 * specify the destination address and scope value for RTM_ADD/RTM_DELETE.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rtrequest_common_locked</span>(<span class="enscript-type">int</span> req, <span class="enscript-type">struct</span> sockaddr *dst0,
    <span class="enscript-type">struct</span> sockaddr *gateway, <span class="enscript-type">struct</span> sockaddr *netmask, <span class="enscript-type">int</span> flags,
    <span class="enscript-type">struct</span> rtentry **ret_nrt, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">struct</span> radix_node *rn;
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	<span class="enscript-type">struct</span> ifaddr *ifa = NULL;
	<span class="enscript-type">struct</span> sockaddr *ndst, *dst = dst0;
	<span class="enscript-type">struct</span> sockaddr_storage ss, mask;
	<span class="enscript-type">struct</span> timeval caltime;
	<span class="enscript-type">int</span> af = dst-&gt;sa_family;
	<span class="enscript-type">void</span> (*ifa_rtrequest)(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> sockaddr *);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">senderr</span>(x) { error = x; goto bad; }

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
	<span class="enscript-comment">/*
	 * Find the correct routing tree to use for this Address Family
	 */</span>
	<span class="enscript-keyword">if</span> ((rnh = rt_tables[af]) == NULL)
		senderr(ESRCH);
	<span class="enscript-comment">/*
	 * If we are adding a host route then we don't want to put
	 * a netmask in the tree
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; RTF_HOST)
		netmask = NULL;

	<span class="enscript-comment">/*
	 * If Scoped Routing is enabled, use a local copy of the destination
	 * address to store the scope ID into.  This logic is repeated below
	 * in the RTM_RESOLVE handler since the caller does not normally
	 * specify such a flag during a resolve, as well as for the handling
	 * of IPv4 link-local address; instead, it passes in the route used for
	 * cloning for which the scope info is derived from.  Note also that
	 * in the case of RTM_DELETE, the address passed in by the caller
	 * might already contain the scope ID info when it is the key itself,
	 * thus making RTF_IFSCOPE unnecessary; one instance where it is
	 * explicitly set is inside route_output() as part of handling a
	 * routing socket request.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (req != RTM_RESOLVE &amp;&amp;
	    ((af == AF_INET &amp;&amp; ip_doscopedroute) ||
	    (af == AF_INET6 &amp;&amp; ip6_doscopedroute))) {
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (req != RTM_RESOLVE &amp;&amp; af == AF_INET &amp;&amp; ip_doscopedroute) {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
		<span class="enscript-comment">/* Transform dst into the internal routing table form */</span>
		dst = sa_copy(dst, &amp;ss, &amp;ifscope);

		<span class="enscript-comment">/* Transform netmask into the internal routing table form */</span>
		<span class="enscript-keyword">if</span> (netmask != NULL)
			netmask = ma_copy(af, netmask, &amp;mask, ifscope);

		<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE)
			flags |= RTF_IFSCOPE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((flags &amp; RTF_IFSCOPE) &amp;&amp; (af != AF_INET &amp;&amp; af != AF_INET6))
			senderr(EINVAL);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> ((af == AF_INET &amp;&amp; !ip_doscopedroute) ||
		    (af == AF_INET6 &amp;&amp; !ip6_doscopedroute))
#<span class="enscript-reference">else</span>
		<span class="enscript-keyword">if</span> (af == AF_INET &amp;&amp; !ip_doscopedroute)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
			ifscope = IFSCOPE_NONE;
	}

	<span class="enscript-keyword">if</span> (ifscope == IFSCOPE_NONE)
		flags &amp;= ~RTF_IFSCOPE;

	<span class="enscript-keyword">switch</span> (req) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_DELETE</span>: {
		<span class="enscript-type">struct</span> rtentry *gwrt = NULL;
		<span class="enscript-comment">/*
		 * Remove the item from the tree and return it.
		 * Complain if it is not there and do no more processing.
		 */</span>
		<span class="enscript-keyword">if</span> ((rn = rnh-&gt;rnh_deladdr(dst, netmask, rnh)) == NULL)
			senderr(ESRCH);
		<span class="enscript-keyword">if</span> (rn-&gt;rn_flags &amp; (RNF_ACTIVE | RNF_ROOT)) {
			panic(<span class="enscript-string">&quot;rtrequest delete&quot;</span>);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		rt = (<span class="enscript-type">struct</span> rtentry *)rn;

		RT_LOCK(rt);
		rt-&gt;rt_flags &amp;= ~RTF_UP;
		<span class="enscript-comment">/*
		 * Release any idle reference count held on the interface
		 * as this route is no longer externally visible.
		 */</span>
		rt_clear_idleref(rt);
		<span class="enscript-comment">/*
		 * Take an extra reference to handle the deletion of a route
		 * entry whose reference count is already 0; e.g. an expiring
		 * cloned route entry or an entry that was added to the table
		 * with 0 reference. If the caller is interested in this route,
		 * we will return it with the reference intact. Otherwise we
		 * will decrement the reference via rtfree_locked() and then
		 * possibly deallocate it.
		 */</span>
		RT_ADDREF_LOCKED(rt);

		<span class="enscript-comment">/*
		 * For consistency, in case the caller didn't set the flag.
		 */</span>
		rt-&gt;rt_flags |= RTF_CONDEMNED;

		<span class="enscript-comment">/*
		 * Clear RTF_ROUTER if it's set.
		 */</span>
		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_ROUTER) {
			VERIFY(rt-&gt;rt_flags &amp; RTF_HOST);
			rt-&gt;rt_flags &amp;= ~RTF_ROUTER;
		}

		<span class="enscript-comment">/*
		 * Now search what's left of the subtree for any cloned
		 * routes which might have been formed from this node.
		 */</span>
		<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; (RTF_CLONING | RTF_PRCLONING)) &amp;&amp;
		    rt_mask(rt)) {
			RT_UNLOCK(rt);
			rnh-&gt;rnh_walktree_from(rnh, dst, rt_mask(rt),
			    rt_fixdelete, rt);
			RT_LOCK(rt);
		}

		<span class="enscript-comment">/*
		 * Remove any external references we may have.
		 */</span>
		<span class="enscript-keyword">if</span> ((gwrt = rt-&gt;rt_gwroute) != NULL)
			rt-&gt;rt_gwroute = NULL;

		<span class="enscript-comment">/*
		 * give the protocol a chance to keep things in sync.
		 */</span>
		<span class="enscript-keyword">if</span> ((ifa = rt-&gt;rt_ifa) != NULL) {
			IFA_LOCK_SPIN(ifa);
			ifa_rtrequest = ifa-&gt;ifa_rtrequest;
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">if</span> (ifa_rtrequest != NULL)
				ifa_rtrequest(RTM_DELETE, rt, NULL);
			<span class="enscript-comment">/* keep reference on rt_ifa */</span>
			ifa = NULL;
		}

		<span class="enscript-comment">/*
		 * one more rtentry floating around that is not
		 * linked to the routing table.
		 */</span>
		(<span class="enscript-type">void</span>) OSIncrementAtomic(&amp;rttrash);
		<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_DEBUG) {
			TAILQ_INSERT_TAIL(&amp;rttrash_head,
			    (<span class="enscript-type">struct</span> rtentry_dbg *)rt, rtd_trash_link);
		}

		<span class="enscript-comment">/*
		 * If this is the (non-scoped) default route, clear
		 * the interface index used for the primary ifscope.
		 */</span>
		<span class="enscript-keyword">if</span> (rt_primary_default(rt, rt_key(rt))) {
			set_primary_ifscope(rt_key(rt)-&gt;sa_family,
			    IFSCOPE_NONE);
		}

		RT_UNLOCK(rt);

		<span class="enscript-comment">/*
		 * This might result in another rtentry being freed if
		 * we held its last reference.  Do this after the rtentry
		 * lock is dropped above, as it could lead to the same
		 * lock being acquired if gwrt is a clone of rt.
		 */</span>
		<span class="enscript-keyword">if</span> (gwrt != NULL)
			rtfree_locked(gwrt);

		<span class="enscript-comment">/*
		 * If the caller wants it, then it can have it,
		 * but it's up to it to free the rtentry as we won't be
		 * doing it.
		 */</span>
		<span class="enscript-keyword">if</span> (ret_nrt != NULL) {
			<span class="enscript-comment">/* Return the route to caller with reference intact */</span>
			*ret_nrt = rt;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Dereference or deallocate the route */</span>
			rtfree_locked(rt);
		}
		<span class="enscript-keyword">if</span> (af == AF_INET)
			routegenid_inet_update();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (af == AF_INET6)
			routegenid_inet6_update();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_RESOLVE</span>:
		<span class="enscript-keyword">if</span> (ret_nrt == NULL || (rt = *ret_nrt) == NULL)
			senderr(EINVAL);
		<span class="enscript-comment">/*
		 * According to the UNIX conformance tests, we need to return
		 * ENETUNREACH when the parent route is RTF_REJECT. 
		 * However, there isn't any point in cloning RTF_REJECT
		 * routes, so we immediately return an error.
		 */</span>
		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_REJECT) {
			<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_HOST) {
				senderr(EHOSTUNREACH);
			} <span class="enscript-keyword">else</span> {
				senderr(ENETUNREACH);
			}
		}
		<span class="enscript-comment">/*
		 * If cloning, we have the parent route given by the caller
		 * and will use its rt_gateway, rt_rmx as part of the cloning
		 * process below.  Since rnh_lock is held at this point, the
		 * parent's rt_ifa and rt_gateway will not change, and its
		 * relevant rt_flags will not change as well.  The only thing
		 * that could change are the metrics, and thus we hold the
		 * parent route's rt_lock later on during the actual copying
		 * of rt_rmx.
		 */</span>
		ifa = rt-&gt;rt_ifa;
		IFA_ADDREF(ifa);
		flags = rt-&gt;rt_flags &amp;
		    ~(RTF_CLONING | RTF_PRCLONING | RTF_STATIC);
		flags |= RTF_WASCLONED;
		gateway = rt-&gt;rt_gateway;
		<span class="enscript-keyword">if</span> ((netmask = rt-&gt;rt_genmask) == NULL)
			flags |= RTF_HOST;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> ((af != AF_INET &amp;&amp; af != AF_INET6) ||
		    (af == AF_INET &amp;&amp; !ip_doscopedroute) ||
		    (af == AF_INET6 &amp;&amp; !ip6_doscopedroute))
#<span class="enscript-reference">else</span>
		<span class="enscript-keyword">if</span> (af != AF_INET || !ip_doscopedroute)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">makeroute</span>;

		<span class="enscript-comment">/*
		 * When scoped routing is enabled, cloned entries are
		 * always scoped according to the interface portion of
		 * the parent route.  The exception to this are IPv4
		 * link local addresses, or those routes that are cloned
		 * from a RTF_PROXY route.  For the latter, the clone
		 * gets to keep the RTF_PROXY flag.
		 */</span>
		<span class="enscript-keyword">if</span> ((af == AF_INET &amp;&amp;
		    IN_LINKLOCAL(ntohl(SIN(dst)-&gt;sin_addr.s_addr))) ||
		    (rt-&gt;rt_flags &amp; RTF_PROXY)) {
			ifscope = IFSCOPE_NONE;
			flags &amp;= ~RTF_IFSCOPE;
			<span class="enscript-comment">/*
			 * These types of cloned routes aren't currently
			 * eligible for idle interface reference counting.
			 */</span>
			flags |= RTF_NOIFREF;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (flags &amp; RTF_IFSCOPE) {
				ifscope = (af == AF_INET) ?
				    sin_get_ifscope(rt_key(rt)) :
				    sin6_get_ifscope(rt_key(rt));
			} <span class="enscript-keyword">else</span> {
				ifscope = rt-&gt;rt_ifp-&gt;if_index;
				flags |= RTF_IFSCOPE;
			}
			VERIFY(ifscope != IFSCOPE_NONE);
		}

		<span class="enscript-comment">/*
		 * Transform dst into the internal routing table form,
		 * clearing out the scope ID field if ifscope isn't set.
		 */</span>
		dst = sa_copy(dst, &amp;ss, (ifscope == IFSCOPE_NONE) ?
		    NULL : &amp;ifscope);

		<span class="enscript-comment">/* Transform netmask into the internal routing table form */</span>
		<span class="enscript-keyword">if</span> (netmask != NULL)
			netmask = ma_copy(af, netmask, &amp;mask, ifscope);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">makeroute</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_ADD</span>:
		<span class="enscript-keyword">if</span> ((flags &amp; RTF_GATEWAY) &amp;&amp; !gateway) {
			panic(<span class="enscript-string">&quot;rtrequest: RTF_GATEWAY but no gateway&quot;</span>);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		<span class="enscript-keyword">if</span> (flags &amp; RTF_IFSCOPE) {
			ifa = ifa_ifwithroute_scoped_locked(flags, dst0,
			    gateway, ifscope);
		} <span class="enscript-keyword">else</span> {
			ifa = ifa_ifwithroute_locked(flags, dst0, gateway);
		}
		<span class="enscript-keyword">if</span> (ifa == NULL)
			senderr(ENETUNREACH);
<span class="enscript-reference">makeroute</span>:
		<span class="enscript-keyword">if</span> ((rt = rte_alloc()) == NULL)
			senderr(ENOBUFS);
		Bzero(rt, <span class="enscript-keyword">sizeof</span>(*rt));
		rte_lock_init(rt);
		getmicrotime(&amp;caltime);
		rt-&gt;base_calendartime = caltime.tv_sec;
		rt-&gt;base_uptime = net_uptime();
		RT_LOCK(rt);
		rt-&gt;rt_flags = RTF_UP | flags;

		<span class="enscript-comment">/*
		 * Point the generation ID to the tree's.
		 */</span>
		<span class="enscript-keyword">switch</span> (af) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			rt-&gt;rt_tree_genid = &amp;route_genid_inet;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			rt-&gt;rt_tree_genid = &amp;route_genid_inet6;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * Add the gateway. Possibly re-malloc-ing the storage for it
		 * also add the rt_gwroute if possible.
		 */</span>
		<span class="enscript-keyword">if</span> ((error = rt_setgate(rt, dst, gateway)) != 0) {
			<span class="enscript-type">int</span> tmp = error;
			RT_UNLOCK(rt);
			nstat_route_detach(rt);
			rte_lock_destroy(rt);
			rte_free(rt);
			senderr(tmp);
		}

		<span class="enscript-comment">/*
		 * point to the (possibly newly malloc'd) dest address.
		 */</span>
		ndst = rt_key(rt);

		<span class="enscript-comment">/*
		 * make sure it contains the value we want (masked if needed).
		 */</span>
		<span class="enscript-keyword">if</span> (netmask)
			rt_maskedcopy(dst, ndst, netmask);
		<span class="enscript-keyword">else</span>
			Bcopy(dst, ndst, dst-&gt;sa_len);

		<span class="enscript-comment">/*
		 * Note that we now have a reference to the ifa.
		 * This moved from below so that rnh-&gt;rnh_addaddr() can
		 * examine the ifa and  ifa-&gt;ifa_ifp if it so desires.
		 */</span>
		rtsetifa(rt, ifa);
		rt-&gt;rt_ifp = rt-&gt;rt_ifa-&gt;ifa_ifp;

		<span class="enscript-comment">/* XXX mtu manipulation will be done in rnh_addaddr -- itojun */</span>

		rn = rnh-&gt;rnh_addaddr((caddr_t)ndst, (caddr_t)netmask,
		    rnh, rt-&gt;rt_nodes);
		<span class="enscript-keyword">if</span> (rn == 0) {
			<span class="enscript-type">struct</span> rtentry *rt2;
			<span class="enscript-comment">/*
			 * Uh-oh, we already have one of these in the tree.
			 * We do a special hack: if the route that's already
			 * there was generated by the protocol-cloning
			 * mechanism, then we just blow it away and retry
			 * the insertion of the new one.
			 */</span>
			<span class="enscript-keyword">if</span> (flags &amp; RTF_IFSCOPE) {
				rt2 = rtalloc1_scoped_locked(dst0, 0,
				    RTF_CLONING | RTF_PRCLONING, ifscope);
			} <span class="enscript-keyword">else</span> {
				rt2 = rtalloc1_locked(dst, 0,
				    RTF_CLONING | RTF_PRCLONING);
			}
			<span class="enscript-keyword">if</span> (rt2 &amp;&amp; rt2-&gt;rt_parent) {
				<span class="enscript-comment">/*
				 * rnh_lock is held here, so rt_key and
				 * rt_gateway of rt2 will not change.
				 */</span>
				(<span class="enscript-type">void</span>) rtrequest_locked(RTM_DELETE, rt_key(rt2),
				    rt2-&gt;rt_gateway, rt_mask(rt2),
				    rt2-&gt;rt_flags, 0);
				rtfree_locked(rt2);
				rn = rnh-&gt;rnh_addaddr((caddr_t)ndst,
				    (caddr_t)netmask, rnh, rt-&gt;rt_nodes);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rt2) {
				<span class="enscript-comment">/* undo the extra ref we got */</span>
				rtfree_locked(rt2);
			}
		}

		<span class="enscript-comment">/*
		 * If it still failed to go into the tree,
		 * then un-make it (this should be a function)
		 */</span>
		<span class="enscript-keyword">if</span> (rn == NULL) {
			<span class="enscript-comment">/* Clear gateway route */</span>
			rt_set_gwroute(rt, rt_key(rt), NULL);
			<span class="enscript-keyword">if</span> (rt-&gt;rt_ifa) {
				IFA_REMREF(rt-&gt;rt_ifa);
				rt-&gt;rt_ifa = NULL;
			}
			R_Free(rt_key(rt));
			RT_UNLOCK(rt);
			nstat_route_detach(rt);
			rte_lock_destroy(rt);
			rte_free(rt);
			senderr(EEXIST);
		}

		rt-&gt;rt_parent = NULL;

		<span class="enscript-comment">/*
		 * If we got here from RESOLVE, then we are cloning so clone
		 * the rest, and note that we are a clone (and increment the
		 * parent's references).  rnh_lock is still held, which prevents
		 * a lookup from returning the newly-created route.  Hence
		 * holding and releasing the parent's rt_lock while still
		 * holding the route's rt_lock is safe since the new route
		 * is not yet externally visible.
		 */</span>
		<span class="enscript-keyword">if</span> (req == RTM_RESOLVE) {
			RT_LOCK_SPIN(*ret_nrt);
			VERIFY((*ret_nrt)-&gt;rt_expire == 0 ||
			    (*ret_nrt)-&gt;rt_rmx.rmx_expire != 0);
			VERIFY((*ret_nrt)-&gt;rt_expire != 0 ||
			    (*ret_nrt)-&gt;rt_rmx.rmx_expire == 0);
			rt-&gt;rt_rmx = (*ret_nrt)-&gt;rt_rmx;
			rt_setexpire(rt, (*ret_nrt)-&gt;rt_expire);
			<span class="enscript-keyword">if</span> ((*ret_nrt)-&gt;rt_flags &amp;
			    (RTF_CLONING | RTF_PRCLONING)) {
				rt-&gt;rt_parent = (*ret_nrt);
				RT_ADDREF_LOCKED(*ret_nrt);
			}
			RT_UNLOCK(*ret_nrt);
		}

		<span class="enscript-comment">/*
		 * if this protocol has something to add to this then
		 * allow it to do that as well.
		 */</span>
		IFA_LOCK_SPIN(ifa);
		ifa_rtrequest = ifa-&gt;ifa_rtrequest;
		IFA_UNLOCK(ifa);
		<span class="enscript-keyword">if</span> (ifa_rtrequest != NULL)
			ifa_rtrequest(req, rt, SA(ret_nrt ? *ret_nrt : NULL));
		IFA_REMREF(ifa);
		ifa = NULL;

		<span class="enscript-comment">/*
		 * If this is the (non-scoped) default route, record
		 * the interface index used for the primary ifscope.
		 */</span>
		<span class="enscript-keyword">if</span> (rt_primary_default(rt, rt_key(rt))) {
			set_primary_ifscope(rt_key(rt)-&gt;sa_family,
			    rt-&gt;rt_ifp-&gt;if_index);
		}

		<span class="enscript-comment">/*
		 * actually return a resultant rtentry and
		 * give the caller a single reference.
		 */</span>
		<span class="enscript-keyword">if</span> (ret_nrt) {
			*ret_nrt = rt;
			RT_ADDREF_LOCKED(rt);
		}

		<span class="enscript-keyword">if</span> (af == AF_INET)
			routegenid_inet_update();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (af == AF_INET6)
			routegenid_inet6_update();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

		RT_GENID_SYNC(rt);

		<span class="enscript-comment">/*
		 * We repeat the same procedures from rt_setgate() here
		 * because they weren't completed when we called it earlier,
		 * since the node was embryonic.
		 */</span>
		<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_GATEWAY) &amp;&amp; rt-&gt;rt_gwroute != NULL)
			rt_set_gwroute(rt, rt_key(rt), rt-&gt;rt_gwroute);

		<span class="enscript-keyword">if</span> (req == RTM_ADD &amp;&amp;
		    !(rt-&gt;rt_flags &amp; RTF_HOST) &amp;&amp; rt_mask(rt) != NULL) {
			<span class="enscript-type">struct</span> rtfc_arg arg;
			arg.rnh = rnh;
			arg.rt0 = rt;
			RT_UNLOCK(rt);
			rnh-&gt;rnh_walktree_from(rnh, rt_key(rt), rt_mask(rt),
			    rt_fixchange, &amp;arg);
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(rt);
		}

		nstat_route_new_entry(rt);
		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (ifa)
		IFA_REMREF(ifa);
	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">senderr</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">rtrequest</span>(<span class="enscript-type">int</span> req, <span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">struct</span> sockaddr *gateway,
    <span class="enscript-type">struct</span> sockaddr *netmask, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> rtentry **ret_nrt)
{
	<span class="enscript-type">int</span> error;
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);
	lck_mtx_lock(rnh_lock);
	error = rtrequest_locked(req, dst, gateway, netmask, flags, ret_nrt);
	lck_mtx_unlock(rnh_lock);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">rtrequest_scoped</span>(<span class="enscript-type">int</span> req, <span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">struct</span> sockaddr *gateway,
    <span class="enscript-type">struct</span> sockaddr *netmask, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> rtentry **ret_nrt,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">int</span> error;
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);
	lck_mtx_lock(rnh_lock);
	error = rtrequest_scoped_locked(req, dst, gateway, netmask, flags,
	    ret_nrt, ifscope);
	lck_mtx_unlock(rnh_lock);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Called from rtrequest(RTM_DELETE, ...) to fix up the route's ``family''
 * (i.e., the routes related to it by the operation of cloning).  This
 * routine is iterated over all potential former-child-routes by way of
 * rnh-&gt;rnh_walktree_from() above, and those that actually are children of
 * the late parent (passed in as VP here) are themselves deleted.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rt_fixdelete</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">void</span> *vp)
{
	<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)rn;
	<span class="enscript-type">struct</span> rtentry *rt0 = vp;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	RT_LOCK(rt);
	<span class="enscript-keyword">if</span> (rt-&gt;rt_parent == rt0 &amp;&amp;
	    !(rt-&gt;rt_flags &amp; (RTF_CLONING | RTF_PRCLONING))) {
		<span class="enscript-comment">/*
		 * Safe to drop rt_lock and use rt_key, since holding
		 * rnh_lock here prevents another thread from calling
		 * rt_setgate() on this route.
		 */</span>
		RT_UNLOCK(rt);
		<span class="enscript-keyword">return</span> (rtrequest_locked(RTM_DELETE, rt_key(rt), NULL,
		    rt_mask(rt), rt-&gt;rt_flags, NULL));
	}
	RT_UNLOCK(rt);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * This routine is called from rt_setgate() to do the analogous thing for
 * adds and changes.  There is the added complication in this case of a
 * middle insert; i.e., insertion of a new network route between an older
 * network route and (cloned) host routes.  For this reason, a simple check
 * of rt-&gt;rt_parent is insufficient; each candidate route must be tested
 * against the (mask, value) of the new route (passed as before in vp)
 * to see if the new route matches it.
 *
 * XXX - it may be possible to do fixdelete() for changes and reserve this
 * routine just for adds.  I'm not sure why I thought it was necessary to do
 * changes this way.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rt_fixchange</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">void</span> *vp)
{
	<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)rn;
	<span class="enscript-type">struct</span> rtfc_arg *ap = vp;
	<span class="enscript-type">struct</span> rtentry *rt0 = ap-&gt;rt0;
	<span class="enscript-type">struct</span> radix_node_head *rnh = ap-&gt;rnh;
	u_char *xk1, *xm1, *xk2, *xmp;
	<span class="enscript-type">int</span> i, len;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	RT_LOCK(rt);

	<span class="enscript-keyword">if</span> (!rt-&gt;rt_parent ||
	    (rt-&gt;rt_flags &amp; (RTF_CLONING | RTF_PRCLONING))) {
		RT_UNLOCK(rt);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (rt-&gt;rt_parent == rt0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">delete_rt</span>;

	<span class="enscript-comment">/*
	 * There probably is a function somewhere which does this...
	 * if not, there should be.
	 */</span>
	len = imin(rt_key(rt0)-&gt;sa_len, rt_key(rt)-&gt;sa_len);

	xk1 = (u_char *)rt_key(rt0);
	xm1 = (u_char *)rt_mask(rt0);
	xk2 = (u_char *)rt_key(rt);

	<span class="enscript-comment">/*
	 * Avoid applying a less specific route; do this only if the parent
	 * route (rt-&gt;rt_parent) is a network route, since otherwise its mask
	 * will be NULL if it is a cloning host route.
	 */</span>
	<span class="enscript-keyword">if</span> ((xmp = (u_char *)rt_mask(rt-&gt;rt_parent)) != NULL) {
		<span class="enscript-type">int</span> mlen = rt_mask(rt-&gt;rt_parent)-&gt;sa_len;
		<span class="enscript-keyword">if</span> (mlen &gt; rt_mask(rt0)-&gt;sa_len) {
			RT_UNLOCK(rt);
			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-keyword">for</span> (i = rnh-&gt;rnh_treetop-&gt;rn_offset; i &lt; mlen; i++) {
			<span class="enscript-keyword">if</span> ((xmp[i] &amp; ~(xmp[i] ^ xm1[i])) != xmp[i]) {
				RT_UNLOCK(rt);
				<span class="enscript-keyword">return</span> (0);
			}
		}
	}

	<span class="enscript-keyword">for</span> (i = rnh-&gt;rnh_treetop-&gt;rn_offset; i &lt; len; i++) {
		<span class="enscript-keyword">if</span> ((xk2[i] &amp; xm1[i]) != xk1[i]) {
			RT_UNLOCK(rt);
			<span class="enscript-keyword">return</span> (0);
		}
	}

	<span class="enscript-comment">/*
	 * OK, this node is a clone, and matches the node currently being
	 * changed/added under the node's mask.  So, get rid of it.
	 */</span>
<span class="enscript-reference">delete_rt</span>:
	<span class="enscript-comment">/*
	 * Safe to drop rt_lock and use rt_key, since holding rnh_lock here
	 * prevents another thread from calling rt_setgate() on this route.
	 */</span>
	RT_UNLOCK(rt);
	<span class="enscript-keyword">return</span> (rtrequest_locked(RTM_DELETE, rt_key(rt), NULL,
	    rt_mask(rt), rt-&gt;rt_flags, NULL));
}

<span class="enscript-comment">/*
 * Round up sockaddr len to multiples of 32-bytes.  This will reduce
 * or even eliminate the need to re-allocate the chunk of memory used
 * for rt_key and rt_gateway in the event the gateway portion changes.
 * Certain code paths (e.g. IPSec) are notorious for caching the address
 * of rt_gateway; this rounding-up would help ensure that the gateway
 * portion never gets deallocated (though it may change contents) and
 * thus greatly simplifies things.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SA_SIZE</span>(x) (-(-((uintptr_t)(x)) &amp; -(32)))

<span class="enscript-comment">/*
 * Sets the gateway and/or gateway route portion of a route; may be
 * called on an existing route to modify the gateway portion.  Both
 * rt_key and rt_gateway are allocated out of the same memory chunk.
 * Route entry lock must be held by caller; this routine will return
 * with the lock held.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">rt_setgate</span>(<span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">struct</span> sockaddr *gate)
{
	<span class="enscript-type">int</span> dlen = SA_SIZE(dst-&gt;sa_len), glen = SA_SIZE(gate-&gt;sa_len);
	<span class="enscript-type">struct</span> radix_node_head *rnh = NULL;
	boolean_t loop = FALSE;

	<span class="enscript-keyword">if</span> (dst-&gt;sa_family != AF_INET &amp;&amp; dst-&gt;sa_family != AF_INET6) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	rnh = rt_tables[dst-&gt;sa_family];
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-comment">/*
	 * If this is for a route that is on its way of being removed,
	 * or is temporarily frozen, reject the modification request.
	 */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_CONDEMNED) {
		<span class="enscript-keyword">return</span> (EBUSY);
	}

	<span class="enscript-comment">/* Add an extra ref for ourselves */</span>
	RT_ADDREF_LOCKED(rt);

	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_GATEWAY) {
		<span class="enscript-keyword">if</span> ((dst-&gt;sa_len == gate-&gt;sa_len) &amp;&amp;
		    (dst-&gt;sa_family == AF_INET || dst-&gt;sa_family == AF_INET6)) {
			<span class="enscript-type">struct</span> sockaddr_storage dst_ss, gate_ss;

			(<span class="enscript-type">void</span>) sa_copy(dst, &amp;dst_ss, NULL);
			(<span class="enscript-type">void</span>) sa_copy(gate, &amp;gate_ss, NULL);

			loop = equal(SA(&amp;dst_ss), SA(&amp;gate_ss));
		} <span class="enscript-keyword">else</span> {
			loop = (dst-&gt;sa_len == gate-&gt;sa_len &amp;&amp;
			    equal(dst, gate));
		}
	}

	<span class="enscript-comment">/*
	 * A (cloning) network route with the destination equal to the gateway
	 * will create an endless loop (see notes below), so disallow it.
	 */</span>
	<span class="enscript-keyword">if</span> (((rt-&gt;rt_flags &amp; (RTF_HOST|RTF_GATEWAY|RTF_LLINFO)) ==
	    RTF_GATEWAY) &amp;&amp; loop) {
		<span class="enscript-comment">/* Release extra ref */</span>
		RT_REMREF_LOCKED(rt);
		<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);
	}

	<span class="enscript-comment">/*
	 * A host route with the destination equal to the gateway
	 * will interfere with keeping LLINFO in the routing
	 * table, so disallow it.
	 */</span>
	<span class="enscript-keyword">if</span> (((rt-&gt;rt_flags &amp; (RTF_HOST|RTF_GATEWAY|RTF_LLINFO)) ==
	    (RTF_HOST|RTF_GATEWAY)) &amp;&amp; loop) {
		<span class="enscript-comment">/*
		 * The route might already exist if this is an RTM_CHANGE
		 * or a routing redirect, so try to delete it.
		 */</span>
		<span class="enscript-keyword">if</span> (rt_key(rt) != NULL) {
			<span class="enscript-comment">/*
			 * Safe to drop rt_lock and use rt_key, rt_gateway,
			 * since holding rnh_lock here prevents another thread
			 * from calling rt_setgate() on this route.
			 */</span>
			RT_UNLOCK(rt);
			(<span class="enscript-type">void</span>) rtrequest_locked(RTM_DELETE, rt_key(rt),
			    rt-&gt;rt_gateway, rt_mask(rt), rt-&gt;rt_flags, NULL);
			RT_LOCK(rt);
		}
		<span class="enscript-comment">/* Release extra ref */</span>
		RT_REMREF_LOCKED(rt);
		<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);
	}

	<span class="enscript-comment">/*
	 * The destination is not directly reachable.  Get a route
	 * to the next-hop gateway and store it in rt_gwroute.
	 */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_GATEWAY) {
		<span class="enscript-type">struct</span> rtentry *gwrt;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope;

		<span class="enscript-keyword">if</span> (dst-&gt;sa_family == AF_INET)
			ifscope = sin_get_ifscope(dst);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dst-&gt;sa_family == AF_INET6)
			ifscope = sin6_get_ifscope(dst);
		<span class="enscript-keyword">else</span>
			ifscope = IFSCOPE_NONE;

		RT_UNLOCK(rt);
		<span class="enscript-comment">/*
		 * Don't ignore RTF_CLONING, since we prefer that rt_gwroute
		 * points to a clone rather than a cloning route; see above
		 * check for cloning loop avoidance (dst == gate).
		 */</span>
		gwrt = rtalloc1_scoped_locked(gate, 1, RTF_PRCLONING, ifscope);
		<span class="enscript-keyword">if</span> (gwrt != NULL)
			RT_LOCK_ASSERT_NOTHELD(gwrt);
		RT_LOCK(rt);

		<span class="enscript-comment">/*
		 * Cloning loop avoidance:
		 *
		 * In the presence of protocol-cloning and bad configuration,
		 * it is possible to get stuck in bottomless mutual recursion
		 * (rtrequest rt_setgate rtalloc1).  We avoid this by not
		 * allowing protocol-cloning to operate for gateways (which
		 * is probably the correct choice anyway), and avoid the
		 * resulting reference loops by disallowing any route to run
		 * through itself as a gateway.  This is obviously mandatory
		 * when we get rt-&gt;rt_output().  It implies that a route to
		 * the gateway must already be present in the system in order
		 * for the gateway to be referred to by another route.
		 */</span>
		<span class="enscript-keyword">if</span> (gwrt == rt) {
			RT_REMREF_LOCKED(gwrt);
			<span class="enscript-comment">/* Release extra ref */</span>
			RT_REMREF_LOCKED(rt);
			<span class="enscript-keyword">return</span> (EADDRINUSE); <span class="enscript-comment">/* failure */</span>
		}

		<span class="enscript-comment">/*
		 * If scoped, the gateway route must use the same interface;
		 * we're holding rnh_lock now, so rt_gateway and rt_ifp of gwrt
		 * should not change and are freely accessible.
		 */</span>
		<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE &amp;&amp; (rt-&gt;rt_flags &amp; RTF_IFSCOPE) &amp;&amp;
		    gwrt != NULL &amp;&amp; gwrt-&gt;rt_ifp != NULL &amp;&amp;
		    gwrt-&gt;rt_ifp-&gt;if_index != ifscope) {
			rtfree_locked(gwrt);	<span class="enscript-comment">/* rt != gwrt, no deadlock */</span>
			<span class="enscript-comment">/* Release extra ref */</span>
			RT_REMREF_LOCKED(rt);
			<span class="enscript-keyword">return</span> ((rt-&gt;rt_flags &amp; RTF_HOST) ?
			    EHOSTUNREACH : ENETUNREACH);
		}

		<span class="enscript-comment">/* Check again since we dropped the lock above */</span>
		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_CONDEMNED) {
			<span class="enscript-keyword">if</span> (gwrt != NULL)
				rtfree_locked(gwrt);
			<span class="enscript-comment">/* Release extra ref */</span>
			RT_REMREF_LOCKED(rt);
			<span class="enscript-keyword">return</span> (EBUSY);
		}

		<span class="enscript-comment">/* Set gateway route; callee adds ref to gwrt if non-NULL */</span>
		rt_set_gwroute(rt, dst, gwrt);

		<span class="enscript-comment">/*
		 * In case the (non-scoped) default route gets modified via
		 * an ICMP redirect, record the interface index used for the
		 * primary ifscope.  Also done in rt_setif() to take care
		 * of the non-redirect cases.
		 */</span>
		<span class="enscript-keyword">if</span> (rt_primary_default(rt, dst) &amp;&amp; rt-&gt;rt_ifp != NULL) {
			set_primary_ifscope(dst-&gt;sa_family,
			    rt-&gt;rt_ifp-&gt;if_index);
		}

		<span class="enscript-comment">/*
		 * Tell the kernel debugger about the new default gateway
		 * if the gateway route uses the primary interface, or
		 * if we are in a transient state before the non-scoped
		 * default gateway is installed (similar to how the system
		 * was behaving in the past).  In future, it would be good
		 * to do all this only when KDP is enabled.
		 */</span>
		<span class="enscript-keyword">if</span> ((dst-&gt;sa_family == AF_INET) &amp;&amp;
		    gwrt != NULL &amp;&amp; gwrt-&gt;rt_gateway-&gt;sa_family == AF_LINK &amp;&amp;
		    (gwrt-&gt;rt_ifp-&gt;if_index == get_primary_ifscope(AF_INET) ||
		    get_primary_ifscope(AF_INET) == IFSCOPE_NONE)) {
			kdp_set_gateway_mac(SDL((<span class="enscript-type">void</span> *)gwrt-&gt;rt_gateway)-&gt;
			    sdl_data);
		}

		<span class="enscript-comment">/* Release extra ref from rtalloc1() */</span>
		<span class="enscript-keyword">if</span> (gwrt != NULL)
			RT_REMREF(gwrt);
	}

	<span class="enscript-comment">/*
	 * Prepare to store the gateway in rt_gateway.  Both dst and gateway
	 * are stored one after the other in the same malloc'd chunk.  If we
	 * have room, reuse the old buffer since rt_gateway already points
	 * to the right place.  Otherwise, malloc a new block and update
	 * the 'dst' address and point rt_gateway to the right place.
	 */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_gateway == NULL || glen &gt; SA_SIZE(rt-&gt;rt_gateway-&gt;sa_len)) {
		caddr_t new;

		<span class="enscript-comment">/* The underlying allocation is done with M_WAITOK set */</span>
		R_Malloc(new, caddr_t, dlen + glen);
		<span class="enscript-keyword">if</span> (new == NULL) {
			<span class="enscript-comment">/* Clear gateway route */</span>
			rt_set_gwroute(rt, dst, NULL);
			<span class="enscript-comment">/* Release extra ref */</span>
			RT_REMREF_LOCKED(rt);
			<span class="enscript-keyword">return</span> (ENOBUFS);
		}

		<span class="enscript-comment">/*
		 * Copy from 'dst' and not rt_key(rt) because we can get
		 * here to initialize a newly allocated route entry, in
		 * which case rt_key(rt) is NULL (and so does rt_gateway).
		 */</span>
		bzero(new, dlen + glen);
		Bcopy(dst, new, dst-&gt;sa_len);
		R_Free(rt_key(rt));	<span class="enscript-comment">/* free old block; NULL is okay */</span>
		rt-&gt;rt_nodes-&gt;rn_key = new;
		rt-&gt;rt_gateway = (<span class="enscript-type">struct</span> sockaddr *)(new + dlen);
	}

	<span class="enscript-comment">/*
	 * Copy the new gateway value into the memory chunk.
	 */</span>
	Bcopy(gate, rt-&gt;rt_gateway, gate-&gt;sa_len);

	<span class="enscript-comment">/*
	 * For consistency between rt_gateway and rt_key(gwrt).
	 */</span>
	<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_GATEWAY) &amp;&amp; rt-&gt;rt_gwroute != NULL &amp;&amp;
	    (rt-&gt;rt_gwroute-&gt;rt_flags &amp; RTF_IFSCOPE)) {
		<span class="enscript-keyword">if</span> (rt-&gt;rt_gateway-&gt;sa_family == AF_INET &amp;&amp;
		    rt_key(rt-&gt;rt_gwroute)-&gt;sa_family == AF_INET) {
			sin_set_ifscope(rt-&gt;rt_gateway,
			    sin_get_ifscope(rt_key(rt-&gt;rt_gwroute)));
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rt-&gt;rt_gateway-&gt;sa_family == AF_INET6 &amp;&amp;
		    rt_key(rt-&gt;rt_gwroute)-&gt;sa_family == AF_INET6) {
			sin6_set_ifscope(rt-&gt;rt_gateway,
			    sin6_get_ifscope(rt_key(rt-&gt;rt_gwroute)));
		}
	}

	<span class="enscript-comment">/*
	 * This isn't going to do anything useful for host routes, so
	 * don't bother.  Also make sure we have a reasonable mask
	 * (we don't yet have one during adds).
	 */</span>
	<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_HOST) &amp;&amp; rt_mask(rt) != 0) {
		<span class="enscript-type">struct</span> rtfc_arg arg;
		arg.rnh = rnh;
		arg.rt0 = rt;
		RT_UNLOCK(rt);
		rnh-&gt;rnh_walktree_from(rnh, rt_key(rt), rt_mask(rt),
		    rt_fixchange, &amp;arg);
		RT_LOCK(rt);
	}

	<span class="enscript-comment">/* Release extra ref */</span>
	RT_REMREF_LOCKED(rt);
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">SA_SIZE</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">rt_set_gwroute</span>(<span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">struct</span> rtentry *gwrt)
{
	boolean_t gwrt_isrouter;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-keyword">if</span> (gwrt != NULL)
		RT_ADDREF(gwrt);	<span class="enscript-comment">/* for this routine */</span>

	<span class="enscript-comment">/*
	 * Get rid of existing gateway route; if rt_gwroute is already
	 * set to gwrt, this is slightly redundant (though safe since
	 * we held an extra ref above) but makes the code simpler.
	 */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_gwroute != NULL) {
		<span class="enscript-type">struct</span> rtentry *ogwrt = rt-&gt;rt_gwroute;

		VERIFY(rt != ogwrt);	<span class="enscript-comment">/* sanity check */</span>
		rt-&gt;rt_gwroute = NULL;
		RT_UNLOCK(rt);
		rtfree_locked(ogwrt);
		RT_LOCK(rt);
		VERIFY(rt-&gt;rt_gwroute == NULL);
	}

	<span class="enscript-comment">/*
	 * And associate the new gateway route.
	 */</span>
	<span class="enscript-keyword">if</span> ((rt-&gt;rt_gwroute = gwrt) != NULL) {
		RT_ADDREF(gwrt);	<span class="enscript-comment">/* for rt */</span>

		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_WASCLONED) {
			<span class="enscript-comment">/* rt_parent might be NULL if rt is embryonic */</span>
			gwrt_isrouter = (rt-&gt;rt_parent != NULL &amp;&amp;
			    SA_DEFAULT(rt_key(rt-&gt;rt_parent)) &amp;&amp;
			    !RT_HOST(rt-&gt;rt_parent));
		} <span class="enscript-keyword">else</span> {
			gwrt_isrouter = (SA_DEFAULT(dst) &amp;&amp; !RT_HOST(rt));
		}

		<span class="enscript-comment">/* If gwrt points to a default router, mark it accordingly */</span>
		<span class="enscript-keyword">if</span> (gwrt_isrouter &amp;&amp; RT_HOST(gwrt) &amp;&amp;
		    !(gwrt-&gt;rt_flags &amp; RTF_ROUTER)) {
			RT_LOCK(gwrt);
			gwrt-&gt;rt_flags |= RTF_ROUTER;
			RT_UNLOCK(gwrt);
		}

		RT_REMREF(gwrt);	<span class="enscript-comment">/* for this routine */</span>
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rt_maskedcopy</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *src, <span class="enscript-type">struct</span> sockaddr *dst,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *netmask)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *netmaskp = &amp;netmask-&gt;sa_data[0];
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *srcp = &amp;src-&gt;sa_data[0];
	<span class="enscript-type">char</span> *dstp = &amp;dst-&gt;sa_data[0];
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *maskend = (<span class="enscript-type">char</span> *)dst
				    + MIN(netmask-&gt;sa_len, src-&gt;sa_len);
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *srcend = (<span class="enscript-type">char</span> *)dst + src-&gt;sa_len;

	dst-&gt;sa_len = src-&gt;sa_len;
	dst-&gt;sa_family = src-&gt;sa_family;

	<span class="enscript-keyword">while</span> (dstp &lt; maskend)
		*dstp++ = *srcp++ &amp; *netmaskp++;
	<span class="enscript-keyword">if</span> (dstp &lt; srcend)
		memset(dstp, 0, (size_t)(srcend - dstp));
}

<span class="enscript-comment">/*
 * Lookup an AF_INET/AF_INET6 scoped or non-scoped route depending on the
 * ifscope value passed in by the caller (IFSCOPE_NONE implies non-scoped).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> radix_node *
<span class="enscript-function-name">node_lookup</span>(<span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">struct</span> sockaddr *netmask,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	<span class="enscript-type">struct</span> radix_node *rn;
	<span class="enscript-type">struct</span> sockaddr_storage ss, mask;
	<span class="enscript-type">int</span> af = dst-&gt;sa_family;
	<span class="enscript-type">struct</span> matchleaf_arg ma = { ifscope };
	rn_matchf_t *f = rn_match_ifscope;
	<span class="enscript-type">void</span> *w = &amp;ma;

	<span class="enscript-keyword">if</span> (af != AF_INET &amp;&amp; af != AF_INET6)
		<span class="enscript-keyword">return</span> (NULL);

	rnh = rt_tables[af];

	<span class="enscript-comment">/*
	 * Transform dst into the internal routing table form,
	 * clearing out the scope ID field if ifscope isn't set.
	 */</span>
	dst = sa_copy(dst, &amp;ss, (ifscope == IFSCOPE_NONE) ? NULL : &amp;ifscope);

	<span class="enscript-comment">/* Transform netmask into the internal routing table form */</span>
	<span class="enscript-keyword">if</span> (netmask != NULL)
		netmask = ma_copy(af, netmask, &amp;mask, ifscope);

	<span class="enscript-keyword">if</span> (ifscope == IFSCOPE_NONE)
		f = w = NULL;

	rn = rnh-&gt;rnh_lookup_args(dst, netmask, rnh, f, w);
	<span class="enscript-keyword">if</span> (rn != NULL &amp;&amp; (rn-&gt;rn_flags &amp; RNF_ROOT))
		rn = NULL;

	<span class="enscript-keyword">return</span> (rn);
}

<span class="enscript-comment">/*
 * Lookup the AF_INET/AF_INET6 non-scoped default route.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> radix_node *
<span class="enscript-function-name">node_lookup_default</span>(<span class="enscript-type">int</span> af)
{
	<span class="enscript-type">struct</span> radix_node_head *rnh;

	VERIFY(af == AF_INET || af == AF_INET6);
	rnh = rt_tables[af];

	<span class="enscript-keyword">return</span> (af == AF_INET ? rnh-&gt;rnh_lookup(&amp;sin_def, NULL, rnh) :
	    rnh-&gt;rnh_lookup(&amp;sin6_def, NULL, rnh));
}

boolean_t
<span class="enscript-function-name">rt_ifa_is_dst</span>(<span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">struct</span> ifaddr *ifa)
{
	boolean_t result = FALSE;

	<span class="enscript-keyword">if</span> (ifa == NULL || ifa-&gt;ifa_addr == NULL)
		<span class="enscript-keyword">return</span> (result);

	IFA_LOCK_SPIN(ifa);

	<span class="enscript-keyword">if</span> (dst-&gt;sa_family == ifa-&gt;ifa_addr-&gt;sa_family &amp;&amp;
	    ((dst-&gt;sa_family == AF_INET &amp;&amp;
	    SIN(dst)-&gt;sin_addr.s_addr ==
	    SIN(ifa-&gt;ifa_addr)-&gt;sin_addr.s_addr) ||
	    (dst-&gt;sa_family == AF_INET6 &amp;&amp;
	    SA6_ARE_ADDR_EQUAL(SIN6(dst), SIN6(ifa-&gt;ifa_addr)))))
		result = TRUE;

	IFA_UNLOCK(ifa);

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/*
 * Common routine to lookup/match a route.  It invokes the lookup/matchaddr
 * callback which could be address family-specific.  The main difference
 * between the two (at least for AF_INET/AF_INET6) is that a lookup does
 * not alter the expiring state of a route, whereas a match would unexpire
 * or revalidate the route.
 *
 * The optional scope or interface index property of a route allows for a
 * per-interface route instance.  This permits multiple route entries having
 * the same destination (but not necessarily the same gateway) to exist in
 * the routing table; each of these entries is specific to the corresponding
 * interface.  This is made possible by storing the scope ID value into the
 * radix key, thus making each route entry unique.  These scoped entries
 * exist along with the regular, non-scoped entries in the same radix tree
 * for a given address family (AF_INET/AF_INET6); the scope logically
 * partitions it into multiple per-interface sub-trees.
 *
 * When a scoped route lookup is performed, the routing table is searched for
 * the best match that would result in a route using the same interface as the
 * one associated with the scope (the exception to this are routes that point
 * to the loopback interface).  The search rule follows the longest matching
 * prefix with the additional interface constraint.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">rt_lookup_common</span>(boolean_t lookup_only, boolean_t coarse, <span class="enscript-type">struct</span> sockaddr *dst,
    <span class="enscript-type">struct</span> sockaddr *netmask, <span class="enscript-type">struct</span> radix_node_head *rnh, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">struct</span> radix_node *rn0, *rn;
	boolean_t dontcare;
	<span class="enscript-type">int</span> af = dst-&gt;sa_family;
	<span class="enscript-type">struct</span> sockaddr_storage dst_ss, mask_ss;
	<span class="enscript-type">char</span> s_dst[MAX_IPv6_STR_LEN], s_netmask[MAX_IPv6_STR_LEN];
	<span class="enscript-type">char</span> dbuf[MAX_SCOPE_ADDR_STR_LEN], gbuf[MAX_IPv6_STR_LEN];

	VERIFY(!coarse || ifscope == IFSCOPE_NONE);

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-comment">/*
	 * While we have rnh_lock held, see if we need to schedule the timer.
	 */</span>
	<span class="enscript-keyword">if</span> (nd6_sched_timeout_want)
		nd6_sched_timeout(NULL, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	<span class="enscript-keyword">if</span> (!lookup_only)
		netmask = NULL;

	<span class="enscript-comment">/*
	 * Non-scoped route lookup.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> ((af != AF_INET &amp;&amp; af != AF_INET6) ||
	    (af == AF_INET &amp;&amp; !ip_doscopedroute) ||
	    (af == AF_INET6 &amp;&amp; !ip6_doscopedroute)) {
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (af != AF_INET || !ip_doscopedroute) {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
		rn = rnh-&gt;rnh_matchaddr(dst, rnh);

		<span class="enscript-comment">/*
		 * Don't return a root node; also, rnh_matchaddr callback
		 * would have done the necessary work to clear RTPRF_OURS
		 * for certain protocol families.
		 */</span>
		<span class="enscript-keyword">if</span> (rn != NULL &amp;&amp; (rn-&gt;rn_flags &amp; RNF_ROOT))
			rn = NULL;
		<span class="enscript-keyword">if</span> (rn != NULL) {
			RT_LOCK_SPIN(RT(rn));
			<span class="enscript-keyword">if</span> (!(RT(rn)-&gt;rt_flags &amp; RTF_CONDEMNED)) {
				RT_ADDREF_LOCKED(RT(rn));
				RT_UNLOCK(RT(rn));
			} <span class="enscript-keyword">else</span> {
				RT_UNLOCK(RT(rn));
				rn = NULL;
			}
		}
		<span class="enscript-keyword">return</span> (RT(rn));
	}

	<span class="enscript-comment">/* Transform dst/netmask into the internal routing table form */</span>
	dst = sa_copy(dst, &amp;dst_ss, &amp;ifscope);
	<span class="enscript-keyword">if</span> (netmask != NULL)
		netmask = ma_copy(af, netmask, &amp;mask_ss, ifscope);
	dontcare = (ifscope == IFSCOPE_NONE);

	<span class="enscript-keyword">if</span> (rt_verbose) {
		<span class="enscript-keyword">if</span> (af == AF_INET)
			(<span class="enscript-type">void</span>) inet_ntop(af, &amp;SIN(dst)-&gt;sin_addr.s_addr,
			    s_dst, <span class="enscript-keyword">sizeof</span> (s_dst));
		<span class="enscript-keyword">else</span>
			(<span class="enscript-type">void</span>) inet_ntop(af, &amp;SIN6(dst)-&gt;sin6_addr,
			    s_dst, <span class="enscript-keyword">sizeof</span> (s_dst));

		<span class="enscript-keyword">if</span> (netmask != NULL &amp;&amp; af == AF_INET)
			(<span class="enscript-type">void</span>) inet_ntop(af, &amp;SIN(netmask)-&gt;sin_addr.s_addr,
			    s_netmask, <span class="enscript-keyword">sizeof</span> (s_netmask));
		<span class="enscript-keyword">if</span> (netmask != NULL &amp;&amp; af == AF_INET6)
			(<span class="enscript-type">void</span>) inet_ntop(af, &amp;SIN6(netmask)-&gt;sin6_addr,
			    s_netmask, <span class="enscript-keyword">sizeof</span> (s_netmask));
		<span class="enscript-keyword">else</span>
			*s_netmask = <span class="enscript-string">'\0'</span>;
		printf(<span class="enscript-string">&quot;%s (%d, %d, %s, %s, %u)\n&quot;</span>,
		    __func__, lookup_only, coarse, s_dst, s_netmask, ifscope);
	}

	<span class="enscript-comment">/*
	 * Scoped route lookup:
	 *
	 * We first perform a non-scoped lookup for the original result.
	 * Afterwards, depending on whether or not the caller has specified
	 * a scope, we perform a more specific scoped search and fallback
	 * to this original result upon failure.
	 */</span>
	rn0 = rn = node_lookup(dst, netmask, IFSCOPE_NONE);

	<span class="enscript-comment">/*
	 * If the caller did not specify a scope, use the primary scope
	 * derived from the system's non-scoped default route.  If, for
	 * any reason, there is no primary interface, ifscope will be
	 * set to IFSCOPE_NONE; if the above lookup resulted in a route,
	 * we'll do a more-specific search below, scoped to the interface
	 * of that route.
	 */</span>
	<span class="enscript-keyword">if</span> (dontcare)
		ifscope = get_primary_ifscope(af);

	<span class="enscript-comment">/*
	 * Keep the original result if either of the following is true:
	 *
	 *   1) The interface portion of the route has the same interface
	 *	index as the scope value and it is marked with RTF_IFSCOPE.
	 *   2) The route uses the loopback interface, in which case the
	 *	destination (host/net) is local/loopback.
	 *
	 * Otherwise, do a more specified search using the scope;
	 * we're holding rnh_lock now, so rt_ifp should not change.
	 */</span>
	<span class="enscript-keyword">if</span> (rn != NULL) {
		<span class="enscript-type">struct</span> rtentry *rt = RT(rn);

		<span class="enscript-keyword">if</span> (rt_verbose) {
			rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf), gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));
			printf(<span class="enscript-string">&quot;%s unscoped search %p to %s-&gt;%s-&gt;%s ifa_ifp %s\n&quot;</span>,
			    __func__, rt,
			    dbuf, gbuf,
			    (rt-&gt;rt_ifp != NULL) ? rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>,
			    (rt-&gt;rt_ifa-&gt;ifa_ifp != NULL) ?
			    rt-&gt;rt_ifa-&gt;ifa_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>);
		}
		<span class="enscript-keyword">if</span> (!(rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_LOOPBACK)) {
			<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp-&gt;if_index != ifscope) {
				<span class="enscript-comment">/*
				 * Wrong interface; keep the original result
				 * only if the caller did not specify a scope,
				 * and do a more specific scoped search using
				 * the scope of the found route.  Otherwise,
				 * start again from scratch.
				 *
				 * For loopback scope we keep the unscoped
				 * route for local addresses
				 */</span>
				rn = NULL;
				<span class="enscript-keyword">if</span> (dontcare)
					ifscope = rt-&gt;rt_ifp-&gt;if_index;
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifscope != lo_ifp-&gt;if_index ||
				    rt_ifa_is_dst(dst, rt-&gt;rt_ifa) == FALSE)
					rn0 = NULL;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_IFSCOPE)) {
				<span class="enscript-comment">/*
				 * Right interface, except that this route
				 * isn't marked with RTF_IFSCOPE.  Do a more
				 * specific scoped search.  Keep the original
				 * result and return it it in case the scoped
				 * search fails.
				 */</span>
				rn = NULL;
			}
		}
	}

	<span class="enscript-comment">/*
	 * Scoped search.  Find the most specific entry having the same
	 * interface scope as the one requested.  The following will result
	 * in searching for the longest prefix scoped match.
	 */</span>
	<span class="enscript-keyword">if</span> (rn == NULL) {
		rn = node_lookup(dst, netmask, ifscope);

		<span class="enscript-keyword">if</span> (rt_verbose &amp;&amp; rn != NULL) {
			<span class="enscript-type">struct</span> rtentry *rt = RT(rn);

			rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf), gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));
			printf(<span class="enscript-string">&quot;%s scoped search %p to %s-&gt;%s-&gt;%s ifa %s\n&quot;</span>,
			    __func__, rt,
			    dbuf, gbuf,
			    (rt-&gt;rt_ifp != NULL) ? rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>,
			    (rt-&gt;rt_ifa-&gt;ifa_ifp != NULL) ?
			    rt-&gt;rt_ifa-&gt;ifa_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>);
		}
	}
	<span class="enscript-comment">/*
	 * Use the original result if either of the following is true:
	 *
	 *   1) The scoped search did not yield any result.
	 *   2) The caller insists on performing a coarse-grained lookup.
	 *   3) The result from the scoped search is a scoped default route,
	 *	and the original (non-scoped) result is not a default route,
	 *	i.e. the original result is a more specific host/net route.
	 *   4)	The scoped search yielded a net route but the original
	 *	result is a host route, i.e. the original result is treated
	 *	as a more specific route.
	 */</span>
	<span class="enscript-keyword">if</span> (rn == NULL || coarse || (rn0 != NULL &amp;&amp;
	    ((SA_DEFAULT(rt_key(RT(rn))) &amp;&amp; !SA_DEFAULT(rt_key(RT(rn0)))) ||
	    (!RT_HOST(rn) &amp;&amp; RT_HOST(rn0)))))
		rn = rn0;

	<span class="enscript-comment">/*
	 * If we still don't have a route, use the non-scoped default
	 * route as long as the interface portion satistifes the scope.
	 */</span>
	<span class="enscript-keyword">if</span> (rn == NULL &amp;&amp; (rn = node_lookup_default(af)) != NULL &amp;&amp;
	    RT(rn)-&gt;rt_ifp-&gt;if_index != ifscope) {
		rn = NULL;
	}

	<span class="enscript-keyword">if</span> (rn != NULL) {
		<span class="enscript-comment">/*
		 * Manually clear RTPRF_OURS using rt_validate() and
		 * bump up the reference count after, and not before;
		 * we only get here for AF_INET/AF_INET6.  node_lookup()
		 * has done the check against RNF_ROOT, so we can be sure
		 * that we're not returning a root node here.
		 */</span>
		RT_LOCK_SPIN(RT(rn));
		<span class="enscript-keyword">if</span> (rt_validate(RT(rn))) {
			RT_ADDREF_LOCKED(RT(rn));
			RT_UNLOCK(RT(rn));
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(RT(rn));
			rn = NULL;
		}
	}

	<span class="enscript-keyword">if</span> (rt_verbose) {
		<span class="enscript-keyword">if</span> (rn == NULL)
			printf(<span class="enscript-string">&quot;%s %u return NULL\n&quot;</span>, __func__, ifscope);
		<span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> rtentry *rt = RT(rn);

			rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf), gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));

			printf(<span class="enscript-string">&quot;%s %u return %p to %s-&gt;%s-&gt;%s ifa_ifp %s\n&quot;</span>,
			    __func__, ifscope, rt,
			    dbuf, gbuf,
			    (rt-&gt;rt_ifp != NULL) ? rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>,
			    (rt-&gt;rt_ifa-&gt;ifa_ifp != NULL) ?
			    rt-&gt;rt_ifa-&gt;ifa_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>);
		}
	}

	<span class="enscript-keyword">return</span> (RT(rn));
}

<span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">rt_lookup</span>(boolean_t lookup_only, <span class="enscript-type">struct</span> sockaddr *dst, <span class="enscript-type">struct</span> sockaddr *netmask,
    <span class="enscript-type">struct</span> radix_node_head *rnh, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-keyword">return</span> (rt_lookup_common(lookup_only, FALSE, dst, netmask,
	    rnh, ifscope));
}

<span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">rt_lookup_coarse</span>(boolean_t lookup_only, <span class="enscript-type">struct</span> sockaddr *dst,
    <span class="enscript-type">struct</span> sockaddr *netmask, <span class="enscript-type">struct</span> radix_node_head *rnh)
{
	<span class="enscript-keyword">return</span> (rt_lookup_common(lookup_only, TRUE, dst, netmask,
	    rnh, IFSCOPE_NONE));
}

boolean_t
<span class="enscript-function-name">rt_validate</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; (RTF_UP | RTF_CONDEMNED)) == RTF_UP) {
		<span class="enscript-type">int</span> af = rt_key(rt)-&gt;sa_family;

		<span class="enscript-keyword">if</span> (af == AF_INET)
			(<span class="enscript-type">void</span>) in_validate(RN(rt));
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (af == AF_INET6)
			(<span class="enscript-type">void</span>) in6_validate(RN(rt));
	} <span class="enscript-keyword">else</span> {
		rt = NULL;
	}

	<span class="enscript-keyword">return</span> (rt != NULL);
}

<span class="enscript-comment">/*
 * Set up a routing table entry, normally
 * for an interface.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">rtinit</span>(<span class="enscript-type">struct</span> ifaddr *ifa, <span class="enscript-type">int</span> cmd, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">int</span> error;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);

	lck_mtx_lock(rnh_lock);
	error = rtinit_locked(ifa, cmd, flags);
	lck_mtx_unlock(rnh_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">rtinit_locked</span>(<span class="enscript-type">struct</span> ifaddr *ifa, <span class="enscript-type">int</span> cmd, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	uint8_t nbuf[128];	<span class="enscript-comment">/* long enough for IPv6 */</span>
	<span class="enscript-type">char</span> dbuf[MAX_IPv6_STR_LEN], gbuf[MAX_IPv6_STR_LEN];
	<span class="enscript-type">char</span> abuf[MAX_IPv6_STR_LEN];
	<span class="enscript-type">struct</span> rtentry *rt = NULL;
	<span class="enscript-type">struct</span> sockaddr *dst;
	<span class="enscript-type">struct</span> sockaddr *netmask;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/*
	 * Holding rnh_lock here prevents the possibility of ifa from
	 * changing (e.g. in_ifinit), so it is safe to access its
	 * ifa_{dst}addr (here and down below) without locking.
	 */</span>
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (flags &amp; RTF_HOST) {
		dst = ifa-&gt;ifa_dstaddr;
		netmask = NULL;
	} <span class="enscript-keyword">else</span> {
		dst = ifa-&gt;ifa_addr;
		netmask = ifa-&gt;ifa_netmask;
	}

	<span class="enscript-keyword">if</span> (dst-&gt;sa_len == 0) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s: %s failed, invalid dst sa_len %d\n&quot;</span>,
		    __func__, rtm2str(cmd), dst-&gt;sa_len);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (netmask != NULL &amp;&amp; netmask-&gt;sa_len &gt; <span class="enscript-keyword">sizeof</span> (nbuf)) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s: %s failed, mask sa_len %d too large\n&quot;</span>,
		    __func__, rtm2str(cmd), dst-&gt;sa_len);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (dst-&gt;sa_family == AF_INET) {
		(<span class="enscript-type">void</span>) inet_ntop(AF_INET, &amp;SIN(dst)-&gt;sin_addr.s_addr,
		    abuf, <span class="enscript-keyword">sizeof</span> (abuf));
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dst-&gt;sa_family == AF_INET6) {
		(<span class="enscript-type">void</span>) inet_ntop(AF_INET6, &amp;SIN6(dst)-&gt;sin6_addr,
		    abuf, <span class="enscript-keyword">sizeof</span> (abuf));
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	<span class="enscript-keyword">if</span> ((rnh = rt_tables[dst-&gt;sa_family]) == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * If it's a delete, check that if it exists, it's on the correct
	 * interface or we might scrub a route to another ifa which would
	 * be confusing at best and possibly worse.
	 */</span>
	<span class="enscript-keyword">if</span> (cmd == RTM_DELETE) {
		<span class="enscript-comment">/*
		 * It's a delete, so it should already exist..
		 * If it's a net, mask off the host bits
		 * (Assuming we have a mask)
		 */</span>
		<span class="enscript-keyword">if</span> (netmask != NULL) {
			rt_maskedcopy(dst, SA(nbuf), netmask);
			dst = SA(nbuf);
		}
		<span class="enscript-comment">/*
		 * Get an rtentry that is in the routing tree and contains
		 * the correct info.  Note that we perform a coarse-grained
		 * lookup here, in case there is a scoped variant of the
		 * subnet/prefix route which we should ignore, as we never
		 * add a scoped subnet/prefix route as part of adding an
		 * interface address.
		 */</span>
		rt = rt_lookup_coarse(TRUE, dst, NULL, rnh);
		<span class="enscript-keyword">if</span> (rt != NULL) {
			rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf), gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));
			<span class="enscript-comment">/*
			 * Ok so we found the rtentry. it has an extra reference
			 * for us at this stage. we won't need that so
			 * lop that off now.
			 */</span>
			RT_LOCK(rt);
			<span class="enscript-keyword">if</span> (rt-&gt;rt_ifa != ifa) {
				<span class="enscript-comment">/*
				 * If the interface address in the rtentry
				 * doesn't match the interface we are using,
				 * then we don't want to delete it, so return
				 * an error.  This seems to be the only point
				 * of this whole RTM_DELETE clause.
				 */</span>
				<span class="enscript-keyword">if</span> (rt_verbose) {
					log(LOG_DEBUG, <span class="enscript-string">&quot;%s: not removing &quot;</span>
					    <span class="enscript-string">&quot;route to %s-&gt;%s-&gt;%s, flags %b, &quot;</span>
					    <span class="enscript-string">&quot;ifaddr %s, rt_ifa 0x%llx != &quot;</span>
					    <span class="enscript-string">&quot;ifa 0x%llx\n&quot;</span>, __func__, dbuf,
					    gbuf, ((rt-&gt;rt_ifp != NULL) ?
					    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>),
					    rt-&gt;rt_flags, RTF_BITS, abuf,
					    (uint64_t)VM_KERNEL_ADDRPERM(
					    rt-&gt;rt_ifa),
					    (uint64_t)VM_KERNEL_ADDRPERM(ifa));
				}
				RT_REMREF_LOCKED(rt);
				RT_UNLOCK(rt);
				rt = NULL;
				error = ((flags &amp; RTF_HOST) ?
				    EHOSTUNREACH : ENETUNREACH);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_STATIC) {
				<span class="enscript-comment">/*
				 * Don't remove the subnet/prefix route if
				 * this was manually added from above.
				 */</span>
				<span class="enscript-keyword">if</span> (rt_verbose) {
					log(LOG_DEBUG, <span class="enscript-string">&quot;%s: not removing &quot;</span>
					    <span class="enscript-string">&quot;static route to %s-&gt;%s-&gt;%s, &quot;</span>
					    <span class="enscript-string">&quot;flags %b, ifaddr %s\n&quot;</span>, __func__,
					    dbuf, gbuf, ((rt-&gt;rt_ifp != NULL) ?
					    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>),
					    rt-&gt;rt_flags, RTF_BITS, abuf);
				}
				RT_REMREF_LOCKED(rt);
				RT_UNLOCK(rt);
				rt = NULL;
				error = EBUSY;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (rt_verbose) {
				log(LOG_DEBUG, <span class="enscript-string">&quot;%s: removing route to &quot;</span>
				    <span class="enscript-string">&quot;%s-&gt;%s-&gt;%s, flags %b, ifaddr %s\n&quot;</span>,
				    __func__, dbuf, gbuf,
				    ((rt-&gt;rt_ifp != NULL) ?
				    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>),
				    rt-&gt;rt_flags, RTF_BITS, abuf);
			}
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
			rt = NULL;
		}
	}
	<span class="enscript-comment">/*
	 * Do the actual request
	 */</span>
	<span class="enscript-keyword">if</span> ((error = rtrequest_locked(cmd, dst, ifa-&gt;ifa_addr, netmask,
	    flags | ifa-&gt;ifa_flags, &amp;rt)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	VERIFY(rt != NULL);

	rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf), gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_DELETE</span>:
		<span class="enscript-comment">/*
		 * If we are deleting, and we found an entry, then it's
		 * been removed from the tree.   Notify any listening
		 * routing agents of the change and throw it away.
		 */</span>
		RT_LOCK(rt);
		rt_newaddrmsg(cmd, ifa, error, rt);
		RT_UNLOCK(rt);
		<span class="enscript-keyword">if</span> (rt_verbose) {
			log(LOG_DEBUG, <span class="enscript-string">&quot;%s: removed route to %s-&gt;%s-&gt;%s, &quot;</span>
			    <span class="enscript-string">&quot;flags %b, ifaddr %s\n&quot;</span>, __func__, dbuf, gbuf,
			    ((rt-&gt;rt_ifp != NULL) ? rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>),
			    rt-&gt;rt_flags, RTF_BITS, abuf);
		}
		rtfree_locked(rt);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_ADD</span>:
		<span class="enscript-comment">/*
		 * We are adding, and we have a returned routing entry.
		 * We need to sanity check the result.  If it came back
		 * with an unexpected interface, then it must have already
		 * existed or something.
		 */</span>
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (rt-&gt;rt_ifa != ifa) {
			<span class="enscript-type">void</span> (*ifa_rtrequest)
			    (<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> sockaddr *);

			<span class="enscript-keyword">if</span> (!(rt-&gt;rt_ifa-&gt;ifa_ifp-&gt;if_flags &amp;
			    (IFF_POINTOPOINT|IFF_LOOPBACK))) {
				log(LOG_ERR, <span class="enscript-string">&quot;%s: %s route to %s-&gt;%s-&gt;%s, &quot;</span>
				    <span class="enscript-string">&quot;flags %b, ifaddr %s, rt_ifa 0x%llx != &quot;</span>
				    <span class="enscript-string">&quot;ifa 0x%llx\n&quot;</span>, __func__, rtm2str(cmd),
				    dbuf, gbuf, ((rt-&gt;rt_ifp != NULL) ?
				    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>), rt-&gt;rt_flags,
				    RTF_BITS, abuf,
				    (uint64_t)VM_KERNEL_ADDRPERM(rt-&gt;rt_ifa),
				    (uint64_t)VM_KERNEL_ADDRPERM(ifa));
			}

			<span class="enscript-keyword">if</span> (rt_verbose) {
				log(LOG_DEBUG, <span class="enscript-string">&quot;%s: %s route to %s-&gt;%s-&gt;%s, &quot;</span>
				    <span class="enscript-string">&quot;flags %b, ifaddr %s, rt_ifa was 0x%llx &quot;</span>
				    <span class="enscript-string">&quot;now 0x%llx\n&quot;</span>, __func__, rtm2str(cmd),
				    dbuf, gbuf, ((rt-&gt;rt_ifp != NULL) ?
				    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>), rt-&gt;rt_flags,
				    RTF_BITS, abuf,
				    (uint64_t)VM_KERNEL_ADDRPERM(rt-&gt;rt_ifa),
				    (uint64_t)VM_KERNEL_ADDRPERM(ifa));
			}

			<span class="enscript-comment">/*
			 * Ask that the protocol in question
			 * remove anything it has associated with
			 * this route and ifaddr.
			 */</span>
			ifa_rtrequest = rt-&gt;rt_ifa-&gt;ifa_rtrequest;
			<span class="enscript-keyword">if</span> (ifa_rtrequest != NULL)
				ifa_rtrequest(RTM_DELETE, rt, NULL);
			<span class="enscript-comment">/*
			 * Set the route's ifa.
			 */</span>
			rtsetifa(rt, ifa);

			<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp != ifa-&gt;ifa_ifp) {
				<span class="enscript-comment">/*
				 * Purge any link-layer info caching.
				 */</span>
				<span class="enscript-keyword">if</span> (rt-&gt;rt_llinfo_purge != NULL)
					rt-&gt;rt_llinfo_purge(rt);
				<span class="enscript-comment">/*
				 * Adjust route ref count for the interfaces.
				 */</span>
				<span class="enscript-keyword">if</span> (rt-&gt;rt_if_ref_fn != NULL) {
					rt-&gt;rt_if_ref_fn(ifa-&gt;ifa_ifp, 1);
					rt-&gt;rt_if_ref_fn(rt-&gt;rt_ifp, -1);
				}
			}

			<span class="enscript-comment">/*
			 * And substitute in references to the ifaddr
			 * we are adding.
			 */</span>
			rt-&gt;rt_ifp = ifa-&gt;ifa_ifp;
			<span class="enscript-comment">/*
			 * If rmx_mtu is not locked, update it
			 * to the MTU used by the new interface.
			 */</span>
			<span class="enscript-keyword">if</span> (!(rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU))
				rt-&gt;rt_rmx.rmx_mtu = rt-&gt;rt_ifp-&gt;if_mtu;

			<span class="enscript-comment">/*
			 * Now ask the protocol to check if it needs
			 * any special processing in its new form.
			 */</span>
			ifa_rtrequest = ifa-&gt;ifa_rtrequest;
			<span class="enscript-keyword">if</span> (ifa_rtrequest != NULL)
				ifa_rtrequest(RTM_ADD, rt, NULL);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (rt_verbose) {
				log(LOG_DEBUG, <span class="enscript-string">&quot;%s: added route to %s-&gt;%s-&gt;%s, &quot;</span>
				    <span class="enscript-string">&quot;flags %b, ifaddr %s\n&quot;</span>, __func__, dbuf,
				    gbuf, ((rt-&gt;rt_ifp != NULL) ?
				    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>), rt-&gt;rt_flags,
				    RTF_BITS, abuf);
			}
		}
		<span class="enscript-comment">/*
		 * notify any listenning routing agents of the change
		 */</span>
		rt_newaddrmsg(cmd, ifa, error, rt);
		<span class="enscript-comment">/*
		 * We just wanted to add it; we don't actually need a
		 * reference.  This will result in a route that's added
		 * to the routing table without a reference count.  The
		 * RTM_DELETE code will do the necessary step to adjust
		 * the reference count at deletion time.
		 */</span>
		RT_REMREF_LOCKED(rt);
		RT_UNLOCK(rt);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rt_set_idleref</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-comment">/*
	 * We currently keep idle refcnt only on unicast cloned routes
	 * that aren't marked with RTF_NOIFREF.
	 */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_parent != NULL &amp;&amp; !(rt-&gt;rt_flags &amp;
	    (RTF_NOIFREF|RTF_BROADCAST | RTF_MULTICAST)) &amp;&amp;
	    (rt-&gt;rt_flags &amp; (RTF_UP|RTF_WASCLONED|RTF_IFREF)) ==
	    (RTF_UP|RTF_WASCLONED)) {
		rt_clear_idleref(rt);	<span class="enscript-comment">/* drop existing refcnt if any  */</span>
		rt-&gt;rt_if_ref_fn = rte_if_ref;
		<span class="enscript-comment">/* Become a regular mutex, just in case */</span>
		RT_CONVERT_LOCK(rt);
		rt-&gt;rt_if_ref_fn(rt-&gt;rt_ifp, 1);
		rt-&gt;rt_flags |= RTF_IFREF;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rt_clear_idleref</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-keyword">if</span> (rt-&gt;rt_if_ref_fn != NULL) {
		VERIFY((rt-&gt;rt_flags &amp; (RTF_NOIFREF | RTF_IFREF)) == RTF_IFREF);
		<span class="enscript-comment">/* Become a regular mutex, just in case */</span>
		RT_CONVERT_LOCK(rt);
		rt-&gt;rt_if_ref_fn(rt-&gt;rt_ifp, -1);
		rt-&gt;rt_flags &amp;= ~RTF_IFREF;
		rt-&gt;rt_if_ref_fn = NULL;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rt_set_proxy</span>(<span class="enscript-type">struct</span> rtentry *rt, boolean_t set)
{
	lck_mtx_lock(rnh_lock);
	RT_LOCK(rt);
	<span class="enscript-comment">/*
	 * Search for any cloned routes which might have
	 * been formed from this node, and delete them.
	 */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; (RTF_CLONING | RTF_PRCLONING)) {
		<span class="enscript-type">struct</span> radix_node_head *rnh = rt_tables[rt_key(rt)-&gt;sa_family];

		<span class="enscript-keyword">if</span> (set)
			rt-&gt;rt_flags |= RTF_PROXY;
		<span class="enscript-keyword">else</span>
			rt-&gt;rt_flags &amp;= ~RTF_PROXY;

		RT_UNLOCK(rt);
		<span class="enscript-keyword">if</span> (rnh != NULL &amp;&amp; rt_mask(rt)) {
			rnh-&gt;rnh_walktree_from(rnh, rt_key(rt), rt_mask(rt),
			    rt_fixdelete, rt);
		}
	} <span class="enscript-keyword">else</span> {
		RT_UNLOCK(rt);
	}
	lck_mtx_unlock(rnh_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rte_lock_init</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	lck_mtx_init(&amp;rt-&gt;rt_lock, rte_mtx_grp, rte_mtx_attr);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rte_lock_destroy</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	RT_LOCK_ASSERT_NOTHELD(rt);
	lck_mtx_destroy(&amp;rt-&gt;rt_lock, rte_mtx_grp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rt_lock</span>(<span class="enscript-type">struct</span> rtentry *rt, boolean_t spin)
{
	RT_LOCK_ASSERT_NOTHELD(rt);
	<span class="enscript-keyword">if</span> (spin)
		lck_mtx_lock_spin(&amp;rt-&gt;rt_lock);
	<span class="enscript-keyword">else</span>
		lck_mtx_lock(&amp;rt-&gt;rt_lock);
	<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_DEBUG)
		rte_lock_debug((<span class="enscript-type">struct</span> rtentry_dbg *)rt);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rt_unlock</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_DEBUG)
		rte_unlock_debug((<span class="enscript-type">struct</span> rtentry_dbg *)rt);
	lck_mtx_unlock(&amp;rt-&gt;rt_lock);

}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">rte_lock_debug</span>(<span class="enscript-type">struct</span> rtentry_dbg *rte)
{
	uint32_t idx;

	RT_LOCK_ASSERT_HELD((<span class="enscript-type">struct</span> rtentry *)rte);
	idx = atomic_add_32_ov(&amp;rte-&gt;rtd_lock_cnt, 1) % CTRACE_HIST_SIZE;
	<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_TRACE)
		ctrace_record(&amp;rte-&gt;rtd_lock[idx]);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">rte_unlock_debug</span>(<span class="enscript-type">struct</span> rtentry_dbg *rte)
{
	uint32_t idx;

	RT_LOCK_ASSERT_HELD((<span class="enscript-type">struct</span> rtentry *)rte);
	idx = atomic_add_32_ov(&amp;rte-&gt;rtd_unlock_cnt, 1) % CTRACE_HIST_SIZE;
	<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_TRACE)
		ctrace_record(&amp;rte-&gt;rtd_unlock[idx]);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">rte_alloc</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_DEBUG)
		<span class="enscript-keyword">return</span> (rte_alloc_debug());

	<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> rtentry *)zalloc(rte_zone));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rte_free</span>(<span class="enscript-type">struct</span> rtentry *p)
{
	<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_DEBUG) {
		rte_free_debug(p);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (p-&gt;rt_refcnt != 0) {
		panic(<span class="enscript-string">&quot;rte_free: rte=%p refcnt=%d non-zero\n&quot;</span>, p, p-&gt;rt_refcnt);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	zfree(rte_zone, p);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rte_if_ref</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> cnt)
{
	<span class="enscript-type">struct</span> kev_msg ev_msg;
	<span class="enscript-type">struct</span> net_event_data ev_data;
	uint32_t old;

	<span class="enscript-comment">/* Force cnt to 1 increment/decrement */</span>
	<span class="enscript-keyword">if</span> (cnt &lt; -1 || cnt &gt; 1) {
		panic(<span class="enscript-string">&quot;%s: invalid count argument (%d)&quot;</span>, __func__, cnt);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	old = atomic_add_32_ov(&amp;ifp-&gt;if_route_refcnt, cnt);
	<span class="enscript-keyword">if</span> (cnt &lt; 0 &amp;&amp; old == 0) {
		panic(<span class="enscript-string">&quot;%s: ifp=%p negative route refcnt!&quot;</span>, __func__, ifp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-comment">/*
	 * The following is done without first holding the ifnet lock,
	 * for performance reasons.  The relevant ifnet fields, with
	 * the exception of the if_idle_flags, are never changed
	 * during the lifetime of the ifnet.  The if_idle_flags
	 * may possibly be modified, so in the event that the value
	 * is stale because IFRF_IDLE_NOTIFY was cleared, we'd end up
	 * sending the event anyway.  This is harmless as it is just
	 * a notification to the monitoring agent in user space, and
	 * it is expected to check via SIOCGIFGETRTREFCNT again anyway.
	 */</span>
	<span class="enscript-keyword">if</span> ((ifp-&gt;if_idle_flags &amp; IFRF_IDLE_NOTIFY) &amp;&amp; cnt &lt; 0 &amp;&amp; old == 1) {
		bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span> (ev_msg));
		bzero(&amp;ev_data, <span class="enscript-keyword">sizeof</span> (ev_data));

		ev_msg.vendor_code	= KEV_VENDOR_APPLE;
		ev_msg.kev_class	= KEV_NETWORK_CLASS;
		ev_msg.kev_subclass	= KEV_DL_SUBCLASS;
		ev_msg.event_code	= KEV_DL_IF_IDLE_ROUTE_REFCNT;

		strlcpy(&amp;ev_data.if_name[0], ifp-&gt;if_name, IFNAMSIZ);

		ev_data.if_family	= ifp-&gt;if_family;
		ev_data.if_unit		= ifp-&gt;if_unit;
		ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> net_event_data);
		ev_msg.dv[0].data_ptr	= &amp;ev_data;

		kev_post_msg(&amp;ev_msg);
	}
}

<span class="enscript-type">static</span> inline <span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">rte_alloc_debug</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> rtentry_dbg *rte;

	rte = ((<span class="enscript-type">struct</span> rtentry_dbg *)zalloc(rte_zone));
	<span class="enscript-keyword">if</span> (rte != NULL) {
		bzero(rte, <span class="enscript-keyword">sizeof</span> (*rte));
		<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_TRACE)
			ctrace_record(&amp;rte-&gt;rtd_alloc);
		rte-&gt;rtd_inuse = RTD_INUSE;
	}
	<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> rtentry *)rte);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">rte_free_debug</span>(<span class="enscript-type">struct</span> rtentry *p)
{
	<span class="enscript-type">struct</span> rtentry_dbg *rte = (<span class="enscript-type">struct</span> rtentry_dbg *)p;

	<span class="enscript-keyword">if</span> (p-&gt;rt_refcnt != 0) {
		panic(<span class="enscript-string">&quot;rte_free: rte=%p refcnt=%d\n&quot;</span>, p, p-&gt;rt_refcnt);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (rte-&gt;rtd_inuse == RTD_FREED) {
		panic(<span class="enscript-string">&quot;rte_free: double free rte=%p\n&quot;</span>, rte);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rte-&gt;rtd_inuse != RTD_INUSE) {
		panic(<span class="enscript-string">&quot;rte_free: corrupted rte=%p\n&quot;</span>, rte);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	bcopy((caddr_t)p, (caddr_t)&amp;rte-&gt;rtd_entry_saved, <span class="enscript-keyword">sizeof</span> (*p));
	<span class="enscript-comment">/* Preserve rt_lock to help catch use-after-free cases */</span>
	bzero((caddr_t)p, offsetof(<span class="enscript-type">struct</span> rtentry, rt_lock));

	rte-&gt;rtd_inuse = RTD_FREED;

	<span class="enscript-keyword">if</span> (rte_debug &amp; RTD_TRACE)
		ctrace_record(&amp;rte-&gt;rtd_free);

	<span class="enscript-keyword">if</span> (!(rte_debug &amp; RTD_NO_FREE))
		zfree(rte_zone, p);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ctrace_record</span>(ctrace_t *tr)
{
	tr-&gt;th = current_thread();
	bzero(tr-&gt;pc, <span class="enscript-keyword">sizeof</span> (tr-&gt;pc));
	(<span class="enscript-type">void</span>) OSBacktrace(tr-&gt;pc, CTRACE_STACK_SIZE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">route_copyout</span>(<span class="enscript-type">struct</span> route *dst, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> route *src, size_t length)
{
	<span class="enscript-comment">/* Copy everything (rt, srcif, flags, dst) from src */</span>
	bcopy(src, dst, length);

	<span class="enscript-comment">/* Hold one reference for the local copy of struct route */</span>
	<span class="enscript-keyword">if</span> (dst-&gt;ro_rt != NULL)
		RT_ADDREF(dst-&gt;ro_rt);

	<span class="enscript-comment">/* Hold one reference for the local copy of struct ifaddr */</span>
	<span class="enscript-keyword">if</span> (dst-&gt;ro_srcia != NULL)
		IFA_ADDREF(dst-&gt;ro_srcia);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">route_copyin</span>(<span class="enscript-type">struct</span> route *src, <span class="enscript-type">struct</span> route *dst, size_t length)
{
	<span class="enscript-comment">/* No cached route at the destination? */</span>
	<span class="enscript-keyword">if</span> (dst-&gt;ro_rt == NULL) {
		<span class="enscript-comment">/*
		 * Ditch the address in the cached copy (dst) since
		 * we're about to take everything there is in src.
		 */</span>
		<span class="enscript-keyword">if</span> (dst-&gt;ro_srcia != NULL)
			IFA_REMREF(dst-&gt;ro_srcia);
		<span class="enscript-comment">/*
		 * Copy everything (rt, srcia, flags, dst) from src; the
		 * references to rt and/or srcia were held at the time
		 * of storage and are kept intact.
		 */</span>
		bcopy(src, dst, length);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (src-&gt;ro_rt != NULL) {
		<span class="enscript-comment">/*
		 * If the same, update srcia and flags, and ditch the route
		 * in the local copy.  Else ditch the one that is currently
		 * cached, and cache the new route.
		 */</span>
		<span class="enscript-keyword">if</span> (dst-&gt;ro_rt == src-&gt;ro_rt) {
			dst-&gt;ro_flags = src-&gt;ro_flags;
			<span class="enscript-keyword">if</span> (dst-&gt;ro_srcia != src-&gt;ro_srcia) {
				<span class="enscript-keyword">if</span> (dst-&gt;ro_srcia != NULL)
					IFA_REMREF(dst-&gt;ro_srcia);
				dst-&gt;ro_srcia = src-&gt;ro_srcia;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (src-&gt;ro_srcia != NULL) {
				IFA_REMREF(src-&gt;ro_srcia);
			}
			rtfree(src-&gt;ro_rt);
		} <span class="enscript-keyword">else</span> {
			rtfree(dst-&gt;ro_rt);
			<span class="enscript-keyword">if</span> (dst-&gt;ro_srcia != NULL)
				IFA_REMREF(dst-&gt;ro_srcia);
			bcopy(src, dst, length);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (src-&gt;ro_srcia != NULL) {
		<span class="enscript-comment">/*
		 * Ditch src address in the local copy (src) since we're
		 * not caching the route entry anyway (ro_rt is NULL).
		 */</span>
		IFA_REMREF(src-&gt;ro_srcia);
	}

	<span class="enscript-comment">/* This function consumes the references on src */</span>
	src-&gt;ro_rt = NULL;
	src-&gt;ro_srcia = NULL;
}

<span class="enscript-comment">/*
 * route_to_gwroute will find the gateway route for a given route.
 *
 * If the route is down, look the route up again.
 * If the route goes through a gateway, get the route to the gateway.
 * If the gateway route is down, look it up again.
 * If the route is set to reject, verify it hasn't expired.
 *
 * If the returned route is non-NULL, the caller is responsible for
 * releasing the reference and unlocking the route.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">senderr</span>(e) { error = (e); goto bad; }
errno_t
<span class="enscript-function-name">route_to_gwroute</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *net_dest, <span class="enscript-type">struct</span> rtentry *hint0,
    <span class="enscript-type">struct</span> rtentry **out_route)
{
	uint64_t timenow;
	<span class="enscript-type">struct</span> rtentry *rt = hint0, *hint = hint0;
	errno_t error = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifindex;
	boolean_t gwroute;

	*out_route = NULL;

	<span class="enscript-keyword">if</span> (rt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/*
	 * Next hop determination.  Because we may involve the gateway route
	 * in addition to the original route, locking is rather complicated.
	 * The general concept is that regardless of whether the route points
	 * to the original route or to the gateway route, this routine takes
	 * an extra reference on such a route.  This extra reference will be
	 * released at the end.
	 *
	 * Care must be taken to ensure that the &quot;hint0&quot; route never gets freed
	 * via rtfree(), since the caller may have stored it inside a struct
	 * route with a reference held for that placeholder.
	 */</span>
	RT_LOCK_SPIN(rt);
	ifindex = rt-&gt;rt_ifp-&gt;if_index;
	RT_ADDREF_LOCKED(rt);
	<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_UP)) {
		RT_REMREF_LOCKED(rt);
		RT_UNLOCK(rt);
		<span class="enscript-comment">/* route is down, find a new one */</span>
		hint = rt = rtalloc1_scoped((<span class="enscript-type">struct</span> sockaddr *)
		    (size_t)net_dest, 1, 0, ifindex);
		<span class="enscript-keyword">if</span> (hint != NULL) {
			RT_LOCK_SPIN(rt);
			ifindex = rt-&gt;rt_ifp-&gt;if_index;
		} <span class="enscript-keyword">else</span> {
			senderr(EHOSTUNREACH);
		}
	}

	<span class="enscript-comment">/*
	 * We have a reference to &quot;rt&quot; by now; it will either
	 * be released or freed at the end of this routine.
	 */</span>
	RT_LOCK_ASSERT_HELD(rt);
	<span class="enscript-keyword">if</span> ((gwroute = (rt-&gt;rt_flags &amp; RTF_GATEWAY))) {
		<span class="enscript-type">struct</span> rtentry *gwrt = rt-&gt;rt_gwroute;
		<span class="enscript-type">struct</span> sockaddr_storage ss;
		<span class="enscript-type">struct</span> sockaddr *gw = (<span class="enscript-type">struct</span> sockaddr *)&amp;ss;

		VERIFY(rt == hint);
		RT_ADDREF_LOCKED(hint);

		<span class="enscript-comment">/* If there's no gateway rt, look it up */</span>
		<span class="enscript-keyword">if</span> (gwrt == NULL) {
			bcopy(rt-&gt;rt_gateway, gw, MIN(<span class="enscript-keyword">sizeof</span> (ss),
			    rt-&gt;rt_gateway-&gt;sa_len));
			RT_UNLOCK(rt);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">lookup</span>;
		}
		<span class="enscript-comment">/* Become a regular mutex */</span>
		RT_CONVERT_LOCK(rt);

		<span class="enscript-comment">/*
		 * Take gwrt's lock while holding route's lock;
		 * this is okay since gwrt never points back
		 * to &quot;rt&quot;, so no lock ordering issues.
		 */</span>
		RT_LOCK_SPIN(gwrt);
		<span class="enscript-keyword">if</span> (!(gwrt-&gt;rt_flags &amp; RTF_UP)) {
			rt-&gt;rt_gwroute = NULL;
			RT_UNLOCK(gwrt);
			bcopy(rt-&gt;rt_gateway, gw, MIN(<span class="enscript-keyword">sizeof</span> (ss),
			    rt-&gt;rt_gateway-&gt;sa_len));
			RT_UNLOCK(rt);
			rtfree(gwrt);
<span class="enscript-reference">lookup</span>:
			lck_mtx_lock(rnh_lock);
			gwrt = rtalloc1_scoped_locked(gw, 1, 0, ifindex);

			RT_LOCK(rt);
			<span class="enscript-comment">/*
			 * Bail out if the route is down, no route
			 * to gateway, circular route, or if the
			 * gateway portion of &quot;rt&quot; has changed.
			 */</span>
			<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_UP) || gwrt == NULL ||
			    gwrt == rt || !equal(gw, rt-&gt;rt_gateway)) {
				<span class="enscript-keyword">if</span> (gwrt == rt) {
					RT_REMREF_LOCKED(gwrt);
					gwrt = NULL;
				}
				VERIFY(rt == hint);
				RT_REMREF_LOCKED(hint);
				hint = NULL;
				RT_UNLOCK(rt);
				<span class="enscript-keyword">if</span> (gwrt != NULL)
					rtfree_locked(gwrt);
				lck_mtx_unlock(rnh_lock);
				senderr(EHOSTUNREACH);
			}
			VERIFY(gwrt != NULL);
			<span class="enscript-comment">/*
			 * Set gateway route; callee adds ref to gwrt;
			 * gwrt has an extra ref from rtalloc1() for
			 * this routine.
			 */</span>
			rt_set_gwroute(rt, rt_key(rt), gwrt);
			VERIFY(rt == hint);
			RT_REMREF_LOCKED(rt);	<span class="enscript-comment">/* hint still holds a refcnt */</span>
			RT_UNLOCK(rt);
			lck_mtx_unlock(rnh_lock);
			rt = gwrt;
		} <span class="enscript-keyword">else</span> {
			RT_ADDREF_LOCKED(gwrt);
			RT_UNLOCK(gwrt);
			VERIFY(rt == hint);
			RT_REMREF_LOCKED(rt);	<span class="enscript-comment">/* hint still holds a refcnt */</span>
			RT_UNLOCK(rt);
			rt = gwrt;
		}
		VERIFY(rt == gwrt &amp;&amp; rt != hint);

		<span class="enscript-comment">/*
		 * This is an opportunity to revalidate the parent route's
		 * rt_gwroute, in case it now points to a dead route entry.
		 * Parent route won't go away since the clone (hint) holds
		 * a reference to it.  rt == gwrt.
		 */</span>
		RT_LOCK_SPIN(hint);
		<span class="enscript-keyword">if</span> ((hint-&gt;rt_flags &amp; (RTF_WASCLONED | RTF_UP)) ==
		    (RTF_WASCLONED | RTF_UP)) {
			<span class="enscript-type">struct</span> rtentry *prt = hint-&gt;rt_parent;
			VERIFY(prt != NULL);

			RT_CONVERT_LOCK(hint);
			RT_ADDREF(prt);
			RT_UNLOCK(hint);
			rt_revalidate_gwroute(prt, rt);
			RT_REMREF(prt);
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(hint);
		}

		<span class="enscript-comment">/* Clean up &quot;hint&quot; now; see notes above regarding hint0 */</span>
		<span class="enscript-keyword">if</span> (hint == hint0)
			RT_REMREF(hint);
		<span class="enscript-keyword">else</span>
			rtfree(hint);
		hint = NULL;

		<span class="enscript-comment">/* rt == gwrt; if it is now down, give up */</span>
		RT_LOCK_SPIN(rt);
		<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_UP)) {
			RT_UNLOCK(rt);
			senderr(EHOSTUNREACH);
		}
	}

	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_REJECT) {
		VERIFY(rt-&gt;rt_expire == 0 || rt-&gt;rt_rmx.rmx_expire != 0);
		VERIFY(rt-&gt;rt_expire != 0 || rt-&gt;rt_rmx.rmx_expire == 0);
		timenow = net_uptime();
		<span class="enscript-keyword">if</span> (rt-&gt;rt_expire == 0 || timenow &lt; rt-&gt;rt_expire) {
			RT_UNLOCK(rt);
			senderr(!gwroute ? EHOSTDOWN : EHOSTUNREACH);
		}
	}

	<span class="enscript-comment">/* Become a regular mutex */</span>
	RT_CONVERT_LOCK(rt);

	<span class="enscript-comment">/* Caller is responsible for cleaning up &quot;rt&quot; */</span>
	*out_route = rt;
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">bad</span>:
	<span class="enscript-comment">/* Clean up route (either it is &quot;rt&quot; or &quot;gwrt&quot;) */</span>
	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK_SPIN(rt);
		<span class="enscript-keyword">if</span> (rt == hint0) {
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(rt);
			rtfree(rt);
		}
	}
	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">senderr</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">rt_revalidate_gwroute</span>(<span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> rtentry *gwrt)
{
	VERIFY(gwrt != NULL);

	RT_LOCK_SPIN(rt);
	<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; (RTF_GATEWAY | RTF_UP)) == (RTF_GATEWAY | RTF_UP) &amp;&amp;
	    rt-&gt;rt_ifp == gwrt-&gt;rt_ifp &amp;&amp; rt-&gt;rt_gateway-&gt;sa_family ==
	    rt_key(gwrt)-&gt;sa_family &amp;&amp; (rt-&gt;rt_gwroute == NULL ||
	    !(rt-&gt;rt_gwroute-&gt;rt_flags &amp; RTF_UP))) {
		boolean_t isequal;
		VERIFY(rt-&gt;rt_flags &amp; (RTF_CLONING | RTF_PRCLONING));

		<span class="enscript-keyword">if</span> (rt-&gt;rt_gateway-&gt;sa_family == AF_INET ||
		    rt-&gt;rt_gateway-&gt;sa_family == AF_INET6) {
			<span class="enscript-type">struct</span> sockaddr_storage key_ss, gw_ss;
			<span class="enscript-comment">/*
			 * We need to compare rt_key and rt_gateway; create
			 * local copies to get rid of any ifscope association.
			 */</span>
			(<span class="enscript-type">void</span>) sa_copy(rt_key(gwrt), &amp;key_ss, NULL);
			(<span class="enscript-type">void</span>) sa_copy(rt-&gt;rt_gateway, &amp;gw_ss, NULL);

			isequal = equal(SA(&amp;key_ss), SA(&amp;gw_ss));
		} <span class="enscript-keyword">else</span> {
			isequal = equal(rt_key(gwrt), rt-&gt;rt_gateway);
		}

		<span class="enscript-comment">/* If they are the same, update gwrt */</span>
		<span class="enscript-keyword">if</span> (isequal) {
			RT_UNLOCK(rt);
			lck_mtx_lock(rnh_lock);
			RT_LOCK(rt);
			rt_set_gwroute(rt, rt_key(rt), gwrt);
			RT_UNLOCK(rt);
			lck_mtx_unlock(rnh_lock);
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(rt);
		}
	} <span class="enscript-keyword">else</span> {
		RT_UNLOCK(rt);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rt_str4</span>(<span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">char</span> *ds, uint32_t dslen, <span class="enscript-type">char</span> *gs, uint32_t gslen)
{
	VERIFY(rt_key(rt)-&gt;sa_family == AF_INET);

	<span class="enscript-keyword">if</span> (ds != NULL) {
		(<span class="enscript-type">void</span>) inet_ntop(AF_INET,
		    &amp;SIN(rt_key(rt))-&gt;sin_addr.s_addr, ds, dslen);
		<span class="enscript-keyword">if</span> (dslen &gt;= MAX_SCOPE_ADDR_STR_LEN &amp;&amp;
		    SINIFSCOPE(rt_key(rt))-&gt;sin_scope_id != IFSCOPE_NONE) {
			<span class="enscript-type">char</span> scpstr[16];

			snprintf(scpstr, <span class="enscript-keyword">sizeof</span>(scpstr), <span class="enscript-string">&quot;@%u&quot;</span>,
			    SINIFSCOPE(rt_key(rt))-&gt;sin_scope_id);

			strlcat(ds, scpstr, dslen);
		}
	}

	<span class="enscript-keyword">if</span> (gs != NULL) {
		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_GATEWAY) {
			(<span class="enscript-type">void</span>) inet_ntop(AF_INET,
			    &amp;SIN(rt-&gt;rt_gateway)-&gt;sin_addr.s_addr, gs, gslen);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rt-&gt;rt_ifp != NULL) {
			snprintf(gs, gslen, <span class="enscript-string">&quot;link#%u&quot;</span>, rt-&gt;rt_ifp-&gt;if_unit);
		} <span class="enscript-keyword">else</span> {
			snprintf(gs, gslen, <span class="enscript-string">&quot;%s&quot;</span>, <span class="enscript-string">&quot;link&quot;</span>);
		}
	}
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rt_str6</span>(<span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">char</span> *ds, uint32_t dslen, <span class="enscript-type">char</span> *gs, uint32_t gslen)
{
	VERIFY(rt_key(rt)-&gt;sa_family == AF_INET6);

	<span class="enscript-keyword">if</span> (ds != NULL) {
		(<span class="enscript-type">void</span>) inet_ntop(AF_INET6,
		    &amp;SIN6(rt_key(rt))-&gt;sin6_addr, ds, dslen);
		<span class="enscript-keyword">if</span> (dslen &gt;= MAX_SCOPE_ADDR_STR_LEN &amp;&amp;
		    SIN6IFSCOPE(rt_key(rt))-&gt;sin6_scope_id != IFSCOPE_NONE) {
			<span class="enscript-type">char</span> scpstr[16];

			snprintf(scpstr, <span class="enscript-keyword">sizeof</span>(scpstr), <span class="enscript-string">&quot;@%u&quot;</span>,
			    SIN6IFSCOPE(rt_key(rt))-&gt;sin6_scope_id);

			strlcat(ds, scpstr, dslen);
		}
	}

	<span class="enscript-keyword">if</span> (gs != NULL) {
		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_GATEWAY) {
			(<span class="enscript-type">void</span>) inet_ntop(AF_INET6,
			    &amp;SIN6(rt-&gt;rt_gateway)-&gt;sin6_addr, gs, gslen);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rt-&gt;rt_ifp != NULL) {
			snprintf(gs, gslen, <span class="enscript-string">&quot;link#%u&quot;</span>, rt-&gt;rt_ifp-&gt;if_unit);
		} <span class="enscript-keyword">else</span> {
			snprintf(gs, gslen, <span class="enscript-string">&quot;%s&quot;</span>, <span class="enscript-string">&quot;link&quot;</span>);
		}
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>


<span class="enscript-type">void</span>
<span class="enscript-function-name">rt_str</span>(<span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">char</span> *ds, uint32_t dslen, <span class="enscript-type">char</span> *gs, uint32_t gslen)
{
	<span class="enscript-keyword">switch</span> (rt_key(rt)-&gt;sa_family) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		rt_str4(rt, ds, dslen, gs, gslen);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		rt_str6(rt, ds, dslen, gs, gslen);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">if</span> (ds != NULL)
			bzero(ds, dslen);
		<span class="enscript-keyword">if</span> (gs != NULL)
			bzero(gs, gslen);
		<span class="enscript-keyword">break</span>;
	}
}
</pre>
<hr />
</body></html>