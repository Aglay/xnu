<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>if_stf.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">if_stf.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$FreeBSD: src/sys/net/if_stf.c,v 1.1.2.6 2001/07/24 19:10:18 brooks Exp $	*/</span>
<span class="enscript-comment">/*	$KAME: if_stf.c,v 1.62 2001/06/07 22:32:16 itojun Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (C) 2000 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2006 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

<span class="enscript-comment">/*
 * 6to4 interface, based on RFC3056.
 *
 * 6to4 interface is NOT capable of link-layer (I mean, IPv4) multicasting.
 * There is no address mapping defined from IPv6 multicast address to IPv4
 * address.  Therefore, we do not have IFF_MULTICAST on the interface.
 *
 * Due to the lack of address mapping for link-local addresses, we cannot
 * throw packets toward link-local addresses (fe80::x).  Also, we cannot throw
 * packets to link-local multicast addresses (ff02::x).
 *
 * Here are interesting symptoms due to the lack of link-local address:
 *
 * Unicast routing exchange:
 * - RIPng: Impossible.  Uses link-local multicast packet toward ff02::9,
 *   and link-local addresses as nexthop.
 * - OSPFv6: Impossible.  OSPFv6 assumes that there's link-local address
 *   assigned to the link, and makes use of them.  Also, HELLO packets use
 *   link-local multicast addresses (ff02::5 and ff02::6).
 * - BGP4+: Maybe.  You can only use global address as nexthop, and global
 *   address as TCP endpoint address.
 *
 * Multicast routing protocols:
 * - PIM: Hello packet cannot be used to discover adjacent PIM routers.
 *   Adjacent PIM routers must be configured manually (is it really spec-wise
 *   correct thing to do?).
 *
 * ICMPv6:
 * - Redirects cannot be used due to the lack of link-local address.
 *
 * stf interface does not have, and will not need, a link-local address.  
 * It seems to have no real benefit and does not help the above symptoms much.
 * Even if we assign link-locals to interface, we cannot really
 * use link-local unicast/multicast on top of 6to4 cloud (since there's no
 * encapsulation defined for link-local address), and the above analysis does
 * not change.  RFC3056 does not mandate the assignment of link-local address
 * either.
 *
 * 6to4 interface has security issues.  Refer to
 * <a href="http://playground.iijlab.net/i-d/draft-itojun-ipv6-transition-abuse-00.txt">http://playground.iijlab.net/i-d/draft-itojun-ipv6-transition-abuse-00.txt</a>
 * for details.  The code tries to filter out some of malicious packets.
 * Note that there is no way to be 100% secure.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_ecn.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_encap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_interface.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_protocol.h&gt;</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bpf.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">GET_V4</span>(x) ((const struct in_addr *)(const void *)(&amp;(x)-&gt;s6_addr16[1])) 

<span class="enscript-type">static</span> lck_grp_t *stf_mtx_grp;

<span class="enscript-type">struct</span> stf_softc {
	ifnet_t				sc_if;	   <span class="enscript-comment">/* common area */</span>
	u_int32_t				sc_protocol_family; <span class="enscript-comment">/* dlil protocol attached */</span>
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> route  __sc_ro4;
		<span class="enscript-type">struct</span> route_in6 __sc_ro6; <span class="enscript-comment">/* just for safety */</span>
	} __sc_ro46;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">sc_ro</span>	__sc_ro46.__sc_ro4
	decl_lck_mtx_data(, sc_ro_mtx);
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> encaptab *encap_cookie;
	bpf_tap_mode		tap_mode;
	bpf_packet_func		tap_callback;
};

<span class="enscript-type">void</span> <span class="enscript-function-name">stfattach</span> (<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_stf_ttl = 40;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> stf_init_done;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_stf_input</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">stfinit</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> protosw in_stf_protosw =
{
	.pr_type =		SOCK_RAW,
	.pr_protocol =		IPPROTO_IPV6,
	.pr_flags =		PR_ATOMIC|PR_ADDR,
	.pr_input =		in_stf_input,
	.pr_ctloutput =		rip_ctloutput,
	.pr_usrreqs =		&amp;rip_usrreqs,
	.pr_unlock =		rip_unlock,
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">stf_encapcheck</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in6_ifaddr *<span class="enscript-function-name">stf_getsrcifa6</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">int</span> <span class="enscript-function-name">stf_pre_output</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t, <span class="enscript-type">struct</span> mbuf **,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">void</span> *, <span class="enscript-type">char</span> *, <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">stf_checkaddr4</span>(<span class="enscript-type">struct</span> stf_softc *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr *,
	<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">stf_checkaddr6</span>(<span class="enscript-type">struct</span> stf_softc *, <span class="enscript-type">struct</span> in6_addr *,
	<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">stf_rtrequest</span>(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">stf_ioctl</span>(ifnet_t ifp, u_long cmd, <span class="enscript-type">void</span> *data);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">stf_output</span>(ifnet_t ifp, mbuf_t m);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">stfinit</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (!stf_init_done) {
		stf_mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;stf&quot;</span>, LCK_GRP_ATTR_NULL);
		stf_init_done = 1;
	}
}

<span class="enscript-comment">/*
 * gif_input is the input handler for IP and IPv6 attached to gif
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">stf_media_input</span>(
	__unused ifnet_t	ifp,
	protocol_family_t	protocol_family,
	mbuf_t				m,
	__unused <span class="enscript-type">char</span>		*frame_header)
{
	<span class="enscript-keyword">if</span> (proto_input(protocol_family, m) != 0)
		m_freem(m);

	<span class="enscript-keyword">return</span> (0);
}



<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">stf_add_proto</span>(
	ifnet_t									ifp,
	protocol_family_t						protocol_family,
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_demux_desc	*demux_array,
	__unused u_int32_t						demux_count)
{
	<span class="enscript-comment">/* Only one protocol may be attached at a time */</span>
	<span class="enscript-type">struct</span> stf_softc* stf = ifnet_softc(ifp);
	<span class="enscript-keyword">if</span> (stf-&gt;sc_protocol_family == 0)
		stf-&gt;sc_protocol_family = protocol_family;
	<span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;stf_add_proto: stf already has a proto\n&quot;</span>);
		<span class="enscript-keyword">return</span> EBUSY;
	}
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">stf_del_proto</span>(
	ifnet_t				ifp,
	protocol_family_t	protocol_family)
{
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> stf_softc*)ifnet_softc(ifp))-&gt;sc_protocol_family == protocol_family)
		((<span class="enscript-type">struct</span> stf_softc*)ifnet_softc(ifp))-&gt;sc_protocol_family = 0;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">stf_attach_inet6</span>(
	ifnet_t				ifp,
	protocol_family_t	protocol_family)
{
    <span class="enscript-type">struct</span> ifnet_attach_proto_param	reg;
    errno_t							stat;
    
    <span class="enscript-keyword">if</span> (protocol_family != PF_INET6)
    	<span class="enscript-keyword">return</span> EPROTONOSUPPORT;

	bzero(&amp;reg, <span class="enscript-keyword">sizeof</span>(reg));
    reg.input = stf_media_input;
    reg.pre_output = stf_pre_output;

    stat = ifnet_attach_protocol(ifp, protocol_family, &amp;reg);
    <span class="enscript-keyword">if</span> (stat &amp;&amp; stat != EEXIST) {
        printf(<span class="enscript-string">&quot;stf_attach_proto_family can't attach interface fam=%d\n&quot;</span>,
        	   protocol_family);
    }

    <span class="enscript-keyword">return</span> stat;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">stf_demux</span>(
	ifnet_t					ifp,
	__unused mbuf_t			m,
	__unused <span class="enscript-type">char</span>			*frame_ptr,
	protocol_family_t		*protocol_family)
{
	<span class="enscript-type">struct</span> stf_softc* stf = ifnet_softc(ifp);
	*protocol_family = stf-&gt;sc_protocol_family;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">stf_set_bpf_tap</span>(
	ifnet_t			ifp,
	bpf_tap_mode	mode,
	bpf_packet_func	callback)
{
	<span class="enscript-type">struct</span> stf_softc	*sc = ifnet_softc(ifp);
	
	sc-&gt;tap_mode = mode;
	sc-&gt;tap_callback = callback;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">stfattach</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> stf_softc *sc;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> encaptab *p;
	<span class="enscript-type">struct</span> ifnet_init_params	stf_init;

	stfinit();

	error = proto_register_plumber(PF_INET6, APPLE_IF_FAM_STF,
								   stf_attach_inet6, NULL);
	<span class="enscript-keyword">if</span> (error != 0)
		printf(<span class="enscript-string">&quot;proto_register_plumber failed for AF_INET6 error=%d\n&quot;</span>, error);

	sc = _MALLOC(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> stf_softc), M_DEVBUF, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (sc == 0) {
		printf(<span class="enscript-string">&quot;stf softc attach failed\n&quot;</span> );
		<span class="enscript-keyword">return</span>;
	}
	
	p = encap_attach_func(AF_INET, IPPROTO_IPV6, stf_encapcheck,
	    &amp;in_stf_protosw, sc);
	<span class="enscript-keyword">if</span> (p == NULL) {
		printf(<span class="enscript-string">&quot;sftattach encap_attach_func failed\n&quot;</span>);
		FREE(sc, M_DEVBUF);
		<span class="enscript-keyword">return</span>;
	}
	sc-&gt;encap_cookie = p;
	lck_mtx_init(&amp;sc-&gt;sc_ro_mtx, stf_mtx_grp, LCK_ATTR_NULL);
	
	bzero(&amp;stf_init, <span class="enscript-keyword">sizeof</span>(stf_init));
	stf_init.name = <span class="enscript-string">&quot;stf&quot;</span>;
	stf_init.unit = 0;
	stf_init.type = IFT_STF;
	stf_init.family = IFNET_FAMILY_STF;
	stf_init.output = stf_output;
	stf_init.demux = stf_demux;
	stf_init.add_proto = stf_add_proto;
	stf_init.del_proto = stf_del_proto;
	stf_init.softc = sc;
	stf_init.ioctl = stf_ioctl;
	stf_init.set_bpf_tap = stf_set_bpf_tap;
	
	error = ifnet_allocate(&amp;stf_init, &amp;sc-&gt;sc_if);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;stfattach, ifnet_allocate failed - %d\n&quot;</span>, error);
		encap_detach(sc-&gt;encap_cookie);
		lck_mtx_destroy(&amp;sc-&gt;sc_ro_mtx, stf_mtx_grp);
		FREE(sc, M_DEVBUF);
		<span class="enscript-keyword">return</span>;
	}
	ifnet_set_mtu(sc-&gt;sc_if, IPV6_MMTU);
	ifnet_set_flags(sc-&gt;sc_if, 0, 0xffff); <span class="enscript-comment">/* clear all flags */</span>
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/* turn off ingress filter */</span>
	ifnet_set_flags(sc-&gt;sc_if, IFF_LINK2, IFF_LINK2);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	mac_ifnet_label_init(&amp;sc-&gt;sc_if);
#<span class="enscript-reference">endif</span>
	
	error = ifnet_attach(sc-&gt;sc_if, NULL);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;stfattach: ifnet_attach returned error=%d\n&quot;</span>, error);
		encap_detach(sc-&gt;encap_cookie);
		ifnet_release(sc-&gt;sc_if);
		lck_mtx_destroy(&amp;sc-&gt;sc_ro_mtx, stf_mtx_grp);
		FREE(sc, M_DEVBUF);
		<span class="enscript-keyword">return</span>;
	}
	
	bpfattach(sc-&gt;sc_if, DLT_NULL, <span class="enscript-keyword">sizeof</span>(u_int));
	
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">stf_encapcheck</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> mbuf *m,
	__unused <span class="enscript-type">int</span> off,
	<span class="enscript-type">int</span> proto,
	<span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ip ip;
	<span class="enscript-type">struct</span> in6_ifaddr *ia6;
	<span class="enscript-type">struct</span> stf_softc *sc;
	<span class="enscript-type">struct</span> in_addr a, b;

	sc = (<span class="enscript-type">struct</span> stf_softc *)arg;
	<span class="enscript-keyword">if</span> (sc == NULL)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">if</span> ((ifnet_flags(sc-&gt;sc_if) &amp; IFF_UP) == 0)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-comment">/* IFF_LINK0 means &quot;no decapsulation&quot; */</span>
	<span class="enscript-keyword">if</span> ((ifnet_flags(sc-&gt;sc_if) &amp; IFF_LINK0) != 0)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">if</span> (proto != IPPROTO_IPV6)
		<span class="enscript-keyword">return</span> 0;

	mbuf_copydata((<span class="enscript-type">struct</span> mbuf *)(size_t)m, 0, <span class="enscript-keyword">sizeof</span>(ip), &amp;ip);

	<span class="enscript-keyword">if</span> (ip.ip_v != 4)
		<span class="enscript-keyword">return</span> 0;

	ia6 = stf_getsrcifa6(sc-&gt;sc_if);
	<span class="enscript-keyword">if</span> (ia6 == NULL)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-comment">/*
	 * check if IPv4 dst matches the IPv4 address derived from the
	 * local 6to4 address.
	 * success on: dst = 10.1.1.1, ia6-&gt;ia_addr = 2002:0a01:0101:...
	 */</span>
	IFA_LOCK(&amp;ia6-&gt;ia_ifa);
	<span class="enscript-keyword">if</span> (bcmp(GET_V4(&amp;ia6-&gt;ia_addr.sin6_addr), &amp;ip.ip_dst,
	    <span class="enscript-keyword">sizeof</span>(ip.ip_dst)) != 0) {
		IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);
		IFA_REMREF(&amp;ia6-&gt;ia_ifa);
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-comment">/*
	 * check if IPv4 src matches the IPv4 address derived from the
	 * local 6to4 address masked by prefixmask.
	 * success on: src = 10.1.1.1, ia6-&gt;ia_addr = 2002:0a00:.../24
	 * fail on: src = 10.1.1.1, ia6-&gt;ia_addr = 2002:0b00:.../24
	 */</span>
	bzero(&amp;a, <span class="enscript-keyword">sizeof</span>(a));
	a.s_addr = GET_V4(&amp;ia6-&gt;ia_addr.sin6_addr)-&gt;s_addr;
	a.s_addr &amp;= GET_V4(&amp;ia6-&gt;ia_prefixmask.sin6_addr)-&gt;s_addr;
	b = ip.ip_src;
	b.s_addr &amp;= GET_V4(&amp;ia6-&gt;ia_prefixmask.sin6_addr)-&gt;s_addr;
	<span class="enscript-keyword">if</span> (a.s_addr != b.s_addr) {
		IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);
		IFA_REMREF(&amp;ia6-&gt;ia_ifa);
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-comment">/* stf interface makes single side match only */</span>
	IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);
	IFA_REMREF(&amp;ia6-&gt;ia_ifa);
	<span class="enscript-keyword">return</span> 32;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in6_ifaddr *
<span class="enscript-function-name">stf_getsrcifa6</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> ifaddr *ia;
	<span class="enscript-type">struct</span> in_ifaddr *ia4;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6;
	<span class="enscript-type">struct</span> in_addr in;

	ifnet_lock_shared(ifp);
	<span class="enscript-keyword">for</span> (ia = ifp-&gt;if_addrlist.tqh_first; ia; ia = ia-&gt;ifa_list.tqe_next) {
		IFA_LOCK(ia);
		<span class="enscript-keyword">if</span> (ia-&gt;ifa_addr == NULL) {
			IFA_UNLOCK(ia);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (ia-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
			IFA_UNLOCK(ia);
			<span class="enscript-keyword">continue</span>;
		}
		sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)ia-&gt;ifa_addr;
		<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_6TO4(&amp;sin6-&gt;sin6_addr)) {
			IFA_UNLOCK(ia);
			<span class="enscript-keyword">continue</span>;
		}
		bcopy(GET_V4(&amp;sin6-&gt;sin6_addr), &amp;in, <span class="enscript-keyword">sizeof</span>(in));
		IFA_UNLOCK(ia);
		lck_rw_lock_shared(in_ifaddr_rwlock);
		<span class="enscript-keyword">for</span> (ia4 = TAILQ_FIRST(&amp;in_ifaddrhead);
		     ia4;
		     ia4 = TAILQ_NEXT(ia4, ia_link))
		{
			IFA_LOCK(&amp;ia4-&gt;ia_ifa);
			<span class="enscript-keyword">if</span> (ia4-&gt;ia_addr.sin_addr.s_addr == in.s_addr) {
				IFA_UNLOCK(&amp;ia4-&gt;ia_ifa);
				<span class="enscript-keyword">break</span>;
			}
			IFA_UNLOCK(&amp;ia4-&gt;ia_ifa);
		}
		lck_rw_done(in_ifaddr_rwlock);
		<span class="enscript-keyword">if</span> (ia4 == NULL)
			<span class="enscript-keyword">continue</span>;

		IFA_ADDREF(ia);		<span class="enscript-comment">/* for caller */</span>
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> in6_ifaddr *)ia);
	}
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">stf_pre_output</span>(
	<span class="enscript-type">struct</span> ifnet	*ifp,
	__unused protocol_family_t  protocol_family,
	<span class="enscript-type">struct</span> mbuf	**m0,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr	*dst,
	__unused <span class="enscript-type">void</span> *route,
	__unused <span class="enscript-type">char</span> *desk_linkaddr,
	__unused <span class="enscript-type">char</span> *frame_type)
{
	<span class="enscript-type">struct</span> mbuf *m = *m0;
	<span class="enscript-type">struct</span> stf_softc *sc;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in6 *dst6;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr *in4;
	u_int8_t tos;
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">struct</span> in6_ifaddr *ia6;
	<span class="enscript-type">struct</span> sockaddr_in 	*dst4;
	<span class="enscript-type">struct</span> ip_out_args ipoa =
	    { IFSCOPE_NONE, { 0 }, IPOAF_SELECT_SRCIF, 0 };
	errno_t				result = 0;

	sc = ifnet_softc(ifp);
	dst6 = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)dst;

	<span class="enscript-comment">/* just in case */</span>
	<span class="enscript-keyword">if</span> ((ifnet_flags(ifp) &amp; IFF_UP) == 0) {
		printf(<span class="enscript-string">&quot;stf: IFF_DOWN\n&quot;</span>);
		<span class="enscript-keyword">return</span> ENETDOWN;
	}

	<span class="enscript-comment">/*
	 * If we don't have an ip4 address that match my inner ip6 address,
	 * we shouldn't generate output.  Without this check, we'll end up
	 * using wrong IPv4 source.
	 */</span>
	ia6 = stf_getsrcifa6(ifp);
	<span class="enscript-keyword">if</span> (ia6 == NULL) {
		<span class="enscript-keyword">return</span> ENETDOWN;
	}

	<span class="enscript-keyword">if</span> (mbuf_len(m) &lt; <span class="enscript-keyword">sizeof</span>(*ip6)) {
		m = m_pullup(m, <span class="enscript-keyword">sizeof</span>(*ip6));
		<span class="enscript-keyword">if</span> (!m) {
			*m0 = NULL; <span class="enscript-comment">/* makes sure this won't be double freed */</span>
			IFA_REMREF(&amp;ia6-&gt;ia_ifa);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
	}
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	tos = (ntohl(ip6-&gt;ip6_flow) &gt;&gt; 20) &amp; 0xff;

	<span class="enscript-comment">/*
	 * Pickup the right outer dst addr from the list of candidates.
	 * ip6_dst has priority as it may be able to give us shorter IPv4 hops.
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_6TO4(&amp;ip6-&gt;ip6_dst))
		in4 = GET_V4(&amp;ip6-&gt;ip6_dst);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IN6_IS_ADDR_6TO4(&amp;dst6-&gt;sin6_addr))
		in4 = GET_V4(&amp;dst6-&gt;sin6_addr);
	<span class="enscript-keyword">else</span> {
		IFA_REMREF(&amp;ia6-&gt;ia_ifa);
		<span class="enscript-keyword">return</span> ENETUNREACH;
	}

	<span class="enscript-keyword">if</span> (ifp-&gt;if_bpf) {
		<span class="enscript-comment">/* We need to prepend the address family as a four byte field. */</span>
		u_int32_t af = AF_INET6;
		
		bpf_tap_out(ifp, 0, m, &amp;af, <span class="enscript-keyword">sizeof</span>(af));
	}

	M_PREPEND(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip), M_DONTWAIT, 1);
	<span class="enscript-keyword">if</span> (m &amp;&amp; mbuf_len(m) &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip))
		m = m_pullup(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip));
	<span class="enscript-keyword">if</span> (m == NULL) {
		*m0 = NULL; 
		IFA_REMREF(&amp;ia6-&gt;ia_ifa);
		<span class="enscript-keyword">return</span> ENOBUFS;
	}
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);

	bzero(ip, <span class="enscript-keyword">sizeof</span>(*ip));

	IFA_LOCK_SPIN(&amp;ia6-&gt;ia_ifa);
	bcopy(GET_V4(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;ia6-&gt;ia_addr)-&gt;sin6_addr),
	    &amp;ip-&gt;ip_src, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_src));
	IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);
	bcopy(in4, &amp;ip-&gt;ip_dst, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_dst));
	ip-&gt;ip_p = IPPROTO_IPV6;
	ip-&gt;ip_ttl = ip_stf_ttl;
	ip-&gt;ip_len = m-&gt;m_pkthdr.len;	<span class="enscript-comment">/*host order*/</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_flags &amp; IFF_LINK1)
		ip_ecn_ingress(ECN_NORMAL, &amp;ip-&gt;ip_tos, &amp;tos);
	<span class="enscript-keyword">else</span>
		ip_ecn_ingress(ECN_NOCARE, &amp;ip-&gt;ip_tos, &amp;tos);

	lck_mtx_lock(&amp;sc-&gt;sc_ro_mtx);
	dst4 = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;sc-&gt;sc_ro.ro_dst;
	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(&amp;sc-&gt;sc_ro) || dst4-&gt;sin_family != AF_INET ||
	    bcmp(&amp;dst4-&gt;sin_addr, &amp;ip-&gt;ip_dst, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_dst)) != 0) {
		ROUTE_RELEASE(&amp;sc-&gt;sc_ro);
		<span class="enscript-comment">/* cache route doesn't match: always the case during the first use */</span>
		dst4-&gt;sin_family = AF_INET;
		dst4-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
		bcopy(&amp;ip-&gt;ip_dst, &amp;dst4-&gt;sin_addr, <span class="enscript-keyword">sizeof</span>(dst4-&gt;sin_addr));
	}

	result = ip_output(m, NULL, &amp;sc-&gt;sc_ro, IP_OUTARGS, NULL, &amp;ipoa);
	lck_mtx_unlock(&amp;sc-&gt;sc_ro_mtx);

	<span class="enscript-comment">/* Assumption: ip_output will free mbuf on errors */</span>
	<span class="enscript-comment">/* All the output processing is done here, don't let stf_output be called */</span>
	<span class="enscript-keyword">if</span> (result == 0)
		result = EJUSTRETURN;
	*m0 = NULL;
	IFA_REMREF(&amp;ia6-&gt;ia_ifa);
	<span class="enscript-keyword">return</span> result;
}
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">stf_output</span>(
	__unused ifnet_t	ifp,
	__unused mbuf_t	m)
{
	<span class="enscript-comment">/* All processing is done in stf_pre_output
	 * this shouldn't be called as the pre_output returns &quot;EJUSTRETURN&quot;
	 */</span>
	<span class="enscript-keyword">return</span> 0;
}	

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">stf_checkaddr4</span>(
	<span class="enscript-type">struct</span> stf_softc *sc,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr *in,
	<span class="enscript-type">struct</span> ifnet *inifp)	<span class="enscript-comment">/* incoming interface */</span>
{
	<span class="enscript-type">struct</span> in_ifaddr *ia4;

	<span class="enscript-comment">/*
	 * reject packets with the following address:
	 * 224.0.0.0/4 0.0.0.0/8 127.0.0.0/8 255.0.0.0/8
	 */</span>
	<span class="enscript-keyword">if</span> (IN_MULTICAST(ntohl(in-&gt;s_addr)))
		<span class="enscript-keyword">return</span> -1;
	<span class="enscript-keyword">switch</span> ((ntohl(in-&gt;s_addr) &amp; 0xff000000) &gt;&gt; 24) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>: <span class="enscript-keyword">case</span> <span class="enscript-reference">127</span>: <span class="enscript-keyword">case</span> <span class="enscript-reference">255</span>:
		<span class="enscript-keyword">return</span> -1;
	}

	<span class="enscript-comment">/*
	 * reject packets with broadcast
	 */</span>
	lck_rw_lock_shared(in_ifaddr_rwlock);
	<span class="enscript-keyword">for</span> (ia4 = TAILQ_FIRST(&amp;in_ifaddrhead);
	     ia4;
	     ia4 = TAILQ_NEXT(ia4, ia_link))
	{
		IFA_LOCK(&amp;ia4-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> ((ia4-&gt;ia_ifa.ifa_ifp-&gt;if_flags &amp; IFF_BROADCAST) == 0) {
			IFA_UNLOCK(&amp;ia4-&gt;ia_ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (in-&gt;s_addr == ia4-&gt;ia_broadaddr.sin_addr.s_addr) {
			IFA_UNLOCK(&amp;ia4-&gt;ia_ifa);
			lck_rw_done(in_ifaddr_rwlock);
			<span class="enscript-keyword">return</span> -1;
		}
		IFA_UNLOCK(&amp;ia4-&gt;ia_ifa);
	}
	lck_rw_done(in_ifaddr_rwlock);

	<span class="enscript-comment">/*
	 * perform ingress filter
	 */</span>
	<span class="enscript-keyword">if</span> (sc &amp;&amp; (ifnet_flags(sc-&gt;sc_if) &amp; IFF_LINK2) == 0 &amp;&amp; inifp) {
		<span class="enscript-type">struct</span> sockaddr_in sin;
		<span class="enscript-type">struct</span> rtentry *rt;

		bzero(&amp;sin, <span class="enscript-keyword">sizeof</span>(sin));
		sin.sin_family = AF_INET;
		sin.sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
		sin.sin_addr = *in;
		rt = rtalloc1((<span class="enscript-type">struct</span> sockaddr *)&amp;sin, 0, 0);
		<span class="enscript-keyword">if</span> (rt != NULL)
			RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (rt == NULL || rt-&gt;rt_ifp != inifp) {
#<span class="enscript-reference">if</span> 1
			log(LOG_WARNING, <span class="enscript-string">&quot;%s: packet from 0x%x dropped &quot;</span>
			    <span class="enscript-string">&quot;due to ingress filter\n&quot;</span>, if_name(sc-&gt;sc_if),
			    (u_int32_t)ntohl(sin.sin_addr.s_addr));
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (rt != NULL) {
				RT_UNLOCK(rt);
				rtfree(rt);
			}
			<span class="enscript-keyword">return</span> -1;
		}
		RT_UNLOCK(rt);
		rtfree(rt);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">stf_checkaddr6</span>(
	<span class="enscript-type">struct</span> stf_softc *sc,
	<span class="enscript-type">struct</span> in6_addr *in6,
	<span class="enscript-type">struct</span> ifnet *inifp)	<span class="enscript-comment">/* incoming interface */</span>
{
	<span class="enscript-comment">/*
	 * check 6to4 addresses
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_6TO4(in6))
		<span class="enscript-keyword">return</span> stf_checkaddr4(sc, GET_V4(in6), inifp);

	<span class="enscript-comment">/*
	 * reject anything that look suspicious.  the test is implemented
	 * in ip6_input too, but we check here as well to
	 * (1) reject bad packets earlier, and
	 * (2) to be safe against future ip6_input change.
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_V4COMPAT(in6) || IN6_IS_ADDR_V4MAPPED(in6))
		<span class="enscript-keyword">return</span> -1;

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in_stf_input</span>(
	<span class="enscript-type">struct</span> mbuf *m,
	<span class="enscript-type">int</span> off)
{
	<span class="enscript-type">struct</span> stf_softc *sc;
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">struct</span> ip6_hdr ip6;
	u_int8_t otos, itos;
	<span class="enscript-type">int</span> proto;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> ifnet_stat_increment_param	stats;

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	proto = ip-&gt;ip_p;

	<span class="enscript-keyword">if</span> (proto != IPPROTO_IPV6) {
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);

	sc = (<span class="enscript-type">struct</span> stf_softc *)encap_getarg(m);

	<span class="enscript-keyword">if</span> (sc == NULL || (ifnet_flags(sc-&gt;sc_if) &amp; IFF_UP) == 0) {
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}

	ifp = sc-&gt;sc_if;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MAC_LABEL</span>
	mac_mbuf_label_associate_ifnet(ifp, m);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * perform sanity check against outer src/dst.
	 * for source, perform ingress filter as well.
	 */</span>
	<span class="enscript-keyword">if</span> (stf_checkaddr4(sc, &amp;ip-&gt;ip_dst, NULL) &lt; 0 ||
	    stf_checkaddr4(sc, &amp;ip-&gt;ip_src, m-&gt;m_pkthdr.rcvif) &lt; 0) {
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}

	otos = ip-&gt;ip_tos;
	mbuf_copydata(m, off, <span class="enscript-keyword">sizeof</span>(ip6), &amp;ip6);

	<span class="enscript-comment">/*
	 * perform sanity check against inner src/dst.
	 * for source, perform ingress filter as well.
	 */</span>
	<span class="enscript-keyword">if</span> (stf_checkaddr6(sc, &amp;ip6.ip6_dst, NULL) &lt; 0 ||
	    stf_checkaddr6(sc, &amp;ip6.ip6_src, m-&gt;m_pkthdr.rcvif) &lt; 0) {
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}

	itos = (ntohl(ip6.ip6_flow) &gt;&gt; 20) &amp; 0xff;
	<span class="enscript-keyword">if</span> ((ifnet_flags(ifp) &amp; IFF_LINK1) != 0)
		ip_ecn_egress(ECN_NORMAL, &amp;otos, &amp;itos);
	<span class="enscript-keyword">else</span>
		ip_ecn_egress(ECN_NOCARE, &amp;otos, &amp;itos);
	ip6.ip6_flow &amp;= ~htonl(0xff &lt;&lt; 20);
	ip6.ip6_flow |= htonl((u_int32_t)itos &lt;&lt; 20);

	m-&gt;m_pkthdr.rcvif = ifp;
	mbuf_pkthdr_setheader(m, mbuf_data(m));
	mbuf_adj(m, off);
	
	<span class="enscript-keyword">if</span> (ifp-&gt;if_bpf) {
		<span class="enscript-comment">/* We need to prepend the address family as a four byte field. */</span>
		u_int32_t af = AF_INET6;
		bpf_tap_in(ifp, 0, m, &amp;af, <span class="enscript-keyword">sizeof</span>(af));
	}

	<span class="enscript-comment">/*
	 * Put the packet to the network layer input queue according to the
	 * specified address family.
	 * See net/if_gif.c for possible issues with packet processing
	 * reorder due to extra queueing.
	 */</span>
	bzero(&amp;stats, <span class="enscript-keyword">sizeof</span>(stats));
	stats.packets_in = 1;
	stats.bytes_in = mbuf_pkthdr_len(m);
	mbuf_pkthdr_setrcvif(m, ifp);
	ifnet_input(ifp, m, &amp;stats);
	
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">stf_rtrequest</span>(
	__unused <span class="enscript-type">int</span> cmd,
	<span class="enscript-type">struct</span> rtentry *rt,
	__unused <span class="enscript-type">struct</span> sockaddr *sa)
{
	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK_ASSERT_HELD(rt);
		rt-&gt;rt_rmx.rmx_mtu = IPV6_MMTU;
	}
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">stf_ioctl</span>(
	ifnet_t		ifp,
	u_long		cmd,
	<span class="enscript-type">void</span>		*data)
{
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> ifreq *ifr;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6;
	<span class="enscript-type">int</span> error;

	error = 0;
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFADDR</span>:
		ifa = (<span class="enscript-type">struct</span> ifaddr *)data;
		<span class="enscript-keyword">if</span> (ifa == NULL) {
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">break</span>;
		}
		IFA_LOCK(ifa);
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
			IFA_UNLOCK(ifa);
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">break</span>;
		}
		sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)ifa-&gt;ifa_addr;
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_6TO4(&amp;sin6-&gt;sin6_addr)) {
                        <span class="enscript-keyword">if</span> ( !(ifnet_flags( ifp ) &amp; IFF_UP) ) {
                                <span class="enscript-comment">/* do this only if the interface is not already up */</span>
				ifa-&gt;ifa_rtrequest = stf_rtrequest;
				IFA_UNLOCK(ifa);
				ifnet_set_flags(ifp, IFF_UP, IFF_UP);
			} <span class="enscript-keyword">else</span> {
				IFA_UNLOCK(ifa);
			}
		} <span class="enscript-keyword">else</span> {
			IFA_UNLOCK(ifa);
			error = EINVAL;
		}
		IFA_LOCK_ASSERT_NOTHELD(ifa);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCADDMULTI</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDELMULTI</span>:
		ifr = (<span class="enscript-type">struct</span> ifreq *)data;
		<span class="enscript-keyword">if</span> (ifr &amp;&amp; ifr-&gt;ifr_addr.sa_family == AF_INET6)
			;
		<span class="enscript-keyword">else</span>
			error = EAFNOSUPPORT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EOPNOTSUPP;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> error;
}
</pre>
<hr />
</body></html>