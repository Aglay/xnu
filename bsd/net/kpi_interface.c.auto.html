<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kpi_interface.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kpi_interface.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;kpi_interface.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>	<span class="enscript-comment">/* for definition of NULL */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span> <span class="enscript-comment">/* for panic */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_arp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_llreach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_ether.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">INET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/igmp_var.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/mld6_var.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;net/net_str_id.h&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TOUCHLASTCHANGE</span>(__if_lastchange) {				\
	(__if_lastchange)-&gt;tv_sec = net_uptime();			\
	(__if_lastchange)-&gt;tv_usec = 0;					\
}

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifnet_defrouter_llreachinfo</span>(ifnet_t, <span class="enscript-type">int</span>,
    <span class="enscript-type">struct</span> ifnet_llreach_info *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifnet_kpi_free</span>(ifnet_t);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifnet_list_get_common</span>(ifnet_family_t, boolean_t, ifnet_t **,
    u_int32_t *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifnet_set_lladdr_internal</span>(ifnet_t, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *, size_t,
    u_char, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifnet_awdl_check_eflags</span>(ifnet_t, u_int32_t *, u_int32_t *);

<span class="enscript-comment">/*
 * Temporary work around until we have real reference counting
 *
 * We keep the bits about calling dlil_if_release (which should be
 * called recycle) transparent by calling it from our if_free function
 * pointer. We have to keep the client's original detach function
 * somewhere so we can call it.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_kpi_free</span>(ifnet_t ifp)
{
	ifnet_detached_func detach_func = ifp-&gt;if_kpi_storage;

	<span class="enscript-keyword">if</span> (detach_func != NULL)
		detach_func(ifp);

	<span class="enscript-keyword">if</span> (ifp-&gt;if_broadcast.length &gt; <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_broadcast.u.buffer)) {
		FREE(ifp-&gt;if_broadcast.u.ptr, M_IFADDR);
		ifp-&gt;if_broadcast.u.ptr = NULL;
	}

	dlil_if_release(ifp);
}

errno_t
<span class="enscript-function-name">ifnet_allocate</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_init_params *init, ifnet_t *interface)
{
	<span class="enscript-type">struct</span> ifnet_init_eparams einit;

	bzero(&amp;einit, <span class="enscript-keyword">sizeof</span> (einit));

	einit.ver		= IFNET_INIT_CURRENT_VERSION;
	einit.len		= <span class="enscript-keyword">sizeof</span> (einit);
	einit.flags		= IFNET_INIT_LEGACY;
	einit.uniqueid		= init-&gt;uniqueid;
	einit.uniqueid_len	= init-&gt;uniqueid_len;
	einit.name		= init-&gt;name;
	einit.unit		= init-&gt;unit;
	einit.family		= init-&gt;family;
	einit.type		= init-&gt;type;
	einit.output		= init-&gt;output;
	einit.demux		= init-&gt;demux;
	einit.add_proto		= init-&gt;add_proto;
	einit.del_proto		= init-&gt;del_proto;
	einit.check_multi	= init-&gt;check_multi;
	einit.framer		= init-&gt;framer;
	einit.softc		= init-&gt;softc;
	einit.ioctl		= init-&gt;ioctl;
	einit.set_bpf_tap	= init-&gt;set_bpf_tap;
	einit.detach		= init-&gt;detach;
	einit.event		= init-&gt;event;
	einit.broadcast_addr	= init-&gt;broadcast_addr;
	einit.broadcast_len	= init-&gt;broadcast_len;

	<span class="enscript-keyword">return</span> (ifnet_allocate_extended(&amp;einit, interface));
}

errno_t
<span class="enscript-function-name">ifnet_allocate_extended</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_init_eparams *einit0,
    ifnet_t *interface)
{
	<span class="enscript-type">struct</span> ifnet_init_eparams einit;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	<span class="enscript-type">int</span> error;

	einit = *einit0;

	<span class="enscript-keyword">if</span> (einit.ver != IFNET_INIT_CURRENT_VERSION ||
	    einit.len &lt; <span class="enscript-keyword">sizeof</span> (einit))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (einit.family == 0 || einit.name == NULL ||
	    strlen(einit.name) &gt;= IFNAMSIZ ||
	    (einit.type &amp; 0xFFFFFF00) != 0 || einit.type == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (einit.flags &amp; IFNET_INIT_LEGACY) {
		<span class="enscript-keyword">if</span> (einit.output == NULL || einit.flags != IFNET_INIT_LEGACY)
			<span class="enscript-keyword">return</span> (EINVAL);

		einit.pre_enqueue = NULL;
		einit.start = NULL;
		einit.output_ctl = NULL;
		einit.output_sched_model = IFNET_SCHED_MODEL_NORMAL;
		einit.input_poll = NULL;
		einit.input_ctl = NULL;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (einit.start == NULL)
			<span class="enscript-keyword">return</span> (EINVAL);

		einit.output = NULL;
		<span class="enscript-keyword">if</span> (einit.output_sched_model &gt;= IFNET_SCHED_MODEL_MAX)
			<span class="enscript-keyword">return</span> (EINVAL);

		<span class="enscript-keyword">if</span> (einit.flags &amp; IFNET_INIT_INPUT_POLL) {
			<span class="enscript-keyword">if</span> (einit.input_poll == NULL || einit.input_ctl == NULL)
				<span class="enscript-keyword">return</span> (EINVAL);
		} <span class="enscript-keyword">else</span> {
			einit.input_poll = NULL;
			einit.input_ctl = NULL;
		}
	}

	error = dlil_if_acquire(einit.family, einit.uniqueid,
	    einit.uniqueid_len, &amp;ifp);

	<span class="enscript-keyword">if</span> (error == 0) {
		u_int64_t br;

		<span class="enscript-comment">/*
		 * Cast ifp-&gt;if_name as non const. dlil_if_acquire sets it up
		 * to point to storage of at least IFNAMSIZ bytes. It is safe
		 * to write to this.
		 */</span>
		strlcpy(__DECONST(<span class="enscript-type">char</span> *, ifp-&gt;if_name), einit.name, IFNAMSIZ);
		ifp-&gt;if_type		= einit.type;
		ifp-&gt;if_family		= einit.family;
		ifp-&gt;if_subfamily	= einit.subfamily;
		ifp-&gt;if_unit		= einit.unit;
		ifp-&gt;if_output		= einit.output;
		ifp-&gt;if_pre_enqueue	= einit.pre_enqueue;
		ifp-&gt;if_start		= einit.start;
		ifp-&gt;if_output_ctl	= einit.output_ctl;
		ifp-&gt;if_output_sched_model = einit.output_sched_model;
		ifp-&gt;if_output_bw.eff_bw = einit.output_bw;
		ifp-&gt;if_output_bw.max_bw = einit.output_bw_max;
		ifp-&gt;if_output_lt.eff_lt = einit.output_lt;
		ifp-&gt;if_output_lt.max_lt = einit.output_lt_max;
		ifp-&gt;if_input_poll	= einit.input_poll;
		ifp-&gt;if_input_ctl	= einit.input_ctl;
		ifp-&gt;if_input_bw.eff_bw	= einit.input_bw;
		ifp-&gt;if_input_bw.max_bw	= einit.input_bw_max;
		ifp-&gt;if_input_lt.eff_lt	= einit.input_lt;
		ifp-&gt;if_input_lt.max_lt	= einit.input_lt_max;
		ifp-&gt;if_demux		= einit.demux;
		ifp-&gt;if_add_proto	= einit.add_proto;
		ifp-&gt;if_del_proto	= einit.del_proto;
		ifp-&gt;if_check_multi	= einit.check_multi;
		ifp-&gt;if_framer_legacy	= einit.framer;
		ifp-&gt;if_framer		= einit.framer_extended;
		ifp-&gt;if_softc		= einit.softc;
		ifp-&gt;if_ioctl		= einit.ioctl;
		ifp-&gt;if_set_bpf_tap	= einit.set_bpf_tap;
		ifp-&gt;if_free		= ifnet_kpi_free;
		ifp-&gt;if_event		= einit.event;
		ifp-&gt;if_kpi_storage	= einit.detach;

		<span class="enscript-comment">/* Initialize external name (name + unit) */</span>
		snprintf(__DECONST(<span class="enscript-type">char</span> *, ifp-&gt;if_xname), IFXNAMSIZ,
		    <span class="enscript-string">&quot;%s%d&quot;</span>, ifp-&gt;if_name, ifp-&gt;if_unit);

		<span class="enscript-comment">/*
		 * On embedded, framer() is already in the extended form;
		 * we simply use it as is, unless the caller specifies
		 * framer_extended() which will then override it.
		 *
		 * On non-embedded, framer() has long been exposed as part
		 * of the public KPI, and therefore its signature must
		 * remain the same (without the pre- and postpend length
		 * parameters.)  We special case ether_frameout, such that
		 * it gets mapped to its extended variant.  All other cases
		 * utilize the stub routine which will simply return zeroes
		 * for those new parameters.
		 *
		 * Internally, DLIL will only use the extended callback
		 * variant which is represented by if_framer.
		 */</span>
		<span class="enscript-keyword">if</span> (ifp-&gt;if_framer == NULL &amp;&amp; ifp-&gt;if_framer_legacy != NULL) {
			<span class="enscript-keyword">if</span> (ifp-&gt;if_framer_legacy == ether_frameout)
				ifp-&gt;if_framer = ether_frameout_extended;
			<span class="enscript-keyword">else</span>
				ifp-&gt;if_framer = ifnet_framer_stub;
		}

		<span class="enscript-keyword">if</span> (ifp-&gt;if_output_bw.eff_bw &gt; ifp-&gt;if_output_bw.max_bw)
			ifp-&gt;if_output_bw.max_bw = ifp-&gt;if_output_bw.eff_bw;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_output_bw.eff_bw == 0)
			ifp-&gt;if_output_bw.eff_bw = ifp-&gt;if_output_bw.max_bw;

		<span class="enscript-keyword">if</span> (ifp-&gt;if_input_bw.eff_bw &gt; ifp-&gt;if_input_bw.max_bw)
			ifp-&gt;if_input_bw.max_bw = ifp-&gt;if_input_bw.eff_bw;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_input_bw.eff_bw == 0)
			ifp-&gt;if_input_bw.eff_bw = ifp-&gt;if_input_bw.max_bw;

		<span class="enscript-keyword">if</span> (ifp-&gt;if_output_bw.max_bw == 0)
			ifp-&gt;if_output_bw = ifp-&gt;if_input_bw;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_input_bw.max_bw == 0)
			ifp-&gt;if_input_bw = ifp-&gt;if_output_bw;

		<span class="enscript-comment">/* Pin if_baudrate to 32 bits */</span>
		br = MAX(ifp-&gt;if_output_bw.max_bw, ifp-&gt;if_input_bw.max_bw);
		<span class="enscript-keyword">if</span> (br != 0)
			ifp-&gt;if_baudrate = (br &gt; 0xFFFFFFFF) ? 0xFFFFFFFF : br;

		<span class="enscript-keyword">if</span> (ifp-&gt;if_output_lt.eff_lt &gt; ifp-&gt;if_output_lt.max_lt)
			ifp-&gt;if_output_lt.max_lt = ifp-&gt;if_output_lt.eff_lt;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_output_lt.eff_lt == 0)
			ifp-&gt;if_output_lt.eff_lt = ifp-&gt;if_output_lt.max_lt;

		<span class="enscript-keyword">if</span> (ifp-&gt;if_input_lt.eff_lt &gt; ifp-&gt;if_input_lt.max_lt)
			ifp-&gt;if_input_lt.max_lt = ifp-&gt;if_input_lt.eff_lt;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_input_lt.eff_lt == 0)
			ifp-&gt;if_input_lt.eff_lt = ifp-&gt;if_input_lt.max_lt;

		<span class="enscript-keyword">if</span> (ifp-&gt;if_output_lt.max_lt == 0)
			ifp-&gt;if_output_lt = ifp-&gt;if_input_lt;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_input_lt.max_lt == 0)
			ifp-&gt;if_input_lt = ifp-&gt;if_output_lt;

		<span class="enscript-keyword">if</span> (ifp-&gt;if_ioctl == NULL)
			ifp-&gt;if_ioctl = ifp_if_ioctl;

		<span class="enscript-keyword">if</span> (ifp-&gt;if_start != NULL) {
			ifp-&gt;if_eflags |= IFEF_TXSTART;
			<span class="enscript-keyword">if</span> (ifp-&gt;if_pre_enqueue == NULL)
				ifp-&gt;if_pre_enqueue = ifnet_enqueue;
			ifp-&gt;if_output = ifp-&gt;if_pre_enqueue;
		} <span class="enscript-keyword">else</span> {
			ifp-&gt;if_eflags &amp;= ~IFEF_TXSTART;
		}

		<span class="enscript-keyword">if</span> (ifp-&gt;if_input_poll != NULL)
			ifp-&gt;if_eflags |= IFEF_RXPOLL;
		<span class="enscript-keyword">else</span>
			ifp-&gt;if_eflags &amp;= ~IFEF_RXPOLL;

		VERIFY(!(einit.flags &amp; IFNET_INIT_LEGACY) ||
		    (ifp-&gt;if_pre_enqueue == NULL &amp;&amp; ifp-&gt;if_start == NULL &amp;&amp;
		    ifp-&gt;if_output_ctl == NULL &amp;&amp; ifp-&gt;if_input_poll == NULL &amp;&amp;
		    ifp-&gt;if_input_ctl == NULL));
		VERIFY(!(einit.flags &amp; IFNET_INIT_INPUT_POLL) ||
		    (ifp-&gt;if_input_poll != NULL &amp;&amp; ifp-&gt;if_input_ctl != NULL));

		<span class="enscript-keyword">if</span> (einit.broadcast_len &amp;&amp; einit.broadcast_addr) {
			<span class="enscript-keyword">if</span> (einit.broadcast_len &gt;
			    <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_broadcast.u.buffer)) {
				MALLOC(ifp-&gt;if_broadcast.u.ptr, u_char *,
				    einit.broadcast_len, M_IFADDR, M_NOWAIT);
				<span class="enscript-keyword">if</span> (ifp-&gt;if_broadcast.u.ptr == NULL) {
					error = ENOMEM;
				} <span class="enscript-keyword">else</span> {
					bcopy(einit.broadcast_addr,
					    ifp-&gt;if_broadcast.u.ptr,
					    einit.broadcast_len);
				}
			} <span class="enscript-keyword">else</span> {
				bcopy(einit.broadcast_addr,
				    ifp-&gt;if_broadcast.u.buffer,
				    einit.broadcast_len);
			}
			ifp-&gt;if_broadcast.length = einit.broadcast_len;
		} <span class="enscript-keyword">else</span> {
			bzero(&amp;ifp-&gt;if_broadcast, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_broadcast));
		}

		<span class="enscript-comment">/*
		 * output target queue delay is specified in millisecond
		 * convert it to nanoseconds
		 */</span>
		IFCQ_TARGET_QDELAY(&amp;ifp-&gt;if_snd) =
		    einit.output_target_qdelay * 1000 * 1000;
		IFCQ_MAXLEN(&amp;ifp-&gt;if_snd) = einit.sndq_maxlen;

		<span class="enscript-keyword">if</span> (einit.start_delay_qlen &gt; 0 &amp;&amp;
		    einit.start_delay_timeout &gt; 0) {
			ifp-&gt;if_eflags |= IFEF_ENQUEUE_MULTI;
			ifp-&gt;if_start_delay_qlen =
			    min(100, einit.start_delay_qlen);
			ifp-&gt;if_start_delay_timeout =
			    min(20000, einit.start_delay_timeout);
			<span class="enscript-comment">/* convert timeout to nanoseconds */</span>
			ifp-&gt;if_start_delay_timeout *= 1000;
		}

		<span class="enscript-keyword">if</span> (error == 0) {
			*interface = ifp;
			<span class="enscript-comment">// temporary - this should be done in dlil_if_acquire
</span>			ifnet_reference(ifp);
		} <span class="enscript-keyword">else</span> {
			dlil_if_release(ifp);
			*interface = NULL;
		}
	}

	<span class="enscript-comment">/*
	 * Note: We should do something here to indicate that we haven't been
	 * attached yet. By doing so, we can catch the case in ifnet_release
	 * where the reference count reaches zero and call the recycle
	 * function. If the interface is attached, the interface will be
	 * recycled when the interface's if_free function is called. If the
	 * interface is never attached, the if_free function will never be
	 * called and the interface will never be recycled.
	 */</span>

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">ifnet_reference</span>(ifnet_t ifp)
{
	<span class="enscript-keyword">return</span> (dlil_if_ref(ifp));
}

errno_t
<span class="enscript-function-name">ifnet_release</span>(ifnet_t ifp)
{
	<span class="enscript-keyword">return</span> (dlil_if_free(ifp));
}

errno_t
<span class="enscript-function-name">ifnet_interface_family_find</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *module_string,
    ifnet_family_t *family_id)
{
	<span class="enscript-keyword">if</span> (module_string == NULL || family_id == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (net_str_id_find_internal(module_string, family_id,
	    NSI_IF_FAM_ID, 1));
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">ifnet_softc</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? NULL : interface-&gt;if_softc);
}

<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">ifnet_name</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? NULL : interface-&gt;if_name);
}

ifnet_family_t
<span class="enscript-function-name">ifnet_family</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? 0 : interface-&gt;if_family);
}

ifnet_subfamily_t
<span class="enscript-function-name">ifnet_subfamily</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? 0 : interface-&gt;if_subfamily);
}

u_int32_t
<span class="enscript-function-name">ifnet_unit</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? (u_int32_t)0xffffffff :
	    (u_int32_t)interface-&gt;if_unit);
}

u_int32_t
<span class="enscript-function-name">ifnet_index</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? (u_int32_t)0xffffffff :
	    interface-&gt;if_index);
}

errno_t
<span class="enscript-function-name">ifnet_set_flags</span>(ifnet_t interface, u_int16_t new_flags, u_int16_t mask)
{
	uint16_t old_flags;

	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifnet_lock_exclusive(interface);

	<span class="enscript-comment">/* If we are modifying the up/down state, call if_updown */</span>
	<span class="enscript-keyword">if</span> ((mask &amp; IFF_UP) != 0) {
		if_updown(interface, (new_flags &amp; IFF_UP) == IFF_UP);
	}

	old_flags = interface-&gt;if_flags;
	interface-&gt;if_flags = (new_flags &amp; mask) | (interface-&gt;if_flags &amp; ~mask);
	<span class="enscript-comment">/* If we are modifying the multicast flag, set/unset the silent flag */</span>
	<span class="enscript-keyword">if</span> ((old_flags &amp; IFF_MULTICAST) !=
	    (interface-&gt;if_flags &amp; IFF_MULTICAST)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">if</span> (IGMP_IFINFO(interface) != NULL)
			igmp_initsilent(interface, IGMP_IFINFO(interface));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (MLD_IFINFO(interface) != NULL)
			mld6_initsilent(interface, MLD_IFINFO(interface));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}

	ifnet_lock_done(interface);

	<span class="enscript-keyword">return</span> (0);
}

u_int16_t
<span class="enscript-function-name">ifnet_flags</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? 0 : interface-&gt;if_flags);
}

<span class="enscript-comment">/*
 * This routine ensures the following:
 *
 * If IFEF_AWDL is set by the caller, also set the rest of flags as
 * defined in IFEF_AWDL_MASK.
 *
 * If IFEF_AWDL has been set on the interface and the caller attempts
 * to clear one or more of the associated flags in IFEF_AWDL_MASK,
 * return failure.
 *
 * If IFEF_AWDL_RESTRICTED is set by the caller, make sure IFEF_AWDL is set
 * on the interface.
 *
 * All other flags not associated with AWDL are not affected.
 *
 * See &lt;net/if.h&gt; for current definition of IFEF_AWDL_MASK.
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifnet_awdl_check_eflags</span>(ifnet_t ifp, u_int32_t *new_eflags, u_int32_t *mask)
{
	u_int32_t eflags;

	ifnet_lock_assert(ifp, IFNET_LCK_ASSERT_EXCLUSIVE);

	eflags = (*new_eflags &amp; *mask) | (ifp-&gt;if_eflags &amp; ~(*mask));

	<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_AWDL) {
		<span class="enscript-keyword">if</span> (eflags &amp; IFEF_AWDL) {
			<span class="enscript-keyword">if</span> ((eflags &amp; IFEF_AWDL_MASK) != IFEF_AWDL_MASK)
				<span class="enscript-keyword">return</span> (EINVAL);
		} <span class="enscript-keyword">else</span> {
			*new_eflags &amp;= ~IFEF_AWDL_MASK;
			*mask |= IFEF_AWDL_MASK;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (eflags &amp; IFEF_AWDL) {
		*new_eflags |= IFEF_AWDL_MASK;
		*mask |= IFEF_AWDL_MASK;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (eflags &amp; IFEF_AWDL_RESTRICTED &amp;&amp;
	    !(ifp-&gt;if_eflags &amp; IFEF_AWDL))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_set_eflags</span>(ifnet_t interface, u_int32_t new_flags, u_int32_t mask)
{
	uint32_t oeflags;
	<span class="enscript-type">struct</span> kev_msg ev_msg;
	<span class="enscript-type">struct</span> net_event_data ev_data;

	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span>(ev_msg));
	ifnet_lock_exclusive(interface);
	<span class="enscript-comment">/*
	 * Sanity checks for IFEF_AWDL and its related flags.
	 */</span>
	<span class="enscript-keyword">if</span> (ifnet_awdl_check_eflags(interface, &amp;new_flags, &amp;mask) != 0) {
		ifnet_lock_done(interface);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	oeflags = interface-&gt;if_eflags;
	interface-&gt;if_eflags =
	    (new_flags &amp; mask) | (interface-&gt;if_eflags &amp; ~mask);
	ifnet_lock_done(interface);
	<span class="enscript-keyword">if</span> (interface-&gt;if_eflags &amp; IFEF_AWDL_RESTRICTED &amp;&amp;
	    !(oeflags &amp; IFEF_AWDL_RESTRICTED)) {
		ev_msg.event_code = KEV_DL_AWDL_RESTRICTED;
		<span class="enscript-comment">/*
		 * The interface is now restricted to applications that have
		 * the entitlement.
		 * The check for the entitlement will be done in the data
		 * path, so we don't have to do anything here.
		 */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (oeflags &amp; IFEF_AWDL_RESTRICTED &amp;&amp;
	    !(interface-&gt;if_eflags &amp; IFEF_AWDL_RESTRICTED))
		ev_msg.event_code = KEV_DL_AWDL_UNRESTRICTED;
	<span class="enscript-comment">/*
	 * Notify configd so that it has a chance to perform better
	 * reachability detection.
	 */</span>
	<span class="enscript-keyword">if</span> (ev_msg.event_code) {
		bzero(&amp;ev_data, <span class="enscript-keyword">sizeof</span>(ev_data));
		ev_msg.vendor_code = KEV_VENDOR_APPLE;
		ev_msg.kev_class = KEV_NETWORK_CLASS;
		ev_msg.kev_subclass = KEV_DL_SUBCLASS;
		strlcpy(ev_data.if_name, interface-&gt;if_name, IFNAMSIZ);
		ev_data.if_family = interface-&gt;if_family;
		ev_data.if_unit = interface-&gt;if_unit;
		ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> net_event_data);
		ev_msg.dv[0].data_ptr = &amp;ev_data;
		ev_msg.dv[1].data_length = 0;
		kev_post_msg(&amp;ev_msg);
	}

	<span class="enscript-keyword">return</span> (0);
}

u_int32_t
<span class="enscript-function-name">ifnet_eflags</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? 0 : interface-&gt;if_eflags);
}

errno_t
<span class="enscript-function-name">ifnet_set_idle_flags_locked</span>(ifnet_t ifp, u_int32_t new_flags, u_int32_t mask)
{
	<span class="enscript-type">int</span> before, after;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
	ifnet_lock_assert(ifp, IFNET_LCK_ASSERT_EXCLUSIVE);

	<span class="enscript-comment">/*
	 * If this is called prior to ifnet attach, the actual work will
	 * be done at attach time.  Otherwise, if it is called after
	 * ifnet detach, then it is a no-op.
	 */</span>
	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 0)) {
		ifp-&gt;if_idle_new_flags = new_flags;
		ifp-&gt;if_idle_new_flags_mask = mask;
		<span class="enscript-keyword">return</span> (0);
	} <span class="enscript-keyword">else</span> {
		ifp-&gt;if_idle_new_flags = ifp-&gt;if_idle_new_flags_mask = 0;
	}

	before = ifp-&gt;if_idle_flags;
	ifp-&gt;if_idle_flags = (new_flags &amp; mask) | (ifp-&gt;if_idle_flags &amp; ~mask);
	after = ifp-&gt;if_idle_flags;

	<span class="enscript-keyword">if</span> ((after - before) &lt; 0 &amp;&amp; ifp-&gt;if_idle_flags == 0 &amp;&amp;
	    ifp-&gt;if_want_aggressive_drain != 0) {
		ifp-&gt;if_want_aggressive_drain = 0;
		<span class="enscript-keyword">if</span> (ifnet_aggressive_drainers == 0)
			panic(<span class="enscript-string">&quot;%s: ifp=%p negative aggdrain!&quot;</span>, __func__, ifp);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((after - before) &gt; 0 &amp;&amp; ifp-&gt;if_want_aggressive_drain == 0) {
		ifp-&gt;if_want_aggressive_drain++;
		<span class="enscript-keyword">if</span> (++ifnet_aggressive_drainers == 0)
			panic(<span class="enscript-string">&quot;%s: ifp=%p wraparound aggdrain!&quot;</span>, __func__, ifp);
	}

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_set_idle_flags</span>(ifnet_t ifp, u_int32_t new_flags, u_int32_t mask)
{
	errno_t err;

	lck_mtx_lock(rnh_lock);
	ifnet_lock_exclusive(ifp);
	err = ifnet_set_idle_flags_locked(ifp, new_flags, mask);
	ifnet_lock_done(ifp);
	lck_mtx_unlock(rnh_lock);

	<span class="enscript-keyword">return</span> (err);
}

u_int32_t
<span class="enscript-function-name">ifnet_idle_flags</span>(ifnet_t ifp)
{
	<span class="enscript-keyword">return</span> ((ifp == NULL) ? 0 : ifp-&gt;if_idle_flags);
}

errno_t
<span class="enscript-function-name">ifnet_set_link_quality</span>(ifnet_t ifp, <span class="enscript-type">int</span> quality)
{
	errno_t err = 0;

	<span class="enscript-keyword">if</span> (ifp == NULL || quality &lt; IFNET_LQM_MIN || quality &gt; IFNET_LQM_MAX) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 0)) {
		err = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	if_lqm_update(ifp, quality, 0);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifnet_link_quality</span>(ifnet_t ifp)
{
	<span class="enscript-type">int</span> lqm;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (IFNET_LQM_THRESH_OFF);

	ifnet_lock_shared(ifp);
	lqm = ifp-&gt;if_interface_state.lqm_state;
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">return</span> (lqm);
}

errno_t
<span class="enscript-function-name">ifnet_set_interface_state</span>(ifnet_t ifp,
    <span class="enscript-type">struct</span> if_interface_state *if_interface_state)
{
	errno_t err = 0;

	<span class="enscript-keyword">if</span> (ifp == NULL || if_interface_state == NULL) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 0)) {
		err = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	if_state_update(ifp, if_interface_state);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (err);
}

errno_t
<span class="enscript-function-name">ifnet_get_interface_state</span>(ifnet_t ifp,
    <span class="enscript-type">struct</span> if_interface_state *if_interface_state)
{
	errno_t err = 0;

	<span class="enscript-keyword">if</span> (ifp == NULL || if_interface_state == NULL) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 0)) {
		err = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	if_get_state(ifp, if_interface_state);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (err);
}


<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifnet_defrouter_llreachinfo</span>(ifnet_t ifp, <span class="enscript-type">int</span> af,
    <span class="enscript-type">struct</span> ifnet_llreach_info *iflri)
{
	<span class="enscript-keyword">if</span> (ifp == NULL || iflri == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	VERIFY(af == AF_INET || af == AF_INET6);

	<span class="enscript-keyword">return</span> (ifnet_llreach_get_defrouter(ifp, af, iflri));
}

errno_t
<span class="enscript-function-name">ifnet_inet_defrouter_llreachinfo</span>(ifnet_t ifp, <span class="enscript-type">struct</span> ifnet_llreach_info *iflri)
{
	<span class="enscript-keyword">return</span> (ifnet_defrouter_llreachinfo(ifp, AF_INET, iflri));
}

errno_t
<span class="enscript-function-name">ifnet_inet6_defrouter_llreachinfo</span>(ifnet_t ifp, <span class="enscript-type">struct</span> ifnet_llreach_info *iflri)
{
	<span class="enscript-keyword">return</span> (ifnet_defrouter_llreachinfo(ifp, AF_INET6, iflri));
}

errno_t
<span class="enscript-function-name">ifnet_set_capabilities_supported</span>(ifnet_t ifp, u_int32_t new_caps,
    u_int32_t mask)
{
	errno_t error = 0;
	<span class="enscript-type">int</span> tmp;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifnet_lock_exclusive(ifp);
	tmp = (new_caps &amp; mask) | (ifp-&gt;if_capabilities &amp; ~mask);
	<span class="enscript-keyword">if</span> ((tmp &amp; ~IFCAP_VALID))
		error = EINVAL;
	<span class="enscript-keyword">else</span>
		ifp-&gt;if_capabilities = tmp;
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">return</span> (error);
}

u_int32_t
<span class="enscript-function-name">ifnet_capabilities_supported</span>(ifnet_t ifp)
{
	<span class="enscript-keyword">return</span> ((ifp == NULL) ? 0 : ifp-&gt;if_capabilities);
}


errno_t
<span class="enscript-function-name">ifnet_set_capabilities_enabled</span>(ifnet_t ifp, u_int32_t new_caps,
    u_int32_t mask)
{
	errno_t error = 0;
	<span class="enscript-type">int</span> tmp;
	<span class="enscript-type">struct</span> kev_msg ev_msg;
	<span class="enscript-type">struct</span> net_event_data ev_data;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifnet_lock_exclusive(ifp);
	tmp = (new_caps &amp; mask) | (ifp-&gt;if_capenable &amp; ~mask);
	<span class="enscript-keyword">if</span> ((tmp &amp; ~IFCAP_VALID) || (tmp &amp; ~ifp-&gt;if_capabilities))
		error = EINVAL;
	<span class="enscript-keyword">else</span>
		ifp-&gt;if_capenable = tmp;
	ifnet_lock_done(ifp);

	<span class="enscript-comment">/* Notify application of the change */</span>
	bzero(&amp;ev_data, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> net_event_data));
	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kev_msg));
	ev_msg.vendor_code	= KEV_VENDOR_APPLE;
	ev_msg.kev_class	= KEV_NETWORK_CLASS;
	ev_msg.kev_subclass	= KEV_DL_SUBCLASS;

	ev_msg.event_code	= KEV_DL_IFCAP_CHANGED;
	strlcpy(&amp;ev_data.if_name[0], ifp-&gt;if_name, IFNAMSIZ);
	ev_data.if_family	= ifp-&gt;if_family;
	ev_data.if_unit		= (u_int32_t)ifp-&gt;if_unit;
	ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> net_event_data);
	ev_msg.dv[0].data_ptr = &amp;ev_data;
	ev_msg.dv[1].data_length = 0;
	kev_post_msg(&amp;ev_msg);

	<span class="enscript-keyword">return</span> (error);
}

u_int32_t
<span class="enscript-function-name">ifnet_capabilities_enabled</span>(ifnet_t ifp)
{
	<span class="enscript-keyword">return</span> ((ifp == NULL) ? 0 : ifp-&gt;if_capenable);
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> ifnet_offload_t offload_mask =
	(IFNET_CSUM_IP | IFNET_CSUM_TCP | IFNET_CSUM_UDP | IFNET_CSUM_FRAGMENT |
	IFNET_IP_FRAGMENT | IFNET_CSUM_TCPIPV6 | IFNET_CSUM_UDPIPV6 |
	IFNET_IPV6_FRAGMENT | IFNET_CSUM_PARTIAL | IFNET_VLAN_TAGGING |
	IFNET_VLAN_MTU | IFNET_MULTIPAGES | IFNET_TSO_IPV4 | IFNET_TSO_IPV6 |
	IFNET_TX_STATUS);

<span class="enscript-type">static</span> <span class="enscript-type">const</span> ifnet_offload_t any_offload_csum =
	(IFNET_CSUM_IP | IFNET_CSUM_TCP | IFNET_CSUM_UDP | IFNET_CSUM_FRAGMENT |
	IFNET_CSUM_TCPIPV6 | IFNET_CSUM_UDPIPV6 | IFNET_CSUM_PARTIAL);

errno_t
<span class="enscript-function-name">ifnet_set_offload</span>(ifnet_t interface, ifnet_offload_t offload)
{
	u_int32_t ifcaps = 0;

	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifnet_lock_exclusive(interface);
	interface-&gt;if_hwassist = (offload &amp; offload_mask);
	<span class="enscript-comment">/*
	 * Hardware capable of partial checksum offload is
	 * flexible enough to handle any transports utilizing
	 * Internet Checksumming.  Include those transports
	 * here, and leave the final decision to IP.
	 */</span>
	<span class="enscript-keyword">if</span> (interface-&gt;if_hwassist &amp; IFNET_CSUM_PARTIAL) {
		interface-&gt;if_hwassist |= (IFNET_CSUM_TCP | IFNET_CSUM_UDP |
		    IFNET_CSUM_TCPIPV6 | IFNET_CSUM_UDPIPV6);
	}
	<span class="enscript-keyword">if</span> (dlil_verbose) {
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: set offload flags=%b\n&quot;</span>,
		    if_name(interface),
		    interface-&gt;if_hwassist, IFNET_OFFLOADF_BITS);
	}
	ifnet_lock_done(interface);

	<span class="enscript-keyword">if</span> ((offload &amp; any_offload_csum))
		ifcaps |= IFCAP_HWCSUM;
	<span class="enscript-keyword">if</span> ((offload &amp; IFNET_TSO_IPV4))
		ifcaps |= IFCAP_TSO4;
	<span class="enscript-keyword">if</span> ((offload &amp; IFNET_TSO_IPV6))
		ifcaps |= IFCAP_TSO6;
	<span class="enscript-keyword">if</span> ((offload &amp; IFNET_VLAN_MTU))
		ifcaps |= IFCAP_VLAN_MTU;
	<span class="enscript-keyword">if</span> ((offload &amp; IFNET_VLAN_TAGGING))
		ifcaps |= IFCAP_VLAN_HWTAGGING;
	<span class="enscript-keyword">if</span> ((offload &amp; IFNET_TX_STATUS))
		ifcaps |= IFNET_TX_STATUS;
	<span class="enscript-keyword">if</span> (ifcaps != 0) {
		(<span class="enscript-type">void</span>) ifnet_set_capabilities_supported(interface, ifcaps,
		    IFCAP_VALID);
		(<span class="enscript-type">void</span>) ifnet_set_capabilities_enabled(interface, ifcaps,
		    IFCAP_VALID);
	}

	<span class="enscript-keyword">return</span> (0);
}

ifnet_offload_t
<span class="enscript-function-name">ifnet_offload</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ?
	    0 : (interface-&gt;if_hwassist &amp; offload_mask));
}

errno_t
<span class="enscript-function-name">ifnet_set_tso_mtu</span>(ifnet_t interface, sa_family_t family, u_int32_t mtuLen)
{
	errno_t error = 0;

	<span class="enscript-keyword">if</span> (interface == NULL || mtuLen &lt; interface-&gt;if_mtu)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">switch</span> (family) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		<span class="enscript-keyword">if</span> (interface-&gt;if_hwassist &amp; IFNET_TSO_IPV4)
			interface-&gt;if_tso_v4_mtu = mtuLen;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-keyword">if</span> (interface-&gt;if_hwassist &amp; IFNET_TSO_IPV6)
			interface-&gt;if_tso_v6_mtu = mtuLen;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EPROTONOSUPPORT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">ifnet_get_tso_mtu</span>(ifnet_t interface, sa_family_t family, u_int32_t *mtuLen)
{
	errno_t error = 0;

	<span class="enscript-keyword">if</span> (interface == NULL || mtuLen == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">switch</span> (family) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		<span class="enscript-keyword">if</span> (interface-&gt;if_hwassist &amp; IFNET_TSO_IPV4)
			*mtuLen = interface-&gt;if_tso_v4_mtu;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-keyword">if</span> (interface-&gt;if_hwassist &amp; IFNET_TSO_IPV6)
			*mtuLen = interface-&gt;if_tso_v6_mtu;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EPROTONOSUPPORT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">ifnet_set_wake_flags</span>(ifnet_t interface, u_int32_t properties, u_int32_t mask)
{
	<span class="enscript-type">struct</span> kev_msg ev_msg;
	<span class="enscript-type">struct</span> net_event_data ev_data;

	bzero(&amp;ev_data, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> net_event_data));
	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kev_msg));

	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* Do not accept wacky values */</span>
	<span class="enscript-keyword">if</span> ((properties &amp; mask) &amp; ~IF_WAKE_VALID_FLAGS)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifnet_lock_exclusive(interface);

	interface-&gt;if_wake_properties =
	    (properties &amp; mask) | (interface-&gt;if_wake_properties &amp; ~mask);

	ifnet_lock_done(interface);

	(<span class="enscript-type">void</span>) ifnet_touch_lastchange(interface);

	<span class="enscript-comment">/* Notify application of the change */</span>
	ev_msg.vendor_code	= KEV_VENDOR_APPLE;
	ev_msg.kev_class	= KEV_NETWORK_CLASS;
	ev_msg.kev_subclass	= KEV_DL_SUBCLASS;

	ev_msg.event_code	= KEV_DL_WAKEFLAGS_CHANGED;
	strlcpy(&amp;ev_data.if_name[0], interface-&gt;if_name, IFNAMSIZ);
	ev_data.if_family	= interface-&gt;if_family;
	ev_data.if_unit		= (u_int32_t)interface-&gt;if_unit;
	ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> net_event_data);
	ev_msg.dv[0].data_ptr	= &amp;ev_data;
	ev_msg.dv[1].data_length = 0;
	kev_post_msg(&amp;ev_msg);

	<span class="enscript-keyword">return</span> (0);
}

u_int32_t
<span class="enscript-function-name">ifnet_get_wake_flags</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? 0 : interface-&gt;if_wake_properties);
}

<span class="enscript-comment">/*
 * Should MIB data store a copy?
 */</span>
errno_t
<span class="enscript-function-name">ifnet_set_link_mib_data</span>(ifnet_t interface, <span class="enscript-type">void</span> *mibData, u_int32_t mibLen)
{
	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifnet_lock_exclusive(interface);
	interface-&gt;if_linkmib = (<span class="enscript-type">void</span>*)mibData;
	interface-&gt;if_linkmiblen = mibLen;
	ifnet_lock_done(interface);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_get_link_mib_data</span>(ifnet_t interface, <span class="enscript-type">void</span> *mibData, u_int32_t *mibLen)
{
	errno_t	result = 0;

	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifnet_lock_shared(interface);
	<span class="enscript-keyword">if</span> (*mibLen &lt; interface-&gt;if_linkmiblen)
		result = EMSGSIZE;
	<span class="enscript-keyword">if</span> (result == 0 &amp;&amp; interface-&gt;if_linkmib == NULL)
		result = ENOTSUP;

	<span class="enscript-keyword">if</span> (result == 0) {
		*mibLen = interface-&gt;if_linkmiblen;
		bcopy(interface-&gt;if_linkmib, mibData, *mibLen);
	}
	ifnet_lock_done(interface);

	<span class="enscript-keyword">return</span> (result);
}

u_int32_t
<span class="enscript-function-name">ifnet_get_link_mib_data_length</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? 0 : interface-&gt;if_linkmiblen);
}

errno_t
<span class="enscript-function-name">ifnet_output</span>(ifnet_t interface, protocol_family_t protocol_family,
    mbuf_t m, <span class="enscript-type">void</span> *route, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *dest)
{
	<span class="enscript-keyword">if</span> (interface == NULL || protocol_family == 0 || m == NULL) {
		<span class="enscript-keyword">if</span> (m != NULL)
			mbuf_freem_list(m);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">return</span> (dlil_output(interface, protocol_family, m, route, dest, 0, NULL));
}

errno_t
<span class="enscript-function-name">ifnet_output_raw</span>(ifnet_t interface, protocol_family_t protocol_family, mbuf_t m)
{
	<span class="enscript-keyword">if</span> (interface == NULL || m == NULL) {
		<span class="enscript-keyword">if</span> (m != NULL)
			mbuf_freem_list(m);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">return</span> (dlil_output(interface, protocol_family, m, NULL, NULL, 1, NULL));
}

errno_t
<span class="enscript-function-name">ifnet_set_mtu</span>(ifnet_t interface, u_int32_t mtu)
{
	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	interface-&gt;if_mtu = mtu;
	<span class="enscript-keyword">return</span> (0);
}

u_int32_t
<span class="enscript-function-name">ifnet_mtu</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? 0 : interface-&gt;if_mtu);
}

u_char
<span class="enscript-function-name">ifnet_type</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? 0 : interface-&gt;if_data.ifi_type);
}

errno_t
<span class="enscript-function-name">ifnet_set_addrlen</span>(ifnet_t interface, u_char addrlen)
{
	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	interface-&gt;if_data.ifi_addrlen = addrlen;
	<span class="enscript-keyword">return</span> (0);
}

u_char
<span class="enscript-function-name">ifnet_addrlen</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? 0 : interface-&gt;if_data.ifi_addrlen);
}

errno_t
<span class="enscript-function-name">ifnet_set_hdrlen</span>(ifnet_t interface, u_char hdrlen)
{
	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	interface-&gt;if_data.ifi_hdrlen = hdrlen;
	<span class="enscript-keyword">return</span> (0);
}

u_char
<span class="enscript-function-name">ifnet_hdrlen</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? 0 : interface-&gt;if_data.ifi_hdrlen);
}

errno_t
<span class="enscript-function-name">ifnet_set_metric</span>(ifnet_t interface, u_int32_t metric)
{
	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	interface-&gt;if_data.ifi_metric = metric;
	<span class="enscript-keyword">return</span> (0);
}

u_int32_t
<span class="enscript-function-name">ifnet_metric</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? 0 : interface-&gt;if_data.ifi_metric);
}

errno_t
<span class="enscript-function-name">ifnet_set_baudrate</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int64_t baudrate)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifp-&gt;if_output_bw.max_bw = ifp-&gt;if_input_bw.max_bw =
	    ifp-&gt;if_output_bw.eff_bw = ifp-&gt;if_input_bw.eff_bw = baudrate;

	<span class="enscript-comment">/* Pin if_baudrate to 32 bits until we can change the storage size */</span>
	ifp-&gt;if_baudrate = (baudrate &gt; 0xFFFFFFFF) ? 0xFFFFFFFF : baudrate;

	<span class="enscript-keyword">return</span> (0);
}

u_int64_t
<span class="enscript-function-name">ifnet_baudrate</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-keyword">return</span> ((ifp == NULL) ? 0 : ifp-&gt;if_baudrate);
}

errno_t
<span class="enscript-function-name">ifnet_set_bandwidths</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> if_bandwidths *output_bw,
    <span class="enscript-type">struct</span> if_bandwidths *input_bw)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* set input values first (if any), as output values depend on them */</span>
	<span class="enscript-keyword">if</span> (input_bw != NULL)
		(<span class="enscript-type">void</span>) ifnet_set_input_bandwidths(ifp, input_bw);

	<span class="enscript-keyword">if</span> (output_bw != NULL)
		(<span class="enscript-type">void</span>) ifnet_set_output_bandwidths(ifp, output_bw, FALSE);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_set_link_status_outbw</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> if_wifi_status_v1 *sr;
	sr = &amp;ifp-&gt;if_link_status-&gt;ifsr_u.ifsr_wifi.if_wifi_u.if_status_v1;
	<span class="enscript-keyword">if</span> (ifp-&gt;if_output_bw.eff_bw != 0) {
		sr-&gt;valid_bitmask |=
		    IF_WIFI_UL_EFFECTIVE_BANDWIDTH_VALID;
		sr-&gt;ul_effective_bandwidth =
		    ifp-&gt;if_output_bw.eff_bw;
	}
	<span class="enscript-keyword">if</span> (ifp-&gt;if_output_bw.max_bw != 0) {
		sr-&gt;valid_bitmask |=
		    IF_WIFI_UL_MAX_BANDWIDTH_VALID;
		sr-&gt;ul_max_bandwidth =
		    ifp-&gt;if_output_bw.max_bw;
	}
}

errno_t
<span class="enscript-function-name">ifnet_set_output_bandwidths</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> if_bandwidths *bw,
    boolean_t locked)
{
	<span class="enscript-type">struct</span> if_bandwidths old_bw;
	<span class="enscript-type">struct</span> ifclassq *ifq;
	u_int64_t br;

	VERIFY(ifp != NULL &amp;&amp; bw != NULL);

	ifq = &amp;ifp-&gt;if_snd;
	<span class="enscript-keyword">if</span> (!locked)
		IFCQ_LOCK(ifq);
	IFCQ_LOCK_ASSERT_HELD(ifq);

	old_bw = ifp-&gt;if_output_bw;
	<span class="enscript-keyword">if</span> (bw-&gt;eff_bw != 0)
		ifp-&gt;if_output_bw.eff_bw = bw-&gt;eff_bw;
	<span class="enscript-keyword">if</span> (bw-&gt;max_bw != 0)
		ifp-&gt;if_output_bw.max_bw = bw-&gt;max_bw;
	<span class="enscript-keyword">if</span> (ifp-&gt;if_output_bw.eff_bw &gt; ifp-&gt;if_output_bw.max_bw)
		ifp-&gt;if_output_bw.max_bw = ifp-&gt;if_output_bw.eff_bw;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_output_bw.eff_bw == 0)
		ifp-&gt;if_output_bw.eff_bw = ifp-&gt;if_output_bw.max_bw;

	<span class="enscript-comment">/* Pin if_baudrate to 32 bits */</span>
	br = MAX(ifp-&gt;if_output_bw.max_bw, ifp-&gt;if_input_bw.max_bw);
	<span class="enscript-keyword">if</span> (br != 0)
		ifp-&gt;if_baudrate = (br &gt; 0xFFFFFFFF) ? 0xFFFFFFFF : br;

	<span class="enscript-comment">/* Adjust queue parameters if needed */</span>
	<span class="enscript-keyword">if</span> (old_bw.eff_bw != ifp-&gt;if_output_bw.eff_bw ||
	    old_bw.max_bw != ifp-&gt;if_output_bw.max_bw)
		ifnet_update_sndq(ifq, CLASSQ_EV_LINK_BANDWIDTH);

	<span class="enscript-keyword">if</span> (!locked)
		IFCQ_UNLOCK(ifq);

	<span class="enscript-comment">/*
	 * If this is a Wifi interface, update the values in
	 * if_link_status structure also.
	 */</span>
	<span class="enscript-keyword">if</span> (IFNET_IS_WIFI(ifp) &amp;&amp; ifp-&gt;if_link_status != NULL) {
		lck_rw_lock_exclusive(&amp;ifp-&gt;if_link_status_lock);
		ifnet_set_link_status_outbw(ifp);
		lck_rw_done(&amp;ifp-&gt;if_link_status_lock);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_set_link_status_inbw</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> if_wifi_status_v1 *sr;

	sr = &amp;ifp-&gt;if_link_status-&gt;ifsr_u.ifsr_wifi.if_wifi_u.if_status_v1;
	<span class="enscript-keyword">if</span> (ifp-&gt;if_input_bw.eff_bw != 0) {
		sr-&gt;valid_bitmask |=
		    IF_WIFI_DL_EFFECTIVE_BANDWIDTH_VALID;
		sr-&gt;dl_effective_bandwidth =
		    ifp-&gt;if_input_bw.eff_bw;
	}
	<span class="enscript-keyword">if</span> (ifp-&gt;if_input_bw.max_bw != 0) {
		sr-&gt;valid_bitmask |=
		    IF_WIFI_DL_MAX_BANDWIDTH_VALID;
		sr-&gt;dl_max_bandwidth = ifp-&gt;if_input_bw.max_bw;
	}
}

errno_t
<span class="enscript-function-name">ifnet_set_input_bandwidths</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> if_bandwidths *bw)
{
	<span class="enscript-type">struct</span> if_bandwidths old_bw;

	VERIFY(ifp != NULL &amp;&amp; bw != NULL);

	old_bw = ifp-&gt;if_input_bw;
	<span class="enscript-keyword">if</span> (bw-&gt;eff_bw != 0)
		ifp-&gt;if_input_bw.eff_bw = bw-&gt;eff_bw;
	<span class="enscript-keyword">if</span> (bw-&gt;max_bw != 0)
		ifp-&gt;if_input_bw.max_bw = bw-&gt;max_bw;
	<span class="enscript-keyword">if</span> (ifp-&gt;if_input_bw.eff_bw &gt; ifp-&gt;if_input_bw.max_bw)
		ifp-&gt;if_input_bw.max_bw = ifp-&gt;if_input_bw.eff_bw;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_input_bw.eff_bw == 0)
		ifp-&gt;if_input_bw.eff_bw = ifp-&gt;if_input_bw.max_bw;

	<span class="enscript-keyword">if</span> (IFNET_IS_WIFI(ifp) &amp;&amp; ifp-&gt;if_link_status != NULL) {
		lck_rw_lock_exclusive(&amp;ifp-&gt;if_link_status_lock);
		ifnet_set_link_status_inbw(ifp);
		lck_rw_done(&amp;ifp-&gt;if_link_status_lock);
	}

	<span class="enscript-keyword">if</span> (old_bw.eff_bw != ifp-&gt;if_input_bw.eff_bw ||
	    old_bw.max_bw != ifp-&gt;if_input_bw.max_bw)
		ifnet_update_rcv(ifp, CLASSQ_EV_LINK_BANDWIDTH);

	<span class="enscript-keyword">return</span> (0);
}

u_int64_t
<span class="enscript-function-name">ifnet_output_linkrate</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> ifclassq *ifq = &amp;ifp-&gt;if_snd;
	u_int64_t rate;

	IFCQ_LOCK_ASSERT_HELD(ifq);

	rate = ifp-&gt;if_output_bw.eff_bw;
	<span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq)) {
		u_int64_t tbr_rate = ifp-&gt;if_snd.ifcq_tbr.tbr_rate_raw;
		VERIFY(tbr_rate &gt; 0);
		rate = MIN(rate, ifp-&gt;if_snd.ifcq_tbr.tbr_rate_raw);
	}

	<span class="enscript-keyword">return</span> (rate);
}

u_int64_t
<span class="enscript-function-name">ifnet_input_linkrate</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-keyword">return</span> (ifp-&gt;if_input_bw.eff_bw);
}

errno_t
<span class="enscript-function-name">ifnet_bandwidths</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> if_bandwidths *output_bw,
    <span class="enscript-type">struct</span> if_bandwidths *input_bw)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (output_bw != NULL)
		*output_bw = ifp-&gt;if_output_bw;
	<span class="enscript-keyword">if</span> (input_bw != NULL)
		*input_bw = ifp-&gt;if_input_bw;

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_set_latencies</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> if_latencies *output_lt,
    <span class="enscript-type">struct</span> if_latencies *input_lt)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (output_lt != NULL)
		(<span class="enscript-type">void</span>) ifnet_set_output_latencies(ifp, output_lt, FALSE);

	<span class="enscript-keyword">if</span> (input_lt != NULL)
		(<span class="enscript-type">void</span>) ifnet_set_input_latencies(ifp, input_lt);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_set_output_latencies</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> if_latencies *lt,
    boolean_t locked)
{
	<span class="enscript-type">struct</span> if_latencies old_lt;
	<span class="enscript-type">struct</span> ifclassq *ifq;

	VERIFY(ifp != NULL &amp;&amp; lt != NULL);

	ifq = &amp;ifp-&gt;if_snd;
	<span class="enscript-keyword">if</span> (!locked)
		IFCQ_LOCK(ifq);
	IFCQ_LOCK_ASSERT_HELD(ifq);

	old_lt = ifp-&gt;if_output_lt;
	<span class="enscript-keyword">if</span> (lt-&gt;eff_lt != 0)
		ifp-&gt;if_output_lt.eff_lt = lt-&gt;eff_lt;
	<span class="enscript-keyword">if</span> (lt-&gt;max_lt != 0)
		ifp-&gt;if_output_lt.max_lt = lt-&gt;max_lt;
	<span class="enscript-keyword">if</span> (ifp-&gt;if_output_lt.eff_lt &gt; ifp-&gt;if_output_lt.max_lt)
		ifp-&gt;if_output_lt.max_lt = ifp-&gt;if_output_lt.eff_lt;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_output_lt.eff_lt == 0)
		ifp-&gt;if_output_lt.eff_lt = ifp-&gt;if_output_lt.max_lt;

	<span class="enscript-comment">/* Adjust queue parameters if needed */</span>
	<span class="enscript-keyword">if</span> (old_lt.eff_lt != ifp-&gt;if_output_lt.eff_lt ||
	    old_lt.max_lt != ifp-&gt;if_output_lt.max_lt)
		ifnet_update_sndq(ifq, CLASSQ_EV_LINK_LATENCY);

	<span class="enscript-keyword">if</span> (!locked)
		IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_set_input_latencies</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> if_latencies *lt)
{
	<span class="enscript-type">struct</span> if_latencies old_lt;

	VERIFY(ifp != NULL &amp;&amp; lt != NULL);

	old_lt = ifp-&gt;if_input_lt;
	<span class="enscript-keyword">if</span> (lt-&gt;eff_lt != 0)
		ifp-&gt;if_input_lt.eff_lt = lt-&gt;eff_lt;
	<span class="enscript-keyword">if</span> (lt-&gt;max_lt != 0)
		ifp-&gt;if_input_lt.max_lt = lt-&gt;max_lt;
	<span class="enscript-keyword">if</span> (ifp-&gt;if_input_lt.eff_lt &gt; ifp-&gt;if_input_lt.max_lt)
		ifp-&gt;if_input_lt.max_lt = ifp-&gt;if_input_lt.eff_lt;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_input_lt.eff_lt == 0)
		ifp-&gt;if_input_lt.eff_lt = ifp-&gt;if_input_lt.max_lt;

	<span class="enscript-keyword">if</span> (old_lt.eff_lt != ifp-&gt;if_input_lt.eff_lt ||
	    old_lt.max_lt != ifp-&gt;if_input_lt.max_lt)
		ifnet_update_rcv(ifp, CLASSQ_EV_LINK_LATENCY);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_latencies</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> if_latencies *output_lt,
    <span class="enscript-type">struct</span> if_latencies *input_lt)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (output_lt != NULL)
		*output_lt = ifp-&gt;if_output_lt;
	<span class="enscript-keyword">if</span> (input_lt != NULL)
		*input_lt = ifp-&gt;if_input_lt;

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_set_poll_params</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifnet_poll_params *p)
{
	errno_t err;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1))
		<span class="enscript-keyword">return</span> (ENXIO);

	err = dlil_rxpoll_set_params(ifp, p, FALSE);

	<span class="enscript-comment">/* Release the io ref count */</span>
	ifnet_decr_iorefcnt(ifp);

	<span class="enscript-keyword">return</span> (err);
}

errno_t
<span class="enscript-function-name">ifnet_poll_params</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifnet_poll_params *p)
{
	errno_t err;

	<span class="enscript-keyword">if</span> (ifp == NULL || p == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1))
		<span class="enscript-keyword">return</span> (ENXIO);

	err = dlil_rxpoll_get_params(ifp, p);

	<span class="enscript-comment">/* Release the io ref count */</span>
	ifnet_decr_iorefcnt(ifp);

	<span class="enscript-keyword">return</span> (err);
}

errno_t
<span class="enscript-function-name">ifnet_stat_increment</span>(<span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_stat_increment_param *s)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (s-&gt;packets_in != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_ipackets, s-&gt;packets_in);
	<span class="enscript-keyword">if</span> (s-&gt;bytes_in != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_ibytes, s-&gt;bytes_in);
	<span class="enscript-keyword">if</span> (s-&gt;errors_in != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_ierrors, s-&gt;errors_in);

	<span class="enscript-keyword">if</span> (s-&gt;packets_out != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_opackets, s-&gt;packets_out);
	<span class="enscript-keyword">if</span> (s-&gt;bytes_out != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_obytes, s-&gt;bytes_out);
	<span class="enscript-keyword">if</span> (s-&gt;errors_out != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_oerrors, s-&gt;errors_out);

	<span class="enscript-keyword">if</span> (s-&gt;collisions != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_collisions, s-&gt;collisions);
	<span class="enscript-keyword">if</span> (s-&gt;dropped != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_iqdrops, s-&gt;dropped);

	<span class="enscript-comment">/* Touch the last change time. */</span>
	TOUCHLASTCHANGE(&amp;ifp-&gt;if_lastchange);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_stat_increment_in</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t packets_in,
    u_int32_t bytes_in, u_int32_t errors_in)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (packets_in != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_ipackets, packets_in);
	<span class="enscript-keyword">if</span> (bytes_in != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_ibytes, bytes_in);
	<span class="enscript-keyword">if</span> (errors_in != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_ierrors, errors_in);

	TOUCHLASTCHANGE(&amp;ifp-&gt;if_lastchange);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_stat_increment_out</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t packets_out,
    u_int32_t bytes_out, u_int32_t errors_out)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (packets_out != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_opackets, packets_out);
	<span class="enscript-keyword">if</span> (bytes_out != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_obytes, bytes_out);
	<span class="enscript-keyword">if</span> (errors_out != 0)
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_oerrors, errors_out);

	TOUCHLASTCHANGE(&amp;ifp-&gt;if_lastchange);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_set_stat</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_stats_param *s)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	atomic_set_64(&amp;ifp-&gt;if_data.ifi_ipackets, s-&gt;packets_in);
	atomic_set_64(&amp;ifp-&gt;if_data.ifi_ibytes, s-&gt;bytes_in);
	atomic_set_64(&amp;ifp-&gt;if_data.ifi_imcasts, s-&gt;multicasts_in);
	atomic_set_64(&amp;ifp-&gt;if_data.ifi_ierrors, s-&gt;errors_in);

	atomic_set_64(&amp;ifp-&gt;if_data.ifi_opackets, s-&gt;packets_out);
	atomic_set_64(&amp;ifp-&gt;if_data.ifi_obytes, s-&gt;bytes_out);
	atomic_set_64(&amp;ifp-&gt;if_data.ifi_omcasts, s-&gt;multicasts_out);
	atomic_set_64(&amp;ifp-&gt;if_data.ifi_oerrors, s-&gt;errors_out);

	atomic_set_64(&amp;ifp-&gt;if_data.ifi_collisions, s-&gt;collisions);
	atomic_set_64(&amp;ifp-&gt;if_data.ifi_iqdrops, s-&gt;dropped);
	atomic_set_64(&amp;ifp-&gt;if_data.ifi_noproto, s-&gt;no_protocol);

	<span class="enscript-comment">/* Touch the last change time. */</span>
	TOUCHLASTCHANGE(&amp;ifp-&gt;if_lastchange);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_stat</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifnet_stats_param *s)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	atomic_get_64(s-&gt;packets_in, &amp;ifp-&gt;if_data.ifi_ipackets);
	atomic_get_64(s-&gt;bytes_in, &amp;ifp-&gt;if_data.ifi_ibytes);
	atomic_get_64(s-&gt;multicasts_in, &amp;ifp-&gt;if_data.ifi_imcasts);
	atomic_get_64(s-&gt;errors_in, &amp;ifp-&gt;if_data.ifi_ierrors);

	atomic_get_64(s-&gt;packets_out, &amp;ifp-&gt;if_data.ifi_opackets);
	atomic_get_64(s-&gt;bytes_out, &amp;ifp-&gt;if_data.ifi_obytes);
	atomic_get_64(s-&gt;multicasts_out, &amp;ifp-&gt;if_data.ifi_omcasts);
	atomic_get_64(s-&gt;errors_out, &amp;ifp-&gt;if_data.ifi_oerrors);

	atomic_get_64(s-&gt;collisions, &amp;ifp-&gt;if_data.ifi_collisions);
	atomic_get_64(s-&gt;dropped, &amp;ifp-&gt;if_data.ifi_iqdrops);
	atomic_get_64(s-&gt;no_protocol, &amp;ifp-&gt;if_data.ifi_noproto);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_touch_lastchange</span>(ifnet_t interface)
{
	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	TOUCHLASTCHANGE(&amp;interface-&gt;if_lastchange);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_lastchange</span>(ifnet_t interface, <span class="enscript-type">struct</span> timeval *last_change)
{
	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	*last_change = interface-&gt;if_data.ifi_lastchange;
	<span class="enscript-comment">/* Crude conversion from uptime to calendar time */</span>
	last_change-&gt;tv_sec += boottime_sec();

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_get_address_list</span>(ifnet_t interface, ifaddr_t **addresses)
{
	<span class="enscript-keyword">return</span> (addresses == NULL ? EINVAL :
	    ifnet_get_address_list_family(interface, addresses, 0));
}

<span class="enscript-type">struct</span> ifnet_addr_list {
	SLIST_ENTRY(ifnet_addr_list)	ifal_le;
	<span class="enscript-type">struct</span> ifaddr			*ifal_ifa;
};

errno_t
<span class="enscript-function-name">ifnet_get_address_list_family</span>(ifnet_t interface, ifaddr_t **addresses,
    sa_family_t family)
{
	<span class="enscript-keyword">return</span> (ifnet_get_address_list_family_internal(interface, addresses,
	    family, 0, M_NOWAIT, 0));
}

errno_t
<span class="enscript-function-name">ifnet_get_inuse_address_list</span>(ifnet_t interface, ifaddr_t **addresses)
{
	<span class="enscript-keyword">return</span> (addresses == NULL ? EINVAL :
		ifnet_get_address_list_family_internal(interface, addresses,
		0, 0, M_NOWAIT, 1));
}

<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">tcp_find_anypcb_byaddr</span>(<span class="enscript-type">struct</span> ifaddr *ifa);

<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">udp_find_anypcb_byaddr</span>(<span class="enscript-type">struct</span> ifaddr *ifa);

__private_extern__ errno_t
<span class="enscript-function-name">ifnet_get_address_list_family_internal</span>(ifnet_t interface, ifaddr_t **addresses,
    sa_family_t family, <span class="enscript-type">int</span> detached, <span class="enscript-type">int</span> how, <span class="enscript-type">int</span> return_inuse_addrs)
{
	SLIST_HEAD(, ifnet_addr_list) ifal_head;
	<span class="enscript-type">struct</span> ifnet_addr_list *ifal, *ifal_tmp;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">int</span> count = 0;
	errno_t err = 0;
	<span class="enscript-type">int</span> usecount = 0;
	<span class="enscript-type">int</span> index = 0;

	SLIST_INIT(&amp;ifal_head);

	<span class="enscript-keyword">if</span> (addresses == NULL) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	*addresses = NULL;

	<span class="enscript-keyword">if</span> (detached) {
		<span class="enscript-comment">/*
		 * Interface has been detached, so skip the lookup
		 * at ifnet_head and go directly to inner loop.
		 */</span>
		ifp = interface;
		<span class="enscript-keyword">if</span> (ifp == NULL) {
			err = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">one</span>;
	}

	ifnet_head_lock_shared();
	TAILQ_FOREACH(ifp, &amp;ifnet_head, if_link) {
		<span class="enscript-keyword">if</span> (interface != NULL &amp;&amp; ifp != interface)
			<span class="enscript-keyword">continue</span>;
<span class="enscript-reference">one</span>:
		ifnet_lock_shared(ifp);
		<span class="enscript-keyword">if</span> (interface == NULL || interface == ifp) {
			<span class="enscript-type">struct</span> ifaddr *ifa;
			TAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrhead, ifa_link) {
				IFA_LOCK(ifa);
				<span class="enscript-keyword">if</span> (family != 0 &amp;&amp;
				    ifa-&gt;ifa_addr-&gt;sa_family != family) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				MALLOC(ifal, <span class="enscript-type">struct</span> ifnet_addr_list *,
				    <span class="enscript-keyword">sizeof</span> (*ifal), M_TEMP, how);
				<span class="enscript-keyword">if</span> (ifal == NULL) {
					IFA_UNLOCK(ifa);
					ifnet_lock_done(ifp);
					<span class="enscript-keyword">if</span> (!detached)
						ifnet_head_done();
					err = ENOMEM;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
				ifal-&gt;ifal_ifa = ifa;
				IFA_ADDREF_LOCKED(ifa);
				SLIST_INSERT_HEAD(&amp;ifal_head, ifal, ifal_le);
				++count;
				IFA_UNLOCK(ifa);
			}
		}
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">if</span> (detached)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (!detached)
		ifnet_head_done();

	<span class="enscript-keyword">if</span> (count == 0) {
		err = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	MALLOC(*addresses, ifaddr_t *, <span class="enscript-keyword">sizeof</span> (ifaddr_t) * (count + 1),
	    M_TEMP, how);
	<span class="enscript-keyword">if</span> (*addresses == NULL) {
		err = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	bzero(*addresses, <span class="enscript-keyword">sizeof</span> (ifaddr_t) * (count + 1));

<span class="enscript-reference">done</span>:
	SLIST_FOREACH_SAFE(ifal, &amp;ifal_head, ifal_le, ifal_tmp) {
		SLIST_REMOVE(&amp;ifal_head, ifal, ifnet_addr_list, ifal_le);
		<span class="enscript-keyword">if</span> (err == 0) {
			<span class="enscript-keyword">if</span> (return_inuse_addrs) {
				usecount = tcp_find_anypcb_byaddr(ifal-&gt;ifal_ifa);
				usecount += udp_find_anypcb_byaddr(ifal-&gt;ifal_ifa);
				<span class="enscript-keyword">if</span> (usecount) {
					(*addresses)[index] = ifal-&gt;ifal_ifa;
					index++;
				} <span class="enscript-keyword">else</span> {
					IFA_REMREF(ifal-&gt;ifal_ifa);
				}
			} <span class="enscript-keyword">else</span> {
				(*addresses)[--count] = ifal-&gt;ifal_ifa;
			}
		} <span class="enscript-keyword">else</span> {
			IFA_REMREF(ifal-&gt;ifal_ifa);
		}
		FREE(ifal, M_TEMP);
	}

	VERIFY(err == 0 || *addresses == NULL);
	<span class="enscript-keyword">if</span> ((err == 0) &amp;&amp; (count) &amp;&amp; ((*addresses)[0] == NULL)) {
		VERIFY(return_inuse_addrs == 1);
		FREE(*addresses, M_TEMP);
		err = ENXIO;
	}
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_free_address_list</span>(ifaddr_t *addresses)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (addresses == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">for</span> (i = 0; addresses[i] != NULL; i++)
		IFA_REMREF(addresses[i]);

	FREE(addresses, M_TEMP);
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">ifnet_lladdr</span>(ifnet_t interface)
{
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">void</span> *lladdr;

	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-comment">/*
	 * if_lladdr points to the permanent link address of
	 * the interface and it never gets deallocated; internal
	 * code should simply use IF_LLADDR() for performance.
	 */</span>
	ifa = interface-&gt;if_lladdr;
	IFA_LOCK_SPIN(ifa);
	lladdr = LLADDR(SDL((<span class="enscript-type">void</span> *)ifa-&gt;ifa_addr));
	IFA_UNLOCK(ifa);

	<span class="enscript-keyword">return</span> (lladdr);
}

errno_t
<span class="enscript-function-name">ifnet_llbroadcast_copy_bytes</span>(ifnet_t interface, <span class="enscript-type">void</span> *addr, size_t buffer_len,
    size_t *out_len)
{
	<span class="enscript-keyword">if</span> (interface == NULL || addr == NULL || out_len == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	*out_len = interface-&gt;if_broadcast.length;

	<span class="enscript-keyword">if</span> (buffer_len &lt; interface-&gt;if_broadcast.length)
		<span class="enscript-keyword">return</span> (EMSGSIZE);

	<span class="enscript-keyword">if</span> (interface-&gt;if_broadcast.length == 0)
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (interface-&gt;if_broadcast.length &lt;=
	    <span class="enscript-keyword">sizeof</span> (interface-&gt;if_broadcast.u.buffer)) {
		bcopy(interface-&gt;if_broadcast.u.buffer, addr,
		    interface-&gt;if_broadcast.length);
	} <span class="enscript-keyword">else</span> {
		bcopy(interface-&gt;if_broadcast.u.ptr, addr,
		    interface-&gt;if_broadcast.length);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifnet_lladdr_copy_bytes_internal</span>(ifnet_t interface, <span class="enscript-type">void</span> *lladdr,
    size_t lladdr_len, kauth_cred_t *credp)
{
	<span class="enscript-type">const</span> u_int8_t *bytes;
	size_t bytes_len;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	uint8_t sdlbuf[SOCK_MAXADDRLEN + 1];
	errno_t error = 0;

	<span class="enscript-comment">/*
	 * Make sure to accomodate the largest possible
	 * size of SA(if_lladdr)-&gt;sa_len.
	 */</span>
	_CASSERT(<span class="enscript-keyword">sizeof</span> (sdlbuf) == (SOCK_MAXADDRLEN + 1));

	<span class="enscript-keyword">if</span> (interface == NULL || lladdr == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifa = interface-&gt;if_lladdr;
	IFA_LOCK_SPIN(ifa);
	bcopy(ifa-&gt;ifa_addr, &amp;sdlbuf, SDL(ifa-&gt;ifa_addr)-&gt;sdl_len);
	IFA_UNLOCK(ifa);

	bytes = dlil_ifaddr_bytes(SDL(&amp;sdlbuf), &amp;bytes_len, credp);
	<span class="enscript-keyword">if</span> (bytes_len != lladdr_len) {
		bzero(lladdr, lladdr_len);
		error = EMSGSIZE;
	} <span class="enscript-keyword">else</span> {
		bcopy(bytes, lladdr, bytes_len);
	}

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">ifnet_lladdr_copy_bytes</span>(ifnet_t interface, <span class="enscript-type">void</span> *lladdr, size_t length)
{
	<span class="enscript-keyword">return</span> (ifnet_lladdr_copy_bytes_internal(interface, lladdr, length,
	    NULL));
}

errno_t
<span class="enscript-function-name">ifnet_guarded_lladdr_copy_bytes</span>(ifnet_t interface, <span class="enscript-type">void</span> *lladdr, size_t length)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	kauth_cred_t cred;
	net_thread_marks_t marks;
#<span class="enscript-reference">endif</span>
	kauth_cred_t *credp;
	errno_t error;

	credp = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	marks = net_thread_marks_push(NET_THREAD_CKREQ_LLADDR);
	cred = kauth_cred_proc_ref(current_proc());
	credp = &amp;cred;
#<span class="enscript-reference">else</span>
	credp = NULL;
#<span class="enscript-reference">endif</span>

	error = ifnet_lladdr_copy_bytes_internal(interface, lladdr, length,
	    credp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	kauth_cred_unref(credp);
	net_thread_marks_pop(marks);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifnet_set_lladdr_internal</span>(ifnet_t interface, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *lladdr,
    size_t lladdr_len, u_char new_type, <span class="enscript-type">int</span> apply_type)
{
	<span class="enscript-type">struct</span> ifaddr *ifa;
	errno_t	error = 0;

	<span class="enscript-keyword">if</span> (interface == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifnet_head_lock_shared();
	ifnet_lock_exclusive(interface);
	<span class="enscript-keyword">if</span> (lladdr_len != 0 &amp;&amp;
	    (lladdr_len != interface-&gt;if_addrlen || lladdr == 0)) {
		ifnet_lock_done(interface);
		ifnet_head_done();
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	ifa = ifnet_addrs[interface-&gt;if_index - 1];
	<span class="enscript-keyword">if</span> (ifa != NULL) {
		<span class="enscript-type">struct</span> sockaddr_dl *sdl;

		IFA_LOCK_SPIN(ifa);
		sdl = (<span class="enscript-type">struct</span> sockaddr_dl *)(<span class="enscript-type">void</span> *)ifa-&gt;ifa_addr;
		<span class="enscript-keyword">if</span> (lladdr_len != 0) {
			bcopy(lladdr, LLADDR(sdl), lladdr_len);
		} <span class="enscript-keyword">else</span> {
			bzero(LLADDR(sdl), interface-&gt;if_addrlen);
		}
		sdl-&gt;sdl_alen = lladdr_len;

		<span class="enscript-keyword">if</span> (apply_type) {
			sdl-&gt;sdl_type = new_type;
		}
		IFA_UNLOCK(ifa);
	} <span class="enscript-keyword">else</span> {
		error = ENXIO;
	}
	ifnet_lock_done(interface);
	ifnet_head_done();

	<span class="enscript-comment">/* Generate a kernel event */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		dlil_post_msg(interface, KEV_DL_SUBCLASS,
		    KEV_DL_LINK_ADDRESS_CHANGED, NULL, 0);
	}

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">ifnet_set_lladdr</span>(ifnet_t interface, <span class="enscript-type">const</span> <span class="enscript-type">void</span>* lladdr, size_t lladdr_len)
{
	<span class="enscript-keyword">return</span> (ifnet_set_lladdr_internal(interface, lladdr, lladdr_len, 0, 0));
}

errno_t
<span class="enscript-function-name">ifnet_set_lladdr_and_type</span>(ifnet_t interface, <span class="enscript-type">const</span> <span class="enscript-type">void</span>* lladdr,
    size_t lladdr_len, u_char type)
{
	<span class="enscript-keyword">return</span> (ifnet_set_lladdr_internal(interface, lladdr,
	    lladdr_len, type, 1));
}

errno_t
<span class="enscript-function-name">ifnet_add_multicast</span>(ifnet_t interface, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *maddr,
    ifmultiaddr_t *ifmap)
{
	<span class="enscript-keyword">if</span> (interface == NULL || maddr == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* Don't let users screw up protocols' entries. */</span>
	<span class="enscript-keyword">if</span> (maddr-&gt;sa_family != AF_UNSPEC &amp;&amp; maddr-&gt;sa_family != AF_LINK)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (if_addmulti_anon(interface, maddr, ifmap));
}

errno_t
<span class="enscript-function-name">ifnet_remove_multicast</span>(ifmultiaddr_t ifma)
{
	<span class="enscript-type">struct</span> sockaddr *maddr;

	<span class="enscript-keyword">if</span> (ifma == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	maddr = ifma-&gt;ifma_addr;
	<span class="enscript-comment">/* Don't let users screw up protocols' entries. */</span>
	<span class="enscript-keyword">if</span> (maddr-&gt;sa_family != AF_UNSPEC &amp;&amp; maddr-&gt;sa_family != AF_LINK)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (if_delmulti_anon(ifma-&gt;ifma_ifp, maddr));
}

errno_t
<span class="enscript-function-name">ifnet_get_multicast_list</span>(ifnet_t ifp, ifmultiaddr_t **addresses)
{
	<span class="enscript-type">int</span> count = 0;
	<span class="enscript-type">int</span> cmax = 0;
	<span class="enscript-type">struct</span> ifmultiaddr *addr;

	<span class="enscript-keyword">if</span> (ifp == NULL || addresses == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifnet_lock_shared(ifp);
	LIST_FOREACH(addr, &amp;ifp-&gt;if_multiaddrs, ifma_link) {
		cmax++;
	}

	MALLOC(*addresses, ifmultiaddr_t *, <span class="enscript-keyword">sizeof</span> (ifmultiaddr_t) * (cmax + 1),
	    M_TEMP, M_NOWAIT);
	<span class="enscript-keyword">if</span> (*addresses == NULL) {
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	LIST_FOREACH(addr, &amp;ifp-&gt;if_multiaddrs, ifma_link) {
		<span class="enscript-keyword">if</span> (count + 1 &gt; cmax)
			<span class="enscript-keyword">break</span>;
		(*addresses)[count] = (ifmultiaddr_t)addr;
		ifmaddr_reference((*addresses)[count]);
		count++;
	}
	(*addresses)[cmax] = NULL;
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_free_multicast_list</span>(ifmultiaddr_t *addresses)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (addresses == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">for</span> (i = 0; addresses[i] != NULL; i++)
		ifmaddr_release(addresses[i]);

	FREE(addresses, M_TEMP);
}

errno_t
<span class="enscript-function-name">ifnet_find_by_name</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *ifname, ifnet_t *ifpp)
{
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">int</span>	namelen;

	<span class="enscript-keyword">if</span> (ifname == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	namelen = strlen(ifname);

	*ifpp = NULL;

	ifnet_head_lock_shared();
	TAILQ_FOREACH(ifp, &amp;ifnet_head, if_link) {
		<span class="enscript-type">struct</span> ifaddr *ifa;
		<span class="enscript-type">struct</span> sockaddr_dl *ll_addr;

		ifa = ifnet_addrs[ifp-&gt;if_index - 1];
		<span class="enscript-keyword">if</span> (ifa == NULL)
			<span class="enscript-keyword">continue</span>;

		IFA_LOCK(ifa);
		ll_addr = (<span class="enscript-type">struct</span> sockaddr_dl *)(<span class="enscript-type">void</span> *)ifa-&gt;ifa_addr;

		<span class="enscript-keyword">if</span> (namelen == ll_addr-&gt;sdl_nlen &amp;&amp; strncmp(ll_addr-&gt;sdl_data,
		    ifname, ll_addr-&gt;sdl_nlen) == 0) {
			IFA_UNLOCK(ifa);
			*ifpp = ifp;
			ifnet_reference(*ifpp);
			<span class="enscript-keyword">break</span>;
		}
		IFA_UNLOCK(ifa);
	}
	ifnet_head_done();

	<span class="enscript-keyword">return</span> ((ifp == NULL) ? ENXIO : 0);
}

errno_t
<span class="enscript-function-name">ifnet_list_get</span>(ifnet_family_t family, ifnet_t **list, u_int32_t *count)
{
	<span class="enscript-keyword">return</span> (ifnet_list_get_common(family, FALSE, list, count));
}

__private_extern__ errno_t
<span class="enscript-function-name">ifnet_list_get_all</span>(ifnet_family_t family, ifnet_t **list, u_int32_t *count)
{
	<span class="enscript-keyword">return</span> (ifnet_list_get_common(family, TRUE, list, count));
}

<span class="enscript-type">struct</span> ifnet_list {
	SLIST_ENTRY(ifnet_list)	ifl_le;
	<span class="enscript-type">struct</span> ifnet		*ifl_ifp;
};

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifnet_list_get_common</span>(ifnet_family_t family, boolean_t get_all, ifnet_t **list,
    u_int32_t *count)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">get_all</span>)
	SLIST_HEAD(, ifnet_list) ifl_head;
	<span class="enscript-type">struct</span> ifnet_list *ifl, *ifl_tmp;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">int</span> cnt = 0;
	errno_t err = 0;

	SLIST_INIT(&amp;ifl_head);

	<span class="enscript-keyword">if</span> (list == NULL || count == NULL) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	*count = 0;
	*list = NULL;

	ifnet_head_lock_shared();
	TAILQ_FOREACH(ifp, &amp;ifnet_head, if_link) {
		<span class="enscript-keyword">if</span> (family == IFNET_FAMILY_ANY || ifp-&gt;if_family == family) {
			MALLOC(ifl, <span class="enscript-type">struct</span> ifnet_list *, <span class="enscript-keyword">sizeof</span> (*ifl),
			    M_TEMP, M_NOWAIT);
			<span class="enscript-keyword">if</span> (ifl == NULL) {
				ifnet_head_done();
				err = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			ifl-&gt;ifl_ifp = ifp;
			ifnet_reference(ifp);
			SLIST_INSERT_HEAD(&amp;ifl_head, ifl, ifl_le);
			++cnt;
		}
	}
	ifnet_head_done();

	<span class="enscript-keyword">if</span> (cnt == 0) {
		err = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	MALLOC(*list, ifnet_t *, <span class="enscript-keyword">sizeof</span> (ifnet_t) * (cnt + 1),
	    M_TEMP, M_NOWAIT);
	<span class="enscript-keyword">if</span> (*list == NULL) {
		err = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	bzero(*list, <span class="enscript-keyword">sizeof</span> (ifnet_t) * (cnt + 1));
	*count = cnt;

<span class="enscript-reference">done</span>:
	SLIST_FOREACH_SAFE(ifl, &amp;ifl_head, ifl_le, ifl_tmp) {
		SLIST_REMOVE(&amp;ifl_head, ifl, ifnet_list, ifl_le);
		<span class="enscript-keyword">if</span> (err == 0)
			(*list)[--cnt] = ifl-&gt;ifl_ifp;
		<span class="enscript-keyword">else</span>
			ifnet_release(ifl-&gt;ifl_ifp);
		FREE(ifl, M_TEMP);
	}

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_list_free</span>(ifnet_t *interfaces)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (interfaces == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">for</span> (i = 0; interfaces[i]; i++)
		ifnet_release(interfaces[i]);

	FREE(interfaces, M_TEMP);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_transmit_burst_start</span>(ifnet_t ifp, mbuf_t pkt)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MEASURE_BW</span>
	uint32_t orig_flags;

	<span class="enscript-keyword">if</span> (ifp == NULL || !(pkt-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span>;

	orig_flags = OSBitOrAtomic(IF_MEASURED_BW_INPROGRESS,
	    &amp;ifp-&gt;if_bw.flags);
	<span class="enscript-keyword">if</span> (orig_flags &amp; IF_MEASURED_BW_INPROGRESS) {
		<span class="enscript-comment">/* There is already a measurement in progress; skip this one */</span>
		<span class="enscript-keyword">return</span>;
	}

	ifp-&gt;if_bw.start_seq = pkt-&gt;m_pkthdr.pkt_bwseq;
	ifp-&gt;if_bw.start_ts = mach_absolute_time();
#<span class="enscript-reference">else</span> <span class="enscript-comment">/*!MEASURE_BW */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">pkt</span>)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !MEASURE_BW */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_transmit_burst_end</span>(ifnet_t ifp, mbuf_t pkt)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MEASURE_BW</span>
	uint64_t oseq, ots, bytes, ts, t;
	uint32_t flags;

	<span class="enscript-keyword">if</span> (ifp == NULL || !(pkt-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span>;

	flags = OSBitOrAtomic(IF_MEASURED_BW_CALCULATION, &amp;ifp-&gt;if_bw.flags);

	<span class="enscript-comment">/* If a calculation is already in progress, just return */</span>
	<span class="enscript-keyword">if</span> (flags &amp; IF_MEASURED_BW_CALCULATION)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Check if a measurement was started at all */</span>
	<span class="enscript-keyword">if</span> (!(flags &amp; IF_MEASURED_BW_INPROGRESS)) {
		<span class="enscript-comment">/*
		 * It is an error to call burst_end before burst_start.
		 * Reset the calculation flag and return.
		 */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	oseq = pkt-&gt;m_pkthdr.pkt_bwseq;
	ots = mach_absolute_time();

	<span class="enscript-keyword">if</span> (ifp-&gt;if_bw.start_seq &gt; 0 &amp;&amp; oseq &gt; ifp-&gt;if_bw.start_seq) {
		ts = ots - ifp-&gt;if_bw.start_ts;
		<span class="enscript-keyword">if</span> (ts &gt; 0) {
			absolutetime_to_nanoseconds(ts, &amp;t);
			bytes = oseq - ifp-&gt;if_bw.start_seq;
			ifp-&gt;if_bw.bytes = bytes;
			ifp-&gt;if_bw.ts = ts;

			<span class="enscript-keyword">if</span> (t &gt; 0) {
				uint64_t bw = 0;

				<span class="enscript-comment">/* Compute bandwidth as bytes/ms */</span>
				bw = (bytes * NSEC_PER_MSEC) / t;
				<span class="enscript-keyword">if</span> (bw &gt; 0) {
					<span class="enscript-keyword">if</span> (ifp-&gt;if_bw.bw &gt; 0) {
						u_int32_t shft;

						shft = if_bw_smoothing_val;
						<span class="enscript-comment">/* Compute EWMA of bw */</span>
						ifp-&gt;if_bw.bw = (bw +
						    ((ifp-&gt;if_bw.bw &lt;&lt; shft) -
						    ifp-&gt;if_bw.bw)) &gt;&gt; shft;
					} <span class="enscript-keyword">else</span> {
						ifp-&gt;if_bw.bw = bw;
					}
				}
			}
			ifp-&gt;if_bw.last_seq = oseq;
			ifp-&gt;if_bw.last_ts = ots;
		}
	}

<span class="enscript-reference">done</span>:
	flags = ~(IF_MEASURED_BW_INPROGRESS | IF_MEASURED_BW_CALCULATION);
	OSBitAndAtomic(flags, &amp;ifp-&gt;if_bw.flags);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !MEASURE_BW */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">pkt</span>)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !MEASURE_BW */</span>
}

<span class="enscript-comment">/****************************************************************************/</span>
<span class="enscript-comment">/* ifaddr_t accessors							    */</span>
<span class="enscript-comment">/****************************************************************************/</span>

errno_t
<span class="enscript-function-name">ifaddr_reference</span>(ifaddr_t ifa)
{
	<span class="enscript-keyword">if</span> (ifa == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	IFA_ADDREF(ifa);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifaddr_release</span>(ifaddr_t ifa)
{
	<span class="enscript-keyword">if</span> (ifa == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	IFA_REMREF(ifa);
	<span class="enscript-keyword">return</span> (0);
}

sa_family_t
<span class="enscript-function-name">ifaddr_address_family</span>(ifaddr_t ifa)
{
	sa_family_t family = 0;

	<span class="enscript-keyword">if</span> (ifa != NULL) {
		IFA_LOCK_SPIN(ifa);
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr != NULL)
			family = ifa-&gt;ifa_addr-&gt;sa_family;
		IFA_UNLOCK(ifa);
	}
	<span class="enscript-keyword">return</span> (family);
}

errno_t
<span class="enscript-function-name">ifaddr_address</span>(ifaddr_t ifa, <span class="enscript-type">struct</span> sockaddr *out_addr, u_int32_t addr_size)
{
	u_int32_t copylen;

	<span class="enscript-keyword">if</span> (ifa == NULL || out_addr == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	IFA_LOCK_SPIN(ifa);
	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr == NULL) {
		IFA_UNLOCK(ifa);
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}

	copylen = (addr_size &gt;= ifa-&gt;ifa_addr-&gt;sa_len) ?
	    ifa-&gt;ifa_addr-&gt;sa_len : addr_size;
	bcopy(ifa-&gt;ifa_addr, out_addr, copylen);

	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_len &gt; addr_size) {
		IFA_UNLOCK(ifa);
		<span class="enscript-keyword">return</span> (EMSGSIZE);
	}

	IFA_UNLOCK(ifa);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifaddr_dstaddress</span>(ifaddr_t ifa, <span class="enscript-type">struct</span> sockaddr *out_addr, u_int32_t addr_size)
{
	u_int32_t copylen;

	<span class="enscript-keyword">if</span> (ifa == NULL || out_addr == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	IFA_LOCK_SPIN(ifa);
	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_dstaddr == NULL) {
		IFA_UNLOCK(ifa);
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}

	copylen = (addr_size &gt;= ifa-&gt;ifa_dstaddr-&gt;sa_len) ?
	    ifa-&gt;ifa_dstaddr-&gt;sa_len : addr_size;
	bcopy(ifa-&gt;ifa_dstaddr, out_addr, copylen);

	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_dstaddr-&gt;sa_len &gt; addr_size) {
		IFA_UNLOCK(ifa);
		<span class="enscript-keyword">return</span> (EMSGSIZE);
	}

	IFA_UNLOCK(ifa);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifaddr_netmask</span>(ifaddr_t ifa, <span class="enscript-type">struct</span> sockaddr *out_addr, u_int32_t addr_size)
{
	u_int32_t copylen;

	<span class="enscript-keyword">if</span> (ifa == NULL || out_addr == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	IFA_LOCK_SPIN(ifa);
	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_netmask == NULL) {
		IFA_UNLOCK(ifa);
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}

	copylen = addr_size &gt;= ifa-&gt;ifa_netmask-&gt;sa_len ?
	    ifa-&gt;ifa_netmask-&gt;sa_len : addr_size;
	bcopy(ifa-&gt;ifa_netmask, out_addr, copylen);

	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_netmask-&gt;sa_len &gt; addr_size) {
		IFA_UNLOCK(ifa);
		<span class="enscript-keyword">return</span> (EMSGSIZE);
	}

	IFA_UNLOCK(ifa);
	<span class="enscript-keyword">return</span> (0);
}

ifnet_t
<span class="enscript-function-name">ifaddr_ifnet</span>(ifaddr_t ifa)
{
	<span class="enscript-type">struct</span> ifnet *ifp;

	<span class="enscript-keyword">if</span> (ifa == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-comment">/* ifa_ifp is set once at creation time; it is never changed */</span>
	ifp = ifa-&gt;ifa_ifp;

	<span class="enscript-keyword">return</span> (ifp);
}

ifaddr_t
<span class="enscript-function-name">ifaddr_withaddr</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *address)
{
	<span class="enscript-keyword">if</span> (address == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">return</span> (ifa_ifwithaddr(address));
}

ifaddr_t
<span class="enscript-function-name">ifaddr_withdstaddr</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *address)
{
	<span class="enscript-keyword">if</span> (address == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">return</span> (ifa_ifwithdstaddr(address));
}

ifaddr_t
<span class="enscript-function-name">ifaddr_withnet</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *net)
{
	<span class="enscript-keyword">if</span> (net == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">return</span> (ifa_ifwithnet(net));
}

ifaddr_t
<span class="enscript-function-name">ifaddr_withroute</span>(<span class="enscript-type">int</span> flags, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *destination,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *gateway)
{
	<span class="enscript-keyword">if</span> (destination == NULL || gateway == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">return</span> (ifa_ifwithroute(flags, destination, gateway));
}

ifaddr_t
<span class="enscript-function-name">ifaddr_findbestforaddr</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *addr, ifnet_t interface)
{
	<span class="enscript-keyword">if</span> (addr == NULL || interface == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">return</span> (ifaof_ifpforaddr(addr, interface));
}

errno_t
<span class="enscript-function-name">ifmaddr_reference</span>(ifmultiaddr_t ifmaddr)
{
	<span class="enscript-keyword">if</span> (ifmaddr == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	IFMA_ADDREF(ifmaddr);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifmaddr_release</span>(ifmultiaddr_t ifmaddr)
{
	<span class="enscript-keyword">if</span> (ifmaddr == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	IFMA_REMREF(ifmaddr);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifmaddr_address</span>(ifmultiaddr_t ifma, <span class="enscript-type">struct</span> sockaddr *out_addr,
    u_int32_t addr_size)
{
	u_int32_t copylen;

	<span class="enscript-keyword">if</span> (ifma == NULL || out_addr == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	IFMA_LOCK(ifma);
	<span class="enscript-keyword">if</span> (ifma-&gt;ifma_addr == NULL) {
		IFMA_UNLOCK(ifma);
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}

	copylen = (addr_size &gt;= ifma-&gt;ifma_addr-&gt;sa_len ?
	    ifma-&gt;ifma_addr-&gt;sa_len : addr_size);
	bcopy(ifma-&gt;ifma_addr, out_addr, copylen);

	<span class="enscript-keyword">if</span> (ifma-&gt;ifma_addr-&gt;sa_len &gt; addr_size) {
		IFMA_UNLOCK(ifma);
		<span class="enscript-keyword">return</span> (EMSGSIZE);
	}
	IFMA_UNLOCK(ifma);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifmaddr_lladdress</span>(ifmultiaddr_t ifma, <span class="enscript-type">struct</span> sockaddr *out_addr,
    u_int32_t addr_size)
{
	<span class="enscript-type">struct</span> ifmultiaddr *ifma_ll;

	<span class="enscript-keyword">if</span> (ifma == NULL || out_addr == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> ((ifma_ll = ifma-&gt;ifma_ll) == NULL)
		<span class="enscript-keyword">return</span> (ENOTSUP);

	<span class="enscript-keyword">return</span> (ifmaddr_address(ifma_ll, out_addr, addr_size));
}

ifnet_t
<span class="enscript-function-name">ifmaddr_ifnet</span>(ifmultiaddr_t ifma)
{
	<span class="enscript-keyword">return</span> ((ifma == NULL) ? NULL : ifma-&gt;ifma_ifp);
}

<span class="enscript-comment">/******************************************************************************/</span>
<span class="enscript-comment">/* interface cloner                                                           */</span>
<span class="enscript-comment">/******************************************************************************/</span>

errno_t
<span class="enscript-function-name">ifnet_clone_attach</span>(<span class="enscript-type">struct</span> ifnet_clone_params *cloner_params,
    if_clone_t *ifcloner)
{
	errno_t error = 0;
	<span class="enscript-type">struct</span> if_clone *ifc = NULL;
	size_t namelen;

	<span class="enscript-keyword">if</span> (cloner_params == NULL || ifcloner == NULL ||
	    cloner_params-&gt;ifc_name == NULL ||
	    cloner_params-&gt;ifc_create == NULL ||
	    cloner_params-&gt;ifc_destroy == NULL ||
	    (namelen = strlen(cloner_params-&gt;ifc_name)) &gt;= IFNAMSIZ) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-keyword">if</span> (if_clone_lookup(cloner_params-&gt;ifc_name, NULL) != NULL) {
		printf(<span class="enscript-string">&quot;%s: already a cloner for %s\n&quot;</span>, __func__,
		    cloner_params-&gt;ifc_name);
		error = EEXIST;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">/* Make room for name string */</span>
	ifc = _MALLOC(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> if_clone) + IFNAMSIZ + 1, M_CLONE,
	    M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (ifc == NULL) {
		printf(<span class="enscript-string">&quot;%s: _MALLOC failed\n&quot;</span>, __func__);
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	strlcpy((<span class="enscript-type">char</span> *)(ifc + 1), cloner_params-&gt;ifc_name, IFNAMSIZ + 1);
	ifc-&gt;ifc_name = (<span class="enscript-type">char</span> *)(ifc + 1);
	ifc-&gt;ifc_namelen = namelen;
	ifc-&gt;ifc_maxunit = IF_MAXUNIT;
	ifc-&gt;ifc_create = cloner_params-&gt;ifc_create;
	ifc-&gt;ifc_destroy = cloner_params-&gt;ifc_destroy;

	error = if_clone_attach(ifc);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: if_clone_attach failed %d\n&quot;</span>, __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	*ifcloner = ifc;

	<span class="enscript-keyword">return</span> (0);
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (ifc != NULL)
		FREE(ifc, M_CLONE);
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">ifnet_clone_detach</span>(if_clone_t ifcloner)
{
	errno_t error = 0;
	<span class="enscript-type">struct</span> if_clone *ifc = ifcloner;

	<span class="enscript-keyword">if</span> (ifc == NULL || ifc-&gt;ifc_name == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> ((if_clone_lookup(ifc-&gt;ifc_name, NULL)) == NULL) {
		printf(<span class="enscript-string">&quot;%s: no cloner for %s\n&quot;</span>, __func__, ifc-&gt;ifc_name);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	if_clone_detach(ifc);

	FREE(ifc, M_CLONE);

<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/******************************************************************************/</span>
<span class="enscript-comment">/* misc                                                                       */</span>
<span class="enscript-comment">/******************************************************************************/</span>

errno_t
<span class="enscript-function-name">ifnet_get_local_ports_extended</span>(ifnet_t ifp, protocol_family_t protocol,
    u_int32_t flags, u_int8_t *bitfield)
{
	u_int32_t ifindex;
	u_int32_t inp_flags = 0;

	inp_flags |= ((flags &amp; IFNET_GET_LOCAL_PORTS_WILDCARDOK) ?
		INPCB_GET_PORTS_USED_WILDCARDOK : 0);
	inp_flags |= ((flags &amp; IFNET_GET_LOCAL_PORTS_NOWAKEUPOK) ?
		INPCB_GET_PORTS_USED_NOWAKEUPOK : 0);
	inp_flags |= ((flags &amp; IFNET_GET_LOCAL_PORTS_RECVANYIFONLY) ?
		INPCB_GET_PORTS_USED_RECVANYIFONLY : 0);
	inp_flags |= ((flags &amp; IFNET_GET_LOCAL_PORTS_EXTBGIDLEONLY) ?
		INPCB_GET_PORTS_USED_EXTBGIDLEONLY : 0);
	inp_flags |= ((flags &amp; IFNET_GET_LOCAL_PORTS_ACTIVEONLY) ?
		INPCB_GET_PORTS_USED_ACTIVEONLY : 0);

	<span class="enscript-keyword">if</span> (bitfield == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">switch</span> (protocol) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_UNSPEC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET6</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/* bit string is long enough to hold 16-bit port values */</span>
	bzero(bitfield, bitstr_size(65536));

	ifindex = (ifp != NULL) ? ifp-&gt;if_index : 0;

	<span class="enscript-keyword">if</span> (!(flags &amp; IFNET_GET_LOCAL_PORTS_TCPONLY))
		udp_get_ports_used(ifindex, protocol, inp_flags, bitfield);

	<span class="enscript-keyword">if</span> (!(flags &amp; IFNET_GET_LOCAL_PORTS_UDPONLY))
		tcp_get_ports_used(ifindex, protocol, inp_flags, bitfield);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_get_local_ports</span>(ifnet_t ifp, u_int8_t *bitfield)
{
	u_int32_t flags = IFNET_GET_LOCAL_PORTS_WILDCARDOK;
	<span class="enscript-keyword">return</span> (ifnet_get_local_ports_extended(ifp, PF_UNSPEC, flags, 
		bitfield));
}

errno_t
<span class="enscript-function-name">ifnet_notice_node_presence</span>(ifnet_t ifp, <span class="enscript-type">struct</span> sockaddr* sa, int32_t rssi,
    <span class="enscript-type">int</span> lqm, <span class="enscript-type">int</span> npm, u_int8_t srvinfo[48])
{
	<span class="enscript-keyword">if</span> (ifp == NULL || sa == NULL || srvinfo == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (sa-&gt;sa_len &gt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_storage))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (sa-&gt;sa_family != AF_LINK &amp;&amp; sa-&gt;sa_family != AF_INET6)
		<span class="enscript-keyword">return</span> (EINVAL);

	dlil_node_present(ifp, sa, rssi, lqm, npm, srvinfo);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_notice_node_absence</span>(ifnet_t ifp, <span class="enscript-type">struct</span> sockaddr* sa)
{
	<span class="enscript-keyword">if</span> (ifp == NULL || sa == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (sa-&gt;sa_len &gt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_storage))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (sa-&gt;sa_family != AF_LINK &amp;&amp; sa-&gt;sa_family != AF_INET6)
		<span class="enscript-keyword">return</span> (EINVAL);

	dlil_node_absent(ifp, sa);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_notice_master_elected</span>(ifnet_t ifp)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	dlil_post_msg(ifp, KEV_DL_SUBCLASS, KEV_DL_MASTER_ELECTED, NULL, 0);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_tx_compl_status</span>(ifnet_t ifp, mbuf_t m, tx_compl_val_t val)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">m</span>, <span class="enscript-variable-name">val</span>)
	<span class="enscript-comment">/* Dummy function to be implemented XXX */</span>
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_report_issues</span>(ifnet_t ifp, u_int8_t modid[IFNET_MODIDLEN],
    u_int8_t info[IFNET_MODARGLEN])
{
	<span class="enscript-keyword">if</span> (ifp == NULL || modid == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	dlil_report_issues(ifp, modid, info);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_set_delegate</span>(ifnet_t ifp, ifnet_t delegated_ifp)
{
	ifnet_t odifp = NULL;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1))
		<span class="enscript-keyword">return</span> (ENXIO);

	ifnet_lock_exclusive(ifp);
	odifp = ifp-&gt;if_delegated.ifp;
	<span class="enscript-keyword">if</span> (odifp != NULL &amp;&amp; odifp == delegated_ifp) {
		<span class="enscript-comment">/* delegate info is unchanged; nothing more to do */</span>
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	bzero(&amp;ifp-&gt;if_delegated, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_delegated));
	<span class="enscript-keyword">if</span> (delegated_ifp != NULL &amp;&amp; ifp != delegated_ifp) {
		ifp-&gt;if_delegated.ifp = delegated_ifp;
		ifnet_reference(delegated_ifp);
		ifp-&gt;if_delegated.type = delegated_ifp-&gt;if_type;
		ifp-&gt;if_delegated.family = delegated_ifp-&gt;if_family;
		ifp-&gt;if_delegated.subfamily = delegated_ifp-&gt;if_subfamily;
		ifp-&gt;if_delegated.expensive =
		    delegated_ifp-&gt;if_eflags &amp; IFEF_EXPENSIVE ? 1 : 0;
		printf(<span class="enscript-string">&quot;%s: is now delegating %s (type 0x%x, family %u, &quot;</span>
		    <span class="enscript-string">&quot;sub-family %u)\n&quot;</span>, ifp-&gt;if_xname, delegated_ifp-&gt;if_xname,
		    delegated_ifp-&gt;if_type, delegated_ifp-&gt;if_family,
		    delegated_ifp-&gt;if_subfamily);
	}
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">if</span> (odifp != NULL) {
		<span class="enscript-keyword">if</span> (odifp != delegated_ifp) {
			printf(<span class="enscript-string">&quot;%s: is no longer delegating %s\n&quot;</span>,
			    ifp-&gt;if_xname, odifp-&gt;if_xname);
		}
		ifnet_release(odifp);
	}

	<span class="enscript-comment">/* Generate a kernel event */</span>
	dlil_post_msg(ifp, KEV_DL_SUBCLASS, KEV_DL_IFDELEGATE_CHANGED, NULL, 0);

<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/* Release the io ref count */</span>
	ifnet_decr_iorefcnt(ifp);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_get_delegate</span>(ifnet_t ifp, ifnet_t *pdelegated_ifp)
{
	<span class="enscript-keyword">if</span> (ifp == NULL || pdelegated_ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1))
		<span class="enscript-keyword">return</span> (ENXIO);

	ifnet_lock_shared(ifp);
	<span class="enscript-keyword">if</span> (ifp-&gt;if_delegated.ifp != NULL)
		ifnet_reference(ifp-&gt;if_delegated.ifp);
	*pdelegated_ifp = ifp-&gt;if_delegated.ifp;
	ifnet_lock_done(ifp);

	<span class="enscript-comment">/* Release the io ref count */</span>
	ifnet_decr_iorefcnt(ifp);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">extern</span> u_int32_t
<span class="enscript-function-name">key_fill_offload_frames_for_savs</span>(ifnet_t ifp,
    <span class="enscript-type">struct</span> ifnet_keepalive_offload_frame *frames_array,
    u_int32_t frames_array_count, size_t frame_data_offset);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">udp_fill_keepalive_offload_frames</span>(ifnet_t ifp,
    <span class="enscript-type">struct</span> ifnet_keepalive_offload_frame *frames_array,
    u_int32_t frames_array_count, size_t frame_data_offset,
    u_int32_t *used_frames_count);

errno_t
<span class="enscript-function-name">ifnet_get_keepalive_offload_frames</span>(ifnet_t ifp,
    <span class="enscript-type">struct</span> ifnet_keepalive_offload_frame *frames_array,
    u_int32_t frames_array_count, size_t frame_data_offset,
    u_int32_t *used_frames_count)
{
	<span class="enscript-keyword">if</span> (frames_array == NULL || used_frames_count == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* frame_data_offset should be 32-bit aligned */</span>
	<span class="enscript-keyword">if</span> (P2ROUNDUP(frame_data_offset, <span class="enscript-keyword">sizeof</span>(u_int32_t))
	    != frame_data_offset)
		<span class="enscript-keyword">return</span> (EINVAL);

	*used_frames_count = 0;
	<span class="enscript-keyword">if</span> (frames_array_count == 0)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* First collect IPSec related keep-alive frames */</span>
	*used_frames_count = key_fill_offload_frames_for_savs(ifp,
	    frames_array, frames_array_count, frame_data_offset);

	<span class="enscript-comment">/* If there is more room, collect other UDP keep-alive frames */</span>
	<span class="enscript-keyword">if</span> (*used_frames_count &lt; frames_array_count)
		udp_fill_keepalive_offload_frames(ifp, frames_array,
		    frames_array_count, frame_data_offset,
		    used_frames_count);

	VERIFY(*used_frames_count &lt;= frames_array_count);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_link_status_report</span>(ifnet_t ifp, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *buffer,
    size_t buffer_len)
{
	<span class="enscript-type">struct</span> if_link_status *ifsr;
	errno_t err = 0;

	<span class="enscript-keyword">if</span> (ifp == NULL || buffer == NULL || buffer_len == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifnet_lock_shared(ifp);

	<span class="enscript-comment">/*
	 * Make sure that the interface is attached but there is no need
	 * to take a reference because this call is coming from the driver.
	 */</span>
	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 0)) {
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">return</span> (ENXIO);
	}

	lck_rw_lock_exclusive(&amp;ifp-&gt;if_link_status_lock);

	<span class="enscript-comment">/*
	 * If this is the first status report then allocate memory
	 * to store it.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_link_status == NULL) {
		MALLOC(ifp-&gt;if_link_status, <span class="enscript-type">struct</span> if_link_status *,
		    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> if_link_status), M_TEMP, M_ZERO);
		<span class="enscript-keyword">if</span> (ifp-&gt;if_link_status == NULL) {
			err = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	ifsr = __DECONST(<span class="enscript-type">struct</span> if_link_status *, buffer);

	<span class="enscript-keyword">if</span> (ifp-&gt;if_type == IFT_CELLULAR) {
		<span class="enscript-type">struct</span> if_cellular_status_v1 *if_cell_sr, *new_cell_sr;
		<span class="enscript-comment">/*
		 * Currently we have a single version -- if it does
		 * not match, just return.
		 */</span>
		<span class="enscript-keyword">if</span> (ifsr-&gt;ifsr_version !=
		    IF_CELLULAR_STATUS_REPORT_CURRENT_VERSION) {
			err = ENOTSUP;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		<span class="enscript-keyword">if</span> (ifsr-&gt;ifsr_len != <span class="enscript-keyword">sizeof</span>(*if_cell_sr)) {
			err = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		if_cell_sr =
		    &amp;ifp-&gt;if_link_status-&gt;ifsr_u.ifsr_cell.if_cell_u.if_status_v1;
		new_cell_sr = &amp;ifsr-&gt;ifsr_u.ifsr_cell.if_cell_u.if_status_v1;
		ifp-&gt;if_link_status-&gt;ifsr_version = ifsr-&gt;ifsr_version;
		ifp-&gt;if_link_status-&gt;ifsr_len = ifsr-&gt;ifsr_len;
		if_cell_sr-&gt;valid_bitmask = 0;
		bcopy(new_cell_sr, if_cell_sr, <span class="enscript-keyword">sizeof</span>(*if_cell_sr));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_subfamily == IFNET_SUBFAMILY_WIFI) {
		<span class="enscript-type">struct</span> if_wifi_status_v1 *if_wifi_sr, *new_wifi_sr;

		<span class="enscript-comment">/* Check version */</span>
		<span class="enscript-keyword">if</span> (ifsr-&gt;ifsr_version !=
		    IF_WIFI_STATUS_REPORT_CURRENT_VERSION) {
			err = ENOTSUP;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		<span class="enscript-keyword">if</span> (ifsr-&gt;ifsr_len != <span class="enscript-keyword">sizeof</span>(*if_wifi_sr)) {
			err = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		if_wifi_sr =
		    &amp;ifp-&gt;if_link_status-&gt;ifsr_u.ifsr_wifi.if_wifi_u.if_status_v1;
		new_wifi_sr =
		    &amp;ifsr-&gt;ifsr_u.ifsr_wifi.if_wifi_u.if_status_v1;
		ifp-&gt;if_link_status-&gt;ifsr_version = ifsr-&gt;ifsr_version;
		ifp-&gt;if_link_status-&gt;ifsr_len = ifsr-&gt;ifsr_len;
		if_wifi_sr-&gt;valid_bitmask = 0;
		bcopy(new_wifi_sr, if_wifi_sr, <span class="enscript-keyword">sizeof</span>(*if_wifi_sr));

		<span class="enscript-comment">/*
		 * Update the bandwidth values if we got recent values
		 * reported through the other KPI.
		 */</span>
		<span class="enscript-keyword">if</span> (!(new_wifi_sr-&gt;valid_bitmask &amp;
		    IF_WIFI_UL_MAX_BANDWIDTH_VALID) &amp;&amp;
		    ifp-&gt;if_output_bw.max_bw &gt; 0) {
			if_wifi_sr-&gt;valid_bitmask |=
			    IF_WIFI_UL_MAX_BANDWIDTH_VALID;
			if_wifi_sr-&gt;ul_max_bandwidth =
			    ifp-&gt;if_output_bw.max_bw;
		}
		<span class="enscript-keyword">if</span> (!(new_wifi_sr-&gt;valid_bitmask &amp;
		    IF_WIFI_UL_EFFECTIVE_BANDWIDTH_VALID) &amp;&amp;
		    ifp-&gt;if_output_bw.eff_bw &gt; 0) {
			if_wifi_sr-&gt;valid_bitmask |=
			    IF_WIFI_UL_EFFECTIVE_BANDWIDTH_VALID;
			if_wifi_sr-&gt;ul_effective_bandwidth =
			    ifp-&gt;if_output_bw.eff_bw;
		}
		<span class="enscript-keyword">if</span> (!(new_wifi_sr-&gt;valid_bitmask &amp;
		    IF_WIFI_DL_MAX_BANDWIDTH_VALID) &amp;&amp;
		    ifp-&gt;if_input_bw.max_bw &gt; 0) {
			if_wifi_sr-&gt;valid_bitmask |=
			    IF_WIFI_DL_MAX_BANDWIDTH_VALID;
			if_wifi_sr-&gt;dl_max_bandwidth =
			    ifp-&gt;if_input_bw.max_bw;
		}
		<span class="enscript-keyword">if</span> (!(new_wifi_sr-&gt;valid_bitmask &amp;
		    IF_WIFI_DL_EFFECTIVE_BANDWIDTH_VALID) &amp;&amp;
		    ifp-&gt;if_input_bw.eff_bw &gt; 0) {
			if_wifi_sr-&gt;valid_bitmask |=
			    IF_WIFI_DL_EFFECTIVE_BANDWIDTH_VALID;
			if_wifi_sr-&gt;dl_effective_bandwidth =
			    ifp-&gt;if_input_bw.eff_bw;
		}
	}

<span class="enscript-reference">done</span>:
	lck_rw_done(&amp;ifp-&gt;if_link_status_lock);
	ifnet_lock_done(ifp);
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-comment">/*************************************************************************/</span>
<span class="enscript-comment">/* Packet preamble                                                       */</span>
<span class="enscript-comment">/*************************************************************************/</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_IF_PACKET_PREAMBLE_LEN</span> 32

errno_t
<span class="enscript-function-name">ifnet_set_packetpreamblelen</span>(ifnet_t interface, u_int32_t len)
{
	errno_t err = 0;

	<span class="enscript-keyword">if</span> (interface == NULL || len &gt; MAX_IF_PACKET_PREAMBLE_LEN) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	interface-&gt;if_data.ifi_preamblelen = len;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (err);
}

u_int32_t
<span class="enscript-function-name">ifnet_packetpreamblelen</span>(ifnet_t interface)
{
	<span class="enscript-keyword">return</span> ((interface == NULL) ? 0 : interface-&gt;if_data.ifi_preamblelen);
}

u_int32_t
<span class="enscript-function-name">ifnet_maxpacketpreamblelen</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (MAX_IF_PACKET_PREAMBLE_LEN);
}
</pre>
<hr />
</body></html>