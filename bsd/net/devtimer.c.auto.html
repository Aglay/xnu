<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>devtimer.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">devtimer.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004,2007-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * devtimer.c 
 * - timer source based on &lt;kern/thread_call.h&gt;
 */</span>

<span class="enscript-comment">/*
 * Modification History:
 *
 * June 22, 2004	Dieter Siegmund (<a href="mailto:dieter@apple.com">dieter@apple.com</a>)
 * - created
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/devtimer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DEVTIMER_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_devtimer_printf</span>	printf
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !DEVTIMER_DEBUG */</span>
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">_devtimer_printf</span>(__unused <span class="enscript-type">const</span> <span class="enscript-type">char</span> * fmt, ...)
{
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !DEVTIMER_DEBUG */</span>

<span class="enscript-type">struct</span> devtimer_s {
    <span class="enscript-type">void</span> *			dt_callout;
    devtimer_timeout_func	dt_timeout_func;
    devtimer_process_func	dt_process_func;
    <span class="enscript-type">void</span> *			dt_arg0;
    <span class="enscript-type">void</span> *			dt_arg1;
    <span class="enscript-type">void</span> *			dt_arg2;
    <span class="enscript-type">int</span>				dt_generation;
    UInt32			dt_retain_count;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">M_DEVTIMER</span>	M_DEVBUF

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">timeval_add</span>(<span class="enscript-type">struct</span> timeval tv1, <span class="enscript-type">struct</span> timeval tv2,
	    <span class="enscript-type">struct</span> timeval * result)
{
    result-&gt;tv_sec = tv1.tv_sec + tv2.tv_sec;
    result-&gt;tv_usec = tv1.tv_usec + tv2.tv_usec;
    <span class="enscript-keyword">if</span> (result-&gt;tv_usec &gt; DEVTIMER_USECS_PER_SEC) {
	result-&gt;tv_usec -= DEVTIMER_USECS_PER_SEC;
	result-&gt;tv_sec++;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> __inline__ uint64_t
<span class="enscript-function-name">timeval_to_absolutetime</span>(<span class="enscript-type">struct</span> timeval tv)
{
    uint64_t	secs;
    uint64_t	usecs;

    clock_interval_to_absolutetime_interval(tv.tv_sec, NSEC_PER_SEC, 
					    &amp;secs);
    clock_interval_to_absolutetime_interval(tv.tv_usec, NSEC_PER_USEC, 
					    &amp;usecs);
    <span class="enscript-keyword">return</span> (secs + usecs);
}


__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">devtimer_valid</span>(devtimer_ref timer)
{
    <span class="enscript-keyword">return</span> (timer-&gt;dt_callout != NULL);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">devtimer_retain</span>(devtimer_ref timer)
{
    OSIncrementAtomic(&amp;timer-&gt;dt_retain_count);
    <span class="enscript-keyword">return</span>;
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">devtimer_invalidate</span>(devtimer_ref timer)
{
    devtimer_cancel(timer);
    timer-&gt;dt_arg0 = NULL;
    <span class="enscript-keyword">if</span> (timer-&gt;dt_callout != NULL) {
	thread_call_free(timer-&gt;dt_callout);
	timer-&gt;dt_callout = NULL;
    }
    <span class="enscript-keyword">return</span>;
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">devtimer_release</span>(devtimer_ref timer)
{
    UInt32	old_retain_count;

    old_retain_count = OSDecrementAtomic(&amp;timer-&gt;dt_retain_count);
    <span class="enscript-keyword">switch</span> (old_retain_count) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
	panic(<span class="enscript-string">&quot;devtimer_release: retain count is 0\n&quot;</span>);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
	devtimer_invalidate(timer);
	FREE(timer, M_DEVTIMER);
	_devtimer_printf(<span class="enscript-string">&quot;devtimer: timer released\n&quot;</span>);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">devtimer_process</span>(<span class="enscript-type">void</span> * param0, <span class="enscript-type">void</span> * param1)
{
    <span class="enscript-type">int</span>				generation = *(<span class="enscript-type">int</span>*)param1;
    devtimer_process_func 	process_func;
    devtimer_timeout_func 	timeout_func;
    devtimer_ref		timer = (devtimer_ref)param0;

    process_func = timer-&gt;dt_process_func;
    <span class="enscript-keyword">if</span> (process_func != NULL) {
	(*process_func)(timer, devtimer_process_func_event_lock);
    }
    timeout_func = timer-&gt;dt_timeout_func;
    <span class="enscript-keyword">if</span> (timeout_func != NULL) {
	timer-&gt;dt_timeout_func = NULL;
	<span class="enscript-keyword">if</span> (timer-&gt;dt_generation == generation) {
	    (*timeout_func)(timer-&gt;dt_arg0, timer-&gt;dt_arg1, timer-&gt;dt_arg2);
	}
    }
    devtimer_release(timer);
    <span class="enscript-keyword">if</span> (process_func != NULL) {
	(*process_func)(timer, devtimer_process_func_event_unlock);
    }
    <span class="enscript-keyword">return</span>;
}

__private_extern__ <span class="enscript-type">void</span> *
<span class="enscript-function-name">devtimer_arg0</span>(devtimer_ref timer)
{
    <span class="enscript-keyword">return</span> (timer-&gt;dt_arg0);
}

__private_extern__ devtimer_ref
<span class="enscript-function-name">devtimer_create</span>(devtimer_process_func process_func, <span class="enscript-type">void</span> * arg0)
{
    devtimer_ref	timer;

    timer = _MALLOC(<span class="enscript-keyword">sizeof</span>(*timer), M_DEVTIMER, M_WAITOK | M_ZERO);
    <span class="enscript-keyword">if</span> (timer == NULL) {
	<span class="enscript-keyword">return</span> (timer);
    }
    devtimer_retain(timer);
    timer-&gt;dt_callout = thread_call_allocate(devtimer_process, timer);
    <span class="enscript-keyword">if</span> (timer-&gt;dt_callout == NULL) {
	_devtimer_printf(<span class="enscript-string">&quot;devtimer: thread_call_allocate failed\n&quot;</span>);
	devtimer_release(timer);
	timer = NULL;
    }
    timer-&gt;dt_process_func = process_func;
    timer-&gt;dt_arg0 = arg0;
    <span class="enscript-keyword">return</span> (timer);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">devtimer_set_absolute</span>(devtimer_ref timer, 
		      <span class="enscript-type">struct</span> timeval abs_time, 
		      devtimer_timeout_func timeout_func, 
		      <span class="enscript-type">void</span> * arg1, <span class="enscript-type">void</span> * arg2)
{
    <span class="enscript-keyword">if</span> (timer-&gt;dt_callout == NULL) {
	printf(<span class="enscript-string">&quot;devtimer_set_absolute: uninitialized/freed timer\n&quot;</span>);
	<span class="enscript-keyword">return</span>;
    }
    devtimer_cancel(timer);
    <span class="enscript-keyword">if</span> (timeout_func == NULL) {
	<span class="enscript-keyword">return</span>;
    }
    timer-&gt;dt_timeout_func = timeout_func;
    timer-&gt;dt_arg1 = arg1;
    timer-&gt;dt_arg2 = arg2;
    _devtimer_printf(<span class="enscript-string">&quot;devtimer: wakeup time is (%d.%d)\n&quot;</span>, 
		     abs_time.tv_sec, abs_time.tv_usec);
    timer-&gt;dt_generation++;
    devtimer_retain(timer);
    thread_call_enter1_delayed(timer-&gt;dt_callout, 
			       &amp;timer-&gt;dt_generation,
			       timeval_to_absolutetime(abs_time));
    <span class="enscript-keyword">return</span>;
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">devtimer_set_relative</span>(devtimer_ref timer, 
		      <span class="enscript-type">struct</span> timeval rel_time, 
		      devtimer_timeout_func timeout_func, 
		      <span class="enscript-type">void</span> * arg1, <span class="enscript-type">void</span> * arg2)
{
    <span class="enscript-type">struct</span> timeval		abs_time;
    <span class="enscript-type">struct</span> timeval		current_time;

    current_time = devtimer_current_time();
    timeval_add(current_time, rel_time, &amp;abs_time);
    devtimer_set_absolute(timer, abs_time, timeout_func, arg1, arg2);
    <span class="enscript-keyword">return</span>;
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">devtimer_cancel</span>(devtimer_ref timer)
{
    <span class="enscript-keyword">if</span> (timer-&gt;dt_timeout_func != NULL) {
	timer-&gt;dt_timeout_func = NULL;
	<span class="enscript-keyword">if</span> (timer-&gt;dt_callout != NULL) {
	    _devtimer_printf(<span class="enscript-string">&quot;devtimer: cancelling timer source\n&quot;</span>);
	    <span class="enscript-keyword">if</span> (thread_call_cancel(timer-&gt;dt_callout)) {
		devtimer_release(timer);
	    }
	    <span class="enscript-keyword">else</span> {
		_devtimer_printf(<span class="enscript-string">&quot;devtimer: delayed release\n&quot;</span>);
	    }
	}
    }
    <span class="enscript-keyword">return</span>;
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">devtimer_enabled</span>(devtimer_ref timer)
{
    <span class="enscript-keyword">return</span> (timer-&gt;dt_timeout_func != NULL);
}

__private_extern__ int32_t
<span class="enscript-function-name">devtimer_current_secs</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">struct</span> timeval	tv;

    tv = devtimer_current_time();
    <span class="enscript-keyword">return</span> (tv.tv_sec);
}

__private_extern__ <span class="enscript-type">struct</span> timeval
<span class="enscript-function-name">devtimer_current_time</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">struct</span> timeval 	tv;
    clock_sec_t sec;
    clock_usec_t usec;

    clock_get_system_microtime(&amp;sec, &amp;usec);
    tv.tv_sec = sec;
    tv.tv_usec = usec;
    <span class="enscript-keyword">return</span> (tv);
}
</pre>
<hr />
</body></html>