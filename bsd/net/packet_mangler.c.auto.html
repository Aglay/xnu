<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>packet_mangler.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">packet_mangler.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http: www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * THEORY OF OPERATION
 *
 * The packet mangler subsystem provides a limited way for user space
 * applications to apply certain actions on certain flows.
 *
 * A user space applications opens a kernel control socket with the name
 * PACKET_MANGLER_CONTROL_NAME to attach to the packet mangler subsystem.
 * When connected, a &quot;struct packet_mangler&quot; is created and set as the
 * &quot;unitinfo&quot; of the corresponding kernel control socket instance.
 * Connect call for packet mangler's kernel control socket also registers
 * ip filers with cookie set to the packet_mangler instance.
 * The ip filters are removed when control socket is disconnected.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_control.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/packet_mangler.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/kpi_ipfilter.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_PACKET_MANGLER</span>			1

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKT_MNGLR_FLG_IPFILTER_ATTACHED</span>		0x00000001

<span class="enscript-function-name">SYSCTL_NODE</span>(_net, OID_AUTO, pktmnglr, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;pktmnglr&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_pktmnglr, OID_AUTO, log, CTLFLAG_RW|CTLFLAG_LOCKED,
		&amp;pkt_mnglr_log_level, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-comment">/*
 * The structure packet_mangler represents a user space packet filter
 * It's created and associated with a kernel control socket instance
 */</span>
<span class="enscript-type">struct</span> packet_mangler {
	kern_ctl_ref			pkt_mnglr_kcref;
	uint32_t			pkt_mnglr_kcunit;
	uint32_t			pkt_mnglr_flags;
	<span class="enscript-comment">/* IP filter related params */</span>
	ipfilter_t 			pkt_mnglr_ipfref;
	ipfilter_t			pkt_mnglr_ipfrefv6;
	<span class="enscript-type">struct</span> ipf_filter 		pkt_mnglr_ipfilter;

	<span class="enscript-comment">/* Options */</span>
	uint8_t 			activate;
	Pkt_Mnglr_Flow			dir;
	<span class="enscript-type">struct</span> sockaddr_storage		lsaddr;
	<span class="enscript-type">struct</span> sockaddr_storage		rsaddr;
	<span class="enscript-type">struct</span> sockaddr_storage		swap_lsaddr;
	<span class="enscript-type">struct</span> sockaddr_storage		swap_rsaddr;
	uint32_t			ip_action_mask;
	uint16_t			lport;
	uint16_t			rport;
	uint32_t			proto;
	uint32_t			proto_action_mask;
};

<span class="enscript-comment">/* Array of all the packet mangler instancesi */</span>
<span class="enscript-type">struct</span> packet_mangler **packet_manglers = NULL;

uint32_t pkt_mnglr_active_count = 0;	<span class="enscript-comment">/* Number of active packet filters */</span>
uint32_t pkt_mnglr_close_wait_timeout = 1000; <span class="enscript-comment">/* in milliseconds */</span>

<span class="enscript-type">static</span> kern_ctl_ref pkt_mnglr_kctlref = NULL;

<span class="enscript-type">static</span> lck_grp_attr_t *pkt_mnglr_lck_grp_attr = NULL;
<span class="enscript-type">static</span> lck_attr_t *pkt_mnglr_lck_attr = NULL;
<span class="enscript-type">static</span> lck_grp_t *pkt_mnglr_lck_grp = NULL;

<span class="enscript-comment">/* The lock below protects packet_manglers DS, packet_mangler DS */</span>
<span class="enscript-function-name">decl_lck_rw_data</span>(<span class="enscript-type">static</span>, pkt_mnglr_lck_rw);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKT_MNGLR_RW_LCK_MAX</span>	8

<span class="enscript-type">int</span> pkt_mnglr_rw_nxt_lck = 0;
<span class="enscript-type">void</span>* pkt_mnglr_rw_lock_history[PKT_MNGLR_RW_LCK_MAX];

<span class="enscript-type">int</span> pkt_mnglr_rw_nxt_unlck = 0;
<span class="enscript-type">void</span>* pkt_mnglr_rw_unlock_history[PKT_MNGLR_RW_LCK_MAX];


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PACKET_MANGLER_ZONE_NAME</span>	<span class="enscript-string">&quot;packet_mangler&quot;</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PACKET_MANGLER_ZONE_MAX</span>		10
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *packet_mangler_zone = NULL;	<span class="enscript-comment">/* zone for packet_mangler */</span>

<span class="enscript-comment">/*
 * For troubleshooting
 */</span>
<span class="enscript-type">int</span> pkt_mnglr_log_level = LOG_ERR;
<span class="enscript-type">int</span> pkt_mnglr_debug = 1;

<span class="enscript-comment">/*
 * Forward declaration to appease the compiler
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pkt_mnglr_rw_lock_exclusive</span>(lck_rw_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pkt_mnglr_rw_unlock_exclusive</span>(lck_rw_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pkt_mnglr_rw_lock_shared</span>(lck_rw_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pkt_mnglr_rw_unlock_shared</span>(lck_rw_t *);

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">pktmnglr_ipfilter_output</span>(<span class="enscript-type">void</span> *cookie, mbuf_t *data,
		ipf_pktopts_t options);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">pktmnglr_ipfilter_input</span>(<span class="enscript-type">void</span> *cookie, mbuf_t *data,
		<span class="enscript-type">int</span> offset, u_int8_t protocol);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pktmnglr_ipfilter_detach</span>(<span class="enscript-type">void</span> *cookie);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">chksm_update</span>(mbuf_t data);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_OPT_MULTIPATH_TCP</span>	30
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MPTCP_SBT_VER_OFFSET</span>	2

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MPTCP_SUBTYPE_MPCAPABLE</span>		0x0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MPTCP_SUBTYPE_MPJOIN</span>		0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MPTCP_SUBTYPE_DSS</span>		0x2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MPTCP_SUBTYPE_ADD_ADDR</span>		0x3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MPTCP_SUBTYPE_REM_ADDR</span>		0x4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MPTCP_SUBTYPE_MP_PRIO</span>		0x5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MPTCP_SUBTYPE_MP_FAIL</span>		0x6
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MPTCP_SUBTYPE_MP_FASTCLOSE</span>	0x7

<span class="enscript-comment">/*
 * packet filter global read write lock
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pkt_mnglr_rw_lock_exclusive</span>(lck_rw_t *lck)
{
	<span class="enscript-type">void</span> *lr_saved;

	lr_saved = __builtin_return_address(0);

	lck_rw_lock_exclusive(lck);

	pkt_mnglr_rw_lock_history[pkt_mnglr_rw_nxt_lck] = lr_saved;
	pkt_mnglr_rw_nxt_lck =
	    (pkt_mnglr_rw_nxt_lck + 1) % PKT_MNGLR_RW_LCK_MAX;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pkt_mnglr_rw_unlock_exclusive</span>(lck_rw_t *lck)
{
	<span class="enscript-type">void</span> *lr_saved;

	lr_saved = __builtin_return_address(0);

	lck_rw_unlock_exclusive(lck);

	pkt_mnglr_rw_unlock_history[pkt_mnglr_rw_nxt_unlck] =
	    lr_saved;
	pkt_mnglr_rw_nxt_unlck = (pkt_mnglr_rw_nxt_unlck + 1) % PKT_MNGLR_RW_LCK_MAX;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pkt_mnglr_rw_lock_shared</span>(lck_rw_t *lck)
{
	<span class="enscript-type">void</span> *lr_saved;

	lr_saved = __builtin_return_address(0);

	lck_rw_lock_shared(lck);

	pkt_mnglr_rw_lock_history[pkt_mnglr_rw_nxt_lck] = lr_saved;
	pkt_mnglr_rw_nxt_lck = (pkt_mnglr_rw_nxt_lck + 1) % PKT_MNGLR_RW_LCK_MAX;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pkt_mnglr_rw_unlock_shared</span>(lck_rw_t *lck)
{
	<span class="enscript-type">void</span> *lr_saved;

	lr_saved = __builtin_return_address(0);

	lck_rw_unlock_shared(lck);

	pkt_mnglr_rw_unlock_history[pkt_mnglr_rw_nxt_unlck] = lr_saved;
	pkt_mnglr_rw_nxt_unlck = (pkt_mnglr_rw_nxt_unlck + 1) % PKT_MNGLR_RW_LCK_MAX;
}

<span class="enscript-comment">/*
 * Packet Mangler's Kernel control socket callbacks
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">pkt_mnglr_ctl_connect</span>(kern_ctl_ref kctlref, <span class="enscript-type">struct</span> sockaddr_ctl *sac,
		<span class="enscript-type">void</span> **unitinfo)
{
	errno_t	error = 0;
	<span class="enscript-type">struct</span> packet_mangler *p_pkt_mnglr = NULL;

	PKT_MNGLR_LOG(LOG_NOTICE, <span class="enscript-string">&quot;Connecting packet mangler filter.&quot;</span>);

	p_pkt_mnglr = zalloc(packet_mangler_zone);
	<span class="enscript-keyword">if</span> (p_pkt_mnglr == NULL) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;zalloc failed&quot;</span>);
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	bzero(p_pkt_mnglr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> packet_mangler));

	pkt_mnglr_rw_lock_exclusive(&amp;pkt_mnglr_lck_rw);
	<span class="enscript-keyword">if</span> (packet_manglers == NULL) {
		<span class="enscript-type">struct</span> packet_mangler **tmp;

		pkt_mnglr_rw_unlock_exclusive(&amp;pkt_mnglr_lck_rw);

		MALLOC(tmp,
		    <span class="enscript-type">struct</span> packet_mangler **,
		    MAX_PACKET_MANGLER * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> packet_mangler *),
		    M_TEMP,
		    M_WAITOK | M_ZERO);

		pkt_mnglr_rw_lock_exclusive(&amp;pkt_mnglr_lck_rw);

		<span class="enscript-keyword">if</span> (tmp == NULL &amp;&amp; packet_manglers == NULL) {
			error = ENOMEM;
			pkt_mnglr_rw_unlock_exclusive(&amp;pkt_mnglr_lck_rw);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/* Another thread may have won the race */</span>
		<span class="enscript-keyword">if</span> (packet_manglers != NULL)
			FREE(tmp, M_TEMP);
		<span class="enscript-keyword">else</span>
			packet_manglers = tmp;
	}

	<span class="enscript-keyword">if</span> (sac-&gt;sc_unit == 0 || sac-&gt;sc_unit &gt; MAX_PACKET_MANGLER) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;bad sc_unit %u&quot;</span>, sac-&gt;sc_unit);
		error = EINVAL;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (packet_manglers[sac-&gt;sc_unit - 1] != NULL) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;sc_unit %u in use&quot;</span>, sac-&gt;sc_unit);
		error = EADDRINUSE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * kernel control socket kcunit numbers start at 1
		 */</span>
		packet_manglers[sac-&gt;sc_unit - 1] = p_pkt_mnglr;

		p_pkt_mnglr-&gt;pkt_mnglr_kcref = kctlref;
		p_pkt_mnglr-&gt;pkt_mnglr_kcunit = sac-&gt;sc_unit;

		*unitinfo = p_pkt_mnglr;
		pkt_mnglr_active_count++;
	}

	p_pkt_mnglr-&gt;pkt_mnglr_ipfilter.cookie = p_pkt_mnglr;
	p_pkt_mnglr-&gt;pkt_mnglr_ipfilter.name = <span class="enscript-string">&quot;com.apple.pktmnglripfilter&quot;</span>;
	p_pkt_mnglr-&gt;pkt_mnglr_ipfilter.ipf_input = pktmnglr_ipfilter_input;
	p_pkt_mnglr-&gt;pkt_mnglr_ipfilter.ipf_output = pktmnglr_ipfilter_output;
	p_pkt_mnglr-&gt;pkt_mnglr_ipfilter.ipf_detach = pktmnglr_ipfilter_detach;
	error = ipf_addv4(&amp;(p_pkt_mnglr-&gt;pkt_mnglr_ipfilter), &amp;(p_pkt_mnglr-&gt;pkt_mnglr_ipfref));
	<span class="enscript-keyword">if</span> (error) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;Could not register packet mangler's IPv4 Filter&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	error = ipf_addv6(&amp;(p_pkt_mnglr-&gt;pkt_mnglr_ipfilter), &amp;(p_pkt_mnglr-&gt;pkt_mnglr_ipfrefv6));
	<span class="enscript-keyword">if</span> (error) {
		ipf_remove(p_pkt_mnglr-&gt;pkt_mnglr_ipfref);
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;Could not register packet mangler's IPv6 Filter&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Registered packet mangler's IP Filters&quot;</span>);
	p_pkt_mnglr-&gt;pkt_mnglr_flags |=	PKT_MNGLR_FLG_IPFILTER_ATTACHED;
	pkt_mnglr_rw_unlock_exclusive(&amp;pkt_mnglr_lck_rw);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error != 0 &amp;&amp; p_pkt_mnglr != NULL)
		zfree(packet_mangler_zone, p_pkt_mnglr);

	PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;return %d pkt_mnglr_active_count %u kcunit %u&quot;</span>,
	    error, pkt_mnglr_active_count, sac-&gt;sc_unit);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">pkt_mnglr_ctl_disconnect</span>(kern_ctl_ref kctlref, u_int32_t kcunit, <span class="enscript-type">void</span> *unitinfo)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>)
	errno_t	error = 0;
	<span class="enscript-type">struct</span> packet_mangler *p_pkt_mnglr;

	PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Disconnecting packet mangler kernel control&quot;</span>);

	<span class="enscript-keyword">if</span> (packet_manglers == NULL) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;no packet filter&quot;</span>);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (kcunit &gt; MAX_PACKET_MANGLER) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;kcunit %u &gt; MAX_PACKET_MANGLER (%d)&quot;</span>,
		    kcunit, MAX_PACKET_MANGLER);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	p_pkt_mnglr = (<span class="enscript-type">struct</span> packet_mangler *)unitinfo;
	<span class="enscript-keyword">if</span> (p_pkt_mnglr == NULL) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;Unit info is NULL&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	pkt_mnglr_rw_lock_exclusive(&amp;pkt_mnglr_lck_rw);
	<span class="enscript-keyword">if</span> (packet_manglers[kcunit - 1] != p_pkt_mnglr || p_pkt_mnglr-&gt;pkt_mnglr_kcunit != kcunit) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;bad unit info %u)&quot;</span>,
		    kcunit);
		pkt_mnglr_rw_unlock_exclusive(&amp;pkt_mnglr_lck_rw);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Make filter inactive
	 */</span>
	packet_manglers[kcunit - 1] = NULL;
	pkt_mnglr_active_count--;
	<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;pkt_mnglr_flags &amp; PKT_MNGLR_FLG_IPFILTER_ATTACHED) {
		(<span class="enscript-type">void</span>) ipf_remove(p_pkt_mnglr-&gt;pkt_mnglr_ipfref);
		(<span class="enscript-type">void</span>) ipf_remove(p_pkt_mnglr-&gt;pkt_mnglr_ipfrefv6);
	}
	pkt_mnglr_rw_unlock_exclusive(&amp;pkt_mnglr_lck_rw);
	zfree(packet_mangler_zone, p_pkt_mnglr);
<span class="enscript-reference">done</span>:
	PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;return %d pkt_mnglr_active_count %u kcunit %u&quot;</span>,
	    error, pkt_mnglr_active_count, kcunit);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">pkt_mnglr_ctl_getopt</span>(kern_ctl_ref kctlref, u_int32_t kcunit, <span class="enscript-type">void</span> *unitinfo,
		<span class="enscript-type">int</span> opt, <span class="enscript-type">void</span> *data, size_t *len)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">opt</span>)
	errno_t	error = 0;
	<span class="enscript-type">struct</span> packet_mangler *p_pkt_mnglr = (<span class="enscript-type">struct</span> packet_mangler *)unitinfo;

	PKT_MNGLR_LOG(LOG_NOTICE, <span class="enscript-string">&quot;&quot;</span>);

	pkt_mnglr_rw_lock_shared(&amp;pkt_mnglr_lck_rw);

	<span class="enscript-keyword">if</span> (packet_manglers == NULL) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;no packet filter&quot;</span>);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (kcunit &gt; MAX_PACKET_MANGLER) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;kcunit %u &gt; MAX_PACKET_MANGLER (%d)&quot;</span>,
		    kcunit, MAX_PACKET_MANGLER);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (p_pkt_mnglr != (<span class="enscript-type">void</span> *)packet_manglers[kcunit - 1]) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;unitinfo does not match for kcunit %u&quot;</span>,
		    kcunit);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">switch</span> (opt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_PROTO_ACT_MASK</span>:
			<span class="enscript-keyword">if</span> (*len &lt; <span class="enscript-keyword">sizeof</span>(uint32_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_PROTO_ACT_MASK &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, *len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}

			<span class="enscript-keyword">if</span> (data != NULL) {
				*(uint32_t *)data = p_pkt_mnglr-&gt;proto_action_mask;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_IP_ACT_MASK</span>:
			<span class="enscript-keyword">if</span> (*len &lt; <span class="enscript-keyword">sizeof</span>(uint32_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_IP_ACT_MASK &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, *len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}

			<span class="enscript-keyword">if</span> (data != NULL) {
				*(uint32_t *)data = p_pkt_mnglr-&gt;ip_action_mask;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_LOCAL_IP</span>:
			<span class="enscript-keyword">if</span> (*len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_storage)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_LOCAL_IP &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, *len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}

			<span class="enscript-keyword">if</span> (data != NULL) {
				*(<span class="enscript-type">struct</span> sockaddr_storage *)data = p_pkt_mnglr-&gt;lsaddr;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_REMOTE_IP</span>:
			<span class="enscript-keyword">if</span> (*len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_storage)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_REMOTE_IP &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, *len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}

			<span class="enscript-keyword">if</span> (data != NULL) {
				*(<span class="enscript-type">struct</span> sockaddr_storage *)data = p_pkt_mnglr-&gt;rsaddr;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_LOCAL_PORT</span>:
			<span class="enscript-keyword">if</span> (*len &lt; <span class="enscript-keyword">sizeof</span>(uint16_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_LOCAL_PORT &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, *len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}

			<span class="enscript-keyword">if</span> (data != NULL) {
				*(uint16_t *)data = p_pkt_mnglr-&gt;lport;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_REMOTE_PORT</span>:
			<span class="enscript-keyword">if</span> (*len &lt; <span class="enscript-keyword">sizeof</span>(uint16_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_REMOTE_PORT &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, *len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}

			<span class="enscript-keyword">if</span> (data != NULL) {
				*(uint16_t *)data = p_pkt_mnglr-&gt;rport;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_DIRECTION</span>:
			<span class="enscript-keyword">if</span> (*len &lt; <span class="enscript-keyword">sizeof</span>(uint32_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_DIRECTION &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, *len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (data != NULL) {
				*(uint32_t *)data = p_pkt_mnglr-&gt;dir;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_PROTOCOL</span>:
			<span class="enscript-keyword">if</span> (*len &lt; <span class="enscript-keyword">sizeof</span>(uint32_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_PROTOCOL &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, *len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (data != NULL) {
				*(uint32_t *)data = p_pkt_mnglr-&gt;proto;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_ACTIVATE</span>:
			<span class="enscript-keyword">if</span> (*len &lt; <span class="enscript-keyword">sizeof</span>(uint8_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_ACTIVATE &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, *len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}

			<span class="enscript-keyword">if</span> (data != NULL) {
				*(uint8_t *)data = p_pkt_mnglr-&gt;activate;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">done</span>:
	pkt_mnglr_rw_unlock_shared(&amp;pkt_mnglr_lck_rw);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">pkt_mnglr_ctl_setopt</span>(kern_ctl_ref kctlref, u_int32_t kcunit, <span class="enscript-type">void</span> *unitinfo,
		<span class="enscript-type">int</span> opt, <span class="enscript-type">void</span> *data, size_t len)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">opt</span>)
	errno_t	error = 0;
	<span class="enscript-type">struct</span> packet_mangler *p_pkt_mnglr = (<span class="enscript-type">struct</span> packet_mangler *)unitinfo;

	PKT_MNGLR_LOG(LOG_NOTICE, <span class="enscript-string">&quot;&quot;</span>);

	pkt_mnglr_rw_lock_exclusive(&amp;pkt_mnglr_lck_rw);

	<span class="enscript-keyword">if</span> (packet_manglers == NULL) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;no packet filter&quot;</span>);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (kcunit &gt; MAX_PACKET_MANGLER) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;kcunit %u &gt; MAX_PACKET_MANGLER (%d)&quot;</span>,
		    kcunit, MAX_PACKET_MANGLER);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (p_pkt_mnglr != (<span class="enscript-type">void</span> *)packet_manglers[kcunit - 1]) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;unitinfo does not match for kcunit %u&quot;</span>,
		    kcunit);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">switch</span> (opt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_PROTO_ACT_MASK</span>:
			<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(uint32_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_PROTO_ACT_MASK &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;proto_action_mask != 0) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_PROTO_ACT_MASK &quot;</span>
				    <span class="enscript-string">&quot;already set %u&quot;</span>,
				    p_pkt_mnglr-&gt;proto_action_mask);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			p_pkt_mnglr-&gt;proto_action_mask = *(uint32_t *)data;
			PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;p_pkt_mnglr-&gt;proto_action_mask set to :%d&quot;</span>, p_pkt_mnglr-&gt;proto_action_mask);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_IP_ACT_MASK</span>:
			<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(uint32_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_IP_ACT_MASK &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;ip_action_mask != 0) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_IP_ACT_MASK &quot;</span>
				    <span class="enscript-string">&quot;already set %u&quot;</span>,
				    p_pkt_mnglr-&gt;ip_action_mask);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			p_pkt_mnglr-&gt;ip_action_mask = *(uint32_t *)data;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_LOCAL_IP</span>:
			<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_storage)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_LOCAL_IP &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;lsaddr.ss_family) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_LOCAL_IP &quot;</span>
				    <span class="enscript-string">&quot;already set&quot;</span>);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			p_pkt_mnglr-&gt;lsaddr = *(<span class="enscript-type">struct</span> sockaddr_storage *)data;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_REMOTE_IP</span>:
			<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_storage)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_REMOTE_IP &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;rsaddr.ss_family) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_REMOTE_IP &quot;</span>
				    <span class="enscript-string">&quot;already set&quot;</span>);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}

			p_pkt_mnglr-&gt;rsaddr = *(<span class="enscript-type">struct</span> sockaddr_storage *)data;
			PKT_MNGLR_LOG(LOG_INFO,
			    <span class="enscript-string">&quot;Remote IP registered for address family: %d&quot;</span>,
			    p_pkt_mnglr-&gt;rsaddr.ss_family);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_LOCAL_PORT</span>:
			<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(uint16_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_LOCAL_PORT &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;lport != 0) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_LOCAL_PORT &quot;</span>
				    <span class="enscript-string">&quot;already set %d&quot;</span>,
				    p_pkt_mnglr-&gt;lport);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			p_pkt_mnglr-&gt;lport = *(uint16_t *)data;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_REMOTE_PORT</span>:
			<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(uint16_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_REMOTE_PORT &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;rport != 0) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_REMOTE_PORT &quot;</span>
				    <span class="enscript-string">&quot;already set %d&quot;</span>,
				    p_pkt_mnglr-&gt;rport);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			p_pkt_mnglr-&gt;rport = *(uint16_t *)data;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_DIRECTION</span>:
			<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(uint32_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_DIRECTION &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;dir != 0) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_DIRECTION &quot;</span>
				    <span class="enscript-string">&quot;already set %u&quot;</span>,
				    p_pkt_mnglr-&gt;dir);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			p_pkt_mnglr-&gt;dir = *(uint32_t *)data;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_PROTOCOL</span>:
			<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(uint32_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_PROTOCOL &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;proto != 0) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_PROTOCOL &quot;</span>
				    <span class="enscript-string">&quot;already set %u&quot;</span>,
				    p_pkt_mnglr-&gt;proto);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			p_pkt_mnglr-&gt;proto = *(uint32_t *)data;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PKT_MNGLR_OPT_ACTIVATE</span>:
			<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(uint8_t)) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_ACTIVATE &quot;</span>
				    <span class="enscript-string">&quot;len too small %lu&quot;</span>, len);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;activate != 0) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;PKT_MNGLR_OPT_ACTIVATE &quot;</span>
				    <span class="enscript-string">&quot;already set %u&quot;</span>,
				    p_pkt_mnglr-&gt;activate);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			p_pkt_mnglr-&gt;activate = *(uint8_t *)data;
			PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;p_pkt_mnglr-&gt;activate set to :%d&quot;</span>,
			    p_pkt_mnglr-&gt;activate);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">done</span>:
	pkt_mnglr_rw_unlock_exclusive(&amp;pkt_mnglr_lck_rw);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pkt_mnglr_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> kern_ctl_reg kern_ctl;
	errno_t	error = 0;
	vm_size_t pkt_mnglr_size = 0;

	PKT_MNGLR_LOG(LOG_NOTICE, <span class="enscript-string">&quot;&quot;</span>);

	<span class="enscript-comment">/*
	 * Compile time verifications
	 */</span>
	_CASSERT(PKT_MNGLR_MAX_FILTER_COUNT == MAX_PACKET_MANGLER);

	<span class="enscript-comment">/*
	 * Zone for packet mangler kernel control sockets
	 */</span>
	pkt_mnglr_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> packet_mangler);
	packet_mangler_zone = zinit(pkt_mnglr_size,
	    PACKET_MANGLER_ZONE_MAX * pkt_mnglr_size,
	    0,
	    PACKET_MANGLER_ZONE_NAME);

	<span class="enscript-keyword">if</span> (packet_mangler_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: zinit(%s) failed&quot;</span>, __func__,
		    PACKET_MANGLER_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(packet_mangler_zone, Z_CALLERACCT, FALSE);
	zone_change(packet_mangler_zone, Z_EXPAND, TRUE);

	<span class="enscript-comment">/*
	 * Allocate locks
	 */</span>
	pkt_mnglr_lck_grp_attr = lck_grp_attr_alloc_init();
	<span class="enscript-keyword">if</span> (pkt_mnglr_lck_grp_attr == NULL) {
		panic(<span class="enscript-string">&quot;%s: lck_grp_attr_alloc_init failed&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	pkt_mnglr_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;packet manglerr&quot;</span>,
	    pkt_mnglr_lck_grp_attr);
	<span class="enscript-keyword">if</span> (pkt_mnglr_lck_grp == NULL) {
		panic(<span class="enscript-string">&quot;%s: lck_grp_alloc_init failed&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	pkt_mnglr_lck_attr = lck_attr_alloc_init();
	<span class="enscript-keyword">if</span> (pkt_mnglr_lck_attr == NULL) {
		panic(<span class="enscript-string">&quot;%s: lck_attr_alloc_init failed&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	lck_rw_init(&amp;pkt_mnglr_lck_rw, pkt_mnglr_lck_grp, pkt_mnglr_lck_attr);

	<span class="enscript-comment">/*
	 * Register kernel control
	 */</span>
	bzero(&amp;kern_ctl, <span class="enscript-keyword">sizeof</span>(kern_ctl));
	strlcpy(kern_ctl.ctl_name, PACKET_MANGLER_CONTROL_NAME,
	    <span class="enscript-keyword">sizeof</span>(kern_ctl.ctl_name));
	kern_ctl.ctl_flags = CTL_FLAG_PRIVILEGED | CTL_FLAG_REG_EXTENDED;
	kern_ctl.ctl_connect = pkt_mnglr_ctl_connect;
	kern_ctl.ctl_disconnect = pkt_mnglr_ctl_disconnect;
	kern_ctl.ctl_getopt = pkt_mnglr_ctl_getopt;
	kern_ctl.ctl_setopt = pkt_mnglr_ctl_setopt;
	error = ctl_register(&amp;kern_ctl, &amp;pkt_mnglr_kctlref);
	<span class="enscript-keyword">if</span> (error != 0) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;ctl_register failed: %d&quot;</span>, error);
	} <span class="enscript-keyword">else</span> {
		PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Registered packet mangler kernel control.&quot;</span>);
	}
}

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">pktmnglr_ipfilter_output</span>(<span class="enscript-type">void</span> *cookie, mbuf_t *data, ipf_pktopts_t options)
{
	<span class="enscript-type">struct</span> packet_mangler *p_pkt_mnglr = (<span class="enscript-type">struct</span> packet_mangler *)cookie;
	<span class="enscript-type">struct</span> ip ip;
	<span class="enscript-type">struct</span> tcphdr tcp;
	<span class="enscript-type">int</span> optlen = 0;
	errno_t error = 0;

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">tcp</span>, <span class="enscript-variable-name">optlen</span>, <span class="enscript-variable-name">options</span>)
	<span class="enscript-keyword">if</span> (p_pkt_mnglr == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">output_done</span>;
	}

	<span class="enscript-keyword">if</span> (!p_pkt_mnglr-&gt;activate) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">output_done</span>;
	}

	<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;dir == IN) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">output_done</span>;
	}

	<span class="enscript-keyword">if</span> (data == NULL) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;Data pointer is NULL&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">output_done</span>;
	}

	<span class="enscript-comment">/* Check for IP filter options */</span>
	error = mbuf_copydata(*data, 0, <span class="enscript-keyword">sizeof</span>(ip), &amp;ip);
	<span class="enscript-keyword">if</span> (error) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;Could not make local IP header copy&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">output_done</span>;
	}

	<span class="enscript-keyword">if</span> ((p_pkt_mnglr-&gt;lsaddr.ss_family == AF_INET6) &amp;&amp; (ip.ip_v == 4)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">output_done</span>;
	}

	<span class="enscript-keyword">if</span> ((p_pkt_mnglr-&gt;lsaddr.ss_family == AF_INET) &amp;&amp; (ip.ip_v == 6)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">output_done</span>;
	}

	<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;lsaddr.ss_family == AF_INET) {
		<span class="enscript-type">struct</span> sockaddr_in laddr = *(<span class="enscript-type">struct</span> sockaddr_in *)(&amp;(p_pkt_mnglr-&gt;lsaddr));
		<span class="enscript-keyword">if</span> (ip.ip_src.s_addr != laddr.sin_addr.s_addr) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">output_done</span>;
		}
	}

	<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;rsaddr.ss_family == AF_INET) {
		<span class="enscript-type">struct</span> sockaddr_in raddr = *(<span class="enscript-type">struct</span> sockaddr_in *)(&amp;(p_pkt_mnglr-&gt;rsaddr));
		<span class="enscript-keyword">if</span> (ip.ip_dst.s_addr != raddr.sin_addr.s_addr) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">output_done</span>;
		}
	}

	<span class="enscript-keyword">if</span> (ip.ip_v != 4) {
		PKT_MNGLR_LOG(LOG_INFO,
		    <span class="enscript-string">&quot;%s:%d Not handling IP version %d\n&quot;</span>,
		    __FILE__, __LINE__, ip.ip_v);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">output_done</span>;
	}

<span class="enscript-reference">output_done</span>:
	<span class="enscript-comment">/* Not handling output flow */</span>
	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_MAX_OPTLEN</span>	40

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">pktmnglr_ipfilter_input</span>(<span class="enscript-type">void</span> *cookie, mbuf_t *data, <span class="enscript-type">int</span> offset, u_int8_t protocol)
{
	<span class="enscript-type">struct</span> packet_mangler *p_pkt_mnglr = (<span class="enscript-type">struct</span> packet_mangler *)cookie;
	<span class="enscript-type">struct</span> ip ip;
	<span class="enscript-type">struct</span> tcphdr tcp;
	<span class="enscript-type">char</span> tcp_opt_buf[TCP_MAX_OPTLEN] = {0};
	<span class="enscript-type">int</span> orig_tcp_optlen;
	<span class="enscript-type">int</span> tcp_optlen = 0;
	errno_t error = 0;

	<span class="enscript-keyword">if</span> (p_pkt_mnglr == NULL) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;p_pkt_mnglr is NULL&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
	}

	<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;activate == 0) {
		PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;p_pkt_mnglr not yet activated&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
	}

	<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;dir == OUT) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
	}

	<span class="enscript-keyword">if</span> (data == NULL) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;Data pointer is NULL&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
	}

	<span class="enscript-comment">/* Check for IP filter options */</span>
	error = mbuf_copydata(*data, 0, <span class="enscript-keyword">sizeof</span>(ip), &amp;ip);
	<span class="enscript-keyword">if</span> (error) {
		PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;Could not make local IP header copy&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
	}

	<span class="enscript-keyword">if</span> ((p_pkt_mnglr-&gt;lsaddr.ss_family == AF_INET6) &amp;&amp; (ip.ip_v == 4)) {
		PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Skipping filtering as address family of packet is IPv4 but local &quot;</span>
		    <span class="enscript-string">&quot;address is set to IPv6&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
	}

	<span class="enscript-keyword">if</span> ((p_pkt_mnglr-&gt;lsaddr.ss_family == AF_INET) &amp;&amp; (ip.ip_v == 6)) {
		PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Skipping filtering as address family &quot;</span>
		    <span class="enscript-string">&quot;of packet is IPv6 but local address is set to IPv4&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
	}

	<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;lsaddr.ss_family == AF_INET) {
		<span class="enscript-type">struct</span> sockaddr_in laddr = *(<span class="enscript-type">struct</span> sockaddr_in *)(&amp;(p_pkt_mnglr-&gt;lsaddr));
		<span class="enscript-keyword">if</span> (ip.ip_dst.s_addr != laddr.sin_addr.s_addr) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
		}
	}

	<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;rsaddr.ss_family == AF_INET) {
		<span class="enscript-type">struct</span> sockaddr_in raddr = *(<span class="enscript-type">struct</span> sockaddr_in *)(&amp;(p_pkt_mnglr-&gt;rsaddr));
		<span class="enscript-keyword">if</span> (ip.ip_src.s_addr != raddr.sin_addr.s_addr) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
		}
		PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Remote IP: %x Source IP: %x in input path&quot;</span>,
		    raddr.sin_addr.s_addr,
		    ip.ip_src.s_addr);
	}

	<span class="enscript-keyword">if</span> (ip.ip_v != 4) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
	}

	<span class="enscript-keyword">if</span> (protocol != p_pkt_mnglr-&gt;proto) {
		PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Skip: Protocol mismatch&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
	}

	<span class="enscript-keyword">switch</span> (protocol) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
			error = mbuf_copydata(*data, offset, <span class="enscript-keyword">sizeof</span>(tcp), &amp;tcp);
			<span class="enscript-keyword">if</span> (error) {
				PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;Could not make local TCP header copy&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
			}

			<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;lport &amp;&amp; (p_pkt_mnglr-&gt;lport != tcp.th_dport)) {
				PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Local port and IP des port do not match&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
			}

			<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;rport &amp;&amp; (p_pkt_mnglr-&gt;rport != tcp.th_sport)) {
				PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Remote port and IP src port do not match&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* XXX Do IP actions here */</span>
	PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Proceeding with packet mangler actions on the packet&quot;</span>);

	<span class="enscript-comment">/* Protocol actions */</span>
	<span class="enscript-keyword">switch</span> (protocol) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
			<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;proto_action_mask) {
				<span class="enscript-type">int</span> i = 0;
				tcp_optlen = (tcp.th_off &lt;&lt; 2)-<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr);
				PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Packet from F5 is TCP\n&quot;</span>);
				PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Optlen: %d\n&quot;</span>, tcp_optlen);
				orig_tcp_optlen = tcp_optlen;
				<span class="enscript-keyword">if</span> (orig_tcp_optlen) {
					error = mbuf_copydata(*data, offset+<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr), orig_tcp_optlen, tcp_opt_buf);
					<span class="enscript-keyword">if</span> (error) {
						PKT_MNGLR_LOG(LOG_ERR, <span class="enscript-string">&quot;Failed to copy tcp options&quot;</span>);
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
					}
				}

				<span class="enscript-keyword">while</span> (tcp_optlen) {
					<span class="enscript-keyword">if</span> (tcp_opt_buf[i] == 0x1) {
						PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Skipping NOP\n&quot;</span>);
						tcp_optlen--;
						i++;
						<span class="enscript-keyword">continue</span>;
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((tcp_opt_buf[i] != 0) &amp;&amp; (tcp_opt_buf[i] != TCP_OPT_MULTIPATH_TCP)) {
						PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Skipping option %x\n&quot;</span>, tcp_opt_buf[i]);
						tcp_optlen -= tcp_opt_buf[i+1];
						i += tcp_opt_buf[i+1];
						<span class="enscript-keyword">continue</span>;
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tcp_opt_buf[i] == TCP_OPT_MULTIPATH_TCP) {
						<span class="enscript-type">int</span> j = 0;
						<span class="enscript-type">int</span> mptcpoptlen = tcp_opt_buf[i+1];
						uint8_t sbtver = tcp_opt_buf[i+MPTCP_SBT_VER_OFFSET];
						uint8_t subtype = sbtver &gt;&gt; 4;

						PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Got MPTCP option %x\n&quot;</span>, tcp_opt_buf[i]);
						PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Got MPTCP subtype %x\n&quot;</span>, subtype);
						<span class="enscript-keyword">if</span> (subtype == MPTCP_SUBTYPE_DSS) {
							PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Got DSS option\n&quot;</span>);
							PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Protocol option mask: %d\n&quot;</span>, p_pkt_mnglr-&gt;proto_action_mask);
							<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;proto_action_mask &amp;
							    PKT_MNGLR_TCP_ACT_DSS_DROP) {
								<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop_it</span>;
							}
						}

						PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Got MPTCP option %x\n&quot;</span>, tcp_opt_buf[i]);
						<span class="enscript-keyword">for</span> (; j &lt; mptcpoptlen; j++) {
							<span class="enscript-keyword">if</span> (p_pkt_mnglr-&gt;proto_action_mask &amp;
							    PKT_MNGLR_TCP_ACT_NOP_MPTCP) {
								tcp_opt_buf[i+j] = 0x1;
							}
						}
						tcp_optlen -= mptcpoptlen;
						i += mptcpoptlen;
					} <span class="enscript-keyword">else</span> {
						tcp_optlen--;
						i++;
					}
				}
				error = mbuf_copyback(*data,
				    offset+<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr),
				    orig_tcp_optlen, tcp_opt_buf, MBUF_WAITOK);

				<span class="enscript-keyword">if</span> (error) {
					PKT_MNGLR_LOG(LOG_ERR,
					    <span class="enscript-string">&quot;Failed to copy tcp options&quot;</span>);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">input_done</span>;
				}
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
			<span class="enscript-comment">/* Don't handle UDP */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}
	chksm_update(*data);
<span class="enscript-reference">input_done</span>:
	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">drop_it</span>:
	PKT_MNGLR_LOG(LOG_INFO, <span class="enscript-string">&quot;Dropping packet\n&quot;</span>);
	mbuf_freem(*data);
	<span class="enscript-keyword">return</span> EJUSTRETURN;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pktmnglr_ipfilter_detach</span>(<span class="enscript-type">void</span> *cookie)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cookie</span>)
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/* XXX Still need to modify this to use mbuf_copy* macros */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">chksm_update</span>(mbuf_t data)
{
	u_int16_t ip_sum;
	u_int16_t tsum;
	<span class="enscript-type">struct</span> tcphdr *tcp;

	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *ptr = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)mbuf_data(data);
	<span class="enscript-type">struct</span> ip *ip = (<span class="enscript-type">struct</span> ip *)(<span class="enscript-type">void</span> *)ptr;
	<span class="enscript-keyword">if</span> (ip-&gt;ip_v != 4) {
		<span class="enscript-keyword">return</span>;
	}

	ip-&gt;ip_sum = 0;
	mbuf_inet_cksum(data, 0, 0, ip-&gt;ip_hl &lt;&lt; 2, &amp;ip_sum); <span class="enscript-comment">// ip sum
</span>
	ip-&gt;ip_sum = ip_sum;
	<span class="enscript-keyword">switch</span> (ip-&gt;ip_p) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
			tcp = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)(ptr + (ip-&gt;ip_hl &lt;&lt; 2));
			tcp-&gt;th_sum = 0;
			mbuf_inet_cksum(data, IPPROTO_TCP, ip-&gt;ip_hl &lt;&lt; 2,
			    ntohs(ip-&gt;ip_len) - (ip-&gt;ip_hl &lt;&lt; 2), &amp;tsum);
			tcp-&gt;th_sum = tsum;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
			<span class="enscript-comment">/* Don't handle UDP */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}

	mbuf_clear_csum_performed(data);
	<span class="enscript-keyword">return</span>;
}
</pre>
<hr />
</body></html>