<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ether_inet_pr_module.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ether_inet_pr_module.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2006 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_llc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_protocol.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/if_ether.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_arp.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>

<span class="enscript-comment">/* #include &quot;vlan.h&quot; */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NVLAN</span> &gt; 0
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_vlan_var.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NVLAN &gt; 0 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ether_if_module.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Local function declarations */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *<span class="enscript-function-name">kdp_get_interface</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kdp_set_ip_and_mac_addresses</span>(<span class="enscript-type">struct</span> in_addr *ipaddr,
    <span class="enscript-type">struct</span> ether_addr *macaddr);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">_ip_copy</span>(dst, src)	\
	bcopy(src, dst, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr))

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ether_inet_arp_input</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> ether_arp *ea;
	<span class="enscript-type">struct</span> sockaddr_dl	sender_hw;
	<span class="enscript-type">struct</span> sockaddr_in	sender_ip;
	<span class="enscript-type">struct</span> sockaddr_in	target_ip;

	<span class="enscript-keyword">if</span> (mbuf_len(m) &lt; <span class="enscript-keyword">sizeof</span> (*ea) &amp;&amp; mbuf_pullup(&amp;m, <span class="enscript-keyword">sizeof</span> (*ea)) != 0)
		<span class="enscript-keyword">return</span>;

	ea = mbuf_data(m);

	<span class="enscript-comment">/* Verify this is an ethernet/ip arp and address lengths are correct */</span>
	<span class="enscript-keyword">if</span> (ntohs(ea-&gt;arp_hrd) != ARPHRD_ETHER ||
	    ntohs(ea-&gt;arp_pro) != ETHERTYPE_IP ||
	    ea-&gt;arp_pln != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr) ||
	    ea-&gt;arp_hln != ETHER_ADDR_LEN) {
		mbuf_freem(m);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Verify the sender is not broadcast */</span>
	<span class="enscript-keyword">if</span> (bcmp(ea-&gt;arp_sha, etherbroadcastaddr, ETHER_ADDR_LEN) == 0) {
		mbuf_freem(m);
		<span class="enscript-keyword">return</span>;
	}

	bzero(&amp;sender_ip, <span class="enscript-keyword">sizeof</span> (sender_ip));
	sender_ip.sin_len = <span class="enscript-keyword">sizeof</span> (sender_ip);
	sender_ip.sin_family = AF_INET;
	_ip_copy(&amp;sender_ip.sin_addr, ea-&gt;arp_spa);
	target_ip = sender_ip;
	_ip_copy(&amp;target_ip.sin_addr, ea-&gt;arp_tpa);

	bzero(&amp;sender_hw, <span class="enscript-keyword">sizeof</span> (sender_hw));
	sender_hw.sdl_len = <span class="enscript-keyword">sizeof</span> (sender_hw);
	sender_hw.sdl_family = AF_LINK;
	sender_hw.sdl_type = IFT_ETHER;
	sender_hw.sdl_alen = ETHER_ADDR_LEN;
	bcopy(ea-&gt;arp_sha, LLADDR(&amp;sender_hw), ETHER_ADDR_LEN);

	<span class="enscript-comment">/* update L2 reachability record, if present */</span>
	arp_llreach_set_reachable(ifp, LLADDR(&amp;sender_hw), ETHER_ADDR_LEN);

	arp_ip_handle_input(ifp, ntohs(ea-&gt;arp_op), &amp;sender_hw, &amp;sender_ip,
	    &amp;target_ip);
	mbuf_freem(m);
}

<span class="enscript-comment">/*
 * Process a received Ethernet packet;
 * the packet is in the mbuf chain m without
 * the ether header, which is provided separately.
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ether_inet_input</span>(ifnet_t ifp, protocol_family_t	protocol_family,
    mbuf_t m_list)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">protocol_family</span>)
	mbuf_t	m;
	mbuf_t	*tailptr = &amp;m_list;
	mbuf_t	nextpkt;

	<span class="enscript-comment">/* Strip ARP and non-IP packets out of the list */</span>
	<span class="enscript-keyword">for</span> (m = m_list; m; m = nextpkt) {
		<span class="enscript-type">struct</span> ether_header *eh = mbuf_pkthdr_header(m);
		<span class="enscript-type">struct</span> ifnet *mifp;

		<span class="enscript-comment">/*
		 * Trust the ifp in the mbuf, rather than ifproto's
		 * since the packet could have been injected via
		 * a dlil_input_packet_list() using an ifp that is
		 * different than the one where the packet really
		 * came from.
		 */</span>
		mifp = mbuf_pkthdr_rcvif(m);

		nextpkt = m-&gt;m_nextpkt;

		<span class="enscript-keyword">if</span> (eh-&gt;ether_type == htons(ETHERTYPE_IP)) {
			<span class="enscript-comment">/*
			 * Update L2 reachability record, if present
			 * (and if not a broadcast sender).
			 */</span>
			<span class="enscript-keyword">if</span> (bcmp(eh-&gt;ether_shost, etherbroadcastaddr,
			    ETHER_ADDR_LEN) != 0) {
				arp_llreach_set_reachable(mifp, eh-&gt;ether_shost,
				    ETHER_ADDR_LEN);
			}
			<span class="enscript-comment">/* put this packet in the list */</span>
			*tailptr = m;
			tailptr = &amp;m-&gt;m_nextpkt;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Pass ARP packets to arp input */</span>
			m-&gt;m_nextpkt = NULL;
			<span class="enscript-keyword">if</span> (eh-&gt;ether_type == htons(ETHERTYPE_ARP))
				ether_inet_arp_input(mifp, m);
			<span class="enscript-keyword">else</span>
				mbuf_freem(m);
		}
	}

	*tailptr = NULL;

	<span class="enscript-comment">/* Pass IP list to ip input */</span>
	<span class="enscript-keyword">if</span> (m_list != NULL &amp;&amp; proto_input(PF_INET, m_list) != 0) {
		mbuf_freem_list(m_list);
	}

	<span class="enscript-keyword">return</span> (EJUSTRETURN);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ether_inet_pre_output</span>(ifnet_t ifp, protocol_family_t protocol_family,
    mbuf_t *m0, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *dst_netaddr,
    <span class="enscript-type">void</span> *route, <span class="enscript-type">char</span> *type, <span class="enscript-type">char</span> *edst)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">protocol_family</span>)
	<span class="enscript-type">struct</span> mbuf *m = *m0;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ether_header *eh;
	errno_t result = 0;

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		<span class="enscript-keyword">return</span> (ENETDOWN);

	<span class="enscript-comment">/*
	 * Tell ether_frameout it's ok to loop packet unless negated below.
	 */</span>
	m-&gt;m_flags |= M_LOOP;

	<span class="enscript-keyword">switch</span> (dst_netaddr-&gt;sa_family) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
		<span class="enscript-type">struct</span> sockaddr_dl ll_dest;

		result = arp_lookup_ip(ifp,
		    (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in *)(uintptr_t)(size_t)dst_netaddr,
		    &amp;ll_dest, <span class="enscript-keyword">sizeof</span> (ll_dest), (route_t)route, *m0);
		<span class="enscript-keyword">if</span> (result == 0) {
			u_int16_t ethertype_ip = htons(ETHERTYPE_IP);

			bcopy(LLADDR(&amp;ll_dest), edst, ETHER_ADDR_LEN);
			bcopy(&amp;ethertype_ip, type, <span class="enscript-keyword">sizeof</span> (ethertype_ip));
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">pseudo_AF_HDRCMPLT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_UNSPEC</span>:
		m-&gt;m_flags &amp;= ~M_LOOP;
		eh = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ether_header *)(uintptr_t)(size_t)
		    dst_netaddr-&gt;sa_data;
		(<span class="enscript-type">void</span>) memcpy(edst, eh-&gt;ether_dhost, 6);
		bcopy(&amp;eh-&gt;ether_type, type, <span class="enscript-keyword">sizeof</span> (u_short));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		printf(<span class="enscript-string">&quot;%s: can't handle af%d\n&quot;</span>, if_name(ifp),
		    dst_netaddr-&gt;sa_family);

		result = EAFNOSUPPORT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ether_inet_resolve_multi</span>(ifnet_t ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *proto_addr,
    <span class="enscript-type">struct</span> sockaddr_dl *out_ll, size_t ll_len)
{
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> size_t minsize =
	    offsetof(<span class="enscript-type">struct</span> sockaddr_dl, sdl_data[0]) + ETHER_ADDR_LEN;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in *sin =
	    (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in *)(uintptr_t)(size_t)proto_addr;

	<span class="enscript-keyword">if</span> (proto_addr-&gt;sa_family != AF_INET)
		<span class="enscript-keyword">return</span> (EAFNOSUPPORT);

	<span class="enscript-keyword">if</span> (proto_addr-&gt;sa_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (ll_len &lt; minsize)
		<span class="enscript-keyword">return</span> (EMSGSIZE);

	bzero(out_ll, minsize);
	out_ll-&gt;sdl_len = minsize;
	out_ll-&gt;sdl_family = AF_LINK;
	out_ll-&gt;sdl_index = ifp-&gt;if_index;
	out_ll-&gt;sdl_type = IFT_ETHER;
	out_ll-&gt;sdl_nlen = 0;
	out_ll-&gt;sdl_alen = ETHER_ADDR_LEN;
	out_ll-&gt;sdl_slen = 0;
	ETHER_MAP_IP_MULTICAST(&amp;sin-&gt;sin_addr, LLADDR(out_ll));

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ether_inet_prmod_ioctl</span>(ifnet_t ifp, protocol_family_t protocol_family,
    u_long command, <span class="enscript-type">void</span> *data)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">protocol_family</span>)
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (command) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFADDR</span>:		<span class="enscript-comment">/* struct ifaddr pointer */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFADDR</span>: {		<span class="enscript-comment">/* struct ifaddr pointer */</span>
		<span class="enscript-comment">/*
		 * Note: caller of ifnet_ioctl() passes in pointer to
		 * struct ifaddr as parameter to SIOC{A,S}IFADDR, for
		 * legacy reasons.
		 */</span>
		<span class="enscript-type">struct</span> ifaddr *ifa = data;

		<span class="enscript-keyword">if</span> (!(ifnet_flags(ifp) &amp; IFF_RUNNING)) {
			ifnet_set_flags(ifp, IFF_UP, IFF_UP);
			ifnet_ioctl(ifp, 0, SIOCSIFFLAGS, NULL);
		}

		<span class="enscript-keyword">if</span> (ifaddr_address_family(ifa) != AF_INET)
			<span class="enscript-keyword">break</span>;

		inet_arp_init_ifaddr(ifp, ifa);

		<span class="enscript-keyword">if</span> (command != SIOCSIFADDR)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * Register new IP and MAC addresses with the kernel
		 * debugger if the interface is the same as was registered
		 * by IOKernelDebugger. If no interface was registered,
		 * fall back and just match against en0 interface.
		 * Do this only for the first address of the interface
		 * and not for aliases.
		 */</span>
		<span class="enscript-keyword">if</span> ((kdp_get_interface() != 0 &amp;&amp;
		    kdp_get_interface() == ifp-&gt;if_softc) ||
		    (kdp_get_interface() == 0 &amp;&amp; ifp-&gt;if_unit == 0))
			kdp_set_ip_and_mac_addresses(&amp;(IA_SIN(ifa)-&gt;sin_addr),
			    (<span class="enscript-type">struct</span> ether_addr *)IF_LLADDR(ifp));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFADDR</span>: {		<span class="enscript-comment">/* struct ifreq */</span>
		<span class="enscript-type">struct</span> ifreq *ifr = data;
		ifnet_guarded_lladdr_copy_bytes(ifp, ifr-&gt;ifr_addr.sa_data,
		    ETHER_ADDR_LEN);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		error = EOPNOTSUPP;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ether_inet_event</span>(ifnet_t ifp, protocol_family_t protocol,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> kev_msg *event)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">protocol</span>)
	ifaddr_t *addresses;

	<span class="enscript-keyword">if</span> (event-&gt;vendor_code !=  KEV_VENDOR_APPLE ||
	    event-&gt;kev_class != KEV_NETWORK_CLASS ||
	    event-&gt;kev_subclass != KEV_DL_SUBCLASS ||
	    event-&gt;event_code != KEV_DL_LINK_ADDRESS_CHANGED) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (ifnet_get_address_list_family(ifp, &amp;addresses, AF_INET) == 0) {
		<span class="enscript-type">int</span> i;

		<span class="enscript-keyword">for</span> (i = 0; addresses[i] != NULL; i++) {
			inet_arp_init_ifaddr(ifp, addresses[i]);
		}

		ifnet_free_address_list(addresses);
	}
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ether_inet_arp</span>(ifnet_t ifp, u_short arpop, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *sender_hw,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sender_proto, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *target_hw,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *target_proto)
{
	mbuf_t	m;
	errno_t	result;
	<span class="enscript-type">struct</span> ether_header *eh;
	<span class="enscript-type">struct</span> ether_arp *ea;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in *sender_ip =
	    (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in *)(uintptr_t)(size_t)sender_proto;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_inarp *target_ip =
	    (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_inarp *)(uintptr_t)(size_t)target_proto;
	<span class="enscript-type">char</span> *datap;

	<span class="enscript-keyword">if</span> (target_ip == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> ((sender_ip &amp;&amp; sender_ip-&gt;sin_family != AF_INET) ||
	    target_ip-&gt;sin_family != AF_INET)
		<span class="enscript-keyword">return</span> (EAFNOSUPPORT);

	result = mbuf_gethdr(MBUF_DONTWAIT, MBUF_TYPE_DATA, &amp;m);
	<span class="enscript-keyword">if</span> (result != 0)
		<span class="enscript-keyword">return</span> (result);

	mbuf_setlen(m, <span class="enscript-keyword">sizeof</span> (*ea));
	mbuf_pkthdr_setlen(m, <span class="enscript-keyword">sizeof</span> (*ea));

	<span class="enscript-comment">/* Move the data pointer in the mbuf to the end, aligned to 4 bytes */</span>
	datap = mbuf_datastart(m);
	datap += mbuf_trailingspace(m);
	datap -= (((uintptr_t)datap) &amp; 0x3);
	mbuf_setdata(m, datap, <span class="enscript-keyword">sizeof</span> (*ea));
	ea = mbuf_data(m);

	<span class="enscript-comment">/*
	 * Prepend the ethernet header, we will send the raw frame;
	 * callee frees the original mbuf when allocation fails.
	 */</span>
	result = mbuf_prepend(&amp;m, <span class="enscript-keyword">sizeof</span> (*eh), MBUF_DONTWAIT);
	<span class="enscript-keyword">if</span> (result != 0)
		<span class="enscript-keyword">return</span> (result);

	eh = mbuf_data(m);
	eh-&gt;ether_type = htons(ETHERTYPE_ARP);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	mac_mbuf_label_associate_linklayer(ifp, m);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Fill out the arp header */</span>
	ea-&gt;arp_pro = htons(ETHERTYPE_IP);
	ea-&gt;arp_hln = <span class="enscript-keyword">sizeof</span> (ea-&gt;arp_sha);
	ea-&gt;arp_pln = <span class="enscript-keyword">sizeof</span> (ea-&gt;arp_spa);
	ea-&gt;arp_hrd = htons(ARPHRD_ETHER);
	ea-&gt;arp_op = htons(arpop);

	<span class="enscript-comment">/* Sender Hardware */</span>
	<span class="enscript-keyword">if</span> (sender_hw != NULL) {
		bcopy(CONST_LLADDR(sender_hw), ea-&gt;arp_sha,
		    <span class="enscript-keyword">sizeof</span> (ea-&gt;arp_sha));
	} <span class="enscript-keyword">else</span> {
		ifnet_lladdr_copy_bytes(ifp, ea-&gt;arp_sha, ETHER_ADDR_LEN);
	}
	ifnet_lladdr_copy_bytes(ifp, eh-&gt;ether_shost, <span class="enscript-keyword">sizeof</span> (eh-&gt;ether_shost));

	<span class="enscript-comment">/* Sender IP */</span>
	<span class="enscript-keyword">if</span> (sender_ip != NULL) {
		bcopy(&amp;sender_ip-&gt;sin_addr, ea-&gt;arp_spa, <span class="enscript-keyword">sizeof</span> (ea-&gt;arp_spa));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> ifaddr *ifa;

		<span class="enscript-comment">/* Look for an IP address to use as our source */</span>
		ifnet_lock_shared(ifp);
		TAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrhead, ifa_link) {
			IFA_LOCK(ifa);
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr != NULL &amp;&amp;
			    ifa-&gt;ifa_addr-&gt;sa_family == AF_INET) {
				bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)
				    ifa-&gt;ifa_addr)-&gt;sin_addr, ea-&gt;arp_spa,
				    <span class="enscript-keyword">sizeof</span> (ea-&gt;arp_spa));
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">break</span>;
			}
			IFA_UNLOCK(ifa);
		}
		ifnet_lock_done(ifp);

		<span class="enscript-keyword">if</span> (ifa == NULL) {
			mbuf_freem(m);
			<span class="enscript-keyword">return</span> (ENXIO);
		}
	}

	<span class="enscript-comment">/* Target Hardware */</span>
	<span class="enscript-keyword">if</span> (target_hw == NULL) {
		bzero(ea-&gt;arp_tha, <span class="enscript-keyword">sizeof</span> (ea-&gt;arp_tha));
		bcopy(etherbroadcastaddr, eh-&gt;ether_dhost,
		    <span class="enscript-keyword">sizeof</span> (eh-&gt;ether_dhost));
		m-&gt;m_flags |= M_BCAST;
	} <span class="enscript-keyword">else</span> {
		bcopy(CONST_LLADDR(target_hw), ea-&gt;arp_tha,
		    <span class="enscript-keyword">sizeof</span> (ea-&gt;arp_tha));
		bcopy(CONST_LLADDR(target_hw), eh-&gt;ether_dhost,
		    <span class="enscript-keyword">sizeof</span> (eh-&gt;ether_dhost));

		<span class="enscript-keyword">if</span> (bcmp(eh-&gt;ether_dhost, etherbroadcastaddr,
		    ETHER_ADDR_LEN) == 0)
			m-&gt;m_flags |= M_BCAST;
	}

	<span class="enscript-comment">/* Target IP */</span>
	bcopy(&amp;target_ip-&gt;sin_addr, ea-&gt;arp_tpa, <span class="enscript-keyword">sizeof</span> (ea-&gt;arp_tpa));

	<span class="enscript-comment">/*
	 * PKTF_{INET,INET6}_RESOLVE_RTR are mutually exclusive, so make
	 * sure only one of them is set (just in case.)
	 */</span>
	m-&gt;m_pkthdr.pkt_flags &amp;= ~(PKTF_INET6_RESOLVE | PKTF_RESOLVE_RTR);
	m-&gt;m_pkthdr.pkt_flags |= PKTF_INET_RESOLVE;
	<span class="enscript-comment">/*
	 * If this is an ARP request for a (default) router, mark
	 * the packet accordingly so that the driver can find out,
	 * in case it needs to perform driver-specific action(s).
	 */</span>
	<span class="enscript-keyword">if</span> (arpop == ARPOP_REQUEST &amp;&amp; (target_ip-&gt;sin_other &amp; SIN_ROUTER))
		m-&gt;m_pkthdr.pkt_flags |= PKTF_RESOLVE_RTR;

	<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_TXSTART) {
		<span class="enscript-comment">/*
		 * Use control service class if the interface
		 * supports transmit-start model
		 */</span>
		(<span class="enscript-type">void</span>) m_set_service_class(m, MBUF_SC_CTL);
	}

	ifnet_output_raw(ifp, PF_INET, m);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ether_attach_inet</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t proto_family)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">proto_family</span>)
	<span class="enscript-type">struct</span> ifnet_attach_proto_param_v2 proto;
	<span class="enscript-type">struct</span> ifnet_demux_desc demux[2];
	u_short en_native = htons(ETHERTYPE_IP);
	u_short arp_native = htons(ETHERTYPE_ARP);
	errno_t	error;

	bzero(&amp;demux[0], <span class="enscript-keyword">sizeof</span> (demux));
	demux[0].type = DLIL_DESC_ETYPE2;
	demux[0].data = &amp;en_native;
	demux[0].datalen = <span class="enscript-keyword">sizeof</span> (en_native);
	demux[1].type = DLIL_DESC_ETYPE2;
	demux[1].data = &amp;arp_native;
	demux[1].datalen = <span class="enscript-keyword">sizeof</span> (arp_native);

	bzero(&amp;proto, <span class="enscript-keyword">sizeof</span> (proto));
	proto.demux_list = demux;
	proto.demux_count = <span class="enscript-keyword">sizeof</span> (demux) / <span class="enscript-keyword">sizeof</span> (demux[0]);
	proto.input = ether_inet_input;
	proto.pre_output = ether_inet_pre_output;
	proto.ioctl = ether_inet_prmod_ioctl;
	proto.event = ether_inet_event;
	proto.resolve = ether_inet_resolve_multi;
	proto.send_arp = ether_inet_arp;

	error = ifnet_attach_protocol_v2(ifp, proto_family, &amp;proto);
	<span class="enscript-keyword">if</span> (error &amp;&amp; error != EEXIST) {
		printf(<span class="enscript-string">&quot;WARNING: %s can't attach ip to %s\n&quot;</span>, __func__,
		    if_name(ifp));
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ether_detach_inet</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t proto_family)
{
	(<span class="enscript-type">void</span>) ifnet_detach_protocol(ifp, proto_family);
}
</pre>
<hr />
</body></html>