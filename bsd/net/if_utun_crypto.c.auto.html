<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>if_utun_crypto.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">if_utun_crypto.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>



#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_utun.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span> 
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_utun_crypto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_utun_crypto_ipsec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_utun_crypto_dtls.h&gt;</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_init_crypto</span> (<span class="enscript-type">void</span>)
{
	utun_ctl_init_crypto_dtls();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">utun_cleanup_crypto</span> (<span class="enscript-type">struct</span> utun_pcb *pcb)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	utun_cleanup_all_crypto_ipsec(pcb);
#<span class="enscript-reference">endif</span>
	utun_cleanup_all_crypto_dtls(pcb);
	pcb-&gt;utun_flags &amp;= ~UTUN_FLAGS_CRYPTO;
}

errno_t
<span class="enscript-function-name">utun_ctl_enable_crypto</span> (__unused kern_ctl_ref  kctlref,
			__unused u_int32_t     unit, 
			__unused <span class="enscript-type">void</span>         *unitinfo,
			__unused <span class="enscript-type">int</span>           opt, 
			<span class="enscript-type">void</span>                  *data, 
			size_t                 len)
{
	<span class="enscript-type">struct</span> utun_pcb	*pcb = unitinfo;

	<span class="enscript-comment">/*
	 * - verify the crypto context args passed from user-land.
	 *    - check the size of the argument buffer.
	 *    - check the direction (IN or OUT)
	 *    - check the type (IPSec or DTLS)
	 * - ensure that the crypto context is *not* already valid (don't recreate already valid context).
	 *    - we have only one context per direction and type.
	 * - any error should be equivalent to noop.
	 */</span>
	<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_ARGS_HDR_SIZE) {
		<span class="enscript-keyword">return</span> EMSGSIZE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span>                 idx;
		utun_crypto_args_t *crypto_args = (__typeof__(crypto_args))data;
		utun_crypto_ctx_t  *crypto_ctx;

		<span class="enscript-keyword">if</span> (crypto_args-&gt;ver == 0 || crypto_args-&gt;ver &gt;= UTUN_CRYPTO_ARGS_VER_MAX) {
			printf(<span class="enscript-string">&quot;%s: ver check failed %d\n&quot;</span>, __FUNCTION__, crypto_args-&gt;ver);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_args-&gt;type == 0 || crypto_args-&gt;type &gt;= UTUN_CRYPTO_TYPE_MAX) {
			printf(<span class="enscript-string">&quot;%s: type check failed %d\n&quot;</span>, __FUNCTION__, crypto_args-&gt;type);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_ARGS_TOTAL_SIZE(crypto_args)) {
			printf(<span class="enscript-string">&quot;%s: vlen check failed (%d,%d)\n&quot;</span>, __FUNCTION__,
				   (<span class="enscript-type">int</span>)len, (<span class="enscript-type">int</span>)UTUN_CRYPTO_ARGS_TOTAL_SIZE(crypto_args));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_args-&gt;args_ulen != <span class="enscript-keyword">sizeof</span>(crypto_args-&gt;u)) {
			printf(<span class="enscript-string">&quot;%s: compatibility mode\n&quot;</span>, __FUNCTION__);
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		<span class="enscript-keyword">if</span> (crypto_args-&gt;type == UTUN_CRYPTO_TYPE_IPSEC) {
			utun_ctl_enable_crypto_ipsec(pcb, crypto_args);
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (crypto_args-&gt;type == UTUN_CRYPTO_TYPE_DTLS) {
			utun_ctl_enable_crypto_dtls(pcb, crypto_args);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// unsupported
</span>			<span class="enscript-keyword">return</span> EPROTONOSUPPORT;
		}
		<span class="enscript-keyword">for</span> (idx = 0; idx &lt; UTUN_CRYPTO_DIR_TO_IDX(UTUN_CRYPTO_DIR_MAX); idx++) {
			crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[idx];
			<span class="enscript-keyword">if</span> (crypto_ctx-&gt;valid) {
				<span class="enscript-keyword">return</span> EBADF;
			}

			crypto_ctx-&gt;type = crypto_args-&gt;type;
			LIST_INIT(&amp;crypto_ctx-&gt;keys_listhead);
			LIST_INIT(&amp;crypto_ctx-&gt;framer_listheads[UTUN_CRYPTO_INNER_TYPE_TO_IDX(UTUN_CRYPTO_INNER_TYPE_IPv4)]);
			LIST_INIT(&amp;crypto_ctx-&gt;framer_listheads[UTUN_CRYPTO_INNER_TYPE_TO_IDX(UTUN_CRYPTO_INNER_TYPE_IPv6)]);
			crypto_ctx-&gt;valid = 1;
			printf(<span class="enscript-string">&quot;%s: initialized framer lists\n&quot;</span>, __FUNCTION__);
		}
		<span class="enscript-comment">// data traffic is stopped by default
</span>		pcb-&gt;utun_flags |= (UTUN_FLAGS_CRYPTO | UTUN_FLAGS_CRYPTO_STOP_DATA_TRAFFIC);
		<span class="enscript-keyword">return</span> 0;
	}
}

errno_t
<span class="enscript-function-name">utun_ctl_disable_crypto</span> (__unused kern_ctl_ref  kctlref,
			 __unused u_int32_t     unit, 
			 __unused <span class="enscript-type">void</span>         *unitinfo,
			 __unused <span class="enscript-type">int</span>           opt, 
			 <span class="enscript-type">void</span>                  *data, 
			 size_t                 len)
{
	<span class="enscript-type">struct</span> utun_pcb	*pcb = unitinfo;

	<span class="enscript-comment">/*
	 * - verify the crypto context args passed from user-land.
	 *    - check the size of the argument buffer.
	 *    - check the direction (IN or OUT)
	 *    - check the type (IPSec or DTLS)
	 * - ensure that the crypto context *is* already valid (don't release invalid context).
	 *    - we have only one context per direction and type.
	 * - ensure that the crypto context has no crypto material.
	 * - any error should be equivalent to noop.
	 */</span>
	<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_ARGS_HDR_SIZE) {
		<span class="enscript-keyword">return</span> EMSGSIZE;
	} <span class="enscript-keyword">else</span> {
		utun_crypto_args_t *crypto_args = (__typeof__(crypto_args))data;

		<span class="enscript-keyword">if</span> (crypto_args-&gt;ver == 0 || crypto_args-&gt;ver &gt;= UTUN_CRYPTO_ARGS_VER_MAX) {
			printf(<span class="enscript-string">&quot;%s: ver check failed %d\n&quot;</span>, __FUNCTION__, crypto_args-&gt;ver);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_args-&gt;type == 0 || crypto_args-&gt;type &gt;= UTUN_CRYPTO_TYPE_MAX) {
			printf(<span class="enscript-string">&quot;%s: type check failed %d\n&quot;</span>, __FUNCTION__, crypto_args-&gt;type);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_ARGS_TOTAL_SIZE(crypto_args)) {
			printf(<span class="enscript-string">&quot;%s: vlen check failed (%d,%d)\n&quot;</span>, __FUNCTION__,
				   (<span class="enscript-type">int</span>)len, (<span class="enscript-type">int</span>)UTUN_CRYPTO_ARGS_TOTAL_SIZE(crypto_args));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_args-&gt;args_ulen != <span class="enscript-keyword">sizeof</span>(crypto_args-&gt;u)) {
			printf(<span class="enscript-string">&quot;%s: compatibility mode\n&quot;</span>, __FUNCTION__);
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		<span class="enscript-keyword">if</span> (crypto_args-&gt;type == UTUN_CRYPTO_TYPE_IPSEC) {
			utun_ctl_disable_crypto_ipsec(pcb);
		} <span class="enscript-keyword">else</span> 
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (crypto_args-&gt;type == UTUN_CRYPTO_TYPE_DTLS) {
			utun_ctl_disable_crypto_dtls(pcb);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// unsupported
</span>			<span class="enscript-keyword">return</span> EPROTONOSUPPORT;
		}
	}
	pcb-&gt;utun_flags &amp;= ~(UTUN_FLAGS_CRYPTO | UTUN_FLAGS_CRYPTO_STOP_DATA_TRAFFIC);
	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">utun_ctl_config_crypto_keys</span> (__unused kern_ctl_ref  kctlref,
			     __unused u_int32_t     unit, 
			     __unused <span class="enscript-type">void</span>         *unitinfo,
			     __unused <span class="enscript-type">int</span>           opt, 
			     <span class="enscript-type">void</span>                  *data, 
			     size_t                 len)
{
	<span class="enscript-type">struct</span> utun_pcb *pcb = unitinfo;

	<span class="enscript-comment">/*
	 * - verify the crypto material args passed from user-land.
	 *    - check the size of the argument buffer.
	 *    - check the direction (IN or OUT)
	 *    - check the type (IPSec only)
	 *    - crypto material direction and type must match the associated crypto context's.
	 *        - we can have a list of crypto materials per context.
	 * - ensure that the crypto context is already valid (don't add crypto material to invalid context).
	 * - any error should be equivalent to noop.
	 */</span>
	<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_KEYS_ARGS_HDR_SIZE) {
		<span class="enscript-keyword">return</span> EMSGSIZE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span>                      idx;
		utun_crypto_keys_args_t *crypto_keys_args = (__typeof__(crypto_keys_args))data;
		utun_crypto_ctx_t       *crypto_ctx;
		utun_crypto_keys_t      *crypto_keys = NULL;

		<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;ver == 0 || crypto_keys_args-&gt;ver &gt;= UTUN_CRYPTO_KEYS_ARGS_VER_MAX) {
			printf(<span class="enscript-string">&quot;%s: ver check failed %d\n&quot;</span>, __FUNCTION__, crypto_keys_args-&gt;ver);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;dir == 0 || crypto_keys_args-&gt;dir &gt;= UTUN_CRYPTO_DIR_MAX) {
			printf(<span class="enscript-string">&quot;%s: dir check failed %d\n&quot;</span>, __FUNCTION__, crypto_keys_args-&gt;dir);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;type == 0 || crypto_keys_args-&gt;type &gt;= UTUN_CRYPTO_TYPE_MAX) {
			printf(<span class="enscript-string">&quot;%s: type check failed %d\n&quot;</span>, __FUNCTION__, crypto_keys_args-&gt;type);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_KEYS_ARGS_TOTAL_SIZE(crypto_keys_args)) {
			printf(<span class="enscript-string">&quot;%s: vlen check failed (%d,%d)\n&quot;</span>, __FUNCTION__,
				   (<span class="enscript-type">int</span>)len, (<span class="enscript-type">int</span>)UTUN_CRYPTO_KEYS_ARGS_TOTAL_SIZE(crypto_keys_args));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		idx = UTUN_CRYPTO_DIR_TO_IDX(crypto_keys_args-&gt;dir);
		crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[idx];
		<span class="enscript-keyword">if</span> (!crypto_ctx-&gt;valid) {
			<span class="enscript-keyword">return</span> EBADF;
		}
		<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;type != crypto_ctx-&gt;type) {
			<span class="enscript-comment">// can't add keymat to context with different crypto type
</span>			<span class="enscript-keyword">return</span> ENOENT;
		}
		crypto_keys = utun_alloc(<span class="enscript-keyword">sizeof</span>(*crypto_keys));
		<span class="enscript-keyword">if</span> (!crypto_keys) {
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		bzero(crypto_keys, <span class="enscript-keyword">sizeof</span>(*crypto_keys));
		<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;args_ulen != <span class="enscript-keyword">sizeof</span>(crypto_keys_args-&gt;u)) {
			printf(<span class="enscript-string">&quot;%s: compatibility mode\n&quot;</span>, __FUNCTION__);
		}

		<span class="enscript-comment">// branch-off for ipsec vs. dtls
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;type == UTUN_CRYPTO_TYPE_IPSEC) {
			errno_t err;
			<span class="enscript-keyword">if</span> ((err = utun_ctl_config_crypto_keys_ipsec(pcb, crypto_keys_args, crypto_keys))) {
				utun_free(crypto_keys);
				<span class="enscript-keyword">return</span> err;
			}
		} <span class="enscript-keyword">else</span> 
#<span class="enscript-reference">endif</span>
		{
			<span class="enscript-comment">// unsupported
</span>			utun_free(crypto_keys);
			<span class="enscript-keyword">return</span> EPROTONOSUPPORT;
		}
		crypto_keys-&gt;type = crypto_keys_args-&gt;type;
		LIST_INSERT_HEAD(&amp;crypto_ctx-&gt;keys_listhead, crypto_keys, chain);
		crypto_keys-&gt;valid = 1;
	}

	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">utun_ctl_unconfig_crypto_keys</span> (__unused kern_ctl_ref  kctlref,
			       __unused u_int32_t     unit, 
			       __unused <span class="enscript-type">void</span>         *unitinfo,
			       __unused <span class="enscript-type">int</span>           opt, 
			       <span class="enscript-type">void</span>                  *data, 
			       size_t                 len)
{
	<span class="enscript-type">struct</span> utun_pcb *pcb = unitinfo;

	<span class="enscript-comment">/*
	 * - verify the crypto material args passed from user-land.
	 *    - check the size of the argument buffer.
	 *    - check the direction (IN or OUT)
	 *    - check the type (IPSec only)
	 *    - crypto material direction and type must match the associated crypto context's.
	 *        - we can have a list of crypto materials per context.
	 * - ensure that the crypto context is already valid (don't add crypto material to invalid context).
	 * - any error should be equivalent to noop.
	 */</span>
	<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_KEYS_ARGS_HDR_SIZE) {
		<span class="enscript-keyword">return</span> EMSGSIZE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span>                      idx;
		utun_crypto_keys_args_t *crypto_keys_args = (__typeof__(crypto_keys_args))data;
		utun_crypto_ctx_t       *crypto_ctx;
		utun_crypto_keys_t      *cur_crypto_keys, *nxt_crypto_keys;

		<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;ver == 0 || crypto_keys_args-&gt;ver &gt;= UTUN_CRYPTO_KEYS_ARGS_VER_MAX) {
			printf(<span class="enscript-string">&quot;%s: ver check failed %d\n&quot;</span>, __FUNCTION__, crypto_keys_args-&gt;ver);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;dir == 0 || crypto_keys_args-&gt;dir &gt;= UTUN_CRYPTO_DIR_MAX) {
			printf(<span class="enscript-string">&quot;%s: dir check failed %d\n&quot;</span>, __FUNCTION__, crypto_keys_args-&gt;dir);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;type == 0 || crypto_keys_args-&gt;type &gt;= UTUN_CRYPTO_TYPE_MAX) {
			printf(<span class="enscript-string">&quot;%s: type check failed %d\n&quot;</span>, __FUNCTION__, crypto_keys_args-&gt;type);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_KEYS_ARGS_TOTAL_SIZE(crypto_keys_args)) {
			printf(<span class="enscript-string">&quot;%s: vlen check failed (%d,%d)\n&quot;</span>, __FUNCTION__,
				   (<span class="enscript-type">int</span>)len, (<span class="enscript-type">int</span>)UTUN_CRYPTO_KEYS_ARGS_TOTAL_SIZE(crypto_keys_args));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		idx = UTUN_CRYPTO_DIR_TO_IDX(crypto_keys_args-&gt;dir);
		crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[idx];
		<span class="enscript-keyword">if</span> (!crypto_ctx-&gt;valid) {
			<span class="enscript-keyword">return</span> EBADF;
		}
		<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;type != crypto_ctx-&gt;type) {
			<span class="enscript-comment">// can't add keymat to context with different crypto type
</span>			<span class="enscript-keyword">return</span> ENOENT;
		}
		<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;args_ulen != <span class="enscript-keyword">sizeof</span>(crypto_keys_args-&gt;u)) {
 			printf(<span class="enscript-string">&quot;%s: compatibility mode\n&quot;</span>, __FUNCTION__);
		}

		<span class="enscript-comment">// traverse crypto materials looking for the right one
</span>		<span class="enscript-keyword">for</span> (cur_crypto_keys = (__typeof__(cur_crypto_keys))LIST_FIRST(&amp;crypto_ctx-&gt;keys_listhead);
			 cur_crypto_keys != NULL;
			 cur_crypto_keys = nxt_crypto_keys) {
			nxt_crypto_keys = (__typeof__(nxt_crypto_keys))LIST_NEXT(cur_crypto_keys, chain);
			<span class="enscript-comment">// branch-off for ipsec vs. dtls
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
			<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;type == UTUN_CRYPTO_TYPE_IPSEC) {
				<span class="enscript-keyword">if</span> (crypto_keys_args-&gt;u.ipsec_v1.spi == cur_crypto_keys-&gt;state.u.ipsec.spi) {
					errno_t err;
					<span class="enscript-keyword">if</span> ((err = utun_ctl_unconfig_crypto_keys_ipsec(crypto_keys_args, cur_crypto_keys))) {
						<span class="enscript-keyword">return</span> err;
					}
					LIST_REMOVE(cur_crypto_keys, chain);
					bzero(cur_crypto_keys, <span class="enscript-keyword">sizeof</span>(*cur_crypto_keys));
					utun_free(cur_crypto_keys);
					<span class="enscript-keyword">return</span> 0;
				}
			} <span class="enscript-keyword">else</span> 
#<span class="enscript-reference">endif</span>
			{
				<span class="enscript-comment">// unsupported
</span>				<span class="enscript-keyword">return</span> EPROTONOSUPPORT;
			}
		}
		<span class="enscript-comment">// TODO: if there is no SA left, ensure utun can't decrypt/encrypt packets directly. it should rely on the vpnplugin for that.
</span>	}

	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">utun_ctl_config_crypto_framer</span> (__unused kern_ctl_ref  kctlref,
			       __unused u_int32_t     unit, 
			       __unused <span class="enscript-type">void</span>         *unitinfo,
			       __unused <span class="enscript-type">int</span>           opt, 
			       <span class="enscript-type">void</span>                  *data, 
			       size_t                 len)
{
	<span class="enscript-type">struct</span> utun_pcb *pcb = unitinfo;

	<span class="enscript-comment">/*
	 * - verify the crypto material args passed from user-land.
	 *    - check the size of the argument buffer.
	 *    - check the direction (IN or OUT)
	 *    - check the type (DTLS only)
	 *    - crypto material direction and type must match the associated crypto context's.
	 *        - we can have a list of crypto materials per context.
	 * - ensure that the crypto context is already valid (don't add crypto material to invalid context).
	 * - any error should be equivalent to noop.
	 */</span>
	<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_FRAMER_ARGS_HDR_SIZE) {
		<span class="enscript-keyword">return</span> EMSGSIZE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span>                        idx;
		utun_crypto_framer_args_t *framer_args = (__typeof__(framer_args))data;
		utun_crypto_ctx_t         *crypto_ctx;

		<span class="enscript-keyword">if</span> (framer_args-&gt;ver == 0 || framer_args-&gt;ver &gt;= UTUN_CRYPTO_FRAMER_ARGS_VER_MAX) {
			printf(<span class="enscript-string">&quot;%s: ver check failed %d\n&quot;</span>, __FUNCTION__, (<span class="enscript-type">int</span>)framer_args-&gt;ver);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (framer_args-&gt;dir == 0 || framer_args-&gt;dir &gt;= UTUN_CRYPTO_DIR_MAX) {
			printf(<span class="enscript-string">&quot;%s: dir check failed %d\n&quot;</span>, __FUNCTION__, (<span class="enscript-type">int</span>)framer_args-&gt;dir);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (framer_args-&gt;type == 0 || framer_args-&gt;type &gt;= UTUN_CRYPTO_TYPE_MAX) {
			printf(<span class="enscript-string">&quot;%s: type check failed %d\n&quot;</span>, __FUNCTION__, (<span class="enscript-type">int</span>)framer_args-&gt;type);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_FRAMER_ARGS_TOTAL_SIZE(framer_args)) {
			printf(<span class="enscript-string">&quot;%s: vlen check failed (%d,%d)\n&quot;</span>, __FUNCTION__,
			       (<span class="enscript-type">int</span>)len, (<span class="enscript-type">int</span>)UTUN_CRYPTO_FRAMER_ARGS_TOTAL_SIZE(framer_args));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		idx = UTUN_CRYPTO_DIR_TO_IDX(framer_args-&gt;dir);
		crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[idx];
		<span class="enscript-keyword">if</span> (!crypto_ctx-&gt;valid) {
			<span class="enscript-keyword">return</span> EBADF;
		}
		<span class="enscript-keyword">if</span> (framer_args-&gt;type != crypto_ctx-&gt;type) {
			<span class="enscript-comment">// can't add keymat to context with different crypto type
</span>			<span class="enscript-keyword">return</span> ENOENT;
		}
		<span class="enscript-keyword">if</span> (framer_args-&gt;args_ulen != <span class="enscript-keyword">sizeof</span>(framer_args-&gt;u)) {
			printf(<span class="enscript-string">&quot;%s: compatibility mode\n&quot;</span>, __FUNCTION__);
			<span class="enscript-comment">// TODO:
</span>		}

		<span class="enscript-comment">// branch-off for ipsec vs. dtls
</span>		<span class="enscript-keyword">if</span> (framer_args-&gt;type == UTUN_CRYPTO_TYPE_DTLS) {
			errno_t err;
			<span class="enscript-keyword">if</span> ((err = utun_ctl_config_crypto_dtls_framer(crypto_ctx, framer_args))) {
				<span class="enscript-keyword">return</span> err;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// unsupported
</span>			<span class="enscript-keyword">return</span> EPROTONOSUPPORT;
		}
	}

	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">utun_ctl_unconfig_crypto_framer</span> (__unused kern_ctl_ref  kctlref,
				 __unused u_int32_t     unit, 
				 __unused <span class="enscript-type">void</span>         *unitinfo,
				 __unused <span class="enscript-type">int</span>           opt, 
				 <span class="enscript-type">void</span>                  *data, 
				 size_t                 len)
{
	<span class="enscript-type">struct</span> utun_pcb *pcb = unitinfo;

	<span class="enscript-comment">/*
	 * - verify the crypto material args passed from user-land.
	 *    - check the size of the argument buffer.
	 *    - check the direction (IN or OUT)
	 *    - check the type (DTLS only)
	 *    - crypto material direction and type must match the associated crypto context's.
	 *        - we can have a list of crypto materials per context.
	 * - ensure that the crypto context is already valid (don't add crypto material to invalid context).
	 * - any error should be equivalent to noop.
	 */</span>
	<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_FRAMER_ARGS_HDR_SIZE) {
		<span class="enscript-keyword">return</span> EMSGSIZE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span>                        idx;
		utun_crypto_framer_args_t *framer_args = (__typeof__(framer_args))data;
		utun_crypto_ctx_t         *crypto_ctx;

		<span class="enscript-keyword">if</span> (framer_args-&gt;ver == 0 || framer_args-&gt;ver &gt;= UTUN_CRYPTO_FRAMER_ARGS_VER_MAX) {
			printf(<span class="enscript-string">&quot;%s: ver check failed %d\n&quot;</span>, __FUNCTION__, (<span class="enscript-type">int</span>)framer_args-&gt;ver);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (framer_args-&gt;dir == 0 || framer_args-&gt;dir &gt;= UTUN_CRYPTO_DIR_MAX) {
			printf(<span class="enscript-string">&quot;%s: dir check failed %d\n&quot;</span>, __FUNCTION__, (<span class="enscript-type">int</span>)framer_args-&gt;dir);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (framer_args-&gt;type == 0 || framer_args-&gt;type &gt;= UTUN_CRYPTO_TYPE_MAX) {
			printf(<span class="enscript-string">&quot;%s: type check failed %d\n&quot;</span>, __FUNCTION__, (<span class="enscript-type">int</span>)framer_args-&gt;type);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_FRAMER_ARGS_TOTAL_SIZE(framer_args)) {
		  	printf(<span class="enscript-string">&quot;%s: vlen check failed (%d,%d)\n&quot;</span>, __FUNCTION__,
		  		   (<span class="enscript-type">int</span>)len, (<span class="enscript-type">int</span>)UTUN_CRYPTO_FRAMER_ARGS_TOTAL_SIZE(framer_args));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		idx = UTUN_CRYPTO_DIR_TO_IDX(framer_args-&gt;dir);
		crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[idx];
		<span class="enscript-keyword">if</span> (!crypto_ctx-&gt;valid) {
			<span class="enscript-keyword">return</span> EBADF;
		}
		<span class="enscript-keyword">if</span> (framer_args-&gt;type != crypto_ctx-&gt;type) {
			<span class="enscript-comment">// can't add keymat to context with different crypto type
</span>			<span class="enscript-keyword">return</span> ENOENT;
		}
		<span class="enscript-keyword">if</span> (framer_args-&gt;args_ulen != <span class="enscript-keyword">sizeof</span>(framer_args-&gt;u)) {
			printf(<span class="enscript-string">&quot;%s: compatibility mode\n&quot;</span>, __FUNCTION__);
		}

		<span class="enscript-comment">// branch-off for ipsec vs. dtls
</span>		<span class="enscript-keyword">if</span> (framer_args-&gt;type == UTUN_CRYPTO_TYPE_DTLS) {
			errno_t err;
			<span class="enscript-keyword">if</span> ((err = utun_ctl_unconfig_crypto_dtls_framer(crypto_ctx, framer_args))) {
				<span class="enscript-keyword">return</span> err;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// unsupported
</span>			<span class="enscript-keyword">return</span> EPROTONOSUPPORT;
		}
	}

	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">utun_ctl_generate_crypto_keys_idx</span> (__unused kern_ctl_ref   kctlref,
				   __unused u_int32_t      unit, 
				   __unused <span class="enscript-type">void</span>          *unitinfo,
				   __unused <span class="enscript-type">int</span>            opt, 
				   <span class="enscript-type">void</span>                   *data, 
				   size_t                 *len)
{
	<span class="enscript-type">struct</span> utun_pcb	*pcb = unitinfo;

	<span class="enscript-comment">/*
	 * - verify the crypto material index args passed from user-land.
	 *    - check the size of the argument buffer.
	 *    - check the direction (IN or OUT)
	 *    - check the type (IPSec only)
	 *    - crypto material direction and type must match the associated crypto context's.
	 *        - we can have a list of crypto materials per context.
	 * - any error should be equivalent to noop.
	 */</span>
	<span class="enscript-keyword">if</span> (*len &lt; UTUN_CRYPTO_KEYS_IDX_ARGS_HDR_SIZE) {
		<span class="enscript-keyword">return</span> EMSGSIZE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span>                          idx;
		utun_crypto_keys_idx_args_t *crypto_keys_idx_args = (__typeof__(crypto_keys_idx_args))data;
		utun_crypto_ctx_t           *crypto_ctx;

		<span class="enscript-keyword">if</span> (crypto_keys_idx_args-&gt;ver == 0 || crypto_keys_idx_args-&gt;ver &gt;= UTUN_CRYPTO_KEYS_ARGS_VER_MAX) {
			printf(<span class="enscript-string">&quot;%s: ver check failed %d\n&quot;</span>, __FUNCTION__, crypto_keys_idx_args-&gt;ver);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_keys_idx_args-&gt;dir == 0 || crypto_keys_idx_args-&gt;dir &gt;= UTUN_CRYPTO_DIR_MAX) {
			printf(<span class="enscript-string">&quot;%s: dir check failed %d\n&quot;</span>, __FUNCTION__, crypto_keys_idx_args-&gt;dir);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_keys_idx_args-&gt;type == 0 || crypto_keys_idx_args-&gt;type &gt;= UTUN_CRYPTO_TYPE_MAX) {
			printf(<span class="enscript-string">&quot;%s: type check failed %d\n&quot;</span>, __FUNCTION__, crypto_keys_idx_args-&gt;type);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (*len &lt; UTUN_CRYPTO_KEYS_IDX_ARGS_TOTAL_SIZE(crypto_keys_idx_args)) {
			printf(<span class="enscript-string">&quot;%s: vlen check failed (%d,%d)\n&quot;</span>, __FUNCTION__,
				   (<span class="enscript-type">int</span>)*len, (<span class="enscript-type">int</span>)UTUN_CRYPTO_KEYS_IDX_ARGS_TOTAL_SIZE(crypto_keys_idx_args));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		idx = UTUN_CRYPTO_DIR_TO_IDX(crypto_keys_idx_args-&gt;dir);
		crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[idx];
		<span class="enscript-keyword">if</span> (!crypto_ctx-&gt;valid) {
			<span class="enscript-keyword">return</span> EBADF;
		}
		<span class="enscript-keyword">if</span> (crypto_keys_idx_args-&gt;type != crypto_ctx-&gt;type) {
			<span class="enscript-comment">// can't add keymat to context with different crypto type
</span>			<span class="enscript-keyword">return</span> ENOENT;
		}
		<span class="enscript-keyword">if</span> (crypto_keys_idx_args-&gt;args_ulen != <span class="enscript-keyword">sizeof</span>(crypto_keys_idx_args-&gt;u)) {
			printf(<span class="enscript-string">&quot;%s: compatibility mode\n&quot;</span>, __FUNCTION__);
		}

		<span class="enscript-comment">// traverse crypto materials looking for the right one
</span>		<span class="enscript-comment">// branch-off for ipsec vs. dtls
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		<span class="enscript-keyword">if</span> (crypto_keys_idx_args-&gt;type == UTUN_CRYPTO_TYPE_IPSEC) {
			errno_t err;
			<span class="enscript-keyword">if</span> ((err = utun_ctl_generate_crypto_keys_idx_ipsec(crypto_keys_idx_args))) {
				<span class="enscript-keyword">return</span> err;
			}
		} <span class="enscript-keyword">else</span> 
#<span class="enscript-reference">endif</span>
		{
			<span class="enscript-comment">// unsupported
</span>			<span class="enscript-keyword">return</span> EPROTONOSUPPORT;
		}
	}

	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">utun_ctl_stop_crypto_data_traffic</span> (__unused kern_ctl_ref  kctlref,
				   __unused u_int32_t     unit, 
				   __unused <span class="enscript-type">void</span>         *unitinfo,
				   __unused <span class="enscript-type">int</span>           opt, 
				   <span class="enscript-type">void</span>                  *data, 
				   size_t                 len)
{
	<span class="enscript-type">struct</span> utun_pcb	*pcb = unitinfo;

	<span class="enscript-comment">/*
	 * - verify the crypto context args passed from user-land.
	 *    - check the size of the argument buffer.
	 *    - check the direction (IN or OUT)
	 *    - check the type (IPSec or DTLS)
	 * - ensure that the crypto context *is* already valid (don't release invalid context).
	 *    - we have only one context per direction and type.
	 * - ensure that the crypto context has no crypto material.
	 * - any error should be equivalent to noop.
	 */</span>
	<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_ARGS_HDR_SIZE) {
		<span class="enscript-keyword">return</span> EMSGSIZE;
	} <span class="enscript-keyword">else</span> {
		utun_crypto_args_t *crypto_args = (__typeof__(crypto_args))data;

		<span class="enscript-keyword">if</span> (crypto_args-&gt;ver == 0 || crypto_args-&gt;ver &gt;= UTUN_CRYPTO_ARGS_VER_MAX) {
			printf(<span class="enscript-string">&quot;%s: ver check failed %d\n&quot;</span>, __FUNCTION__, crypto_args-&gt;ver);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_args-&gt;type == 0 || crypto_args-&gt;type &gt;= UTUN_CRYPTO_TYPE_MAX) {
			printf(<span class="enscript-string">&quot;%s: type check failed %d\n&quot;</span>, __FUNCTION__, crypto_args-&gt;type);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_ARGS_TOTAL_SIZE(crypto_args)) {
			printf(<span class="enscript-string">&quot;%s: vlen check failed (%d,%d)\n&quot;</span>, __FUNCTION__,
				   (<span class="enscript-type">int</span>)len, (<span class="enscript-type">int</span>)UTUN_CRYPTO_ARGS_TOTAL_SIZE(crypto_args));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_args-&gt;args_ulen != <span class="enscript-keyword">sizeof</span>(crypto_args-&gt;u)) {
			printf(<span class="enscript-string">&quot;%s: compatibility mode\n&quot;</span>, __FUNCTION__);
		}

		<span class="enscript-keyword">if</span> ((pcb-&gt;utun_flags &amp; UTUN_FLAGS_CRYPTO) == 0) {
			printf(<span class="enscript-string">&quot;%s: crypto is already disabled\n&quot;</span>, __FUNCTION__);
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-keyword">if</span> (crypto_args-&gt;type == UTUN_CRYPTO_TYPE_IPSEC) {
			<span class="enscript-comment">// nothing
</span>		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (crypto_args-&gt;type == UTUN_CRYPTO_TYPE_DTLS) {
			utun_ctl_stop_datatraffic_crypto_dtls(pcb);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// unsupported
</span>			<span class="enscript-keyword">return</span> EPROTONOSUPPORT;
		}
	}
	pcb-&gt;utun_flags |= UTUN_FLAGS_CRYPTO_STOP_DATA_TRAFFIC;
	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">utun_ctl_start_crypto_data_traffic</span> (__unused kern_ctl_ref  kctlref,
				    __unused u_int32_t     unit, 
				    __unused <span class="enscript-type">void</span>         *unitinfo,
				    __unused <span class="enscript-type">int</span>           opt, 
				    <span class="enscript-type">void</span>                  *data, 
				    size_t                 len)
{
	<span class="enscript-type">struct</span> utun_pcb	*pcb = unitinfo;

	<span class="enscript-comment">/*
	 * - verify the crypto context args passed from user-land.
	 *    - check the size of the argument buffer.
	 *    - check the direction (IN or OUT)
	 *    - check the type (IPSec or DTLS)
	 * - ensure that the crypto context *is* already valid (don't release invalid context).
	 *    - we have only one context per direction and type.
	 * - ensure that the crypto context has no crypto material.
	 * - any error should be equivalent to noop.
	 */</span>
	<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_ARGS_HDR_SIZE) {
		<span class="enscript-keyword">return</span> EMSGSIZE;
	} <span class="enscript-keyword">else</span> {
		utun_crypto_args_t *crypto_args = (__typeof__(crypto_args))data;

		<span class="enscript-keyword">if</span> (crypto_args-&gt;ver == 0 || crypto_args-&gt;ver &gt;= UTUN_CRYPTO_ARGS_VER_MAX) {
			printf(<span class="enscript-string">&quot;%s: ver check failed %d\n&quot;</span>, __FUNCTION__, crypto_args-&gt;ver);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_args-&gt;type == 0 || crypto_args-&gt;type &gt;= UTUN_CRYPTO_TYPE_MAX) {
			printf(<span class="enscript-string">&quot;%s: type check failed %d\n&quot;</span>, __FUNCTION__, crypto_args-&gt;type);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (len &lt; UTUN_CRYPTO_ARGS_TOTAL_SIZE(crypto_args)) {
			printf(<span class="enscript-string">&quot;%s: vlen check failed (%d,%d)\n&quot;</span>, __FUNCTION__,
				   (<span class="enscript-type">int</span>)len, (<span class="enscript-type">int</span>)UTUN_CRYPTO_ARGS_TOTAL_SIZE(crypto_args));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (crypto_args-&gt;args_ulen != <span class="enscript-keyword">sizeof</span>(crypto_args-&gt;u)) {
			printf(<span class="enscript-string">&quot;%s: compatibility mode\n&quot;</span>, __FUNCTION__);
		}

		<span class="enscript-keyword">if</span> ((pcb-&gt;utun_flags &amp; UTUN_FLAGS_CRYPTO) == 0) {
			printf(<span class="enscript-string">&quot;%s: crypto is already disabled\n&quot;</span>, __FUNCTION__);
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-keyword">if</span> (crypto_args-&gt;type == UTUN_CRYPTO_TYPE_IPSEC) {
			<span class="enscript-comment">// nothing
</span>		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (crypto_args-&gt;type == UTUN_CRYPTO_TYPE_DTLS) {
			utun_ctl_start_datatraffic_crypto_dtls(pcb);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// unsupported
</span>			<span class="enscript-keyword">return</span> EPROTONOSUPPORT;
		}
	}
	pcb-&gt;utun_flags &amp;= ~UTUN_FLAGS_CRYPTO_STOP_DATA_TRAFFIC;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">utun_pkt_crypto_output</span> (<span class="enscript-type">struct</span> utun_pcb *pcb, mbuf_t *m)
{
	<span class="enscript-type">int</span> idx = UTUN_CRYPTO_DIR_TO_IDX(UTUN_CRYPTO_DIR_OUT);
	<span class="enscript-keyword">if</span> (!pcb-&gt;utun_crypto_ctx[idx].valid) {
		printf(<span class="enscript-string">&quot;%s: context is invalid %d\n&quot;</span>, __FUNCTION__, pcb-&gt;utun_crypto_ctx[idx].valid);
		<span class="enscript-keyword">return</span> -1;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (pcb-&gt;utun_crypto_ctx[idx].type ==  UTUN_CRYPTO_TYPE_IPSEC) {
		<span class="enscript-keyword">return</span>(utun_pkt_ipsec_output(pcb, m));
	} <span class="enscript-keyword">else</span> 
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (pcb-&gt;utun_crypto_ctx[idx].type ==  UTUN_CRYPTO_TYPE_DTLS) {
		<span class="enscript-keyword">return</span>(utun_pkt_dtls_output(pcb, m));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// unsupported
</span>		printf(<span class="enscript-string">&quot;%s: type is invalid %d\n&quot;</span>, __FUNCTION__, pcb-&gt;utun_crypto_ctx[idx].type);
	}
	<span class="enscript-keyword">return</span> -1;
}
</pre>
<hr />
</body></html>