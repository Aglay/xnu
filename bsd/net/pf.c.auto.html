<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>pf.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">pf.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
ï»¿<span class="enscript-comment">/*
 * Copyright (c) 2007-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$apfw: git commit 6602420f2f101b74305cd78f7cd9e0c8fdedae97 $ */</span>
<span class="enscript-comment">/*	$OpenBSD: pf.c,v 1.567 2008/02/20 23:40:13 henning Exp $ */</span>

<span class="enscript-comment">/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002 - 2013 Henning Brauer
 * NAT64 - Copyright (c) 2010 Viagenie Inc. (<a href="http://www.viagenie.ca">http://www.viagenie.ca</a>)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/endian.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/random.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/md5.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bpf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_icmp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_fsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_ether.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ethernet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/flowhash.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_pflog.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_pfsync.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_dummynet.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

<span class="enscript-comment">/*
 * For RandomULong(), to get a 32 bits random value 
 * Note that random() returns a 31 bits value, see rdar://11159750
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPFPRINTF</span>(n, x)	(pf_status.debug &gt;= (n) ? printf x : ((void)0))

<span class="enscript-comment">/*
 * On Mac OS X, the rtableid value is treated as the interface scope
 * value that is equivalent to the interface index used for scoped
 * routing.  A valid scope value is anything but IFSCOPE_NONE (0),
 * as per definition of ifindex which is a positive, non-zero number.
 * The other BSDs treat a negative rtableid value as invalid, hence
 * the test against INT_MAX to handle userland apps which initialize
 * the field with a negative number.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PF_RTABLEID_IS_VALID</span>(r) \
	((r) &gt; IFSCOPE_NONE &amp;&amp; (r) &lt;= INT_MAX)

<span class="enscript-comment">/*
 * Global variables
 */</span>
<span class="enscript-function-name">decl_lck_mtx_data</span>(,pf_lock_data);
<span class="enscript-function-name">decl_lck_rw_data</span>(,pf_perim_lock_data);
lck_mtx_t *pf_lock = &amp;pf_lock_data;
lck_rw_t *pf_perim_lock = &amp;pf_perim_lock_data;

<span class="enscript-comment">/* state tables */</span>
<span class="enscript-type">struct</span> pf_state_tree_lan_ext	 pf_statetbl_lan_ext;
<span class="enscript-type">struct</span> pf_state_tree_ext_gwy	 pf_statetbl_ext_gwy;

<span class="enscript-type">struct</span> pf_palist	 pf_pabuf;
<span class="enscript-type">struct</span> pf_status	 pf_status;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
<span class="enscript-type">struct</span> pf_altqqueue	 pf_altqs[2];
<span class="enscript-type">struct</span> pf_altqqueue	*pf_altqs_active;
<span class="enscript-type">struct</span> pf_altqqueue	*pf_altqs_inactive;
u_int32_t		 ticket_altqs_active;
u_int32_t		 ticket_altqs_inactive;
<span class="enscript-type">int</span>			 altqs_inactive_open;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
u_int32_t		 ticket_pabuf;

<span class="enscript-type">static</span> MD5_CTX		 pf_tcp_secret_ctx;
<span class="enscript-type">static</span> u_char		 pf_tcp_secret[16];
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_tcp_secret_init;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_tcp_iss_off;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pf_anchor_stackframe {
	<span class="enscript-type">struct</span> pf_ruleset			*rs;
	<span class="enscript-type">struct</span> pf_rule				*r;
	<span class="enscript-type">struct</span> pf_anchor_node			*parent;
	<span class="enscript-type">struct</span> pf_anchor			*child;
} pf_anchor_stack[64];

<span class="enscript-type">struct</span> pool		 pf_src_tree_pl, pf_rule_pl, pf_pooladdr_pl;
<span class="enscript-type">struct</span> pool		 pf_state_pl, pf_state_key_pl;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
<span class="enscript-type">struct</span> pool		 pf_altq_pl;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*hook_fn_t)(<span class="enscript-type">void</span> *);

<span class="enscript-type">struct</span> hook_desc {
	TAILQ_ENTRY(hook_desc) hd_list;
	hook_fn_t hd_fn;
	<span class="enscript-type">void</span> *hd_arg;
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HOOK_REMOVE</span>	0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HOOK_FREE</span>	0x02
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HOOK_ABORT</span>	0x04

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		*hook_establish(<span class="enscript-type">struct</span> hook_desc_head *, <span class="enscript-type">int</span>,
			    hook_fn_t, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		hook_runloop(<span class="enscript-type">struct</span> hook_desc_head *, <span class="enscript-type">int</span> flags);

<span class="enscript-type">struct</span> pool		 pf_app_state_pl;
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_print_addr(<span class="enscript-type">struct</span> pf_addr *addr, sa_family_t af);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_print_sk_host(<span class="enscript-type">struct</span> pf_state_host *, u_int8_t, <span class="enscript-type">int</span>,
			    u_int8_t);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_print_host(<span class="enscript-type">struct</span> pf_addr *, u_int16_t, u_int8_t);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_init_threshold(<span class="enscript-type">struct</span> pf_threshold *, u_int32_t,
			    u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_add_threshold(<span class="enscript-type">struct</span> pf_threshold *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_check_threshold(<span class="enscript-type">struct</span> pf_threshold *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_change_ap(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> pf_addr *,
			    u_int16_t *, u_int16_t *, u_int16_t *,
			    <span class="enscript-type">struct</span> pf_addr *, u_int16_t, u_int8_t, sa_family_t,
			    sa_family_t, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_modulate_sack(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> pf_pdesc *,
			    <span class="enscript-type">struct</span> tcphdr *, <span class="enscript-type">struct</span> pf_state_peer *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_change_a6(<span class="enscript-type">struct</span> pf_addr *, u_int16_t *,
			    <span class="enscript-type">struct</span> pf_addr *, u_int8_t);
<span class="enscript-type">void</span>			 pf_change_addr(<span class="enscript-type">struct</span> pf_addr *a, u_int16_t *c,
					<span class="enscript-type">struct</span> pf_addr *an, u_int8_t u,
					sa_family_t af, sa_family_t afn);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_change_icmp(<span class="enscript-type">struct</span> pf_addr *, u_int16_t *,
			    <span class="enscript-type">struct</span> pf_addr *, <span class="enscript-type">struct</span> pf_addr *, u_int16_t,
			    u_int16_t *, u_int16_t *, u_int16_t *,
			    u_int16_t *, u_int8_t, sa_family_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_send_tcp(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> pf_rule *, sa_family_t,
			    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> pf_addr *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> pf_addr *,
			    u_int16_t, u_int16_t, u_int32_t, u_int32_t,
			    u_int8_t, u_int16_t, u_int16_t, u_int8_t, <span class="enscript-type">int</span>,
			    u_int16_t, <span class="enscript-type">struct</span> ether_header *, <span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_send_icmp(<span class="enscript-type">struct</span> mbuf *, u_int8_t, u_int8_t,
			    sa_family_t, <span class="enscript-type">struct</span> pf_rule *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pf_rule	*pf_match_translation(<span class="enscript-type">struct</span> pf_pdesc *, <span class="enscript-type">struct</span> mbuf *,
			    <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> pfi_kif *, <span class="enscript-type">struct</span> pf_addr *,
			    <span class="enscript-type">union</span> pf_state_xport *, <span class="enscript-type">struct</span> pf_addr *,
			    <span class="enscript-type">union</span> pf_state_xport *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pf_rule	*pf_get_translation_aux(<span class="enscript-type">struct</span> pf_pdesc *,
			    <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> pfi_kif *,
			    <span class="enscript-type">struct</span> pf_src_node **, <span class="enscript-type">struct</span> pf_addr *,
			    <span class="enscript-type">union</span> pf_state_xport *, <span class="enscript-type">struct</span> pf_addr *,
			    <span class="enscript-type">union</span> pf_state_xport *, <span class="enscript-type">union</span> pf_state_xport *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_attach_state(<span class="enscript-type">struct</span> pf_state_key *,
			    <span class="enscript-type">struct</span> pf_state *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_detach_state(<span class="enscript-type">struct</span> pf_state *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> u_int32_t	 pf_tcp_iss(<span class="enscript-type">struct</span> pf_pdesc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_test_rule(<span class="enscript-type">struct</span> pf_rule **, <span class="enscript-type">struct</span> pf_state **,
			    <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> pfi_kif *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>,
			    <span class="enscript-type">void</span> *, <span class="enscript-type">struct</span> pf_pdesc *, <span class="enscript-type">struct</span> pf_rule **,
			    <span class="enscript-type">struct</span> pf_ruleset **, <span class="enscript-type">struct</span> ifqueue *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_test_dummynet(<span class="enscript-type">struct</span> pf_rule **, <span class="enscript-type">int</span>, 
			    <span class="enscript-type">struct</span> pfi_kif *, <span class="enscript-type">struct</span> mbuf **, 
			    <span class="enscript-type">struct</span> pf_pdesc *, <span class="enscript-type">struct</span> ip_fw_args *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_test_fragment(<span class="enscript-type">struct</span> pf_rule **, <span class="enscript-type">int</span>,
			    <span class="enscript-type">struct</span> pfi_kif *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">void</span> *,
			    <span class="enscript-type">struct</span> pf_pdesc *, <span class="enscript-type">struct</span> pf_rule **,
			    <span class="enscript-type">struct</span> pf_ruleset **);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_test_state_tcp(<span class="enscript-type">struct</span> pf_state **, <span class="enscript-type">int</span>,
			    <span class="enscript-type">struct</span> pfi_kif *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>,
			    <span class="enscript-type">void</span> *, <span class="enscript-type">struct</span> pf_pdesc *, u_short *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_test_state_udp(<span class="enscript-type">struct</span> pf_state **, <span class="enscript-type">int</span>,
			    <span class="enscript-type">struct</span> pfi_kif *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>,
			    <span class="enscript-type">void</span> *, <span class="enscript-type">struct</span> pf_pdesc *, u_short *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_test_state_icmp(<span class="enscript-type">struct</span> pf_state **, <span class="enscript-type">int</span>,
			    <span class="enscript-type">struct</span> pfi_kif *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>,
			    <span class="enscript-type">void</span> *, <span class="enscript-type">struct</span> pf_pdesc *, u_short *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_test_state_other(<span class="enscript-type">struct</span> pf_state **, <span class="enscript-type">int</span>,
			    <span class="enscript-type">struct</span> pfi_kif *, <span class="enscript-type">struct</span> pf_pdesc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_match_tag(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> pf_rule *,
			    <span class="enscript-type">struct</span> pf_mtag *, <span class="enscript-type">int</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_hash(<span class="enscript-type">struct</span> pf_addr *, <span class="enscript-type">struct</span> pf_addr *,
			    <span class="enscript-type">struct</span> pf_poolhashkey *, sa_family_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_map_addr(u_int8_t, <span class="enscript-type">struct</span> pf_rule *,
			    <span class="enscript-type">struct</span> pf_addr *, <span class="enscript-type">struct</span> pf_addr *,
			    <span class="enscript-type">struct</span> pf_addr *, <span class="enscript-type">struct</span> pf_src_node **);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_get_sport(<span class="enscript-type">struct</span> pf_pdesc *, <span class="enscript-type">struct</span> pfi_kif *,
			    <span class="enscript-type">struct</span> pf_rule *, <span class="enscript-type">struct</span> pf_addr *,
			    <span class="enscript-type">union</span> pf_state_xport *, <span class="enscript-type">struct</span> pf_addr *,
			    <span class="enscript-type">union</span> pf_state_xport *, <span class="enscript-type">struct</span> pf_addr *,
			    <span class="enscript-type">union</span> pf_state_xport *, <span class="enscript-type">struct</span> pf_src_node **);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_route(<span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> pf_rule *, <span class="enscript-type">int</span>,
			    <span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> pf_state *,
			    <span class="enscript-type">struct</span> pf_pdesc *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_route6(<span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> pf_rule *, <span class="enscript-type">int</span>,
			    <span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> pf_state *,
			    <span class="enscript-type">struct</span> pf_pdesc *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
<span class="enscript-type">static</span> u_int8_t		 pf_get_wscale(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, u_int16_t,
			    sa_family_t);
<span class="enscript-type">static</span> u_int16_t	 pf_get_mss(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, u_int16_t,
			    sa_family_t);
<span class="enscript-type">static</span> u_int16_t	 pf_calc_mss(<span class="enscript-type">struct</span> pf_addr *, sa_family_t,
				u_int16_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_set_rt_ifp(<span class="enscript-type">struct</span> pf_state *,
			    <span class="enscript-type">struct</span> pf_addr *, sa_family_t af);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_check_proto_cksum(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>,
			    u_int8_t, sa_family_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_addr_wrap_neq(<span class="enscript-type">struct</span> pf_addr_wrap *,
			    <span class="enscript-type">struct</span> pf_addr_wrap *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pf_state	*pf_find_state(<span class="enscript-type">struct</span> pfi_kif *,
			    <span class="enscript-type">struct</span> pf_state_key_cmp *, u_int);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_src_connlimit(<span class="enscript-type">struct</span> pf_state **);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		 pf_stateins_err(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">struct</span> pf_state *,
			    <span class="enscript-type">struct</span> pfi_kif *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		 pf_check_congestion(<span class="enscript-type">struct</span> ifqueue *);

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">pf_pptp_ctrl_type_name</span>(u_int16_t code);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		pf_pptp_handler(<span class="enscript-type">struct</span> pf_state *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>,
			    <span class="enscript-type">struct</span> pf_pdesc *, <span class="enscript-type">struct</span> pfi_kif *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		pf_pptp_unlink(<span class="enscript-type">struct</span> pf_state *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		pf_grev1_unlink(<span class="enscript-type">struct</span> pf_state *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		pf_test_state_grev1(<span class="enscript-type">struct</span> pf_state **, <span class="enscript-type">int</span>,
			    <span class="enscript-type">struct</span> pfi_kif *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> pf_pdesc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		pf_ike_compare(<span class="enscript-type">struct</span> pf_app_state *,
			    <span class="enscript-type">struct</span> pf_app_state *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		pf_test_state_esp(<span class="enscript-type">struct</span> pf_state **, <span class="enscript-type">int</span>,
			    <span class="enscript-type">struct</span> pfi_kif *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> pf_pdesc *);

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> pool pfr_ktable_pl;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> pool pfr_kentry_pl;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> path_mtu_discovery;

<span class="enscript-type">struct</span> pf_pool_limit pf_pool_limits[PF_LIMIT_MAX] = {
	{ &amp;pf_state_pl, PFSTATE_HIWAT },
	{ &amp;pf_app_state_pl, PFAPPSTATE_HIWAT },
	{ &amp;pf_src_tree_pl, PFSNODE_HIWAT },
	{ &amp;pf_frent_pl, PFFRAG_FRENT_HIWAT },
	{ &amp;pfr_ktable_pl, PFR_KTABLE_HIWAT },
	{ &amp;pfr_kentry_pl, PFR_KENTRY_HIWAT },
};

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">pf_lazy_makewritable</span>(<span class="enscript-type">struct</span> pf_pdesc *pd, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> len)
{
	<span class="enscript-keyword">if</span> (pd-&gt;lmw &lt; 0)
		<span class="enscript-keyword">return</span> (0);

	VERIFY(m == pd-&gt;mp);

	<span class="enscript-keyword">if</span> (len &gt; pd-&gt;lmw) {
		<span class="enscript-keyword">if</span> (m_makewritable(&amp;m, 0, len, M_DONTWAIT))
			len = -1;
		pd-&gt;lmw = len;
		<span class="enscript-keyword">if</span> (len &gt;= 0 &amp;&amp; m != pd-&gt;mp) {
			pd-&gt;mp = m;
			pd-&gt;pf_mtag = pf_find_mtag(m);

			<span class="enscript-keyword">switch</span> (pd-&gt;af) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
				<span class="enscript-type">struct</span> ip *h = mtod(m, <span class="enscript-type">struct</span> ip *);
				pd-&gt;src = (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip_src;
				pd-&gt;dst = (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip_dst;
				pd-&gt;ip_sum = &amp;h-&gt;ip_sum;
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
				<span class="enscript-type">struct</span> ip6_hdr *h = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
				pd-&gt;src = (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip6_src;
				pd-&gt;dst = (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip6_dst;
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			}
		}
	}

	<span class="enscript-keyword">return</span> (len &lt; 0 ? 0 : m);
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> *
<span class="enscript-function-name">pf_state_lookup_aux</span>(<span class="enscript-type">struct</span> pf_state **state, <span class="enscript-type">struct</span> pfi_kif *kif,
	<span class="enscript-type">int</span> direction, <span class="enscript-type">int</span> *action)
{
	<span class="enscript-keyword">if</span> (*state == NULL || (*state)-&gt;timeout == PFTM_PURGE) {
		*action = PF_DROP;
		<span class="enscript-keyword">return</span> (action);
	}

	<span class="enscript-keyword">if</span> (direction == PF_OUT &amp;&amp;
	    (((*state)-&gt;rule.ptr-&gt;rt == PF_ROUTETO &amp;&amp;
	    (*state)-&gt;rule.ptr-&gt;direction == PF_OUT) ||
	    ((*state)-&gt;rule.ptr-&gt;rt == PF_REPLYTO &amp;&amp;
	    (*state)-&gt;rule.ptr-&gt;direction == PF_IN)) &amp;&amp;
	    (*state)-&gt;rt_kif != NULL &amp;&amp; (*state)-&gt;rt_kif != kif) {
		*action = PF_PASS;
		<span class="enscript-keyword">return</span> (action);
	}

	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATE_LOOKUP</span>()							 \
	<span class="enscript-keyword">do</span> {								 \
		<span class="enscript-type">int</span> action;						 \
		*state = pf_find_state(kif, &amp;key, direction);		 \
		<span class="enscript-keyword">if</span> (*state != NULL &amp;&amp; pd != NULL &amp;&amp;			 \
		    !(pd-&gt;pktflags &amp; PKTF_FLOW_ID)) {			 \
			pd-&gt;flowsrc = (*state)-&gt;state_key-&gt;flowsrc;	 \
			pd-&gt;flowhash = (*state)-&gt;state_key-&gt;flowhash;	 \
			<span class="enscript-keyword">if</span> (pd-&gt;flowhash != 0) {			 \
				pd-&gt;pktflags |= PKTF_FLOW_ID;		 \
				pd-&gt;pktflags &amp;= ~PKTF_FLOW_ADV;		 \
			}						 \
		}							 \
		<span class="enscript-keyword">if</span> (pf_state_lookup_aux(state, kif, direction, &amp;action)) \
			<span class="enscript-keyword">return</span> (action);				 \
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STATE_ADDR_TRANSLATE</span>(sk)					\
	(sk)-&gt;lan.addr.addr32[0] != (sk)-&gt;gwy.addr.addr32[0] ||		\
	((sk)-&gt;af_lan == AF_INET6 &amp;&amp;					\
	((sk)-&gt;lan.addr.addr32[1] != (sk)-&gt;gwy.addr.addr32[1] ||	\
	(sk)-&gt;lan.addr.addr32[2] != (sk)-&gt;gwy.addr.addr32[2] ||		\
	(sk)-&gt;lan.addr.addr32[3] != (sk)-&gt;gwy.addr.addr32[3]))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATE_TRANSLATE</span>(sk)						\
	((sk)-&gt;af_lan != (sk)-&gt;af_gwy ||				\
	STATE_ADDR_TRANSLATE(sk) ||					\
	(sk)-&gt;lan.xport.port != (sk)-&gt;gwy.xport.port)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATE_GRE_TRANSLATE</span>(sk)						\
	(STATE_ADDR_TRANSLATE(sk) ||					\
	(sk)-&gt;lan.xport.call_id != (sk)-&gt;gwy.xport.call_id)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">BOUND_IFACE</span>(r, k) \
	((r)-&gt;rule_flag &amp; PFRULE_IFBOUND) ? (k) : pfi_all

#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATE_INC_COUNTERS</span>(s)					\
	<span class="enscript-keyword">do</span> {							\
		s-&gt;rule.ptr-&gt;states++;				\
		VERIFY(s-&gt;rule.ptr-&gt;states != 0);		\
		<span class="enscript-keyword">if</span> (s-&gt;anchor.ptr != NULL) {			\
			s-&gt;anchor.ptr-&gt;states++;		\
			VERIFY(s-&gt;anchor.ptr-&gt;states != 0);	\
		}						\
		<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr != NULL) {			\
			s-&gt;nat_rule.ptr-&gt;states++;		\
			VERIFY(s-&gt;nat_rule.ptr-&gt;states != 0);	\
		}						\
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATE_DEC_COUNTERS</span>(s)					\
	<span class="enscript-keyword">do</span> {							\
		<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr != NULL) {			\
			VERIFY(s-&gt;nat_rule.ptr-&gt;states &gt; 0);	\
			s-&gt;nat_rule.ptr-&gt;states--;		\
		}						\
		<span class="enscript-keyword">if</span> (s-&gt;anchor.ptr != NULL) {			\
			VERIFY(s-&gt;anchor.ptr-&gt;states &gt; 0);	\
			s-&gt;anchor.ptr-&gt;states--;		\
		}						\
		VERIFY(s-&gt;rule.ptr-&gt;states &gt; 0);		\
		s-&gt;rule.ptr-&gt;states--;				\
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span> <span class="enscript-function-name">pf_src_compare</span>(<span class="enscript-type">struct</span> pf_src_node *, <span class="enscript-type">struct</span> pf_src_node *);
<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span> <span class="enscript-function-name">pf_state_compare_lan_ext</span>(<span class="enscript-type">struct</span> pf_state_key *,
	<span class="enscript-type">struct</span> pf_state_key *);
<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span> <span class="enscript-function-name">pf_state_compare_ext_gwy</span>(<span class="enscript-type">struct</span> pf_state_key *,
	<span class="enscript-type">struct</span> pf_state_key *);
<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span> <span class="enscript-function-name">pf_state_compare_id</span>(<span class="enscript-type">struct</span> pf_state *,
	<span class="enscript-type">struct</span> pf_state *);

<span class="enscript-type">struct</span> pf_src_tree tree_src_tracking;

<span class="enscript-type">struct</span> pf_state_tree_id tree_id;
<span class="enscript-type">struct</span> pf_state_queue state_list;

<span class="enscript-function-name">RB_GENERATE</span>(pf_src_tree, pf_src_node, entry, pf_src_compare);
<span class="enscript-function-name">RB_GENERATE</span>(pf_state_tree_lan_ext, pf_state_key,
    entry_lan_ext, pf_state_compare_lan_ext);
<span class="enscript-function-name">RB_GENERATE</span>(pf_state_tree_ext_gwy, pf_state_key,
    entry_ext_gwy, pf_state_compare_ext_gwy);
<span class="enscript-function-name">RB_GENERATE</span>(pf_state_tree_id, pf_state,
    entry_id, pf_state_compare_id);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PF_DT_SKIP_LANEXT</span>	0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PF_DT_SKIP_EXTGWY</span>	0x02

<span class="enscript-type">static</span> <span class="enscript-type">const</span> u_int16_t PF_PPTP_PORT = 1723;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> u_int32_t PF_PPTP_MAGIC_NUMBER = 0x1A2B3C4D;

<span class="enscript-type">struct</span> pf_pptp_hdr {
	u_int16_t	length;
	u_int16_t	type;
	u_int32_t	magic;
};

<span class="enscript-type">struct</span> pf_pptp_ctrl_hdr {
	u_int16_t	type;
	u_int16_t	reserved_0;
};

<span class="enscript-type">struct</span> pf_pptp_ctrl_generic {
	u_int16_t	data[0];
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_START_REQ</span>	1
<span class="enscript-type">struct</span> pf_pptp_ctrl_start_req {
	u_int16_t	protocol_version;
	u_int16_t	reserved_1;
	u_int32_t	framing_capabilities;
	u_int32_t	bearer_capabilities;
	u_int16_t	maximum_channels;
	u_int16_t	firmware_revision;
	u_int8_t	host_name[64];
	u_int8_t	vendor_string[64];
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_START_RPY</span>	2
<span class="enscript-type">struct</span> pf_pptp_ctrl_start_rpy {
	u_int16_t	protocol_version;
	u_int8_t	result_code;
	u_int8_t	error_code;
	u_int32_t	framing_capabilities;
	u_int32_t	bearer_capabilities;
	u_int16_t	maximum_channels;
	u_int16_t	firmware_revision;
	u_int8_t	host_name[64];
	u_int8_t	vendor_string[64];
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_STOP_REQ</span>	3
<span class="enscript-type">struct</span> pf_pptp_ctrl_stop_req {
	u_int8_t	reason;
	u_int8_t	reserved_1;
	u_int16_t	reserved_2;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_STOP_RPY</span>	4
<span class="enscript-type">struct</span> pf_pptp_ctrl_stop_rpy {
	u_int8_t	reason;
	u_int8_t	error_code;
	u_int16_t	reserved_1;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_ECHO_REQ</span>	5
<span class="enscript-type">struct</span> pf_pptp_ctrl_echo_req {
	u_int32_t	identifier;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_ECHO_RPY</span>	6
<span class="enscript-type">struct</span> pf_pptp_ctrl_echo_rpy {
	u_int32_t	identifier;
	u_int8_t	result_code;
	u_int8_t	error_code;
	u_int16_t	reserved_1;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_CALL_OUT_REQ</span>	7
<span class="enscript-type">struct</span> pf_pptp_ctrl_call_out_req {
	u_int16_t	call_id;
	u_int16_t	call_sernum;
	u_int32_t	min_bps;
	u_int32_t	bearer_type;
	u_int32_t	framing_type;
	u_int16_t	rxwindow_size;
	u_int16_t	proc_delay;
	u_int8_t	phone_num[64];
	u_int8_t	sub_addr[64];
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_CALL_OUT_RPY</span>	8
<span class="enscript-type">struct</span> pf_pptp_ctrl_call_out_rpy {
	u_int16_t	call_id;
	u_int16_t	peer_call_id;
	u_int8_t	result_code;
	u_int8_t	error_code;
	u_int16_t	cause_code;
	u_int32_t	connect_speed;
	u_int16_t	rxwindow_size;
	u_int16_t	proc_delay;
	u_int32_t	phy_channel_id;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_CALL_IN_1ST</span>	9
<span class="enscript-type">struct</span> pf_pptp_ctrl_call_in_1st {
	u_int16_t	call_id;
	u_int16_t	call_sernum;
	u_int32_t	bearer_type;
	u_int32_t	phy_channel_id;
	u_int16_t	dialed_number_len;
	u_int16_t	dialing_number_len;
	u_int8_t	dialed_num[64];
	u_int8_t	dialing_num[64];
	u_int8_t	sub_addr[64];
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_CALL_IN_2ND</span>	10
<span class="enscript-type">struct</span> pf_pptp_ctrl_call_in_2nd {
	u_int16_t	call_id;
	u_int16_t	peer_call_id;
	u_int8_t	result_code;
	u_int8_t	error_code;
	u_int16_t	rxwindow_size;
	u_int16_t	txdelay;
	u_int16_t	reserved_1;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_CALL_IN_3RD</span>	11
<span class="enscript-type">struct</span> pf_pptp_ctrl_call_in_3rd {
	u_int16_t	call_id;
	u_int16_t	reserved_1;
	u_int32_t	connect_speed;
	u_int16_t	rxwindow_size;
	u_int16_t	txdelay;
	u_int32_t	framing_type;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_CALL_CLR</span>	12
<span class="enscript-type">struct</span> pf_pptp_ctrl_call_clr {
	u_int16_t	call_id;
	u_int16_t	reserved_1;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_CALL_DISC</span>	13
<span class="enscript-type">struct</span> pf_pptp_ctrl_call_disc {
	u_int16_t	call_id;
	u_int8_t	result_code;
	u_int8_t	error_code;
	u_int16_t	cause_code;
	u_int16_t	reserved_1;
	u_int8_t	statistics[128];
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_ERROR</span>	14
<span class="enscript-type">struct</span> pf_pptp_ctrl_error {
	u_int16_t	peer_call_id;
	u_int16_t	reserved_1;
	u_int32_t	crc_errors;
	u_int32_t	fr_errors;
	u_int32_t	hw_errors;
	u_int32_t	buf_errors;
	u_int32_t	tim_errors;
	u_int32_t	align_errors;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_PPTP_CTRL_TYPE_SET_LINKINFO</span>	15
<span class="enscript-type">struct</span> pf_pptp_ctrl_set_linkinfo {
	u_int16_t	peer_call_id;
	u_int16_t	reserved_1;
	u_int32_t	tx_accm;
	u_int32_t	rx_accm;
};

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">pf_pptp_ctrl_type_name</span>(u_int16_t code)
{
	code = ntohs(code);

	<span class="enscript-keyword">if</span> (code &lt; PF_PPTP_CTRL_TYPE_START_REQ ||
	    code &gt; PF_PPTP_CTRL_TYPE_SET_LINKINFO) {
		<span class="enscript-type">static</span> <span class="enscript-type">char</span> reserved[] = <span class="enscript-string">&quot;reserved-00&quot;</span>;

		sprintf(&amp;reserved[9], <span class="enscript-string">&quot;%02x&quot;</span>, code);
		<span class="enscript-keyword">return</span> (reserved);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name[] = {
			<span class="enscript-string">&quot;start_req&quot;</span>, <span class="enscript-string">&quot;start_rpy&quot;</span>, <span class="enscript-string">&quot;stop_req&quot;</span>, <span class="enscript-string">&quot;stop_rpy&quot;</span>,
			<span class="enscript-string">&quot;echo_req&quot;</span>, <span class="enscript-string">&quot;echo_rpy&quot;</span>, <span class="enscript-string">&quot;call_out_req&quot;</span>, <span class="enscript-string">&quot;call_out_rpy&quot;</span>,
			<span class="enscript-string">&quot;call_in_1st&quot;</span>, <span class="enscript-string">&quot;call_in_2nd&quot;</span>, <span class="enscript-string">&quot;call_in_3rd&quot;</span>,
			<span class="enscript-string">&quot;call_clr&quot;</span>, <span class="enscript-string">&quot;call_disc&quot;</span>, <span class="enscript-string">&quot;error&quot;</span>, <span class="enscript-string">&quot;set_linkinfo&quot;</span>
		};

		<span class="enscript-keyword">return</span> (name[code - 1]);
	}
};
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">const</span> size_t PF_PPTP_CTRL_MSG_MINSIZE =
	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_hdr) +
	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_hdr) +
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_start_req),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_start_rpy),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_stop_req),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_stop_rpy),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_echo_req),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_echo_rpy),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_call_out_req),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_call_out_rpy),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_call_in_1st),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_call_in_2nd),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_call_in_3rd),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_call_clr),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_call_disc),
	MIN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_error),
	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_pptp_ctrl_set_linkinfo)
	))))))))))))));

<span class="enscript-type">union</span> pf_pptp_ctrl_msg_union {
	<span class="enscript-type">struct</span> pf_pptp_ctrl_start_req		start_req;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_start_rpy		start_rpy;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_stop_req		stop_req;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_stop_rpy		stop_rpy;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_echo_req		echo_req;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_echo_rpy		echo_rpy;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_call_out_req	call_out_req;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_call_out_rpy	call_out_rpy;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_call_in_1st		call_in_1st;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_call_in_2nd		call_in_2nd;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_call_in_3rd		call_in_3rd;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_call_clr		call_clr;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_call_disc		call_disc;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_error			error;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_set_linkinfo	set_linkinfo;
	u_int8_t							data[0];
};

<span class="enscript-type">struct</span> pf_pptp_ctrl_msg {
	<span class="enscript-type">struct</span> pf_pptp_hdr				hdr;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_hdr			ctrl;
	<span class="enscript-type">union</span> pf_pptp_ctrl_msg_union	msg;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_GRE_FLAG_CHECKSUM_PRESENT</span>	0x8000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_GRE_FLAG_VERSION_MASK</span>		0x0007
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_GRE_PPP_ETHERTYPE</span>			0x880B

<span class="enscript-type">struct</span> pf_grev1_hdr {
	u_int16_t flags;
	u_int16_t protocol_type;
	u_int16_t payload_length;
	u_int16_t call_id;
	<span class="enscript-comment">/*
	u_int32_t seqno;
	u_int32_t ackno;
	*/</span>
};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> u_int16_t PF_IKE_PORT = 500;

<span class="enscript-type">struct</span> pf_ike_hdr {
	u_int64_t initiator_cookie, responder_cookie;
	u_int8_t next_payload, version, exchange_type, flags;
	u_int32_t message_id, length;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKE_PACKET_MINSIZE</span>	(sizeof (struct pf_ike_hdr))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv1_EXCHTYPE_BASE</span>				 1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv1_EXCHTYPE_ID_PROTECT</span>		 2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv1_EXCHTYPE_AUTH_ONLY</span>			 3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv1_EXCHTYPE_AGGRESSIVE</span>		 4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv1_EXCHTYPE_INFORMATIONAL</span>		 5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv2_EXCHTYPE_SA_INIT</span>			34
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv2_EXCHTYPE_AUTH</span>				35
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv2_EXCHTYPE_CREATE_CHILD_SA</span>	36
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv2_EXCHTYPE_INFORMATIONAL</span>		37

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv1_FLAG_E</span>		0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv1_FLAG_C</span>		0x02
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv1_FLAG_A</span>		0x04
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv2_FLAG_I</span>		0x08
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv2_FLAG_V</span>		0x10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PF_IKEv2_FLAG_R</span>		0x20

<span class="enscript-type">struct</span> pf_esp_hdr {
	u_int32_t spi;
	u_int32_t seqno;
	u_int8_t payload[];
};

<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_addr_compare</span>(<span class="enscript-type">struct</span> pf_addr *a, <span class="enscript-type">struct</span> pf_addr *b, sa_family_t af)
{
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		<span class="enscript-keyword">if</span> (a-&gt;addr32[0] &gt; b-&gt;addr32[0])
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">if</span> (a-&gt;addr32[0] &lt; b-&gt;addr32[0])
			<span class="enscript-keyword">return</span> (-1);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-keyword">if</span> (a-&gt;addr32[3] &gt; b-&gt;addr32[3])
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">if</span> (a-&gt;addr32[3] &lt; b-&gt;addr32[3])
			<span class="enscript-keyword">return</span> (-1);
		<span class="enscript-keyword">if</span> (a-&gt;addr32[2] &gt; b-&gt;addr32[2])
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">if</span> (a-&gt;addr32[2] &lt; b-&gt;addr32[2])
			<span class="enscript-keyword">return</span> (-1);
		<span class="enscript-keyword">if</span> (a-&gt;addr32[1] &gt; b-&gt;addr32[1])
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">if</span> (a-&gt;addr32[1] &lt; b-&gt;addr32[1])
			<span class="enscript-keyword">return</span> (-1);
		<span class="enscript-keyword">if</span> (a-&gt;addr32[0] &gt; b-&gt;addr32[0])
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">if</span> (a-&gt;addr32[0] &lt; b-&gt;addr32[0])
			<span class="enscript-keyword">return</span> (-1);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_src_compare</span>(<span class="enscript-type">struct</span> pf_src_node *a, <span class="enscript-type">struct</span> pf_src_node *b)
{
	<span class="enscript-type">int</span>	diff;

	<span class="enscript-keyword">if</span> (a-&gt;rule.ptr &gt; b-&gt;rule.ptr)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">if</span> (a-&gt;rule.ptr &lt; b-&gt;rule.ptr)
		<span class="enscript-keyword">return</span> (-1);
	<span class="enscript-keyword">if</span> ((diff = a-&gt;af - b-&gt;af) != 0)
		<span class="enscript-keyword">return</span> (diff);
	<span class="enscript-keyword">if</span> ((diff = pf_addr_compare(&amp;a-&gt;addr, &amp;b-&gt;addr, a-&gt;af)) != 0)
		<span class="enscript-keyword">return</span> (diff);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_state_compare_lan_ext</span>(<span class="enscript-type">struct</span> pf_state_key *a, <span class="enscript-type">struct</span> pf_state_key *b)
{
	<span class="enscript-type">int</span>	diff;
	<span class="enscript-type">int</span>	extfilter;

	<span class="enscript-keyword">if</span> ((diff = a-&gt;proto - b-&gt;proto) != 0)
		<span class="enscript-keyword">return</span> (diff);
	<span class="enscript-keyword">if</span> ((diff = a-&gt;af_lan - b-&gt;af_lan) != 0)
		<span class="enscript-keyword">return</span> (diff);

	extfilter = PF_EXTFILTER_APD;

	<span class="enscript-keyword">switch</span> (a-&gt;proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
		<span class="enscript-keyword">if</span> ((diff = a-&gt;lan.xport.port - b-&gt;lan.xport.port) != 0)
			<span class="enscript-keyword">return</span> (diff);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		<span class="enscript-keyword">if</span> ((diff = a-&gt;lan.xport.port - b-&gt;lan.xport.port) != 0)
			<span class="enscript-keyword">return</span> (diff);
		<span class="enscript-keyword">if</span> ((diff = a-&gt;ext_lan.xport.port - b-&gt;ext_lan.xport.port) != 0)
			<span class="enscript-keyword">return</span> (diff);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		<span class="enscript-keyword">if</span> ((diff = a-&gt;proto_variant - b-&gt;proto_variant))
			<span class="enscript-keyword">return</span> (diff);
		extfilter = a-&gt;proto_variant;
		<span class="enscript-keyword">if</span> ((diff = a-&gt;lan.xport.port - b-&gt;lan.xport.port) != 0)
			<span class="enscript-keyword">return</span> (diff);
		<span class="enscript-keyword">if</span> ((extfilter &lt; PF_EXTFILTER_AD) &amp;&amp;
		    (diff = a-&gt;ext_lan.xport.port - b-&gt;ext_lan.xport.port) != 0)
			<span class="enscript-keyword">return</span> (diff);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
		<span class="enscript-keyword">if</span> (a-&gt;proto_variant == PF_GRE_PPTP_VARIANT &amp;&amp;
		    a-&gt;proto_variant == b-&gt;proto_variant) {
			<span class="enscript-keyword">if</span> (!!(diff = a-&gt;ext_lan.xport.call_id -
			    b-&gt;ext_lan.xport.call_id))
				<span class="enscript-keyword">return</span> (diff);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
		<span class="enscript-keyword">if</span> (!!(diff = a-&gt;ext_lan.xport.spi - b-&gt;ext_lan.xport.spi))
			<span class="enscript-keyword">return</span> (diff);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">switch</span> (a-&gt;af_lan) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		<span class="enscript-keyword">if</span> ((diff = pf_addr_compare(&amp;a-&gt;lan.addr, &amp;b-&gt;lan.addr,
					    a-&gt;af_lan)) != 0)
			<span class="enscript-keyword">return</span> (diff);

		<span class="enscript-keyword">if</span> (extfilter &lt; PF_EXTFILTER_EI) {
			<span class="enscript-keyword">if</span> ((diff = pf_addr_compare(&amp;a-&gt;ext_lan.addr,
						    &amp;b-&gt;ext_lan.addr,
						    a-&gt;af_lan)) != 0)
				<span class="enscript-keyword">return</span> (diff);
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-keyword">if</span> ((diff = pf_addr_compare(&amp;a-&gt;lan.addr, &amp;b-&gt;lan.addr,
					    a-&gt;af_lan)) != 0)
			<span class="enscript-keyword">return</span> (diff);

		<span class="enscript-keyword">if</span> (extfilter &lt; PF_EXTFILTER_EI ||
		    !PF_AZERO(&amp;b-&gt;ext_lan.addr, AF_INET6)) {
			<span class="enscript-keyword">if</span> ((diff = pf_addr_compare(&amp;a-&gt;ext_lan.addr,
						    &amp;b-&gt;ext_lan.addr,
						    a-&gt;af_lan)) != 0)
				<span class="enscript-keyword">return</span> (diff);
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}

	<span class="enscript-keyword">if</span> (a-&gt;app_state &amp;&amp; b-&gt;app_state) {
		<span class="enscript-keyword">if</span> (a-&gt;app_state-&gt;compare_lan_ext &amp;&amp;
		    b-&gt;app_state-&gt;compare_lan_ext) {
			diff = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)b-&gt;app_state-&gt;compare_lan_ext -
			    (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)a-&gt;app_state-&gt;compare_lan_ext;
			<span class="enscript-keyword">if</span> (diff != 0)
				<span class="enscript-keyword">return</span> (diff);
			diff = a-&gt;app_state-&gt;compare_lan_ext(a-&gt;app_state,
			    b-&gt;app_state);
			<span class="enscript-keyword">if</span> (diff != 0)
				<span class="enscript-keyword">return</span> (diff);
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_state_compare_ext_gwy</span>(<span class="enscript-type">struct</span> pf_state_key *a, <span class="enscript-type">struct</span> pf_state_key *b)
{
	<span class="enscript-type">int</span>	diff;
	<span class="enscript-type">int</span>	extfilter;

	<span class="enscript-keyword">if</span> ((diff = a-&gt;proto - b-&gt;proto) != 0)
		<span class="enscript-keyword">return</span> (diff);

	<span class="enscript-keyword">if</span> ((diff = a-&gt;af_gwy - b-&gt;af_gwy) != 0)
		<span class="enscript-keyword">return</span> (diff);

	extfilter = PF_EXTFILTER_APD;

	<span class="enscript-keyword">switch</span> (a-&gt;proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
		<span class="enscript-keyword">if</span> ((diff = a-&gt;gwy.xport.port - b-&gt;gwy.xport.port) != 0)
			<span class="enscript-keyword">return</span> (diff);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		<span class="enscript-keyword">if</span> ((diff = a-&gt;ext_gwy.xport.port - b-&gt;ext_gwy.xport.port) != 0)
			<span class="enscript-keyword">return</span> (diff);
		<span class="enscript-keyword">if</span> ((diff = a-&gt;gwy.xport.port - b-&gt;gwy.xport.port) != 0)
			<span class="enscript-keyword">return</span> (diff);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		<span class="enscript-keyword">if</span> ((diff = a-&gt;proto_variant - b-&gt;proto_variant))
			<span class="enscript-keyword">return</span> (diff);
		extfilter = a-&gt;proto_variant;
		<span class="enscript-keyword">if</span> ((diff = a-&gt;gwy.xport.port - b-&gt;gwy.xport.port) != 0)
			<span class="enscript-keyword">return</span> (diff);
		<span class="enscript-keyword">if</span> ((extfilter &lt; PF_EXTFILTER_AD) &amp;&amp;
		    (diff = a-&gt;ext_gwy.xport.port - b-&gt;ext_gwy.xport.port) != 0)
			<span class="enscript-keyword">return</span> (diff);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
		<span class="enscript-keyword">if</span> (a-&gt;proto_variant == PF_GRE_PPTP_VARIANT &amp;&amp;
		    a-&gt;proto_variant == b-&gt;proto_variant) {
			<span class="enscript-keyword">if</span> (!!(diff = a-&gt;gwy.xport.call_id -
			    b-&gt;gwy.xport.call_id))
				<span class="enscript-keyword">return</span> (diff);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
		<span class="enscript-keyword">if</span> (!!(diff = a-&gt;gwy.xport.spi - b-&gt;gwy.xport.spi))
			<span class="enscript-keyword">return</span> (diff);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">switch</span> (a-&gt;af_gwy) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		<span class="enscript-keyword">if</span> ((diff = pf_addr_compare(&amp;a-&gt;gwy.addr, &amp;b-&gt;gwy.addr,
					    a-&gt;af_gwy)) != 0)
			<span class="enscript-keyword">return</span> (diff);

		<span class="enscript-keyword">if</span> (extfilter &lt; PF_EXTFILTER_EI) {
			<span class="enscript-keyword">if</span> ((diff = pf_addr_compare(&amp;a-&gt;ext_gwy.addr, &amp;b-&gt;ext_gwy.addr,
						    a-&gt;af_gwy)) != 0)
				<span class="enscript-keyword">return</span> (diff);
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-keyword">if</span> ((diff = pf_addr_compare(&amp;a-&gt;gwy.addr, &amp;b-&gt;gwy.addr,
					    a-&gt;af_gwy)) != 0)
			<span class="enscript-keyword">return</span> (diff);

		<span class="enscript-keyword">if</span> (extfilter &lt; PF_EXTFILTER_EI ||
		    !PF_AZERO(&amp;b-&gt;ext_gwy.addr, AF_INET6)) {
			<span class="enscript-keyword">if</span> ((diff = pf_addr_compare(&amp;a-&gt;ext_gwy.addr, &amp;b-&gt;ext_gwy.addr,
						    a-&gt;af_gwy)) != 0)
				<span class="enscript-keyword">return</span> (diff);
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}

	<span class="enscript-keyword">if</span> (a-&gt;app_state &amp;&amp; b-&gt;app_state) {
		<span class="enscript-keyword">if</span> (a-&gt;app_state-&gt;compare_ext_gwy &amp;&amp;
		    b-&gt;app_state-&gt;compare_ext_gwy) {
			diff = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)b-&gt;app_state-&gt;compare_ext_gwy -
			    (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)a-&gt;app_state-&gt;compare_ext_gwy;
			<span class="enscript-keyword">if</span> (diff != 0)
				<span class="enscript-keyword">return</span> (diff);
			diff = a-&gt;app_state-&gt;compare_ext_gwy(a-&gt;app_state,
			    b-&gt;app_state);
			<span class="enscript-keyword">if</span> (diff != 0)
				<span class="enscript-keyword">return</span> (diff);
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_state_compare_id</span>(<span class="enscript-type">struct</span> pf_state *a, <span class="enscript-type">struct</span> pf_state *b)
{
	<span class="enscript-keyword">if</span> (a-&gt;id &gt; b-&gt;id)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">if</span> (a-&gt;id &lt; b-&gt;id)
		<span class="enscript-keyword">return</span> (-1);
	<span class="enscript-keyword">if</span> (a-&gt;creatorid &gt; b-&gt;creatorid)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">if</span> (a-&gt;creatorid &lt; b-&gt;creatorid)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_addrcpy</span>(<span class="enscript-type">struct</span> pf_addr *dst, <span class="enscript-type">struct</span> pf_addr *src, sa_family_t af)
{
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		dst-&gt;addr32[0] = src-&gt;addr32[0];
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		dst-&gt;addr32[0] = src-&gt;addr32[0];
		dst-&gt;addr32[1] = src-&gt;addr32[1];
		dst-&gt;addr32[2] = src-&gt;addr32[2];
		dst-&gt;addr32[3] = src-&gt;addr32[3];
		<span class="enscript-keyword">break</span>;
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">struct</span> pf_state *
<span class="enscript-function-name">pf_find_state_byid</span>(<span class="enscript-type">struct</span> pf_state_cmp *key)
{
	pf_status.fcounters[FCNT_STATE_SEARCH]++;

	<span class="enscript-keyword">return</span> (RB_FIND(pf_state_tree_id, &amp;tree_id,
	    (<span class="enscript-type">struct</span> pf_state *)(<span class="enscript-type">void</span> *)key));
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pf_state *
<span class="enscript-function-name">pf_find_state</span>(<span class="enscript-type">struct</span> pfi_kif *kif, <span class="enscript-type">struct</span> pf_state_key_cmp *key, u_int dir)
{
	<span class="enscript-type">struct</span> pf_state_key	*sk = NULL;
	<span class="enscript-type">struct</span> pf_state		*s;

	pf_status.fcounters[FCNT_STATE_SEARCH]++;

	<span class="enscript-keyword">switch</span> (dir) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OUT</span>:
		sk = RB_FIND(pf_state_tree_lan_ext, &amp;pf_statetbl_lan_ext,
		    (<span class="enscript-type">struct</span> pf_state_key *)key);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_IN</span>:
		sk = RB_FIND(pf_state_tree_ext_gwy, &amp;pf_statetbl_ext_gwy,
		    (<span class="enscript-type">struct</span> pf_state_key *)key);
		<span class="enscript-comment">/*
		 * NAT64 is done only on input, for packets coming in from
		 * from the LAN side, need to lookup the lan_ext tree.
		 */</span>
		<span class="enscript-keyword">if</span> (sk == NULL) {
			sk = RB_FIND(pf_state_tree_lan_ext,
				     &amp;pf_statetbl_lan_ext,
				     (<span class="enscript-type">struct</span> pf_state_key *)key);
			<span class="enscript-keyword">if</span> (sk &amp;&amp; sk-&gt;af_lan == sk-&gt;af_gwy)
				sk = NULL;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;pf_find_state&quot;</span>);
	}

	<span class="enscript-comment">/* list is sorted, if-bound states before floating ones */</span>
	<span class="enscript-keyword">if</span> (sk != NULL)
		TAILQ_FOREACH(s, &amp;sk-&gt;states, next)
			<span class="enscript-keyword">if</span> (s-&gt;kif == pfi_all || s-&gt;kif == kif)
				<span class="enscript-keyword">return</span> (s);

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">struct</span> pf_state *
<span class="enscript-function-name">pf_find_state_all</span>(<span class="enscript-type">struct</span> pf_state_key_cmp *key, u_int dir, <span class="enscript-type">int</span> *more)
{
	<span class="enscript-type">struct</span> pf_state_key	*sk = NULL;
	<span class="enscript-type">struct</span> pf_state		*s, *ret = NULL;

	pf_status.fcounters[FCNT_STATE_SEARCH]++;

	<span class="enscript-keyword">switch</span> (dir) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OUT</span>:
		sk = RB_FIND(pf_state_tree_lan_ext,
		    &amp;pf_statetbl_lan_ext, (<span class="enscript-type">struct</span> pf_state_key *)key);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_IN</span>:
		sk = RB_FIND(pf_state_tree_ext_gwy,
		    &amp;pf_statetbl_ext_gwy, (<span class="enscript-type">struct</span> pf_state_key *)key);
		<span class="enscript-comment">/*
		 * NAT64 is done only on input, for packets coming in from
		 * from the LAN side, need to lookup the lan_ext tree.
		 */</span>
		<span class="enscript-keyword">if</span> ((sk == NULL) &amp;&amp; pf_nat64_configured) {
			sk = RB_FIND(pf_state_tree_lan_ext,
					&amp;pf_statetbl_lan_ext,
					(<span class="enscript-type">struct</span> pf_state_key *)key);
			<span class="enscript-keyword">if</span> (sk &amp;&amp; sk-&gt;af_lan == sk-&gt;af_gwy)
				sk = NULL;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;pf_find_state_all&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (sk != NULL) {
		ret = TAILQ_FIRST(&amp;sk-&gt;states);
		<span class="enscript-keyword">if</span> (more == NULL)
			<span class="enscript-keyword">return</span> (ret);

		TAILQ_FOREACH(s, &amp;sk-&gt;states, next)
			(*more)++;
	}

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_init_threshold</span>(<span class="enscript-type">struct</span> pf_threshold *threshold,
    u_int32_t limit, u_int32_t seconds)
{
	threshold-&gt;limit = limit * PF_THRESHOLD_MULT;
	threshold-&gt;seconds = seconds;
	threshold-&gt;count = 0;
	threshold-&gt;last = pf_time_second();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_add_threshold</span>(<span class="enscript-type">struct</span> pf_threshold *threshold)
{
	u_int32_t t = pf_time_second(), diff = t - threshold-&gt;last;

	<span class="enscript-keyword">if</span> (diff &gt;= threshold-&gt;seconds)
		threshold-&gt;count = 0;
	<span class="enscript-keyword">else</span>
		threshold-&gt;count -= threshold-&gt;count * diff /
		    threshold-&gt;seconds;
	threshold-&gt;count += PF_THRESHOLD_MULT;
	threshold-&gt;last = t;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_check_threshold</span>(<span class="enscript-type">struct</span> pf_threshold *threshold)
{
	<span class="enscript-keyword">return</span> (threshold-&gt;count &gt; threshold-&gt;limit);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_src_connlimit</span>(<span class="enscript-type">struct</span> pf_state **state)
{
	<span class="enscript-type">int</span> bad = 0;
	(*state)-&gt;src_node-&gt;conn++;
	VERIFY((*state)-&gt;src_node-&gt;conn != 0);
	(*state)-&gt;src.tcp_est = 1;
	pf_add_threshold(&amp;(*state)-&gt;src_node-&gt;conn_rate);

	<span class="enscript-keyword">if</span> ((*state)-&gt;rule.ptr-&gt;max_src_conn &amp;&amp;
	    (*state)-&gt;rule.ptr-&gt;max_src_conn &lt;
	    (*state)-&gt;src_node-&gt;conn) {
		pf_status.lcounters[LCNT_SRCCONN]++;
		bad++;
	}

	<span class="enscript-keyword">if</span> ((*state)-&gt;rule.ptr-&gt;max_src_conn_rate.limit &amp;&amp;
	    pf_check_threshold(&amp;(*state)-&gt;src_node-&gt;conn_rate)) {
		pf_status.lcounters[LCNT_SRCCONNRATE]++;
		bad++;
	}

	<span class="enscript-keyword">if</span> (!bad)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> ((*state)-&gt;rule.ptr-&gt;overload_tbl) {
		<span class="enscript-type">struct</span> pfr_addr p;
		u_int32_t	killed = 0;

		pf_status.lcounters[LCNT_OVERLOAD_TABLE]++;
		<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
			printf(<span class="enscript-string">&quot;pf_src_connlimit: blocking address &quot;</span>);
			pf_print_host(&amp;(*state)-&gt;src_node-&gt;addr, 0,
					(*state)-&gt;state_key-&gt;af_lan);
		}

		bzero(&amp;p, <span class="enscript-keyword">sizeof</span> (p));
		p.pfra_af = (*state)-&gt;state_key-&gt;af_lan;
		<span class="enscript-keyword">switch</span> ((*state)-&gt;state_key-&gt;af_lan) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			p.pfra_net = 32;
			p.pfra_ip4addr = (*state)-&gt;src_node-&gt;addr.v4;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			p.pfra_net = 128;
			p.pfra_ip6addr = (*state)-&gt;src_node-&gt;addr.v6;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		}

		pfr_insert_kentry((*state)-&gt;rule.ptr-&gt;overload_tbl,
		    &amp;p, pf_calendar_time_second());

		<span class="enscript-comment">/* kill existing states if that's required. */</span>
		<span class="enscript-keyword">if</span> ((*state)-&gt;rule.ptr-&gt;flush) {
			<span class="enscript-type">struct</span> pf_state_key *sk;
			<span class="enscript-type">struct</span> pf_state *st;

			pf_status.lcounters[LCNT_OVERLOAD_FLUSH]++;
			RB_FOREACH(st, pf_state_tree_id, &amp;tree_id) {
				sk = st-&gt;state_key;
				<span class="enscript-comment">/*
				 * Kill states from this source.  (Only those
				 * from the same rule if PF_FLUSH_GLOBAL is not
				 * set)
				 */</span>
				<span class="enscript-keyword">if</span> (sk-&gt;af_lan ==
				    (*state)-&gt;state_key-&gt;af_lan &amp;&amp;
				    (((*state)-&gt;state_key-&gt;direction ==
				        PF_OUT &amp;&amp;
				    PF_AEQ(&amp;(*state)-&gt;src_node-&gt;addr,
				        &amp;sk-&gt;lan.addr, sk-&gt;af_lan)) ||
				    ((*state)-&gt;state_key-&gt;direction == PF_IN &amp;&amp;
				    PF_AEQ(&amp;(*state)-&gt;src_node-&gt;addr,
				        &amp;sk-&gt;ext_lan.addr, sk-&gt;af_lan))) &amp;&amp;
				    ((*state)-&gt;rule.ptr-&gt;flush &amp;
				    PF_FLUSH_GLOBAL ||
				    (*state)-&gt;rule.ptr == st-&gt;rule.ptr)) {
					st-&gt;timeout = PFTM_PURGE;
					st-&gt;src.state = st-&gt;dst.state =
					    TCPS_CLOSED;
					killed++;
				}
			}
			<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC)
				printf(<span class="enscript-string">&quot;, %u states killed&quot;</span>, killed);
		}
		<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC)
			printf(<span class="enscript-string">&quot;\n&quot;</span>);
	}

	<span class="enscript-comment">/* kill this state */</span>
	(*state)-&gt;timeout = PFTM_PURGE;
	(*state)-&gt;src.state = (*state)-&gt;dst.state = TCPS_CLOSED;
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_insert_src_node</span>(<span class="enscript-type">struct</span> pf_src_node **sn, <span class="enscript-type">struct</span> pf_rule *rule,
    <span class="enscript-type">struct</span> pf_addr *src, sa_family_t af)
{
	<span class="enscript-type">struct</span> pf_src_node	k;

	<span class="enscript-keyword">if</span> (*sn == NULL) {
		k.af = af;
		PF_ACPY(&amp;k.addr, src, af);
		<span class="enscript-keyword">if</span> (rule-&gt;rule_flag &amp; PFRULE_RULESRCTRACK ||
		    rule-&gt;rpool.opts &amp; PF_POOL_STICKYADDR)
			k.rule.ptr = rule;
		<span class="enscript-keyword">else</span>
			k.rule.ptr = NULL;
		pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
		*sn = RB_FIND(pf_src_tree, &amp;tree_src_tracking, &amp;k);
	}
	<span class="enscript-keyword">if</span> (*sn == NULL) {
		<span class="enscript-keyword">if</span> (!rule-&gt;max_src_nodes ||
		    rule-&gt;src_nodes &lt; rule-&gt;max_src_nodes)
			(*sn) = pool_get(&amp;pf_src_tree_pl, PR_WAITOK);
		<span class="enscript-keyword">else</span>
			pf_status.lcounters[LCNT_SRCNODES]++;
		<span class="enscript-keyword">if</span> ((*sn) == NULL)
			<span class="enscript-keyword">return</span> (-1);
		bzero(*sn, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> pf_src_node));

		pf_init_threshold(&amp;(*sn)-&gt;conn_rate,
		    rule-&gt;max_src_conn_rate.limit,
		    rule-&gt;max_src_conn_rate.seconds);

		(*sn)-&gt;af = af;
		<span class="enscript-keyword">if</span> (rule-&gt;rule_flag &amp; PFRULE_RULESRCTRACK ||
		    rule-&gt;rpool.opts &amp; PF_POOL_STICKYADDR)
			(*sn)-&gt;rule.ptr = rule;
		<span class="enscript-keyword">else</span>
			(*sn)-&gt;rule.ptr = NULL;
		PF_ACPY(&amp;(*sn)-&gt;addr, src, af);
		<span class="enscript-keyword">if</span> (RB_INSERT(pf_src_tree,
		    &amp;tree_src_tracking, *sn) != NULL) {
			<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
				printf(<span class="enscript-string">&quot;pf: src_tree insert failed: &quot;</span>);
				pf_print_host(&amp;(*sn)-&gt;addr, 0, af);
				printf(<span class="enscript-string">&quot;\n&quot;</span>);
			}
			pool_put(&amp;pf_src_tree_pl, *sn);
			<span class="enscript-keyword">return</span> (-1);
		}
		(*sn)-&gt;creation = pf_time_second();
		(*sn)-&gt;ruletype = rule-&gt;action;
		<span class="enscript-keyword">if</span> ((*sn)-&gt;rule.ptr != NULL)
			(*sn)-&gt;rule.ptr-&gt;src_nodes++;
		pf_status.scounters[SCNT_SRC_NODE_INSERT]++;
		pf_status.src_nodes++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (rule-&gt;max_src_states &amp;&amp;
		    (*sn)-&gt;states &gt;= rule-&gt;max_src_states) {
			pf_status.lcounters[LCNT_SRCSTATES]++;
			<span class="enscript-keyword">return</span> (-1);
		}
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_stateins_err</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *tree, <span class="enscript-type">struct</span> pf_state *s, <span class="enscript-type">struct</span> pfi_kif *kif)
{
	<span class="enscript-type">struct</span> pf_state_key	*sk = s-&gt;state_key;

	<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
		printf(<span class="enscript-string">&quot;pf: state insert failed: %s %s &quot;</span>, tree, kif-&gt;pfik_name);
		<span class="enscript-keyword">switch</span> (sk-&gt;proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
			printf(<span class="enscript-string">&quot;TCP&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
			printf(<span class="enscript-string">&quot;UDP&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
			printf(<span class="enscript-string">&quot;ICMP4&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
			printf(<span class="enscript-string">&quot;ICMP6&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			printf(<span class="enscript-string">&quot;PROTO=%u&quot;</span>, sk-&gt;proto);
			<span class="enscript-keyword">break</span>;
		}
		printf(<span class="enscript-string">&quot; lan: &quot;</span>);
		pf_print_sk_host(&amp;sk-&gt;lan, sk-&gt;af_lan, sk-&gt;proto,
		    sk-&gt;proto_variant);
		printf(<span class="enscript-string">&quot; gwy: &quot;</span>);
		pf_print_sk_host(&amp;sk-&gt;gwy, sk-&gt;af_gwy, sk-&gt;proto,
		    sk-&gt;proto_variant);
		printf(<span class="enscript-string">&quot; ext_lan: &quot;</span>);
		pf_print_sk_host(&amp;sk-&gt;ext_lan, sk-&gt;af_lan, sk-&gt;proto,
		    sk-&gt;proto_variant);
		printf(<span class="enscript-string">&quot; ext_gwy: &quot;</span>);
		pf_print_sk_host(&amp;sk-&gt;ext_gwy, sk-&gt;af_gwy, sk-&gt;proto,
		    sk-&gt;proto_variant);
		<span class="enscript-keyword">if</span> (s-&gt;sync_flags &amp; PFSTATE_FROMSYNC)
			printf(<span class="enscript-string">&quot; (from sync)&quot;</span>);
		printf(<span class="enscript-string">&quot;\n&quot;</span>);
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_insert_state</span>(<span class="enscript-type">struct</span> pfi_kif *kif, <span class="enscript-type">struct</span> pf_state *s)
{
	<span class="enscript-type">struct</span> pf_state_key	*cur;
	<span class="enscript-type">struct</span> pf_state		*sp;

	VERIFY(s-&gt;state_key != NULL);
	s-&gt;kif = kif;

	<span class="enscript-keyword">if</span> ((cur = RB_INSERT(pf_state_tree_lan_ext, &amp;pf_statetbl_lan_ext,
	    s-&gt;state_key)) != NULL) {
		<span class="enscript-comment">/* key exists. check for same kif, if none, add to key */</span>
		TAILQ_FOREACH(sp, &amp;cur-&gt;states, next)
			<span class="enscript-keyword">if</span> (sp-&gt;kif == kif) {	<span class="enscript-comment">/* collision! */</span>
				pf_stateins_err(<span class="enscript-string">&quot;tree_lan_ext&quot;</span>, s, kif);
				pf_detach_state(s,
				    PF_DT_SKIP_LANEXT|PF_DT_SKIP_EXTGWY);
				<span class="enscript-keyword">return</span> (-1);
			}
		pf_detach_state(s, PF_DT_SKIP_LANEXT|PF_DT_SKIP_EXTGWY);
		pf_attach_state(cur, s, kif == pfi_all ? 1 : 0);
	}

	<span class="enscript-comment">/* if cur != NULL, we already found a state key and attached to it */</span>
	<span class="enscript-keyword">if</span> (cur == NULL &amp;&amp; (cur = RB_INSERT(pf_state_tree_ext_gwy,
	    &amp;pf_statetbl_ext_gwy, s-&gt;state_key)) != NULL) {
		<span class="enscript-comment">/* must not happen. we must have found the sk above! */</span>
		pf_stateins_err(<span class="enscript-string">&quot;tree_ext_gwy&quot;</span>, s, kif);
		pf_detach_state(s, PF_DT_SKIP_EXTGWY);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (s-&gt;id == 0 &amp;&amp; s-&gt;creatorid == 0) {
		s-&gt;id = htobe64(pf_status.stateid++);
		s-&gt;creatorid = pf_status.hostid;
	}
	<span class="enscript-keyword">if</span> (RB_INSERT(pf_state_tree_id, &amp;tree_id, s) != NULL) {
		<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
			printf(<span class="enscript-string">&quot;pf: state insert failed: &quot;</span>
			    <span class="enscript-string">&quot;id: %016llx creatorid: %08x&quot;</span>,
			    be64toh(s-&gt;id), ntohl(s-&gt;creatorid));
			<span class="enscript-keyword">if</span> (s-&gt;sync_flags &amp; PFSTATE_FROMSYNC)
				printf(<span class="enscript-string">&quot; (from sync)&quot;</span>);
			printf(<span class="enscript-string">&quot;\n&quot;</span>);
		}
		pf_detach_state(s, 0);
		<span class="enscript-keyword">return</span> (-1);
	}
	TAILQ_INSERT_TAIL(&amp;state_list, s, entry_list);
	pf_status.fcounters[FCNT_STATE_INSERT]++;
	pf_status.states++;
	VERIFY(pf_status.states != 0);
	pfi_kif_ref(kif, PFI_KIF_REF_STATE);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
	pfsync_insert_state(s);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_purge_thread_cont</span>(<span class="enscript-type">int</span> err)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">err</span>)
	<span class="enscript-type">static</span> u_int32_t nloops = 0;
	<span class="enscript-type">int</span> t = 1;	<span class="enscript-comment">/* 1 second */</span>

	<span class="enscript-comment">/*
	 * Update coarse-grained networking timestamp (in sec.); the idea
	 * is to piggy-back on the periodic timeout callout to update
	 * the counter returnable via net_uptime().
	 */</span>
	net_update_uptime();

	lck_rw_lock_shared(pf_perim_lock);
	lck_mtx_lock(pf_lock);

	<span class="enscript-comment">/* purge everything if not running */</span>
	<span class="enscript-keyword">if</span> (!pf_status.running) {
		pf_purge_expired_states(pf_status.states);
		pf_purge_expired_fragments();
		pf_purge_expired_src_nodes();

		<span class="enscript-comment">/* terminate thread (we don't currently do this) */</span>
		<span class="enscript-keyword">if</span> (pf_purge_thread == NULL) {
			lck_mtx_unlock(pf_lock);
			lck_rw_done(pf_perim_lock);

			thread_deallocate(current_thread());
			thread_terminate(current_thread());
			<span class="enscript-comment">/* NOTREACHED */</span>
			<span class="enscript-keyword">return</span> (0);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* if there's nothing left, sleep w/o timeout */</span>
			<span class="enscript-keyword">if</span> (pf_status.states == 0 &amp;&amp;
			    pf_normalize_isempty() &amp;&amp;
			    RB_EMPTY(&amp;tree_src_tracking)) {
				nloops = 0;
				t = 0;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	<span class="enscript-comment">/* process a fraction of the state table every second */</span>
	pf_purge_expired_states(1 + (pf_status.states
	    / pf_default_rule.timeout[PFTM_INTERVAL]));

	<span class="enscript-comment">/* purge other expired types every PFTM_INTERVAL seconds */</span>
	<span class="enscript-keyword">if</span> (++nloops &gt;= pf_default_rule.timeout[PFTM_INTERVAL]) {
		pf_purge_expired_fragments();
		pf_purge_expired_src_nodes();
		nloops = 0;
	}
<span class="enscript-reference">done</span>:
	lck_mtx_unlock(pf_lock);
	lck_rw_done(pf_perim_lock);

	(<span class="enscript-type">void</span>) tsleep0(pf_purge_thread_fn, PWAIT, <span class="enscript-string">&quot;pf_purge_cont&quot;</span>,
	    t * hz, pf_purge_thread_cont);
	<span class="enscript-comment">/* NOTREACHED */</span>
	VERIFY(0);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_purge_thread_fn</span>(<span class="enscript-type">void</span> *v, wait_result_t w)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">v</span>, <span class="enscript-variable-name">w</span>)
	(<span class="enscript-type">void</span>) tsleep0(pf_purge_thread_fn, PWAIT, <span class="enscript-string">&quot;pf_purge&quot;</span>, 0,
	    pf_purge_thread_cont);
	<span class="enscript-comment">/*
	 * tsleep0() shouldn't have returned as PCATCH was not set;
	 * therefore assert in this case.
	 */</span>
	VERIFY(0);
}

u_int64_t
<span class="enscript-function-name">pf_state_expires</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> pf_state *state)
{
	u_int32_t	t;
	u_int32_t	start;
	u_int32_t	end;
	u_int32_t	states;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* handle all PFTM_* &gt; PFTM_MAX here */</span>
	<span class="enscript-keyword">if</span> (state-&gt;timeout == PFTM_PURGE)
		<span class="enscript-keyword">return</span> (pf_time_second());

	VERIFY(state-&gt;timeout != PFTM_UNLINKED);
	VERIFY(state-&gt;timeout &lt; PFTM_MAX);
	t = state-&gt;rule.ptr-&gt;timeout[state-&gt;timeout];
	<span class="enscript-keyword">if</span> (!t)
		t = pf_default_rule.timeout[state-&gt;timeout];
	start = state-&gt;rule.ptr-&gt;timeout[PFTM_ADAPTIVE_START];
	<span class="enscript-keyword">if</span> (start) {
		end = state-&gt;rule.ptr-&gt;timeout[PFTM_ADAPTIVE_END];
		states = state-&gt;rule.ptr-&gt;states;
	} <span class="enscript-keyword">else</span> {
		start = pf_default_rule.timeout[PFTM_ADAPTIVE_START];
		end = pf_default_rule.timeout[PFTM_ADAPTIVE_END];
		states = pf_status.states;
	}
	<span class="enscript-keyword">if</span> (end &amp;&amp; states &gt; start &amp;&amp; start &lt; end) {
		<span class="enscript-keyword">if</span> (states &lt; end)
			<span class="enscript-keyword">return</span> (state-&gt;expire + t * (end - states) /
			    (end - start));
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> (pf_time_second());
	}
	<span class="enscript-keyword">return</span> (state-&gt;expire + t);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_purge_expired_src_nodes</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> pf_src_node		*cur, *next;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">for</span> (cur = RB_MIN(pf_src_tree, &amp;tree_src_tracking); cur; cur = next) {
		next = RB_NEXT(pf_src_tree, &amp;tree_src_tracking, cur);

		<span class="enscript-keyword">if</span> (cur-&gt;states &lt;= 0 &amp;&amp; cur-&gt;expire &lt;= pf_time_second()) {
			<span class="enscript-keyword">if</span> (cur-&gt;rule.ptr != NULL) {
				cur-&gt;rule.ptr-&gt;src_nodes--;
				<span class="enscript-keyword">if</span> (cur-&gt;rule.ptr-&gt;states &lt;= 0 &amp;&amp;
				    cur-&gt;rule.ptr-&gt;max_src_nodes &lt;= 0)
					pf_rm_rule(NULL, cur-&gt;rule.ptr);
			}
			RB_REMOVE(pf_src_tree, &amp;tree_src_tracking, cur);
			pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
			pf_status.src_nodes--;
			pool_put(&amp;pf_src_tree_pl, cur);
		}
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_src_tree_remove_state</span>(<span class="enscript-type">struct</span> pf_state *s)
{
	u_int32_t t;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (s-&gt;src_node != NULL) {
		<span class="enscript-keyword">if</span> (s-&gt;src.tcp_est) {
			VERIFY(s-&gt;src_node-&gt;conn &gt; 0);
			--s-&gt;src_node-&gt;conn;
		}
		VERIFY(s-&gt;src_node-&gt;states &gt; 0);
		<span class="enscript-keyword">if</span> (--s-&gt;src_node-&gt;states &lt;= 0) {
			t = s-&gt;rule.ptr-&gt;timeout[PFTM_SRC_NODE];
			<span class="enscript-keyword">if</span> (!t)
				t = pf_default_rule.timeout[PFTM_SRC_NODE];
			s-&gt;src_node-&gt;expire = pf_time_second() + t;
		}
	}
	<span class="enscript-keyword">if</span> (s-&gt;nat_src_node != s-&gt;src_node &amp;&amp; s-&gt;nat_src_node != NULL) {
		VERIFY(s-&gt;nat_src_node-&gt;states &gt; 0);
		<span class="enscript-keyword">if</span> (--s-&gt;nat_src_node-&gt;states &lt;= 0) {
			t = s-&gt;rule.ptr-&gt;timeout[PFTM_SRC_NODE];
			<span class="enscript-keyword">if</span> (!t)
				t = pf_default_rule.timeout[PFTM_SRC_NODE];
			s-&gt;nat_src_node-&gt;expire = pf_time_second() + t;
		}
	}
	s-&gt;src_node = s-&gt;nat_src_node = NULL;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_unlink_state</span>(<span class="enscript-type">struct</span> pf_state *cur)
{
	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (cur-&gt;src.state == PF_TCPS_PROXY_DST) {
		pf_send_tcp(cur-&gt;rule.ptr, cur-&gt;state_key-&gt;af_lan,
		    &amp;cur-&gt;state_key-&gt;ext_lan.addr, &amp;cur-&gt;state_key-&gt;lan.addr,
		    cur-&gt;state_key-&gt;ext_lan.xport.port,
		    cur-&gt;state_key-&gt;lan.xport.port,
		    cur-&gt;src.seqhi, cur-&gt;src.seqlo + 1,
		    TH_RST|TH_ACK, 0, 0, 0, 1, cur-&gt;tag, NULL, NULL);
	}

	hook_runloop(&amp;cur-&gt;unlink_hooks, HOOK_REMOVE|HOOK_FREE);
	RB_REMOVE(pf_state_tree_id, &amp;tree_id, cur);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
	<span class="enscript-keyword">if</span> (cur-&gt;creatorid == pf_status.hostid)
		pfsync_delete_state(cur);
#<span class="enscript-reference">endif</span>
	cur-&gt;timeout = PFTM_UNLINKED;
	pf_src_tree_remove_state(cur);
	pf_detach_state(cur, 0);
}

<span class="enscript-comment">/* callers should be at splpf and hold the
 * write_lock on pf_consistency_lock */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_free_state</span>(<span class="enscript-type">struct</span> pf_state *cur)
{
	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
	<span class="enscript-keyword">if</span> (pfsyncif != NULL &amp;&amp;
	    (pfsyncif-&gt;sc_bulk_send_next == cur ||
	    pfsyncif-&gt;sc_bulk_terminator == cur))
		<span class="enscript-keyword">return</span>;
#<span class="enscript-reference">endif</span>
	VERIFY(cur-&gt;timeout == PFTM_UNLINKED);
	VERIFY(cur-&gt;rule.ptr-&gt;states &gt; 0);
	<span class="enscript-keyword">if</span> (--cur-&gt;rule.ptr-&gt;states &lt;= 0 &amp;&amp;
	    cur-&gt;rule.ptr-&gt;src_nodes &lt;= 0)
		pf_rm_rule(NULL, cur-&gt;rule.ptr);
	<span class="enscript-keyword">if</span> (cur-&gt;nat_rule.ptr != NULL) {
		VERIFY(cur-&gt;nat_rule.ptr-&gt;states &gt; 0);
		<span class="enscript-keyword">if</span> (--cur-&gt;nat_rule.ptr-&gt;states &lt;= 0 &amp;&amp;
		    cur-&gt;nat_rule.ptr-&gt;src_nodes &lt;= 0)
			pf_rm_rule(NULL, cur-&gt;nat_rule.ptr);
	}
	<span class="enscript-keyword">if</span> (cur-&gt;anchor.ptr != NULL) {
		VERIFY(cur-&gt;anchor.ptr-&gt;states &gt; 0);
		<span class="enscript-keyword">if</span> (--cur-&gt;anchor.ptr-&gt;states &lt;= 0)
			pf_rm_rule(NULL, cur-&gt;anchor.ptr);
	}
	pf_normalize_tcp_cleanup(cur);
	pfi_kif_unref(cur-&gt;kif, PFI_KIF_REF_STATE);
	TAILQ_REMOVE(&amp;state_list, cur, entry_list);
	<span class="enscript-keyword">if</span> (cur-&gt;tag)
		pf_tag_unref(cur-&gt;tag);
	pool_put(&amp;pf_state_pl, cur);
	pf_status.fcounters[FCNT_STATE_REMOVALS]++;
	VERIFY(pf_status.states &gt; 0);
	pf_status.states--;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_purge_expired_states</span>(u_int32_t maxcheck)
{
	<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pf_state	*cur = NULL;
	<span class="enscript-type">struct</span> pf_state		*next;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">while</span> (maxcheck--) {
		<span class="enscript-comment">/* wrap to start of list when we hit the end */</span>
		<span class="enscript-keyword">if</span> (cur == NULL) {
			cur = TAILQ_FIRST(&amp;state_list);
			<span class="enscript-keyword">if</span> (cur == NULL)
				<span class="enscript-keyword">break</span>;	<span class="enscript-comment">/* list empty */</span>
		}

		<span class="enscript-comment">/* get next state, as cur may get deleted */</span>
		next = TAILQ_NEXT(cur, entry_list);

		<span class="enscript-keyword">if</span> (cur-&gt;timeout == PFTM_UNLINKED) {
			pf_free_state(cur);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pf_state_expires(cur) &lt;= pf_time_second()) {
			<span class="enscript-comment">/* unlink and free expired state */</span>
			pf_unlink_state(cur);
			pf_free_state(cur);
		}
		cur = next;
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_tbladdr_setup</span>(<span class="enscript-type">struct</span> pf_ruleset *rs, <span class="enscript-type">struct</span> pf_addr_wrap *aw)
{
	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (aw-&gt;type != PF_ADDR_TABLE)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> ((aw-&gt;p.tbl = pfr_attach_table(rs, aw-&gt;v.tblname)) == NULL)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_tbladdr_remove</span>(<span class="enscript-type">struct</span> pf_addr_wrap *aw)
{
	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (aw-&gt;type != PF_ADDR_TABLE || aw-&gt;p.tbl == NULL)
		<span class="enscript-keyword">return</span>;
	pfr_detach_table(aw-&gt;p.tbl);
	aw-&gt;p.tbl = NULL;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_tbladdr_copyout</span>(<span class="enscript-type">struct</span> pf_addr_wrap *aw)
{
	<span class="enscript-type">struct</span> pfr_ktable *kt = aw-&gt;p.tbl;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (aw-&gt;type != PF_ADDR_TABLE || kt == NULL)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (!(kt-&gt;pfrkt_flags &amp; PFR_TFLAG_ACTIVE) &amp;&amp; kt-&gt;pfrkt_root != NULL)
		kt = kt-&gt;pfrkt_root;
	aw-&gt;p.tbl = NULL;
	aw-&gt;p.tblcnt = (kt-&gt;pfrkt_flags &amp; PFR_TFLAG_ACTIVE) ?
	    kt-&gt;pfrkt_cnt : -1;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_print_addr</span>(<span class="enscript-type">struct</span> pf_addr *addr, sa_family_t af)
{
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
		u_int32_t a = ntohl(addr-&gt;addr32[0]);
		printf(<span class="enscript-string">&quot;%u.%u.%u.%u&quot;</span>, (a&gt;&gt;24)&amp;255, (a&gt;&gt;16)&amp;255,
		    (a&gt;&gt;8)&amp;255, a&amp;255);
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
		u_int16_t b;
		u_int8_t i, curstart = 255, curend = 0,
		    maxstart = 0, maxend = 0;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; 8; i++) {
			<span class="enscript-keyword">if</span> (!addr-&gt;addr16[i]) {
				<span class="enscript-keyword">if</span> (curstart == 255)
					curstart = i;
				<span class="enscript-keyword">else</span>
					curend = i;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (curstart) {
					<span class="enscript-keyword">if</span> ((curend - curstart) &gt;
					    (maxend - maxstart)) {
						maxstart = curstart;
						maxend = curend;
						curstart = 255;
					}
				}
			}
		}
		<span class="enscript-keyword">for</span> (i = 0; i &lt; 8; i++) {
			<span class="enscript-keyword">if</span> (i &gt;= maxstart &amp;&amp; i &lt;= maxend) {
				<span class="enscript-keyword">if</span> (maxend != 7) {
					<span class="enscript-keyword">if</span> (i == maxstart)
						printf(<span class="enscript-string">&quot;:&quot;</span>);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (i == maxend)
						printf(<span class="enscript-string">&quot;:&quot;</span>);
				}
			} <span class="enscript-keyword">else</span> {
				b = ntohs(addr-&gt;addr16[i]);
				printf(<span class="enscript-string">&quot;%x&quot;</span>, b);
				<span class="enscript-keyword">if</span> (i &lt; 7)
					printf(<span class="enscript-string">&quot;:&quot;</span>);
			}
		}
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_print_sk_host</span>(<span class="enscript-type">struct</span> pf_state_host *sh, sa_family_t af, <span class="enscript-type">int</span> proto,
	u_int8_t proto_variant)
{
	pf_print_addr(&amp;sh-&gt;addr, af);

	<span class="enscript-keyword">switch</span> (proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
		<span class="enscript-keyword">if</span> (sh-&gt;xport.spi)
			printf(<span class="enscript-string">&quot;[%08x]&quot;</span>, ntohl(sh-&gt;xport.spi));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
		<span class="enscript-keyword">if</span> (proto_variant == PF_GRE_PPTP_VARIANT)
			printf(<span class="enscript-string">&quot;[%u]&quot;</span>, ntohs(sh-&gt;xport.call_id));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		printf(<span class="enscript-string">&quot;[%u]&quot;</span>, ntohs(sh-&gt;xport.port));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_print_host</span>(<span class="enscript-type">struct</span> pf_addr *addr, u_int16_t p, sa_family_t af)
{
	pf_print_addr(addr, af);
	<span class="enscript-keyword">if</span> (p)
		printf(<span class="enscript-string">&quot;[%u]&quot;</span>, ntohs(p));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_print_state</span>(<span class="enscript-type">struct</span> pf_state *s)
{
	<span class="enscript-type">struct</span> pf_state_key *sk = s-&gt;state_key;
	<span class="enscript-keyword">switch</span> (sk-&gt;proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
		printf(<span class="enscript-string">&quot;ESP &quot;</span>);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
		printf(<span class="enscript-string">&quot;GRE%u &quot;</span>, sk-&gt;proto_variant);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		printf(<span class="enscript-string">&quot;TCP &quot;</span>);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		printf(<span class="enscript-string">&quot;UDP &quot;</span>);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
		printf(<span class="enscript-string">&quot;ICMP &quot;</span>);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
		printf(<span class="enscript-string">&quot;ICMPV6 &quot;</span>);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		printf(<span class="enscript-string">&quot;%u &quot;</span>, sk-&gt;proto);
		<span class="enscript-keyword">break</span>;
	}
	pf_print_sk_host(&amp;sk-&gt;lan, sk-&gt;af_lan, sk-&gt;proto, sk-&gt;proto_variant);
	printf(<span class="enscript-string">&quot; &quot;</span>);
	pf_print_sk_host(&amp;sk-&gt;gwy, sk-&gt;af_gwy, sk-&gt;proto, sk-&gt;proto_variant);
	printf(<span class="enscript-string">&quot; &quot;</span>);
	pf_print_sk_host(&amp;sk-&gt;ext_lan, sk-&gt;af_lan, sk-&gt;proto,
			 sk-&gt;proto_variant);
	printf(<span class="enscript-string">&quot; &quot;</span>);
	pf_print_sk_host(&amp;sk-&gt;ext_gwy, sk-&gt;af_gwy, sk-&gt;proto,
			 sk-&gt;proto_variant);
	printf(<span class="enscript-string">&quot; [lo=%u high=%u win=%u modulator=%u&quot;</span>, s-&gt;src.seqlo,
	    s-&gt;src.seqhi, s-&gt;src.max_win, s-&gt;src.seqdiff);
	<span class="enscript-keyword">if</span> (s-&gt;src.wscale &amp;&amp; s-&gt;dst.wscale)
		printf(<span class="enscript-string">&quot; wscale=%u&quot;</span>, s-&gt;src.wscale &amp; PF_WSCALE_MASK);
	printf(<span class="enscript-string">&quot;]&quot;</span>);
	printf(<span class="enscript-string">&quot; [lo=%u high=%u win=%u modulator=%u&quot;</span>, s-&gt;dst.seqlo,
	    s-&gt;dst.seqhi, s-&gt;dst.max_win, s-&gt;dst.seqdiff);
	<span class="enscript-keyword">if</span> (s-&gt;src.wscale &amp;&amp; s-&gt;dst.wscale)
		printf(<span class="enscript-string">&quot; wscale=%u&quot;</span>, s-&gt;dst.wscale &amp; PF_WSCALE_MASK);
	printf(<span class="enscript-string">&quot;]&quot;</span>);
	printf(<span class="enscript-string">&quot; %u:%u&quot;</span>, s-&gt;src.state, s-&gt;dst.state);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_print_flags</span>(u_int8_t f)
{
	<span class="enscript-keyword">if</span> (f)
		printf(<span class="enscript-string">&quot; &quot;</span>);
	<span class="enscript-keyword">if</span> (f &amp; TH_FIN)
		printf(<span class="enscript-string">&quot;F&quot;</span>);
	<span class="enscript-keyword">if</span> (f &amp; TH_SYN)
		printf(<span class="enscript-string">&quot;S&quot;</span>);
	<span class="enscript-keyword">if</span> (f &amp; TH_RST)
		printf(<span class="enscript-string">&quot;R&quot;</span>);
	<span class="enscript-keyword">if</span> (f &amp; TH_PUSH)
		printf(<span class="enscript-string">&quot;P&quot;</span>);
	<span class="enscript-keyword">if</span> (f &amp; TH_ACK)
		printf(<span class="enscript-string">&quot;A&quot;</span>);
	<span class="enscript-keyword">if</span> (f &amp; TH_URG)
		printf(<span class="enscript-string">&quot;U&quot;</span>);
	<span class="enscript-keyword">if</span> (f &amp; TH_ECE)
		printf(<span class="enscript-string">&quot;E&quot;</span>);
	<span class="enscript-keyword">if</span> (f &amp; TH_CWR)
		printf(<span class="enscript-string">&quot;W&quot;</span>);
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PF_SET_SKIP_STEPS</span>(i)					\
	<span class="enscript-keyword">do</span> {							\
		<span class="enscript-keyword">while</span> (head[i] != cur) {			\
			head[i]-&gt;skip[i].ptr = cur;		\
			head[i] = TAILQ_NEXT(head[i], entries);	\
		}						\
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_calc_skip_steps</span>(<span class="enscript-type">struct</span> pf_rulequeue *rules)
{
	<span class="enscript-type">struct</span> pf_rule *cur, *prev, *head[PF_SKIP_COUNT];
	<span class="enscript-type">int</span> i;

	cur = TAILQ_FIRST(rules);
	prev = cur;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; PF_SKIP_COUNT; ++i)
		head[i] = cur;
	<span class="enscript-keyword">while</span> (cur != NULL) {

		<span class="enscript-keyword">if</span> (cur-&gt;kif != prev-&gt;kif || cur-&gt;ifnot != prev-&gt;ifnot)
			PF_SET_SKIP_STEPS(PF_SKIP_IFP);
		<span class="enscript-keyword">if</span> (cur-&gt;direction != prev-&gt;direction)
			PF_SET_SKIP_STEPS(PF_SKIP_DIR);
		<span class="enscript-keyword">if</span> (cur-&gt;af != prev-&gt;af)
			PF_SET_SKIP_STEPS(PF_SKIP_AF);
		<span class="enscript-keyword">if</span> (cur-&gt;proto != prev-&gt;proto)
			PF_SET_SKIP_STEPS(PF_SKIP_PROTO);
		<span class="enscript-keyword">if</span> (cur-&gt;src.neg != prev-&gt;src.neg ||
		    pf_addr_wrap_neq(&amp;cur-&gt;src.addr, &amp;prev-&gt;src.addr))
			PF_SET_SKIP_STEPS(PF_SKIP_SRC_ADDR);
		{
			<span class="enscript-type">union</span> pf_rule_xport *cx = &amp;cur-&gt;src.xport;
			<span class="enscript-type">union</span> pf_rule_xport *px = &amp;prev-&gt;src.xport;

			<span class="enscript-keyword">switch</span> (cur-&gt;proto) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
				PF_SET_SKIP_STEPS(PF_SKIP_SRC_PORT);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">if</span> (prev-&gt;proto == IPPROTO_GRE ||
				    prev-&gt;proto == IPPROTO_ESP ||
				    cx-&gt;range.op != px-&gt;range.op ||
				    cx-&gt;range.port[0] != px-&gt;range.port[0] ||
				    cx-&gt;range.port[1] != px-&gt;range.port[1])
					PF_SET_SKIP_STEPS(PF_SKIP_SRC_PORT);
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (cur-&gt;dst.neg != prev-&gt;dst.neg ||
		    pf_addr_wrap_neq(&amp;cur-&gt;dst.addr, &amp;prev-&gt;dst.addr))
			PF_SET_SKIP_STEPS(PF_SKIP_DST_ADDR);
		{
			<span class="enscript-type">union</span> pf_rule_xport *cx = &amp;cur-&gt;dst.xport;
			<span class="enscript-type">union</span> pf_rule_xport *px = &amp;prev-&gt;dst.xport;

			<span class="enscript-keyword">switch</span> (cur-&gt;proto) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
				<span class="enscript-keyword">if</span> (cur-&gt;proto != prev-&gt;proto ||
				    cx-&gt;call_id != px-&gt;call_id)
					PF_SET_SKIP_STEPS(PF_SKIP_DST_PORT);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
				<span class="enscript-keyword">if</span> (cur-&gt;proto != prev-&gt;proto ||
				    cx-&gt;spi != px-&gt;spi)
					PF_SET_SKIP_STEPS(PF_SKIP_DST_PORT);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">if</span> (prev-&gt;proto == IPPROTO_GRE ||
				    prev-&gt;proto == IPPROTO_ESP ||
				    cx-&gt;range.op != px-&gt;range.op ||
				    cx-&gt;range.port[0] != px-&gt;range.port[0] ||
				    cx-&gt;range.port[1] != px-&gt;range.port[1])
					PF_SET_SKIP_STEPS(PF_SKIP_DST_PORT);
				<span class="enscript-keyword">break</span>;
			}
		}

		prev = cur;
		cur = TAILQ_NEXT(cur, entries);
	}
	<span class="enscript-keyword">for</span> (i = 0; i &lt; PF_SKIP_COUNT; ++i)
		PF_SET_SKIP_STEPS(i);
}

u_int32_t
<span class="enscript-function-name">pf_calc_state_key_flowhash</span>(<span class="enscript-type">struct</span> pf_state_key *sk)
{
	<span class="enscript-type">struct</span> pf_flowhash_key fh __attribute__((aligned(8)));
	uint32_t flowhash = 0;

	bzero(&amp;fh, <span class="enscript-keyword">sizeof</span> (fh));
	<span class="enscript-keyword">if</span> (PF_ALEQ(&amp;sk-&gt;lan.addr, &amp;sk-&gt;ext_lan.addr, sk-&gt;af_lan)) {
		bcopy(&amp;sk-&gt;lan.addr, &amp;fh.ap1.addr, <span class="enscript-keyword">sizeof</span> (fh.ap1.addr));
		bcopy(&amp;sk-&gt;ext_lan.addr, &amp;fh.ap2.addr, <span class="enscript-keyword">sizeof</span> (fh.ap2.addr));
	} <span class="enscript-keyword">else</span> {
		bcopy(&amp;sk-&gt;ext_lan.addr, &amp;fh.ap1.addr, <span class="enscript-keyword">sizeof</span> (fh.ap1.addr));
		bcopy(&amp;sk-&gt;lan.addr, &amp;fh.ap2.addr, <span class="enscript-keyword">sizeof</span> (fh.ap2.addr));
	}
	<span class="enscript-keyword">if</span> (sk-&gt;lan.xport.spi &lt;= sk-&gt;ext_lan.xport.spi) {
		fh.ap1.xport.spi = sk-&gt;lan.xport.spi;
		fh.ap2.xport.spi = sk-&gt;ext_lan.xport.spi;
	} <span class="enscript-keyword">else</span> {
		fh.ap1.xport.spi = sk-&gt;ext_lan.xport.spi;
		fh.ap2.xport.spi = sk-&gt;lan.xport.spi;
	}
	fh.af = sk-&gt;af_lan;
	fh.proto = sk-&gt;proto;

<span class="enscript-reference">try_again</span>:
	flowhash = net_flowhash(&amp;fh, <span class="enscript-keyword">sizeof</span> (fh), pf_hash_seed);
	<span class="enscript-keyword">if</span> (flowhash == 0) {
		<span class="enscript-comment">/* try to get a non-zero flowhash */</span>
		pf_hash_seed = RandomULong();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;
	}

	<span class="enscript-keyword">return</span> (flowhash);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_addr_wrap_neq</span>(<span class="enscript-type">struct</span> pf_addr_wrap *aw1, <span class="enscript-type">struct</span> pf_addr_wrap *aw2)
{
	<span class="enscript-keyword">if</span> (aw1-&gt;type != aw2-&gt;type)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">switch</span> (aw1-&gt;type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_ADDR_ADDRMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_ADDR_RANGE</span>:
		<span class="enscript-keyword">if</span> (PF_ANEQ(&amp;aw1-&gt;v.a.addr, &amp;aw2-&gt;v.a.addr, 0))
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">if</span> (PF_ANEQ(&amp;aw1-&gt;v.a.mask, &amp;aw2-&gt;v.a.mask, 0))
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_ADDR_DYNIFTL</span>:
		<span class="enscript-keyword">return</span> (aw1-&gt;p.dyn == NULL || aw2-&gt;p.dyn == NULL ||
		    aw1-&gt;p.dyn-&gt;pfid_kt != aw2-&gt;p.dyn-&gt;pfid_kt);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_ADDR_NOROUTE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_ADDR_URPFFAILED</span>:
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_ADDR_TABLE</span>:
		<span class="enscript-keyword">return</span> (aw1-&gt;p.tbl != aw2-&gt;p.tbl);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_ADDR_RTLABEL</span>:
		<span class="enscript-keyword">return</span> (aw1-&gt;v.rtlabel != aw2-&gt;v.rtlabel);
	<span class="enscript-reference">default</span>:
		printf(<span class="enscript-string">&quot;invalid address type: %d\n&quot;</span>, aw1-&gt;type);
		<span class="enscript-keyword">return</span> (1);
	}
}

u_int16_t
<span class="enscript-function-name">pf_cksum_fixup</span>(u_int16_t cksum, u_int16_t old, u_int16_t new, u_int8_t udp)
{
	u_int32_t	l;

	<span class="enscript-keyword">if</span> (udp &amp;&amp; !cksum)
		<span class="enscript-keyword">return</span> (0);
	l = cksum + old - new;
	l = (l &gt;&gt; 16) + (l &amp; 0xffff);
	l = l &amp; 0xffff;
	<span class="enscript-keyword">if</span> (udp &amp;&amp; !l)
		<span class="enscript-keyword">return</span> (0xffff);
	<span class="enscript-keyword">return</span> (l);
}

<span class="enscript-comment">/*
 * change ip address &amp; port
 * dir	: packet direction
 * a	: address to be changed
 * p	: port to be changed
 * ic	: ip header checksum
 * pc	: protocol checksum
 * an	: new ip address
 * pn	: new port
 * u	: should be 1 if UDP packet else 0
 * af	: address family of the packet
 * afn	: address family of the new address
 * ua	: should be 1 if ip address needs to be updated in the packet else
 *	  only the checksum is recalculated &amp; updated.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_change_ap</span>(<span class="enscript-type">int</span> dir, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> pf_addr *a, u_int16_t *p,
    u_int16_t *ic, u_int16_t *pc, <span class="enscript-type">struct</span> pf_addr *an, u_int16_t pn,
    u_int8_t u, sa_family_t af, sa_family_t afn, <span class="enscript-type">int</span> ua)
{
	<span class="enscript-type">struct</span> pf_addr	ao;
	u_int16_t	po = *p;

	PF_ACPY(&amp;ao, a, af);
	<span class="enscript-keyword">if</span> (ua)
		PF_ACPY(a, an, afn);

	*p = pn;

	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		<span class="enscript-keyword">switch</span> (afn) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			*ic = pf_cksum_fixup(pf_cksum_fixup(*ic,
			ao.addr16[0], an-&gt;addr16[0], 0),
			ao.addr16[1], an-&gt;addr16[1], 0);
			*p = pn;
		<span class="enscript-comment">/*
		 * If the packet is originated from an ALG on the NAT gateway
		 * (source address is loopback or local), in which case the
		 * TCP/UDP checksum field contains the pseudo header checksum
		 * that's not yet complemented. A packet generated locally
		 * will have UDP/TCP CSUM flag set (gets set in protocol
		 * output).
		 */</span>
			<span class="enscript-keyword">if</span> (dir == PF_OUT &amp;&amp; m != NULL &amp;&amp;
			(m-&gt;m_flags &amp; M_PKTHDR) &amp;&amp;
			(m-&gt;m_pkthdr.csum_flags &amp; (CSUM_TCP | CSUM_UDP))) {
			<span class="enscript-comment">/* Pseudo-header checksum does not include ports */</span>
				*pc = ~pf_cksum_fixup(pf_cksum_fixup(~*pc,
				ao.addr16[0], an-&gt;addr16[0], u),
				ao.addr16[1], an-&gt;addr16[1], u);
			} <span class="enscript-keyword">else</span> {
				*pc =
				pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
				*pc, ao.addr16[0], an-&gt;addr16[0], u),
				ao.addr16[1], an-&gt;addr16[1], u),
				po, pn, u);
			}
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			*p = pn;
			*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(

			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
			    ao.addr16[0], an-&gt;addr16[0], u),
			    ao.addr16[1], an-&gt;addr16[1], u),
			    0,            an-&gt;addr16[2], u),
			    0,            an-&gt;addr16[3], u),
			    0,            an-&gt;addr16[4], u),
			    0,            an-&gt;addr16[5], u),
			    0,            an-&gt;addr16[6], u),
			    0,            an-&gt;addr16[7], u),
			    po, pn, u);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-keyword">switch</span> (afn) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-comment">/*
		 * If the packet is originated from an ALG on the NAT gateway
		 * (source address is loopback or local), in which case the
		 * TCP/UDP checksum field contains the pseudo header checksum
		 * that's not yet complemented.
		 * A packet generated locally
		 * will have UDP/TCP CSUM flag set (gets set in protocol
		 * output).
		 */</span>
			<span class="enscript-keyword">if</span> (dir == PF_OUT &amp;&amp; m != NULL &amp;&amp;
			    (m-&gt;m_flags &amp; M_PKTHDR) &amp;&amp;
			    (m-&gt;m_pkthdr.csum_flags &amp; (CSUM_TCPIPV6 |
						   CSUM_UDPIPV6))) {
			<span class="enscript-comment">/* Pseudo-header checksum does not include ports */</span>
				*pc =
				~pf_cksum_fixup(pf_cksum_fixup(
				pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
				pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
					~*pc,
					ao.addr16[0], an-&gt;addr16[0], u),
					ao.addr16[1], an-&gt;addr16[1], u),
					ao.addr16[2], an-&gt;addr16[2], u),
					ao.addr16[3], an-&gt;addr16[3], u),
					ao.addr16[4], an-&gt;addr16[4], u),
					ao.addr16[5], an-&gt;addr16[5], u),
					ao.addr16[6], an-&gt;addr16[6], u),
					ao.addr16[7], an-&gt;addr16[7], u);
			} <span class="enscript-keyword">else</span> {
				*pc =
				pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
				pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
				pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
					*pc,
					ao.addr16[0], an-&gt;addr16[0], u),
					ao.addr16[1], an-&gt;addr16[1], u),
					ao.addr16[2], an-&gt;addr16[2], u),
					ao.addr16[3], an-&gt;addr16[3], u),
					ao.addr16[4], an-&gt;addr16[4], u),
					ao.addr16[5], an-&gt;addr16[5], u),
					ao.addr16[6], an-&gt;addr16[6], u),
					ao.addr16[7], an-&gt;addr16[7], u),
					po, pn, u);
			}
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
			    ao.addr16[0], an-&gt;addr16[0], u),
			    ao.addr16[1], an-&gt;addr16[1], u),
			    ao.addr16[2], 0,             u),
			    ao.addr16[3], 0,             u),
			    ao.addr16[4], 0,             u),
			    ao.addr16[5], 0,             u),
			    ao.addr16[6], 0,             u),
			    ao.addr16[7], 0,             u),
			    po, pn, u);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
}


<span class="enscript-comment">/* Changes a u_int32_t.  Uses a void * so there are no align restrictions */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_change_a</span>(<span class="enscript-type">void</span> *a, u_int16_t *c, u_int32_t an, u_int8_t u)
{
	u_int32_t	ao;

	memcpy(&amp;ao, a, <span class="enscript-keyword">sizeof</span> (ao));
	memcpy(a, &amp;an, <span class="enscript-keyword">sizeof</span> (u_int32_t));
	*c = pf_cksum_fixup(pf_cksum_fixup(*c, ao / 65536, an / 65536, u),
	    ao % 65536, an % 65536, u);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_change_a6</span>(<span class="enscript-type">struct</span> pf_addr *a, u_int16_t *c, <span class="enscript-type">struct</span> pf_addr *an, u_int8_t u)
{
	<span class="enscript-type">struct</span> pf_addr	ao;

	PF_ACPY(&amp;ao, a, AF_INET6);
	PF_ACPY(a, an, AF_INET6);

	*c = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
	    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
	    pf_cksum_fixup(pf_cksum_fixup(*c,
	    ao.addr16[0], an-&gt;addr16[0], u),
	    ao.addr16[1], an-&gt;addr16[1], u),
	    ao.addr16[2], an-&gt;addr16[2], u),
	    ao.addr16[3], an-&gt;addr16[3], u),
	    ao.addr16[4], an-&gt;addr16[4], u),
	    ao.addr16[5], an-&gt;addr16[5], u),
	    ao.addr16[6], an-&gt;addr16[6], u),
	    ao.addr16[7], an-&gt;addr16[7], u);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_change_addr</span>(<span class="enscript-type">struct</span> pf_addr *a, u_int16_t *c, <span class="enscript-type">struct</span> pf_addr *an, u_int8_t u,
	       sa_family_t af, sa_family_t afn)
{
	<span class="enscript-type">struct</span> pf_addr	ao;

	PF_ACPY(&amp;ao, a, af);
	PF_ACPY(a, an, afn);

	<span class="enscript-keyword">switch</span> (af) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		<span class="enscript-keyword">switch</span> (afn) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			pf_change_a(a, c, an-&gt;v4.s_addr, u);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			*c = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(*c,
			    ao.addr16[0], an-&gt;addr16[0], u),
			    ao.addr16[1], an-&gt;addr16[1], u),
			    0,            an-&gt;addr16[2], u),
			    0,            an-&gt;addr16[3], u),
			    0,            an-&gt;addr16[4], u),
			    0,            an-&gt;addr16[5], u),
			    0,            an-&gt;addr16[6], u),
			    0,            an-&gt;addr16[7], u);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-keyword">switch</span> (afn) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			*c = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
			    pf_cksum_fixup(pf_cksum_fixup(*c,
			    ao.addr16[0], an-&gt;addr16[0], u),
			    ao.addr16[1], an-&gt;addr16[1], u),
			    ao.addr16[2], 0,             u),
			    ao.addr16[3], 0,             u),
			    ao.addr16[4], 0,             u),
			    ao.addr16[5], 0,             u),
			    ao.addr16[6], 0,             u),
			    ao.addr16[7], 0,             u);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			pf_change_a6(a, c, an, u);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_change_icmp</span>(<span class="enscript-type">struct</span> pf_addr *ia, u_int16_t *ip, <span class="enscript-type">struct</span> pf_addr *oa,
    <span class="enscript-type">struct</span> pf_addr *na, u_int16_t np, u_int16_t *pc, u_int16_t *h2c,
    u_int16_t *ic, u_int16_t *hc, u_int8_t u, sa_family_t af)
{
	<span class="enscript-type">struct</span> pf_addr	oia, ooa;

	PF_ACPY(&amp;oia, ia, af);
	PF_ACPY(&amp;ooa, oa, af);

	<span class="enscript-comment">/* Change inner protocol port, fix inner protocol checksum. */</span>
	<span class="enscript-keyword">if</span> (ip != NULL) {
		u_int16_t	oip = *ip;
		u_int32_t	opc = 0;

		<span class="enscript-keyword">if</span> (pc != NULL)
			opc = *pc;
		*ip = np;
		<span class="enscript-keyword">if</span> (pc != NULL)
			*pc = pf_cksum_fixup(*pc, oip, *ip, u);
		*ic = pf_cksum_fixup(*ic, oip, *ip, 0);
		<span class="enscript-keyword">if</span> (pc != NULL)
			*ic = pf_cksum_fixup(*ic, opc, *pc, 0);
	}
	<span class="enscript-comment">/* Change inner ip address, fix inner ip and icmp checksums. */</span>
	PF_ACPY(ia, na, af);
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
		u_int32_t	 oh2c = *h2c;

		*h2c = pf_cksum_fixup(pf_cksum_fixup(*h2c,
		    oia.addr16[0], ia-&gt;addr16[0], 0),
		    oia.addr16[1], ia-&gt;addr16[1], 0);
		*ic = pf_cksum_fixup(pf_cksum_fixup(*ic,
		    oia.addr16[0], ia-&gt;addr16[0], 0),
		    oia.addr16[1], ia-&gt;addr16[1], 0);
		*ic = pf_cksum_fixup(*ic, oh2c, *h2c, 0);
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		*ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(*ic,
		    oia.addr16[0], ia-&gt;addr16[0], u),
		    oia.addr16[1], ia-&gt;addr16[1], u),
		    oia.addr16[2], ia-&gt;addr16[2], u),
		    oia.addr16[3], ia-&gt;addr16[3], u),
		    oia.addr16[4], ia-&gt;addr16[4], u),
		    oia.addr16[5], ia-&gt;addr16[5], u),
		    oia.addr16[6], ia-&gt;addr16[6], u),
		    oia.addr16[7], ia-&gt;addr16[7], u);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
	<span class="enscript-comment">/* Change outer ip address, fix outer ip or icmpv6 checksum. */</span>
	PF_ACPY(oa, na, af);
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		*hc = pf_cksum_fixup(pf_cksum_fixup(*hc,
		    ooa.addr16[0], oa-&gt;addr16[0], 0),
		    ooa.addr16[1], oa-&gt;addr16[1], 0);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		*ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
		    pf_cksum_fixup(pf_cksum_fixup(*ic,
		    ooa.addr16[0], oa-&gt;addr16[0], u),
		    ooa.addr16[1], oa-&gt;addr16[1], u),
		    ooa.addr16[2], oa-&gt;addr16[2], u),
		    ooa.addr16[3], oa-&gt;addr16[3], u),
		    ooa.addr16[4], oa-&gt;addr16[4], u),
		    ooa.addr16[5], oa-&gt;addr16[5], u),
		    ooa.addr16[6], oa-&gt;addr16[6], u),
		    ooa.addr16[7], oa-&gt;addr16[7], u);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
}


<span class="enscript-comment">/*
 * Need to modulate the sequence numbers in the TCP SACK option
 * (credits to Krzysztof Pfaff for report and patch)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_modulate_sack</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">struct</span> pf_pdesc *pd,
    <span class="enscript-type">struct</span> tcphdr *th, <span class="enscript-type">struct</span> pf_state_peer *dst)
{
	<span class="enscript-type">int</span> hlen = (th-&gt;th_off &lt;&lt; 2) - <span class="enscript-keyword">sizeof</span> (*th), thoptlen = hlen;
	u_int8_t opts[MAX_TCPOPTLEN], *opt = opts;
	<span class="enscript-type">int</span> copyback = 0, i, olen;
	<span class="enscript-type">struct</span> sackblk sack;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCPOLEN_SACKLEN</span>	(TCPOLEN_SACK + 2)
	<span class="enscript-keyword">if</span> (hlen &lt; TCPOLEN_SACKLEN ||
	    !pf_pull_hdr(m, off + <span class="enscript-keyword">sizeof</span> (*th), opts, hlen, NULL, NULL, pd-&gt;af))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">while</span> (hlen &gt;= TCPOLEN_SACKLEN) {
		olen = opt[1];
		<span class="enscript-keyword">switch</span> (*opt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_EOL</span>:	<span class="enscript-comment">/* FALLTHROUGH */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_NOP</span>:
			opt++;
			hlen--;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_SACK</span>:
			<span class="enscript-keyword">if</span> (olen &gt; hlen)
				olen = hlen;
			<span class="enscript-keyword">if</span> (olen &gt;= TCPOLEN_SACKLEN) {
				<span class="enscript-keyword">for</span> (i = 2; i + TCPOLEN_SACK &lt;= olen;
				    i += TCPOLEN_SACK) {
					memcpy(&amp;sack, &amp;opt[i], <span class="enscript-keyword">sizeof</span> (sack));
					pf_change_a(&amp;sack.start, &amp;th-&gt;th_sum,
					    htonl(ntohl(sack.start) -
					    dst-&gt;seqdiff), 0);
					pf_change_a(&amp;sack.end, &amp;th-&gt;th_sum,
					    htonl(ntohl(sack.end) -
					    dst-&gt;seqdiff), 0);
					memcpy(&amp;opt[i], &amp;sack, <span class="enscript-keyword">sizeof</span> (sack));
				}
				copyback = off + <span class="enscript-keyword">sizeof</span> (*th) + thoptlen;
			}
			<span class="enscript-comment">/* FALLTHROUGH */</span>
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">if</span> (olen &lt; 2)
				olen = 2;
			hlen -= olen;
			opt += olen;
		}
	}

	<span class="enscript-keyword">if</span> (copyback) {
		m = pf_lazy_makewritable(pd, m, copyback);
		<span class="enscript-keyword">if</span> (!m)
			<span class="enscript-keyword">return</span> (-1);
		m_copyback(m, off + <span class="enscript-keyword">sizeof</span> (*th), thoptlen, opts);
	}
	<span class="enscript-keyword">return</span> (copyback);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_send_tcp</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> pf_rule *r, sa_family_t af,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> pf_addr *saddr, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> pf_addr *daddr,
    u_int16_t sport, u_int16_t dport, u_int32_t seq, u_int32_t ack,
    u_int8_t flags, u_int16_t win, u_int16_t mss, u_int8_t ttl, <span class="enscript-type">int</span> tag,
    u_int16_t rtag, <span class="enscript-type">struct</span> ether_header *eh, <span class="enscript-type">struct</span> ifnet *ifp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">eh</span>, <span class="enscript-variable-name">ifp</span>)
	<span class="enscript-type">struct</span> mbuf	*m;
	<span class="enscript-type">int</span>		 len, tlen;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-type">struct</span> ip	*h = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> ip6_hdr	*h6 = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-type">struct</span> tcphdr	*th = NULL;
	<span class="enscript-type">char</span>		*opt;
	<span class="enscript-type">struct</span> pf_mtag	*pf_mtag;

	<span class="enscript-comment">/* maximum segment size tcp option */</span>
	tlen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
	<span class="enscript-keyword">if</span> (mss)
		tlen += 4;

	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) + tlen;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) + tlen;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;pf_send_tcp: not AF_INET or AF_INET6!&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* create outgoing mbuf */</span>
	m = m_gethdr(M_DONTWAIT, MT_HEADER);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ((pf_mtag = pf_get_mtag(m)) == NULL) {
		m_free(m);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (tag)
		pf_mtag-&gt;pftag_flags |= PF_TAG_GENERATED;
	pf_mtag-&gt;pftag_tag = rtag;

	<span class="enscript-keyword">if</span> (r != NULL &amp;&amp; PF_RTABLEID_IS_VALID(r-&gt;rtableid))
		pf_mtag-&gt;pftag_rtableid = r-&gt;rtableid;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">if</span> (altq_allowed &amp;&amp; r != NULL &amp;&amp; r-&gt;qid)
		pf_mtag-&gt;pftag_qid = r-&gt;qid;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ECN</span>
	<span class="enscript-comment">/* add hints for ecn */</span>
	pf_mtag-&gt;pftag_hdr = mtod(m, <span class="enscript-type">struct</span> ip *);
	<span class="enscript-comment">/* record address family */</span>
	pf_mtag-&gt;pftag_flags &amp;= ~(PF_TAG_HDR_INET | PF_TAG_HDR_INET6);
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		pf_mtag-&gt;pftag_flags |= PF_TAG_HDR_INET;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		pf_mtag-&gt;pftag_flags |= PF_TAG_HDR_INET6;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ECN */</span>

	<span class="enscript-comment">/* indicate this is TCP */</span>
	m-&gt;m_pkthdr.pkt_proto = IPPROTO_TCP;

	<span class="enscript-comment">/* Make sure headers are 32-bit aligned */</span>
	m-&gt;m_data += max_linkhdr;
	m-&gt;m_pkthdr.len = m-&gt;m_len = len;
	m-&gt;m_pkthdr.rcvif = NULL;
	bzero(m-&gt;m_data, len);
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		h = mtod(m, <span class="enscript-type">struct</span> ip *);

		<span class="enscript-comment">/* IP header fields included in the TCP checksum */</span>
		h-&gt;ip_p = IPPROTO_TCP;
		h-&gt;ip_len = htons(tlen);
		h-&gt;ip_src.s_addr = saddr-&gt;v4.s_addr;
		h-&gt;ip_dst.s_addr = daddr-&gt;v4.s_addr;

		th = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)((caddr_t)h + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip));
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		h6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

		<span class="enscript-comment">/* IP header fields included in the TCP checksum */</span>
		h6-&gt;ip6_nxt = IPPROTO_TCP;
		h6-&gt;ip6_plen = htons(tlen);
		memcpy(&amp;h6-&gt;ip6_src, &amp;saddr-&gt;v6, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));
		memcpy(&amp;h6-&gt;ip6_dst, &amp;daddr-&gt;v6, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));

		th = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)
		    ((caddr_t)h6 + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr));
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}

	<span class="enscript-comment">/* TCP header */</span>
	th-&gt;th_sport = sport;
	th-&gt;th_dport = dport;
	th-&gt;th_seq = htonl(seq);
	th-&gt;th_ack = htonl(ack);
	th-&gt;th_off = tlen &gt;&gt; 2;
	th-&gt;th_flags = flags;
	th-&gt;th_win = htons(win);

	<span class="enscript-keyword">if</span> (mss) {
		opt = (<span class="enscript-type">char</span> *)(th + 1);
		opt[0] = TCPOPT_MAXSEG;
		opt[1] = 4;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
		HTONS(mss);
#<span class="enscript-reference">endif</span>
		bcopy((caddr_t)&amp;mss, (caddr_t)(opt + 2), 2);
	}

	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
		<span class="enscript-type">struct</span> route ro;

		<span class="enscript-comment">/* TCP checksum */</span>
		th-&gt;th_sum = in_cksum(m, len);

		<span class="enscript-comment">/* Finish the IP header */</span>
		h-&gt;ip_v = 4;
		h-&gt;ip_hl = <span class="enscript-keyword">sizeof</span> (*h) &gt;&gt; 2;
		h-&gt;ip_tos = IPTOS_LOWDELAY;
		<span class="enscript-comment">/*
		 * ip_output() expects ip_len and ip_off to be in host order.
		 */</span>
		h-&gt;ip_len = len;
		h-&gt;ip_off = (path_mtu_discovery ? IP_DF : 0);
		h-&gt;ip_ttl = ttl ? ttl : ip_defttl;
		h-&gt;ip_sum = 0;

		bzero(&amp;ro, <span class="enscript-keyword">sizeof</span> (ro));
		ip_output(m, NULL, &amp;ro, 0, NULL, NULL);
		ROUTE_RELEASE(&amp;ro);
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
		<span class="enscript-type">struct</span> route_in6 ro6;

		<span class="enscript-comment">/* TCP checksum */</span>
		th-&gt;th_sum = in6_cksum(m, IPPROTO_TCP,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr), tlen);

		h6-&gt;ip6_vfc |= IPV6_VERSION;
		h6-&gt;ip6_hlim = IPV6_DEFHLIM;

		bzero(&amp;ro6, <span class="enscript-keyword">sizeof</span> (ro6));
		ip6_output(m, NULL, &amp;ro6, 0, NULL, NULL, NULL);
		ROUTE_RELEASE(&amp;ro6);
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_send_icmp</span>(<span class="enscript-type">struct</span> mbuf *m, u_int8_t type, u_int8_t code, sa_family_t af,
    <span class="enscript-type">struct</span> pf_rule *r)
{
	<span class="enscript-type">struct</span> mbuf	*m0;
	<span class="enscript-type">struct</span> pf_mtag	*pf_mtag;

	m0 = m_copy(m, 0, M_COPYALL);
	<span class="enscript-keyword">if</span> (m0 == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ((pf_mtag = pf_get_mtag(m0)) == NULL)
		<span class="enscript-keyword">return</span>;

	pf_mtag-&gt;pftag_flags |= PF_TAG_GENERATED;

	<span class="enscript-keyword">if</span> (PF_RTABLEID_IS_VALID(r-&gt;rtableid))
		pf_mtag-&gt;pftag_rtableid = r-&gt;rtableid;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">if</span> (altq_allowed &amp;&amp; r-&gt;qid)
		pf_mtag-&gt;pftag_qid = r-&gt;qid;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ECN</span>
	<span class="enscript-comment">/* add hints for ecn */</span>
	pf_mtag-&gt;pftag_hdr = mtod(m0, <span class="enscript-type">struct</span> ip *);
	<span class="enscript-comment">/* record address family */</span>
	pf_mtag-&gt;pftag_flags &amp;= ~(PF_TAG_HDR_INET | PF_TAG_HDR_INET6);
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		pf_mtag-&gt;pftag_flags |= PF_TAG_HDR_INET;
		m0-&gt;m_pkthdr.pkt_proto = IPPROTO_ICMP;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		pf_mtag-&gt;pftag_flags |= PF_TAG_HDR_INET6;
		m0-&gt;m_pkthdr.pkt_proto = IPPROTO_ICMPV6;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ECN */</span>

	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		icmp_error(m0, type, code, 0, 0);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		icmp6_error(m0, type, code, 0);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
}

<span class="enscript-comment">/*
 * Return 1 if the addresses a and b match (with mask m), otherwise return 0.
 * If n is 0, they match if they are equal. If n is != 0, they match if they
 * are different.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_match_addr</span>(u_int8_t n, <span class="enscript-type">struct</span> pf_addr *a, <span class="enscript-type">struct</span> pf_addr *m,
    <span class="enscript-type">struct</span> pf_addr *b, sa_family_t af)
{
	<span class="enscript-type">int</span>	match = 0;

	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		<span class="enscript-keyword">if</span> ((a-&gt;addr32[0] &amp; m-&gt;addr32[0]) ==
		    (b-&gt;addr32[0] &amp; m-&gt;addr32[0]))
			match++;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-keyword">if</span> (((a-&gt;addr32[0] &amp; m-&gt;addr32[0]) ==
		     (b-&gt;addr32[0] &amp; m-&gt;addr32[0])) &amp;&amp;
		    ((a-&gt;addr32[1] &amp; m-&gt;addr32[1]) ==
		     (b-&gt;addr32[1] &amp; m-&gt;addr32[1])) &amp;&amp;
		    ((a-&gt;addr32[2] &amp; m-&gt;addr32[2]) ==
		     (b-&gt;addr32[2] &amp; m-&gt;addr32[2])) &amp;&amp;
		    ((a-&gt;addr32[3] &amp; m-&gt;addr32[3]) ==
		     (b-&gt;addr32[3] &amp; m-&gt;addr32[3])))
			match++;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
	<span class="enscript-keyword">if</span> (match) {
		<span class="enscript-keyword">if</span> (n)
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> (1);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (n)
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> (0);
	}
}

<span class="enscript-comment">/*
 * Return 1 if b &lt;= a &lt;= e, otherwise return 0.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_match_addr_range</span>(<span class="enscript-type">struct</span> pf_addr *b, <span class="enscript-type">struct</span> pf_addr *e,
    <span class="enscript-type">struct</span> pf_addr *a, sa_family_t af)
{
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		<span class="enscript-keyword">if</span> ((a-&gt;addr32[0] &lt; b-&gt;addr32[0]) ||
		    (a-&gt;addr32[0] &gt; e-&gt;addr32[0]))
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
		<span class="enscript-type">int</span>	i;

		<span class="enscript-comment">/* check a &gt;= b */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; 4; ++i)
			<span class="enscript-keyword">if</span> (a-&gt;addr32[i] &gt; b-&gt;addr32[i])
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;addr32[i] &lt; b-&gt;addr32[i])
				<span class="enscript-keyword">return</span> (0);
		<span class="enscript-comment">/* check a &lt;= e */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; 4; ++i)
			<span class="enscript-keyword">if</span> (a-&gt;addr32[i] &lt; e-&gt;addr32[i])
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;addr32[i] &gt; e-&gt;addr32[i])
				<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_match</span>(u_int8_t op, u_int32_t a1, u_int32_t a2, u_int32_t p)
{
	<span class="enscript-keyword">switch</span> (op) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OP_IRG</span>:
		<span class="enscript-keyword">return</span> ((p &gt; a1) &amp;&amp; (p &lt; a2));
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OP_XRG</span>:
		<span class="enscript-keyword">return</span> ((p &lt; a1) || (p &gt; a2));
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OP_RRG</span>:
		<span class="enscript-keyword">return</span> ((p &gt;= a1) &amp;&amp; (p &lt;= a2));
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OP_EQ</span>:
		<span class="enscript-keyword">return</span> (p == a1);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OP_NE</span>:
		<span class="enscript-keyword">return</span> (p != a1);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OP_LT</span>:
		<span class="enscript-keyword">return</span> (p &lt; a1);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OP_LE</span>:
		<span class="enscript-keyword">return</span> (p &lt;= a1);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OP_GT</span>:
		<span class="enscript-keyword">return</span> (p &gt; a1);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OP_GE</span>:
		<span class="enscript-keyword">return</span> (p &gt;= a1);
	}
	<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* never reached */</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_match_port</span>(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	NTOHS(a1);
	NTOHS(a2);
	NTOHS(p);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (pf_match(op, a1, a2, p));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_match_xport</span>(u_int8_t proto, u_int8_t proto_variant, <span class="enscript-type">union</span> pf_rule_xport *rx,
    <span class="enscript-type">union</span> pf_state_xport *sx)
{
	<span class="enscript-type">int</span> d = !0;

	<span class="enscript-keyword">if</span> (sx) {
		<span class="enscript-keyword">switch</span> (proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
			<span class="enscript-keyword">if</span> (proto_variant == PF_GRE_PPTP_VARIANT)
				d = (rx-&gt;call_id == sx-&gt;call_id);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
			d = (rx-&gt;spi == sx-&gt;spi);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
			<span class="enscript-keyword">if</span> (rx-&gt;range.op)
				d = pf_match_port(rx-&gt;range.op,
				    rx-&gt;range.port[0], rx-&gt;range.port[1],
				    sx-&gt;port);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (d);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_match_uid</span>(u_int8_t op, uid_t a1, uid_t a2, uid_t u)
{
	<span class="enscript-keyword">if</span> (u == UID_MAX &amp;&amp; op != PF_OP_EQ &amp;&amp; op != PF_OP_NE)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">return</span> (pf_match(op, a1, a2, u));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_match_gid</span>(u_int8_t op, gid_t a1, gid_t a2, gid_t g)
{
	<span class="enscript-keyword">if</span> (g == GID_MAX &amp;&amp; op != PF_OP_EQ &amp;&amp; op != PF_OP_NE)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">return</span> (pf_match(op, a1, a2, g));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_match_tag</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> pf_rule *r, <span class="enscript-type">struct</span> pf_mtag *pf_mtag,
    <span class="enscript-type">int</span> *tag)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">m</span>)
	<span class="enscript-keyword">if</span> (*tag == -1)
		*tag = pf_mtag-&gt;pftag_tag;

	<span class="enscript-keyword">return</span> ((!r-&gt;match_tag_not &amp;&amp; r-&gt;match_tag == *tag) ||
	    (r-&gt;match_tag_not &amp;&amp; r-&gt;match_tag != *tag));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_tag_packet</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> pf_mtag *pf_mtag, <span class="enscript-type">int</span> tag,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> rtableid, <span class="enscript-type">struct</span> pf_pdesc *pd)
{
	<span class="enscript-keyword">if</span> (tag &lt;= 0 &amp;&amp; !PF_RTABLEID_IS_VALID(rtableid) &amp;&amp;
	    (pd == NULL || !(pd-&gt;pktflags &amp; PKTF_FLOW_ID)))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (pf_mtag == NULL &amp;&amp; (pf_mtag = pf_get_mtag(m)) == NULL)
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">if</span> (tag &gt; 0)
		pf_mtag-&gt;pftag_tag = tag;
	<span class="enscript-keyword">if</span> (PF_RTABLEID_IS_VALID(rtableid))
		pf_mtag-&gt;pftag_rtableid = rtableid;
	<span class="enscript-keyword">if</span> (pd != NULL &amp;&amp; (pd-&gt;pktflags &amp; PKTF_FLOW_ID)) {
		m-&gt;m_pkthdr.pkt_flowsrc = pd-&gt;flowsrc;
		m-&gt;m_pkthdr.pkt_flowid = pd-&gt;flowhash;
		m-&gt;m_pkthdr.pkt_flags |= pd-&gt;pktflags;
		m-&gt;m_pkthdr.pkt_proto = pd-&gt;proto;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_step_into_anchor</span>(<span class="enscript-type">int</span> *depth, <span class="enscript-type">struct</span> pf_ruleset **rs, <span class="enscript-type">int</span> n,
    <span class="enscript-type">struct</span> pf_rule **r, <span class="enscript-type">struct</span> pf_rule **a,  <span class="enscript-type">int</span> *match)
{
	<span class="enscript-type">struct</span> pf_anchor_stackframe	*f;

	(*r)-&gt;anchor-&gt;match = 0;
	<span class="enscript-keyword">if</span> (match)
		*match = 0;
	<span class="enscript-keyword">if</span> (*depth &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (pf_anchor_stack) /
	    (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (pf_anchor_stack[0])) {
		printf(<span class="enscript-string">&quot;pf_step_into_anchor: stack overflow\n&quot;</span>);
		*r = TAILQ_NEXT(*r, entries);
		<span class="enscript-keyword">return</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*depth == 0 &amp;&amp; a != NULL)
		*a = *r;
	f = pf_anchor_stack + (*depth)++;
	f-&gt;rs = *rs;
	f-&gt;r = *r;
	<span class="enscript-keyword">if</span> ((*r)-&gt;anchor_wildcard) {
		f-&gt;parent = &amp;(*r)-&gt;anchor-&gt;children;
		<span class="enscript-keyword">if</span> ((f-&gt;child = RB_MIN(pf_anchor_node, f-&gt;parent)) ==
		    NULL) {
			*r = NULL;
			<span class="enscript-keyword">return</span>;
		}
		*rs = &amp;f-&gt;child-&gt;ruleset;
	} <span class="enscript-keyword">else</span> {
		f-&gt;parent = NULL;
		f-&gt;child = NULL;
		*rs = &amp;(*r)-&gt;anchor-&gt;ruleset;
	}
	*r = TAILQ_FIRST((*rs)-&gt;rules[n].active.ptr);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_step_out_of_anchor</span>(<span class="enscript-type">int</span> *depth, <span class="enscript-type">struct</span> pf_ruleset **rs, <span class="enscript-type">int</span> n,
    <span class="enscript-type">struct</span> pf_rule **r, <span class="enscript-type">struct</span> pf_rule **a, <span class="enscript-type">int</span> *match)
{
	<span class="enscript-type">struct</span> pf_anchor_stackframe	*f;
	<span class="enscript-type">int</span> quick = 0;

	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (*depth &lt;= 0)
			<span class="enscript-keyword">break</span>;
		f = pf_anchor_stack + *depth - 1;
		<span class="enscript-keyword">if</span> (f-&gt;parent != NULL &amp;&amp; f-&gt;child != NULL) {
			<span class="enscript-keyword">if</span> (f-&gt;child-&gt;match ||
			    (match != NULL &amp;&amp; *match)) {
				f-&gt;r-&gt;anchor-&gt;match = 1;
				*match = 0;
			}
			f-&gt;child = RB_NEXT(pf_anchor_node, f-&gt;parent, f-&gt;child);
			<span class="enscript-keyword">if</span> (f-&gt;child != NULL) {
				*rs = &amp;f-&gt;child-&gt;ruleset;
				*r = TAILQ_FIRST((*rs)-&gt;rules[n].active.ptr);
				<span class="enscript-keyword">if</span> (*r == NULL)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">else</span>
					<span class="enscript-keyword">break</span>;
			}
		}
		(*depth)--;
		<span class="enscript-keyword">if</span> (*depth == 0 &amp;&amp; a != NULL)
			*a = NULL;
		*rs = f-&gt;rs;
		<span class="enscript-keyword">if</span> (f-&gt;r-&gt;anchor-&gt;match || (match  != NULL &amp;&amp; *match))
			quick = f-&gt;r-&gt;quick;
		*r = TAILQ_NEXT(f-&gt;r, entries);
	} <span class="enscript-keyword">while</span> (*r == NULL);

	<span class="enscript-keyword">return</span> (quick);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_poolmask</span>(<span class="enscript-type">struct</span> pf_addr *naddr, <span class="enscript-type">struct</span> pf_addr *raddr,
    <span class="enscript-type">struct</span> pf_addr *rmask, <span class="enscript-type">struct</span> pf_addr *saddr, sa_family_t af)
{
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		naddr-&gt;addr32[0] = (raddr-&gt;addr32[0] &amp; rmask-&gt;addr32[0]) |
		    ((rmask-&gt;addr32[0] ^ 0xffffffff) &amp; saddr-&gt;addr32[0]);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		naddr-&gt;addr32[0] = (raddr-&gt;addr32[0] &amp; rmask-&gt;addr32[0]) |
		    ((rmask-&gt;addr32[0] ^ 0xffffffff) &amp; saddr-&gt;addr32[0]);
		naddr-&gt;addr32[1] = (raddr-&gt;addr32[1] &amp; rmask-&gt;addr32[1]) |
		    ((rmask-&gt;addr32[1] ^ 0xffffffff) &amp; saddr-&gt;addr32[1]);
		naddr-&gt;addr32[2] = (raddr-&gt;addr32[2] &amp; rmask-&gt;addr32[2]) |
		    ((rmask-&gt;addr32[2] ^ 0xffffffff) &amp; saddr-&gt;addr32[2]);
		naddr-&gt;addr32[3] = (raddr-&gt;addr32[3] &amp; rmask-&gt;addr32[3]) |
		    ((rmask-&gt;addr32[3] ^ 0xffffffff) &amp; saddr-&gt;addr32[3]);
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pf_addr_inc</span>(<span class="enscript-type">struct</span> pf_addr *addr, sa_family_t af)
{
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		addr-&gt;addr32[0] = htonl(ntohl(addr-&gt;addr32[0]) + 1);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-keyword">if</span> (addr-&gt;addr32[3] == 0xffffffff) {
			addr-&gt;addr32[3] = 0;
			<span class="enscript-keyword">if</span> (addr-&gt;addr32[2] == 0xffffffff) {
				addr-&gt;addr32[2] = 0;
				<span class="enscript-keyword">if</span> (addr-&gt;addr32[1] == 0xffffffff) {
					addr-&gt;addr32[1] = 0;
					addr-&gt;addr32[0] =
					    htonl(ntohl(addr-&gt;addr32[0]) + 1);
				} <span class="enscript-keyword">else</span>
					addr-&gt;addr32[1] =
					    htonl(ntohl(addr-&gt;addr32[1]) + 1);
			} <span class="enscript-keyword">else</span>
				addr-&gt;addr32[2] =
				    htonl(ntohl(addr-&gt;addr32[2]) + 1);
		} <span class="enscript-keyword">else</span>
			addr-&gt;addr32[3] =
			    htonl(ntohl(addr-&gt;addr32[3]) + 1);
		<span class="enscript-keyword">break</span>;
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mix</span>(a, b, c) \
	<span class="enscript-keyword">do</span> {					\
		a -= b; a -= c; a ^= (c &gt;&gt; 13);	\
		b -= c; b -= a; b ^= (a &lt;&lt; 8);	\
		c -= a; c -= b; c ^= (b &gt;&gt; 13);	\
		a -= b; a -= c; a ^= (c &gt;&gt; 12);	\
		b -= c; b -= a; b ^= (a &lt;&lt; 16);	\
		c -= a; c -= b; c ^= (b &gt;&gt; 5);	\
		a -= b; a -= c; a ^= (c &gt;&gt; 3);	\
		b -= c; b -= a; b ^= (a &lt;&lt; 10);	\
		c -= a; c -= b; c ^= (b &gt;&gt; 15);	\
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * hash function based on bridge_hash in if_bridge.c
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_hash</span>(<span class="enscript-type">struct</span> pf_addr *inaddr, <span class="enscript-type">struct</span> pf_addr *hash,
    <span class="enscript-type">struct</span> pf_poolhashkey *key, sa_family_t af)
{
	u_int32_t	a = 0x9e3779b9, b = 0x9e3779b9, c = key-&gt;key32[0];

	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		a += inaddr-&gt;addr32[0];
		b += key-&gt;key32[1];
		mix(a, b, c);
		hash-&gt;addr32[0] = c + key-&gt;key32[2];
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		a += inaddr-&gt;addr32[0];
		b += inaddr-&gt;addr32[2];
		mix(a, b, c);
		hash-&gt;addr32[0] = c;
		a += inaddr-&gt;addr32[1];
		b += inaddr-&gt;addr32[3];
		c += key-&gt;key32[1];
		mix(a, b, c);
		hash-&gt;addr32[1] = c;
		a += inaddr-&gt;addr32[2];
		b += inaddr-&gt;addr32[1];
		c += key-&gt;key32[2];
		mix(a, b, c);
		hash-&gt;addr32[2] = c;
		a += inaddr-&gt;addr32[3];
		b += inaddr-&gt;addr32[0];
		c += key-&gt;key32[3];
		mix(a, b, c);
		hash-&gt;addr32[3] = c;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_map_addr</span>(sa_family_t af, <span class="enscript-type">struct</span> pf_rule *r, <span class="enscript-type">struct</span> pf_addr *saddr,
    <span class="enscript-type">struct</span> pf_addr *naddr, <span class="enscript-type">struct</span> pf_addr *init_addr, <span class="enscript-type">struct</span> pf_src_node **sn)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>		 hash[16];
	<span class="enscript-type">struct</span> pf_pool		*rpool = &amp;r-&gt;rpool;
	<span class="enscript-type">struct</span> pf_addr		*raddr = &amp;rpool-&gt;cur-&gt;addr.v.a.addr;
	<span class="enscript-type">struct</span> pf_addr		*rmask = &amp;rpool-&gt;cur-&gt;addr.v.a.mask;
	<span class="enscript-type">struct</span> pf_pooladdr	*acur = rpool-&gt;cur;
	<span class="enscript-type">struct</span> pf_src_node	 k;

	<span class="enscript-keyword">if</span> (*sn == NULL &amp;&amp; r-&gt;rpool.opts &amp; PF_POOL_STICKYADDR &amp;&amp;
	    (r-&gt;rpool.opts &amp; PF_POOL_TYPEMASK) != PF_POOL_NONE) {
		k.af = af;
		PF_ACPY(&amp;k.addr, saddr, af);
		<span class="enscript-keyword">if</span> (r-&gt;rule_flag &amp; PFRULE_RULESRCTRACK ||
		    r-&gt;rpool.opts &amp; PF_POOL_STICKYADDR)
			k.rule.ptr = r;
		<span class="enscript-keyword">else</span>
			k.rule.ptr = NULL;
		pf_status.scounters[SCNT_SRC_NODE_SEARCH]++;
		*sn = RB_FIND(pf_src_tree, &amp;tree_src_tracking, &amp;k);
		<span class="enscript-keyword">if</span> (*sn != NULL &amp;&amp; !PF_AZERO(&amp;(*sn)-&gt;raddr, rpool-&gt;af)) {
			PF_ACPY(naddr, &amp;(*sn)-&gt;raddr, rpool-&gt;af);
			<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
				printf(<span class="enscript-string">&quot;pf_map_addr: src tracking maps &quot;</span>);
				pf_print_host(&amp;k.addr, 0, af);
				printf(<span class="enscript-string">&quot; to &quot;</span>);
				pf_print_host(naddr, 0, rpool-&gt;af);
				printf(<span class="enscript-string">&quot;\n&quot;</span>);
			}
			<span class="enscript-keyword">return</span> (0);
		}
	}

	<span class="enscript-keyword">if</span> (rpool-&gt;cur-&gt;addr.type == PF_ADDR_NOROUTE)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">if</span> (rpool-&gt;cur-&gt;addr.type == PF_ADDR_DYNIFTL) {
		<span class="enscript-keyword">if</span> (rpool-&gt;cur-&gt;addr.p.dyn == NULL)
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">switch</span> (rpool-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			<span class="enscript-keyword">if</span> (rpool-&gt;cur-&gt;addr.p.dyn-&gt;pfid_acnt4 &lt; 1 &amp;&amp;
			    (rpool-&gt;opts &amp; PF_POOL_TYPEMASK) !=
			    PF_POOL_ROUNDROBIN)
				<span class="enscript-keyword">return</span> (1);
			raddr = &amp;rpool-&gt;cur-&gt;addr.p.dyn-&gt;pfid_addr4;
			rmask = &amp;rpool-&gt;cur-&gt;addr.p.dyn-&gt;pfid_mask4;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			<span class="enscript-keyword">if</span> (rpool-&gt;cur-&gt;addr.p.dyn-&gt;pfid_acnt6 &lt; 1 &amp;&amp;
			    (rpool-&gt;opts &amp; PF_POOL_TYPEMASK) !=
			    PF_POOL_ROUNDROBIN)
				<span class="enscript-keyword">return</span> (1);
			raddr = &amp;rpool-&gt;cur-&gt;addr.p.dyn-&gt;pfid_addr6;
			rmask = &amp;rpool-&gt;cur-&gt;addr.p.dyn-&gt;pfid_mask6;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rpool-&gt;cur-&gt;addr.type == PF_ADDR_TABLE) {
		<span class="enscript-keyword">if</span> ((rpool-&gt;opts &amp; PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN)
			<span class="enscript-keyword">return</span> (1); <span class="enscript-comment">/* unsupported */</span>
	} <span class="enscript-keyword">else</span> {
		raddr = &amp;rpool-&gt;cur-&gt;addr.v.a.addr;
		rmask = &amp;rpool-&gt;cur-&gt;addr.v.a.mask;
	}

	<span class="enscript-keyword">switch</span> (rpool-&gt;opts &amp; PF_POOL_TYPEMASK) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_POOL_NONE</span>:
		PF_ACPY(naddr, raddr, rpool-&gt;af);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_POOL_BITMASK</span>:
		ASSERT(af == rpool-&gt;af);
		PF_POOLMASK(naddr, raddr, rmask, saddr, af);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_POOL_RANDOM</span>:
		<span class="enscript-keyword">if</span> (init_addr != NULL &amp;&amp; PF_AZERO(init_addr, rpool-&gt;af)) {
			<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				rpool-&gt;counter.addr32[0] = htonl(random());
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				<span class="enscript-keyword">if</span> (rmask-&gt;addr32[3] != 0xffffffff)
					rpool-&gt;counter.addr32[3] =
					    RandomULong();
				<span class="enscript-keyword">else</span>
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">if</span> (rmask-&gt;addr32[2] != 0xffffffff)
					rpool-&gt;counter.addr32[2] =
					    RandomULong();
				<span class="enscript-keyword">else</span>
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">if</span> (rmask-&gt;addr32[1] != 0xffffffff)
					rpool-&gt;counter.addr32[1] =
					    RandomULong();
				<span class="enscript-keyword">else</span>
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">if</span> (rmask-&gt;addr32[0] != 0xffffffff)
					rpool-&gt;counter.addr32[0] =
					    RandomULong();
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			}
			PF_POOLMASK(naddr, raddr, rmask, &amp;rpool-&gt;counter,
				    rpool-&gt;af);
			PF_ACPY(init_addr, naddr, rpool-&gt;af);

		} <span class="enscript-keyword">else</span> {
			PF_AINC(&amp;rpool-&gt;counter, rpool-&gt;af);
			PF_POOLMASK(naddr, raddr, rmask, &amp;rpool-&gt;counter,
				    rpool-&gt;af);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_POOL_SRCHASH</span>:
		ASSERT(af == rpool-&gt;af);
		PF_POOLMASK(naddr, raddr, rmask, saddr, af);
		pf_hash(saddr, (<span class="enscript-type">struct</span> pf_addr *)(<span class="enscript-type">void</span> *)&amp;hash,
		    &amp;rpool-&gt;key, af);
		PF_POOLMASK(naddr, raddr, rmask,
		    (<span class="enscript-type">struct</span> pf_addr *)(<span class="enscript-type">void</span> *)&amp;hash, af);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_POOL_ROUNDROBIN</span>:
		<span class="enscript-keyword">if</span> (rpool-&gt;cur-&gt;addr.type == PF_ADDR_TABLE) {
			<span class="enscript-keyword">if</span> (!pfr_pool_get(rpool-&gt;cur-&gt;addr.p.tbl,
			    &amp;rpool-&gt;tblidx, &amp;rpool-&gt;counter,
			    &amp;raddr, &amp;rmask, rpool-&gt;af))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">get_addr</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rpool-&gt;cur-&gt;addr.type == PF_ADDR_DYNIFTL) {
			<span class="enscript-keyword">if</span> (rpool-&gt;cur-&gt;addr.p.dyn != NULL &amp;&amp;
			    !pfr_pool_get(rpool-&gt;cur-&gt;addr.p.dyn-&gt;pfid_kt,
			    &amp;rpool-&gt;tblidx, &amp;rpool-&gt;counter,
			    &amp;raddr, &amp;rmask, af))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">get_addr</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pf_match_addr(0, raddr, rmask, &amp;rpool-&gt;counter,
					 rpool-&gt;af))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">get_addr</span>;

	<span class="enscript-reference">try_next</span>:
		<span class="enscript-keyword">if</span> ((rpool-&gt;cur = TAILQ_NEXT(rpool-&gt;cur, entries)) == NULL)
			rpool-&gt;cur = TAILQ_FIRST(&amp;rpool-&gt;list);
		<span class="enscript-keyword">if</span> (rpool-&gt;cur-&gt;addr.type == PF_ADDR_TABLE) {
			rpool-&gt;tblidx = -1;
			<span class="enscript-keyword">if</span> (pfr_pool_get(rpool-&gt;cur-&gt;addr.p.tbl,
			    &amp;rpool-&gt;tblidx, &amp;rpool-&gt;counter,
			    &amp;raddr, &amp;rmask, rpool-&gt;af)) {
				<span class="enscript-comment">/* table contains no address of type
				 * 'rpool-&gt;af' */</span>
				<span class="enscript-keyword">if</span> (rpool-&gt;cur != acur)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_next</span>;
				<span class="enscript-keyword">return</span> (1);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rpool-&gt;cur-&gt;addr.type == PF_ADDR_DYNIFTL) {
			rpool-&gt;tblidx = -1;
			<span class="enscript-keyword">if</span> (rpool-&gt;cur-&gt;addr.p.dyn == NULL)
				<span class="enscript-keyword">return</span> (1);
			<span class="enscript-keyword">if</span> (pfr_pool_get(rpool-&gt;cur-&gt;addr.p.dyn-&gt;pfid_kt,
			    &amp;rpool-&gt;tblidx, &amp;rpool-&gt;counter,
			    &amp;raddr, &amp;rmask, rpool-&gt;af)) {
				<span class="enscript-comment">/* table contains no address of type
				 * 'rpool-&gt;af' */</span>
				<span class="enscript-keyword">if</span> (rpool-&gt;cur != acur)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_next</span>;
				<span class="enscript-keyword">return</span> (1);
			}
		} <span class="enscript-keyword">else</span> {
			raddr = &amp;rpool-&gt;cur-&gt;addr.v.a.addr;
			rmask = &amp;rpool-&gt;cur-&gt;addr.v.a.mask;
			PF_ACPY(&amp;rpool-&gt;counter, raddr, rpool-&gt;af);
		}

	<span class="enscript-reference">get_addr</span>:
		PF_ACPY(naddr, &amp;rpool-&gt;counter, rpool-&gt;af);
		<span class="enscript-keyword">if</span> (init_addr != NULL &amp;&amp; PF_AZERO(init_addr, rpool-&gt;af))
			PF_ACPY(init_addr, naddr, rpool-&gt;af);
		PF_AINC(&amp;rpool-&gt;counter, rpool-&gt;af);
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (*sn != NULL)
		PF_ACPY(&amp;(*sn)-&gt;raddr, naddr, rpool-&gt;af);

	<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC &amp;&amp;
	    (rpool-&gt;opts &amp; PF_POOL_TYPEMASK) != PF_POOL_NONE) {
		printf(<span class="enscript-string">&quot;pf_map_addr: selected address &quot;</span>);
		pf_print_host(naddr, 0, rpool-&gt;af);
		printf(<span class="enscript-string">&quot;\n&quot;</span>);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_get_sport</span>(<span class="enscript-type">struct</span> pf_pdesc *pd, <span class="enscript-type">struct</span> pfi_kif *kif, <span class="enscript-type">struct</span> pf_rule *r,
    <span class="enscript-type">struct</span> pf_addr *saddr, <span class="enscript-type">union</span> pf_state_xport *sxport, <span class="enscript-type">struct</span> pf_addr *daddr,
    <span class="enscript-type">union</span> pf_state_xport *dxport, <span class="enscript-type">struct</span> pf_addr *naddr,
    <span class="enscript-type">union</span> pf_state_xport *nxport, <span class="enscript-type">struct</span> pf_src_node **sn)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kif</span>)
	<span class="enscript-type">struct</span> pf_state_key_cmp	key;
	<span class="enscript-type">struct</span> pf_addr		init_addr;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> cut;
	sa_family_t af = pd-&gt;af;
	u_int8_t proto = pd-&gt;proto;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> low = r-&gt;rpool.proxy_port[0];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> high = r-&gt;rpool.proxy_port[1];

	bzero(&amp;init_addr, <span class="enscript-keyword">sizeof</span> (init_addr));
	<span class="enscript-keyword">if</span> (pf_map_addr(af, r, saddr, naddr, &amp;init_addr, sn))
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">if</span> (proto == IPPROTO_ICMP) {
		low = 1;
		high = 65535;
	}

	<span class="enscript-keyword">if</span> (!nxport)
		<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* No output necessary. */</span>

	<span class="enscript-comment">/*--- Special mapping rules for UDP ---*/</span>
	<span class="enscript-keyword">if</span> (proto == IPPROTO_UDP) {

		<span class="enscript-comment">/*--- Never float IKE source port ---*/</span>
		<span class="enscript-keyword">if</span> (ntohs(sxport-&gt;port) == PF_IKE_PORT) {
			nxport-&gt;port = sxport-&gt;port;
			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-comment">/*--- Apply exterior mapping options ---*/</span>
		<span class="enscript-keyword">if</span> (r-&gt;extmap &gt; PF_EXTMAP_APD) {
			<span class="enscript-type">struct</span> pf_state *s;

			TAILQ_FOREACH(s, &amp;state_list, entry_list) {
				<span class="enscript-type">struct</span> pf_state_key *sk = s-&gt;state_key;
				<span class="enscript-keyword">if</span> (!sk)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr != r)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">if</span> (sk-&gt;proto != IPPROTO_UDP ||
				    sk-&gt;af_lan != af)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">if</span> (sk-&gt;lan.xport.port != sxport-&gt;port)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">if</span> (PF_ANEQ(&amp;sk-&gt;lan.addr, saddr, af))
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">if</span> (r-&gt;extmap &lt; PF_EXTMAP_EI &amp;&amp;
				    PF_ANEQ(&amp;sk-&gt;ext_lan.addr, daddr, af))
					<span class="enscript-keyword">continue</span>;

				nxport-&gt;port = sk-&gt;gwy.xport.port;
				<span class="enscript-keyword">return</span> (0);
			}
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (proto == IPPROTO_TCP) {
		<span class="enscript-type">struct</span> pf_state* s;
		<span class="enscript-comment">/*
		 * APPLE MODIFICATION: &lt;rdar://problem/6546358&gt;
		 * Fix allows....NAT to use a single binding for TCP session
		 * with same source IP and source port
		 */</span>
		TAILQ_FOREACH(s, &amp;state_list, entry_list) {
			<span class="enscript-type">struct</span> pf_state_key* sk = s-&gt;state_key;
			<span class="enscript-keyword">if</span> (!sk)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr != r)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (sk-&gt;proto != IPPROTO_TCP || sk-&gt;af_lan != af)
				 <span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (sk-&gt;lan.xport.port != sxport-&gt;port)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (!(PF_AEQ(&amp;sk-&gt;lan.addr, saddr, af)))
				<span class="enscript-keyword">continue</span>;
			nxport-&gt;port = sk-&gt;gwy.xport.port;
			<span class="enscript-keyword">return</span> (0);
		}
	}
	<span class="enscript-keyword">do</span> {
		key.af_gwy = af;
		key.proto = proto;
		PF_ACPY(&amp;key.ext_gwy.addr, daddr, key.af_gwy);
		PF_ACPY(&amp;key.gwy.addr, naddr, key.af_gwy);
		<span class="enscript-keyword">switch</span> (proto) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
				key.proto_variant = r-&gt;extfilter;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				key.proto_variant = 0;
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (dxport)
			key.ext_gwy.xport = *dxport;
		<span class="enscript-keyword">else</span>
			memset(&amp;key.ext_gwy.xport, 0,
				<span class="enscript-keyword">sizeof</span> (key.ext_gwy.xport));
		<span class="enscript-comment">/*
		 * port search; start random, step;
		 * similar 2 portloop in in_pcbbind
		 */</span>
		<span class="enscript-keyword">if</span> (!(proto == IPPROTO_TCP || proto == IPPROTO_UDP ||
		    proto == IPPROTO_ICMP)) {
			<span class="enscript-keyword">if</span> (dxport)
				key.gwy.xport = *dxport;
			<span class="enscript-keyword">else</span>
				memset(&amp;key.gwy.xport, 0,
				    <span class="enscript-keyword">sizeof</span> (key.gwy.xport));
			<span class="enscript-keyword">if</span> (pf_find_state_all(&amp;key, PF_IN, NULL) == NULL)
				<span class="enscript-keyword">return</span> (0);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (low == 0 &amp;&amp; high == 0) {
			key.gwy.xport = *nxport;
			<span class="enscript-keyword">if</span> (pf_find_state_all(&amp;key, PF_IN, NULL) == NULL)
				<span class="enscript-keyword">return</span> (0);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (low == high) {
			key.gwy.xport.port = htons(low);
			<span class="enscript-keyword">if</span> (pf_find_state_all(&amp;key, PF_IN, NULL) == NULL) {
				nxport-&gt;port = htons(low);
				<span class="enscript-keyword">return</span> (0);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> tmp;
			<span class="enscript-keyword">if</span> (low &gt; high) {
				tmp = low;
				low = high;
				high = tmp;
			}
			<span class="enscript-comment">/* low &lt; high */</span>
			cut = htonl(random()) % (1 + high - low) + low;
			<span class="enscript-comment">/* low &lt;= cut &lt;= high */</span>
			<span class="enscript-keyword">for</span> (tmp = cut; tmp &lt;= high; ++(tmp)) {
				key.gwy.xport.port = htons(tmp);
				<span class="enscript-keyword">if</span> (pf_find_state_all(&amp;key, PF_IN, NULL) ==
				    NULL) {
					nxport-&gt;port = htons(tmp);
					<span class="enscript-keyword">return</span> (0);
				}
			}
			<span class="enscript-keyword">for</span> (tmp = cut - 1; tmp &gt;= low; --(tmp)) {
				key.gwy.xport.port = htons(tmp);
				<span class="enscript-keyword">if</span> (pf_find_state_all(&amp;key, PF_IN, NULL) ==
				    NULL) {
					nxport-&gt;port = htons(tmp);
					<span class="enscript-keyword">return</span> (0);
				}
			}
		}

		<span class="enscript-keyword">switch</span> (r-&gt;rpool.opts &amp; PF_POOL_TYPEMASK) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_POOL_RANDOM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_POOL_ROUNDROBIN</span>:
			<span class="enscript-keyword">if</span> (pf_map_addr(af, r, saddr, naddr, &amp;init_addr, sn))
				<span class="enscript-keyword">return</span> (1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_POOL_NONE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_POOL_SRCHASH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_POOL_BITMASK</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (1);
		}
	} <span class="enscript-keyword">while</span> (!PF_AEQ(&amp;init_addr, naddr, af));

	<span class="enscript-keyword">return</span> (1);					<span class="enscript-comment">/* none available */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pf_rule *
<span class="enscript-function-name">pf_match_translation</span>(<span class="enscript-type">struct</span> pf_pdesc *pd, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off,
    <span class="enscript-type">int</span> direction, <span class="enscript-type">struct</span> pfi_kif *kif, <span class="enscript-type">struct</span> pf_addr *saddr,
    <span class="enscript-type">union</span> pf_state_xport *sxport, <span class="enscript-type">struct</span> pf_addr *daddr,
    <span class="enscript-type">union</span> pf_state_xport *dxport, <span class="enscript-type">int</span> rs_num)
{
	<span class="enscript-type">struct</span> pf_rule		*r, *rm = NULL;
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset = NULL;
	<span class="enscript-type">int</span>			 tag = -1;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		 rtableid = IFSCOPE_NONE;
	<span class="enscript-type">int</span>			 asd = 0;

	r = TAILQ_FIRST(pf_main_ruleset.rules[rs_num].active.ptr);
	<span class="enscript-keyword">while</span> (r &amp;&amp; rm == NULL) {
		<span class="enscript-type">struct</span> pf_rule_addr	*src = NULL, *dst = NULL;
		<span class="enscript-type">struct</span> pf_addr_wrap	*xdst = NULL;
		<span class="enscript-type">struct</span> pf_addr_wrap	*xsrc = NULL;
		<span class="enscript-type">union</span> pf_rule_xport	rdrxport;

		<span class="enscript-keyword">if</span> (r-&gt;action == PF_BINAT &amp;&amp; direction == PF_IN) {
			src = &amp;r-&gt;dst;
			<span class="enscript-keyword">if</span> (r-&gt;rpool.cur != NULL)
				xdst = &amp;r-&gt;rpool.cur-&gt;addr;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;action == PF_RDR &amp;&amp; direction == PF_OUT) {
			dst = &amp;r-&gt;src;
			src = &amp;r-&gt;dst;
			<span class="enscript-keyword">if</span> (r-&gt;rpool.cur != NULL) {
				rdrxport.range.op = PF_OP_EQ;
				rdrxport.range.port[0] =
				    htons(r-&gt;rpool.proxy_port[0]);
				xsrc = &amp;r-&gt;rpool.cur-&gt;addr;
			}
		} <span class="enscript-keyword">else</span> {
			src = &amp;r-&gt;src;
			dst = &amp;r-&gt;dst;
		}

		r-&gt;evaluations++;
		<span class="enscript-keyword">if</span> (pfi_kif_match(r-&gt;kif, kif) == r-&gt;ifnot)
			r = r-&gt;skip[PF_SKIP_IFP].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;direction &amp;&amp; r-&gt;direction != direction)
			r = r-&gt;skip[PF_SKIP_DIR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;af &amp;&amp; r-&gt;af != pd-&gt;af)
			r = r-&gt;skip[PF_SKIP_AF].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;proto &amp;&amp; r-&gt;proto != pd-&gt;proto)
			r = r-&gt;skip[PF_SKIP_PROTO].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (xsrc &amp;&amp; PF_MISMATCHAW(xsrc, saddr, pd-&gt;af, 0, NULL))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!xsrc &amp;&amp; PF_MISMATCHAW(&amp;src-&gt;addr, saddr, pd-&gt;af,
		    src-&gt;neg, kif))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (xsrc &amp;&amp; (!rdrxport.range.port[0] ||
		    !pf_match_xport(r-&gt;proto, r-&gt;proto_variant, &amp;rdrxport,
		    sxport)))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!xsrc &amp;&amp; !pf_match_xport(r-&gt;proto,
		    r-&gt;proto_variant, &amp;src-&gt;xport, sxport))
			r = r-&gt;skip[src == &amp;r-&gt;src ? PF_SKIP_SRC_PORT :
			    PF_SKIP_DST_PORT].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dst != NULL &amp;&amp;
		    PF_MISMATCHAW(&amp;dst-&gt;addr, daddr, pd-&gt;af, dst-&gt;neg, NULL))
			r = r-&gt;skip[PF_SKIP_DST_ADDR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (xdst != NULL &amp;&amp; PF_MISMATCHAW(xdst, daddr, pd-&gt;af,
		    0, NULL))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dst &amp;&amp; !pf_match_xport(r-&gt;proto, r-&gt;proto_variant,
		    &amp;dst-&gt;xport, dxport))
			r = r-&gt;skip[PF_SKIP_DST_PORT].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;match_tag &amp;&amp; !pf_match_tag(m, r, pd-&gt;pf_mtag, &amp;tag))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;os_fingerprint != PF_OSFP_ANY &amp;&amp; (pd-&gt;proto !=
		    IPPROTO_TCP || !pf_osfp_match(pf_osfp_fingerprint(pd, m,
		    off, pd-&gt;hdr.tcp), r-&gt;os_fingerprint)))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (r-&gt;tag)
				tag = r-&gt;tag;
			<span class="enscript-keyword">if</span> (PF_RTABLEID_IS_VALID(r-&gt;rtableid))
				rtableid = r-&gt;rtableid;
			<span class="enscript-keyword">if</span> (r-&gt;anchor == NULL) {
				rm = r;
			} <span class="enscript-keyword">else</span>
				pf_step_into_anchor(&amp;asd, &amp;ruleset, rs_num,
				    &amp;r, NULL, NULL);
		}
		<span class="enscript-keyword">if</span> (r == NULL)
			pf_step_out_of_anchor(&amp;asd, &amp;ruleset, rs_num, &amp;r,
			    NULL, NULL);
	}
	<span class="enscript-keyword">if</span> (pf_tag_packet(m, pd-&gt;pf_mtag, tag, rtableid, NULL))
		<span class="enscript-keyword">return</span> (NULL);
	<span class="enscript-keyword">if</span> (rm != NULL &amp;&amp; (rm-&gt;action == PF_NONAT ||
	    rm-&gt;action == PF_NORDR || rm-&gt;action == PF_NOBINAT ||
	    rm-&gt;action == PF_NONAT64))
		<span class="enscript-keyword">return</span> (NULL);
	<span class="enscript-keyword">return</span> (rm);
}

<span class="enscript-comment">/* 
 * Get address translation information for NAT/BINAT/RDR
 * pd		: pf packet descriptor
 * m		: mbuf holding the packet
 * off		: offset to protocol header
 * direction	: direction of packet
 * kif		: pf interface info obtained from the packet's recv interface
 * sn		: source node pointer (output)
 * saddr	: packet source address
 * sxport	: packet source port
 * daddr	: packet destination address
 * dxport	: packet destination port
 * nsxport	: translated source port (output)
 *
 * Translated source &amp; destination address are updated in pd-&gt;nsaddr &amp;
 * pd-&gt;ndaddr
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pf_rule *
<span class="enscript-function-name">pf_get_translation_aux</span>(<span class="enscript-type">struct</span> pf_pdesc *pd, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off,
    <span class="enscript-type">int</span> direction, <span class="enscript-type">struct</span> pfi_kif *kif, <span class="enscript-type">struct</span> pf_src_node **sn,
    <span class="enscript-type">struct</span> pf_addr *saddr, <span class="enscript-type">union</span> pf_state_xport *sxport, <span class="enscript-type">struct</span> pf_addr *daddr,
    <span class="enscript-type">union</span> pf_state_xport *dxport, <span class="enscript-type">union</span> pf_state_xport *nsxport)
{
	<span class="enscript-type">struct</span> pf_rule	*r = NULL;
	pd-&gt;naf = pd-&gt;af;

	<span class="enscript-keyword">if</span> (direction == PF_OUT) {
		r = pf_match_translation(pd, m, off, direction, kif, saddr,
		    sxport, daddr, dxport, PF_RULESET_BINAT);
		<span class="enscript-keyword">if</span> (r == NULL)
			r = pf_match_translation(pd, m, off, direction, kif,
			    saddr, sxport, daddr, dxport, PF_RULESET_RDR);
		<span class="enscript-keyword">if</span> (r == NULL)
			r = pf_match_translation(pd, m, off, direction, kif,
			    saddr, sxport, daddr, dxport, PF_RULESET_NAT);
	} <span class="enscript-keyword">else</span> {
		r = pf_match_translation(pd, m, off, direction, kif, saddr,
		    sxport, daddr, dxport, PF_RULESET_RDR);
		<span class="enscript-keyword">if</span> (r == NULL)
			r = pf_match_translation(pd, m, off, direction, kif,
			    saddr, sxport, daddr, dxport, PF_RULESET_BINAT);
	}

	<span class="enscript-keyword">if</span> (r != NULL) {
		<span class="enscript-type">struct</span> pf_addr *nsaddr = &amp;pd-&gt;naddr;
		<span class="enscript-type">struct</span> pf_addr *ndaddr = &amp;pd-&gt;ndaddr;

		*nsaddr = *saddr;
		*ndaddr = *daddr;

		<span class="enscript-keyword">switch</span> (r-&gt;action) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NONAT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NONAT64</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NOBINAT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NORDR</span>:
			<span class="enscript-keyword">return</span> (NULL);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NAT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_NAT64</span>:
			<span class="enscript-comment">/*
			 * we do NAT64 on incoming path and we call ip_input
			 * which asserts receive interface to be not NULL.
			 * The below check is to prevent NAT64 action on any
			 * packet generated by local entity using synthesized
			 * IPv6 address.
			 */</span>
			<span class="enscript-keyword">if</span> ((r-&gt;action == PF_NAT64) &amp;&amp; (direction == PF_OUT))
				<span class="enscript-keyword">return</span> (NULL);

			<span class="enscript-keyword">if</span> (pf_get_sport(pd, kif, r, saddr, sxport, daddr,
			    dxport, nsaddr, nsxport, sn)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    (<span class="enscript-string">&quot;pf: NAT proxy port allocation &quot;</span>
				    <span class="enscript-string">&quot;(%u-%u) failed\n&quot;</span>,
				    r-&gt;rpool.proxy_port[0],
				    r-&gt;rpool.proxy_port[1]));
				<span class="enscript-keyword">return</span> (NULL);
			}
			<span class="enscript-comment">/*
			 * For NAT64 the destination IPv4 address is derived
			 * from the last 32 bits of synthesized IPv6 address
			 */</span>
			<span class="enscript-keyword">if</span> (r-&gt;action == PF_NAT64) {
				ndaddr-&gt;v4.s_addr = daddr-&gt;addr32[3];
				pd-&gt;naf = AF_INET;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_BINAT</span>:
			<span class="enscript-keyword">switch</span> (direction) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OUT</span>:
				<span class="enscript-keyword">if</span> (r-&gt;rpool.cur-&gt;addr.type ==
				    PF_ADDR_DYNIFTL) {
					<span class="enscript-keyword">if</span> (r-&gt;rpool.cur-&gt;addr.p.dyn == NULL)
						<span class="enscript-keyword">return</span> (NULL);
					<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
						<span class="enscript-keyword">if</span> (r-&gt;rpool.cur-&gt;addr.p.dyn-&gt;
						    pfid_acnt4 &lt; 1)
							<span class="enscript-keyword">return</span> (NULL);
						PF_POOLMASK(nsaddr,
						    &amp;r-&gt;rpool.cur-&gt;addr.p.dyn-&gt;
						    pfid_addr4,
						    &amp;r-&gt;rpool.cur-&gt;addr.p.dyn-&gt;
						    pfid_mask4,
						    saddr, AF_INET);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
						<span class="enscript-keyword">if</span> (r-&gt;rpool.cur-&gt;addr.p.dyn-&gt;
						    pfid_acnt6 &lt; 1)
							<span class="enscript-keyword">return</span> (NULL);
						PF_POOLMASK(nsaddr,
						    &amp;r-&gt;rpool.cur-&gt;addr.p.dyn-&gt;
						    pfid_addr6,
						    &amp;r-&gt;rpool.cur-&gt;addr.p.dyn-&gt;
						    pfid_mask6,
						    saddr, AF_INET6);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					}
				} <span class="enscript-keyword">else</span> {
					PF_POOLMASK(nsaddr,
					    &amp;r-&gt;rpool.cur-&gt;addr.v.a.addr,
					    &amp;r-&gt;rpool.cur-&gt;addr.v.a.mask,
					    saddr, pd-&gt;af);
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_IN</span>:
				<span class="enscript-keyword">if</span> (r-&gt;src.addr.type == PF_ADDR_DYNIFTL) {
					<span class="enscript-keyword">if</span> (r-&gt;src.addr.p.dyn == NULL)
						<span class="enscript-keyword">return</span> (NULL);
					<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
						<span class="enscript-keyword">if</span> (r-&gt;src.addr.p.dyn-&gt;
						    pfid_acnt4 &lt; 1)
							<span class="enscript-keyword">return</span> (NULL);
						PF_POOLMASK(ndaddr,
						    &amp;r-&gt;src.addr.p.dyn-&gt;
						    pfid_addr4,
						    &amp;r-&gt;src.addr.p.dyn-&gt;
						    pfid_mask4,
						    daddr, AF_INET);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
						<span class="enscript-keyword">if</span> (r-&gt;src.addr.p.dyn-&gt;
						    pfid_acnt6 &lt; 1)
							<span class="enscript-keyword">return</span> (NULL);
						PF_POOLMASK(ndaddr,
						    &amp;r-&gt;src.addr.p.dyn-&gt;
						    pfid_addr6,
						    &amp;r-&gt;src.addr.p.dyn-&gt;
						    pfid_mask6,
						    daddr, AF_INET6);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					}
				} <span class="enscript-keyword">else</span>
					PF_POOLMASK(ndaddr,
					    &amp;r-&gt;src.addr.v.a.addr,
					    &amp;r-&gt;src.addr.v.a.mask, daddr,
					    pd-&gt;af);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_RDR</span>: {
			<span class="enscript-keyword">switch</span> (direction) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OUT</span>:
				<span class="enscript-keyword">if</span> (r-&gt;dst.addr.type == PF_ADDR_DYNIFTL) {
					<span class="enscript-keyword">if</span> (r-&gt;dst.addr.p.dyn == NULL)
						<span class="enscript-keyword">return</span> (NULL);
					<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
						<span class="enscript-keyword">if</span> (r-&gt;dst.addr.p.dyn-&gt;
						    pfid_acnt4 &lt; 1)
							<span class="enscript-keyword">return</span> (NULL);
						PF_POOLMASK(nsaddr,
						    &amp;r-&gt;dst.addr.p.dyn-&gt;
						    pfid_addr4,
						    &amp;r-&gt;dst.addr.p.dyn-&gt;
						    pfid_mask4,
						    daddr, AF_INET);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
						<span class="enscript-keyword">if</span> (r-&gt;dst.addr.p.dyn-&gt;
						    pfid_acnt6 &lt; 1)
							<span class="enscript-keyword">return</span> (NULL);
						PF_POOLMASK(nsaddr,
						    &amp;r-&gt;dst.addr.p.dyn-&gt;
						    pfid_addr6,
						    &amp;r-&gt;dst.addr.p.dyn-&gt;
						    pfid_mask6,
						    daddr, AF_INET6);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					}
				} <span class="enscript-keyword">else</span> {
					PF_POOLMASK(nsaddr,
					    &amp;r-&gt;dst.addr.v.a.addr,
					    &amp;r-&gt;dst.addr.v.a.mask,
					    daddr, pd-&gt;af);
				}
				<span class="enscript-keyword">if</span> (nsxport &amp;&amp; r-&gt;dst.xport.range.port[0])
					nsxport-&gt;port =
					    r-&gt;dst.xport.range.port[0];
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_IN</span>:
				<span class="enscript-keyword">if</span> (pf_map_addr(pd-&gt;af, r, saddr,
				    ndaddr, NULL, sn))
					<span class="enscript-keyword">return</span> (NULL);
				<span class="enscript-keyword">if</span> ((r-&gt;rpool.opts &amp; PF_POOL_TYPEMASK) ==
				    PF_POOL_BITMASK)
					PF_POOLMASK(ndaddr, ndaddr,
					    &amp;r-&gt;rpool.cur-&gt;addr.v.a.mask, daddr,
					    pd-&gt;af);

				<span class="enscript-keyword">if</span> (nsxport &amp;&amp; dxport) {
					<span class="enscript-keyword">if</span> (r-&gt;rpool.proxy_port[1]) {
						u_int32_t	tmp_nport;

						tmp_nport =
						    ((ntohs(dxport-&gt;port) -
						    ntohs(r-&gt;dst.xport.range.
						    port[0])) %
						    (r-&gt;rpool.proxy_port[1] -
						    r-&gt;rpool.proxy_port[0] +
						    1)) + r-&gt;rpool.proxy_port[0];

						<span class="enscript-comment">/* wrap around if necessary */</span>
						<span class="enscript-keyword">if</span> (tmp_nport &gt; 65535)
							tmp_nport -= 65535;
						nsxport-&gt;port =
						    htons((u_int16_t)tmp_nport);
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;rpool.proxy_port[0]) {
						nsxport-&gt;port = htons(r-&gt;rpool.
						    proxy_port[0]);
					}
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (NULL);
		}
	}

	<span class="enscript-keyword">return</span> (r);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_socket_lookup</span>(<span class="enscript-type">int</span> direction, <span class="enscript-type">struct</span> pf_pdesc *pd)
{
	<span class="enscript-type">struct</span> pf_addr		*saddr, *daddr;
	u_int16_t		 sport, dport;
	<span class="enscript-type">struct</span> inpcbinfo	*pi; 
	<span class="enscript-type">int</span> 			inp = 0;

	<span class="enscript-keyword">if</span> (pd == NULL)
		<span class="enscript-keyword">return</span> (-1);
	pd-&gt;lookup.uid = UID_MAX;
	pd-&gt;lookup.gid = GID_MAX;
	pd-&gt;lookup.pid = NO_PID;

	<span class="enscript-keyword">switch</span> (pd-&gt;proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		<span class="enscript-keyword">if</span> (pd-&gt;hdr.tcp == NULL)
			<span class="enscript-keyword">return</span> (-1);
		sport = pd-&gt;hdr.tcp-&gt;th_sport;
		dport = pd-&gt;hdr.tcp-&gt;th_dport;
		pi = &amp;tcbinfo;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		<span class="enscript-keyword">if</span> (pd-&gt;hdr.udp == NULL)
			<span class="enscript-keyword">return</span> (-1);
		sport = pd-&gt;hdr.udp-&gt;uh_sport;
		dport = pd-&gt;hdr.udp-&gt;uh_dport;
		pi = &amp;udbinfo;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (-1);
	}
	<span class="enscript-keyword">if</span> (direction == PF_IN) {
		saddr = pd-&gt;src;
		daddr = pd-&gt;dst;
	} <span class="enscript-keyword">else</span> {
		u_int16_t	p;

		p = sport;
		sport = dport;
		dport = p;
		saddr = pd-&gt;dst;
		daddr = pd-&gt;src;
	}
	<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		inp = in_pcblookup_hash_exists(pi, saddr-&gt;v4, sport, daddr-&gt;v4, dport,
		    0, &amp;pd-&gt;lookup.uid, &amp;pd-&gt;lookup.gid, NULL);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (inp == 0) {
			<span class="enscript-type">struct</span> in6_addr s6, d6;

			memset(&amp;s6, 0, <span class="enscript-keyword">sizeof</span> (s6));
			s6.s6_addr16[5] = htons(0xffff);
			memcpy(&amp;s6.s6_addr32[3], &amp;saddr-&gt;v4,
			    <span class="enscript-keyword">sizeof</span> (saddr-&gt;v4));

			memset(&amp;d6, 0, <span class="enscript-keyword">sizeof</span> (d6));
			d6.s6_addr16[5] = htons(0xffff);
			memcpy(&amp;d6.s6_addr32[3], &amp;daddr-&gt;v4,
			    <span class="enscript-keyword">sizeof</span> (daddr-&gt;v4));

			inp = in6_pcblookup_hash_exists(pi, &amp;s6, sport,
			    &amp;d6, dport, 0, &amp;pd-&gt;lookup.uid, &amp;pd-&gt;lookup.gid, NULL);
			<span class="enscript-keyword">if</span> (inp == 0) {
				inp = in_pcblookup_hash_exists(pi, saddr-&gt;v4, sport,
				    daddr-&gt;v4, dport, INPLOOKUP_WILDCARD, &amp;pd-&gt;lookup.uid, &amp;pd-&gt;lookup.gid, NULL);
				<span class="enscript-keyword">if</span> (inp == 0) {
					inp = in6_pcblookup_hash_exists(pi, &amp;s6, sport,
					    &amp;d6, dport, INPLOOKUP_WILDCARD,
					    &amp;pd-&gt;lookup.uid, &amp;pd-&gt;lookup.gid, NULL);
					<span class="enscript-keyword">if</span> (inp == 0)
						<span class="enscript-keyword">return</span> (-1);
				}
			}
		}
#<span class="enscript-reference">else</span>
		<span class="enscript-keyword">if</span> (inp == 0) {
			inp = in_pcblookup_hash_exists(pi, saddr-&gt;v4, sport,
			    daddr-&gt;v4, dport, INPLOOKUP_WILDCARD, 
			    &amp;pd-&gt;lookup.uid, &amp;pd-&gt;lookup.gid, NULL);
			<span class="enscript-keyword">if</span> (inp == 0)
				<span class="enscript-keyword">return</span> (-1);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		inp = in6_pcblookup_hash_exists(pi, &amp;saddr-&gt;v6, sport, &amp;daddr-&gt;v6,
		    dport, 0, &amp;pd-&gt;lookup.uid, &amp;pd-&gt;lookup.gid, NULL);
		<span class="enscript-keyword">if</span> (inp == 0) {
			inp = in6_pcblookup_hash_exists(pi, &amp;saddr-&gt;v6, sport,
			    &amp;daddr-&gt;v6, dport, INPLOOKUP_WILDCARD,
			    &amp;pd-&gt;lookup.uid, &amp;pd-&gt;lookup.gid, NULL);
			<span class="enscript-keyword">if</span> (inp == 0)
				<span class="enscript-keyword">return</span> (-1);
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
                            
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-type">static</span> u_int8_t
<span class="enscript-function-name">pf_get_wscale</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, u_int16_t th_off, sa_family_t af)
{
	<span class="enscript-type">int</span>		 hlen;
	u_int8_t	 hdr[60];
	u_int8_t	*opt, optlen;
	u_int8_t	 wscale = 0;

	hlen = th_off &lt;&lt; 2;		<span class="enscript-comment">/* hlen &lt;= sizeof (hdr) */</span>
	<span class="enscript-keyword">if</span> (hlen &lt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr))
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, hdr, hlen, NULL, NULL, af))
		<span class="enscript-keyword">return</span> (0);
	opt = hdr + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
	hlen -= <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
	<span class="enscript-keyword">while</span> (hlen &gt;= 3) {
		<span class="enscript-keyword">switch</span> (*opt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_EOL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_NOP</span>:
			++opt;
			--hlen;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_WINDOW</span>:
			wscale = opt[2];
			<span class="enscript-keyword">if</span> (wscale &gt; TCP_MAX_WINSHIFT)
				wscale = TCP_MAX_WINSHIFT;
			wscale |= PF_WSCALE_FLAG;
			<span class="enscript-comment">/* FALLTHROUGH */</span>
		<span class="enscript-reference">default</span>:
			optlen = opt[1];
			<span class="enscript-keyword">if</span> (optlen &lt; 2)
				optlen = 2;
			hlen -= optlen;
			opt += optlen;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> (wscale);
}

<span class="enscript-type">static</span> u_int16_t
<span class="enscript-function-name">pf_get_mss</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, u_int16_t th_off, sa_family_t af)
{
	<span class="enscript-type">int</span>		 hlen;
	u_int8_t	 hdr[60];
	u_int8_t	*opt, optlen;
	u_int16_t	 mss = tcp_mssdflt;

	hlen = th_off &lt;&lt; 2;	<span class="enscript-comment">/* hlen &lt;= sizeof (hdr) */</span>
	<span class="enscript-keyword">if</span> (hlen &lt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr))
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, hdr, hlen, NULL, NULL, af))
		<span class="enscript-keyword">return</span> (0);
	opt = hdr + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
	hlen -= <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
	<span class="enscript-keyword">while</span> (hlen &gt;= TCPOLEN_MAXSEG) {
		<span class="enscript-keyword">switch</span> (*opt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_EOL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_NOP</span>:
			++opt;
			--hlen;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_MAXSEG</span>:
			bcopy((caddr_t)(opt + 2), (caddr_t)&amp;mss, 2);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
			NTOHS(mss);
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/* FALLTHROUGH */</span>
		<span class="enscript-reference">default</span>:
			optlen = opt[1];
			<span class="enscript-keyword">if</span> (optlen &lt; 2)
				optlen = 2;
			hlen -= optlen;
			opt += optlen;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> (mss);
}

<span class="enscript-type">static</span> u_int16_t
<span class="enscript-function-name">pf_calc_mss</span>(<span class="enscript-type">struct</span> pf_addr *addr, sa_family_t af, u_int16_t offer)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-type">struct</span> sockaddr_in	*dst;
	<span class="enscript-type">struct</span> route		 ro;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> sockaddr_in6	*dst6;
	<span class="enscript-type">struct</span> route_in6	 ro6;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-type">struct</span> rtentry		*rt = NULL;
	<span class="enscript-type">int</span>			 hlen;
	u_int16_t		 mss = tcp_mssdflt;

	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		hlen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
		bzero(&amp;ro, <span class="enscript-keyword">sizeof</span> (ro));
		dst = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;ro.ro_dst;
		dst-&gt;sin_family = AF_INET;
		dst-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*dst);
		dst-&gt;sin_addr = addr-&gt;v4;
		rtalloc(&amp;ro);
		rt = ro.ro_rt;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		hlen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr);
		bzero(&amp;ro6, <span class="enscript-keyword">sizeof</span> (ro6));
		dst6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)&amp;ro6.ro_dst;
		dst6-&gt;sin6_family = AF_INET6;
		dst6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> (*dst6);
		dst6-&gt;sin6_addr = addr-&gt;v6;
		rtalloc((<span class="enscript-type">struct</span> route *)&amp;ro);
		rt = ro6.ro_rt;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;pf_calc_mss: not AF_INET or AF_INET6!&quot;</span>);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (rt &amp;&amp; rt-&gt;rt_ifp) {
		mss = rt-&gt;rt_ifp-&gt;if_mtu - hlen - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
		mss = max(tcp_mssdflt, mss);
		rtfree(rt);
	}
	mss = min(mss, offer);
	mss = max(mss, 64);		<span class="enscript-comment">/* sanity - at least max opt space */</span>
	<span class="enscript-keyword">return</span> (mss);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_set_rt_ifp</span>(<span class="enscript-type">struct</span> pf_state *s, <span class="enscript-type">struct</span> pf_addr *saddr, sa_family_t af)
{
	<span class="enscript-type">struct</span> pf_rule *r = s-&gt;rule.ptr;

	s-&gt;rt_kif = NULL;

	<span class="enscript-keyword">if</span> (!r-&gt;rt || r-&gt;rt == PF_FASTROUTE)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> ((af == AF_INET) || (af == AF_INET6)) {
		pf_map_addr(af, r, saddr, &amp;s-&gt;rt_addr, NULL,
		    &amp;s-&gt;nat_src_node);
		s-&gt;rt_kif = r-&gt;rpool.cur-&gt;kif;
	}

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_attach_state</span>(<span class="enscript-type">struct</span> pf_state_key *sk, <span class="enscript-type">struct</span> pf_state *s, <span class="enscript-type">int</span> tail)
{
	s-&gt;state_key = sk;
	sk-&gt;refcnt++;

	<span class="enscript-comment">/* list is sorted, if-bound states before floating */</span>
	<span class="enscript-keyword">if</span> (tail)
		TAILQ_INSERT_TAIL(&amp;sk-&gt;states, s, next);
	<span class="enscript-keyword">else</span>
		TAILQ_INSERT_HEAD(&amp;sk-&gt;states, s, next);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_detach_state</span>(<span class="enscript-type">struct</span> pf_state *s, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> pf_state_key	*sk = s-&gt;state_key;

	<span class="enscript-keyword">if</span> (sk == NULL)
		<span class="enscript-keyword">return</span>;

	s-&gt;state_key = NULL;
	TAILQ_REMOVE(&amp;sk-&gt;states, s, next);
	<span class="enscript-keyword">if</span> (--sk-&gt;refcnt == 0) {
		<span class="enscript-keyword">if</span> (!(flags &amp; PF_DT_SKIP_EXTGWY))
			RB_REMOVE(pf_state_tree_ext_gwy,
			    &amp;pf_statetbl_ext_gwy, sk);
		<span class="enscript-keyword">if</span> (!(flags &amp; PF_DT_SKIP_LANEXT))
			RB_REMOVE(pf_state_tree_lan_ext,
			    &amp;pf_statetbl_lan_ext, sk);
		<span class="enscript-keyword">if</span> (sk-&gt;app_state)
			pool_put(&amp;pf_app_state_pl, sk-&gt;app_state);
		pool_put(&amp;pf_state_key_pl, sk);
	}
}

<span class="enscript-type">struct</span> pf_state_key *
<span class="enscript-function-name">pf_alloc_state_key</span>(<span class="enscript-type">struct</span> pf_state *s, <span class="enscript-type">struct</span> pf_state_key *psk)
{
	<span class="enscript-type">struct</span> pf_state_key	*sk;

	<span class="enscript-keyword">if</span> ((sk = pool_get(&amp;pf_state_key_pl, PR_WAITOK)) == NULL)
		<span class="enscript-keyword">return</span> (NULL);
	bzero(sk, <span class="enscript-keyword">sizeof</span> (*sk));
	TAILQ_INIT(&amp;sk-&gt;states);
	pf_attach_state(sk, s, 0);

	<span class="enscript-comment">/* initialize state key from psk, if provided */</span>
	<span class="enscript-keyword">if</span> (psk != NULL) {
		bcopy(&amp;psk-&gt;lan, &amp;sk-&gt;lan, <span class="enscript-keyword">sizeof</span> (sk-&gt;lan));
		bcopy(&amp;psk-&gt;gwy, &amp;sk-&gt;gwy, <span class="enscript-keyword">sizeof</span> (sk-&gt;gwy));
		bcopy(&amp;psk-&gt;ext_lan, &amp;sk-&gt;ext_lan, <span class="enscript-keyword">sizeof</span> (sk-&gt;ext_lan));
		bcopy(&amp;psk-&gt;ext_gwy, &amp;sk-&gt;ext_gwy, <span class="enscript-keyword">sizeof</span> (sk-&gt;ext_gwy));
		sk-&gt;af_lan = psk-&gt;af_lan;
		sk-&gt;af_gwy = psk-&gt;af_gwy;
		sk-&gt;proto = psk-&gt;proto;
		sk-&gt;direction = psk-&gt;direction;
		sk-&gt;proto_variant = psk-&gt;proto_variant;
		VERIFY(psk-&gt;app_state == NULL);
		sk-&gt;flowsrc = psk-&gt;flowsrc;
		sk-&gt;flowhash = psk-&gt;flowhash;
		<span class="enscript-comment">/* don't touch tree entries, states and refcnt on sk */</span>
	}

	<span class="enscript-keyword">return</span> (sk);
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">pf_tcp_iss</span>(<span class="enscript-type">struct</span> pf_pdesc *pd)
{
	MD5_CTX ctx;
	u_int32_t digest[4];

	<span class="enscript-keyword">if</span> (pf_tcp_secret_init == 0) {
		read_random(pf_tcp_secret, <span class="enscript-keyword">sizeof</span> (pf_tcp_secret));
		MD5Init(&amp;pf_tcp_secret_ctx);
		MD5Update(&amp;pf_tcp_secret_ctx, pf_tcp_secret,
		    <span class="enscript-keyword">sizeof</span> (pf_tcp_secret));
		pf_tcp_secret_init = 1;
	}
	ctx = pf_tcp_secret_ctx;

	MD5Update(&amp;ctx, (<span class="enscript-type">char</span> *)&amp;pd-&gt;hdr.tcp-&gt;th_sport, <span class="enscript-keyword">sizeof</span> (u_short));
	MD5Update(&amp;ctx, (<span class="enscript-type">char</span> *)&amp;pd-&gt;hdr.tcp-&gt;th_dport, <span class="enscript-keyword">sizeof</span> (u_short));
	<span class="enscript-keyword">if</span> (pd-&gt;af == AF_INET6) {
		MD5Update(&amp;ctx, (<span class="enscript-type">char</span> *)&amp;pd-&gt;src-&gt;v6, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));
		MD5Update(&amp;ctx, (<span class="enscript-type">char</span> *)&amp;pd-&gt;dst-&gt;v6, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));
	} <span class="enscript-keyword">else</span> {
		MD5Update(&amp;ctx, (<span class="enscript-type">char</span> *)&amp;pd-&gt;src-&gt;v4, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr));
		MD5Update(&amp;ctx, (<span class="enscript-type">char</span> *)&amp;pd-&gt;dst-&gt;v4, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr));
	}
	MD5Final((u_char *)digest, &amp;ctx);
	pf_tcp_iss_off += 4096;
	<span class="enscript-keyword">return</span> (digest[0] + random() + pf_tcp_iss_off);
}

<span class="enscript-comment">/*
 * This routine is called to perform address family translation on the
 * inner IP header (that may come as payload) of an ICMP(v4/6) error
 * response.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_change_icmp_af</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off,
	<span class="enscript-type">struct</span> pf_pdesc *pd, <span class="enscript-type">struct</span> pf_pdesc *pd2, <span class="enscript-type">struct</span> pf_addr *src,
	<span class="enscript-type">struct</span> pf_addr *dst, sa_family_t af, sa_family_t naf)
{
	<span class="enscript-type">struct</span> mbuf		*n = NULL;
	<span class="enscript-type">struct</span> ip		*ip4 = NULL;
	<span class="enscript-type">struct</span> ip6_hdr		*ip6 = NULL;
	<span class="enscript-type">int</span>			 hlen, olen, mlen;

	<span class="enscript-keyword">if</span> (af == naf || (af != AF_INET &amp;&amp; af != AF_INET6) ||
	    (naf != AF_INET &amp;&amp; naf != AF_INET6))
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-comment">/* split the mbuf chain on the inner ip/ip6 header boundary */</span>
	<span class="enscript-keyword">if</span> ((n = m_split(m, off, M_DONTWAIT)) == NULL)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-comment">/* old header */</span>
	olen = pd2-&gt;off - off;
	<span class="enscript-comment">/* new header */</span>
	hlen = naf == AF_INET ? <span class="enscript-keyword">sizeof</span>(*ip4) : <span class="enscript-keyword">sizeof</span>(*ip6);

	<span class="enscript-comment">/* trim old header */</span>
	m_adj(n, olen);

	<span class="enscript-comment">/* prepend a new one */</span>
	<span class="enscript-keyword">if</span> (M_PREPEND(n, hlen, M_DONTWAIT, 0) == NULL)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-comment">/* translate inner ip/ip6 header */</span>
	<span class="enscript-keyword">switch</span> (naf) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		ip4 = mtod(n, <span class="enscript-type">struct</span> ip *);
		bzero(ip4, <span class="enscript-keyword">sizeof</span>(*ip4));
		ip4-&gt;ip_v   = IPVERSION;
		ip4-&gt;ip_hl  = <span class="enscript-keyword">sizeof</span>(*ip4) &gt;&gt; 2;
		ip4-&gt;ip_len = htons(<span class="enscript-keyword">sizeof</span>(*ip4) + pd2-&gt;tot_len - olen);
		ip4-&gt;ip_id  = htons(ip_randomid());
		ip4-&gt;ip_off = htons(IP_DF);
		ip4-&gt;ip_ttl = pd2-&gt;ttl;
		<span class="enscript-keyword">if</span> (pd2-&gt;proto == IPPROTO_ICMPV6)
			ip4-&gt;ip_p = IPPROTO_ICMP;
		<span class="enscript-keyword">else</span>
			ip4-&gt;ip_p = pd2-&gt;proto;
		ip4-&gt;ip_src = src-&gt;v4;
		ip4-&gt;ip_dst = dst-&gt;v4;
		ip4-&gt;ip_sum = in_cksum(n, ip4-&gt;ip_hl &lt;&lt; 2);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		ip6 = mtod(n, <span class="enscript-type">struct</span> ip6_hdr *);
		bzero(ip6, <span class="enscript-keyword">sizeof</span>(*ip6));
		ip6-&gt;ip6_vfc  = IPV6_VERSION;
		ip6-&gt;ip6_plen = htons(pd2-&gt;tot_len - olen);
		<span class="enscript-keyword">if</span> (pd2-&gt;proto == IPPROTO_ICMP)
			ip6-&gt;ip6_nxt = IPPROTO_ICMPV6;
		<span class="enscript-keyword">else</span>
			ip6-&gt;ip6_nxt = pd2-&gt;proto;
		<span class="enscript-keyword">if</span> (!pd2-&gt;ttl || pd2-&gt;ttl &gt; IPV6_DEFHLIM)
			ip6-&gt;ip6_hlim = IPV6_DEFHLIM;
		<span class="enscript-keyword">else</span>
			ip6-&gt;ip6_hlim = pd2-&gt;ttl;
		ip6-&gt;ip6_src  = src-&gt;v6;
		ip6-&gt;ip6_dst  = dst-&gt;v6;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* adjust payload offset and total packet length */</span>
	pd2-&gt;off += hlen - olen;
	pd-&gt;tot_len += hlen - olen;

	<span class="enscript-comment">/* merge modified inner packet with the original header */</span>
	mlen = n-&gt;m_pkthdr.len;
	m_cat(m, n);
	m-&gt;m_pkthdr.len += mlen;

	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PTR_IP</span>(field)	((int32_t)offsetof(struct ip, field))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PTR_IP6</span>(field)	((int32_t)offsetof(struct ip6_hdr, field))

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_translate_icmp_af</span>(<span class="enscript-type">int</span> af, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> icmp		*icmp4;
	<span class="enscript-type">struct</span> icmp6_hdr	*icmp6;
	u_int32_t		 mtu;
	int32_t			 ptr = -1;
	u_int8_t		 type;
	u_int8_t		 code;

	<span class="enscript-keyword">switch</span> (af) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		icmp6 = arg;
		type  = icmp6-&gt;icmp6_type;
		code  = icmp6-&gt;icmp6_code;
		mtu   = ntohl(icmp6-&gt;icmp6_mtu);

		<span class="enscript-keyword">switch</span> (type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_ECHO_REQUEST</span>:
			type = ICMP_ECHO;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_ECHO_REPLY</span>:
			type = ICMP_ECHOREPLY;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH</span>:
			type = ICMP_UNREACH;
			<span class="enscript-keyword">switch</span> (code) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_NOROUTE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_BEYONDSCOPE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_ADDR</span>:
				code = ICMP_UNREACH_HOST;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_ADMIN</span>:
				code = ICMP_UNREACH_HOST_PROHIB;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_NOPORT</span>:
				code = ICMP_UNREACH_PORT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">return</span> (-1);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PACKET_TOO_BIG</span>:
			type = ICMP_UNREACH;
			code = ICMP_UNREACH_NEEDFRAG;
			mtu -= 20;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_TIME_EXCEEDED</span>:
			type = ICMP_TIMXCEED;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PARAM_PROB</span>:
			<span class="enscript-keyword">switch</span> (code) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PARAMPROB_HEADER</span>:
				type = ICMP_PARAMPROB;
				code = ICMP_PARAMPROB_ERRATPTR;
				ptr  = ntohl(icmp6-&gt;icmp6_pptr);

				<span class="enscript-keyword">if</span> (ptr == PTR_IP6(ip6_vfc))
					; <span class="enscript-comment">/* preserve */</span>
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ptr == PTR_IP6(ip6_vfc) + 1)
					ptr = PTR_IP(ip_tos);
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ptr == PTR_IP6(ip6_plen) ||
				    ptr == PTR_IP6(ip6_plen) + 1)
					ptr = PTR_IP(ip_len);
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ptr == PTR_IP6(ip6_nxt))
					ptr = PTR_IP(ip_p);
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ptr == PTR_IP6(ip6_hlim))
					ptr = PTR_IP(ip_ttl);
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ptr &gt;= PTR_IP6(ip6_src) &amp;&amp;
				    ptr &lt; PTR_IP6(ip6_dst))
					ptr = PTR_IP(ip_src);
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ptr &gt;= PTR_IP6(ip6_dst) &amp;&amp;
				    ptr &lt; (int32_t)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr))
					ptr = PTR_IP(ip_dst);
				<span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">return</span> (-1);
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PARAMPROB_NEXTHEADER</span>:
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_PROTOCOL;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">return</span> (-1);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (-1);
		}
		icmp6-&gt;icmp6_type = type;
		icmp6-&gt;icmp6_code = code;
		<span class="enscript-comment">/* aligns well with a icmpv4 nextmtu */</span>
		icmp6-&gt;icmp6_mtu = htonl(mtu);
		<span class="enscript-comment">/* icmpv4 pptr is a one most significant byte */</span>
		<span class="enscript-keyword">if</span> (ptr &gt;= 0)
			icmp6-&gt;icmp6_pptr = htonl(ptr &lt;&lt; 24);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		icmp4 = arg;
		type  = icmp4-&gt;icmp_type;
		code  = icmp4-&gt;icmp_code;
		mtu   = ntohs(icmp4-&gt;icmp_nextmtu);

		<span class="enscript-keyword">switch</span> (type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_ECHO</span>:
			type = ICMP6_ECHO_REQUEST;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_ECHOREPLY</span>:
			type = ICMP6_ECHO_REPLY;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH</span>:
			type = ICMP6_DST_UNREACH;
			<span class="enscript-keyword">switch</span> (code) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_NET</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_HOST</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_NET_UNKNOWN</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_HOST_UNKNOWN</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_ISOLATED</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_TOSNET</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_TOSHOST</span>:
				code = ICMP6_DST_UNREACH_NOROUTE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_PORT</span>:
				code = ICMP6_DST_UNREACH_NOPORT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_NET_PROHIB</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_HOST_PROHIB</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_FILTER_PROHIB</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_PRECEDENCE_CUTOFF</span>:
				code = ICMP6_DST_UNREACH_ADMIN;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_PROTOCOL</span>:
				type = ICMP6_PARAM_PROB;
				code = ICMP6_PARAMPROB_NEXTHEADER;
				ptr  = offsetof(<span class="enscript-type">struct</span> ip6_hdr, ip6_nxt);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_UNREACH_NEEDFRAG</span>:
				type = ICMP6_PACKET_TOO_BIG;
				code = 0;
				mtu += 20;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">return</span> (-1);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_TIMXCEED</span>:
			type = ICMP6_TIME_EXCEEDED;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_PARAMPROB</span>:
			type = ICMP6_PARAM_PROB;
			<span class="enscript-keyword">switch</span> (code) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_PARAMPROB_ERRATPTR</span>:
				code = ICMP6_PARAMPROB_HEADER;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP_PARAMPROB_LENGTH</span>:
				code = ICMP6_PARAMPROB_HEADER;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">return</span> (-1);
			}

			ptr = icmp4-&gt;icmp_pptr;
			<span class="enscript-keyword">if</span> (ptr == 0 || ptr == PTR_IP(ip_tos))
				; <span class="enscript-comment">/* preserve */</span>
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ptr == PTR_IP(ip_len) ||
			    ptr == PTR_IP(ip_len) + 1)
				ptr = PTR_IP6(ip6_plen);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ptr == PTR_IP(ip_ttl))
				ptr = PTR_IP6(ip6_hlim);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ptr == PTR_IP(ip_p))
				ptr = PTR_IP6(ip6_nxt);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ptr &gt;= PTR_IP(ip_src) &amp;&amp;
			    ptr &lt; PTR_IP(ip_dst))
				ptr = PTR_IP6(ip6_src);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ptr &gt;= PTR_IP(ip_dst) &amp;&amp;
			    ptr &lt; (int32_t)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip))
				ptr = PTR_IP6(ip6_dst);
			<span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">return</span> (-1);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (-1);
		}
		icmp4-&gt;icmp_type = type;
		icmp4-&gt;icmp_code = code;
		icmp4-&gt;icmp_nextmtu = htons(mtu);
		<span class="enscript-keyword">if</span> (ptr &gt;= 0)
			icmp4-&gt;icmp_void = htonl(ptr);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_nat64_ipv6</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">struct</span> pf_pdesc *pd)
{
	<span class="enscript-type">struct</span> ip		*ip4;

	<span class="enscript-comment">/*
	 * ip_input asserts for rcvif to be not NULL
	 * That may not be true for two corner cases
	 * 1. If for some reason a local app sends DNS
	 * AAAA query to local host
	 * 2. If IPv6 stack in kernel internally generates a
	 * message destined for a synthesized IPv6 end-point.
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.rcvif == NULL)
		<span class="enscript-keyword">return</span> (PF_DROP);

	<span class="enscript-comment">/* trim the old header */</span>
	m_adj(m, off);

	<span class="enscript-comment">/* prepend the new one */</span>
	<span class="enscript-keyword">if</span> (M_PREPEND(m, <span class="enscript-keyword">sizeof</span>(*ip4), M_DONTWAIT, 0) == NULL)
		<span class="enscript-keyword">return</span> (PF_DROP);

	ip4 = mtod(m, <span class="enscript-type">struct</span> ip *);
	ip4-&gt;ip_v   = 4;
	ip4-&gt;ip_hl  = 5;
	ip4-&gt;ip_tos = pd-&gt;tos &amp; htonl(0x0ff00000);
	ip4-&gt;ip_len = htons(<span class="enscript-keyword">sizeof</span>(*ip4) + (pd-&gt;tot_len - off));
        ip4-&gt;ip_id  = 0;
        ip4-&gt;ip_off = htons(IP_DF);
        ip4-&gt;ip_ttl = pd-&gt;ttl;
        ip4-&gt;ip_p   = pd-&gt;proto;
	ip4-&gt;ip_sum = 0;
	ip4-&gt;ip_src = pd-&gt;naddr.v4;
	ip4-&gt;ip_dst = pd-&gt;ndaddr.v4;
	ip4-&gt;ip_sum = in_cksum(m, ip4-&gt;ip_hl &lt;&lt; 2);

	<span class="enscript-comment">/* recalculate icmp checksums */</span>
	<span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_ICMP) {
		<span class="enscript-type">struct</span> mbuf *mp;
		<span class="enscript-type">struct</span> icmp *icmp;
		<span class="enscript-type">int</span> moff, hlen = <span class="enscript-keyword">sizeof</span>(*ip4);

		<span class="enscript-keyword">if</span> ((mp = m_pulldown(m, hlen, ICMP_MINLEN, &amp;moff)) == NULL)
			<span class="enscript-keyword">return</span> (PF_NAT64);

		icmp = (<span class="enscript-type">struct</span> icmp *)(<span class="enscript-type">void</span> *)(mtod(mp, <span class="enscript-type">char</span> *) + moff);
		icmp-&gt;icmp_cksum = 0;
		icmp-&gt;icmp_cksum = inet_cksum(m, 0, hlen,
						ntohs(ip4-&gt;ip_len) - hlen);
	}

	ip_input(m);
	<span class="enscript-keyword">return</span> (PF_NAT64);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_nat64_ipv4</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">struct</span> pf_pdesc *pd)
{
	<span class="enscript-type">struct</span> ip6_hdr		*ip6;

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.rcvif == NULL)
		<span class="enscript-keyword">return</span> (PF_DROP);

	m_adj(m, off);
	<span class="enscript-keyword">if</span> (M_PREPEND(m, <span class="enscript-keyword">sizeof</span>(*ip6), M_DONTWAIT, 0) == NULL)
		<span class="enscript-keyword">return</span> (PF_DROP);

	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	ip6-&gt;ip6_vfc  = htonl((6 &lt;&lt; 28) | (pd-&gt;tos &lt;&lt; 20));
	ip6-&gt;ip6_plen = htons(pd-&gt;tot_len - off);
	ip6-&gt;ip6_nxt  = pd-&gt;proto;
	ip6-&gt;ip6_hlim = pd-&gt;ttl;
	ip6-&gt;ip6_src = pd-&gt;naddr.v6;
	ip6-&gt;ip6_dst = pd-&gt;ndaddr.v6;

	<span class="enscript-comment">/* recalculate icmp6 checksums */</span>
	<span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_ICMPV6) {
		<span class="enscript-type">struct</span> mbuf *mp;
		<span class="enscript-type">struct</span> icmp6_hdr *icmp6;
		<span class="enscript-type">int</span> moff, hlen = <span class="enscript-keyword">sizeof</span>(*ip6);

		<span class="enscript-keyword">if</span> ((mp = m_pulldown(m, hlen, <span class="enscript-keyword">sizeof</span>(*icmp6), &amp;moff)) == NULL)
			<span class="enscript-keyword">return</span> (PF_NAT64);

		icmp6 = (<span class="enscript-type">struct</span> icmp6_hdr *)(<span class="enscript-type">void</span> *)(mtod(mp, <span class="enscript-type">char</span> *) + moff);
		icmp6-&gt;icmp6_cksum = 0;
		icmp6-&gt;icmp6_cksum = inet6_cksum(m, IPPROTO_ICMPV6, hlen,
						ntohs(ip6-&gt;ip6_plen));
	}
	ip6_input(m);
	<span class="enscript-keyword">return</span> (PF_NAT64);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_test_rule</span>(<span class="enscript-type">struct</span> pf_rule **rm, <span class="enscript-type">struct</span> pf_state **sm, <span class="enscript-type">int</span> direction,
    <span class="enscript-type">struct</span> pfi_kif *kif, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">void</span> *h,
    <span class="enscript-type">struct</span> pf_pdesc *pd, <span class="enscript-type">struct</span> pf_rule **am, <span class="enscript-type">struct</span> pf_ruleset **rsm,
    <span class="enscript-type">struct</span> ifqueue *ifq)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">h</span>)
	<span class="enscript-type">struct</span> pf_rule		*nr = NULL;
	<span class="enscript-type">struct</span> pf_addr		*saddr = pd-&gt;src, *daddr = pd-&gt;dst;
	sa_family_t		 af = pd-&gt;af;
	<span class="enscript-type">struct</span> pf_rule		*r, *a = NULL;
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset = NULL;
	<span class="enscript-type">struct</span> pf_src_node	*nsn = NULL;
	<span class="enscript-type">struct</span> tcphdr		*th = pd-&gt;hdr.tcp;
	<span class="enscript-type">struct</span> udphdr		*uh = pd-&gt;hdr.udp;
	u_short			 reason;
	<span class="enscript-type">int</span>			 rewrite = 0, hdrlen = 0;
	<span class="enscript-type">int</span>			 tag = -1;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		 rtableid = IFSCOPE_NONE;
	<span class="enscript-type">int</span>			 asd = 0;
	<span class="enscript-type">int</span>			 match = 0;
	<span class="enscript-type">int</span>			 state_icmp = 0;
	u_int16_t		 mss = tcp_mssdflt;
	u_int8_t		 icmptype = 0, icmpcode = 0;

	<span class="enscript-type">struct</span> pf_grev1_hdr	*grev1 = pd-&gt;hdr.grev1;
	<span class="enscript-type">union</span> pf_state_xport bxport, bdxport, nxport, sxport, dxport;
	<span class="enscript-type">struct</span> pf_state_key	 psk;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (direction == PF_IN &amp;&amp; pf_check_congestion(ifq)) {
		REASON_SET(&amp;reason, PFRES_CONGEST);
		<span class="enscript-keyword">return</span> (PF_DROP);
	}

	hdrlen = 0;
	sxport.spi = 0;
	dxport.spi = 0;
	nxport.spi = 0;

	<span class="enscript-keyword">switch</span> (pd-&gt;proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		sxport.port = th-&gt;th_sport;
		dxport.port = th-&gt;th_dport;
		hdrlen = <span class="enscript-keyword">sizeof</span> (*th);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		sxport.port = uh-&gt;uh_sport;
		dxport.port = uh-&gt;uh_dport;
		hdrlen = <span class="enscript-keyword">sizeof</span> (*uh);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
		<span class="enscript-keyword">if</span> (pd-&gt;af != AF_INET)
			<span class="enscript-keyword">break</span>;
		sxport.port = dxport.port = pd-&gt;hdr.icmp-&gt;icmp_id;
		hdrlen = ICMP_MINLEN;
		icmptype = pd-&gt;hdr.icmp-&gt;icmp_type;
		icmpcode = pd-&gt;hdr.icmp-&gt;icmp_code;

		<span class="enscript-keyword">if</span> (icmptype == ICMP_UNREACH ||
		    icmptype == ICMP_SOURCEQUENCH ||
		    icmptype == ICMP_REDIRECT ||
		    icmptype == ICMP_TIMXCEED ||
		    icmptype == ICMP_PARAMPROB)
			state_icmp++;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
		<span class="enscript-keyword">if</span> (pd-&gt;af != AF_INET6)
			<span class="enscript-keyword">break</span>;
		sxport.port = dxport.port = pd-&gt;hdr.icmp6-&gt;icmp6_id;
		hdrlen = <span class="enscript-keyword">sizeof</span> (*pd-&gt;hdr.icmp6);
		icmptype = pd-&gt;hdr.icmp6-&gt;icmp6_type;
		icmpcode = pd-&gt;hdr.icmp6-&gt;icmp6_code;

		<span class="enscript-keyword">if</span> (icmptype == ICMP6_DST_UNREACH ||
		    icmptype == ICMP6_PACKET_TOO_BIG ||
		    icmptype == ICMP6_TIME_EXCEEDED ||
		    icmptype == ICMP6_PARAM_PROB)
			state_icmp++;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
		<span class="enscript-keyword">if</span> (pd-&gt;proto_variant == PF_GRE_PPTP_VARIANT) {
			sxport.call_id = dxport.call_id =
			    pd-&gt;hdr.grev1-&gt;call_id;
			hdrlen = <span class="enscript-keyword">sizeof</span> (*pd-&gt;hdr.grev1);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
		sxport.spi = 0;
		dxport.spi = pd-&gt;hdr.esp-&gt;spi;
		hdrlen = <span class="enscript-keyword">sizeof</span> (*pd-&gt;hdr.esp);
		<span class="enscript-keyword">break</span>;
	}

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);

	bxport = sxport;
	bdxport = dxport;

	<span class="enscript-keyword">if</span> (direction == PF_OUT)
		nxport = sxport;
	<span class="enscript-keyword">else</span>
		nxport = dxport;

	<span class="enscript-comment">/* check packet for BINAT/NAT/RDR */</span>
	<span class="enscript-keyword">if</span> ((nr = pf_get_translation_aux(pd, m, off, direction, kif, &amp;nsn,
		    saddr, &amp;sxport, daddr, &amp;dxport, &amp;nxport)) !=
		    NULL) {
		<span class="enscript-type">int</span> ua;
		u_int16_t dport;

		<span class="enscript-keyword">if</span> (pd-&gt;af != pd-&gt;naf)
			ua = 0;
		<span class="enscript-keyword">else</span>
			ua = 1;

		PF_ACPY(&amp;pd-&gt;baddr, saddr, af);
		PF_ACPY(&amp;pd-&gt;bdaddr, daddr, af);

		<span class="enscript-keyword">switch</span> (pd-&gt;proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
			<span class="enscript-keyword">if</span> (pd-&gt;af != pd-&gt;naf ||
			    PF_ANEQ(saddr, &amp;pd-&gt;naddr, pd-&gt;af)) {
				pf_change_ap(direction, pd-&gt;mp, saddr,
					&amp;th-&gt;th_sport, pd-&gt;ip_sum, &amp;th-&gt;th_sum,
					&amp;pd-&gt;naddr, nxport.port, 0, af,
					pd-&gt;naf, ua);
				sxport.port = th-&gt;th_sport;
			}

			<span class="enscript-keyword">if</span> (pd-&gt;af != pd-&gt;naf ||
			    PF_ANEQ(daddr, &amp;pd-&gt;ndaddr, pd-&gt;af) ||
			    (nr &amp;&amp; (nr-&gt;action == PF_RDR) &amp;&amp;
			     (th-&gt;th_dport != nxport.port))) {
				<span class="enscript-keyword">if</span> (nr &amp;&amp; nr-&gt;action == PF_RDR)
					dport = nxport.port;
				<span class="enscript-keyword">else</span>
					dport = th-&gt;th_dport;
				pf_change_ap(direction, pd-&gt;mp, daddr,
					&amp;th-&gt;th_dport, pd-&gt;ip_sum,
					&amp;th-&gt;th_sum, &amp;pd-&gt;ndaddr,
					dport, 0, af, pd-&gt;naf, ua);
				dxport.port = th-&gt;th_dport;
			}
			rewrite++;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
			<span class="enscript-keyword">if</span> (pd-&gt;af != pd-&gt;naf ||
			    PF_ANEQ(saddr, &amp;pd-&gt;naddr, pd-&gt;af)) {
				pf_change_ap(direction, pd-&gt;mp, saddr,
					&amp;uh-&gt;uh_sport, pd-&gt;ip_sum,
					&amp;uh-&gt;uh_sum, &amp;pd-&gt;naddr,
					nxport.port, 1, af, pd-&gt;naf, ua);
				sxport.port = uh-&gt;uh_sport;
			}

			<span class="enscript-keyword">if</span> (pd-&gt;af != pd-&gt;naf ||
			    PF_ANEQ(daddr, &amp;pd-&gt;ndaddr, pd-&gt;af) ||
			    (nr &amp;&amp; (nr-&gt;action == PF_RDR) &amp;&amp;
			     (uh-&gt;uh_dport != nxport.port))) {
				<span class="enscript-keyword">if</span> (nr &amp;&amp; nr-&gt;action == PF_RDR)
					dport = nxport.port;
				<span class="enscript-keyword">else</span>
					dport = uh-&gt;uh_dport;
				pf_change_ap(direction, pd-&gt;mp, daddr,
					&amp;uh-&gt;uh_dport, pd-&gt;ip_sum,
					&amp;uh-&gt;uh_sum, &amp;pd-&gt;ndaddr,
					dport, 0, af, pd-&gt;naf, ua);
				dxport.port = uh-&gt;uh_dport;
			}
			rewrite++;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
			<span class="enscript-keyword">if</span> (pd-&gt;af != AF_INET)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-comment">/*
			 * TODO:
			 * pd-&gt;af != pd-&gt;naf not handled yet here and would be
			 * needed for NAT46 needed to support XLAT.
			 * Will cross the bridge when it comes.
			 */</span>
			<span class="enscript-keyword">if</span> (PF_ANEQ(saddr, &amp;pd-&gt;naddr, pd-&gt;af)) {
				pf_change_a(&amp;saddr-&gt;v4.s_addr, pd-&gt;ip_sum,
					pd-&gt;naddr.v4.s_addr, 0);
				pd-&gt;hdr.icmp-&gt;icmp_cksum = pf_cksum_fixup(
				    pd-&gt;hdr.icmp-&gt;icmp_cksum, sxport.port,
				    nxport.port, 0);
				pd-&gt;hdr.icmp-&gt;icmp_id = nxport.port;
			}

			<span class="enscript-keyword">if</span> (PF_ANEQ(daddr, &amp;pd-&gt;ndaddr, pd-&gt;af)) {
				pf_change_a(&amp;daddr-&gt;v4.s_addr, pd-&gt;ip_sum,
					    pd-&gt;ndaddr.v4.s_addr, 0);
			}
			++rewrite;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
			<span class="enscript-keyword">if</span> (pd-&gt;af != AF_INET6)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (pd-&gt;af != pd-&gt;naf ||
			    PF_ANEQ(saddr, &amp;pd-&gt;naddr, pd-&gt;af)) {
				pf_change_addr(saddr,
					&amp;pd-&gt;hdr.icmp6-&gt;icmp6_cksum,
					&amp;pd-&gt;naddr, 0, pd-&gt;af, pd-&gt;naf);
			}

			<span class="enscript-keyword">if</span> (pd-&gt;af != pd-&gt;naf ||
			    PF_ANEQ(daddr, &amp;pd-&gt;ndaddr, pd-&gt;af)) {
				pf_change_addr(daddr,
					&amp;pd-&gt;hdr.icmp6-&gt;icmp6_cksum,
					&amp;pd-&gt;ndaddr, 0, pd-&gt;af, pd-&gt;naf);
			}

			<span class="enscript-keyword">if</span> (pd-&gt;af != pd-&gt;naf) {
				<span class="enscript-keyword">if</span> (pf_translate_icmp_af(AF_INET,
							pd-&gt;hdr.icmp6))
					<span class="enscript-keyword">return</span> (PF_DROP);
				pd-&gt;proto = IPPROTO_ICMP;
			}
			rewrite++;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
			<span class="enscript-keyword">if</span> ((direction == PF_IN) &amp;&amp;
			    (pd-&gt;proto_variant == PF_GRE_PPTP_VARIANT))
			    grev1-&gt;call_id = nxport.call_id;

			<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				<span class="enscript-keyword">if</span> (PF_ANEQ(saddr, &amp;pd-&gt;naddr, pd-&gt;af)) {
					pf_change_a(&amp;saddr-&gt;v4.s_addr,
						pd-&gt;ip_sum,
						pd-&gt;naddr.v4.s_addr, 0);
				}
				<span class="enscript-keyword">if</span> (PF_ANEQ(daddr, &amp;pd-&gt;ndaddr, pd-&gt;af)) {
					pf_change_a(&amp;daddr-&gt;v4.s_addr,
						pd-&gt;ip_sum,
						pd-&gt;ndaddr.v4.s_addr, 0);
				}
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				<span class="enscript-keyword">if</span> (PF_ANEQ(saddr, &amp;pd-&gt;naddr, pd-&gt;af))
					PF_ACPY(saddr, &amp;pd-&gt;naddr, AF_INET6);
				<span class="enscript-keyword">if</span> (PF_ANEQ(daddr, &amp;pd-&gt;ndaddr, pd-&gt;af))
					PF_ACPY(daddr, &amp;pd-&gt;ndaddr, AF_INET6);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			}
			++rewrite;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
			<span class="enscript-keyword">if</span> (direction == PF_OUT)
				bxport.spi = 0;

			<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				<span class="enscript-keyword">if</span> (PF_ANEQ(saddr, &amp;pd-&gt;naddr, pd-&gt;af)) {
					pf_change_a(&amp;saddr-&gt;v4.s_addr,
					pd-&gt;ip_sum, pd-&gt;naddr.v4.s_addr, 0);
				}
				<span class="enscript-keyword">if</span> (PF_ANEQ(daddr, &amp;pd-&gt;ndaddr, pd-&gt;af)) {
					pf_change_a(&amp;daddr-&gt;v4.s_addr,
						pd-&gt;ip_sum,
						pd-&gt;ndaddr.v4.s_addr, 0);
				}
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				<span class="enscript-keyword">if</span> (PF_ANEQ(saddr, &amp;pd-&gt;naddr, pd-&gt;af))
					PF_ACPY(saddr, &amp;pd-&gt;naddr, AF_INET6);
				<span class="enscript-keyword">if</span> (PF_ANEQ(daddr, &amp;pd-&gt;ndaddr, pd-&gt;af))
					PF_ACPY(daddr, &amp;pd-&gt;ndaddr, AF_INET6);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				<span class="enscript-keyword">if</span> ((pd-&gt;naf != AF_INET) ||
				    (PF_ANEQ(saddr, &amp;pd-&gt;naddr, pd-&gt;af))) {
					pf_change_addr(saddr, pd-&gt;ip_sum,
						&amp;pd-&gt;naddr, 0, af, pd-&gt;naf);
				}

				<span class="enscript-keyword">if</span> ((pd-&gt;naf != AF_INET) ||
				    (PF_ANEQ(daddr, &amp;pd-&gt;ndaddr, pd-&gt;af))) {
					pf_change_addr(daddr, pd-&gt;ip_sum,
						&amp;pd-&gt;ndaddr, 0, af, pd-&gt;naf);
				}
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				<span class="enscript-keyword">if</span> (PF_ANEQ(saddr, &amp;pd-&gt;naddr, pd-&gt;af))
					PF_ACPY(saddr, &amp;pd-&gt;naddr, af);
				<span class="enscript-keyword">if</span> (PF_ANEQ(daddr, &amp;pd-&gt;ndaddr, pd-&gt;af))
					PF_ACPY(daddr, &amp;pd-&gt;ndaddr, af);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
			}
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (nr-&gt;natpass)
			r = NULL;
		pd-&gt;nat_rule = nr;
		pd-&gt;af = pd-&gt;naf;
	}

	<span class="enscript-keyword">if</span> (nr &amp;&amp; nr-&gt;tag &gt; 0)
		tag = nr-&gt;tag;

	<span class="enscript-keyword">while</span> (r != NULL) {
		r-&gt;evaluations++;
		<span class="enscript-keyword">if</span> (pfi_kif_match(r-&gt;kif, kif) == r-&gt;ifnot)
			r = r-&gt;skip[PF_SKIP_IFP].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;direction &amp;&amp; r-&gt;direction != direction)
			r = r-&gt;skip[PF_SKIP_DIR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;af &amp;&amp; r-&gt;af != pd-&gt;af)
			r = r-&gt;skip[PF_SKIP_AF].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;proto &amp;&amp; r-&gt;proto != pd-&gt;proto)
			r = r-&gt;skip[PF_SKIP_PROTO].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PF_MISMATCHAW(&amp;r-&gt;src.addr, saddr, pd-&gt;af,
		    r-&gt;src.neg, kif))
			r = r-&gt;skip[PF_SKIP_SRC_ADDR].ptr;
		<span class="enscript-comment">/* tcp/udp only. port_op always 0 in other cases */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;proto == pd-&gt;proto &amp;&amp;
		    (r-&gt;proto == IPPROTO_TCP || r-&gt;proto == IPPROTO_UDP) &amp;&amp;
		    r-&gt;src.xport.range.op &amp;&amp;
		    !pf_match_port(r-&gt;src.xport.range.op,
		    r-&gt;src.xport.range.port[0], r-&gt;src.xport.range.port[1],
		    th-&gt;th_sport))
			r = r-&gt;skip[PF_SKIP_SRC_PORT].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PF_MISMATCHAW(&amp;r-&gt;dst.addr, daddr, pd-&gt;af,
		    r-&gt;dst.neg, NULL))
			r = r-&gt;skip[PF_SKIP_DST_ADDR].ptr;
		<span class="enscript-comment">/* tcp/udp only. port_op always 0 in other cases */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;proto == pd-&gt;proto &amp;&amp;
		    (r-&gt;proto == IPPROTO_TCP || r-&gt;proto == IPPROTO_UDP) &amp;&amp;
		    r-&gt;dst.xport.range.op &amp;&amp;
		    !pf_match_port(r-&gt;dst.xport.range.op,
		    r-&gt;dst.xport.range.port[0], r-&gt;dst.xport.range.port[1],
		    th-&gt;th_dport))
			r = r-&gt;skip[PF_SKIP_DST_PORT].ptr;
		<span class="enscript-comment">/* icmp only. type always 0 in other cases */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;type &amp;&amp; r-&gt;type != icmptype + 1)
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-comment">/* icmp only. type always 0 in other cases */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;code &amp;&amp; r-&gt;code != icmpcode + 1)
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((r-&gt;rule_flag &amp; PFRULE_TOS) &amp;&amp; r-&gt;tos &amp;&amp;
		    !(r-&gt;tos &amp; pd-&gt;tos))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((r-&gt;rule_flag &amp; PFRULE_DSCP) &amp;&amp; r-&gt;tos &amp;&amp;
		    !(r-&gt;tos &amp; (pd-&gt;tos &amp; DSCP_MASK)))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((r-&gt;rule_flag &amp; PFRULE_SC) &amp;&amp; r-&gt;tos &amp;&amp;
		    ((r-&gt;tos &amp; SCIDX_MASK) != pd-&gt;sc))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;rule_flag &amp; PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_TCP &amp;&amp;
		    (r-&gt;flagset &amp; th-&gt;th_flags) != r-&gt;flags)
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-comment">/* tcp/udp only. uid.op always 0 in other cases */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;uid.op &amp;&amp; (pd-&gt;lookup.done || (pd-&gt;lookup.done =
		    pf_socket_lookup(direction, pd), 1)) &amp;&amp;
		    !pf_match_uid(r-&gt;uid.op, r-&gt;uid.uid[0], r-&gt;uid.uid[1],
		    pd-&gt;lookup.uid))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-comment">/* tcp/udp only. gid.op always 0 in other cases */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;gid.op &amp;&amp; (pd-&gt;lookup.done || (pd-&gt;lookup.done =
		    pf_socket_lookup(direction, pd), 1)) &amp;&amp;
		    !pf_match_gid(r-&gt;gid.op, r-&gt;gid.gid[0], r-&gt;gid.gid[1],
		    pd-&gt;lookup.gid))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;prob &amp;&amp; r-&gt;prob &lt;= (RandomULong() % (UINT_MAX - 1) + 1))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;match_tag &amp;&amp; !pf_match_tag(m, r, pd-&gt;pf_mtag, &amp;tag))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;os_fingerprint != PF_OSFP_ANY &amp;&amp;
		    (pd-&gt;proto != IPPROTO_TCP || !pf_osfp_match(
		    pf_osfp_fingerprint(pd, m, off, th),
		    r-&gt;os_fingerprint)))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (r-&gt;tag)
				tag = r-&gt;tag;
			<span class="enscript-keyword">if</span> (PF_RTABLEID_IS_VALID(r-&gt;rtableid))
				rtableid = r-&gt;rtableid;
			<span class="enscript-keyword">if</span> (r-&gt;anchor == NULL) {
				match = 1;
				*rm = r;
				*am = a;
				*rsm = ruleset;
				<span class="enscript-keyword">if</span> ((*rm)-&gt;quick)
					<span class="enscript-keyword">break</span>;
				r = TAILQ_NEXT(r, entries);
			} <span class="enscript-keyword">else</span>
				pf_step_into_anchor(&amp;asd, &amp;ruleset,
				    PF_RULESET_FILTER, &amp;r, &amp;a, &amp;match);
		}
		<span class="enscript-keyword">if</span> (r == NULL &amp;&amp; pf_step_out_of_anchor(&amp;asd, &amp;ruleset,
		    PF_RULESET_FILTER, &amp;r, &amp;a, &amp;match))
			<span class="enscript-keyword">break</span>;
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	REASON_SET(&amp;reason, PFRES_MATCH);

	<span class="enscript-keyword">if</span> (r-&gt;log || (nr != NULL &amp;&amp; nr-&gt;log)) {
		<span class="enscript-keyword">if</span> (rewrite &gt; 0) {
			<span class="enscript-keyword">if</span> (rewrite &lt; off + hdrlen)
				rewrite = off + hdrlen;

			m = pf_lazy_makewritable(pd, m, rewrite);
			<span class="enscript-keyword">if</span> (!m) {
				REASON_SET(&amp;reason, PFRES_MEMORY);
				<span class="enscript-keyword">return</span> (PF_DROP);
			}

			m_copyback(m, off, hdrlen, pd-&gt;hdr.any);
		}
		PFLOG_PACKET(kif, h, m, pd-&gt;af, direction, reason,
				r-&gt;log ? r : nr, a, ruleset, pd);
	}

	<span class="enscript-keyword">if</span> ((r-&gt;action == PF_DROP) &amp;&amp;
	    ((r-&gt;rule_flag &amp; PFRULE_RETURNRST) ||
	    (r-&gt;rule_flag &amp; PFRULE_RETURNICMP) ||
	    (r-&gt;rule_flag &amp; PFRULE_RETURN))) {
		<span class="enscript-comment">/* undo NAT changes, if they have taken place */</span>
		<span class="enscript-comment">/* XXX For NAT64 we are not reverting the changes */</span>
		<span class="enscript-keyword">if</span> (nr != NULL &amp;&amp; nr-&gt;action != PF_NAT64) {
			<span class="enscript-keyword">if</span> (direction == PF_OUT) {
				pd-&gt;af = af;
				<span class="enscript-keyword">switch</span> (pd-&gt;proto) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
					pf_change_ap(direction, pd-&gt;mp, saddr,
					    &amp;th-&gt;th_sport, pd-&gt;ip_sum,
					    &amp;th-&gt;th_sum, &amp;pd-&gt;baddr,
					    bxport.port, 0, af, pd-&gt;af, 1);
					sxport.port = th-&gt;th_sport;
					rewrite++;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
					pf_change_ap(direction, pd-&gt;mp, saddr,
					    &amp;pd-&gt;hdr.udp-&gt;uh_sport, pd-&gt;ip_sum,
					    &amp;pd-&gt;hdr.udp-&gt;uh_sum, &amp;pd-&gt;baddr,
					    bxport.port, 1, af, pd-&gt;af, 1);
					sxport.port = pd-&gt;hdr.udp-&gt;uh_sport;
					rewrite++;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
#<span class="enscript-reference">endif</span>
					<span class="enscript-comment">/* nothing! */</span>
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
					PF_ACPY(&amp;pd-&gt;baddr, saddr, af);
					++rewrite;
					<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
						pf_change_a(&amp;saddr-&gt;v4.s_addr,
						    pd-&gt;ip_sum,
						    pd-&gt;baddr.v4.s_addr, 0);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
						PF_ACPY(saddr, &amp;pd-&gt;baddr,
						    AF_INET6);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					}
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
					PF_ACPY(&amp;pd-&gt;baddr, saddr, af);
					<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
						pf_change_a(&amp;saddr-&gt;v4.s_addr,
						    pd-&gt;ip_sum,
						    pd-&gt;baddr.v4.s_addr, 0);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
						PF_ACPY(saddr, &amp;pd-&gt;baddr,
						    AF_INET6);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					}
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					<span class="enscript-keyword">switch</span> (af) {
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
						pf_change_a(&amp;saddr-&gt;v4.s_addr,
						    pd-&gt;ip_sum,
						    pd-&gt;baddr.v4.s_addr, 0);
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
						PF_ACPY(saddr, &amp;pd-&gt;baddr, af);
						<span class="enscript-keyword">break</span>;
					}
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">switch</span> (pd-&gt;proto) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
					pf_change_ap(direction, pd-&gt;mp, daddr,
					    &amp;th-&gt;th_dport, pd-&gt;ip_sum,
					    &amp;th-&gt;th_sum, &amp;pd-&gt;bdaddr,
					    bdxport.port, 0, af, pd-&gt;af, 1);
					dxport.port = th-&gt;th_dport;
					rewrite++;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
					pf_change_ap(direction, pd-&gt;mp, daddr,
					    &amp;pd-&gt;hdr.udp-&gt;uh_dport, pd-&gt;ip_sum,
					    &amp;pd-&gt;hdr.udp-&gt;uh_sum, &amp;pd-&gt;bdaddr,
					    bdxport.port, 1, af, pd-&gt;af, 1);
					dxport.port = pd-&gt;hdr.udp-&gt;uh_dport;
					rewrite++;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
#<span class="enscript-reference">endif</span>
					<span class="enscript-comment">/* nothing! */</span>
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
					<span class="enscript-keyword">if</span> (pd-&gt;proto_variant ==
					    PF_GRE_PPTP_VARIANT)
						grev1-&gt;call_id =
							bdxport.call_id;
					++rewrite;
					<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
						pf_change_a(&amp;daddr-&gt;v4.s_addr,
						    pd-&gt;ip_sum,
						    pd-&gt;bdaddr.v4.s_addr, 0);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
						PF_ACPY(daddr, &amp;pd-&gt;bdaddr,
						    AF_INET6);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					}
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
					<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
						pf_change_a(&amp;daddr-&gt;v4.s_addr,
						    pd-&gt;ip_sum,
						    pd-&gt;bdaddr.v4.s_addr, 0);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
						PF_ACPY(daddr, &amp;pd-&gt;bdaddr,
						    AF_INET6);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					}
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					<span class="enscript-keyword">switch</span> (af) {
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
						pf_change_a(&amp;daddr-&gt;v4.s_addr,
						    pd-&gt;ip_sum,
						    pd-&gt;bdaddr.v4.s_addr, 0);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
					<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
						PF_ACPY(daddr, &amp;pd-&gt;bdaddr, af);
						<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					}
				}
			}
		}
		<span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_TCP &amp;&amp;
		    ((r-&gt;rule_flag &amp; PFRULE_RETURNRST) ||
		    (r-&gt;rule_flag &amp; PFRULE_RETURN)) &amp;&amp;
		    !(th-&gt;th_flags &amp; TH_RST)) {
			u_int32_t	 ack = ntohl(th-&gt;th_seq) + pd-&gt;p_len;
			<span class="enscript-type">int</span>		 len = 0;
			<span class="enscript-type">struct</span> ip	*h4;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-type">struct</span> ip6_hdr	*h6;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

			<span class="enscript-keyword">switch</span> (pd-&gt;af) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				h4 = mtod(m, <span class="enscript-type">struct</span> ip *);
				len = ntohs(h4-&gt;ip_len) - off;
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				h6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
				len = ntohs(h6-&gt;ip6_plen) -
				    (off - <span class="enscript-keyword">sizeof</span> (*h6));
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			}

			<span class="enscript-keyword">if</span> (pf_check_proto_cksum(m, off, len, IPPROTO_TCP,
						 pd-&gt;af))
				REASON_SET(&amp;reason, PFRES_PROTCKSUM);
			<span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_SYN)
					ack++;
				<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_FIN)
					ack++;
				pf_send_tcp(r, pd-&gt;af, pd-&gt;dst,
				    pd-&gt;src, th-&gt;th_dport, th-&gt;th_sport,
				    ntohl(th-&gt;th_ack), ack, TH_RST|TH_ACK, 0, 0,
				    r-&gt;return_ttl, 1, 0, pd-&gt;eh, kif-&gt;pfik_ifp);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pd-&gt;proto != IPPROTO_ICMP &amp;&amp; pd-&gt;af == AF_INET &amp;&amp;
		    pd-&gt;proto != IPPROTO_ESP &amp;&amp; pd-&gt;proto != IPPROTO_AH &amp;&amp;
		    r-&gt;return_icmp)
			pf_send_icmp(m, r-&gt;return_icmp &gt;&gt; 8,
			    r-&gt;return_icmp &amp; 255, pd-&gt;af, r);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pd-&gt;proto != IPPROTO_ICMPV6 &amp;&amp; af == AF_INET6 &amp;&amp;
		    pd-&gt;proto != IPPROTO_ESP &amp;&amp; pd-&gt;proto != IPPROTO_AH &amp;&amp;
		    r-&gt;return_icmp6)
			pf_send_icmp(m, r-&gt;return_icmp6 &gt;&gt; 8,
			    r-&gt;return_icmp6 &amp; 255, pd-&gt;af, r);
	}

	<span class="enscript-keyword">if</span> (r-&gt;action == PF_DROP)
		<span class="enscript-keyword">return</span> (PF_DROP);

	<span class="enscript-comment">/* prepare state key, for flowhash and/or the state (if created) */</span>
	bzero(&amp;psk, <span class="enscript-keyword">sizeof</span> (psk));
	psk.proto = pd-&gt;proto;
	psk.direction = direction;
	<span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_UDP) {
		<span class="enscript-keyword">if</span> (ntohs(pd-&gt;hdr.udp-&gt;uh_sport) == PF_IKE_PORT &amp;&amp;
		    ntohs(pd-&gt;hdr.udp-&gt;uh_dport) == PF_IKE_PORT) {
			psk.proto_variant = PF_EXTFILTER_APD;
		} <span class="enscript-keyword">else</span> {
			psk.proto_variant = nr ? nr-&gt;extfilter : r-&gt;extfilter;
			<span class="enscript-keyword">if</span> (psk.proto_variant &lt; PF_EXTFILTER_APD)
				psk.proto_variant = PF_EXTFILTER_APD;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_GRE) {
		psk.proto_variant = pd-&gt;proto_variant;
	}
	<span class="enscript-keyword">if</span> (direction == PF_OUT) {
		psk.af_gwy = af;
		PF_ACPY(&amp;psk.gwy.addr, saddr, af);
		PF_ACPY(&amp;psk.ext_gwy.addr, daddr, af);
		<span class="enscript-keyword">switch</span> (pd-&gt;proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
			psk.gwy.xport.spi = 0;
			psk.ext_gwy.xport.spi = pd-&gt;hdr.esp-&gt;spi;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/*
			 * NAT64 requires protocol translation  between ICMPv4
			 * and ICMPv6. TCP and UDP do not require protocol
			 * translation. To avoid adding complexity just to
			 * handle ICMP(v4/v6), we always lookup  for
			 * proto = IPPROTO_ICMP on both LAN and WAN side
			 */</span>
			psk.proto = IPPROTO_ICMP;
			psk.gwy.xport.port = nxport.port;
			psk.ext_gwy.xport.spi = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			psk.gwy.xport = sxport;
			psk.ext_gwy.xport = dxport;
			<span class="enscript-keyword">break</span>;
		}
		psk.af_lan = af;
		<span class="enscript-keyword">if</span> (nr != NULL) {
			PF_ACPY(&amp;psk.lan.addr, &amp;pd-&gt;baddr, af);
			psk.lan.xport = bxport;
			PF_ACPY(&amp;psk.ext_lan.addr, &amp;pd-&gt;bdaddr, af);
			psk.ext_lan.xport = bdxport;
		} <span class="enscript-keyword">else</span> {
			PF_ACPY(&amp;psk.lan.addr, &amp;psk.gwy.addr, af);
			psk.lan.xport = psk.gwy.xport;
			PF_ACPY(&amp;psk.ext_lan.addr, &amp;psk.ext_gwy.addr, af);
			psk.ext_lan.xport = psk.ext_gwy.xport;
		}
	} <span class="enscript-keyword">else</span> {
		psk.af_lan = af;
		<span class="enscript-keyword">if</span> (nr &amp;&amp; nr-&gt;action == PF_NAT64) {
			PF_ACPY(&amp;psk.lan.addr, &amp;pd-&gt;baddr, af);
			PF_ACPY(&amp;psk.ext_lan.addr, &amp;pd-&gt;bdaddr, af);
		} <span class="enscript-keyword">else</span> {
			PF_ACPY(&amp;psk.lan.addr, daddr, af);
			PF_ACPY(&amp;psk.ext_lan.addr, saddr, af);
		}
		<span class="enscript-keyword">switch</span> (pd-&gt;proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/*
			 * NAT64 requires protocol translation  between ICMPv4
			 * and ICMPv6. TCP and UDP do not require protocol
			 * translation. To avoid adding complexity just to
			 * handle ICMP(v4/v6), we always lookup  for
			 * proto = IPPROTO_ICMP on both LAN and WAN side
			 */</span>
			psk.proto = IPPROTO_ICMP;
			<span class="enscript-keyword">if</span> (nr &amp;&amp; nr-&gt;action == PF_NAT64) {
				psk.lan.xport = bxport;
				psk.ext_lan.xport = bxport;
			} <span class="enscript-keyword">else</span> {
				psk.lan.xport = nxport;
				psk.ext_lan.xport.spi = 0;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
			psk.ext_lan.xport.spi = 0;
			psk.lan.xport.spi = pd-&gt;hdr.esp-&gt;spi;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">if</span> (nr != NULL) {
				<span class="enscript-keyword">if</span> (nr-&gt;action == PF_NAT64) {
					psk.lan.xport = bxport;
					psk.ext_lan.xport = bdxport;
				} <span class="enscript-keyword">else</span> {
					psk.lan.xport = dxport;
					psk.ext_lan.xport = sxport;
				}
			} <span class="enscript-keyword">else</span> {
				psk.lan.xport = dxport;
				psk.ext_lan.xport = sxport;
			}
			<span class="enscript-keyword">break</span>;
		}
		psk.af_gwy = pd-&gt;naf;
		<span class="enscript-keyword">if</span> (nr != NULL) {
			<span class="enscript-keyword">if</span> (nr-&gt;action == PF_NAT64) {
				PF_ACPY(&amp;psk.gwy.addr, &amp;pd-&gt;naddr, pd-&gt;naf);
				PF_ACPY(&amp;psk.ext_gwy.addr, &amp;pd-&gt;ndaddr,
					pd-&gt;naf);
				<span class="enscript-keyword">if</span> ((pd-&gt;proto == IPPROTO_ICMPV6) ||
				    (pd-&gt;proto == IPPROTO_ICMP)) {
					psk.gwy.xport = nxport;
					psk.ext_gwy.xport = nxport;
				} <span class="enscript-keyword">else</span> {
					psk.gwy.xport = sxport;
					psk.ext_gwy.xport = dxport;
				}
			} <span class="enscript-keyword">else</span> {
				PF_ACPY(&amp;psk.gwy.addr, &amp;pd-&gt;bdaddr, af);
				psk.gwy.xport = bdxport;
				PF_ACPY(&amp;psk.ext_gwy.addr, saddr, af);
				psk.ext_gwy.xport = sxport;
			}
		} <span class="enscript-keyword">else</span> {
			PF_ACPY(&amp;psk.gwy.addr, &amp;psk.lan.addr, af);
			psk.gwy.xport = psk.lan.xport;
			PF_ACPY(&amp;psk.ext_gwy.addr, &amp;psk.ext_lan.addr, af);
			psk.ext_gwy.xport = psk.ext_lan.xport;
		}
	}
	<span class="enscript-keyword">if</span> (pd-&gt;pktflags &amp; PKTF_FLOW_ID) {
		<span class="enscript-comment">/* flow hash was already computed outside of PF */</span>
		psk.flowsrc = pd-&gt;flowsrc;
		psk.flowhash = pd-&gt;flowhash;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* compute flow hash and store it in state key */</span>
		psk.flowsrc = FLOWSRC_PF;
		psk.flowhash = pf_calc_state_key_flowhash(&amp;psk);
		pd-&gt;flowsrc = psk.flowsrc;
		pd-&gt;flowhash = psk.flowhash;
		pd-&gt;pktflags |= PKTF_FLOW_ID;
		pd-&gt;pktflags &amp;= ~PKTF_FLOW_ADV;
	}

	<span class="enscript-keyword">if</span> (pf_tag_packet(m, pd-&gt;pf_mtag, tag, rtableid, pd)) {
		REASON_SET(&amp;reason, PFRES_MEMORY);
		<span class="enscript-keyword">return</span> (PF_DROP);
	}

	<span class="enscript-keyword">if</span> (!state_icmp &amp;&amp; (r-&gt;keep_state || nr != NULL ||
	    (pd-&gt;flags &amp; PFDESC_TCP_NORM))) {
		<span class="enscript-comment">/* create new state */</span>
		<span class="enscript-type">struct</span> pf_state	*s = NULL;
		<span class="enscript-type">struct</span> pf_state_key *sk = NULL;
		<span class="enscript-type">struct</span> pf_src_node *sn = NULL;
		<span class="enscript-type">struct</span> pf_ike_hdr ike;

		<span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_UDP) {
			size_t plen = m-&gt;m_pkthdr.len - off - <span class="enscript-keyword">sizeof</span> (*uh);

			<span class="enscript-keyword">if</span> (ntohs(uh-&gt;uh_sport) == PF_IKE_PORT &amp;&amp;
			    ntohs(uh-&gt;uh_dport) == PF_IKE_PORT &amp;&amp;
			    plen &gt;= PF_IKE_PACKET_MINSIZE) {
				<span class="enscript-keyword">if</span> (plen &gt; PF_IKE_PACKET_MINSIZE)
					plen = PF_IKE_PACKET_MINSIZE;
				m_copydata(m, off + <span class="enscript-keyword">sizeof</span> (*uh), plen, &amp;ike);
			}
		}

		<span class="enscript-keyword">if</span> (nr != NULL &amp;&amp; pd-&gt;proto == IPPROTO_ESP &amp;&amp;
		    direction == PF_OUT) {
			<span class="enscript-type">struct</span> pf_state_key_cmp	sk0;
			<span class="enscript-type">struct</span> pf_state *s0;

			<span class="enscript-comment">/*
			 * &lt;<a href="mailto:jhw@apple.com">jhw@apple.com</a>&gt;
			 * This squelches state creation if the external
			 * address matches an existing incomplete state with a
			 * different internal address.  Only one 'blocking'
			 * partial state is allowed for each external address.
			 */</span>
			memset(&amp;sk0, 0, <span class="enscript-keyword">sizeof</span> (sk0));
			sk0.af_gwy = pd-&gt;af;
			sk0.proto = IPPROTO_ESP;
			PF_ACPY(&amp;sk0.gwy.addr, saddr, sk0.af_gwy);
			PF_ACPY(&amp;sk0.ext_gwy.addr, daddr, sk0.af_gwy);
			s0 = pf_find_state(kif, &amp;sk0, PF_IN);

			<span class="enscript-keyword">if</span> (s0 &amp;&amp; PF_ANEQ(&amp;s0-&gt;state_key-&gt;lan.addr,
			    pd-&gt;src, pd-&gt;af)) {
				nsn = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
			}
		}

		<span class="enscript-comment">/* check maximums */</span>
		<span class="enscript-keyword">if</span> (r-&gt;max_states &amp;&amp; (r-&gt;states &gt;= r-&gt;max_states)) {
			pf_status.lcounters[LCNT_STATES]++;
			REASON_SET(&amp;reason, PFRES_MAXSTATES);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
		}
		<span class="enscript-comment">/* src node for filter rule */</span>
		<span class="enscript-keyword">if</span> ((r-&gt;rule_flag &amp; PFRULE_SRCTRACK ||
		    r-&gt;rpool.opts &amp; PF_POOL_STICKYADDR) &amp;&amp;
		    pf_insert_src_node(&amp;sn, r, saddr, af) != 0) {
			REASON_SET(&amp;reason, PFRES_SRCLIMIT);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
		}
		<span class="enscript-comment">/* src node for translation rule */</span>
		<span class="enscript-keyword">if</span> (nr != NULL &amp;&amp; (nr-&gt;rpool.opts &amp; PF_POOL_STICKYADDR) &amp;&amp;
		    ((direction == PF_OUT &amp;&amp;
		    nr-&gt;action != PF_RDR &amp;&amp;
		    pf_insert_src_node(&amp;nsn, nr, &amp;pd-&gt;baddr, af) != 0) ||
		    (pf_insert_src_node(&amp;nsn, nr, saddr, af) != 0))) {
			REASON_SET(&amp;reason, PFRES_SRCLIMIT);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
		}
		s = pool_get(&amp;pf_state_pl, PR_WAITOK);
		<span class="enscript-keyword">if</span> (s == NULL) {
			REASON_SET(&amp;reason, PFRES_MEMORY);
<span class="enscript-reference">cleanup</span>:
			<span class="enscript-keyword">if</span> (sn != NULL &amp;&amp; sn-&gt;states == 0 &amp;&amp; sn-&gt;expire == 0) {
				RB_REMOVE(pf_src_tree, &amp;tree_src_tracking, sn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&amp;pf_src_tree_pl, sn);
			}
			<span class="enscript-keyword">if</span> (nsn != sn &amp;&amp; nsn != NULL &amp;&amp; nsn-&gt;states == 0 &amp;&amp;
			    nsn-&gt;expire == 0) {
				RB_REMOVE(pf_src_tree, &amp;tree_src_tracking, nsn);
				pf_status.scounters[SCNT_SRC_NODE_REMOVALS]++;
				pf_status.src_nodes--;
				pool_put(&amp;pf_src_tree_pl, nsn);
			}
			<span class="enscript-keyword">if</span> (sk != NULL) {
				<span class="enscript-keyword">if</span> (sk-&gt;app_state)
					pool_put(&amp;pf_app_state_pl,
					    sk-&gt;app_state);
				pool_put(&amp;pf_state_key_pl, sk);
			}
			<span class="enscript-keyword">return</span> (PF_DROP);
		}
		bzero(s, <span class="enscript-keyword">sizeof</span> (*s));
		TAILQ_INIT(&amp;s-&gt;unlink_hooks);
		s-&gt;rule.ptr = r;
		s-&gt;nat_rule.ptr = nr;
		s-&gt;anchor.ptr = a;
		STATE_INC_COUNTERS(s);
		s-&gt;allow_opts = r-&gt;allow_opts;
		s-&gt;log = r-&gt;log &amp; PF_LOG_ALL;
		<span class="enscript-keyword">if</span> (nr != NULL)
			s-&gt;log |= nr-&gt;log &amp; PF_LOG_ALL;
		<span class="enscript-keyword">switch</span> (pd-&gt;proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
			s-&gt;src.seqlo = ntohl(th-&gt;th_seq);
			s-&gt;src.seqhi = s-&gt;src.seqlo + pd-&gt;p_len + 1;
			<span class="enscript-keyword">if</span> ((th-&gt;th_flags &amp; (TH_SYN|TH_ACK)) ==
			    TH_SYN &amp;&amp; r-&gt;keep_state == PF_STATE_MODULATE) {
				<span class="enscript-comment">/* Generate sequence number modulator */</span>
				<span class="enscript-keyword">if</span> ((s-&gt;src.seqdiff = pf_tcp_iss(pd) -
				    s-&gt;src.seqlo) == 0)
					s-&gt;src.seqdiff = 1;
				pf_change_a(&amp;th-&gt;th_seq, &amp;th-&gt;th_sum,
				    htonl(s-&gt;src.seqlo + s-&gt;src.seqdiff), 0);
				rewrite = off + <span class="enscript-keyword">sizeof</span> (*th);
			} <span class="enscript-keyword">else</span>
				s-&gt;src.seqdiff = 0;
			<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_SYN) {
				s-&gt;src.seqhi++;
				s-&gt;src.wscale = pf_get_wscale(m, off,
				    th-&gt;th_off, af);
			}
			s-&gt;src.max_win = MAX(ntohs(th-&gt;th_win), 1);
			<span class="enscript-keyword">if</span> (s-&gt;src.wscale &amp; PF_WSCALE_MASK) {
				<span class="enscript-comment">/* Remove scale factor from initial window */</span>
				<span class="enscript-type">int</span> win = s-&gt;src.max_win;
				win += 1 &lt;&lt; (s-&gt;src.wscale &amp; PF_WSCALE_MASK);
				s-&gt;src.max_win = (win - 1) &gt;&gt;
				    (s-&gt;src.wscale &amp; PF_WSCALE_MASK);
			}
			<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_FIN)
				s-&gt;src.seqhi++;
			s-&gt;dst.seqhi = 1;
			s-&gt;dst.max_win = 1;
			s-&gt;src.state = TCPS_SYN_SENT;
			s-&gt;dst.state = TCPS_CLOSED;
			s-&gt;timeout = PFTM_TCP_FIRST_PACKET;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
			s-&gt;src.state = PFUDPS_SINGLE;
			s-&gt;dst.state = PFUDPS_NO_TRAFFIC;
			s-&gt;timeout = PFTM_UDP_FIRST_PACKET;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
#<span class="enscript-reference">endif</span>
			s-&gt;timeout = PFTM_ICMP_FIRST_PACKET;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
			s-&gt;src.state = PFGRE1S_INITIATING;
			s-&gt;dst.state = PFGRE1S_NO_TRAFFIC;
			s-&gt;timeout = PFTM_GREv1_INITIATING;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
			s-&gt;src.state = PFESPS_INITIATING;
			s-&gt;dst.state = PFESPS_NO_TRAFFIC;
			s-&gt;timeout = PFTM_ESP_FIRST_PACKET;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			s-&gt;src.state = PFOTHERS_SINGLE;
			s-&gt;dst.state = PFOTHERS_NO_TRAFFIC;
			s-&gt;timeout = PFTM_OTHER_FIRST_PACKET;
		}

		s-&gt;creation = pf_time_second();
		s-&gt;expire = pf_time_second();

		<span class="enscript-keyword">if</span> (sn != NULL) {
			s-&gt;src_node = sn;
			s-&gt;src_node-&gt;states++;
			VERIFY(s-&gt;src_node-&gt;states != 0);
		}
		<span class="enscript-keyword">if</span> (nsn != NULL) {
			PF_ACPY(&amp;nsn-&gt;raddr, &amp;pd-&gt;naddr, af);
			s-&gt;nat_src_node = nsn;
			s-&gt;nat_src_node-&gt;states++;
			VERIFY(s-&gt;nat_src_node-&gt;states != 0);
		}
		<span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_TCP) {
			<span class="enscript-keyword">if</span> ((pd-&gt;flags &amp; PFDESC_TCP_NORM) &amp;&amp;
			    pf_normalize_tcp_init(m, off, pd, th, &amp;s-&gt;src,
			    &amp;s-&gt;dst)) {
				REASON_SET(&amp;reason, PFRES_MEMORY);
				pf_src_tree_remove_state(s);
				STATE_DEC_COUNTERS(s);
				pool_put(&amp;pf_state_pl, s);
				<span class="enscript-keyword">return</span> (PF_DROP);
			}
			<span class="enscript-keyword">if</span> ((pd-&gt;flags &amp; PFDESC_TCP_NORM) &amp;&amp; s-&gt;src.scrub &amp;&amp;
			    pf_normalize_tcp_stateful(m, off, pd, &amp;reason,
			    th, s, &amp;s-&gt;src, &amp;s-&gt;dst, &amp;rewrite)) {
				<span class="enscript-comment">/* This really shouldn't happen!!! */</span>
				DPFPRINTF(PF_DEBUG_URGENT,
				    (<span class="enscript-string">&quot;pf_normalize_tcp_stateful failed on &quot;</span>
				    <span class="enscript-string">&quot;first pkt&quot;</span>));
				pf_normalize_tcp_cleanup(s);
				pf_src_tree_remove_state(s);
				STATE_DEC_COUNTERS(s);
				pool_put(&amp;pf_state_pl, s);
				<span class="enscript-keyword">return</span> (PF_DROP);
			}
		}

		<span class="enscript-comment">/* allocate state key and import values from psk */</span>
		<span class="enscript-keyword">if</span> ((sk = pf_alloc_state_key(s, &amp;psk)) == NULL) {
			REASON_SET(&amp;reason, PFRES_MEMORY);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
		}

		pf_set_rt_ifp(s, saddr, af);	<span class="enscript-comment">/* needs s-&gt;state_key set */</span>

		m = pd-&gt;mp;

		<span class="enscript-keyword">if</span> (sk-&gt;app_state == 0) {
			<span class="enscript-keyword">switch</span> (pd-&gt;proto) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>: {
				u_int16_t dport = (direction == PF_OUT) ?
				    sk-&gt;ext_gwy.xport.port : sk-&gt;gwy.xport.port;

				<span class="enscript-keyword">if</span> (nr != NULL &amp;&amp;
				    ntohs(dport) == PF_PPTP_PORT) {
					<span class="enscript-type">struct</span> pf_app_state *as;

					as = pool_get(&amp;pf_app_state_pl,
					    PR_WAITOK);
					<span class="enscript-keyword">if</span> (!as) {
						REASON_SET(&amp;reason,
						    PFRES_MEMORY);
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
					}

					bzero(as, <span class="enscript-keyword">sizeof</span> (*as));
					as-&gt;handler = pf_pptp_handler;
					as-&gt;compare_lan_ext = 0;
					as-&gt;compare_ext_gwy = 0;
					as-&gt;u.pptp.grev1_state = 0;
					sk-&gt;app_state = as;
					(<span class="enscript-type">void</span>) hook_establish(&amp;s-&gt;unlink_hooks,
					    0, (hook_fn_t) pf_pptp_unlink, s);
				}
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>: {
				<span class="enscript-keyword">if</span> (nr != NULL &amp;&amp;
				    ntohs(uh-&gt;uh_sport) == PF_IKE_PORT &amp;&amp;
				    ntohs(uh-&gt;uh_dport) == PF_IKE_PORT) {
					<span class="enscript-type">struct</span> pf_app_state *as;

					as = pool_get(&amp;pf_app_state_pl,
					    PR_WAITOK);
					<span class="enscript-keyword">if</span> (!as) {
						REASON_SET(&amp;reason,
						    PFRES_MEMORY);
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
					}

					bzero(as, <span class="enscript-keyword">sizeof</span> (*as));
					as-&gt;compare_lan_ext = pf_ike_compare;
					as-&gt;compare_ext_gwy = pf_ike_compare;
					as-&gt;u.ike.cookie = ike.initiator_cookie;
					sk-&gt;app_state = as;
				}
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (pf_insert_state(BOUND_IFACE(r, kif), s)) {
			<span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_TCP)
				pf_normalize_tcp_cleanup(s);
			REASON_SET(&amp;reason, PFRES_STATEINS);
			pf_src_tree_remove_state(s);
			STATE_DEC_COUNTERS(s);
			pool_put(&amp;pf_state_pl, s);
			<span class="enscript-keyword">return</span> (PF_DROP);
		} <span class="enscript-keyword">else</span>
			*sm = s;
		<span class="enscript-keyword">if</span> (tag &gt; 0) {
			pf_tag_ref(tag);
			s-&gt;tag = tag;
		}
		<span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_TCP &amp;&amp;
		    (th-&gt;th_flags &amp; (TH_SYN|TH_ACK)) == TH_SYN &amp;&amp;
		    r-&gt;keep_state == PF_STATE_SYNPROXY) {
			<span class="enscript-type">int</span> ua = (sk-&gt;af_lan == sk-&gt;af_gwy) ? 1 : 0;
			s-&gt;src.state = PF_TCPS_PROXY_SRC;
			<span class="enscript-keyword">if</span> (nr != NULL) {
				<span class="enscript-keyword">if</span> (direction == PF_OUT) {
					pf_change_ap(direction, pd-&gt;mp, saddr,
					    &amp;th-&gt;th_sport, pd-&gt;ip_sum,
					    &amp;th-&gt;th_sum, &amp;pd-&gt;baddr,
					    bxport.port, 0, af, pd-&gt;af, ua);
					sxport.port = th-&gt;th_sport;
				} <span class="enscript-keyword">else</span> {
					pf_change_ap(direction, pd-&gt;mp, daddr,
					    &amp;th-&gt;th_dport, pd-&gt;ip_sum,
					    &amp;th-&gt;th_sum, &amp;pd-&gt;baddr,
					    bxport.port, 0, af, pd-&gt;af, ua);
					sxport.port = th-&gt;th_dport;
				}
			}
			s-&gt;src.seqhi = htonl(random());
			<span class="enscript-comment">/* Find mss option */</span>
			mss = pf_get_mss(m, off, th-&gt;th_off, af);
			mss = pf_calc_mss(saddr, af, mss);
			mss = pf_calc_mss(daddr, af, mss);
			s-&gt;src.mss = mss;
			pf_send_tcp(r, af, daddr, saddr, th-&gt;th_dport,
			    th-&gt;th_sport, s-&gt;src.seqhi, ntohl(th-&gt;th_seq) + 1,
			    TH_SYN|TH_ACK, 0, s-&gt;src.mss, 0, 1, 0, NULL, NULL);
			REASON_SET(&amp;reason, PFRES_SYNPROXY);
			<span class="enscript-keyword">return</span> (PF_SYNPROXY_DROP);
		}

		<span class="enscript-keyword">if</span> (sk-&gt;app_state &amp;&amp; sk-&gt;app_state-&gt;handler) {
			<span class="enscript-type">int</span> offx = off;

			<span class="enscript-keyword">switch</span> (pd-&gt;proto) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
				offx += th-&gt;th_off &lt;&lt; 2;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
				offx += pd-&gt;hdr.udp-&gt;uh_ulen &lt;&lt; 2;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-comment">/* ALG handlers only apply to TCP and UDP rules */</span>
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (offx &gt; off) {
				sk-&gt;app_state-&gt;handler(s, direction, offx,
				    pd, kif);
				<span class="enscript-keyword">if</span> (pd-&gt;lmw &lt; 0) {
					REASON_SET(&amp;reason, PFRES_MEMORY);
					<span class="enscript-keyword">return</span> (PF_DROP);
				}
				m = pd-&gt;mp;
			}
		}
	}

	<span class="enscript-comment">/* copy back packet headers if we performed NAT operations */</span>
	<span class="enscript-keyword">if</span> (rewrite) {
		<span class="enscript-keyword">if</span> (rewrite &lt; off + hdrlen)
			rewrite = off + hdrlen;

		m = pf_lazy_makewritable(pd, pd-&gt;mp, rewrite);
		<span class="enscript-keyword">if</span> (!m) {
			REASON_SET(&amp;reason, PFRES_MEMORY);
			<span class="enscript-keyword">return</span> (PF_DROP);
		}

		m_copyback(m, off, hdrlen, pd-&gt;hdr.any);
		<span class="enscript-keyword">if</span> (af == AF_INET6 &amp;&amp; pd-&gt;naf == AF_INET)
			<span class="enscript-keyword">return</span> pf_nat64_ipv6(m, off, pd);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (af == AF_INET  &amp;&amp; pd-&gt;naf == AF_INET6)
			<span class="enscript-keyword">return</span> pf_nat64_ipv4(m, off, pd);

	}

	<span class="enscript-keyword">return</span> (PF_PASS);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
<span class="enscript-comment">/*
 * When pf_test_dummynet() returns PF_PASS, the rule matching parameter &quot;rm&quot; 
 * remains unchanged, meaning the packet did not match a dummynet rule.
 * when the packet does match a dummynet rule, pf_test_dummynet() returns 
 * PF_PASS and zero out the mbuf rule as the packet is effectively siphoned 
 * out by dummynet.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_test_dummynet</span>(<span class="enscript-type">struct</span> pf_rule **rm, <span class="enscript-type">int</span> direction, <span class="enscript-type">struct</span> pfi_kif *kif, 
    <span class="enscript-type">struct</span> mbuf **m0, <span class="enscript-type">struct</span> pf_pdesc *pd, <span class="enscript-type">struct</span> ip_fw_args *fwa)
{
	<span class="enscript-type">struct</span> mbuf		*m = *m0;
	<span class="enscript-type">struct</span> pf_rule		*am = NULL;
	<span class="enscript-type">struct</span> pf_ruleset	*rsm = NULL;
	<span class="enscript-type">struct</span> pf_addr		*saddr = pd-&gt;src, *daddr = pd-&gt;dst;
	sa_family_t		 af = pd-&gt;af;
	<span class="enscript-type">struct</span> pf_rule		*r, *a = NULL;
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset = NULL;
	<span class="enscript-type">struct</span> tcphdr		*th = pd-&gt;hdr.tcp;
	u_short			 reason;
	<span class="enscript-type">int</span>			 hdrlen = 0;
	<span class="enscript-type">int</span>			 tag = -1;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		 rtableid = IFSCOPE_NONE;
	<span class="enscript-type">int</span>			 asd = 0;
	<span class="enscript-type">int</span>			 match = 0;
	u_int8_t		 icmptype = 0, icmpcode = 0;
	<span class="enscript-type">struct</span> ip_fw_args	dnflow;
	<span class="enscript-type">struct</span> pf_rule		*prev_matching_rule = fwa ? fwa-&gt;fwa_pf_rule : NULL;
	<span class="enscript-type">int</span>			found_prev_rule = (prev_matching_rule) ? 0 : 1;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!DUMMYNET_LOADED)
		<span class="enscript-keyword">return</span> (PF_PASS);
	
	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(pf_main_ruleset.rules[PF_RULESET_DUMMYNET].active.ptr))
		<span class="enscript-keyword">return</span> (PF_PASS);
	
	bzero(&amp;dnflow, <span class="enscript-keyword">sizeof</span>(dnflow));

	hdrlen = 0;

	<span class="enscript-comment">/* Fragments don't gave protocol headers */</span>
	<span class="enscript-keyword">if</span> (!(pd-&gt;flags &amp; PFDESC_IP_FRAG))	
		<span class="enscript-keyword">switch</span> (pd-&gt;proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
			dnflow.fwa_id.flags = pd-&gt;hdr.tcp-&gt;th_flags;
			dnflow.fwa_id.dst_port = ntohs(pd-&gt;hdr.tcp-&gt;th_dport);
			dnflow.fwa_id.src_port = ntohs(pd-&gt;hdr.tcp-&gt;th_sport);
			hdrlen = <span class="enscript-keyword">sizeof</span> (*th);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
			dnflow.fwa_id.dst_port = ntohs(pd-&gt;hdr.udp-&gt;uh_dport);
			dnflow.fwa_id.src_port = ntohs(pd-&gt;hdr.udp-&gt;uh_sport);
			hdrlen = <span class="enscript-keyword">sizeof</span> (*pd-&gt;hdr.udp);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
			<span class="enscript-keyword">if</span> (af != AF_INET)
				<span class="enscript-keyword">break</span>;
			hdrlen = ICMP_MINLEN;
			icmptype = pd-&gt;hdr.icmp-&gt;icmp_type;
			icmpcode = pd-&gt;hdr.icmp-&gt;icmp_code;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
			<span class="enscript-keyword">if</span> (af != AF_INET6)
				<span class="enscript-keyword">break</span>;
			hdrlen = <span class="enscript-keyword">sizeof</span> (*pd-&gt;hdr.icmp6);
			icmptype = pd-&gt;hdr.icmp6-&gt;icmp6_type;
			icmpcode = pd-&gt;hdr.icmp6-&gt;icmp6_code;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>:
			<span class="enscript-keyword">if</span> (pd-&gt;proto_variant == PF_GRE_PPTP_VARIANT)
				hdrlen = <span class="enscript-keyword">sizeof</span> (*pd-&gt;hdr.grev1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
			hdrlen = <span class="enscript-keyword">sizeof</span> (*pd-&gt;hdr.esp);
			<span class="enscript-keyword">break</span>;
		}

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_DUMMYNET].active.ptr);

	<span class="enscript-keyword">while</span> (r != NULL) {
		r-&gt;evaluations++;
		<span class="enscript-keyword">if</span> (pfi_kif_match(r-&gt;kif, kif) == r-&gt;ifnot)
			r = r-&gt;skip[PF_SKIP_IFP].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;direction &amp;&amp; r-&gt;direction != direction)
			r = r-&gt;skip[PF_SKIP_DIR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;af &amp;&amp; r-&gt;af != af)
			r = r-&gt;skip[PF_SKIP_AF].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;proto &amp;&amp; r-&gt;proto != pd-&gt;proto)
			r = r-&gt;skip[PF_SKIP_PROTO].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PF_MISMATCHAW(&amp;r-&gt;src.addr, saddr, af,
		    r-&gt;src.neg, kif))
			r = r-&gt;skip[PF_SKIP_SRC_ADDR].ptr;
		<span class="enscript-comment">/* tcp/udp only. port_op always 0 in other cases */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;proto == pd-&gt;proto &amp;&amp; 
		    (r-&gt;proto == IPPROTO_TCP || r-&gt;proto == IPPROTO_UDP) &amp;&amp;
		    ((pd-&gt;flags &amp; PFDESC_IP_FRAG) ||
		    ((r-&gt;src.xport.range.op &amp;&amp;
		    !pf_match_port(r-&gt;src.xport.range.op,
		    r-&gt;src.xport.range.port[0], r-&gt;src.xport.range.port[1],
		    th-&gt;th_sport)))))
			r = r-&gt;skip[PF_SKIP_SRC_PORT].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PF_MISMATCHAW(&amp;r-&gt;dst.addr, daddr, af,
		    r-&gt;dst.neg, NULL))
			r = r-&gt;skip[PF_SKIP_DST_ADDR].ptr;
		<span class="enscript-comment">/* tcp/udp only. port_op always 0 in other cases */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;proto == pd-&gt;proto &amp;&amp;
		    (r-&gt;proto == IPPROTO_TCP || r-&gt;proto == IPPROTO_UDP) &amp;&amp;
		    r-&gt;dst.xport.range.op &amp;&amp;
		    ((pd-&gt;flags &amp; PFDESC_IP_FRAG) ||
		    !pf_match_port(r-&gt;dst.xport.range.op,
		    r-&gt;dst.xport.range.port[0], r-&gt;dst.xport.range.port[1],
		    th-&gt;th_dport)))
			r = r-&gt;skip[PF_SKIP_DST_PORT].ptr;
		<span class="enscript-comment">/* icmp only. type always 0 in other cases */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;type &amp;&amp; 
			((pd-&gt;flags &amp; PFDESC_IP_FRAG) ||
			r-&gt;type != icmptype + 1))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-comment">/* icmp only. type always 0 in other cases */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;code &amp;&amp; 
			((pd-&gt;flags &amp; PFDESC_IP_FRAG) ||
			r-&gt;code != icmpcode + 1))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;tos &amp;&amp; !(r-&gt;tos == pd-&gt;tos))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;rule_flag &amp; PFRULE_FRAGMENT)
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_TCP &amp;&amp;
		    ((pd-&gt;flags &amp; PFDESC_IP_FRAG) ||
		    (r-&gt;flagset &amp; th-&gt;th_flags) != r-&gt;flags))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;prob &amp;&amp; r-&gt;prob &lt;= (RandomULong() % (UINT_MAX - 1) + 1))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;match_tag &amp;&amp; !pf_match_tag(m, r, pd-&gt;pf_mtag, &amp;tag))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* 
			 * Need to go past the previous dummynet matching rule	
			 */</span>
			<span class="enscript-keyword">if</span> (r-&gt;anchor == NULL) {
				<span class="enscript-keyword">if</span> (found_prev_rule) {
					<span class="enscript-keyword">if</span> (r-&gt;tag)
						tag = r-&gt;tag;
					<span class="enscript-keyword">if</span> (PF_RTABLEID_IS_VALID(r-&gt;rtableid))
						rtableid = r-&gt;rtableid;
					match = 1;
					*rm = r;
					am = a;
					rsm = ruleset;
					<span class="enscript-keyword">if</span> ((*rm)-&gt;quick)
						<span class="enscript-keyword">break</span>;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r == prev_matching_rule) {
					found_prev_rule = 1;
				}
				r = TAILQ_NEXT(r, entries);
			} <span class="enscript-keyword">else</span> {
				pf_step_into_anchor(&amp;asd, &amp;ruleset,
				    PF_RULESET_DUMMYNET, &amp;r, &amp;a, &amp;match);
			}
		}
		<span class="enscript-keyword">if</span> (r == NULL &amp;&amp; pf_step_out_of_anchor(&amp;asd, &amp;ruleset,
		    PF_RULESET_DUMMYNET, &amp;r, &amp;a, &amp;match))
			<span class="enscript-keyword">break</span>;
	}
	r = *rm;
	a = am;
	ruleset = rsm;

	<span class="enscript-keyword">if</span> (!match)
		<span class="enscript-keyword">return</span> (PF_PASS);

	REASON_SET(&amp;reason, PFRES_DUMMYNET);

	<span class="enscript-keyword">if</span> (r-&gt;log) {
		PFLOG_PACKET(kif, h, m, af, direction, reason, r,
		    a, ruleset, pd);
	}

	<span class="enscript-keyword">if</span> (r-&gt;action == PF_NODUMMYNET) {
		<span class="enscript-type">int</span> dirndx = (direction == PF_OUT);
		
		r-&gt;packets[dirndx]++;
		r-&gt;bytes[dirndx] += pd-&gt;tot_len;

		<span class="enscript-keyword">return</span> (PF_PASS);
	}
	<span class="enscript-keyword">if</span> (pf_tag_packet(m, pd-&gt;pf_mtag, tag, rtableid, pd)) {
		REASON_SET(&amp;reason, PFRES_MEMORY);

		<span class="enscript-keyword">return</span> (PF_DROP);
	}

	<span class="enscript-keyword">if</span> (r-&gt;dnpipe &amp;&amp; ip_dn_io_ptr != NULL) {
		<span class="enscript-type">int</span> dirndx = (direction == PF_OUT);
		
		r-&gt;packets[dirndx]++;
		r-&gt;bytes[dirndx] += pd-&gt;tot_len;
		
		dnflow.fwa_cookie = r-&gt;dnpipe;
		dnflow.fwa_pf_rule = r;
		dnflow.fwa_id.proto = pd-&gt;proto;
		dnflow.fwa_flags = r-&gt;dntype;
		<span class="enscript-keyword">switch</span> (af) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				dnflow.fwa_id.addr_type = 4;
				dnflow.fwa_id.src_ip = ntohl(saddr-&gt;v4.s_addr);
				dnflow.fwa_id.dst_ip = ntohl(daddr-&gt;v4.s_addr);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				dnflow.fwa_id.addr_type = 6;
				dnflow.fwa_id.src_ip6 = saddr-&gt;v6;
				dnflow.fwa_id.dst_ip6 = saddr-&gt;v6;
				<span class="enscript-keyword">break</span>;
			}

		<span class="enscript-keyword">if</span> (fwa != NULL) {
			dnflow.fwa_oif = fwa-&gt;fwa_oif;
			dnflow.fwa_oflags = fwa-&gt;fwa_oflags;
			<span class="enscript-comment">/*
			 * Note that fwa_ro, fwa_dst and fwa_ipoa are 
			 * actually in a union so the following does work  
			 * for both IPv4 and IPv6
			 */</span>
			dnflow.fwa_ro = fwa-&gt;fwa_ro;
			dnflow.fwa_dst = fwa-&gt;fwa_dst;
			dnflow.fwa_ipoa = fwa-&gt;fwa_ipoa;
			dnflow.fwa_ro6_pmtu = fwa-&gt;fwa_ro6_pmtu;
			dnflow.fwa_origifp = fwa-&gt;fwa_origifp;
			dnflow.fwa_mtu = fwa-&gt;fwa_mtu;
			dnflow.fwa_alwaysfrag = fwa-&gt;fwa_alwaysfrag;
			dnflow.fwa_unfragpartlen = fwa-&gt;fwa_unfragpartlen;
			dnflow.fwa_exthdrs = fwa-&gt;fwa_exthdrs;
		}
		
		<span class="enscript-keyword">if</span> (af == AF_INET) {
			<span class="enscript-type">struct</span> ip *iphdr = mtod(m, <span class="enscript-type">struct</span> ip *);
			NTOHS(iphdr-&gt;ip_len);
			NTOHS(iphdr-&gt;ip_off);
		}
		<span class="enscript-comment">/*
		 * Don't need to unlock pf_lock as NET_THREAD_HELD_PF 
		 * allows for recursive behavior
		 */</span>
		ip_dn_io_ptr(m,
			dnflow.fwa_cookie,
			af == AF_INET ? 
				direction == PF_IN ? DN_TO_IP_IN : DN_TO_IP_OUT :
				direction == PF_IN ? DN_TO_IP6_IN : DN_TO_IP6_OUT,
			&amp;dnflow, DN_CLIENT_PF);
		
		<span class="enscript-comment">/*
		 * The packet is siphoned out by dummynet so return a NULL 
		 * mbuf so the caller can still return success.
		 */</span>
		*m0 = NULL;
		 
		<span class="enscript-keyword">return</span> (PF_PASS);
	}

	<span class="enscript-keyword">return</span> (PF_PASS);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_test_fragment</span>(<span class="enscript-type">struct</span> pf_rule **rm, <span class="enscript-type">int</span> direction, <span class="enscript-type">struct</span> pfi_kif *kif,
    <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">void</span> *h, <span class="enscript-type">struct</span> pf_pdesc *pd, <span class="enscript-type">struct</span> pf_rule **am,
    <span class="enscript-type">struct</span> pf_ruleset **rsm)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">h</span>)
	<span class="enscript-type">struct</span> pf_rule		*r, *a = NULL;
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset = NULL;
	sa_family_t		 af = pd-&gt;af;
	u_short			 reason;
	<span class="enscript-type">int</span>			 tag = -1;
	<span class="enscript-type">int</span>			 asd = 0;
	<span class="enscript-type">int</span>			 match = 0;

	r = TAILQ_FIRST(pf_main_ruleset.rules[PF_RULESET_FILTER].active.ptr);
	<span class="enscript-keyword">while</span> (r != NULL) {
		r-&gt;evaluations++;
		<span class="enscript-keyword">if</span> (pfi_kif_match(r-&gt;kif, kif) == r-&gt;ifnot)
			r = r-&gt;skip[PF_SKIP_IFP].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;direction &amp;&amp; r-&gt;direction != direction)
			r = r-&gt;skip[PF_SKIP_DIR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;af &amp;&amp; r-&gt;af != af)
			r = r-&gt;skip[PF_SKIP_AF].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;proto &amp;&amp; r-&gt;proto != pd-&gt;proto)
			r = r-&gt;skip[PF_SKIP_PROTO].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PF_MISMATCHAW(&amp;r-&gt;src.addr, pd-&gt;src, af,
		    r-&gt;src.neg, kif))
			r = r-&gt;skip[PF_SKIP_SRC_ADDR].ptr;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PF_MISMATCHAW(&amp;r-&gt;dst.addr, pd-&gt;dst, af,
		    r-&gt;dst.neg, NULL))
			r = r-&gt;skip[PF_SKIP_DST_ADDR].ptr;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((r-&gt;rule_flag &amp; PFRULE_TOS) &amp;&amp; r-&gt;tos &amp;&amp;
		    !(r-&gt;tos &amp; pd-&gt;tos))
			r = TAILQ_NEXT(r, entries);
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((r-&gt;rule_flag &amp; PFRULE_DSCP) &amp;&amp; r-&gt;tos &amp;&amp;
		    !(r-&gt;tos &amp; (pd-&gt;tos &amp; DSCP_MASK)))
			r = TAILQ_NEXT(r, entries);
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((r-&gt;rule_flag &amp; PFRULE_SC) &amp;&amp; r-&gt;tos &amp;&amp;
		    ((r-&gt;tos &amp; SCIDX_MASK) != pd-&gt;sc))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;os_fingerprint != PF_OSFP_ANY)
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_UDP &amp;&amp;
		    (r-&gt;src.xport.range.op || r-&gt;dst.xport.range.op))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pd-&gt;proto == IPPROTO_TCP &amp;&amp;
		    (r-&gt;src.xport.range.op || r-&gt;dst.xport.range.op ||
		    r-&gt;flagset))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((pd-&gt;proto == IPPROTO_ICMP ||
		    pd-&gt;proto == IPPROTO_ICMPV6) &amp;&amp;
		    (r-&gt;type || r-&gt;code))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;prob &amp;&amp; r-&gt;prob &lt;= (RandomULong() % (UINT_MAX - 1) + 1))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;match_tag &amp;&amp; !pf_match_tag(m, r, pd-&gt;pf_mtag, &amp;tag))
			r = TAILQ_NEXT(r, entries);
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (r-&gt;anchor == NULL) {
				match = 1;
				*rm = r;
				*am = a;
				*rsm = ruleset;
				<span class="enscript-keyword">if</span> ((*rm)-&gt;quick)
					<span class="enscript-keyword">break</span>;
				r = TAILQ_NEXT(r, entries);
			} <span class="enscript-keyword">else</span>
				pf_step_into_anchor(&amp;asd, &amp;ruleset,
				    PF_RULESET_FILTER, &amp;r, &amp;a, &amp;match);
		}
		<span class="enscript-keyword">if</span> (r == NULL &amp;&amp; pf_step_out_of_anchor(&amp;asd, &amp;ruleset,
		    PF_RULESET_FILTER, &amp;r, &amp;a, &amp;match))
			<span class="enscript-keyword">break</span>;
	}
	r = *rm;
	a = *am;
	ruleset = *rsm;

	REASON_SET(&amp;reason, PFRES_MATCH);

	<span class="enscript-keyword">if</span> (r-&gt;log)
		PFLOG_PACKET(kif, h, m, af, direction, reason, r, a, ruleset,
		    pd);

	<span class="enscript-keyword">if</span> (r-&gt;action != PF_PASS)
		<span class="enscript-keyword">return</span> (PF_DROP);

	<span class="enscript-keyword">if</span> (pf_tag_packet(m, pd-&gt;pf_mtag, tag, -1, NULL)) {
		REASON_SET(&amp;reason, PFRES_MEMORY);
		<span class="enscript-keyword">return</span> (PF_DROP);
	}

	<span class="enscript-keyword">return</span> (PF_PASS);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_pptp_handler</span>(<span class="enscript-type">struct</span> pf_state *s, <span class="enscript-type">int</span> direction, <span class="enscript-type">int</span> off,
    <span class="enscript-type">struct</span> pf_pdesc *pd, <span class="enscript-type">struct</span> pfi_kif *kif)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">direction</span>)
	<span class="enscript-type">struct</span> tcphdr *th;
	<span class="enscript-type">struct</span> pf_pptp_state *pptps;
	<span class="enscript-type">struct</span> pf_pptp_ctrl_msg cm;
	size_t plen;
	<span class="enscript-type">struct</span> pf_state *gs;
	u_int16_t ct;
	u_int16_t *pac_call_id;
	u_int16_t *pns_call_id;
	u_int16_t *spoof_call_id;
	u_int8_t *pac_state;
	u_int8_t *pns_state;
	<span class="enscript-type">enum</span> { PF_PPTP_PASS, PF_PPTP_INSERT_GRE, PF_PPTP_REMOVE_GRE } op;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> pf_state_key *sk;
	<span class="enscript-type">struct</span> pf_state_key *gsk;
	<span class="enscript-type">struct</span> pf_app_state *gas;

	sk = s-&gt;state_key;
	pptps = &amp;sk-&gt;app_state-&gt;u.pptp;
	gs = pptps-&gt;grev1_state;

	<span class="enscript-keyword">if</span> (gs)
		gs-&gt;expire = pf_time_second();

	m = pd-&gt;mp;
	plen = min(<span class="enscript-keyword">sizeof</span> (cm), m-&gt;m_pkthdr.len - off);
	<span class="enscript-keyword">if</span> (plen &lt; PF_PPTP_CTRL_MSG_MINSIZE)
		<span class="enscript-keyword">return</span>;

	m_copydata(m, off, plen, &amp;cm);

	<span class="enscript-keyword">if</span> (ntohl(cm.hdr.magic) != PF_PPTP_MAGIC_NUMBER)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (ntohs(cm.hdr.type) != 1)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (!gs) {
		gs = pool_get(&amp;pf_state_pl, PR_WAITOK);
		<span class="enscript-keyword">if</span> (!gs)
			<span class="enscript-keyword">return</span>;

		memcpy(gs, s, <span class="enscript-keyword">sizeof</span> (*gs));

		memset(&amp;gs-&gt;entry_id, 0, <span class="enscript-keyword">sizeof</span> (gs-&gt;entry_id));
		memset(&amp;gs-&gt;entry_list, 0, <span class="enscript-keyword">sizeof</span> (gs-&gt;entry_list));

		TAILQ_INIT(&amp;gs-&gt;unlink_hooks);
		gs-&gt;rt_kif = NULL;
		gs-&gt;creation = 0;
		gs-&gt;pfsync_time = 0;
		gs-&gt;packets[0] = gs-&gt;packets[1] = 0;
		gs-&gt;bytes[0] = gs-&gt;bytes[1] = 0;
		gs-&gt;timeout = PFTM_UNLINKED;
		gs-&gt;id = gs-&gt;creatorid = 0;
		gs-&gt;src.state = gs-&gt;dst.state = PFGRE1S_NO_TRAFFIC;
		gs-&gt;src.scrub = gs-&gt;dst.scrub = 0;

		gas = pool_get(&amp;pf_app_state_pl, PR_NOWAIT);
		<span class="enscript-keyword">if</span> (!gas) {
			pool_put(&amp;pf_state_pl, gs);
			<span class="enscript-keyword">return</span>;
		}

		gsk = pf_alloc_state_key(gs, NULL);
		<span class="enscript-keyword">if</span> (!gsk) {
			pool_put(&amp;pf_app_state_pl, gas);
			pool_put(&amp;pf_state_pl, gs);
			<span class="enscript-keyword">return</span>;
		}

		memcpy(&amp;gsk-&gt;lan, &amp;sk-&gt;lan, <span class="enscript-keyword">sizeof</span> (gsk-&gt;lan));
		memcpy(&amp;gsk-&gt;gwy, &amp;sk-&gt;gwy, <span class="enscript-keyword">sizeof</span> (gsk-&gt;gwy));
		memcpy(&amp;gsk-&gt;ext_lan, &amp;sk-&gt;ext_lan, <span class="enscript-keyword">sizeof</span> (gsk-&gt;ext_lan));
		memcpy(&amp;gsk-&gt;ext_gwy, &amp;sk-&gt;ext_gwy, <span class="enscript-keyword">sizeof</span> (gsk-&gt;ext_gwy));
		gsk-&gt;af_lan = sk-&gt;af_lan;
		gsk-&gt;af_gwy = sk-&gt;af_gwy;
		gsk-&gt;proto = IPPROTO_GRE;
		gsk-&gt;proto_variant = PF_GRE_PPTP_VARIANT;
		gsk-&gt;app_state = gas;
		gsk-&gt;lan.xport.call_id = 0;
		gsk-&gt;gwy.xport.call_id = 0;
		gsk-&gt;ext_lan.xport.call_id = 0;
		gsk-&gt;ext_gwy.xport.call_id = 0;
		gsk-&gt;flowsrc = FLOWSRC_PF;
		gsk-&gt;flowhash = pf_calc_state_key_flowhash(gsk);
		memset(gas, 0, <span class="enscript-keyword">sizeof</span> (*gas));
		gas-&gt;u.grev1.pptp_state = s;
		STATE_INC_COUNTERS(gs);
		pptps-&gt;grev1_state = gs;
		(<span class="enscript-type">void</span>) hook_establish(&amp;gs-&gt;unlink_hooks, 0,
		    (hook_fn_t) pf_grev1_unlink, gs);
	} <span class="enscript-keyword">else</span> {
		gsk = gs-&gt;state_key;
	}

	<span class="enscript-keyword">switch</span> (sk-&gt;direction) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_IN</span>:
		pns_call_id = &amp;gsk-&gt;ext_lan.xport.call_id;
		pns_state = &amp;gs-&gt;dst.state;
		pac_call_id = &amp;gsk-&gt;lan.xport.call_id;
		pac_state = &amp;gs-&gt;src.state;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_OUT</span>:
		pns_call_id = &amp;gsk-&gt;lan.xport.call_id;
		pns_state = &amp;gs-&gt;src.state;
		pac_call_id = &amp;gsk-&gt;ext_lan.xport.call_id;
		pac_state = &amp;gs-&gt;dst.state;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		DPFPRINTF(PF_DEBUG_URGENT,
		    (<span class="enscript-string">&quot;pf_pptp_handler: bad directional!\n&quot;</span>));
		<span class="enscript-keyword">return</span>;
	}

	spoof_call_id = 0;
	op = PF_PPTP_PASS;

	ct = ntohs(cm.ctrl.type);

	<span class="enscript-keyword">switch</span> (ct) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_PPTP_CTRL_TYPE_CALL_OUT_REQ</span>:
		*pns_call_id = cm.msg.call_out_req.call_id;
		*pns_state = PFGRE1S_INITIATING;
		<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr &amp;&amp; pns_call_id == &amp;gsk-&gt;lan.xport.call_id)
			spoof_call_id = &amp;cm.msg.call_out_req.call_id;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_PPTP_CTRL_TYPE_CALL_OUT_RPY</span>:
		*pac_call_id = cm.msg.call_out_rpy.call_id;
		<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr)
			spoof_call_id =
			    (pac_call_id == &amp;gsk-&gt;lan.xport.call_id) ?
			    &amp;cm.msg.call_out_rpy.call_id :
			    &amp;cm.msg.call_out_rpy.peer_call_id;
		<span class="enscript-keyword">if</span> (gs-&gt;timeout == PFTM_UNLINKED) {
			*pac_state = PFGRE1S_INITIATING;
			op = PF_PPTP_INSERT_GRE;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_PPTP_CTRL_TYPE_CALL_IN_1ST</span>:
		*pns_call_id = cm.msg.call_in_1st.call_id;
		*pns_state = PFGRE1S_INITIATING;
		<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr &amp;&amp; pns_call_id == &amp;gsk-&gt;lan.xport.call_id)
			spoof_call_id = &amp;cm.msg.call_in_1st.call_id;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_PPTP_CTRL_TYPE_CALL_IN_2ND</span>:
		*pac_call_id = cm.msg.call_in_2nd.call_id;
		*pac_state = PFGRE1S_INITIATING;
		<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr)
			spoof_call_id =
			    (pac_call_id == &amp;gsk-&gt;lan.xport.call_id) ?
			    &amp;cm.msg.call_in_2nd.call_id :
			    &amp;cm.msg.call_in_2nd.peer_call_id;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_PPTP_CTRL_TYPE_CALL_IN_3RD</span>:
		<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr &amp;&amp; pns_call_id == &amp;gsk-&gt;lan.xport.call_id)
			spoof_call_id = &amp;cm.msg.call_in_3rd.call_id;
		<span class="enscript-keyword">if</span> (cm.msg.call_in_3rd.call_id != *pns_call_id) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (gs-&gt;timeout == PFTM_UNLINKED)
			op = PF_PPTP_INSERT_GRE;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_PPTP_CTRL_TYPE_CALL_CLR</span>:
		<span class="enscript-keyword">if</span> (cm.msg.call_clr.call_id != *pns_call_id)
			op = PF_PPTP_REMOVE_GRE;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_PPTP_CTRL_TYPE_CALL_DISC</span>:
		<span class="enscript-keyword">if</span> (cm.msg.call_clr.call_id != *pac_call_id)
			op = PF_PPTP_REMOVE_GRE;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_PPTP_CTRL_TYPE_ERROR</span>:
		<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr &amp;&amp; pns_call_id == &amp;gsk-&gt;lan.xport.call_id)
			spoof_call_id = &amp;cm.msg.error.peer_call_id;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_PPTP_CTRL_TYPE_SET_LINKINFO</span>:
		<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr &amp;&amp; pac_call_id == &amp;gsk-&gt;lan.xport.call_id)
			spoof_call_id = &amp;cm.msg.set_linkinfo.peer_call_id;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		op = PF_PPTP_PASS;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (!gsk-&gt;gwy.xport.call_id &amp;&amp; gsk-&gt;lan.xport.call_id) {
		gsk-&gt;gwy.xport.call_id = gsk-&gt;lan.xport.call_id;
		<span class="enscript-keyword">if</span> (spoof_call_id) {
			u_int16_t call_id = 0;
			<span class="enscript-type">int</span> n = 0;
			<span class="enscript-type">struct</span> pf_state_key_cmp key;

			key.af_gwy = gsk-&gt;af_gwy;
			key.proto = IPPROTO_GRE;
			key.proto_variant = PF_GRE_PPTP_VARIANT;
			PF_ACPY(&amp;key.gwy.addr, &amp;gsk-&gt;gwy.addr, key.af_gwy);
			PF_ACPY(&amp;key.ext_gwy.addr, &amp;gsk-&gt;ext_gwy.addr, key.af_gwy);
			key.gwy.xport.call_id = gsk-&gt;gwy.xport.call_id;
			key.ext_gwy.xport.call_id = gsk-&gt;ext_gwy.xport.call_id;
			<span class="enscript-keyword">do</span> {
				call_id = htonl(random());
			} <span class="enscript-keyword">while</span> (!call_id);

			<span class="enscript-keyword">while</span> (pf_find_state_all(&amp;key, PF_IN, 0)) {
				call_id = ntohs(call_id);
				--call_id;
				<span class="enscript-keyword">if</span> (--call_id == 0) call_id = 0xffff;
				call_id = htons(call_id);

				key.gwy.xport.call_id = call_id;

				<span class="enscript-keyword">if</span> (++n &gt; 65535) {
					DPFPRINTF(PF_DEBUG_URGENT,
					    (<span class="enscript-string">&quot;pf_pptp_handler: failed to spoof &quot;</span>
					    <span class="enscript-string">&quot;call id\n&quot;</span>));
					key.gwy.xport.call_id = 0;
					<span class="enscript-keyword">break</span>;
				}
			}

			gsk-&gt;gwy.xport.call_id = call_id;
		}
	}

	th = pd-&gt;hdr.tcp;

	<span class="enscript-keyword">if</span> (spoof_call_id &amp;&amp; gsk-&gt;lan.xport.call_id != gsk-&gt;gwy.xport.call_id) {
		<span class="enscript-keyword">if</span> (*spoof_call_id == gsk-&gt;gwy.xport.call_id) {
			*spoof_call_id = gsk-&gt;lan.xport.call_id;
			th-&gt;th_sum = pf_cksum_fixup(th-&gt;th_sum,
			    gsk-&gt;gwy.xport.call_id, gsk-&gt;lan.xport.call_id, 0);
		} <span class="enscript-keyword">else</span> {
			*spoof_call_id = gsk-&gt;gwy.xport.call_id;
			th-&gt;th_sum = pf_cksum_fixup(th-&gt;th_sum,
			    gsk-&gt;lan.xport.call_id, gsk-&gt;gwy.xport.call_id, 0);
		}

		m = pf_lazy_makewritable(pd, m, off + plen);
		<span class="enscript-keyword">if</span> (!m) {
			pptps-&gt;grev1_state = NULL;
			STATE_DEC_COUNTERS(gs);
			pool_put(&amp;pf_state_pl, gs);
			<span class="enscript-keyword">return</span>;
		}
		m_copyback(m, off, plen, &amp;cm);
	}

	<span class="enscript-keyword">switch</span> (op) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_PPTP_REMOVE_GRE</span>:
		gs-&gt;timeout = PFTM_PURGE;
		gs-&gt;src.state = gs-&gt;dst.state = PFGRE1S_NO_TRAFFIC;
		gsk-&gt;lan.xport.call_id = 0;
		gsk-&gt;gwy.xport.call_id = 0;
		gsk-&gt;ext_lan.xport.call_id = 0;
		gsk-&gt;ext_gwy.xport.call_id = 0;
		gs-&gt;id = gs-&gt;creatorid = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_PPTP_INSERT_GRE</span>:
		gs-&gt;creation = pf_time_second();
		gs-&gt;expire = pf_time_second();
		gs-&gt;timeout = PFTM_TCP_ESTABLISHED;
		<span class="enscript-keyword">if</span> (gs-&gt;src_node != NULL) {
			++gs-&gt;src_node-&gt;states;
			VERIFY(gs-&gt;src_node-&gt;states != 0);
		}
		<span class="enscript-keyword">if</span> (gs-&gt;nat_src_node != NULL) {
			++gs-&gt;nat_src_node-&gt;states;
			VERIFY(gs-&gt;nat_src_node-&gt;states != 0);
		}
		pf_set_rt_ifp(gs, &amp;sk-&gt;lan.addr, sk-&gt;af_lan);
		<span class="enscript-keyword">if</span> (pf_insert_state(BOUND_IFACE(s-&gt;rule.ptr, kif), gs)) {

			<span class="enscript-comment">/*
			 * &lt;<a href="mailto:jhw@apple.com">jhw@apple.com</a>&gt;
			 * FIX ME: insertion can fail when multiple PNS
			 * behind the same NAT open calls to the same PAC
			 * simultaneously because spoofed call ID numbers
			 * are chosen before states are inserted.  This is
			 * hard to fix and happens infrequently enough that
			 * users will normally try again and this ALG will
			 * succeed.  Failures are expected to be rare enough
			 * that fixing this is a low priority.
			 */</span>
			pptps-&gt;grev1_state = NULL;
			pd-&gt;lmw = -1;	<span class="enscript-comment">/* Force PF_DROP on PFRES_MEMORY */</span>
			pf_src_tree_remove_state(gs);
			STATE_DEC_COUNTERS(gs);
			pool_put(&amp;pf_state_pl, gs);
			DPFPRINTF(PF_DEBUG_URGENT, (<span class="enscript-string">&quot;pf_pptp_handler: error &quot;</span>
			    <span class="enscript-string">&quot;inserting GREv1 state.\n&quot;</span>));
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_pptp_unlink</span>(<span class="enscript-type">struct</span> pf_state *s)
{
	<span class="enscript-type">struct</span> pf_app_state *as = s-&gt;state_key-&gt;app_state;
	<span class="enscript-type">struct</span> pf_state *grev1s = as-&gt;u.pptp.grev1_state;

	<span class="enscript-keyword">if</span> (grev1s) {
		<span class="enscript-type">struct</span> pf_app_state *gas = grev1s-&gt;state_key-&gt;app_state;

		<span class="enscript-keyword">if</span> (grev1s-&gt;timeout &lt; PFTM_MAX)
			grev1s-&gt;timeout = PFTM_PURGE;
		gas-&gt;u.grev1.pptp_state = NULL;
		as-&gt;u.pptp.grev1_state = NULL;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_grev1_unlink</span>(<span class="enscript-type">struct</span> pf_state *s)
{
	<span class="enscript-type">struct</span> pf_app_state *as = s-&gt;state_key-&gt;app_state;
	<span class="enscript-type">struct</span> pf_state *pptps = as-&gt;u.grev1.pptp_state;

	<span class="enscript-keyword">if</span> (pptps) {
		<span class="enscript-type">struct</span> pf_app_state *pas = pptps-&gt;state_key-&gt;app_state;

		pas-&gt;u.pptp.grev1_state = NULL;
		as-&gt;u.grev1.pptp_state = NULL;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_ike_compare</span>(<span class="enscript-type">struct</span> pf_app_state *a, <span class="enscript-type">struct</span> pf_app_state *b)
{
	int64_t d = a-&gt;u.ike.cookie - b-&gt;u.ike.cookie;
	<span class="enscript-keyword">return</span> ((d &gt; 0) ? 1 : ((d &lt; 0) ? -1 : 0));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_do_nat64</span>(<span class="enscript-type">struct</span> pf_state_key *sk, <span class="enscript-type">struct</span> pf_pdesc *pd, <span class="enscript-type">struct</span> mbuf *m,
	    <span class="enscript-type">int</span> off)
{
	<span class="enscript-keyword">if</span> (pd-&gt;af == AF_INET) {
		<span class="enscript-keyword">if</span> (pd-&gt;af != sk-&gt;af_lan) {
			pd-&gt;ndaddr = sk-&gt;lan.addr;
			pd-&gt;naddr = sk-&gt;ext_lan.addr;
		} <span class="enscript-keyword">else</span> {
			pd-&gt;naddr = sk-&gt;gwy.addr;
			pd-&gt;ndaddr = sk-&gt;ext_gwy.addr;
		}
		<span class="enscript-keyword">return</span> (pf_nat64_ipv4(m, off, pd));
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pd-&gt;af == AF_INET6) {
		<span class="enscript-keyword">if</span> (pd-&gt;af != sk-&gt;af_lan) {
			pd-&gt;ndaddr = sk-&gt;lan.addr;
			pd-&gt;naddr = sk-&gt;ext_lan.addr;
			} <span class="enscript-keyword">else</span> {
				pd-&gt;naddr = sk-&gt;gwy.addr;
				pd-&gt;ndaddr = sk-&gt;ext_gwy.addr;
			}
			<span class="enscript-keyword">return</span> (pf_nat64_ipv6(m, off, pd));
	}
	<span class="enscript-keyword">return</span> (PF_DROP);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_test_state_tcp</span>(<span class="enscript-type">struct</span> pf_state **state, <span class="enscript-type">int</span> direction, <span class="enscript-type">struct</span> pfi_kif *kif,
    <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">void</span> *h, <span class="enscript-type">struct</span> pf_pdesc *pd,
    u_short *reason)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">h</span>)
	<span class="enscript-type">struct</span> pf_state_key_cmp	 key;
	<span class="enscript-type">struct</span> tcphdr		*th = pd-&gt;hdr.tcp;
	u_int16_t		 win = ntohs(th-&gt;th_win);
	u_int32_t		 ack, end, seq, orig_seq;
	u_int8_t		 sws, dws;
	<span class="enscript-type">int</span>			 ackskew;
	<span class="enscript-type">int</span>			 copyback = 0;
	<span class="enscript-type">struct</span> pf_state_peer	*src, *dst;
	<span class="enscript-type">struct</span> pf_state_key	*sk;

	key.app_state = 0;
	key.proto = IPPROTO_TCP;
	key.af_lan = key.af_gwy = pd-&gt;af;

	<span class="enscript-comment">/*
	 * For NAT64 the first time rule search and state creation
	 * is done on the incoming side only.
	 * Once the state gets created, NAT64's LAN side (ipv6) will
	 * not be able to find the state in ext-gwy tree as that normally
	 * is intended to be looked up for incoming traffic from the
	 * WAN side.
	 * Therefore to handle NAT64 case we init keys here for both
	 * lan-ext as well as ext-gwy trees.
	 * In the state lookup we attempt a lookup on both trees if
	 * first one does not return any result and return a match if
	 * the match state's was created by NAT64 rule.
	 */</span>
	PF_ACPY(&amp;key.ext_gwy.addr, pd-&gt;src, key.af_gwy);
	PF_ACPY(&amp;key.gwy.addr, pd-&gt;dst, key.af_gwy);
	key.ext_gwy.xport.port = th-&gt;th_sport;
	key.gwy.xport.port = th-&gt;th_dport;

	PF_ACPY(&amp;key.lan.addr, pd-&gt;src, key.af_lan);
	PF_ACPY(&amp;key.ext_lan.addr, pd-&gt;dst, key.af_lan);
	key.lan.xport.port = th-&gt;th_sport;
	key.ext_lan.xport.port = th-&gt;th_dport;

	STATE_LOOKUP();

	sk = (*state)-&gt;state_key;
	<span class="enscript-comment">/*
	 * In case of NAT64 the translation is first applied on the LAN
	 * side. Therefore for stack's address family comparison
	 * we use sk-&gt;af_lan.
	 */</span>
	<span class="enscript-keyword">if</span> ((direction == sk-&gt;direction) &amp;&amp; (pd-&gt;af == sk-&gt;af_lan)) {
		src = &amp;(*state)-&gt;src;
		dst = &amp;(*state)-&gt;dst;
	} <span class="enscript-keyword">else</span> {
		src = &amp;(*state)-&gt;dst;
		dst = &amp;(*state)-&gt;src;
	}

	<span class="enscript-keyword">if</span> (src-&gt;state == PF_TCPS_PROXY_SRC) {
		<span class="enscript-keyword">if</span> (direction != sk-&gt;direction) {
			REASON_SET(reason, PFRES_SYNPROXY);
			<span class="enscript-keyword">return</span> (PF_SYNPROXY_DROP);
		}
		<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_SYN) {
			<span class="enscript-keyword">if</span> (ntohl(th-&gt;th_seq) != src-&gt;seqlo) {
				REASON_SET(reason, PFRES_SYNPROXY);
				<span class="enscript-keyword">return</span> (PF_DROP);
			}
			pf_send_tcp((*state)-&gt;rule.ptr, pd-&gt;af, pd-&gt;dst,
			    pd-&gt;src, th-&gt;th_dport, th-&gt;th_sport,
			    src-&gt;seqhi, ntohl(th-&gt;th_seq) + 1,
			    TH_SYN|TH_ACK, 0, src-&gt;mss, 0, 1,
			    0, NULL, NULL);
			REASON_SET(reason, PFRES_SYNPROXY);
			<span class="enscript-keyword">return</span> (PF_SYNPROXY_DROP);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(th-&gt;th_flags &amp; TH_ACK) ||
		    (ntohl(th-&gt;th_ack) != src-&gt;seqhi + 1) ||
		    (ntohl(th-&gt;th_seq) != src-&gt;seqlo + 1)) {
			REASON_SET(reason, PFRES_SYNPROXY);
			<span class="enscript-keyword">return</span> (PF_DROP);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((*state)-&gt;src_node != NULL &amp;&amp;
		    pf_src_connlimit(state)) {
			REASON_SET(reason, PFRES_SRCLIMIT);
			<span class="enscript-keyword">return</span> (PF_DROP);
		} <span class="enscript-keyword">else</span>
			src-&gt;state = PF_TCPS_PROXY_DST;
	}
	<span class="enscript-keyword">if</span> (src-&gt;state == PF_TCPS_PROXY_DST) {
		<span class="enscript-type">struct</span> pf_state_host *psrc, *pdst;

		<span class="enscript-keyword">if</span> (direction == PF_OUT) {
			psrc = &amp;sk-&gt;gwy;
			pdst = &amp;sk-&gt;ext_gwy;
		} <span class="enscript-keyword">else</span> {
			psrc = &amp;sk-&gt;ext_lan;
			pdst = &amp;sk-&gt;lan;
		}
		<span class="enscript-keyword">if</span> (direction == sk-&gt;direction) {
			<span class="enscript-keyword">if</span> (((th-&gt;th_flags &amp; (TH_SYN|TH_ACK)) != TH_ACK) ||
			    (ntohl(th-&gt;th_ack) != src-&gt;seqhi + 1) ||
			    (ntohl(th-&gt;th_seq) != src-&gt;seqlo + 1)) {
				REASON_SET(reason, PFRES_SYNPROXY);
				<span class="enscript-keyword">return</span> (PF_DROP);
			}
			src-&gt;max_win = MAX(ntohs(th-&gt;th_win), 1);
			<span class="enscript-keyword">if</span> (dst-&gt;seqhi == 1)
				dst-&gt;seqhi = htonl(random());
			pf_send_tcp((*state)-&gt;rule.ptr, pd-&gt;af, &amp;psrc-&gt;addr,
			    &amp;pdst-&gt;addr, psrc-&gt;xport.port, pdst-&gt;xport.port,
			    dst-&gt;seqhi, 0, TH_SYN, 0,
			    src-&gt;mss, 0, 0, (*state)-&gt;tag, NULL, NULL);
			REASON_SET(reason, PFRES_SYNPROXY);
			<span class="enscript-keyword">return</span> (PF_SYNPROXY_DROP);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((th-&gt;th_flags &amp; (TH_SYN|TH_ACK)) !=
		    (TH_SYN|TH_ACK)) ||
		    (ntohl(th-&gt;th_ack) != dst-&gt;seqhi + 1)) {
			REASON_SET(reason, PFRES_SYNPROXY);
			<span class="enscript-keyword">return</span> (PF_DROP);
		} <span class="enscript-keyword">else</span> {
			dst-&gt;max_win = MAX(ntohs(th-&gt;th_win), 1);
			dst-&gt;seqlo = ntohl(th-&gt;th_seq);
			pf_send_tcp((*state)-&gt;rule.ptr, pd-&gt;af, pd-&gt;dst,
			    pd-&gt;src, th-&gt;th_dport, th-&gt;th_sport,
			    ntohl(th-&gt;th_ack), ntohl(th-&gt;th_seq) + 1,
			    TH_ACK, src-&gt;max_win, 0, 0, 0,
			    (*state)-&gt;tag, NULL, NULL);
			pf_send_tcp((*state)-&gt;rule.ptr, pd-&gt;af, &amp;psrc-&gt;addr,
			    &amp;pdst-&gt;addr, psrc-&gt;xport.port, pdst-&gt;xport.port,
			    src-&gt;seqhi + 1, src-&gt;seqlo + 1,
			    TH_ACK, dst-&gt;max_win, 0, 0, 1,
			    0, NULL, NULL);
			src-&gt;seqdiff = dst-&gt;seqhi -
			    src-&gt;seqlo;
			dst-&gt;seqdiff = src-&gt;seqhi -
			    dst-&gt;seqlo;
			src-&gt;seqhi = src-&gt;seqlo +
			    dst-&gt;max_win;
			dst-&gt;seqhi = dst-&gt;seqlo +
			    src-&gt;max_win;
			src-&gt;wscale = dst-&gt;wscale = 0;
			src-&gt;state = dst-&gt;state =
			    TCPS_ESTABLISHED;
			REASON_SET(reason, PFRES_SYNPROXY);
			<span class="enscript-keyword">return</span> (PF_SYNPROXY_DROP);
		}
	}

	<span class="enscript-keyword">if</span> (((th-&gt;th_flags &amp; (TH_SYN|TH_ACK)) == TH_SYN) &amp;&amp;
	    dst-&gt;state &gt;= TCPS_FIN_WAIT_2 &amp;&amp;
	    src-&gt;state &gt;= TCPS_FIN_WAIT_2) {
		<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
			printf(<span class="enscript-string">&quot;pf: state reuse &quot;</span>);
			pf_print_state(*state);
			pf_print_flags(th-&gt;th_flags);
			printf(<span class="enscript-string">&quot;\n&quot;</span>);
		}
		<span class="enscript-comment">/* XXX make sure it's the same direction ?? */</span>
		src-&gt;state = dst-&gt;state = TCPS_CLOSED;
		pf_unlink_state(*state);
		*state = NULL;
		<span class="enscript-keyword">return</span> (PF_DROP);
	}

	<span class="enscript-keyword">if</span> ((th-&gt;th_flags &amp; TH_SYN) == 0) {
		sws = (src-&gt;wscale &amp; PF_WSCALE_FLAG) ?
		    (src-&gt;wscale &amp; PF_WSCALE_MASK) : TCP_MAX_WINSHIFT;
		dws = (dst-&gt;wscale &amp; PF_WSCALE_FLAG) ?
		    (dst-&gt;wscale &amp; PF_WSCALE_MASK) : TCP_MAX_WINSHIFT;
	}
	<span class="enscript-keyword">else</span>
		sws = dws = 0;

	<span class="enscript-comment">/*
	 * Sequence tracking algorithm from Guido van Rooij's paper:
	 *   <a href="http://www.madison-gurkha.com/publications/tcp_filtering/">http://www.madison-gurkha.com/publications/tcp_filtering/</a>
	 *	tcp_filtering.ps
	 */</span>

	orig_seq = seq = ntohl(th-&gt;th_seq);
	<span class="enscript-keyword">if</span> (src-&gt;seqlo == 0) {
		<span class="enscript-comment">/* First packet from this end. Set its state */</span>

		<span class="enscript-keyword">if</span> ((pd-&gt;flags &amp; PFDESC_TCP_NORM || dst-&gt;scrub) &amp;&amp;
		    src-&gt;scrub == NULL) {
			<span class="enscript-keyword">if</span> (pf_normalize_tcp_init(m, off, pd, th, src, dst)) {
				REASON_SET(reason, PFRES_MEMORY);
				<span class="enscript-keyword">return</span> (PF_DROP);
			}
		}

		<span class="enscript-comment">/* Deferred generation of sequence number modulator */</span>
		<span class="enscript-keyword">if</span> (dst-&gt;seqdiff &amp;&amp; !src-&gt;seqdiff) {
			<span class="enscript-comment">/* use random iss for the TCP server */</span>
			<span class="enscript-keyword">while</span> ((src-&gt;seqdiff = random() - seq) == 0)
				;
			ack = ntohl(th-&gt;th_ack) - dst-&gt;seqdiff;
			pf_change_a(&amp;th-&gt;th_seq, &amp;th-&gt;th_sum, htonl(seq +
			    src-&gt;seqdiff), 0);
			pf_change_a(&amp;th-&gt;th_ack, &amp;th-&gt;th_sum, htonl(ack), 0);
			copyback = off + <span class="enscript-keyword">sizeof</span> (*th);
		} <span class="enscript-keyword">else</span> {
			ack = ntohl(th-&gt;th_ack);
		}

		end = seq + pd-&gt;p_len;
		<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_SYN) {
			end++;
			<span class="enscript-keyword">if</span> (dst-&gt;wscale &amp; PF_WSCALE_FLAG) {
				src-&gt;wscale = pf_get_wscale(m, off, th-&gt;th_off,
				    pd-&gt;af);
				<span class="enscript-keyword">if</span> (src-&gt;wscale &amp; PF_WSCALE_FLAG) {
					<span class="enscript-comment">/*
					 * Remove scale factor from initial
					 * window
					 */</span>
					sws = src-&gt;wscale &amp; PF_WSCALE_MASK;
					win = ((u_int32_t)win + (1 &lt;&lt; sws) - 1)
					    &gt;&gt; sws;
					dws = dst-&gt;wscale &amp; PF_WSCALE_MASK;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * Window scale negotiation has failed,
					 * therefore we must restore the window
					 * scale in the state record that we
					 * optimistically removed in
					 * pf_test_rule().  Care is required to
					 * prevent arithmetic overflow from
					 * zeroing the window when it's
					 * truncated down to 16-bits.
					 */</span>
					u_int32_t max_win = dst-&gt;max_win;
					max_win &lt;&lt;=
					    dst-&gt;wscale &amp; PF_WSCALE_MASK;
					dst-&gt;max_win = MIN(0xffff, max_win);
					<span class="enscript-comment">/* in case of a retrans SYN|ACK */</span>
					dst-&gt;wscale = 0;
				}
			}
		}
		<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_FIN)
			end++;

		src-&gt;seqlo = seq;
		<span class="enscript-keyword">if</span> (src-&gt;state &lt; TCPS_SYN_SENT)
			src-&gt;state = TCPS_SYN_SENT;

		<span class="enscript-comment">/*
		 * May need to slide the window (seqhi may have been set by
		 * the crappy stack check or if we picked up the connection
		 * after establishment)
		 */</span>
		<span class="enscript-keyword">if</span> (src-&gt;seqhi == 1 ||
		    SEQ_GEQ(end + MAX(1, (u_int32_t)dst-&gt;max_win &lt;&lt; dws),
		    src-&gt;seqhi))
			src-&gt;seqhi = end + MAX(1, (u_int32_t)dst-&gt;max_win &lt;&lt; dws);
		<span class="enscript-keyword">if</span> (win &gt; src-&gt;max_win)
			src-&gt;max_win = win;

	} <span class="enscript-keyword">else</span> {
		ack = ntohl(th-&gt;th_ack) - dst-&gt;seqdiff;
		<span class="enscript-keyword">if</span> (src-&gt;seqdiff) {
			<span class="enscript-comment">/* Modulate sequence numbers */</span>
			pf_change_a(&amp;th-&gt;th_seq, &amp;th-&gt;th_sum, htonl(seq +
			    src-&gt;seqdiff), 0);
			pf_change_a(&amp;th-&gt;th_ack, &amp;th-&gt;th_sum, htonl(ack), 0);
			copyback = off+ <span class="enscript-keyword">sizeof</span> (*th);
		}
		end = seq + pd-&gt;p_len;
		<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_SYN)
			end++;
		<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_FIN)
			end++;
	}

	<span class="enscript-keyword">if</span> ((th-&gt;th_flags &amp; TH_ACK) == 0) {
		<span class="enscript-comment">/* Let it pass through the ack skew check */</span>
		ack = dst-&gt;seqlo;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ack == 0 &amp;&amp;
	    (th-&gt;th_flags &amp; (TH_ACK|TH_RST)) == (TH_ACK|TH_RST)) ||
	    <span class="enscript-comment">/* broken tcp stacks do not set ack */</span>
	    (dst-&gt;state &lt; TCPS_SYN_SENT)) {
		<span class="enscript-comment">/*
		 * Many stacks (ours included) will set the ACK number in an
		 * FIN|ACK if the SYN times out -- no sequence to ACK.
		 */</span>
		ack = dst-&gt;seqlo;
	}

	<span class="enscript-keyword">if</span> (seq == end) {
		<span class="enscript-comment">/* Ease sequencing restrictions on no data packets */</span>
		seq = src-&gt;seqlo;
		end = seq;
	}

	ackskew = dst-&gt;seqlo - ack;


	<span class="enscript-comment">/*
	 * Need to demodulate the sequence numbers in any TCP SACK options
	 * (Selective ACK). We could optionally validate the SACK values
	 * against the current ACK window, either forwards or backwards, but
	 * I'm not confident that SACK has been implemented properly
	 * everywhere. It wouldn't surprise me if several stacks accidently
	 * SACK too far backwards of previously ACKed data. There really aren't
	 * any security implications of bad SACKing unless the target stack
	 * doesn't validate the option length correctly. Someone trying to
	 * spoof into a TCP connection won't bother blindly sending SACK
	 * options anyway.
	 */</span>
	<span class="enscript-keyword">if</span> (dst-&gt;seqdiff &amp;&amp; (th-&gt;th_off &lt;&lt; 2) &gt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr)) {
		copyback = pf_modulate_sack(m, off, pd, th, dst);
		<span class="enscript-keyword">if</span> (copyback == -1) {
			REASON_SET(reason, PFRES_MEMORY);
			<span class="enscript-keyword">return</span> (PF_DROP);
		}

		m = pd-&gt;mp;
	}


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAXACKWINDOW</span> (0xffff + 1500)	<span class="enscript-comment">/* 1500 is an arbitrary fudge factor */</span>
	<span class="enscript-keyword">if</span> (SEQ_GEQ(src-&gt;seqhi, end) &amp;&amp;
	    <span class="enscript-comment">/* Last octet inside other's window space */</span>
	    SEQ_GEQ(seq, src-&gt;seqlo - ((u_int32_t)dst-&gt;max_win &lt;&lt; dws)) &amp;&amp;
	    <span class="enscript-comment">/* Retrans: not more than one window back */</span>
	    (ackskew &gt;= -MAXACKWINDOW) &amp;&amp;
	    <span class="enscript-comment">/* Acking not more than one reassembled fragment backwards */</span>
	    (ackskew &lt;= (MAXACKWINDOW &lt;&lt; sws)) &amp;&amp;
	    <span class="enscript-comment">/* Acking not more than one window forward */</span>
	    ((th-&gt;th_flags &amp; TH_RST) == 0 || orig_seq == src-&gt;seqlo ||
	    (orig_seq == src-&gt;seqlo + 1) || (orig_seq + 1 == src-&gt;seqlo) ||
	    (pd-&gt;flags &amp; PFDESC_IP_REAS) == 0)) {
	    <span class="enscript-comment">/* Require an exact/+1 sequence match on resets when possible */</span>

		<span class="enscript-keyword">if</span> (dst-&gt;scrub || src-&gt;scrub) {
			<span class="enscript-keyword">if</span> (pf_normalize_tcp_stateful(m, off, pd, reason, th,
			    *state, src, dst, &amp;copyback))
				<span class="enscript-keyword">return</span> (PF_DROP);

			m = pd-&gt;mp;
		}

		<span class="enscript-comment">/* update max window */</span>
		<span class="enscript-keyword">if</span> (src-&gt;max_win &lt; win)
			src-&gt;max_win = win;
		<span class="enscript-comment">/* synchronize sequencing */</span>
		<span class="enscript-keyword">if</span> (SEQ_GT(end, src-&gt;seqlo))
			src-&gt;seqlo = end;
		<span class="enscript-comment">/* slide the window of what the other end can send */</span>
		<span class="enscript-keyword">if</span> (SEQ_GEQ(ack + ((u_int32_t)win &lt;&lt; sws), dst-&gt;seqhi))
			dst-&gt;seqhi = ack + MAX(((u_int32_t)win &lt;&lt; sws), 1);

		<span class="enscript-comment">/* update states */</span>
		<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_SYN)
			<span class="enscript-keyword">if</span> (src-&gt;state &lt; TCPS_SYN_SENT)
				src-&gt;state = TCPS_SYN_SENT;
		<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_FIN)
			<span class="enscript-keyword">if</span> (src-&gt;state &lt; TCPS_CLOSING)
				src-&gt;state = TCPS_CLOSING;
		<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_ACK) {
			<span class="enscript-keyword">if</span> (dst-&gt;state == TCPS_SYN_SENT) {
				dst-&gt;state = TCPS_ESTABLISHED;
				<span class="enscript-keyword">if</span> (src-&gt;state == TCPS_ESTABLISHED &amp;&amp;
				    (*state)-&gt;src_node != NULL &amp;&amp;
				    pf_src_connlimit(state)) {
					REASON_SET(reason, PFRES_SRCLIMIT);
					<span class="enscript-keyword">return</span> (PF_DROP);
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dst-&gt;state == TCPS_CLOSING)
				dst-&gt;state = TCPS_FIN_WAIT_2;
		}
		<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_RST)
			src-&gt;state = dst-&gt;state = TCPS_TIME_WAIT;

		<span class="enscript-comment">/* update expire time */</span>
		(*state)-&gt;expire = pf_time_second();
		<span class="enscript-keyword">if</span> (src-&gt;state &gt;= TCPS_FIN_WAIT_2 &amp;&amp;
		    dst-&gt;state &gt;= TCPS_FIN_WAIT_2)
			(*state)-&gt;timeout = PFTM_TCP_CLOSED;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (src-&gt;state &gt;= TCPS_CLOSING &amp;&amp;
		    dst-&gt;state &gt;= TCPS_CLOSING)
			(*state)-&gt;timeout = PFTM_TCP_FIN_WAIT;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (src-&gt;state &lt; TCPS_ESTABLISHED ||
		    dst-&gt;state &lt; TCPS_ESTABLISHED)
			(*state)-&gt;timeout = PFTM_TCP_OPENING;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (src-&gt;state &gt;= TCPS_CLOSING ||
		    dst-&gt;state &gt;= TCPS_CLOSING)
			(*state)-&gt;timeout = PFTM_TCP_CLOSING;
		<span class="enscript-keyword">else</span>
			(*state)-&gt;timeout = PFTM_TCP_ESTABLISHED;

		<span class="enscript-comment">/* Fall through to PASS packet */</span>

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((dst-&gt;state &lt; TCPS_SYN_SENT ||
	    dst-&gt;state &gt;= TCPS_FIN_WAIT_2 || src-&gt;state &gt;= TCPS_FIN_WAIT_2) &amp;&amp;
	    SEQ_GEQ(src-&gt;seqhi + MAXACKWINDOW, end) &amp;&amp;
	    <span class="enscript-comment">/* Within a window forward of the originating packet */</span>
	    SEQ_GEQ(seq, src-&gt;seqlo - MAXACKWINDOW)) {
	    <span class="enscript-comment">/* Within a window backward of the originating packet */</span>

		<span class="enscript-comment">/*
		 * This currently handles three situations:
		 *  1) Stupid stacks will shotgun SYNs before their peer
		 *     replies.
		 *  2) When PF catches an already established stream (the
		 *     firewall rebooted, the state table was flushed, routes
		 *     changed...)
		 *  3) Packets get funky immediately after the connection
		 *     closes (this should catch Solaris spurious ACK|FINs
		 *     that web servers like to spew after a close)
		 *
		 * This must be a little more careful than the above code
		 * since packet floods will also be caught here. We don't
		 * update the TTL here to mitigate the damage of a packet
		 * flood and so the same code can handle awkward establishment
		 * and a loosened connection close.
		 * In the establishment case, a correct peer response will
		 * validate the connection, go through the normal state code
		 * and keep updating the state TTL.
		 */</span>

		<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
			printf(<span class="enscript-string">&quot;pf: loose state match: &quot;</span>);
			pf_print_state(*state);
			pf_print_flags(th-&gt;th_flags);
			printf(<span class="enscript-string">&quot; seq=%u (%u) ack=%u len=%u ackskew=%d &quot;</span>
			    <span class="enscript-string">&quot;pkts=%llu:%llu dir=%s,%s\n&quot;</span>, seq, orig_seq, ack,
			    pd-&gt;p_len, ackskew, (*state)-&gt;packets[0],
			    (*state)-&gt;packets[1],
			    direction == PF_IN ? <span class="enscript-string">&quot;in&quot;</span> : <span class="enscript-string">&quot;out&quot;</span>,
			    direction == sk-&gt;direction ?
			    <span class="enscript-string">&quot;fwd&quot;</span> : <span class="enscript-string">&quot;rev&quot;</span>);
		}

		<span class="enscript-keyword">if</span> (dst-&gt;scrub || src-&gt;scrub) {
			<span class="enscript-keyword">if</span> (pf_normalize_tcp_stateful(m, off, pd, reason, th,
			    *state, src, dst, &amp;copyback))
				<span class="enscript-keyword">return</span> (PF_DROP);
			m = pd-&gt;mp;
		}

		<span class="enscript-comment">/* update max window */</span>
		<span class="enscript-keyword">if</span> (src-&gt;max_win &lt; win)
			src-&gt;max_win = win;
		<span class="enscript-comment">/* synchronize sequencing */</span>
		<span class="enscript-keyword">if</span> (SEQ_GT(end, src-&gt;seqlo))
			src-&gt;seqlo = end;
		<span class="enscript-comment">/* slide the window of what the other end can send */</span>
		<span class="enscript-keyword">if</span> (SEQ_GEQ(ack + ((u_int32_t)win &lt;&lt; sws), dst-&gt;seqhi))
			dst-&gt;seqhi = ack + MAX(((u_int32_t)win &lt;&lt; sws), 1);

		<span class="enscript-comment">/*
		 * Cannot set dst-&gt;seqhi here since this could be a shotgunned
		 * SYN and not an already established connection.
		 */</span>

		<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_FIN)
			<span class="enscript-keyword">if</span> (src-&gt;state &lt; TCPS_CLOSING)
				src-&gt;state = TCPS_CLOSING;
		<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_RST)
			src-&gt;state = dst-&gt;state = TCPS_TIME_WAIT;

		<span class="enscript-comment">/* Fall through to PASS packet */</span>

	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (dst-&gt;state == TCPS_SYN_SENT &amp;&amp;
		    src-&gt;state == TCPS_SYN_SENT) {
			<span class="enscript-comment">/* Send RST for state mismatches during handshake */</span>
			<span class="enscript-keyword">if</span> (!(th-&gt;th_flags &amp; TH_RST))
				pf_send_tcp((*state)-&gt;rule.ptr, pd-&gt;af,
				    pd-&gt;dst, pd-&gt;src, th-&gt;th_dport,
				    th-&gt;th_sport, ntohl(th-&gt;th_ack), 0,
				    TH_RST, 0, 0,
				    (*state)-&gt;rule.ptr-&gt;return_ttl, 1, 0,
				    pd-&gt;eh, kif-&gt;pfik_ifp);
			src-&gt;seqlo = 0;
			src-&gt;seqhi = 1;
			src-&gt;max_win = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
			printf(<span class="enscript-string">&quot;pf: BAD state: &quot;</span>);
			pf_print_state(*state);
			pf_print_flags(th-&gt;th_flags);
			printf(<span class="enscript-string">&quot;\n   seq=%u (%u) ack=%u len=%u ackskew=%d &quot;</span>
			    <span class="enscript-string">&quot;sws=%u dws=%u pkts=%llu:%llu dir=%s,%s\n&quot;</span>,
			    seq, orig_seq, ack, pd-&gt;p_len, ackskew,
			    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)sws, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)dws,
			    (*state)-&gt;packets[0], (*state)-&gt;packets[1],
			    direction == PF_IN ? <span class="enscript-string">&quot;in&quot;</span> : <span class="enscript-string">&quot;out&quot;</span>,
			    direction == sk-&gt;direction ?
			    <span class="enscript-string">&quot;fwd&quot;</span> : <span class="enscript-string">&quot;rev&quot;</span>);
			printf(<span class="enscript-string">&quot;pf: State failure on: %c %c %c %c | %c %c\n&quot;</span>,
			    SEQ_GEQ(src-&gt;seqhi, end) ? <span class="enscript-string">' '</span> : <span class="enscript-string">'1'</span>,
			    SEQ_GEQ(seq,
			    src-&gt;seqlo - ((u_int32_t)dst-&gt;max_win &lt;&lt; dws)) ?
			    <span class="enscript-string">' '</span>: <span class="enscript-string">'2'</span>,
			    (ackskew &gt;= -MAXACKWINDOW) ? <span class="enscript-string">' '</span> : <span class="enscript-string">'3'</span>,
			    (ackskew &lt;= (MAXACKWINDOW &lt;&lt; sws)) ? <span class="enscript-string">' '</span> : <span class="enscript-string">'4'</span>,
			    SEQ_GEQ(src-&gt;seqhi + MAXACKWINDOW, end) ?<span class="enscript-string">' '</span> :<span class="enscript-string">'5'</span>,
			    SEQ_GEQ(seq, src-&gt;seqlo - MAXACKWINDOW) ?<span class="enscript-string">' '</span> :<span class="enscript-string">'6'</span>);
		}
		REASON_SET(reason, PFRES_BADSTATE);
		<span class="enscript-keyword">return</span> (PF_DROP);
	}

	<span class="enscript-comment">/* Any packets which have gotten here are to be passed */</span>

	<span class="enscript-keyword">if</span> (sk-&gt;app_state &amp;&amp;
	    sk-&gt;app_state-&gt;handler) {
		sk-&gt;app_state-&gt;handler(*state, direction,
		    off + (th-&gt;th_off &lt;&lt; 2), pd, kif);
		<span class="enscript-keyword">if</span> (pd-&gt;lmw &lt; 0) {
			REASON_SET(reason, PFRES_MEMORY);
			<span class="enscript-keyword">return</span> (PF_DROP);
		}
		m = pd-&gt;mp;
	}

	<span class="enscript-comment">/* translate source/destination address, if necessary */</span>
	<span class="enscript-keyword">if</span> (STATE_TRANSLATE(sk)) {
		pd-&gt;naf = (pd-&gt;af == sk-&gt;af_lan) ? sk-&gt;af_gwy : sk-&gt;af_lan;

		<span class="enscript-keyword">if</span> (direction == PF_OUT) {
			pf_change_ap(direction, pd-&gt;mp, pd-&gt;src, &amp;th-&gt;th_sport,
				     pd-&gt;ip_sum, &amp;th-&gt;th_sum, &amp;sk-&gt;gwy.addr,
				     sk-&gt;gwy.xport.port, 0, pd-&gt;af, pd-&gt;naf, 1);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (pd-&gt;af != pd-&gt;naf) {
				<span class="enscript-keyword">if</span> (pd-&gt;af == sk-&gt;af_gwy) {
					pf_change_ap(direction, pd-&gt;mp, pd-&gt;dst,
						&amp;th-&gt;th_dport, pd-&gt;ip_sum,
						&amp;th-&gt;th_sum, &amp;sk-&gt;lan.addr,
						sk-&gt;lan.xport.port, 0,
						pd-&gt;af, pd-&gt;naf, 0);

					pf_change_ap(direction, pd-&gt;mp, pd-&gt;src,
						&amp;th-&gt;th_sport, pd-&gt;ip_sum,
						&amp;th-&gt;th_sum, &amp;sk-&gt;ext_lan.addr,
						th-&gt;th_sport, 0, pd-&gt;af,
						pd-&gt;naf, 0);

				} <span class="enscript-keyword">else</span> {
					pf_change_ap(direction, pd-&gt;mp, pd-&gt;dst,
						&amp;th-&gt;th_dport, pd-&gt;ip_sum,
						&amp;th-&gt;th_sum, &amp;sk-&gt;ext_gwy.addr,
						th-&gt;th_dport, 0, pd-&gt;af,
						pd-&gt;naf, 0);

					pf_change_ap(direction, pd-&gt;mp, pd-&gt;src,
						&amp;th-&gt;th_sport, pd-&gt;ip_sum,
						&amp;th-&gt;th_sum, &amp;sk-&gt;gwy.addr,
						sk-&gt;gwy.xport.port, 0, pd-&gt;af,
						pd-&gt;naf, 0);
				}
			} <span class="enscript-keyword">else</span> {
				pf_change_ap(direction, pd-&gt;mp, pd-&gt;dst,
					     &amp;th-&gt;th_dport, pd-&gt;ip_sum,
					     &amp;th-&gt;th_sum, &amp;sk-&gt;lan.addr,
					     sk-&gt;lan.xport.port, 0, pd-&gt;af,
					     pd-&gt;naf, 1);
			}
		}

		copyback = off + <span class="enscript-keyword">sizeof</span> (*th);
	}

	<span class="enscript-keyword">if</span> (copyback) {
		m = pf_lazy_makewritable(pd, m, copyback);
		<span class="enscript-keyword">if</span> (!m) {
			REASON_SET(reason, PFRES_MEMORY);
			<span class="enscript-keyword">return</span> (PF_DROP);
		}

		<span class="enscript-comment">/* Copyback sequence modulation or stateful scrub changes */</span>
		m_copyback(m, off, <span class="enscript-keyword">sizeof</span> (*th), th);

		<span class="enscript-keyword">if</span> (sk-&gt;af_lan != sk-&gt;af_gwy)
			<span class="enscript-keyword">return</span> (pf_do_nat64(sk, pd, m, off));
	}
	<span class="enscript-keyword">return</span> (PF_PASS);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_test_state_udp</span>(<span class="enscript-type">struct</span> pf_state **state, <span class="enscript-type">int</span> direction, <span class="enscript-type">struct</span> pfi_kif *kif,
    <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">void</span> *h, <span class="enscript-type">struct</span> pf_pdesc *pd, u_short *reason)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">h</span>)
	<span class="enscript-type">struct</span> pf_state_peer	*src, *dst;
	<span class="enscript-type">struct</span> pf_state_key_cmp	 key;
	<span class="enscript-type">struct</span> pf_state_key	*sk;
	<span class="enscript-type">struct</span> udphdr		*uh = pd-&gt;hdr.udp;
	<span class="enscript-type">struct</span> pf_app_state as;
	<span class="enscript-type">int</span> action, extfilter;
	key.app_state = 0;
	key.proto_variant = PF_EXTFILTER_APD;

	key.proto = IPPROTO_UDP;
	key.af_lan = key.af_gwy = pd-&gt;af;

	<span class="enscript-comment">/*
	 * For NAT64 the first time rule search and state creation
	 * is done on the incoming side only.
	 * Once the state gets created, NAT64's LAN side (ipv6) will
	 * not be able to find the state in ext-gwy tree as that normally
	 * is intended to be looked up for incoming traffic from the
	 * WAN side.
	 * Therefore to handle NAT64 case we init keys here for both
	 * lan-ext as well as ext-gwy trees.
	 * In the state lookup we attempt a lookup on both trees if
	 * first one does not return any result and return a match if
	 * the match state's was created by NAT64 rule.
	 */</span>
	PF_ACPY(&amp;key.ext_gwy.addr, pd-&gt;src, key.af_gwy);
	PF_ACPY(&amp;key.gwy.addr, pd-&gt;dst, key.af_gwy);
	key.ext_gwy.xport.port = uh-&gt;uh_sport;
	key.gwy.xport.port = uh-&gt;uh_dport;

	PF_ACPY(&amp;key.lan.addr, pd-&gt;src, key.af_lan);
	PF_ACPY(&amp;key.ext_lan.addr, pd-&gt;dst, key.af_lan);
	key.lan.xport.port = uh-&gt;uh_sport;
	key.ext_lan.xport.port = uh-&gt;uh_dport;

	<span class="enscript-keyword">if</span> (ntohs(uh-&gt;uh_sport) == PF_IKE_PORT &amp;&amp;
	    ntohs(uh-&gt;uh_dport) == PF_IKE_PORT) {
		<span class="enscript-type">struct</span> pf_ike_hdr ike;
		size_t plen = m-&gt;m_pkthdr.len - off - <span class="enscript-keyword">sizeof</span> (*uh);
		<span class="enscript-keyword">if</span> (plen &lt; PF_IKE_PACKET_MINSIZE) {
			DPFPRINTF(PF_DEBUG_MISC,
			    (<span class="enscript-string">&quot;pf: IKE message too small.\n&quot;</span>));
			<span class="enscript-keyword">return</span> (PF_DROP);
		}

		<span class="enscript-keyword">if</span> (plen &gt; <span class="enscript-keyword">sizeof</span> (ike))
			plen = <span class="enscript-keyword">sizeof</span> (ike);
		m_copydata(m, off + <span class="enscript-keyword">sizeof</span> (*uh), plen, &amp;ike);

		<span class="enscript-keyword">if</span> (ike.initiator_cookie) {
			key.app_state = &amp;as;
			as.compare_lan_ext = pf_ike_compare;
			as.compare_ext_gwy = pf_ike_compare;
			as.u.ike.cookie = ike.initiator_cookie;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * &lt;<a href="http://tools.ietf.org/html/">http://tools.ietf.org/html/</a>\
			 *    draft-ietf-ipsec-nat-t-ike-01&gt;
			 * Support non-standard NAT-T implementations that
			 * push the ESP packet over the top of the IKE packet.
			 * Do not drop packet.
			 */</span>
			DPFPRINTF(PF_DEBUG_MISC,
			    (<span class="enscript-string">&quot;pf: IKE initiator cookie = 0.\n&quot;</span>));
		}
	}

	*state = pf_find_state(kif, &amp;key, direction);

	<span class="enscript-keyword">if</span> (!key.app_state &amp;&amp; *state == 0) {
		key.proto_variant = PF_EXTFILTER_AD;
		*state = pf_find_state(kif, &amp;key, direction);
	}

	<span class="enscript-keyword">if</span> (!key.app_state &amp;&amp; *state == 0) {
		key.proto_variant = PF_EXTFILTER_EI;
		*state = pf_find_state(kif, &amp;key, direction);
	}

	<span class="enscript-comment">/* similar to STATE_LOOKUP() */</span>
	<span class="enscript-keyword">if</span> (*state != NULL &amp;&amp; pd != NULL &amp;&amp; !(pd-&gt;pktflags &amp; PKTF_FLOW_ID)) {
		pd-&gt;flowsrc = (*state)-&gt;state_key-&gt;flowsrc;
		pd-&gt;flowhash = (*state)-&gt;state_key-&gt;flowhash;
		<span class="enscript-keyword">if</span> (pd-&gt;flowhash != 0) {
			pd-&gt;pktflags |= PKTF_FLOW_ID;
			pd-&gt;pktflags &amp;= ~PKTF_FLOW_ADV;
		}
	}

	<span class="enscript-keyword">if</span> (pf_state_lookup_aux(state, kif, direction, &amp;action))
		<span class="enscript-keyword">return</span> (action);

	sk = (*state)-&gt;state_key;

	<span class="enscript-comment">/*
	 * In case of NAT64 the translation is first applied on the LAN
	 * side. Therefore for stack's address family comparison
	 * we use sk-&gt;af_lan.
	 */</span>
	<span class="enscript-keyword">if</span> ((direction == sk-&gt;direction) &amp;&amp; (pd-&gt;af == sk-&gt;af_lan)) {
		src = &amp;(*state)-&gt;src;
		dst = &amp;(*state)-&gt;dst;
	} <span class="enscript-keyword">else</span> {
		src = &amp;(*state)-&gt;dst;
		dst = &amp;(*state)-&gt;src;
	}

	<span class="enscript-comment">/* update states */</span>
	<span class="enscript-keyword">if</span> (src-&gt;state &lt; PFUDPS_SINGLE)
		src-&gt;state = PFUDPS_SINGLE;
	<span class="enscript-keyword">if</span> (dst-&gt;state == PFUDPS_SINGLE)
		dst-&gt;state = PFUDPS_MULTIPLE;

	<span class="enscript-comment">/* update expire time */</span>
	(*state)-&gt;expire = pf_time_second();
	<span class="enscript-keyword">if</span> (src-&gt;state == PFUDPS_MULTIPLE &amp;&amp; dst-&gt;state == PFUDPS_MULTIPLE)
		(*state)-&gt;timeout = PFTM_UDP_MULTIPLE;
	<span class="enscript-keyword">else</span>
		(*state)-&gt;timeout = PFTM_UDP_SINGLE;

	extfilter = sk-&gt;proto_variant;
	<span class="enscript-keyword">if</span> (extfilter &gt; PF_EXTFILTER_APD) {
		<span class="enscript-keyword">if</span> (direction == PF_OUT) {
			sk-&gt;ext_lan.xport.port = key.ext_lan.xport.port;
			<span class="enscript-keyword">if</span> (extfilter &gt; PF_EXTFILTER_AD)
				PF_ACPY(&amp;sk-&gt;ext_lan.addr, &amp;key.ext_lan.addr,
					key.af_lan);
		} <span class="enscript-keyword">else</span> {
			sk-&gt;ext_gwy.xport.port = key.ext_gwy.xport.port;
			<span class="enscript-keyword">if</span> (extfilter &gt; PF_EXTFILTER_AD)
				PF_ACPY(&amp;sk-&gt;ext_gwy.addr, &amp;key.ext_gwy.addr,
					key.af_gwy);
		}
	}

	<span class="enscript-keyword">if</span> (sk-&gt;app_state &amp;&amp; sk-&gt;app_state-&gt;handler) {
		sk-&gt;app_state-&gt;handler(*state, direction, off + uh-&gt;uh_ulen,
					pd, kif);
		<span class="enscript-keyword">if</span> (pd-&gt;lmw &lt; 0) {
			REASON_SET(reason, PFRES_MEMORY);
			<span class="enscript-keyword">return</span> (PF_DROP);
		}
		m = pd-&gt;mp;
	}

	<span class="enscript-comment">/* translate source/destination address, if necessary */</span>
	<span class="enscript-keyword">if</span> (STATE_TRANSLATE(sk)) {
		m = pf_lazy_makewritable(pd, m, off + <span class="enscript-keyword">sizeof</span> (*uh));
		<span class="enscript-keyword">if</span> (!m) {
			REASON_SET(reason, PFRES_MEMORY);
			<span class="enscript-keyword">return</span> (PF_DROP);
		}

		pd-&gt;naf = (pd-&gt;af == sk-&gt;af_lan) ? sk-&gt;af_gwy : sk-&gt;af_lan;

		<span class="enscript-keyword">if</span> (direction == PF_OUT) {
			pf_change_ap(direction, pd-&gt;mp, pd-&gt;src, &amp;uh-&gt;uh_sport,
				     pd-&gt;ip_sum, &amp;uh-&gt;uh_sum, &amp;sk-&gt;gwy.addr,
				     sk-&gt;gwy.xport.port, 1, pd-&gt;af, pd-&gt;naf, 1);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (pd-&gt;af != pd-&gt;naf) {

				<span class="enscript-keyword">if</span> (pd-&gt;af == sk-&gt;af_gwy) {
					pf_change_ap(direction, pd-&gt;mp, pd-&gt;dst,
						&amp;uh-&gt;uh_dport, pd-&gt;ip_sum,
						&amp;uh-&gt;uh_sum, &amp;sk-&gt;lan.addr,
						sk-&gt;lan.xport.port, 1,
						pd-&gt;af, pd-&gt;naf, 0);

					pf_change_ap(direction, pd-&gt;mp, pd-&gt;src,
						&amp;uh-&gt;uh_sport, pd-&gt;ip_sum,
						&amp;uh-&gt;uh_sum, &amp;sk-&gt;ext_lan.addr,
						uh-&gt;uh_sport, 1, pd-&gt;af,
						pd-&gt;naf, 0);

				} <span class="enscript-keyword">else</span> {
					pf_change_ap(direction, pd-&gt;mp, pd-&gt;dst,
						&amp;uh-&gt;uh_dport, pd-&gt;ip_sum,
						&amp;uh-&gt;uh_sum, &amp;sk-&gt;ext_gwy.addr,
						uh-&gt;uh_dport, 1, pd-&gt;af,
						pd-&gt;naf, 0);

					pf_change_ap(direction, pd-&gt;mp, pd-&gt;src,
						&amp;uh-&gt;uh_sport, pd-&gt;ip_sum,
						&amp;uh-&gt;uh_sum, &amp;sk-&gt;gwy.addr,
						sk-&gt;gwy.xport.port, 1, pd-&gt;af,
						pd-&gt;naf, 0);
				}
			} <span class="enscript-keyword">else</span> {
				pf_change_ap(direction, pd-&gt;mp, pd-&gt;dst,
						&amp;uh-&gt;uh_dport, pd-&gt;ip_sum,
						&amp;uh-&gt;uh_sum, &amp;sk-&gt;lan.addr,
						sk-&gt;lan.xport.port, 1,
						pd-&gt;af, pd-&gt;naf, 1);
			}
		}

		m_copyback(m, off, <span class="enscript-keyword">sizeof</span> (*uh), uh);
		<span class="enscript-keyword">if</span> (sk-&gt;af_lan != sk-&gt;af_gwy)
			<span class="enscript-keyword">return</span> (pf_do_nat64(sk, pd, m, off));
	}
	<span class="enscript-keyword">return</span> (PF_PASS);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_test_state_icmp</span>(<span class="enscript-type">struct</span> pf_state **state, <span class="enscript-type">int</span> direction, <span class="enscript-type">struct</span> pfi_kif *kif,
    <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">void</span> *h, <span class="enscript-type">struct</span> pf_pdesc *pd, u_short *reason)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">h</span>)
	<span class="enscript-type">struct</span> pf_addr	*saddr = pd-&gt;src, *daddr = pd-&gt;dst;
	<span class="enscript-type">struct</span> in_addr	srcv4_inaddr = saddr-&gt;v4;
	u_int16_t	 icmpid = 0, *icmpsum;
	u_int8_t	 icmptype;
	<span class="enscript-type">int</span>		 state_icmp = 0;
	<span class="enscript-type">struct</span> pf_state_key_cmp key;
	<span class="enscript-type">struct</span> pf_state_key	*sk;

	<span class="enscript-type">struct</span> pf_app_state as;
	key.app_state = 0;

	pd-&gt;off = off;

	<span class="enscript-keyword">switch</span> (pd-&gt;proto) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
		icmptype = pd-&gt;hdr.icmp-&gt;icmp_type;
		icmpid = pd-&gt;hdr.icmp-&gt;icmp_id;
		icmpsum = &amp;pd-&gt;hdr.icmp-&gt;icmp_cksum;

		<span class="enscript-keyword">if</span> (icmptype == ICMP_UNREACH ||
		    icmptype == ICMP_SOURCEQUENCH ||
		    icmptype == ICMP_REDIRECT ||
		    icmptype == ICMP_TIMXCEED ||
		    icmptype == ICMP_PARAMPROB)
			state_icmp++;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
		icmptype = pd-&gt;hdr.icmp6-&gt;icmp6_type;
		icmpid = pd-&gt;hdr.icmp6-&gt;icmp6_id;
		icmpsum = &amp;pd-&gt;hdr.icmp6-&gt;icmp6_cksum;

		<span class="enscript-keyword">if</span> (icmptype == ICMP6_DST_UNREACH ||
		    icmptype == ICMP6_PACKET_TOO_BIG ||
		    icmptype == ICMP6_TIME_EXCEEDED ||
		    icmptype == ICMP6_PARAM_PROB)
			state_icmp++;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}

	<span class="enscript-keyword">if</span> (!state_icmp) {

		<span class="enscript-comment">/*
		 * ICMP query/reply message not related to a TCP/UDP packet.
		 * Search for an ICMP state.
		 */</span>
		<span class="enscript-comment">/*
		 * NAT64 requires protocol translation  between ICMPv4
		 * and ICMPv6. TCP and UDP do not require protocol
		 * translation. To avoid adding complexity just to
		 * handle ICMP(v4/v6), we always lookup  for
		 * proto = IPPROTO_ICMP on both LAN and WAN side
		 */</span>
		key.proto = IPPROTO_ICMP;
		key.af_lan = key.af_gwy = pd-&gt;af;

		PF_ACPY(&amp;key.ext_gwy.addr, pd-&gt;src, key.af_gwy);
		PF_ACPY(&amp;key.gwy.addr, pd-&gt;dst, key.af_gwy);
		key.ext_gwy.xport.port = 0;
		key.gwy.xport.port = icmpid;

		PF_ACPY(&amp;key.lan.addr, pd-&gt;src, key.af_lan);
		PF_ACPY(&amp;key.ext_lan.addr, pd-&gt;dst, key.af_lan);
		key.lan.xport.port = icmpid;
		key.ext_lan.xport.port = 0;

		STATE_LOOKUP();

		sk = (*state)-&gt;state_key;
		(*state)-&gt;expire = pf_time_second();
		(*state)-&gt;timeout = PFTM_ICMP_ERROR_REPLY;

		<span class="enscript-comment">/* translate source/destination address, if necessary */</span>
		<span class="enscript-keyword">if</span> (STATE_TRANSLATE(sk)) {
			pd-&gt;naf = (pd-&gt;af == sk-&gt;af_lan) ?
						sk-&gt;af_gwy : sk-&gt;af_lan;
			<span class="enscript-keyword">if</span> (direction == PF_OUT) {
				<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
					pf_change_a(&amp;saddr-&gt;v4.s_addr,
					    pd-&gt;ip_sum,
					    sk-&gt;gwy.addr.v4.s_addr, 0);
					pd-&gt;hdr.icmp-&gt;icmp_cksum =
					    pf_cksum_fixup(
					    pd-&gt;hdr.icmp-&gt;icmp_cksum, icmpid,
					    sk-&gt;gwy.xport.port, 0);
					pd-&gt;hdr.icmp-&gt;icmp_id =
							sk-&gt;gwy.xport.port;
					m = pf_lazy_makewritable(pd, m,
							off + ICMP_MINLEN);
					<span class="enscript-keyword">if</span> (!m)
						<span class="enscript-keyword">return</span> (PF_DROP);
					m_copyback(m, off, ICMP_MINLEN,
					    pd-&gt;hdr.icmp);
					<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
					pf_change_a6(saddr,
					    &amp;pd-&gt;hdr.icmp6-&gt;icmp6_cksum,
					    &amp;sk-&gt;gwy.addr, 0);
					m = pf_lazy_makewritable(pd, m,
					    off + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr));
					<span class="enscript-keyword">if</span> (!m)
						<span class="enscript-keyword">return</span> (PF_DROP);
					m_copyback(m, off,
					    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr),
					    pd-&gt;hdr.icmp6);
					<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
					<span class="enscript-keyword">if</span> (pd-&gt;naf != AF_INET) {
						<span class="enscript-keyword">if</span> (pf_translate_icmp_af(
							AF_INET6, pd-&gt;hdr.icmp))
							<span class="enscript-keyword">return</span> (PF_DROP);

						pd-&gt;proto = IPPROTO_ICMPV6;

					} <span class="enscript-keyword">else</span> {

						pf_change_a(&amp;daddr-&gt;v4.s_addr,
						pd-&gt;ip_sum,
						sk-&gt;lan.addr.v4.s_addr, 0);

						pd-&gt;hdr.icmp-&gt;icmp_cksum =
						pf_cksum_fixup(
						pd-&gt;hdr.icmp-&gt;icmp_cksum,
						icmpid, sk-&gt;lan.xport.port, 0);

						pd-&gt;hdr.icmp-&gt;icmp_id =
							sk-&gt;lan.xport.port;
					}

					m = pf_lazy_makewritable(pd, m,
					    off + ICMP_MINLEN);
					<span class="enscript-keyword">if</span> (!m)
						<span class="enscript-keyword">return</span> (PF_DROP);
					m_copyback(m, off, ICMP_MINLEN,
							pd-&gt;hdr.icmp);
					<span class="enscript-keyword">if</span> (sk-&gt;af_lan != sk-&gt;af_gwy)
						<span class="enscript-keyword">return</span> (pf_do_nat64(sk, pd, m,
								   off));
					<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
					<span class="enscript-keyword">if</span> (pd-&gt;naf != AF_INET6) {
						<span class="enscript-keyword">if</span> (pf_translate_icmp_af(
							AF_INET, pd-&gt;hdr.icmp6))
							<span class="enscript-keyword">return</span> (PF_DROP);

						pd-&gt;proto = IPPROTO_ICMP;
					} <span class="enscript-keyword">else</span> {
						pf_change_a6(daddr,
						&amp;pd-&gt;hdr.icmp6-&gt;icmp6_cksum,
						&amp;sk-&gt;lan.addr, 0);
					}
					m = pf_lazy_makewritable(pd, m,
					    off + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr));
					<span class="enscript-keyword">if</span> (!m)
						<span class="enscript-keyword">return</span> (PF_DROP);
					m_copyback(m, off,
						<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr),
						pd-&gt;hdr.icmp6);
					<span class="enscript-keyword">if</span> (sk-&gt;af_lan != sk-&gt;af_gwy)
						<span class="enscript-keyword">return</span> (pf_do_nat64(sk, pd, m,
								   off));
					<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				}
			}
		}

		<span class="enscript-keyword">return</span> (PF_PASS);

	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * ICMP error message in response to a TCP/UDP packet.
		 * Extract the inner TCP/UDP header and search for that state.
		 */</span>
		<span class="enscript-type">struct</span> pf_pdesc	pd2; <span class="enscript-comment">/* For inner (original) header */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-type">struct</span> ip	h2;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-type">struct</span> ip6_hdr	h2_6;
		<span class="enscript-type">int</span>		terminal = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-type">int</span>		ipoff2 = 0;
		<span class="enscript-type">int</span>		off2 = 0;

		memset(&amp;pd2, 0, <span class="enscript-keyword">sizeof</span> (pd2));

		pd2.af = pd-&gt;af;
		<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			<span class="enscript-comment">/* offset of h2 in mbuf chain */</span>
			ipoff2 = off + ICMP_MINLEN;

			<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, ipoff2, &amp;h2, <span class="enscript-keyword">sizeof</span> (h2),
			    NULL, reason, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    (<span class="enscript-string">&quot;pf: ICMP error message too short &quot;</span>
				    <span class="enscript-string">&quot;(ip)\n&quot;</span>));
				<span class="enscript-keyword">return</span> (PF_DROP);
			}
			<span class="enscript-comment">/*
			 * ICMP error messages don't refer to non-first
			 * fragments
			 */</span>
			<span class="enscript-keyword">if</span> (h2.ip_off &amp; htons(IP_OFFMASK)) {
				REASON_SET(reason, PFRES_FRAG);
				<span class="enscript-keyword">return</span> (PF_DROP);
			}

			<span class="enscript-comment">/* offset of protocol header that follows h2 */</span>
			off2 = ipoff2 + (h2.ip_hl &lt;&lt; 2);
			<span class="enscript-comment">/* TODO */</span>
			pd2.off = ipoff2 + (h2.ip_hl &lt;&lt; 2);

			pd2.proto = h2.ip_p;
			pd2.src = (<span class="enscript-type">struct</span> pf_addr *)&amp;h2.ip_src;
			pd2.dst = (<span class="enscript-type">struct</span> pf_addr *)&amp;h2.ip_dst;
			pd2.ip_sum = &amp;h2.ip_sum;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			ipoff2 = off + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr);

			<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, ipoff2, &amp;h2_6, <span class="enscript-keyword">sizeof</span> (h2_6),
			    NULL, reason, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    (<span class="enscript-string">&quot;pf: ICMP error message too short &quot;</span>
				    <span class="enscript-string">&quot;(ip6)\n&quot;</span>));
				<span class="enscript-keyword">return</span> (PF_DROP);
			}
			pd2.proto = h2_6.ip6_nxt;
			pd2.src = (<span class="enscript-type">struct</span> pf_addr *)&amp;h2_6.ip6_src;
			pd2.dst = (<span class="enscript-type">struct</span> pf_addr *)&amp;h2_6.ip6_dst;
			pd2.ip_sum = NULL;
			off2 = ipoff2 + <span class="enscript-keyword">sizeof</span> (h2_6);
			<span class="enscript-keyword">do</span> {
				<span class="enscript-keyword">switch</span> (pd2.proto) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_FRAGMENT</span>:
					<span class="enscript-comment">/*
					 * ICMPv6 error messages for
					 * non-first fragments
					 */</span>
					REASON_SET(reason, PFRES_FRAG);
					<span class="enscript-keyword">return</span> (PF_DROP);
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_HOPOPTS</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ROUTING</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_DSTOPTS</span>: {
					<span class="enscript-comment">/* get next header and header length */</span>
					<span class="enscript-type">struct</span> ip6_ext opt6;

					<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off2, &amp;opt6,
					    <span class="enscript-keyword">sizeof</span> (opt6), NULL, reason,
					    pd2.af)) {
						DPFPRINTF(PF_DEBUG_MISC,
						    (<span class="enscript-string">&quot;pf: ICMPv6 short opt\n&quot;</span>));
						<span class="enscript-keyword">return</span> (PF_DROP);
					}
					<span class="enscript-keyword">if</span> (pd2.proto == IPPROTO_AH)
						off2 += (opt6.ip6e_len + 2) * 4;
					<span class="enscript-keyword">else</span>
						off2 += (opt6.ip6e_len + 1) * 8;
					pd2.proto = opt6.ip6e_nxt;
					<span class="enscript-comment">/* goto the next header */</span>
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-reference">default</span>:
					terminal++;
					<span class="enscript-keyword">break</span>;
				}
			} <span class="enscript-keyword">while</span> (!terminal);
			<span class="enscript-comment">/* TODO */</span>
			pd2.off = ipoff2;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		}

		<span class="enscript-keyword">switch</span> (pd2.proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>: {
			<span class="enscript-type">struct</span> tcphdr		 th;
			u_int32_t		 seq;
			<span class="enscript-type">struct</span> pf_state_peer	*src, *dst;
			u_int8_t		 dws;
			<span class="enscript-type">int</span>			 copyback = 0;

			<span class="enscript-comment">/*
			 * Only the first 8 bytes of the TCP header can be
			 * expected. Don't access any TCP header fields after
			 * th_seq, an ackskew test is not possible.
			 */</span>
			<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off2, &amp;th, 8, NULL, reason,
			    pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    (<span class="enscript-string">&quot;pf: ICMP error message too short &quot;</span>
				    <span class="enscript-string">&quot;(tcp)\n&quot;</span>));
				<span class="enscript-keyword">return</span> (PF_DROP);
			}

			key.proto = IPPROTO_TCP;
			key.af_gwy = pd2.af;
			PF_ACPY(&amp;key.ext_gwy.addr, pd2.dst, key.af_gwy);
			PF_ACPY(&amp;key.gwy.addr, pd2.src, key.af_gwy);
			key.ext_gwy.xport.port = th.th_dport;
			key.gwy.xport.port = th.th_sport;

			key.af_lan = pd2.af;
			PF_ACPY(&amp;key.lan.addr, pd2.dst, key.af_lan);
			PF_ACPY(&amp;key.ext_lan.addr, pd2.src, key.af_lan);
			key.lan.xport.port = th.th_dport;
			key.ext_lan.xport.port = th.th_sport;

			STATE_LOOKUP();

			sk = (*state)-&gt;state_key;
			<span class="enscript-keyword">if</span> ((direction == sk-&gt;direction) &amp;&amp;
			    ((sk-&gt;af_lan == sk-&gt;af_gwy) ||
			     (pd2.af == sk-&gt;af_lan))) {
				src = &amp;(*state)-&gt;dst;
				dst = &amp;(*state)-&gt;src;
			} <span class="enscript-keyword">else</span> {
				src = &amp;(*state)-&gt;src;
				dst = &amp;(*state)-&gt;dst;
			}

			<span class="enscript-keyword">if</span> (src-&gt;wscale &amp;&amp; (dst-&gt;wscale &amp; PF_WSCALE_FLAG))
				dws = dst-&gt;wscale &amp; PF_WSCALE_MASK;
			<span class="enscript-keyword">else</span>
				dws = TCP_MAX_WINSHIFT;

			<span class="enscript-comment">/* Demodulate sequence number */</span>
			seq = ntohl(th.th_seq) - src-&gt;seqdiff;
			<span class="enscript-keyword">if</span> (src-&gt;seqdiff) {
				pf_change_a(&amp;th.th_seq, icmpsum,
				    htonl(seq), 0);
				copyback = 1;
			}

			<span class="enscript-keyword">if</span> (!SEQ_GEQ(src-&gt;seqhi, seq) ||
			    !SEQ_GEQ(seq,
			    src-&gt;seqlo - ((u_int32_t)dst-&gt;max_win &lt;&lt; dws))) {
				<span class="enscript-keyword">if</span> (pf_status.debug &gt;= PF_DEBUG_MISC) {
					printf(<span class="enscript-string">&quot;pf: BAD ICMP %d:%d &quot;</span>,
					    icmptype, pd-&gt;hdr.icmp-&gt;icmp_code);
					pf_print_host(pd-&gt;src, 0, pd-&gt;af);
					printf(<span class="enscript-string">&quot; -&gt; &quot;</span>);
					pf_print_host(pd-&gt;dst, 0, pd-&gt;af);
					printf(<span class="enscript-string">&quot; state: &quot;</span>);
					pf_print_state(*state);
					printf(<span class="enscript-string">&quot; seq=%u\n&quot;</span>, seq);
				}
				REASON_SET(reason, PFRES_BADSTATE);
				<span class="enscript-keyword">return</span> (PF_DROP);
			}

			pd-&gt;naf = pd2.naf = (pd2.af == sk-&gt;af_lan) ?
						sk-&gt;af_gwy : sk-&gt;af_lan;

			<span class="enscript-keyword">if</span> (STATE_TRANSLATE(sk)) {
				<span class="enscript-comment">/* NAT64 case */</span>
				<span class="enscript-keyword">if</span> (sk-&gt;af_lan != sk-&gt;af_gwy) {
					<span class="enscript-type">struct</span> pf_state_host *saddr2, *daddr2;

					<span class="enscript-keyword">if</span> (pd2.naf == sk-&gt;af_lan) {
						saddr2 = &amp;sk-&gt;lan;
						daddr2 = &amp;sk-&gt;ext_lan;
					} <span class="enscript-keyword">else</span> {
						saddr2 = &amp;sk-&gt;ext_gwy;
						daddr2 = &amp;sk-&gt;gwy;
					}

					<span class="enscript-comment">/* translate ICMP message types and codes */</span>
					<span class="enscript-keyword">if</span> (pf_translate_icmp_af(pd-&gt;naf,
						pd-&gt;hdr.icmp))
						<span class="enscript-keyword">return</span> (PF_DROP);
					m =
					pf_lazy_makewritable(pd, m, off2 + 8);
					<span class="enscript-keyword">if</span> (!m)
						<span class="enscript-keyword">return</span> (PF_DROP);

					m_copyback(m, pd-&gt;off,
						<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr),
						pd-&gt;hdr.icmp6);

					<span class="enscript-comment">/*
					 * translate inner ip header within the
					 * ICMP message
					 */</span>
					<span class="enscript-keyword">if</span> (pf_change_icmp_af(m, ipoff2, pd,
					    &amp;pd2, &amp;saddr2-&gt;addr, &amp;daddr2-&gt;addr,
					    pd-&gt;af, pd-&gt;naf))
						<span class="enscript-keyword">return</span> (PF_DROP);

					<span class="enscript-keyword">if</span> (pd-&gt;naf == AF_INET)
						pd-&gt;proto = IPPROTO_ICMP;
					<span class="enscript-keyword">else</span>
						pd-&gt;proto = IPPROTO_ICMPV6;

					<span class="enscript-comment">/*
					 * translate inner tcp header within
					 * the ICMP message
					 */</span>
					pf_change_ap(direction, NULL, pd2.src,
						&amp;th.th_sport, pd2.ip_sum,
						&amp;th.th_sum, &amp;daddr2-&gt;addr,
						saddr2-&gt;xport.port, 0, pd2.af,
						pd2.naf, 0);

					pf_change_ap(direction, NULL, pd2.dst,
						&amp;th.th_dport, pd2.ip_sum,
						&amp;th.th_sum, &amp;saddr2-&gt;addr,
						daddr2-&gt;xport.port, 0, pd2.af,
						pd2.naf, 0);

					m_copyback(m, pd2.off, 8, &amp;th);

					<span class="enscript-comment">/* translate outer ip header */</span>
					PF_ACPY(&amp;pd-&gt;naddr, &amp;daddr2-&gt;addr,
						pd-&gt;naf);
					PF_ACPY(&amp;pd-&gt;ndaddr, &amp;saddr2-&gt;addr,
						pd-&gt;naf);
					<span class="enscript-keyword">if</span> (pd-&gt;af == AF_INET) {
						memcpy(&amp;pd-&gt;naddr.addr32[3],
						    &amp;srcv4_inaddr,
						    <span class="enscript-keyword">sizeof</span>(pd-&gt;naddr.addr32[3]));
						<span class="enscript-keyword">return</span> (pf_nat64_ipv4(m, off,
									pd));
					} <span class="enscript-keyword">else</span> {
						<span class="enscript-keyword">return</span> (pf_nat64_ipv6(m, off,
									pd));
					}
				}
				<span class="enscript-keyword">if</span> (direction == PF_IN) {
					pf_change_icmp(pd2.src, &amp;th.th_sport,
					    daddr, &amp;sk-&gt;lan.addr,
					    sk-&gt;lan.xport.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd-&gt;ip_sum, 0, pd2.af);
				} <span class="enscript-keyword">else</span> {
					pf_change_icmp(pd2.dst, &amp;th.th_dport,
					    saddr, &amp;sk-&gt;gwy.addr,
					    sk-&gt;gwy.xport.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd-&gt;ip_sum, 0, pd2.af);
				}
				copyback = 1;
			}

			<span class="enscript-keyword">if</span> (copyback) {
				m = pf_lazy_makewritable(pd, m, off2 + 8);
				<span class="enscript-keyword">if</span> (!m)
					<span class="enscript-keyword">return</span> (PF_DROP);
				<span class="enscript-keyword">switch</span> (pd2.af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
					m_copyback(m, off, ICMP_MINLEN,
					    pd-&gt;hdr.icmp);
					m_copyback(m, ipoff2, <span class="enscript-keyword">sizeof</span> (h2),
					    &amp;h2);
					<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
					m_copyback(m, off,
					    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr),
					    pd-&gt;hdr.icmp6);
					m_copyback(m, ipoff2, <span class="enscript-keyword">sizeof</span> (h2_6),
					    &amp;h2_6);
					<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				}
				m_copyback(m, off2, 8, &amp;th);
			}

			<span class="enscript-keyword">return</span> (PF_PASS);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>: {
			<span class="enscript-type">struct</span> udphdr uh;
			<span class="enscript-type">int</span> dx, action;
			<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off2, &amp;uh, <span class="enscript-keyword">sizeof</span> (uh),
			    NULL, reason, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    (<span class="enscript-string">&quot;pf: ICMP error message too short &quot;</span>
				    <span class="enscript-string">&quot;(udp)\n&quot;</span>));
				<span class="enscript-keyword">return</span> (PF_DROP);
			}

			key.af_gwy = pd2.af;
			PF_ACPY(&amp;key.ext_gwy.addr, pd2.dst, key.af_gwy);
			PF_ACPY(&amp;key.gwy.addr, pd2.src, key.af_gwy);
			key.ext_gwy.xport.port = uh.uh_dport;
			key.gwy.xport.port = uh.uh_sport;

			key.af_lan = pd2.af;
			PF_ACPY(&amp;key.lan.addr, pd2.dst, key.af_lan);
			PF_ACPY(&amp;key.ext_lan.addr, pd2.src, key.af_lan);
			key.lan.xport.port = uh.uh_dport;
			key.ext_lan.xport.port = uh.uh_sport;

			key.proto = IPPROTO_UDP;
			key.proto_variant = PF_EXTFILTER_APD;
			dx = direction;

			<span class="enscript-keyword">if</span> (ntohs(uh.uh_sport) == PF_IKE_PORT &amp;&amp;
			    ntohs(uh.uh_dport) == PF_IKE_PORT) {
				<span class="enscript-type">struct</span> pf_ike_hdr ike;
				size_t plen =
				    m-&gt;m_pkthdr.len - off2 - <span class="enscript-keyword">sizeof</span> (uh);
				<span class="enscript-keyword">if</span> (direction == PF_IN &amp;&amp;
				    plen &lt; 8 <span class="enscript-comment">/* PF_IKE_PACKET_MINSIZE */</span>) {
					DPFPRINTF(PF_DEBUG_MISC, (<span class="enscript-string">&quot;pf: &quot;</span>
					    <span class="enscript-string">&quot;ICMP error, embedded IKE message &quot;</span>
					    <span class="enscript-string">&quot;too small.\n&quot;</span>));
					<span class="enscript-keyword">return</span> (PF_DROP);
				}

				<span class="enscript-keyword">if</span> (plen &gt; <span class="enscript-keyword">sizeof</span> (ike))
					plen = <span class="enscript-keyword">sizeof</span> (ike);
				m_copydata(m, off + <span class="enscript-keyword">sizeof</span> (uh), plen, &amp;ike);

				key.app_state = &amp;as;
				as.compare_lan_ext = pf_ike_compare;
				as.compare_ext_gwy = pf_ike_compare;
				as.u.ike.cookie = ike.initiator_cookie;
			}

			*state = pf_find_state(kif, &amp;key, dx);

			<span class="enscript-keyword">if</span> (key.app_state &amp;&amp; *state == 0) {
				key.app_state = 0;
				*state = pf_find_state(kif, &amp;key, dx);
			}

			<span class="enscript-keyword">if</span> (*state == 0) {
				key.proto_variant = PF_EXTFILTER_AD;
				*state = pf_find_state(kif, &amp;key, dx);
			}

			<span class="enscript-keyword">if</span> (*state == 0) {
				key.proto_variant = PF_EXTFILTER_EI;
				*state = pf_find_state(kif, &amp;key, dx);
			}

			<span class="enscript-comment">/* similar to STATE_LOOKUP() */</span>
			<span class="enscript-keyword">if</span> (*state != NULL &amp;&amp; pd != NULL &amp;&amp;
			    !(pd-&gt;pktflags &amp; PKTF_FLOW_ID)) {
				pd-&gt;flowsrc = (*state)-&gt;state_key-&gt;flowsrc;
				pd-&gt;flowhash = (*state)-&gt;state_key-&gt;flowhash;
				<span class="enscript-keyword">if</span> (pd-&gt;flowhash != 0) {
					pd-&gt;pktflags |= PKTF_FLOW_ID;
					pd-&gt;pktflags &amp;= ~PKTF_FLOW_ADV;
				}
			}

			<span class="enscript-keyword">if</span> (pf_state_lookup_aux(state, kif, direction, &amp;action))
				<span class="enscript-keyword">return</span> (action);

			sk = (*state)-&gt;state_key;
			pd-&gt;naf = pd2.naf = (pd2.af == sk-&gt;af_lan) ?
						sk-&gt;af_gwy : sk-&gt;af_lan;

			<span class="enscript-keyword">if</span> (STATE_TRANSLATE(sk)) {
				<span class="enscript-comment">/* NAT64 case */</span>
				<span class="enscript-keyword">if</span> (sk-&gt;af_lan != sk-&gt;af_gwy) {
					<span class="enscript-type">struct</span> pf_state_host *saddr2, *daddr2;

					<span class="enscript-keyword">if</span> (pd2.naf == sk-&gt;af_lan) {
						saddr2 = &amp;sk-&gt;lan;
						daddr2 = &amp;sk-&gt;ext_lan;
					} <span class="enscript-keyword">else</span> {
						saddr2 = &amp;sk-&gt;ext_gwy;
						daddr2 = &amp;sk-&gt;gwy;
					}

					<span class="enscript-comment">/* translate ICMP message */</span>
					<span class="enscript-keyword">if</span> (pf_translate_icmp_af(pd-&gt;naf,
						pd-&gt;hdr.icmp))
						<span class="enscript-keyword">return</span> (PF_DROP);
					m =
					pf_lazy_makewritable(pd, m, off2 + 8);
					<span class="enscript-keyword">if</span> (!m)
						<span class="enscript-keyword">return</span> (PF_DROP);

					m_copyback(m, pd-&gt;off,
						<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr),
						pd-&gt;hdr.icmp6);

					<span class="enscript-comment">/*
					 * translate inner ip header within the
					 * ICMP message
					 */</span>
					<span class="enscript-keyword">if</span> (pf_change_icmp_af(m, ipoff2, pd,
					    &amp;pd2, &amp;saddr2-&gt;addr, &amp;daddr2-&gt;addr,
					    pd-&gt;af, pd-&gt;naf))
						<span class="enscript-keyword">return</span> (PF_DROP);

					<span class="enscript-keyword">if</span> (pd-&gt;naf == AF_INET)
						pd-&gt;proto = IPPROTO_ICMP;
					<span class="enscript-keyword">else</span>
						pd-&gt;proto = IPPROTO_ICMPV6;

					<span class="enscript-comment">/*
					 * translate inner udp header within
					 * the ICMP message
					 */</span>
					pf_change_ap(direction, NULL, pd2.src,
						&amp;uh.uh_sport, pd2.ip_sum,
						&amp;uh.uh_sum, &amp;daddr2-&gt;addr,
						saddr2-&gt;xport.port, 0, pd2.af,
						pd2.naf, 0);

					pf_change_ap(direction, NULL, pd2.dst,
						&amp;uh.uh_dport, pd2.ip_sum,
						&amp;uh.uh_sum, &amp;saddr2-&gt;addr,
						daddr2-&gt;xport.port, 0, pd2.af,
						pd2.naf, 0);

					m_copyback(m, pd2.off, <span class="enscript-keyword">sizeof</span>(uh), &amp;uh);

					<span class="enscript-comment">/* translate outer ip header */</span>
					PF_ACPY(&amp;pd-&gt;naddr, &amp;daddr2-&gt;addr,
						pd-&gt;naf);
					PF_ACPY(&amp;pd-&gt;ndaddr, &amp;saddr2-&gt;addr,
						pd-&gt;naf);
					<span class="enscript-keyword">if</span> (pd-&gt;af == AF_INET) {
						memcpy(&amp;pd-&gt;naddr.addr32[3],
						    &amp;srcv4_inaddr,
						    <span class="enscript-keyword">sizeof</span>(pd-&gt;naddr.addr32[3]));
						<span class="enscript-keyword">return</span> (pf_nat64_ipv4(m, off,
									pd));
					} <span class="enscript-keyword">else</span> {
						<span class="enscript-keyword">return</span> (pf_nat64_ipv6(m, off,
									pd));
					}
				}
				<span class="enscript-keyword">if</span> (direction == PF_IN) {
					pf_change_icmp(pd2.src, &amp;uh.uh_sport,
					    daddr, &amp;sk-&gt;lan.addr,
					    sk-&gt;lan.xport.port, &amp;uh.uh_sum,
					    pd2.ip_sum, icmpsum,
					    pd-&gt;ip_sum, 1, pd2.af);
				} <span class="enscript-keyword">else</span> {
					pf_change_icmp(pd2.dst, &amp;uh.uh_dport,
					    saddr, &amp;sk-&gt;gwy.addr,
					    sk-&gt;gwy.xport.port, &amp;uh.uh_sum,
					    pd2.ip_sum, icmpsum,
					    pd-&gt;ip_sum, 1, pd2.af);
				}
				m = pf_lazy_makewritable(pd, m,
				    off2 + <span class="enscript-keyword">sizeof</span> (uh));
				<span class="enscript-keyword">if</span> (!m)
					<span class="enscript-keyword">return</span> (PF_DROP);
				<span class="enscript-keyword">switch</span> (pd2.af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
					m_copyback(m, off, ICMP_MINLEN,
					    pd-&gt;hdr.icmp);
					m_copyback(m, ipoff2, <span class="enscript-keyword">sizeof</span> (h2), &amp;h2);
					<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
					m_copyback(m, off,
					    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr),
					    pd-&gt;hdr.icmp6);
					m_copyback(m, ipoff2, <span class="enscript-keyword">sizeof</span> (h2_6),
					    &amp;h2_6);
					<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				}
				m_copyback(m, off2, <span class="enscript-keyword">sizeof</span> (uh), &amp;uh);
			}

			<span class="enscript-keyword">return</span> (PF_PASS);
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>: {
			<span class="enscript-type">struct</span> icmp		iih;

			<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off2, &amp;iih, ICMP_MINLEN,
			    NULL, reason, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    (<span class="enscript-string">&quot;pf: ICMP error message too short i&quot;</span>
				    <span class="enscript-string">&quot;(icmp)\n&quot;</span>));
				<span class="enscript-keyword">return</span> (PF_DROP);
			}

			key.proto = IPPROTO_ICMP;
			<span class="enscript-keyword">if</span> (direction == PF_IN)	{
				key.af_gwy = pd2.af;
				PF_ACPY(&amp;key.ext_gwy.addr, pd2.dst, key.af_gwy);
				PF_ACPY(&amp;key.gwy.addr, pd2.src, key.af_gwy);
				key.ext_gwy.xport.port = 0;
				key.gwy.xport.port = iih.icmp_id;
			} <span class="enscript-keyword">else</span> {
				key.af_lan = pd2.af;
				PF_ACPY(&amp;key.lan.addr, pd2.dst, key.af_lan);
				PF_ACPY(&amp;key.ext_lan.addr, pd2.src, key.af_lan);
				key.lan.xport.port = iih.icmp_id;
				key.ext_lan.xport.port = 0;
			}

			STATE_LOOKUP();

			sk = (*state)-&gt;state_key;
			<span class="enscript-keyword">if</span> (STATE_TRANSLATE(sk)) {
				<span class="enscript-keyword">if</span> (direction == PF_IN) {
					pf_change_icmp(pd2.src, &amp;iih.icmp_id,
					    daddr, &amp;sk-&gt;lan.addr,
					    sk-&gt;lan.xport.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd-&gt;ip_sum, 0, AF_INET);
				} <span class="enscript-keyword">else</span> {
					pf_change_icmp(pd2.dst, &amp;iih.icmp_id,
					    saddr, &amp;sk-&gt;gwy.addr,
					    sk-&gt;gwy.xport.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd-&gt;ip_sum, 0, AF_INET);
				}
				m = pf_lazy_makewritable(pd, m,
							 off2 + ICMP_MINLEN);
				<span class="enscript-keyword">if</span> (!m)
					<span class="enscript-keyword">return</span> (PF_DROP);
				m_copyback(m, off, ICMP_MINLEN, pd-&gt;hdr.icmp);
				m_copyback(m, ipoff2, <span class="enscript-keyword">sizeof</span> (h2), &amp;h2);
				m_copyback(m, off2, ICMP_MINLEN, &amp;iih);
			}

			<span class="enscript-keyword">return</span> (PF_PASS);
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>: {
			<span class="enscript-type">struct</span> icmp6_hdr	iih;

			<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off2, &amp;iih,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr), NULL, reason, pd2.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    (<span class="enscript-string">&quot;pf: ICMP error message too short &quot;</span>
				    <span class="enscript-string">&quot;(icmp6)\n&quot;</span>));
				<span class="enscript-keyword">return</span> (PF_DROP);
			}

			key.proto = IPPROTO_ICMPV6;
			<span class="enscript-keyword">if</span> (direction == PF_IN)	{
				key.af_gwy = pd2.af;
				PF_ACPY(&amp;key.ext_gwy.addr, pd2.dst, key.af_gwy);
				PF_ACPY(&amp;key.gwy.addr, pd2.src, key.af_gwy);
				key.ext_gwy.xport.port = 0;
				key.gwy.xport.port = iih.icmp6_id;
			} <span class="enscript-keyword">else</span> {
				key.af_lan = pd2.af;
				PF_ACPY(&amp;key.lan.addr, pd2.dst, key.af_lan);
				PF_ACPY(&amp;key.ext_lan.addr, pd2.src, key.af_lan);
				key.lan.xport.port = iih.icmp6_id;
				key.ext_lan.xport.port = 0;
			}

			STATE_LOOKUP();

			sk = (*state)-&gt;state_key;
			<span class="enscript-keyword">if</span> (STATE_TRANSLATE(sk)) {
				<span class="enscript-keyword">if</span> (direction == PF_IN) {
					pf_change_icmp(pd2.src, &amp;iih.icmp6_id,
					    daddr, &amp;sk-&gt;lan.addr,
					    sk-&gt;lan.xport.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd-&gt;ip_sum, 0, AF_INET6);
				} <span class="enscript-keyword">else</span> {
					pf_change_icmp(pd2.dst, &amp;iih.icmp6_id,
					    saddr, &amp;sk-&gt;gwy.addr,
					    sk-&gt;gwy.xport.port, NULL,
					    pd2.ip_sum, icmpsum,
					    pd-&gt;ip_sum, 0, AF_INET6);
				}
				m = pf_lazy_makewritable(pd, m, off2 +
				    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr));
				<span class="enscript-keyword">if</span> (!m)
					<span class="enscript-keyword">return</span> (PF_DROP);
				m_copyback(m, off, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr),
				    pd-&gt;hdr.icmp6);
				m_copyback(m, ipoff2, <span class="enscript-keyword">sizeof</span> (h2_6), &amp;h2_6);
				m_copyback(m, off2, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr),
				    &amp;iih);
			}

			<span class="enscript-keyword">return</span> (PF_PASS);
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-reference">default</span>: {
			key.proto = pd2.proto;
			<span class="enscript-keyword">if</span> (direction == PF_IN)	{
				key.af_gwy = pd2.af;
				PF_ACPY(&amp;key.ext_gwy.addr, pd2.dst, key.af_gwy);
				PF_ACPY(&amp;key.gwy.addr, pd2.src, key.af_gwy);
				key.ext_gwy.xport.port = 0;
				key.gwy.xport.port = 0;
			} <span class="enscript-keyword">else</span> {
				key.af_lan = pd2.af;
				PF_ACPY(&amp;key.lan.addr, pd2.dst, key.af_lan);
				PF_ACPY(&amp;key.ext_lan.addr, pd2.src, key.af_lan);
				key.lan.xport.port = 0;
				key.ext_lan.xport.port = 0;
			}

			STATE_LOOKUP();

			sk = (*state)-&gt;state_key;
			<span class="enscript-keyword">if</span> (STATE_TRANSLATE(sk)) {
				<span class="enscript-keyword">if</span> (direction == PF_IN) {
					pf_change_icmp(pd2.src, NULL, daddr,
						&amp;sk-&gt;lan.addr, 0, NULL,
						pd2.ip_sum, icmpsum,
						pd-&gt;ip_sum, 0, pd2.af);
				} <span class="enscript-keyword">else</span> {
					pf_change_icmp(pd2.dst, NULL, saddr,
						&amp;sk-&gt;gwy.addr, 0, NULL,
						pd2.ip_sum, icmpsum,
						pd-&gt;ip_sum, 0, pd2.af);
				}
				<span class="enscript-keyword">switch</span> (pd2.af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
					m = pf_lazy_makewritable(pd, m,
					    ipoff2 + <span class="enscript-keyword">sizeof</span> (h2));
					<span class="enscript-keyword">if</span> (!m)
						<span class="enscript-keyword">return</span> (PF_DROP);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
					m = pf_lazy_makewritable(pd, m,
							ipoff2 + <span class="enscript-keyword">sizeof</span> (h2_6));
					<span class="enscript-keyword">if</span> (!m)
						<span class="enscript-keyword">return</span> (PF_DROP);
					m_copyback(m, off,
						<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr),
						pd-&gt;hdr.icmp6);
					m_copyback(m, ipoff2, <span class="enscript-keyword">sizeof</span> (h2_6),
						   &amp;h2_6);
					<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				}
			}

			<span class="enscript-keyword">return</span> (PF_PASS);
			<span class="enscript-keyword">break</span>;
		}
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_test_state_grev1</span>(<span class="enscript-type">struct</span> pf_state **state, <span class="enscript-type">int</span> direction,
    <span class="enscript-type">struct</span> pfi_kif *kif, <span class="enscript-type">int</span> off, <span class="enscript-type">struct</span> pf_pdesc *pd)
{
	<span class="enscript-type">struct</span> pf_state_peer *src;
	<span class="enscript-type">struct</span> pf_state_peer *dst;
	<span class="enscript-type">struct</span> pf_state_key_cmp key;
	<span class="enscript-type">struct</span> pf_grev1_hdr *grev1 = pd-&gt;hdr.grev1;
	<span class="enscript-type">struct</span> mbuf *m;

	key.app_state = 0;
	key.proto = IPPROTO_GRE;
	key.proto_variant = PF_GRE_PPTP_VARIANT;
	<span class="enscript-keyword">if</span> (direction == PF_IN)	{
		key.af_gwy = pd-&gt;af;
		PF_ACPY(&amp;key.ext_gwy.addr, pd-&gt;src, key.af_gwy);
		PF_ACPY(&amp;key.gwy.addr, pd-&gt;dst, key.af_gwy);
		key.gwy.xport.call_id = grev1-&gt;call_id;
	} <span class="enscript-keyword">else</span> {
		key.af_lan = pd-&gt;af;
		PF_ACPY(&amp;key.lan.addr, pd-&gt;src, key.af_lan);
		PF_ACPY(&amp;key.ext_lan.addr, pd-&gt;dst, key.af_lan);
		key.ext_lan.xport.call_id = grev1-&gt;call_id;
	}

	STATE_LOOKUP();

	<span class="enscript-keyword">if</span> (direction == (*state)-&gt;state_key-&gt;direction) {
		src = &amp;(*state)-&gt;src;
		dst = &amp;(*state)-&gt;dst;
	} <span class="enscript-keyword">else</span> {
		src = &amp;(*state)-&gt;dst;
		dst = &amp;(*state)-&gt;src;
	}

	<span class="enscript-comment">/* update states */</span>
	<span class="enscript-keyword">if</span> (src-&gt;state &lt; PFGRE1S_INITIATING)
		src-&gt;state = PFGRE1S_INITIATING;

	<span class="enscript-comment">/* update expire time */</span>
	(*state)-&gt;expire = pf_time_second();
	<span class="enscript-keyword">if</span> (src-&gt;state &gt;= PFGRE1S_INITIATING &amp;&amp;
	    dst-&gt;state &gt;= PFGRE1S_INITIATING) {
		<span class="enscript-keyword">if</span> ((*state)-&gt;timeout != PFTM_TCP_ESTABLISHED)
			(*state)-&gt;timeout = PFTM_GREv1_ESTABLISHED;
		src-&gt;state = PFGRE1S_ESTABLISHED;
		dst-&gt;state = PFGRE1S_ESTABLISHED;
	} <span class="enscript-keyword">else</span> {
		(*state)-&gt;timeout = PFTM_GREv1_INITIATING;
	}

	<span class="enscript-keyword">if</span> ((*state)-&gt;state_key-&gt;app_state)
		(*state)-&gt;state_key-&gt;app_state-&gt;u.grev1.pptp_state-&gt;expire =
		    pf_time_second();

	<span class="enscript-comment">/* translate source/destination address, if necessary */</span>
	<span class="enscript-keyword">if</span> (STATE_GRE_TRANSLATE((*state)-&gt;state_key)) {
		<span class="enscript-keyword">if</span> (direction == PF_OUT) {
			<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				pf_change_a(&amp;pd-&gt;src-&gt;v4.s_addr,
				    pd-&gt;ip_sum,
				    (*state)-&gt;state_key-&gt;gwy.addr.v4.s_addr, 0);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				PF_ACPY(pd-&gt;src, &amp;(*state)-&gt;state_key-&gt;gwy.addr,
				    pd-&gt;af);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			}
		} <span class="enscript-keyword">else</span> {
			grev1-&gt;call_id = (*state)-&gt;state_key-&gt;lan.xport.call_id;

			<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				pf_change_a(&amp;pd-&gt;dst-&gt;v4.s_addr,
				    pd-&gt;ip_sum,
				    (*state)-&gt;state_key-&gt;lan.addr.v4.s_addr, 0);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				PF_ACPY(pd-&gt;dst, &amp;(*state)-&gt;state_key-&gt;lan.addr,
				    pd-&gt;af);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			}
		}

		m = pf_lazy_makewritable(pd, pd-&gt;mp, off + <span class="enscript-keyword">sizeof</span> (*grev1));
		<span class="enscript-keyword">if</span> (!m)
			<span class="enscript-keyword">return</span> (PF_DROP);
		m_copyback(m, off, <span class="enscript-keyword">sizeof</span> (*grev1), grev1);
	}

	<span class="enscript-keyword">return</span> (PF_PASS);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_test_state_esp</span>(<span class="enscript-type">struct</span> pf_state **state, <span class="enscript-type">int</span> direction, <span class="enscript-type">struct</span> pfi_kif *kif,
    <span class="enscript-type">int</span> off, <span class="enscript-type">struct</span> pf_pdesc *pd)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">off</span>)
	<span class="enscript-type">struct</span> pf_state_peer *src;
	<span class="enscript-type">struct</span> pf_state_peer *dst;
	<span class="enscript-type">struct</span> pf_state_key_cmp key;
	<span class="enscript-type">struct</span> pf_esp_hdr *esp = pd-&gt;hdr.esp;
	<span class="enscript-type">int</span> action;

	memset(&amp;key, 0, <span class="enscript-keyword">sizeof</span> (key));
	key.proto = IPPROTO_ESP;
	<span class="enscript-keyword">if</span> (direction == PF_IN)	{
		key.af_gwy = pd-&gt;af;
		PF_ACPY(&amp;key.ext_gwy.addr, pd-&gt;src, key.af_gwy);
		PF_ACPY(&amp;key.gwy.addr, pd-&gt;dst, key.af_gwy);
		key.gwy.xport.spi = esp-&gt;spi;
	} <span class="enscript-keyword">else</span> {
		key.af_lan = pd-&gt;af;
		PF_ACPY(&amp;key.lan.addr, pd-&gt;src, key.af_lan);
		PF_ACPY(&amp;key.ext_lan.addr, pd-&gt;dst, key.af_lan);
		key.ext_lan.xport.spi = esp-&gt;spi;
	}

	*state = pf_find_state(kif, &amp;key, direction);

	<span class="enscript-keyword">if</span> (*state == 0) {
		<span class="enscript-type">struct</span> pf_state *s;

		<span class="enscript-comment">/*
		 * &lt;<a href="mailto:jhw@apple.com">jhw@apple.com</a>&gt;
		 * No matching state.  Look for a blocking state.  If we find
		 * one, then use that state and move it so that it's keyed to
		 * the SPI in the current packet.
		 */</span>
		<span class="enscript-keyword">if</span> (direction == PF_IN) {
			key.gwy.xport.spi = 0;

			s = pf_find_state(kif, &amp;key, direction);
			<span class="enscript-keyword">if</span> (s) {
				<span class="enscript-type">struct</span> pf_state_key *sk = s-&gt;state_key;

				RB_REMOVE(pf_state_tree_ext_gwy,
				    &amp;pf_statetbl_ext_gwy, sk);
				sk-&gt;lan.xport.spi = sk-&gt;gwy.xport.spi =
				    esp-&gt;spi;

				<span class="enscript-keyword">if</span> (RB_INSERT(pf_state_tree_ext_gwy,
				    &amp;pf_statetbl_ext_gwy, sk))
					pf_detach_state(s, PF_DT_SKIP_EXTGWY);
				<span class="enscript-keyword">else</span>
					*state = s;
			}
		} <span class="enscript-keyword">else</span> {
			key.ext_lan.xport.spi = 0;

			s = pf_find_state(kif, &amp;key, direction);
			<span class="enscript-keyword">if</span> (s) {
				<span class="enscript-type">struct</span> pf_state_key *sk = s-&gt;state_key;

				RB_REMOVE(pf_state_tree_lan_ext,
				    &amp;pf_statetbl_lan_ext, sk);
				sk-&gt;ext_lan.xport.spi = esp-&gt;spi;

				<span class="enscript-keyword">if</span> (RB_INSERT(pf_state_tree_lan_ext,
				    &amp;pf_statetbl_lan_ext, sk))
					pf_detach_state(s, PF_DT_SKIP_LANEXT);
				<span class="enscript-keyword">else</span>
					*state = s;
			}
		}

		<span class="enscript-keyword">if</span> (s) {
			<span class="enscript-keyword">if</span> (*state == 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
				<span class="enscript-keyword">if</span> (s-&gt;creatorid == pf_status.hostid)
					pfsync_delete_state(s);
#<span class="enscript-reference">endif</span>
				s-&gt;timeout = PFTM_UNLINKED;
				hook_runloop(&amp;s-&gt;unlink_hooks,
				    HOOK_REMOVE|HOOK_FREE);
				pf_src_tree_remove_state(s);
				pf_free_state(s);
				<span class="enscript-keyword">return</span> (PF_DROP);
			}
		}
	}

	<span class="enscript-comment">/* similar to STATE_LOOKUP() */</span>
	<span class="enscript-keyword">if</span> (*state != NULL &amp;&amp; pd != NULL &amp;&amp; !(pd-&gt;pktflags &amp; PKTF_FLOW_ID)) {
		pd-&gt;flowsrc = (*state)-&gt;state_key-&gt;flowsrc;
		pd-&gt;flowhash = (*state)-&gt;state_key-&gt;flowhash;
		<span class="enscript-keyword">if</span> (pd-&gt;flowhash != 0) {
			pd-&gt;pktflags |= PKTF_FLOW_ID;
			pd-&gt;pktflags &amp;= ~PKTF_FLOW_ADV;
		}
	}

	<span class="enscript-keyword">if</span> (pf_state_lookup_aux(state, kif, direction, &amp;action))
		<span class="enscript-keyword">return</span> (action);

	<span class="enscript-keyword">if</span> (direction == (*state)-&gt;state_key-&gt;direction) {
		src = &amp;(*state)-&gt;src;
		dst = &amp;(*state)-&gt;dst;
	} <span class="enscript-keyword">else</span> {
		src = &amp;(*state)-&gt;dst;
		dst = &amp;(*state)-&gt;src;
	}

	<span class="enscript-comment">/* update states */</span>
	<span class="enscript-keyword">if</span> (src-&gt;state &lt; PFESPS_INITIATING)
		src-&gt;state = PFESPS_INITIATING;

	<span class="enscript-comment">/* update expire time */</span>
	(*state)-&gt;expire = pf_time_second();
	<span class="enscript-keyword">if</span> (src-&gt;state &gt;= PFESPS_INITIATING &amp;&amp;
	    dst-&gt;state &gt;= PFESPS_INITIATING) {
		(*state)-&gt;timeout = PFTM_ESP_ESTABLISHED;
		src-&gt;state = PFESPS_ESTABLISHED;
		dst-&gt;state = PFESPS_ESTABLISHED;
	} <span class="enscript-keyword">else</span> {
		(*state)-&gt;timeout = PFTM_ESP_INITIATING;
	}
	<span class="enscript-comment">/* translate source/destination address, if necessary */</span>
	<span class="enscript-keyword">if</span> (STATE_ADDR_TRANSLATE((*state)-&gt;state_key)) {
		<span class="enscript-keyword">if</span> (direction == PF_OUT) {
			<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				pf_change_a(&amp;pd-&gt;src-&gt;v4.s_addr,
				    pd-&gt;ip_sum,
				    (*state)-&gt;state_key-&gt;gwy.addr.v4.s_addr, 0);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				PF_ACPY(pd-&gt;src, &amp;(*state)-&gt;state_key-&gt;gwy.addr,
				    pd-&gt;af);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				pf_change_a(&amp;pd-&gt;dst-&gt;v4.s_addr,
				    pd-&gt;ip_sum,
				    (*state)-&gt;state_key-&gt;lan.addr.v4.s_addr, 0);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				PF_ACPY(pd-&gt;dst, &amp;(*state)-&gt;state_key-&gt;lan.addr,
				    pd-&gt;af);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			}
		}
	}

	<span class="enscript-keyword">return</span> (PF_PASS);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_test_state_other</span>(<span class="enscript-type">struct</span> pf_state **state, <span class="enscript-type">int</span> direction, <span class="enscript-type">struct</span> pfi_kif *kif,
    <span class="enscript-type">struct</span> pf_pdesc *pd)
{
	<span class="enscript-type">struct</span> pf_state_peer	*src, *dst;
	<span class="enscript-type">struct</span> pf_state_key_cmp	 key;

	key.app_state = 0;
	key.proto = pd-&gt;proto;
	<span class="enscript-keyword">if</span> (direction == PF_IN)	{
		key.af_gwy = pd-&gt;af;
		PF_ACPY(&amp;key.ext_gwy.addr, pd-&gt;src, key.af_gwy);
		PF_ACPY(&amp;key.gwy.addr, pd-&gt;dst, key.af_gwy);
		key.ext_gwy.xport.port = 0;
		key.gwy.xport.port = 0;
	} <span class="enscript-keyword">else</span> {
		key.af_lan = pd-&gt;af;
		PF_ACPY(&amp;key.lan.addr, pd-&gt;src, key.af_lan);
		PF_ACPY(&amp;key.ext_lan.addr, pd-&gt;dst, key.af_lan);
		key.lan.xport.port = 0;
		key.ext_lan.xport.port = 0;
	}

	STATE_LOOKUP();

	<span class="enscript-keyword">if</span> (direction == (*state)-&gt;state_key-&gt;direction) {
		src = &amp;(*state)-&gt;src;
		dst = &amp;(*state)-&gt;dst;
	} <span class="enscript-keyword">else</span> {
		src = &amp;(*state)-&gt;dst;
		dst = &amp;(*state)-&gt;src;
	}

	<span class="enscript-comment">/* update states */</span>
	<span class="enscript-keyword">if</span> (src-&gt;state &lt; PFOTHERS_SINGLE)
		src-&gt;state = PFOTHERS_SINGLE;
	<span class="enscript-keyword">if</span> (dst-&gt;state == PFOTHERS_SINGLE)
		dst-&gt;state = PFOTHERS_MULTIPLE;

	<span class="enscript-comment">/* update expire time */</span>
	(*state)-&gt;expire = pf_time_second();
	<span class="enscript-keyword">if</span> (src-&gt;state == PFOTHERS_MULTIPLE &amp;&amp; dst-&gt;state == PFOTHERS_MULTIPLE)
		(*state)-&gt;timeout = PFTM_OTHER_MULTIPLE;
	<span class="enscript-keyword">else</span>
		(*state)-&gt;timeout = PFTM_OTHER_SINGLE;

	<span class="enscript-comment">/* translate source/destination address, if necessary */</span>
	<span class="enscript-keyword">if</span> (STATE_ADDR_TRANSLATE((*state)-&gt;state_key)) {
		<span class="enscript-keyword">if</span> (direction == PF_OUT) {
			<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				pf_change_a(&amp;pd-&gt;src-&gt;v4.s_addr,
				    pd-&gt;ip_sum,
				    (*state)-&gt;state_key-&gt;gwy.addr.v4.s_addr,
				    0);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				PF_ACPY(pd-&gt;src,
				    &amp;(*state)-&gt;state_key-&gt;gwy.addr, pd-&gt;af);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">switch</span> (pd-&gt;af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				pf_change_a(&amp;pd-&gt;dst-&gt;v4.s_addr,
				    pd-&gt;ip_sum,
				    (*state)-&gt;state_key-&gt;lan.addr.v4.s_addr,
				    0);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				PF_ACPY(pd-&gt;dst,
				    &amp;(*state)-&gt;state_key-&gt;lan.addr, pd-&gt;af);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			}
		}
	}

	<span class="enscript-keyword">return</span> (PF_PASS);
}

<span class="enscript-comment">/*
 * ipoff and off are measured from the start of the mbuf chain.
 * h must be at &quot;ipoff&quot; on the mbuf chain.
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">pf_pull_hdr</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">void</span> *p, <span class="enscript-type">int</span> len,
    u_short *actionp, u_short *reasonp, sa_family_t af)
{
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
		<span class="enscript-type">struct</span> ip	*h = mtod(m, <span class="enscript-type">struct</span> ip *);
		u_int16_t	 fragoff = (ntohs(h-&gt;ip_off) &amp; IP_OFFMASK) &lt;&lt; 3;

		<span class="enscript-keyword">if</span> (fragoff) {
			<span class="enscript-keyword">if</span> (fragoff &gt;= len) {
				ACTION_SET(actionp, PF_PASS);
			} <span class="enscript-keyword">else</span> {
				ACTION_SET(actionp, PF_DROP);
				REASON_SET(reasonp, PFRES_FRAG);
			}
			<span class="enscript-keyword">return</span> (NULL);
		}
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; off + len ||
		    ntohs(h-&gt;ip_len) &lt; off + len) {
			ACTION_SET(actionp, PF_DROP);
			REASON_SET(reasonp, PFRES_SHORT);
			<span class="enscript-keyword">return</span> (NULL);
		}
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
		<span class="enscript-type">struct</span> ip6_hdr	*h = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; off + len ||
		    (ntohs(h-&gt;ip6_plen) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr)) &lt;
		    (<span class="enscript-type">unsigned</span>)(off + len)) {
			ACTION_SET(actionp, PF_DROP);
			REASON_SET(reasonp, PFRES_SHORT);
			<span class="enscript-keyword">return</span> (NULL);
		}
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
	m_copydata(m, off, len, p);
	<span class="enscript-keyword">return</span> (p);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_routable</span>(<span class="enscript-type">struct</span> pf_addr *addr, sa_family_t af, <span class="enscript-type">struct</span> pfi_kif *kif)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kif</span>)
	<span class="enscript-type">struct</span> sockaddr_in	*dst;
	<span class="enscript-type">int</span>			 ret = 1;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> sockaddr_in6	*dst6;
	<span class="enscript-type">struct</span> route_in6	 ro;
#<span class="enscript-reference">else</span>
	<span class="enscript-type">struct</span> route		 ro;
#<span class="enscript-reference">endif</span>

	bzero(&amp;ro, <span class="enscript-keyword">sizeof</span> (ro));
	<span class="enscript-keyword">switch</span> (af) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		dst = satosin(&amp;ro.ro_dst);
		dst-&gt;sin_family = AF_INET;
		dst-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*dst);
		dst-&gt;sin_addr = addr-&gt;v4;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		dst6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;ro.ro_dst;
		dst6-&gt;sin6_family = AF_INET6;
		dst6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> (*dst6);
		dst6-&gt;sin6_addr = addr-&gt;v6;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* XXX: IFT_ENC is not currently used by anything*/</span>
	<span class="enscript-comment">/* Skip checks for ipsec interfaces */</span>
	<span class="enscript-keyword">if</span> (kif != NULL &amp;&amp; kif-&gt;pfik_ifp-&gt;if_type == IFT_ENC)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* XXX: what is the point of this? */</span>
	rtalloc((<span class="enscript-type">struct</span> route *)&amp;ro);

<span class="enscript-reference">out</span>:
	ROUTE_RELEASE(&amp;ro);
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_rtlabel_match</span>(<span class="enscript-type">struct</span> pf_addr *addr, sa_family_t af, <span class="enscript-type">struct</span> pf_addr_wrap *aw)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">aw</span>)
	<span class="enscript-type">struct</span> sockaddr_in	*dst;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> sockaddr_in6	*dst6;
	<span class="enscript-type">struct</span> route_in6	 ro;
#<span class="enscript-reference">else</span>
	<span class="enscript-type">struct</span> route		 ro;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span>			 ret = 0;

	bzero(&amp;ro, <span class="enscript-keyword">sizeof</span> (ro));
	<span class="enscript-keyword">switch</span> (af) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		dst = satosin(&amp;ro.ro_dst);
		dst-&gt;sin_family = AF_INET;
		dst-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*dst);
		dst-&gt;sin_addr = addr-&gt;v4;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		dst6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;ro.ro_dst;
		dst6-&gt;sin6_family = AF_INET6;
		dst6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> (*dst6);
		dst6-&gt;sin6_addr = addr-&gt;v6;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* XXX: what is the point of this? */</span>
	rtalloc((<span class="enscript-type">struct</span> route *)&amp;ro);

	ROUTE_RELEASE(&amp;ro);

	<span class="enscript-keyword">return</span> (ret);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_route</span>(<span class="enscript-type">struct</span> mbuf **m, <span class="enscript-type">struct</span> pf_rule *r, <span class="enscript-type">int</span> dir, <span class="enscript-type">struct</span> ifnet *oifp,
    <span class="enscript-type">struct</span> pf_state *s, <span class="enscript-type">struct</span> pf_pdesc *pd)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">pd</span>)
	<span class="enscript-type">struct</span> mbuf		*m0, *m1;
	<span class="enscript-type">struct</span> route		 iproute;
	<span class="enscript-type">struct</span> route		*ro = &amp;iproute;
	<span class="enscript-type">struct</span> sockaddr_in	*dst;
	<span class="enscript-type">struct</span> ip		*ip;
	<span class="enscript-type">struct</span> ifnet		*ifp = NULL;
	<span class="enscript-type">struct</span> pf_addr		 naddr;
	<span class="enscript-type">struct</span> pf_src_node	*sn = NULL;
	<span class="enscript-type">int</span>			 error = 0;
	uint32_t		 sw_csum;

	bzero(&amp;iproute, <span class="enscript-keyword">sizeof</span> (iproute));

	<span class="enscript-keyword">if</span> (m == NULL || *m == NULL || r == NULL ||
	    (dir != PF_IN &amp;&amp; dir != PF_OUT) || oifp == NULL)
		panic(<span class="enscript-string">&quot;pf_route: invalid parameters&quot;</span>);

	<span class="enscript-keyword">if</span> (pd-&gt;pf_mtag-&gt;pftag_routed++ &gt; 3) {
		m0 = *m;
		*m = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (r-&gt;rt == PF_DUPTO) {
		<span class="enscript-keyword">if</span> ((m0 = m_copym(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
			<span class="enscript-keyword">return</span>;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((r-&gt;rt == PF_REPLYTO) == (r-&gt;direction == dir))
			<span class="enscript-keyword">return</span>;
		m0 = *m;
	}

	<span class="enscript-keyword">if</span> (m0-&gt;m_len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip)) {
		DPFPRINTF(PF_DEBUG_URGENT,
		    (<span class="enscript-string">&quot;pf_route: m0-&gt;m_len &lt; sizeof (struct ip)\n&quot;</span>));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	ip = mtod(m0, <span class="enscript-type">struct</span> ip *);

	dst = satosin((<span class="enscript-type">void</span> *)&amp;ro-&gt;ro_dst);
	dst-&gt;sin_family = AF_INET;
	dst-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*dst);
	dst-&gt;sin_addr = ip-&gt;ip_dst;

	<span class="enscript-keyword">if</span> (r-&gt;rt == PF_FASTROUTE) {
		rtalloc(ro);
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt == NULL) {
			ipstat.ips_noroute++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		ifp = ro-&gt;ro_rt-&gt;rt_ifp;
		RT_LOCK(ro-&gt;ro_rt);
		ro-&gt;ro_rt-&gt;rt_use++;

		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt-&gt;rt_flags &amp; RTF_GATEWAY)
			dst = satosin((<span class="enscript-type">void</span> *)ro-&gt;ro_rt-&gt;rt_gateway);
		RT_UNLOCK(ro-&gt;ro_rt);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;r-&gt;rpool.list)) {
			DPFPRINTF(PF_DEBUG_URGENT,
			    (<span class="enscript-string">&quot;pf_route: TAILQ_EMPTY(&amp;r-&gt;rpool.list)\n&quot;</span>));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">if</span> (s == NULL) {
			pf_map_addr(AF_INET, r, (<span class="enscript-type">struct</span> pf_addr *)&amp;ip-&gt;ip_src,
			    &amp;naddr, NULL, &amp;sn);
			<span class="enscript-keyword">if</span> (!PF_AZERO(&amp;naddr, AF_INET))
				dst-&gt;sin_addr.s_addr = naddr.v4.s_addr;
			ifp = r-&gt;rpool.cur-&gt;kif ?
			    r-&gt;rpool.cur-&gt;kif-&gt;pfik_ifp : NULL;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (!PF_AZERO(&amp;s-&gt;rt_addr, AF_INET))
				dst-&gt;sin_addr.s_addr =
				    s-&gt;rt_addr.v4.s_addr;
			ifp = s-&gt;rt_kif ? s-&gt;rt_kif-&gt;pfik_ifp : NULL;
		}
	}
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (oifp != ifp) {
		<span class="enscript-keyword">if</span> (pf_test(PF_OUT, ifp, &amp;m0, NULL, NULL) != PF_PASS)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m0 == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		<span class="enscript-keyword">if</span> (m0-&gt;m_len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip)) {
			DPFPRINTF(PF_DEBUG_URGENT,
			    (<span class="enscript-string">&quot;pf_route: m0-&gt;m_len &lt; sizeof (struct ip)\n&quot;</span>));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		ip = mtod(m0, <span class="enscript-type">struct</span> ip *);
	}

	<span class="enscript-comment">/* Catch routing changes wrt. hardware checksumming for TCP or UDP. */</span>
	ip_output_checksum(ifp, m0, ((ip-&gt;ip_hl) &lt;&lt; 2), ntohs(ip-&gt;ip_len),
	    &amp;sw_csum);

	<span class="enscript-keyword">if</span> (ntohs(ip-&gt;ip_len) &lt;= ifp-&gt;if_mtu || TSO_IPV4_OK(ifp, m0) ||
	    (!(ip-&gt;ip_off &amp; htons(IP_DF)) &amp;&amp;
	    (ifp-&gt;if_hwassist &amp; CSUM_FRAGMENT))) {
		ip-&gt;ip_sum = 0;
		<span class="enscript-keyword">if</span> (sw_csum &amp; CSUM_DELAY_IP) {
			ip-&gt;ip_sum = in_cksum(m0, ip-&gt;ip_hl &lt;&lt; 2);
			sw_csum &amp;= ~CSUM_DELAY_IP;
			m0-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_DELAY_IP;
		}
		error = ifnet_output(ifp, PF_INET, m0, ro-&gt;ro_rt, sintosa(dst));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Too large for interface; fragment if possible.
	 * Must be able to put at least 8 bytes per fragment.
	 * Balk when DF bit is set or the interface didn't support TSO.
	 */</span>
	<span class="enscript-keyword">if</span> ((ip-&gt;ip_off &amp; htons(IP_DF)) ||
	    (m0-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO_IPV4)) {
		ipstat.ips_cantfrag++;
		<span class="enscript-keyword">if</span> (r-&gt;rt != PF_DUPTO) {
			icmp_error(m0, ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG, 0,
			    ifp-&gt;if_mtu);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		} <span class="enscript-keyword">else</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	m1 = m0;

	<span class="enscript-comment">/* PR-8933605: send ip_len,ip_off to ip_fragment in host byte order */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	NTOHS(ip-&gt;ip_off);
	NTOHS(ip-&gt;ip_len);
#<span class="enscript-reference">endif</span>
	error = ip_fragment(m0, ifp, ifp-&gt;if_mtu, sw_csum);

	<span class="enscript-keyword">if</span> (error) {
		m0 = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">for</span> (m0 = m1; m0; m0 = m1) {
		m1 = m0-&gt;m_nextpkt;
		m0-&gt;m_nextpkt = 0;
		<span class="enscript-keyword">if</span> (error == 0)
			error = ifnet_output(ifp, PF_INET, m0, ro-&gt;ro_rt,
			    sintosa(dst));
		<span class="enscript-keyword">else</span>
			m_freem(m0);
	}

	<span class="enscript-keyword">if</span> (error == 0)
		ipstat.ips_fragmented++;

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (r-&gt;rt != PF_DUPTO)
		*m = NULL;

	ROUTE_RELEASE(&amp;iproute);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">bad</span>:
	m_freem(m0);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pf_route6</span>(<span class="enscript-type">struct</span> mbuf **m, <span class="enscript-type">struct</span> pf_rule *r, <span class="enscript-type">int</span> dir, <span class="enscript-type">struct</span> ifnet *oifp,
    <span class="enscript-type">struct</span> pf_state *s, <span class="enscript-type">struct</span> pf_pdesc *pd)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">pd</span>)
	<span class="enscript-type">struct</span> mbuf		*m0;
	<span class="enscript-type">struct</span> route_in6	 ip6route;
	<span class="enscript-type">struct</span> route_in6	*ro;
	<span class="enscript-type">struct</span> sockaddr_in6	*dst;
	<span class="enscript-type">struct</span> ip6_hdr		*ip6;
	<span class="enscript-type">struct</span> ifnet		*ifp = NULL;
	<span class="enscript-type">struct</span> pf_addr		 naddr;
	<span class="enscript-type">struct</span> pf_src_node	*sn = NULL;
	<span class="enscript-type">int</span>			 error = 0;

	<span class="enscript-keyword">if</span> (m == NULL || *m == NULL || r == NULL ||
	    (dir != PF_IN &amp;&amp; dir != PF_OUT) || oifp == NULL)
		panic(<span class="enscript-string">&quot;pf_route6: invalid parameters&quot;</span>);

	<span class="enscript-keyword">if</span> (pd-&gt;pf_mtag-&gt;pftag_routed++ &gt; 3) {
		m0 = *m;
		*m = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (r-&gt;rt == PF_DUPTO) {
		<span class="enscript-keyword">if</span> ((m0 = m_copym(*m, 0, M_COPYALL, M_NOWAIT)) == NULL)
			<span class="enscript-keyword">return</span>;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((r-&gt;rt == PF_REPLYTO) == (r-&gt;direction == dir))
			<span class="enscript-keyword">return</span>;
		m0 = *m;
	}

	<span class="enscript-keyword">if</span> (m0-&gt;m_len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr)) {
		DPFPRINTF(PF_DEBUG_URGENT,
		    (<span class="enscript-string">&quot;pf_route6: m0-&gt;m_len &lt; sizeof (struct ip6_hdr)\n&quot;</span>));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	ip6 = mtod(m0, <span class="enscript-type">struct</span> ip6_hdr *);

	ro = &amp;ip6route;
	bzero((caddr_t)ro, <span class="enscript-keyword">sizeof</span> (*ro));
	dst = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;ro-&gt;ro_dst;
	dst-&gt;sin6_family = AF_INET6;
	dst-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> (*dst);
	dst-&gt;sin6_addr = ip6-&gt;ip6_dst;

	<span class="enscript-comment">/* Cheat. XXX why only in the v6 case??? */</span>
	<span class="enscript-keyword">if</span> (r-&gt;rt == PF_FASTROUTE) {
		<span class="enscript-type">struct</span> pf_mtag *pf_mtag;

		<span class="enscript-keyword">if</span> ((pf_mtag = pf_get_mtag(m0)) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		pf_mtag-&gt;pftag_flags |= PF_TAG_GENERATED;
		ip6_output(m0, NULL, NULL, 0, NULL, NULL, NULL);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;r-&gt;rpool.list)) {
		DPFPRINTF(PF_DEBUG_URGENT,
		    (<span class="enscript-string">&quot;pf_route6: TAILQ_EMPTY(&amp;r-&gt;rpool.list)\n&quot;</span>));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">if</span> (s == NULL) {
		pf_map_addr(AF_INET6, r, (<span class="enscript-type">struct</span> pf_addr *)&amp;ip6-&gt;ip6_src,
		    &amp;naddr, NULL, &amp;sn);
		<span class="enscript-keyword">if</span> (!PF_AZERO(&amp;naddr, AF_INET6))
			PF_ACPY((<span class="enscript-type">struct</span> pf_addr *)&amp;dst-&gt;sin6_addr,
			    &amp;naddr, AF_INET6);
		ifp = r-&gt;rpool.cur-&gt;kif ? r-&gt;rpool.cur-&gt;kif-&gt;pfik_ifp : NULL;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (!PF_AZERO(&amp;s-&gt;rt_addr, AF_INET6))
			PF_ACPY((<span class="enscript-type">struct</span> pf_addr *)&amp;dst-&gt;sin6_addr,
			    &amp;s-&gt;rt_addr, AF_INET6);
		ifp = s-&gt;rt_kif ? s-&gt;rt_kif-&gt;pfik_ifp : NULL;
	}
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (oifp != ifp) {
		<span class="enscript-keyword">if</span> (pf_test6(PF_OUT, ifp, &amp;m0, NULL, NULL) != PF_PASS)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m0 == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		<span class="enscript-keyword">if</span> (m0-&gt;m_len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr)) {
			DPFPRINTF(PF_DEBUG_URGENT, (<span class="enscript-string">&quot;pf_route6: m0-&gt;m_len &quot;</span>
			    <span class="enscript-string">&quot;&lt; sizeof (struct ip6_hdr)\n&quot;</span>));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		ip6 = mtod(m0, <span class="enscript-type">struct</span> ip6_hdr *);
	}

	<span class="enscript-comment">/*
	 * If the packet is too large for the outgoing interface,
	 * send back an icmp6 error.
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;dst-&gt;sin6_addr))
		dst-&gt;sin6_addr.s6_addr16[1] = htons(ifp-&gt;if_index);
	<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>)m0-&gt;m_pkthdr.len &lt;= ifp-&gt;if_mtu) {
		error = nd6_output(ifp, ifp, m0, dst, NULL, NULL);
	} <span class="enscript-keyword">else</span> {
		in6_ifstat_inc(ifp, ifs6_in_toobig);
		<span class="enscript-keyword">if</span> (r-&gt;rt != PF_DUPTO)
			icmp6_error(m0, ICMP6_PACKET_TOO_BIG, 0, ifp-&gt;if_mtu);
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (r-&gt;rt != PF_DUPTO)
		*m = NULL;
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">bad</span>:
	m_freem(m0);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>


<span class="enscript-comment">/*
 * check protocol (tcp/udp/icmp/icmp6) checksum and set mbuf flag
 *   off is the offset where the protocol header starts
 *   len is the total length of protocol header plus payload
 * returns 0 when the checksum is valid, otherwise returns 1.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_check_proto_cksum</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> len, u_int8_t p,
    sa_family_t af)
{
	u_int16_t sum;

	<span class="enscript-keyword">switch</span> (p) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		<span class="enscript-comment">/*
		 * Optimize for the common case; if the hardware calculated
		 * value doesn't include pseudo-header checksum, or if it
		 * is partially-computed (only 16-bit summation), do it in
		 * software below.
		 */</span>
		<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp;
		    (CSUM_DATA_VALID | CSUM_PSEUDO_HDR)) ==
		    (CSUM_DATA_VALID | CSUM_PSEUDO_HDR) &amp;&amp;
		    (m-&gt;m_pkthdr.csum_data ^ 0xffff) == 0) {
			<span class="enscript-keyword">return</span> (0);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">if</span> (off &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) || len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr))
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; off + len)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		<span class="enscript-keyword">if</span> (p == IPPROTO_ICMP) {
			<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; off)
				<span class="enscript-keyword">return</span> (1);
			m-&gt;m_data += off;
			m-&gt;m_len -= off;
			sum = in_cksum(m, len);
			m-&gt;m_data -= off;
			m-&gt;m_len += off;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip))
				<span class="enscript-keyword">return</span> (1);
			sum = inet_cksum(m, p, off, len);
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr))
			<span class="enscript-keyword">return</span> (1);
		sum = inet6_cksum(m, p, off, len);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">if</span> (sum) {
		<span class="enscript-keyword">switch</span> (p) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
			tcpstat.tcps_rcvbadsum++;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
			udpstat.udps_badsum++;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
			icmpstat.icps_checksum++;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
			icmp6stat.icp6s_checksum++;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		}
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PF_APPLE_UPDATE_PDESC_IPv4</span>()				\
	<span class="enscript-keyword">do</span> {							\
		<span class="enscript-keyword">if</span> (m &amp;&amp; pd.mp &amp;&amp; m != pd.mp) {			\
			m = pd.mp;				\
			h = mtod(m, <span class="enscript-type">struct</span> ip *);		\
			pd.pf_mtag = pf_get_mtag(m);		\
		}						\
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_test</span>(<span class="enscript-type">int</span> dir, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf **m0,
    <span class="enscript-type">struct</span> ether_header *eh, <span class="enscript-type">struct</span> ip_fw_args *fwa)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">DUMMYNET</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">fwa</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> pfi_kif		*kif;
	u_short			 action = PF_PASS, reason = 0, log = 0;
	<span class="enscript-type">struct</span> mbuf		*m = *m0;
	<span class="enscript-type">struct</span> ip		*h = 0;
	<span class="enscript-type">struct</span> pf_rule		*a = NULL, *r = &amp;pf_default_rule, *tr, *nr;
	<span class="enscript-type">struct</span> pf_state		*s = NULL;
	<span class="enscript-type">struct</span> pf_state_key	*sk = NULL;
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset = NULL;
	<span class="enscript-type">struct</span> pf_pdesc		 pd;
	<span class="enscript-type">int</span>			 off, dirndx, pqid = 0;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!pf_status.running)
		<span class="enscript-keyword">return</span> (PF_PASS);

	memset(&amp;pd, 0, <span class="enscript-keyword">sizeof</span> (pd));

	<span class="enscript-keyword">if</span> ((pd.pf_mtag = pf_get_mtag(m)) == NULL) {
		DPFPRINTF(PF_DEBUG_URGENT,
		    (<span class="enscript-string">&quot;pf_test: pf_get_mtag returned NULL\n&quot;</span>));
		<span class="enscript-keyword">return</span> (PF_DROP);
	}

	<span class="enscript-keyword">if</span> (pd.pf_mtag-&gt;pftag_flags &amp; PF_TAG_GENERATED)
		<span class="enscript-keyword">return</span> (PF_PASS);

	kif = (<span class="enscript-type">struct</span> pfi_kif *)ifp-&gt;if_pf_kif;

	<span class="enscript-keyword">if</span> (kif == NULL) {
		DPFPRINTF(PF_DEBUG_URGENT,
		    (<span class="enscript-string">&quot;pf_test: kif == NULL, if_name %s\n&quot;</span>, ifp-&gt;if_name));
		<span class="enscript-keyword">return</span> (PF_DROP);
	}
	<span class="enscript-keyword">if</span> (kif-&gt;pfik_flags &amp; PFI_IFLAG_SKIP)
		<span class="enscript-keyword">return</span> (PF_PASS);

	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-comment">/* initialize enough of pd for the done label */</span>
	h = mtod(m, <span class="enscript-type">struct</span> ip *);
	pd.mp = m;
	pd.lmw = 0;
	pd.pf_mtag = pf_get_mtag(m);
	pd.src = (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip_src;
	pd.dst = (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip_dst;
	PF_ACPY(&amp;pd.baddr, pd.src, AF_INET);
	PF_ACPY(&amp;pd.bdaddr, pd.dst, AF_INET);
	pd.ip_sum = &amp;h-&gt;ip_sum;
	pd.proto = h-&gt;ip_p;
	pd.proto_variant = 0;
	pd.af = AF_INET;
	pd.tos = h-&gt;ip_tos;
	pd.ttl = h-&gt;ip_ttl;
	pd.tot_len = ntohs(h-&gt;ip_len);
	pd.eh = eh;

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (*h)) {
		action = PF_DROP;
		REASON_SET(&amp;reason, PFRES_SHORT);
		log = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> (fwa != NULL &amp;&amp; fwa-&gt;fwa_pf_rule != NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nonormalize</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

	<span class="enscript-comment">/* We do IP header normalization and packet reassembly here */</span>
	action = pf_normalize_ip(m0, dir, kif, &amp;reason, &amp;pd);
	pd.mp = m = *m0;
	<span class="enscript-keyword">if</span> (action != PF_PASS || pd.lmw &lt; 0) {
		action = PF_DROP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
<span class="enscript-reference">nonormalize</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
	m = *m0;	<span class="enscript-comment">/* pf_normalize messes with m0 */</span>
	h = mtod(m, <span class="enscript-type">struct</span> ip *);

	off = h-&gt;ip_hl &lt;&lt; 2;
	<span class="enscript-keyword">if</span> (off &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (*h)) {
		action = PF_DROP;
		REASON_SET(&amp;reason, PFRES_SHORT);
		log = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	pd.src = (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip_src;
	pd.dst = (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip_dst;
	PF_ACPY(&amp;pd.baddr, pd.src, AF_INET);
	PF_ACPY(&amp;pd.bdaddr, pd.dst, AF_INET);
	pd.ip_sum = &amp;h-&gt;ip_sum;
	pd.proto = h-&gt;ip_p;
	pd.proto_variant = 0;
	pd.mp = m;
	pd.lmw = 0;
	pd.pf_mtag = pf_get_mtag(m);
	pd.af = AF_INET;
	pd.tos = h-&gt;ip_tos;
	pd.ttl = h-&gt;ip_ttl;
	pd.sc = MBUF_SCIDX(mbuf_get_service_class(m));
	pd.tot_len = ntohs(h-&gt;ip_len);
	pd.eh = eh;

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_FLOW_ID) {
		pd.flowsrc = m-&gt;m_pkthdr.pkt_flowsrc;
		pd.flowhash = m-&gt;m_pkthdr.pkt_flowid;
		pd.pktflags = (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_FLOW_MASK);
	}

	<span class="enscript-comment">/* handle fragments that didn't get reassembled by normalization */</span>
	<span class="enscript-keyword">if</span> (h-&gt;ip_off &amp; htons(IP_MF | IP_OFFMASK)) {
		pd.flags |= PFDESC_IP_FRAG;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		action = pf_test_fragment(&amp;r, dir, kif, m, h,
		    &amp;pd, &amp;a, &amp;ruleset);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">switch</span> (h-&gt;ip_p) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>: {
		<span class="enscript-type">struct</span> tcphdr	th;
		pd.hdr.tcp = &amp;th;
		<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;th, <span class="enscript-keyword">sizeof</span> (th),
		    &amp;action, &amp;reason, AF_INET)) {
			log = action != PF_PASS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		pd.p_len = pd.tot_len - off - (th.th_off &lt;&lt; 2);
		<span class="enscript-keyword">if</span> ((th.th_flags &amp; TH_ACK) &amp;&amp; pd.p_len == 0)
			pqid = 1;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		action = pf_normalize_tcp(dir, kif, m, 0, off, h, &amp;pd);
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		PF_APPLE_UPDATE_PDESC_IPv4();
		<span class="enscript-keyword">if</span> (action == PF_DROP)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		action = pf_test_state_tcp(&amp;s, dir, kif, m, off, h, &amp;pd,
		    &amp;reason);
		<span class="enscript-keyword">if</span> (action == PF_NAT64)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		PF_APPLE_UPDATE_PDESC_IPv4();
		<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
			pfsync_update_state(s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>
			r = s-&gt;rule.ptr;
			a = s-&gt;anchor.ptr;
			log = s-&gt;log;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == NULL)
			action = pf_test_rule(&amp;r, &amp;s, dir, kif,
			    m, off, h, &amp;pd, &amp;a, &amp;ruleset, NULL);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>: {
		<span class="enscript-type">struct</span> udphdr	uh;

		pd.hdr.udp = &amp;uh;
		<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;uh, <span class="enscript-keyword">sizeof</span> (uh),
		    &amp;action, &amp;reason, AF_INET)) {
			log = action != PF_PASS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">if</span> (uh.uh_dport == 0 ||
		    ntohs(uh.uh_ulen) &gt; m-&gt;m_pkthdr.len - off ||
		    ntohs(uh.uh_ulen) &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr)) {
			action = PF_DROP;
			REASON_SET(&amp;reason, PFRES_SHORT);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		action = pf_test_state_udp(&amp;s, dir, kif, m, off, h, &amp;pd,
		    &amp;reason);
		<span class="enscript-keyword">if</span> (action == PF_NAT64)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		PF_APPLE_UPDATE_PDESC_IPv4();
		<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
			pfsync_update_state(s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>
			r = s-&gt;rule.ptr;
			a = s-&gt;anchor.ptr;
			log = s-&gt;log;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == NULL)
			action = pf_test_rule(&amp;r, &amp;s, dir, kif,
			    m, off, h, &amp;pd, &amp;a, &amp;ruleset, NULL);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>: {
		<span class="enscript-type">struct</span> icmp	ih;

		pd.hdr.icmp = &amp;ih;
		<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;ih, ICMP_MINLEN,
		    &amp;action, &amp;reason, AF_INET)) {
			log = action != PF_PASS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		action = pf_test_state_icmp(&amp;s, dir, kif, m, off, h, &amp;pd,
		    &amp;reason);
		<span class="enscript-keyword">if</span> (action == PF_NAT64)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		PF_APPLE_UPDATE_PDESC_IPv4();
		<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
			pfsync_update_state(s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>
			r = s-&gt;rule.ptr;
			a = s-&gt;anchor.ptr;
			log = s-&gt;log;
                } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == NULL)
			action = pf_test_rule(&amp;r, &amp;s, dir, kif,
			    m, off, h, &amp;pd, &amp;a, &amp;ruleset, NULL);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>: {
		<span class="enscript-type">struct</span> pf_esp_hdr	esp;

		pd.hdr.esp = &amp;esp;
		<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;esp, <span class="enscript-keyword">sizeof</span> (esp), &amp;action, &amp;reason,
		    AF_INET)) {
			log = action != PF_PASS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		action = pf_test_state_esp(&amp;s, dir, kif, off, &amp;pd);
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		PF_APPLE_UPDATE_PDESC_IPv4();
		<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
			pfsync_update_state(s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>
			r = s-&gt;rule.ptr;
			a = s-&gt;anchor.ptr;
			log = s-&gt;log;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == NULL)
			action = pf_test_rule(&amp;r, &amp;s, dir, kif,
			    m, off, h, &amp;pd, &amp;a, &amp;ruleset, NULL);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>: {
		<span class="enscript-type">struct</span> pf_grev1_hdr	grev1;
		pd.hdr.grev1 = &amp;grev1;
		<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;grev1, <span class="enscript-keyword">sizeof</span> (grev1), &amp;action,
		    &amp;reason, AF_INET)) {
			log = (action != PF_PASS);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		<span class="enscript-keyword">if</span> ((ntohs(grev1.flags) &amp; PF_GRE_FLAG_VERSION_MASK) == 1 &amp;&amp;
		    ntohs(grev1.protocol_type) == PF_GRE_PPP_ETHERTYPE) {
			<span class="enscript-keyword">if</span> (ntohs(grev1.payload_length) &gt;
			    m-&gt;m_pkthdr.len - off) {
				action = PF_DROP;
				REASON_SET(&amp;reason, PFRES_SHORT);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			pd.proto_variant = PF_GRE_PPTP_VARIANT;
			action = pf_test_state_grev1(&amp;s, dir, kif, off, &amp;pd);
			<span class="enscript-keyword">if</span> (pd.lmw &lt; 0) <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			PF_APPLE_UPDATE_PDESC_IPv4();
			<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
				pfsync_update_state(s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>
				r = s-&gt;rule.ptr;
				a = s-&gt;anchor.ptr;
				log = s-&gt;log;
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == NULL) {
				action = pf_test_rule(&amp;r, &amp;s, dir, kif, m, off,
				    h, &amp;pd, &amp;a, &amp;ruleset, NULL);
				<span class="enscript-keyword">if</span> (action == PF_PASS)
					<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-comment">/* not GREv1/PPTP, so treat as ordinary GRE... */</span>
	}

	<span class="enscript-reference">default</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		action = pf_test_state_other(&amp;s, dir, kif, &amp;pd);
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		PF_APPLE_UPDATE_PDESC_IPv4();
		<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
			pfsync_update_state(s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>
			r = s-&gt;rule.ptr;
			a = s-&gt;anchor.ptr;
			log = s-&gt;log;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == NULL)
			action = pf_test_rule(&amp;r, &amp;s, dir, kif, m, off, h,
			    &amp;pd, &amp;a, &amp;ruleset, NULL);
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (action == PF_NAT64) {
		*m0 = NULL;
		<span class="enscript-keyword">return</span> (action);
	}

	*m0 = pd.mp;
	PF_APPLE_UPDATE_PDESC_IPv4();

	<span class="enscript-keyword">if</span> (action == PF_PASS &amp;&amp; h-&gt;ip_hl &gt; 5 &amp;&amp;
	    !((s &amp;&amp; s-&gt;allow_opts) || r-&gt;allow_opts)) {
		action = PF_DROP;
		REASON_SET(&amp;reason, PFRES_IPOPTIONS);
		log = 1;
		DPFPRINTF(PF_DEBUG_MISC,
		    (<span class="enscript-string">&quot;pf: dropping packet with ip options [hlen=%u]\n&quot;</span>,
		    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) h-&gt;ip_hl));
	}

	<span class="enscript-keyword">if</span> ((s &amp;&amp; s-&gt;tag) || PF_RTABLEID_IS_VALID(r-&gt;rtableid) ||
	    (pd.pktflags &amp; PKTF_FLOW_ID))
		(<span class="enscript-type">void</span>) pf_tag_packet(m, pd.pf_mtag, s ? s-&gt;tag : 0,
		    r-&gt;rtableid, &amp;pd);

	<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
		<span class="enscript-keyword">if</span> (altq_allowed &amp;&amp; r-&gt;qid) {
			<span class="enscript-keyword">if</span> (pqid || (pd.tos &amp; IPTOS_LOWDELAY))
				pd.pf_mtag-&gt;pftag_qid = r-&gt;pqid;
			<span class="enscript-keyword">else</span>
				pd.pf_mtag-&gt;pftag_qid = r-&gt;qid;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ECN</span>
		<span class="enscript-comment">/* add hints for ecn */</span>
		pd.pf_mtag-&gt;pftag_hdr = h;
		<span class="enscript-comment">/* record address family */</span>
		pd.pf_mtag-&gt;pftag_flags &amp;= ~PF_TAG_HDR_INET6;
		pd.pf_mtag-&gt;pftag_flags |= PF_TAG_HDR_INET;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ECN */</span>
		<span class="enscript-comment">/* record protocol */</span>
		m-&gt;m_pkthdr.pkt_proto = pd.proto;
	}

	<span class="enscript-comment">/*
	 * connections redirected to loopback should not match sockets
	 * bound specifically to loopback due to security implications,
	 * see tcp_input() and in_pcblookup_listen().
	 */</span>
	<span class="enscript-keyword">if</span> (dir == PF_IN &amp;&amp; action == PF_PASS &amp;&amp; (pd.proto == IPPROTO_TCP ||
	    pd.proto == IPPROTO_UDP) &amp;&amp; s != NULL &amp;&amp; s-&gt;nat_rule.ptr != NULL &amp;&amp;
	    (s-&gt;nat_rule.ptr-&gt;action == PF_RDR ||
	    s-&gt;nat_rule.ptr-&gt;action == PF_BINAT) &amp;&amp;
	    (ntohl(pd.dst-&gt;v4.s_addr) &gt;&gt; IN_CLASSA_NSHIFT) == IN_LOOPBACKNET)
		pd.pf_mtag-&gt;pftag_flags |= PF_TAG_TRANSLATE_LOCALHOST;

	<span class="enscript-keyword">if</span> (log) {
		<span class="enscript-type">struct</span> pf_rule *lr;

		<span class="enscript-keyword">if</span> (s != NULL &amp;&amp; s-&gt;nat_rule.ptr != NULL &amp;&amp;
		    s-&gt;nat_rule.ptr-&gt;log &amp; PF_LOG_ALL)
			lr = s-&gt;nat_rule.ptr;
		<span class="enscript-keyword">else</span>
			lr = r;
		PFLOG_PACKET(kif, h, m, AF_INET, dir, reason, lr, a, ruleset,
		    &amp;pd);
	}

	kif-&gt;pfik_bytes[0][dir == PF_OUT][action != PF_PASS] += pd.tot_len;
	kif-&gt;pfik_packets[0][dir == PF_OUT][action != PF_PASS]++;

	<span class="enscript-keyword">if</span> (action == PF_PASS || r-&gt;action == PF_DROP) {
		dirndx = (dir == PF_OUT);
		r-&gt;packets[dirndx]++;
		r-&gt;bytes[dirndx] += pd.tot_len;
		<span class="enscript-keyword">if</span> (a != NULL) {
			a-&gt;packets[dirndx]++;
			a-&gt;bytes[dirndx] += pd.tot_len;
		}
		<span class="enscript-keyword">if</span> (s != NULL) {
			sk = s-&gt;state_key;
			<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr != NULL) {
				s-&gt;nat_rule.ptr-&gt;packets[dirndx]++;
				s-&gt;nat_rule.ptr-&gt;bytes[dirndx] += pd.tot_len;
			}
			<span class="enscript-keyword">if</span> (s-&gt;src_node != NULL) {
				s-&gt;src_node-&gt;packets[dirndx]++;
				s-&gt;src_node-&gt;bytes[dirndx] += pd.tot_len;
			}
			<span class="enscript-keyword">if</span> (s-&gt;nat_src_node != NULL) {
				s-&gt;nat_src_node-&gt;packets[dirndx]++;
				s-&gt;nat_src_node-&gt;bytes[dirndx] += pd.tot_len;
			}
			dirndx = (dir == sk-&gt;direction) ? 0 : 1;
			s-&gt;packets[dirndx]++;
			s-&gt;bytes[dirndx] += pd.tot_len;
		}
		tr = r;
		nr = (s != NULL) ? s-&gt;nat_rule.ptr : pd.nat_rule;
		<span class="enscript-keyword">if</span> (nr != NULL) {
			<span class="enscript-type">struct</span> pf_addr *x;
			<span class="enscript-comment">/*
			 * XXX: we need to make sure that the addresses
			 * passed to pfr_update_stats() are the same than
			 * the addresses used during matching (pfr_match)
			 */</span>
			<span class="enscript-keyword">if</span> (r == &amp;pf_default_rule) {
				tr = nr;
				x = (sk == NULL || sk-&gt;direction == dir) ?
				    &amp;pd.baddr : &amp;pd.naddr;
			} <span class="enscript-keyword">else</span>
				x = (sk == NULL || sk-&gt;direction == dir) ?
				    &amp;pd.naddr : &amp;pd.baddr;
			<span class="enscript-keyword">if</span> (x == &amp;pd.baddr || s == NULL) {
				<span class="enscript-comment">/* we need to change the address */</span>
				<span class="enscript-keyword">if</span> (dir == PF_OUT)
					pd.src = x;
				<span class="enscript-keyword">else</span>
					pd.dst = x;
			}
		}
		<span class="enscript-keyword">if</span> (tr-&gt;src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr-&gt;src.addr.p.tbl, (sk == NULL ||
			    sk-&gt;direction == dir) ?
			    pd.src : pd.dst, pd.af,
			    pd.tot_len, dir == PF_OUT, r-&gt;action == PF_PASS,
			    tr-&gt;src.neg);
		<span class="enscript-keyword">if</span> (tr-&gt;dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr-&gt;dst.addr.p.tbl, (sk == NULL ||
			    sk-&gt;direction == dir) ? pd.dst : pd.src, pd.af,
			    pd.tot_len, dir == PF_OUT, r-&gt;action == PF_PASS,
			    tr-&gt;dst.neg);
	}

	VERIFY(m == NULL || pd.mp == NULL || pd.mp == m);

	<span class="enscript-keyword">if</span> (*m0) {
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0) {
			REASON_SET(&amp;reason, PFRES_MEMORY);
			action = PF_DROP;
		}

		<span class="enscript-keyword">if</span> (action == PF_DROP) {
			m_freem(*m0);
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (PF_DROP);
		}

		*m0 = m;
	}

	<span class="enscript-keyword">if</span> (action == PF_SYNPROXY_DROP) {
		m_freem(*m0);
		*m0 = NULL;
		action = PF_PASS;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;rt)
		<span class="enscript-comment">/* pf_route can free the mbuf causing *m0 to become NULL */</span>
		pf_route(m0, r, dir, kif-&gt;pfik_ifp, s, &amp;pd);

	<span class="enscript-keyword">return</span> (action);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PF_APPLE_UPDATE_PDESC_IPv6</span>()				\
	<span class="enscript-keyword">do</span> {							\
		<span class="enscript-keyword">if</span> (m &amp;&amp; pd.mp &amp;&amp; m != pd.mp) {			\
			<span class="enscript-keyword">if</span> (n == m)				\
				n = pd.mp;			\
			m = pd.mp;				\
			h = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);		\
		}						\
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">int</span>
<span class="enscript-function-name">pf_test6</span>(<span class="enscript-type">int</span> dir, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf **m0,
    <span class="enscript-type">struct</span> ether_header *eh, <span class="enscript-type">struct</span> ip_fw_args *fwa)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">DUMMYNET</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">fwa</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> pfi_kif		*kif;
	u_short			 action = PF_PASS, reason = 0, log = 0;
	<span class="enscript-type">struct</span> mbuf		*m = *m0, *n = NULL;
	<span class="enscript-type">struct</span> ip6_hdr		*h;
	<span class="enscript-type">struct</span> pf_rule		*a = NULL, *r = &amp;pf_default_rule, *tr, *nr;
	<span class="enscript-type">struct</span> pf_state		*s = NULL;
	<span class="enscript-type">struct</span> pf_state_key	*sk = NULL;
	<span class="enscript-type">struct</span> pf_ruleset	*ruleset = NULL;
	<span class="enscript-type">struct</span> pf_pdesc		 pd;
	<span class="enscript-type">int</span>			 off, terminal = 0, dirndx, rh_cnt = 0;
	u_int8_t		 nxt;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!pf_status.running)
		<span class="enscript-keyword">return</span> (PF_PASS);

	memset(&amp;pd, 0, <span class="enscript-keyword">sizeof</span> (pd));

	<span class="enscript-keyword">if</span> ((pd.pf_mtag = pf_get_mtag(m)) == NULL) {
		DPFPRINTF(PF_DEBUG_URGENT,
		    (<span class="enscript-string">&quot;pf_test6: pf_get_mtag returned NULL\n&quot;</span>));
		<span class="enscript-keyword">return</span> (PF_DROP);
	}

	<span class="enscript-keyword">if</span> (pd.pf_mtag-&gt;pftag_flags &amp; PF_TAG_GENERATED)
		<span class="enscript-keyword">return</span> (PF_PASS);

	kif = (<span class="enscript-type">struct</span> pfi_kif *)ifp-&gt;if_pf_kif;

	<span class="enscript-keyword">if</span> (kif == NULL) {
		DPFPRINTF(PF_DEBUG_URGENT,
		    (<span class="enscript-string">&quot;pf_test6: kif == NULL, if_name %s\n&quot;</span>, ifp-&gt;if_name));
		<span class="enscript-keyword">return</span> (PF_DROP);
	}
	<span class="enscript-keyword">if</span> (kif-&gt;pfik_flags &amp; PFI_IFLAG_SKIP)
		<span class="enscript-keyword">return</span> (PF_PASS);

	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	h = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

	nxt = h-&gt;ip6_nxt;
	off = ((caddr_t)h - m-&gt;m_data) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
	pd.mp = m;
	pd.lmw = 0;
	pd.pf_mtag = pf_get_mtag(m);
	pd.src = (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip6_src;
	pd.dst = (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip6_dst;
	PF_ACPY(&amp;pd.baddr, pd.src, AF_INET6);
	PF_ACPY(&amp;pd.bdaddr, pd.dst, AF_INET6);
	pd.ip_sum = NULL;
	pd.af = AF_INET6;
	pd.proto = nxt;
	pd.proto_variant = 0;
	pd.tos = 0;
	pd.ttl = h-&gt;ip6_hlim;
	pd.sc = MBUF_SCIDX(mbuf_get_service_class(m));
	pd.tot_len = ntohs(h-&gt;ip6_plen) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
	pd.eh = eh;

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_FLOW_ID) {
		pd.flowsrc = m-&gt;m_pkthdr.pkt_flowsrc;
		pd.flowhash = m-&gt;m_pkthdr.pkt_flowid;
		pd.pktflags = (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_FLOW_MASK);
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (*h)) {
		action = PF_DROP;
		REASON_SET(&amp;reason, PFRES_SHORT);
		log = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> (fwa != NULL &amp;&amp; fwa-&gt;fwa_pf_rule != NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nonormalize</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

	<span class="enscript-comment">/* We do IP header normalization and packet reassembly here */</span>
	action = pf_normalize_ip6(m0, dir, kif, &amp;reason, &amp;pd);
	pd.mp = m = *m0;
	<span class="enscript-keyword">if</span> (action != PF_PASS || pd.lmw &lt; 0) {
		action = PF_DROP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
<span class="enscript-reference">nonormalize</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
	h = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

#<span class="enscript-reference">if</span> 1
	<span class="enscript-comment">/*
	 * we do not support jumbogram yet.  if we keep going, zero ip6_plen
	 * will do something bad, so drop the packet for now.
	 */</span>
	<span class="enscript-keyword">if</span> (htons(h-&gt;ip6_plen) == 0) {
		action = PF_DROP;
		REASON_SET(&amp;reason, PFRES_NORM);	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
#<span class="enscript-reference">endif</span>

	pd.src = (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip6_src;
	pd.dst = (<span class="enscript-type">struct</span> pf_addr *)&amp;h-&gt;ip6_dst;
	PF_ACPY(&amp;pd.baddr, pd.src, AF_INET6);
	PF_ACPY(&amp;pd.bdaddr, pd.dst, AF_INET6);
	pd.ip_sum = NULL;
	pd.af = AF_INET6;
	pd.tos = 0;
	pd.ttl = h-&gt;ip6_hlim;
	pd.tot_len = ntohs(h-&gt;ip6_plen) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr);
	pd.eh = eh;

	off = ((caddr_t)h - m-&gt;m_data) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr);
	pd.proto = h-&gt;ip6_nxt;
	pd.proto_variant = 0;
	pd.mp = m;
	pd.lmw = 0;
	pd.pf_mtag = pf_get_mtag(m);

	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">switch</span> (nxt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_FRAGMENT</span>: {
			<span class="enscript-type">struct</span> ip6_frag ip6f;

			pd.flags |= PFDESC_IP_FRAG;
			<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;ip6f, <span class="enscript-keyword">sizeof</span> ip6f, NULL,
			    &amp;reason, pd.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    (<span class="enscript-string">&quot;pf: IPv6 short fragment header\n&quot;</span>));
				action = PF_DROP;
				REASON_SET(&amp;reason, PFRES_SHORT);
				log = 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			pd.proto = nxt = ip6f.ip6f_nxt;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
			<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
			action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
			<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
				*m0 = NULL;
				<span class="enscript-keyword">return</span> (action);
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
			action = pf_test_fragment(&amp;r, dir, kif, m, h, &amp;pd, &amp;a,
			    &amp;ruleset);
			<span class="enscript-keyword">if</span> (action == PF_DROP) {
				REASON_SET(&amp;reason, PFRES_FRAG);
				log = 1;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ROUTING</span>:
			++rh_cnt;
			<span class="enscript-comment">/* FALL THROUGH */</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_HOPOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_DSTOPTS</span>: {
			<span class="enscript-comment">/* get next header and header length */</span>
			<span class="enscript-type">struct</span> ip6_ext	opt6;

			<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;opt6, <span class="enscript-keyword">sizeof</span>(opt6),
			    NULL, &amp;reason, pd.af)) {
				DPFPRINTF(PF_DEBUG_MISC,
				    (<span class="enscript-string">&quot;pf: IPv6 short opt\n&quot;</span>));
				action = PF_DROP;
				log = 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (pd.proto == IPPROTO_AH)
				off += (opt6.ip6e_len + 2) * 4;
			<span class="enscript-keyword">else</span>
				off += (opt6.ip6e_len + 1) * 8;
			nxt = opt6.ip6e_nxt;
			<span class="enscript-comment">/* goto the next header */</span>
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>:
			terminal++;
			<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">while</span> (!terminal);

	<span class="enscript-comment">/* if there's no routing header, use unmodified mbuf for checksumming */</span>
	<span class="enscript-keyword">if</span> (!n)
		n = m;

	<span class="enscript-keyword">switch</span> (pd.proto) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>: {
		<span class="enscript-type">struct</span> tcphdr	th;

		pd.hdr.tcp = &amp;th;
		<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;th, <span class="enscript-keyword">sizeof</span> (th),
		    &amp;action, &amp;reason, AF_INET6)) {
			log = action != PF_PASS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		pd.p_len = pd.tot_len - off - (th.th_off &lt;&lt; 2);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		action = pf_normalize_tcp(dir, kif, m, 0, off, h, &amp;pd);
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		PF_APPLE_UPDATE_PDESC_IPv6();
		<span class="enscript-keyword">if</span> (action == PF_DROP)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		action = pf_test_state_tcp(&amp;s, dir, kif, m, off, h, &amp;pd,
		    &amp;reason);
		<span class="enscript-keyword">if</span> (action == PF_NAT64)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		PF_APPLE_UPDATE_PDESC_IPv6();
		<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
			pfsync_update_state(s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>
			r = s-&gt;rule.ptr;
			a = s-&gt;anchor.ptr;
			log = s-&gt;log;
                } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == NULL)
			action = pf_test_rule(&amp;r, &amp;s, dir, kif,
			    m, off, h, &amp;pd, &amp;a, &amp;ruleset, NULL);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>: {
		<span class="enscript-type">struct</span> udphdr	uh;

		pd.hdr.udp = &amp;uh;
		<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;uh, <span class="enscript-keyword">sizeof</span> (uh),
		    &amp;action, &amp;reason, AF_INET6)) {
			log = action != PF_PASS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">if</span> (uh.uh_dport == 0 ||
		    ntohs(uh.uh_ulen) &gt; m-&gt;m_pkthdr.len - off ||
		    ntohs(uh.uh_ulen) &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr)) {
			action = PF_DROP;
			REASON_SET(&amp;reason, PFRES_SHORT);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		action = pf_test_state_udp(&amp;s, dir, kif, m, off, h, &amp;pd,
		    &amp;reason);
		<span class="enscript-keyword">if</span> (action == PF_NAT64)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		PF_APPLE_UPDATE_PDESC_IPv6();
		<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
			pfsync_update_state(s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>
			r = s-&gt;rule.ptr;
			a = s-&gt;anchor.ptr;
			log = s-&gt;log;
                } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == NULL)
			action = pf_test_rule(&amp;r, &amp;s, dir, kif,
			    m, off, h, &amp;pd, &amp;a, &amp;ruleset, NULL);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>: {
		<span class="enscript-type">struct</span> icmp6_hdr	ih;

		pd.hdr.icmp6 = &amp;ih;
		<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;ih, <span class="enscript-keyword">sizeof</span> (ih),
		    &amp;action, &amp;reason, AF_INET6)) {
			log = action != PF_PASS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		action = pf_test_state_icmp(&amp;s, dir, kif,
		    m, off, h, &amp;pd, &amp;reason);
		<span class="enscript-keyword">if</span> (action == PF_NAT64)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		PF_APPLE_UPDATE_PDESC_IPv6();
		<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
			pfsync_update_state(s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>
			r = s-&gt;rule.ptr;
			a = s-&gt;anchor.ptr;
			log = s-&gt;log;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == NULL)
			action = pf_test_rule(&amp;r, &amp;s, dir, kif,
			    m, off, h, &amp;pd, &amp;a, &amp;ruleset, NULL);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>: {
		<span class="enscript-type">struct</span> pf_esp_hdr	esp;

		pd.hdr.esp = &amp;esp;
		<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;esp, <span class="enscript-keyword">sizeof</span> (esp), &amp;action, &amp;reason,
		    AF_INET6)) {
			log = action != PF_PASS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		action = pf_test_state_esp(&amp;s, dir, kif, off, &amp;pd);
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		PF_APPLE_UPDATE_PDESC_IPv6();
		<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
			pfsync_update_state(s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>
			r = s-&gt;rule.ptr;
			a = s-&gt;anchor.ptr;
			log = s-&gt;log;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == NULL)
			action = pf_test_rule(&amp;r, &amp;s, dir, kif,
			    m, off, h, &amp;pd, &amp;a, &amp;ruleset, NULL);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_GRE</span>: {
		<span class="enscript-type">struct</span> pf_grev1_hdr	grev1;

		pd.hdr.grev1 = &amp;grev1;
		<span class="enscript-keyword">if</span> (!pf_pull_hdr(m, off, &amp;grev1, <span class="enscript-keyword">sizeof</span> (grev1), &amp;action,
		    &amp;reason, AF_INET6)) {
			log = (action != PF_PASS);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		<span class="enscript-keyword">if</span> ((ntohs(grev1.flags) &amp; PF_GRE_FLAG_VERSION_MASK) == 1 &amp;&amp;
		    ntohs(grev1.protocol_type) == PF_GRE_PPP_ETHERTYPE) {
			<span class="enscript-keyword">if</span> (ntohs(grev1.payload_length) &gt;
			    m-&gt;m_pkthdr.len - off) {
				action = PF_DROP;
				REASON_SET(&amp;reason, PFRES_SHORT);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			action = pf_test_state_grev1(&amp;s, dir, kif, off, &amp;pd);
			<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			PF_APPLE_UPDATE_PDESC_IPv6();
			<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
				pfsync_update_state(s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>
				r = s-&gt;rule.ptr;
				a = s-&gt;anchor.ptr;
				log = s-&gt;log;
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == NULL) {
				action = pf_test_rule(&amp;r, &amp;s, dir, kif, m, off,
				    h, &amp;pd, &amp;a, &amp;ruleset, NULL);
				<span class="enscript-keyword">if</span> (action == PF_PASS)
					<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-comment">/* not GREv1/PPTP, so treat as ordinary GRE... */</span>
	}

	<span class="enscript-reference">default</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-comment">/* Traffic goes through dummynet first */</span>
		action = pf_test_dummynet(&amp;r, dir, kif, &amp;m, &amp;pd, fwa);
		<span class="enscript-keyword">if</span> (action == PF_DROP || m == NULL) {
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (action);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		action = pf_test_state_other(&amp;s, dir, kif, &amp;pd);
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		PF_APPLE_UPDATE_PDESC_IPv6();
		<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NPFSYNC</span>
			pfsync_update_state(s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NPFSYNC */</span>
			r = s-&gt;rule.ptr;
			a = s-&gt;anchor.ptr;
			log = s-&gt;log;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s == NULL)
			action = pf_test_rule(&amp;r, &amp;s, dir, kif, m, off, h,
			    &amp;pd, &amp;a, &amp;ruleset, NULL);
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (action == PF_NAT64) {
		*m0 = NULL;
		<span class="enscript-keyword">return</span> (action);
	}

	*m0 = pd.mp;
	PF_APPLE_UPDATE_PDESC_IPv6();

	<span class="enscript-keyword">if</span> (n != m) {
		m_freem(n);
		n = NULL;
	}

	<span class="enscript-comment">/* handle dangerous IPv6 extension headers. */</span>
	<span class="enscript-keyword">if</span> (action == PF_PASS &amp;&amp; rh_cnt &amp;&amp;
	    !((s &amp;&amp; s-&gt;allow_opts) || r-&gt;allow_opts)) {
		action = PF_DROP;
		REASON_SET(&amp;reason, PFRES_IPOPTIONS);
		log = 1;
		DPFPRINTF(PF_DEBUG_MISC,
		    (<span class="enscript-string">&quot;pf: dropping packet with dangerous v6 headers\n&quot;</span>));
	}

	<span class="enscript-keyword">if</span> ((s &amp;&amp; s-&gt;tag) || PF_RTABLEID_IS_VALID(r-&gt;rtableid) ||
	    (pd.pktflags &amp; PKTF_FLOW_ID))
		(<span class="enscript-type">void</span>) pf_tag_packet(m, pd.pf_mtag, s ? s-&gt;tag : 0,
		    r-&gt;rtableid, &amp;pd);

	<span class="enscript-keyword">if</span> (action == PF_PASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
		<span class="enscript-keyword">if</span> (altq_allowed &amp;&amp; r-&gt;qid) {
			<span class="enscript-keyword">if</span> (pd.tos &amp; IPTOS_LOWDELAY)
				pd.pf_mtag-&gt;pftag_qid = r-&gt;pqid;
			<span class="enscript-keyword">else</span>
				pd.pf_mtag-&gt;pftag_qid = r-&gt;qid;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ECN</span>
		<span class="enscript-comment">/* add hints for ecn */</span>
		pd.pf_mtag-&gt;pftag_hdr = h;
		<span class="enscript-comment">/* record address family */</span>
		pd.pf_mtag-&gt;pftag_flags &amp;= ~PF_TAG_HDR_INET;
		pd.pf_mtag-&gt;pftag_flags |= PF_TAG_HDR_INET6;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ECN */</span>
		<span class="enscript-comment">/* record protocol */</span>
		m-&gt;m_pkthdr.pkt_proto = pd.proto;
	}

	<span class="enscript-keyword">if</span> (dir == PF_IN &amp;&amp; action == PF_PASS &amp;&amp; (pd.proto == IPPROTO_TCP ||
	    pd.proto == IPPROTO_UDP) &amp;&amp; s != NULL &amp;&amp; s-&gt;nat_rule.ptr != NULL &amp;&amp;
	    (s-&gt;nat_rule.ptr-&gt;action == PF_RDR ||
	    s-&gt;nat_rule.ptr-&gt;action == PF_BINAT) &amp;&amp;
	    IN6_IS_ADDR_LOOPBACK(&amp;pd.dst-&gt;v6))
		pd.pf_mtag-&gt;pftag_flags |= PF_TAG_TRANSLATE_LOCALHOST;

	<span class="enscript-keyword">if</span> (log) {
		<span class="enscript-type">struct</span> pf_rule *lr;

		<span class="enscript-keyword">if</span> (s != NULL &amp;&amp; s-&gt;nat_rule.ptr != NULL &amp;&amp;
		    s-&gt;nat_rule.ptr-&gt;log &amp; PF_LOG_ALL)
			lr = s-&gt;nat_rule.ptr;
		<span class="enscript-keyword">else</span>
			lr = r;
		PFLOG_PACKET(kif, h, m, AF_INET6, dir, reason, lr, a, ruleset,
		    &amp;pd);
	}

	kif-&gt;pfik_bytes[1][dir == PF_OUT][action != PF_PASS] += pd.tot_len;
	kif-&gt;pfik_packets[1][dir == PF_OUT][action != PF_PASS]++;

	<span class="enscript-keyword">if</span> (action == PF_PASS || r-&gt;action == PF_DROP) {
		dirndx = (dir == PF_OUT);
		r-&gt;packets[dirndx]++;
		r-&gt;bytes[dirndx] += pd.tot_len;
		<span class="enscript-keyword">if</span> (a != NULL) {
			a-&gt;packets[dirndx]++;
			a-&gt;bytes[dirndx] += pd.tot_len;
		}
		<span class="enscript-keyword">if</span> (s != NULL) {
			sk = s-&gt;state_key;
			<span class="enscript-keyword">if</span> (s-&gt;nat_rule.ptr != NULL) {
				s-&gt;nat_rule.ptr-&gt;packets[dirndx]++;
				s-&gt;nat_rule.ptr-&gt;bytes[dirndx] += pd.tot_len;
			}
			<span class="enscript-keyword">if</span> (s-&gt;src_node != NULL) {
				s-&gt;src_node-&gt;packets[dirndx]++;
				s-&gt;src_node-&gt;bytes[dirndx] += pd.tot_len;
			}
			<span class="enscript-keyword">if</span> (s-&gt;nat_src_node != NULL) {
				s-&gt;nat_src_node-&gt;packets[dirndx]++;
				s-&gt;nat_src_node-&gt;bytes[dirndx] += pd.tot_len;
			}
			dirndx = (dir == sk-&gt;direction) ? 0 : 1;
			s-&gt;packets[dirndx]++;
			s-&gt;bytes[dirndx] += pd.tot_len;
		}
		tr = r;
		nr = (s != NULL) ? s-&gt;nat_rule.ptr : pd.nat_rule;
		<span class="enscript-keyword">if</span> (nr != NULL) {
			<span class="enscript-type">struct</span> pf_addr *x;
			<span class="enscript-comment">/*
			 * XXX: we need to make sure that the addresses
			 * passed to pfr_update_stats() are the same than
			 * the addresses used during matching (pfr_match)
			 */</span>
			<span class="enscript-keyword">if</span> (r == &amp;pf_default_rule) {
				tr = nr;
				x = (s == NULL || sk-&gt;direction == dir) ?
				    &amp;pd.baddr : &amp;pd.naddr;
			} <span class="enscript-keyword">else</span> {
				x = (s == NULL || sk-&gt;direction == dir) ?
				    &amp;pd.naddr : &amp;pd.baddr;
			}
			<span class="enscript-keyword">if</span> (x == &amp;pd.baddr || s == NULL) {
				<span class="enscript-keyword">if</span> (dir == PF_OUT)
					pd.src = x;
				<span class="enscript-keyword">else</span>
					pd.dst = x;
			}
		}
		<span class="enscript-keyword">if</span> (tr-&gt;src.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr-&gt;src.addr.p.tbl, (sk == NULL ||
			    sk-&gt;direction == dir) ? pd.src : pd.dst, pd.af,
			    pd.tot_len, dir == PF_OUT, r-&gt;action == PF_PASS,
			    tr-&gt;src.neg);
		<span class="enscript-keyword">if</span> (tr-&gt;dst.addr.type == PF_ADDR_TABLE)
			pfr_update_stats(tr-&gt;dst.addr.p.tbl, (sk == NULL ||
			    sk-&gt;direction == dir) ? pd.dst : pd.src, pd.af,
			    pd.tot_len, dir == PF_OUT, r-&gt;action == PF_PASS,
			    tr-&gt;dst.neg);
	}

#<span class="enscript-reference">if</span> 0
	<span class="enscript-keyword">if</span> (action == PF_SYNPROXY_DROP) {
		m_freem(*m0);
		*m0 = NULL;
		action = PF_PASS;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;rt)
		<span class="enscript-comment">/* pf_route6 can free the mbuf causing *m0 to become NULL */</span>
		pf_route6(m0, r, dir, kif-&gt;pfik_ifp, s, &amp;pd);
#<span class="enscript-reference">else</span>
	VERIFY(m == NULL || pd.mp == NULL || pd.mp == m);

	<span class="enscript-keyword">if</span> (*m0) {
		<span class="enscript-keyword">if</span> (pd.lmw &lt; 0) {
			REASON_SET(&amp;reason, PFRES_MEMORY);
			action = PF_DROP;
		}

		<span class="enscript-keyword">if</span> (action == PF_DROP) {
			m_freem(*m0);
			*m0 = NULL;
			<span class="enscript-keyword">return</span> (PF_DROP);
		}

		*m0 = m;
	}

	<span class="enscript-keyword">if</span> (action == PF_SYNPROXY_DROP) {
		m_freem(*m0);
		*m0 = NULL;
		action = PF_PASS;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r-&gt;rt) {
		<span class="enscript-keyword">if</span> (action == PF_PASS) {
			m = *m0;
			h = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		}

		<span class="enscript-comment">/* pf_route6 can free the mbuf causing *m0 to become NULL */</span>
		pf_route6(m0, r, dir, kif-&gt;pfik_ifp, s, &amp;pd);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0 */</span>

	<span class="enscript-keyword">return</span> (action);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pf_check_congestion</span>(<span class="enscript-type">struct</span> ifqueue *ifq)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifq</span>)
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pool_init</span>(<span class="enscript-type">struct</span> pool *pp, size_t size, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> align, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ioff,
    <span class="enscript-type">int</span> flags, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *wchan, <span class="enscript-type">void</span> *palloc)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">align</span>, <span class="enscript-variable-name">ioff</span>, <span class="enscript-variable-name">flags</span>, <span class="enscript-variable-name">palloc</span>)
	bzero(pp, <span class="enscript-keyword">sizeof</span> (*pp));
	pp-&gt;pool_zone = zinit(size, 1024 * size, PAGE_SIZE, wchan);
	<span class="enscript-keyword">if</span> (pp-&gt;pool_zone != NULL) {
		zone_change(pp-&gt;pool_zone, Z_EXPAND, TRUE);
		zone_change(pp-&gt;pool_zone, Z_CALLERACCT, FALSE);
		pp-&gt;pool_hiwat = pp-&gt;pool_limit = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)-1;
		pp-&gt;pool_name = wchan;
	}
}

<span class="enscript-comment">/* Zones cannot be currently destroyed */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pool_destroy</span>(<span class="enscript-type">struct</span> pool *pp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">pp</span>)
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pool_sethiwat</span>(<span class="enscript-type">struct</span> pool *pp, <span class="enscript-type">int</span> n)
{
	pp-&gt;pool_hiwat = n;	<span class="enscript-comment">/* Currently unused */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pool_sethardlimit</span>(<span class="enscript-type">struct</span> pool *pp, <span class="enscript-type">int</span> n, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *warnmess, <span class="enscript-type">int</span> ratecap)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">warnmess</span>, <span class="enscript-variable-name">ratecap</span>)
	pp-&gt;pool_limit = n;
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">pool_get</span>(<span class="enscript-type">struct</span> pool *pp, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">void</span> *buf;

	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (pp-&gt;pool_count &gt; pp-&gt;pool_limit) {
		DPFPRINTF(PF_DEBUG_NOISY,
		    (<span class="enscript-string">&quot;pf: pool %s hard limit reached (%d)\n&quot;</span>,
		    pp-&gt;pool_name != NULL ? pp-&gt;pool_name : <span class="enscript-string">&quot;unknown&quot;</span>,
		    pp-&gt;pool_limit));
		pp-&gt;pool_fails++;
		<span class="enscript-keyword">return</span> (NULL);
	}

	buf = zalloc_canblock(pp-&gt;pool_zone, (flags &amp; (PR_NOWAIT | PR_WAITOK)));
	<span class="enscript-keyword">if</span> (buf != NULL) {
		pp-&gt;pool_count++;
		VERIFY(pp-&gt;pool_count != 0);
	}
	<span class="enscript-keyword">return</span> (buf);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pool_put</span>(<span class="enscript-type">struct</span> pool *pp, <span class="enscript-type">void</span> *v)
{
	lck_mtx_assert(pf_lock, LCK_MTX_ASSERT_OWNED);

	zfree(pp-&gt;pool_zone, v);
	VERIFY(pp-&gt;pool_count != 0);
	pp-&gt;pool_count--;
}

<span class="enscript-type">struct</span> pf_mtag *
<span class="enscript-function-name">pf_find_mtag</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">return</span> (m_pftag(m));
}

<span class="enscript-type">struct</span> pf_mtag *
<span class="enscript-function-name">pf_get_mtag</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-keyword">return</span> (pf_find_mtag(m));
}

uint64_t
<span class="enscript-function-name">pf_time_second</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> timeval t;

	microuptime(&amp;t);
	<span class="enscript-keyword">return</span> (t.tv_sec);
}

uint64_t
<span class="enscript-function-name">pf_calendar_time_second</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> timeval t;

	getmicrotime(&amp;t);
	<span class="enscript-keyword">return</span> (t.tv_sec);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">hook_establish</span>(<span class="enscript-type">struct</span> hook_desc_head *head, <span class="enscript-type">int</span> tail, hook_fn_t fn, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> hook_desc *hd;

	hd = _MALLOC(<span class="enscript-keyword">sizeof</span>(*hd), M_DEVBUF, M_WAITOK);
	<span class="enscript-keyword">if</span> (hd == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	hd-&gt;hd_fn = fn;
	hd-&gt;hd_arg = arg;
	<span class="enscript-keyword">if</span> (tail)
		TAILQ_INSERT_TAIL(head, hd, hd_list);
	<span class="enscript-keyword">else</span>
		TAILQ_INSERT_HEAD(head, hd, hd_list);

	<span class="enscript-keyword">return</span> (hd);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hook_runloop</span>(<span class="enscript-type">struct</span> hook_desc_head *head, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> hook_desc *hd;

	<span class="enscript-keyword">if</span> (!(flags &amp; HOOK_REMOVE)) {
		<span class="enscript-keyword">if</span> (!(flags &amp; HOOK_ABORT))
			TAILQ_FOREACH(hd, head, hd_list)
				hd-&gt;hd_fn(hd-&gt;hd_arg);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">while</span> (!!(hd = TAILQ_FIRST(head))) {
			TAILQ_REMOVE(head, hd, hd_list);
			<span class="enscript-keyword">if</span> (!(flags &amp; HOOK_ABORT))
				hd-&gt;hd_fn(hd-&gt;hd_arg);
			<span class="enscript-keyword">if</span> (flags &amp; HOOK_FREE)
				_FREE(hd, M_DEVBUF);
		}
	}
}
</pre>
<hr />
</body></html>