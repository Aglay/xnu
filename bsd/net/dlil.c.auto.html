<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>dlil.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">dlil.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1999-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stddef.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/random.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_arp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/iptap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pktap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_protocol.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_llreach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_interfacefilter.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/classq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/classq_sfb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/flowhash.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/igmp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/if_ether.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/mld6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/scope6_var.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/tree.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ethernet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/firewire.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfvar.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/altq/altq.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pktsched/pktsched.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_LAYER_BEG</span>		DLILDBG_CODE(DBG_DLIL_STATIC, 0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_LAYER_END</span>		DLILDBG_CODE(DBG_DLIL_STATIC, 2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_DLIL_INPUT</span>      DLILDBG_CODE(DBG_DLIL_STATIC, (1 &lt;&lt; 8))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_DLIL_OUTPUT</span>     DLILDBG_CODE(DBG_DLIL_STATIC, (2 &lt;&lt; 8))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_DLIL_IFOUT</span>      DLILDBG_CODE(DBG_DLIL_STATIC, (3 &lt;&lt; 8))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_FRAME_TYPE_SIZE</span> 4 <span class="enscript-comment">/* LONGWORDS */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_LINKADDR</span>	    4 <span class="enscript-comment">/* LONGWORDS */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">M_NKE</span> M_IFADDR

#<span class="enscript-reference">if</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DLIL_PRINTF</span>	printf
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DLIL_PRINTF</span>	kprintf
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IF_DATA_REQUIRE_ALIGNED_64</span>(f)	\
	_CASSERT(!(offsetof(<span class="enscript-type">struct</span> if_data_internal, f) % <span class="enscript-keyword">sizeof</span> (u_int64_t)))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFNET_IF_DATA_REQUIRE_ALIGNED_64</span>(f)	\
	_CASSERT(!(offsetof(<span class="enscript-type">struct</span> ifnet, if_data.f) % <span class="enscript-keyword">sizeof</span> (u_int64_t)))

<span class="enscript-type">enum</span> {
	kProtoKPI_v1	= 1,
	kProtoKPI_v2	= 2
};

<span class="enscript-comment">/*
 * List of if_proto structures in if_proto_hash[] is protected by
 * the ifnet lock.  The rest of the fields are initialized at protocol
 * attach time and never change, thus no lock required as long as
 * a reference to it is valid, via if_proto_ref().
 */</span>
<span class="enscript-type">struct</span> if_proto {
    SLIST_ENTRY(if_proto)	next_hash;
    u_int32_t			refcount;
    u_int32_t			detached;
    <span class="enscript-type">struct</span> ifnet		*ifp;
    protocol_family_t		protocol_family;
    <span class="enscript-type">int</span>				proto_kpi;
    <span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			proto_media_input		input;
			proto_media_preout		pre_output;
			proto_media_event		event;
			proto_media_ioctl		ioctl;
			proto_media_detached		detached;
			proto_media_resolve_multi	resolve_multi;
			proto_media_send_arp		send_arp;
		} v1;
		<span class="enscript-type">struct</span> {
			proto_media_input_v2		input;
			proto_media_preout		pre_output;
			proto_media_event		event;
			proto_media_ioctl		ioctl;
			proto_media_detached		detached;
			proto_media_resolve_multi	resolve_multi;
			proto_media_send_arp		send_arp;
		} v2;
	} kpi;
};

<span class="enscript-function-name">SLIST_HEAD</span>(proto_hash_entry, if_proto);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIL_SDLMAXLEN</span>	64
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIL_SDLDATALEN</span>	\
	(DLIL_SDLMAXLEN - offsetof(<span class="enscript-type">struct</span> sockaddr_dl, sdl_data[0]))

<span class="enscript-type">struct</span> dlil_ifnet {
	<span class="enscript-type">struct</span> ifnet	dl_if;			<span class="enscript-comment">/* public ifnet */</span>
	<span class="enscript-comment">/*
	 * DLIL private fields, protected by dl_if_lock
	 */</span>
	decl_lck_mtx_data(, dl_if_lock);
	TAILQ_ENTRY(dlil_ifnet) dl_if_link;	<span class="enscript-comment">/* dlil_ifnet link */</span>
	u_int32_t dl_if_flags;			<span class="enscript-comment">/* flags (below) */</span>
	u_int32_t dl_if_refcnt;			<span class="enscript-comment">/* refcnt */</span>
	<span class="enscript-type">void</span> (*dl_if_trace)(<span class="enscript-type">struct</span> dlil_ifnet *, <span class="enscript-type">int</span>); <span class="enscript-comment">/* ref trace callback */</span>
	<span class="enscript-type">void</span>	*dl_if_uniqueid;		<span class="enscript-comment">/* unique interface id */</span>
	size_t	dl_if_uniqueid_len;		<span class="enscript-comment">/* length of the unique id */</span>
	<span class="enscript-type">char</span>	dl_if_namestorage[IFNAMSIZ];	<span class="enscript-comment">/* interface name storage */</span>
	<span class="enscript-type">char</span>	dl_if_xnamestorage[IFXNAMSIZ];	<span class="enscript-comment">/* external name storage */</span>
	<span class="enscript-type">struct</span> {
		<span class="enscript-type">struct</span> ifaddr	ifa;		<span class="enscript-comment">/* lladdr ifa */</span>
		u_int8_t	asdl[DLIL_SDLMAXLEN]; <span class="enscript-comment">/* addr storage */</span>
		u_int8_t	msdl[DLIL_SDLMAXLEN]; <span class="enscript-comment">/* mask storage */</span>
	} dl_if_lladdr;
	u_int8_t dl_if_descstorage[IF_DESCSIZE]; <span class="enscript-comment">/* desc storage */</span>
	<span class="enscript-type">struct</span> dlil_threading_info dl_if_inpstorage; <span class="enscript-comment">/* input thread storage */</span>
	ctrace_t	dl_if_attach;		<span class="enscript-comment">/* attach PC stacktrace */</span>
	ctrace_t	dl_if_detach;		<span class="enscript-comment">/* detach PC stacktrace */</span>
};

<span class="enscript-comment">/* Values for dl_if_flags (private to DLIL) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_INUSE</span>	0x1	<span class="enscript-comment">/* DLIL ifnet recycler, ifnet in use */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_REUSE</span>	0x2	<span class="enscript-comment">/* DLIL ifnet recycles, ifnet is not new */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_DEBUG</span>	0x4	<span class="enscript-comment">/* has debugging info */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_REF_TRACE_HIST_SIZE</span>	8	<span class="enscript-comment">/* size of ref trace history */</span>

<span class="enscript-comment">/* For gdb */</span>
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> if_ref_trace_hist_size = IF_REF_TRACE_HIST_SIZE;

<span class="enscript-type">struct</span> dlil_ifnet_dbg {
	<span class="enscript-type">struct</span> dlil_ifnet	dldbg_dlif;		<span class="enscript-comment">/* dlil_ifnet */</span>
	u_int16_t		dldbg_if_refhold_cnt;	<span class="enscript-comment">/* # ifnet references */</span>
	u_int16_t		dldbg_if_refrele_cnt;	<span class="enscript-comment">/* # ifnet releases */</span>
	<span class="enscript-comment">/*
	 * Circular lists of ifnet_{reference,release} callers.
	 */</span>
	ctrace_t		dldbg_if_refhold[IF_REF_TRACE_HIST_SIZE];
	ctrace_t		dldbg_if_refrele[IF_REF_TRACE_HIST_SIZE];
};

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DLIL_TO_IFP</span>(s)	(&amp;s-&gt;dl_if)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFP_TO_DLIL</span>(s)	((struct dlil_ifnet *)s)

<span class="enscript-type">struct</span> ifnet_filter {
	TAILQ_ENTRY(ifnet_filter)	filt_next;
	u_int32_t			filt_skip;
	u_int32_t			filt_flags;
	ifnet_t				filt_ifp;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>			*filt_name;
	<span class="enscript-type">void</span>				*filt_cookie;
	protocol_family_t		filt_protocol;
	iff_input_func			filt_input;
	iff_output_func			filt_output;
	iff_event_func			filt_event;
	iff_ioctl_func			filt_ioctl;
	iff_detached_func		filt_detached;
};

<span class="enscript-type">struct</span> proto_input_entry;

<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(, dlil_ifnet) dlil_ifnet_head;
<span class="enscript-type">static</span> lck_grp_t *dlil_lock_group;
lck_grp_t *ifnet_lock_group;
<span class="enscript-type">static</span> lck_grp_t *ifnet_head_lock_group;
<span class="enscript-type">static</span> lck_grp_t *ifnet_snd_lock_group;
<span class="enscript-type">static</span> lck_grp_t *ifnet_rcv_lock_group;
lck_attr_t *ifnet_lock_attr;
<span class="enscript-function-name">decl_lck_rw_data</span>(<span class="enscript-type">static</span>, ifnet_head_lock);
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, dlil_ifnet_lock);
u_int32_t dlil_filter_disable_tso_count = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifnet_debug = 1;	<span class="enscript-comment">/* debugging (enabled) */</span>
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifnet_debug;	<span class="enscript-comment">/* debugging (disabled) */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !DEBUG */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dlif_size;		<span class="enscript-comment">/* size of dlil_ifnet to allocate */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dlif_bufsize;	<span class="enscript-comment">/* size of dlif_size + headroom */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *dlif_zone;		<span class="enscript-comment">/* zone for dlil_ifnet */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_ZONE_MAX</span>		64		<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_ZONE_NAME</span>		<span class="enscript-string">&quot;ifnet&quot;</span>		<span class="enscript-comment">/* zone name */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dlif_filt_size;	<span class="enscript-comment">/* size of ifnet_filter */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *dlif_filt_zone;	<span class="enscript-comment">/* zone for ifnet_filter */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_FILT_ZONE_MAX</span>	8		<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_FILT_ZONE_NAME</span>	<span class="enscript-string">&quot;ifnet_filter&quot;</span>	<span class="enscript-comment">/* zone name */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dlif_phash_size;	<span class="enscript-comment">/* size of ifnet proto hash table */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *dlif_phash_zone;	<span class="enscript-comment">/* zone for ifnet proto hash table */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_PHASH_ZONE_MAX</span>	DLIF_ZONE_MAX	<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_PHASH_ZONE_NAME</span>	<span class="enscript-string">&quot;ifnet_proto_hash&quot;</span> <span class="enscript-comment">/* zone name */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dlif_proto_size;	<span class="enscript-comment">/* size of if_proto */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *dlif_proto_zone;	<span class="enscript-comment">/* zone for if_proto */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_PROTO_ZONE_MAX</span>	(DLIF_ZONE_MAX*2) <span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_PROTO_ZONE_NAME</span>	<span class="enscript-string">&quot;ifnet_proto&quot;</span>	<span class="enscript-comment">/* zone name */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dlif_tcpstat_size;		<span class="enscript-comment">/* size of tcpstat_local to allocate */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dlif_tcpstat_bufsize;	<span class="enscript-comment">/* size of dlif_tcpstat_size + headroom */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *dlif_tcpstat_zone;		<span class="enscript-comment">/* zone for tcpstat_local */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_TCPSTAT_ZONE_MAX</span>	1		<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_TCPSTAT_ZONE_NAME</span>	<span class="enscript-string">&quot;ifnet_tcpstat&quot;</span>	<span class="enscript-comment">/* zone name */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dlif_udpstat_size;		<span class="enscript-comment">/* size of udpstat_local to allocate */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dlif_udpstat_bufsize;	<span class="enscript-comment">/* size of dlif_udpstat_size + headroom */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *dlif_udpstat_zone;		<span class="enscript-comment">/* zone for udpstat_local */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_UDPSTAT_ZONE_MAX</span>	1		<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DLIF_UDPSTAT_ZONE_NAME</span>	<span class="enscript-string">&quot;ifnet_udpstat&quot;</span>	<span class="enscript-comment">/* zone name */</span>

<span class="enscript-comment">/*
 * Updating this variable should be done by first acquiring the global
 * radix node head (rnh_lock), in tandem with settting/clearing the
 * PR_AGGDRAIN for routedomain.
 */</span>
u_int32_t ifnet_aggressive_drainers;
<span class="enscript-type">static</span> u_int32_t net_rtref;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> dlil_main_threading_info dlil_main_input_thread_info;
__private_extern__ <span class="enscript-type">struct</span> dlil_threading_info *dlil_main_input_thread =
    (<span class="enscript-type">struct</span> dlil_threading_info *)&amp;dlil_main_input_thread_info;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dlil_event_internal</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> kev_msg *msg);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dlil_detach_filter_internal</span>(interface_filter_t filter, <span class="enscript-type">int</span> detached);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dlil_if_trace</span>(<span class="enscript-type">struct</span> dlil_ifnet *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_proto_ref</span>(<span class="enscript-type">struct</span> if_proto *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_proto_free</span>(<span class="enscript-type">struct</span> if_proto *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> if_proto *<span class="enscript-function-name">find_attached_proto</span>(<span class="enscript-type">struct</span> ifnet *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dlil_ifp_proto_count</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_flt_monitor_busy</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_flt_monitor_unbusy</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_flt_monitor_enter</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_flt_monitor_leave</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dlil_interface_filters_input</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf **,
    <span class="enscript-type">char</span> **, protocol_family_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dlil_interface_filters_output</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf **,
    protocol_family_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">dlil_alloc_lladdr</span>(<span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifnet_lookup</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_purgeaddrs</span>(<span class="enscript-type">struct</span> ifnet *);

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifproto_media_input_v1</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t,
    <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifproto_media_input_v2</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t,
    <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifproto_media_preout</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t,
    mbuf_t *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">void</span> *, <span class="enscript-type">char</span> *, <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifproto_media_event</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> kev_msg *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifproto_media_ioctl</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifproto_media_resolve_multi</span>(ifnet_t, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">struct</span> sockaddr_dl *, size_t);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifproto_media_send_arp</span>(<span class="enscript-type">struct</span> ifnet *, u_short,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *);

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifp_if_output</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifp_if_start</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifp_if_input_poll</span>(<span class="enscript-type">struct</span> ifnet *, u_int32_t, u_int32_t,
    <span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> mbuf **, u_int32_t *, u_int32_t *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifp_if_ctl</span>(<span class="enscript-type">struct</span> ifnet *, ifnet_ctl_cmd_t, u_int32_t, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifp_if_demux</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">char</span> *,
    protocol_family_t *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifp_if_add_proto</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_demux_desc *, u_int32_t);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifp_if_del_proto</span>(<span class="enscript-type">struct</span> ifnet *, protocol_family_t);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifp_if_check_multi</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifp_if_framer</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf **,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifp_if_framer_extended</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf **,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *,
    u_int32_t *, u_int32_t *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifp_if_set_bpf_tap</span>(<span class="enscript-type">struct</span> ifnet *, bpf_tap_mode, bpf_packet_func);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifp_if_free</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifp_if_event</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> kev_msg *);
<span class="enscript-type">static</span> __inline <span class="enscript-type">void</span> <span class="enscript-function-name">ifp_inc_traffic_class_in</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> __inline <span class="enscript-type">void</span> <span class="enscript-function-name">ifp_inc_traffic_class_out</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dlil_main_input_thread_func</span>(<span class="enscript-type">void</span> *, wait_result_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dlil_input_thread_func</span>(<span class="enscript-type">void</span> *, wait_result_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dlil_rxpoll_input_thread_func</span>(<span class="enscript-type">void</span> *, wait_result_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dlil_create_input_thread</span>(ifnet_t, <span class="enscript-type">struct</span> dlil_threading_info *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dlil_terminate_input_thread</span>(<span class="enscript-type">struct</span> dlil_threading_info *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dlil_input_stats_add</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_stat_increment_param *,
    <span class="enscript-type">struct</span> dlil_threading_info *, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dlil_input_stats_sync</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> dlil_threading_info *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dlil_input_packet_list_common</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *,
    u_int32_t, ifnet_model_t, boolean_t);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifnet_input_common</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> mbuf *,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_stat_increment_param *, boolean_t, boolean_t);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dlil_verify_sum16</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dlil_output_cksum_dbg</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *, uint32_t,
    protocol_family_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dlil_input_cksum_dbg</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">char</span> *,
    protocol_family_t);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifnet_detacher_thread_func</span>(<span class="enscript-type">void</span> *, wait_result_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifnet_detacher_thread_cont</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifnet_detach_final</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifnet_detaching_enqueue</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifnet *<span class="enscript-function-name">ifnet_detaching_dequeue</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifnet_start_thread_fn</span>(<span class="enscript-type">void</span> *, wait_result_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifnet_poll_thread_fn</span>(<span class="enscript-type">void</span> *, wait_result_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifnet_poll</span>(<span class="enscript-type">struct</span> ifnet *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifp_src_route_copyout</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> route *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifp_src_route_copyin</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> route *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifp_src_route6_copyout</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> route_in6 *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifp_src_route6_copyin</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> route_in6 *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_rxpoll SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_rxpoll_mode_holdtime SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_rxpoll_sample_holdtime SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_rxpoll_interval_time SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_rxpoll_wlowat SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_rxpoll_whiwat SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_sndq_maxlen SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_rcvq_maxlen SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_hwcksum_dbg_mode SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_hwcksum_dbg_partial_rxoff_forced SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_hwcksum_dbg_partial_rxoff_adj SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_get_ports_used SYSCTL_HANDLER_ARGS;

<span class="enscript-type">struct</span> chain_len_stats tx_chain_len_stats;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_tx_chain_len_stats SYSCTL_HANDLER_ARGS;

<span class="enscript-comment">/* The following are protected by dlil_ifnet_lock */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(, ifnet) ifnet_detaching_head;
<span class="enscript-type">static</span> u_int32_t ifnet_detaching_cnt;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *ifnet_delayed_run;	<span class="enscript-comment">/* wait channel for detaching thread */</span>

<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, ifnet_fc_lock);

<span class="enscript-type">static</span> uint32_t ifnet_flowhash_seed;

<span class="enscript-type">struct</span> ifnet_flowhash_key {
	<span class="enscript-type">char</span>		ifk_name[IFNAMSIZ];
	uint32_t	ifk_unit;
	uint32_t	ifk_flags;
	uint32_t	ifk_eflags;
	uint32_t	ifk_capabilities;
	uint32_t	ifk_capenable;
	uint32_t	ifk_output_sched_model;
	uint32_t	ifk_rand1;
	uint32_t	ifk_rand2;
};

<span class="enscript-comment">/* Flow control entry per interface */</span>
<span class="enscript-type">struct</span> ifnet_fc_entry {
	RB_ENTRY(ifnet_fc_entry) ifce_entry;
	u_int32_t	ifce_flowhash;
	<span class="enscript-type">struct</span> ifnet	*ifce_ifp;
};

<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">ifnet_calc_flowhash</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifce_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_fc_entry *,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_fc_entry *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifnet_fc_add</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifnet_fc_entry *<span class="enscript-function-name">ifnet_fc_get</span>(u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifnet_fc_entry_free</span>(<span class="enscript-type">struct</span> ifnet_fc_entry *);

<span class="enscript-comment">/* protected by ifnet_fc_lock */</span>
<span class="enscript-function-name">RB_HEAD</span>(ifnet_fc_tree, ifnet_fc_entry) ifnet_fc_tree;
<span class="enscript-function-name">RB_PROTOTYPE</span>(ifnet_fc_tree, ifnet_fc_entry, ifce_entry, ifce_cmp);
<span class="enscript-function-name">RB_GENERATE</span>(ifnet_fc_tree, ifnet_fc_entry, ifce_entry, ifce_cmp);

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifnet_fc_zone_size;		<span class="enscript-comment">/* sizeof ifnet_fc_entry */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *ifnet_fc_zone;		<span class="enscript-comment">/* ifnet_fc_entry zone */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFNET_FC_ZONE_NAME</span>	<span class="enscript-string">&quot;ifnet_fc_zone&quot;</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFNET_FC_ZONE_MAX</span>	 32

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bpfdetach</span>(<span class="enscript-type">struct</span> ifnet*);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proto_input_run</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">udp_count_opportunistic</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifindex, 
	u_int32_t flags);
<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">tcp_count_opportunistic</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifindex, 
	u_int32_t flags);

__private_extern__ <span class="enscript-type">void</span> link_rtrequest(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> sockaddr *);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
<span class="enscript-type">int</span> dlil_lladdr_ckreq = 0;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">int</span> dlil_verbose = 1;
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span> dlil_verbose = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IFNET_INPUT_SANITY_CHK</span>
<span class="enscript-comment">/* sanity checking of input packet lists received */</span>
<span class="enscript-type">static</span> u_int32_t dlil_input_sanity_check = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IFNET_INPUT_SANITY_CHK */</span>
<span class="enscript-comment">/* rate limit debug messages */</span>
<span class="enscript-type">struct</span> timespec dlil_dbgrate = { 1, 0 };

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_link_generic_system);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_generic_system, OID_AUTO, dlil_lladdr_ckreq,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;dlil_lladdr_ckreq, 0,
	<span class="enscript-string">&quot;Require MACF system info check to expose link-layer address&quot;</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_generic_system, OID_AUTO, dlil_verbose,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;dlil_verbose, 0, <span class="enscript-string">&quot;Log DLIL error messages&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_SNDQ_MINLEN</span>	32
u_int32_t if_sndq_maxlen = IFQ_MAXLEN;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_generic_system, OID_AUTO, sndq_maxlen,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_sndq_maxlen, IFQ_MAXLEN,
    sysctl_sndq_maxlen, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Default transmit queue max length&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_RCVQ_MINLEN</span>	32
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IF_RCVQ_MAXLEN</span>	256
u_int32_t if_rcvq_maxlen = IF_RCVQ_MAXLEN;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_generic_system, OID_AUTO, rcvq_maxlen,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_rcvq_maxlen, IFQ_MAXLEN,
    sysctl_rcvq_maxlen, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Default receive queue max length&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_RXPOLL_DECAY</span>		2	<span class="enscript-comment">/* ilog2 of EWMA decay rate (4) */</span>
<span class="enscript-type">static</span> u_int32_t if_rxpoll_decay = IF_RXPOLL_DECAY;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, rxpoll_decay,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_rxpoll_decay, IF_RXPOLL_DECAY,
    <span class="enscript-string">&quot;ilog2 of EWMA decay rate of avg inbound packets&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_RXPOLL_MODE_HOLDTIME_MIN</span>	(10ULL * 1000 * 1000)   <span class="enscript-comment">/* 10 ms */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_RXPOLL_MODE_HOLDTIME</span>		(1000ULL * 1000 * 1000)	<span class="enscript-comment">/* 1 sec */</span>
<span class="enscript-type">static</span> u_int64_t if_rxpoll_mode_holdtime = IF_RXPOLL_MODE_HOLDTIME;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_generic_system, OID_AUTO, rxpoll_freeze_time,
    CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_rxpoll_mode_holdtime,
    IF_RXPOLL_MODE_HOLDTIME, sysctl_rxpoll_mode_holdtime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;input poll mode freeze time&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_RXPOLL_SAMPLETIME_MIN</span>	(1ULL * 1000 * 1000)	<span class="enscript-comment">/* 1 ms */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_RXPOLL_SAMPLETIME</span>		(10ULL * 1000 * 1000)	<span class="enscript-comment">/* 10 ms */</span>
<span class="enscript-type">static</span> u_int64_t if_rxpoll_sample_holdtime = IF_RXPOLL_SAMPLETIME;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_generic_system, OID_AUTO, rxpoll_sample_time,
    CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_rxpoll_sample_holdtime,
    IF_RXPOLL_SAMPLETIME, sysctl_rxpoll_sample_holdtime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;input poll sampling time&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_RXPOLL_INTERVALTIME_MIN</span>	(1ULL * 1000)		<span class="enscript-comment">/* 1 us */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_RXPOLL_INTERVALTIME</span>		(1ULL * 1000 * 1000)	<span class="enscript-comment">/* 1 ms */</span>
<span class="enscript-type">static</span> u_int64_t if_rxpoll_interval_time = IF_RXPOLL_INTERVALTIME;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_generic_system, OID_AUTO, rxpoll_interval_time,
    CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_rxpoll_interval_time,
    IF_RXPOLL_INTERVALTIME, sysctl_rxpoll_interval_time,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;input poll interval (time)&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_RXPOLL_INTERVAL_PKTS</span>	0	<span class="enscript-comment">/* 0 (disabled) */</span>
<span class="enscript-type">static</span> u_int32_t if_rxpoll_interval_pkts = IF_RXPOLL_INTERVAL_PKTS;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, rxpoll_interval_pkts,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_rxpoll_interval_pkts,
    IF_RXPOLL_INTERVAL_PKTS, <span class="enscript-string">&quot;input poll interval (packets)&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_RXPOLL_WLOWAT</span>	10
<span class="enscript-type">static</span> u_int32_t if_rxpoll_wlowat = IF_RXPOLL_WLOWAT;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_generic_system, OID_AUTO, rxpoll_wakeups_lowat,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_rxpoll_wlowat,
    IF_RXPOLL_WLOWAT, sysctl_rxpoll_wlowat,
    <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;input poll wakeup low watermark&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IF_RXPOLL_WHIWAT</span>	100
<span class="enscript-type">static</span> u_int32_t if_rxpoll_whiwat = IF_RXPOLL_WHIWAT;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_generic_system, OID_AUTO, rxpoll_wakeups_hiwat,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_rxpoll_whiwat,
    IF_RXPOLL_WHIWAT, sysctl_rxpoll_whiwat,
    <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;input poll wakeup high watermark&quot;</span>);

<span class="enscript-type">static</span> u_int32_t if_rxpoll_max = 0;			<span class="enscript-comment">/* 0 (automatic) */</span>
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, rxpoll_max,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_rxpoll_max, 0,
    <span class="enscript-string">&quot;max packets per poll call&quot;</span>);

<span class="enscript-type">static</span> u_int32_t if_rxpoll = 1;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_generic_system, OID_AUTO, rxpoll,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_rxpoll, 0,
    sysctl_rxpoll, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;enable opportunistic input polling&quot;</span>);

u_int32_t if_bw_smoothing_val = 3;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, if_bw_smoothing_val,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_bw_smoothing_val, 0, <span class="enscript-string">&quot;&quot;</span>);

u_int32_t if_bw_measure_size = 10;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_generic_system, OID_AUTO, if_bw_measure_size,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_bw_measure_size, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> u_int32_t cur_dlil_input_threads = 0;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, dlil_input_threads,
    CTLFLAG_RD | CTLFLAG_LOCKED, &amp;cur_dlil_input_threads , 0,
    <span class="enscript-string">&quot;Current number of DLIL input threads&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IFNET_INPUT_SANITY_CHK</span>
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, dlil_input_sanity_check,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;dlil_input_sanity_check , 0,
    <span class="enscript-string">&quot;Turn on sanity checking in DLIL input&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IFNET_INPUT_SANITY_CHK */</span>

<span class="enscript-type">static</span> u_int32_t if_flowadv = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, flow_advisory,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_flowadv, 1,
    <span class="enscript-string">&quot;enable flow-advisory mechanism&quot;</span>);

<span class="enscript-type">static</span> u_int32_t if_delaybased_queue = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, delaybased_queue,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_delaybased_queue, 1,
    <span class="enscript-string">&quot;enable delay based dynamic queue sizing&quot;</span>);

<span class="enscript-type">static</span> uint64_t hwcksum_in_invalidated = 0;
<span class="enscript-function-name">SYSCTL_QUAD</span>(_net_link_generic_system, OID_AUTO,
    hwcksum_in_invalidated, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;hwcksum_in_invalidated, <span class="enscript-string">&quot;inbound packets with invalidated hardware cksum&quot;</span>);

uint32_t hwcksum_dbg = 0;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, hwcksum_dbg,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;hwcksum_dbg, 0,
    <span class="enscript-string">&quot;enable hardware cksum debugging&quot;</span>);

u_int32_t ifnet_start_delayed = 0;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, start_delayed,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ifnet_start_delayed, 0,
    <span class="enscript-string">&quot;number of times start was delayed&quot;</span>);

u_int32_t ifnet_delay_start_disabled = 0;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, start_delay_disabled,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ifnet_delay_start_disabled, 0,
    <span class="enscript-string">&quot;number of times start was delayed&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HWCKSUM_DBG_PARTIAL_FORCED</span>	0x1	<span class="enscript-comment">/* forced partial checksum */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HWCKSUM_DBG_PARTIAL_RXOFF_ADJ</span>	0x2	<span class="enscript-comment">/* adjust start offset */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HWCKSUM_DBG_FINALIZE_FORCED</span>	0x10	<span class="enscript-comment">/* forced finalize */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HWCKSUM_DBG_MASK</span> \
	(HWCKSUM_DBG_PARTIAL_FORCED | HWCKSUM_DBG_PARTIAL_RXOFF_ADJ |	\
	HWCKSUM_DBG_FINALIZE_FORCED)

<span class="enscript-type">static</span> uint32_t hwcksum_dbg_mode = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_generic_system, OID_AUTO, hwcksum_dbg_mode,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;hwcksum_dbg_mode,
    0, sysctl_hwcksum_dbg_mode, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;hardware cksum debugging mode&quot;</span>);

<span class="enscript-type">static</span> uint64_t hwcksum_dbg_partial_forced = 0;
<span class="enscript-function-name">SYSCTL_QUAD</span>(_net_link_generic_system, OID_AUTO,
    hwcksum_dbg_partial_forced, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;hwcksum_dbg_partial_forced, <span class="enscript-string">&quot;packets forced using partial cksum&quot;</span>);

<span class="enscript-type">static</span> uint64_t hwcksum_dbg_partial_forced_bytes = 0;
<span class="enscript-function-name">SYSCTL_QUAD</span>(_net_link_generic_system, OID_AUTO,
    hwcksum_dbg_partial_forced_bytes, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;hwcksum_dbg_partial_forced_bytes, <span class="enscript-string">&quot;bytes forced using partial cksum&quot;</span>);

<span class="enscript-type">static</span> uint32_t hwcksum_dbg_partial_rxoff_forced = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_generic_system, OID_AUTO,
    hwcksum_dbg_partial_rxoff_forced, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;hwcksum_dbg_partial_rxoff_forced, 0,
    sysctl_hwcksum_dbg_partial_rxoff_forced, <span class="enscript-string">&quot;I&quot;</span>,
    <span class="enscript-string">&quot;forced partial cksum rx offset&quot;</span>);

<span class="enscript-type">static</span> uint32_t hwcksum_dbg_partial_rxoff_adj = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_generic_system, OID_AUTO, hwcksum_dbg_partial_rxoff_adj,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;hwcksum_dbg_partial_rxoff_adj,
    0, sysctl_hwcksum_dbg_partial_rxoff_adj, <span class="enscript-string">&quot;I&quot;</span>,
    <span class="enscript-string">&quot;adjusted partial cksum rx offset&quot;</span>);

<span class="enscript-type">static</span> uint64_t hwcksum_dbg_verified = 0;
<span class="enscript-function-name">SYSCTL_QUAD</span>(_net_link_generic_system, OID_AUTO,
    hwcksum_dbg_verified, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;hwcksum_dbg_verified, <span class="enscript-string">&quot;packets verified for having good checksum&quot;</span>);

<span class="enscript-type">static</span> uint64_t hwcksum_dbg_bad_cksum = 0;
<span class="enscript-function-name">SYSCTL_QUAD</span>(_net_link_generic_system, OID_AUTO,
    hwcksum_dbg_bad_cksum, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;hwcksum_dbg_bad_cksum, <span class="enscript-string">&quot;packets with bad hardware calculated checksum&quot;</span>);

<span class="enscript-type">static</span> uint64_t hwcksum_dbg_bad_rxoff = 0;
<span class="enscript-function-name">SYSCTL_QUAD</span>(_net_link_generic_system, OID_AUTO,
    hwcksum_dbg_bad_rxoff, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;hwcksum_dbg_bad_rxoff, <span class="enscript-string">&quot;packets with invalid rxoff&quot;</span>);

<span class="enscript-type">static</span> uint64_t hwcksum_dbg_adjusted = 0;
<span class="enscript-function-name">SYSCTL_QUAD</span>(_net_link_generic_system, OID_AUTO,
    hwcksum_dbg_adjusted, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;hwcksum_dbg_adjusted, <span class="enscript-string">&quot;packets with rxoff adjusted&quot;</span>);

<span class="enscript-type">static</span> uint64_t hwcksum_dbg_finalized_hdr = 0;
<span class="enscript-function-name">SYSCTL_QUAD</span>(_net_link_generic_system, OID_AUTO,
    hwcksum_dbg_finalized_hdr, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;hwcksum_dbg_finalized_hdr, <span class="enscript-string">&quot;finalized headers&quot;</span>);

<span class="enscript-type">static</span> uint64_t hwcksum_dbg_finalized_data = 0;
<span class="enscript-function-name">SYSCTL_QUAD</span>(_net_link_generic_system, OID_AUTO,
    hwcksum_dbg_finalized_data, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;hwcksum_dbg_finalized_data, <span class="enscript-string">&quot;finalized payloads&quot;</span>);

uint32_t hwcksum_tx = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, hwcksum_tx,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;hwcksum_tx, 0,
    <span class="enscript-string">&quot;enable transmit hardware checksum offload&quot;</span>);

uint32_t hwcksum_rx = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, hwcksum_rx,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;hwcksum_rx, 0,
    <span class="enscript-string">&quot;enable receive hardware checksum offload&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_generic_system, OID_AUTO, tx_chain_len_stats,
    CTLFLAG_RD | CTLFLAG_LOCKED, 0, 9,
    sysctl_tx_chain_len_stats, <span class="enscript-string">&quot;S&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

uint32_t tx_chain_len_count = 0;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_generic_system, OID_AUTO, tx_chain_len_count,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tx_chain_len_count, 0,
    <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_NODE</span>(_net_link_generic_system, OID_AUTO, get_ports_used,
    CTLFLAG_RD | CTLFLAG_LOCKED, sysctl_get_ports_used, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> net_rxpoll = 1;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> net_affinity = 1;
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">dlil_affinity_set</span>(<span class="enscript-type">struct</span> thread *, u_int32_t);

<span class="enscript-type">extern</span> u_int32_t	inject_buckets;

<span class="enscript-type">static</span>	lck_grp_attr_t	*dlil_grp_attributes = NULL;
<span class="enscript-type">static</span>	lck_attr_t	*dlil_lck_attributes = NULL;


#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DLIL_INPUT_CHECK</span>(m, ifp) {					\
	<span class="enscript-type">struct</span> ifnet *_rcvif = mbuf_pkthdr_rcvif(m);			\
	<span class="enscript-keyword">if</span> (_rcvif == NULL || (ifp != lo_ifp &amp;&amp; _rcvif != ifp) ||	\
	    !(mbuf_flags(m) &amp; MBUF_PKTHDR)) {				\
		panic_plain(<span class="enscript-string">&quot;%s: invalid mbuf %p\n&quot;</span>, __func__, m);	\
		<span class="enscript-comment">/* NOTREACHED */</span>					\
	}								\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DLIL_EWMA</span>(old, new, decay) do {					\
	u_int32_t _avg;							\
	<span class="enscript-keyword">if</span> ((_avg = (old)) &gt; 0)						\
		_avg = (((_avg &lt;&lt; (decay)) - _avg) + (new)) &gt;&gt; (decay);	\
	<span class="enscript-keyword">else</span>								\
		_avg = (new);						\
	(old) = _avg;							\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBPS</span>	(1ULL * 1000 * 1000)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">GBPS</span>	(MBPS * 1000)

<span class="enscript-type">struct</span> rxpoll_time_tbl {
	u_int64_t	speed;		<span class="enscript-comment">/* downlink speed */</span>
	u_int32_t	plowat;		<span class="enscript-comment">/* packets low watermark */</span>
	u_int32_t	phiwat;		<span class="enscript-comment">/* packets high watermark */</span>
	u_int32_t	blowat;		<span class="enscript-comment">/* bytes low watermark */</span>
	u_int32_t	bhiwat;		<span class="enscript-comment">/* bytes high watermark */</span>
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rxpoll_time_tbl rxpoll_tbl[] = {
	{  10 * MBPS,	2,	8,	(1 * 1024),	(6 * 1024)	},
	{ 100 * MBPS,	10,	40,	(4 * 1024),	(64 * 1024)	},
	{   1 * GBPS,	10,	40,	(4 * 1024),	(64 * 1024)	},
	{  10 * GBPS,	10,	40,	(4 * 1024),	(64 * 1024)	},
	{ 100 * GBPS,	10,	40,	(4 * 1024),	(64 * 1024)	},
	{ 0, 0, 0, 0, 0 }
};

<span class="enscript-type">int</span>
<span class="enscript-function-name">proto_hash_value</span>(u_int32_t protocol_family)
{
	<span class="enscript-comment">/*
	 * dlil_proto_unplumb_all() depends on the mapping between
	 * the hash bucket index and the protocol family defined
	 * here; future changes must be applied there as well.
	 */</span>
	<span class="enscript-keyword">switch</span>(protocol_family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET</span>:
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET6</span>:
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_VLAN</span>:
			<span class="enscript-keyword">return</span> (2);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_UNSPEC</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (3);
	}
}

<span class="enscript-comment">/*
 * Caller must already be holding ifnet lock.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> if_proto *
<span class="enscript-function-name">find_attached_proto</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t protocol_family)
{
	<span class="enscript-type">struct</span> if_proto *proto = NULL;
	u_int32_t i = proto_hash_value(protocol_family);

	ifnet_lock_assert(ifp, IFNET_LCK_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (ifp-&gt;if_proto_hash != NULL)
		proto = SLIST_FIRST(&amp;ifp-&gt;if_proto_hash[i]);

	<span class="enscript-keyword">while</span> (proto != NULL &amp;&amp; proto-&gt;protocol_family != protocol_family)
		proto = SLIST_NEXT(proto, next_hash);

	<span class="enscript-keyword">if</span> (proto != NULL)
		if_proto_ref(proto);

	<span class="enscript-keyword">return</span> (proto);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">if_proto_ref</span>(<span class="enscript-type">struct</span> if_proto *proto)
{
	atomic_add_32(&amp;proto-&gt;refcount, 1);
}

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_rtproto_del</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> protocol);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">if_proto_free</span>(<span class="enscript-type">struct</span> if_proto *proto)
{
	u_int32_t oldval;
	<span class="enscript-type">struct</span> ifnet *ifp = proto-&gt;ifp;
	u_int32_t proto_family = proto-&gt;protocol_family;
	<span class="enscript-type">struct</span> kev_dl_proto_data ev_pr_data;

	oldval = atomic_add_32_ov(&amp;proto-&gt;refcount, -1);
	<span class="enscript-keyword">if</span> (oldval &gt; 1)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* No more reference on this, protocol must have been detached */</span>
	VERIFY(proto-&gt;detached);

	<span class="enscript-keyword">if</span> (proto-&gt;proto_kpi == kProtoKPI_v1) {
		<span class="enscript-keyword">if</span> (proto-&gt;kpi.v1.detached)
			proto-&gt;kpi.v1.detached(ifp, proto-&gt;protocol_family);
	}
	<span class="enscript-keyword">if</span> (proto-&gt;proto_kpi == kProtoKPI_v2) {
		<span class="enscript-keyword">if</span> (proto-&gt;kpi.v2.detached)
			proto-&gt;kpi.v2.detached(ifp, proto-&gt;protocol_family);
	}

	<span class="enscript-comment">/*
	 * Cleanup routes that may still be in the routing table for that
	 * interface/protocol pair.
	 */</span>
	if_rtproto_del(ifp, proto_family);

	<span class="enscript-comment">/*
	 * The reserved field carries the number of protocol still attached
	 * (subject to change)
	 */</span>
	ifnet_lock_shared(ifp);
	ev_pr_data.proto_family = proto_family;
	ev_pr_data.proto_remaining_count = dlil_ifp_proto_count(ifp);
	ifnet_lock_done(ifp);

	dlil_post_msg(ifp, KEV_DL_SUBCLASS, KEV_DL_PROTO_DETACHED,
	    (<span class="enscript-type">struct</span> net_event_data *)&amp;ev_pr_data,
	    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kev_dl_proto_data));

	zfree(dlif_proto_zone, proto);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_lock_assert</span>(<span class="enscript-type">struct</span> ifnet *ifp, ifnet_lock_assert_t what)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> type = 0;
	<span class="enscript-type">int</span> ass = 1;

	<span class="enscript-keyword">switch</span> (what) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFNET_LCK_ASSERT_EXCLUSIVE</span>:
		type = LCK_RW_ASSERT_EXCLUSIVE;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFNET_LCK_ASSERT_SHARED</span>:
		type = LCK_RW_ASSERT_SHARED;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFNET_LCK_ASSERT_OWNED</span>:
		type = LCK_RW_ASSERT_HELD;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFNET_LCK_ASSERT_NOTOWNED</span>:
		<span class="enscript-comment">/* nothing to do here for RW lock; bypass assert */</span>
		ass = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;bad ifnet assert type: %d&quot;</span>, what);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (ass)
		lck_rw_assert(&amp;ifp-&gt;if_lock, type);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_lock_shared</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_rw_lock_shared(&amp;ifp-&gt;if_lock);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_lock_exclusive</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_rw_lock_exclusive(&amp;ifp-&gt;if_lock);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_lock_done</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_rw_done(&amp;ifp-&gt;if_lock);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_inetdata_lock_shared</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_rw_lock_shared(&amp;ifp-&gt;if_inetdata_lock);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_inetdata_lock_exclusive</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_rw_lock_exclusive(&amp;ifp-&gt;if_inetdata_lock);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_inetdata_lock_done</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_rw_done(&amp;ifp-&gt;if_inetdata_lock);
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_inet6data_lock_shared</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_rw_lock_shared(&amp;ifp-&gt;if_inet6data_lock);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_inet6data_lock_exclusive</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_rw_lock_exclusive(&amp;ifp-&gt;if_inet6data_lock);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_inet6data_lock_done</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_rw_done(&amp;ifp-&gt;if_inet6data_lock);
}
#<span class="enscript-reference">endif</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_head_lock_shared</span>(<span class="enscript-type">void</span>)
{
	lck_rw_lock_shared(&amp;ifnet_head_lock);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_head_lock_exclusive</span>(<span class="enscript-type">void</span>)
{
	lck_rw_lock_exclusive(&amp;ifnet_head_lock);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_head_done</span>(<span class="enscript-type">void</span>)
{
	lck_rw_done(&amp;ifnet_head_lock);
}

<span class="enscript-comment">/*
 * Caller must already be holding ifnet lock.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dlil_ifp_proto_count</span>(<span class="enscript-type">struct</span> ifnet * ifp)
{
	<span class="enscript-type">int</span> i, count = 0;

	ifnet_lock_assert(ifp, IFNET_LCK_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (ifp-&gt;if_proto_hash == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; PROTO_HASH_SLOTS; i++) {
		<span class="enscript-type">struct</span> if_proto *proto;
		SLIST_FOREACH(proto, &amp;ifp-&gt;if_proto_hash[i], next_hash) {
			count++;
		}
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (count);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_post_msg</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t event_subclass,
    u_int32_t event_code, <span class="enscript-type">struct</span> net_event_data *event_data,
    u_int32_t event_data_len)
{
	<span class="enscript-type">struct</span> net_event_data ev_data;
	<span class="enscript-type">struct</span> kev_msg ev_msg;

	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span> (ev_msg));
	bzero(&amp;ev_data, <span class="enscript-keyword">sizeof</span> (ev_data));
	<span class="enscript-comment">/*
	 * a net event always starts with a net_event_data structure
	 * but the caller can generate a simple net event or
	 * provide a longer event structure to post
	 */</span>
	ev_msg.vendor_code	= KEV_VENDOR_APPLE;
	ev_msg.kev_class	= KEV_NETWORK_CLASS;
	ev_msg.kev_subclass	= event_subclass;
	ev_msg.event_code	= event_code;

	<span class="enscript-keyword">if</span> (event_data == NULL) {
		event_data = &amp;ev_data;
		event_data_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> net_event_data);
	}

	strlcpy(&amp;event_data-&gt;if_name[0], ifp-&gt;if_name, IFNAMSIZ);
	event_data-&gt;if_family = ifp-&gt;if_family;
	event_data-&gt;if_unit   = (u_int32_t) ifp-&gt;if_unit;

	ev_msg.dv[0].data_length = event_data_len;
	ev_msg.dv[0].data_ptr    = event_data;
	ev_msg.dv[1].data_length = 0;

	dlil_event_internal(ifp, &amp;ev_msg);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">dlil_alloc_local_stats</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">int</span> ret = EINVAL;
	<span class="enscript-type">void</span> *buf, *base, **pbuf;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;

	<span class="enscript-keyword">if</span> (ifp-&gt;if_tcp_stat == NULL &amp;&amp; ifp-&gt;if_udp_stat == NULL) {
		<span class="enscript-comment">/* allocate tcpstat_local structure */</span>
		buf = zalloc(dlif_tcpstat_zone);
		<span class="enscript-keyword">if</span> (buf == NULL) {
			ret = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
		}
		bzero(buf, dlif_tcpstat_bufsize);

		<span class="enscript-comment">/* Get the 64-bit aligned base address for this object */</span>
		base = (<span class="enscript-type">void</span> *)P2ROUNDUP((intptr_t)buf + <span class="enscript-keyword">sizeof</span> (u_int64_t),
		    <span class="enscript-keyword">sizeof</span> (u_int64_t));
		VERIFY(((intptr_t)base + dlif_tcpstat_size) &lt;=
		    ((intptr_t)buf + dlif_tcpstat_bufsize));

		<span class="enscript-comment">/*
		 * Wind back a pointer size from the aligned base and
		 * save the original address so we can free it later.
		 */</span>
		pbuf = (<span class="enscript-type">void</span> **)((intptr_t)base - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *));
		*pbuf = buf;
		ifp-&gt;if_tcp_stat = base;

		<span class="enscript-comment">/* allocate udpstat_local structure */</span>
		buf = zalloc(dlif_udpstat_zone);
		<span class="enscript-keyword">if</span> (buf == NULL) {
			ret = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
		}
		bzero(buf, dlif_udpstat_bufsize);

		<span class="enscript-comment">/* Get the 64-bit aligned base address for this object */</span>
		base = (<span class="enscript-type">void</span> *)P2ROUNDUP((intptr_t)buf + <span class="enscript-keyword">sizeof</span> (u_int64_t),
		    <span class="enscript-keyword">sizeof</span> (u_int64_t));
		VERIFY(((intptr_t)base + dlif_udpstat_size) &lt;=
		    ((intptr_t)buf + dlif_udpstat_bufsize));

		<span class="enscript-comment">/*
		 * Wind back a pointer size from the aligned base and
		 * save the original address so we can free it later.
		 */</span>
		pbuf = (<span class="enscript-type">void</span> **)((intptr_t)base - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *));
		*pbuf = buf;
		ifp-&gt;if_udp_stat = base;

		VERIFY(IS_P2ALIGNED(ifp-&gt;if_tcp_stat, <span class="enscript-keyword">sizeof</span> (u_int64_t)) &amp;&amp;
		    IS_P2ALIGNED(ifp-&gt;if_udp_stat, <span class="enscript-keyword">sizeof</span> (u_int64_t)));

		ret = 0;
	}

<span class="enscript-reference">end</span>:
	<span class="enscript-keyword">if</span> (ret != 0) {
		<span class="enscript-keyword">if</span> (ifp-&gt;if_tcp_stat != NULL) {
			pbuf = (<span class="enscript-type">void</span> **)
			    ((intptr_t)ifp-&gt;if_tcp_stat - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *));
			zfree(dlif_tcpstat_zone, *pbuf);
			ifp-&gt;if_tcp_stat = NULL;
		}
		<span class="enscript-keyword">if</span> (ifp-&gt;if_udp_stat != NULL) {
			pbuf = (<span class="enscript-type">void</span> **)
			    ((intptr_t)ifp-&gt;if_udp_stat - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *));
			zfree(dlif_udpstat_zone, *pbuf);
			ifp-&gt;if_udp_stat = NULL;
		}
	}

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dlil_create_input_thread</span>(ifnet_t ifp, <span class="enscript-type">struct</span> dlil_threading_info *inp)
{
	thread_continue_t func;
	u_int32_t limit;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* NULL ifp indicates the main input thread, called at dlil_init time */</span>
	<span class="enscript-keyword">if</span> (ifp == NULL) {
		func = dlil_main_input_thread_func;
		VERIFY(inp == dlil_main_input_thread);
		(<span class="enscript-type">void</span>) strlcat(inp-&gt;input_name,
		    <span class="enscript-string">&quot;main_input&quot;</span>, DLIL_THREADNAME_LEN);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (net_rxpoll &amp;&amp; (ifp-&gt;if_eflags &amp; IFEF_RXPOLL)) {
		func = dlil_rxpoll_input_thread_func;
		VERIFY(inp != dlil_main_input_thread);
		(<span class="enscript-type">void</span>) snprintf(inp-&gt;input_name, DLIL_THREADNAME_LEN,
		    <span class="enscript-string">&quot;%s_input_poll&quot;</span>, if_name(ifp));
	} <span class="enscript-keyword">else</span> {
		func = dlil_input_thread_func;
		VERIFY(inp != dlil_main_input_thread);
		(<span class="enscript-type">void</span>) snprintf(inp-&gt;input_name, DLIL_THREADNAME_LEN,
		    <span class="enscript-string">&quot;%s_input&quot;</span>, if_name(ifp));
	}
	VERIFY(inp-&gt;input_thr == THREAD_NULL);

	inp-&gt;lck_grp = lck_grp_alloc_init(inp-&gt;input_name, dlil_grp_attributes);
	lck_mtx_init(&amp;inp-&gt;input_lck, inp-&gt;lck_grp, dlil_lck_attributes);

	inp-&gt;mode = IFNET_MODEL_INPUT_POLL_OFF;
	inp-&gt;ifp = ifp;		<span class="enscript-comment">/* NULL for main input thread */</span>

	net_timerclear(&amp;inp-&gt;mode_holdtime);
	net_timerclear(&amp;inp-&gt;mode_lasttime);
	net_timerclear(&amp;inp-&gt;sample_holdtime);
	net_timerclear(&amp;inp-&gt;sample_lasttime);
	net_timerclear(&amp;inp-&gt;dbg_lasttime);

	<span class="enscript-comment">/*
	 * For interfaces that support opportunistic polling, set the
	 * low and high watermarks for outstanding inbound packets/bytes.
	 * Also define freeze times for transitioning between modes
	 * and updating the average.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp != NULL &amp;&amp; net_rxpoll &amp;&amp; (ifp-&gt;if_eflags &amp; IFEF_RXPOLL)) {
		limit = MAX(if_rcvq_maxlen, IF_RCVQ_MINLEN);
		(<span class="enscript-type">void</span>) dlil_rxpoll_set_params(ifp, NULL, FALSE);
	} <span class="enscript-keyword">else</span> {
		limit = (u_int32_t)-1;
	}

	_qinit(&amp;inp-&gt;rcvq_pkts, Q_DROPTAIL, limit);
	<span class="enscript-keyword">if</span> (inp == dlil_main_input_thread) {
		<span class="enscript-type">struct</span> dlil_main_threading_info *inpm =
		    (<span class="enscript-type">struct</span> dlil_main_threading_info *)inp;
		_qinit(&amp;inpm-&gt;lo_rcvq_pkts, Q_DROPTAIL, limit);
	}

	error = kernel_thread_start(func, inp, &amp;inp-&gt;input_thr);
	<span class="enscript-keyword">if</span> (error == KERN_SUCCESS) {
		ml_thread_policy(inp-&gt;input_thr, MACHINE_GROUP,
		    (MACHINE_NETWORK_GROUP|MACHINE_NETWORK_NETISR));
		<span class="enscript-comment">/*
		 * We create an affinity set so that the matching workloop
		 * thread or the starter thread (for loopback) can be
		 * scheduled on the same processor set as the input thread.
		 */</span>
		<span class="enscript-keyword">if</span> (net_affinity) {
			<span class="enscript-type">struct</span> thread *tp = inp-&gt;input_thr;
			u_int32_t tag;
			<span class="enscript-comment">/*
			 * Randomize to reduce the probability
			 * of affinity tag namespace collision.
			 */</span>
			read_random(&amp;tag, <span class="enscript-keyword">sizeof</span> (tag));
			<span class="enscript-keyword">if</span> (dlil_affinity_set(tp, tag) == KERN_SUCCESS) {
				thread_reference(tp);
				inp-&gt;tag = tag;
				inp-&gt;net_affinity = TRUE;
			}
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp == dlil_main_input_thread) {
		panic_plain(<span class="enscript-string">&quot;%s: couldn't create main input thread&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> {
		panic_plain(<span class="enscript-string">&quot;%s: couldn't create %s input thread&quot;</span>, __func__,
		    if_name(ifp));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	OSAddAtomic(1, &amp;cur_dlil_input_threads);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_terminate_input_thread</span>(<span class="enscript-type">struct</span> dlil_threading_info *inp)
{
	<span class="enscript-type">struct</span> ifnet *ifp;

	VERIFY(current_thread() == inp-&gt;input_thr);
	VERIFY(inp != dlil_main_input_thread);

	OSAddAtomic(-1, &amp;cur_dlil_input_threads);

	lck_mtx_destroy(&amp;inp-&gt;input_lck, inp-&gt;lck_grp);
	lck_grp_free(inp-&gt;lck_grp);

	inp-&gt;input_waiting = 0;
	inp-&gt;wtot = 0;
	bzero(inp-&gt;input_name, <span class="enscript-keyword">sizeof</span> (inp-&gt;input_name));
	ifp = inp-&gt;ifp;
	inp-&gt;ifp = NULL;
	VERIFY(qhead(&amp;inp-&gt;rcvq_pkts) == NULL &amp;&amp; qempty(&amp;inp-&gt;rcvq_pkts));
	qlimit(&amp;inp-&gt;rcvq_pkts) = 0;
	bzero(&amp;inp-&gt;stats, <span class="enscript-keyword">sizeof</span> (inp-&gt;stats));

	VERIFY(!inp-&gt;net_affinity);
	inp-&gt;input_thr = THREAD_NULL;
	VERIFY(inp-&gt;wloop_thr == THREAD_NULL);
	VERIFY(inp-&gt;poll_thr == THREAD_NULL);
	VERIFY(inp-&gt;tag == 0);

	inp-&gt;mode = IFNET_MODEL_INPUT_POLL_OFF;
	bzero(&amp;inp-&gt;tstats, <span class="enscript-keyword">sizeof</span> (inp-&gt;tstats));
	bzero(&amp;inp-&gt;pstats, <span class="enscript-keyword">sizeof</span> (inp-&gt;pstats));
	bzero(&amp;inp-&gt;sstats, <span class="enscript-keyword">sizeof</span> (inp-&gt;sstats));

	net_timerclear(&amp;inp-&gt;mode_holdtime);
	net_timerclear(&amp;inp-&gt;mode_lasttime);
	net_timerclear(&amp;inp-&gt;sample_holdtime);
	net_timerclear(&amp;inp-&gt;sample_lasttime);
	net_timerclear(&amp;inp-&gt;dbg_lasttime);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IFNET_INPUT_SANITY_CHK</span>
	inp-&gt;input_mbuf_cnt = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IFNET_INPUT_SANITY_CHK */</span>

	<span class="enscript-keyword">if</span> (dlil_verbose) {
		printf(<span class="enscript-string">&quot;%s: input thread terminated\n&quot;</span>,
		    if_name(ifp));
	}

	<span class="enscript-comment">/* for the extra refcnt from kernel_thread_start() */</span>
	thread_deallocate(current_thread());

	<span class="enscript-comment">/* this is the end */</span>
	thread_terminate(current_thread());
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">dlil_affinity_set</span>(<span class="enscript-type">struct</span> thread *tp, u_int32_t tag)
{
	thread_affinity_policy_data_t policy;

	bzero(&amp;policy, <span class="enscript-keyword">sizeof</span> (policy));
	policy.affinity_tag = tag;
	<span class="enscript-keyword">return</span> (thread_policy_set(tp, THREAD_AFFINITY_POLICY,
	    (thread_policy_t)&amp;policy, THREAD_AFFINITY_POLICY_COUNT));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_init</span>(<span class="enscript-type">void</span>)
{
	thread_t thread = THREAD_NULL;

	<span class="enscript-comment">/*
	 * The following fields must be 64-bit aligned for atomic operations.
	 */</span>
	IF_DATA_REQUIRE_ALIGNED_64(ifi_ipackets);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_ierrors)
	IF_DATA_REQUIRE_ALIGNED_64(ifi_opackets);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_oerrors);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_collisions);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_ibytes);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_obytes);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_imcasts);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_omcasts);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_iqdrops);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_noproto);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_alignerrs);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_dt_bytes);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_fpackets);
	IF_DATA_REQUIRE_ALIGNED_64(ifi_fbytes);

	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_ipackets);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_ierrors)
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_opackets);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_oerrors);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_collisions);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_ibytes);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_obytes);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_imcasts);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_omcasts);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_iqdrops);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_noproto);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_alignerrs);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_dt_bytes);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_fpackets);
	IFNET_IF_DATA_REQUIRE_ALIGNED_64(ifi_fbytes);

	<span class="enscript-comment">/*
	 * These IF_HWASSIST_ flags must be equal to their IFNET_* counterparts.
	 */</span>
	_CASSERT(IF_HWASSIST_CSUM_IP == IFNET_CSUM_IP);
	_CASSERT(IF_HWASSIST_CSUM_TCP == IFNET_CSUM_TCP);
	_CASSERT(IF_HWASSIST_CSUM_UDP == IFNET_CSUM_UDP);
	_CASSERT(IF_HWASSIST_CSUM_IP_FRAGS == IFNET_CSUM_FRAGMENT);
	_CASSERT(IF_HWASSIST_CSUM_FRAGMENT == IFNET_IP_FRAGMENT);
	_CASSERT(IF_HWASSIST_CSUM_TCPIPV6 == IFNET_CSUM_TCPIPV6);
	_CASSERT(IF_HWASSIST_CSUM_UDPIPV6 == IFNET_CSUM_UDPIPV6);
	_CASSERT(IF_HWASSIST_CSUM_FRAGMENT_IPV6 == IFNET_IPV6_FRAGMENT);
	_CASSERT(IF_HWASSIST_CSUM_PARTIAL == IFNET_CSUM_PARTIAL);
	_CASSERT(IF_HWASSIST_VLAN_TAGGING == IFNET_VLAN_TAGGING);
	_CASSERT(IF_HWASSIST_VLAN_MTU == IFNET_VLAN_MTU);
	_CASSERT(IF_HWASSIST_TSO_V4 == IFNET_TSO_IPV4);
	_CASSERT(IF_HWASSIST_TSO_V6 == IFNET_TSO_IPV6);

	<span class="enscript-comment">/*
	 * ... as well as the mbuf checksum flags counterparts.
	 */</span>
	_CASSERT(CSUM_IP == IF_HWASSIST_CSUM_IP);
	_CASSERT(CSUM_TCP == IF_HWASSIST_CSUM_TCP);
	_CASSERT(CSUM_UDP == IF_HWASSIST_CSUM_UDP);
	_CASSERT(CSUM_IP_FRAGS == IF_HWASSIST_CSUM_IP_FRAGS);
	_CASSERT(CSUM_FRAGMENT == IF_HWASSIST_CSUM_FRAGMENT);
	_CASSERT(CSUM_TCPIPV6 == IF_HWASSIST_CSUM_TCPIPV6);
	_CASSERT(CSUM_UDPIPV6 == IF_HWASSIST_CSUM_UDPIPV6);
	_CASSERT(CSUM_FRAGMENT_IPV6 == IF_HWASSIST_CSUM_FRAGMENT_IPV6);
	_CASSERT(CSUM_PARTIAL == IF_HWASSIST_CSUM_PARTIAL);
	_CASSERT(CSUM_VLAN_TAG_VALID == IF_HWASSIST_VLAN_TAGGING);

	<span class="enscript-comment">/*
	 * Make sure we have at least IF_LLREACH_MAXLEN in the llreach info.
	 */</span>
	_CASSERT(IF_LLREACH_MAXLEN &lt;= IF_LLREACHINFO_ADDRLEN);
	_CASSERT(IFNET_LLREACHINFO_ADDRLEN == IF_LLREACHINFO_ADDRLEN);

	_CASSERT(IFRLOGF_DLIL == IFNET_LOGF_DLIL);
	_CASSERT(IFRLOGF_FAMILY == IFNET_LOGF_FAMILY);
	_CASSERT(IFRLOGF_DRIVER == IFNET_LOGF_DRIVER);
	_CASSERT(IFRLOGF_FIRMWARE == IFNET_LOGF_FIRMWARE);

	_CASSERT(IFRLOGCAT_CONNECTIVITY == IFNET_LOGCAT_CONNECTIVITY);
	_CASSERT(IFRLOGCAT_QUALITY == IFNET_LOGCAT_QUALITY);
	_CASSERT(IFRLOGCAT_PERFORMANCE == IFNET_LOGCAT_PERFORMANCE);

	_CASSERT(IFRTYPE_FAMILY_ANY == IFNET_FAMILY_ANY);
	_CASSERT(IFRTYPE_FAMILY_LOOPBACK == IFNET_FAMILY_LOOPBACK);
	_CASSERT(IFRTYPE_FAMILY_ETHERNET == IFNET_FAMILY_ETHERNET);
	_CASSERT(IFRTYPE_FAMILY_SLIP == IFNET_FAMILY_SLIP);
	_CASSERT(IFRTYPE_FAMILY_TUN == IFNET_FAMILY_TUN);
	_CASSERT(IFRTYPE_FAMILY_VLAN == IFNET_FAMILY_VLAN);
	_CASSERT(IFRTYPE_FAMILY_PPP == IFNET_FAMILY_PPP);
	_CASSERT(IFRTYPE_FAMILY_PVC == IFNET_FAMILY_PVC);
	_CASSERT(IFRTYPE_FAMILY_DISC == IFNET_FAMILY_DISC);
	_CASSERT(IFRTYPE_FAMILY_MDECAP == IFNET_FAMILY_MDECAP);
	_CASSERT(IFRTYPE_FAMILY_GIF == IFNET_FAMILY_GIF);
	_CASSERT(IFRTYPE_FAMILY_FAITH == IFNET_FAMILY_FAITH);
	_CASSERT(IFRTYPE_FAMILY_STF == IFNET_FAMILY_STF);
	_CASSERT(IFRTYPE_FAMILY_FIREWIRE == IFNET_FAMILY_FIREWIRE);
	_CASSERT(IFRTYPE_FAMILY_BOND == IFNET_FAMILY_BOND);
	_CASSERT(IFRTYPE_FAMILY_CELLULAR == IFNET_FAMILY_CELLULAR);

	_CASSERT(IFRTYPE_SUBFAMILY_ANY == IFNET_SUBFAMILY_ANY);
	_CASSERT(IFRTYPE_SUBFAMILY_USB == IFNET_SUBFAMILY_USB);
	_CASSERT(IFRTYPE_SUBFAMILY_BLUETOOTH == IFNET_SUBFAMILY_BLUETOOTH);
	_CASSERT(IFRTYPE_SUBFAMILY_WIFI == IFNET_SUBFAMILY_WIFI);
	_CASSERT(IFRTYPE_SUBFAMILY_THUNDERBOLT == IFNET_SUBFAMILY_THUNDERBOLT);
	_CASSERT(IFRTYPE_SUBFAMILY_RESERVED == IFNET_SUBFAMILY_RESERVED);

	_CASSERT(DLIL_MODIDLEN == IFNET_MODIDLEN);
	_CASSERT(DLIL_MODARGLEN == IFNET_MODARGLEN);

	PE_parse_boot_argn(<span class="enscript-string">&quot;net_affinity&quot;</span>, &amp;net_affinity,
	    <span class="enscript-keyword">sizeof</span> (net_affinity));

	PE_parse_boot_argn(<span class="enscript-string">&quot;net_rxpoll&quot;</span>, &amp;net_rxpoll, <span class="enscript-keyword">sizeof</span> (net_rxpoll));

	PE_parse_boot_argn(<span class="enscript-string">&quot;net_rtref&quot;</span>, &amp;net_rtref, <span class="enscript-keyword">sizeof</span> (net_rtref));

	PE_parse_boot_argn(<span class="enscript-string">&quot;ifnet_debug&quot;</span>, &amp;ifnet_debug, <span class="enscript-keyword">sizeof</span> (ifnet_debug));

	dlif_size = (ifnet_debug == 0) ? <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> dlil_ifnet) :
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> dlil_ifnet_dbg);
	<span class="enscript-comment">/* Enforce 64-bit alignment for dlil_ifnet structure */</span>
	dlif_bufsize = dlif_size + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *) + <span class="enscript-keyword">sizeof</span> (u_int64_t);
	dlif_bufsize = P2ROUNDUP(dlif_bufsize, <span class="enscript-keyword">sizeof</span> (u_int64_t));
	dlif_zone = zinit(dlif_bufsize, DLIF_ZONE_MAX * dlif_bufsize,
	    0, DLIF_ZONE_NAME);
	<span class="enscript-keyword">if</span> (dlif_zone == NULL) {
		panic_plain(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__,
		    DLIF_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(dlif_zone, Z_EXPAND, TRUE);
	zone_change(dlif_zone, Z_CALLERACCT, FALSE);

	dlif_filt_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifnet_filter);
	dlif_filt_zone = zinit(dlif_filt_size,
	    DLIF_FILT_ZONE_MAX * dlif_filt_size, 0, DLIF_FILT_ZONE_NAME);
	<span class="enscript-keyword">if</span> (dlif_filt_zone == NULL) {
		panic_plain(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__,
		    DLIF_FILT_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(dlif_filt_zone, Z_EXPAND, TRUE);
	zone_change(dlif_filt_zone, Z_CALLERACCT, FALSE);

	dlif_phash_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> proto_hash_entry) * PROTO_HASH_SLOTS;
	dlif_phash_zone = zinit(dlif_phash_size,
	    DLIF_PHASH_ZONE_MAX * dlif_phash_size, 0, DLIF_PHASH_ZONE_NAME);
	<span class="enscript-keyword">if</span> (dlif_phash_zone == NULL) {
		panic_plain(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__,
		    DLIF_PHASH_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(dlif_phash_zone, Z_EXPAND, TRUE);
	zone_change(dlif_phash_zone, Z_CALLERACCT, FALSE);

	dlif_proto_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> if_proto);
	dlif_proto_zone = zinit(dlif_proto_size,
	    DLIF_PROTO_ZONE_MAX * dlif_proto_size, 0, DLIF_PROTO_ZONE_NAME);
	<span class="enscript-keyword">if</span> (dlif_proto_zone == NULL) {
		panic_plain(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__,
		    DLIF_PROTO_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(dlif_proto_zone, Z_EXPAND, TRUE);
	zone_change(dlif_proto_zone, Z_CALLERACCT, FALSE);

	dlif_tcpstat_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcpstat_local);
	<span class="enscript-comment">/* Enforce 64-bit alignment for tcpstat_local structure */</span>
	dlif_tcpstat_bufsize =
	    dlif_tcpstat_size + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *) + <span class="enscript-keyword">sizeof</span> (u_int64_t);
	dlif_tcpstat_bufsize =
	    P2ROUNDUP(dlif_tcpstat_bufsize, <span class="enscript-keyword">sizeof</span> (u_int64_t));
	dlif_tcpstat_zone = zinit(dlif_tcpstat_bufsize,
	    DLIF_TCPSTAT_ZONE_MAX * dlif_tcpstat_bufsize, 0,
	    DLIF_TCPSTAT_ZONE_NAME);
	<span class="enscript-keyword">if</span> (dlif_tcpstat_zone == NULL) {
		panic_plain(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__,
		    DLIF_TCPSTAT_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(dlif_tcpstat_zone, Z_EXPAND, TRUE);
	zone_change(dlif_tcpstat_zone, Z_CALLERACCT, FALSE);

	dlif_udpstat_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udpstat_local);
	<span class="enscript-comment">/* Enforce 64-bit alignment for udpstat_local structure */</span>
	dlif_udpstat_bufsize =
	    dlif_udpstat_size + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *) + <span class="enscript-keyword">sizeof</span> (u_int64_t);
	dlif_udpstat_bufsize =
	    P2ROUNDUP(dlif_udpstat_bufsize, <span class="enscript-keyword">sizeof</span> (u_int64_t));
	dlif_udpstat_zone = zinit(dlif_udpstat_bufsize,
	    DLIF_TCPSTAT_ZONE_MAX * dlif_udpstat_bufsize, 0,
	    DLIF_UDPSTAT_ZONE_NAME);
	<span class="enscript-keyword">if</span> (dlif_udpstat_zone == NULL) {
		panic_plain(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__,
		    DLIF_UDPSTAT_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(dlif_udpstat_zone, Z_EXPAND, TRUE);
	zone_change(dlif_udpstat_zone, Z_CALLERACCT, FALSE);

	ifnet_llreach_init();

	TAILQ_INIT(&amp;dlil_ifnet_head);
	TAILQ_INIT(&amp;ifnet_head);
	TAILQ_INIT(&amp;ifnet_detaching_head);

	<span class="enscript-comment">/* Setup the lock groups we will use */</span>
	dlil_grp_attributes = lck_grp_attr_alloc_init();

	dlil_lock_group = lck_grp_alloc_init(<span class="enscript-string">&quot;DLIL internal locks&quot;</span>,
	    dlil_grp_attributes);
	ifnet_lock_group = lck_grp_alloc_init(<span class="enscript-string">&quot;ifnet locks&quot;</span>,
	    dlil_grp_attributes);
	ifnet_head_lock_group = lck_grp_alloc_init(<span class="enscript-string">&quot;ifnet head lock&quot;</span>,
	    dlil_grp_attributes);
	ifnet_rcv_lock_group = lck_grp_alloc_init(<span class="enscript-string">&quot;ifnet rcv locks&quot;</span>,
	    dlil_grp_attributes);
	ifnet_snd_lock_group = lck_grp_alloc_init(<span class="enscript-string">&quot;ifnet snd locks&quot;</span>,
	    dlil_grp_attributes);

	<span class="enscript-comment">/* Setup the lock attributes we will use */</span>
	dlil_lck_attributes = lck_attr_alloc_init();

	ifnet_lock_attr = lck_attr_alloc_init();

	lck_rw_init(&amp;ifnet_head_lock, ifnet_head_lock_group,
	    dlil_lck_attributes);
	lck_mtx_init(&amp;dlil_ifnet_lock, dlil_lock_group, dlil_lck_attributes);

	<span class="enscript-comment">/* Setup interface flow control related items */</span>
	lck_mtx_init(&amp;ifnet_fc_lock, dlil_lock_group, dlil_lck_attributes);

	ifnet_fc_zone_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifnet_fc_entry);
	ifnet_fc_zone = zinit(ifnet_fc_zone_size,
	    IFNET_FC_ZONE_MAX * ifnet_fc_zone_size, 0, IFNET_FC_ZONE_NAME);
	<span class="enscript-keyword">if</span> (ifnet_fc_zone == NULL) {
		panic_plain(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__,
		    IFNET_FC_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(ifnet_fc_zone, Z_EXPAND, TRUE);
	zone_change(ifnet_fc_zone, Z_CALLERACCT, FALSE);

	<span class="enscript-comment">/* Initialize interface address subsystem */</span>
	ifa_init();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	<span class="enscript-comment">/* Initialize the packet filter */</span>
	pfinit();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

	<span class="enscript-comment">/* Initialize queue algorithms */</span>
	classq_init();

	<span class="enscript-comment">/* Initialize packet schedulers */</span>
	pktsched_init();

	<span class="enscript-comment">/* Initialize flow advisory subsystem */</span>
	flowadv_init();

	<span class="enscript-comment">/* Initialize the pktap virtual interface */</span>
	pktap_init();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-comment">/* Run self-tests */</span>
	dlil_verify_sum16();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	<span class="enscript-comment">/*
	 * Create and start up the main DLIL input thread and the interface
	 * detacher threads once everything is initialized.
	 */</span>
	dlil_create_input_thread(NULL, dlil_main_input_thread);

	<span class="enscript-keyword">if</span> (kernel_thread_start(ifnet_detacher_thread_func,
	    NULL, &amp;thread) != KERN_SUCCESS) {
		panic_plain(<span class="enscript-string">&quot;%s: couldn't create detacher thread&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	thread_deallocate(thread);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">if_flt_monitor_busy</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_mtx_assert(&amp;ifp-&gt;if_flt_lock, LCK_MTX_ASSERT_OWNED);

	++ifp-&gt;if_flt_busy;
	VERIFY(ifp-&gt;if_flt_busy != 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">if_flt_monitor_unbusy</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	if_flt_monitor_leave(ifp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">if_flt_monitor_enter</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_mtx_assert(&amp;ifp-&gt;if_flt_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">while</span> (ifp-&gt;if_flt_busy) {
		++ifp-&gt;if_flt_waiters;
		(<span class="enscript-type">void</span>) msleep(&amp;ifp-&gt;if_flt_head, &amp;ifp-&gt;if_flt_lock,
		    (PZERO - 1), <span class="enscript-string">&quot;if_flt_monitor&quot;</span>, NULL);
	}
	if_flt_monitor_busy(ifp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">if_flt_monitor_leave</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_mtx_assert(&amp;ifp-&gt;if_flt_lock, LCK_MTX_ASSERT_OWNED);

	VERIFY(ifp-&gt;if_flt_busy != 0);
	--ifp-&gt;if_flt_busy;

	<span class="enscript-keyword">if</span> (ifp-&gt;if_flt_busy == 0 &amp;&amp; ifp-&gt;if_flt_waiters &gt; 0) {
		ifp-&gt;if_flt_waiters = 0;
		wakeup(&amp;ifp-&gt;if_flt_head);
	}
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">dlil_attach_filter</span>(<span class="enscript-type">struct</span> ifnet	*ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> iff_filter *if_filter,
    interface_filter_t *filter_ref, u_int32_t flags)
{
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">struct</span> ifnet_filter *filter = NULL;

	ifnet_head_lock_shared();
	<span class="enscript-comment">/* Check that the interface is in the global list */</span>
	<span class="enscript-keyword">if</span> (!ifnet_lookup(ifp)) {
		retval = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	filter = zalloc(dlif_filt_zone);
	<span class="enscript-keyword">if</span> (filter == NULL) {
		retval = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	bzero(filter, dlif_filt_size);

	<span class="enscript-comment">/* refcnt held above during lookup */</span>
	filter-&gt;filt_flags = flags;
	filter-&gt;filt_ifp = ifp;
	filter-&gt;filt_cookie = if_filter-&gt;iff_cookie;
	filter-&gt;filt_name = if_filter-&gt;iff_name;
	filter-&gt;filt_protocol = if_filter-&gt;iff_protocol;
	filter-&gt;filt_input = if_filter-&gt;iff_input;
	filter-&gt;filt_output = if_filter-&gt;iff_output;
	filter-&gt;filt_event = if_filter-&gt;iff_event;
	filter-&gt;filt_ioctl = if_filter-&gt;iff_ioctl;
	filter-&gt;filt_detached = if_filter-&gt;iff_detached;

	lck_mtx_lock(&amp;ifp-&gt;if_flt_lock);
	if_flt_monitor_enter(ifp);

	lck_mtx_assert(&amp;ifp-&gt;if_flt_lock, LCK_MTX_ASSERT_OWNED);
	TAILQ_INSERT_TAIL(&amp;ifp-&gt;if_flt_head, filter, filt_next);

	if_flt_monitor_leave(ifp);
	lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

	*filter_ref = filter;

	<span class="enscript-comment">/*
	 * Bump filter count and route_generation ID to let TCP
	 * know it shouldn't do TSO on this connection
	 */</span>
	<span class="enscript-keyword">if</span> ((filter-&gt;filt_flags &amp; DLIL_IFF_TSO) == 0) {
		OSAddAtomic(1, &amp;dlil_filter_disable_tso_count);
		routegenid_update();
	}
	<span class="enscript-keyword">if</span> (dlil_verbose) {
		printf(<span class="enscript-string">&quot;%s: %s filter attached\n&quot;</span>, if_name(ifp),
		    if_filter-&gt;iff_name);
	}
<span class="enscript-reference">done</span>:
	ifnet_head_done();
	<span class="enscript-keyword">if</span> (retval != 0 &amp;&amp; ifp != NULL) {
		DLIL_PRINTF(<span class="enscript-string">&quot;%s: failed to attach %s (err=%d)\n&quot;</span>,
		    if_name(ifp), if_filter-&gt;iff_name, retval);
	}
	<span class="enscript-keyword">if</span> (retval != 0 &amp;&amp; filter != NULL)
		zfree(dlif_filt_zone, filter);

	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dlil_detach_filter_internal</span>(interface_filter_t	filter, <span class="enscript-type">int</span> detached)
{
	<span class="enscript-type">int</span> retval = 0;

	<span class="enscript-keyword">if</span> (detached == 0) {
		ifnet_t ifp = NULL;

		ifnet_head_lock_shared();
		TAILQ_FOREACH(ifp, &amp;ifnet_head, if_link) {
			interface_filter_t entry = NULL;

			lck_mtx_lock(&amp;ifp-&gt;if_flt_lock);
			TAILQ_FOREACH(entry, &amp;ifp-&gt;if_flt_head, filt_next) {
				<span class="enscript-keyword">if</span> (entry != filter || entry-&gt;filt_skip)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-comment">/*
				 * We've found a match; since it's possible
				 * that the thread gets blocked in the monitor,
				 * we do the lock dance.  Interface should
				 * not be detached since we still have a use
				 * count held during filter attach.
				 */</span>
				entry-&gt;filt_skip = 1;	<span class="enscript-comment">/* skip input/output */</span>
				lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);
				ifnet_head_done();

				lck_mtx_lock(&amp;ifp-&gt;if_flt_lock);
				if_flt_monitor_enter(ifp);
				lck_mtx_assert(&amp;ifp-&gt;if_flt_lock,
				    LCK_MTX_ASSERT_OWNED);

				<span class="enscript-comment">/* Remove the filter from the list */</span>
				TAILQ_REMOVE(&amp;ifp-&gt;if_flt_head, filter,
				    filt_next);

				if_flt_monitor_leave(ifp);
				lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);
				<span class="enscript-keyword">if</span> (dlil_verbose) {
					printf(<span class="enscript-string">&quot;%s: %s filter detached\n&quot;</span>,
					    if_name(ifp), filter-&gt;filt_name);
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">destroy</span>;
			}
			lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);
		}
		ifnet_head_done();

		<span class="enscript-comment">/* filter parameter is not a valid filter ref */</span>
		retval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (dlil_verbose)
		printf(<span class="enscript-string">&quot;%s filter detached\n&quot;</span>, filter-&gt;filt_name);

<span class="enscript-reference">destroy</span>:

	<span class="enscript-comment">/* Call the detached function if there is one */</span>
	<span class="enscript-keyword">if</span> (filter-&gt;filt_detached)
		filter-&gt;filt_detached(filter-&gt;filt_cookie, filter-&gt;filt_ifp);

	<span class="enscript-comment">/* Free the filter */</span>
	zfree(dlif_filt_zone, filter);

	<span class="enscript-comment">/*
	 * Decrease filter count and route_generation ID to let TCP
	 * know it should reevalute doing TSO or not
	 */</span>
	<span class="enscript-keyword">if</span> ((filter-&gt;filt_flags &amp; DLIL_IFF_TSO) == 0) {
		OSAddAtomic(-1, &amp;dlil_filter_disable_tso_count);
		routegenid_update();
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (retval != 0) {
		DLIL_PRINTF(<span class="enscript-string">&quot;failed to detach %s filter (err=%d)\n&quot;</span>,
		    filter-&gt;filt_name, retval);
	}
	<span class="enscript-keyword">return</span> (retval);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_detach_filter</span>(interface_filter_t filter)
{
	<span class="enscript-keyword">if</span> (filter == NULL)
		<span class="enscript-keyword">return</span>;
	dlil_detach_filter_internal(filter, 0);
}

<span class="enscript-comment">/*
 * Main input thread:
 *
 *   a) handles all inbound packets for lo0
 *   b) handles all inbound packets for interfaces with no dedicated
 *	input thread (e.g. anything but Ethernet/PDP or those that support
 *	opportunistic polling.)
 *   c) protocol registrations
 *   d) packet injections
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_main_input_thread_func</span>(<span class="enscript-type">void</span> *v, wait_result_t w)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">w</span>)
	<span class="enscript-type">struct</span> dlil_main_threading_info *inpm = v;
	<span class="enscript-type">struct</span> dlil_threading_info *inp = v;

	VERIFY(inp == dlil_main_input_thread);
	VERIFY(inp-&gt;ifp == NULL);
	VERIFY(inp-&gt;mode == IFNET_MODEL_INPUT_POLL_OFF);

	<span class="enscript-keyword">while</span> (1) {
		<span class="enscript-type">struct</span> mbuf *m = NULL, *m_loop = NULL;
		u_int32_t m_cnt, m_cnt_loop;
		boolean_t proto_req;

		lck_mtx_lock_spin(&amp;inp-&gt;input_lck);

		<span class="enscript-comment">/* Wait until there is work to be done */</span>
		<span class="enscript-keyword">while</span> (!(inp-&gt;input_waiting &amp; ~DLIL_INPUT_RUNNING)) {
			inp-&gt;input_waiting &amp;= ~DLIL_INPUT_RUNNING;
			(<span class="enscript-type">void</span>) msleep(&amp;inp-&gt;input_waiting, &amp;inp-&gt;input_lck,
			    (PZERO - 1) | PSPIN, inp-&gt;input_name, NULL);
		}

		inp-&gt;input_waiting |= DLIL_INPUT_RUNNING;
		inp-&gt;input_waiting &amp;= ~DLIL_INPUT_WAITING;

		<span class="enscript-comment">/* Main input thread cannot be terminated */</span>
		VERIFY(!(inp-&gt;input_waiting &amp; DLIL_INPUT_TERMINATE));

		proto_req = (inp-&gt;input_waiting &amp;
		    (DLIL_PROTO_WAITING | DLIL_PROTO_REGISTER));

		<span class="enscript-comment">/* Packets for non-dedicated interfaces other than lo0 */</span>
		m_cnt = qlen(&amp;inp-&gt;rcvq_pkts);
		m = _getq_all(&amp;inp-&gt;rcvq_pkts);

		<span class="enscript-comment">/* Packets exclusive to lo0 */</span>
		m_cnt_loop = qlen(&amp;inpm-&gt;lo_rcvq_pkts);
		m_loop = _getq_all(&amp;inpm-&gt;lo_rcvq_pkts);

		inp-&gt;wtot = 0;

		lck_mtx_unlock(&amp;inp-&gt;input_lck);

		<span class="enscript-comment">/*
		* NOTE warning %%% attention !!!!
		* We should think about putting some thread starvation
		* safeguards if we deal with long chains of packets.
		*/</span>
		<span class="enscript-keyword">if</span> (m_loop != NULL)
			dlil_input_packet_list_extended(lo_ifp, m_loop,
			    m_cnt_loop, inp-&gt;mode);

		<span class="enscript-keyword">if</span> (m != NULL)
			dlil_input_packet_list_extended(NULL, m,
			    m_cnt, inp-&gt;mode);

		<span class="enscript-keyword">if</span> (proto_req)
			proto_input_run();
	}

	<span class="enscript-comment">/* NOTREACHED */</span>
	VERIFY(0);	<span class="enscript-comment">/* we should never get here */</span>
}

<span class="enscript-comment">/*
 * Input thread for interfaces with legacy input model.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_input_thread_func</span>(<span class="enscript-type">void</span> *v, wait_result_t w)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">w</span>)
	<span class="enscript-type">struct</span> dlil_threading_info *inp = v;
	<span class="enscript-type">struct</span> ifnet *ifp = inp-&gt;ifp;

	VERIFY(inp != dlil_main_input_thread);
	VERIFY(ifp != NULL);
	VERIFY(!(ifp-&gt;if_eflags &amp; IFEF_RXPOLL) || !net_rxpoll);
	VERIFY(inp-&gt;mode == IFNET_MODEL_INPUT_POLL_OFF);

	<span class="enscript-keyword">while</span> (1) {
		<span class="enscript-type">struct</span> mbuf *m = NULL;
		u_int32_t m_cnt;

		lck_mtx_lock_spin(&amp;inp-&gt;input_lck);

		<span class="enscript-comment">/* Wait until there is work to be done */</span>
		<span class="enscript-keyword">while</span> (!(inp-&gt;input_waiting &amp; ~DLIL_INPUT_RUNNING)) {
			inp-&gt;input_waiting &amp;= ~DLIL_INPUT_RUNNING;
			(<span class="enscript-type">void</span>) msleep(&amp;inp-&gt;input_waiting, &amp;inp-&gt;input_lck,
			    (PZERO - 1) | PSPIN, inp-&gt;input_name, NULL);
		}

		inp-&gt;input_waiting |= DLIL_INPUT_RUNNING;
		inp-&gt;input_waiting &amp;= ~DLIL_INPUT_WAITING;

		<span class="enscript-comment">/*
		 * Protocol registration and injection must always use
		 * the main input thread; in theory the latter can utilize
		 * the corresponding input thread where the packet arrived
		 * on, but that requires our knowing the interface in advance
		 * (and the benefits might not worth the trouble.)
		 */</span>
		VERIFY(!(inp-&gt;input_waiting &amp;
		    (DLIL_PROTO_WAITING|DLIL_PROTO_REGISTER)));

		<span class="enscript-comment">/* Packets for this interface */</span>
		m_cnt = qlen(&amp;inp-&gt;rcvq_pkts);
		m = _getq_all(&amp;inp-&gt;rcvq_pkts);

		<span class="enscript-keyword">if</span> (inp-&gt;input_waiting &amp; DLIL_INPUT_TERMINATE) {
			lck_mtx_unlock(&amp;inp-&gt;input_lck);

			<span class="enscript-comment">/* Free up pending packets */</span>
			<span class="enscript-keyword">if</span> (m != NULL)
				mbuf_freem_list(m);

			dlil_terminate_input_thread(inp);
			<span class="enscript-comment">/* NOTREACHED */</span>
			<span class="enscript-keyword">return</span>;
		}

		inp-&gt;wtot = 0;

		dlil_input_stats_sync(ifp, inp);

		lck_mtx_unlock(&amp;inp-&gt;input_lck);

		<span class="enscript-comment">/*
		* NOTE warning %%% attention !!!!
		* We should think about putting some thread starvation
		* safeguards if we deal with long chains of packets.
		*/</span>
		<span class="enscript-keyword">if</span> (m != NULL)
			dlil_input_packet_list_extended(NULL, m,
			    m_cnt, inp-&gt;mode);
	}

	<span class="enscript-comment">/* NOTREACHED */</span>
	VERIFY(0);	<span class="enscript-comment">/* we should never get here */</span>
}

<span class="enscript-comment">/*
 * Input thread for interfaces with opportunistic polling input model.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_rxpoll_input_thread_func</span>(<span class="enscript-type">void</span> *v, wait_result_t w)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">w</span>)
	<span class="enscript-type">struct</span> dlil_threading_info *inp = v;
	<span class="enscript-type">struct</span> ifnet *ifp = inp-&gt;ifp;
	<span class="enscript-type">struct</span> timespec ts;

	VERIFY(inp != dlil_main_input_thread);
	VERIFY(ifp != NULL &amp;&amp; (ifp-&gt;if_eflags &amp; IFEF_RXPOLL));

	<span class="enscript-keyword">while</span> (1) {
		<span class="enscript-type">struct</span> mbuf *m = NULL;
		u_int32_t m_cnt, m_size, poll_req = 0;
		ifnet_model_t mode;
		<span class="enscript-type">struct</span> timespec now, delta;
		u_int64_t ival;

		lck_mtx_lock_spin(&amp;inp-&gt;input_lck);

		<span class="enscript-keyword">if</span> ((ival = inp-&gt;rxpoll_ival) &lt; IF_RXPOLL_INTERVALTIME_MIN)
			ival = IF_RXPOLL_INTERVALTIME_MIN;

		<span class="enscript-comment">/* Link parameters changed? */</span>
		<span class="enscript-keyword">if</span> (ifp-&gt;if_poll_update != 0) {
			ifp-&gt;if_poll_update = 0;
			(<span class="enscript-type">void</span>) dlil_rxpoll_set_params(ifp, NULL, TRUE);
		}

		<span class="enscript-comment">/* Current operating mode */</span>
		mode = inp-&gt;mode;

		<span class="enscript-comment">/* Wait until there is work to be done */</span>
		<span class="enscript-keyword">while</span> (!(inp-&gt;input_waiting &amp; ~DLIL_INPUT_RUNNING)) {
			inp-&gt;input_waiting &amp;= ~DLIL_INPUT_RUNNING;
			(<span class="enscript-type">void</span>) msleep(&amp;inp-&gt;input_waiting, &amp;inp-&gt;input_lck,
			    (PZERO - 1) | PSPIN, inp-&gt;input_name, NULL);
		}

		inp-&gt;input_waiting |= DLIL_INPUT_RUNNING;
		inp-&gt;input_waiting &amp;= ~DLIL_INPUT_WAITING;

		<span class="enscript-comment">/*
		 * Protocol registration and injection must always use
		 * the main input thread; in theory the latter can utilize
		 * the corresponding input thread where the packet arrived
		 * on, but that requires our knowing the interface in advance
		 * (and the benefits might not worth the trouble.)
		 */</span>
		VERIFY(!(inp-&gt;input_waiting &amp;
		    (DLIL_PROTO_WAITING|DLIL_PROTO_REGISTER)));

		<span class="enscript-keyword">if</span> (inp-&gt;input_waiting &amp; DLIL_INPUT_TERMINATE) {
			<span class="enscript-comment">/* Free up pending packets */</span>
			_flushq(&amp;inp-&gt;rcvq_pkts);
			lck_mtx_unlock(&amp;inp-&gt;input_lck);

			dlil_terminate_input_thread(inp);
			<span class="enscript-comment">/* NOTREACHED */</span>
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/* Total count of all packets */</span>
		m_cnt = qlen(&amp;inp-&gt;rcvq_pkts);

		<span class="enscript-comment">/* Total bytes of all packets */</span>
		m_size = qsize(&amp;inp-&gt;rcvq_pkts);

		<span class="enscript-comment">/* Packets for this interface */</span>
		m = _getq_all(&amp;inp-&gt;rcvq_pkts);
		VERIFY(m != NULL || m_cnt == 0);

		nanouptime(&amp;now);
		<span class="enscript-keyword">if</span> (!net_timerisset(&amp;inp-&gt;sample_lasttime))
			*(&amp;inp-&gt;sample_lasttime) = *(&amp;now);

		net_timersub(&amp;now, &amp;inp-&gt;sample_lasttime, &amp;delta);
		<span class="enscript-keyword">if</span> (if_rxpoll &amp;&amp; net_timerisset(&amp;inp-&gt;sample_holdtime)) {
			u_int32_t ptot, btot;

			<span class="enscript-comment">/* Accumulate statistics for current sampling */</span>
			PKTCNTR_ADD(&amp;inp-&gt;sstats, m_cnt, m_size);

			<span class="enscript-keyword">if</span> (net_timercmp(&amp;delta, &amp;inp-&gt;sample_holdtime, &lt;))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip</span>;

			*(&amp;inp-&gt;sample_lasttime) = *(&amp;now);

			<span class="enscript-comment">/* Calculate min/max of inbound bytes */</span>
			btot = (u_int32_t)inp-&gt;sstats.bytes;
			<span class="enscript-keyword">if</span> (inp-&gt;rxpoll_bmin == 0 || inp-&gt;rxpoll_bmin &gt; btot)
				inp-&gt;rxpoll_bmin = btot;
			<span class="enscript-keyword">if</span> (btot &gt; inp-&gt;rxpoll_bmax)
				inp-&gt;rxpoll_bmax = btot;

			<span class="enscript-comment">/* Calculate EWMA of inbound bytes */</span>
			DLIL_EWMA(inp-&gt;rxpoll_bavg, btot, if_rxpoll_decay);

			<span class="enscript-comment">/* Calculate min/max of inbound packets */</span>
			ptot = (u_int32_t)inp-&gt;sstats.packets;
			<span class="enscript-keyword">if</span> (inp-&gt;rxpoll_pmin == 0 || inp-&gt;rxpoll_pmin &gt; ptot)
				inp-&gt;rxpoll_pmin = ptot;
			<span class="enscript-keyword">if</span> (ptot &gt; inp-&gt;rxpoll_pmax)
				inp-&gt;rxpoll_pmax = ptot;

			<span class="enscript-comment">/* Calculate EWMA of inbound packets */</span>
			DLIL_EWMA(inp-&gt;rxpoll_pavg, ptot, if_rxpoll_decay);

			<span class="enscript-comment">/* Reset sampling statistics */</span>
			PKTCNTR_CLEAR(&amp;inp-&gt;sstats);

			<span class="enscript-comment">/* Calculate EWMA of wakeup requests */</span>
			DLIL_EWMA(inp-&gt;rxpoll_wavg, inp-&gt;wtot, if_rxpoll_decay);
			inp-&gt;wtot = 0;

			<span class="enscript-keyword">if</span> (dlil_verbose) {
				<span class="enscript-keyword">if</span> (!net_timerisset(&amp;inp-&gt;dbg_lasttime))
					*(&amp;inp-&gt;dbg_lasttime) = *(&amp;now);
				net_timersub(&amp;now, &amp;inp-&gt;dbg_lasttime, &amp;delta);
				<span class="enscript-keyword">if</span> (net_timercmp(&amp;delta, &amp;dlil_dbgrate, &gt;=)) {
					*(&amp;inp-&gt;dbg_lasttime) = *(&amp;now);
					printf(<span class="enscript-string">&quot;%s: [%s] pkts avg %d max %d &quot;</span>
					    <span class="enscript-string">&quot;limits [%d/%d], wreq avg %d &quot;</span>
					    <span class="enscript-string">&quot;limits [%d/%d], bytes avg %d &quot;</span>
					    <span class="enscript-string">&quot;limits [%d/%d]\n&quot;</span>, if_name(ifp),
					    (inp-&gt;mode ==
					    IFNET_MODEL_INPUT_POLL_ON) ?
					    <span class="enscript-string">&quot;ON&quot;</span> : <span class="enscript-string">&quot;OFF&quot;</span>, inp-&gt;rxpoll_pavg,
					    inp-&gt;rxpoll_pmax,
					    inp-&gt;rxpoll_plowat,
					    inp-&gt;rxpoll_phiwat,
					    inp-&gt;rxpoll_wavg,
					    inp-&gt;rxpoll_wlowat,
					    inp-&gt;rxpoll_whiwat,
					    inp-&gt;rxpoll_bavg,
					    inp-&gt;rxpoll_blowat,
					    inp-&gt;rxpoll_bhiwat);
				}
			}

			<span class="enscript-comment">/* Perform mode transition, if necessary */</span>
			<span class="enscript-keyword">if</span> (!net_timerisset(&amp;inp-&gt;mode_lasttime))
				*(&amp;inp-&gt;mode_lasttime) = *(&amp;now);

			net_timersub(&amp;now, &amp;inp-&gt;mode_lasttime, &amp;delta);
			<span class="enscript-keyword">if</span> (net_timercmp(&amp;delta, &amp;inp-&gt;mode_holdtime, &lt;))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip</span>;

			<span class="enscript-keyword">if</span> (inp-&gt;rxpoll_pavg &lt;= inp-&gt;rxpoll_plowat &amp;&amp;
			    inp-&gt;rxpoll_bavg &lt;= inp-&gt;rxpoll_blowat &amp;&amp;
			    inp-&gt;mode != IFNET_MODEL_INPUT_POLL_OFF) {
				mode = IFNET_MODEL_INPUT_POLL_OFF;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;rxpoll_pavg &gt;= inp-&gt;rxpoll_phiwat &amp;&amp;
			    (inp-&gt;rxpoll_bavg &gt;= inp-&gt;rxpoll_bhiwat ||
			    inp-&gt;rxpoll_wavg &gt;= inp-&gt;rxpoll_whiwat) &amp;&amp;
			    inp-&gt;mode != IFNET_MODEL_INPUT_POLL_ON) {
				mode = IFNET_MODEL_INPUT_POLL_ON;
			}

			<span class="enscript-keyword">if</span> (mode != inp-&gt;mode) {
				inp-&gt;mode = mode;
				*(&amp;inp-&gt;mode_lasttime) = *(&amp;now);
				poll_req++;
			}
		}
<span class="enscript-reference">skip</span>:
		dlil_input_stats_sync(ifp, inp);

		lck_mtx_unlock(&amp;inp-&gt;input_lck);

		<span class="enscript-comment">/*
		 * If there's a mode change and interface is still attached,
		 * perform a downcall to the driver for the new mode.  Also
		 * hold an IO refcnt on the interface to prevent it from
		 * being detached (will be release below.)
		 */</span>
		<span class="enscript-keyword">if</span> (poll_req != 0 &amp;&amp; ifnet_is_attached(ifp, 1)) {
			<span class="enscript-type">struct</span> ifnet_model_params p = { mode, { 0 } };
			errno_t err;

			<span class="enscript-keyword">if</span> (dlil_verbose) {
				printf(<span class="enscript-string">&quot;%s: polling is now %s, &quot;</span>
				    <span class="enscript-string">&quot;pkts avg %d max %d limits [%d/%d], &quot;</span>
				    <span class="enscript-string">&quot;wreq avg %d limits [%d/%d], &quot;</span>
				    <span class="enscript-string">&quot;bytes avg %d limits [%d/%d]\n&quot;</span>,
				    if_name(ifp),
				    (mode == IFNET_MODEL_INPUT_POLL_ON) ?
				    <span class="enscript-string">&quot;ON&quot;</span> : <span class="enscript-string">&quot;OFF&quot;</span>, inp-&gt;rxpoll_pavg,
				    inp-&gt;rxpoll_pmax, inp-&gt;rxpoll_plowat,
				    inp-&gt;rxpoll_phiwat, inp-&gt;rxpoll_wavg,
				    inp-&gt;rxpoll_wlowat, inp-&gt;rxpoll_whiwat,
				    inp-&gt;rxpoll_bavg, inp-&gt;rxpoll_blowat,
				    inp-&gt;rxpoll_bhiwat);
			}

			<span class="enscript-keyword">if</span> ((err = ((*ifp-&gt;if_input_ctl)(ifp,
			    IFNET_CTL_SET_INPUT_MODEL, <span class="enscript-keyword">sizeof</span> (p), &amp;p))) != 0) {
				printf(<span class="enscript-string">&quot;%s: error setting polling mode &quot;</span>
				    <span class="enscript-string">&quot;to %s (%d)\n&quot;</span>, if_name(ifp),
				    (mode == IFNET_MODEL_INPUT_POLL_ON) ?
				    <span class="enscript-string">&quot;ON&quot;</span> : <span class="enscript-string">&quot;OFF&quot;</span>, err);
			}

			<span class="enscript-keyword">switch</span> (mode) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IFNET_MODEL_INPUT_POLL_OFF</span>:
				ifnet_set_poll_cycle(ifp, NULL);
				inp-&gt;rxpoll_offreq++;
				<span class="enscript-keyword">if</span> (err != 0)
					inp-&gt;rxpoll_offerr++;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IFNET_MODEL_INPUT_POLL_ON</span>:
				net_nsectimer(&amp;ival, &amp;ts);
				ifnet_set_poll_cycle(ifp, &amp;ts);
				ifnet_poll(ifp);
				inp-&gt;rxpoll_onreq++;
				<span class="enscript-keyword">if</span> (err != 0)
					inp-&gt;rxpoll_onerr++;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-reference">default</span>:
				VERIFY(0);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}

			<span class="enscript-comment">/* Release the IO refcnt */</span>
			ifnet_decr_iorefcnt(ifp);
		}

		<span class="enscript-comment">/*
		* NOTE warning %%% attention !!!!
		* We should think about putting some thread starvation
		* safeguards if we deal with long chains of packets.
		*/</span>
		<span class="enscript-keyword">if</span> (m != NULL)
			dlil_input_packet_list_extended(NULL, m, m_cnt, mode);
	}

	<span class="enscript-comment">/* NOTREACHED */</span>
	VERIFY(0);	<span class="enscript-comment">/* we should never get here */</span>
}

<span class="enscript-comment">/*
 * Must be called on an attached ifnet (caller is expected to check.)
 * Caller may pass NULL for poll parameters to indicate &quot;auto-tuning.&quot;
 */</span>
errno_t
<span class="enscript-function-name">dlil_rxpoll_set_params</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifnet_poll_params *p,
    boolean_t locked)
{
	<span class="enscript-type">struct</span> dlil_threading_info *inp;
	u_int64_t sample_holdtime, inbw;

	VERIFY(ifp != NULL);
	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_RXPOLL) || (inp = ifp-&gt;if_inp) == NULL)
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (p != NULL) {
		<span class="enscript-keyword">if</span> ((p-&gt;packets_lowat == 0 &amp;&amp; p-&gt;packets_hiwat != 0) ||
		    (p-&gt;packets_lowat != 0 &amp;&amp; p-&gt;packets_hiwat == 0))
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> (p-&gt;packets_lowat != 0 &amp;&amp;	<span class="enscript-comment">/* hiwat must be non-zero */</span>
		    p-&gt;packets_lowat &gt;= p-&gt;packets_hiwat)
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> ((p-&gt;bytes_lowat == 0 &amp;&amp; p-&gt;bytes_hiwat != 0) ||
		    (p-&gt;bytes_lowat != 0 &amp;&amp; p-&gt;bytes_hiwat == 0))
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> (p-&gt;bytes_lowat != 0 &amp;&amp;	<span class="enscript-comment">/* hiwat must be non-zero */</span>
		    p-&gt;bytes_lowat &gt;= p-&gt;bytes_hiwat)
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> (p-&gt;interval_time != 0 &amp;&amp;
		    p-&gt;interval_time &lt; IF_RXPOLL_INTERVALTIME_MIN)
			p-&gt;interval_time = IF_RXPOLL_INTERVALTIME_MIN;
	}

	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_lock(&amp;inp-&gt;input_lck);

	lck_mtx_assert(&amp;inp-&gt;input_lck, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/*
	 * Normally, we'd reset the parameters to the auto-tuned values
	 * if the the input thread detects a change in link rate.  If the
	 * driver provides its own parameters right after a link rate
	 * changes, but before the input thread gets to run, we want to
	 * make sure to keep the driver's values.  Clearing if_poll_update
	 * will achieve that.
	 */</span>
	<span class="enscript-keyword">if</span> (p != NULL &amp;&amp; !locked &amp;&amp; ifp-&gt;if_poll_update != 0)
		ifp-&gt;if_poll_update = 0;

	<span class="enscript-keyword">if</span> ((inbw = ifnet_input_linkrate(ifp)) == 0 &amp;&amp; p == NULL) {
		sample_holdtime = 0;	<span class="enscript-comment">/* polling is disabled */</span>
		inp-&gt;rxpoll_wlowat = inp-&gt;rxpoll_plowat =
		    inp-&gt;rxpoll_blowat = 0;
		inp-&gt;rxpoll_whiwat = inp-&gt;rxpoll_phiwat =
		    inp-&gt;rxpoll_bhiwat = (u_int32_t)-1;
		inp-&gt;rxpoll_plim = 0;
		inp-&gt;rxpoll_ival = IF_RXPOLL_INTERVALTIME_MIN;
	} <span class="enscript-keyword">else</span> {
		u_int32_t plowat, phiwat, blowat, bhiwat, plim;
		u_int64_t ival;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> n, i;

		<span class="enscript-keyword">for</span> (n = 0, i = 0; rxpoll_tbl[i].speed != 0; i++) {
			<span class="enscript-keyword">if</span> (inbw &lt; rxpoll_tbl[i].speed)
				<span class="enscript-keyword">break</span>;
			n = i;
		}
		<span class="enscript-comment">/* auto-tune if caller didn't specify a value */</span>
		plowat = ((p == NULL || p-&gt;packets_lowat == 0) ?
		    rxpoll_tbl[n].plowat : p-&gt;packets_lowat);
		phiwat = ((p == NULL || p-&gt;packets_hiwat == 0) ?
		    rxpoll_tbl[n].phiwat : p-&gt;packets_hiwat);
		blowat = ((p == NULL || p-&gt;bytes_lowat == 0) ?
		    rxpoll_tbl[n].blowat : p-&gt;bytes_lowat);
		bhiwat = ((p == NULL || p-&gt;bytes_hiwat == 0) ?
		    rxpoll_tbl[n].bhiwat : p-&gt;bytes_hiwat);
		plim = ((p == NULL || p-&gt;packets_limit == 0) ?
		    if_rxpoll_max : p-&gt;packets_limit);
		ival = ((p == NULL || p-&gt;interval_time == 0) ?
		    if_rxpoll_interval_time : p-&gt;interval_time);

		VERIFY(plowat != 0 &amp;&amp; phiwat != 0);
		VERIFY(blowat != 0 &amp;&amp; bhiwat != 0);
		VERIFY(ival &gt;= IF_RXPOLL_INTERVALTIME_MIN);

		sample_holdtime = if_rxpoll_sample_holdtime;
		inp-&gt;rxpoll_wlowat = if_rxpoll_wlowat;
		inp-&gt;rxpoll_whiwat = if_rxpoll_whiwat;
		inp-&gt;rxpoll_plowat = plowat;
		inp-&gt;rxpoll_phiwat = phiwat;
		inp-&gt;rxpoll_blowat = blowat;
		inp-&gt;rxpoll_bhiwat = bhiwat;
		inp-&gt;rxpoll_plim = plim;
		inp-&gt;rxpoll_ival = ival;
	}

	net_nsectimer(&amp;if_rxpoll_mode_holdtime, &amp;inp-&gt;mode_holdtime);
	net_nsectimer(&amp;sample_holdtime, &amp;inp-&gt;sample_holdtime);

	<span class="enscript-keyword">if</span> (dlil_verbose) {
		printf(<span class="enscript-string">&quot;%s: speed %llu bps, sample per %llu nsec, &quot;</span>
		    <span class="enscript-string">&quot;poll interval %llu nsec, pkts per poll %u, &quot;</span>
		    <span class="enscript-string">&quot;pkt limits [%u/%u], wreq limits [%u/%u], &quot;</span>
		    <span class="enscript-string">&quot;bytes limits [%u/%u]\n&quot;</span>, if_name(ifp),
		    inbw, sample_holdtime, inp-&gt;rxpoll_ival, inp-&gt;rxpoll_plim,
		    inp-&gt;rxpoll_plowat, inp-&gt;rxpoll_phiwat, inp-&gt;rxpoll_wlowat,
		    inp-&gt;rxpoll_whiwat, inp-&gt;rxpoll_blowat, inp-&gt;rxpoll_bhiwat);
	}

	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_unlock(&amp;inp-&gt;input_lck);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Must be called on an attached ifnet (caller is expected to check.)
 */</span>
errno_t
<span class="enscript-function-name">dlil_rxpoll_get_params</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifnet_poll_params *p)
{
	<span class="enscript-type">struct</span> dlil_threading_info *inp;

	VERIFY(ifp != NULL &amp;&amp; p != NULL);
	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_RXPOLL) || (inp = ifp-&gt;if_inp) == NULL)
		<span class="enscript-keyword">return</span> (ENXIO);

	bzero(p, <span class="enscript-keyword">sizeof</span> (*p));

	lck_mtx_lock(&amp;inp-&gt;input_lck);
	p-&gt;packets_limit = inp-&gt;rxpoll_plim;
	p-&gt;packets_lowat = inp-&gt;rxpoll_plowat;
	p-&gt;packets_hiwat = inp-&gt;rxpoll_phiwat;
	p-&gt;bytes_lowat = inp-&gt;rxpoll_blowat;
	p-&gt;bytes_hiwat = inp-&gt;rxpoll_bhiwat;
	p-&gt;interval_time = inp-&gt;rxpoll_ival;
	lck_mtx_unlock(&amp;inp-&gt;input_lck);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_input</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m_head,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_stat_increment_param *s)
{
	<span class="enscript-keyword">return</span> (ifnet_input_common(ifp, m_head, NULL, s, FALSE, FALSE));
}

errno_t
<span class="enscript-function-name">ifnet_input_extended</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m_head,
    <span class="enscript-type">struct</span> mbuf *m_tail, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_stat_increment_param *s)
{
	<span class="enscript-keyword">return</span> (ifnet_input_common(ifp, m_head, m_tail, s, TRUE, FALSE));
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifnet_input_common</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m_head, <span class="enscript-type">struct</span> mbuf *m_tail,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_stat_increment_param *s, boolean_t ext, boolean_t poll)
{
	<span class="enscript-type">struct</span> thread *tp = current_thread();
	<span class="enscript-type">struct</span> mbuf *last;
	<span class="enscript-type">struct</span> dlil_threading_info *inp;
	u_int32_t m_cnt = 0, m_size = 0;

	<span class="enscript-keyword">if</span> ((m_head == NULL &amp;&amp; !poll) || (s == NULL &amp;&amp; ext)) {
		<span class="enscript-keyword">if</span> (m_head != NULL)
			mbuf_freem_list(m_head);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	VERIFY(m_head != NULL || (s == NULL &amp;&amp; m_tail == NULL &amp;&amp; !ext &amp;&amp; poll));
	VERIFY(m_tail == NULL || ext);
	VERIFY(s != NULL || !ext);

	<span class="enscript-comment">/*
	 * Drop the packet(s) if the parameters are invalid, or if the
	 * interface is no longer attached; else hold an IO refcnt to
	 * prevent it from being detached (will be released below.)
	 */</span>
	<span class="enscript-keyword">if</span> (ifp == NULL || (ifp != lo_ifp &amp;&amp; !ifnet_is_attached(ifp, 1))) {
		<span class="enscript-keyword">if</span> (m_head != NULL)
			mbuf_freem_list(m_head);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (m_tail == NULL) {
		last = m_head;
		<span class="enscript-keyword">while</span> (m_head != NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IFNET_INPUT_SANITY_CHK</span>
			<span class="enscript-keyword">if</span> (dlil_input_sanity_check != 0)
				DLIL_INPUT_CHECK(last, ifp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IFNET_INPUT_SANITY_CHK */</span>
			m_cnt++;
			m_size += m_length(last);
			<span class="enscript-keyword">if</span> (mbuf_nextpkt(last) == NULL)
				<span class="enscript-keyword">break</span>;
			last = mbuf_nextpkt(last);
		}
		m_tail = last;
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IFNET_INPUT_SANITY_CHK</span>
		<span class="enscript-keyword">if</span> (dlil_input_sanity_check != 0) {
			last = m_head;
			<span class="enscript-keyword">while</span> (1) {
				DLIL_INPUT_CHECK(last, ifp);
				m_cnt++;
				m_size += m_length(last);
				<span class="enscript-keyword">if</span> (mbuf_nextpkt(last) == NULL)
					<span class="enscript-keyword">break</span>;
				last = mbuf_nextpkt(last);
			}
		} <span class="enscript-keyword">else</span> {
			m_cnt = s-&gt;packets_in;
			m_size = s-&gt;bytes_in;
			last = m_tail;
		}
#<span class="enscript-reference">else</span>
		m_cnt = s-&gt;packets_in;
		m_size = s-&gt;bytes_in;
		last = m_tail;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IFNET_INPUT_SANITY_CHK */</span>
	}

	<span class="enscript-keyword">if</span> (last != m_tail) {
		panic_plain(<span class="enscript-string">&quot;%s: invalid input packet chain for %s, &quot;</span>
		    <span class="enscript-string">&quot;tail mbuf %p instead of %p\n&quot;</span>, __func__, if_name(ifp),
		    m_tail, last);
	}

	<span class="enscript-comment">/*
	 * Assert packet count only for the extended variant, for backwards
	 * compatibility, since this came directly from the device driver.
	 * Relax this assertion for input bytes, as the driver may have
	 * included the link-layer headers in the computation; hence
	 * m_size is just an approximation.
	 */</span>
	<span class="enscript-keyword">if</span> (ext &amp;&amp; s-&gt;packets_in != m_cnt) {
		panic_plain(<span class="enscript-string">&quot;%s: input packet count mismatch for %s, &quot;</span>
		    <span class="enscript-string">&quot;%d instead of %d\n&quot;</span>, __func__, if_name(ifp),
		    s-&gt;packets_in, m_cnt);
	}

	<span class="enscript-keyword">if</span> ((inp = ifp-&gt;if_inp) == NULL)
		inp = dlil_main_input_thread;

	<span class="enscript-comment">/*
	 * If there is a matching DLIL input thread associated with an
	 * affinity set, associate this thread with the same set.  We
	 * will only do this once.
	 */</span>
	lck_mtx_lock_spin(&amp;inp-&gt;input_lck);
	<span class="enscript-keyword">if</span> (inp != dlil_main_input_thread &amp;&amp; inp-&gt;net_affinity &amp;&amp;
	    ((!poll &amp;&amp; inp-&gt;wloop_thr == THREAD_NULL) ||
	    (poll &amp;&amp; inp-&gt;poll_thr == THREAD_NULL))) {
		u_int32_t tag = inp-&gt;tag;

		<span class="enscript-keyword">if</span> (poll) {
			VERIFY(inp-&gt;poll_thr == THREAD_NULL);
			inp-&gt;poll_thr = tp;
		} <span class="enscript-keyword">else</span> {
			VERIFY(inp-&gt;wloop_thr == THREAD_NULL);
			inp-&gt;wloop_thr = tp;
		}
		lck_mtx_unlock(&amp;inp-&gt;input_lck);

		<span class="enscript-comment">/* Associate the current thread with the new affinity tag */</span>
		(<span class="enscript-type">void</span>) dlil_affinity_set(tp, tag);

		<span class="enscript-comment">/*
		 * Take a reference on the current thread; during detach,
		 * we will need to refer to it in order ot tear down its
		 * affinity.
		 */</span>
		thread_reference(tp);
		lck_mtx_lock_spin(&amp;inp-&gt;input_lck);
	}

	VERIFY(m_head != NULL || (m_tail == NULL &amp;&amp; m_cnt == 0));

        <span class="enscript-comment">/*
	 * Because of loopbacked multicast we cannot stuff the ifp in
	 * the rcvif of the packet header: loopback (lo0) packets use a
	 * dedicated list so that we can later associate them with lo_ifp
	 * on their way up the stack.  Packets for other interfaces without
	 * dedicated input threads go to the regular list.
	 */</span>
	<span class="enscript-keyword">if</span> (m_head != NULL) {
		<span class="enscript-keyword">if</span> (inp == dlil_main_input_thread &amp;&amp; ifp == lo_ifp) {
			<span class="enscript-type">struct</span> dlil_main_threading_info *inpm =
			    (<span class="enscript-type">struct</span> dlil_main_threading_info *)inp;
			_addq_multi(&amp;inpm-&gt;lo_rcvq_pkts, m_head, m_tail,
			    m_cnt, m_size);
		} <span class="enscript-keyword">else</span> {
			_addq_multi(&amp;inp-&gt;rcvq_pkts, m_head, m_tail,
			    m_cnt, m_size);
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IFNET_INPUT_SANITY_CHK</span>
	<span class="enscript-keyword">if</span> (dlil_input_sanity_check != 0) {
		u_int32_t count;
		<span class="enscript-type">struct</span> mbuf *m0;

		<span class="enscript-keyword">for</span> (m0 = m_head, count = 0; m0; m0 = mbuf_nextpkt(m0))
			count++;

		<span class="enscript-keyword">if</span> (count != m_cnt) {
			panic_plain(<span class="enscript-string">&quot;%s: invalid packet count %d &quot;</span>
			    <span class="enscript-string">&quot;(expected %d)\n&quot;</span>, if_name(ifp),
			    count, m_cnt);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}

		inp-&gt;input_mbuf_cnt += m_cnt;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IFNET_INPUT_SANITY_CHK */</span>

	<span class="enscript-keyword">if</span> (s != NULL) {
		dlil_input_stats_add(s, inp, poll);
		<span class="enscript-comment">/*
		 * If we're using the main input thread, synchronize the
		 * stats now since we have the interface context.  All
		 * other cases involving dedicated input threads will
		 * have their stats synchronized there.
		 */</span>
		<span class="enscript-keyword">if</span> (inp == dlil_main_input_thread)
			dlil_input_stats_sync(ifp, inp);
	}

	inp-&gt;input_waiting |= DLIL_INPUT_WAITING;
	<span class="enscript-keyword">if</span> (!(inp-&gt;input_waiting &amp; DLIL_INPUT_RUNNING)) {
		inp-&gt;wtot++;
		wakeup_one((caddr_t)&amp;inp-&gt;input_waiting);
	}
	lck_mtx_unlock(&amp;inp-&gt;input_lck);

	<span class="enscript-keyword">if</span> (ifp != lo_ifp) {
		<span class="enscript-comment">/* Release the IO refcnt */</span>
		ifnet_decr_iorefcnt(ifp);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_start_common</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> resetfc)
{
	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART))
		<span class="enscript-keyword">return</span>;
	<span class="enscript-comment">/*
	 * If the starter thread is inactive, signal it to do work,
	 * unless the interface is being flow controlled from below,
	 * e.g. a virtual interface being flow controlled by a real
	 * network interface beneath it.
	 */</span>
	lck_mtx_lock_spin(&amp;ifp-&gt;if_start_lock);
	<span class="enscript-keyword">if</span> (resetfc) {
		ifp-&gt;if_start_flags &amp;= ~IFSF_FLOW_CONTROLLED;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_start_flags &amp; IFSF_FLOW_CONTROLLED) {
		lck_mtx_unlock(&amp;ifp-&gt;if_start_lock);
		<span class="enscript-keyword">return</span>;
	}
	ifp-&gt;if_start_req++;
	<span class="enscript-keyword">if</span> (!ifp-&gt;if_start_active &amp;&amp; ifp-&gt;if_start_thread != THREAD_NULL &amp;&amp;
	    (resetfc || !(ifp-&gt;if_eflags &amp; IFEF_ENQUEUE_MULTI) ||
	    IFCQ_LEN(&amp;ifp-&gt;if_snd) &gt;= ifp-&gt;if_start_delay_qlen
	    || ifp-&gt;if_start_delayed == 0)) {
		wakeup_one((caddr_t)&amp;ifp-&gt;if_start_thread);
	}
	lck_mtx_unlock(&amp;ifp-&gt;if_start_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_start</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	ifnet_start_common(ifp, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_start_thread_fn</span>(<span class="enscript-type">void</span> *v, wait_result_t w)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">w</span>)
	<span class="enscript-type">struct</span> ifnet *ifp = v;
	<span class="enscript-type">char</span> ifname[IFNAMSIZ + 1];
	<span class="enscript-type">struct</span> timespec *ts = NULL;
	<span class="enscript-type">struct</span> ifclassq *ifq = &amp;ifp-&gt;if_snd;
	<span class="enscript-type">struct</span> timespec delay_start_ts;

	<span class="enscript-comment">/*
	 * Treat the dedicated starter thread for lo0 as equivalent to
	 * the driver workloop thread; if net_affinity is enabled for
	 * the main input thread, associate this starter thread to it
	 * by binding them with the same affinity tag.  This is done
	 * only once (as we only have one lo_ifp which never goes away.)
	 */</span>
	<span class="enscript-keyword">if</span> (ifp == lo_ifp) {
		<span class="enscript-type">struct</span> dlil_threading_info *inp = dlil_main_input_thread;
		<span class="enscript-type">struct</span> thread *tp = current_thread();

		lck_mtx_lock(&amp;inp-&gt;input_lck);
		<span class="enscript-keyword">if</span> (inp-&gt;net_affinity) {
			u_int32_t tag = inp-&gt;tag;

			VERIFY(inp-&gt;wloop_thr == THREAD_NULL);
			VERIFY(inp-&gt;poll_thr == THREAD_NULL);
			inp-&gt;wloop_thr = tp;
			lck_mtx_unlock(&amp;inp-&gt;input_lck);

			<span class="enscript-comment">/* Associate this thread with the affinity tag */</span>
			(<span class="enscript-type">void</span>) dlil_affinity_set(tp, tag);
		} <span class="enscript-keyword">else</span> {
			lck_mtx_unlock(&amp;inp-&gt;input_lck);
		}
	}

	snprintf(ifname, <span class="enscript-keyword">sizeof</span> (ifname), <span class="enscript-string">&quot;%s_starter&quot;</span>,
	    if_name(ifp));

	lck_mtx_lock_spin(&amp;ifp-&gt;if_start_lock);

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (ifp-&gt;if_start_thread != NULL)
			(<span class="enscript-type">void</span>) msleep(&amp;ifp-&gt;if_start_thread, &amp;ifp-&gt;if_start_lock,
			    (PZERO - 1) | PSPIN, ifname, ts);

		<span class="enscript-comment">/* interface is detached? */</span>
		<span class="enscript-keyword">if</span> (ifp-&gt;if_start_thread == THREAD_NULL) {
			ifnet_set_start_cycle(ifp, NULL);
			lck_mtx_unlock(&amp;ifp-&gt;if_start_lock);
			ifnet_purge(ifp);

			<span class="enscript-keyword">if</span> (dlil_verbose) {
				printf(<span class="enscript-string">&quot;%s: starter thread terminated\n&quot;</span>,
				    if_name(ifp));
			}

			<span class="enscript-comment">/* for the extra refcnt from kernel_thread_start() */</span>
			thread_deallocate(current_thread());
			<span class="enscript-comment">/* this is the end */</span>
			thread_terminate(current_thread());
			<span class="enscript-comment">/* NOTREACHED */</span>
			<span class="enscript-keyword">return</span>;
		}

		ifp-&gt;if_start_active = 1;

		<span class="enscript-keyword">for</span> (;;) {
			u_int32_t req = ifp-&gt;if_start_req;
			<span class="enscript-keyword">if</span> (!IFCQ_IS_EMPTY(ifq) &amp;&amp;
			    (ifp-&gt;if_eflags &amp; IFEF_ENQUEUE_MULTI) &amp;&amp;
			    ifp-&gt;if_start_delayed == 0 &amp;&amp;
			    IFCQ_LEN(ifq) &lt; ifp-&gt;if_start_delay_qlen &amp;&amp;
			    (ifp-&gt;if_eflags &amp; IFEF_DELAY_START)) {
				ifp-&gt;if_start_delayed = 1;
				ifnet_start_delayed++;
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> {
				ifp-&gt;if_start_delayed = 0;
			}
			lck_mtx_unlock(&amp;ifp-&gt;if_start_lock);

			<span class="enscript-comment">/*
			 * If no longer attached, don't call start because ifp
			 * is being destroyed; else hold an IO refcnt to
			 * prevent the interface from being detached (will be
			 * released below.)
			 */</span>
			<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1)) {
				lck_mtx_lock_spin(&amp;ifp-&gt;if_start_lock);
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/* invoke the driver's start routine */</span>
			((*ifp-&gt;if_start)(ifp));

			<span class="enscript-comment">/*
			 * Release the io ref count taken by ifnet_is_attached.
			 */</span>
			ifnet_decr_iorefcnt(ifp);

			lck_mtx_lock_spin(&amp;ifp-&gt;if_start_lock);

			<span class="enscript-comment">/* if there's no pending request, we're done */</span>
			<span class="enscript-keyword">if</span> (req == ifp-&gt;if_start_req)
				<span class="enscript-keyword">break</span>;
		}

		ifp-&gt;if_start_req = 0;
		ifp-&gt;if_start_active = 0;

		<span class="enscript-comment">/*
		 * Wakeup N ns from now if rate-controlled by TBR, and if
		 * there are still packets in the send queue which haven't
		 * been dequeued so far; else sleep indefinitely (ts = NULL)
		 * until ifnet_start() is called again.
		 */</span>
		ts = ((IFCQ_TBR_IS_ENABLED(ifq) &amp;&amp; !IFCQ_IS_EMPTY(ifq)) ?
		    &amp;ifp-&gt;if_start_cycle : NULL);

		<span class="enscript-keyword">if</span> (ts == NULL &amp;&amp; ifp-&gt;if_start_delayed == 1) {
			delay_start_ts.tv_sec = 0;
			delay_start_ts.tv_nsec = ifp-&gt;if_start_delay_timeout;
			ts = &amp;delay_start_ts;
		}

		<span class="enscript-keyword">if</span> (ts != NULL &amp;&amp; ts-&gt;tv_sec == 0 &amp;&amp; ts-&gt;tv_nsec == 0)
			ts = NULL;
	}

	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_set_start_cycle</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> timespec *ts)
{
	<span class="enscript-keyword">if</span> (ts == NULL)
		bzero(&amp;ifp-&gt;if_start_cycle, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_start_cycle));
	<span class="enscript-keyword">else</span>
		*(&amp;ifp-&gt;if_start_cycle) = *ts;

	<span class="enscript-keyword">if</span> (ts != NULL &amp;&amp; ts-&gt;tv_nsec != 0 &amp;&amp; dlil_verbose)
		printf(<span class="enscript-string">&quot;%s: restart interval set to %lu nsec\n&quot;</span>,
		    if_name(ifp), ts-&gt;tv_nsec);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_poll</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-comment">/*
	 * If the poller thread is inactive, signal it to do work.
	 */</span>
	lck_mtx_lock_spin(&amp;ifp-&gt;if_poll_lock);
	ifp-&gt;if_poll_req++;
	<span class="enscript-keyword">if</span> (!ifp-&gt;if_poll_active &amp;&amp; ifp-&gt;if_poll_thread != THREAD_NULL) {
		wakeup_one((caddr_t)&amp;ifp-&gt;if_poll_thread);
	}
	lck_mtx_unlock(&amp;ifp-&gt;if_poll_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_poll_thread_fn</span>(<span class="enscript-type">void</span> *v, wait_result_t w)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">w</span>)
	<span class="enscript-type">struct</span> dlil_threading_info *inp;
	<span class="enscript-type">struct</span> ifnet *ifp = v;
	<span class="enscript-type">char</span> ifname[IFNAMSIZ + 1];
	<span class="enscript-type">struct</span> timespec *ts = NULL;
	<span class="enscript-type">struct</span> ifnet_stat_increment_param s;

	snprintf(ifname, <span class="enscript-keyword">sizeof</span> (ifname), <span class="enscript-string">&quot;%s_poller&quot;</span>,
	    if_name(ifp));
	bzero(&amp;s, <span class="enscript-keyword">sizeof</span> (s));

	lck_mtx_lock_spin(&amp;ifp-&gt;if_poll_lock);

	inp = ifp-&gt;if_inp;
	VERIFY(inp != NULL);

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (ifp-&gt;if_poll_thread != THREAD_NULL) {
			(<span class="enscript-type">void</span>) msleep(&amp;ifp-&gt;if_poll_thread, &amp;ifp-&gt;if_poll_lock,
			    (PZERO - 1) | PSPIN, ifname, ts);
		}

		<span class="enscript-comment">/* interface is detached (maybe while asleep)? */</span>
		<span class="enscript-keyword">if</span> (ifp-&gt;if_poll_thread == THREAD_NULL) {
			ifnet_set_poll_cycle(ifp, NULL);
			lck_mtx_unlock(&amp;ifp-&gt;if_poll_lock);

			<span class="enscript-keyword">if</span> (dlil_verbose) {
				printf(<span class="enscript-string">&quot;%s: poller thread terminated\n&quot;</span>,
				    if_name(ifp));
			}

			<span class="enscript-comment">/* for the extra refcnt from kernel_thread_start() */</span>
			thread_deallocate(current_thread());
			<span class="enscript-comment">/* this is the end */</span>
			thread_terminate(current_thread());
			<span class="enscript-comment">/* NOTREACHED */</span>
			<span class="enscript-keyword">return</span>;
		}

		ifp-&gt;if_poll_active = 1;
		<span class="enscript-keyword">for</span> (;;) {
			<span class="enscript-type">struct</span> mbuf *m_head, *m_tail;
			u_int32_t m_lim, m_cnt, m_totlen;
			u_int16_t req = ifp-&gt;if_poll_req;

			lck_mtx_unlock(&amp;ifp-&gt;if_poll_lock);

			<span class="enscript-comment">/*
			 * If no longer attached, there's nothing to do;
			 * else hold an IO refcnt to prevent the interface
			 * from being detached (will be released below.)
			 */</span>
			<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1)) {
				lck_mtx_lock_spin(&amp;ifp-&gt;if_poll_lock);
				<span class="enscript-keyword">break</span>;
			}

			m_lim = (inp-&gt;rxpoll_plim != 0) ? inp-&gt;rxpoll_plim :
			    MAX((qlimit(&amp;inp-&gt;rcvq_pkts)),
			    (inp-&gt;rxpoll_phiwat &lt;&lt; 2));

			<span class="enscript-keyword">if</span> (dlil_verbose &gt; 1) {
				printf(<span class="enscript-string">&quot;%s: polling up to %d pkts, &quot;</span>
				    <span class="enscript-string">&quot;pkts avg %d max %d, wreq avg %d, &quot;</span>
				    <span class="enscript-string">&quot;bytes avg %d\n&quot;</span>,
				    if_name(ifp), m_lim,
				    inp-&gt;rxpoll_pavg, inp-&gt;rxpoll_pmax,
				    inp-&gt;rxpoll_wavg, inp-&gt;rxpoll_bavg);
			}

			<span class="enscript-comment">/* invoke the driver's input poll routine */</span>
			((*ifp-&gt;if_input_poll)(ifp, 0, m_lim, &amp;m_head, &amp;m_tail,
			    &amp;m_cnt, &amp;m_totlen));

			<span class="enscript-keyword">if</span> (m_head != NULL) {
				VERIFY(m_tail != NULL &amp;&amp; m_cnt &gt; 0);

				<span class="enscript-keyword">if</span> (dlil_verbose &gt; 1) {
					printf(<span class="enscript-string">&quot;%s: polled %d pkts, &quot;</span>
					    <span class="enscript-string">&quot;pkts avg %d max %d, wreq avg %d, &quot;</span>
					    <span class="enscript-string">&quot;bytes avg %d\n&quot;</span>,
					    if_name(ifp), m_cnt,
					    inp-&gt;rxpoll_pavg, inp-&gt;rxpoll_pmax,
					    inp-&gt;rxpoll_wavg, inp-&gt;rxpoll_bavg);
				}

				<span class="enscript-comment">/* stats are required for extended variant */</span>
				s.packets_in = m_cnt;
				s.bytes_in = m_totlen;

				(<span class="enscript-type">void</span>) ifnet_input_common(ifp, m_head, m_tail,
				    &amp;s, TRUE, TRUE);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (dlil_verbose &gt; 1) {
					printf(<span class="enscript-string">&quot;%s: no packets, &quot;</span>
					    <span class="enscript-string">&quot;pkts avg %d max %d, wreq avg %d, &quot;</span>
					    <span class="enscript-string">&quot;bytes avg %d\n&quot;</span>,
					    if_name(ifp), inp-&gt;rxpoll_pavg,
					    inp-&gt;rxpoll_pmax, inp-&gt;rxpoll_wavg,
					    inp-&gt;rxpoll_bavg);
				}

				(<span class="enscript-type">void</span>) ifnet_input_common(ifp, NULL, NULL,
				    NULL, FALSE, TRUE);
			}

			<span class="enscript-comment">/* Release the io ref count */</span>
			ifnet_decr_iorefcnt(ifp);

			lck_mtx_lock_spin(&amp;ifp-&gt;if_poll_lock);

			<span class="enscript-comment">/* if there's no pending request, we're done */</span>
			<span class="enscript-keyword">if</span> (req == ifp-&gt;if_poll_req)
				<span class="enscript-keyword">break</span>;
		}
		ifp-&gt;if_poll_req = 0;
		ifp-&gt;if_poll_active = 0;

		<span class="enscript-comment">/*
		 * Wakeup N ns from now, else sleep indefinitely (ts = NULL)
		 * until ifnet_poll() is called again.
		 */</span>
		ts = &amp;ifp-&gt;if_poll_cycle;
		<span class="enscript-keyword">if</span> (ts-&gt;tv_sec == 0 &amp;&amp; ts-&gt;tv_nsec == 0)
			ts = NULL;
	}

	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_set_poll_cycle</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> timespec *ts)
{
	<span class="enscript-keyword">if</span> (ts == NULL)
		bzero(&amp;ifp-&gt;if_poll_cycle, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_poll_cycle));
	<span class="enscript-keyword">else</span>
		*(&amp;ifp-&gt;if_poll_cycle) = *ts;

	<span class="enscript-keyword">if</span> (ts != NULL &amp;&amp; ts-&gt;tv_nsec != 0 &amp;&amp; dlil_verbose)
		printf(<span class="enscript-string">&quot;%s: poll interval set to %lu nsec\n&quot;</span>,
		    if_name(ifp), ts-&gt;tv_nsec);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_purge</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-keyword">if</span> (ifp != NULL &amp;&amp; (ifp-&gt;if_eflags &amp; IFEF_TXSTART))
		if_qflush(ifp, 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_update_sndq</span>(<span class="enscript-type">struct</span> ifclassq *ifq, cqev_t ev)
{
	IFCQ_LOCK_ASSERT_HELD(ifq);

	<span class="enscript-keyword">if</span> (!(IFCQ_IS_READY(ifq)))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq)) {
		<span class="enscript-type">struct</span> tb_profile tb = { ifq-&gt;ifcq_tbr.tbr_rate_raw,
		    ifq-&gt;ifcq_tbr.tbr_percent, 0 };
		(<span class="enscript-type">void</span>) ifclassq_tbr_set(ifq, &amp;tb, FALSE);
	}

	ifclassq_update(ifq, ev);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_update_rcv</span>(<span class="enscript-type">struct</span> ifnet *ifp, cqev_t ev)
{
	<span class="enscript-keyword">switch</span> (ev) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">CLASSQ_EV_LINK_BANDWIDTH</span>:
		<span class="enscript-keyword">if</span> (net_rxpoll &amp;&amp; (ifp-&gt;if_eflags &amp; IFEF_RXPOLL))
			ifp-&gt;if_poll_update++;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
}

errno_t
<span class="enscript-function-name">ifnet_set_output_sched_model</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t model)
{
	<span class="enscript-type">struct</span> ifclassq *ifq;
	u_int32_t omodel;
	errno_t err;

	<span class="enscript-keyword">if</span> (ifp == NULL || (model != IFNET_SCHED_MODEL_DRIVER_MANAGED &amp;&amp;
	    model != IFNET_SCHED_MODEL_NORMAL))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART))
		<span class="enscript-keyword">return</span> (ENXIO);

	ifq = &amp;ifp-&gt;if_snd;
	IFCQ_LOCK(ifq);
	omodel = ifp-&gt;if_output_sched_model;
	ifp-&gt;if_output_sched_model = model;
	<span class="enscript-keyword">if</span> ((err = ifclassq_pktsched_setup(ifq)) != 0)
		ifp-&gt;if_output_sched_model = omodel;
	IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">return</span> (err);
}

errno_t
<span class="enscript-function-name">ifnet_set_sndq_maxlen</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t maxqlen)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART))
		<span class="enscript-keyword">return</span> (ENXIO);

	ifclassq_set_maxlen(&amp;ifp-&gt;if_snd, maxqlen);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_get_sndq_maxlen</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t *maxqlen)
{
	<span class="enscript-keyword">if</span> (ifp == NULL || maxqlen == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART))
		<span class="enscript-keyword">return</span> (ENXIO);

	*maxqlen = ifclassq_get_maxlen(&amp;ifp-&gt;if_snd);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_get_sndq_len</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t *pkts)
{
	errno_t err;

	<span class="enscript-keyword">if</span> (ifp == NULL || pkts == NULL)
		err = EINVAL;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART))
		err = ENXIO;
	<span class="enscript-keyword">else</span>
		err = ifclassq_get_len(&amp;ifp-&gt;if_snd, MBUF_SC_UNSPEC,
		    pkts, NULL);

	<span class="enscript-keyword">return</span> (err);
}

errno_t
<span class="enscript-function-name">ifnet_get_service_class_sndq_len</span>(<span class="enscript-type">struct</span> ifnet *ifp, mbuf_svc_class_t sc,
    u_int32_t *pkts, u_int32_t *bytes)
{
	errno_t err;

	<span class="enscript-keyword">if</span> (ifp == NULL || !MBUF_VALID_SC(sc) ||
	    (pkts == NULL &amp;&amp; bytes == NULL))
		err = EINVAL;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART))
		err = ENXIO;
	<span class="enscript-keyword">else</span>
		err = ifclassq_get_len(&amp;ifp-&gt;if_snd, sc, pkts, bytes);

	<span class="enscript-keyword">return</span> (err);
}

errno_t
<span class="enscript-function-name">ifnet_set_rcvq_maxlen</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t maxqlen)
{
	<span class="enscript-type">struct</span> dlil_threading_info *inp;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_RXPOLL) || ifp-&gt;if_inp == NULL)
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (maxqlen == 0)
		maxqlen = if_rcvq_maxlen;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (maxqlen &lt; IF_RCVQ_MINLEN)
		maxqlen = IF_RCVQ_MINLEN;

	inp = ifp-&gt;if_inp;
	lck_mtx_lock(&amp;inp-&gt;input_lck);
	qlimit(&amp;inp-&gt;rcvq_pkts) = maxqlen;
	lck_mtx_unlock(&amp;inp-&gt;input_lck);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_get_rcvq_maxlen</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t *maxqlen)
{
	<span class="enscript-type">struct</span> dlil_threading_info *inp;

	<span class="enscript-keyword">if</span> (ifp == NULL || maxqlen == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_RXPOLL) || ifp-&gt;if_inp == NULL)
		<span class="enscript-keyword">return</span> (ENXIO);

	inp = ifp-&gt;if_inp;
	lck_mtx_lock(&amp;inp-&gt;input_lck);
	*maxqlen = qlimit(&amp;inp-&gt;rcvq_pkts);
	lck_mtx_unlock(&amp;inp-&gt;input_lck);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_enqueue</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> timespec now;
	u_int64_t now_nsec;

	<span class="enscript-keyword">if</span> (ifp == NULL || m == NULL || !(m-&gt;m_flags &amp; M_PKTHDR) ||
	    m-&gt;m_nextpkt != NULL) {
		<span class="enscript-keyword">if</span> (m != NULL)
			m_freem_list(m);
		<span class="enscript-keyword">return</span> (EINVAL);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART) ||
	    !(ifp-&gt;if_refflags &amp; IFRF_ATTACHED)) {
		<span class="enscript-comment">/* flag tested without lock for performance */</span>
		m_freem(m);
		<span class="enscript-keyword">return</span> (ENXIO);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; IFF_UP)) {
		m_freem(m);
		<span class="enscript-keyword">return</span> (ENETDOWN);
	}

	nanouptime(&amp;now);
	net_timernsec(&amp;now, &amp;now_nsec);
	m-&gt;m_pkthdr.pkt_enqueue_ts = now_nsec;

	<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_ENQUEUE_MULTI) {
		<span class="enscript-comment">/*
		 * If the driver chose to delay start callback for
		 * coalescing multiple packets, Then use the following
		 * heuristics to make sure that start callback will
		 * be delayed only when bulk data transfer is detected.
		 * 1. number of packets enqueued in (delay_win * 2) is
		 * greater than or equal to the delay qlen.
		 * 2. If delay_start is enabled it will stay enabled for
		 * another 10 idle windows. This is to take into account
		 * variable RTT and burst traffic.
		 * 3. If the time elapsed since last enqueue is more
		 * than 200ms we disable delaying start callback. This is
		 * is to take idle time into account.
		 */</span> 
		u_int64_t dwin = (ifp-&gt;if_start_delay_timeout &lt;&lt; 1);
		<span class="enscript-keyword">if</span> (ifp-&gt;if_start_delay_swin &gt; 0) {
			<span class="enscript-keyword">if</span> ((ifp-&gt;if_start_delay_swin + dwin) &gt; now_nsec) {
				ifp-&gt;if_start_delay_cnt++;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((now_nsec - ifp-&gt;if_start_delay_swin)
			    &gt;= (200 * 1000 * 1000)) {
				ifp-&gt;if_start_delay_swin = now_nsec;
				ifp-&gt;if_start_delay_cnt = 1;
				ifp-&gt;if_start_delay_idle = 0;
				<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_DELAY_START) {
					ifp-&gt;if_eflags &amp;=
					    ~(IFEF_DELAY_START);
					ifnet_delay_start_disabled++;
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (ifp-&gt;if_start_delay_cnt &gt;=
				    ifp-&gt;if_start_delay_qlen) {
					ifp-&gt;if_eflags |= IFEF_DELAY_START;
					ifp-&gt;if_start_delay_idle = 0;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (ifp-&gt;if_start_delay_idle &gt;= 10) {
						ifp-&gt;if_eflags &amp;= ~(IFEF_DELAY_START);
						ifnet_delay_start_disabled++;
					} <span class="enscript-keyword">else</span> {
						ifp-&gt;if_start_delay_idle++;
					}
				} 
				ifp-&gt;if_start_delay_swin = now_nsec;
				ifp-&gt;if_start_delay_cnt = 1;
			}
		} <span class="enscript-keyword">else</span> {
			ifp-&gt;if_start_delay_swin = now_nsec;
			ifp-&gt;if_start_delay_cnt = 1;
			ifp-&gt;if_start_delay_idle = 0;
			ifp-&gt;if_eflags &amp;= ~(IFEF_DELAY_START);
		}
	} <span class="enscript-keyword">else</span> {
		ifp-&gt;if_eflags &amp;= ~(IFEF_DELAY_START);
	}

	<span class="enscript-comment">/* enqueue the packet */</span>
	error = ifclassq_enqueue(&amp;ifp-&gt;if_snd, m);

	<span class="enscript-comment">/*
	 * Tell the driver to start dequeueing; do this even when the queue
	 * for the packet is suspended (EQSUSPENDED), as the driver could still
	 * be dequeueing from other unsuspended queues.
	 */</span>
	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_ENQUEUE_MULTI) &amp;&amp;
	    (error == 0 || error == EQFULL || error == EQSUSPENDED))
		ifnet_start(ifp);

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">ifnet_dequeue</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf **mp)
{
	errno_t rc;
	<span class="enscript-keyword">if</span> (ifp == NULL || mp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART) ||
	    (ifp-&gt;if_output_sched_model != IFNET_SCHED_MODEL_NORMAL))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1))
		<span class="enscript-keyword">return</span> (ENXIO);
	rc = ifclassq_dequeue(&amp;ifp-&gt;if_snd, 1, mp, NULL, NULL, NULL);
	ifnet_decr_iorefcnt(ifp);

	<span class="enscript-keyword">return</span> (rc);
}

errno_t
<span class="enscript-function-name">ifnet_dequeue_service_class</span>(<span class="enscript-type">struct</span> ifnet *ifp, mbuf_svc_class_t sc,
    <span class="enscript-type">struct</span> mbuf **mp)
{
	errno_t rc;
	<span class="enscript-keyword">if</span> (ifp == NULL || mp == NULL || !MBUF_VALID_SC(sc))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART) ||
	    (ifp-&gt;if_output_sched_model != IFNET_SCHED_MODEL_DRIVER_MANAGED))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1))
		<span class="enscript-keyword">return</span> (ENXIO);
	
	rc = ifclassq_dequeue_sc(&amp;ifp-&gt;if_snd, sc, 1, mp, NULL, NULL, NULL);
	ifnet_decr_iorefcnt(ifp);
	<span class="enscript-keyword">return</span> (rc);
}

errno_t
<span class="enscript-function-name">ifnet_dequeue_multi</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t limit, <span class="enscript-type">struct</span> mbuf **head,
    <span class="enscript-type">struct</span> mbuf **tail, u_int32_t *cnt, u_int32_t *len)
{
	errno_t rc;
	<span class="enscript-keyword">if</span> (ifp == NULL || head == NULL || limit &lt; 1)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART) ||
	    (ifp-&gt;if_output_sched_model != IFNET_SCHED_MODEL_NORMAL))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1))
		<span class="enscript-keyword">return</span> (ENXIO);
	
	rc = ifclassq_dequeue(&amp;ifp-&gt;if_snd, limit, head, tail, cnt, len);
	ifnet_decr_iorefcnt(ifp);
	<span class="enscript-keyword">return</span> (rc);
}

errno_t
<span class="enscript-function-name">ifnet_dequeue_service_class_multi</span>(<span class="enscript-type">struct</span> ifnet *ifp, mbuf_svc_class_t sc,
    u_int32_t limit, <span class="enscript-type">struct</span> mbuf **head, <span class="enscript-type">struct</span> mbuf **tail, u_int32_t *cnt,
    u_int32_t *len)
{
	errno_t rc;
	<span class="enscript-keyword">if</span> (ifp == NULL || head == NULL || limit &lt; 1 || !MBUF_VALID_SC(sc))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART) ||
	    (ifp-&gt;if_output_sched_model != IFNET_SCHED_MODEL_DRIVER_MANAGED))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1))
		<span class="enscript-keyword">return</span> (ENXIO);
	rc = ifclassq_dequeue_sc(&amp;ifp-&gt;if_snd, sc, limit, head,
	    tail, cnt, len);
	ifnet_decr_iorefcnt(ifp);
	<span class="enscript-keyword">return</span> (rc);
}

errno_t
<span class="enscript-function-name">ifnet_framer_stub</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf **m,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *dest, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *dest_linkaddr,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *frame_type, u_int32_t *pre, u_int32_t *post)
{
	<span class="enscript-keyword">if</span> (pre != NULL)
		*pre = 0;
	<span class="enscript-keyword">if</span> (post != NULL)
		*post = 0;

	<span class="enscript-keyword">return</span> (ifp-&gt;if_framer_legacy(ifp, m, dest, dest_linkaddr, frame_type));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dlil_interface_filters_input</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf **m_p,
    <span class="enscript-type">char</span> **frame_header_p, protocol_family_t protocol_family)
{
	<span class="enscript-type">struct</span> ifnet_filter *filter;

	<span class="enscript-comment">/*
	 * Pass the inbound packet to the interface filters
	 */</span>
	lck_mtx_lock_spin(&amp;ifp-&gt;if_flt_lock);
	<span class="enscript-comment">/* prevent filter list from changing in case we drop the lock */</span>
	if_flt_monitor_busy(ifp);
	TAILQ_FOREACH(filter, &amp;ifp-&gt;if_flt_head, filt_next) {
		<span class="enscript-type">int</span> result;

		<span class="enscript-keyword">if</span> (!filter-&gt;filt_skip &amp;&amp; filter-&gt;filt_input != NULL &amp;&amp;
		    (filter-&gt;filt_protocol == 0 ||
		    filter-&gt;filt_protocol == protocol_family)) {
			lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

			result = (*filter-&gt;filt_input)(filter-&gt;filt_cookie,
			    ifp, protocol_family, m_p, frame_header_p);

			lck_mtx_lock_spin(&amp;ifp-&gt;if_flt_lock);
			<span class="enscript-keyword">if</span> (result != 0) {
				<span class="enscript-comment">/* we're done with the filter list */</span>
				if_flt_monitor_unbusy(ifp);
				lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);
				<span class="enscript-keyword">return</span> (result);
			}
		}
	}
	<span class="enscript-comment">/* we're done with the filter list */</span>
	if_flt_monitor_unbusy(ifp);
	lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

	<span class="enscript-comment">/*
	 * Strip away M_PROTO1 bit prior to sending packet up the stack as
	 * it is meant to be local to a subsystem -- if_bridge for M_PROTO1
	 */</span>
	<span class="enscript-keyword">if</span> (*m_p != NULL)
		(*m_p)-&gt;m_flags &amp;= ~M_PROTO1;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dlil_interface_filters_output</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf **m_p,
    protocol_family_t protocol_family)
{
	<span class="enscript-type">struct</span> ifnet_filter *filter;

	<span class="enscript-comment">/*
	 * Pass the outbound packet to the interface filters
	 */</span>
	lck_mtx_lock_spin(&amp;ifp-&gt;if_flt_lock);
	<span class="enscript-comment">/* prevent filter list from changing in case we drop the lock */</span>
	if_flt_monitor_busy(ifp);
	TAILQ_FOREACH(filter, &amp;ifp-&gt;if_flt_head, filt_next) {
		<span class="enscript-type">int</span> result;

		<span class="enscript-keyword">if</span> (!filter-&gt;filt_skip &amp;&amp; filter-&gt;filt_output != NULL &amp;&amp;
		    (filter-&gt;filt_protocol == 0 ||
		    filter-&gt;filt_protocol == protocol_family)) {
			lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

			result = filter-&gt;filt_output(filter-&gt;filt_cookie, ifp,
			    protocol_family, m_p);

			lck_mtx_lock_spin(&amp;ifp-&gt;if_flt_lock);
			<span class="enscript-keyword">if</span> (result != 0) {
				<span class="enscript-comment">/* we're done with the filter list */</span>
				if_flt_monitor_unbusy(ifp);
				lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);
				<span class="enscript-keyword">return</span> (result);
			}
		}
	}
	<span class="enscript-comment">/* we're done with the filter list */</span>
	if_flt_monitor_unbusy(ifp);
	lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_ifproto_input</span>(<span class="enscript-type">struct</span> if_proto * ifproto, mbuf_t m)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (ifproto-&gt;proto_kpi == kProtoKPI_v1) {
		<span class="enscript-comment">/* Version 1 protocols get one packet at a time */</span>
		<span class="enscript-keyword">while</span> (m != NULL) {
			<span class="enscript-type">char</span> *	frame_header;
			mbuf_t	next_packet;

			next_packet = m-&gt;m_nextpkt;
			m-&gt;m_nextpkt = NULL;
			frame_header = m-&gt;m_pkthdr.pkt_hdr;
			m-&gt;m_pkthdr.pkt_hdr = NULL;
			error = (*ifproto-&gt;kpi.v1.input)(ifproto-&gt;ifp,
			    ifproto-&gt;protocol_family, m, frame_header);
			<span class="enscript-keyword">if</span> (error != 0 &amp;&amp; error != EJUSTRETURN)
				m_freem(m);
			m = next_packet;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifproto-&gt;proto_kpi == kProtoKPI_v2) {
		<span class="enscript-comment">/* Version 2 protocols support packet lists */</span>
		error = (*ifproto-&gt;kpi.v2.input)(ifproto-&gt;ifp,
		    ifproto-&gt;protocol_family, m);
		<span class="enscript-keyword">if</span> (error != 0 &amp;&amp; error != EJUSTRETURN)
			m_freem_list(m);
	}
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_input_stats_add</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_stat_increment_param *s,
    <span class="enscript-type">struct</span> dlil_threading_info *inp, boolean_t poll)
{
	<span class="enscript-type">struct</span> ifnet_stat_increment_param *d = &amp;inp-&gt;stats;

	<span class="enscript-keyword">if</span> (s-&gt;packets_in != 0)
		d-&gt;packets_in += s-&gt;packets_in;
	<span class="enscript-keyword">if</span> (s-&gt;bytes_in != 0)
		d-&gt;bytes_in += s-&gt;bytes_in;
	<span class="enscript-keyword">if</span> (s-&gt;errors_in != 0)
		d-&gt;errors_in += s-&gt;errors_in;

	<span class="enscript-keyword">if</span> (s-&gt;packets_out != 0)
		d-&gt;packets_out += s-&gt;packets_out;
	<span class="enscript-keyword">if</span> (s-&gt;bytes_out != 0)
		d-&gt;bytes_out += s-&gt;bytes_out;
	<span class="enscript-keyword">if</span> (s-&gt;errors_out != 0)
		d-&gt;errors_out += s-&gt;errors_out;

	<span class="enscript-keyword">if</span> (s-&gt;collisions != 0)
		d-&gt;collisions += s-&gt;collisions;
	<span class="enscript-keyword">if</span> (s-&gt;dropped != 0)
		d-&gt;dropped += s-&gt;dropped;

	<span class="enscript-keyword">if</span> (poll)
		PKTCNTR_ADD(&amp;inp-&gt;tstats, s-&gt;packets_in, s-&gt;bytes_in);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_input_stats_sync</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> dlil_threading_info *inp)
{
	<span class="enscript-type">struct</span> ifnet_stat_increment_param *s = &amp;inp-&gt;stats;

	<span class="enscript-comment">/*
	 * Use of atomic operations is unavoidable here because
	 * these stats may also be incremented elsewhere via KPIs.
	 */</span>
	<span class="enscript-keyword">if</span> (s-&gt;packets_in != 0) {
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_ipackets, s-&gt;packets_in);
		s-&gt;packets_in = 0;
	}
	<span class="enscript-keyword">if</span> (s-&gt;bytes_in != 0) {
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_ibytes, s-&gt;bytes_in);
		s-&gt;bytes_in = 0;
	}
	<span class="enscript-keyword">if</span> (s-&gt;errors_in != 0) {
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_ierrors, s-&gt;errors_in);
		s-&gt;errors_in = 0;
	}

	<span class="enscript-keyword">if</span> (s-&gt;packets_out != 0) {
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_opackets, s-&gt;packets_out);
		s-&gt;packets_out = 0;
	}
	<span class="enscript-keyword">if</span> (s-&gt;bytes_out != 0) {
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_obytes, s-&gt;bytes_out);
		s-&gt;bytes_out = 0;
	}
	<span class="enscript-keyword">if</span> (s-&gt;errors_out != 0) {
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_oerrors, s-&gt;errors_out);
		s-&gt;errors_out = 0;
	}

	<span class="enscript-keyword">if</span> (s-&gt;collisions != 0) {
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_collisions, s-&gt;collisions);
		s-&gt;collisions = 0;
	}
	<span class="enscript-keyword">if</span> (s-&gt;dropped != 0) {
		atomic_add_64(&amp;ifp-&gt;if_data.ifi_iqdrops, s-&gt;dropped);
		s-&gt;dropped = 0;
	}
	<span class="enscript-comment">/*
	 * If we went over the threshold, notify NetworkStatistics.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_data_threshold &amp;&amp;
	    (ifp-&gt;if_ibytes + ifp-&gt;if_obytes) - ifp-&gt;if_dt_bytes &gt;
	    ifp-&gt;if_data_threshold) {
		ifp-&gt;if_dt_bytes = ifp-&gt;if_ibytes + ifp-&gt;if_obytes;
		nstat_ifnet_threshold_reached(ifp-&gt;if_index);
	}
	<span class="enscript-comment">/*
	 * No need for atomic operations as they are modified here
	 * only from within the DLIL input thread context.
	 */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;tstats.packets != 0) {
		inp-&gt;pstats.ifi_poll_packets += inp-&gt;tstats.packets;
		inp-&gt;tstats.packets = 0;
	}
	<span class="enscript-keyword">if</span> (inp-&gt;tstats.bytes != 0) {
		inp-&gt;pstats.ifi_poll_bytes += inp-&gt;tstats.bytes;
		inp-&gt;tstats.bytes = 0;
	}
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_input_packet_list</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-keyword">return</span> (dlil_input_packet_list_common(ifp, m, 0,
	    IFNET_MODEL_INPUT_POLL_OFF, FALSE));
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_input_packet_list_extended</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m,
    u_int32_t cnt, ifnet_model_t mode)
{
	<span class="enscript-keyword">return</span> (dlil_input_packet_list_common(ifp, m, cnt, mode, TRUE));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_input_packet_list_common</span>(<span class="enscript-type">struct</span> ifnet *ifp_param, <span class="enscript-type">struct</span> mbuf *m,
    u_int32_t cnt, ifnet_model_t mode, boolean_t ext)
{
	<span class="enscript-type">int</span>				error = 0;
	protocol_family_t		protocol_family;
	mbuf_t				next_packet;
	ifnet_t				ifp = ifp_param;
	<span class="enscript-type">char</span> *				frame_header;
	<span class="enscript-type">struct</span> if_proto	*		last_ifproto = NULL;
	mbuf_t				pkt_first = NULL;
	mbuf_t *			pkt_next = NULL;
	u_int32_t			poll_thresh = 0, poll_ival = 0;

	KERNEL_DEBUG(DBG_FNC_DLIL_INPUT | DBG_FUNC_START,0,0,0,0,0);

	<span class="enscript-keyword">if</span> (ext &amp;&amp; mode == IFNET_MODEL_INPUT_POLL_ON &amp;&amp; cnt &gt; 1 &amp;&amp;
	    (poll_ival = if_rxpoll_interval_pkts) &gt; 0)
		poll_thresh = cnt;

	<span class="enscript-keyword">while</span> (m != NULL) {
		<span class="enscript-type">struct</span> if_proto *ifproto = NULL;
		<span class="enscript-type">int</span> iorefcnt = 0;
		uint32_t pktf_mask;	<span class="enscript-comment">/* pkt flags to preserve */</span>

		<span class="enscript-keyword">if</span> (ifp_param == NULL)
			ifp = m-&gt;m_pkthdr.rcvif;

		<span class="enscript-keyword">if</span> ((ifp-&gt;if_eflags &amp; IFEF_RXPOLL) &amp;&amp; poll_thresh != 0 &amp;&amp;
		    poll_ival &gt; 0 &amp;&amp; (--poll_thresh % poll_ival) == 0)
			ifnet_poll(ifp);

		<span class="enscript-comment">/* Check if this mbuf looks valid */</span>
		MBUF_INPUT_CHECK(m, ifp);

		next_packet = m-&gt;m_nextpkt;
		m-&gt;m_nextpkt = NULL;
		frame_header = m-&gt;m_pkthdr.pkt_hdr;
		m-&gt;m_pkthdr.pkt_hdr = NULL;

		<span class="enscript-comment">/*
		 * Get an IO reference count if the interface is not
		 * loopback (lo0) and it is attached; lo0 never goes
		 * away, so optimize for that.
		 */</span>
		<span class="enscript-keyword">if</span> (ifp != lo_ifp) {
			<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1)) {
				m_freem(m);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
			}
			iorefcnt = 1;
			pktf_mask = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * If this arrived on lo0, preserve interface addr
			 * info to allow for connectivity between loopback
			 * and local interface addresses.
			 */</span>
			pktf_mask = (PKTF_LOOP|PKTF_IFAINFO);
		}

		<span class="enscript-comment">/* make sure packet comes in clean */</span>
		m_classifier_init(m, pktf_mask);

		ifp_inc_traffic_class_in(ifp, m);

		<span class="enscript-comment">/* find which protocol family this packet is for */</span>
		ifnet_lock_shared(ifp);
		error = (*ifp-&gt;if_demux)(ifp, m, frame_header,
		    &amp;protocol_family);
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">if</span> (error == EJUSTRETURN)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
			protocol_family = 0;
		}

		<span class="enscript-keyword">if</span> (hwcksum_dbg != 0 &amp;&amp; !(ifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
		    !(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP))
			dlil_input_cksum_dbg(ifp, m, frame_header,
			    protocol_family);

		<span class="enscript-comment">/*
		 * For partial checksum offload, we expect the driver to
		 * set the start offset indicating the start of the span
		 * that is covered by the hardware-computed checksum;
		 * adjust this start offset accordingly because the data
		 * pointer has been advanced beyond the link-layer header.
		 *
		 * Don't adjust if the interface is a bridge member, as
		 * the adjustment will occur from the context of the
		 * bridge interface during input.
		 */</span>
		<span class="enscript-keyword">if</span> (ifp-&gt;if_bridge == NULL &amp;&amp; (m-&gt;m_pkthdr.csum_flags &amp;
		    (CSUM_DATA_VALID | CSUM_PARTIAL)) ==
		    (CSUM_DATA_VALID | CSUM_PARTIAL)) {
			<span class="enscript-type">int</span> adj;

			<span class="enscript-keyword">if</span> (frame_header == NULL ||
			    frame_header &lt; (<span class="enscript-type">char</span> *)mbuf_datastart(m) ||
			    frame_header &gt; (<span class="enscript-type">char</span> *)m-&gt;m_data ||
			    (adj = (m-&gt;m_data - frame_header)) &gt;
			    m-&gt;m_pkthdr.csum_rx_start) {
				m-&gt;m_pkthdr.csum_data = 0;
				m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_DATA_VALID;
				hwcksum_in_invalidated++;
			} <span class="enscript-keyword">else</span> {
				m-&gt;m_pkthdr.csum_rx_start -= adj;
			}
		}

		pktap_input(ifp, protocol_family, m, frame_header);

		<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; (M_BCAST|M_MCAST))
			atomic_add_64(&amp;ifp-&gt;if_imcasts, 1);

		<span class="enscript-comment">/* run interface filters, exclude VLAN packets PR-3586856 */</span>
		<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_VLAN_TAG_VALID) == 0) {
			error = dlil_interface_filters_input(ifp, &amp;m,
			    &amp;frame_header, protocol_family);
			<span class="enscript-keyword">if</span> (error != 0) {
				<span class="enscript-keyword">if</span> (error != EJUSTRETURN)
					m_freem(m);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
			}
		}
		<span class="enscript-keyword">if</span> (error != 0 || ((m-&gt;m_flags &amp; M_PROMISC) != 0) ) {
			m_freem(m);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		}

		<span class="enscript-comment">/* Lookup the protocol attachment to this interface */</span>
		<span class="enscript-keyword">if</span> (protocol_family == 0) {
			ifproto = NULL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (last_ifproto != NULL &amp;&amp; last_ifproto-&gt;ifp == ifp &amp;&amp;
		    (last_ifproto-&gt;protocol_family == protocol_family)) {
			VERIFY(ifproto == NULL);
			ifproto = last_ifproto;
			if_proto_ref(last_ifproto);
		} <span class="enscript-keyword">else</span> {
			VERIFY(ifproto == NULL);
			ifnet_lock_shared(ifp);
			<span class="enscript-comment">/* callee holds a proto refcnt upon success */</span>
			ifproto	= find_attached_proto(ifp, protocol_family);
			ifnet_lock_done(ifp);
		}
		<span class="enscript-keyword">if</span> (ifproto == NULL) {
			<span class="enscript-comment">/* no protocol for this packet, discard */</span>
			m_freem(m);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		}
		<span class="enscript-keyword">if</span> (ifproto != last_ifproto) {
			<span class="enscript-keyword">if</span> (last_ifproto != NULL) {
				<span class="enscript-comment">/* pass up the list for the previous protocol */</span>
				dlil_ifproto_input(last_ifproto, pkt_first);
				pkt_first = NULL;
				if_proto_free(last_ifproto);
			}
			last_ifproto = ifproto;
			if_proto_ref(ifproto);
		}
		<span class="enscript-comment">/* extend the list */</span>
		m-&gt;m_pkthdr.pkt_hdr = frame_header;
		<span class="enscript-keyword">if</span> (pkt_first == NULL) {
			pkt_first = m;
		} <span class="enscript-keyword">else</span> {
			*pkt_next = m;
		}
		pkt_next = &amp;m-&gt;m_nextpkt;

<span class="enscript-reference">next</span>:
		<span class="enscript-keyword">if</span> (next_packet == NULL &amp;&amp; last_ifproto != NULL) {
			<span class="enscript-comment">/* pass up the last list of packets */</span>
			dlil_ifproto_input(last_ifproto, pkt_first);
			if_proto_free(last_ifproto);
			last_ifproto = NULL;
		}
		<span class="enscript-keyword">if</span> (ifproto != NULL) {
			if_proto_free(ifproto);
			ifproto = NULL;
		}

		m = next_packet;

		<span class="enscript-comment">/* update the driver's multicast filter, if needed */</span>
		<span class="enscript-keyword">if</span> (ifp-&gt;if_updatemcasts &gt; 0 &amp;&amp; if_mcasts_update(ifp) == 0)
			ifp-&gt;if_updatemcasts = 0;
		<span class="enscript-keyword">if</span> (iorefcnt == 1)
			ifnet_decr_iorefcnt(ifp);
	}

	KERNEL_DEBUG(DBG_FNC_DLIL_INPUT | DBG_FUNC_END,0,0,0,0,0);
}

errno_t
<span class="enscript-function-name">if_mcasts_update</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	errno_t err;

	err = ifnet_ioctl(ifp, 0, SIOCADDMULTI, NULL);
	<span class="enscript-keyword">if</span> (err == EAFNOSUPPORT)
		err = 0;
	printf(<span class="enscript-string">&quot;%s: %s %d suspended link-layer multicast membership(s) &quot;</span>
	    <span class="enscript-string">&quot;(err=%d)\n&quot;</span>, if_name(ifp),
	    (err == 0 ? <span class="enscript-string">&quot;successfully restored&quot;</span> : <span class="enscript-string">&quot;failed to restore&quot;</span>),
	    ifp-&gt;if_updatemcasts, err);

	<span class="enscript-comment">/* just return success */</span>
	<span class="enscript-keyword">return</span> (0);
}

	
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMP_IF_PROTO_ARR_SIZE</span>	10
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dlil_event_internal</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> kev_msg *event)
{
	<span class="enscript-type">struct</span> ifnet_filter *filter = NULL;
	<span class="enscript-type">struct</span> if_proto *proto = NULL;
	<span class="enscript-type">int</span> if_proto_count = 0;
	<span class="enscript-type">struct</span> if_proto **tmp_ifproto_arr = NULL;
	<span class="enscript-type">struct</span> if_proto *tmp_ifproto_stack_arr[TMP_IF_PROTO_ARR_SIZE] = {NULL};
	<span class="enscript-type">int</span> tmp_ifproto_arr_idx = 0;
	bool tmp_malloc = false;

	<span class="enscript-comment">/*
	 * Pass the event to the interface filters
	 */</span>
	lck_mtx_lock_spin(&amp;ifp-&gt;if_flt_lock);
	<span class="enscript-comment">/* prevent filter list from changing in case we drop the lock */</span>
	if_flt_monitor_busy(ifp);
	TAILQ_FOREACH(filter, &amp;ifp-&gt;if_flt_head, filt_next) {
		<span class="enscript-keyword">if</span> (filter-&gt;filt_event != NULL) {
			lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

			filter-&gt;filt_event(filter-&gt;filt_cookie, ifp,
			    filter-&gt;filt_protocol, event);

			lck_mtx_lock_spin(&amp;ifp-&gt;if_flt_lock);
		}
	}
	<span class="enscript-comment">/* we're done with the filter list */</span>
	if_flt_monitor_unbusy(ifp);
	lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

	<span class="enscript-comment">/* Get an io ref count if the interface is attached */</span>
	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-comment">/*
	 * An embedded tmp_list_entry in if_proto may still get
	 * over-written by another thread after giving up ifnet lock,
	 * therefore we are avoiding embedded pointers here.
	 */</span>
	ifnet_lock_shared(ifp);
	if_proto_count = dlil_ifp_proto_count(ifp);
	<span class="enscript-keyword">if</span> (if_proto_count) {
		<span class="enscript-type">int</span> i;
		VERIFY(ifp-&gt;if_proto_hash != NULL);
		<span class="enscript-keyword">if</span> (if_proto_count &lt;= TMP_IF_PROTO_ARR_SIZE) {
			tmp_ifproto_arr = tmp_ifproto_stack_arr;
		} <span class="enscript-keyword">else</span> {
			MALLOC(tmp_ifproto_arr, <span class="enscript-type">struct</span> if_proto **,
			    <span class="enscript-keyword">sizeof</span> (*tmp_ifproto_arr) * if_proto_count,
			    M_TEMP, M_ZERO);
			<span class="enscript-keyword">if</span> (tmp_ifproto_arr == NULL) {
				ifnet_lock_done(ifp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
			}
			tmp_malloc = true;
		}

		<span class="enscript-keyword">for</span> (i = 0; i &lt; PROTO_HASH_SLOTS; i++) {
			SLIST_FOREACH(proto, &amp;ifp-&gt;if_proto_hash[i],
			    next_hash) {
				if_proto_ref(proto);
				tmp_ifproto_arr[tmp_ifproto_arr_idx] = proto;
				tmp_ifproto_arr_idx++;
			}
		}
		VERIFY(if_proto_count == tmp_ifproto_arr_idx);
	}
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">for</span> (tmp_ifproto_arr_idx = 0; tmp_ifproto_arr_idx &lt; if_proto_count;
	    tmp_ifproto_arr_idx++) {
		proto = tmp_ifproto_arr[tmp_ifproto_arr_idx];
		VERIFY(proto != NULL);
		proto_media_event eventp =
		    (proto-&gt;proto_kpi == kProtoKPI_v1 ?
		    proto-&gt;kpi.v1.event :
		    proto-&gt;kpi.v2.event);

		<span class="enscript-keyword">if</span> (eventp != NULL) {
			eventp(ifp, proto-&gt;protocol_family,
			    event);
		}
		if_proto_free(proto);
	}

<span class="enscript-reference">cleanup</span>:	
	<span class="enscript-keyword">if</span> (tmp_malloc) {
		FREE(tmp_ifproto_arr, M_TEMP);
	}

	<span class="enscript-comment">/* Pass the event to the interface */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_event != NULL)
		ifp-&gt;if_event(ifp, event);

	<span class="enscript-comment">/* Release the io ref count */</span>
	ifnet_decr_iorefcnt(ifp);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (kev_post_msg(event));
}

errno_t
<span class="enscript-function-name">ifnet_event</span>(ifnet_t ifp, <span class="enscript-type">struct</span> kern_event_msg *event)
{
	<span class="enscript-type">struct</span> kev_msg               kev_msg;
	<span class="enscript-type">int</span> result = 0;

	<span class="enscript-keyword">if</span> (ifp == NULL || event == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	bzero(&amp;kev_msg, <span class="enscript-keyword">sizeof</span> (kev_msg));
	kev_msg.vendor_code    = event-&gt;vendor_code;
	kev_msg.kev_class      = event-&gt;kev_class;
	kev_msg.kev_subclass   = event-&gt;kev_subclass;
	kev_msg.event_code     = event-&gt;event_code;
	kev_msg.dv[0].data_ptr = &amp;event-&gt;event_data[0];
	kev_msg.dv[0].data_length = event-&gt;total_size - KEV_MSG_HEADER_SIZE;
	kev_msg.dv[1].data_length = 0;

	result = dlil_event_internal(ifp, &amp;kev_msg);

	<span class="enscript-keyword">return</span> (result);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dlil_get_socket_type</span>(<span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">int</span> family, <span class="enscript-type">int</span> raw)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">int</span> type = SOCK_RAW;

	<span class="enscript-keyword">if</span> (!raw) {
		<span class="enscript-keyword">switch</span> (family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET</span>:
			m = m_pullup(*mp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip));
			<span class="enscript-keyword">if</span> (m == NULL)
				<span class="enscript-keyword">break</span>;
			*mp = m;
			ip = mtod(m, <span class="enscript-type">struct</span> ip *);
			<span class="enscript-keyword">if</span> (ip-&gt;ip_p == IPPROTO_TCP)
				type = SOCK_STREAM;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ip-&gt;ip_p == IPPROTO_UDP)
				type = SOCK_DGRAM;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET6</span>:
			m = m_pullup(*mp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
			<span class="enscript-keyword">if</span> (m == NULL)
				<span class="enscript-keyword">break</span>;
			*mp = m;
			ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
			<span class="enscript-keyword">if</span> (ip6-&gt;ip6_nxt == IPPROTO_TCP)
				type = SOCK_STREAM;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ip6-&gt;ip6_nxt == IPPROTO_UDP)
				type = SOCK_DGRAM;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (type);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * This is mostly called from the context of the DLIL input thread;
 * because of that there is no need for atomic operations.
 */</span>
<span class="enscript-type">static</span> __inline <span class="enscript-type">void</span>
<span class="enscript-function-name">ifp_inc_traffic_class_in</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">switch</span> (m_get_traffic_class(m)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_TC_BE</span>:
		ifp-&gt;if_tc.ifi_ibepackets++;
		ifp-&gt;if_tc.ifi_ibebytes += m-&gt;m_pkthdr.len;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_TC_BK</span>:
		ifp-&gt;if_tc.ifi_ibkpackets++;
		ifp-&gt;if_tc.ifi_ibkbytes += m-&gt;m_pkthdr.len;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_TC_VI</span>:
		ifp-&gt;if_tc.ifi_ivipackets++;
		ifp-&gt;if_tc.ifi_ivibytes += m-&gt;m_pkthdr.len;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_TC_VO</span>:
		ifp-&gt;if_tc.ifi_ivopackets++;
		ifp-&gt;if_tc.ifi_ivobytes += m-&gt;m_pkthdr.len;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (mbuf_is_traffic_class_privileged(m)) {
		ifp-&gt;if_tc.ifi_ipvpackets++;
		ifp-&gt;if_tc.ifi_ipvbytes += m-&gt;m_pkthdr.len;
	}
}

<span class="enscript-comment">/*
 * This is called from DLIL output, hence multiple threads could end
 * up modifying the statistics.  We trade off acccuracy for performance
 * by not using atomic operations here.
 */</span>
<span class="enscript-type">static</span> __inline <span class="enscript-type">void</span>
<span class="enscript-function-name">ifp_inc_traffic_class_out</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">switch</span> (m_get_traffic_class(m)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_TC_BE</span>:
		ifp-&gt;if_tc.ifi_obepackets++;
		ifp-&gt;if_tc.ifi_obebytes += m-&gt;m_pkthdr.len;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_TC_BK</span>:
		ifp-&gt;if_tc.ifi_obkpackets++;
		ifp-&gt;if_tc.ifi_obkbytes += m-&gt;m_pkthdr.len;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_TC_VI</span>:
		ifp-&gt;if_tc.ifi_ovipackets++;
		ifp-&gt;if_tc.ifi_ovibytes += m-&gt;m_pkthdr.len;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_TC_VO</span>:
		ifp-&gt;if_tc.ifi_ovopackets++;
		ifp-&gt;if_tc.ifi_ovobytes += m-&gt;m_pkthdr.len;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (mbuf_is_traffic_class_privileged(m)) {
		ifp-&gt;if_tc.ifi_opvpackets++;
		ifp-&gt;if_tc.ifi_opvbytes += m-&gt;m_pkthdr.len;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_count_chain_len</span>(mbuf_t m, <span class="enscript-type">struct</span> chain_len_stats *cls)
{
	mbuf_t	n = m;
	<span class="enscript-type">int</span> chainlen = 0;

	<span class="enscript-keyword">while</span> (n != NULL) {
		chainlen++;
		n = n-&gt;m_next;
	}
	<span class="enscript-keyword">switch</span> (chainlen) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
			atomic_add_64(&amp;cls-&gt;cls_one, 1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
			atomic_add_64(&amp;cls-&gt;cls_two, 1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
			atomic_add_64(&amp;cls-&gt;cls_three, 1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
			atomic_add_64(&amp;cls-&gt;cls_four, 1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
		<span class="enscript-reference">default</span>:
			atomic_add_64(&amp;cls-&gt;cls_five_or_more, 1);
			<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-comment">/*
 * dlil_output
 *
 * Caller should have a lock on the protocol domain if the protocol
 * doesn't support finer grained locking. In most cases, the lock
 * will be held from the socket layer and won't be released until
 * we return back to the socket layer.
 *
 * This does mean that we must take a protocol lock before we take
 * an interface lock if we're going to take both. This makes sense
 * because a protocol is likely to interact with an ifp while it
 * is under the protocol lock.
 *
 * An advisory code will be returned if adv is not null. This
 * can be used to provide feedback about interface queues to the
 * application.
 */</span>
errno_t
<span class="enscript-function-name">dlil_output</span>(ifnet_t ifp, protocol_family_t proto_family, mbuf_t packetlist,
    <span class="enscript-type">void</span> *route, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *dest, <span class="enscript-type">int</span> raw, <span class="enscript-type">struct</span> flowadv *adv)
{
	<span class="enscript-type">char</span> *frame_type = NULL;
	<span class="enscript-type">char</span> *dst_linkaddr = NULL;
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">char</span> frame_type_buffer[MAX_FRAME_TYPE_SIZE * 4];
	<span class="enscript-type">char</span> dst_linkaddr_buffer[MAX_LINKADDR * 4];
	<span class="enscript-type">struct</span> if_proto	*proto = NULL;
	mbuf_t	m;
	mbuf_t	send_head = NULL;
	mbuf_t	*send_tail = &amp;send_head;
	<span class="enscript-type">int</span> iorefcnt = 0;
	u_int32_t pre = 0, post = 0;
	u_int32_t fpkts = 0, fbytes = 0;
	int32_t flen = 0;

	KERNEL_DEBUG(DBG_FNC_DLIL_OUTPUT | DBG_FUNC_START, 0, 0, 0, 0, 0);

	<span class="enscript-comment">/* Get an io refcnt if the interface is attached to prevent ifnet_detach
	 * from happening while this operation is in progress */</span>
	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1)) {
		retval = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	}
	iorefcnt = 1;

	<span class="enscript-comment">/* update the driver's multicast filter, if needed */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_updatemcasts &gt; 0 &amp;&amp; if_mcasts_update(ifp) == 0)
		ifp-&gt;if_updatemcasts = 0;

	frame_type = frame_type_buffer;
	dst_linkaddr = dst_linkaddr_buffer;

	<span class="enscript-keyword">if</span> (raw == 0) {
		ifnet_lock_shared(ifp);
		<span class="enscript-comment">/* callee holds a proto refcnt upon success */</span>
		proto = find_attached_proto(ifp, proto_family);
		<span class="enscript-keyword">if</span> (proto == NULL) {
			ifnet_lock_done(ifp);
			retval = ENXIO;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
		}
		ifnet_lock_done(ifp);
	}

<span class="enscript-reference">preout_again</span>:
	<span class="enscript-keyword">if</span> (packetlist == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

	m = packetlist;
	packetlist = packetlist-&gt;m_nextpkt;
	m-&gt;m_nextpkt = NULL;

	<span class="enscript-keyword">if</span> (raw == 0) {
		proto_media_preout preoutp = (proto-&gt;proto_kpi == kProtoKPI_v1 ?
		    proto-&gt;kpi.v1.pre_output : proto-&gt;kpi.v2.pre_output);
		retval = 0;
		<span class="enscript-keyword">if</span> (preoutp != NULL) {
			retval = preoutp(ifp, proto_family, &amp;m, dest, route,
			    frame_type, dst_linkaddr);

			<span class="enscript-keyword">if</span> (retval != 0) {
				<span class="enscript-keyword">if</span> (retval == EJUSTRETURN)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">preout_again</span>;
				m_freem(m);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
			}
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	retval = mac_ifnet_check_transmit(ifp, m, proto_family,
	    dlil_get_socket_type(&amp;m, proto_family, raw));
	<span class="enscript-keyword">if</span> (retval != 0) {
		m_freem(m);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">do</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-keyword">if</span> (!raw &amp;&amp; proto_family == PF_INET) {
			<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip*);
	                DTRACE_IP6(send, <span class="enscript-type">struct</span> mbuf *, m, <span class="enscript-type">struct</span> inpcb *, NULL,
				<span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> ifnet *, ifp,
				<span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> ip6_hdr *, NULL);

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!raw &amp;&amp; proto_family == PF_INET6) {
			<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr*);
			DTRACE_IP6(send, <span class="enscript-type">struct</span> mbuf*, m, <span class="enscript-type">struct</span> inpcb *, NULL,
				<span class="enscript-type">struct</span> ip6_hdr *, ip6, <span class="enscript-type">struct</span> ifnet*, ifp,
				<span class="enscript-type">struct</span> ip*, NULL, <span class="enscript-type">struct</span> ip6_hdr *, ip6);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>

		<span class="enscript-keyword">if</span> (raw == 0 &amp;&amp; ifp-&gt;if_framer != NULL) {
			<span class="enscript-type">int</span> rcvif_set = 0;

			<span class="enscript-comment">/*
			 * If this is a broadcast packet that needs to be
			 * looped back into the system, set the inbound ifp
			 * to that of the outbound ifp.  This will allow
			 * us to determine that it is a legitimate packet
			 * for the system.  Only set the ifp if it's not
			 * already set, just to be safe.
			 */</span>
			<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; (M_BCAST | M_LOOP)) &amp;&amp;
			    m-&gt;m_pkthdr.rcvif == NULL) {
				m-&gt;m_pkthdr.rcvif = ifp;
				rcvif_set = 1;
			}

			retval = ifp-&gt;if_framer(ifp, &amp;m, dest, dst_linkaddr,
			    frame_type, &amp;pre, &amp;post);
			<span class="enscript-keyword">if</span> (retval != 0) {
				<span class="enscript-keyword">if</span> (retval != EJUSTRETURN)
					m_freem(m);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
			}

			<span class="enscript-comment">/*
			 * For partial checksum offload, adjust the start
			 * and stuff offsets based on the prepended header.
			 */</span>
			<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp;
			    (CSUM_DATA_VALID | CSUM_PARTIAL)) ==
			    (CSUM_DATA_VALID | CSUM_PARTIAL)) {
				m-&gt;m_pkthdr.csum_tx_stuff += pre;
				m-&gt;m_pkthdr.csum_tx_start += pre;
			}

			<span class="enscript-keyword">if</span> (hwcksum_dbg != 0 &amp;&amp; !(ifp-&gt;if_flags &amp; IFF_LOOPBACK))
				dlil_output_cksum_dbg(ifp, m, pre,
				    proto_family);

			<span class="enscript-comment">/*
			 * Clear the ifp if it was set above, and to be
			 * safe, only if it is still the same as the
			 * outbound ifp we have in context.  If it was
			 * looped back, then a copy of it was sent to the
			 * loopback interface with the rcvif set, and we
			 * are clearing the one that will go down to the
			 * layer below.
			 */</span>
			<span class="enscript-keyword">if</span> (rcvif_set &amp;&amp; m-&gt;m_pkthdr.rcvif == ifp)
				m-&gt;m_pkthdr.rcvif = NULL;
		}

		<span class="enscript-comment">/*
		 * Let interface filters (if any) do their thing ...
		 */</span>
		<span class="enscript-comment">/* Do not pass VLAN tagged packets to filters PR-3586856 */</span>
		<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_VLAN_TAG_VALID) == 0) {
			retval = dlil_interface_filters_output(ifp,
			    &amp;m, proto_family);
			<span class="enscript-keyword">if</span> (retval != 0) {
				<span class="enscript-keyword">if</span> (retval != EJUSTRETURN)
					m_freem(m);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
			}
		}
		<span class="enscript-comment">/*
		 * Strip away M_PROTO1 bit prior to sending packet
		 * to the driver as this field may be used by the driver
		 */</span>
		m-&gt;m_flags &amp;= ~M_PROTO1;

		<span class="enscript-comment">/*
		 * If the underlying interface is not capable of handling a
		 * packet whose data portion spans across physically disjoint
		 * pages, we need to &quot;normalize&quot; the packet so that we pass
		 * down a chain of mbufs where each mbuf points to a span that
		 * resides in the system page boundary.  If the packet does
		 * not cross page(s), the following is a no-op.
		 */</span>
		<span class="enscript-keyword">if</span> (!(ifp-&gt;if_hwassist &amp; IFNET_MULTIPAGES)) {
			<span class="enscript-keyword">if</span> ((m = m_normalize(m)) == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		}

		<span class="enscript-comment">/*
		 * If this is a TSO packet, make sure the interface still
		 * advertise TSO capability.
		 */</span>
		<span class="enscript-keyword">if</span> (TSO_IPV4_NOTOK(ifp, m) || TSO_IPV6_NOTOK(ifp, m)) {
			retval = EMSGSIZE;
			m_freem(m);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
		}

		<span class="enscript-comment">/*
		 * If the packet service class is not background,
		 * update the timestamp to indicate recent activity
		 * on a foreground socket.
		 */</span>
		<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.pkt_flags &amp; PKTF_FLOW_ID) &amp;&amp;
		    m-&gt;m_pkthdr.pkt_flowsrc == FLOWSRC_INPCB) {
			<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_SO_BACKGROUND))
				ifp-&gt;if_fg_sendts = net_uptime();

			<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_SO_REALTIME)
				ifp-&gt;if_rt_sendts = net_uptime();
		}

		ifp_inc_traffic_class_out(ifp, m);
		pktap_output(ifp, proto_family, m, pre, post);

		<span class="enscript-comment">/*
		 * Count the number of elements in the mbuf chain
		 */</span>
		<span class="enscript-keyword">if</span> (tx_chain_len_count) {
			dlil_count_chain_len(m, &amp;tx_chain_len_stats);
		}

		<span class="enscript-comment">/*
		 * Finally, call the driver.
		 */</span>
		<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; (IFEF_SENDLIST | IFEF_ENQUEUE_MULTI)) {
			<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_FORWARDED) {
				flen += (m_pktlen(m) - (pre + post));
				m-&gt;m_pkthdr.pkt_flags &amp;= ~PKTF_FORWARDED;
			}
			*send_tail = m;
			send_tail = &amp;m-&gt;m_nextpkt;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_FORWARDED) {
				flen = (m_pktlen(m) - (pre + post));
				m-&gt;m_pkthdr.pkt_flags &amp;= ~PKTF_FORWARDED;
			} <span class="enscript-keyword">else</span> {
				flen = 0;
			}
			KERNEL_DEBUG(DBG_FNC_DLIL_IFOUT | DBG_FUNC_START,
			    0, 0, 0, 0, 0);
			retval = (*ifp-&gt;if_output)(ifp, m);
			<span class="enscript-keyword">if</span> (retval == EQFULL || retval == EQSUSPENDED) {
				<span class="enscript-keyword">if</span> (adv != NULL &amp;&amp; adv-&gt;code == FADV_SUCCESS) {
					adv-&gt;code = (retval == EQFULL ?
					    FADV_FLOW_CONTROLLED :
					    FADV_SUSPENDED);
				}
				retval = 0;
			}
			<span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; flen &gt; 0) {
				fbytes += flen;
				fpkts++;
			}
			<span class="enscript-keyword">if</span> (retval != 0 &amp;&amp; dlil_verbose) {
				printf(<span class="enscript-string">&quot;%s: output error on %s retval = %d\n&quot;</span>,
				    __func__, if_name(ifp),
				    retval);
			}
			KERNEL_DEBUG(DBG_FNC_DLIL_IFOUT | DBG_FUNC_END,
			    0, 0, 0, 0, 0);
		}
		KERNEL_DEBUG(DBG_FNC_DLIL_IFOUT | DBG_FUNC_END, 0, 0, 0, 0, 0);

<span class="enscript-reference">next</span>:
		m = packetlist;
		<span class="enscript-keyword">if</span> (m != NULL) {
			packetlist = packetlist-&gt;m_nextpkt;
			m-&gt;m_nextpkt = NULL;
		}
	} <span class="enscript-keyword">while</span> (m != NULL);

	<span class="enscript-keyword">if</span> (send_head != NULL) {
		KERNEL_DEBUG(DBG_FNC_DLIL_IFOUT | DBG_FUNC_START,
		    0, 0, 0, 0, 0);
		<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_SENDLIST) {
			retval = (*ifp-&gt;if_output)(ifp, send_head);
			<span class="enscript-keyword">if</span> (retval == EQFULL || retval == EQSUSPENDED) {
				<span class="enscript-keyword">if</span> (adv != NULL) {
					adv-&gt;code = (retval == EQFULL ?
					    FADV_FLOW_CONTROLLED :
					    FADV_SUSPENDED);
				}
				retval = 0;
			}
			<span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; flen &gt; 0) {
				fbytes += flen;
				fpkts++;
			}
			<span class="enscript-keyword">if</span> (retval != 0 &amp;&amp; dlil_verbose) {
				printf(<span class="enscript-string">&quot;%s: output error on %s retval = %d\n&quot;</span>,
				    __func__, if_name(ifp), retval);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> mbuf *send_m;
			<span class="enscript-type">int</span> enq_cnt = 0;
			VERIFY(ifp-&gt;if_eflags &amp; IFEF_ENQUEUE_MULTI);
			<span class="enscript-keyword">while</span> (send_head != NULL) {
				send_m = send_head;
				send_head = send_m-&gt;m_nextpkt;
				send_m-&gt;m_nextpkt = NULL;
				retval = (*ifp-&gt;if_output)(ifp, send_m);
				<span class="enscript-keyword">if</span> (retval == EQFULL || retval == EQSUSPENDED) {
					<span class="enscript-keyword">if</span> (adv != NULL) {
						adv-&gt;code = (retval == EQFULL ?
						    FADV_FLOW_CONTROLLED :
						    FADV_SUSPENDED);
					}
					retval = 0;
				}
				<span class="enscript-keyword">if</span> (retval == 0) {
					enq_cnt++;
					<span class="enscript-keyword">if</span> (flen &gt; 0)
						fpkts++;
				}
				<span class="enscript-keyword">if</span> (retval != 0 &amp;&amp; dlil_verbose) {
					printf(<span class="enscript-string">&quot;%s: output error on %s retval = %d\n&quot;</span>,
					    __func__, if_name(ifp), retval);
				}
			}
			<span class="enscript-keyword">if</span> (enq_cnt &gt; 0) {
				fbytes += flen;
				ifnet_start(ifp);
			}
		}
		KERNEL_DEBUG(DBG_FNC_DLIL_IFOUT | DBG_FUNC_END, 0, 0, 0, 0, 0);
	}

	KERNEL_DEBUG(DBG_FNC_DLIL_OUTPUT | DBG_FUNC_END, 0, 0, 0, 0, 0);

<span class="enscript-reference">cleanup</span>:
	<span class="enscript-keyword">if</span> (fbytes &gt; 0)
		ifp-&gt;if_fbytes += fbytes;
	<span class="enscript-keyword">if</span> (fpkts &gt; 0)
		ifp-&gt;if_fpackets += fpkts;
	<span class="enscript-keyword">if</span> (proto != NULL)
		if_proto_free(proto);
	<span class="enscript-keyword">if</span> (packetlist) <span class="enscript-comment">/* if any packets are left, clean up */</span>
		mbuf_freem_list(packetlist);
	<span class="enscript-keyword">if</span> (retval == EJUSTRETURN)
		retval = 0;
	<span class="enscript-keyword">if</span> (iorefcnt == 1)
		ifnet_decr_iorefcnt(ifp);

	<span class="enscript-keyword">return</span> (retval);
}

errno_t
<span class="enscript-function-name">ifnet_ioctl</span>(ifnet_t ifp, protocol_family_t proto_fam, u_long ioctl_code,
    <span class="enscript-type">void</span> *ioctl_arg)
{
	<span class="enscript-type">struct</span> ifnet_filter *filter;
	<span class="enscript-type">int</span> retval = EOPNOTSUPP;
	<span class="enscript-type">int</span> result = 0;

	<span class="enscript-keyword">if</span> (ifp == NULL || ioctl_code == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* Get an io ref count if the interface is attached */</span>
	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1))
		<span class="enscript-keyword">return</span> (EOPNOTSUPP);

	<span class="enscript-comment">/* Run the interface filters first.
	 * We want to run all filters before calling the protocol,
	 * interface family, or interface.
	 */</span>
	lck_mtx_lock_spin(&amp;ifp-&gt;if_flt_lock);
	<span class="enscript-comment">/* prevent filter list from changing in case we drop the lock */</span>
	if_flt_monitor_busy(ifp);
	TAILQ_FOREACH(filter, &amp;ifp-&gt;if_flt_head, filt_next) {
		<span class="enscript-keyword">if</span> (filter-&gt;filt_ioctl != NULL &amp;&amp; (filter-&gt;filt_protocol == 0 ||
		    filter-&gt;filt_protocol == proto_fam)) {
			lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

			result = filter-&gt;filt_ioctl(filter-&gt;filt_cookie, ifp,
			    proto_fam, ioctl_code, ioctl_arg);

			lck_mtx_lock_spin(&amp;ifp-&gt;if_flt_lock);

			<span class="enscript-comment">/* Only update retval if no one has handled the ioctl */</span>
			<span class="enscript-keyword">if</span> (retval == EOPNOTSUPP || result == EJUSTRETURN) {
				<span class="enscript-keyword">if</span> (result == ENOTSUP)
					result = EOPNOTSUPP;
				retval = result;
				<span class="enscript-keyword">if</span> (retval != 0 &amp;&amp; retval != EOPNOTSUPP) {
					<span class="enscript-comment">/* we're done with the filter list */</span>
					if_flt_monitor_unbusy(ifp);
					lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
				}
			}
		}
	}
	<span class="enscript-comment">/* we're done with the filter list */</span>
	if_flt_monitor_unbusy(ifp);
	lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

	<span class="enscript-comment">/* Allow the protocol to handle the ioctl */</span>
	<span class="enscript-keyword">if</span> (proto_fam != 0) {
		<span class="enscript-type">struct</span> if_proto	*proto;

		<span class="enscript-comment">/* callee holds a proto refcnt upon success */</span>
		ifnet_lock_shared(ifp);
		proto = find_attached_proto(ifp, proto_fam);
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">if</span> (proto != NULL) {
			proto_media_ioctl ioctlp =
			    (proto-&gt;proto_kpi == kProtoKPI_v1 ?
			    proto-&gt;kpi.v1.ioctl : proto-&gt;kpi.v2.ioctl);
			result = EOPNOTSUPP;
			<span class="enscript-keyword">if</span> (ioctlp != NULL)
				result = ioctlp(ifp, proto_fam, ioctl_code,
				    ioctl_arg);
			if_proto_free(proto);

			<span class="enscript-comment">/* Only update retval if no one has handled the ioctl */</span>
			<span class="enscript-keyword">if</span> (retval == EOPNOTSUPP || result == EJUSTRETURN) {
				<span class="enscript-keyword">if</span> (result == ENOTSUP)
					result = EOPNOTSUPP;
				retval = result;
				<span class="enscript-keyword">if</span> (retval &amp;&amp; retval != EOPNOTSUPP)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
			}
		}
	}

	<span class="enscript-comment">/* retval is either 0 or EOPNOTSUPP */</span>

	<span class="enscript-comment">/*
	 * Let the interface handle this ioctl.
	 * If it returns EOPNOTSUPP, ignore that, we may have
	 * already handled this in the protocol or family.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_ioctl)
		result = (*ifp-&gt;if_ioctl)(ifp, ioctl_code, ioctl_arg);

	<span class="enscript-comment">/* Only update retval if no one has handled the ioctl */</span>
	<span class="enscript-keyword">if</span> (retval == EOPNOTSUPP || result == EJUSTRETURN) {
		<span class="enscript-keyword">if</span> (result == ENOTSUP)
			result = EOPNOTSUPP;
		retval = result;
		<span class="enscript-keyword">if</span> (retval &amp;&amp; retval != EOPNOTSUPP) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
		}
	}

<span class="enscript-reference">cleanup</span>:
	<span class="enscript-keyword">if</span> (retval == EJUSTRETURN)
		retval = 0;

	ifnet_decr_iorefcnt(ifp);

	<span class="enscript-keyword">return</span> (retval);
}

__private_extern__ errno_t
<span class="enscript-function-name">dlil_set_bpf_tap</span>(ifnet_t ifp, bpf_tap_mode mode, bpf_packet_func callback)
{
	errno_t	error = 0;


	<span class="enscript-keyword">if</span> (ifp-&gt;if_set_bpf_tap) {
		<span class="enscript-comment">/* Get an io reference on the interface if it is attached */</span>
		<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1))
			<span class="enscript-keyword">return</span> ENXIO;
		error = ifp-&gt;if_set_bpf_tap(ifp, mode, callback);
		ifnet_decr_iorefcnt(ifp);
	}
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">dlil_resolve_multi</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *proto_addr,
    <span class="enscript-type">struct</span> sockaddr *ll_addr, size_t ll_len)
{
	errno_t	result = EOPNOTSUPP;
	<span class="enscript-type">struct</span> if_proto *proto;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *verify;
	proto_media_resolve_multi resolvep;

	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 1))
		<span class="enscript-keyword">return</span> result;

	bzero(ll_addr, ll_len);

	<span class="enscript-comment">/* Call the protocol first; callee holds a proto refcnt upon success */</span>
	ifnet_lock_shared(ifp);
	proto = find_attached_proto(ifp, proto_addr-&gt;sa_family);
	ifnet_lock_done(ifp);
	<span class="enscript-keyword">if</span> (proto != NULL) {
		resolvep = (proto-&gt;proto_kpi == kProtoKPI_v1 ?
		    proto-&gt;kpi.v1.resolve_multi : proto-&gt;kpi.v2.resolve_multi);
		<span class="enscript-keyword">if</span> (resolvep != NULL)
			result = resolvep(ifp, proto_addr,
			    (<span class="enscript-type">struct</span> sockaddr_dl*)(<span class="enscript-type">void</span> *)ll_addr, ll_len);
		if_proto_free(proto);
	}

	<span class="enscript-comment">/* Let the interface verify the multicast address */</span>
	<span class="enscript-keyword">if</span> ((result == EOPNOTSUPP || result == 0) &amp;&amp; ifp-&gt;if_check_multi) {
		<span class="enscript-keyword">if</span> (result == 0)
			verify = ll_addr;
		<span class="enscript-keyword">else</span>
			verify = proto_addr;
		result = ifp-&gt;if_check_multi(ifp, verify);
	}

	ifnet_decr_iorefcnt(ifp);
	<span class="enscript-keyword">return</span> (result);
}

__private_extern__ errno_t
<span class="enscript-function-name">dlil_send_arp_internal</span>(ifnet_t ifp, u_short arpop,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl* sender_hw, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr* sender_proto,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl* target_hw, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr* target_proto)
{
	<span class="enscript-type">struct</span> if_proto *proto;
	errno_t	result = 0;

	<span class="enscript-comment">/* callee holds a proto refcnt upon success */</span>
	ifnet_lock_shared(ifp);
	proto = find_attached_proto(ifp, target_proto-&gt;sa_family);
	ifnet_lock_done(ifp);
	<span class="enscript-keyword">if</span> (proto == NULL) {
		result = ENOTSUP;
	} <span class="enscript-keyword">else</span> {
		proto_media_send_arp	arpp;
		arpp = (proto-&gt;proto_kpi == kProtoKPI_v1 ?
		    proto-&gt;kpi.v1.send_arp : proto-&gt;kpi.v2.send_arp);
		<span class="enscript-keyword">if</span> (arpp == NULL) {
			result = ENOTSUP;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">switch</span> (arpop) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ARPOP_REQUEST</span>:
				arpstat.txrequests++;
				<span class="enscript-keyword">if</span> (target_hw != NULL)
					arpstat.txurequests++;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ARPOP_REPLY</span>:
				arpstat.txreplies++;
				<span class="enscript-keyword">break</span>;
			}
			result = arpp(ifp, arpop, sender_hw, sender_proto,
			    target_hw, target_proto);
		}
		if_proto_free(proto);
	}

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">struct</span> net_thread_marks { };
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> net_thread_marks net_thread_marks_base = { };

__private_extern__ <span class="enscript-type">const</span> net_thread_marks_t net_thread_marks_none =
    &amp;net_thread_marks_base;

__private_extern__ net_thread_marks_t
<span class="enscript-function-name">net_thread_marks_push</span>(u_int32_t push)
{
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> base = (<span class="enscript-type">const</span> <span class="enscript-type">void</span>*)&amp;net_thread_marks_base;
	u_int32_t pop = 0;

	<span class="enscript-keyword">if</span> (push != 0) {
		<span class="enscript-type">struct</span> uthread *uth = get_bsdthread_info(current_thread());

		pop = push &amp; ~uth-&gt;uu_network_marks;
		<span class="enscript-keyword">if</span> (pop != 0)
			uth-&gt;uu_network_marks |= pop;
	}

	<span class="enscript-keyword">return</span> ((net_thread_marks_t)&amp;base[pop]);
}

__private_extern__ net_thread_marks_t
<span class="enscript-function-name">net_thread_unmarks_push</span>(u_int32_t unpush)
{
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> base = (<span class="enscript-type">const</span> <span class="enscript-type">void</span>*)&amp;net_thread_marks_base;
	u_int32_t unpop = 0;

	<span class="enscript-keyword">if</span> (unpush != 0) {
		<span class="enscript-type">struct</span> uthread *uth = get_bsdthread_info(current_thread());

		unpop = unpush &amp; uth-&gt;uu_network_marks;
		<span class="enscript-keyword">if</span> (unpop != 0)
			uth-&gt;uu_network_marks &amp;= ~unpop;
	}

	<span class="enscript-keyword">return</span> ((net_thread_marks_t)&amp;base[unpop]);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">net_thread_marks_pop</span>(net_thread_marks_t popx)
{
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> base = (<span class="enscript-type">const</span> <span class="enscript-type">void</span>*)&amp;net_thread_marks_base;
	<span class="enscript-type">const</span> ptrdiff_t pop = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)popx - (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)base;

	<span class="enscript-keyword">if</span> (pop != 0) {
		<span class="enscript-type">static</span> <span class="enscript-type">const</span> ptrdiff_t ones = (ptrdiff_t)(u_int32_t)~0U;
		<span class="enscript-type">struct</span> uthread *uth = get_bsdthread_info(current_thread());

		VERIFY((pop &amp; ones) == pop);
		VERIFY((ptrdiff_t)(uth-&gt;uu_network_marks &amp; pop) == pop);
		uth-&gt;uu_network_marks &amp;= ~pop;
	}
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">net_thread_unmarks_pop</span>(net_thread_marks_t unpopx)
{
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-type">const</span> base = (<span class="enscript-type">const</span> <span class="enscript-type">void</span>*)&amp;net_thread_marks_base;
	ptrdiff_t unpop = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)unpopx - (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)base;

	<span class="enscript-keyword">if</span> (unpop != 0) {
		<span class="enscript-type">static</span> <span class="enscript-type">const</span> ptrdiff_t ones = (ptrdiff_t)(u_int32_t)~0U;
		<span class="enscript-type">struct</span> uthread *uth = get_bsdthread_info(current_thread());

		VERIFY((unpop &amp; ones) == unpop);
		VERIFY((ptrdiff_t)(uth-&gt;uu_network_marks &amp; unpop) == 0);
		uth-&gt;uu_network_marks |= unpop;
	}
}

__private_extern__ u_int32_t
<span class="enscript-function-name">net_thread_is_marked</span>(u_int32_t check)
{
	<span class="enscript-keyword">if</span> (check != 0) {
		<span class="enscript-type">struct</span> uthread *uth = get_bsdthread_info(current_thread());
		<span class="enscript-keyword">return</span> (uth-&gt;uu_network_marks &amp; check);
	}
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (0);
}

__private_extern__ u_int32_t
<span class="enscript-function-name">net_thread_is_unmarked</span>(u_int32_t check)
{
	<span class="enscript-keyword">if</span> (check != 0) {
		<span class="enscript-type">struct</span> uthread *uth = get_bsdthread_info(current_thread());
		<span class="enscript-keyword">return</span> (~uth-&gt;uu_network_marks &amp; check);
	}
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">_is_announcement</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in * sender_sin,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in * target_sin)
{
	<span class="enscript-keyword">if</span> (sender_sin == NULL) {
		<span class="enscript-keyword">return</span> (FALSE);
	}
	<span class="enscript-keyword">return</span> (sender_sin-&gt;sin_addr.s_addr == target_sin-&gt;sin_addr.s_addr);
}

__private_extern__ errno_t
<span class="enscript-function-name">dlil_send_arp</span>(ifnet_t ifp, u_short arpop, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl* sender_hw,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr* sender_proto, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl* target_hw,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr* target_proto0, u_int32_t rtflags)
{
	errno_t	result = 0;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in * sender_sin;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in * target_sin;
	<span class="enscript-type">struct</span> sockaddr_inarp target_proto_sinarp;
	<span class="enscript-type">struct</span> sockaddr *target_proto = (<span class="enscript-type">void</span> *)(uintptr_t)target_proto0;

	<span class="enscript-keyword">if</span> (target_proto == NULL || (sender_proto != NULL &amp;&amp;
	    sender_proto-&gt;sa_family != target_proto-&gt;sa_family))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/*
	 * If the target is a (default) router, provide that
	 * information to the send_arp callback routine.
	 */</span>
	<span class="enscript-keyword">if</span> (rtflags &amp; RTF_ROUTER) {
		bcopy(target_proto, &amp;target_proto_sinarp,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in));
		target_proto_sinarp.sin_other |= SIN_ROUTER;
		target_proto = (<span class="enscript-type">struct</span> sockaddr *)&amp;target_proto_sinarp;
	}

	<span class="enscript-comment">/*
	 * If this is an ARP request and the target IP is IPv4LL,
	 * send the request on all interfaces.  The exception is
	 * an announcement, which must only appear on the specific
	 * interface.
	 */</span>
	sender_sin = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)(uintptr_t)sender_proto;
	target_sin = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)(uintptr_t)target_proto;
	<span class="enscript-keyword">if</span> (target_proto-&gt;sa_family == AF_INET &amp;&amp;
	    IN_LINKLOCAL(ntohl(target_sin-&gt;sin_addr.s_addr)) &amp;&amp;
	    ipv4_ll_arp_aware != 0 &amp;&amp; arpop == ARPOP_REQUEST &amp;&amp;
	    !_is_announcement(target_sin, sender_sin)) {
		ifnet_t		*ifp_list;
		u_int32_t	count;
		u_int32_t	ifp_on;

		result = ENOTSUP;

		<span class="enscript-keyword">if</span> (ifnet_list_get(IFNET_FAMILY_ANY, &amp;ifp_list, &amp;count) == 0) {
			<span class="enscript-keyword">for</span> (ifp_on = 0; ifp_on &lt; count; ifp_on++) {
				errno_t new_result;
				ifaddr_t source_hw = NULL;
				ifaddr_t source_ip = NULL;
				<span class="enscript-type">struct</span> sockaddr_in source_ip_copy;
				<span class="enscript-type">struct</span> ifnet *cur_ifp = ifp_list[ifp_on];

				<span class="enscript-comment">/*
				 * Only arp on interfaces marked for IPv4LL
				 * ARPing.  This may mean that we don't ARP on
				 * the interface the subnet route points to.
				 */</span>
				<span class="enscript-keyword">if</span> (!(cur_ifp-&gt;if_eflags &amp; IFEF_ARPLL))
					<span class="enscript-keyword">continue</span>;

				<span class="enscript-comment">/* Find the source IP address */</span>
				ifnet_lock_shared(cur_ifp);
				source_hw = cur_ifp-&gt;if_lladdr;
				TAILQ_FOREACH(source_ip, &amp;cur_ifp-&gt;if_addrhead,
				    ifa_link) {
					IFA_LOCK(source_ip);
					<span class="enscript-keyword">if</span> (source_ip-&gt;ifa_addr != NULL &amp;&amp;
					    source_ip-&gt;ifa_addr-&gt;sa_family ==
					    AF_INET) {
						<span class="enscript-comment">/* Copy the source IP address */</span>
						source_ip_copy =
						    *(<span class="enscript-type">struct</span> sockaddr_in *)
						    (<span class="enscript-type">void</span> *)source_ip-&gt;ifa_addr;
						IFA_UNLOCK(source_ip);
						<span class="enscript-keyword">break</span>;
					}
					IFA_UNLOCK(source_ip);
				}

				<span class="enscript-comment">/* No IP Source, don't arp */</span>
				<span class="enscript-keyword">if</span> (source_ip == NULL) {
					ifnet_lock_done(cur_ifp);
					<span class="enscript-keyword">continue</span>;
				}

				IFA_ADDREF(source_hw);
				ifnet_lock_done(cur_ifp);

				<span class="enscript-comment">/* Send the ARP */</span>
				new_result = dlil_send_arp_internal(cur_ifp,
				    arpop, (<span class="enscript-type">struct</span> sockaddr_dl *)(<span class="enscript-type">void</span> *)
				    source_hw-&gt;ifa_addr,
				    (<span class="enscript-type">struct</span> sockaddr *)&amp;source_ip_copy, NULL,
				    target_proto);

				IFA_REMREF(source_hw);
				<span class="enscript-keyword">if</span> (result == ENOTSUP) {
					result = new_result;
				}
			}
			ifnet_list_free(ifp_list);
		}
	} <span class="enscript-keyword">else</span> {
		result = dlil_send_arp_internal(ifp, arpop, sender_hw,
		    sender_proto, target_hw, target_proto);
	}

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/*
 * Caller must hold ifnet head lock.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ifnet_lookup</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> ifnet *_ifp;

	lck_rw_assert(&amp;ifnet_head_lock, LCK_RW_ASSERT_HELD);
	TAILQ_FOREACH(_ifp, &amp;ifnet_head, if_link) {
		<span class="enscript-keyword">if</span> (_ifp == ifp)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (_ifp != NULL);
}
<span class="enscript-comment">/*
 * Caller has to pass a non-zero refio argument to get a
 * IO reference count. This will prevent ifnet_detach from
 * being called when there are outstanding io reference counts. 
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ifnet_is_attached</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> refio)
{
	<span class="enscript-type">int</span> ret;

	lck_mtx_lock_spin(&amp;ifp-&gt;if_ref_lock);
	<span class="enscript-keyword">if</span> ((ret = ((ifp-&gt;if_refflags &amp; (IFRF_ATTACHED | IFRF_DETACHING)) ==
	    IFRF_ATTACHED))) {
		<span class="enscript-keyword">if</span> (refio &gt; 0)
			ifp-&gt;if_refio++;
	}
	lck_mtx_unlock(&amp;ifp-&gt;if_ref_lock);

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_decr_iorefcnt</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	lck_mtx_lock_spin(&amp;ifp-&gt;if_ref_lock);
	VERIFY(ifp-&gt;if_refio &gt; 0);
	VERIFY((ifp-&gt;if_refflags &amp; (IFRF_ATTACHED | IFRF_DETACHING)) != 0);
	ifp-&gt;if_refio--;

	<span class="enscript-comment">/* if there are no more outstanding io references, wakeup the 
	 * ifnet_detach thread if detaching flag is set.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_refio == 0 &amp;&amp; 
		(ifp-&gt;if_refflags &amp; IFRF_DETACHING) != 0) {
		wakeup(&amp;(ifp-&gt;if_refio));
	}
	lck_mtx_unlock(&amp;ifp-&gt;if_ref_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_if_trace</span>(<span class="enscript-type">struct</span> dlil_ifnet *dl_if, <span class="enscript-type">int</span> refhold)
{
	<span class="enscript-type">struct</span> dlil_ifnet_dbg *dl_if_dbg = (<span class="enscript-type">struct</span> dlil_ifnet_dbg *)dl_if;
	ctrace_t *tr;
	u_int32_t idx;
	u_int16_t *cnt;

	<span class="enscript-keyword">if</span> (!(dl_if-&gt;dl_if_flags &amp; DLIF_DEBUG)) {
		panic(<span class="enscript-string">&quot;%s: dl_if %p has no debug structure&quot;</span>, __func__, dl_if);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (refhold) {
		cnt = &amp;dl_if_dbg-&gt;dldbg_if_refhold_cnt;
		tr = dl_if_dbg-&gt;dldbg_if_refhold;
	} <span class="enscript-keyword">else</span> {
		cnt = &amp;dl_if_dbg-&gt;dldbg_if_refrele_cnt;
		tr = dl_if_dbg-&gt;dldbg_if_refrele;
	}

	idx = atomic_add_16_ov(cnt, 1) % IF_REF_TRACE_HIST_SIZE;
	ctrace_record(&amp;tr[idx]);
}

errno_t
<span class="enscript-function-name">dlil_if_ref</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> dlil_ifnet *dl_if = (<span class="enscript-type">struct</span> dlil_ifnet *)ifp;

	<span class="enscript-keyword">if</span> (dl_if == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	lck_mtx_lock_spin(&amp;dl_if-&gt;dl_if_lock);
	++dl_if-&gt;dl_if_refcnt;
	<span class="enscript-keyword">if</span> (dl_if-&gt;dl_if_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s: wraparound refcnt for ifp=%p&quot;</span>, __func__, ifp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (dl_if-&gt;dl_if_trace != NULL)
		(*dl_if-&gt;dl_if_trace)(dl_if, TRUE);
	lck_mtx_unlock(&amp;dl_if-&gt;dl_if_lock);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">dlil_if_free</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> dlil_ifnet *dl_if = (<span class="enscript-type">struct</span> dlil_ifnet *)ifp;

	<span class="enscript-keyword">if</span> (dl_if == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	lck_mtx_lock_spin(&amp;dl_if-&gt;dl_if_lock);
	<span class="enscript-keyword">if</span> (dl_if-&gt;dl_if_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s: negative refcnt for ifp=%p&quot;</span>, __func__, ifp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	--dl_if-&gt;dl_if_refcnt;
	<span class="enscript-keyword">if</span> (dl_if-&gt;dl_if_trace != NULL)
		(*dl_if-&gt;dl_if_trace)(dl_if, FALSE);
	lck_mtx_unlock(&amp;dl_if-&gt;dl_if_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">dlil_attach_protocol_internal</span>(<span class="enscript-type">struct</span> if_proto *proto,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_demux_desc *demux_list, u_int32_t demux_count)
{
	<span class="enscript-type">struct</span> kev_dl_proto_data ev_pr_data;
	<span class="enscript-type">struct</span> ifnet *ifp = proto-&gt;ifp;
	<span class="enscript-type">int</span> retval = 0;
	u_int32_t hash_value = proto_hash_value(proto-&gt;protocol_family);
	<span class="enscript-type">struct</span> if_proto *prev_proto;
	<span class="enscript-type">struct</span> if_proto *_proto;

	<span class="enscript-comment">/* callee holds a proto refcnt upon success */</span>
	ifnet_lock_exclusive(ifp);
	_proto = find_attached_proto(ifp, proto-&gt;protocol_family);
	<span class="enscript-keyword">if</span> (_proto != NULL) {
		ifnet_lock_done(ifp);
		if_proto_free(_proto);
		<span class="enscript-keyword">return</span> (EEXIST);
	}

	<span class="enscript-comment">/*
	 * Call family module add_proto routine so it can refine the
	 * demux descriptors as it wishes.
	 */</span>
	retval = ifp-&gt;if_add_proto(ifp, proto-&gt;protocol_family, demux_list,
	    demux_count);
	<span class="enscript-keyword">if</span> (retval) {
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">return</span> (retval);
	}

	<span class="enscript-comment">/*
	 * Insert the protocol in the hash
	 */</span>
	prev_proto = SLIST_FIRST(&amp;ifp-&gt;if_proto_hash[hash_value]);
	<span class="enscript-keyword">while</span> (prev_proto != NULL &amp;&amp; SLIST_NEXT(prev_proto, next_hash) != NULL)
		prev_proto = SLIST_NEXT(prev_proto, next_hash);
	<span class="enscript-keyword">if</span> (prev_proto)
		SLIST_INSERT_AFTER(prev_proto, proto, next_hash);
	<span class="enscript-keyword">else</span>
		SLIST_INSERT_HEAD(&amp;ifp-&gt;if_proto_hash[hash_value],
		    proto, next_hash);

	<span class="enscript-comment">/* hold a proto refcnt for attach */</span>
	if_proto_ref(proto);

	<span class="enscript-comment">/*
	 * The reserved field carries the number of protocol still attached
	 * (subject to change)
	 */</span>
	ev_pr_data.proto_family = proto-&gt;protocol_family;
	ev_pr_data.proto_remaining_count = dlil_ifp_proto_count(ifp);
	ifnet_lock_done(ifp);

	dlil_post_msg(ifp, KEV_DL_SUBCLASS, KEV_DL_PROTO_ATTACHED,
	    (<span class="enscript-type">struct</span> net_event_data *)&amp;ev_pr_data,
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kev_dl_proto_data));
	<span class="enscript-keyword">return</span> (retval);
}

errno_t
<span class="enscript-function-name">ifnet_attach_protocol</span>(ifnet_t ifp, protocol_family_t protocol,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_attach_proto_param *proto_details)
{
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">struct</span> if_proto  *ifproto = NULL;

	ifnet_head_lock_shared();
	<span class="enscript-keyword">if</span> (ifp == NULL || protocol == 0 || proto_details == NULL) {
		retval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	<span class="enscript-comment">/* Check that the interface is in the global list */</span>
	<span class="enscript-keyword">if</span> (!ifnet_lookup(ifp)) {
		retval = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}

	ifproto = zalloc(dlif_proto_zone);
	<span class="enscript-keyword">if</span> (ifproto == NULL) {
		retval = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	bzero(ifproto, dlif_proto_size);

	<span class="enscript-comment">/* refcnt held above during lookup */</span>
	ifproto-&gt;ifp = ifp;
	ifproto-&gt;protocol_family = protocol;
	ifproto-&gt;proto_kpi = kProtoKPI_v1;
	ifproto-&gt;kpi.v1.input = proto_details-&gt;input;
	ifproto-&gt;kpi.v1.pre_output = proto_details-&gt;pre_output;
	ifproto-&gt;kpi.v1.event = proto_details-&gt;event;
	ifproto-&gt;kpi.v1.ioctl = proto_details-&gt;ioctl;
	ifproto-&gt;kpi.v1.detached = proto_details-&gt;detached;
	ifproto-&gt;kpi.v1.resolve_multi = proto_details-&gt;resolve;
	ifproto-&gt;kpi.v1.send_arp = proto_details-&gt;send_arp;

	retval = dlil_attach_protocol_internal(ifproto,
	    proto_details-&gt;demux_list, proto_details-&gt;demux_count);

	<span class="enscript-keyword">if</span> (dlil_verbose) {
		printf(<span class="enscript-string">&quot;%s: attached v1 protocol %d\n&quot;</span>, if_name(ifp),
		    protocol);
	}

<span class="enscript-reference">end</span>:
	<span class="enscript-keyword">if</span> (retval != 0 &amp;&amp; retval != EEXIST &amp;&amp; ifp != NULL) {
		DLIL_PRINTF(<span class="enscript-string">&quot;%s: failed to attach v1 protocol %d (err=%d)\n&quot;</span>,
		    if_name(ifp), protocol, retval);
	}
	ifnet_head_done();
	<span class="enscript-keyword">if</span> (retval != 0  &amp;&amp; ifproto != NULL)
		zfree(dlif_proto_zone, ifproto);
	<span class="enscript-keyword">return</span> (retval);
}

errno_t
<span class="enscript-function-name">ifnet_attach_protocol_v2</span>(ifnet_t ifp, protocol_family_t protocol,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_attach_proto_param_v2 *proto_details)
{
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">struct</span> if_proto  *ifproto = NULL;

	ifnet_head_lock_shared();
	<span class="enscript-keyword">if</span> (ifp == NULL || protocol == 0 || proto_details == NULL) {
		retval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	<span class="enscript-comment">/* Check that the interface is in the global list */</span>
	<span class="enscript-keyword">if</span> (!ifnet_lookup(ifp)) {
		retval = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}

	ifproto = zalloc(dlif_proto_zone);
	<span class="enscript-keyword">if</span> (ifproto == NULL) {
		retval = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	bzero(ifproto, <span class="enscript-keyword">sizeof</span>(*ifproto));

	<span class="enscript-comment">/* refcnt held above during lookup */</span>
	ifproto-&gt;ifp = ifp;
	ifproto-&gt;protocol_family = protocol;
	ifproto-&gt;proto_kpi = kProtoKPI_v2;
	ifproto-&gt;kpi.v2.input = proto_details-&gt;input;
	ifproto-&gt;kpi.v2.pre_output = proto_details-&gt;pre_output;
	ifproto-&gt;kpi.v2.event = proto_details-&gt;event;
	ifproto-&gt;kpi.v2.ioctl = proto_details-&gt;ioctl;
	ifproto-&gt;kpi.v2.detached = proto_details-&gt;detached;
	ifproto-&gt;kpi.v2.resolve_multi = proto_details-&gt;resolve;
	ifproto-&gt;kpi.v2.send_arp = proto_details-&gt;send_arp;

	retval = dlil_attach_protocol_internal(ifproto,
	    proto_details-&gt;demux_list, proto_details-&gt;demux_count);

	<span class="enscript-keyword">if</span> (dlil_verbose) {
		printf(<span class="enscript-string">&quot;%s: attached v2 protocol %d\n&quot;</span>, if_name(ifp),
		    protocol);
	}

<span class="enscript-reference">end</span>:
	<span class="enscript-keyword">if</span> (retval != 0 &amp;&amp; retval != EEXIST &amp;&amp; ifp != NULL) {
		DLIL_PRINTF(<span class="enscript-string">&quot;%s: failed to attach v2 protocol %d (err=%d)\n&quot;</span>,
		    if_name(ifp), protocol, retval);
	}
	ifnet_head_done();
	<span class="enscript-keyword">if</span> (retval != 0 &amp;&amp; ifproto != NULL)
		zfree(dlif_proto_zone, ifproto);
	<span class="enscript-keyword">return</span> (retval);
}

errno_t
<span class="enscript-function-name">ifnet_detach_protocol</span>(ifnet_t ifp, protocol_family_t proto_family)
{
	<span class="enscript-type">struct</span> if_proto *proto = NULL;
	<span class="enscript-type">int</span>	retval = 0;

	<span class="enscript-keyword">if</span> (ifp == NULL || proto_family == 0) {
		retval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}

	ifnet_lock_exclusive(ifp);
	<span class="enscript-comment">/* callee holds a proto refcnt upon success */</span>
	proto = find_attached_proto(ifp, proto_family);
	<span class="enscript-keyword">if</span> (proto == NULL) {
		retval = ENXIO;
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}

	<span class="enscript-comment">/* call family module del_proto */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_del_proto)
		ifp-&gt;if_del_proto(ifp, proto-&gt;protocol_family);

	SLIST_REMOVE(&amp;ifp-&gt;if_proto_hash[proto_hash_value(proto_family)],
	    proto, if_proto, next_hash);

	<span class="enscript-keyword">if</span> (proto-&gt;proto_kpi == kProtoKPI_v1) {
		proto-&gt;kpi.v1.input = ifproto_media_input_v1;
		proto-&gt;kpi.v1.pre_output= ifproto_media_preout;
		proto-&gt;kpi.v1.event = ifproto_media_event;
		proto-&gt;kpi.v1.ioctl = ifproto_media_ioctl;
		proto-&gt;kpi.v1.resolve_multi = ifproto_media_resolve_multi;
		proto-&gt;kpi.v1.send_arp = ifproto_media_send_arp;
	} <span class="enscript-keyword">else</span> {
		proto-&gt;kpi.v2.input = ifproto_media_input_v2;
		proto-&gt;kpi.v2.pre_output = ifproto_media_preout;
		proto-&gt;kpi.v2.event = ifproto_media_event;
		proto-&gt;kpi.v2.ioctl = ifproto_media_ioctl;
		proto-&gt;kpi.v2.resolve_multi = ifproto_media_resolve_multi;
		proto-&gt;kpi.v2.send_arp = ifproto_media_send_arp;
	}
	proto-&gt;detached = 1;
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">if</span> (dlil_verbose) {
		printf(<span class="enscript-string">&quot;%s: detached %s protocol %d\n&quot;</span>, if_name(ifp),
		    (proto-&gt;proto_kpi == kProtoKPI_v1) ?
		    <span class="enscript-string">&quot;v1&quot;</span> : <span class="enscript-string">&quot;v2&quot;</span>, proto_family);
	}

	<span class="enscript-comment">/* release proto refcnt held during protocol attach */</span>
	if_proto_free(proto);

	<span class="enscript-comment">/*
	 * Release proto refcnt held during lookup; the rest of
	 * protocol detach steps will happen when the last proto
	 * reference is released.
	 */</span>
	if_proto_free(proto);

<span class="enscript-reference">end</span>:
	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifproto_media_input_v1</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t protocol,
    <span class="enscript-type">struct</span> mbuf *packet, <span class="enscript-type">char</span> *header)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">protocol</span>, <span class="enscript-variable-name">packet</span>, <span class="enscript-variable-name">header</span>)
	<span class="enscript-keyword">return</span> (ENXIO);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifproto_media_input_v2</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t protocol,
    <span class="enscript-type">struct</span> mbuf *packet)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">protocol</span>, <span class="enscript-variable-name">packet</span>)
	<span class="enscript-keyword">return</span> (ENXIO);

}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifproto_media_preout</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t protocol,
    mbuf_t *packet, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *dest, <span class="enscript-type">void</span> *route, <span class="enscript-type">char</span> *frame_type,
    <span class="enscript-type">char</span> *link_layer_dest)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">protocol</span>, <span class="enscript-variable-name">packet</span>, <span class="enscript-variable-name">dest</span>, <span class="enscript-variable-name">route</span>, <span class="enscript-variable-name">frame_type</span>, <span class="enscript-variable-name">link_layer_dest</span>)
	<span class="enscript-keyword">return</span> (ENXIO);

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifproto_media_event</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t protocol,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> kev_msg *event)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">protocol</span>, <span class="enscript-variable-name">event</span>)
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifproto_media_ioctl</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t protocol,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> command, <span class="enscript-type">void</span> *argument)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">protocol</span>, <span class="enscript-variable-name">command</span>, <span class="enscript-variable-name">argument</span>)
	<span class="enscript-keyword">return</span> (ENXIO);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifproto_media_resolve_multi</span>(ifnet_t ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *proto_addr,
    <span class="enscript-type">struct</span> sockaddr_dl *out_ll, size_t ll_len)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">proto_addr</span>, <span class="enscript-variable-name">out_ll</span>, <span class="enscript-variable-name">ll_len</span>)
	<span class="enscript-keyword">return</span> (ENXIO);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifproto_media_send_arp</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_short arpop,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *sender_hw, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sender_proto,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *target_hw, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *target_proto)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">arpop</span>, <span class="enscript-variable-name">sender_hw</span>, <span class="enscript-variable-name">sender_proto</span>, <span class="enscript-variable-name">target_hw</span>, <span class="enscript-variable-name">target_proto</span>)
	<span class="enscript-keyword">return</span> (ENXIO);
}

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_next_index</span>(<span class="enscript-type">void</span>);

errno_t
<span class="enscript-function-name">ifnet_attach</span>(ifnet_t ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *ll_addr)
{
	<span class="enscript-type">struct</span> ifnet *tmp_if;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> if_data_internal if_data_saved;
	<span class="enscript-type">struct</span> dlil_ifnet *dl_if = (<span class="enscript-type">struct</span> dlil_ifnet *)ifp;
	<span class="enscript-type">struct</span> dlil_threading_info *dl_inp;
	u_int32_t sflags = 0;
	<span class="enscript-type">int</span> err;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/*
	 * Serialize ifnet attach using dlil_ifnet_lock, in order to
	 * prevent the interface from being configured while it is
	 * embryonic, as ifnet_head_lock is dropped and reacquired
	 * below prior to marking the ifnet with IFRF_ATTACHED.
	 */</span>
	dlil_if_lock();
	ifnet_head_lock_exclusive();
	<span class="enscript-comment">/* Verify we aren't already on the list */</span>
	TAILQ_FOREACH(tmp_if, &amp;ifnet_head, if_link) {
		<span class="enscript-keyword">if</span> (tmp_if == ifp) {
			ifnet_head_done();
			dlil_if_unlock();
			<span class="enscript-keyword">return</span> (EEXIST);
		}
	}

	lck_mtx_lock_spin(&amp;ifp-&gt;if_ref_lock);
	<span class="enscript-keyword">if</span> (ifp-&gt;if_refflags &amp; IFRF_ATTACHED) {
		panic_plain(<span class="enscript-string">&quot;%s: flags mismatch (attached set) ifp=%p&quot;</span>,
		    __func__, ifp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	lck_mtx_unlock(&amp;ifp-&gt;if_ref_lock);

	ifnet_lock_exclusive(ifp);

	<span class="enscript-comment">/* Sanity check */</span>
	VERIFY(ifp-&gt;if_detaching_link.tqe_next == NULL);
	VERIFY(ifp-&gt;if_detaching_link.tqe_prev == NULL);

	<span class="enscript-keyword">if</span> (ll_addr != NULL) {
		<span class="enscript-keyword">if</span> (ifp-&gt;if_addrlen == 0) {
			ifp-&gt;if_addrlen = ll_addr-&gt;sdl_alen;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ll_addr-&gt;sdl_alen != ifp-&gt;if_addrlen) {
			ifnet_lock_done(ifp);
			ifnet_head_done();
			dlil_if_unlock();
			<span class="enscript-keyword">return</span> (EINVAL);
		}
	}

	<span class="enscript-comment">/*
	 * Allow interfaces without protocol families to attach
	 * only if they have the necessary fields filled out.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_add_proto == NULL || ifp-&gt;if_del_proto == NULL) {
		DLIL_PRINTF(<span class="enscript-string">&quot;%s: Attempt to attach interface without &quot;</span>
		    <span class="enscript-string">&quot;family module - %d\n&quot;</span>, __func__, ifp-&gt;if_family);
		ifnet_lock_done(ifp);
		ifnet_head_done();
		dlil_if_unlock();
		<span class="enscript-keyword">return</span> (ENODEV);
	}

	<span class="enscript-comment">/* Allocate protocol hash table */</span>
	VERIFY(ifp-&gt;if_proto_hash == NULL);
	ifp-&gt;if_proto_hash = zalloc(dlif_phash_zone);
	<span class="enscript-keyword">if</span> (ifp-&gt;if_proto_hash == NULL) {
		ifnet_lock_done(ifp);
		ifnet_head_done();
		dlil_if_unlock();
		<span class="enscript-keyword">return</span> (ENOBUFS);
	}
	bzero(ifp-&gt;if_proto_hash, dlif_phash_size);

	lck_mtx_lock_spin(&amp;ifp-&gt;if_flt_lock);
	VERIFY(TAILQ_EMPTY(&amp;ifp-&gt;if_flt_head));
	TAILQ_INIT(&amp;ifp-&gt;if_flt_head);
	VERIFY(ifp-&gt;if_flt_busy == 0);
	VERIFY(ifp-&gt;if_flt_waiters == 0);
	lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

	VERIFY(TAILQ_EMPTY(&amp;ifp-&gt;if_prefixhead));
	TAILQ_INIT(&amp;ifp-&gt;if_prefixhead);

	<span class="enscript-keyword">if</span> (!(dl_if-&gt;dl_if_flags &amp; DLIF_REUSE)) {
		VERIFY(LIST_EMPTY(&amp;ifp-&gt;if_multiaddrs));
		LIST_INIT(&amp;ifp-&gt;if_multiaddrs);
	}

	VERIFY(ifp-&gt;if_allhostsinm == NULL);
	VERIFY(TAILQ_EMPTY(&amp;ifp-&gt;if_addrhead));
	TAILQ_INIT(&amp;ifp-&gt;if_addrhead);

	<span class="enscript-keyword">if</span> (ifp-&gt;if_index == 0) {
		<span class="enscript-type">int</span> idx = if_next_index();

		<span class="enscript-keyword">if</span> (idx == -1) {
			ifp-&gt;if_index = 0;
			ifnet_lock_done(ifp);
			ifnet_head_done();
			dlil_if_unlock();
			<span class="enscript-keyword">return</span> (ENOBUFS);
		}
		ifp-&gt;if_index = idx;
	}
	<span class="enscript-comment">/* There should not be anything occupying this slot */</span>
	VERIFY(ifindex2ifnet[ifp-&gt;if_index] == NULL);

	<span class="enscript-comment">/* allocate (if needed) and initialize a link address */</span>
	VERIFY(!(dl_if-&gt;dl_if_flags &amp; DLIF_REUSE) || ifp-&gt;if_lladdr != NULL);
	ifa = dlil_alloc_lladdr(ifp, ll_addr);
	<span class="enscript-keyword">if</span> (ifa == NULL) {
		ifnet_lock_done(ifp);
		ifnet_head_done();
		dlil_if_unlock();
		<span class="enscript-keyword">return</span> (ENOBUFS);
	}

	VERIFY(ifnet_addrs[ifp-&gt;if_index - 1] == NULL);
	ifnet_addrs[ifp-&gt;if_index - 1] = ifa;

	<span class="enscript-comment">/* make this address the first on the list */</span>
	IFA_LOCK(ifa);
	<span class="enscript-comment">/* hold a reference for ifnet_addrs[] */</span>
	IFA_ADDREF_LOCKED(ifa);
	<span class="enscript-comment">/* if_attach_link_ifa() holds a reference for ifa_link */</span>
	if_attach_link_ifa(ifp, ifa);
	IFA_UNLOCK(ifa);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	mac_ifnet_label_associate(ifp);
#<span class="enscript-reference">endif</span>

	TAILQ_INSERT_TAIL(&amp;ifnet_head, ifp, if_link);
	ifindex2ifnet[ifp-&gt;if_index] = ifp;

	<span class="enscript-comment">/* Hold a reference to the underlying dlil_ifnet */</span>
	ifnet_reference(ifp);

	<span class="enscript-comment">/* Clear stats (save and restore other fields that we care) */</span>
	if_data_saved = ifp-&gt;if_data;
	bzero(&amp;ifp-&gt;if_data, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_data));
	ifp-&gt;if_data.ifi_type = if_data_saved.ifi_type;
	ifp-&gt;if_data.ifi_typelen = if_data_saved.ifi_typelen;
	ifp-&gt;if_data.ifi_physical = if_data_saved.ifi_physical;
	ifp-&gt;if_data.ifi_addrlen = if_data_saved.ifi_addrlen;
	ifp-&gt;if_data.ifi_hdrlen = if_data_saved.ifi_hdrlen;
	ifp-&gt;if_data.ifi_mtu = if_data_saved.ifi_mtu;
	ifp-&gt;if_data.ifi_baudrate = if_data_saved.ifi_baudrate;
	ifp-&gt;if_data.ifi_hwassist = if_data_saved.ifi_hwassist;
	ifp-&gt;if_data.ifi_tso_v4_mtu = if_data_saved.ifi_tso_v4_mtu;
	ifp-&gt;if_data.ifi_tso_v6_mtu = if_data_saved.ifi_tso_v6_mtu;
	ifnet_touch_lastchange(ifp);

	VERIFY(ifp-&gt;if_output_sched_model == IFNET_SCHED_MODEL_NORMAL ||
	    ifp-&gt;if_output_sched_model == IFNET_SCHED_MODEL_DRIVER_MANAGED);

	<span class="enscript-comment">/* By default, use SFB and enable flow advisory */</span>
	sflags = PKTSCHEDF_QALG_SFB;
	<span class="enscript-keyword">if</span> (if_flowadv)
		sflags |= PKTSCHEDF_QALG_FLOWCTL;

	<span class="enscript-keyword">if</span> (if_delaybased_queue)
		sflags |= PKTSCHEDF_QALG_DELAYBASED;

	<span class="enscript-comment">/* Initialize transmit queue(s) */</span>
	err = ifclassq_setup(ifp, sflags, (dl_if-&gt;dl_if_flags &amp; DLIF_REUSE));
	<span class="enscript-keyword">if</span> (err != 0) {
		panic_plain(<span class="enscript-string">&quot;%s: ifp=%p couldn't initialize transmit queue; &quot;</span>
		    <span class="enscript-string">&quot;err=%d&quot;</span>, __func__, ifp, err);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/* Sanity checks on the input thread storage */</span>
	dl_inp = &amp;dl_if-&gt;dl_if_inpstorage;
	bzero(&amp;dl_inp-&gt;stats, <span class="enscript-keyword">sizeof</span> (dl_inp-&gt;stats));
	VERIFY(dl_inp-&gt;input_waiting == 0);
	VERIFY(dl_inp-&gt;wtot == 0);
	VERIFY(dl_inp-&gt;ifp == NULL);
	VERIFY(qhead(&amp;dl_inp-&gt;rcvq_pkts) == NULL &amp;&amp; qempty(&amp;dl_inp-&gt;rcvq_pkts));
	VERIFY(qlimit(&amp;dl_inp-&gt;rcvq_pkts) == 0);
	VERIFY(!dl_inp-&gt;net_affinity);
	VERIFY(ifp-&gt;if_inp == NULL);
	VERIFY(dl_inp-&gt;input_thr == THREAD_NULL);
	VERIFY(dl_inp-&gt;wloop_thr == THREAD_NULL);
	VERIFY(dl_inp-&gt;poll_thr == THREAD_NULL);
	VERIFY(dl_inp-&gt;tag == 0);
	VERIFY(dl_inp-&gt;mode == IFNET_MODEL_INPUT_POLL_OFF);
	bzero(&amp;dl_inp-&gt;tstats, <span class="enscript-keyword">sizeof</span> (dl_inp-&gt;tstats));
	bzero(&amp;dl_inp-&gt;pstats, <span class="enscript-keyword">sizeof</span> (dl_inp-&gt;pstats));
	bzero(&amp;dl_inp-&gt;sstats, <span class="enscript-keyword">sizeof</span> (dl_inp-&gt;sstats));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IFNET_INPUT_SANITY_CHK</span>
	VERIFY(dl_inp-&gt;input_mbuf_cnt == 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IFNET_INPUT_SANITY_CHK */</span>

	<span class="enscript-comment">/*
	 * A specific DLIL input thread is created per Ethernet/cellular
	 * interface or for an interface which supports opportunistic
	 * input polling.  Pseudo interfaces or other types of interfaces
	 * use the main input thread instead.
	 */</span>
	<span class="enscript-keyword">if</span> ((net_rxpoll &amp;&amp; (ifp-&gt;if_eflags &amp; IFEF_RXPOLL)) ||
	    ifp-&gt;if_type == IFT_ETHER || ifp-&gt;if_type == IFT_CELLULAR) {
		ifp-&gt;if_inp = dl_inp;
		err = dlil_create_input_thread(ifp, ifp-&gt;if_inp);
		<span class="enscript-keyword">if</span> (err != 0) {
			panic_plain(<span class="enscript-string">&quot;%s: ifp=%p couldn't get an input thread; &quot;</span>
			    <span class="enscript-string">&quot;err=%d&quot;</span>, __func__, ifp, err);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
	}

	<span class="enscript-comment">/*
	 * If the driver supports the new transmit model, calculate flow hash
	 * and create a workloop starter thread to invoke the if_start callback
	 * where the packets may be dequeued and transmitted.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_TXSTART) {
		ifp-&gt;if_flowhash = ifnet_calc_flowhash(ifp);
		VERIFY(ifp-&gt;if_flowhash != 0);

		VERIFY(ifp-&gt;if_start != NULL);
		VERIFY(ifp-&gt;if_start_thread == THREAD_NULL);

		ifnet_set_start_cycle(ifp, NULL);
		ifp-&gt;if_start_active = 0;
		ifp-&gt;if_start_req = 0;
		ifp-&gt;if_start_flags = 0;
		<span class="enscript-keyword">if</span> ((err = kernel_thread_start(ifnet_start_thread_fn, ifp,
		    &amp;ifp-&gt;if_start_thread)) != KERN_SUCCESS) {
			panic_plain(<span class="enscript-string">&quot;%s: ifp=%p couldn't get a start thread; &quot;</span>
			    <span class="enscript-string">&quot;err=%d&quot;</span>, __func__, ifp, err);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		ml_thread_policy(ifp-&gt;if_start_thread, MACHINE_GROUP,
		    (MACHINE_NETWORK_GROUP|MACHINE_NETWORK_WORKLOOP));
	} <span class="enscript-keyword">else</span> {
		ifp-&gt;if_flowhash = 0;
	}

	<span class="enscript-comment">/*
	 * If the driver supports the new receive model, create a poller
	 * thread to invoke if_input_poll callback where the packets may
	 * be dequeued from the driver and processed for reception.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_RXPOLL) {
		VERIFY(ifp-&gt;if_input_poll != NULL);
		VERIFY(ifp-&gt;if_input_ctl != NULL);
		VERIFY(ifp-&gt;if_poll_thread == THREAD_NULL);

		ifnet_set_poll_cycle(ifp, NULL);
		ifp-&gt;if_poll_update = 0;
		ifp-&gt;if_poll_active = 0;
		ifp-&gt;if_poll_req = 0;
		<span class="enscript-keyword">if</span> ((err = kernel_thread_start(ifnet_poll_thread_fn, ifp,
		    &amp;ifp-&gt;if_poll_thread)) != KERN_SUCCESS) {
			panic_plain(<span class="enscript-string">&quot;%s: ifp=%p couldn't get a poll thread; &quot;</span>
			    <span class="enscript-string">&quot;err=%d&quot;</span>, __func__, ifp, err);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		ml_thread_policy(ifp-&gt;if_poll_thread, MACHINE_GROUP,
		    (MACHINE_NETWORK_GROUP|MACHINE_NETWORK_WORKLOOP));
	}

	VERIFY(ifp-&gt;if_desc.ifd_maxlen == IF_DESCSIZE);
	VERIFY(ifp-&gt;if_desc.ifd_len == 0);
	VERIFY(ifp-&gt;if_desc.ifd_desc != NULL);

	<span class="enscript-comment">/* Record attach PC stacktrace */</span>
	ctrace_record(&amp;((<span class="enscript-type">struct</span> dlil_ifnet *)ifp)-&gt;dl_if_attach);

	ifp-&gt;if_updatemcasts = 0;
	<span class="enscript-keyword">if</span> (!LIST_EMPTY(&amp;ifp-&gt;if_multiaddrs)) {
		<span class="enscript-type">struct</span> ifmultiaddr *ifma;
		LIST_FOREACH(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link) {
			IFMA_LOCK(ifma);
			<span class="enscript-keyword">if</span> (ifma-&gt;ifma_addr-&gt;sa_family == AF_LINK ||
			    ifma-&gt;ifma_addr-&gt;sa_family == AF_UNSPEC)
				ifp-&gt;if_updatemcasts++;
			IFMA_UNLOCK(ifma);
		}

		printf(<span class="enscript-string">&quot;%s: attached with %d suspended link-layer multicast &quot;</span>
		    <span class="enscript-string">&quot;membership(s)\n&quot;</span>, if_name(ifp),
		    ifp-&gt;if_updatemcasts);
	}

	<span class="enscript-comment">/* Clear logging parameters */</span>
	bzero(&amp;ifp-&gt;if_log, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_log));
	ifp-&gt;if_fg_sendts = 0;

	VERIFY(ifp-&gt;if_delegated.ifp == NULL);
	VERIFY(ifp-&gt;if_delegated.type == 0);
	VERIFY(ifp-&gt;if_delegated.family == 0);
	VERIFY(ifp-&gt;if_delegated.subfamily == 0);
	VERIFY(ifp-&gt;if_delegated.expensive == 0);

	bzero(&amp;ifp-&gt;if_agentids, <span class="enscript-keyword">sizeof</span>(ifp-&gt;if_agentids));

	<span class="enscript-comment">/* Reset interface state */</span>
	bzero(&amp;ifp-&gt;if_interface_state, <span class="enscript-keyword">sizeof</span>(ifp-&gt;if_interface_state));
	ifp-&gt;if_interface_state.valid_bitmask |= 
		IF_INTERFACE_STATE_INTERFACE_AVAILABILITY_VALID;
	ifp-&gt;if_interface_state.interface_availability =
		IF_INTERFACE_STATE_INTERFACE_AVAILABLE;

	<span class="enscript-comment">/* Initialize Link Quality Metric (loopback [lo0] is always good) */</span>
	<span class="enscript-keyword">if</span> (ifp == lo_ifp) {
		ifp-&gt;if_interface_state.lqm_state = IFNET_LQM_THRESH_GOOD;
		ifp-&gt;if_interface_state.valid_bitmask |=
		    IF_INTERFACE_STATE_LQM_STATE_VALID;
	} <span class="enscript-keyword">else</span> {
		ifp-&gt;if_interface_state.lqm_state = IFNET_LQM_THRESH_UNKNOWN;
	}
	ifnet_lock_done(ifp);
	ifnet_head_done();

	lck_mtx_lock(&amp;ifp-&gt;if_cached_route_lock);
	<span class="enscript-comment">/* Enable forwarding cached route */</span>
	ifp-&gt;if_fwd_cacheok = 1;
	<span class="enscript-comment">/* Clean up any existing cached routes */</span>
	ROUTE_RELEASE(&amp;ifp-&gt;if_fwd_route);
	bzero(&amp;ifp-&gt;if_fwd_route, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_fwd_route));
	ROUTE_RELEASE(&amp;ifp-&gt;if_src_route);
	bzero(&amp;ifp-&gt;if_src_route, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_src_route));
	ROUTE_RELEASE(&amp;ifp-&gt;if_src_route6);
	bzero(&amp;ifp-&gt;if_src_route6, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_src_route6));
	lck_mtx_unlock(&amp;ifp-&gt;if_cached_route_lock);

	ifnet_llreach_ifattach(ifp, (dl_if-&gt;dl_if_flags &amp; DLIF_REUSE));

	<span class="enscript-comment">/*
	 * Allocate and attach IGMPv3/MLDv2 interface specific variables
	 * and trees; do this before the ifnet is marked as attached.
	 * The ifnet keeps the reference to the info structures even after
	 * the ifnet is detached, since the network-layer records still
	 * refer to the info structures even after that.  This also
	 * makes it possible for them to still function after the ifnet
	 * is recycled or reattached.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">if</span> (IGMP_IFINFO(ifp) == NULL) {
		IGMP_IFINFO(ifp) = igmp_domifattach(ifp, M_WAITOK);
		VERIFY(IGMP_IFINFO(ifp) != NULL);
	} <span class="enscript-keyword">else</span> {
		VERIFY(IGMP_IFINFO(ifp)-&gt;igi_ifp == ifp);
		igmp_domifreattach(IGMP_IFINFO(ifp));
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (MLD_IFINFO(ifp) == NULL) {
		MLD_IFINFO(ifp) = mld_domifattach(ifp, M_WAITOK);
		VERIFY(MLD_IFINFO(ifp) != NULL);
	} <span class="enscript-keyword">else</span> {
		VERIFY(MLD_IFINFO(ifp)-&gt;mli_ifp == ifp);
		mld_domifreattach(MLD_IFINFO(ifp));
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	VERIFY(ifp-&gt;if_data_threshold == 0);

	<span class="enscript-comment">/*
	 * Finally, mark this ifnet as attached.
	 */</span>
	lck_mtx_lock(rnh_lock);
	ifnet_lock_exclusive(ifp);
	lck_mtx_lock_spin(&amp;ifp-&gt;if_ref_lock);
	ifp-&gt;if_refflags = IFRF_ATTACHED;
	lck_mtx_unlock(&amp;ifp-&gt;if_ref_lock);
	<span class="enscript-keyword">if</span> (net_rtref) {
		<span class="enscript-comment">/* boot-args override; enable idle notification */</span>
		(<span class="enscript-type">void</span>) ifnet_set_idle_flags_locked(ifp, IFRF_IDLE_NOTIFY,
		    IFRF_IDLE_NOTIFY);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* apply previous request(s) to set the idle flags, if any */</span>
		(<span class="enscript-type">void</span>) ifnet_set_idle_flags_locked(ifp, ifp-&gt;if_idle_new_flags,
		    ifp-&gt;if_idle_new_flags_mask);

	}
	ifnet_lock_done(ifp);
	lck_mtx_unlock(rnh_lock);
	dlil_if_unlock();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	<span class="enscript-comment">/*
	 * Attach packet filter to this interface, if enabled.
	 */</span>
	pf_ifnet_hook(ifp, 1);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

	dlil_post_msg(ifp, KEV_DL_SUBCLASS, KEV_DL_IF_ATTACHED, NULL, 0);

	<span class="enscript-keyword">if</span> (dlil_verbose) {
		printf(<span class="enscript-string">&quot;%s: attached%s\n&quot;</span>, if_name(ifp),
		    (dl_if-&gt;dl_if_flags &amp; DLIF_REUSE) ? <span class="enscript-string">&quot; (recycled)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Prepare the storage for the first/permanent link address, which must
 * must have the same lifetime as the ifnet itself.  Although the link
 * address gets removed from if_addrhead and ifnet_addrs[] at detach time,
 * its location in memory must never change as it may still be referred
 * to by some parts of the system afterwards (unfortunate implementation
 * artifacts inherited from BSD.)
 *
 * Caller must hold ifnet lock as writer.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">dlil_alloc_lladdr</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *ll_addr)
{
	<span class="enscript-type">struct</span> ifaddr *ifa, *oifa;
	<span class="enscript-type">struct</span> sockaddr_dl *asdl, *msdl;
	<span class="enscript-type">char</span> workbuf[IFNAMSIZ*2];
	<span class="enscript-type">int</span> namelen, masklen, socksize;
	<span class="enscript-type">struct</span> dlil_ifnet *dl_if = (<span class="enscript-type">struct</span> dlil_ifnet *)ifp;

	ifnet_lock_assert(ifp, IFNET_LCK_ASSERT_EXCLUSIVE);
	VERIFY(ll_addr == NULL || ll_addr-&gt;sdl_alen == ifp-&gt;if_addrlen);

	namelen = snprintf(workbuf, <span class="enscript-keyword">sizeof</span> (workbuf), <span class="enscript-string">&quot;%s&quot;</span>,
	    if_name(ifp));
	masklen = offsetof(<span class="enscript-type">struct</span> sockaddr_dl, sdl_data[0]) + namelen;
	socksize = masklen + ifp-&gt;if_addrlen;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ROUNDUP</span>(a) (1 + (((a) - 1) | (sizeof (u_int32_t) - 1)))
	<span class="enscript-keyword">if</span> ((u_int32_t)socksize &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_dl))
		socksize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_dl);
	socksize = ROUNDUP(socksize);
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ROUNDUP</span>

	ifa = ifp-&gt;if_lladdr;
	<span class="enscript-keyword">if</span> (socksize &gt; DLIL_SDLMAXLEN ||
	    (ifa != NULL &amp;&amp; ifa != &amp;dl_if-&gt;dl_if_lladdr.ifa)) {
		<span class="enscript-comment">/*
		 * Rare, but in the event that the link address requires
		 * more storage space than DLIL_SDLMAXLEN, allocate the
		 * largest possible storages for address and mask, such
		 * that we can reuse the same space when if_addrlen grows.
		 * This same space will be used when if_addrlen shrinks.
		 */</span>
		<span class="enscript-keyword">if</span> (ifa == NULL || ifa == &amp;dl_if-&gt;dl_if_lladdr.ifa) {
			<span class="enscript-type">int</span> ifasize = <span class="enscript-keyword">sizeof</span> (*ifa) + 2 * SOCK_MAXADDRLEN;
			ifa = _MALLOC(ifasize, M_IFADDR, M_WAITOK | M_ZERO);
			<span class="enscript-keyword">if</span> (ifa == NULL)
				<span class="enscript-keyword">return</span> (NULL);
			ifa_lock_init(ifa);
			<span class="enscript-comment">/* Don't set IFD_ALLOC, as this is permanent */</span>
			ifa-&gt;ifa_debug = IFD_LINK;
		}
		IFA_LOCK(ifa);
		<span class="enscript-comment">/* address and mask sockaddr_dl locations */</span>
		asdl = (<span class="enscript-type">struct</span> sockaddr_dl *)(ifa + 1);
		bzero(asdl, SOCK_MAXADDRLEN);
		msdl = (<span class="enscript-type">struct</span> sockaddr_dl *)(<span class="enscript-type">void</span> *)
		    ((<span class="enscript-type">char</span> *)asdl + SOCK_MAXADDRLEN);
		bzero(msdl, SOCK_MAXADDRLEN);
	} <span class="enscript-keyword">else</span> {
		VERIFY(ifa == NULL || ifa == &amp;dl_if-&gt;dl_if_lladdr.ifa);
		<span class="enscript-comment">/*
		 * Use the storage areas for address and mask within the
		 * dlil_ifnet structure.  This is the most common case.
		 */</span>
		<span class="enscript-keyword">if</span> (ifa == NULL) {
			ifa = &amp;dl_if-&gt;dl_if_lladdr.ifa;
			ifa_lock_init(ifa);
			<span class="enscript-comment">/* Don't set IFD_ALLOC, as this is permanent */</span>
			ifa-&gt;ifa_debug = IFD_LINK;
		}
		IFA_LOCK(ifa);
		<span class="enscript-comment">/* address and mask sockaddr_dl locations */</span>
		asdl = (<span class="enscript-type">struct</span> sockaddr_dl *)(<span class="enscript-type">void</span> *)&amp;dl_if-&gt;dl_if_lladdr.asdl;
		bzero(asdl, <span class="enscript-keyword">sizeof</span> (dl_if-&gt;dl_if_lladdr.asdl));
		msdl = (<span class="enscript-type">struct</span> sockaddr_dl *)(<span class="enscript-type">void</span> *)&amp;dl_if-&gt;dl_if_lladdr.msdl;
		bzero(msdl, <span class="enscript-keyword">sizeof</span> (dl_if-&gt;dl_if_lladdr.msdl));
	}

	<span class="enscript-comment">/* hold a permanent reference for the ifnet itself */</span>
	IFA_ADDREF_LOCKED(ifa);
	oifa = ifp-&gt;if_lladdr;
	ifp-&gt;if_lladdr = ifa;

	VERIFY(ifa-&gt;ifa_debug == IFD_LINK);
	ifa-&gt;ifa_ifp = ifp;
	ifa-&gt;ifa_rtrequest = link_rtrequest;
	ifa-&gt;ifa_addr = (<span class="enscript-type">struct</span> sockaddr *)asdl;
	asdl-&gt;sdl_len = socksize;
	asdl-&gt;sdl_family = AF_LINK;
	bcopy(workbuf, asdl-&gt;sdl_data, namelen);
	asdl-&gt;sdl_nlen = namelen;
	asdl-&gt;sdl_index = ifp-&gt;if_index;
	asdl-&gt;sdl_type = ifp-&gt;if_type;
	<span class="enscript-keyword">if</span> (ll_addr != NULL) {
		asdl-&gt;sdl_alen = ll_addr-&gt;sdl_alen;
		bcopy(CONST_LLADDR(ll_addr), LLADDR(asdl), asdl-&gt;sdl_alen);
	} <span class="enscript-keyword">else</span> {
		asdl-&gt;sdl_alen = 0;
	}
	ifa-&gt;ifa_netmask = (<span class="enscript-type">struct</span> sockaddr*)msdl;
	msdl-&gt;sdl_len = masklen;
	<span class="enscript-keyword">while</span> (namelen != 0)
		msdl-&gt;sdl_data[--namelen] = 0xff;
	IFA_UNLOCK(ifa);

	<span class="enscript-keyword">if</span> (oifa != NULL)
		IFA_REMREF(oifa);

	<span class="enscript-keyword">return</span> (ifa);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">if_purgeaddrs</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	in_purgeaddrs(ifp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	in6_purgeaddrs(ifp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
}

errno_t
<span class="enscript-function-name">ifnet_detach</span>(ifnet_t ifp)
{
	<span class="enscript-type">struct</span> ifnet *delegated_ifp;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	lck_mtx_lock(rnh_lock);
	ifnet_head_lock_exclusive();
	ifnet_lock_exclusive(ifp);

	<span class="enscript-comment">/*
	 * Check to see if this interface has previously triggered
	 * aggressive protocol draining; if so, decrement the global
	 * refcnt and clear PR_AGGDRAIN on the route domain if
	 * there are no more of such an interface around.
	 */</span>
	(<span class="enscript-type">void</span>) ifnet_set_idle_flags_locked(ifp, 0, ~0);

	lck_mtx_lock_spin(&amp;ifp-&gt;if_ref_lock);
	 <span class="enscript-keyword">if</span> (!(ifp-&gt;if_refflags &amp; IFRF_ATTACHED)) {
		lck_mtx_unlock(&amp;ifp-&gt;if_ref_lock);
		ifnet_lock_done(ifp);
		ifnet_head_done();
		lck_mtx_unlock(rnh_lock);
		<span class="enscript-keyword">return</span> (EINVAL);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp-&gt;if_refflags &amp; IFRF_DETACHING) {
		<span class="enscript-comment">/* Interface has already been detached */</span>
		lck_mtx_unlock(&amp;ifp-&gt;if_ref_lock);
		ifnet_lock_done(ifp);
		ifnet_head_done();
		lck_mtx_unlock(rnh_lock);
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	<span class="enscript-comment">/* Indicate this interface is being detached */</span>
	ifp-&gt;if_refflags &amp;= ~IFRF_ATTACHED;
	ifp-&gt;if_refflags |= IFRF_DETACHING;
	lck_mtx_unlock(&amp;ifp-&gt;if_ref_lock);

	<span class="enscript-keyword">if</span> (dlil_verbose)
		printf(<span class="enscript-string">&quot;%s: detaching\n&quot;</span>, if_name(ifp));

	<span class="enscript-comment">/*
	 * Remove ifnet from the ifnet_head, ifindex2ifnet[]; it will
	 * no longer be visible during lookups from this point.
	 */</span>
	VERIFY(ifindex2ifnet[ifp-&gt;if_index] == ifp);
	TAILQ_REMOVE(&amp;ifnet_head, ifp, if_link);
	ifp-&gt;if_link.tqe_next = NULL;
	ifp-&gt;if_link.tqe_prev = NULL;
	ifindex2ifnet[ifp-&gt;if_index] = NULL;

	<span class="enscript-comment">/* 18717626 - reset IFEF_IPV4_ROUTER and IFEF_IPV6_ROUTER */</span>
	ifp-&gt;if_eflags &amp;= ~(IFEF_IPV4_ROUTER | IFEF_IPV6_ROUTER);

	<span class="enscript-comment">/* Record detach PC stacktrace */</span>
	ctrace_record(&amp;((<span class="enscript-type">struct</span> dlil_ifnet *)ifp)-&gt;dl_if_detach);

	<span class="enscript-comment">/* Clear logging parameters */</span>
	bzero(&amp;ifp-&gt;if_log, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_log));

	<span class="enscript-comment">/* Clear delegated interface info (reference released below) */</span>
	delegated_ifp = ifp-&gt;if_delegated.ifp;
	bzero(&amp;ifp-&gt;if_delegated, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_delegated));

	<span class="enscript-comment">/* Reset interface state */</span>
	bzero(&amp;ifp-&gt;if_interface_state, <span class="enscript-keyword">sizeof</span>(ifp-&gt;if_interface_state));

	ifnet_lock_done(ifp);
	ifnet_head_done();
	lck_mtx_unlock(rnh_lock);

	<span class="enscript-comment">/* Release reference held on the delegated interface */</span>
	<span class="enscript-keyword">if</span> (delegated_ifp != NULL)
		ifnet_release(delegated_ifp);

	<span class="enscript-comment">/* Reset Link Quality Metric (unless loopback [lo0]) */</span>
	<span class="enscript-keyword">if</span> (ifp != lo_ifp)
		if_lqm_update(ifp, IFNET_LQM_THRESH_OFF, 0);

	<span class="enscript-comment">/* Reset TCP local statistics */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_tcp_stat != NULL)
		bzero(ifp-&gt;if_tcp_stat, <span class="enscript-keyword">sizeof</span>(*ifp-&gt;if_tcp_stat));

	<span class="enscript-comment">/* Reset UDP local statistics */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_udp_stat != NULL)
		bzero(ifp-&gt;if_udp_stat, <span class="enscript-keyword">sizeof</span>(*ifp-&gt;if_udp_stat));

	<span class="enscript-comment">/* Release memory held for interface link status report */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_link_status != NULL) {
		FREE(ifp-&gt;if_link_status, M_TEMP);
		ifp-&gt;if_link_status = NULL;
	}

	<span class="enscript-comment">/* Let BPF know we're detaching */</span>
	bpfdetach(ifp);

	<span class="enscript-comment">/* Mark the interface as DOWN */</span>
	if_down(ifp);

	<span class="enscript-comment">/* Disable forwarding cached route */</span>
	lck_mtx_lock(&amp;ifp-&gt;if_cached_route_lock);
	ifp-&gt;if_fwd_cacheok = 0;
	lck_mtx_unlock(&amp;ifp-&gt;if_cached_route_lock);

	ifp-&gt;if_data_threshold = 0;
	<span class="enscript-comment">/*
	 * Drain any deferred IGMPv3/MLDv2 query responses, but keep the
	 * references to the info structures and leave them attached to
	 * this ifnet.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	igmp_domifdetach(ifp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	mld_domifdetach(ifp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	dlil_post_msg(ifp, KEV_DL_SUBCLASS, KEV_DL_IF_DETACHING, NULL, 0);

	<span class="enscript-comment">/* Let worker thread take care of the rest, to avoid reentrancy */</span>
	dlil_if_lock();
	ifnet_detaching_enqueue(ifp);
	dlil_if_unlock();

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_detaching_enqueue</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	dlil_if_lock_assert();

	++ifnet_detaching_cnt;
	VERIFY(ifnet_detaching_cnt != 0);
	TAILQ_INSERT_TAIL(&amp;ifnet_detaching_head, ifp, if_detaching_link);
	wakeup((caddr_t)&amp;ifnet_delayed_run);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifnet *
<span class="enscript-function-name">ifnet_detaching_dequeue</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> ifnet *ifp;

	dlil_if_lock_assert();

	ifp = TAILQ_FIRST(&amp;ifnet_detaching_head);
	VERIFY(ifnet_detaching_cnt != 0 || ifp == NULL);
	<span class="enscript-keyword">if</span> (ifp != NULL) {
		VERIFY(ifnet_detaching_cnt != 0);
		--ifnet_detaching_cnt;
		TAILQ_REMOVE(&amp;ifnet_detaching_head, ifp, if_detaching_link);
		ifp-&gt;if_detaching_link.tqe_next = NULL;
		ifp-&gt;if_detaching_link.tqe_prev = NULL;
	}
	<span class="enscript-keyword">return</span> (ifp);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ifnet_detacher_thread_cont</span>(<span class="enscript-type">int</span> err)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">err</span>)
	<span class="enscript-type">struct</span> ifnet *ifp;

	<span class="enscript-keyword">for</span> (;;) {
		dlil_if_lock_assert();
		<span class="enscript-keyword">while</span> (ifnet_detaching_cnt == 0) {
			(<span class="enscript-type">void</span>) msleep0(&amp;ifnet_delayed_run, &amp;dlil_ifnet_lock,
			    (PZERO - 1), <span class="enscript-string">&quot;ifnet_detacher_cont&quot;</span>, 0,
			    ifnet_detacher_thread_cont);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}

		VERIFY(TAILQ_FIRST(&amp;ifnet_detaching_head) != NULL);

		<span class="enscript-comment">/* Take care of detaching ifnet */</span>
		ifp = ifnet_detaching_dequeue();
		<span class="enscript-keyword">if</span> (ifp != NULL) {
			dlil_if_unlock();
			ifnet_detach_final(ifp);
			dlil_if_lock();
		}
	}
	<span class="enscript-comment">/* NOTREACHED */</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_detacher_thread_func</span>(<span class="enscript-type">void</span> *v, wait_result_t w)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">v</span>, <span class="enscript-variable-name">w</span>)
	dlil_if_lock();
	(<span class="enscript-type">void</span>) msleep0(&amp;ifnet_delayed_run, &amp;dlil_ifnet_lock,
	    (PZERO - 1), <span class="enscript-string">&quot;ifnet_detacher&quot;</span>, 0, ifnet_detacher_thread_cont);
	<span class="enscript-comment">/*
	 * msleep0() shouldn't have returned as PCATCH was not set;
	 * therefore assert in this case.
	 */</span>
	dlil_if_unlock();
	VERIFY(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_detach_final</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> ifnet_filter *filter, *filter_next;
	<span class="enscript-type">struct</span> ifnet_filter_head fhead;
	<span class="enscript-type">struct</span> dlil_threading_info *inp;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	ifnet_detached_func if_free;
	<span class="enscript-type">int</span> i;

	lck_mtx_lock(&amp;ifp-&gt;if_ref_lock);
	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_refflags &amp; IFRF_DETACHING)) {
		panic(<span class="enscript-string">&quot;%s: flags mismatch (detaching not set) ifp=%p&quot;</span>,
		    __func__, ifp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/*
	 * Wait until the existing IO references get released
	 * before we proceed with ifnet_detach.  This is not a
	 * common case, so block without using a continuation.
	 */</span>
	<span class="enscript-keyword">while</span> (ifp-&gt;if_refio &gt; 0) {
		printf(<span class="enscript-string">&quot;%s: Waiting for IO references on %s interface &quot;</span>
		    <span class="enscript-string">&quot;to be released\n&quot;</span>, __func__, if_name(ifp));
		(<span class="enscript-type">void</span>) msleep(&amp;(ifp-&gt;if_refio), &amp;ifp-&gt;if_ref_lock,
			(PZERO - 1), <span class="enscript-string">&quot;ifnet_ioref_wait&quot;</span>, NULL);
	}
	lck_mtx_unlock(&amp;ifp-&gt;if_ref_lock);

	<span class="enscript-comment">/* Drain and destroy send queue */</span>
	ifclassq_teardown(ifp);

	<span class="enscript-comment">/* Detach interface filters */</span>
	lck_mtx_lock(&amp;ifp-&gt;if_flt_lock);
	if_flt_monitor_enter(ifp);

	lck_mtx_assert(&amp;ifp-&gt;if_flt_lock, LCK_MTX_ASSERT_OWNED);
	fhead = ifp-&gt;if_flt_head;
	TAILQ_INIT(&amp;ifp-&gt;if_flt_head);

	<span class="enscript-keyword">for</span> (filter = TAILQ_FIRST(&amp;fhead); filter; filter = filter_next) {
		filter_next = TAILQ_NEXT(filter, filt_next);
		lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

		dlil_detach_filter_internal(filter, 1);
		lck_mtx_lock(&amp;ifp-&gt;if_flt_lock);
	}
	if_flt_monitor_leave(ifp);
	lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

	<span class="enscript-comment">/* Tell upper layers to drop their network addresses */</span>
	if_purgeaddrs(ifp);

	ifnet_lock_exclusive(ifp);

	<span class="enscript-comment">/* Uplumb all protocols */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; PROTO_HASH_SLOTS; i++) {
		<span class="enscript-type">struct</span> if_proto *proto;

		proto = SLIST_FIRST(&amp;ifp-&gt;if_proto_hash[i]);
		<span class="enscript-keyword">while</span> (proto != NULL) {
			protocol_family_t family = proto-&gt;protocol_family;
			ifnet_lock_done(ifp);
			proto_unplumb(family, ifp);
			ifnet_lock_exclusive(ifp);
			proto = SLIST_FIRST(&amp;ifp-&gt;if_proto_hash[i]);
		}
		<span class="enscript-comment">/* There should not be any protocols left */</span>
		VERIFY(SLIST_EMPTY(&amp;ifp-&gt;if_proto_hash[i]));
	}
	zfree(dlif_phash_zone, ifp-&gt;if_proto_hash);
	ifp-&gt;if_proto_hash = NULL;

	<span class="enscript-comment">/* Detach (permanent) link address from if_addrhead */</span>
	ifa = TAILQ_FIRST(&amp;ifp-&gt;if_addrhead);
	VERIFY(ifnet_addrs[ifp-&gt;if_index - 1] == ifa);
	IFA_LOCK(ifa);
	if_detach_link_ifa(ifp, ifa);
	IFA_UNLOCK(ifa);

	<span class="enscript-comment">/* Remove (permanent) link address from ifnet_addrs[] */</span>
	IFA_REMREF(ifa);
	ifnet_addrs[ifp-&gt;if_index - 1] = NULL;

	<span class="enscript-comment">/* This interface should not be on {ifnet_head,detaching} */</span>
	VERIFY(ifp-&gt;if_link.tqe_next == NULL);
	VERIFY(ifp-&gt;if_link.tqe_prev == NULL);
	VERIFY(ifp-&gt;if_detaching_link.tqe_next == NULL);
	VERIFY(ifp-&gt;if_detaching_link.tqe_prev == NULL);

	<span class="enscript-comment">/* Prefix list should be empty by now */</span>
	VERIFY(TAILQ_EMPTY(&amp;ifp-&gt;if_prefixhead));

	<span class="enscript-comment">/* The slot should have been emptied */</span>
	VERIFY(ifindex2ifnet[ifp-&gt;if_index] == NULL);

	<span class="enscript-comment">/* There should not be any addresses left */</span>
	VERIFY(TAILQ_EMPTY(&amp;ifp-&gt;if_addrhead));

	<span class="enscript-comment">/*
	 * Signal the starter thread to terminate itself.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_start_thread != THREAD_NULL) {
		lck_mtx_lock_spin(&amp;ifp-&gt;if_start_lock);
		ifp-&gt;if_start_flags = 0;
		ifp-&gt;if_start_thread = THREAD_NULL;
		wakeup_one((caddr_t)&amp;ifp-&gt;if_start_thread);
		lck_mtx_unlock(&amp;ifp-&gt;if_start_lock);
	}

	<span class="enscript-comment">/*
	 * Signal the poller thread to terminate itself.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_poll_thread != THREAD_NULL) {
		lck_mtx_lock_spin(&amp;ifp-&gt;if_poll_lock);
		ifp-&gt;if_poll_thread = THREAD_NULL;
		wakeup_one((caddr_t)&amp;ifp-&gt;if_poll_thread);
		lck_mtx_unlock(&amp;ifp-&gt;if_poll_lock);
	}

	<span class="enscript-comment">/*
	 * If thread affinity was set for the workloop thread, we will need
	 * to tear down the affinity and release the extra reference count
	 * taken at attach time.  Does not apply to lo0 or other interfaces
	 * without dedicated input threads.
	 */</span>
	<span class="enscript-keyword">if</span> ((inp = ifp-&gt;if_inp) != NULL) {
		VERIFY(inp != dlil_main_input_thread);

		<span class="enscript-keyword">if</span> (inp-&gt;net_affinity) {
			<span class="enscript-type">struct</span> thread *tp, *wtp, *ptp;

			lck_mtx_lock_spin(&amp;inp-&gt;input_lck);
			wtp = inp-&gt;wloop_thr;
			inp-&gt;wloop_thr = THREAD_NULL;
			ptp = inp-&gt;poll_thr;
			inp-&gt;poll_thr = THREAD_NULL;
			tp = inp-&gt;input_thr;	<span class="enscript-comment">/* don't nullify now */</span>
			inp-&gt;tag = 0;
			inp-&gt;net_affinity = FALSE;
			lck_mtx_unlock(&amp;inp-&gt;input_lck);

			<span class="enscript-comment">/* Tear down poll thread affinity */</span>
			<span class="enscript-keyword">if</span> (ptp != NULL) {
				VERIFY(ifp-&gt;if_eflags &amp; IFEF_RXPOLL);
				(<span class="enscript-type">void</span>) dlil_affinity_set(ptp,
				    THREAD_AFFINITY_TAG_NULL);
				thread_deallocate(ptp);
			}

			<span class="enscript-comment">/* Tear down workloop thread affinity */</span>
			<span class="enscript-keyword">if</span> (wtp != NULL) {
				(<span class="enscript-type">void</span>) dlil_affinity_set(wtp,
				    THREAD_AFFINITY_TAG_NULL);
				thread_deallocate(wtp);
			}

			<span class="enscript-comment">/* Tear down DLIL input thread affinity */</span>
			(<span class="enscript-type">void</span>) dlil_affinity_set(tp, THREAD_AFFINITY_TAG_NULL);
			thread_deallocate(tp);
		}

		<span class="enscript-comment">/* disassociate ifp DLIL input thread */</span>
		ifp-&gt;if_inp = NULL;

		lck_mtx_lock_spin(&amp;inp-&gt;input_lck);
		inp-&gt;input_waiting |= DLIL_INPUT_TERMINATE;
		<span class="enscript-keyword">if</span> (!(inp-&gt;input_waiting &amp; DLIL_INPUT_RUNNING)) {
			wakeup_one((caddr_t)&amp;inp-&gt;input_waiting);
		}
		lck_mtx_unlock(&amp;inp-&gt;input_lck);
	}

	<span class="enscript-comment">/* The driver might unload, so point these to ourselves */</span>
	if_free = ifp-&gt;if_free;
	ifp-&gt;if_output = ifp_if_output;
	ifp-&gt;if_pre_enqueue = ifp_if_output;
	ifp-&gt;if_start = ifp_if_start;
	ifp-&gt;if_output_ctl = ifp_if_ctl;
	ifp-&gt;if_input_poll = ifp_if_input_poll;
	ifp-&gt;if_input_ctl = ifp_if_ctl;
	ifp-&gt;if_ioctl = ifp_if_ioctl;
	ifp-&gt;if_set_bpf_tap = ifp_if_set_bpf_tap;
	ifp-&gt;if_free = ifp_if_free;
	ifp-&gt;if_demux = ifp_if_demux;
	ifp-&gt;if_event = ifp_if_event;
	ifp-&gt;if_framer_legacy = ifp_if_framer;
	ifp-&gt;if_framer = ifp_if_framer_extended;
	ifp-&gt;if_add_proto = ifp_if_add_proto;
	ifp-&gt;if_del_proto = ifp_if_del_proto;
	ifp-&gt;if_check_multi = ifp_if_check_multi;

	<span class="enscript-comment">/* wipe out interface description */</span>
	VERIFY(ifp-&gt;if_desc.ifd_maxlen == IF_DESCSIZE);
	ifp-&gt;if_desc.ifd_len = 0;
	VERIFY(ifp-&gt;if_desc.ifd_desc != NULL);
	bzero(ifp-&gt;if_desc.ifd_desc, IF_DESCSIZE);

	<span class="enscript-comment">/* there shouldn't be any delegation by now */</span>
	VERIFY(ifp-&gt;if_delegated.ifp == NULL);
	VERIFY(ifp-&gt;if_delegated.type == 0);
	VERIFY(ifp-&gt;if_delegated.family == 0);
	VERIFY(ifp-&gt;if_delegated.subfamily == 0);
	VERIFY(ifp-&gt;if_delegated.expensive == 0);

	ifnet_lock_done(ifp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	<span class="enscript-comment">/*
	 * Detach this interface from packet filter, if enabled.
	 */</span>
	pf_ifnet_hook(ifp, 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

	<span class="enscript-comment">/* Filter list should be empty */</span>
	lck_mtx_lock_spin(&amp;ifp-&gt;if_flt_lock);
	VERIFY(TAILQ_EMPTY(&amp;ifp-&gt;if_flt_head));
	VERIFY(ifp-&gt;if_flt_busy == 0);
	VERIFY(ifp-&gt;if_flt_waiters == 0);
	lck_mtx_unlock(&amp;ifp-&gt;if_flt_lock);

	<span class="enscript-comment">/* Last chance to drain send queue */</span>
	if_qflush(ifp, 0);

	<span class="enscript-comment">/* Last chance to cleanup any cached route */</span>
	lck_mtx_lock(&amp;ifp-&gt;if_cached_route_lock);
	VERIFY(!ifp-&gt;if_fwd_cacheok);
	ROUTE_RELEASE(&amp;ifp-&gt;if_fwd_route);
	bzero(&amp;ifp-&gt;if_fwd_route, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_fwd_route));
	ROUTE_RELEASE(&amp;ifp-&gt;if_src_route);
	bzero(&amp;ifp-&gt;if_src_route, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_src_route));
	ROUTE_RELEASE(&amp;ifp-&gt;if_src_route6);
	bzero(&amp;ifp-&gt;if_src_route6, <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_src_route6));
	lck_mtx_unlock(&amp;ifp-&gt;if_cached_route_lock);

	VERIFY(ifp-&gt;if_data_threshold == 0);

	ifnet_llreach_ifdetach(ifp);

	dlil_post_msg(ifp, KEV_DL_SUBCLASS, KEV_DL_IF_DETACHED, NULL, 0);

	<span class="enscript-keyword">if</span> (if_free != NULL)
		if_free(ifp);

	<span class="enscript-comment">/*
	 * Finally, mark this ifnet as detached.
	 */</span>
	lck_mtx_lock_spin(&amp;ifp-&gt;if_ref_lock);
	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_refflags &amp; IFRF_DETACHING)) {
		panic(<span class="enscript-string">&quot;%s: flags mismatch (detaching not set) ifp=%p&quot;</span>,
		    __func__, ifp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	ifp-&gt;if_refflags &amp;= ~IFRF_DETACHING;
	lck_mtx_unlock(&amp;ifp-&gt;if_ref_lock);

	<span class="enscript-keyword">if</span> (dlil_verbose)
		printf(<span class="enscript-string">&quot;%s: detached\n&quot;</span>, if_name(ifp));

	<span class="enscript-comment">/* Release reference held during ifnet attach */</span>
	ifnet_release(ifp);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifp_if_output</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>)
	m_freem(m);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifp_if_start</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	ifnet_purge(ifp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifp_if_input_poll</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t flags, u_int32_t max_cnt,
    <span class="enscript-type">struct</span> mbuf **m_head, <span class="enscript-type">struct</span> mbuf **m_tail, u_int32_t *cnt, u_int32_t *len)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">flags</span>, <span class="enscript-variable-name">max_cnt</span>)
	<span class="enscript-keyword">if</span> (m_head != NULL)
		*m_head = NULL;
	<span class="enscript-keyword">if</span> (m_tail != NULL)
		*m_tail = NULL;
	<span class="enscript-keyword">if</span> (cnt != NULL)
		*cnt = 0;
	<span class="enscript-keyword">if</span> (len != NULL)
		*len = 0;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifp_if_ctl</span>(<span class="enscript-type">struct</span> ifnet *ifp, ifnet_ctl_cmd_t cmd, u_int32_t arglen, <span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">cmd</span>, <span class="enscript-variable-name">arglen</span>, <span class="enscript-variable-name">arg</span>)
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifp_if_demux</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">char</span> *fh, protocol_family_t *pf)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">fh</span>, <span class="enscript-variable-name">pf</span>)
	m_freem(m);
	<span class="enscript-keyword">return</span> (EJUSTRETURN);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifp_if_add_proto</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t pf,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_demux_desc *da, u_int32_t dc)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">pf</span>, <span class="enscript-variable-name">da</span>, <span class="enscript-variable-name">dc</span>)
	<span class="enscript-keyword">return</span> (EINVAL);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifp_if_del_proto</span>(<span class="enscript-type">struct</span> ifnet *ifp, protocol_family_t pf)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">pf</span>)
	<span class="enscript-keyword">return</span> (EINVAL);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifp_if_check_multi</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sa)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">sa</span>)
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifp_if_framer</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf **m,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sa, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ll, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *t)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">m</span>, <span class="enscript-variable-name">sa</span>, <span class="enscript-variable-name">ll</span>, <span class="enscript-variable-name">t</span>)
	<span class="enscript-keyword">return</span> (ifp_if_framer_extended(ifp, m, sa, ll, t, NULL, NULL));
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifp_if_framer_extended</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf **m,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sa, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ll, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *t,
    u_int32_t *pre, u_int32_t *post)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">sa</span>, <span class="enscript-variable-name">ll</span>, <span class="enscript-variable-name">t</span>)
	m_freem(*m);
	*m = NULL;

	<span class="enscript-keyword">if</span> (pre != NULL)
		*pre = 0;
	<span class="enscript-keyword">if</span> (post != NULL)
		*post = 0;

	<span class="enscript-keyword">return</span> (EJUSTRETURN);
}

errno_t
<span class="enscript-function-name">ifp_if_ioctl</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> cmd, <span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">cmd</span>, <span class="enscript-variable-name">arg</span>)
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifp_if_set_bpf_tap</span>(<span class="enscript-type">struct</span> ifnet *ifp, bpf_tap_mode tm, bpf_packet_func f)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">tm</span>, <span class="enscript-variable-name">f</span>)
	<span class="enscript-comment">/* XXX not sure what to do here */</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifp_if_free</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>)
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifp_if_event</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> kev_msg *e)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">e</span>)
}

__private_extern__
<span class="enscript-type">int</span> <span class="enscript-function-name">dlil_if_acquire</span>(u_int32_t family, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *uniqueid,
    size_t uniqueid_len, <span class="enscript-type">struct</span> ifnet **ifp)
{
	<span class="enscript-type">struct</span> ifnet *ifp1 = NULL;
	<span class="enscript-type">struct</span> dlil_ifnet *dlifp1 = NULL;
	<span class="enscript-type">void</span> *buf, *base, **pbuf;
	<span class="enscript-type">int</span> ret = 0;

	dlil_if_lock();
	TAILQ_FOREACH(dlifp1, &amp;dlil_ifnet_head, dl_if_link) {
		ifp1 = (<span class="enscript-type">struct</span> ifnet *)dlifp1;

		<span class="enscript-keyword">if</span> (ifp1-&gt;if_family != family)
			<span class="enscript-keyword">continue</span>;

		lck_mtx_lock(&amp;dlifp1-&gt;dl_if_lock);
		<span class="enscript-comment">/* same uniqueid and same len or no unique id specified */</span>
		<span class="enscript-keyword">if</span> ((uniqueid_len == dlifp1-&gt;dl_if_uniqueid_len) &amp;&amp;
		    !bcmp(uniqueid, dlifp1-&gt;dl_if_uniqueid, uniqueid_len)) {
			<span class="enscript-comment">/* check for matching interface in use */</span>
			<span class="enscript-keyword">if</span> (dlifp1-&gt;dl_if_flags &amp; DLIF_INUSE) {
				<span class="enscript-keyword">if</span> (uniqueid_len) {
					ret = EBUSY;
					lck_mtx_unlock(&amp;dlifp1-&gt;dl_if_lock);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
				}
			} <span class="enscript-keyword">else</span> {
				dlifp1-&gt;dl_if_flags |= (DLIF_INUSE|DLIF_REUSE);
				lck_mtx_unlock(&amp;dlifp1-&gt;dl_if_lock);
				*ifp = ifp1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
			}
		}
		lck_mtx_unlock(&amp;dlifp1-&gt;dl_if_lock);
	}

	<span class="enscript-comment">/* no interface found, allocate a new one */</span>
	buf = zalloc(dlif_zone);
	<span class="enscript-keyword">if</span> (buf == NULL) {
		ret = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	bzero(buf, dlif_bufsize);

	<span class="enscript-comment">/* Get the 64-bit aligned base address for this object */</span>
	base = (<span class="enscript-type">void</span> *)P2ROUNDUP((intptr_t)buf + <span class="enscript-keyword">sizeof</span> (u_int64_t),
	    <span class="enscript-keyword">sizeof</span> (u_int64_t));
	VERIFY(((intptr_t)base + dlif_size) &lt;= ((intptr_t)buf + dlif_bufsize));

	<span class="enscript-comment">/*
	 * Wind back a pointer size from the aligned base and
	 * save the original address so we can free it later.
	 */</span>
	pbuf = (<span class="enscript-type">void</span> **)((intptr_t)base - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *));
	*pbuf = buf;
	dlifp1 = base;

	<span class="enscript-keyword">if</span> (uniqueid_len) {
		MALLOC(dlifp1-&gt;dl_if_uniqueid, <span class="enscript-type">void</span> *, uniqueid_len,
		    M_NKE, M_WAITOK);
		<span class="enscript-keyword">if</span> (dlifp1-&gt;dl_if_uniqueid == NULL) {
			zfree(dlif_zone, dlifp1);
			ret = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
		}
		bcopy(uniqueid, dlifp1-&gt;dl_if_uniqueid, uniqueid_len);
		dlifp1-&gt;dl_if_uniqueid_len = uniqueid_len;
	}

	ifp1 = (<span class="enscript-type">struct</span> ifnet *)dlifp1;
	dlifp1-&gt;dl_if_flags = DLIF_INUSE;
	<span class="enscript-keyword">if</span> (ifnet_debug) {
		dlifp1-&gt;dl_if_flags |= DLIF_DEBUG;
		dlifp1-&gt;dl_if_trace = dlil_if_trace;
	}
	ifp1-&gt;if_name = dlifp1-&gt;dl_if_namestorage;
	ifp1-&gt;if_xname = dlifp1-&gt;dl_if_xnamestorage;

	<span class="enscript-comment">/* initialize interface description */</span>
	ifp1-&gt;if_desc.ifd_maxlen = IF_DESCSIZE;
	ifp1-&gt;if_desc.ifd_len = 0;
	ifp1-&gt;if_desc.ifd_desc = dlifp1-&gt;dl_if_descstorage;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	mac_ifnet_label_init(ifp1);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> ((ret = dlil_alloc_local_stats(ifp1)) != 0) {
		DLIL_PRINTF(<span class="enscript-string">&quot;%s: failed to allocate if local stats, &quot;</span>
		    <span class="enscript-string">&quot;error: %d\n&quot;</span>, __func__, ret);
		<span class="enscript-comment">/* This probably shouldn't be fatal */</span>
		ret = 0;
	}

	lck_mtx_init(&amp;dlifp1-&gt;dl_if_lock, ifnet_lock_group, ifnet_lock_attr);
	lck_rw_init(&amp;ifp1-&gt;if_lock, ifnet_lock_group, ifnet_lock_attr);
	lck_mtx_init(&amp;ifp1-&gt;if_ref_lock, ifnet_lock_group, ifnet_lock_attr);
	lck_mtx_init(&amp;ifp1-&gt;if_flt_lock, ifnet_lock_group, ifnet_lock_attr);
	lck_mtx_init(&amp;ifp1-&gt;if_addrconfig_lock, ifnet_lock_group,
	    ifnet_lock_attr);
	lck_rw_init(&amp;ifp1-&gt;if_llreach_lock, ifnet_lock_group, ifnet_lock_attr);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	lck_rw_init(&amp;ifp1-&gt;if_inetdata_lock, ifnet_lock_group,
	    ifnet_lock_attr);
	ifp1-&gt;if_inetdata = NULL;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	lck_rw_init(&amp;ifp1-&gt;if_inet6data_lock, ifnet_lock_group,
	    ifnet_lock_attr);
	ifp1-&gt;if_inet6data = NULL;
#<span class="enscript-reference">endif</span>
	lck_rw_init(&amp;ifp1-&gt;if_link_status_lock, ifnet_lock_group,
	    ifnet_lock_attr);
	ifp1-&gt;if_link_status = NULL;

	<span class="enscript-comment">/* for send data paths */</span>
	lck_mtx_init(&amp;ifp1-&gt;if_start_lock, ifnet_snd_lock_group,
	    ifnet_lock_attr);
	lck_mtx_init(&amp;ifp1-&gt;if_cached_route_lock, ifnet_snd_lock_group,
	    ifnet_lock_attr);
	lck_mtx_init(&amp;ifp1-&gt;if_snd.ifcq_lock, ifnet_snd_lock_group,
	    ifnet_lock_attr);

	<span class="enscript-comment">/* for receive data paths */</span>
	lck_mtx_init(&amp;ifp1-&gt;if_poll_lock, ifnet_rcv_lock_group,
	    ifnet_lock_attr);

	TAILQ_INSERT_TAIL(&amp;dlil_ifnet_head, dlifp1, dl_if_link);

	*ifp = ifp1;

<span class="enscript-reference">end</span>:
	dlil_if_unlock();

	VERIFY(dlifp1 == NULL || (IS_P2ALIGNED(dlifp1, <span class="enscript-keyword">sizeof</span> (u_int64_t)) &amp;&amp;
	    IS_P2ALIGNED(&amp;ifp1-&gt;if_data, <span class="enscript-keyword">sizeof</span> (u_int64_t))));

	<span class="enscript-keyword">return</span> (ret);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_if_release</span>(ifnet_t	ifp)
{
	<span class="enscript-type">struct</span> dlil_ifnet *dlifp = (<span class="enscript-type">struct</span> dlil_ifnet *)ifp;

	ifnet_lock_exclusive(ifp);
	lck_mtx_lock(&amp;dlifp-&gt;dl_if_lock);
	dlifp-&gt;dl_if_flags &amp;= ~DLIF_INUSE;
	strlcpy(dlifp-&gt;dl_if_namestorage, ifp-&gt;if_name, IFNAMSIZ);
	ifp-&gt;if_name = dlifp-&gt;dl_if_namestorage;
	<span class="enscript-comment">/* Reset external name (name + unit) */</span>
	ifp-&gt;if_xname = dlifp-&gt;dl_if_xnamestorage;
	snprintf(__DECONST(<span class="enscript-type">char</span> *, ifp-&gt;if_xname), IFXNAMSIZ, 
	    <span class="enscript-string">&quot;%s?&quot;</span>, ifp-&gt;if_name);
	lck_mtx_unlock(&amp;dlifp-&gt;dl_if_lock);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	<span class="enscript-comment">/*
	* We can either recycle the MAC label here or in dlil_if_acquire().
	* It seems logical to do it here but this means that anything that
	* still has a handle on ifp will now see it as unlabeled.
	* Since the interface is &quot;dead&quot; that may be OK.  Revisit later.
	*/</span>
	mac_ifnet_label_recycle(ifp);
#<span class="enscript-reference">endif</span>
	ifnet_lock_done(ifp);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_if_lock</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock(&amp;dlil_ifnet_lock);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_if_unlock</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_unlock(&amp;dlil_ifnet_lock);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_if_lock_assert</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_assert(&amp;dlil_ifnet_lock, LCK_MTX_ASSERT_OWNED);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_proto_unplumb_all</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-comment">/*
	 * if_proto_hash[0-2] are for PF_INET, PF_INET6 and PF_VLAN, where
	 * each bucket contains exactly one entry; PF_VLAN does not need an
	 * explicit unplumb.
	 *
	 * if_proto_hash[3] is for other protocols; we expect anything
	 * in this bucket to respond to the DETACHING event (which would
	 * have happened by now) and do the unplumb then.
	 */</span>
	(<span class="enscript-type">void</span>) proto_unplumb(PF_INET, ifp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	(<span class="enscript-type">void</span>) proto_unplumb(PF_INET6, ifp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifp_src_route_copyout</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> route *dst)
{
	lck_mtx_lock_spin(&amp;ifp-&gt;if_cached_route_lock);
	lck_mtx_convert_spin(&amp;ifp-&gt;if_cached_route_lock);

	route_copyout(dst, &amp;ifp-&gt;if_src_route, <span class="enscript-keyword">sizeof</span> (*dst));

	lck_mtx_unlock(&amp;ifp-&gt;if_cached_route_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifp_src_route_copyin</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> route *src)
{
	lck_mtx_lock_spin(&amp;ifp-&gt;if_cached_route_lock);
	lck_mtx_convert_spin(&amp;ifp-&gt;if_cached_route_lock);

	<span class="enscript-keyword">if</span> (ifp-&gt;if_fwd_cacheok) {
		route_copyin(src, &amp;ifp-&gt;if_src_route, <span class="enscript-keyword">sizeof</span> (*src));
	} <span class="enscript-keyword">else</span> {
		ROUTE_RELEASE(src);
	}
	lck_mtx_unlock(&amp;ifp-&gt;if_cached_route_lock);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifp_src_route6_copyout</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> route_in6 *dst)
{
	lck_mtx_lock_spin(&amp;ifp-&gt;if_cached_route_lock);
	lck_mtx_convert_spin(&amp;ifp-&gt;if_cached_route_lock);

	route_copyout((<span class="enscript-type">struct</span> route *)dst, (<span class="enscript-type">struct</span> route *)&amp;ifp-&gt;if_src_route6,
	    <span class="enscript-keyword">sizeof</span> (*dst));

	lck_mtx_unlock(&amp;ifp-&gt;if_cached_route_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifp_src_route6_copyin</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> route_in6 *src)
{
	lck_mtx_lock_spin(&amp;ifp-&gt;if_cached_route_lock);
	lck_mtx_convert_spin(&amp;ifp-&gt;if_cached_route_lock);

	<span class="enscript-keyword">if</span> (ifp-&gt;if_fwd_cacheok) {
		route_copyin((<span class="enscript-type">struct</span> route *)src,
		    (<span class="enscript-type">struct</span> route *)&amp;ifp-&gt;if_src_route6, <span class="enscript-keyword">sizeof</span> (*src));
	} <span class="enscript-keyword">else</span> {
		ROUTE_RELEASE(src);
	}
	lck_mtx_unlock(&amp;ifp-&gt;if_cached_route_lock);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">ifnet_cached_rtlookup_inet</span>(<span class="enscript-type">struct</span> ifnet	*ifp, <span class="enscript-type">struct</span> in_addr src_ip)
{
	<span class="enscript-type">struct</span> route		src_rt;
	<span class="enscript-type">struct</span> sockaddr_in	*dst;

	dst = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)(&amp;src_rt.ro_dst);

	ifp_src_route_copyout(ifp, &amp;src_rt);

	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(&amp;src_rt) || src_ip.s_addr != dst-&gt;sin_addr.s_addr) {
		ROUTE_RELEASE(&amp;src_rt);
		<span class="enscript-keyword">if</span> (dst-&gt;sin_family != AF_INET) {
			bzero(&amp;src_rt.ro_dst, <span class="enscript-keyword">sizeof</span> (src_rt.ro_dst));
			dst-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (src_rt.ro_dst);
			dst-&gt;sin_family = AF_INET;
		}
		dst-&gt;sin_addr = src_ip;

		<span class="enscript-keyword">if</span> (src_rt.ro_rt == NULL) {
			src_rt.ro_rt = rtalloc1_scoped((<span class="enscript-type">struct</span> sockaddr *)dst,
			    0, 0, ifp-&gt;if_index);

			<span class="enscript-keyword">if</span> (src_rt.ro_rt != NULL) {
				<span class="enscript-comment">/* retain a ref, copyin consumes one */</span>
				<span class="enscript-type">struct</span> rtentry	*rte = src_rt.ro_rt;
				RT_ADDREF(rte);
				ifp_src_route_copyin(ifp, &amp;src_rt);
				src_rt.ro_rt = rte;
			}
		}
	}

	<span class="enscript-keyword">return</span> (src_rt.ro_rt);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">struct</span> rtentry*
<span class="enscript-function-name">ifnet_cached_rtlookup_inet6</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in6_addr *src_ip6)
{
	<span class="enscript-type">struct</span> route_in6 src_rt;

	ifp_src_route6_copyout(ifp, &amp;src_rt);

	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(&amp;src_rt) ||
	    !IN6_ARE_ADDR_EQUAL(src_ip6, &amp;src_rt.ro_dst.sin6_addr)) {
		ROUTE_RELEASE(&amp;src_rt);
		<span class="enscript-keyword">if</span> (src_rt.ro_dst.sin6_family != AF_INET6) {
			bzero(&amp;src_rt.ro_dst, <span class="enscript-keyword">sizeof</span> (src_rt.ro_dst));
			src_rt.ro_dst.sin6_len = <span class="enscript-keyword">sizeof</span> (src_rt.ro_dst);
			src_rt.ro_dst.sin6_family = AF_INET6;
		}
		src_rt.ro_dst.sin6_scope_id = in6_addr2scopeid(ifp, src_ip6);
		bcopy(src_ip6, &amp;src_rt.ro_dst.sin6_addr,
		    <span class="enscript-keyword">sizeof</span> (src_rt.ro_dst.sin6_addr));

		<span class="enscript-keyword">if</span> (src_rt.ro_rt == NULL) {
			src_rt.ro_rt = rtalloc1_scoped(
			    (<span class="enscript-type">struct</span> sockaddr *)&amp;src_rt.ro_dst, 0, 0,
			    ifp-&gt;if_index);

			<span class="enscript-keyword">if</span> (src_rt.ro_rt != NULL) {
				<span class="enscript-comment">/* retain a ref, copyin consumes one */</span>
				<span class="enscript-type">struct</span> rtentry	*rte = src_rt.ro_rt;
				RT_ADDREF(rte);
				ifp_src_route6_copyin(ifp, &amp;src_rt);
				src_rt.ro_rt = rte;
			}
		}
	}

	<span class="enscript-keyword">return</span> (src_rt.ro_rt);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">if_lqm_update</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> lqm, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-type">struct</span> kev_dl_link_quality_metric_data ev_lqm_data;

	VERIFY(lqm &gt;= IFNET_LQM_MIN &amp;&amp; lqm &lt;= IFNET_LQM_MAX);

	<span class="enscript-comment">/* Normalize to edge */</span>
	<span class="enscript-keyword">if</span> (lqm &gt;= 0 &amp;&amp; lqm &lt;= IFNET_LQM_THRESH_BAD)
		lqm = IFNET_LQM_THRESH_BAD;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lqm &gt; IFNET_LQM_THRESH_BAD &amp;&amp; lqm &lt;= IFNET_LQM_THRESH_POOR)
		lqm = IFNET_LQM_THRESH_POOR;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lqm &gt; IFNET_LQM_THRESH_POOR &amp;&amp; lqm &lt;= IFNET_LQM_THRESH_GOOD)
		lqm = IFNET_LQM_THRESH_GOOD;

	<span class="enscript-comment">/*
	 * Take the lock if needed
	 */</span>
	<span class="enscript-keyword">if</span> (!locked)
		ifnet_lock_exclusive(ifp);

	<span class="enscript-keyword">if</span> (lqm == ifp-&gt;if_interface_state.lqm_state &amp;&amp;
	    (ifp-&gt;if_interface_state.valid_bitmask &amp; 
	    IF_INTERFACE_STATE_LQM_STATE_VALID)) {
		<span class="enscript-comment">/*
		 * Release the lock if was not held by the caller
		 */</span>
		<span class="enscript-keyword">if</span> (!locked)
			ifnet_lock_done(ifp);
		<span class="enscript-keyword">return</span>;		<span class="enscript-comment">/* nothing to update */</span>
	}
	ifp-&gt;if_interface_state.valid_bitmask |=
		    IF_INTERFACE_STATE_LQM_STATE_VALID;
	ifp-&gt;if_interface_state.lqm_state = lqm;

	<span class="enscript-comment">/*
	 * Don't want to hold the lock when issuing kernel events
	 */</span>
	ifnet_lock_done(ifp);

	bzero(&amp;ev_lqm_data, <span class="enscript-keyword">sizeof</span> (ev_lqm_data));
	ev_lqm_data.link_quality_metric = lqm;

	dlil_post_msg(ifp, KEV_DL_SUBCLASS, KEV_DL_LINK_QUALITY_METRIC_CHANGED,
	    (<span class="enscript-type">struct</span> net_event_data *)&amp;ev_lqm_data, <span class="enscript-keyword">sizeof</span> (ev_lqm_data));

	<span class="enscript-comment">/*
	 * Reacquire the lock for the caller
	 */</span>
	<span class="enscript-keyword">if</span> (locked)
		ifnet_lock_exclusive(ifp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">if_rrc_state_update</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> rrc_state)
{
	<span class="enscript-type">struct</span> kev_dl_rrc_state kev;
	
	<span class="enscript-keyword">if</span> (rrc_state == ifp-&gt;if_interface_state.rrc_state &amp;&amp;
	    (ifp-&gt;if_interface_state.valid_bitmask &amp;
	    IF_INTERFACE_STATE_RRC_STATE_VALID))
		<span class="enscript-keyword">return</span>;

	ifp-&gt;if_interface_state.valid_bitmask |=
	    IF_INTERFACE_STATE_RRC_STATE_VALID;

	ifp-&gt;if_interface_state.rrc_state = rrc_state;

	<span class="enscript-comment">/*
	 * Don't want to hold the lock when issuing kernel events
	 */</span>
	ifnet_lock_done(ifp);

	bzero(&amp;kev, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kev_dl_rrc_state));
	kev.rrc_state = rrc_state;

	dlil_post_msg(ifp, KEV_DL_SUBCLASS, KEV_DL_RRC_STATE_CHANGED,
	    (<span class="enscript-type">struct</span> net_event_data *)&amp;kev, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kev_dl_rrc_state));

	ifnet_lock_exclusive(ifp);
}

errno_t
<span class="enscript-function-name">if_state_update</span>(<span class="enscript-type">struct</span> ifnet *ifp,
   <span class="enscript-type">struct</span> if_interface_state* if_interface_state)
{
	u_short if_index_available = 0;

	ifnet_lock_exclusive(ifp);

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_type != IFT_CELLULAR) &amp;&amp;
	    (if_interface_state-&gt;valid_bitmask &amp;
	    IF_INTERFACE_STATE_RRC_STATE_VALID)) {
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}
	<span class="enscript-keyword">if</span> ((if_interface_state-&gt;valid_bitmask &amp;
	    IF_INTERFACE_STATE_LQM_STATE_VALID) &amp;&amp;
	    (if_interface_state-&gt;lqm_state &lt; IFNET_LQM_MIN ||
	    if_interface_state-&gt;lqm_state &gt; IFNET_LQM_MAX)) {
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> ((if_interface_state-&gt;valid_bitmask &amp;
	    IF_INTERFACE_STATE_RRC_STATE_VALID) &amp;&amp;
	    if_interface_state-&gt;rrc_state !=
	    IF_INTERFACE_STATE_RRC_STATE_IDLE &amp;&amp;
	    if_interface_state-&gt;rrc_state !=
	    IF_INTERFACE_STATE_RRC_STATE_CONNECTED) {
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (if_interface_state-&gt;valid_bitmask &amp;
	    IF_INTERFACE_STATE_LQM_STATE_VALID) {
		if_lqm_update(ifp, if_interface_state-&gt;lqm_state, 1);
	}
	<span class="enscript-keyword">if</span> (if_interface_state-&gt;valid_bitmask &amp;
	    IF_INTERFACE_STATE_RRC_STATE_VALID) {
		if_rrc_state_update(ifp, if_interface_state-&gt;rrc_state);
	}
	<span class="enscript-keyword">if</span> (if_interface_state-&gt;valid_bitmask &amp;
	    IF_INTERFACE_STATE_INTERFACE_AVAILABILITY_VALID) {
		ifp-&gt;if_interface_state.valid_bitmask |=
		    IF_INTERFACE_STATE_INTERFACE_AVAILABILITY_VALID;
		ifp-&gt;if_interface_state.interface_availability =
		    if_interface_state-&gt;interface_availability;

		<span class="enscript-keyword">if</span> (ifp-&gt;if_interface_state.interface_availability ==
		    IF_INTERFACE_STATE_INTERFACE_AVAILABLE) {
			if_index_available = ifp-&gt;if_index;
		}
	}
	ifnet_lock_done(ifp);

	<span class="enscript-comment">/*
	 * Check if the TCP connections going on this interface should be
	 * forced to send probe packets instead of waiting for TCP timers
	 * to fire. This will be done when there is an explicit
	 * notification that the interface became available.
	 */</span>
	<span class="enscript-keyword">if</span> (if_index_available &gt; 0)
		tcp_interface_send_probe(if_index_available);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">if_get_state</span>(<span class="enscript-type">struct</span> ifnet *ifp,
   <span class="enscript-type">struct</span> if_interface_state* if_interface_state)
{
	ifnet_lock_shared(ifp);

	if_interface_state-&gt;valid_bitmask = 0;

	<span class="enscript-keyword">if</span> (ifp-&gt;if_interface_state.valid_bitmask &amp;
	    IF_INTERFACE_STATE_RRC_STATE_VALID) {
		if_interface_state-&gt;valid_bitmask |=
		    IF_INTERFACE_STATE_RRC_STATE_VALID;
		if_interface_state-&gt;rrc_state =
		    ifp-&gt;if_interface_state.rrc_state;
	}
	<span class="enscript-keyword">if</span> (ifp-&gt;if_interface_state.valid_bitmask &amp;
	    IF_INTERFACE_STATE_LQM_STATE_VALID) {
		if_interface_state-&gt;valid_bitmask |=
		    IF_INTERFACE_STATE_LQM_STATE_VALID;
		if_interface_state-&gt;lqm_state =
		    ifp-&gt;if_interface_state.lqm_state;
	}
	<span class="enscript-keyword">if</span> (ifp-&gt;if_interface_state.valid_bitmask &amp;
	    IF_INTERFACE_STATE_INTERFACE_AVAILABILITY_VALID) {
		if_interface_state-&gt;valid_bitmask |=
		    IF_INTERFACE_STATE_INTERFACE_AVAILABILITY_VALID;
		if_interface_state-&gt;interface_availability =
		    ifp-&gt;if_interface_state.interface_availability;
	}

	ifnet_lock_done(ifp);
}

errno_t
<span class="enscript-function-name">if_probe_connectivity</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t conn_probe)
{
	ifnet_lock_exclusive(ifp);
	<span class="enscript-keyword">if</span> (conn_probe &gt; 1) {
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (conn_probe == 0)
		ifp-&gt;if_eflags &amp;= ~IFEF_PROBE_CONNECTIVITY;
	<span class="enscript-keyword">else</span>
		ifp-&gt;if_eflags |= IFEF_PROBE_CONNECTIVITY;
	ifnet_lock_done(ifp);

	tcp_probe_connectivity(ifp, conn_probe);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* for uuid.c */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">uuid_get_ethernet</span>(u_int8_t *node)
{
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> sockaddr_dl *sdl;

	ifnet_head_lock_shared();
	TAILQ_FOREACH(ifp, &amp;ifnet_head, if_link) {
		ifnet_lock_shared(ifp);
		IFA_LOCK_SPIN(ifp-&gt;if_lladdr);
		sdl = (<span class="enscript-type">struct</span> sockaddr_dl *)(<span class="enscript-type">void</span> *)ifp-&gt;if_lladdr-&gt;ifa_addr;
		<span class="enscript-keyword">if</span> (sdl-&gt;sdl_type == IFT_ETHER) {
			memcpy(node, LLADDR(sdl), ETHER_ADDR_LEN);
			IFA_UNLOCK(ifp-&gt;if_lladdr);
			ifnet_lock_done(ifp);
			ifnet_head_done();
			<span class="enscript-keyword">return</span> (0);
		}
		IFA_UNLOCK(ifp-&gt;if_lladdr);
		ifnet_lock_done(ifp);
	}
	ifnet_head_done();

	<span class="enscript-keyword">return</span> (-1);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_rxpoll SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	uint32_t i;
	<span class="enscript-type">int</span> err;

	i = if_rxpoll;

	err = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (net_rxpoll == 0)
		<span class="enscript-keyword">return</span> (ENXIO);

	if_rxpoll = i;
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_rxpoll_mode_holdtime SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	uint64_t q;
	<span class="enscript-type">int</span> err;

	q = if_rxpoll_mode_holdtime;

	err = sysctl_handle_quad(oidp, &amp;q, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (q &lt; IF_RXPOLL_MODE_HOLDTIME_MIN)
		q = IF_RXPOLL_MODE_HOLDTIME_MIN;

	if_rxpoll_mode_holdtime = q;

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_rxpoll_sample_holdtime SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	uint64_t q;
	<span class="enscript-type">int</span> err;

	q = if_rxpoll_sample_holdtime;

	err = sysctl_handle_quad(oidp, &amp;q, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (q &lt; IF_RXPOLL_SAMPLETIME_MIN)
		q = IF_RXPOLL_SAMPLETIME_MIN;

	if_rxpoll_sample_holdtime = q;

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_rxpoll_interval_time SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	uint64_t q;
	<span class="enscript-type">int</span> err;

	q = if_rxpoll_interval_time;

	err = sysctl_handle_quad(oidp, &amp;q, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (q &lt; IF_RXPOLL_INTERVALTIME_MIN)
		q = IF_RXPOLL_INTERVALTIME_MIN;

	if_rxpoll_interval_time = q;

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_rxpoll_wlowat SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	uint32_t i;
	<span class="enscript-type">int</span> err;

	i = if_rxpoll_wlowat;

	err = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (i == 0 || i &gt;= if_rxpoll_whiwat)
		<span class="enscript-keyword">return</span> (EINVAL);

	if_rxpoll_wlowat = i;
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_rxpoll_whiwat SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	uint32_t i;
	<span class="enscript-type">int</span> err;

	i = if_rxpoll_whiwat;

	err = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (i &lt;= if_rxpoll_wlowat)
		<span class="enscript-keyword">return</span> (EINVAL);

	if_rxpoll_whiwat = i;
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_sndq_maxlen SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> i, err;

	i = if_sndq_maxlen;

	err = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (i &lt; IF_SNDQ_MINLEN)
		i = IF_SNDQ_MINLEN;

	if_sndq_maxlen = i;
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_rcvq_maxlen SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> i, err;

	i = if_rcvq_maxlen;

	err = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (i &lt; IF_RCVQ_MINLEN)
		i = IF_RCVQ_MINLEN;

	if_rcvq_maxlen = i;
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_node_present</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> sockaddr *sa,
    int32_t rssi, <span class="enscript-type">int</span> lqm, <span class="enscript-type">int</span> npm, u_int8_t srvinfo[48])
{
	<span class="enscript-type">struct</span> kev_dl_node_presence kev;
	<span class="enscript-type">struct</span> sockaddr_dl *sdl;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6;

	VERIFY(ifp);
	VERIFY(sa);
	VERIFY(sa-&gt;sa_family == AF_LINK || sa-&gt;sa_family == AF_INET6);

	bzero(&amp;kev, <span class="enscript-keyword">sizeof</span> (kev));
	sin6 = &amp;kev.sin6_node_address;
	sdl = &amp;kev.sdl_node_address;
	nd6_alt_node_addr_decompose(ifp, sa, sdl, sin6);
	kev.rssi = rssi;
	kev.link_quality_metric = lqm;
	kev.node_proximity_metric = npm;
	bcopy(srvinfo, kev.node_service_info, <span class="enscript-keyword">sizeof</span> (kev.node_service_info));

	nd6_alt_node_present(ifp, sin6, sdl, rssi, lqm, npm);
	dlil_post_msg(ifp, KEV_DL_SUBCLASS, KEV_DL_NODE_PRESENCE,
	    &amp;kev.link_data, <span class="enscript-keyword">sizeof</span> (kev));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_node_absent</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> sockaddr *sa)
{
	<span class="enscript-type">struct</span> kev_dl_node_absence kev;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6;
	<span class="enscript-type">struct</span> sockaddr_dl *sdl;

	VERIFY(ifp);
	VERIFY(sa);
	VERIFY(sa-&gt;sa_family == AF_LINK || sa-&gt;sa_family == AF_INET6);

	bzero(&amp;kev, <span class="enscript-keyword">sizeof</span> (kev));
	sin6 = &amp;kev.sin6_node_address;
	sdl = &amp;kev.sdl_node_address;
	nd6_alt_node_addr_decompose(ifp, sa, sdl, sin6);

	nd6_alt_node_absent(ifp, sin6);
	dlil_post_msg(ifp, KEV_DL_SUBCLASS, KEV_DL_NODE_ABSENCE,
	    &amp;kev.link_data, <span class="enscript-keyword">sizeof</span> (kev));
}

<span class="enscript-type">const</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">dlil_ifaddr_bytes</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *sdl, size_t *sizep,
	kauth_cred_t *credp)
{
	<span class="enscript-type">const</span> u_int8_t *bytes;
	size_t size;

	bytes = CONST_LLADDR(sdl);
	size = sdl-&gt;sdl_alen;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (dlil_lladdr_ckreq) {
		<span class="enscript-keyword">switch</span> (sdl-&gt;sdl_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ETHER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE1394</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			credp = NULL;
			<span class="enscript-keyword">break</span>;
		};

		<span class="enscript-keyword">if</span> (credp &amp;&amp; mac_system_check_info(*credp, <span class="enscript-string">&quot;net.link.addr&quot;</span>)) {
			<span class="enscript-type">static</span> <span class="enscript-type">const</span> u_int8_t unspec[FIREWIRE_EUI64_LEN] = {
			    [0] = 2
			};

			<span class="enscript-keyword">switch</span> (sdl-&gt;sdl_type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ETHER</span>:
				VERIFY(size == ETHER_ADDR_LEN);
				bytes = unspec;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE1394</span>:
				VERIFY(size == FIREWIRE_EUI64_LEN);
				bytes = unspec;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				VERIFY(FALSE);
				<span class="enscript-keyword">break</span>;
			};
		}
	}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">credp</span>)
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (sizep != NULL) *sizep = size;
	<span class="enscript-keyword">return</span> (bytes);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_report_issues</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int8_t modid[DLIL_MODIDLEN],
    u_int8_t info[DLIL_MODARGLEN])
{
	<span class="enscript-type">struct</span> kev_dl_issues kev;
	<span class="enscript-type">struct</span> timeval tv;

	VERIFY(ifp != NULL);
	VERIFY(modid != NULL);
	_CASSERT(<span class="enscript-keyword">sizeof</span> (kev.modid) == DLIL_MODIDLEN);
	_CASSERT(<span class="enscript-keyword">sizeof</span> (kev.info) == DLIL_MODARGLEN);

	bzero(&amp;kev, <span class="enscript-keyword">sizeof</span> (kev));

	microtime(&amp;tv);
	kev.timestamp = tv.tv_sec;
	bcopy(modid, &amp;kev.modid, DLIL_MODIDLEN);
	<span class="enscript-keyword">if</span> (info != NULL)
		bcopy(info, &amp;kev.info, DLIL_MODARGLEN);

	dlil_post_msg(ifp, KEV_DL_SUBCLASS, KEV_DL_ISSUES,
	    &amp;kev.link_data, <span class="enscript-keyword">sizeof</span> (kev));
}

errno_t
<span class="enscript-function-name">ifnet_getset_opportunistic</span>(ifnet_t ifp, u_long cmd, <span class="enscript-type">struct</span> ifreq *ifr,
    <span class="enscript-type">struct</span> proc *p)
{
	u_int32_t level = IFNET_THROTTLE_OFF;
	errno_t result = 0;

	VERIFY(cmd == SIOCSIFOPPORTUNISTIC || cmd == SIOCGIFOPPORTUNISTIC);

	<span class="enscript-keyword">if</span> (cmd == SIOCSIFOPPORTUNISTIC) {
		<span class="enscript-comment">/*
		 * XXX: Use priv_check_cred() instead of root check?
		 */</span>
		<span class="enscript-keyword">if</span> ((result = proc_suser(p)) != 0)
			<span class="enscript-keyword">return</span> (result);

		<span class="enscript-keyword">if</span> (ifr-&gt;ifr_opportunistic.ifo_flags ==
		    IFRIFOF_BLOCK_OPPORTUNISTIC)
			level = IFNET_THROTTLE_OPPORTUNISTIC;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifr-&gt;ifr_opportunistic.ifo_flags == 0)
			level = IFNET_THROTTLE_OFF;
		<span class="enscript-keyword">else</span>
			result = EINVAL;

		<span class="enscript-keyword">if</span> (result == 0)
			result = ifnet_set_throttle(ifp, level);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((result = ifnet_get_throttle(ifp, &amp;level)) == 0) {
		ifr-&gt;ifr_opportunistic.ifo_flags = 0;
		<span class="enscript-keyword">if</span> (level == IFNET_THROTTLE_OPPORTUNISTIC) {
			ifr-&gt;ifr_opportunistic.ifo_flags |=
			    IFRIFOF_BLOCK_OPPORTUNISTIC;
		}
	}

	<span class="enscript-comment">/*
	 * Return the count of current opportunistic connections
	 * over the interface.
	 */</span>
	<span class="enscript-keyword">if</span> (result == 0) {
		uint32_t flags = 0;
		flags |= (cmd == SIOCSIFOPPORTUNISTIC) ?
			INPCB_OPPORTUNISTIC_SETCMD : 0;
		flags |= (level == IFNET_THROTTLE_OPPORTUNISTIC) ? 
			INPCB_OPPORTUNISTIC_THROTTLEON : 0;
		ifr-&gt;ifr_opportunistic.ifo_inuse =
		    udp_count_opportunistic(ifp-&gt;if_index, flags) +
		    tcp_count_opportunistic(ifp-&gt;if_index, flags);
	}

	<span class="enscript-keyword">if</span> (result == EALREADY)
		result = 0;

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifnet_get_throttle</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t *level)
{
	<span class="enscript-type">struct</span> ifclassq *ifq;
	<span class="enscript-type">int</span> err = 0;

	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART))
		<span class="enscript-keyword">return</span> (ENXIO);

	*level = IFNET_THROTTLE_OFF;

	ifq = &amp;ifp-&gt;if_snd;
	IFCQ_LOCK(ifq);
	<span class="enscript-comment">/* Throttling works only for IFCQ, not ALTQ instances */</span>
	<span class="enscript-keyword">if</span> (IFCQ_IS_ENABLED(ifq))
		IFCQ_GET_THROTTLE(ifq, *level, err);
	IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifnet_set_throttle</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t level)
{
	<span class="enscript-type">struct</span> ifclassq *ifq;
	<span class="enscript-type">int</span> err = 0;

	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART))
		<span class="enscript-keyword">return</span> (ENXIO);

	ifq = &amp;ifp-&gt;if_snd;

	<span class="enscript-keyword">switch</span> (level) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFNET_THROTTLE_OFF</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFNET_THROTTLE_OPPORTUNISTIC</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
		<span class="enscript-comment">/* Throttling works only for IFCQ, not ALTQ instances */</span>
		<span class="enscript-keyword">if</span> (ALTQ_IS_ENABLED(IFCQ_ALTQ(ifq)))
			<span class="enscript-keyword">return</span> (ENXIO);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	IFCQ_LOCK(ifq);
	<span class="enscript-keyword">if</span> (IFCQ_IS_ENABLED(ifq))
		IFCQ_SET_THROTTLE(ifq, level, err);
	IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">if</span> (err == 0) {
		printf(<span class="enscript-string">&quot;%s: throttling level set to %d\n&quot;</span>, if_name(ifp),
		    level);
		<span class="enscript-keyword">if</span> (level == IFNET_THROTTLE_OFF)
			ifnet_start(ifp);
	}

	<span class="enscript-keyword">return</span> (err);
}

errno_t
<span class="enscript-function-name">ifnet_getset_log</span>(ifnet_t ifp, u_long cmd, <span class="enscript-type">struct</span> ifreq *ifr,
    <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	errno_t result = 0;
	uint32_t flags;
	<span class="enscript-type">int</span> level, category, subcategory;

	VERIFY(cmd == SIOCSIFLOG || cmd == SIOCGIFLOG);

	<span class="enscript-keyword">if</span> (cmd == SIOCSIFLOG) {
		<span class="enscript-keyword">if</span> ((result = priv_check_cred(kauth_cred_get(),
		    PRIV_NET_INTERFACE_CONTROL, 0)) != 0)
			<span class="enscript-keyword">return</span> (result);

		level = ifr-&gt;ifr_log.ifl_level;
		<span class="enscript-keyword">if</span> (level &lt; IFNET_LOG_MIN || level &gt; IFNET_LOG_MAX)
			result = EINVAL;

		flags = ifr-&gt;ifr_log.ifl_flags;
		<span class="enscript-keyword">if</span> ((flags &amp;= IFNET_LOGF_MASK) == 0)
			result = EINVAL;

		category = ifr-&gt;ifr_log.ifl_category;
		subcategory = ifr-&gt;ifr_log.ifl_subcategory;

		<span class="enscript-keyword">if</span> (result == 0)
			result = ifnet_set_log(ifp, level, flags,
			    category, subcategory);
	} <span class="enscript-keyword">else</span> {
		result = ifnet_get_log(ifp, &amp;level, &amp;flags, &amp;category,
		    &amp;subcategory);
		<span class="enscript-keyword">if</span> (result == 0) {
			ifr-&gt;ifr_log.ifl_level = level;
			ifr-&gt;ifr_log.ifl_flags = flags;
			ifr-&gt;ifr_log.ifl_category = category;
			ifr-&gt;ifr_log.ifl_subcategory = subcategory;
		}
	}

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifnet_set_log</span>(<span class="enscript-type">struct</span> ifnet *ifp, int32_t level, uint32_t flags,
    int32_t category, int32_t subcategory)
{
	<span class="enscript-type">int</span> err = 0;

	VERIFY(level &gt;= IFNET_LOG_MIN &amp;&amp; level &lt;= IFNET_LOG_MAX);
	VERIFY(flags &amp; IFNET_LOGF_MASK);

	<span class="enscript-comment">/*
	 * The logging level applies to all facilities; make sure to
	 * update them all with the most current level.
	 */</span>
	flags |= ifp-&gt;if_log.flags;

	<span class="enscript-keyword">if</span> (ifp-&gt;if_output_ctl != NULL) {
		<span class="enscript-type">struct</span> ifnet_log_params l;

		bzero(&amp;l, <span class="enscript-keyword">sizeof</span> (l));
		l.level = level;
		l.flags = flags;
		l.flags &amp;= ~IFNET_LOGF_DLIL;
		l.category = category;
		l.subcategory = subcategory;

		<span class="enscript-comment">/* Send this request to lower layers */</span>
		<span class="enscript-keyword">if</span> (l.flags != 0) {
			err = ifp-&gt;if_output_ctl(ifp, IFNET_CTL_SET_LOG,
			    <span class="enscript-keyword">sizeof</span> (l), &amp;l);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((flags &amp; ~IFNET_LOGF_DLIL) &amp;&amp; ifp-&gt;if_output_ctl == NULL) {
		<span class="enscript-comment">/*
		 * If targeted to the lower layers without an output
		 * control callback registered on the interface, just
		 * silently ignore facilities other than ours.
		 */</span>
		flags &amp;= IFNET_LOGF_DLIL;
		<span class="enscript-keyword">if</span> (flags == 0 &amp;&amp; (!ifp-&gt;if_log.flags &amp; IFNET_LOGF_DLIL))
			level = 0;
	}

	<span class="enscript-keyword">if</span> (err == 0) {
		<span class="enscript-keyword">if</span> ((ifp-&gt;if_log.level = level) == IFNET_LOG_DEFAULT)
			ifp-&gt;if_log.flags = 0;
		<span class="enscript-keyword">else</span>
			ifp-&gt;if_log.flags |= flags;

		log(LOG_INFO, <span class="enscript-string">&quot;%s: logging level set to %d flags=%b &quot;</span>
		    <span class="enscript-string">&quot;arg=%b, category=%d subcategory=%d\n&quot;</span>, if_name(ifp),
		    ifp-&gt;if_log.level, ifp-&gt;if_log.flags,
		    IFNET_LOGF_BITS, flags, IFNET_LOGF_BITS,
		    category, subcategory);
	}

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifnet_get_log</span>(<span class="enscript-type">struct</span> ifnet *ifp, int32_t *level, uint32_t *flags,
    int32_t *category, int32_t *subcategory)
{
	<span class="enscript-keyword">if</span> (level != NULL)
		*level = ifp-&gt;if_log.level;
	<span class="enscript-keyword">if</span> (flags != NULL)
		*flags = ifp-&gt;if_log.flags;
	<span class="enscript-keyword">if</span> (category != NULL)
		*category = ifp-&gt;if_log.category;
	<span class="enscript-keyword">if</span> (subcategory != NULL)
		*subcategory = ifp-&gt;if_log.subcategory;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifnet_notify_address</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> af)
{
	<span class="enscript-type">struct</span> ifnet_notify_address_params na;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	(<span class="enscript-type">void</span>) pf_ifaddr_hook(ifp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

	<span class="enscript-keyword">if</span> (ifp-&gt;if_output_ctl == NULL)
		<span class="enscript-keyword">return</span> (EOPNOTSUPP);

	bzero(&amp;na, <span class="enscript-keyword">sizeof</span> (na));
	na.address_family = af;

	<span class="enscript-keyword">return</span> (ifp-&gt;if_output_ctl(ifp, IFNET_CTL_NOTIFY_ADDRESS,
	    <span class="enscript-keyword">sizeof</span> (na), &amp;na));
}

errno_t
<span class="enscript-function-name">ifnet_flowid</span>(<span class="enscript-type">struct</span> ifnet *ifp, uint32_t *flowid)
{
	<span class="enscript-keyword">if</span> (ifp == NULL || flowid == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART) ||
	    !(ifp-&gt;if_refflags &amp; IFRF_ATTACHED)) {
		<span class="enscript-keyword">return</span> (ENXIO);
	}

	*flowid = ifp-&gt;if_flowhash;

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ifnet_disable_output</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">int</span> err;

	<span class="enscript-keyword">if</span> (ifp == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART) ||
	    !(ifp-&gt;if_refflags &amp; IFRF_ATTACHED)) {
		<span class="enscript-keyword">return</span> (ENXIO);
	}

	<span class="enscript-keyword">if</span> ((err = ifnet_fc_add(ifp)) == 0) {
		lck_mtx_lock_spin(&amp;ifp-&gt;if_start_lock);
		ifp-&gt;if_start_flags |= IFSF_FLOW_CONTROLLED;
		lck_mtx_unlock(&amp;ifp-&gt;if_start_lock);
	}
	<span class="enscript-keyword">return</span> (err);
}

errno_t
<span class="enscript-function-name">ifnet_enable_output</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-keyword">if</span> (ifp == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_TXSTART) ||
	    !(ifp-&gt;if_refflags &amp; IFRF_ATTACHED)) {
		<span class="enscript-keyword">return</span> (ENXIO);
	}

	ifnet_start_common(ifp, 1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_flowadv</span>(uint32_t flowhash)
{
	<span class="enscript-type">struct</span> ifnet_fc_entry *ifce;
	<span class="enscript-type">struct</span> ifnet *ifp;

	ifce = ifnet_fc_get(flowhash);
	<span class="enscript-keyword">if</span> (ifce == NULL)
		<span class="enscript-keyword">return</span>;

	VERIFY(ifce-&gt;ifce_ifp != NULL);
	ifp = ifce-&gt;ifce_ifp;

	<span class="enscript-comment">/* flow hash gets recalculated per attach, so check */</span>
	<span class="enscript-keyword">if</span> (ifnet_is_attached(ifp, 1)) {
		<span class="enscript-keyword">if</span> (ifp-&gt;if_flowhash == flowhash)
			(<span class="enscript-type">void</span>) ifnet_enable_output(ifp);
		ifnet_decr_iorefcnt(ifp);
	}
	ifnet_fc_entry_free(ifce);
}

<span class="enscript-comment">/*
 * Function to compare ifnet_fc_entries in ifnet flow control tree
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">ifce_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_fc_entry *fc1, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet_fc_entry *fc2)
{
	<span class="enscript-keyword">return</span> (fc1-&gt;ifce_flowhash - fc2-&gt;ifce_flowhash);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ifnet_fc_add</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> ifnet_fc_entry keyfc, *ifce;
	uint32_t flowhash;

	VERIFY(ifp != NULL &amp;&amp; (ifp-&gt;if_eflags &amp; IFEF_TXSTART));
	VERIFY(ifp-&gt;if_flowhash != 0);
	flowhash = ifp-&gt;if_flowhash;

	bzero(&amp;keyfc, <span class="enscript-keyword">sizeof</span> (keyfc));
	keyfc.ifce_flowhash = flowhash;

	lck_mtx_lock_spin(&amp;ifnet_fc_lock);
	ifce = RB_FIND(ifnet_fc_tree, &amp;ifnet_fc_tree, &amp;keyfc);
	<span class="enscript-keyword">if</span> (ifce != NULL &amp;&amp; ifce-&gt;ifce_ifp == ifp) {
		<span class="enscript-comment">/* Entry is already in ifnet_fc_tree, return */</span>
		lck_mtx_unlock(&amp;ifnet_fc_lock);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (ifce != NULL) {
		<span class="enscript-comment">/*
		 * There is a different fc entry with the same flow hash
		 * but different ifp pointer.  There can be a collision
		 * on flow hash but the probability is low.  Let's just
		 * avoid adding a second one when there is a collision.
		 */</span>
		lck_mtx_unlock(&amp;ifnet_fc_lock);
		<span class="enscript-keyword">return</span> (EAGAIN);
	}

	<span class="enscript-comment">/* become regular mutex */</span>
	lck_mtx_convert_spin(&amp;ifnet_fc_lock);

	ifce = zalloc_noblock(ifnet_fc_zone);
	<span class="enscript-keyword">if</span> (ifce == NULL) {
		<span class="enscript-comment">/* memory allocation failed */</span>
		lck_mtx_unlock(&amp;ifnet_fc_lock);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	bzero(ifce, ifnet_fc_zone_size);

	ifce-&gt;ifce_flowhash = flowhash;
	ifce-&gt;ifce_ifp = ifp;

	RB_INSERT(ifnet_fc_tree, &amp;ifnet_fc_tree, ifce);
	lck_mtx_unlock(&amp;ifnet_fc_lock);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifnet_fc_entry *
<span class="enscript-function-name">ifnet_fc_get</span>(uint32_t flowhash)
{
	<span class="enscript-type">struct</span> ifnet_fc_entry keyfc, *ifce;
	<span class="enscript-type">struct</span> ifnet *ifp;

	bzero(&amp;keyfc, <span class="enscript-keyword">sizeof</span> (keyfc));
	keyfc.ifce_flowhash = flowhash;

	lck_mtx_lock_spin(&amp;ifnet_fc_lock);
	ifce = RB_FIND(ifnet_fc_tree, &amp;ifnet_fc_tree, &amp;keyfc);
	<span class="enscript-keyword">if</span> (ifce == NULL) {
		<span class="enscript-comment">/* Entry is not present in ifnet_fc_tree, return */</span>
		lck_mtx_unlock(&amp;ifnet_fc_lock);
		<span class="enscript-keyword">return</span> (NULL);
	}

	RB_REMOVE(ifnet_fc_tree, &amp;ifnet_fc_tree, ifce);

	VERIFY(ifce-&gt;ifce_ifp != NULL);
	ifp = ifce-&gt;ifce_ifp;

	<span class="enscript-comment">/* become regular mutex */</span>
	lck_mtx_convert_spin(&amp;ifnet_fc_lock);

	<span class="enscript-keyword">if</span> (!ifnet_is_attached(ifp, 0)) {
		<span class="enscript-comment">/*
		 * This ifp is not attached or in the process of being
		 * detached; just don't process it.
		 */</span>
		ifnet_fc_entry_free(ifce);
		ifce = NULL;
	}
	lck_mtx_unlock(&amp;ifnet_fc_lock);

	<span class="enscript-keyword">return</span> (ifce);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_fc_entry_free</span>(<span class="enscript-type">struct</span> ifnet_fc_entry *ifce)
{
	zfree(ifnet_fc_zone, ifce);
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">ifnet_calc_flowhash</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> ifnet_flowhash_key fh __attribute__((aligned(8)));
	uint32_t flowhash = 0;

	<span class="enscript-keyword">if</span> (ifnet_flowhash_seed == 0)
		ifnet_flowhash_seed = RandomULong();

	bzero(&amp;fh, <span class="enscript-keyword">sizeof</span> (fh));

	(<span class="enscript-type">void</span>) snprintf(fh.ifk_name, <span class="enscript-keyword">sizeof</span> (fh.ifk_name), <span class="enscript-string">&quot;%s&quot;</span>, ifp-&gt;if_name);
	fh.ifk_unit = ifp-&gt;if_unit;
	fh.ifk_flags = ifp-&gt;if_flags;
	fh.ifk_eflags = ifp-&gt;if_eflags;
	fh.ifk_capabilities = ifp-&gt;if_capabilities;
	fh.ifk_capenable = ifp-&gt;if_capenable;
	fh.ifk_output_sched_model = ifp-&gt;if_output_sched_model;
	fh.ifk_rand1 = RandomULong();
	fh.ifk_rand2 = RandomULong();

<span class="enscript-reference">try_again</span>:
	flowhash = net_flowhash(&amp;fh, <span class="enscript-keyword">sizeof</span> (fh), ifnet_flowhash_seed);
	<span class="enscript-keyword">if</span> (flowhash == 0) {
		<span class="enscript-comment">/* try to get a non-zero flowhash */</span>
		ifnet_flowhash_seed = RandomULong();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;
	}

	<span class="enscript-keyword">return</span> (flowhash);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifnet_set_netsignature</span>(<span class="enscript-type">struct</span> ifnet *ifp, uint8_t family, uint8_t len,
    uint16_t flags, uint8_t *data)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">flags</span>)
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (family) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		if_inetdata_lock_exclusive(ifp);
		<span class="enscript-keyword">if</span> (IN_IFEXTRA(ifp) != NULL) {
			<span class="enscript-keyword">if</span> (len == 0) {
				<span class="enscript-comment">/* Allow clearing the signature */</span>
				IN_IFEXTRA(ifp)-&gt;netsig_len = 0;
				bzero(IN_IFEXTRA(ifp)-&gt;netsig,
				    <span class="enscript-keyword">sizeof</span> (IN_IFEXTRA(ifp)-&gt;netsig));
				if_inetdata_lock_done(ifp);
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (len &gt; <span class="enscript-keyword">sizeof</span> (IN_IFEXTRA(ifp)-&gt;netsig)) {
				error = EINVAL;
				if_inetdata_lock_done(ifp);
				<span class="enscript-keyword">break</span>;
			}
			IN_IFEXTRA(ifp)-&gt;netsig_len = len;
			bcopy(data, IN_IFEXTRA(ifp)-&gt;netsig, len);
		} <span class="enscript-keyword">else</span> {
			error = ENOMEM;
		}
		if_inetdata_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		if_inet6data_lock_exclusive(ifp);
		<span class="enscript-keyword">if</span> (IN6_IFEXTRA(ifp) != NULL) {
			<span class="enscript-keyword">if</span> (len == 0) {
				<span class="enscript-comment">/* Allow clearing the signature */</span>
				IN6_IFEXTRA(ifp)-&gt;netsig_len = 0;
				bzero(IN6_IFEXTRA(ifp)-&gt;netsig,
				    <span class="enscript-keyword">sizeof</span> (IN6_IFEXTRA(ifp)-&gt;netsig));
				if_inet6data_lock_done(ifp);
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (len &gt; <span class="enscript-keyword">sizeof</span> (IN6_IFEXTRA(ifp)-&gt;netsig)) {
				error = EINVAL;
				if_inet6data_lock_done(ifp);
				<span class="enscript-keyword">break</span>;
			}
			IN6_IFEXTRA(ifp)-&gt;netsig_len = len;
			bcopy(data, IN6_IFEXTRA(ifp)-&gt;netsig, len);
		} <span class="enscript-keyword">else</span> {
			error = ENOMEM;
		}
		if_inet6data_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifnet_get_netsignature</span>(<span class="enscript-type">struct</span> ifnet *ifp, uint8_t family, uint8_t *len,
    uint16_t *flags, uint8_t *data)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (ifp == NULL || len == NULL || flags == NULL || data == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">switch</span> (family) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		if_inetdata_lock_shared(ifp);
		<span class="enscript-keyword">if</span> (IN_IFEXTRA(ifp) != NULL) {
			<span class="enscript-keyword">if</span> (*len == 0 || *len &lt; IN_IFEXTRA(ifp)-&gt;netsig_len) {
				error = EINVAL;
				if_inetdata_lock_done(ifp);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> ((*len = IN_IFEXTRA(ifp)-&gt;netsig_len) &gt; 0)
				bcopy(IN_IFEXTRA(ifp)-&gt;netsig, data, *len);
			<span class="enscript-keyword">else</span>
				error = ENOENT;
		} <span class="enscript-keyword">else</span> {
			error = ENOMEM;
		}
		if_inetdata_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		if_inet6data_lock_shared(ifp);
		<span class="enscript-keyword">if</span> (IN6_IFEXTRA(ifp) != NULL) {
			<span class="enscript-keyword">if</span> (*len == 0 || *len &lt; IN6_IFEXTRA(ifp)-&gt;netsig_len) {
				error = EINVAL;
				if_inet6data_lock_done(ifp);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> ((*len = IN6_IFEXTRA(ifp)-&gt;netsig_len) &gt; 0)
				bcopy(IN6_IFEXTRA(ifp)-&gt;netsig, data, *len);
			<span class="enscript-keyword">else</span>
				error = ENOENT;
		} <span class="enscript-keyword">else</span> {
			error = ENOMEM;
		}
		if_inet6data_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (error == 0)
		*flags = 0;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_output_cksum_dbg</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m, uint32_t hoff,
    protocol_family_t pf)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>)
	uint32_t did_sw;

	<span class="enscript-keyword">if</span> (!(hwcksum_dbg_mode &amp; HWCKSUM_DBG_FINALIZE_FORCED) ||
	    (m-&gt;m_pkthdr.csum_flags &amp; (CSUM_TSO_IPV4|CSUM_TSO_IPV6)))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">switch</span> (pf) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET</span>:
		did_sw = in_finalize_cksum(m, hoff, m-&gt;m_pkthdr.csum_flags);
		<span class="enscript-keyword">if</span> (did_sw &amp; CSUM_DELAY_IP)
			hwcksum_dbg_finalized_hdr++;
		<span class="enscript-keyword">if</span> (did_sw &amp; CSUM_DELAY_DATA)
			hwcksum_dbg_finalized_data++;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET6</span>:
		<span class="enscript-comment">/*
		 * Checksum offload should not have been enabled when
		 * extension headers exist; that also means that we
		 * cannot force-finalize packets with extension headers.
		 * Indicate to the callee should it skip such case by
		 * setting optlen to -1.
		 */</span>
		did_sw = in6_finalize_cksum(m, hoff, -1, -1,
		    m-&gt;m_pkthdr.csum_flags);
		<span class="enscript-keyword">if</span> (did_sw &amp; CSUM_DELAY_IPV6_DATA)
			hwcksum_dbg_finalized_data++;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_input_cksum_dbg</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">char</span> *frame_header,
    protocol_family_t pf)
{
	uint16_t sum;
	uint32_t hlen;

	<span class="enscript-keyword">if</span> (frame_header == NULL ||
	    frame_header &lt; (<span class="enscript-type">char</span> *)mbuf_datastart(m) ||
	    frame_header &gt; (<span class="enscript-type">char</span> *)m-&gt;m_data) {
		printf(<span class="enscript-string">&quot;%s: frame header pointer 0x%llx out of range &quot;</span>
		    <span class="enscript-string">&quot;[0x%llx,0x%llx] for mbuf 0x%llx\n&quot;</span>, if_name(ifp),
		    (uint64_t)VM_KERNEL_ADDRPERM(frame_header),
		    (uint64_t)VM_KERNEL_ADDRPERM(mbuf_datastart(m)),
		    (uint64_t)VM_KERNEL_ADDRPERM(m-&gt;m_data),
		    (uint64_t)VM_KERNEL_ADDRPERM(m));
		<span class="enscript-keyword">return</span>;
	}
	hlen = (m-&gt;m_data - frame_header);

	<span class="enscript-keyword">switch</span> (pf) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET6</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * Force partial checksum offload; useful to simulate cases
	 * where the hardware does not support partial checksum offload,
	 * in order to validate correctness throughout the layers above.
	 */</span>
	<span class="enscript-keyword">if</span> (hwcksum_dbg_mode &amp; HWCKSUM_DBG_PARTIAL_FORCED) {
		uint32_t foff = hwcksum_dbg_partial_rxoff_forced;

		<span class="enscript-keyword">if</span> (foff &gt; (uint32_t)m-&gt;m_pkthdr.len)
			<span class="enscript-keyword">return</span>;

		m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_RX_FLAGS;

		<span class="enscript-comment">/* Compute 16-bit 1's complement sum from forced offset */</span>
		sum = m_sum16(m, foff, (m-&gt;m_pkthdr.len - foff));

		m-&gt;m_pkthdr.csum_flags |= (CSUM_DATA_VALID | CSUM_PARTIAL);
		m-&gt;m_pkthdr.csum_rx_val = sum;
		m-&gt;m_pkthdr.csum_rx_start = (foff + hlen);

		hwcksum_dbg_partial_forced++;
		hwcksum_dbg_partial_forced_bytes += m-&gt;m_pkthdr.len;
	}

	<span class="enscript-comment">/*
	 * Partial checksum offload verification (and adjustment);
	 * useful to validate and test cases where the hardware
	 * supports partial checksum offload.
	 */</span>
	<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp;
	    (CSUM_DATA_VALID | CSUM_PARTIAL | CSUM_PSEUDO_HDR)) ==
	    (CSUM_DATA_VALID | CSUM_PARTIAL)) {
		uint32_t rxoff;

		<span class="enscript-comment">/* Start offset must begin after frame header */</span>
		rxoff = m-&gt;m_pkthdr.csum_rx_start;
		<span class="enscript-keyword">if</span> (hlen &gt; rxoff) {
			hwcksum_dbg_bad_rxoff++;
			<span class="enscript-keyword">if</span> (dlil_verbose) {
				printf(<span class="enscript-string">&quot;%s: partial cksum start offset %d &quot;</span>
				    <span class="enscript-string">&quot;is less than frame header length %d for &quot;</span>
				    <span class="enscript-string">&quot;mbuf 0x%llx\n&quot;</span>, if_name(ifp), rxoff, hlen,
				    (uint64_t)VM_KERNEL_ADDRPERM(m));
			}
			<span class="enscript-keyword">return</span>;
		}
		rxoff -=hlen;

		<span class="enscript-keyword">if</span> (!(hwcksum_dbg_mode &amp; HWCKSUM_DBG_PARTIAL_FORCED)) {
			<span class="enscript-comment">/*
			 * Compute the expected 16-bit 1's complement sum;
			 * skip this if we've already computed it above
			 * when partial checksum offload is forced.
			 */</span>
			sum = m_sum16(m, rxoff, (m-&gt;m_pkthdr.len - rxoff));

			<span class="enscript-comment">/* Hardware or driver is buggy */</span>
			<span class="enscript-keyword">if</span> (sum != m-&gt;m_pkthdr.csum_rx_val) {
				hwcksum_dbg_bad_cksum++;
				<span class="enscript-keyword">if</span> (dlil_verbose) {
					printf(<span class="enscript-string">&quot;%s: bad partial cksum value &quot;</span>
					    <span class="enscript-string">&quot;0x%x (expected 0x%x) for mbuf &quot;</span>
					    <span class="enscript-string">&quot;0x%llx [rx_start %d]\n&quot;</span>,
					    if_name(ifp),
					    m-&gt;m_pkthdr.csum_rx_val, sum,
					    (uint64_t)VM_KERNEL_ADDRPERM(m),
					    m-&gt;m_pkthdr.csum_rx_start);
				}
				<span class="enscript-keyword">return</span>;
			}
		}
		hwcksum_dbg_verified++;

		<span class="enscript-comment">/*
		 * This code allows us to emulate various hardwares that
		 * perform 16-bit 1's complement sum beginning at various
		 * start offset values.
		 */</span>
		<span class="enscript-keyword">if</span> (hwcksum_dbg_mode &amp; HWCKSUM_DBG_PARTIAL_RXOFF_ADJ) {
			uint32_t aoff = hwcksum_dbg_partial_rxoff_adj;

			<span class="enscript-keyword">if</span> (aoff == rxoff || aoff &gt; (uint32_t)m-&gt;m_pkthdr.len)
				<span class="enscript-keyword">return</span>;

			sum = m_adj_sum16(m, rxoff, aoff, sum);

			m-&gt;m_pkthdr.csum_rx_val = sum;
			m-&gt;m_pkthdr.csum_rx_start = (aoff + hlen);

			hwcksum_dbg_adjusted++;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_hwcksum_dbg_mode SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	u_int32_t i;
	<span class="enscript-type">int</span> err;

	i = hwcksum_dbg_mode;

	err = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (hwcksum_dbg == 0)
		<span class="enscript-keyword">return</span> (ENODEV);

	<span class="enscript-keyword">if</span> ((i &amp; ~HWCKSUM_DBG_MASK) != 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	hwcksum_dbg_mode = (i &amp; HWCKSUM_DBG_MASK);

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_hwcksum_dbg_partial_rxoff_forced SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	u_int32_t i;
	<span class="enscript-type">int</span> err;

	i = hwcksum_dbg_partial_rxoff_forced;

	err = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (!(hwcksum_dbg_mode &amp; HWCKSUM_DBG_PARTIAL_FORCED))
		<span class="enscript-keyword">return</span> (ENODEV);

	hwcksum_dbg_partial_rxoff_forced = i;

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_hwcksum_dbg_partial_rxoff_adj SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	u_int32_t i;
	<span class="enscript-type">int</span> err;

	i = hwcksum_dbg_partial_rxoff_adj;

	err = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (!(hwcksum_dbg_mode &amp; HWCKSUM_DBG_PARTIAL_RXOFF_ADJ))
		<span class="enscript-keyword">return</span> (ENODEV);

	hwcksum_dbg_partial_rxoff_adj = i;

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_tx_chain_len_stats SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> err;
	
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
			
	}
	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
		<span class="enscript-keyword">return</span> (EPERM);
	}
	err = SYSCTL_OUT(req, &amp;tx_chain_len_stats,
	    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> chain_len_stats));

	<span class="enscript-keyword">return</span> (err);
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-comment">/* Blob for sum16 verification */</span>
<span class="enscript-type">static</span> uint8_t sumdata[] = {
	0x1f, 0x8b, 0x08, 0x08, 0x4c, 0xe5, 0x9a, 0x4f, 0x00, 0x03,
	0x5f, 0x00, 0x5d, 0x91, 0x41, 0x4e, 0xc4, 0x30, 0x0c, 0x45,
	0xf7, 0x9c, 0xc2, 0x07, 0x18, 0xf5, 0x0e, 0xb0, 0xe2, 0x00,
	0x48, 0x88, 0xa5, 0xdb, 0xba, 0x49, 0x34, 0x69, 0xdc, 0x71,
	0x92, 0xa9, 0xc2, 0x8a, 0x6b, 0x70, 0x3d, 0x4e, 0x82, 0x93,
	0xb4, 0x08, 0xd8, 0xc5, 0xb1, 0xfd, 0xff, 0xb3, 0xfd, 0x4c,
	0x42, 0x5f, 0x1f, 0x9f, 0x11, 0x12, 0x43, 0xb2, 0x04, 0x93,
	0xe0, 0x7b, 0x01, 0x0e, 0x14, 0x07, 0x78, 0xd1, 0x78, 0x75,
	0x71, 0x71, 0xe9, 0x08, 0x84, 0x46, 0xf2, 0xc7, 0x3b, 0x09,
	0xe7, 0xd1, 0xd3, 0x8a, 0x57, 0x92, 0x33, 0xcd, 0x39, 0xcc,
	0xb0, 0x91, 0x89, 0xe0, 0x42, 0x53, 0x8b, 0xb7, 0x8c, 0x42,
	0x60, 0xd9, 0x9f, 0x7a, 0x55, 0x19, 0x76, 0xcb, 0x10, 0x49,
	0x35, 0xac, 0x0b, 0x5a, 0x3c, 0xbb, 0x65, 0x51, 0x8c, 0x90,
	0x7c, 0x69, 0x45, 0x45, 0x81, 0xb4, 0x2b, 0x70, 0x82, 0x85,
	0x55, 0x91, 0x17, 0x90, 0xdc, 0x14, 0x1e, 0x35, 0x52, 0xdd,
	0x02, 0x16, 0xef, 0xb5, 0x40, 0x89, 0xe2, 0x46, 0x53, 0xad,
	0x93, 0x6e, 0x98, 0x30, 0xe5, 0x08, 0xb7, 0xcc, 0x03, 0xbc,
	0x71, 0x86, 0x09, 0x43, 0x0d, 0x52, 0xf5, 0xa2, 0xf5, 0xa2,
	0x56, 0x11, 0x8d, 0xa8, 0xf5, 0xee, 0x92, 0x3d, 0xfe, 0x8c,
	0x67, 0x71, 0x8b, 0x0e, 0x2d, 0x70, 0x77, 0xbe, 0xbe, 0xea,
	0xbf, 0x9a, 0x8d, 0x9c, 0x53, 0x53, 0xe5, 0xe0, 0x4b, 0x87,
	0x85, 0xd2, 0x45, 0x95, 0x30, 0xc1, 0xcc, 0xe0, 0x74, 0x54,
	0x13, 0x58, 0xe8, 0xe8, 0x79, 0xa2, 0x09, 0x73, 0xa4, 0x0e,
	0x39, 0x59, 0x0c, 0xe6, 0x9c, 0xb2, 0x4f, 0x06, 0x5b, 0x8e,
	0xcd, 0x17, 0x6c, 0x5e, 0x95, 0x4d, 0x70, 0xa2, 0x0a, 0xbf,
	0xa3, 0xcc, 0x03, 0xbc, 0x5a, 0xe7, 0x75, 0x06, 0x5e, 0x75,
	0xef, 0x58, 0x8e, 0x15, 0xd1, 0x0a, 0x18, 0xff, 0xdd, 0xe6,
	0x02, 0x3b, 0xb5, 0xb4, 0xa1, 0xe0, 0x72, 0xfc, 0xe3, 0xab,
	0x07, 0xe0, 0x4d, 0x65, 0xea, 0x92, 0xeb, 0xf2, 0x7b, 0x17,
	0x05, 0xce, 0xc6, 0xf6, 0x2b, 0xbb, 0x70, 0x3d, 0x00, 0x95,
	0xe0, 0x07, 0x52, 0x3b, 0x58, 0xfc, 0x7c, 0x69, 0x4d, 0xe9,
	0xf7, 0xa9, 0x66, 0x1e, 0x1e, 0xbe, 0x01, 0x69, 0x98, 0xfe,
	0xc8, 0x28, 0x02, 0x00, 0x00
};

<span class="enscript-comment">/* Precomputed 16-bit 1's complement sums for various spans of the above data */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> {
	<span class="enscript-type">int</span>		len;
	uint16_t	sum;
} sumtbl[] = {
	{	11,	0xcb6d	},
	{	20,	0x20dd	},
	{	27,	0xbabd	},
	{	32,	0xf3e8	},
	{	37,	0x197d	},
	{	43,	0x9eae	},
	{	64,	0x4678	},
	{	127,	0x9399	},
	{	256,	0xd147	},
	{	325,	0x0358	}
};
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SUMTBL_MAX</span>	((int)sizeof (sumtbl) / (int)sizeof (sumtbl[0]))

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dlil_verify_sum16</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> mbuf *m;
	uint8_t *buf;
	<span class="enscript-type">int</span> n;

	<span class="enscript-comment">/* Make sure test data plus extra room for alignment fits in cluster */</span>
	_CASSERT((<span class="enscript-keyword">sizeof</span> (sumdata) + (<span class="enscript-keyword">sizeof</span> (uint64_t) * 2)) &lt;= MCLBYTES);

	m = m_getcl(M_WAITOK, MT_DATA, M_PKTHDR);
	MH_ALIGN(m, <span class="enscript-keyword">sizeof</span> (uint32_t));		<span class="enscript-comment">/* 32-bit starting alignment */</span>
	buf = mtod(m, uint8_t *);		<span class="enscript-comment">/* base address */</span>

	<span class="enscript-keyword">for</span> (n = 0; n &lt; SUMTBL_MAX; n++) {
		uint16_t len = sumtbl[n].len;
		<span class="enscript-type">int</span> i;

		<span class="enscript-comment">/* Verify for all possible alignments */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (uint64_t); i++) {
			uint16_t sum;
			uint8_t *c;

			<span class="enscript-comment">/* Copy over test data to mbuf */</span>
			VERIFY(len &lt;= <span class="enscript-keyword">sizeof</span> (sumdata));
			c = buf + i;
			bcopy(sumdata, c, len);

			<span class="enscript-comment">/* Zero-offset test (align by data pointer) */</span>
			m-&gt;m_data = (caddr_t)c;
			m-&gt;m_len = len;
			sum = m_sum16(m, 0, len);

			<span class="enscript-comment">/* Something is horribly broken; stop now */</span>
			<span class="enscript-keyword">if</span> (sum != sumtbl[n].sum) {
				panic(<span class="enscript-string">&quot;%s: broken m_sum16 for len=%d align=%d &quot;</span>
				    <span class="enscript-string">&quot;sum=0x%04x [expected=0x%04x]\n&quot;</span>, __func__,
				    len, i, sum, sumtbl[n].sum);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}

			<span class="enscript-comment">/* Alignment test by offset (fixed data pointer) */</span>
			m-&gt;m_data = (caddr_t)buf;
			m-&gt;m_len = i + len;
			sum = m_sum16(m, i, len);

			<span class="enscript-comment">/* Something is horribly broken; stop now */</span>
			<span class="enscript-keyword">if</span> (sum != sumtbl[n].sum) {
				panic(<span class="enscript-string">&quot;%s: broken m_sum16 for len=%d offset=%d &quot;</span>
				    <span class="enscript-string">&quot;sum=0x%04x [expected=0x%04x]\n&quot;</span>, __func__,
				    len, i, sum, sumtbl[n].sum);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
			<span class="enscript-comment">/* Simple sum16 contiguous buffer test by aligment */</span>
			sum = b_sum16(c, len);

			<span class="enscript-comment">/* Something is horribly broken; stop now */</span>
			<span class="enscript-keyword">if</span> (sum != sumtbl[n].sum) {
				panic(<span class="enscript-string">&quot;%s: broken b_sum16 for len=%d align=%d &quot;</span>
				    <span class="enscript-string">&quot;sum=0x%04x [expected=0x%04x]\n&quot;</span>, __func__,
				    len, i, sum, sumtbl[n].sum);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
		}
	}
	m_freem(m);

	printf(<span class="enscript-string">&quot;DLIL: SUM16 self-tests PASSED\n&quot;</span>);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">CASE_STRINGIFY</span>(x) case x: return #x

__private_extern__ <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">dlil_kev_dl_code_str</span>(u_int32_t event_code)
{
	<span class="enscript-keyword">switch</span> (event_code) {
	CASE_STRINGIFY(KEV_DL_SIFFLAGS);
	CASE_STRINGIFY(KEV_DL_SIFMETRICS);
	CASE_STRINGIFY(KEV_DL_SIFMTU);
	CASE_STRINGIFY(KEV_DL_SIFPHYS);
	CASE_STRINGIFY(KEV_DL_SIFMEDIA);
	CASE_STRINGIFY(KEV_DL_SIFGENERIC);
	CASE_STRINGIFY(KEV_DL_ADDMULTI);
	CASE_STRINGIFY(KEV_DL_DELMULTI);
	CASE_STRINGIFY(KEV_DL_IF_ATTACHED);
	CASE_STRINGIFY(KEV_DL_IF_DETACHING);
	CASE_STRINGIFY(KEV_DL_IF_DETACHED);
	CASE_STRINGIFY(KEV_DL_LINK_OFF);
	CASE_STRINGIFY(KEV_DL_LINK_ON);
	CASE_STRINGIFY(KEV_DL_PROTO_ATTACHED);
	CASE_STRINGIFY(KEV_DL_PROTO_DETACHED);
	CASE_STRINGIFY(KEV_DL_LINK_ADDRESS_CHANGED);
	CASE_STRINGIFY(KEV_DL_WAKEFLAGS_CHANGED);
	CASE_STRINGIFY(KEV_DL_IF_IDLE_ROUTE_REFCNT);
	CASE_STRINGIFY(KEV_DL_IFCAP_CHANGED);
	CASE_STRINGIFY(KEV_DL_LINK_QUALITY_METRIC_CHANGED);
	CASE_STRINGIFY(KEV_DL_NODE_PRESENCE);
	CASE_STRINGIFY(KEV_DL_NODE_ABSENCE);
	CASE_STRINGIFY(KEV_DL_MASTER_ELECTED);
	CASE_STRINGIFY(KEV_DL_ISSUES);
	CASE_STRINGIFY(KEV_DL_IFDELEGATE_CHANGED);
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (<span class="enscript-string">&quot;&quot;</span>);
}

<span class="enscript-comment">/*
 * Mirror the arguments of ifnet_get_local_ports_extended()
 *  ifindex
 *  protocol
 *  flags
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_get_ports_used SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>)
	<span class="enscript-type">int</span> *name = (<span class="enscript-type">int</span> *)arg1;
	<span class="enscript-type">int</span> namelen = arg2;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> idx;
	protocol_family_t protocol;
	u_int32_t flags;
	ifnet_t ifp = NULL;
	u_int8_t *bitfield = NULL;

	<span class="enscript-keyword">if</span> (req-&gt;newptr) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (namelen != 3) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		req-&gt;oldidx = bitstr_size(65536);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (req-&gt;oldlen &lt; bitstr_size(65536)) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	
	idx = name[0];
	protocol = name[1];
	flags = name[2];
	
	
	ifnet_head_lock_shared();
	<span class="enscript-keyword">if</span> (idx &gt; if_index) {
		ifnet_head_done();
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	ifp = ifindex2ifnet[idx];
	ifnet_head_done();
	
	bitfield = _MALLOC(bitstr_size(65536), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (bitfield == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	error = ifnet_get_local_ports_extended(ifp, protocol, flags, bitfield);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: ifnet_get_local_ports_extended() error %d\n&quot;</span>,
		    __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	error = SYSCTL_OUT(req, bitfield, bitstr_size(65536));
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (bitfield != NULL)
		_FREE(bitfield, M_TEMP);
	<span class="enscript-keyword">return</span> (error);
}

</pre>
<hr />
</body></html>