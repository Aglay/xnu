<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>flowhash.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">flowhash.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2011-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * <a href="http://code.google.com/p/smhasher/">http://code.google.com/p/smhasher/</a>
 *
 * Copyright (c) 2009-2011 Austin Appleby.
 *
 * MurmurHash3 was written by Austin Appleby, and is placed in the public
 * domain. The author hereby disclaims copyright to this source code.
 */</span>

<span class="enscript-comment">/*
 * <a href="http://burtleburtle.net/bob/hash/">http://burtleburtle.net/bob/hash/</a>
 *
 * lookup3.c, by Bob Jenkins, May 2006, Public Domain.
 *
 * You can use this free for any purpose.  It's in the public domain.
 * It has no warranty.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/endian.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/flowhash.h&gt;</span>

<span class="enscript-type">static</span> inline u_int32_t <span class="enscript-function-name">getblock32</span>(<span class="enscript-type">const</span> u_int32_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> inline u_int64_t <span class="enscript-function-name">getblock64</span>(<span class="enscript-type">const</span> u_int64_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> inline u_int32_t <span class="enscript-function-name">mh3_fmix32</span>(u_int32_t);
<span class="enscript-type">static</span> inline u_int64_t <span class="enscript-function-name">mh3_fmix64</span>(u_int64_t);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ALIGNED16</span>(v)	((((uintptr_t)(v)) &amp; 1) == 0)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ALIGNED32</span>(v)	((((uintptr_t)(v)) &amp; 3) == 0)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ALIGNED64</span>(v)	((((uintptr_t)(v)) &amp; 7) == 0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ROTL32</span>(x, r)	(((x) &lt;&lt; (r)) | ((x) &gt;&gt; (32 - (r))))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ROTL64</span>(x, r)	(((x) &lt;&lt; (r)) | ((x) &gt;&gt; (64 - (r))))

<span class="enscript-comment">/*
 * The following hash algorithms are selected based on performance:
 *
 * Intel 32-bit:	MurmurHash3_x86_32
 * Intel 64-bit:	MurmurHash3_x64_128
 * ARM, et al:		JHash
 */</span>
#<span class="enscript-reference">if</span>   <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
net_flowhash_fn_t *net_flowhash = net_flowhash_mh3_x64_128;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__i386__ &amp;&amp; !__x86_64__ */</span>
net_flowhash_fn_t *net_flowhash = net_flowhash_jhash;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__i386__ &amp;&amp; !__x86_64__ */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">static</span> inline u_int32_t
<span class="enscript-function-name">getblock32</span>(<span class="enscript-type">const</span> u_int32_t *p, <span class="enscript-type">int</span> i)
{
	<span class="enscript-keyword">return</span> (p[i]);
}

<span class="enscript-type">static</span> inline u_int64_t
<span class="enscript-function-name">getblock64</span>(<span class="enscript-type">const</span> u_int64_t *p, <span class="enscript-type">int</span> i)
{
	<span class="enscript-keyword">return</span> (p[i]);
}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__i386__ &amp;&amp; !__x86_64 */</span>
<span class="enscript-type">static</span> inline u_int32_t
<span class="enscript-function-name">getblock32</span>(<span class="enscript-type">const</span> u_int32_t *p, <span class="enscript-type">int</span> i)
{
	<span class="enscript-type">const</span> u_int8_t *bytes = (u_int8_t *)(<span class="enscript-type">void</span> *)(uintptr_t)(p + i);
	u_int32_t value;

	<span class="enscript-keyword">if</span> (ALIGNED32(p)) {
		value = p[i];
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> == <span class="enscript-variable-name">BIG_ENDIAN</span>
		value =
		    (((u_int32_t)bytes[0]) &lt;&lt; 24) |
		    (((u_int32_t)bytes[1]) &lt;&lt; 16) |
		    (((u_int32_t)bytes[2]) &lt;&lt; 8) |
		    ((u_int32_t)bytes[3]);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* LITTLE_ENDIAN */</span>
		value =
		    (((u_int32_t)bytes[3]) &lt;&lt; 24) |
		    (((u_int32_t)bytes[2]) &lt;&lt; 16) |
		    (((u_int32_t)bytes[1]) &lt;&lt; 8) |
		    ((u_int32_t)bytes[0]);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LITTLE_ENDIAN */</span>
	}
	<span class="enscript-keyword">return</span> (value);
}

<span class="enscript-type">static</span> inline u_int64_t
<span class="enscript-function-name">getblock64</span>(<span class="enscript-type">const</span> u_int64_t *p, <span class="enscript-type">int</span> i)
{
	<span class="enscript-type">const</span> u_int8_t *bytes = (<span class="enscript-type">const</span> u_int8_t *)(<span class="enscript-type">void</span> *)(uintptr_t)(p + i);
	u_int64_t value;

	<span class="enscript-keyword">if</span> (ALIGNED64(p)) {
		value = p[i];
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> == <span class="enscript-variable-name">BIG_ENDIAN</span>
		value =
		    (((u_int64_t)bytes[0]) &lt;&lt; 56) |
		    (((u_int64_t)bytes[1]) &lt;&lt; 48) |
		    (((u_int64_t)bytes[2]) &lt;&lt; 40) |
		    (((u_int64_t)bytes[3]) &lt;&lt; 32) |
		    (((u_int64_t)bytes[4]) &lt;&lt; 24) |
		    (((u_int64_t)bytes[5]) &lt;&lt; 16) |
		    (((u_int64_t)bytes[6]) &lt;&lt; 8) |
		    ((u_int64_t)bytes[7]);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* LITTLE_ENDIAN */</span>
		value =
		    (((u_int64_t)bytes[7]) &lt;&lt; 56) |
		    (((u_int64_t)bytes[6]) &lt;&lt; 48) |
		    (((u_int64_t)bytes[5]) &lt;&lt; 40) |
		    (((u_int64_t)bytes[4]) &lt;&lt; 32) |
		    (((u_int64_t)bytes[3]) &lt;&lt; 24) |
		    (((u_int64_t)bytes[2]) &lt;&lt; 16) |
		    (((u_int64_t)bytes[1]) &lt;&lt; 8) |
		    ((u_int64_t)bytes[0]);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LITTLE_ENDIAN */</span>
	}
	<span class="enscript-keyword">return</span> (value);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__i386__ &amp;&amp; !__x86_64 */</span>

<span class="enscript-type">static</span> inline u_int32_t
<span class="enscript-function-name">mh3_fmix32</span>(u_int32_t h)
{
	h ^= h &gt;&gt; 16;
	h *= 0x85ebca6b;
	h ^= h &gt;&gt; 13;
	h *= 0xc2b2ae35;
	h ^= h &gt;&gt; 16;

	<span class="enscript-keyword">return</span> (h);
}

<span class="enscript-type">static</span> inline u_int64_t
<span class="enscript-function-name">mh3_fmix64</span>(u_int64_t k)
{
	k ^= k &gt;&gt; 33;
	k *= 0xff51afd7ed558ccdLLU;
	k ^= k &gt;&gt; 33;
	k *= 0xc4ceb9fe1a85ec53LLU;
	k ^= k &gt;&gt; 33;

	<span class="enscript-keyword">return</span> (k);
}

<span class="enscript-comment">/*
 * MurmurHash3_x86_32
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH3_X86_32_C1</span>	0xcc9e2d51
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH3_X86_32_C2</span>	0x1b873593

u_int32_t
<span class="enscript-function-name">net_flowhash_mh3_x86_32</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *key, u_int32_t len, <span class="enscript-type">const</span> u_int32_t seed)
{
	<span class="enscript-type">const</span> u_int8_t *data = (<span class="enscript-type">const</span> u_int8_t *)key;
	<span class="enscript-type">const</span> u_int32_t nblocks = len / 4;
	<span class="enscript-type">const</span> u_int32_t *blocks;
	<span class="enscript-type">const</span> u_int8_t *tail;
	u_int32_t h1 = seed, k1;
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">/* body */</span>
	blocks = (<span class="enscript-type">const</span> u_int32_t *)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)(data + nblocks * 4);

	<span class="enscript-keyword">for</span> (i = -nblocks; i; i++) {
		k1 = getblock32(blocks, i);

		k1 *= MH3_X86_32_C1;
		k1 = ROTL32(k1, 15);
		k1 *= MH3_X86_32_C2;

		h1 ^= k1;
		h1 = ROTL32(h1, 13);
		h1 = h1 * 5 + 0xe6546b64;
	}

	<span class="enscript-comment">/* tail */</span>
	tail = (<span class="enscript-type">const</span> u_int8_t *)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)(data + nblocks * 4);
	k1 = 0;

	<span class="enscript-keyword">switch</span> (len &amp; 3) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
		k1 ^= tail[2] &lt;&lt; 16;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		k1 ^= tail[1] &lt;&lt; 8;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		k1 ^= tail[0];
		k1 *= MH3_X86_32_C1;
		k1 = ROTL32(k1, 15);
		k1 *= MH3_X86_32_C2;
		h1 ^= k1;
	};

	<span class="enscript-comment">/* finalization */</span>
	h1 ^= len;

	h1 = mh3_fmix32(h1);

	<span class="enscript-keyword">return</span> (h1);
}

<span class="enscript-comment">/*
 * MurmurHash3_x64_128
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH3_X64_128_C1</span>	0x87c37b91114253d5LLU
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MH3_X64_128_C2</span>	0x4cf5ad432745937fLLU

u_int32_t
<span class="enscript-function-name">net_flowhash_mh3_x64_128</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *key, u_int32_t len, <span class="enscript-type">const</span> u_int32_t seed)
{
	<span class="enscript-type">const</span> u_int8_t *data = (<span class="enscript-type">const</span> u_int8_t *)key;
	<span class="enscript-type">const</span> u_int32_t nblocks = len / 16;
	<span class="enscript-type">const</span> u_int64_t *blocks;
	<span class="enscript-type">const</span> u_int8_t *tail;
	u_int64_t h1 = seed, k1;
	u_int64_t h2 = seed, k2;
	u_int32_t i;

	<span class="enscript-comment">/* body */</span>
	blocks = (<span class="enscript-type">const</span> u_int64_t *)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)data;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; nblocks; i++) {
		k1 = getblock64(blocks, i * 2 + 0);
		k2 = getblock64(blocks, i * 2 + 1);

		k1 *= MH3_X64_128_C1;
		k1 = ROTL64(k1, 31);
		k1 *= MH3_X64_128_C2;
		h1 ^= k1;

		h1 = ROTL64(h1, 27);
		h1 += h2;
		h1 = h1 * 5 + 0x52dce729;

		k2 *= MH3_X64_128_C2;
		k2 = ROTL64(k2, 33);
		k2 *= MH3_X64_128_C1;
		h2 ^= k2;

		h2 = ROTL64(h2, 31);
		h2 += h1;
		h2 = h2 * 5+ 0x38495ab5;
	}

	<span class="enscript-comment">/* tail */</span>
	tail = (<span class="enscript-type">const</span> u_int8_t *)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)(data + nblocks * 16);
	k1 = 0;
	k2 = 0;

	<span class="enscript-keyword">switch</span> (len &amp; 15) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">15</span>:
		k2 ^= ((u_int64_t)tail[14]) &lt;&lt; 48;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">14</span>:
		k2 ^= ((u_int64_t)tail[13]) &lt;&lt; 40;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">13</span>:
		k2 ^= ((u_int64_t)tail[12]) &lt;&lt; 32;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">12</span>:
		k2 ^= ((u_int64_t)tail[11]) &lt;&lt; 24;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">11</span>:
		k2 ^= ((u_int64_t)tail[10]) &lt;&lt; 16;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">10</span>:
		k2 ^= ((u_int64_t)tail[9]) &lt;&lt; 8;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">9</span>:
		k2 ^= ((u_int64_t)tail[8]) &lt;&lt; 0;
		k2 *= MH3_X64_128_C2;
		k2 = ROTL64(k2, 33);
		k2 *= MH3_X64_128_C1;
		h2 ^= k2;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:
		k1 ^= ((u_int64_t)tail[7]) &lt;&lt; 56;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">7</span>:
		k1 ^= ((u_int64_t)tail[6]) &lt;&lt; 48;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
		k1 ^= ((u_int64_t)tail[5]) &lt;&lt; 40;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
		k1 ^= ((u_int64_t)tail[4]) &lt;&lt; 32;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		k1 ^= ((u_int64_t)tail[3]) &lt;&lt; 24;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
		k1 ^= ((u_int64_t)tail[2]) &lt;&lt; 16;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		k1 ^= ((u_int64_t)tail[1]) &lt;&lt; 8;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		k1 ^= ((u_int64_t)tail[0]) &lt;&lt; 0;
		k1 *= MH3_X64_128_C1;
		k1 = ROTL64(k1, 31);
		k1 *= MH3_X64_128_C2;
		h1 ^= k1;
	};

	<span class="enscript-comment">/* finalization */</span>
	h1 ^= len;
	h2 ^= len;

	h1 += h2;
	h2 += h1;

	h1 = mh3_fmix64(h1);
	h2 = mh3_fmix64(h2);

	h1 += h2;
	h2 += h1;

	<span class="enscript-comment">/* throw all but lowest 32-bit */</span>
	<span class="enscript-keyword">return</span> (h1 &amp; 0xffffffff);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">JHASH_INIT</span>	0xdeadbeef

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">JHASH_MIX</span>(a, b, c) {			\
	a -= c;  a ^= ROTL32(c, 4);   c += b;	\
	b -= a;  b ^= ROTL32(a, 6);   a += c;	\
	c -= b;  c ^= ROTL32(b, 8);   b += a;	\
	a -= c;  a ^= ROTL32(c, 16);  c += b;	\
	b -= a;  b ^= ROTL32(a, 19);  a += c;	\
	c -= b;  c ^= ROTL32(b, 4);   b += a;	\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">JHASH_FINAL</span>(a, b, c) {			\
	c ^= b;  c -= ROTL32(b, 14);		\
	a ^= c;  a -= ROTL32(c, 11);		\
	b ^= a;  b -= ROTL32(a, 25);		\
	c ^= b;  c -= ROTL32(b, 16);		\
	a ^= c;  a -= ROTL32(c, 4);		\
	b ^= a;  b -= ROTL32(a, 14);		\
	c ^= b;  c -= ROTL32(b, 24);		\
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> == <span class="enscript-variable-name">BIG_ENDIAN</span>
<span class="enscript-comment">/*
 * hashbig()
 */</span>
u_int32_t
<span class="enscript-function-name">net_flowhash_jhash</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *key, u_int32_t len, <span class="enscript-type">const</span> u_int32_t seed)
{
	u_int32_t a, b, c;

	<span class="enscript-comment">/* Set up the internal state */</span>
	a = b = c = JHASH_INIT + len + seed;

	<span class="enscript-keyword">if</span> (ALIGNED32(key)) {
		<span class="enscript-comment">/* read 32-bit chunks */</span>
		<span class="enscript-type">const</span> u_int32_t *k = (<span class="enscript-type">const</span> u_int32_t *)key;

		<span class="enscript-comment">/*
		 * all but last block:
		 * aligned reads and affect 32 bits of (a,b,c)
		 */</span>
		<span class="enscript-keyword">while</span> (len &gt; 12) {
			a += k[0];
			b += k[1];
			c += k[2];
			JHASH_MIX(a, b, c);
			len -= 12;
			k += 3;
		}

		<span class="enscript-comment">/*
		 * handle the last (probably partial) block
		 *
		 * &quot;k[2] &lt;&lt; 8&quot; actually reads beyond the end of the string,
		 * but then shifts out the part it's not allowed to read.
		 * Because the string is aligned, the illegal read is in
		 * the same word as the rest of the string.  The masking
		 * trick does make the hash noticably faster for short
		 * strings (like English words).
		 */</span>
		<span class="enscript-keyword">switch</span> (len) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">12</span>:
			c += k[2];
			b += k[1];
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">11</span>:
			c += k[2] &amp; 0xffffff00;
			b += k[1];
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">10</span>:
			c += k[2] &amp; 0xffff0000;
			b += k[1];
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">9</span>:
			c += k[2] &amp; 0xff000000;
			b += k[1];
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:
			b += k[1];
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">7</span>:
			b += k[1] &amp; 0xffffff00;
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
			b += k[1] &amp; 0xffff0000;
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
			b += k[1] &amp; 0xff000000;
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
			a += k[0] &amp; 0xffffff00;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
			a += k[0] &amp; 0xffff0000;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
			a += k[0] &amp; 0xff000000;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
			<span class="enscript-comment">/* zero length requires no mixing */</span>
			<span class="enscript-keyword">return</span> (c);
		}

		JHASH_FINAL(a, b, c);

		<span class="enscript-keyword">return</span> (c);
	}

	<span class="enscript-comment">/* need to read the key one byte at a time */</span>
	<span class="enscript-type">const</span> u_int8_t *k = (<span class="enscript-type">const</span> u_int8_t *)key;

	<span class="enscript-comment">/* all but the last block: affect some 32 bits of (a,b,c) */</span>
	<span class="enscript-keyword">while</span> (len &gt; 12) {
		a += ((u_int32_t)k[0]) &lt;&lt; 24;
		a += ((u_int32_t)k[1]) &lt;&lt; 16;
		a += ((u_int32_t)k[2]) &lt;&lt; 8;
		a += ((u_int32_t)k[3]);
		b += ((u_int32_t)k[4]) &lt;&lt; 24;
		b += ((u_int32_t)k[5]) &lt;&lt; 16;
		b += ((u_int32_t)k[6]) &lt;&lt; 8;
		b += ((u_int32_t)k[7]);
		c += ((u_int32_t)k[8]) &lt;&lt; 24;
		c += ((u_int32_t)k[9]) &lt;&lt; 16;
		c += ((u_int32_t)k[10]) &lt;&lt; 8;
		c += ((u_int32_t)k[11]);
		JHASH_MIX(a, b, c);
		len -= 12;
		k += 12;
	}

	<span class="enscript-comment">/* last block: affect all 32 bits of (c) */</span>
	<span class="enscript-keyword">switch</span> (len) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">12</span>:
		c += k[11];
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">11</span>:
		c += ((u_int32_t)k[10]) &lt;&lt; 8;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">10</span>:
		c += ((u_int32_t)k[9]) &lt;&lt; 16;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">9</span>:
		c += ((u_int32_t)k[8]) &lt;&lt; 24;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:
		b += k[7];
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">7</span>:
		b += ((u_int32_t)k[6]) &lt;&lt; 8;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
		b += ((u_int32_t)k[5]) &lt;&lt; 16;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
		b += ((u_int32_t)k[4]) &lt;&lt; 24;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		a += k[3];
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
		a += ((u_int32_t)k[2]) &lt;&lt; 8;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		a += ((u_int32_t)k[1]) &lt;&lt; 16;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		a += ((u_int32_t)k[0]) &lt;&lt; 24;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		<span class="enscript-comment">/* zero length requires no mixing */</span>
		<span class="enscript-keyword">return</span> (c);
	}

	JHASH_FINAL(a, b, c);

	<span class="enscript-keyword">return</span> (c);
}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* LITTLE_ENDIAN */</span>
<span class="enscript-comment">/*
 * hashlittle()
 */</span>
u_int32_t
<span class="enscript-function-name">net_flowhash_jhash</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *key, u_int32_t len, <span class="enscript-type">const</span> u_int32_t seed)
{
	u_int32_t a, b, c;

	<span class="enscript-comment">/* Set up the internal state */</span>
	a = b = c = JHASH_INIT + len + seed;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
	<span class="enscript-comment">/*
	 * On i386/x86_64, it is faster to read 32-bit chunks if the key
	 * is aligned 32-bit OR not 16-bit, and perform 16-bit reads if it
	 * is aligned 16-bit.
	 */</span>
	<span class="enscript-keyword">if</span> (ALIGNED32(key) || !ALIGNED16(key)) {
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !defined(__i386__) &amp;&amp; !defined(__x86_64__) */</span>
	<span class="enscript-keyword">if</span> (ALIGNED32(key)) {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !defined(__i386__) &amp;&amp; !defined(__x86_64__) */</span>
		<span class="enscript-comment">/* read 32-bit chunks */</span>
		<span class="enscript-type">const</span> u_int32_t *k = (<span class="enscript-type">const</span> u_int32_t *)key;

		<span class="enscript-comment">/*
		 * all but last block:
		 * aligned reads and affect 32 bits of (a,b,c)
		 */</span>
		<span class="enscript-keyword">while</span> (len &gt; 12) {
			a += k[0];
			b += k[1];
			c += k[2];
			JHASH_MIX(a, b, c);
			len -= 12;
			k += 3;
		}

		<span class="enscript-comment">/*
		 * handle the last (probably partial) block
		 *
		 * &quot;k[2] &amp; 0xffffff&quot; actually reads beyond the end of the
		 * string, but then masks off the part it's not allowed
		 * to read.  Because the string is aligned, the masked-off
		 * tail is in the same word as the rest of the string.
		 * The masking trick does make the hash noticably faster
		 * for short strings (like English words).
		 */</span>
		<span class="enscript-keyword">switch</span> (len) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">12</span>:
			c += k[2];
			b += k[1];
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">11</span>:
			c += k[2] &amp; 0xffffff;
			b += k[1];
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">10</span>:
			c += k[2] &amp; 0xffff;
			b += k[1];
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">9</span>:
			c += k[2] &amp; 0xff;
			b += k[1];
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:
			b += k[1];
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">7</span>:
			b += k[1] &amp; 0xffffff;
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
			b += k[1] &amp; 0xffff;
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
			b += k[1] &amp; 0xff;
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
			a += k[0] &amp; 0xffffff;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
			a += k[0] &amp; 0xffff;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
			a += k[0] &amp; 0xff;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
			<span class="enscript-comment">/* zero length requires no mixing */</span>
			<span class="enscript-keyword">return</span> (c);
		}

		JHASH_FINAL(a, b, c);

		<span class="enscript-keyword">return</span> (c);
	}
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ALIGNED16(key)) {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !defined(__i386__) &amp;&amp; !defined(__x86_64__) */</span>
		<span class="enscript-comment">/* read 16-bit chunks */</span>
		<span class="enscript-type">const</span> u_int16_t *k = (<span class="enscript-type">const</span> u_int16_t *)key;
		<span class="enscript-type">const</span> u_int8_t *k8;

		<span class="enscript-comment">/* all but last block: aligned reads and different mixing */</span>
		<span class="enscript-keyword">while</span> (len &gt; 12) {
			a += k[0] + (((u_int32_t)k[1]) &lt;&lt; 16);
			b += k[2] + (((u_int32_t)k[3]) &lt;&lt; 16);
			c += k[4] + (((u_int32_t)k[5]) &lt;&lt; 16);
			JHASH_MIX(a, b, c);
			len -= 12;
			k += 6;
		}

		<span class="enscript-comment">/* handle the last (probably partial) block */</span>
		k8 = (<span class="enscript-type">const</span> u_int8_t *)k;
		<span class="enscript-keyword">switch</span> (len) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">12</span>:
			c += k[4] + (((u_int32_t)k[5]) &lt;&lt; 16);
			b += k[2] + (((u_int32_t)k[3]) &lt;&lt; 16);
			a += k[0] + (((u_int32_t)k[1]) &lt;&lt; 16);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">11</span>:
			c += ((u_int32_t)k8[10]) &lt;&lt; 16;
			<span class="enscript-comment">/* FALLTHRU */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">10</span>:
			c += k[4];
			b += k[2] + (((u_int32_t)k[3]) &lt;&lt; 16);
			a += k[0] + (((u_int32_t)k[1]) &lt;&lt; 16);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">9</span>:
			c += k8[8];
			<span class="enscript-comment">/* FALLTHRU */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:
			b += k[2] + (((u_int32_t)k[3]) &lt;&lt; 16);
			a += k[0] + (((u_int32_t)k[1]) &lt;&lt; 16);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">7</span>:
			b += ((u_int32_t)k8[6]) &lt;&lt; 16;
			<span class="enscript-comment">/* FALLTHRU */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
			b += k[2];
			a += k[0] + (((u_int32_t)k[1]) &lt;&lt; 16);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
			b += k8[4];
			<span class="enscript-comment">/* FALLTHRU */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
			a += k[0] + (((u_int32_t)k[1]) &lt;&lt; 16);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
			a += ((u_int32_t)k8[2]) &lt;&lt; 16;
			<span class="enscript-comment">/* FALLTHRU */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
			a += k[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
			a += k8[0];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
			<span class="enscript-comment">/* zero length requires no mixing */</span>
			<span class="enscript-keyword">return</span> (c);
		}

		JHASH_FINAL(a, b, c);

		<span class="enscript-keyword">return</span> (c);
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
	}

	<span class="enscript-comment">/* need to read the key one byte at a time */</span>
	<span class="enscript-type">const</span> u_int8_t *k = (<span class="enscript-type">const</span> u_int8_t *)key;

	<span class="enscript-comment">/* all but the last block: affect some 32 bits of (a,b,c) */</span>
	<span class="enscript-keyword">while</span> (len &gt; 12) {
		a += k[0];
		a += ((u_int32_t)k[1]) &lt;&lt; 8;
		a += ((u_int32_t)k[2]) &lt;&lt; 16;
		a += ((u_int32_t)k[3]) &lt;&lt; 24;
		b += k[4];
		b += ((u_int32_t)k[5]) &lt;&lt; 8;
		b += ((u_int32_t)k[6]) &lt;&lt; 16;
		b += ((u_int32_t)k[7]) &lt;&lt; 24;
		c += k[8];
		c += ((u_int32_t)k[9]) &lt;&lt; 8;
		c += ((u_int32_t)k[10]) &lt;&lt; 16;
		c += ((u_int32_t)k[11]) &lt;&lt; 24;
		JHASH_MIX(a, b, c);
		len -= 12;
		k += 12;
	}

	<span class="enscript-comment">/* last block: affect all 32 bits of (c) */</span>
	<span class="enscript-keyword">switch</span> (len) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">12</span>:
		c += ((u_int32_t)k[11]) &lt;&lt; 24;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">11</span>:
		c += ((u_int32_t)k[10]) &lt;&lt; 16;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">10</span>:
		c += ((u_int32_t)k[9]) &lt;&lt; 8;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">9</span>:
		c += k[8];
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">8</span>:
		b += ((u_int32_t)k[7]) &lt;&lt; 24;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">7</span>:
		b += ((u_int32_t)k[6]) &lt;&lt; 16;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
		b += ((u_int32_t)k[5]) &lt;&lt; 8;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
		b += k[4];
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		a += ((u_int32_t)k[3]) &lt;&lt; 24;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
		a += ((u_int32_t)k[2]) &lt;&lt; 16;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		a += ((u_int32_t)k[1]) &lt;&lt; 8;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		a += k[0];
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		<span class="enscript-comment">/* zero length requires no mixing */</span>
		<span class="enscript-keyword">return</span> (c);
	}

	JHASH_FINAL(a, b, c);

	<span class="enscript-keyword">return</span> (c);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !defined(__i386__) &amp;&amp; !defined(__x86_64__) */</span>
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LITTLE_ENDIAN */</span>
</pre>
<hr />
</body></html>