<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>pktsched_hfsc.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">pktsched_hfsc.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$OpenBSD: altq_hfsc.c,v 1.25 2007/09/13 20:40:02 chl Exp $	*/</span>
<span class="enscript-comment">/*	$KAME: altq_hfsc.c,v 1.17 2002/11/29 07:48:33 kjc Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (c) 1997-1999 Carnegie Mellon University. All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation is hereby granted (including for commercial or
 * for-profit use), provided that both the copyright notice and this
 * permission notice appear in all copies of the software, derivative
 * works, or modified versions, and any portions thereof.
 *
 * THIS SOFTWARE IS EXPERIMENTAL AND IS KNOWN TO HAVE BUGS, SOME OF
 * WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON PROVIDES THIS
 * SOFTWARE IN ITS ``AS IS'' CONDITION, AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 *
 * Carnegie Mellon encourages (but does not require) users of this
 * software to return any improvements or extensions that they make,
 * and to grant Carnegie Mellon the rights to redistribute these
 * changes without encumbrance.
 */</span>
<span class="enscript-comment">/*
 * H-FSC is described in Proceedings of SIGCOMM'97,
 * &quot;A Hierarchical Fair Service Curve Algorithm for Link-Sharing,
 * Real-Time and Priority Service&quot;
 * by Ion Stoica, Hui Zhang, and T. S. Eugene Ng.
 *
 * Oleg Cherevko &lt;<a href="mailto:olwi@aq.ml.com.ua">olwi@aq.ml.com.ua</a>&gt; added the upperlimit for link-sharing.
 * when a class has an upperlimit, the fit-time is computed from the
 * upperlimit service curve.  the link-sharing scheduler does not schedule
 * a class whose fit-time exceeds the current time.
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PKTSCHED_HFSC</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pktsched/pktsched_hfsc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>

<span class="enscript-comment">/*
 * function prototypes
 */</span>
#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfsc_enqueue_ifclassq</span>(<span class="enscript-type">struct</span> ifclassq *, <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">hfsc_dequeue_ifclassq</span>(<span class="enscript-type">struct</span> ifclassq *, cqdq_op_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfsc_request_ifclassq</span>(<span class="enscript-type">struct</span> ifclassq *, cqrq_t, <span class="enscript-type">void</span> *);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfsc_addq</span>(<span class="enscript-type">struct</span> hfsc_class *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> pf_mtag *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">hfsc_getq</span>(<span class="enscript-type">struct</span> hfsc_class *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">hfsc_pollq</span>(<span class="enscript-type">struct</span> hfsc_class *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfsc_purgeq</span>(<span class="enscript-type">struct</span> hfsc_if *, <span class="enscript-type">struct</span> hfsc_class *, u_int32_t,
    u_int32_t *, u_int32_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfsc_print_sc</span>(<span class="enscript-type">struct</span> hfsc_if *, u_int32_t, u_int64_t,
    <span class="enscript-type">struct</span> service_curve *, <span class="enscript-type">struct</span> internal_sc *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfsc_updateq_linkrate</span>(<span class="enscript-type">struct</span> hfsc_if *, <span class="enscript-type">struct</span> hfsc_class *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfsc_updateq</span>(<span class="enscript-type">struct</span> hfsc_if *, <span class="enscript-type">struct</span> hfsc_class *, cqev_t);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfsc_clear_interface</span>(<span class="enscript-type">struct</span> hfsc_if *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> hfsc_class *<span class="enscript-function-name">hfsc_class_create</span>(<span class="enscript-type">struct</span> hfsc_if *,
    <span class="enscript-type">struct</span> service_curve *, <span class="enscript-type">struct</span> service_curve *, <span class="enscript-type">struct</span> service_curve *,
    <span class="enscript-type">struct</span> hfsc_class *, u_int32_t, <span class="enscript-type">int</span>, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfsc_class_destroy</span>(<span class="enscript-type">struct</span> hfsc_if *, <span class="enscript-type">struct</span> hfsc_class *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfsc_destroy_locked</span>(<span class="enscript-type">struct</span> hfsc_if *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> hfsc_class *<span class="enscript-function-name">hfsc_nextclass</span>(<span class="enscript-type">struct</span> hfsc_class *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> hfsc_class *<span class="enscript-function-name">hfsc_clh_to_clp</span>(<span class="enscript-type">struct</span> hfsc_if *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">hfsc_style</span>(<span class="enscript-type">struct</span> hfsc_if *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">set_active</span>(<span class="enscript-type">struct</span> hfsc_class *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">set_passive</span>(<span class="enscript-type">struct</span> hfsc_class *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">init_ed</span>(<span class="enscript-type">struct</span> hfsc_class *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">update_ed</span>(<span class="enscript-type">struct</span> hfsc_class *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">update_d</span>(<span class="enscript-type">struct</span> hfsc_class *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">init_vf</span>(<span class="enscript-type">struct</span> hfsc_class *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">update_vf</span>(<span class="enscript-type">struct</span> hfsc_class *, u_int32_t, u_int64_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">update_cfmin</span>(<span class="enscript-type">struct</span> hfsc_class *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ellist_insert</span>(<span class="enscript-type">struct</span> hfsc_class *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ellist_remove</span>(<span class="enscript-type">struct</span> hfsc_class *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ellist_update</span>(<span class="enscript-type">struct</span> hfsc_class *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> hfsc_class *<span class="enscript-function-name">ellist_get_mindl</span>(ellist_t *, u_int64_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">actlist_insert</span>(<span class="enscript-type">struct</span> hfsc_class *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">actlist_remove</span>(<span class="enscript-type">struct</span> hfsc_class *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">actlist_update</span>(<span class="enscript-type">struct</span> hfsc_class *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> hfsc_class *<span class="enscript-function-name">actlist_firstfit</span>(<span class="enscript-type">struct</span> hfsc_class *, u_int64_t);

<span class="enscript-type">static</span> inline u_int64_t	seg_x2y(u_int64_t, u_int64_t);
<span class="enscript-type">static</span> inline u_int64_t	seg_y2x(u_int64_t, u_int64_t);
<span class="enscript-type">static</span> inline u_int64_t	m2sm(u_int64_t);
<span class="enscript-type">static</span> inline u_int64_t	m2ism(u_int64_t);
<span class="enscript-type">static</span> inline u_int64_t	d2dx(u_int64_t);
<span class="enscript-type">static</span> u_int64_t <span class="enscript-function-name">sm2m</span>(u_int64_t);
<span class="enscript-type">static</span> u_int64_t <span class="enscript-function-name">dx2d</span>(u_int64_t);

<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">sc2isc</span>(<span class="enscript-type">struct</span> hfsc_class *, <span class="enscript-type">struct</span> service_curve *,
    <span class="enscript-type">struct</span> internal_sc *, u_int64_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rtsc_init</span>(<span class="enscript-type">struct</span> runtime_sc *, <span class="enscript-type">struct</span> internal_sc *,
    u_int64_t, u_int64_t);
<span class="enscript-type">static</span> u_int64_t <span class="enscript-function-name">rtsc_y2x</span>(<span class="enscript-type">struct</span> runtime_sc *, u_int64_t);
<span class="enscript-type">static</span> u_int64_t <span class="enscript-function-name">rtsc_x2y</span>(<span class="enscript-type">struct</span> runtime_sc *, u_int64_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rtsc_min</span>(<span class="enscript-type">struct</span> runtime_sc *, <span class="enscript-type">struct</span> internal_sc *,
    u_int64_t, u_int64_t);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HFSC_ZONE_MAX</span>	32		<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HFSC_ZONE_NAME</span>	<span class="enscript-string">&quot;pktsched_hfsc&quot;</span>	<span class="enscript-comment">/* zone name */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> hfsc_size;		<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *hfsc_zone;		<span class="enscript-comment">/* zone for hfsc_if */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HFSC_CL_ZONE_MAX</span>	32	<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HFSC_CL_ZONE_NAME</span>	<span class="enscript-string">&quot;pktsched_hfsc_cl&quot;</span> <span class="enscript-comment">/* zone name */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> hfsc_cl_size;	<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *hfsc_cl_zone;	<span class="enscript-comment">/* zone for hfsc_class */</span>

<span class="enscript-comment">/*
 * macros
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">HFSC_IS_A_PARENT_CLASS</span>(cl)	((cl)-&gt;cl_children != NULL)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HT_INFINITY</span>	0xffffffffffffffffLL	<span class="enscript-comment">/* infinite time value */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">hfsc_init</span>(<span class="enscript-type">void</span>)
{
	hfsc_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> hfsc_if);
	hfsc_zone = zinit(hfsc_size, HFSC_ZONE_MAX * hfsc_size,
	    0, HFSC_ZONE_NAME);
	<span class="enscript-keyword">if</span> (hfsc_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__, HFSC_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(hfsc_zone, Z_EXPAND, TRUE);
	zone_change(hfsc_zone, Z_CALLERACCT, TRUE);

	hfsc_cl_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> hfsc_class);
	hfsc_cl_zone = zinit(hfsc_cl_size, HFSC_CL_ZONE_MAX * hfsc_cl_size,
	    0, HFSC_CL_ZONE_NAME);
	<span class="enscript-keyword">if</span> (hfsc_cl_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__, HFSC_CL_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(hfsc_cl_zone, Z_EXPAND, TRUE);
	zone_change(hfsc_cl_zone, Z_CALLERACCT, TRUE);
}

<span class="enscript-type">struct</span> hfsc_if *
<span class="enscript-function-name">hfsc_alloc</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> how, boolean_t altq)
{
	<span class="enscript-type">struct</span> hfsc_if *hif;

	hif = (how == M_WAITOK) ? zalloc(hfsc_zone) : zalloc_noblock(hfsc_zone);
	<span class="enscript-keyword">if</span> (hif == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	bzero(hif, hfsc_size);
	TAILQ_INIT(&amp;hif-&gt;hif_eligible);
	hif-&gt;hif_ifq = &amp;ifp-&gt;if_snd;
	<span class="enscript-keyword">if</span> (altq) {
		hif-&gt;hif_maxclasses = HFSC_MAX_CLASSES;
		hif-&gt;hif_flags |= HFSCIFF_ALTQ;
	} <span class="enscript-keyword">else</span> {
		hif-&gt;hif_maxclasses = IFCQ_SC_MAX + 1;	<span class="enscript-comment">/* incl. root class */</span>
	}

	<span class="enscript-keyword">if</span> ((hif-&gt;hif_class_tbl = _MALLOC(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> hfsc_class *) *
	    hif-&gt;hif_maxclasses, M_DEVBUF, M_WAITOK|M_ZERO)) == NULL) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s: %s unable to allocate class table array\n&quot;</span>,
		    if_name(ifp), hfsc_style(hif));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
	}

	<span class="enscript-keyword">if</span> (pktsched_verbose) {
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: %s scheduler allocated\n&quot;</span>,
		    if_name(ifp), hfsc_style(hif));
	}

	<span class="enscript-keyword">return</span> (hif);

<span class="enscript-reference">error</span>:
	<span class="enscript-keyword">if</span> (hif-&gt;hif_class_tbl != NULL) {
		_FREE(hif-&gt;hif_class_tbl, M_DEVBUF);
		hif-&gt;hif_class_tbl = NULL;
	}
	zfree(hfsc_zone, hif);

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfsc_destroy</span>(<span class="enscript-type">struct</span> hfsc_if *hif)
{
	<span class="enscript-type">struct</span> ifclassq *ifq = hif-&gt;hif_ifq;
	<span class="enscript-type">int</span> err;

	IFCQ_LOCK(ifq);
	err = hfsc_destroy_locked(hif);
	IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfsc_destroy_locked</span>(<span class="enscript-type">struct</span> hfsc_if *hif)
{
	IFCQ_LOCK_ASSERT_HELD(hif-&gt;hif_ifq);

	(<span class="enscript-type">void</span>) hfsc_clear_interface(hif);
	(<span class="enscript-type">void</span>) hfsc_class_destroy(hif, hif-&gt;hif_rootclass);

	VERIFY(hif-&gt;hif_class_tbl != NULL);
	_FREE(hif-&gt;hif_class_tbl, M_DEVBUF);
	hif-&gt;hif_class_tbl = NULL;

	<span class="enscript-keyword">if</span> (pktsched_verbose) {
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: %s scheduler destroyed\n&quot;</span>,
		    if_name(HFSCIF_IFP(hif)), hfsc_style(hif));
	}

	zfree(hfsc_zone, hif);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * bring the interface back to the initial state by discarding
 * all the filters and classes except the root class.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfsc_clear_interface</span>(<span class="enscript-type">struct</span> hfsc_if *hif)
{
	<span class="enscript-type">struct</span> hfsc_class	*cl;

	IFCQ_LOCK_ASSERT_HELD(hif-&gt;hif_ifq);

	<span class="enscript-comment">/* clear out the classes */</span>
	<span class="enscript-keyword">while</span> (hif-&gt;hif_rootclass != NULL &amp;&amp;
	    (cl = hif-&gt;hif_rootclass-&gt;cl_children) != NULL) {
		<span class="enscript-comment">/*
		 * remove the first leaf class found in the hierarchy
		 * then start over
		 */</span>
		<span class="enscript-keyword">for</span> (; cl != NULL; cl = hfsc_nextclass(cl)) {
			<span class="enscript-keyword">if</span> (!HFSC_IS_A_PARENT_CLASS(cl)) {
				(<span class="enscript-type">void</span>) hfsc_class_destroy(hif, cl);
				<span class="enscript-keyword">break</span>;
			}
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* discard all the queued packets on the interface */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfsc_purge</span>(<span class="enscript-type">struct</span> hfsc_if *hif)
{
	<span class="enscript-type">struct</span> hfsc_class *cl;

	IFCQ_LOCK_ASSERT_HELD(hif-&gt;hif_ifq);

	<span class="enscript-keyword">for</span> (cl = hif-&gt;hif_rootclass; cl != NULL; cl = hfsc_nextclass(cl)) {
		<span class="enscript-keyword">if</span> (!qempty(&amp;cl-&gt;cl_q))
			hfsc_purgeq(hif, cl, 0, NULL, NULL);
	}
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-comment">/*
	 * This assertion is safe to be made only when PF_ALTQ is not
	 * configured; otherwise, IFCQ_LEN represents the sum of the
	 * packets managed by ifcq_disc and altq_disc instances, which
	 * is possible when transitioning between the two.
	 */</span>
	VERIFY(IFCQ_LEN(hif-&gt;hif_ifq) == 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !PF_ALTQ */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">hfsc_event</span>(<span class="enscript-type">struct</span> hfsc_if *hif, cqev_t ev)
{
	<span class="enscript-type">struct</span> hfsc_class *cl;

	IFCQ_LOCK_ASSERT_HELD(hif-&gt;hif_ifq);

	<span class="enscript-keyword">for</span> (cl = hif-&gt;hif_rootclass; cl != NULL; cl = hfsc_nextclass(cl))
		hfsc_updateq(hif, cl, ev);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfsc_add_queue</span>(<span class="enscript-type">struct</span> hfsc_if *hif, <span class="enscript-type">struct</span> service_curve *rtsc,
    <span class="enscript-type">struct</span> service_curve *lssc, <span class="enscript-type">struct</span> service_curve *ulsc,
    u_int32_t qlimit, <span class="enscript-type">int</span> flags, u_int32_t parent_qid, u_int32_t qid,
    <span class="enscript-type">struct</span> hfsc_class **clp)
{
	<span class="enscript-type">struct</span> hfsc_class *cl = NULL, *parent;

	IFCQ_LOCK_ASSERT_HELD(hif-&gt;hif_ifq);

	<span class="enscript-keyword">if</span> (parent_qid == HFSC_NULLCLASS_HANDLE &amp;&amp; hif-&gt;hif_rootclass == NULL)
		parent = NULL;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((parent = hfsc_clh_to_clp(hif, parent_qid)) == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (hfsc_clh_to_clp(hif, qid) != NULL)
		<span class="enscript-keyword">return</span> (EBUSY);

	cl = hfsc_class_create(hif, rtsc, lssc, ulsc, parent,
	    qlimit, flags, qid);
	<span class="enscript-keyword">if</span> (cl == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	<span class="enscript-keyword">if</span> (clp != NULL)
		*clp = cl;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> hfsc_class *
<span class="enscript-function-name">hfsc_class_create</span>(<span class="enscript-type">struct</span> hfsc_if *hif, <span class="enscript-type">struct</span> service_curve *rsc,
    <span class="enscript-type">struct</span> service_curve *fsc, <span class="enscript-type">struct</span> service_curve *usc,
    <span class="enscript-type">struct</span> hfsc_class *parent, u_int32_t qlimit, <span class="enscript-type">int</span> flags, u_int32_t qid)
{
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> ifclassq *ifq;
	<span class="enscript-type">struct</span> hfsc_class *cl, *p;
	u_int64_t eff_rate;
	u_int32_t i;

	IFCQ_LOCK_ASSERT_HELD(hif-&gt;hif_ifq);

	<span class="enscript-comment">/* Sanitize flags unless internally configured */</span>
	<span class="enscript-keyword">if</span> (hif-&gt;hif_flags &amp; HFSCIFF_ALTQ)
		flags &amp;= HFCF_USERFLAGS;

	<span class="enscript-keyword">if</span> (hif-&gt;hif_classes &gt;= hif-&gt;hif_maxclasses) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s: %s out of classes! (max %d)\n&quot;</span>,
		    if_name(HFSCIF_IFP(hif)), hfsc_style(hif),
		    hif-&gt;hif_maxclasses);
		<span class="enscript-keyword">return</span> (NULL);
	}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CLASSQ_RED</span>
	<span class="enscript-keyword">if</span> (flags &amp; HFCF_RED) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s: %s RED not available!\n&quot;</span>,
		    if_name(HFSCIF_IFP(hif)), hfsc_style(hif));
		<span class="enscript-keyword">return</span> (NULL);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !CLASSQ_RED */</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CLASSQ_RIO</span>
	<span class="enscript-keyword">if</span> (flags &amp; HFCF_RIO) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s: %s RIO not available!\n&quot;</span>,
		    if_name(HFSCIF_IFP(hif)), hfsc_style(hif));
		<span class="enscript-keyword">return</span> (NULL);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RIO */</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CLASSQ_BLUE</span>
	<span class="enscript-keyword">if</span> (flags &amp; HFCF_BLUE) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s: %s BLUE not available!\n&quot;</span>,
		    if_name(HFSCIF_IFP(hif)), hfsc_style(hif));
		<span class="enscript-keyword">return</span> (NULL);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_BLUE */</span>

	<span class="enscript-comment">/* These are mutually exclusive */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; (HFCF_RED|HFCF_RIO|HFCF_BLUE|HFCF_SFB)) &amp;&amp;
	    (flags &amp; (HFCF_RED|HFCF_RIO|HFCF_BLUE|HFCF_SFB)) != HFCF_RED &amp;&amp;
	    (flags &amp; (HFCF_RED|HFCF_RIO|HFCF_BLUE|HFCF_SFB)) != HFCF_RIO &amp;&amp;
	    (flags &amp; (HFCF_RED|HFCF_RIO|HFCF_BLUE|HFCF_SFB)) != HFCF_BLUE &amp;&amp;
	    (flags &amp; (HFCF_RED|HFCF_RIO|HFCF_BLUE|HFCF_SFB)) != HFCF_SFB) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s: %s more than one RED|RIO|BLUE|SFB\n&quot;</span>,
		    if_name(HFSCIF_IFP(hif)), hfsc_style(hif));
		<span class="enscript-keyword">return</span> (NULL);
	}

	cl = zalloc(hfsc_cl_zone);
	<span class="enscript-keyword">if</span> (cl == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	bzero(cl, hfsc_cl_size);
	TAILQ_INIT(&amp;cl-&gt;cl_actc);
	ifq = hif-&gt;hif_ifq;
	ifp = HFSCIF_IFP(hif);

	<span class="enscript-keyword">if</span> (qlimit == 0 || qlimit &gt; IFCQ_MAXLEN(ifq)) {
		qlimit = IFCQ_MAXLEN(ifq);
		<span class="enscript-keyword">if</span> (qlimit == 0)
			qlimit = DEFAULT_QLIMIT;  <span class="enscript-comment">/* use default */</span>
	}
	_qinit(&amp;cl-&gt;cl_q, Q_DROPTAIL, qlimit);

	cl-&gt;cl_flags = flags;
	<span class="enscript-keyword">if</span> (flags &amp; (HFCF_RED|HFCF_RIO|HFCF_BLUE|HFCF_SFB)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RED</span> || <span class="enscript-variable-name">CLASSQ_RIO</span>
		<span class="enscript-type">int</span> pkttime;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RED || CLASSQ_RIO */</span>
		u_int64_t m2;

		m2 = 0;
		<span class="enscript-keyword">if</span> (rsc != NULL &amp;&amp; rsc-&gt;m2 &gt; m2)
			m2 = rsc-&gt;m2;
		<span class="enscript-keyword">if</span> (fsc != NULL &amp;&amp; fsc-&gt;m2 &gt; m2)
			m2 = fsc-&gt;m2;
		<span class="enscript-keyword">if</span> (usc != NULL &amp;&amp; usc-&gt;m2 &gt; m2)
			m2 = usc-&gt;m2;

		cl-&gt;cl_qflags = 0;
		<span class="enscript-keyword">if</span> (flags &amp; HFCF_ECN) {
			<span class="enscript-keyword">if</span> (flags &amp; HFCF_BLUE)
				cl-&gt;cl_qflags |= BLUEF_ECN;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; HFCF_SFB)
				cl-&gt;cl_qflags |= SFBF_ECN;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; HFCF_RED)
				cl-&gt;cl_qflags |= REDF_ECN;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; HFCF_RIO)
				cl-&gt;cl_qflags |= RIOF_ECN;
		}
		<span class="enscript-keyword">if</span> (flags &amp; HFCF_FLOWCTL) {
			<span class="enscript-keyword">if</span> (flags &amp; HFCF_SFB)
				cl-&gt;cl_qflags |= SFBF_FLOWCTL;
		}
		<span class="enscript-keyword">if</span> (flags &amp; HFCF_CLEARDSCP) {
			<span class="enscript-keyword">if</span> (flags &amp; HFCF_RIO)
				cl-&gt;cl_qflags |= RIOF_CLEARDSCP;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RED</span> || <span class="enscript-variable-name">CLASSQ_RIO</span>
		<span class="enscript-comment">/*
		 * XXX: RED &amp; RIO should be watching link speed and MTU
		 *	events and recompute pkttime accordingly.
		 */</span>
		<span class="enscript-keyword">if</span> (m2 &lt; 8)
			pkttime = 1000 * 1000 * 1000; <span class="enscript-comment">/* 1 sec */</span>
		<span class="enscript-keyword">else</span>
			pkttime = (int64_t)ifp-&gt;if_mtu * 1000 * 1000 * 1000 /
			    (m2 / 8);

		<span class="enscript-comment">/* Test for exclusivity {RED,RIO,BLUE,SFB} was done above */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RED</span>
		<span class="enscript-keyword">if</span> (flags &amp; HFCF_RED) {
			cl-&gt;cl_red = red_alloc(ifp, 0, 0,
			    qlimit(&amp;cl-&gt;cl_q) * 10/100,
			    qlimit(&amp;cl-&gt;cl_q) * 30/100,
			    cl-&gt;cl_qflags, pkttime);
			<span class="enscript-keyword">if</span> (cl-&gt;cl_red != NULL)
				qtype(&amp;cl-&gt;cl_q) = Q_RED;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RED */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RIO</span>
		<span class="enscript-keyword">if</span> (flags &amp; HFCF_RIO) {
			cl-&gt;cl_rio =
			    rio_alloc(ifp, 0, NULL, cl-&gt;cl_qflags, pkttime);
			<span class="enscript-keyword">if</span> (cl-&gt;cl_rio != NULL)
				qtype(&amp;cl-&gt;cl_q) = Q_RIO;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RIO */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RED || CLASSQ_RIO */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_BLUE</span>
		<span class="enscript-keyword">if</span> (flags &amp; HFCF_BLUE) {
			cl-&gt;cl_blue = blue_alloc(ifp, 0, 0, cl-&gt;cl_qflags);
			<span class="enscript-keyword">if</span> (cl-&gt;cl_blue != NULL)
				qtype(&amp;cl-&gt;cl_q) = Q_BLUE;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_BLUE */</span>
		<span class="enscript-keyword">if</span> (flags &amp; HFCF_SFB) {
			<span class="enscript-keyword">if</span> (!(cl-&gt;cl_flags &amp; HFCF_LAZY))
				cl-&gt;cl_sfb = sfb_alloc(ifp, qid,
				    qlimit(&amp;cl-&gt;cl_q), cl-&gt;cl_qflags);
			<span class="enscript-keyword">if</span> (cl-&gt;cl_sfb != NULL || (cl-&gt;cl_flags &amp; HFCF_LAZY))
				qtype(&amp;cl-&gt;cl_q) = Q_SFB;
		}
	}

	cl-&gt;cl_id = hif-&gt;hif_classid++;
	cl-&gt;cl_handle = qid;
	cl-&gt;cl_hif = hif;
	cl-&gt;cl_parent = parent;

	eff_rate = ifnet_output_linkrate(HFSCIF_IFP(hif));
	hif-&gt;hif_eff_rate = eff_rate;

	<span class="enscript-keyword">if</span> (rsc != NULL &amp;&amp; (rsc-&gt;m1 != 0 || rsc-&gt;m2 != 0) &amp;&amp;
	    (!(rsc-&gt;fl &amp; HFSCF_M1_PCT) || (rsc-&gt;m1 &gt; 0 &amp;&amp; rsc-&gt;m1 &lt;= 100)) &amp;&amp;
	    (!(rsc-&gt;fl &amp; HFSCF_M2_PCT) || (rsc-&gt;m2 &gt; 0 &amp;&amp; rsc-&gt;m2 &lt;= 100))) {
		rsc-&gt;fl &amp;= HFSCF_USERFLAGS;
		cl-&gt;cl_flags |= HFCF_RSC;
		cl-&gt;cl_rsc0 = *rsc;
		(<span class="enscript-type">void</span>) sc2isc(cl, &amp;cl-&gt;cl_rsc0, &amp;cl-&gt;cl_rsc, eff_rate);
		rtsc_init(&amp;cl-&gt;cl_deadline, &amp;cl-&gt;cl_rsc, 0, 0);
		rtsc_init(&amp;cl-&gt;cl_eligible, &amp;cl-&gt;cl_rsc, 0, 0);
	}
	<span class="enscript-keyword">if</span> (fsc != NULL &amp;&amp; (fsc-&gt;m1 != 0 || fsc-&gt;m2 != 0) &amp;&amp;
	    (!(fsc-&gt;fl &amp; HFSCF_M1_PCT) || (fsc-&gt;m1 &gt; 0 &amp;&amp; fsc-&gt;m1 &lt;= 100)) &amp;&amp;
	    (!(fsc-&gt;fl &amp; HFSCF_M2_PCT) || (fsc-&gt;m2 &gt; 0 &amp;&amp; fsc-&gt;m2 &lt;= 100))) {
		fsc-&gt;fl &amp;= HFSCF_USERFLAGS;
		cl-&gt;cl_flags |= HFCF_FSC;
		cl-&gt;cl_fsc0 = *fsc;
		(<span class="enscript-type">void</span>) sc2isc(cl, &amp;cl-&gt;cl_fsc0, &amp;cl-&gt;cl_fsc, eff_rate);
		rtsc_init(&amp;cl-&gt;cl_virtual, &amp;cl-&gt;cl_fsc, 0, 0);
	}
	<span class="enscript-keyword">if</span> (usc != NULL &amp;&amp; (usc-&gt;m1 != 0 || usc-&gt;m2 != 0) &amp;&amp;
	    (!(usc-&gt;fl &amp; HFSCF_M1_PCT) || (usc-&gt;m1 &gt; 0 &amp;&amp; usc-&gt;m1 &lt;= 100)) &amp;&amp;
	    (!(usc-&gt;fl &amp; HFSCF_M2_PCT) || (usc-&gt;m2 &gt; 0 &amp;&amp; usc-&gt;m2 &lt;= 100))) {
		usc-&gt;fl &amp;= HFSCF_USERFLAGS;
		cl-&gt;cl_flags |= HFCF_USC;
		cl-&gt;cl_usc0 = *usc;
		(<span class="enscript-type">void</span>) sc2isc(cl, &amp;cl-&gt;cl_usc0, &amp;cl-&gt;cl_usc, eff_rate);
		rtsc_init(&amp;cl-&gt;cl_ulimit, &amp;cl-&gt;cl_usc, 0, 0);
	}

	<span class="enscript-comment">/*
	 * find a free slot in the class table.  if the slot matching
	 * the lower bits of qid is free, use this slot.  otherwise,
	 * use the first free slot.
	 */</span>
	i = qid % hif-&gt;hif_maxclasses;
	<span class="enscript-keyword">if</span> (hif-&gt;hif_class_tbl[i] == NULL) {
		hif-&gt;hif_class_tbl[i] = cl;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; hif-&gt;hif_maxclasses; i++)
			<span class="enscript-keyword">if</span> (hif-&gt;hif_class_tbl[i] == NULL) {
				hif-&gt;hif_class_tbl[i] = cl;
				<span class="enscript-keyword">break</span>;
			}
		<span class="enscript-keyword">if</span> (i == hif-&gt;hif_maxclasses) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_ret</span>;
		}
	}
	hif-&gt;hif_classes++;

	<span class="enscript-keyword">if</span> (flags &amp; HFCF_DEFAULTCLASS)
		hif-&gt;hif_defaultclass = cl;

	<span class="enscript-keyword">if</span> (parent == NULL) {
		<span class="enscript-comment">/* this is root class */</span>
		hif-&gt;hif_rootclass = cl;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* add this class to the children list of the parent */</span>
		<span class="enscript-keyword">if</span> ((p = parent-&gt;cl_children) == NULL)
			parent-&gt;cl_children = cl;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">while</span> (p-&gt;cl_siblings != NULL)
				p = p-&gt;cl_siblings;
			p-&gt;cl_siblings = cl;
		}
	}

	<span class="enscript-keyword">if</span> (pktsched_verbose) {
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: %s created qid=%d pqid=%d qlimit=%d &quot;</span>
		    <span class="enscript-string">&quot;flags=%b\n&quot;</span>, if_name(ifp), hfsc_style(hif), cl-&gt;cl_handle,
		    (cl-&gt;cl_parent != NULL) ? cl-&gt;cl_parent-&gt;cl_handle : 0,
		    qlimit(&amp;cl-&gt;cl_q), cl-&gt;cl_flags, HFCF_BITS);
		<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_RSC) {
			hfsc_print_sc(hif, cl-&gt;cl_handle, eff_rate,
			    &amp;cl-&gt;cl_rsc0, &amp;cl-&gt;cl_rsc, <span class="enscript-string">&quot;rsc&quot;</span>);
		}
		<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_FSC) {
			hfsc_print_sc(hif, cl-&gt;cl_handle, eff_rate,
			    &amp;cl-&gt;cl_fsc0, &amp;cl-&gt;cl_fsc, <span class="enscript-string">&quot;fsc&quot;</span>);
		}
		<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_USC) {
			hfsc_print_sc(hif, cl-&gt;cl_handle, eff_rate,
			    &amp;cl-&gt;cl_usc0, &amp;cl-&gt;cl_usc, <span class="enscript-string">&quot;usc&quot;</span>);
		}
	}

	<span class="enscript-keyword">return</span> (cl);

<span class="enscript-reference">err_ret</span>:
	<span class="enscript-keyword">if</span> (cl-&gt;cl_qalg.ptr != NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RIO</span>
		<span class="enscript-keyword">if</span> (q_is_rio(&amp;cl-&gt;cl_q))
			rio_destroy(cl-&gt;cl_rio);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RIO */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RED</span>
		<span class="enscript-keyword">if</span> (q_is_red(&amp;cl-&gt;cl_q))
			red_destroy(cl-&gt;cl_red);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RED */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_BLUE</span>
		<span class="enscript-keyword">if</span> (q_is_blue(&amp;cl-&gt;cl_q))
			blue_destroy(cl-&gt;cl_blue);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_BLUE */</span>
		<span class="enscript-keyword">if</span> (q_is_sfb(&amp;cl-&gt;cl_q) &amp;&amp; cl-&gt;cl_sfb != NULL)
			sfb_destroy(cl-&gt;cl_sfb);
		cl-&gt;cl_qalg.ptr = NULL;
		qtype(&amp;cl-&gt;cl_q) = Q_DROPTAIL;
		qstate(&amp;cl-&gt;cl_q) = QS_RUNNING;
	}
	zfree(hfsc_cl_zone, cl);
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfsc_remove_queue</span>(<span class="enscript-type">struct</span> hfsc_if *hif, u_int32_t qid)
{
	<span class="enscript-type">struct</span> hfsc_class *cl;

	IFCQ_LOCK_ASSERT_HELD(hif-&gt;hif_ifq);

	<span class="enscript-keyword">if</span> ((cl = hfsc_clh_to_clp(hif, qid)) == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (hfsc_class_destroy(hif, cl));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfsc_class_destroy</span>(<span class="enscript-type">struct</span> hfsc_if *hif, <span class="enscript-type">struct</span> hfsc_class *cl)
{
	u_int32_t i;

	<span class="enscript-keyword">if</span> (cl == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (HFSC_IS_A_PARENT_CLASS(cl))
		<span class="enscript-keyword">return</span> (EBUSY);

	IFCQ_LOCK_ASSERT_HELD(hif-&gt;hif_ifq);

	<span class="enscript-keyword">if</span> (!qempty(&amp;cl-&gt;cl_q))
		hfsc_purgeq(hif, cl, 0, NULL, NULL);

	<span class="enscript-keyword">if</span> (cl-&gt;cl_parent == NULL) {
		<span class="enscript-comment">/* this is root class */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> hfsc_class *p = cl-&gt;cl_parent-&gt;cl_children;

		<span class="enscript-keyword">if</span> (p == cl)
			cl-&gt;cl_parent-&gt;cl_children = cl-&gt;cl_siblings;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> (p-&gt;cl_siblings == cl) {
				p-&gt;cl_siblings = cl-&gt;cl_siblings;
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">while</span> ((p = p-&gt;cl_siblings) != NULL);
		VERIFY(p != NULL);
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt; hif-&gt;hif_maxclasses; i++)
		<span class="enscript-keyword">if</span> (hif-&gt;hif_class_tbl[i] == cl) {
			hif-&gt;hif_class_tbl[i] = NULL;
			<span class="enscript-keyword">break</span>;
		}

	hif-&gt;hif_classes--;

	<span class="enscript-keyword">if</span> (cl-&gt;cl_qalg.ptr != NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RIO</span>
		<span class="enscript-keyword">if</span> (q_is_rio(&amp;cl-&gt;cl_q))
			rio_destroy(cl-&gt;cl_rio);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RIO */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RED</span>
		<span class="enscript-keyword">if</span> (q_is_red(&amp;cl-&gt;cl_q))
			red_destroy(cl-&gt;cl_red);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RED */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_BLUE</span>
		<span class="enscript-keyword">if</span> (q_is_blue(&amp;cl-&gt;cl_q))
			blue_destroy(cl-&gt;cl_blue);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_BLUE */</span>
		<span class="enscript-keyword">if</span> (q_is_sfb(&amp;cl-&gt;cl_q) &amp;&amp; cl-&gt;cl_sfb != NULL)
			sfb_destroy(cl-&gt;cl_sfb);
		cl-&gt;cl_qalg.ptr = NULL;
		qtype(&amp;cl-&gt;cl_q) = Q_DROPTAIL;
		qstate(&amp;cl-&gt;cl_q) = QS_RUNNING;
	}

	<span class="enscript-keyword">if</span> (cl == hif-&gt;hif_rootclass)
		hif-&gt;hif_rootclass = NULL;
	<span class="enscript-keyword">if</span> (cl == hif-&gt;hif_defaultclass)
		hif-&gt;hif_defaultclass = NULL;

	<span class="enscript-keyword">if</span> (pktsched_verbose) {
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: %s destroyed qid=%d slot=%d\n&quot;</span>,
		    if_name(HFSCIF_IFP(hif)), hfsc_style(hif),
		    cl-&gt;cl_handle, cl-&gt;cl_id);
	}

	zfree(hfsc_cl_zone, cl);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * hfsc_nextclass returns the next class in the tree.
 *   usage:
 *	for (cl = hif-&gt;hif_rootclass; cl != NULL; cl = hfsc_nextclass(cl))
 *		do_something;
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> hfsc_class *
<span class="enscript-function-name">hfsc_nextclass</span>(<span class="enscript-type">struct</span> hfsc_class *cl)
{
	IFCQ_LOCK_ASSERT_HELD(cl-&gt;cl_hif-&gt;hif_ifq);

	<span class="enscript-keyword">if</span> (cl-&gt;cl_children != NULL)
		cl = cl-&gt;cl_children;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cl-&gt;cl_siblings != NULL)
		cl = cl-&gt;cl_siblings;
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">while</span> ((cl = cl-&gt;cl_parent) != NULL)
			<span class="enscript-keyword">if</span> (cl-&gt;cl_siblings) {
				cl = cl-&gt;cl_siblings;
				<span class="enscript-keyword">break</span>;
			}
	}

	<span class="enscript-keyword">return</span> (cl);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfsc_enqueue</span>(<span class="enscript-type">struct</span> hfsc_if *hif, <span class="enscript-type">struct</span> hfsc_class *cl, <span class="enscript-type">struct</span> mbuf *m,
    <span class="enscript-type">struct</span> pf_mtag *t)
{
	<span class="enscript-type">struct</span> ifclassq *ifq = hif-&gt;hif_ifq;
	u_int32_t len;
	<span class="enscript-type">int</span> ret;

	IFCQ_LOCK_ASSERT_HELD(ifq);
	VERIFY(cl == NULL || cl-&gt;cl_hif == hif);

	<span class="enscript-keyword">if</span> (cl == NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
		cl = hfsc_clh_to_clp(hif, t-&gt;pftag_qid);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !PF_ALTQ */</span>
		cl = hfsc_clh_to_clp(hif, 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !PF_ALTQ */</span>
		<span class="enscript-keyword">if</span> (cl == NULL || HFSC_IS_A_PARENT_CLASS(cl)) {
			cl = hif-&gt;hif_defaultclass;
			<span class="enscript-keyword">if</span> (cl == NULL) {
				IFCQ_CONVERT_LOCK(ifq);
				m_freem(m);
				<span class="enscript-keyword">return</span> (ENOBUFS);
			}
		}
	}

	len = m_pktlen(m);

	ret = hfsc_addq(cl, m, t);
	<span class="enscript-keyword">if</span> (ret != 0) {
		<span class="enscript-keyword">if</span> (ret == CLASSQEQ_SUCCESS_FC) {
			<span class="enscript-comment">/* packet enqueued, return advisory feedback */</span>
			ret = EQFULL;
		} <span class="enscript-keyword">else</span> {
			VERIFY(ret == CLASSQEQ_DROPPED ||
			    ret == CLASSQEQ_DROPPED_FC ||
			    ret == CLASSQEQ_DROPPED_SP);
			<span class="enscript-comment">/* packet has been freed in hfsc_addq */</span>
			PKTCNTR_ADD(&amp;cl-&gt;cl_stats.drop_cnt, 1, len);
			IFCQ_DROP_ADD(ifq, 1, len);
			<span class="enscript-keyword">switch</span> (ret) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">CLASSQEQ_DROPPED</span>:
				<span class="enscript-keyword">return</span> (ENOBUFS);
			<span class="enscript-keyword">case</span> <span class="enscript-reference">CLASSQEQ_DROPPED_FC</span>:
				<span class="enscript-keyword">return</span> (EQFULL);
			<span class="enscript-keyword">case</span> <span class="enscript-reference">CLASSQEQ_DROPPED_SP</span>:
				<span class="enscript-keyword">return</span> (EQSUSPENDED);
			}
			<span class="enscript-comment">/* NOT_REACHED */</span>
		}
	}
	IFCQ_INC_LEN(ifq);
	IFCQ_INC_BYTES(ifq, len);
	cl-&gt;cl_hif-&gt;hif_packets++;

	<span class="enscript-comment">/* successfully queued. */</span>
	<span class="enscript-keyword">if</span> (qlen(&amp;cl-&gt;cl_q) == 1)
		set_active(cl, len);

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/*
 * note: CLASSQDQ_POLL returns the next packet without removing the packet
 *	from the queue.  CLASSQDQ_REMOVE is a normal dequeue operation.
 *	CLASSQDQ_REMOVE must return the same packet if called immediately
 *	after CLASSQDQ_POLL.
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">hfsc_dequeue</span>(<span class="enscript-type">struct</span> hfsc_if *hif, cqdq_op_t op)
{
	<span class="enscript-type">struct</span> ifclassq *ifq = hif-&gt;hif_ifq;
	<span class="enscript-type">struct</span> hfsc_class *cl;
	<span class="enscript-type">struct</span> mbuf *m;
	u_int32_t len, next_len;
	<span class="enscript-type">int</span> realtime = 0;
	u_int64_t cur_time;

	IFCQ_LOCK_ASSERT_HELD(ifq);

	<span class="enscript-keyword">if</span> (hif-&gt;hif_packets == 0)
		<span class="enscript-comment">/* no packet in the tree */</span>
		<span class="enscript-keyword">return</span> (NULL);

	cur_time = read_machclk();

	<span class="enscript-keyword">if</span> (op == CLASSQDQ_REMOVE &amp;&amp; hif-&gt;hif_pollcache != NULL) {

		cl = hif-&gt;hif_pollcache;
		hif-&gt;hif_pollcache = NULL;
		<span class="enscript-comment">/* check if the class was scheduled by real-time criteria */</span>
		<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_RSC)
			realtime = (cl-&gt;cl_e &lt;= cur_time);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * if there are eligible classes, use real-time criteria.
		 * find the class with the minimum deadline among
		 * the eligible classes.
		 */</span>
		<span class="enscript-keyword">if</span> ((cl = ellist_get_mindl(&amp;hif-&gt;hif_eligible, cur_time))
		    != NULL) {
			realtime = 1;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">int</span> fits = 0;
			<span class="enscript-comment">/*
			 * use link-sharing criteria
			 * get the class with the minimum vt in the hierarchy
			 */</span>
			cl = hif-&gt;hif_rootclass;
			<span class="enscript-keyword">while</span> (HFSC_IS_A_PARENT_CLASS(cl)) {

				cl = actlist_firstfit(cl, cur_time);
				<span class="enscript-keyword">if</span> (cl == NULL) {
					<span class="enscript-keyword">if</span> (fits &gt; 0)
						log(LOG_ERR, <span class="enscript-string">&quot;%s: %s &quot;</span>
						    <span class="enscript-string">&quot;%d fit but none found\n&quot;</span>,
						    if_name(HFSCIF_IFP(hif)),
						    hfsc_style(hif), fits);
					<span class="enscript-keyword">return</span> (NULL);
				}
				<span class="enscript-comment">/*
				 * update parent's cl_cvtmin.
				 * don't update if the new vt is smaller.
				 */</span>
				<span class="enscript-keyword">if</span> (cl-&gt;cl_parent-&gt;cl_cvtmin &lt; cl-&gt;cl_vt)
					cl-&gt;cl_parent-&gt;cl_cvtmin = cl-&gt;cl_vt;
				fits++;
			}
		}

		<span class="enscript-keyword">if</span> (op == CLASSQDQ_POLL) {
			hif-&gt;hif_pollcache = cl;
			m = hfsc_pollq(cl);
			<span class="enscript-keyword">return</span> (m);
		}
	}

	m = hfsc_getq(cl);
	VERIFY(m != NULL);
	len = m_pktlen(m);
	cl-&gt;cl_hif-&gt;hif_packets--;
	IFCQ_DEC_LEN(ifq);
	IFCQ_DEC_BYTES(ifq, len);
	IFCQ_XMIT_ADD(ifq, 1, len);
	PKTCNTR_ADD(&amp;cl-&gt;cl_stats.xmit_cnt, 1, len);

	update_vf(cl, len, cur_time);
	<span class="enscript-keyword">if</span> (realtime)
		cl-&gt;cl_cumul += len;

	<span class="enscript-keyword">if</span> (!qempty(&amp;cl-&gt;cl_q)) {
		<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_RSC) {
			<span class="enscript-comment">/* update ed */</span>
			next_len = m_pktlen(qhead(&amp;cl-&gt;cl_q));

			<span class="enscript-keyword">if</span> (realtime)
				update_ed(cl, next_len);
			<span class="enscript-keyword">else</span>
				update_d(cl, next_len);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* the class becomes passive */</span>
		set_passive(cl);
	}

	<span class="enscript-keyword">return</span> (m);

}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfsc_addq</span>(<span class="enscript-type">struct</span> hfsc_class *cl, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> pf_mtag *t)
{
	<span class="enscript-type">struct</span> ifclassq *ifq = cl-&gt;cl_hif-&gt;hif_ifq;

	IFCQ_LOCK_ASSERT_HELD(ifq);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RIO</span>
	<span class="enscript-keyword">if</span> (q_is_rio(&amp;cl-&gt;cl_q))
		<span class="enscript-keyword">return</span> (rio_addq(cl-&gt;cl_rio, &amp;cl-&gt;cl_q, m, t));
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RIO */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RED</span>
	<span class="enscript-keyword">if</span> (q_is_red(&amp;cl-&gt;cl_q))
		<span class="enscript-keyword">return</span> (red_addq(cl-&gt;cl_red, &amp;cl-&gt;cl_q, m, t));
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RED */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_BLUE</span>
	<span class="enscript-keyword">if</span> (q_is_blue(&amp;cl-&gt;cl_q))
		<span class="enscript-keyword">return</span> (blue_addq(cl-&gt;cl_blue, &amp;cl-&gt;cl_q, m, t));
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_BLUE */</span>
	<span class="enscript-keyword">if</span> (q_is_sfb(&amp;cl-&gt;cl_q)) {
		<span class="enscript-keyword">if</span> (cl-&gt;cl_sfb == NULL) {
			<span class="enscript-type">struct</span> ifnet *ifp = HFSCIF_IFP(cl-&gt;cl_hif);

			VERIFY(cl-&gt;cl_flags &amp; HFCF_LAZY);
			IFCQ_CONVERT_LOCK(ifq);

			cl-&gt;cl_sfb = sfb_alloc(ifp, cl-&gt;cl_handle,
			    qlimit(&amp;cl-&gt;cl_q), cl-&gt;cl_qflags);
			<span class="enscript-keyword">if</span> (cl-&gt;cl_sfb == NULL) {
				<span class="enscript-comment">/* fall back to droptail */</span>
				qtype(&amp;cl-&gt;cl_q) = Q_DROPTAIL;
				cl-&gt;cl_flags &amp;= ~HFCF_SFB;
				cl-&gt;cl_qflags &amp;= ~(SFBF_ECN | SFBF_FLOWCTL);

				log(LOG_ERR, <span class="enscript-string">&quot;%s: %s SFB lazy allocation &quot;</span>
				    <span class="enscript-string">&quot;failed for qid=%d slot=%d, falling back &quot;</span>
				    <span class="enscript-string">&quot;to DROPTAIL\n&quot;</span>, if_name(ifp),
				    hfsc_style(cl-&gt;cl_hif), cl-&gt;cl_handle,
				    cl-&gt;cl_id);
			}
		}
		<span class="enscript-keyword">if</span> (cl-&gt;cl_sfb != NULL)
			<span class="enscript-keyword">return</span> (sfb_addq(cl-&gt;cl_sfb, &amp;cl-&gt;cl_q, m, t));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (qlen(&amp;cl-&gt;cl_q) &gt;= qlimit(&amp;cl-&gt;cl_q)) {
		IFCQ_CONVERT_LOCK(ifq);
		m_freem(m);
		<span class="enscript-keyword">return</span> (CLASSQEQ_DROPPED);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ECN</span>
	<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_CLEARDSCP)
		write_dsfield(m, t, 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ECN */</span>

	_addq(&amp;cl-&gt;cl_q, m);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">hfsc_getq</span>(<span class="enscript-type">struct</span> hfsc_class *cl)
{
	IFCQ_LOCK_ASSERT_HELD(cl-&gt;cl_hif-&gt;hif_ifq);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RIO</span>
	<span class="enscript-keyword">if</span> (q_is_rio(&amp;cl-&gt;cl_q))
		<span class="enscript-keyword">return</span> (rio_getq(cl-&gt;cl_rio, &amp;cl-&gt;cl_q));
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RIO */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RED</span>
	<span class="enscript-keyword">if</span> (q_is_red(&amp;cl-&gt;cl_q))
		<span class="enscript-keyword">return</span> (red_getq(cl-&gt;cl_red, &amp;cl-&gt;cl_q));
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RED */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_BLUE</span>
	<span class="enscript-keyword">if</span> (q_is_blue(&amp;cl-&gt;cl_q))
		<span class="enscript-keyword">return</span> (blue_getq(cl-&gt;cl_blue, &amp;cl-&gt;cl_q));
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_BLUE */</span>
	<span class="enscript-keyword">if</span> (q_is_sfb(&amp;cl-&gt;cl_q) &amp;&amp; cl-&gt;cl_sfb != NULL)
		<span class="enscript-keyword">return</span> (sfb_getq(cl-&gt;cl_sfb, &amp;cl-&gt;cl_q));

	<span class="enscript-keyword">return</span> (_getq(&amp;cl-&gt;cl_q));
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">hfsc_pollq</span>(<span class="enscript-type">struct</span> hfsc_class *cl)
{
	IFCQ_LOCK_ASSERT_HELD(cl-&gt;cl_hif-&gt;hif_ifq);

	<span class="enscript-keyword">return</span> (qhead(&amp;cl-&gt;cl_q));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hfsc_purgeq</span>(<span class="enscript-type">struct</span> hfsc_if *hif, <span class="enscript-type">struct</span> hfsc_class *cl, u_int32_t flow,
    u_int32_t *packets, u_int32_t *bytes)
{
	<span class="enscript-type">struct</span> ifclassq *ifq = hif-&gt;hif_ifq;
	u_int32_t cnt = 0, len = 0, qlen;

	IFCQ_LOCK_ASSERT_HELD(ifq);

	<span class="enscript-keyword">if</span> ((qlen = qlen(&amp;cl-&gt;cl_q)) == 0) {
		VERIFY(hif-&gt;hif_packets == 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* become regular mutex before freeing mbufs */</span>
	IFCQ_CONVERT_LOCK(ifq);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RIO</span>
	<span class="enscript-keyword">if</span> (q_is_rio(&amp;cl-&gt;cl_q))
		rio_purgeq(cl-&gt;cl_rio, &amp;cl-&gt;cl_q, flow, &amp;cnt, &amp;len);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RIO */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RED</span>
	<span class="enscript-keyword">if</span> (q_is_red(&amp;cl-&gt;cl_q))
		red_purgeq(cl-&gt;cl_red, &amp;cl-&gt;cl_q, flow, &amp;cnt, &amp;len);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RED */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_BLUE</span>
	<span class="enscript-keyword">if</span> (q_is_blue(&amp;cl-&gt;cl_q))
		blue_purgeq(cl-&gt;cl_blue, &amp;cl-&gt;cl_q, flow, &amp;cnt, &amp;len);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_BLUE */</span>
	<span class="enscript-keyword">if</span> (q_is_sfb(&amp;cl-&gt;cl_q) &amp;&amp; cl-&gt;cl_sfb != NULL)
		sfb_purgeq(cl-&gt;cl_sfb, &amp;cl-&gt;cl_q, flow, &amp;cnt, &amp;len);
	<span class="enscript-keyword">else</span>
		_flushq_flow(&amp;cl-&gt;cl_q, flow, &amp;cnt, &amp;len);

	<span class="enscript-keyword">if</span> (cnt &gt; 0) {
		VERIFY(qlen(&amp;cl-&gt;cl_q) == (qlen - cnt));

		PKTCNTR_ADD(&amp;cl-&gt;cl_stats.drop_cnt, cnt, len);
		IFCQ_DROP_ADD(ifq, cnt, len);

		VERIFY(hif-&gt;hif_packets &gt;= cnt);
		hif-&gt;hif_packets -= cnt;

		VERIFY(((<span class="enscript-type">signed</span>)IFCQ_LEN(ifq) - cnt) &gt;= 0);
		IFCQ_LEN(ifq) -= cnt;

		<span class="enscript-keyword">if</span> (qempty(&amp;cl-&gt;cl_q)) {
			update_vf(cl, 0, 0);	<span class="enscript-comment">/* remove cl from the actlist */</span>
			set_passive(cl);
		}

		<span class="enscript-keyword">if</span> (pktsched_verbose) {
			log(LOG_DEBUG, <span class="enscript-string">&quot;%s: %s purge qid=%d slot=%d &quot;</span>
			    <span class="enscript-string">&quot;qlen=[%d,%d] cnt=%d len=%d flow=0x%x\n&quot;</span>,
			    if_name(HFSCIF_IFP(hif)), hfsc_style(hif),
			    cl-&gt;cl_handle, cl-&gt;cl_id, qlen, qlen(&amp;cl-&gt;cl_q),
			    cnt, len, flow);
		}
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (packets != NULL)
		*packets = cnt;
	<span class="enscript-keyword">if</span> (bytes != NULL)
		*bytes = len;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hfsc_print_sc</span>(<span class="enscript-type">struct</span> hfsc_if *hif, u_int32_t qid, u_int64_t eff_rate,
    <span class="enscript-type">struct</span> service_curve *sc, <span class="enscript-type">struct</span> internal_sc *isc, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *which)
{
	<span class="enscript-type">struct</span> ifnet *ifp = HFSCIF_IFP(hif);

	log(LOG_DEBUG, <span class="enscript-string">&quot;%s: %s   qid=%d {%s_m1=%llu%s [%llu], &quot;</span>
	    <span class="enscript-string">&quot;%s_d=%u msec, %s_m2=%llu%s [%llu]} linkrate=%llu bps\n&quot;</span>,
	    if_name(ifp), hfsc_style(hif), qid,
	    which, sc-&gt;m1, (sc-&gt;fl &amp; HFSCF_M1_PCT) ? <span class="enscript-string">&quot;%&quot;</span> : <span class="enscript-string">&quot; bps&quot;</span>, isc-&gt;sm1,
	    which, sc-&gt;d,
	    which, sc-&gt;m2, (sc-&gt;fl &amp; HFSCF_M2_PCT) ? <span class="enscript-string">&quot;%&quot;</span> : <span class="enscript-string">&quot; bps&quot;</span>, isc-&gt;sm2,
	    eff_rate);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hfsc_updateq_linkrate</span>(<span class="enscript-type">struct</span> hfsc_if *hif, <span class="enscript-type">struct</span> hfsc_class *cl)
{
	u_int64_t eff_rate = ifnet_output_linkrate(HFSCIF_IFP(hif));
	<span class="enscript-type">struct</span> service_curve *sc;
	<span class="enscript-type">struct</span> internal_sc *isc;

	<span class="enscript-comment">/* Update parameters only if rate has changed */</span>
	<span class="enscript-keyword">if</span> (eff_rate == hif-&gt;hif_eff_rate)
		<span class="enscript-keyword">return</span>;

	sc = &amp;cl-&gt;cl_rsc0;
	isc = &amp;cl-&gt;cl_rsc;
	<span class="enscript-keyword">if</span> ((cl-&gt;cl_flags &amp; HFCF_RSC) &amp;&amp; sc2isc(cl, sc, isc, eff_rate)) {
		rtsc_init(&amp;cl-&gt;cl_deadline, isc, 0, 0);
		rtsc_init(&amp;cl-&gt;cl_eligible, isc, 0, 0);
		<span class="enscript-keyword">if</span> (pktsched_verbose) {
			hfsc_print_sc(hif, cl-&gt;cl_handle, eff_rate,
			    sc, isc, <span class="enscript-string">&quot;rsc&quot;</span>);
		}
	}
	sc = &amp;cl-&gt;cl_fsc0;
	isc = &amp;cl-&gt;cl_fsc;
	<span class="enscript-keyword">if</span> ((cl-&gt;cl_flags &amp; HFCF_FSC) &amp;&amp; sc2isc(cl, sc, isc, eff_rate)) {
		rtsc_init(&amp;cl-&gt;cl_virtual, isc, 0, 0);
		<span class="enscript-keyword">if</span> (pktsched_verbose) {
			hfsc_print_sc(hif, cl-&gt;cl_handle, eff_rate,
			    sc, isc, <span class="enscript-string">&quot;fsc&quot;</span>);
		}
	}
	sc = &amp;cl-&gt;cl_usc0;
	isc = &amp;cl-&gt;cl_usc;
	<span class="enscript-keyword">if</span> ((cl-&gt;cl_flags &amp; HFCF_USC) &amp;&amp; sc2isc(cl, sc, isc, eff_rate)) {
		rtsc_init(&amp;cl-&gt;cl_ulimit, isc, 0, 0);
		<span class="enscript-keyword">if</span> (pktsched_verbose) {
			hfsc_print_sc(hif, cl-&gt;cl_handle, eff_rate,
			    sc, isc, <span class="enscript-string">&quot;usc&quot;</span>);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hfsc_updateq</span>(<span class="enscript-type">struct</span> hfsc_if *hif, <span class="enscript-type">struct</span> hfsc_class *cl, cqev_t ev)
{
	IFCQ_LOCK_ASSERT_HELD(hif-&gt;hif_ifq);

	<span class="enscript-keyword">if</span> (pktsched_verbose) {
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: %s update qid=%d slot=%d event=%s\n&quot;</span>,
		    if_name(HFSCIF_IFP(hif)), hfsc_style(hif),
		    cl-&gt;cl_handle, cl-&gt;cl_id, ifclassq_ev2str(ev));
	}

	<span class="enscript-keyword">if</span> (ev == CLASSQ_EV_LINK_BANDWIDTH)
		hfsc_updateq_linkrate(hif, cl);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RIO</span>
	<span class="enscript-keyword">if</span> (q_is_rio(&amp;cl-&gt;cl_q))
		<span class="enscript-keyword">return</span> (rio_updateq(cl-&gt;cl_rio, ev));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RIO */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RED</span>
	<span class="enscript-keyword">if</span> (q_is_red(&amp;cl-&gt;cl_q))
		<span class="enscript-keyword">return</span> (red_updateq(cl-&gt;cl_red, ev));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RED */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_BLUE</span>
	<span class="enscript-keyword">if</span> (q_is_blue(&amp;cl-&gt;cl_q))
		<span class="enscript-keyword">return</span> (blue_updateq(cl-&gt;cl_blue, ev));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_BLUE */</span>
	<span class="enscript-keyword">if</span> (q_is_sfb(&amp;cl-&gt;cl_q) &amp;&amp; cl-&gt;cl_sfb != NULL)
		<span class="enscript-keyword">return</span> (sfb_updateq(cl-&gt;cl_sfb, ev));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">set_active</span>(<span class="enscript-type">struct</span> hfsc_class *cl, u_int32_t len)
{
	<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_RSC)
		init_ed(cl, len);
	<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_FSC)
		init_vf(cl, len);

	cl-&gt;cl_stats.period++;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">set_passive</span>(<span class="enscript-type">struct</span> hfsc_class *cl)
{
	<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_RSC)
		ellist_remove(cl);

	<span class="enscript-comment">/*
	 * actlist is now handled in update_vf() so that update_vf(cl, 0, 0)
	 * needs to be called explicitly to remove a class from actlist
	 */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">init_ed</span>(<span class="enscript-type">struct</span> hfsc_class *cl, u_int32_t next_len)
{
	u_int64_t cur_time;

	cur_time = read_machclk();

	<span class="enscript-comment">/* update the deadline curve */</span>
	rtsc_min(&amp;cl-&gt;cl_deadline, &amp;cl-&gt;cl_rsc, cur_time, cl-&gt;cl_cumul);

	<span class="enscript-comment">/*
	 * update the eligible curve.
	 * for concave, it is equal to the deadline curve.
	 * for convex, it is a linear curve with slope m2.
	 */</span>
	cl-&gt;cl_eligible = cl-&gt;cl_deadline;
	<span class="enscript-keyword">if</span> (cl-&gt;cl_rsc.sm1 &lt;= cl-&gt;cl_rsc.sm2) {
		cl-&gt;cl_eligible.dx = 0;
		cl-&gt;cl_eligible.dy = 0;
	}

	<span class="enscript-comment">/* compute e and d */</span>
	cl-&gt;cl_e = rtsc_y2x(&amp;cl-&gt;cl_eligible, cl-&gt;cl_cumul);
	cl-&gt;cl_d = rtsc_y2x(&amp;cl-&gt;cl_deadline, cl-&gt;cl_cumul + next_len);

	ellist_insert(cl);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">update_ed</span>(<span class="enscript-type">struct</span> hfsc_class *cl, u_int32_t next_len)
{
	cl-&gt;cl_e = rtsc_y2x(&amp;cl-&gt;cl_eligible, cl-&gt;cl_cumul);
	cl-&gt;cl_d = rtsc_y2x(&amp;cl-&gt;cl_deadline, cl-&gt;cl_cumul + next_len);

	ellist_update(cl);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">update_d</span>(<span class="enscript-type">struct</span> hfsc_class *cl, u_int32_t next_len)
{
	cl-&gt;cl_d = rtsc_y2x(&amp;cl-&gt;cl_deadline, cl-&gt;cl_cumul + next_len);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">init_vf</span>(<span class="enscript-type">struct</span> hfsc_class *cl, u_int32_t len)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">len</span>)
	<span class="enscript-type">struct</span> hfsc_class *max_cl, *p;
	u_int64_t vt, f, cur_time;
	<span class="enscript-type">int</span> go_active;

	cur_time = 0;
	go_active = 1;
	<span class="enscript-keyword">for</span> (; cl-&gt;cl_parent != NULL; cl = cl-&gt;cl_parent) {

		<span class="enscript-keyword">if</span> (go_active &amp;&amp; cl-&gt;cl_nactive++ == 0)
			go_active = 1;
		<span class="enscript-keyword">else</span>
			go_active = 0;

		<span class="enscript-keyword">if</span> (go_active) {
			max_cl = actlist_last(&amp;cl-&gt;cl_parent-&gt;cl_actc);
			<span class="enscript-keyword">if</span> (max_cl != NULL) {
				<span class="enscript-comment">/*
				 * set vt to the average of the min and max
				 * classes.  if the parent's period didn't
				 * change, don't decrease vt of the class.
				 */</span>
				vt = max_cl-&gt;cl_vt;
				<span class="enscript-keyword">if</span> (cl-&gt;cl_parent-&gt;cl_cvtmin != 0)
					vt = (cl-&gt;cl_parent-&gt;cl_cvtmin + vt)/2;

				<span class="enscript-keyword">if</span> (cl-&gt;cl_parent-&gt;cl_vtperiod !=
				    cl-&gt;cl_parentperiod || vt &gt; cl-&gt;cl_vt)
					cl-&gt;cl_vt = vt;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * first child for a new parent backlog period.
				 * add parent's cvtmax to vtoff of children
				 * to make a new vt (vtoff + vt) larger than
				 * the vt in the last period for all children.
				 */</span>
				vt = cl-&gt;cl_parent-&gt;cl_cvtmax;
				<span class="enscript-keyword">for</span> (p = cl-&gt;cl_parent-&gt;cl_children; p != NULL;
				    p = p-&gt;cl_siblings)
					p-&gt;cl_vtoff += vt;
				cl-&gt;cl_vt = 0;
				cl-&gt;cl_parent-&gt;cl_cvtmax = 0;
				cl-&gt;cl_parent-&gt;cl_cvtmin = 0;
			}
			cl-&gt;cl_initvt = cl-&gt;cl_vt;

			<span class="enscript-comment">/* update the virtual curve */</span>
			vt = cl-&gt;cl_vt + cl-&gt;cl_vtoff;
			rtsc_min(&amp;cl-&gt;cl_virtual, &amp;cl-&gt;cl_fsc,
			    vt, cl-&gt;cl_total);
			<span class="enscript-keyword">if</span> (cl-&gt;cl_virtual.x == vt) {
				cl-&gt;cl_virtual.x -= cl-&gt;cl_vtoff;
				cl-&gt;cl_vtoff = 0;
			}
			cl-&gt;cl_vtadj = 0;

			cl-&gt;cl_vtperiod++;  <span class="enscript-comment">/* increment vt period */</span>
			cl-&gt;cl_parentperiod = cl-&gt;cl_parent-&gt;cl_vtperiod;
			<span class="enscript-keyword">if</span> (cl-&gt;cl_parent-&gt;cl_nactive == 0)
				cl-&gt;cl_parentperiod++;
			cl-&gt;cl_f = 0;

			actlist_insert(cl);

			<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_USC) {
				<span class="enscript-comment">/* class has upper limit curve */</span>
				<span class="enscript-keyword">if</span> (cur_time == 0)
					cur_time = read_machclk();

				<span class="enscript-comment">/* update the ulimit curve */</span>
				rtsc_min(&amp;cl-&gt;cl_ulimit, &amp;cl-&gt;cl_usc, cur_time,
				    cl-&gt;cl_total);
				<span class="enscript-comment">/* compute myf */</span>
				cl-&gt;cl_myf = rtsc_y2x(&amp;cl-&gt;cl_ulimit,
				    cl-&gt;cl_total);
				cl-&gt;cl_myfadj = 0;
			}
		}

		<span class="enscript-keyword">if</span> (cl-&gt;cl_myf &gt; cl-&gt;cl_cfmin)
			f = cl-&gt;cl_myf;
		<span class="enscript-keyword">else</span>
			f = cl-&gt;cl_cfmin;
		<span class="enscript-keyword">if</span> (f != cl-&gt;cl_f) {
			cl-&gt;cl_f = f;
			update_cfmin(cl-&gt;cl_parent);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">update_vf</span>(<span class="enscript-type">struct</span> hfsc_class *cl, u_int32_t len, u_int64_t cur_time)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cur_time</span>)
#<span class="enscript-reference">if</span> 0
	u_int64_t myf_bound, delta;
#<span class="enscript-reference">endif</span>
	u_int64_t f;
	<span class="enscript-type">int</span> go_passive;

	go_passive = (qempty(&amp;cl-&gt;cl_q) &amp;&amp; (cl-&gt;cl_flags &amp; HFCF_FSC));

	<span class="enscript-keyword">for</span> (; cl-&gt;cl_parent != NULL; cl = cl-&gt;cl_parent) {

		cl-&gt;cl_total += len;

		<span class="enscript-keyword">if</span> (!(cl-&gt;cl_flags &amp; HFCF_FSC) || cl-&gt;cl_nactive == 0)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (go_passive &amp;&amp; --cl-&gt;cl_nactive == 0)
			go_passive = 1;
		<span class="enscript-keyword">else</span>
			go_passive = 0;

		<span class="enscript-keyword">if</span> (go_passive) {
			<span class="enscript-comment">/* no more active child, going passive */</span>

			<span class="enscript-comment">/* update cvtmax of the parent class */</span>
			<span class="enscript-keyword">if</span> (cl-&gt;cl_vt &gt; cl-&gt;cl_parent-&gt;cl_cvtmax)
				cl-&gt;cl_parent-&gt;cl_cvtmax = cl-&gt;cl_vt;

			<span class="enscript-comment">/* remove this class from the vt list */</span>
			actlist_remove(cl);

			update_cfmin(cl-&gt;cl_parent);

			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * update vt and f
		 */</span>
		cl-&gt;cl_vt = rtsc_y2x(&amp;cl-&gt;cl_virtual, cl-&gt;cl_total)
		    - cl-&gt;cl_vtoff + cl-&gt;cl_vtadj;

		<span class="enscript-comment">/*
		 * if vt of the class is smaller than cvtmin,
		 * the class was skipped in the past due to non-fit.
		 * if so, we need to adjust vtadj.
		 */</span>
		<span class="enscript-keyword">if</span> (cl-&gt;cl_vt &lt; cl-&gt;cl_parent-&gt;cl_cvtmin) {
			cl-&gt;cl_vtadj += cl-&gt;cl_parent-&gt;cl_cvtmin - cl-&gt;cl_vt;
			cl-&gt;cl_vt = cl-&gt;cl_parent-&gt;cl_cvtmin;
		}

		<span class="enscript-comment">/* update the vt list */</span>
		actlist_update(cl);

		<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_USC) {
			cl-&gt;cl_myf = cl-&gt;cl_myfadj +
			    rtsc_y2x(&amp;cl-&gt;cl_ulimit, cl-&gt;cl_total);
#<span class="enscript-reference">if</span> 0
			<span class="enscript-comment">/*
			 * if myf lags behind by more than one clock tick
			 * from the current time, adjust myfadj to prevent
			 * a rate-limited class from going greedy.
			 * in a steady state under rate-limiting, myf
			 * fluctuates within one clock tick.
			 */</span>
			myf_bound = cur_time - machclk_per_tick;
			<span class="enscript-keyword">if</span> (cl-&gt;cl_myf &lt; myf_bound) {
				delta = cur_time - cl-&gt;cl_myf;
				cl-&gt;cl_myfadj += delta;
				cl-&gt;cl_myf += delta;
			}
#<span class="enscript-reference">endif</span>
		}

		<span class="enscript-comment">/* cl_f is max(cl_myf, cl_cfmin) */</span>
		<span class="enscript-keyword">if</span> (cl-&gt;cl_myf &gt; cl-&gt;cl_cfmin)
			f = cl-&gt;cl_myf;
		<span class="enscript-keyword">else</span>
			f = cl-&gt;cl_cfmin;
		<span class="enscript-keyword">if</span> (f != cl-&gt;cl_f) {
			cl-&gt;cl_f = f;
			update_cfmin(cl-&gt;cl_parent);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">update_cfmin</span>(<span class="enscript-type">struct</span> hfsc_class *cl)
{
	<span class="enscript-type">struct</span> hfsc_class *p;
	u_int64_t cfmin;

	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;cl-&gt;cl_actc)) {
		cl-&gt;cl_cfmin = 0;
		<span class="enscript-keyword">return</span>;
	}
	cfmin = HT_INFINITY;
	TAILQ_FOREACH(p, &amp;cl-&gt;cl_actc, cl_actlist) {
		<span class="enscript-keyword">if</span> (p-&gt;cl_f == 0) {
			cl-&gt;cl_cfmin = 0;
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">if</span> (p-&gt;cl_f &lt; cfmin)
			cfmin = p-&gt;cl_f;
	}
	cl-&gt;cl_cfmin = cfmin;
}

<span class="enscript-comment">/*
 * TAILQ based ellist and actlist implementation
 * (ion wanted to make a calendar queue based implementation)
 */</span>
<span class="enscript-comment">/*
 * eligible list holds backlogged classes being sorted by their eligible times.
 * there is one eligible list per interface.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ellist_insert</span>(<span class="enscript-type">struct</span> hfsc_class *cl)
{
	<span class="enscript-type">struct</span> hfsc_if	*hif = cl-&gt;cl_hif;
	<span class="enscript-type">struct</span> hfsc_class *p;

	<span class="enscript-comment">/* check the last entry first */</span>
	<span class="enscript-keyword">if</span> ((p = TAILQ_LAST(&amp;hif-&gt;hif_eligible, _eligible)) == NULL ||
	    p-&gt;cl_e &lt;= cl-&gt;cl_e) {
		TAILQ_INSERT_TAIL(&amp;hif-&gt;hif_eligible, cl, cl_ellist);
		<span class="enscript-keyword">return</span>;
	}

	TAILQ_FOREACH(p, &amp;hif-&gt;hif_eligible, cl_ellist) {
		<span class="enscript-keyword">if</span> (cl-&gt;cl_e &lt; p-&gt;cl_e) {
			TAILQ_INSERT_BEFORE(p, cl, cl_ellist);
			<span class="enscript-keyword">return</span>;
		}
	}
	VERIFY(0); <span class="enscript-comment">/* should not reach here */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ellist_remove</span>(<span class="enscript-type">struct</span> hfsc_class *cl)
{
	<span class="enscript-type">struct</span> hfsc_if	*hif = cl-&gt;cl_hif;

	TAILQ_REMOVE(&amp;hif-&gt;hif_eligible, cl, cl_ellist);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ellist_update</span>(<span class="enscript-type">struct</span> hfsc_class *cl)
{
	<span class="enscript-type">struct</span> hfsc_if	*hif = cl-&gt;cl_hif;
	<span class="enscript-type">struct</span> hfsc_class *p, *last;

	<span class="enscript-comment">/*
	 * the eligible time of a class increases monotonically.
	 * if the next entry has a larger eligible time, nothing to do.
	 */</span>
	p = TAILQ_NEXT(cl, cl_ellist);
	<span class="enscript-keyword">if</span> (p == NULL || cl-&gt;cl_e &lt;= p-&gt;cl_e)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* check the last entry */</span>
	last = TAILQ_LAST(&amp;hif-&gt;hif_eligible, _eligible);
	VERIFY(last != NULL);
	<span class="enscript-keyword">if</span> (last-&gt;cl_e &lt;= cl-&gt;cl_e) {
		TAILQ_REMOVE(&amp;hif-&gt;hif_eligible, cl, cl_ellist);
		TAILQ_INSERT_TAIL(&amp;hif-&gt;hif_eligible, cl, cl_ellist);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * the new position must be between the next entry
	 * and the last entry
	 */</span>
	<span class="enscript-keyword">while</span> ((p = TAILQ_NEXT(p, cl_ellist)) != NULL) {
		<span class="enscript-keyword">if</span> (cl-&gt;cl_e &lt; p-&gt;cl_e) {
			TAILQ_REMOVE(&amp;hif-&gt;hif_eligible, cl, cl_ellist);
			TAILQ_INSERT_BEFORE(p, cl, cl_ellist);
			<span class="enscript-keyword">return</span>;
		}
	}
	VERIFY(0); <span class="enscript-comment">/* should not reach here */</span>
}

<span class="enscript-comment">/* find the class with the minimum deadline among the eligible classes */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> hfsc_class *
<span class="enscript-function-name">ellist_get_mindl</span>(ellist_t *head, u_int64_t cur_time)
{
	<span class="enscript-type">struct</span> hfsc_class *p, *cl = NULL;

	TAILQ_FOREACH(p, head, cl_ellist) {
		<span class="enscript-keyword">if</span> (p-&gt;cl_e &gt; cur_time)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (cl == NULL || p-&gt;cl_d &lt; cl-&gt;cl_d)
			cl = p;
	}
	<span class="enscript-keyword">return</span> (cl);
}

<span class="enscript-comment">/*
 * active children list holds backlogged child classes being sorted
 * by their virtual time.
 * each intermediate class has one active children list.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">actlist_insert</span>(<span class="enscript-type">struct</span> hfsc_class *cl)
{
	<span class="enscript-type">struct</span> hfsc_class *p;

	<span class="enscript-comment">/* check the last entry first */</span>
	<span class="enscript-keyword">if</span> ((p = TAILQ_LAST(&amp;cl-&gt;cl_parent-&gt;cl_actc, _active)) == NULL ||
	    p-&gt;cl_vt &lt;= cl-&gt;cl_vt) {
		TAILQ_INSERT_TAIL(&amp;cl-&gt;cl_parent-&gt;cl_actc, cl, cl_actlist);
		<span class="enscript-keyword">return</span>;
	}

	TAILQ_FOREACH(p, &amp;cl-&gt;cl_parent-&gt;cl_actc, cl_actlist) {
		<span class="enscript-keyword">if</span> (cl-&gt;cl_vt &lt; p-&gt;cl_vt) {
			TAILQ_INSERT_BEFORE(p, cl, cl_actlist);
			<span class="enscript-keyword">return</span>;
		}
	}
	VERIFY(0); <span class="enscript-comment">/* should not reach here */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">actlist_remove</span>(<span class="enscript-type">struct</span> hfsc_class *cl)
{
	TAILQ_REMOVE(&amp;cl-&gt;cl_parent-&gt;cl_actc, cl, cl_actlist);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">actlist_update</span>(<span class="enscript-type">struct</span> hfsc_class *cl)
{
	<span class="enscript-type">struct</span> hfsc_class *p, *last;

	<span class="enscript-comment">/*
	 * the virtual time of a class increases monotonically during its
	 * backlogged period.
	 * if the next entry has a larger virtual time, nothing to do.
	 */</span>
	p = TAILQ_NEXT(cl, cl_actlist);
	<span class="enscript-keyword">if</span> (p == NULL || cl-&gt;cl_vt &lt; p-&gt;cl_vt)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* check the last entry */</span>
	last = TAILQ_LAST(&amp;cl-&gt;cl_parent-&gt;cl_actc, _active);
	VERIFY(last != NULL);
	<span class="enscript-keyword">if</span> (last-&gt;cl_vt &lt;= cl-&gt;cl_vt) {
		TAILQ_REMOVE(&amp;cl-&gt;cl_parent-&gt;cl_actc, cl, cl_actlist);
		TAILQ_INSERT_TAIL(&amp;cl-&gt;cl_parent-&gt;cl_actc, cl, cl_actlist);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * the new position must be between the next entry
	 * and the last entry
	 */</span>
	<span class="enscript-keyword">while</span> ((p = TAILQ_NEXT(p, cl_actlist)) != NULL) {
		<span class="enscript-keyword">if</span> (cl-&gt;cl_vt &lt; p-&gt;cl_vt) {
			TAILQ_REMOVE(&amp;cl-&gt;cl_parent-&gt;cl_actc, cl, cl_actlist);
			TAILQ_INSERT_BEFORE(p, cl, cl_actlist);
			<span class="enscript-keyword">return</span>;
		}
	}
	VERIFY(0); <span class="enscript-comment">/* should not reach here */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> hfsc_class *
<span class="enscript-function-name">actlist_firstfit</span>(<span class="enscript-type">struct</span> hfsc_class *cl, u_int64_t cur_time)
{
	<span class="enscript-type">struct</span> hfsc_class *p;

	TAILQ_FOREACH(p, &amp;cl-&gt;cl_actc, cl_actlist) {
		<span class="enscript-keyword">if</span> (p-&gt;cl_f &lt;= cur_time)
			<span class="enscript-keyword">return</span> (p);
	}
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * service curve support functions
 *
 *  external service curve parameters
 *	m: bits/sec
 *	d: msec
 *  internal service curve parameters
 *	sm: (bytes/tsc_interval) &lt;&lt; SM_SHIFT
 *	ism: (tsc_count/byte) &lt;&lt; ISM_SHIFT
 *	dx: tsc_count
 *
 * SM_SHIFT and ISM_SHIFT are scaled in order to keep effective digits.
 * we should be able to handle 100K-1Gbps linkspeed with 200Hz-1GHz CPU
 * speed.  SM_SHIFT and ISM_SHIFT are selected to have at least 3 effective
 * digits in decimal using the following table.
 *
 *  bits/sec    100Kbps     1Mbps     10Mbps     100Mbps    1Gbps
 *  ----------+-------------------------------------------------------
 *  bytes/nsec  12.5e-6    125e-6     1250e-6    12500e-6   125000e-6
 *  sm(500MHz)  25.0e-6    250e-6     2500e-6    25000e-6   250000e-6
 *  sm(200MHz)  62.5e-6    625e-6     6250e-6    62500e-6   625000e-6
 *
 *  nsec/byte   80000      8000       800        80         8
 *  ism(500MHz) 40000      4000       400        40         4
 *  ism(200MHz) 16000      1600       160        16         1.6
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SM_SHIFT</span>	24
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ISM_SHIFT</span>	10

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SM_MASK</span>		((1LL &lt;&lt; SM_SHIFT) - 1)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ISM_MASK</span>	((1LL &lt;&lt; ISM_SHIFT) - 1)

<span class="enscript-type">static</span> inline u_int64_t
<span class="enscript-function-name">seg_x2y</span>(u_int64_t x, u_int64_t sm)
{
	u_int64_t y;

	<span class="enscript-comment">/*
	 * compute
	 *	y = x * sm &gt;&gt; SM_SHIFT
	 * but divide it for the upper and lower bits to avoid overflow
	 */</span>
	y = (x &gt;&gt; SM_SHIFT) * sm + (((x &amp; SM_MASK) * sm) &gt;&gt; SM_SHIFT);
	<span class="enscript-keyword">return</span> (y);
}

<span class="enscript-type">static</span> inline u_int64_t
<span class="enscript-function-name">seg_y2x</span>(u_int64_t y, u_int64_t ism)
{
	u_int64_t x;

	<span class="enscript-keyword">if</span> (y == 0)
		x = 0;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ism == HT_INFINITY)
		x = HT_INFINITY;
	<span class="enscript-keyword">else</span> {
		x = (y &gt;&gt; ISM_SHIFT) * ism
		    + (((y &amp; ISM_MASK) * ism) &gt;&gt; ISM_SHIFT);
	}
	<span class="enscript-keyword">return</span> (x);
}

<span class="enscript-type">static</span> inline u_int64_t
<span class="enscript-function-name">m2sm</span>(u_int64_t m)
{
	u_int64_t sm;

	sm = (m &lt;&lt; SM_SHIFT) / 8 / machclk_freq;
	<span class="enscript-keyword">return</span> (sm);
}

<span class="enscript-type">static</span> inline u_int64_t
<span class="enscript-function-name">m2ism</span>(u_int64_t m)
{
	u_int64_t ism;

	<span class="enscript-keyword">if</span> (m == 0)
		ism = HT_INFINITY;
	<span class="enscript-keyword">else</span>
		ism = ((u_int64_t)machclk_freq &lt;&lt; ISM_SHIFT) * 8 / m;
	<span class="enscript-keyword">return</span> (ism);
}

<span class="enscript-type">static</span> inline u_int64_t
<span class="enscript-function-name">d2dx</span>(u_int64_t d)
{
	u_int64_t dx;

	dx = (d * machclk_freq) / 1000;
	<span class="enscript-keyword">return</span> (dx);
}

<span class="enscript-type">static</span> u_int64_t
<span class="enscript-function-name">sm2m</span>(u_int64_t sm)
{
	u_int64_t m;

	m = (sm * 8 * machclk_freq) &gt;&gt; SM_SHIFT;
	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-type">static</span> u_int64_t
<span class="enscript-function-name">dx2d</span>(u_int64_t dx)
{
	u_int64_t d;

	d = dx * 1000 / machclk_freq;
	<span class="enscript-keyword">return</span> (d);
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">sc2isc</span>(<span class="enscript-type">struct</span> hfsc_class *cl, <span class="enscript-type">struct</span> service_curve *sc, <span class="enscript-type">struct</span> internal_sc *isc,
    u_int64_t eff_rate)
{
	<span class="enscript-type">struct</span> hfsc_if *hif = cl-&gt;cl_hif;
	<span class="enscript-type">struct</span> internal_sc oisc = *isc;
	u_int64_t m1, m2;

	<span class="enscript-keyword">if</span> (eff_rate == 0 &amp;&amp; (sc-&gt;fl &amp; (HFSCF_M1_PCT | HFSCF_M2_PCT))) {
		<span class="enscript-comment">/*
		 * If service curve is configured with percentage and the
		 * effective uplink rate is not known, assume this is a
		 * transient case, and that the rate will be updated in
		 * the near future via CLASSQ_EV_LINK_SPEED.  Pick a
		 * reasonable number for now, e.g. 10 Mbps.
		 */</span>
		eff_rate = (10 * 1000 * 1000);

		log(LOG_WARNING, <span class="enscript-string">&quot;%s: %s qid=%d slot=%d eff_rate unknown; &quot;</span>
		    <span class="enscript-string">&quot;using temporary rate %llu bps\n&quot;</span>, if_name(HFSCIF_IFP(hif)),
		    hfsc_style(hif), cl-&gt;cl_handle, cl-&gt;cl_id, eff_rate);
	}

	m1 = sc-&gt;m1;
	<span class="enscript-keyword">if</span> (sc-&gt;fl &amp; HFSCF_M1_PCT) {
		VERIFY(m1 &gt; 0 &amp;&amp; m1 &lt;= 100);
		m1 = (eff_rate * m1) / 100;
	}

	m2 = sc-&gt;m2;
	<span class="enscript-keyword">if</span> (sc-&gt;fl &amp; HFSCF_M2_PCT) {
		VERIFY(m2 &gt; 0 &amp;&amp; m2 &lt;= 100);
		m2 = (eff_rate * m2) / 100;
	}

	isc-&gt;sm1 = m2sm(m1);
	isc-&gt;ism1 = m2ism(m1);
	isc-&gt;dx = d2dx(sc-&gt;d);
	isc-&gt;dy = seg_x2y(isc-&gt;dx, isc-&gt;sm1);
	isc-&gt;sm2 = m2sm(m2);
	isc-&gt;ism2 = m2ism(m2);

	<span class="enscript-comment">/* return non-zero if there's any change */</span>
	<span class="enscript-keyword">return</span> (bcmp(&amp;oisc, isc, <span class="enscript-keyword">sizeof</span> (*isc)));
}

<span class="enscript-comment">/*
 * initialize the runtime service curve with the given internal
 * service curve starting at (x, y).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rtsc_init</span>(<span class="enscript-type">struct</span> runtime_sc *rtsc, <span class="enscript-type">struct</span> internal_sc *isc, u_int64_t x,
    u_int64_t y)
{
	rtsc-&gt;x =	x;
	rtsc-&gt;y =	y;
	rtsc-&gt;sm1 =	isc-&gt;sm1;
	rtsc-&gt;ism1 =	isc-&gt;ism1;
	rtsc-&gt;dx =	isc-&gt;dx;
	rtsc-&gt;dy =	isc-&gt;dy;
	rtsc-&gt;sm2 =	isc-&gt;sm2;
	rtsc-&gt;ism2 =	isc-&gt;ism2;
}

<span class="enscript-comment">/*
 * calculate the y-projection of the runtime service curve by the
 * given x-projection value
 */</span>
<span class="enscript-type">static</span> u_int64_t
<span class="enscript-function-name">rtsc_y2x</span>(<span class="enscript-type">struct</span> runtime_sc *rtsc, u_int64_t y)
{
	u_int64_t	x;

	<span class="enscript-keyword">if</span> (y &lt; rtsc-&gt;y)
		x = rtsc-&gt;x;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (y &lt;= rtsc-&gt;y + rtsc-&gt;dy) {
		<span class="enscript-comment">/* x belongs to the 1st segment */</span>
		<span class="enscript-keyword">if</span> (rtsc-&gt;dy == 0)
			x = rtsc-&gt;x + rtsc-&gt;dx;
		<span class="enscript-keyword">else</span>
			x = rtsc-&gt;x + seg_y2x(y - rtsc-&gt;y, rtsc-&gt;ism1);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* x belongs to the 2nd segment */</span>
		x = rtsc-&gt;x + rtsc-&gt;dx
		    + seg_y2x(y - rtsc-&gt;y - rtsc-&gt;dy, rtsc-&gt;ism2);
	}
	<span class="enscript-keyword">return</span> (x);
}

<span class="enscript-type">static</span> u_int64_t
<span class="enscript-function-name">rtsc_x2y</span>(<span class="enscript-type">struct</span> runtime_sc *rtsc, u_int64_t x)
{
	u_int64_t	y;

	<span class="enscript-keyword">if</span> (x &lt;= rtsc-&gt;x)
		y = rtsc-&gt;y;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (x &lt;= rtsc-&gt;x + rtsc-&gt;dx)
		<span class="enscript-comment">/* y belongs to the 1st segment */</span>
		y = rtsc-&gt;y + seg_x2y(x - rtsc-&gt;x, rtsc-&gt;sm1);
	<span class="enscript-keyword">else</span>
		<span class="enscript-comment">/* y belongs to the 2nd segment */</span>
		y = rtsc-&gt;y + rtsc-&gt;dy
		    + seg_x2y(x - rtsc-&gt;x - rtsc-&gt;dx, rtsc-&gt;sm2);
	<span class="enscript-keyword">return</span> (y);
}

<span class="enscript-comment">/*
 * update the runtime service curve by taking the minimum of the current
 * runtime service curve and the service curve starting at (x, y).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rtsc_min</span>(<span class="enscript-type">struct</span> runtime_sc *rtsc, <span class="enscript-type">struct</span> internal_sc *isc, u_int64_t x,
    u_int64_t y)
{
	u_int64_t	y1, y2, dx, dy;

	<span class="enscript-keyword">if</span> (isc-&gt;sm1 &lt;= isc-&gt;sm2) {
		<span class="enscript-comment">/* service curve is convex */</span>
		y1 = rtsc_x2y(rtsc, x);
		<span class="enscript-keyword">if</span> (y1 &lt; y)
			<span class="enscript-comment">/* the current rtsc is smaller */</span>
			<span class="enscript-keyword">return</span>;
		rtsc-&gt;x = x;
		rtsc-&gt;y = y;
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * service curve is concave
	 * compute the two y values of the current rtsc
	 *	y1: at x
	 *	y2: at (x + dx)
	 */</span>
	y1 = rtsc_x2y(rtsc, x);
	<span class="enscript-keyword">if</span> (y1 &lt;= y) {
		<span class="enscript-comment">/* rtsc is below isc, no change to rtsc */</span>
		<span class="enscript-keyword">return</span>;
	}

	y2 = rtsc_x2y(rtsc, x + isc-&gt;dx);
	<span class="enscript-keyword">if</span> (y2 &gt;= y + isc-&gt;dy) {
		<span class="enscript-comment">/* rtsc is above isc, replace rtsc by isc */</span>
		rtsc-&gt;x = x;
		rtsc-&gt;y = y;
		rtsc-&gt;dx = isc-&gt;dx;
		rtsc-&gt;dy = isc-&gt;dy;
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * the two curves intersect
	 * compute the offsets (dx, dy) using the reverse
	 * function of seg_x2y()
	 *	seg_x2y(dx, sm1) == seg_x2y(dx, sm2) + (y1 - y)
	 */</span>
	dx = ((y1 - y) &lt;&lt; SM_SHIFT) / (isc-&gt;sm1 - isc-&gt;sm2);
	<span class="enscript-comment">/*
	 * check if (x, y1) belongs to the 1st segment of rtsc.
	 * if so, add the offset.
	 */</span>
	<span class="enscript-keyword">if</span> (rtsc-&gt;x + rtsc-&gt;dx &gt; x)
		dx += rtsc-&gt;x + rtsc-&gt;dx - x;
	dy = seg_x2y(dx, isc-&gt;sm1);

	rtsc-&gt;x = x;
	rtsc-&gt;y = y;
	rtsc-&gt;dx = dx;
	rtsc-&gt;dy = dy;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfsc_get_class_stats</span>(<span class="enscript-type">struct</span> hfsc_if *hif, u_int32_t qid,
    <span class="enscript-type">struct</span> hfsc_classstats *sp)
{
	<span class="enscript-type">struct</span> hfsc_class *cl;

	IFCQ_LOCK_ASSERT_HELD(hif-&gt;hif_ifq);

	<span class="enscript-keyword">if</span> ((cl = hfsc_clh_to_clp(hif, qid)) == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	sp-&gt;class_id = cl-&gt;cl_id;
	sp-&gt;class_handle = cl-&gt;cl_handle;

	<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_RSC) {
		sp-&gt;rsc.m1 = sm2m(cl-&gt;cl_rsc.sm1);
		sp-&gt;rsc.d = dx2d(cl-&gt;cl_rsc.dx);
		sp-&gt;rsc.m2 = sm2m(cl-&gt;cl_rsc.sm2);
	} <span class="enscript-keyword">else</span> {
		sp-&gt;rsc.m1 = 0;
		sp-&gt;rsc.d = 0;
		sp-&gt;rsc.m2 = 0;
	}
	<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_FSC) {
		sp-&gt;fsc.m1 = sm2m(cl-&gt;cl_fsc.sm1);
		sp-&gt;fsc.d = dx2d(cl-&gt;cl_fsc.dx);
		sp-&gt;fsc.m2 = sm2m(cl-&gt;cl_fsc.sm2);
	} <span class="enscript-keyword">else</span> {
		sp-&gt;fsc.m1 = 0;
		sp-&gt;fsc.d = 0;
		sp-&gt;fsc.m2 = 0;
	}
	<span class="enscript-keyword">if</span> (cl-&gt;cl_flags &amp; HFCF_USC) {
		sp-&gt;usc.m1 = sm2m(cl-&gt;cl_usc.sm1);
		sp-&gt;usc.d = dx2d(cl-&gt;cl_usc.dx);
		sp-&gt;usc.m2 = sm2m(cl-&gt;cl_usc.sm2);
	} <span class="enscript-keyword">else</span> {
		sp-&gt;usc.m1 = 0;
		sp-&gt;usc.d = 0;
		sp-&gt;usc.m2 = 0;
	}

	sp-&gt;total = cl-&gt;cl_total;
	sp-&gt;cumul = cl-&gt;cl_cumul;

	sp-&gt;d = cl-&gt;cl_d;
	sp-&gt;e = cl-&gt;cl_e;
	sp-&gt;vt = cl-&gt;cl_vt;
	sp-&gt;f = cl-&gt;cl_f;

	sp-&gt;initvt = cl-&gt;cl_initvt;
	sp-&gt;vtperiod = cl-&gt;cl_vtperiod;
	sp-&gt;parentperiod = cl-&gt;cl_parentperiod;
	sp-&gt;nactive = cl-&gt;cl_nactive;
	sp-&gt;vtoff = cl-&gt;cl_vtoff;
	sp-&gt;cvtmax = cl-&gt;cl_cvtmax;
	sp-&gt;myf = cl-&gt;cl_myf;
	sp-&gt;cfmin = cl-&gt;cl_cfmin;
	sp-&gt;cvtmin = cl-&gt;cl_cvtmin;
	sp-&gt;myfadj = cl-&gt;cl_myfadj;
	sp-&gt;vtadj = cl-&gt;cl_vtadj;

	sp-&gt;cur_time = read_machclk();
	sp-&gt;machclk_freq = machclk_freq;

	sp-&gt;qlength = qlen(&amp;cl-&gt;cl_q);
	sp-&gt;qlimit = qlimit(&amp;cl-&gt;cl_q);
	sp-&gt;xmit_cnt = cl-&gt;cl_stats.xmit_cnt;
	sp-&gt;drop_cnt = cl-&gt;cl_stats.drop_cnt;
	sp-&gt;period = cl-&gt;cl_stats.period;

	sp-&gt;qtype = qtype(&amp;cl-&gt;cl_q);
	sp-&gt;qstate = qstate(&amp;cl-&gt;cl_q);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RED</span>
	<span class="enscript-keyword">if</span> (q_is_red(&amp;cl-&gt;cl_q))
		red_getstats(cl-&gt;cl_red, &amp;sp-&gt;red[0]);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RED */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RIO</span>
	<span class="enscript-keyword">if</span> (q_is_rio(&amp;cl-&gt;cl_q))
		rio_getstats(cl-&gt;cl_rio, &amp;sp-&gt;red[0]);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RIO */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_BLUE</span>
	<span class="enscript-keyword">if</span> (q_is_blue(&amp;cl-&gt;cl_q))
		blue_getstats(cl-&gt;cl_blue, &amp;sp-&gt;blue);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_BLUE */</span>
	<span class="enscript-keyword">if</span> (q_is_sfb(&amp;cl-&gt;cl_q) &amp;&amp; cl-&gt;cl_sfb != NULL)
		sfb_getstats(cl-&gt;cl_sfb, &amp;sp-&gt;sfb);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* convert a class handle to the corresponding class pointer */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> hfsc_class *
<span class="enscript-function-name">hfsc_clh_to_clp</span>(<span class="enscript-type">struct</span> hfsc_if *hif, u_int32_t chandle)
{
	u_int32_t i;
	<span class="enscript-type">struct</span> hfsc_class *cl;

	IFCQ_LOCK_ASSERT_HELD(hif-&gt;hif_ifq);

	<span class="enscript-comment">/*
	 * first, try optimistically the slot matching the lower bits of
	 * the handle.  if it fails, do the linear table search.
	 */</span>
	i = chandle % hif-&gt;hif_maxclasses;
	<span class="enscript-keyword">if</span> ((cl = hif-&gt;hif_class_tbl[i]) != NULL &amp;&amp; cl-&gt;cl_handle == chandle)
		<span class="enscript-keyword">return</span> (cl);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; hif-&gt;hif_maxclasses; i++)
		<span class="enscript-keyword">if</span> ((cl = hif-&gt;hif_class_tbl[i]) != NULL &amp;&amp;
		    cl-&gt;cl_handle == chandle)
			<span class="enscript-keyword">return</span> (cl);
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">hfsc_style</span>(<span class="enscript-type">struct</span> hfsc_if *hif)
{
	<span class="enscript-keyword">return</span> ((hif-&gt;hif_flags &amp; HFSCIFF_ALTQ) ? <span class="enscript-string">&quot;ALTQ_HFSC&quot;</span> : <span class="enscript-string">&quot;HFSC&quot;</span>);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfsc_setup_ifclassq</span>(<span class="enscript-type">struct</span> ifclassq *ifq, u_int32_t flags)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifq</span>, <span class="enscript-variable-name">flags</span>)
	<span class="enscript-keyword">return</span> (ENXIO);		<span class="enscript-comment">/* not yet */</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfsc_teardown_ifclassq</span>(<span class="enscript-type">struct</span> ifclassq *ifq)
{
	<span class="enscript-type">struct</span> hfsc_if *hif = ifq-&gt;ifcq_disc;
	<span class="enscript-type">int</span> i;

	IFCQ_LOCK_ASSERT_HELD(ifq);
	VERIFY(hif != NULL &amp;&amp; ifq-&gt;ifcq_type == PKTSCHEDT_HFSC);

	(<span class="enscript-type">void</span>) hfsc_destroy_locked(hif);

	ifq-&gt;ifcq_disc = NULL;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; IFCQ_SC_MAX; i++) {
		ifq-&gt;ifcq_disc_slots[i].qid = 0;
		ifq-&gt;ifcq_disc_slots[i].cl = NULL;
	}

	<span class="enscript-keyword">return</span> (ifclassq_detach(ifq));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfsc_getqstats_ifclassq</span>(<span class="enscript-type">struct</span> ifclassq *ifq, u_int32_t slot,
    <span class="enscript-type">struct</span> if_ifclassq_stats *ifqs)
{
	<span class="enscript-type">struct</span> hfsc_if *hif = ifq-&gt;ifcq_disc;

	IFCQ_LOCK_ASSERT_HELD(ifq);
	VERIFY(ifq-&gt;ifcq_type == PKTSCHEDT_HFSC);

	<span class="enscript-keyword">if</span> (slot &gt;= IFCQ_SC_MAX)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (hfsc_get_class_stats(hif, ifq-&gt;ifcq_disc_slots[slot].qid,
	    &amp;ifqs-&gt;ifqs_hfsc_stats));
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PKTSCHED_HFSC */</span>
</pre>
<hr />
</body></html>