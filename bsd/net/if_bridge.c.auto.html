<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>if_bridge.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">if_bridge.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$NetBSD: if_bridge.c,v 1.31 2005/06/01 19:45:34 jdc Exp $	*/</span>
<span class="enscript-comment">/*
 * Copyright 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 1999, 2000 Jason L. Wright (<a href="mailto:jason@thought.net">jason@thought.net</a>)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * OpenBSD: if_bridge.c,v 1.60 2001/06/15 03:38:33 itojun Exp
 */</span>

<span class="enscript-comment">/*
 * Network interface bridge support.
 *
 * TODO:
 *
 *	- Currently only supports Ethernet-like interfaces (Ethernet,
 *	  802.11, VLANs on Ethernet, etc.)  Figure out a nice way
 *	  to bridge other types of interfaces (FDDI-FDDI, and maybe
 *	  consider heterogenous bridges).
 *
 *	- GIF isn't handled due to the lack of IPPROTO_ETHERIP support.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BRIDGE_DEBUG</span> 1

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span> <span class="enscript-comment">/* for net/if.h */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/random.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NBPFILTER</span> &gt; 0
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bpf.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_media.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span> <span class="enscript-comment">/* for struct arpcom */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_IP_VHL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DEV_CARP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_carp.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/if_ether.h&gt;</span> <span class="enscript-comment">/* for struct arpcom */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bridgestp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_bridgevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_llc.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NVLAN</span> &gt; 0
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_vlan_var.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NVLAN &gt; 0 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_ether.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_interfacefilter.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PFIL_HOOKS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_fw2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_dummynet.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFIL_HOOKS */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/bootp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/dhcp.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BR_DBGF_LIFECYCLE</span>	0x0001
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BR_DBGF_INPUT</span>		0x0002
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BR_DBGF_OUTPPUT</span>		0x0004
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BR_DBGF_RT_TABLE</span>	0x0008
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BR_DBGF_DELAYED_CALL</span>	0x0010
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BR_DBGF_IOCTL</span>		0x0020
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BR_DBGF_MBUF</span>		0x0040
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BR_DBGF_MCAST</span>		0x0080
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BR_DBGF_HOSTFILTER</span>	0x0100
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">_BRIDGE_LOCK</span>(_sc)		lck_mtx_lock(&amp;(_sc)-&gt;sc_mtx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">_BRIDGE_UNLOCK</span>(_sc)		lck_mtx_unlock(&amp;(_sc)-&gt;sc_mtx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_LOCK_ASSERT_HELD</span>(_sc)		\
	lck_mtx_assert(&amp;(_sc)-&gt;sc_mtx, LCK_MTX_ASSERT_OWNED)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_LOCK_ASSERT_NOTHELD</span>(_sc)		\
	lck_mtx_assert(&amp;(_sc)-&gt;sc_mtx, LCK_MTX_ASSERT_NOTOWNED)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BR_LCKDBG_MAX</span>			4

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_LOCK</span>(_sc)		bridge_lock(_sc)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_UNLOCK</span>(_sc)		bridge_unlock(_sc)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_LOCK2REF</span>(_sc, _err)	_err = bridge_lock2ref(_sc)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_UNREF</span>(_sc)		bridge_unref(_sc)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_XLOCK</span>(_sc)		bridge_xlock(_sc)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_XDROP</span>(_sc)		bridge_xdrop(_sc)

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !BRIDGE_DEBUG */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_LOCK</span>(_sc)		_BRIDGE_LOCK(_sc)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_UNLOCK</span>(_sc)		_BRIDGE_UNLOCK(_sc)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_LOCK2REF</span>(_sc, _err)	do {				\
	BRIDGE_LOCK_ASSERT_HELD(_sc);					\
	<span class="enscript-keyword">if</span> ((_sc)-&gt;sc_iflist_xcnt &gt; 0)					\
		(_err) = EBUSY;						\
	<span class="enscript-keyword">else</span>								\
		(_sc)-&gt;sc_iflist_ref++;					\
	_BRIDGE_UNLOCK(_sc);						\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_UNREF</span>(_sc)		do {				\
	_BRIDGE_LOCK(_sc);						\
	(_sc)-&gt;sc_iflist_ref--;						\
	<span class="enscript-keyword">if</span> (((_sc)-&gt;sc_iflist_xcnt &gt; 0) &amp;&amp; ((_sc)-&gt;sc_iflist_ref == 0))	{ \
		_BRIDGE_UNLOCK(_sc);					\
		wakeup(&amp;(_sc)-&gt;sc_cv);					\
	} <span class="enscript-keyword">else</span>								\
		_BRIDGE_UNLOCK(_sc);					\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_XLOCK</span>(_sc)		do {				\
	BRIDGE_LOCK_ASSERT_HELD(_sc);					\
	(_sc)-&gt;sc_iflist_xcnt++;					\
	<span class="enscript-keyword">while</span> ((_sc)-&gt;sc_iflist_ref &gt; 0)				\
		msleep(&amp;(_sc)-&gt;sc_cv, &amp;(_sc)-&gt;sc_mtx, PZERO,		\
		    <span class="enscript-string">&quot;BRIDGE_XLOCK&quot;</span>, NULL);				\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_XDROP</span>(_sc)		do {				\
	BRIDGE_LOCK_ASSERT_HELD(_sc);					\
	(_sc)-&gt;sc_iflist_xcnt--;					\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NBPFILTER</span> &gt; 0
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_BPF_MTAP_INPUT</span>(sc, m)					\
	<span class="enscript-keyword">if</span> (sc-&gt;sc_bpf_input)						\
		bridge_bpf_input(sc-&gt;sc_ifp, m)
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* NBPFILTER */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_BPF_MTAP_INPUT</span>(ifp, m)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NBPFILTER */</span>

<span class="enscript-comment">/*
 * Initial size of the route hash table.  Must be a power of two.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">BRIDGE_RTHASH_SIZE</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BRIDGE_RTHASH_SIZE</span>		16
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Maximum size of the routing hash table
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BRIDGE_RTHASH_SIZE_MAX</span>		2048

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_RTHASH_MASK</span>(sc)		((sc)-&gt;sc_rthash_size - 1)

<span class="enscript-comment">/*
 * Maximum number of addresses to cache.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">BRIDGE_RTABLE_MAX</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BRIDGE_RTABLE_MAX</span>		100
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 * Timeout (in seconds) for entries learned dynamically.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">BRIDGE_RTABLE_TIMEOUT</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BRIDGE_RTABLE_TIMEOUT</span>		(20 * 60)	<span class="enscript-comment">/* same as ARP */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Number of seconds between walks of the route list.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">BRIDGE_RTABLE_PRUNE_PERIOD</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BRIDGE_RTABLE_PRUNE_PERIOD</span>	(5 * 60)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * List of capabilities to possibly mask on the member interface.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BRIDGE_IFCAPS_MASK</span>		(IFCAP_TOE|IFCAP_TSO|IFCAP_TXCSUM)
<span class="enscript-comment">/*
 * List of capabilities to disable on the member interface.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BRIDGE_IFCAPS_STRIP</span>		IFCAP_LRO

<span class="enscript-comment">/*
 * Bridge interface list entry.
 */</span>
<span class="enscript-type">struct</span> bridge_iflist {
	TAILQ_ENTRY(bridge_iflist) bif_next;
	<span class="enscript-type">struct</span> ifnet		*bif_ifp;	<span class="enscript-comment">/* member if */</span>
	<span class="enscript-type">struct</span> bstp_port	bif_stp;	<span class="enscript-comment">/* STP state */</span>
	uint32_t		bif_ifflags;	<span class="enscript-comment">/* member if flags */</span>
	<span class="enscript-type">int</span>			bif_savedcaps;	<span class="enscript-comment">/* saved capabilities */</span>
	uint32_t		bif_addrmax;	<span class="enscript-comment">/* max # of addresses */</span>
	uint32_t		bif_addrcnt;	<span class="enscript-comment">/* cur. # of addresses */</span>
	uint32_t		bif_addrexceeded; <span class="enscript-comment">/* # of address violations */</span>

	interface_filter_t	bif_iff_ref;
	<span class="enscript-type">struct</span> bridge_softc	*bif_sc;
	uint32_t		bif_flags;

	<span class="enscript-type">struct</span> in_addr		bif_hf_ipsrc;
	uint8_t			bif_hf_hwsrc[ETHER_ADDR_LEN];
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BIFF_PROMISC</span>		0x01	<span class="enscript-comment">/* promiscuous mode set */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BIFF_PROTO_ATTACHED</span>	0x02	<span class="enscript-comment">/* protocol attached */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BIFF_FILTER_ATTACHED</span>	0x04	<span class="enscript-comment">/* interface filter attached */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BIFF_MEDIA_ACTIVE</span>	0x08	<span class="enscript-comment">/* interface media active */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BIFF_HOST_FILTER</span>	0x10	<span class="enscript-comment">/* host filter enabled */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BIFF_HF_HWSRC</span>		0x20	<span class="enscript-comment">/* host filter source MAC is set */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BIFF_HF_IPSRC</span>		0x40	<span class="enscript-comment">/* host filter source IP is set */</span>

<span class="enscript-comment">/*
 * Bridge route node.
 */</span>
<span class="enscript-type">struct</span> bridge_rtnode {
	LIST_ENTRY(bridge_rtnode) brt_hash;	<span class="enscript-comment">/* hash table linkage */</span>
	LIST_ENTRY(bridge_rtnode) brt_list;	<span class="enscript-comment">/* list linkage */</span>
	<span class="enscript-type">struct</span> bridge_iflist	*brt_dst;	<span class="enscript-comment">/* destination if */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>		brt_expire;	<span class="enscript-comment">/* expiration time */</span>
	uint8_t			brt_flags;	<span class="enscript-comment">/* address flags */</span>
	uint8_t			brt_addr[ETHER_ADDR_LEN];
	uint16_t		brt_vlan;	<span class="enscript-comment">/* vlan id */</span>

};
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">brt_ifp</span>			brt_dst-&gt;bif_ifp

<span class="enscript-comment">/*
 * Bridge delayed function call context
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*bridge_delayed_func_t)(<span class="enscript-type">struct</span> bridge_softc *);

<span class="enscript-type">struct</span> bridge_delayed_call {
	<span class="enscript-type">struct</span> bridge_softc	*bdc_sc;
	bridge_delayed_func_t 	bdc_func; <span class="enscript-comment">/* Function to call */</span>
	<span class="enscript-type">struct</span> timespec 	bdc_ts;	<span class="enscript-comment">/* Time to call */</span>
	u_int32_t		bdc_flags;
	thread_call_t		bdc_thread_call;
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BDCF_OUTSTANDING</span> 	0x01	<span class="enscript-comment">/* Delayed call has been scheduled */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BDCF_CANCELLING</span>		0x02	<span class="enscript-comment">/* May be waiting for call completion */</span>

<span class="enscript-comment">/*
 * Software state for each bridge.
 */</span>

<span class="enscript-function-name">LIST_HEAD</span>(_bridge_rtnode_list, bridge_rtnode);

<span class="enscript-type">struct</span> bridge_softc {
	<span class="enscript-type">struct</span> ifnet		*sc_ifp;	<span class="enscript-comment">/* make this an interface */</span>
	LIST_ENTRY(bridge_softc) sc_list;
	decl_lck_mtx_data(,	sc_mtx);
	<span class="enscript-type">void</span>			*sc_cv;
	uint32_t		sc_brtmax;	<span class="enscript-comment">/* max # of addresses */</span>
	uint32_t		sc_brtcnt;	<span class="enscript-comment">/* cur. # of addresses */</span>
	uint32_t		sc_brttimeout;	<span class="enscript-comment">/* rt timeout in seconds */</span>
	uint32_t		sc_iflist_ref;	<span class="enscript-comment">/* refcount for sc_iflist */</span>
	uint32_t		sc_iflist_xcnt;	<span class="enscript-comment">/* refcount for sc_iflist */</span>
	TAILQ_HEAD(, bridge_iflist) sc_iflist;	<span class="enscript-comment">/* member interface list */</span>
	<span class="enscript-type">struct</span> _bridge_rtnode_list *sc_rthash;	<span class="enscript-comment">/* our forwarding table */</span>
	<span class="enscript-type">struct</span> _bridge_rtnode_list sc_rtlist;	<span class="enscript-comment">/* list version of above */</span>
	uint32_t		sc_rthash_key;	<span class="enscript-comment">/* key for hash */</span>
	uint32_t		sc_rthash_size;	<span class="enscript-comment">/* size of the hash table */</span>
	TAILQ_HEAD(, bridge_iflist) sc_spanlist;	<span class="enscript-comment">/* span ports list */</span>
	<span class="enscript-type">struct</span> bstp_state	sc_stp;		<span class="enscript-comment">/* STP state */</span>
	uint32_t		sc_brtexceeded;	<span class="enscript-comment">/* # of cache drops */</span>
	uint32_t		sc_filter_flags; <span class="enscript-comment">/* ipf and flags */</span>
	<span class="enscript-type">struct</span> ifnet		*sc_ifaddr;	<span class="enscript-comment">/* member mac copied from */</span>
	u_char			sc_defaddr[6];	<span class="enscript-comment">/* Default MAC address */</span>

	<span class="enscript-type">char</span>			sc_if_xname[IFNAMSIZ];
	bpf_packet_func		sc_bpf_input;
	bpf_packet_func		sc_bpf_output;
	u_int32_t		sc_flags;
	<span class="enscript-type">struct</span> bridge_delayed_call sc_aging_timer;
	<span class="enscript-type">struct</span> bridge_delayed_call sc_resize_call;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-comment">/*
	 * Locking and unlocking calling history
	 */</span>
	<span class="enscript-type">void</span>			*lock_lr[BR_LCKDBG_MAX];
	<span class="enscript-type">int</span>			next_lock_lr;
	<span class="enscript-type">void</span>			*unlock_lr[BR_LCKDBG_MAX];
	<span class="enscript-type">int</span>			next_unlock_lr;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCF_DETACHING</span> 0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCF_RESIZING</span> 0x02
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCF_MEDIA_ACTIVE</span> 0x04

<span class="enscript-type">struct</span> bridge_hostfilter_stats bridge_hostfilter_stats;

<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, bridge_list_mtx);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_rtable_prune_period = BRIDGE_RTABLE_PRUNE_PERIOD;

<span class="enscript-type">static</span> zone_t	bridge_rtnode_pool = NULL;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_clone_create(<span class="enscript-type">struct</span> if_clone *, uint32_t, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_clone_destroy(<span class="enscript-type">struct</span> ifnet *);

<span class="enscript-type">static</span> errno_t	bridge_ioctl(<span class="enscript-type">struct</span> ifnet *, u_long, <span class="enscript-type">void</span> *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAS_IF_CAP</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_mutecaps(<span class="enscript-type">struct</span> bridge_softc *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_set_ifcap(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">struct</span> bridge_iflist *,
		    <span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">bridge_set_tso</span>(<span class="enscript-type">struct</span> bridge_softc *);
__private_extern__ <span class="enscript-type">void</span>	bridge_ifdetach(<span class="enscript-type">struct</span> bridge_iflist *, <span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_init(<span class="enscript-type">struct</span> ifnet *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAS_BRIDGE_DUMMYNET</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_dummynet(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> ifnet *);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_ifstop(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_output(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_finalize_cksum(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_start(<span class="enscript-type">struct</span> ifnet *);
__private_extern__ errno_t bridge_input(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">void</span> *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_MEMBER_OUT_FILTER</span>
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">bridge_iff_output</span>(<span class="enscript-type">void</span> *, ifnet_t, protocol_family_t,
	mbuf_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_member_output(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *,
		    <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> rtentry *);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_enqueue(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">struct</span> ifnet *,
		    <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_rtdelete(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_forward(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">struct</span> bridge_iflist *,
		    <span class="enscript-type">struct</span> mbuf *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_aging_timer(<span class="enscript-type">struct</span> bridge_softc *sc);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_broadcast(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">struct</span> ifnet *,
		    <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_span(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">struct</span> mbuf *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_rtupdate(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">const</span> uint8_t *,
		    uint16_t, <span class="enscript-type">struct</span> bridge_iflist *, <span class="enscript-type">int</span>, uint8_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifnet *<span class="enscript-function-name">bridge_rtlookup</span>(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">const</span> uint8_t *,
		    uint16_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_rttrim(<span class="enscript-type">struct</span> bridge_softc *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_rtage(<span class="enscript-type">struct</span> bridge_softc *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_rtflush(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_rtdaddr(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">const</span> uint8_t *,
		    uint16_t);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_rtable_init(<span class="enscript-type">struct</span> bridge_softc *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_rtable_fini(<span class="enscript-type">struct</span> bridge_softc *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_rthash_resize(<span class="enscript-type">struct</span> bridge_softc *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_rtnode_addr_cmp(<span class="enscript-type">const</span> uint8_t *, <span class="enscript-type">const</span> uint8_t *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> bridge_rtnode *<span class="enscript-function-name">bridge_rtnode_lookup</span>(<span class="enscript-type">struct</span> bridge_softc *,
		    <span class="enscript-type">const</span> uint8_t *, uint16_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_rtnode_hash(<span class="enscript-type">struct</span> bridge_softc *,
		    <span class="enscript-type">struct</span> bridge_rtnode *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_rtnode_insert(<span class="enscript-type">struct</span> bridge_softc *,
		    <span class="enscript-type">struct</span> bridge_rtnode *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_rtnode_destroy(<span class="enscript-type">struct</span> bridge_softc *,
		    <span class="enscript-type">struct</span> bridge_rtnode *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_rtable_expire(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_state_change(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> bridge_iflist *<span class="enscript-function-name">bridge_lookup_member</span>(<span class="enscript-type">struct</span> bridge_softc *,
		    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> bridge_iflist *<span class="enscript-function-name">bridge_lookup_member_if</span>(<span class="enscript-type">struct</span> bridge_softc *,
		    <span class="enscript-type">struct</span> ifnet *ifp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_delete_member(<span class="enscript-type">struct</span> bridge_softc *,
		    <span class="enscript-type">struct</span> bridge_iflist *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bridge_delete_span(<span class="enscript-type">struct</span> bridge_softc *,
		    <span class="enscript-type">struct</span> bridge_iflist *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_add(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_del(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gifflags(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_sifflags(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_scache(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gcache(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gifs32(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gifs64(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_rts32(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_rts64(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_saddr32(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_saddr64(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_sto(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gto(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_daddr32(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_daddr64(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_flush(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gpri(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_spri(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_ght(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_sht(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gfd(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_sfd(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gma(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_sma(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_sifprio(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_sifcost(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_sifmaxaddr(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_addspan(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_delspan(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gbparam32(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gbparam64(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_grte(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gifsstp32(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gifsstp64(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_sproto(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_stxhc(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_purge(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_gfilt(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_sfilt(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_ghostfilter(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ioctl_shostfilter(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PFIL_HOOKS</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_pfil(<span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> ifnet *,
		    <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ip_checkbasic(<span class="enscript-type">struct</span> mbuf **);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_ip6_checkbasic(<span class="enscript-type">struct</span> mbuf **);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	bridge_fragment(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *,
		    <span class="enscript-type">struct</span> ether_header *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> llc *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFIL_HOOKS */</span>

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">bridge_set_bpf_tap</span>(ifnet_t, bpf_tap_mode, bpf_packet_func);
__private_extern__ errno_t bridge_bpf_input(ifnet_t, <span class="enscript-type">struct</span> mbuf *);
__private_extern__ errno_t bridge_bpf_output(ifnet_t, <span class="enscript-type">struct</span> mbuf *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bridge_detach</span>(ifnet_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bridge_link_event</span>(<span class="enscript-type">struct</span> ifnet *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bridge_iflinkevent</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">bridge_updatelinkstatus</span>(<span class="enscript-type">struct</span> bridge_softc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">interface_media_active</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bridge_schedule_delayed_call</span>(<span class="enscript-type">struct</span> bridge_delayed_call *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bridge_cancel_delayed_call</span>(<span class="enscript-type">struct</span> bridge_delayed_call *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bridge_cleanup_delayed_call</span>(<span class="enscript-type">struct</span> bridge_delayed_call *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bridge_host_filter</span>(<span class="enscript-type">struct</span> bridge_iflist *, <span class="enscript-type">struct</span> mbuf *);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_copypacket</span>(m, how) m_copym(m, 0, M_COPYALL, how)

<span class="enscript-comment">/* The default bridge vlan is 1 (IEEE 802.1Q-2003 Table 9-2) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VLANTAGOF</span>(_m)	0

u_int8_t bstp_etheraddr[ETHER_ADDR_LEN] =
	{ 0x01, 0x80, 0xc2, 0x00, 0x00, 0x00 };

<span class="enscript-type">static</span> u_int8_t ethernulladdr[ETHER_ADDR_LEN] =
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> bstp_cb_ops bridge_ops = {
	.bcb_state = bridge_state_change,
	.bcb_rtage = bridge_rtable_expire
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_link);
<span class="enscript-function-name">SYSCTL_NODE</span>(_net_link, IFT_BRIDGE, bridge, CTLFLAG_RW|CTLFLAG_LOCKED, 0,
	<span class="enscript-string">&quot;Bridge&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> bridge_inherit_mac = 0;   <span class="enscript-comment">/* share MAC with first bridge member */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_bridge, OID_AUTO, inherit_mac,
	CTLFLAG_RW|CTLFLAG_LOCKED,
	&amp;bridge_inherit_mac, 0,
	<span class="enscript-string">&quot;Inherit MAC address from the first bridge member&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_bridge, OID_AUTO, rtable_prune_period,
	CTLFLAG_RW|CTLFLAG_LOCKED,
	&amp;bridge_rtable_prune_period, 0,
	<span class="enscript-string">&quot;Interval between pruning of routing table&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bridge_rtable_hash_size_max = BRIDGE_RTHASH_SIZE_MAX;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_link_bridge, OID_AUTO, rtable_hash_size_max,
	CTLFLAG_RW|CTLFLAG_LOCKED,
	&amp;bridge_rtable_hash_size_max, 0,
	<span class="enscript-string">&quot;Maximum size of the routing hash table&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG_DELAYED_CALLBACK</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> bridge_delayed_callback_delay = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_bridge, OID_AUTO, delayed_callback_delay,
	CTLFLAG_RW|CTLFLAG_LOCKED,
	&amp;bridge_delayed_callback_delay, 0,
	<span class="enscript-string">&quot;Delay before calling delayed function&quot;</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-function-name">SYSCTL_STRUCT</span>(_net_link_bridge, OID_AUTO,
	hostfilterstats, CTLFLAG_RD | CTLFLAG_LOCKED,
	&amp;bridge_hostfilter_stats, bridge_hostfilter_stats, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">PFIL_HOOKS</span>)
<span class="enscript-type">static</span> <span class="enscript-type">int</span> pfil_onlyip = 1; <span class="enscript-comment">/* only pass IP[46] packets when pfil is enabled */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> pfil_bridge = 1; <span class="enscript-comment">/* run pfil hooks on the bridge interface */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> pfil_member = 1; <span class="enscript-comment">/* run pfil hooks on the member interface */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> pfil_ipfw = 0;   <span class="enscript-comment">/* layer2 filter with ipfw */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> pfil_ipfw_arp = 0;   <span class="enscript-comment">/* layer2 filter with ipfw */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> pfil_local_phys = 0; <span class="enscript-comment">/* run pfil hooks on the physical interface */</span>
				<span class="enscript-comment">/* for locally destined packets */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_bridge, OID_AUTO, pfil_onlyip, CTLFLAG_RW|CTLFLAG_LOCKED,
	&amp;pfil_onlyip, 0, <span class="enscript-string">&quot;Only pass IP packets when pfil is enabled&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_bridge, OID_AUTO, ipfw_arp, CTLFLAG_RW|CTLFLAG_LOCKED,
	&amp;pfil_ipfw_arp, 0, <span class="enscript-string">&quot;Filter ARP packets through IPFW layer2&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_bridge, OID_AUTO, pfil_bridge, CTLFLAG_RW|CTLFLAG_LOCKED,
	&amp;pfil_bridge, 0, <span class="enscript-string">&quot;Packet filter on the bridge interface&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_bridge, OID_AUTO, pfil_member, CTLFLAG_RW|CTLFLAG_LOCKED,
	&amp;pfil_member, 0, <span class="enscript-string">&quot;Packet filter on the member interface&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_bridge, OID_AUTO, pfil_local_phys,
	CTLFLAG_RW|CTLFLAG_LOCKED, &amp;pfil_local_phys, 0,
	<span class="enscript-string">&quot;Packet filter on the physical interface for locally destined packets&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFIL_HOOKS */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> log_stp   = 0;   <span class="enscript-comment">/* log STP state changes */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_bridge, OID_AUTO, log_stp, CTLFLAG_RW,
	&amp;log_stp, 0, <span class="enscript-string">&quot;Log STP state changes&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

<span class="enscript-type">struct</span> bridge_control {
	<span class="enscript-type">int</span>		(*bc_func)(<span class="enscript-type">struct</span> bridge_softc *, <span class="enscript-type">void</span> *);
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	bc_argsize;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	bc_flags;
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BC_F_COPYIN</span>		0x01	<span class="enscript-comment">/* copy arguments in */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BC_F_COPYOUT</span>		0x02	<span class="enscript-comment">/* copy arguments out */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BC_F_SUSER</span>		0x04	<span class="enscript-comment">/* do super-user check */</span>

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> bridge_control bridge_control_table32[] = {
	{ bridge_ioctl_add,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),	<span class="enscript-comment">/* 0 */</span>
	    BC_F_COPYIN|BC_F_SUSER },
	{ bridge_ioctl_del,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_gifflags,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_COPYOUT },
	{ bridge_ioctl_sifflags,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_scache,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },
	{ bridge_ioctl_gcache,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },

	{ bridge_ioctl_gifs32,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbifconf32),
	    BC_F_COPYIN|BC_F_COPYOUT },
	{ bridge_ioctl_rts32,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbaconf32),
	    BC_F_COPYIN|BC_F_COPYOUT },

	{ bridge_ioctl_saddr32,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbareq32),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_sto,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },
	{ bridge_ioctl_gto,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam), <span class="enscript-comment">/* 10 */</span>
	    BC_F_COPYOUT },

	{ bridge_ioctl_daddr32,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbareq32),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_flush,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_gpri,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },
	{ bridge_ioctl_spri,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_ght,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },
	{ bridge_ioctl_sht,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_gfd,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },
	{ bridge_ioctl_sfd,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_gma,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },
	{ bridge_ioctl_sma,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam), <span class="enscript-comment">/* 20 */</span>
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_sifprio,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_sifcost,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_gfilt,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },
	{ bridge_ioctl_sfilt,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_purge,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_addspan,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
		BC_F_COPYIN|BC_F_SUSER },
	{ bridge_ioctl_delspan,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
		BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_gbparam32,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbropreq32),
	    BC_F_COPYOUT },

	{ bridge_ioctl_grte,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },

	{ bridge_ioctl_gifsstp32,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbpstpconf32), <span class="enscript-comment">/* 30 */</span>
	    BC_F_COPYIN|BC_F_COPYOUT },

	{ bridge_ioctl_sproto,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_stxhc,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_sifmaxaddr,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_ghostfilter,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrhostfilter),
	    BC_F_COPYIN|BC_F_COPYOUT },
	{ bridge_ioctl_shostfilter,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrhostfilter),
	    BC_F_COPYIN|BC_F_SUSER },
};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> bridge_control bridge_control_table64[] = {
	{ bridge_ioctl_add,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq), <span class="enscript-comment">/* 0 */</span>
	    BC_F_COPYIN|BC_F_SUSER },
	{ bridge_ioctl_del,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_gifflags,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_COPYOUT },
	{ bridge_ioctl_sifflags,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_scache,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },
	{ bridge_ioctl_gcache,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },

	{ bridge_ioctl_gifs64,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbifconf64),
	    BC_F_COPYIN|BC_F_COPYOUT },
	{ bridge_ioctl_rts64,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbaconf64),
	    BC_F_COPYIN|BC_F_COPYOUT },

	{ bridge_ioctl_saddr64,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbareq64),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_sto,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },
	{ bridge_ioctl_gto,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam), <span class="enscript-comment">/* 10 */</span>
	    BC_F_COPYOUT },

	{ bridge_ioctl_daddr64,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbareq64),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_flush,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_gpri,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },
	{ bridge_ioctl_spri,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_ght,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },
	{ bridge_ioctl_sht,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_gfd,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },
	{ bridge_ioctl_sfd,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_gma,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },
	{ bridge_ioctl_sma,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam), <span class="enscript-comment">/* 20 */</span>
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_sifprio,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_sifcost,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_gfilt,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },
	{ bridge_ioctl_sfilt,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_purge,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_addspan,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },
	{ bridge_ioctl_delspan,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_gbparam64,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbropreq64),
	    BC_F_COPYOUT },

	{ bridge_ioctl_grte,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYOUT },

	{ bridge_ioctl_gifsstp64,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbpstpconf64), <span class="enscript-comment">/* 30 */</span>
	    BC_F_COPYIN|BC_F_COPYOUT },

	{ bridge_ioctl_sproto,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_stxhc,		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrparam),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_sifmaxaddr,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbreq),
	    BC_F_COPYIN|BC_F_SUSER },

	{ bridge_ioctl_ghostfilter,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrhostfilter),
	    BC_F_COPYIN|BC_F_COPYOUT },
	{ bridge_ioctl_shostfilter,	<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifbrhostfilter),
	    BC_F_COPYIN|BC_F_SUSER },
};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bridge_control_table_size =
	<span class="enscript-keyword">sizeof</span> (bridge_control_table32) / <span class="enscript-keyword">sizeof</span> (bridge_control_table32[0]);

<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(, bridge_softc) bridge_list =
	LIST_HEAD_INITIALIZER(bridge_list);

<span class="enscript-type">static</span> lck_grp_t *bridge_lock_grp = NULL;
<span class="enscript-type">static</span> lck_attr_t *bridge_lock_attr = NULL;

<span class="enscript-type">static</span> if_clone_t bridge_cloner = NULL;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> if_bridge_txstart = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_bridge, OID_AUTO, txstart, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;if_bridge_txstart, 0, <span class="enscript-string">&quot;Bridge interface uses TXSTART model&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> if_bridge_debug = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_bridge, OID_AUTO, debug, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;if_bridge_debug, 0, <span class="enscript-string">&quot;Bridge debug&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">printf_ether_header</span>(<span class="enscript-type">struct</span> ether_header *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">printf_mbuf_data</span>(mbuf_t, size_t, size_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">printf_mbuf_pkthdr</span>(mbuf_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">printf_mbuf</span>(mbuf_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">link_print</span>(<span class="enscript-type">struct</span> sockaddr_dl *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bridge_lock</span>(<span class="enscript-type">struct</span> bridge_softc *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bridge_unlock</span>(<span class="enscript-type">struct</span> bridge_softc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bridge_lock2ref</span>(<span class="enscript-type">struct</span> bridge_softc *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bridge_unref</span>(<span class="enscript-type">struct</span> bridge_softc *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bridge_xlock</span>(<span class="enscript-type">struct</span> bridge_softc *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bridge_xdrop</span>(<span class="enscript-type">struct</span> bridge_softc *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_lock</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	<span class="enscript-type">void</span> *lr_saved = __builtin_return_address(0);

	BRIDGE_LOCK_ASSERT_NOTHELD(sc);

	_BRIDGE_LOCK(sc);

	sc-&gt;lock_lr[sc-&gt;next_lock_lr] = lr_saved;
	sc-&gt;next_lock_lr = (sc-&gt;next_lock_lr+1) % SO_LCKDBG_MAX;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_unlock</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	<span class="enscript-type">void</span> *lr_saved = __builtin_return_address(0);

	BRIDGE_LOCK_ASSERT_HELD(sc);

	sc-&gt;unlock_lr[sc-&gt;next_unlock_lr] = lr_saved;
	sc-&gt;next_unlock_lr = (sc-&gt;next_unlock_lr+1) % SO_LCKDBG_MAX;

	_BRIDGE_UNLOCK(sc);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_lock2ref</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">void</span> *lr_saved = __builtin_return_address(0);

	BRIDGE_LOCK_ASSERT_HELD(sc);

	<span class="enscript-keyword">if</span> (sc-&gt;sc_iflist_xcnt &gt; 0)
		error = EBUSY;
	<span class="enscript-keyword">else</span>
		sc-&gt;sc_iflist_ref++;

	sc-&gt;unlock_lr[sc-&gt;next_unlock_lr] = lr_saved;
	sc-&gt;next_unlock_lr = (sc-&gt;next_unlock_lr+1) % SO_LCKDBG_MAX;

	_BRIDGE_UNLOCK(sc);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_unref</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	<span class="enscript-type">void</span> *lr_saved = __builtin_return_address(0);

	BRIDGE_LOCK_ASSERT_NOTHELD(sc);

	_BRIDGE_LOCK(sc);
	sc-&gt;lock_lr[sc-&gt;next_lock_lr] = lr_saved;
	sc-&gt;next_lock_lr = (sc-&gt;next_lock_lr+1) % SO_LCKDBG_MAX;

	sc-&gt;sc_iflist_ref--;

	sc-&gt;unlock_lr[sc-&gt;next_unlock_lr] = lr_saved;
	sc-&gt;next_unlock_lr = (sc-&gt;next_unlock_lr+1) % SO_LCKDBG_MAX;
	<span class="enscript-keyword">if</span> ((sc-&gt;sc_iflist_xcnt &gt; 0) &amp;&amp; (sc-&gt;sc_iflist_ref == 0)) {
		_BRIDGE_UNLOCK(sc);
		wakeup(&amp;sc-&gt;sc_cv);
	} <span class="enscript-keyword">else</span>
		_BRIDGE_UNLOCK(sc);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_xlock</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	<span class="enscript-type">void</span> *lr_saved = __builtin_return_address(0);

	BRIDGE_LOCK_ASSERT_HELD(sc);

	sc-&gt;sc_iflist_xcnt++;
	<span class="enscript-keyword">while</span> (sc-&gt;sc_iflist_ref &gt; 0) {
		sc-&gt;unlock_lr[sc-&gt;next_unlock_lr] = lr_saved;
		sc-&gt;next_unlock_lr = (sc-&gt;next_unlock_lr+1) % SO_LCKDBG_MAX;

		msleep(&amp;sc-&gt;sc_cv, &amp;sc-&gt;sc_mtx, PZERO, <span class="enscript-string">&quot;BRIDGE_XLOCK&quot;</span>, NULL);

		sc-&gt;lock_lr[sc-&gt;next_lock_lr] = lr_saved;
		sc-&gt;next_lock_lr = (sc-&gt;next_lock_lr+1) % SO_LCKDBG_MAX;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_xdrop</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	BRIDGE_LOCK_ASSERT_HELD(sc);

	sc-&gt;sc_iflist_xcnt--;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">printf_mbuf_pkthdr</span>(mbuf_t m, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *prefix, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *suffix)
{
	<span class="enscript-keyword">if</span> (m)
		printf(<span class="enscript-string">&quot;%spktlen: %u rcvif: 0x%llx header: 0x%llx &quot;</span>
		    <span class="enscript-string">&quot;nextpkt: 0x%llx%s&quot;</span>,
		    prefix ? prefix : <span class="enscript-string">&quot;&quot;</span>, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)mbuf_pkthdr_len(m),
		    (uint64_t)VM_KERNEL_ADDRPERM(mbuf_pkthdr_rcvif(m)),
		    (uint64_t)VM_KERNEL_ADDRPERM(mbuf_pkthdr_header(m)),
		    (uint64_t)VM_KERNEL_ADDRPERM(mbuf_nextpkt(m)),
		    suffix ? suffix : <span class="enscript-string">&quot;&quot;</span>);
	<span class="enscript-keyword">else</span>
		printf(<span class="enscript-string">&quot;%s&lt;NULL&gt;%s\n&quot;</span>, prefix, suffix);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">printf_mbuf</span>(mbuf_t m, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *prefix, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *suffix)
{
	<span class="enscript-keyword">if</span> (m) {
		printf(<span class="enscript-string">&quot;%s0x%llx type: %u flags: 0x%x len: %u data: 0x%llx &quot;</span>
		    <span class="enscript-string">&quot;maxlen: %u datastart: 0x%llx next: 0x%llx%s&quot;</span>,
		    prefix ? prefix : <span class="enscript-string">&quot;&quot;</span>, (uint64_t)VM_KERNEL_ADDRPERM(m),
		    mbuf_type(m), mbuf_flags(m), (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)mbuf_len(m),
		    (uint64_t)VM_KERNEL_ADDRPERM(mbuf_data(m)),
		    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)mbuf_maxlen(m),
		    (uint64_t)VM_KERNEL_ADDRPERM(mbuf_datastart(m)),
		    (uint64_t)VM_KERNEL_ADDRPERM(mbuf_next(m)),
		    !suffix || (mbuf_flags(m) &amp; MBUF_PKTHDR) ? <span class="enscript-string">&quot;&quot;</span> : suffix);
		<span class="enscript-keyword">if</span> ((mbuf_flags(m) &amp; MBUF_PKTHDR))
			printf_mbuf_pkthdr(m, <span class="enscript-string">&quot; &quot;</span>, suffix);
	} <span class="enscript-keyword">else</span>
		printf(<span class="enscript-string">&quot;%s&lt;NULL&gt;%s\n&quot;</span>, prefix, suffix);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">printf_mbuf_data</span>(mbuf_t m, size_t offset, size_t len)
{
	mbuf_t			n;
	size_t			i, j;
	size_t			pktlen, mlen, maxlen;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>	*ptr;

	pktlen = mbuf_pkthdr_len(m);

	<span class="enscript-keyword">if</span> (offset &gt; pktlen)
		<span class="enscript-keyword">return</span>;

	maxlen = (pktlen - offset &gt; len) ? len : pktlen - offset;
	n = m;
	mlen = mbuf_len(n);
	ptr = mbuf_data(n);
	<span class="enscript-keyword">for</span> (i = 0, j = 0; i &lt; maxlen; i++, j++) {
		<span class="enscript-keyword">if</span> (j &gt;= mlen) {
			n = mbuf_next(n);
			<span class="enscript-keyword">if</span> (n == 0)
				<span class="enscript-keyword">break</span>;
			ptr = mbuf_data(n);
			mlen = mbuf_len(n);
			j = 0;
		}
		<span class="enscript-keyword">if</span> (i &gt;= offset) {
			printf(<span class="enscript-string">&quot;%02x%s&quot;</span>, ptr[j], i % 2 ? <span class="enscript-string">&quot; &quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">printf_ether_header</span>(<span class="enscript-type">struct</span> ether_header *eh)
{
	printf(<span class="enscript-string">&quot;%02x:%02x:%02x:%02x:%02x:%02x &gt; &quot;</span>
	    <span class="enscript-string">&quot;%02x:%02x:%02x:%02x:%02x:%02x 0x%04x &quot;</span>,
	    eh-&gt;ether_shost[0], eh-&gt;ether_shost[1], eh-&gt;ether_shost[2],
	    eh-&gt;ether_shost[3], eh-&gt;ether_shost[4], eh-&gt;ether_shost[5],
	    eh-&gt;ether_dhost[0], eh-&gt;ether_dhost[1], eh-&gt;ether_dhost[2],
	    eh-&gt;ether_dhost[3], eh-&gt;ether_dhost[4], eh-&gt;ether_dhost[5],
	    ntohs(eh-&gt;ether_type));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">link_print</span>(<span class="enscript-type">struct</span> sockaddr_dl *dl_p)
{
	<span class="enscript-type">int</span> i;

#<span class="enscript-reference">if</span> 1
	printf(<span class="enscript-string">&quot;sdl len %d index %d family %d type 0x%x nlen %d alen %d&quot;</span>
	    <span class="enscript-string">&quot; slen %d addr &quot;</span>, dl_p-&gt;sdl_len, dl_p-&gt;sdl_index,
	    dl_p-&gt;sdl_family, dl_p-&gt;sdl_type, dl_p-&gt;sdl_nlen,
	    dl_p-&gt;sdl_alen, dl_p-&gt;sdl_slen);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; dl_p-&gt;sdl_alen; i++)
		printf(<span class="enscript-string">&quot;%s%x&quot;</span>, i ? <span class="enscript-string">&quot;:&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, (CONST_LLADDR(dl_p))[i]);
	printf(<span class="enscript-string">&quot;\n&quot;</span>);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

<span class="enscript-comment">/*
 * bridgeattach:
 *
 *	Pseudo-device attach routine.
 */</span>
__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">bridgeattach</span>(<span class="enscript-type">int</span> n)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">n</span>)
	<span class="enscript-type">int</span> error;
	lck_grp_attr_t *lck_grp_attr = NULL;
	<span class="enscript-type">struct</span> ifnet_clone_params ifnet_clone_params;

	bridge_rtnode_pool = zinit(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> bridge_rtnode),
	    1024 * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> bridge_rtnode), 0, <span class="enscript-string">&quot;bridge_rtnode&quot;</span>);
	zone_change(bridge_rtnode_pool, Z_CALLERACCT, FALSE);

	lck_grp_attr = lck_grp_attr_alloc_init();

	bridge_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;if_bridge&quot;</span>, lck_grp_attr);

	bridge_lock_attr = lck_attr_alloc_init();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	lck_attr_setdebug(bridge_lock_attr);
#<span class="enscript-reference">endif</span>

	lck_mtx_init(&amp;bridge_list_mtx, bridge_lock_grp, bridge_lock_attr);

	<span class="enscript-comment">/* can free the attributes once we've allocated the group lock */</span>
	lck_grp_attr_free(lck_grp_attr);

	LIST_INIT(&amp;bridge_list);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	bstp_sys_init();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

	ifnet_clone_params.ifc_name = <span class="enscript-string">&quot;bridge&quot;</span>;
	ifnet_clone_params.ifc_create = bridge_clone_create;
	ifnet_clone_params.ifc_destroy = bridge_clone_destroy;

	error = ifnet_clone_attach(&amp;ifnet_clone_params, &amp;bridge_cloner);
	<span class="enscript-keyword">if</span> (error != 0)
		printf(<span class="enscript-string">&quot;%s: ifnet_clone_attach failed %d\n&quot;</span>, __func__, error);

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">PFIL_HOOKS</span>)
<span class="enscript-comment">/*
 * handler for net.link.bridge.pfil_ipfw
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_pfil_ipfw SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> enable = pfil_ipfw;
	<span class="enscript-type">int</span> error;

	error = sysctl_handle_int(oidp, &amp;enable, 0, req);
	enable = (enable) ? 1 : 0;

	<span class="enscript-keyword">if</span> (enable != pfil_ipfw) {
		pfil_ipfw = enable;

		<span class="enscript-comment">/*
		 * Disable pfil so that ipfw doesnt run twice, if the user
		 * really wants both then they can re-enable pfil_bridge and/or
		 * pfil_member. Also allow non-ip packets as ipfw can filter by
		 * layer2 type.
		 */</span>
		<span class="enscript-keyword">if</span> (pfil_ipfw) {
			pfil_onlyip = 0;
			pfil_bridge = 0;
			pfil_member = 0;
		}
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_link_bridge, OID_AUTO, ipfw, CTLTYPE_INT|CTLFLAG_RW,
	    &amp;pfil_ipfw, 0, &amp;sysctl_pfil_ipfw, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Layer2 filter with IPFW&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFIL_HOOKS */</span>

<span class="enscript-comment">/*
 * bridge_clone_create:
 *
 *	Create a new bridge instance.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_clone_create</span>(<span class="enscript-type">struct</span> if_clone *ifc, uint32_t unit, <span class="enscript-type">void</span> *params)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">params</span>)
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	<span class="enscript-type">struct</span> bridge_softc *sc, *sc2;
	<span class="enscript-type">struct</span> ifnet_init_eparams init_params;
	errno_t error = 0;
	uint32_t sdl_buffer[offsetof(<span class="enscript-type">struct</span> sockaddr_dl, sdl_data) +
	    IFNAMSIZ + ETHER_ADDR_LEN];
	<span class="enscript-type">struct</span> sockaddr_dl *sdl = (<span class="enscript-type">struct</span> sockaddr_dl *)sdl_buffer;
	uint8_t eth_hostid[ETHER_ADDR_LEN];
	<span class="enscript-type">int</span> fb, retry, has_hostid;

	sc = _MALLOC(<span class="enscript-keyword">sizeof</span> (*sc), M_DEVBUF, M_WAITOK | M_ZERO);

	lck_mtx_init(&amp;sc-&gt;sc_mtx, bridge_lock_grp, bridge_lock_attr);
	sc-&gt;sc_brtmax = BRIDGE_RTABLE_MAX;
	sc-&gt;sc_brttimeout = BRIDGE_RTABLE_TIMEOUT;
	sc-&gt;sc_filter_flags = IFBF_FILT_DEFAULT;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">BRIDGE_IPF</span>
	<span class="enscript-comment">/*
	 * For backwards compatibility with previous behaviour...
	 * Switch off filtering on the bridge itself if BRIDGE_IPF is
	 * not defined.
	 */</span>
	sc-&gt;sc_filter_flags &amp;= ~IFBF_FILT_USEIPF;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Initialize our routing table. */</span>
	error = bridge_rtable_init(sc);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: bridge_rtable_init failed %d\n&quot;</span>, __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	TAILQ_INIT(&amp;sc-&gt;sc_iflist);
	TAILQ_INIT(&amp;sc-&gt;sc_spanlist);

	<span class="enscript-comment">/* use the interface name as the unique id for ifp recycle */</span>
	snprintf(sc-&gt;sc_if_xname, <span class="enscript-keyword">sizeof</span> (sc-&gt;sc_if_xname), <span class="enscript-string">&quot;%s%d&quot;</span>,
	    ifc-&gt;ifc_name, unit);
	bzero(&amp;init_params, <span class="enscript-keyword">sizeof</span> (init_params));
	init_params.ver			= IFNET_INIT_CURRENT_VERSION;
	init_params.len			= <span class="enscript-keyword">sizeof</span> (init_params);
	<span class="enscript-keyword">if</span> (if_bridge_txstart) {
		init_params.start	= bridge_start;
	} <span class="enscript-keyword">else</span> {
		init_params.flags	= IFNET_INIT_LEGACY;
		init_params.output	= bridge_output;
	}
	init_params.uniqueid		= sc-&gt;sc_if_xname;
	init_params.uniqueid_len	= strlen(sc-&gt;sc_if_xname);
	init_params.sndq_maxlen		= IFQ_MAXLEN;
	init_params.name		= ifc-&gt;ifc_name;
	init_params.unit		= unit;
	init_params.family		= IFNET_FAMILY_ETHERNET;
	init_params.type		= IFT_BRIDGE;
	init_params.demux		= ether_demux;
	init_params.add_proto		= ether_add_proto;
	init_params.del_proto		= ether_del_proto;
	init_params.check_multi		= ether_check_multi;
	init_params.framer_extended	= ether_frameout_extended;
	init_params.softc		= sc;
	init_params.ioctl		= bridge_ioctl;
	init_params.set_bpf_tap		= bridge_set_bpf_tap;
	init_params.detach		= bridge_detach;
	init_params.broadcast_addr	= etherbroadcastaddr;
	init_params.broadcast_len	= ETHER_ADDR_LEN;
	error = ifnet_allocate_extended(&amp;init_params, &amp;ifp);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: ifnet_allocate failed %d\n&quot;</span>, __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	sc-&gt;sc_ifp = ifp;

	error = ifnet_set_mtu(ifp, ETHERMTU);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: ifnet_set_mtu failed %d\n&quot;</span>, __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	error = ifnet_set_addrlen(ifp, ETHER_ADDR_LEN);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: ifnet_set_addrlen failed %d\n&quot;</span>, __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	error = ifnet_set_hdrlen(ifp, ETHER_HDR_LEN);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: ifnet_set_hdrlen failed %d\n&quot;</span>, __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	error = ifnet_set_flags(ifp,
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST,
	    0xffff);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: ifnet_set_flags failed %d\n&quot;</span>, __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Generate an ethernet address with a locally administered address.
	 *
	 * Since we are using random ethernet addresses for the bridge, it is
	 * possible that we might have address collisions, so make sure that
	 * this hardware address isn't already in use on another bridge.
	 * The first try uses the &quot;hostid&quot; and falls back to read_random();
	 * for &quot;hostid&quot;, we use the MAC address of the first-encountered
	 * Ethernet-type interface that is currently configured.
	 */</span>
	fb = 0;
	has_hostid = (uuid_get_ethernet(&amp;eth_hostid[0]) == 0);
	<span class="enscript-keyword">for</span> (retry = 1; retry != 0; ) {
		<span class="enscript-keyword">if</span> (fb || has_hostid == 0) {
			read_random(&amp;sc-&gt;sc_defaddr, ETHER_ADDR_LEN);
			sc-&gt;sc_defaddr[0] &amp;= ~1; <span class="enscript-comment">/* clear multicast bit */</span>
			sc-&gt;sc_defaddr[0] |= 2;  <span class="enscript-comment">/* set the LAA bit */</span>
		} <span class="enscript-keyword">else</span> {
			bcopy(&amp;eth_hostid[0], &amp;sc-&gt;sc_defaddr,
			    ETHER_ADDR_LEN);
			sc-&gt;sc_defaddr[0] &amp;= ~1; <span class="enscript-comment">/* clear multicast bit */</span>
			sc-&gt;sc_defaddr[0] |= 2;  <span class="enscript-comment">/* set the LAA bit */</span>
			sc-&gt;sc_defaddr[3] =	<span class="enscript-comment">/* stir it up a bit */</span>
			    ((sc-&gt;sc_defaddr[3] &amp; 0x0f) &lt;&lt; 4) |
			    ((sc-&gt;sc_defaddr[3] &amp; 0xf0) &gt;&gt; 4);
			<span class="enscript-comment">/*
			 * Mix in the LSB as it's actually pretty significant,
			 * see rdar://14076061
			 */</span>
			sc-&gt;sc_defaddr[4] =
			    (((sc-&gt;sc_defaddr[4] &amp; 0x0f) &lt;&lt; 4) |
			    ((sc-&gt;sc_defaddr[4] &amp; 0xf0) &gt;&gt; 4)) ^
			    sc-&gt;sc_defaddr[5];
			sc-&gt;sc_defaddr[5] = ifp-&gt;if_unit &amp; 0xff;
		}

		fb = 1;
		retry = 0;
		lck_mtx_lock(&amp;bridge_list_mtx);
		LIST_FOREACH(sc2, &amp;bridge_list, sc_list) {
			<span class="enscript-keyword">if</span> (memcmp(sc-&gt;sc_defaddr,
			    IF_LLADDR(sc2-&gt;sc_ifp), ETHER_ADDR_LEN) == 0)
				retry = 1;
		}
		lck_mtx_unlock(&amp;bridge_list_mtx);
	}

	memset(sdl, 0, <span class="enscript-keyword">sizeof</span> (sdl_buffer));
	sdl-&gt;sdl_family = AF_LINK;
	sdl-&gt;sdl_nlen = strlen(sc-&gt;sc_if_xname);
	sdl-&gt;sdl_alen = ETHER_ADDR_LEN;
	sdl-&gt;sdl_len = offsetof(<span class="enscript-type">struct</span> sockaddr_dl, sdl_data);
	memcpy(sdl-&gt;sdl_data, sc-&gt;sc_if_xname, sdl-&gt;sdl_nlen);
	memcpy(LLADDR(sdl), sc-&gt;sc_defaddr, ETHER_ADDR_LEN);

	sc-&gt;sc_flags &amp;= ~SCF_MEDIA_ACTIVE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_LIFECYCLE)
		link_print(sdl);
#<span class="enscript-reference">endif</span>

	error = ifnet_attach(ifp, NULL);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: ifnet_attach failed %d\n&quot;</span>, __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = ifnet_set_lladdr_and_type(ifp, sc-&gt;sc_defaddr, ETHER_ADDR_LEN,
	    IFT_ETHER);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: ifnet_set_lladdr_and_type failed %d\n&quot;</span>, __func__,
		    error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	ifnet_set_offload(ifp,
	    IFNET_CSUM_IP | IFNET_CSUM_TCP | IFNET_CSUM_UDP |
	    IFNET_CSUM_TCPIPV6 | IFNET_CSUM_UDPIPV6 | IFNET_MULTIPAGES);

	error = bridge_set_tso(sc);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: bridge_set_tso failed %d\n&quot;</span>, __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	bstp_attach(&amp;sc-&gt;sc_stp, &amp;bridge_ops);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

	lck_mtx_lock(&amp;bridge_list_mtx);
	LIST_INSERT_HEAD(&amp;bridge_list, sc, sc_list);
	lck_mtx_unlock(&amp;bridge_list_mtx);

	<span class="enscript-comment">/* attach as ethernet */</span>
	error = bpf_attach(ifp, DLT_EN10MB, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ether_header),
	    NULL, NULL);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s failed error %d\n&quot;</span>, __func__, error);
		<span class="enscript-comment">/* Cleanup TBD */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * bridge_clone_destroy:
 *
 *	Destroy a bridge instance.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_clone_destroy</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = ifp-&gt;if_softc;
	<span class="enscript-type">struct</span> bridge_iflist *bif;
	errno_t error;

	BRIDGE_LOCK(sc);
	<span class="enscript-keyword">if</span> ((sc-&gt;sc_flags &amp; SCF_DETACHING)) {
		BRIDGE_UNLOCK(sc);
		<span class="enscript-keyword">return</span> (0);
	}
	sc-&gt;sc_flags |= SCF_DETACHING;

	bridge_ifstop(ifp, 1);

	bridge_cancel_delayed_call(&amp;sc-&gt;sc_resize_call);

	bridge_cleanup_delayed_call(&amp;sc-&gt;sc_resize_call);
	bridge_cleanup_delayed_call(&amp;sc-&gt;sc_aging_timer);

	error = ifnet_set_flags(ifp, 0, IFF_UP);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: ifnet_set_flags failed %d\n&quot;</span>, __func__, error);
	}

	<span class="enscript-keyword">while</span> ((bif = TAILQ_FIRST(&amp;sc-&gt;sc_iflist)) != NULL)
		bridge_delete_member(sc, bif, 0);

	<span class="enscript-keyword">while</span> ((bif = TAILQ_FIRST(&amp;sc-&gt;sc_spanlist)) != NULL) {
		bridge_delete_span(sc, bif);
	}

	BRIDGE_UNLOCK(sc);

	error = ifnet_detach(ifp);
	<span class="enscript-keyword">if</span> (error != 0) {
		panic(<span class="enscript-string">&quot;bridge_clone_destroy: ifnet_detach(%p) failed %d\n&quot;</span>,
		    ifp, error);
		<span class="enscript-keyword">if</span> ((sc = (<span class="enscript-type">struct</span> bridge_softc *)ifnet_softc(ifp)) != NULL) {
			BRIDGE_LOCK(sc);
			sc-&gt;sc_flags &amp;= ~SCF_DETACHING;
			BRIDGE_UNLOCK(sc);
		}
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DRVSPEC</span> do { \
	<span class="enscript-keyword">if</span> (ifd-&gt;ifd_cmd &gt;= bridge_control_table_size) {		\
		error = EINVAL;						\
		<span class="enscript-keyword">break</span>;							\
	}								\
	bc = &amp;bridge_control_table[ifd-&gt;ifd_cmd];			\
									\
	<span class="enscript-keyword">if</span> (cmd == SIOCGDRVSPEC &amp;&amp;					\
	    (bc-&gt;bc_flags &amp; BC_F_COPYOUT) == 0) {			\
		error = EINVAL;						\
		<span class="enscript-keyword">break</span>;							\
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd == SIOCSDRVSPEC &amp;&amp;				\
	    (bc-&gt;bc_flags &amp; BC_F_COPYOUT) != 0) {			\
		error = EINVAL;						\
		<span class="enscript-keyword">break</span>;							\
	}								\
									\
	<span class="enscript-keyword">if</span> (bc-&gt;bc_flags &amp; BC_F_SUSER) {				\
		error = kauth_authorize_generic(kauth_cred_get(),	\
		    KAUTH_GENERIC_ISSUSER);				\
		<span class="enscript-keyword">if</span> (error)						\
			<span class="enscript-keyword">break</span>;						\
	}								\
									\
	<span class="enscript-keyword">if</span> (ifd-&gt;ifd_len != bc-&gt;bc_argsize ||				\
	    ifd-&gt;ifd_len &gt; <span class="enscript-keyword">sizeof</span> (args)) {				\
		error = EINVAL;						\
		<span class="enscript-keyword">break</span>;							\
	}								\
									\
	bzero(&amp;args, <span class="enscript-keyword">sizeof</span> (args));					\
	<span class="enscript-keyword">if</span> (bc-&gt;bc_flags &amp; BC_F_COPYIN) {				\
		error = copyin(ifd-&gt;ifd_data, &amp;args, ifd-&gt;ifd_len);	\
		<span class="enscript-keyword">if</span> (error)						\
			<span class="enscript-keyword">break</span>;						\
	}								\
									\
	BRIDGE_LOCK(sc);						\
	error = (*bc-&gt;bc_func)(sc, &amp;args);				\
	BRIDGE_UNLOCK(sc);						\
	<span class="enscript-keyword">if</span> (error)							\
		<span class="enscript-keyword">break</span>;							\
									\
	<span class="enscript-keyword">if</span> (bc-&gt;bc_flags &amp; BC_F_COPYOUT)				\
		error = copyout(&amp;args, ifd-&gt;ifd_data, ifd-&gt;ifd_len);	\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * bridge_ioctl:
 *
 *	Handle a control request from the operator.
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">bridge_ioctl</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, <span class="enscript-type">void</span> *data)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = ifp-&gt;if_softc;
	<span class="enscript-type">struct</span> ifreq *ifr = (<span class="enscript-type">struct</span> ifreq *)data;
	<span class="enscript-type">struct</span> bridge_iflist *bif;
	<span class="enscript-type">int</span> error = 0;

	BRIDGE_LOCK_ASSERT_NOTHELD(sc);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_IOCTL)
		printf(<span class="enscript-string">&quot;%s: ifp %s cmd 0x%08lx (%c%c [%lu] %c %lu)\n&quot;</span>,
		    __func__, ifp-&gt;if_xname, cmd, (cmd &amp; IOC_IN) ? <span class="enscript-string">'I'</span> : <span class="enscript-string">' '</span>,
		    (cmd &amp; IOC_OUT) ? <span class="enscript-string">'O'</span> : <span class="enscript-string">' '</span>, IOCPARM_LEN(cmd),
		    (<span class="enscript-type">char</span>)IOCGROUP(cmd), cmd &amp; 0xff);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

	<span class="enscript-keyword">switch</span> (cmd) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFADDR</span>:
		ifnet_set_flags(ifp, IFF_UP, IFF_UP);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMEDIA32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMEDIA64</span>: {
		<span class="enscript-type">struct</span> ifmediareq *ifmr = (<span class="enscript-type">struct</span> ifmediareq *)data;
		user_addr_t user_addr;

		user_addr = (cmd == SIOCGIFMEDIA64) ?
		    ((<span class="enscript-type">struct</span> ifmediareq64 *)ifmr)-&gt;ifmu_ulist :
		    CAST_USER_ADDR_T(((<span class="enscript-type">struct</span> ifmediareq32 *)ifmr)-&gt;ifmu_ulist);

		ifmr-&gt;ifm_status = IFM_AVALID;
		ifmr-&gt;ifm_mask = 0;
		ifmr-&gt;ifm_count = 1;

		BRIDGE_LOCK(sc);
		<span class="enscript-keyword">if</span> (!(sc-&gt;sc_flags &amp; SCF_DETACHING) &amp;&amp;
		    (sc-&gt;sc_flags &amp; SCF_MEDIA_ACTIVE)) {
			ifmr-&gt;ifm_status |= IFM_ACTIVE;
			ifmr-&gt;ifm_active = ifmr-&gt;ifm_current =
			    IFM_ETHER | IFM_AUTO;
		} <span class="enscript-keyword">else</span> {
			ifmr-&gt;ifm_active = ifmr-&gt;ifm_current = IFM_NONE;
		}
		BRIDGE_UNLOCK(sc);

		<span class="enscript-keyword">if</span> (user_addr != USER_ADDR_NULL) {
			error = copyout(&amp;ifmr-&gt;ifm_current, user_addr,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>));
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCADDMULTI</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDELMULTI</span>:
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSDRVSPEC32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDRVSPEC32</span>: {
		<span class="enscript-type">union</span> {
			<span class="enscript-type">struct</span> ifbreq ifbreq;
			<span class="enscript-type">struct</span> ifbifconf32 ifbifconf;
			<span class="enscript-type">struct</span> ifbareq32 ifbareq;
			<span class="enscript-type">struct</span> ifbaconf32 ifbaconf;
			<span class="enscript-type">struct</span> ifbrparam ifbrparam;
			<span class="enscript-type">struct</span> ifbropreq32 ifbropreq;
		} args;
		<span class="enscript-type">struct</span> ifdrv32 *ifd = (<span class="enscript-type">struct</span> ifdrv32 *)data;
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> bridge_control *bridge_control_table =
		    bridge_control_table32, *bc;

		DRVSPEC;

		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSDRVSPEC64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDRVSPEC64</span>: {
		<span class="enscript-type">union</span> {
			<span class="enscript-type">struct</span> ifbreq ifbreq;
			<span class="enscript-type">struct</span> ifbifconf64 ifbifconf;
			<span class="enscript-type">struct</span> ifbareq64 ifbareq;
			<span class="enscript-type">struct</span> ifbaconf64 ifbaconf;
			<span class="enscript-type">struct</span> ifbrparam ifbrparam;
			<span class="enscript-type">struct</span> ifbropreq64 ifbropreq;
		} args;
		<span class="enscript-type">struct</span> ifdrv64 *ifd = (<span class="enscript-type">struct</span> ifdrv64 *)data;
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> bridge_control *bridge_control_table =
		    bridge_control_table64, *bc;

		DRVSPEC;

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFFLAGS</span>:
		<span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; IFF_UP) &amp;&amp;
		    (ifp-&gt;if_flags &amp; IFF_RUNNING)) {
			<span class="enscript-comment">/*
			 * If interface is marked down and it is running,
			 * then stop and disable it.
			 */</span>
			BRIDGE_LOCK(sc);
			bridge_ifstop(ifp, 1);
			BRIDGE_UNLOCK(sc);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_UP) &amp;&amp;
		    !(ifp-&gt;if_flags &amp; IFF_RUNNING)) {
			<span class="enscript-comment">/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */</span>
			BRIDGE_LOCK(sc);
			error = bridge_init(ifp);
			BRIDGE_UNLOCK(sc);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFLLADDR</span>:
		error = ifnet_set_lladdr(ifp, ifr-&gt;ifr_addr.sa_data,
		    ifr-&gt;ifr_addr.sa_len);
		<span class="enscript-keyword">if</span> (error != 0)
			printf(<span class="enscript-string">&quot;%s: SIOCSIFLLADDR error %d\n&quot;</span>, ifp-&gt;if_xname,
			    error);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMTU</span>:
		<span class="enscript-keyword">if</span> (ifr-&gt;ifr_mtu &lt; 576) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		BRIDGE_LOCK(sc);
		<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;sc-&gt;sc_iflist)) {
			sc-&gt;sc_ifp-&gt;if_mtu = ifr-&gt;ifr_mtu;
			BRIDGE_UNLOCK(sc);
			<span class="enscript-keyword">break</span>;
		}
		TAILQ_FOREACH(bif, &amp;sc-&gt;sc_iflist, bif_next) {
			<span class="enscript-keyword">if</span> (bif-&gt;bif_ifp-&gt;if_mtu != (<span class="enscript-type">unsigned</span>)ifr-&gt;ifr_mtu) {
				printf(<span class="enscript-string">&quot;%s: invalid MTU: %u(%s) != %d\n&quot;</span>,
				    sc-&gt;sc_ifp-&gt;if_xname,
				    bif-&gt;bif_ifp-&gt;if_mtu,
				    bif-&gt;bif_ifp-&gt;if_xname, ifr-&gt;ifr_mtu);
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (!error)
			sc-&gt;sc_ifp-&gt;if_mtu = ifr-&gt;ifr_mtu;
		BRIDGE_UNLOCK(sc);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = ether_ioctl(ifp, cmd, data);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
		<span class="enscript-keyword">if</span> (error != 0 &amp;&amp; error != EOPNOTSUPP)
			printf(<span class="enscript-string">&quot;%s: ifp %s cmd 0x%08lx &quot;</span>
			    <span class="enscript-string">&quot;(%c%c [%lu] %c %lu) failed error: %d\n&quot;</span>,
			    __func__, ifp-&gt;if_xname, cmd,
			    (cmd &amp; IOC_IN) ? <span class="enscript-string">'I'</span> : <span class="enscript-string">' '</span>,
			    (cmd &amp; IOC_OUT) ? <span class="enscript-string">'O'</span> : <span class="enscript-string">' '</span>,
			    IOCPARM_LEN(cmd), (<span class="enscript-type">char</span>)IOCGROUP(cmd),
			    cmd &amp; 0xff, error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>
		<span class="enscript-keyword">break</span>;
	}
	BRIDGE_LOCK_ASSERT_NOTHELD(sc);

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAS_IF_CAP</span>
<span class="enscript-comment">/*
 * bridge_mutecaps:
 *
 *	Clear or restore unwanted capabilities on the member interface
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_mutecaps</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	<span class="enscript-type">struct</span> bridge_iflist *bif;
	<span class="enscript-type">int</span> enabled, mask;

	<span class="enscript-comment">/* Initial bitmask of capabilities to test */</span>
	mask = BRIDGE_IFCAPS_MASK;

	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_iflist, bif_next) {
		<span class="enscript-comment">/* Every member must support it or its disabled */</span>
		mask &amp;= bif-&gt;bif_savedcaps;
	}

	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_iflist, bif_next) {
		enabled = bif-&gt;bif_ifp-&gt;if_capenable;
		enabled &amp;= ~BRIDGE_IFCAPS_STRIP;
		<span class="enscript-comment">/* strip off mask bits and enable them again if allowed */</span>
		enabled &amp;= ~BRIDGE_IFCAPS_MASK;
		enabled |= mask;

		bridge_set_ifcap(sc, bif, enabled);
	}

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_set_ifcap</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">struct</span> bridge_iflist *bif, <span class="enscript-type">int</span> set)
{
	<span class="enscript-type">struct</span> ifnet *ifp = bif-&gt;bif_ifp;
	<span class="enscript-type">struct</span> ifreq ifr;
	<span class="enscript-type">int</span> error;

	bzero(&amp;ifr, <span class="enscript-keyword">sizeof</span> (ifr));
	ifr.ifr_reqcap = set;

	<span class="enscript-keyword">if</span> (ifp-&gt;if_capenable != set) {
		IFF_LOCKGIANT(ifp);
		error = (*ifp-&gt;if_ioctl)(ifp, SIOCSIFCAP, (caddr_t)&amp;ifr);
		IFF_UNLOCKGIANT(ifp);
		<span class="enscript-keyword">if</span> (error)
			printf(<span class="enscript-string">&quot;%s: %s error setting interface capabilities &quot;</span>
			    <span class="enscript-string">&quot;on %s\n&quot;</span>, __func__, sc-&gt;sc_ifp-&gt;if_xname,
			    ifp-&gt;if_xname);
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HAS_IF_CAP */</span>

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">bridge_set_tso</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	<span class="enscript-type">struct</span> bridge_iflist *bif;
	u_int32_t tso_v4_mtu;
	u_int32_t tso_v6_mtu;
	ifnet_offload_t offload;
	errno_t error = 0;

	<span class="enscript-comment">/* By default, support TSO */</span>
	offload = sc-&gt;sc_ifp-&gt;if_hwassist | IFNET_TSO_IPV4 | IFNET_TSO_IPV6;
	tso_v4_mtu = IP_MAXPACKET;
	tso_v6_mtu = IP_MAXPACKET;

	<span class="enscript-comment">/* Use the lowest common denominator of the members */</span>
	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_iflist, bif_next) {
		ifnet_t ifp = bif-&gt;bif_ifp;

		<span class="enscript-keyword">if</span> (ifp == NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (offload &amp; IFNET_TSO_IPV4) {
			<span class="enscript-keyword">if</span> (ifp-&gt;if_hwassist &amp; IFNET_TSO_IPV4) {
				<span class="enscript-keyword">if</span> (tso_v4_mtu &gt; ifp-&gt;if_tso_v4_mtu)
					tso_v4_mtu = ifp-&gt;if_tso_v4_mtu;
			} <span class="enscript-keyword">else</span> {
				offload &amp;= ~IFNET_TSO_IPV4;
				tso_v4_mtu = 0;
			}
		}
		<span class="enscript-keyword">if</span> (offload &amp; IFNET_TSO_IPV6) {
			<span class="enscript-keyword">if</span> (ifp-&gt;if_hwassist &amp; IFNET_TSO_IPV6) {
				<span class="enscript-keyword">if</span> (tso_v6_mtu &gt; ifp-&gt;if_tso_v6_mtu)
					tso_v6_mtu = ifp-&gt;if_tso_v6_mtu;
			} <span class="enscript-keyword">else</span> {
				offload &amp;= ~IFNET_TSO_IPV6;
				tso_v6_mtu = 0;
			}
		}
	}

	<span class="enscript-keyword">if</span> (offload != sc-&gt;sc_ifp-&gt;if_hwassist) {
		error = ifnet_set_offload(sc-&gt;sc_ifp, offload);
		<span class="enscript-keyword">if</span> (error != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
			<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_LIFECYCLE)
				printf(<span class="enscript-string">&quot;%s: ifnet_set_offload(%s, 0x%x) &quot;</span>
				    <span class="enscript-string">&quot;failed %d\n&quot;</span>, __func__,
				    sc-&gt;sc_ifp-&gt;if_xname, offload, error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/*
		 * For ifnet_set_tso_mtu() sake, the TSO MTU must be at least
		 * as large as the interface MTU
		 */</span>
		<span class="enscript-keyword">if</span> (sc-&gt;sc_ifp-&gt;if_hwassist &amp; IFNET_TSO_IPV4) {
			<span class="enscript-keyword">if</span> (tso_v4_mtu &lt; sc-&gt;sc_ifp-&gt;if_mtu)
				tso_v4_mtu = sc-&gt;sc_ifp-&gt;if_mtu;
			error = ifnet_set_tso_mtu(sc-&gt;sc_ifp, AF_INET,
			    tso_v4_mtu);
			<span class="enscript-keyword">if</span> (error != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
				<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_LIFECYCLE)
					printf(<span class="enscript-string">&quot;%s: ifnet_set_tso_mtu(%s, &quot;</span>
					    <span class="enscript-string">&quot;AF_INET, %u) failed %d\n&quot;</span>,
					    __func__, sc-&gt;sc_ifp-&gt;if_xname,
					    tso_v4_mtu, error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
		}
		<span class="enscript-keyword">if</span> (sc-&gt;sc_ifp-&gt;if_hwassist &amp; IFNET_TSO_IPV6) {
			<span class="enscript-keyword">if</span> (tso_v6_mtu &lt; sc-&gt;sc_ifp-&gt;if_mtu)
				tso_v6_mtu = sc-&gt;sc_ifp-&gt;if_mtu;
			error = ifnet_set_tso_mtu(sc-&gt;sc_ifp, AF_INET6,
			    tso_v6_mtu);
			<span class="enscript-keyword">if</span> (error != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
				<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_LIFECYCLE)
					printf(<span class="enscript-string">&quot;%s: ifnet_set_tso_mtu(%s, &quot;</span>
					    <span class="enscript-string">&quot;AF_INET6, %u) failed %d\n&quot;</span>,
					    __func__, sc-&gt;sc_ifp-&gt;if_xname,
					    tso_v6_mtu, error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
		}
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * bridge_lookup_member:
 *
 *	Lookup a bridge member interface.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> bridge_iflist *
<span class="enscript-function-name">bridge_lookup_member</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	<span class="enscript-type">struct</span> bridge_iflist *bif;
	<span class="enscript-type">struct</span> ifnet *ifp;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_iflist, bif_next) {
		ifp = bif-&gt;bif_ifp;
		<span class="enscript-keyword">if</span> (strcmp(ifp-&gt;if_xname, name) == 0)
			<span class="enscript-keyword">return</span> (bif);
	}

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * bridge_lookup_member_if:
 *
 *	Lookup a bridge member interface by ifnet*.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> bridge_iflist *
<span class="enscript-function-name">bridge_lookup_member_if</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">struct</span> ifnet *member_ifp)
{
	<span class="enscript-type">struct</span> bridge_iflist *bif;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_iflist, bif_next) {
		<span class="enscript-keyword">if</span> (bif-&gt;bif_ifp == member_ifp)
			<span class="enscript-keyword">return</span> (bif);
	}

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">bridge_iff_input</span>(<span class="enscript-type">void</span> *cookie, ifnet_t ifp, protocol_family_t protocol,
	mbuf_t *data, <span class="enscript-type">char</span> **frame_ptr)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">protocol</span>)
	errno_t error = 0;
	<span class="enscript-type">struct</span> bridge_iflist *bif = (<span class="enscript-type">struct</span> bridge_iflist *)cookie;
	<span class="enscript-type">struct</span> bridge_softc *sc = bif-&gt;bif_sc;
	<span class="enscript-type">int</span> included = 0;
	size_t frmlen = 0;
	mbuf_t m = *data;

	<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_PROTO1))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (*frame_ptr &gt;= (<span class="enscript-type">char</span> *)mbuf_datastart(m) &amp;&amp;
	    *frame_ptr &lt;= (<span class="enscript-type">char</span> *)mbuf_data(m)) {
		included = 1;
		frmlen = (<span class="enscript-type">char</span> *)mbuf_data(m) - *frame_ptr;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_INPUT) {
		printf(<span class="enscript-string">&quot;%s: %s from %s m 0x%llx data 0x%llx frame 0x%llx %s &quot;</span>
		    <span class="enscript-string">&quot;frmlen %lu\n&quot;</span>, __func__, sc-&gt;sc_ifp-&gt;if_xname,
		    ifp-&gt;if_xname, (uint64_t)VM_KERNEL_ADDRPERM(m),
		    (uint64_t)VM_KERNEL_ADDRPERM(mbuf_data(m)),
		    (uint64_t)VM_KERNEL_ADDRPERM(*frame_ptr),
		    included ? <span class="enscript-string">&quot;inside&quot;</span> : <span class="enscript-string">&quot;outside&quot;</span>, frmlen);

		<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_MBUF) {
			printf_mbuf(m, <span class="enscript-string">&quot;bridge_iff_input[&quot;</span>, <span class="enscript-string">&quot;\n&quot;</span>);
			printf_ether_header((<span class="enscript-type">struct</span> ether_header *)
			    (<span class="enscript-type">void</span> *)*frame_ptr);
			printf_mbuf_data(m, 0, 20);
			printf(<span class="enscript-string">&quot;\n&quot;</span>);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

	<span class="enscript-comment">/* Move data pointer to start of frame to the link layer header */</span>
	<span class="enscript-keyword">if</span> (included) {
		(<span class="enscript-type">void</span>) mbuf_setdata(m, (<span class="enscript-type">char</span> *)mbuf_data(m) - frmlen,
		    mbuf_len(m) + frmlen);
		(<span class="enscript-type">void</span>) mbuf_pkthdr_adjustlen(m, frmlen);
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;%s: frame_ptr outside mbuf\n&quot;</span>, __func__);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = bridge_input(ifp, m, *frame_ptr);

	<span class="enscript-comment">/* Adjust packet back to original */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		(<span class="enscript-type">void</span>) mbuf_setdata(m, (<span class="enscript-type">char</span> *)mbuf_data(m) + frmlen,
		    mbuf_len(m) - frmlen);
		(<span class="enscript-type">void</span>) mbuf_pkthdr_adjustlen(m, -frmlen);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> ((if_bridge_debug &amp; BR_DBGF_INPUT) &amp;&amp;
	    (if_bridge_debug &amp; BR_DBGF_MBUF)) {
		printf(<span class="enscript-string">&quot;\n&quot;</span>);
		printf_mbuf(m, <span class="enscript-string">&quot;bridge_iff_input]&quot;</span>, <span class="enscript-string">&quot;\n&quot;</span>);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

<span class="enscript-reference">out</span>:
	BRIDGE_LOCK_ASSERT_NOTHELD(sc);

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_MEMBER_OUT_FILTER</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">bridge_iff_output</span>(<span class="enscript-type">void</span> *cookie, ifnet_t ifp, protocol_family_t protocol,
	mbuf_t *data)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">protocol</span>)
	errno_t error = 0;
	<span class="enscript-type">struct</span> bridge_iflist *bif = (<span class="enscript-type">struct</span> bridge_iflist *)cookie;
	<span class="enscript-type">struct</span> bridge_softc *sc = bif-&gt;bif_sc;
	mbuf_t m = *data;

	<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_PROTO1))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_OUTPPUT) {
		printf(<span class="enscript-string">&quot;%s: %s from %s m 0x%llx data 0x%llx\n&quot;</span>, __func__,
		    sc-&gt;sc_ifp-&gt;if_xname, ifp-&gt;if_xname,
		    (uint64_t)VM_KERNEL_ADDRPERM(m),
		    (uint64_t)VM_KERNEL_ADDRPERM(mbuf_data(m)));
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

	error = bridge_member_output(sc, ifp, m);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: bridge_member_output failed error %d\n&quot;</span>, __func__,
		    error);
	}

<span class="enscript-reference">out</span>:
	BRIDGE_LOCK_ASSERT_NOTHELD(sc);

	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_MEMBER_OUT_FILTER */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_iff_event</span>(<span class="enscript-type">void</span> *cookie, ifnet_t ifp, protocol_family_t protocol,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> kev_msg *event_msg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">protocol</span>)
	<span class="enscript-type">struct</span> bridge_iflist *bif = (<span class="enscript-type">struct</span> bridge_iflist *)cookie;
	<span class="enscript-type">struct</span> bridge_softc *sc = bif-&gt;bif_sc;

	<span class="enscript-keyword">if</span> (event_msg-&gt;vendor_code == KEV_VENDOR_APPLE &amp;&amp;
	    event_msg-&gt;kev_class == KEV_NETWORK_CLASS &amp;&amp;
	    event_msg-&gt;kev_subclass == KEV_DL_SUBCLASS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
		<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_LIFECYCLE)
			printf(<span class="enscript-string">&quot;%s: %s event_code %u - %s\n&quot;</span>, __func__,
			    ifp-&gt;if_xname, event_msg-&gt;event_code,
			    dlil_kev_dl_code_str(event_msg-&gt;event_code));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

		<span class="enscript-keyword">switch</span> (event_msg-&gt;event_code) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_IF_DETACHING</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_IF_DETACHED</span>: {
				bridge_ifdetach(bif, ifp);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_LINK_OFF</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_LINK_ON</span>: {
				bridge_iflinkevent(ifp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
				bstp_linkstate(ifp, event_msg-&gt;event_code);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_SIFFLAGS</span>: {
				<span class="enscript-keyword">if</span> ((bif-&gt;bif_flags &amp; BIFF_PROMISC) == 0 &amp;&amp;
				    (ifp-&gt;if_flags &amp; IFF_UP)) {
					errno_t error;

					error = ifnet_set_promiscuous(ifp, 1);
					<span class="enscript-keyword">if</span> (error != 0) {
						printf(<span class="enscript-string">&quot;%s: &quot;</span>
						    <span class="enscript-string">&quot;ifnet_set_promiscuous (%s)&quot;</span>
						    <span class="enscript-string">&quot; failed %d\n&quot;</span>,
						    __func__, ifp-&gt;if_xname,
						    error);
					} <span class="enscript-keyword">else</span> {
						bif-&gt;bif_flags |= BIFF_PROMISC;
					}
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">KEV_DL_IFCAP_CHANGED</span>: {
				BRIDGE_LOCK(sc);
				bridge_set_tso(sc);
				BRIDGE_UNLOCK(sc);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
		}
	}
}

<span class="enscript-comment">/*
 * bridge_iff_detached:
 *
 *	Detach an interface from a bridge.  Called when a member
 *	interface is detaching.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_iff_detached</span>(<span class="enscript-type">void</span> *cookie, ifnet_t ifp)
{
	<span class="enscript-type">struct</span> bridge_iflist *bif = (<span class="enscript-type">struct</span> bridge_iflist *)cookie;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_LIFECYCLE)
		printf(<span class="enscript-string">&quot;%s: %s\n&quot;</span>, __func__, ifp-&gt;if_xname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

	bridge_ifdetach(bif, ifp);

	_FREE(bif, M_DEVBUF);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">bridge_proto_input</span>(ifnet_t ifp, protocol_family_t protocol, mbuf_t packet,
	<span class="enscript-type">char</span> *header)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">protocol</span>, <span class="enscript-variable-name">packet</span>, <span class="enscript-variable-name">header</span>)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	printf(<span class="enscript-string">&quot;%s: unexpected packet from %s\n&quot;</span>, __func__,
	    ifp-&gt;if_xname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_attach_protocol</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">int</span>	error;
	<span class="enscript-type">struct</span> ifnet_attach_proto_param	reg;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_LIFECYCLE)
		printf(<span class="enscript-string">&quot;%s: %s\n&quot;</span>, __func__, ifp-&gt;if_xname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

	bzero(&amp;reg, <span class="enscript-keyword">sizeof</span> (reg));
	reg.input = bridge_proto_input;

	error = ifnet_attach_protocol(ifp, PF_BRIDGE, &amp;reg);
	<span class="enscript-keyword">if</span> (error)
		printf(<span class="enscript-string">&quot;%s: ifnet_attach_protocol(%s) failed, %d\n&quot;</span>,
		    __func__, ifp-&gt;if_xname, error);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_detach_protocol</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">int</span>	error;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_LIFECYCLE)
		printf(<span class="enscript-string">&quot;%s: %s\n&quot;</span>, __func__, ifp-&gt;if_xname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>
	error = ifnet_detach_protocol(ifp, PF_BRIDGE);
	<span class="enscript-keyword">if</span> (error)
		printf(<span class="enscript-string">&quot;%s: ifnet_detach_protocol(%s) failed, %d\n&quot;</span>,
		    __func__, ifp-&gt;if_xname, error);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * bridge_delete_member:
 *
 *	Delete the specified member interface.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_delete_member</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">struct</span> bridge_iflist *bif,
	<span class="enscript-type">int</span> gone)
{
	<span class="enscript-type">struct</span> ifnet *ifs = bif-&gt;bif_ifp, *bifp = sc-&gt;sc_ifp;
	<span class="enscript-type">int</span> lladdr_changed = 0, error, filt_attached;
	uint8_t eaddr[ETHER_ADDR_LEN];
	u_int32_t event_code = 0;

	BRIDGE_LOCK_ASSERT_HELD(sc);
	VERIFY(ifs != NULL);

	<span class="enscript-comment">/*
	 * First, remove the member from the list first so it cannot be found anymore
	 * when we release the bridge lock below
	 */</span>
	BRIDGE_XLOCK(sc);
	TAILQ_REMOVE(&amp;sc-&gt;sc_iflist, bif, bif_next);
	BRIDGE_XDROP(sc);

	<span class="enscript-keyword">if</span> (!gone) {
		<span class="enscript-keyword">switch</span> (ifs-&gt;if_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ETHER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_L2VLAN</span>:
			<span class="enscript-comment">/*
			 * Take the interface out of promiscuous mode.
			 */</span>
			<span class="enscript-keyword">if</span> (bif-&gt;bif_flags &amp; BIFF_PROMISC) {
				<span class="enscript-comment">/*
				 * Unlock to prevent deadlock with bridge_iff_event() in
				 * case the driver generates an interface event
				 */</span>
				BRIDGE_UNLOCK(sc);
				(<span class="enscript-type">void</span>) ifnet_set_promiscuous(ifs, 0);
				BRIDGE_LOCK(sc);
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_GIF</span>:
			<span class="enscript-comment">/* currently not supported */</span>
			<span class="enscript-comment">/* FALLTHRU */</span>
		<span class="enscript-reference">default</span>:
			VERIFY(0);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAS_IF_CAP</span>
		<span class="enscript-comment">/* reneable any interface capabilities */</span>
		bridge_set_ifcap(sc, bif, bif-&gt;bif_savedcaps);
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-keyword">if</span> (bif-&gt;bif_flags &amp; BIFF_PROTO_ATTACHED) {
		<span class="enscript-comment">/* Respect lock ordering with DLIL lock */</span>
		BRIDGE_UNLOCK(sc);
		(<span class="enscript-type">void</span>) bridge_detach_protocol(ifs);
		BRIDGE_LOCK(sc);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	<span class="enscript-keyword">if</span> (bif-&gt;bif_ifflags &amp; IFBIF_STP)
		bstp_disable(&amp;bif-&gt;bif_stp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

	<span class="enscript-comment">/*
	 * If removing the interface that gave the bridge its mac address, set
	 * the mac address of the bridge to the address of the next member, or
	 * to its default address if no members are left.
	 */</span>
	<span class="enscript-keyword">if</span> (bridge_inherit_mac &amp;&amp; sc-&gt;sc_ifaddr == ifs) {
		ifnet_release(sc-&gt;sc_ifaddr);
		<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;sc-&gt;sc_iflist)) {
			bcopy(sc-&gt;sc_defaddr, eaddr, ETHER_ADDR_LEN);
			sc-&gt;sc_ifaddr = NULL;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> ifnet *fif =
			    TAILQ_FIRST(&amp;sc-&gt;sc_iflist)-&gt;bif_ifp;
			bcopy(IF_LLADDR(fif), eaddr, ETHER_ADDR_LEN);
			sc-&gt;sc_ifaddr = fif;
			ifnet_reference(fif);	<span class="enscript-comment">/* for sc_ifaddr */</span>
		}
		lladdr_changed = 1;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAS_IF_CAP</span>
	bridge_mutecaps(sc);	<span class="enscript-comment">/* recalculate now this interface is removed */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HAS_IF_CAP */</span>

	error = bridge_set_tso(sc);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: bridge_set_tso failed %d\n&quot;</span>, __func__, error);
	}

	bridge_rtdelete(sc, ifs, IFBF_FLUSHALL);
	KASSERT(bif-&gt;bif_addrcnt == 0,
	    (<span class="enscript-string">&quot;%s: %d bridge routes referenced&quot;</span>, __func__, bif-&gt;bif_addrcnt));

	filt_attached = bif-&gt;bif_flags &amp; BIFF_FILTER_ATTACHED;

	<span class="enscript-comment">/*
	 * Update link status of the bridge based on its remaining members
	 */</span>
	event_code = bridge_updatelinkstatus(sc);

	BRIDGE_UNLOCK(sc);

	<span class="enscript-keyword">if</span> (lladdr_changed &amp;&amp;
	    (error = ifnet_set_lladdr(bifp, eaddr, ETHER_ADDR_LEN)) != 0)
		printf(<span class="enscript-string">&quot;%s: ifnet_set_lladdr failed %d\n&quot;</span>, __func__, error);

	<span class="enscript-keyword">if</span> (event_code != 0)
		bridge_link_event(bifp, event_code);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	bstp_destroy(&amp;bif-&gt;bif_stp);	<span class="enscript-comment">/* prepare to free */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

	<span class="enscript-keyword">if</span> (filt_attached)
		iflt_detach(bif-&gt;bif_iff_ref);
	<span class="enscript-keyword">else</span>
		_FREE(bif, M_DEVBUF);

	ifs-&gt;if_bridge = NULL;
	ifnet_release(ifs);

	BRIDGE_LOCK(sc);
}

<span class="enscript-comment">/*
 * bridge_delete_span:
 *
 *	Delete the specified span interface.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_delete_span</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">struct</span> bridge_iflist *bif)
{
	BRIDGE_LOCK_ASSERT_HELD(sc);

	KASSERT(bif-&gt;bif_ifp-&gt;if_bridge == NULL,
	    (<span class="enscript-string">&quot;%s: not a span interface&quot;</span>, __func__));

	ifnet_release(bif-&gt;bif_ifp);

	TAILQ_REMOVE(&amp;sc-&gt;sc_spanlist, bif, bif_next);
	_FREE(bif, M_DEVBUF);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_add</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbreq *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif = NULL;
	<span class="enscript-type">struct</span> ifnet *ifs, *bifp = sc-&gt;sc_ifp;
	<span class="enscript-type">int</span> error = 0, lladdr_changed = 0;
	uint8_t eaddr[ETHER_ADDR_LEN];
	<span class="enscript-type">struct</span> iff_filter iff;
	u_int32_t event_code = 0;

	ifs = ifunit(req-&gt;ifbr_ifsname);
	<span class="enscript-keyword">if</span> (ifs == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);
	<span class="enscript-keyword">if</span> (ifs-&gt;if_ioctl == NULL)	<span class="enscript-comment">/* must be supported */</span>
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* If it's in the span list, it can't be a member. */</span>
	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_spanlist, bif_next)
		<span class="enscript-keyword">if</span> (ifs == bif-&gt;bif_ifp)
			<span class="enscript-keyword">return</span> (EBUSY);

	<span class="enscript-keyword">if</span> (ifs-&gt;if_bridge == sc)
		<span class="enscript-keyword">return</span> (EEXIST);

	<span class="enscript-keyword">if</span> (ifs-&gt;if_bridge != NULL)
		<span class="enscript-keyword">return</span> (EBUSY);

	<span class="enscript-keyword">switch</span> (ifs-&gt;if_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ETHER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_L2VLAN</span>:
		<span class="enscript-comment">/* permitted interface types */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_GIF</span>:
		<span class="enscript-comment">/* currently not supported */</span>
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	bif = _MALLOC(<span class="enscript-keyword">sizeof</span> (*bif), M_DEVBUF, M_NOWAIT | M_ZERO);
	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	bif-&gt;bif_ifp = ifs;
	ifnet_reference(ifs);
	bif-&gt;bif_ifflags = IFBIF_LEARNING | IFBIF_DISCOVER;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAS_IF_CAP</span>
	bif-&gt;bif_savedcaps = ifs-&gt;if_capenable;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HAS_IF_CAP */</span>
	bif-&gt;bif_sc = sc;

	<span class="enscript-comment">/* Allow the first Ethernet member to define the MTU */</span>
	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;sc-&gt;sc_iflist))
		sc-&gt;sc_ifp-&gt;if_mtu = ifs-&gt;if_mtu;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sc-&gt;sc_ifp-&gt;if_mtu != ifs-&gt;if_mtu) {
		printf(<span class="enscript-string">&quot;%s: %s: invalid MTU for %s&quot;</span>, __func__,
		    sc-&gt;sc_ifp-&gt;if_xname,
		    ifs-&gt;if_xname);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/*
	 * Assign the interface's MAC address to the bridge if it's the first
	 * member and the MAC address of the bridge has not been changed from
	 * the default (randomly) generated one.
	 */</span>
	<span class="enscript-keyword">if</span> (bridge_inherit_mac &amp;&amp; TAILQ_EMPTY(&amp;sc-&gt;sc_iflist) &amp;&amp;
	    !memcmp(IF_LLADDR(sc-&gt;sc_ifp), sc-&gt;sc_defaddr, ETHER_ADDR_LEN)) {
		bcopy(IF_LLADDR(ifs), eaddr, ETHER_ADDR_LEN);
		sc-&gt;sc_ifaddr = ifs;
		ifnet_reference(ifs);	<span class="enscript-comment">/* for sc_ifaddr */</span>
		lladdr_changed = 1;
	}

	ifs-&gt;if_bridge = sc;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	bstp_create(&amp;sc-&gt;sc_stp, &amp;bif-&gt;bif_stp, bif-&gt;bif_ifp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

	<span class="enscript-comment">/*
	 * XXX: XLOCK HERE!?!
	 */</span>
	TAILQ_INSERT_TAIL(&amp;sc-&gt;sc_iflist, bif, bif_next);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAS_IF_CAP</span>
	<span class="enscript-comment">/* Set interface capabilities to the intersection set of all members */</span>
	bridge_mutecaps(sc);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HAS_IF_CAP */</span>

	bridge_set_tso(sc);


	<span class="enscript-comment">/*
	 * Place the interface into promiscuous mode.
	 */</span>
	<span class="enscript-keyword">switch</span> (ifs-&gt;if_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ETHER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_L2VLAN</span>:
		error = ifnet_set_promiscuous(ifs, 1);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* Ignore error when device is not up */</span>
			<span class="enscript-keyword">if</span> (error != ENETDOWN)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			error = 0;
		} <span class="enscript-keyword">else</span> {
			bif-&gt;bif_flags |= BIFF_PROMISC;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * The new member may change the link status of the bridge interface
	 */</span>
	<span class="enscript-keyword">if</span> (interface_media_active(ifs))
		bif-&gt;bif_flags |= BIFF_MEDIA_ACTIVE;
	<span class="enscript-keyword">else</span>
		bif-&gt;bif_flags &amp;= ~BIFF_MEDIA_ACTIVE;

	event_code = bridge_updatelinkstatus(sc);

	<span class="enscript-comment">/*
	 * Respect lock ordering with DLIL lock for the following operations
	 */</span>
	BRIDGE_UNLOCK(sc);

	<span class="enscript-comment">/*
	 * install an interface filter
	 */</span>
	memset(&amp;iff, 0, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> iff_filter));
	iff.iff_cookie = bif;
	iff.iff_name = <span class="enscript-string">&quot;com.apple.kernel.bsd.net.if_bridge&quot;</span>;
	iff.iff_input = bridge_iff_input;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_MEMBER_OUT_FILTER</span>
	iff.iff_output = bridge_iff_output;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_MEMBER_OUT_FILTER */</span>
	iff.iff_event = bridge_iff_event;
	iff.iff_detached = bridge_iff_detached;
	error = dlil_attach_filter(ifs, &amp;iff, &amp;bif-&gt;bif_iff_ref, DLIL_IFF_TSO);
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: iflt_attach failed %d\n&quot;</span>, __func__, error);
		BRIDGE_LOCK(sc);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	bif-&gt;bif_flags |= BIFF_FILTER_ATTACHED;

	<span class="enscript-comment">/*
	 * install an dummy &quot;bridge&quot; protocol
	 */</span>
	<span class="enscript-keyword">if</span> ((error = bridge_attach_protocol(ifs)) != 0) {
		<span class="enscript-keyword">if</span> (error != 0) {
			printf(<span class="enscript-string">&quot;%s: bridge_attach_protocol failed %d\n&quot;</span>,
			    __func__, error);
			BRIDGE_LOCK(sc);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	bif-&gt;bif_flags |= BIFF_PROTO_ATTACHED;

	<span class="enscript-keyword">if</span> (lladdr_changed &amp;&amp;
	    (error = ifnet_set_lladdr(bifp, eaddr, ETHER_ADDR_LEN)) != 0)
		printf(<span class="enscript-string">&quot;%s: ifnet_set_lladdr failed %d\n&quot;</span>, __func__, error);

	<span class="enscript-keyword">if</span> (event_code != 0)
		bridge_link_event(bifp, event_code);

	BRIDGE_LOCK(sc);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error &amp;&amp; bif != NULL)
		bridge_delete_member(sc, bif, 1);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_del</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbreq *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif;

	bif = bridge_lookup_member(sc, req-&gt;ifbr_ifsname);
	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	bridge_delete_member(sc, bif, 0);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_purge</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">sc</span>, <span class="enscript-variable-name">arg</span>)
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gifflags</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbreq *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif;
	<span class="enscript-type">struct</span> bstp_port *bp;

	bif = bridge_lookup_member(sc, req-&gt;ifbr_ifsname);
	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	bp = &amp;bif-&gt;bif_stp;
	req-&gt;ifbr_ifsflags = bif-&gt;bif_ifflags;
	req-&gt;ifbr_state = bp-&gt;bp_state;
	req-&gt;ifbr_priority = bp-&gt;bp_priority;
	req-&gt;ifbr_path_cost = bp-&gt;bp_path_cost;
	req-&gt;ifbr_portno = bif-&gt;bif_ifp-&gt;if_index &amp; 0xfff;
	req-&gt;ifbr_proto = bp-&gt;bp_protover;
	req-&gt;ifbr_role = bp-&gt;bp_role;
	req-&gt;ifbr_stpflags = bp-&gt;bp_flags;
	req-&gt;ifbr_addrcnt = bif-&gt;bif_addrcnt;
	req-&gt;ifbr_addrmax = bif-&gt;bif_addrmax;
	req-&gt;ifbr_addrexceeded = bif-&gt;bif_addrexceeded;

	<span class="enscript-comment">/* Copy STP state options as flags */</span>
	<span class="enscript-keyword">if</span> (bp-&gt;bp_operedge)
		req-&gt;ifbr_ifsflags |= IFBIF_BSTP_EDGE;
	<span class="enscript-keyword">if</span> (bp-&gt;bp_flags &amp; BSTP_PORT_AUTOEDGE)
		req-&gt;ifbr_ifsflags |= IFBIF_BSTP_AUTOEDGE;
	<span class="enscript-keyword">if</span> (bp-&gt;bp_ptp_link)
		req-&gt;ifbr_ifsflags |= IFBIF_BSTP_PTP;
	<span class="enscript-keyword">if</span> (bp-&gt;bp_flags &amp; BSTP_PORT_AUTOPTP)
		req-&gt;ifbr_ifsflags |= IFBIF_BSTP_AUTOPTP;
	<span class="enscript-keyword">if</span> (bp-&gt;bp_flags &amp; BSTP_PORT_ADMEDGE)
		req-&gt;ifbr_ifsflags |= IFBIF_BSTP_ADMEDGE;
	<span class="enscript-keyword">if</span> (bp-&gt;bp_flags &amp; BSTP_PORT_ADMCOST)
		req-&gt;ifbr_ifsflags |= IFBIF_BSTP_ADMCOST;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_sifflags</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbreq *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	<span class="enscript-type">struct</span> bstp_port *bp;
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

	bif = bridge_lookup_member(sc, req-&gt;ifbr_ifsname);
	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	<span class="enscript-keyword">if</span> (req-&gt;ifbr_ifsflags &amp; IFBIF_SPAN)
		<span class="enscript-comment">/* SPAN is readonly */</span>
		<span class="enscript-keyword">return</span> (EINVAL);


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	<span class="enscript-keyword">if</span> (req-&gt;ifbr_ifsflags &amp; IFBIF_STP) {
		<span class="enscript-keyword">if</span> ((bif-&gt;bif_ifflags &amp; IFBIF_STP) == 0) {
			error = bstp_enable(&amp;bif-&gt;bif_stp);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((bif-&gt;bif_ifflags &amp; IFBIF_STP) != 0)
			bstp_disable(&amp;bif-&gt;bif_stp);
	}

	<span class="enscript-comment">/* Pass on STP flags */</span>
	bp = &amp;bif-&gt;bif_stp;
	bstp_set_edge(bp, req-&gt;ifbr_ifsflags &amp; IFBIF_BSTP_EDGE ? 1 : 0);
	bstp_set_autoedge(bp, req-&gt;ifbr_ifsflags &amp; IFBIF_BSTP_AUTOEDGE ? 1 : 0);
	bstp_set_ptp(bp, req-&gt;ifbr_ifsflags &amp; IFBIF_BSTP_PTP ? 1 : 0);
	bstp_set_autoptp(bp, req-&gt;ifbr_ifsflags &amp; IFBIF_BSTP_AUTOPTP ? 1 : 0);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
	<span class="enscript-keyword">if</span> (req-&gt;ifbr_ifsflags &amp; IFBIF_STP)
		<span class="enscript-keyword">return</span> (EOPNOTSUPP);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !BRIDGESTP */</span>

	<span class="enscript-comment">/* Save the bits relating to the bridge */</span>
	bif-&gt;bif_ifflags = req-&gt;ifbr_ifsflags &amp; IFBIFMASK;


	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_scache</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	sc-&gt;sc_brtmax = param-&gt;ifbrp_csize;
	bridge_rttrim(sc);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gcache</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	param-&gt;ifbrp_csize = sc-&gt;sc_brtmax;

	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BRIDGE_IOCTL_GIFS</span> do { \
	<span class="enscript-type">struct</span> bridge_iflist *bif;					\
	<span class="enscript-type">struct</span> ifbreq breq;						\
	<span class="enscript-type">char</span> *buf, *outbuf;						\
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count, buflen, len;				\
									\
	count = 0;							\
	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_iflist, bif_next)			\
		count++;						\
	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_spanlist, bif_next)			\
		count++;						\
									\
	buflen = <span class="enscript-keyword">sizeof</span> (breq) * count;					\
	<span class="enscript-keyword">if</span> (bifc-&gt;ifbic_len == 0) {					\
		bifc-&gt;ifbic_len = buflen;				\
		<span class="enscript-keyword">return</span> (0);						\
	}								\
	BRIDGE_UNLOCK(sc);						\
	outbuf = _MALLOC(buflen, M_TEMP, M_WAITOK | M_ZERO);		\
	BRIDGE_LOCK(sc);						\
									\
	count = 0;							\
	buf = outbuf;							\
	len = min(bifc-&gt;ifbic_len, buflen);				\
	bzero(&amp;breq, <span class="enscript-keyword">sizeof</span> (breq));					\
	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_iflist, bif_next) {			\
		<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span> (breq))				\
			<span class="enscript-keyword">break</span>;						\
									\
		snprintf(breq.ifbr_ifsname, <span class="enscript-keyword">sizeof</span> (breq.ifbr_ifsname),	\
		    <span class="enscript-string">&quot;%s&quot;</span>, bif-&gt;bif_ifp-&gt;if_xname);			\
		<span class="enscript-comment">/* Fill in the ifbreq structure */</span>			\
		error = bridge_ioctl_gifflags(sc, &amp;breq);		\
		<span class="enscript-keyword">if</span> (error)						\
			<span class="enscript-keyword">break</span>;						\
		memcpy(buf, &amp;breq, <span class="enscript-keyword">sizeof</span> (breq));			\
		count++;						\
		buf += <span class="enscript-keyword">sizeof</span> (breq);					\
		len -= <span class="enscript-keyword">sizeof</span> (breq);					\
	}								\
	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_spanlist, bif_next) {		\
		<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span> (breq))				\
			<span class="enscript-keyword">break</span>;						\
									\
		snprintf(breq.ifbr_ifsname, <span class="enscript-keyword">sizeof</span> (breq.ifbr_ifsname),	\
		    <span class="enscript-string">&quot;%s&quot;</span>, bif-&gt;bif_ifp-&gt;if_xname);			\
		breq.ifbr_ifsflags = bif-&gt;bif_ifflags;			\
		breq.ifbr_portno = bif-&gt;bif_ifp-&gt;if_index &amp; 0xfff;	\
		memcpy(buf, &amp;breq, <span class="enscript-keyword">sizeof</span> (breq));			\
		count++;						\
		buf += <span class="enscript-keyword">sizeof</span> (breq);					\
		len -= <span class="enscript-keyword">sizeof</span> (breq);					\
	}								\
									\
	BRIDGE_UNLOCK(sc);						\
	bifc-&gt;ifbic_len = <span class="enscript-keyword">sizeof</span> (breq) * count;			\
	error = copyout(outbuf, bifc-&gt;ifbic_req, bifc-&gt;ifbic_len);	\
	BRIDGE_LOCK(sc);						\
	_FREE(outbuf, M_TEMP);						\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gifs64</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbifconf64 *bifc = arg;
	<span class="enscript-type">int</span> error = 0;

	BRIDGE_IOCTL_GIFS;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gifs32</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbifconf32 *bifc = arg;
	<span class="enscript-type">int</span> error = 0;

	BRIDGE_IOCTL_GIFS;

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BRIDGE_IOCTL_RTS</span> do {						    \
	<span class="enscript-type">struct</span> bridge_rtnode *brt;					    \
	<span class="enscript-type">char</span> *buf, *outbuf;						    \
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count, buflen, len;				    \
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> now;						    \
									    \
	<span class="enscript-keyword">if</span> (bac-&gt;ifbac_len == 0)					    \
		<span class="enscript-keyword">return</span> (0);						    \
									    \
	count = 0;							    \
	LIST_FOREACH(brt, &amp;sc-&gt;sc_rtlist, brt_list)			    \
		count++;						    \
	buflen = <span class="enscript-keyword">sizeof</span> (bareq) * count;				    \
									    \
	BRIDGE_UNLOCK(sc);						    \
	outbuf = _MALLOC(buflen, M_TEMP, M_WAITOK | M_ZERO);		    \
	BRIDGE_LOCK(sc);						    \
									    \
	count = 0;							    \
	buf = outbuf;							    \
	len = min(bac-&gt;ifbac_len, buflen);				    \
	bzero(&amp;bareq, <span class="enscript-keyword">sizeof</span> (bareq));					    \
	LIST_FOREACH(brt, &amp;sc-&gt;sc_rtlist, brt_list) {			    \
		<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span> (bareq))				    \
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;					    \
		snprintf(bareq.ifba_ifsname, <span class="enscript-keyword">sizeof</span> (bareq.ifba_ifsname),   \
		    <span class="enscript-string">&quot;%s&quot;</span>, brt-&gt;brt_ifp-&gt;if_xname);			    \
		memcpy(bareq.ifba_dst, brt-&gt;brt_addr, <span class="enscript-keyword">sizeof</span> (brt-&gt;brt_addr)); \
		bareq.ifba_vlan = brt-&gt;brt_vlan;			    \
		<span class="enscript-keyword">if</span> ((brt-&gt;brt_flags &amp; IFBAF_TYPEMASK) == IFBAF_DYNAMIC) {   \
			now = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) net_uptime();		    \
			<span class="enscript-keyword">if</span> (now &lt; brt-&gt;brt_expire)			    \
				bareq.ifba_expire =			    \
				    brt-&gt;brt_expire - now;		    \
		} <span class="enscript-keyword">else</span>							    \
			bareq.ifba_expire = 0;				    \
		bareq.ifba_flags = brt-&gt;brt_flags;			    \
									    \
		memcpy(buf, &amp;bareq, <span class="enscript-keyword">sizeof</span> (bareq));			    \
		count++;						    \
		buf += <span class="enscript-keyword">sizeof</span> (bareq);					    \
		len -= <span class="enscript-keyword">sizeof</span> (bareq);					    \
	}								    \
<span class="enscript-reference">out</span>:									    \
	BRIDGE_UNLOCK(sc);						    \
	bac-&gt;ifbac_len = <span class="enscript-keyword">sizeof</span> (bareq) * count;			    \
	error = copyout(outbuf, bac-&gt;ifbac_req, bac-&gt;ifbac_len);	    \
	BRIDGE_LOCK(sc);						    \
	_FREE(outbuf, M_TEMP);						    \
	<span class="enscript-keyword">return</span> (error);							    \
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_rts64</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbaconf64 *bac = arg;
	<span class="enscript-type">struct</span> ifbareq64 bareq;
	<span class="enscript-type">int</span> error = 0;

	BRIDGE_IOCTL_RTS;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_rts32</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbaconf32 *bac = arg;
	<span class="enscript-type">struct</span> ifbareq32 bareq;
	<span class="enscript-type">int</span> error = 0;

	BRIDGE_IOCTL_RTS;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_saddr32</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbareq32 *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif;
	<span class="enscript-type">int</span> error;

	bif = bridge_lookup_member(sc, req-&gt;ifba_ifsname);
	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	error = bridge_rtupdate(sc, req-&gt;ifba_dst, req-&gt;ifba_vlan, bif, 1,
	    req-&gt;ifba_flags);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_saddr64</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbareq64 *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif;
	<span class="enscript-type">int</span> error;

	bif = bridge_lookup_member(sc, req-&gt;ifba_ifsname);
	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	error = bridge_rtupdate(sc, req-&gt;ifba_dst, req-&gt;ifba_vlan, bif, 1,
	    req-&gt;ifba_flags);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_sto</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	sc-&gt;sc_brttimeout = param-&gt;ifbrp_ctime;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gto</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	param-&gt;ifbrp_ctime = sc-&gt;sc_brttimeout;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_daddr32</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbareq32 *req = arg;

	<span class="enscript-keyword">return</span> (bridge_rtdaddr(sc, req-&gt;ifba_dst, req-&gt;ifba_vlan));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_daddr64</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbareq64 *req = arg;

	<span class="enscript-keyword">return</span> (bridge_rtdaddr(sc, req-&gt;ifba_dst, req-&gt;ifba_vlan));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_flush</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbreq *req = arg;

	bridge_rtflush(sc, req-&gt;ifbr_ifsflags);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gpri</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrparam *param = arg;
	<span class="enscript-type">struct</span> bstp_state *bs = &amp;sc-&gt;sc_stp;

	param-&gt;ifbrp_prio = bs-&gt;bs_bridge_priority;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_spri</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	<span class="enscript-keyword">return</span> (bstp_set_priority(&amp;sc-&gt;sc_stp, param-&gt;ifbrp_prio));
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">sc</span>, <span class="enscript-variable-name">arg</span>)
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_ght</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrparam *param = arg;
	<span class="enscript-type">struct</span> bstp_state *bs = &amp;sc-&gt;sc_stp;

	param-&gt;ifbrp_hellotime = bs-&gt;bs_bridge_htime &gt;&gt; 8;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_sht</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	<span class="enscript-keyword">return</span> (bstp_set_htime(&amp;sc-&gt;sc_stp, param-&gt;ifbrp_hellotime));
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">sc</span>, <span class="enscript-variable-name">arg</span>)
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gfd</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrparam *param = arg;
	<span class="enscript-type">struct</span> bstp_state *bs = &amp;sc-&gt;sc_stp;

	param-&gt;ifbrp_fwddelay = bs-&gt;bs_bridge_fdelay &gt;&gt; 8;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_sfd</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	<span class="enscript-keyword">return</span> (bstp_set_fdelay(&amp;sc-&gt;sc_stp, param-&gt;ifbrp_fwddelay));
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">sc</span>, <span class="enscript-variable-name">arg</span>)
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gma</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrparam *param = arg;
	<span class="enscript-type">struct</span> bstp_state *bs = &amp;sc-&gt;sc_stp;

	param-&gt;ifbrp_maxage = bs-&gt;bs_bridge_max_age &gt;&gt; 8;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_sma</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	<span class="enscript-keyword">return</span> (bstp_set_maxage(&amp;sc-&gt;sc_stp, param-&gt;ifbrp_maxage));
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">sc</span>, <span class="enscript-variable-name">arg</span>)
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_sifprio</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	<span class="enscript-type">struct</span> ifbreq *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif;

	bif = bridge_lookup_member(sc, req-&gt;ifbr_ifsname);
	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	<span class="enscript-keyword">return</span> (bstp_set_port_priority(&amp;bif-&gt;bif_stp, req-&gt;ifbr_priority));
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">sc</span>, <span class="enscript-variable-name">arg</span>)
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_sifcost</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	<span class="enscript-type">struct</span> ifbreq *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif;

	bif = bridge_lookup_member(sc, req-&gt;ifbr_ifsname);
	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	<span class="enscript-keyword">return</span> (bstp_set_path_cost(&amp;bif-&gt;bif_stp, req-&gt;ifbr_path_cost));
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">sc</span>, <span class="enscript-variable-name">arg</span>)
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gfilt</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	param-&gt;ifbrp_filter = sc-&gt;sc_filter_flags;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_sfilt</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	<span class="enscript-keyword">if</span> (param-&gt;ifbrp_filter &amp; ~IFBF_FILT_MASK)
		<span class="enscript-keyword">return</span> (EINVAL);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">BRIDGE_IPF</span>
	<span class="enscript-keyword">if</span> (param-&gt;ifbrp_filter &amp; IFBF_FILT_USEIPF)
		<span class="enscript-keyword">return</span> (EINVAL);
#<span class="enscript-reference">endif</span>

	sc-&gt;sc_filter_flags = param-&gt;ifbrp_filter;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_sifmaxaddr</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbreq *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif;

	bif = bridge_lookup_member(sc, req-&gt;ifbr_ifsname);
	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	bif-&gt;bif_addrmax = req-&gt;ifbr_addrmax;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_addspan</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbreq *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif = NULL;
	<span class="enscript-type">struct</span> ifnet *ifs;

	ifs = ifunit(req-&gt;ifbr_ifsname);
	<span class="enscript-keyword">if</span> (ifs == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_spanlist, bif_next)
		<span class="enscript-keyword">if</span> (ifs == bif-&gt;bif_ifp)
			<span class="enscript-keyword">return</span> (EBUSY);

	<span class="enscript-keyword">if</span> (ifs-&gt;if_bridge != NULL)
		<span class="enscript-keyword">return</span> (EBUSY);

	<span class="enscript-keyword">switch</span> (ifs-&gt;if_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ETHER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_L2VLAN</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_GIF</span>:
			<span class="enscript-comment">/* currently not supported */</span>
			<span class="enscript-comment">/* FALLTHRU */</span>
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (EINVAL);
	}

	bif = _MALLOC(<span class="enscript-keyword">sizeof</span> (*bif), M_DEVBUF, M_NOWAIT | M_ZERO);
	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	bif-&gt;bif_ifp = ifs;
	bif-&gt;bif_ifflags = IFBIF_SPAN;

	ifnet_reference(bif-&gt;bif_ifp);

	TAILQ_INSERT_HEAD(&amp;sc-&gt;sc_spanlist, bif, bif_next);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_delspan</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbreq *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif;
	<span class="enscript-type">struct</span> ifnet *ifs;

	ifs = ifunit(req-&gt;ifbr_ifsname);
	<span class="enscript-keyword">if</span> (ifs == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_spanlist, bif_next)
		<span class="enscript-keyword">if</span> (ifs == bif-&gt;bif_ifp)
			<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	bridge_delete_span(sc, bif);

	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BRIDGE_IOCTL_GBPARAM</span> do {					\
	<span class="enscript-type">struct</span> bstp_state *bs = &amp;sc-&gt;sc_stp;				\
	<span class="enscript-type">struct</span> bstp_port *root_port;					\
									\
	req-&gt;ifbop_maxage = bs-&gt;bs_bridge_max_age &gt;&gt; 8;			\
	req-&gt;ifbop_hellotime = bs-&gt;bs_bridge_htime &gt;&gt; 8;		\
	req-&gt;ifbop_fwddelay = bs-&gt;bs_bridge_fdelay &gt;&gt; 8;		\
									\
	root_port = bs-&gt;bs_root_port;					\
	<span class="enscript-keyword">if</span> (root_port == NULL)						\
		req-&gt;ifbop_root_port = 0;				\
	<span class="enscript-keyword">else</span>								\
		req-&gt;ifbop_root_port = root_port-&gt;bp_ifp-&gt;if_index;	\
									\
	req-&gt;ifbop_holdcount = bs-&gt;bs_txholdcount;			\
	req-&gt;ifbop_priority = bs-&gt;bs_bridge_priority;			\
	req-&gt;ifbop_protocol = bs-&gt;bs_protover;				\
	req-&gt;ifbop_root_path_cost = bs-&gt;bs_root_pv.pv_cost;		\
	req-&gt;ifbop_bridgeid = bs-&gt;bs_bridge_pv.pv_dbridge_id;		\
	req-&gt;ifbop_designated_root = bs-&gt;bs_root_pv.pv_root_id;		\
	req-&gt;ifbop_designated_bridge = bs-&gt;bs_root_pv.pv_dbridge_id;	\
	req-&gt;ifbop_last_tc_time.tv_sec = bs-&gt;bs_last_tc_time.tv_sec;	\
	req-&gt;ifbop_last_tc_time.tv_usec = bs-&gt;bs_last_tc_time.tv_usec;	\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gbparam32</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbropreq32 *req = arg;

	BRIDGE_IOCTL_GBPARAM;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gbparam64</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbropreq64 *req = arg;

	BRIDGE_IOCTL_GBPARAM;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_grte</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	param-&gt;ifbrp_cexceeded = sc-&gt;sc_brtexceeded;
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BRIDGE_IOCTL_GIFSSTP</span> do {					\
	<span class="enscript-type">struct</span> bridge_iflist *bif;					\
	<span class="enscript-type">struct</span> bstp_port *bp;						\
	<span class="enscript-type">struct</span> ifbpstpreq bpreq;					\
	<span class="enscript-type">char</span> *buf, *outbuf;						\
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count, buflen, len;				\
									\
	count = 0;							\
	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_iflist, bif_next) {			\
		<span class="enscript-keyword">if</span> ((bif-&gt;bif_ifflags &amp; IFBIF_STP) != 0)		\
			count++;					\
	}								\
									\
	buflen = <span class="enscript-keyword">sizeof</span> (bpreq) * count;				\
	<span class="enscript-keyword">if</span> (bifstp-&gt;ifbpstp_len == 0) {					\
		bifstp-&gt;ifbpstp_len = buflen;				\
		<span class="enscript-keyword">return</span> (0);						\
	}								\
									\
	BRIDGE_UNLOCK(sc);						\
	outbuf = _MALLOC(buflen, M_TEMP, M_WAITOK | M_ZERO);		\
	BRIDGE_LOCK(sc);						\
									\
	count = 0;							\
	buf = outbuf;							\
	len = min(bifstp-&gt;ifbpstp_len, buflen);				\
	bzero(&amp;bpreq, <span class="enscript-keyword">sizeof</span> (bpreq));					\
	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_iflist, bif_next) {			\
		<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span> (bpreq))				\
			<span class="enscript-keyword">break</span>;						\
									\
		<span class="enscript-keyword">if</span> ((bif-&gt;bif_ifflags &amp; IFBIF_STP) == 0)		\
			<span class="enscript-keyword">continue</span>;					\
									\
		bp = &amp;bif-&gt;bif_stp;					\
		bpreq.ifbp_portno = bif-&gt;bif_ifp-&gt;if_index &amp; 0xfff;	\
		bpreq.ifbp_fwd_trans = bp-&gt;bp_forward_transitions;	\
		bpreq.ifbp_design_cost = bp-&gt;bp_desg_pv.pv_cost;	\
		bpreq.ifbp_design_port = bp-&gt;bp_desg_pv.pv_port_id;	\
		bpreq.ifbp_design_bridge = bp-&gt;bp_desg_pv.pv_dbridge_id; \
		bpreq.ifbp_design_root = bp-&gt;bp_desg_pv.pv_root_id;	\
									\
		memcpy(buf, &amp;bpreq, <span class="enscript-keyword">sizeof</span> (bpreq));			\
		count++;						\
		buf += <span class="enscript-keyword">sizeof</span> (bpreq);					\
		len -= <span class="enscript-keyword">sizeof</span> (bpreq);					\
	}								\
									\
	BRIDGE_UNLOCK(sc);						\
	bifstp-&gt;ifbpstp_len = <span class="enscript-keyword">sizeof</span> (bpreq) * count;			\
	error = copyout(outbuf, bifstp-&gt;ifbpstp_req, bifstp-&gt;ifbpstp_len); \
	BRIDGE_LOCK(sc);						\
	_FREE(outbuf, M_TEMP);						\
	<span class="enscript-keyword">return</span> (error);							\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gifsstp32</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbpstpconf32 *bifstp = arg;
	<span class="enscript-type">int</span> error = 0;

	BRIDGE_IOCTL_GIFSSTP;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_gifsstp64</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbpstpconf64 *bifstp = arg;
	<span class="enscript-type">int</span> error = 0;

	BRIDGE_IOCTL_GIFSSTP;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_sproto</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	<span class="enscript-keyword">return</span> (bstp_set_protocol(&amp;sc-&gt;sc_stp, param-&gt;ifbrp_proto));
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">sc</span>, <span class="enscript-variable-name">arg</span>)
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_stxhc</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	<span class="enscript-type">struct</span> ifbrparam *param = arg;

	<span class="enscript-keyword">return</span> (bstp_set_holdcount(&amp;sc-&gt;sc_stp, param-&gt;ifbrp_txhc));
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">sc</span>, <span class="enscript-variable-name">arg</span>)
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_ghostfilter</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrhostfilter *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif;

	bif = bridge_lookup_member(sc, req-&gt;ifbrhf_ifsname);
	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	bzero(req, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ifbrhostfilter));
	<span class="enscript-keyword">if</span> (bif-&gt;bif_flags &amp; BIFF_HOST_FILTER) {
		req-&gt;ifbrhf_flags |= IFBRHF_ENABLED;
		bcopy(bif-&gt;bif_hf_hwsrc, req-&gt;ifbrhf_hwsrca,
		    ETHER_ADDR_LEN);
		req-&gt;ifbrhf_ipsrc = bif-&gt;bif_hf_ipsrc.s_addr;
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ioctl_shostfilter</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> ifbrhostfilter *req = arg;
	<span class="enscript-type">struct</span> bridge_iflist *bif;

	bif = bridge_lookup_member(sc, req-&gt;ifbrhf_ifsname);
	<span class="enscript-keyword">if</span> (bif == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	<span class="enscript-keyword">if</span> (req-&gt;ifbrhf_flags &amp; IFBRHF_ENABLED) {
		bif-&gt;bif_flags |= BIFF_HOST_FILTER;

		<span class="enscript-keyword">if</span> (req-&gt;ifbrhf_flags &amp; IFBRHF_HWSRC) {
			bcopy(req-&gt;ifbrhf_hwsrca, bif-&gt;bif_hf_hwsrc,
			    ETHER_ADDR_LEN);
			<span class="enscript-keyword">if</span> (bcmp(req-&gt;ifbrhf_hwsrca, ethernulladdr,
			    ETHER_ADDR_LEN) != 0)
				bif-&gt;bif_flags |= BIFF_HF_HWSRC;
			<span class="enscript-keyword">else</span>
				bif-&gt;bif_flags &amp;= ~BIFF_HF_HWSRC;
		}
		<span class="enscript-keyword">if</span> (req-&gt;ifbrhf_flags &amp; IFBRHF_IPSRC) {
			bif-&gt;bif_hf_ipsrc.s_addr = req-&gt;ifbrhf_ipsrc;
			<span class="enscript-keyword">if</span> (bif-&gt;bif_hf_ipsrc.s_addr != INADDR_ANY)
				bif-&gt;bif_flags |= BIFF_HF_IPSRC;
			<span class="enscript-keyword">else</span>
				bif-&gt;bif_flags &amp;= ~BIFF_HF_IPSRC;
		}
	} <span class="enscript-keyword">else</span> {
		bif-&gt;bif_flags &amp;= ~(BIFF_HOST_FILTER | BIFF_HF_HWSRC |
		    BIFF_HF_IPSRC);
		bzero(bif-&gt;bif_hf_hwsrc, ETHER_ADDR_LEN);
		bif-&gt;bif_hf_ipsrc.s_addr = INADDR_ANY;
	}

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * bridge_ifdetach:
 *
 *	Detach an interface from a bridge.  Called when a member
 *	interface is detaching.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_ifdetach</span>(<span class="enscript-type">struct</span> bridge_iflist *bif, <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = ifp-&gt;if_bridge;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_LIFECYCLE)
		printf(<span class="enscript-string">&quot;%s: %s\n&quot;</span>, __func__, ifp-&gt;if_xname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

	<span class="enscript-comment">/* Check if the interface is a bridge member */</span>
	<span class="enscript-keyword">if</span> (sc != NULL) {
		BRIDGE_LOCK(sc);
		bif = bridge_lookup_member_if(sc, ifp);
		<span class="enscript-keyword">if</span> (bif != NULL)
			bridge_delete_member(sc, bif, 1);
		BRIDGE_UNLOCK(sc);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Check if the interface is a span port */</span>
	lck_mtx_lock(&amp;bridge_list_mtx);
	LIST_FOREACH(sc, &amp;bridge_list, sc_list) {
		BRIDGE_LOCK(sc);
		TAILQ_FOREACH(bif, &amp;sc-&gt;sc_spanlist, bif_next)
			<span class="enscript-keyword">if</span> (ifp == bif-&gt;bif_ifp) {
				bridge_delete_span(sc, bif);
				<span class="enscript-keyword">break</span>;
			}
		BRIDGE_UNLOCK(sc);
	}
	lck_mtx_unlock(&amp;bridge_list_mtx);
}

<span class="enscript-comment">/*
 * interface_media_active:
 *
 *	Tells if an interface media is active.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">interface_media_active</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> ifmediareq   ifmr;
	<span class="enscript-type">int</span> status = 0;

	bzero(&amp;ifmr, <span class="enscript-keyword">sizeof</span>(ifmr));
	<span class="enscript-keyword">if</span> (ifnet_ioctl(ifp, 0, SIOCGIFMEDIA, &amp;ifmr) == 0) {
		<span class="enscript-keyword">if</span> ((ifmr.ifm_status &amp; IFM_AVALID) &amp;&amp; ifmr.ifm_count &gt; 0)
			status = ifmr.ifm_status &amp; IFM_ACTIVE ? 1 : 0;
	}

	<span class="enscript-keyword">return</span> (status);
}

<span class="enscript-comment">/*
 * bridge_updatelinkstatus:
 *
 * 	Update the media active status of the bridge based on the
 *	media active status of its member.
 *	If changed, return the corresponding onf/off link event.
 */</span>
<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">bridge_updatelinkstatus</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	<span class="enscript-type">struct</span> bridge_iflist *bif;
	<span class="enscript-type">int</span> active_member = 0;
	u_int32_t event_code = 0;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	<span class="enscript-comment">/*
	 * Find out if we have an active interface
	 */</span>
	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_iflist, bif_next) {
		<span class="enscript-keyword">if</span> (bif-&gt;bif_flags &amp; BIFF_MEDIA_ACTIVE) {
			active_member = 1;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (active_member &amp;&amp; !(sc-&gt;sc_flags &amp; SCF_MEDIA_ACTIVE)) {
		sc-&gt;sc_flags |= SCF_MEDIA_ACTIVE;
		event_code = KEV_DL_LINK_ON;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!active_member &amp;&amp; (sc-&gt;sc_flags &amp; SCF_MEDIA_ACTIVE)) {
		sc-&gt;sc_flags &amp;= ~SCF_MEDIA_ACTIVE;
		event_code = KEV_DL_LINK_OFF;
	}

	<span class="enscript-keyword">return</span> (event_code);
}

<span class="enscript-comment">/*
 * bridge_iflinkevent:
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_iflinkevent</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = ifp-&gt;if_bridge;
	<span class="enscript-type">struct</span> bridge_iflist *bif;
	u_int32_t event_code = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_LIFECYCLE)
		printf(<span class="enscript-string">&quot;%s: %s\n&quot;</span>, __func__, ifp-&gt;if_xname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

	<span class="enscript-comment">/* Check if the interface is a bridge member */</span>
	<span class="enscript-keyword">if</span> (sc == NULL)
		<span class="enscript-keyword">return</span>;

	BRIDGE_LOCK(sc);
	bif = bridge_lookup_member_if(sc, ifp);
	<span class="enscript-keyword">if</span> (bif != NULL) {
		<span class="enscript-keyword">if</span> (interface_media_active(ifp))
			bif-&gt;bif_flags |= BIFF_MEDIA_ACTIVE;
		<span class="enscript-keyword">else</span>
			bif-&gt;bif_flags &amp;= ~BIFF_MEDIA_ACTIVE;

			event_code = bridge_updatelinkstatus(sc);
	}
	BRIDGE_UNLOCK(sc);

	<span class="enscript-keyword">if</span> (event_code != 0)
		bridge_link_event(sc-&gt;sc_ifp, event_code);
}

<span class="enscript-comment">/*
 * bridge_delayed_callback:
 *
 *	Makes a delayed call
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_delayed_callback</span>(<span class="enscript-type">void</span> *param)
{
	<span class="enscript-type">struct</span> bridge_delayed_call *call = (<span class="enscript-type">struct</span> bridge_delayed_call *)param;
	<span class="enscript-type">struct</span> bridge_softc *sc = call-&gt;bdc_sc;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG_DELAYED_CALLBACK</span>
	<span class="enscript-keyword">if</span> (bridge_delayed_callback_delay &gt; 0) {
		<span class="enscript-type">struct</span> timespec ts;

		ts.tv_sec = bridge_delayed_callback_delay;
		ts.tv_nsec = 0;

		printf(<span class="enscript-string">&quot;%s: sleeping for %d seconds\n&quot;</span>,
		    __func__, bridge_delayed_callback_delay);

		msleep(&amp;bridge_delayed_callback_delay, NULL, PZERO,
		    __func__, &amp;ts);

		printf(<span class="enscript-string">&quot;%s: awoken\n&quot;</span>, __func__);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG_DELAYED_CALLBACK */</span>

	BRIDGE_LOCK(sc);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG_DELAYED_CALLBACK</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_DELAYED_CALL)
		printf(<span class="enscript-string">&quot;%s: %s call 0x%llx flags 0x%x\n&quot;</span>, __func__,
		    sc-&gt;sc_if_xname, (uint64_t)VM_KERNEL_ADDRPERM(call),
		    call-&gt;bdc_flags);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG_DELAYED_CALLBACK */</span>

	<span class="enscript-keyword">if</span> (call-&gt;bdc_flags &amp; BDCF_CANCELLING) {
		wakeup(call);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((sc-&gt;sc_flags &amp; SCF_DETACHING) == 0)
			(*call-&gt;bdc_func)(sc);
		}
	call-&gt;bdc_flags &amp;= ~BDCF_OUTSTANDING;
	BRIDGE_UNLOCK(sc);
}

<span class="enscript-comment">/*
 * bridge_schedule_delayed_call:
 *
 *	Schedule a function to be called on a separate thread
 * 	The actual call may be scheduled to run at a given time or ASAP.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_schedule_delayed_call</span>(<span class="enscript-type">struct</span> bridge_delayed_call *call)
{
	uint64_t deadline = 0;
	<span class="enscript-type">struct</span> bridge_softc *sc = call-&gt;bdc_sc;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	<span class="enscript-keyword">if</span> ((sc-&gt;sc_flags &amp; SCF_DETACHING) ||
	    (call-&gt;bdc_flags &amp; (BDCF_OUTSTANDING | BDCF_CANCELLING)))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (call-&gt;bdc_ts.tv_sec || call-&gt;bdc_ts.tv_nsec) {
		nanoseconds_to_absolutetime(
		    (uint64_t)call-&gt;bdc_ts.tv_sec * NSEC_PER_SEC +
		    call-&gt;bdc_ts.tv_nsec, &amp;deadline);
		clock_absolutetime_interval_to_deadline(deadline, &amp;deadline);
	}

	call-&gt;bdc_flags = BDCF_OUTSTANDING;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG_DELAYED_CALLBACK</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_DELAYED_CALL)
		printf(<span class="enscript-string">&quot;%s: %s call 0x%llx flags 0x%x\n&quot;</span>, __func__,
		    sc-&gt;sc_if_xname, (uint64_t)VM_KERNEL_ADDRPERM(call),
		    call-&gt;bdc_flags);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG_DELAYED_CALLBACK */</span>

	<span class="enscript-keyword">if</span> (call-&gt;bdc_ts.tv_sec || call-&gt;bdc_ts.tv_nsec)
		thread_call_func_delayed(
			(thread_call_func_t)bridge_delayed_callback,
			call, deadline);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (call-&gt;bdc_thread_call == NULL)
			call-&gt;bdc_thread_call = thread_call_allocate(
				(thread_call_func_t)bridge_delayed_callback,
				call);
		thread_call_enter(call-&gt;bdc_thread_call);
	}
}

<span class="enscript-comment">/*
 * bridge_cancel_delayed_call:
 *
 *	Cancel a queued or running delayed call.
 *	If call is running, does not return until the call is done to
 *	prevent race condition with the brigde interface getting destroyed
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_cancel_delayed_call</span>(<span class="enscript-type">struct</span> bridge_delayed_call *call)
{
	boolean_t result;
	<span class="enscript-type">struct</span> bridge_softc *sc = call-&gt;bdc_sc;

	<span class="enscript-comment">/*
	 * The call was never scheduled
	 */</span>
	<span class="enscript-keyword">if</span> (sc == NULL)
		<span class="enscript-keyword">return</span>;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	call-&gt;bdc_flags |= BDCF_CANCELLING;

	<span class="enscript-keyword">while</span> (call-&gt;bdc_flags &amp; BDCF_OUTSTANDING) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
		<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_DELAYED_CALL)
			printf(<span class="enscript-string">&quot;%s: %s call 0x%llx flags 0x%x\n&quot;</span>, __func__,
			    sc-&gt;sc_if_xname, (uint64_t)VM_KERNEL_ADDRPERM(call),
			    call-&gt;bdc_flags);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>
		result = thread_call_func_cancel(
		    (thread_call_func_t)bridge_delayed_callback, call, FALSE);

		<span class="enscript-keyword">if</span> (result) {
			<span class="enscript-comment">/*
			 * We managed to dequeue the delayed call
			 */</span>
			call-&gt;bdc_flags &amp;= ~BDCF_OUTSTANDING;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Wait for delayed call do be done running
			 */</span>
			msleep(call, &amp;sc-&gt;sc_mtx, PZERO, __func__, NULL);
		}
	}
	call-&gt;bdc_flags &amp;= ~BDCF_CANCELLING;
}

<span class="enscript-comment">/*
 * bridge_cleanup_delayed_call:
 *
 *	Dispose resource allocated for a delayed call
 *	Assume the delayed call is not queued or running .
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_cleanup_delayed_call</span>(<span class="enscript-type">struct</span> bridge_delayed_call *call)
{
	boolean_t result;
	<span class="enscript-type">struct</span> bridge_softc *sc = call-&gt;bdc_sc;

	<span class="enscript-comment">/*
	 * The call was never scheduled
	 */</span>
	<span class="enscript-keyword">if</span> (sc == NULL)
		<span class="enscript-keyword">return</span>;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	VERIFY((call-&gt;bdc_flags &amp; BDCF_OUTSTANDING) == 0);
	VERIFY((call-&gt;bdc_flags &amp; BDCF_CANCELLING) == 0);

	<span class="enscript-keyword">if</span> (call-&gt;bdc_thread_call != NULL) {
		result = thread_call_free(call-&gt;bdc_thread_call);
		<span class="enscript-keyword">if</span> (result == FALSE)
			panic(<span class="enscript-string">&quot;%s thread_call_free() failed for call %p&quot;</span>,
				__func__, call);
		call-&gt;bdc_thread_call = NULL;
	}
}

<span class="enscript-comment">/*
 * bridge_init:
 *
 *	Initialize a bridge interface.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_init</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = (<span class="enscript-type">struct</span> bridge_softc *)ifp-&gt;if_softc;
	errno_t error;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	<span class="enscript-keyword">if</span> ((ifnet_flags(ifp) &amp; IFF_RUNNING))
		<span class="enscript-keyword">return</span> (0);

	error = ifnet_set_flags(ifp, IFF_RUNNING, IFF_RUNNING);

	<span class="enscript-comment">/*
	 * Calling bridge_aging_timer() is OK as there are no entries to
	 * age so we're just going to arm the timer
	 */</span>
	bridge_aging_timer(sc);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	<span class="enscript-keyword">if</span> (error == 0)
		bstp_init(&amp;sc-&gt;sc_stp);		<span class="enscript-comment">/* Initialize Spanning Tree */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * bridge_ifstop:
 *
 *	Stop the bridge interface.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_ifstop</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> disable)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">disable</span>)
	<span class="enscript-type">struct</span> bridge_softc *sc = ifp-&gt;if_softc;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	<span class="enscript-keyword">if</span> ((ifnet_flags(ifp) &amp; IFF_RUNNING) == 0)
		<span class="enscript-keyword">return</span>;

	bridge_cancel_delayed_call(&amp;sc-&gt;sc_aging_timer);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	bstp_stop(&amp;sc-&gt;sc_stp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

	bridge_rtflush(sc, IFBF_FLUSHDYN);

	(<span class="enscript-type">void</span>) ifnet_set_flags(ifp, 0, IFF_RUNNING);
}

<span class="enscript-comment">/*
 * bridge_enqueue:
 *
 *	Enqueue a packet on a bridge member interface.
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_enqueue</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">struct</span> ifnet *dst_ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">int</span> len, error = 0;
	<span class="enscript-type">short</span> mflags;
	<span class="enscript-type">struct</span> mbuf *m0;

	VERIFY(dst_ifp != NULL);

	<span class="enscript-comment">/*
	 * We may be sending a fragment so traverse the mbuf
	 *
	 * NOTE: bridge_fragment() is called only when PFIL_HOOKS is enabled.
	 */</span>
	<span class="enscript-keyword">for</span> (; m; m = m0) {
		errno_t _error;
		<span class="enscript-type">struct</span> flowadv adv = { FADV_SUCCESS };

		m0 = m-&gt;m_nextpkt;
		m-&gt;m_nextpkt = NULL;

		len = m-&gt;m_pkthdr.len;
		mflags = m-&gt;m_flags;
		m-&gt;m_flags |= M_PROTO1; <span class="enscript-comment">/* set to avoid loops */</span>

		bridge_finalize_cksum(dst_ifp, m);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAS_IF_CAP</span>
		<span class="enscript-comment">/*
		 * If underlying interface can not do VLAN tag insertion itself
		 * then attach a packet tag that holds it.
		 */</span>
		<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_VLANTAG) &amp;&amp;
		    (dst_ifp-&gt;if_capenable &amp; IFCAP_VLAN_HWTAGGING) == 0) {
			m = ether_vlanencap(m, m-&gt;m_pkthdr.ether_vtag);
			<span class="enscript-keyword">if</span> (m == NULL) {
				printf(<span class="enscript-string">&quot;%s: %s: unable to prepend VLAN &quot;</span>
				    <span class="enscript-string">&quot;header\n&quot;</span>, __func__, dst_ifp-&gt;if_xname);
				(<span class="enscript-type">void</span>) ifnet_stat_increment_out(dst_ifp,
				    0, 0, 1);
				<span class="enscript-keyword">continue</span>;
			}
			m-&gt;m_flags &amp;= ~M_VLANTAG;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HAS_IF_CAP */</span>

		_error = dlil_output(dst_ifp, 0, m, NULL, NULL, 1, &amp;adv);

		<span class="enscript-comment">/* Preserve existing error value */</span>
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-keyword">if</span> (_error != 0)
				error = _error;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (adv.code == FADV_FLOW_CONTROLLED)
				error = EQFULL;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (adv.code == FADV_SUSPENDED)
				error = EQSUSPENDED;
		}

		<span class="enscript-keyword">if</span> (_error == 0) {
			(<span class="enscript-type">void</span>) ifnet_stat_increment_out(sc-&gt;sc_ifp, 1, len, 0);
		} <span class="enscript-keyword">else</span> {
			(<span class="enscript-type">void</span>) ifnet_stat_increment_out(sc-&gt;sc_ifp, 0, 0, 1);
		}
	}

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAS_BRIDGE_DUMMYNET</span>
<span class="enscript-comment">/*
 * bridge_dummynet:
 *
 *	Receive a queued packet from dummynet and pass it on to the output
 *	interface.
 *
 *	The mbuf has the Ethernet header already attached.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_dummynet</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> bridge_softc *sc;

	sc = ifp-&gt;if_bridge;

	<span class="enscript-comment">/*
	 * The packet didnt originate from a member interface. This should only
	 * ever happen if a member interface is removed while packets are
	 * queued for it.
	 */</span>
	<span class="enscript-keyword">if</span> (sc == NULL) {
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (PFIL_HOOKED(&amp;inet_pfil_hook) || PFIL_HOOKED_INET6) {
		<span class="enscript-keyword">if</span> (bridge_pfil(&amp;m, sc-&gt;sc_ifp, ifp, PFIL_OUT) != 0)
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span>;
	}

	(<span class="enscript-type">void</span>) bridge_enqueue(sc, ifp, m);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HAS_BRIDGE_DUMMYNET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_MEMBER_OUT_FILTER</span>
<span class="enscript-comment">/*
 * bridge_member_output:
 *
 *	Send output from a bridge member interface.  This
 *	performs the bridging function for locally originated
 *	packets.
 *
 *	The mbuf has the Ethernet header already attached.  We must
 *	enqueue or free the mbuf before returning.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_member_output</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> sockaddr *sa,
	<span class="enscript-type">struct</span> rtentry *rt)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">sa</span>, <span class="enscript-variable-name">rt</span>)
	<span class="enscript-type">struct</span> ether_header *eh;
	<span class="enscript-type">struct</span> ifnet *dst_if;
	<span class="enscript-type">struct</span> bridge_softc *sc;
	uint16_t vlan;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_OUTPPUT)
		printf(<span class="enscript-string">&quot;%s: ifp %s\n&quot;</span>, __func__, ifp-&gt;if_xname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; ETHER_HDR_LEN) {
		m = m_pullup(m, ETHER_HDR_LEN);
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span> (0);
	}

	eh = mtod(m, <span class="enscript-type">struct</span> ether_header *);
	sc = ifp-&gt;if_bridge;
	vlan = VLANTAGOF(m);

	BRIDGE_LOCK(sc);

	<span class="enscript-comment">/*
	 * APPLE MODIFICATION
	 * If the packet is an 802.1X ethertype, then only send on the
	 * original output interface.
	 */</span>
	<span class="enscript-keyword">if</span> (eh-&gt;ether_type == htons(ETHERTYPE_PAE)) {
		dst_if = ifp;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">sendunicast</span>;
	}

	<span class="enscript-comment">/*
	 * If bridge is down, but the original output interface is up,
	 * go ahead and send out that interface.  Otherwise, the packet
	 * is dropped below.
	 */</span>
	<span class="enscript-keyword">if</span> ((sc-&gt;sc_ifp-&gt;if_flags &amp; IFF_RUNNING) == 0) {
		dst_if = ifp;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">sendunicast</span>;
	}

	<span class="enscript-comment">/*
	 * If the packet is a multicast, or we don't know a better way to
	 * get there, send to all interfaces.
	 */</span>
	<span class="enscript-keyword">if</span> (ETHER_IS_MULTICAST(eh-&gt;ether_dhost))
		dst_if = NULL;
	<span class="enscript-keyword">else</span>
		dst_if = bridge_rtlookup(sc, eh-&gt;ether_dhost, vlan);
	<span class="enscript-keyword">if</span> (dst_if == NULL) {
		<span class="enscript-type">struct</span> bridge_iflist *bif;
		<span class="enscript-type">struct</span> mbuf *mc;
		<span class="enscript-type">int</span> error = 0, used = 0;

		bridge_span(sc, m);

		BRIDGE_LOCK2REF(sc, error);
		<span class="enscript-keyword">if</span> (error) {
			m_freem(m);
			<span class="enscript-keyword">return</span> (0);
		}

		TAILQ_FOREACH(bif, &amp;sc-&gt;sc_iflist, bif_next) {
			dst_if = bif-&gt;bif_ifp;

			<span class="enscript-keyword">if</span> (dst_if-&gt;if_type == IFT_GIF)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> ((dst_if-&gt;if_flags &amp; IFF_RUNNING) == 0)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-comment">/*
			 * If this is not the original output interface,
			 * and the interface is participating in spanning
			 * tree, make sure the port is in a state that
			 * allows forwarding.
			 */</span>
			<span class="enscript-keyword">if</span> (dst_if != ifp &amp;&amp; (bif-&gt;bif_ifflags &amp; IFBIF_STP) &amp;&amp;
			    bif-&gt;bif_stp.bp_state == BSTP_IFSTATE_DISCARDING)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (LIST_NEXT(bif, bif_next) == NULL) {
				used = 1;
				mc = m;
			} <span class="enscript-keyword">else</span> {
				mc = m_copypacket(m, M_DONTWAIT);
				<span class="enscript-keyword">if</span> (mc == NULL) {
					(<span class="enscript-type">void</span>) ifnet_stat_increment_out(
					    sc-&gt;sc_ifp, 0, 0, 1);
					<span class="enscript-keyword">continue</span>;
				}
			}

			(<span class="enscript-type">void</span>) bridge_enqueue(sc, dst_if, mc);
		}
		<span class="enscript-keyword">if</span> (used == 0)
			m_freem(m);
		BRIDGE_UNREF(sc);
		<span class="enscript-keyword">return</span> (0);
	}

<span class="enscript-reference">sendunicast</span>:
	<span class="enscript-comment">/*
	 * XXX Spanning tree consideration here?
	 */</span>

	bridge_span(sc, m);
	<span class="enscript-keyword">if</span> ((dst_if-&gt;if_flags &amp; IFF_RUNNING) == 0) {
		m_freem(m);
		BRIDGE_UNLOCK(sc);
		<span class="enscript-keyword">return</span> (0);
	}

	BRIDGE_UNLOCK(sc);
	(<span class="enscript-type">void</span>) bridge_enqueue(sc, dst_if, m);
	<span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_MEMBER_OUT_FILTER */</span>

<span class="enscript-comment">/*
 * Output callback.
 *
 * This routine is called externally from above only when if_bridge_txstart
 * is disabled; otherwise it is called internally by bridge_start().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_output</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = ifnet_softc(ifp);
	<span class="enscript-type">struct</span> ether_header *eh;
	<span class="enscript-type">struct</span> ifnet *dst_if;
	<span class="enscript-type">int</span> error = 0;

	eh = mtod(m, <span class="enscript-type">struct</span> ether_header *);
	dst_if = NULL;

	BRIDGE_LOCK(sc);
	<span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; (M_BCAST|M_MCAST)))
		dst_if = bridge_rtlookup(sc, eh-&gt;ether_dhost, 0);

	(<span class="enscript-type">void</span>) ifnet_stat_increment_out(ifp, 1, m-&gt;m_pkthdr.len, 0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NBPFILTER</span> &gt; 0
	<span class="enscript-keyword">if</span> (sc-&gt;sc_bpf_output)
		bridge_bpf_output(ifp, m);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (dst_if == NULL) {
		<span class="enscript-comment">/* callee will unlock */</span>
		bridge_broadcast(sc, ifp, m, 0);
	} <span class="enscript-keyword">else</span> {
		BRIDGE_UNLOCK(sc);
		error = bridge_enqueue(sc, dst_if, m);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_finalize_cksum</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> ether_header *eh = mtod(m, <span class="enscript-type">struct</span> ether_header *);
	uint32_t sw_csum, hwcap;

	<span class="enscript-keyword">if</span> (ifp != NULL)
		hwcap = (ifp-&gt;if_hwassist | CSUM_DATA_VALID);
	<span class="enscript-keyword">else</span>
		hwcap = 0;

	<span class="enscript-comment">/* do in software what the hardware cannot */</span>
	sw_csum = m-&gt;m_pkthdr.csum_flags &amp; ~IF_HWASSIST_CSUM_FLAGS(hwcap);
	sw_csum &amp;= IF_HWASSIST_CSUM_MASK;

	<span class="enscript-keyword">switch</span> (ntohs(eh-&gt;ether_type)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ETHERTYPE_IP</span>:
		<span class="enscript-keyword">if</span> ((hwcap &amp; CSUM_PARTIAL) &amp;&amp; !(sw_csum &amp; CSUM_DELAY_DATA) &amp;&amp;
		    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_DELAY_DATA)) {
			<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TCP) {
				uint16_t start =
				    <span class="enscript-keyword">sizeof</span> (*eh) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
				uint16_t ulpoff =
				    m-&gt;m_pkthdr.csum_data &amp; 0xffff;
				m-&gt;m_pkthdr.csum_flags |=
				    (CSUM_DATA_VALID | CSUM_PARTIAL);
				m-&gt;m_pkthdr.csum_tx_stuff = (ulpoff + start);
				m-&gt;m_pkthdr.csum_tx_start = start;
			} <span class="enscript-keyword">else</span> {
				sw_csum |= (CSUM_DELAY_DATA &amp;
				    m-&gt;m_pkthdr.csum_flags);
			}
		}
		(<span class="enscript-type">void</span>) in_finalize_cksum(m, <span class="enscript-keyword">sizeof</span> (*eh), sw_csum);
		<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ETHERTYPE_IPV6</span>:
		<span class="enscript-keyword">if</span> ((hwcap &amp; CSUM_PARTIAL) &amp;&amp;
		    !(sw_csum &amp; CSUM_DELAY_IPV6_DATA) &amp;&amp;
		    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_DELAY_IPV6_DATA)) {
			<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TCPIPV6) {
				uint16_t start =
				    <span class="enscript-keyword">sizeof</span> (*eh) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr);
				uint16_t ulpoff =
				    m-&gt;m_pkthdr.csum_data &amp; 0xffff;
				m-&gt;m_pkthdr.csum_flags |=
				    (CSUM_DATA_VALID | CSUM_PARTIAL);
				m-&gt;m_pkthdr.csum_tx_stuff = (ulpoff + start);
				m-&gt;m_pkthdr.csum_tx_start = start;
			} <span class="enscript-keyword">else</span> {
				sw_csum |= (CSUM_DELAY_IPV6_DATA &amp;
				    m-&gt;m_pkthdr.csum_flags);
			}
		}
		(<span class="enscript-type">void</span>) in6_finalize_cksum(m, <span class="enscript-keyword">sizeof</span> (*eh), -1, -1, sw_csum);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	}
}

<span class="enscript-comment">/*
 * bridge_start:
 *
 *	Start output on a bridge.
 *
 * This routine is invoked by the start worker thread; because we never call
 * it directly, there is no need do deploy any serialization mechanism other
 * than what's already used by the worker thread, i.e. this is already single
 * threaded.
 *
 * This routine is called only when if_bridge_txstart is enabled.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_start</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> mbuf *m;

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (ifnet_dequeue(ifp, &amp;m) != 0)
			<span class="enscript-keyword">break</span>;

		(<span class="enscript-type">void</span>) bridge_output(ifp, m);
	}
}

<span class="enscript-comment">/*
 * bridge_forward:
 *
 *	The forwarding function of the bridge.
 *
 *	NOTE: Releases the lock on return.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_forward</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">struct</span> bridge_iflist *sbif,
	<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> bridge_iflist *dbif;
	<span class="enscript-type">struct</span> ifnet *src_if, *dst_if, *ifp;
	<span class="enscript-type">struct</span> ether_header *eh;
	uint16_t vlan;
	uint8_t *dst;
	<span class="enscript-type">int</span> error;

	BRIDGE_LOCK_ASSERT_HELD(sc);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_OUTPPUT)
		printf(<span class="enscript-string">&quot;%s: %s m 0x%llx\n&quot;</span>, __func__, sc-&gt;sc_ifp-&gt;if_xname,
		    (uint64_t)VM_KERNEL_ADDRPERM(m));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

	src_if = m-&gt;m_pkthdr.rcvif;
	ifp = sc-&gt;sc_ifp;

	(<span class="enscript-type">void</span>) ifnet_stat_increment_in(ifp, 1, m-&gt;m_pkthdr.len, 0);
	vlan = VLANTAGOF(m);


	<span class="enscript-keyword">if</span> ((sbif-&gt;bif_ifflags &amp; IFBIF_STP) &amp;&amp;
	    sbif-&gt;bif_stp.bp_state == BSTP_IFSTATE_DISCARDING)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;

	eh = mtod(m, <span class="enscript-type">struct</span> ether_header *);
	dst = eh-&gt;ether_dhost;

	<span class="enscript-comment">/* If the interface is learning, record the address. */</span>
	<span class="enscript-keyword">if</span> (sbif-&gt;bif_ifflags &amp; IFBIF_LEARNING) {
		error = bridge_rtupdate(sc, eh-&gt;ether_shost, vlan,
		    sbif, 0, IFBAF_DYNAMIC);
		<span class="enscript-comment">/*
		 * If the interface has addresses limits then deny any source
		 * that is not in the cache.
		 */</span>
		<span class="enscript-keyword">if</span> (error &amp;&amp; sbif-&gt;bif_addrmax)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
	}

	<span class="enscript-keyword">if</span> ((sbif-&gt;bif_ifflags &amp; IFBIF_STP) != 0 &amp;&amp;
	    sbif-&gt;bif_stp.bp_state == BSTP_IFSTATE_LEARNING)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;

	<span class="enscript-comment">/*
	 * At this point, the port either doesn't participate
	 * in spanning tree or it is in the forwarding state.
	 */</span>

	<span class="enscript-comment">/*
	 * If the packet is unicast, destined for someone on
	 * &quot;this&quot; side of the bridge, drop it.
	 */</span>
	<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; (M_BCAST|M_MCAST)) == 0) {
		dst_if = bridge_rtlookup(sc, dst, vlan);
		<span class="enscript-keyword">if</span> (src_if == dst_if)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Check if its a reserved multicast address, any address
		 * listed in 802.1D section 7.12.6 may not be forwarded by the
		 * bridge.
		 * This is currently 01-80-C2-00-00-00 to 01-80-C2-00-00-0F
		 */</span>
		<span class="enscript-keyword">if</span> (dst[0] == 0x01 &amp;&amp; dst[1] == 0x80 &amp;&amp;
		    dst[2] == 0xc2 &amp;&amp; dst[3] == 0x00 &amp;&amp;
		    dst[4] == 0x00 &amp;&amp; dst[5] &lt;= 0x0f)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;


		<span class="enscript-comment">/* ...forward it to all interfaces. */</span>
		atomic_add_64(&amp;ifp-&gt;if_imcasts, 1);
		dst_if = NULL;
	}

	<span class="enscript-comment">/*
	 * If we have a destination interface which is a member of our bridge,
	 * OR this is a unicast packet, push it through the bpf(4) machinery.
	 * For broadcast or multicast packets, don't bother because it will
	 * be reinjected into ether_input. We do this before we pass the packets
	 * through the pfil(9) framework, as it is possible that pfil(9) will
	 * drop the packet, or possibly modify it, making it difficult to debug
	 * firewall issues on the bridge.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NBPFILTER</span> &gt; 0
	<span class="enscript-keyword">if</span> (eh-&gt;ether_type == htons(ETHERTYPE_RSN_PREAUTH) ||
	    dst_if != NULL || (m-&gt;m_flags &amp; (M_BCAST | M_MCAST)) == 0) {
		m-&gt;m_pkthdr.rcvif = ifp;
		<span class="enscript-keyword">if</span> (sc-&gt;sc_bpf_input)
			bridge_bpf_input(ifp, m);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NBPFILTER */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">PFIL_HOOKS</span>)
	<span class="enscript-comment">/* run the packet filter */</span>
	<span class="enscript-keyword">if</span> (PFIL_HOOKED(&amp;inet_pfil_hook) || PFIL_HOOKED_INET6) {
		BRIDGE_UNLOCK(sc);
		<span class="enscript-keyword">if</span> (bridge_pfil(&amp;m, ifp, src_if, PFIL_IN) != 0)
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span>;
		BRIDGE_LOCK(sc);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFIL_HOOKS */</span>

	<span class="enscript-keyword">if</span> (dst_if == NULL) {
		bridge_broadcast(sc, src_if, m, 1);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * At this point, we're dealing with a unicast frame
	 * going to a different interface.
	 */</span>
	<span class="enscript-keyword">if</span> ((dst_if-&gt;if_flags &amp; IFF_RUNNING) == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;

	dbif = bridge_lookup_member_if(sc, dst_if);
	<span class="enscript-keyword">if</span> (dbif == NULL)
		<span class="enscript-comment">/* Not a member of the bridge (anymore?) */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;

	<span class="enscript-comment">/* Private segments can not talk to each other */</span>
	<span class="enscript-keyword">if</span> (sbif-&gt;bif_ifflags &amp; dbif-&gt;bif_ifflags &amp; IFBIF_PRIVATE)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;

	<span class="enscript-keyword">if</span> ((dbif-&gt;bif_ifflags &amp; IFBIF_STP) &amp;&amp;
	    dbif-&gt;bif_stp.bp_state == BSTP_IFSTATE_DISCARDING)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HAS_DHCPRA_MASK</span>
	<span class="enscript-comment">/* APPLE MODIFICATION &lt;rdar:6985737&gt; */</span>
	<span class="enscript-keyword">if</span> ((dst_if-&gt;if_extflags &amp; IFEXTF_DHCPRA_MASK) != 0) {
		m = ip_xdhcpra_output(dst_if, m);
		<span class="enscript-keyword">if</span> (!m) {
			++sc-&gt;sc_sc.sc_ifp.if_xdhcpra;
			<span class="enscript-keyword">return</span>;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HAS_DHCPRA_MASK */</span>

	BRIDGE_UNLOCK(sc);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">PFIL_HOOKS</span>)
	<span class="enscript-keyword">if</span> (PFIL_HOOKED(&amp;inet_pfil_hook) || PFIL_HOOKED_INET6) {
		<span class="enscript-keyword">if</span> (bridge_pfil(&amp;m, ifp, dst_if, PFIL_OUT) != 0)
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFIL_HOOKS */</span>

	(<span class="enscript-type">void</span>) bridge_enqueue(sc, dst_if, m);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">drop</span>:
	BRIDGE_UNLOCK(sc);
	m_freem(m);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>

<span class="enscript-type">char</span> *<span class="enscript-function-name">ether_ntop</span>(<span class="enscript-type">char</span> *, size_t, <span class="enscript-type">const</span> u_char *);

__private_extern__ <span class="enscript-type">char</span> *
<span class="enscript-function-name">ether_ntop</span>(<span class="enscript-type">char</span> *buf, size_t len, <span class="enscript-type">const</span> u_char *ap)
{
	snprintf(buf, len, <span class="enscript-string">&quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;</span>,
	    ap[0], ap[1], ap[2], ap[3], ap[4], ap[5]);

	<span class="enscript-keyword">return</span> (buf);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

<span class="enscript-comment">/*
 * bridge_input:
 *
 *	Filter input from a member interface.  Queue the packet for
 *	bridging if it is not for us.
 */</span>
__private_extern__ errno_t
<span class="enscript-function-name">bridge_input</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">void</span> *frame_header)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = ifp-&gt;if_bridge;
	<span class="enscript-type">struct</span> bridge_iflist *bif, *bif2;
	<span class="enscript-type">struct</span> ifnet *bifp;
	<span class="enscript-type">struct</span> ether_header *eh;
	<span class="enscript-type">struct</span> mbuf *mc, *mc2;
	uint16_t vlan;
	<span class="enscript-type">int</span> error;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_INPUT)
		printf(<span class="enscript-string">&quot;%s: %s from %s m 0x%llx data 0x%llx\n&quot;</span>, __func__,
		    sc-&gt;sc_ifp-&gt;if_xname, ifp-&gt;if_xname,
		    (uint64_t)VM_KERNEL_ADDRPERM(m),
		    (uint64_t)VM_KERNEL_ADDRPERM(mbuf_data(m)));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

	<span class="enscript-keyword">if</span> ((sc-&gt;sc_ifp-&gt;if_flags &amp; IFF_RUNNING) == 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
		<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_INPUT)
			printf(<span class="enscript-string">&quot;%s: %s not running passing along\n&quot;</span>,
			    __func__, sc-&gt;sc_ifp-&gt;if_xname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>
		<span class="enscript-keyword">return</span> (0);
	}

	bifp = sc-&gt;sc_ifp;
	vlan = VLANTAGOF(m);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IFF_MONITOR</span>
	<span class="enscript-comment">/*
	 * Implement support for bridge monitoring. If this flag has been
	 * set on this interface, discard the packet once we push it through
	 * the bpf(4) machinery, but before we do, increment the byte and
	 * packet counters associated with this interface.
	 */</span>
	<span class="enscript-keyword">if</span> ((bifp-&gt;if_flags &amp; IFF_MONITOR) != 0) {
		m-&gt;m_pkthdr.rcvif  = bifp;
		BRIDGE_BPF_MTAP_INPUT(sc, m);
		(<span class="enscript-type">void</span>) ifnet_stat_increment_in(bifp, 1, m-&gt;m_pkthdr.len, 0);
		m_freem(m);
		<span class="enscript-keyword">return</span> (EJUSTRETURN);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IFF_MONITOR */</span>

	<span class="enscript-comment">/*
	 * Need to clear the promiscous flags otherwise it will be
	 * dropped by DLIL after processing filters
	 */</span>
	<span class="enscript-keyword">if</span> ((mbuf_flags(m) &amp; MBUF_PROMISC))
		mbuf_setflags_mask(m, 0, MBUF_PROMISC);

	BRIDGE_LOCK(sc);
	bif = bridge_lookup_member_if(sc, ifp);
	<span class="enscript-keyword">if</span> (bif == NULL) {
		BRIDGE_UNLOCK(sc);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
		<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_INPUT)
			printf(<span class="enscript-string">&quot;%s: %s bridge_lookup_member_if failed\n&quot;</span>,
			    __func__, sc-&gt;sc_ifp-&gt;if_xname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (bif-&gt;bif_flags &amp; BIFF_HOST_FILTER) {
		error = bridge_host_filter(bif, m);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_INPUT)
				printf(<span class="enscript-string">&quot;%s: %s bridge_host_filter failed\n&quot;</span>,
				    __func__, bif-&gt;bif_ifp-&gt;if_xname);
			BRIDGE_UNLOCK(sc);
			<span class="enscript-keyword">return</span> (EJUSTRETURN);
		}
	}

	eh = mtod(m, <span class="enscript-type">struct</span> ether_header *);

	bridge_span(sc, m);

	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; (M_BCAST|M_MCAST)) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
		<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_MCAST)
			<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_MCAST))
				printf(<span class="enscript-string">&quot;%s: multicast: &quot;</span>
				    <span class="enscript-string">&quot;%02x:%02x:%02x:%02x:%02x:%02x\n&quot;</span>,
				    __func__,
				    eh-&gt;ether_dhost[0], eh-&gt;ether_dhost[1],
				    eh-&gt;ether_dhost[2], eh-&gt;ether_dhost[3],
				    eh-&gt;ether_dhost[4], eh-&gt;ether_dhost[5]);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

		<span class="enscript-comment">/* Tap off 802.1D packets; they do not get forwarded. */</span>
		<span class="enscript-keyword">if</span> (memcmp(eh-&gt;ether_dhost, bstp_etheraddr,
		    ETHER_ADDR_LEN) == 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
			m = bstp_input(&amp;bif-&gt;bif_stp, ifp, m);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
			m_freem(m);
			m = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !BRIDGESTP */</span>
			<span class="enscript-keyword">if</span> (m == NULL) {
				BRIDGE_UNLOCK(sc);
				<span class="enscript-keyword">return</span> (EJUSTRETURN);
			}
		}

		<span class="enscript-keyword">if</span> ((bif-&gt;bif_ifflags &amp; IFBIF_STP) &amp;&amp;
		    bif-&gt;bif_stp.bp_state == BSTP_IFSTATE_DISCARDING) {
			BRIDGE_UNLOCK(sc);
			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-comment">/*
		 * Make a deep copy of the packet and enqueue the copy
		 * for bridge processing; return the original packet for
		 * local processing.
		 */</span>
		mc = m_dup(m, M_DONTWAIT);
		<span class="enscript-keyword">if</span> (mc == NULL) {
			BRIDGE_UNLOCK(sc);
			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-comment">/*
		 * Perform the bridge forwarding function with the copy.
		 *
		 * Note that bridge_forward calls BRIDGE_UNLOCK
		 */</span>
		bridge_forward(sc, bif, mc);

		<span class="enscript-comment">/*
		 * Reinject the mbuf as arriving on the bridge so we have a
		 * chance at claiming multicast packets. We can not loop back
		 * here from ether_input as a bridge is never a member of a
		 * bridge.
		 */</span>
		VERIFY(bifp-&gt;if_bridge == NULL);
		mc2 = m_dup(m, M_DONTWAIT);
		<span class="enscript-keyword">if</span> (mc2 != NULL) {
			<span class="enscript-comment">/* Keep the layer3 header aligned */</span>
			<span class="enscript-type">int</span> i = min(mc2-&gt;m_pkthdr.len, max_protohdr);
			mc2 = m_copyup(mc2, i, ETHER_ALIGN);
		}
		<span class="enscript-keyword">if</span> (mc2 != NULL) {
			<span class="enscript-comment">/* mark packet as arriving on the bridge */</span>
			mc2-&gt;m_pkthdr.rcvif = bifp;
			mc2-&gt;m_pkthdr.pkt_hdr = mbuf_data(mc2);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NBPFILTER</span> &gt; 0
			<span class="enscript-keyword">if</span> (sc-&gt;sc_bpf_input)
				bridge_bpf_input(bifp, mc2);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NBPFILTER */</span>
			(<span class="enscript-type">void</span>) mbuf_setdata(mc2,
			    (<span class="enscript-type">char</span> *)mbuf_data(mc2) + ETHER_HDR_LEN,
			    mbuf_len(mc2) - ETHER_HDR_LEN);
			(<span class="enscript-type">void</span>) mbuf_pkthdr_adjustlen(mc2, - ETHER_HDR_LEN);

			(<span class="enscript-type">void</span>) ifnet_stat_increment_in(bifp, 1,
			    mbuf_pkthdr_len(mc2), 0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
			<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_MCAST)
				printf(<span class="enscript-string">&quot;%s: %s mcast for us\n&quot;</span>, __func__,
				    sc-&gt;sc_ifp-&gt;if_xname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

			dlil_input_packet_list(bifp, mc2);
		}

		<span class="enscript-comment">/* Return the original packet for local processing. */</span>
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> ((bif-&gt;bif_ifflags &amp; IFBIF_STP) &amp;&amp;
	    bif-&gt;bif_stp.bp_state == BSTP_IFSTATE_DISCARDING) {
		BRIDGE_UNLOCK(sc);
		<span class="enscript-keyword">return</span> (0);
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DEV_CARP</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">CARP_CHECK_WE_ARE_DST</span>(iface) \
	((iface)-&gt;if_carp &amp;&amp;\
		carp_forus((iface)-&gt;if_carp, eh-&gt;ether_dhost))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">CARP_CHECK_WE_ARE_SRC</span>(iface) \
	((iface)-&gt;if_carp &amp;&amp;\
		carp_forus((iface)-&gt;if_carp, eh-&gt;ether_shost))
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">CARP_CHECK_WE_ARE_DST</span>(iface) 0
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">CARP_CHECK_WE_ARE_SRC</span>(iface) 0
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PFIL_HOOKED_INET6</span> PFIL_HOOKED(&amp;inet6_pfil_hook)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PFIL_HOOKED_INET6</span> 0
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">PFIL_HOOKS</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PFIL_PHYS</span>(sc, ifp, m) do {					\
	<span class="enscript-keyword">if</span> (pfil_local_phys &amp;&amp;						\
	(PFIL_HOOKED(&amp;inet_pfil_hook) || PFIL_HOOKED_INET6)) {		\
		<span class="enscript-keyword">if</span> (bridge_pfil(&amp;m, NULL, ifp,				\
		    PFIL_IN) != 0 || m == NULL) {			\
			BRIDGE_UNLOCK(sc);				\
			<span class="enscript-keyword">return</span> (NULL);					\
		}							\
	}								\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* PFIL_HOOKS */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PFIL_PHYS</span>(sc, ifp, m)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFIL_HOOKS */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">GRAB_OUR_PACKETS</span>(iface)						\
	<span class="enscript-keyword">if</span> ((iface)-&gt;if_type == IFT_GIF)				\
		<span class="enscript-keyword">continue</span>;						\
	<span class="enscript-comment">/* It is destined for us. */</span>					\
	<span class="enscript-keyword">if</span> (memcmp(IF_LLADDR((iface)), eh-&gt;ether_dhost,		\
	    ETHER_ADDR_LEN) == 0 || CARP_CHECK_WE_ARE_DST((iface))) {	\
		<span class="enscript-keyword">if</span> ((iface)-&gt;if_type == IFT_BRIDGE) {			\
			BRIDGE_BPF_MTAP_INPUT(sc, m);			\
			<span class="enscript-comment">/* Filter on the physical interface. */</span>		\
			PFIL_PHYS(sc, iface, m);			\
		}							\
		<span class="enscript-keyword">if</span> (bif-&gt;bif_ifflags &amp; IFBIF_LEARNING) {		\
			error = bridge_rtupdate(sc, eh-&gt;ether_shost,	\
			    vlan, bif, 0, IFBAF_DYNAMIC);		\
			<span class="enscript-keyword">if</span> (error &amp;&amp; bif-&gt;bif_addrmax) {		\
				BRIDGE_UNLOCK(sc);			\
				<span class="enscript-keyword">return</span> (EJUSTRETURN);			\
			}						\
		}							\
		m-&gt;m_pkthdr.rcvif = iface;				\
		BRIDGE_UNLOCK(sc);					\
		<span class="enscript-keyword">return</span> (0);						\
	}								\
									\
	<span class="enscript-comment">/* We just received a packet that we sent out. */</span>		\
	<span class="enscript-keyword">if</span> (memcmp(IF_LLADDR((iface)), eh-&gt;ether_shost,		\
	    ETHER_ADDR_LEN) == 0 || CARP_CHECK_WE_ARE_SRC((iface))) {	\
		BRIDGE_UNLOCK(sc);					\
		<span class="enscript-keyword">return</span> (EJUSTRETURN);					\
	}

	<span class="enscript-comment">/*
	 * Unicast.
	 */</span>
	<span class="enscript-comment">/*
	 * If the packet is for us, set the packets source as the
	 * bridge, and return the packet back to ether_input for
	 * local processing.
	 */</span>
	<span class="enscript-keyword">if</span> (memcmp(eh-&gt;ether_dhost, IF_LLADDR(bifp),
	    ETHER_ADDR_LEN) == 0 || CARP_CHECK_WE_ARE_DST(bifp)) {

		<span class="enscript-comment">/* Mark the packet as arriving on the bridge interface */</span>
		(<span class="enscript-type">void</span>) mbuf_pkthdr_setrcvif(m, bifp);
		mbuf_pkthdr_setheader(m, frame_header);

		<span class="enscript-comment">/*
		 * If the interface is learning, and the source
		 * address is valid and not multicast, record
		 * the address.
		 */</span>
		<span class="enscript-keyword">if</span> (bif-&gt;bif_ifflags &amp; IFBIF_LEARNING)
			(<span class="enscript-type">void</span>) bridge_rtupdate(sc, eh-&gt;ether_shost,
			    vlan, bif, 0, IFBAF_DYNAMIC);

		BRIDGE_BPF_MTAP_INPUT(sc, m);

		(<span class="enscript-type">void</span>) mbuf_setdata(m, (<span class="enscript-type">char</span> *)mbuf_data(m) + ETHER_HDR_LEN,
		    mbuf_len(m) - ETHER_HDR_LEN);
		(<span class="enscript-type">void</span>) mbuf_pkthdr_adjustlen(m, - ETHER_HDR_LEN);

		(<span class="enscript-type">void</span>) ifnet_stat_increment_in(bifp, 1, mbuf_pkthdr_len(m), 0);

		BRIDGE_UNLOCK(sc);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
		<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_INPUT)
			printf(<span class="enscript-string">&quot;%s: %s packet for bridge\n&quot;</span>, __func__,
			    sc-&gt;sc_ifp-&gt;if_xname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

		dlil_input_packet_list(bifp, m);

		<span class="enscript-keyword">return</span> (EJUSTRETURN);
	}

	<span class="enscript-comment">/*
	 * if the destination of the packet is for the MAC address of
	 * the member interface itself, then we don't need to forward
	 * it -- just pass it back.  Note that it'll likely just be
	 * dropped by the stack, but if something else is bound to
	 * the interface directly (for example, the wireless stats
	 * protocol -- although that actually uses BPF right now),
	 * then it will consume the packet
	 *
	 * ALSO, note that we do this check AFTER checking for the
	 * bridge's own MAC address, because the bridge may be
	 * using the SAME MAC address as one of its interfaces
	 */</span>
	<span class="enscript-keyword">if</span> (memcmp(eh-&gt;ether_dhost, IF_LLADDR(ifp), ETHER_ADDR_LEN) == 0) {

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VERY_VERY_VERY_DIAGNOSTIC</span>
			printf(<span class="enscript-string">&quot;%s: not forwarding packet bound for member &quot;</span>
			    <span class="enscript-string">&quot;interface\n&quot;</span>, __func__);
#<span class="enscript-reference">endif</span>
			BRIDGE_UNLOCK(sc);
			<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* Now check the all bridge members. */</span>
	TAILQ_FOREACH(bif2, &amp;sc-&gt;sc_iflist, bif_next) {
		GRAB_OUR_PACKETS(bif2-&gt;bif_ifp)
	}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">CARP_CHECK_WE_ARE_DST</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">CARP_CHECK_WE_ARE_SRC</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">GRAB_OUR_PACKETS</span>

	<span class="enscript-comment">/*
	 * Perform the bridge forwarding function.
	 *
	 * Note that bridge_forward calls BRIDGE_UNLOCK
	 */</span>
	bridge_forward(sc, bif, m);

	<span class="enscript-keyword">return</span> (EJUSTRETURN);
}

<span class="enscript-comment">/*
 * bridge_broadcast:
 *
 *	Send a frame to all interfaces that are members of
 *	the bridge, except for the one on which the packet
 *	arrived.
 *
 *	NOTE: Releases the lock on return.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_broadcast</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">struct</span> ifnet *src_if,
	<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> runfilt)
{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PFIL_HOOKS</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">runfilt</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> bridge_iflist *dbif, *sbif;
	<span class="enscript-type">struct</span> mbuf *mc;
	<span class="enscript-type">struct</span> ifnet *dst_if;
	<span class="enscript-type">int</span> error = 0, used = 0;

	sbif = bridge_lookup_member_if(sc, src_if);

	BRIDGE_LOCK2REF(sc, error);
	<span class="enscript-keyword">if</span> (error) {
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PFIL_HOOKS</span>
	<span class="enscript-comment">/* Filter on the bridge interface before broadcasting */</span>
	<span class="enscript-keyword">if</span> (runfilt &amp;&amp; (PFIL_HOOKED(&amp;inet_pfil_hook) || PFIL_HOOKED_INET6)) {
		<span class="enscript-keyword">if</span> (bridge_pfil(&amp;m, sc-&gt;sc_ifp, NULL, PFIL_OUT) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFIL_HOOKS */</span>

	TAILQ_FOREACH(dbif, &amp;sc-&gt;sc_iflist, bif_next) {
		dst_if = dbif-&gt;bif_ifp;
		<span class="enscript-keyword">if</span> (dst_if == src_if)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* Private segments can not talk to each other */</span>
		<span class="enscript-keyword">if</span> (sbif &amp;&amp;
		    (sbif-&gt;bif_ifflags &amp; dbif-&gt;bif_ifflags &amp; IFBIF_PRIVATE))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> ((dbif-&gt;bif_ifflags &amp; IFBIF_STP) &amp;&amp;
		    dbif-&gt;bif_stp.bp_state == BSTP_IFSTATE_DISCARDING)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> ((dbif-&gt;bif_ifflags &amp; IFBIF_DISCOVER) == 0 &amp;&amp;
		    (m-&gt;m_flags &amp; (M_BCAST|M_MCAST)) == 0)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> ((dst_if-&gt;if_flags &amp; IFF_RUNNING) == 0)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (!(dbif-&gt;bif_flags &amp; BIFF_MEDIA_ACTIVE)) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (TAILQ_NEXT(dbif, bif_next) == NULL) {
			mc = m;
			used = 1;
		} <span class="enscript-keyword">else</span> {
			mc = m_dup(m, M_DONTWAIT);
			<span class="enscript-keyword">if</span> (mc == NULL) {
				(<span class="enscript-type">void</span>) ifnet_stat_increment_out(sc-&gt;sc_ifp,
				    0, 0, 1);
				<span class="enscript-keyword">continue</span>;
			}
		}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PFIL_HOOKS</span>
		<span class="enscript-comment">/*
		 * Filter on the output interface. Pass a NULL bridge interface
		 * pointer so we do not redundantly filter on the bridge for
		 * each interface we broadcast on.
		 */</span>
		<span class="enscript-keyword">if</span> (runfilt &amp;&amp;
		    (PFIL_HOOKED(&amp;inet_pfil_hook) || PFIL_HOOKED_INET6)) {
			<span class="enscript-keyword">if</span> (used == 0) {
				<span class="enscript-comment">/* Keep the layer3 header aligned */</span>
				<span class="enscript-type">int</span> i = min(mc-&gt;m_pkthdr.len, max_protohdr);
				mc = m_copyup(mc, i, ETHER_ALIGN);
				<span class="enscript-keyword">if</span> (mc == NULL) {
					(<span class="enscript-type">void</span>) ifnet_stat_increment_out(
					    sc-&gt;sc_ifp, 0, 0, 1);
					<span class="enscript-keyword">continue</span>;
				}
			}
			<span class="enscript-keyword">if</span> (bridge_pfil(&amp;mc, NULL, dst_if, PFIL_OUT) != 0)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (mc == NULL)
				<span class="enscript-keyword">continue</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFIL_HOOKS */</span>

		(<span class="enscript-type">void</span>) bridge_enqueue(sc, dst_if, mc);
	}
	<span class="enscript-keyword">if</span> (used == 0)
		m_freem(m);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PFIL_HOOKS</span>
<span class="enscript-reference">out</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFIL_HOOKS */</span>

	BRIDGE_UNREF(sc);
}

<span class="enscript-comment">/*
 * bridge_span:
 *
 *	Duplicate a packet out one or more interfaces that are in span mode,
 *	the original mbuf is unmodified.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_span</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> bridge_iflist *bif;
	<span class="enscript-type">struct</span> ifnet *dst_if;
	<span class="enscript-type">struct</span> mbuf *mc;

	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;sc-&gt;sc_spanlist))
		<span class="enscript-keyword">return</span>;

	TAILQ_FOREACH(bif, &amp;sc-&gt;sc_spanlist, bif_next) {
		dst_if = bif-&gt;bif_ifp;

		<span class="enscript-keyword">if</span> ((dst_if-&gt;if_flags &amp; IFF_RUNNING) == 0)
			<span class="enscript-keyword">continue</span>;

		mc = m_copypacket(m, M_DONTWAIT);
		<span class="enscript-keyword">if</span> (mc == NULL) {
			(<span class="enscript-type">void</span>) ifnet_stat_increment_out(sc-&gt;sc_ifp, 0, 0, 1);
			<span class="enscript-keyword">continue</span>;
		}

		(<span class="enscript-type">void</span>) bridge_enqueue(sc, dst_if, mc);
	}
}


<span class="enscript-comment">/*
 * bridge_rtupdate:
 *
 *	Add a bridge routing entry.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_rtupdate</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">const</span> uint8_t *dst, uint16_t vlan,
	<span class="enscript-type">struct</span> bridge_iflist *bif, <span class="enscript-type">int</span> setflags, uint8_t flags)
{
	<span class="enscript-type">struct</span> bridge_rtnode *brt;
	<span class="enscript-type">int</span> error;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	<span class="enscript-comment">/* Check the source address is valid and not multicast. */</span>
	<span class="enscript-keyword">if</span> (ETHER_IS_MULTICAST(dst) ||
	    (dst[0] == 0 &amp;&amp; dst[1] == 0 &amp;&amp; dst[2] == 0 &amp;&amp;
	    dst[3] == 0 &amp;&amp; dst[4] == 0 &amp;&amp; dst[5] == 0) != 0)
		<span class="enscript-keyword">return</span> (EINVAL);


	<span class="enscript-comment">/* 802.1p frames map to vlan 1 */</span>
	<span class="enscript-keyword">if</span> (vlan == 0)
		vlan = 1;

	<span class="enscript-comment">/*
	 * A route for this destination might already exist.  If so,
	 * update it, otherwise create a new one.
	 */</span>
	<span class="enscript-keyword">if</span> ((brt = bridge_rtnode_lookup(sc, dst, vlan)) == NULL) {
		<span class="enscript-keyword">if</span> (sc-&gt;sc_brtcnt &gt;= sc-&gt;sc_brtmax) {
			sc-&gt;sc_brtexceeded++;
			<span class="enscript-keyword">return</span> (ENOSPC);
		}
		<span class="enscript-comment">/* Check per interface address limits (if enabled) */</span>
		<span class="enscript-keyword">if</span> (bif-&gt;bif_addrmax &amp;&amp; bif-&gt;bif_addrcnt &gt;= bif-&gt;bif_addrmax) {
			bif-&gt;bif_addrexceeded++;
			<span class="enscript-keyword">return</span> (ENOSPC);
		}

		<span class="enscript-comment">/*
		 * Allocate a new bridge forwarding node, and
		 * initialize the expiration time and Ethernet
		 * address.
		 */</span>
		brt = zalloc_noblock(bridge_rtnode_pool);
		<span class="enscript-keyword">if</span> (brt == NULL)
			<span class="enscript-keyword">return</span> (ENOMEM);
		bzero(brt, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bridge_rtnode));

		<span class="enscript-keyword">if</span> (bif-&gt;bif_ifflags &amp; IFBIF_STICKY)
			brt-&gt;brt_flags = IFBAF_STICKY;
		<span class="enscript-keyword">else</span>
			brt-&gt;brt_flags = IFBAF_DYNAMIC;

		memcpy(brt-&gt;brt_addr, dst, ETHER_ADDR_LEN);
		brt-&gt;brt_vlan = vlan;


		<span class="enscript-keyword">if</span> ((error = bridge_rtnode_insert(sc, brt)) != 0) {
			zfree(bridge_rtnode_pool, brt);
			<span class="enscript-keyword">return</span> (error);
		}
		brt-&gt;brt_dst = bif;
		bif-&gt;bif_addrcnt++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
		<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_RT_TABLE)
			printf(<span class="enscript-string">&quot;%s: added %02x:%02x:%02x:%02x:%02x:%02x &quot;</span>
			    <span class="enscript-string">&quot;on %s count %u hashsize %u\n&quot;</span>, __func__,
			    dst[0], dst[1], dst[2], dst[3], dst[4], dst[5],
			    sc-&gt;sc_ifp-&gt;if_xname, sc-&gt;sc_brtcnt,
			    sc-&gt;sc_rthash_size);
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-keyword">if</span> ((brt-&gt;brt_flags &amp; IFBAF_TYPEMASK) == IFBAF_DYNAMIC &amp;&amp;
	    brt-&gt;brt_dst != bif) {
		brt-&gt;brt_dst-&gt;bif_addrcnt--;
		brt-&gt;brt_dst = bif;
		brt-&gt;brt_dst-&gt;bif_addrcnt++;
	}

	<span class="enscript-keyword">if</span> ((flags &amp; IFBAF_TYPEMASK) == IFBAF_DYNAMIC) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> now;

		now = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) net_uptime();
		brt-&gt;brt_expire = now + sc-&gt;sc_brttimeout;
	}
	<span class="enscript-keyword">if</span> (setflags)
		brt-&gt;brt_flags = flags;


	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * bridge_rtlookup:
 *
 *	Lookup the destination interface for an address.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifnet *
<span class="enscript-function-name">bridge_rtlookup</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">const</span> uint8_t *addr, uint16_t vlan)
{
	<span class="enscript-type">struct</span> bridge_rtnode *brt;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	<span class="enscript-keyword">if</span> ((brt = bridge_rtnode_lookup(sc, addr, vlan)) == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">return</span> (brt-&gt;brt_ifp);
}

<span class="enscript-comment">/*
 * bridge_rttrim:
 *
 *	Trim the routine table so that we have a number
 *	of routing entries less than or equal to the
 *	maximum number.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_rttrim</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	<span class="enscript-type">struct</span> bridge_rtnode *brt, *nbrt;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	<span class="enscript-comment">/* Make sure we actually need to do this. */</span>
	<span class="enscript-keyword">if</span> (sc-&gt;sc_brtcnt &lt;= sc-&gt;sc_brtmax)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Force an aging cycle; this might trim enough addresses. */</span>
	bridge_rtage(sc);
	<span class="enscript-keyword">if</span> (sc-&gt;sc_brtcnt &lt;= sc-&gt;sc_brtmax)
		<span class="enscript-keyword">return</span>;

	LIST_FOREACH_SAFE(brt, &amp;sc-&gt;sc_rtlist, brt_list, nbrt) {
		<span class="enscript-keyword">if</span> ((brt-&gt;brt_flags &amp; IFBAF_TYPEMASK) == IFBAF_DYNAMIC) {
			bridge_rtnode_destroy(sc, brt);
			<span class="enscript-keyword">if</span> (sc-&gt;sc_brtcnt &lt;= sc-&gt;sc_brtmax)
				<span class="enscript-keyword">return</span>;
		}
	}
}

<span class="enscript-comment">/*
 * bridge_aging_timer:
 *
 *	Aging periodic timer for the bridge routing table.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_aging_timer</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	BRIDGE_LOCK_ASSERT_HELD(sc);

	bridge_rtage(sc);

	<span class="enscript-keyword">if</span> ((sc-&gt;sc_ifp-&gt;if_flags &amp; IFF_RUNNING) &amp;&amp;
	    (sc-&gt;sc_flags &amp; SCF_DETACHING) == 0) {
		sc-&gt;sc_aging_timer.bdc_sc = sc;
		sc-&gt;sc_aging_timer.bdc_func = bridge_aging_timer;
		sc-&gt;sc_aging_timer.bdc_ts.tv_sec = bridge_rtable_prune_period;
		bridge_schedule_delayed_call(&amp;sc-&gt;sc_aging_timer);
	}
}

<span class="enscript-comment">/*
 * bridge_rtage:
 *
 *	Perform an aging cycle.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_rtage</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	<span class="enscript-type">struct</span> bridge_rtnode *brt, *nbrt;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> now;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	now = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) net_uptime();

	LIST_FOREACH_SAFE(brt, &amp;sc-&gt;sc_rtlist, brt_list, nbrt) {
		<span class="enscript-keyword">if</span> ((brt-&gt;brt_flags &amp; IFBAF_TYPEMASK) == IFBAF_DYNAMIC) {
			<span class="enscript-keyword">if</span> (now &gt;= brt-&gt;brt_expire)
				bridge_rtnode_destroy(sc, brt);
		}
	}
}

<span class="enscript-comment">/*
 * bridge_rtflush:
 *
 *	Remove all dynamic addresses from the bridge.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_rtflush</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">int</span> full)
{
	<span class="enscript-type">struct</span> bridge_rtnode *brt, *nbrt;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	LIST_FOREACH_SAFE(brt, &amp;sc-&gt;sc_rtlist, brt_list, nbrt) {
		<span class="enscript-keyword">if</span> (full || (brt-&gt;brt_flags &amp; IFBAF_TYPEMASK) == IFBAF_DYNAMIC)
			bridge_rtnode_destroy(sc, brt);
	}
}

<span class="enscript-comment">/*
 * bridge_rtdaddr:
 *
 *	Remove an address from the table.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_rtdaddr</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">const</span> uint8_t *addr, uint16_t vlan)
{
	<span class="enscript-type">struct</span> bridge_rtnode *brt;
	<span class="enscript-type">int</span> found = 0;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	<span class="enscript-comment">/*
	 * If vlan is zero then we want to delete for all vlans so the lookup
	 * may return more than one.
	 */</span>
	<span class="enscript-keyword">while</span> ((brt = bridge_rtnode_lookup(sc, addr, vlan)) != NULL) {
		bridge_rtnode_destroy(sc, brt);
		found = 1;
	}

	<span class="enscript-keyword">return</span> (found ? 0 : ENOENT);
}

<span class="enscript-comment">/*
 * bridge_rtdelete:
 *
 *	Delete routes to a speicifc member interface.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_rtdelete</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> full)
{
	<span class="enscript-type">struct</span> bridge_rtnode *brt, *nbrt;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	LIST_FOREACH_SAFE(brt, &amp;sc-&gt;sc_rtlist, brt_list, nbrt) {
		<span class="enscript-keyword">if</span> (brt-&gt;brt_ifp == ifp &amp;&amp; (full ||
		    (brt-&gt;brt_flags &amp; IFBAF_TYPEMASK) == IFBAF_DYNAMIC))
			bridge_rtnode_destroy(sc, brt);
	}
}

<span class="enscript-comment">/*
 * bridge_rtable_init:
 *
 *	Initialize the route table for this bridge.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_rtable_init</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	u_int32_t i;

	sc-&gt;sc_rthash = _MALLOC(<span class="enscript-keyword">sizeof</span> (*sc-&gt;sc_rthash) * BRIDGE_RTHASH_SIZE,
	    M_DEVBUF, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (sc-&gt;sc_rthash == NULL) {
		printf(<span class="enscript-string">&quot;%s: no memory\n&quot;</span>, __func__);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	sc-&gt;sc_rthash_size = BRIDGE_RTHASH_SIZE;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; sc-&gt;sc_rthash_size; i++)
		LIST_INIT(&amp;sc-&gt;sc_rthash[i]);

	sc-&gt;sc_rthash_key = RandomULong();

	LIST_INIT(&amp;sc-&gt;sc_rtlist);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * bridge_rthash_delayed_resize:
 *
 *	Resize the routing table hash on a delayed thread call.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_rthash_delayed_resize</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	u_int32_t new_rthash_size;
	<span class="enscript-type">struct</span> _bridge_rtnode_list *new_rthash = NULL;
	<span class="enscript-type">struct</span> _bridge_rtnode_list *old_rthash = NULL;
	u_int32_t i;
	<span class="enscript-type">struct</span> bridge_rtnode *brt;
	<span class="enscript-type">int</span> error = 0;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	<span class="enscript-comment">/*
	 * Four entries per hash bucket is our ideal load factor
	 */</span>
	<span class="enscript-keyword">if</span> (sc-&gt;sc_brtcnt &lt; sc-&gt;sc_rthash_size * 4)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * Doubling the number of hash buckets may be too simplistic
	 * especially when facing a spike of new entries
	 */</span>
	new_rthash_size = sc-&gt;sc_rthash_size * 2;

	sc-&gt;sc_flags |= SCF_RESIZING;
	BRIDGE_UNLOCK(sc);

	new_rthash = _MALLOC(<span class="enscript-keyword">sizeof</span> (*sc-&gt;sc_rthash) * new_rthash_size,
	    M_DEVBUF, M_WAITOK | M_ZERO);

	BRIDGE_LOCK(sc);
	sc-&gt;sc_flags &amp;= ~SCF_RESIZING;

	<span class="enscript-keyword">if</span> (new_rthash == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> ((sc-&gt;sc_flags &amp; SCF_DETACHING)) {
		error = ENODEV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * Fail safe from here on
	 */</span>
	old_rthash = sc-&gt;sc_rthash;
	sc-&gt;sc_rthash = new_rthash;
	sc-&gt;sc_rthash_size = new_rthash_size;

	<span class="enscript-comment">/*
	 * Get a new key to force entries to be shuffled around to reduce
	 * the likelihood they will land in the same buckets
	 */</span>
	sc-&gt;sc_rthash_key = RandomULong();

	<span class="enscript-keyword">for</span> (i = 0; i &lt; sc-&gt;sc_rthash_size; i++)
		LIST_INIT(&amp;sc-&gt;sc_rthash[i]);

		LIST_FOREACH(brt, &amp;sc-&gt;sc_rtlist, brt_list) {
		LIST_REMOVE(brt, brt_hash);
		(<span class="enscript-type">void</span>) bridge_rtnode_hash(sc, brt);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error == 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
		<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_RT_TABLE)
			printf(<span class="enscript-string">&quot;%s: %s new size %u\n&quot;</span>, __func__,
			    sc-&gt;sc_ifp-&gt;if_xname, sc-&gt;sc_rthash_size);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>
		<span class="enscript-keyword">if</span> (old_rthash)
			_FREE(old_rthash, M_DEVBUF);
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
		printf(<span class="enscript-string">&quot;%s: %s failed %d\n&quot;</span>, __func__,
		    sc-&gt;sc_ifp-&gt;if_xname, error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>
		<span class="enscript-keyword">if</span> (new_rthash != NULL)
			_FREE(new_rthash, M_DEVBUF);
	}
}

<span class="enscript-comment">/*
 * Resize the number of hash buckets based on the load factor
 * Currently only grow
 * Failing to resize the hash table is not fatal
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_rthash_resize</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	BRIDGE_LOCK_ASSERT_HELD(sc);

	<span class="enscript-keyword">if</span> ((sc-&gt;sc_flags &amp; SCF_DETACHING) || (sc-&gt;sc_flags &amp; SCF_RESIZING))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Four entries per hash bucket is our ideal load factor
	 */</span>
	<span class="enscript-keyword">if</span> (sc-&gt;sc_brtcnt &lt; sc-&gt;sc_rthash_size * 4)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-comment">/*
	 * Hard limit on the size of the routing hash table
	 */</span>
	<span class="enscript-keyword">if</span> (sc-&gt;sc_rthash_size &gt;= bridge_rtable_hash_size_max)
		<span class="enscript-keyword">return</span>;

	sc-&gt;sc_resize_call.bdc_sc = sc;
	sc-&gt;sc_resize_call.bdc_func = bridge_rthash_delayed_resize;
	bridge_schedule_delayed_call(&amp;sc-&gt;sc_resize_call);
}

<span class="enscript-comment">/*
 * bridge_rtable_fini:
 *
 *	Deconstruct the route table for this bridge.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_rtable_fini</span>(<span class="enscript-type">struct</span> bridge_softc *sc)
{
	KASSERT(sc-&gt;sc_brtcnt == 0,
	    (<span class="enscript-string">&quot;%s: %d bridge routes referenced&quot;</span>, __func__, sc-&gt;sc_brtcnt));
	<span class="enscript-keyword">if</span> (sc-&gt;sc_rthash) {
		_FREE(sc-&gt;sc_rthash, M_DEVBUF);
		sc-&gt;sc_rthash = NULL;
	}
}

<span class="enscript-comment">/*
 * The following hash function is adapted from &quot;Hash Functions&quot; by Bob Jenkins
 * (&quot;Algorithm Alley&quot;, Dr. Dobbs Journal, September 1997).
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">mix</span>(a, b, c)							\
<span class="enscript-keyword">do</span> {									\
	a -= b; a -= c; a ^= (c &gt;&gt; 13);					\
	b -= c; b -= a; b ^= (a &lt;&lt; 8);					\
	c -= a; c -= b; c ^= (b &gt;&gt; 13);					\
	a -= b; a -= c; a ^= (c &gt;&gt; 12);					\
	b -= c; b -= a; b ^= (a &lt;&lt; 16);					\
	c -= a; c -= b; c ^= (b &gt;&gt; 5);					\
	a -= b; a -= c; a ^= (c &gt;&gt; 3);					\
	b -= c; b -= a; b ^= (a &lt;&lt; 10);					\
	c -= a; c -= b; c ^= (b &gt;&gt; 15);					\
} <span class="enscript-keyword">while</span> (<span class="enscript-comment">/*CONSTCOND*/</span>0)

<span class="enscript-type">static</span> __inline uint32_t
<span class="enscript-function-name">bridge_rthash</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">const</span> uint8_t *addr)
{
	uint32_t a = 0x9e3779b9, b = 0x9e3779b9, c = sc-&gt;sc_rthash_key;

	b += addr[5] &lt;&lt; 8;
	b += addr[4];
	a += addr[3] &lt;&lt; 24;
	a += addr[2] &lt;&lt; 16;
	a += addr[1] &lt;&lt; 8;
	a += addr[0];

	mix(a, b, c);

	<span class="enscript-keyword">return</span> (c &amp; BRIDGE_RTHASH_MASK(sc));
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">mix</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_rtnode_addr_cmp</span>(<span class="enscript-type">const</span> uint8_t *a, <span class="enscript-type">const</span> uint8_t *b)
{
	<span class="enscript-type">int</span> i, d;

	<span class="enscript-keyword">for</span> (i = 0, d = 0; i &lt; ETHER_ADDR_LEN &amp;&amp; d == 0; i++) {
		d = ((<span class="enscript-type">int</span>)a[i]) - ((<span class="enscript-type">int</span>)b[i]);
	}

	<span class="enscript-keyword">return</span> (d);
}

<span class="enscript-comment">/*
 * bridge_rtnode_lookup:
 *
 *	Look up a bridge route node for the specified destination. Compare the
 *	vlan id or if zero then just return the first match.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> bridge_rtnode *
<span class="enscript-function-name">bridge_rtnode_lookup</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">const</span> uint8_t *addr,
	uint16_t vlan)
{
	<span class="enscript-type">struct</span> bridge_rtnode *brt;
	uint32_t hash;
	<span class="enscript-type">int</span> dir;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	hash = bridge_rthash(sc, addr);
	LIST_FOREACH(brt, &amp;sc-&gt;sc_rthash[hash], brt_hash) {
		dir = bridge_rtnode_addr_cmp(addr, brt-&gt;brt_addr);
		<span class="enscript-keyword">if</span> (dir == 0 &amp;&amp; (brt-&gt;brt_vlan == vlan || vlan == 0))
			<span class="enscript-keyword">return</span> (brt);
		<span class="enscript-keyword">if</span> (dir &gt; 0)
			<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * bridge_rtnode_hash:
 *
 *	Insert the specified bridge node into the route hash table.
 *	This is used when adding a new node or to rehash when resizing
 *	the hash table
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_rtnode_hash</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">struct</span> bridge_rtnode *brt)
{
	<span class="enscript-type">struct</span> bridge_rtnode *lbrt;
	uint32_t hash;
	<span class="enscript-type">int</span> dir;

	BRIDGE_LOCK_ASSERT_HELD(sc);

	hash = bridge_rthash(sc, brt-&gt;brt_addr);

	lbrt = LIST_FIRST(&amp;sc-&gt;sc_rthash[hash]);
	<span class="enscript-keyword">if</span> (lbrt == NULL) {
		LIST_INSERT_HEAD(&amp;sc-&gt;sc_rthash[hash], brt, brt_hash);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">do</span> {
		dir = bridge_rtnode_addr_cmp(brt-&gt;brt_addr, lbrt-&gt;brt_addr);
		<span class="enscript-keyword">if</span> (dir == 0 &amp;&amp; brt-&gt;brt_vlan == lbrt-&gt;brt_vlan) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
			<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_RT_TABLE)
				printf(<span class="enscript-string">&quot;%s: %s EEXIST &quot;</span>
				    <span class="enscript-string">&quot;%02x:%02x:%02x:%02x:%02x:%02x\n&quot;</span>,
				    __func__, sc-&gt;sc_ifp-&gt;if_xname,
				    brt-&gt;brt_addr[0], brt-&gt;brt_addr[1],
				    brt-&gt;brt_addr[2], brt-&gt;brt_addr[3],
				    brt-&gt;brt_addr[4], brt-&gt;brt_addr[5]);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">return</span> (EEXIST);
		}
		<span class="enscript-keyword">if</span> (dir &gt; 0) {
			LIST_INSERT_BEFORE(lbrt, brt, brt_hash);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (LIST_NEXT(lbrt, brt_hash) == NULL) {
			LIST_INSERT_AFTER(lbrt, brt, brt_hash);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		lbrt = LIST_NEXT(lbrt, brt_hash);
	} <span class="enscript-keyword">while</span> (lbrt != NULL);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_RT_TABLE)
		printf(<span class="enscript-string">&quot;%s: %s impossible %02x:%02x:%02x:%02x:%02x:%02x\n&quot;</span>,
		    __func__, sc-&gt;sc_ifp-&gt;if_xname,
		    brt-&gt;brt_addr[0], brt-&gt;brt_addr[1], brt-&gt;brt_addr[2],
		    brt-&gt;brt_addr[3], brt-&gt;brt_addr[4], brt-&gt;brt_addr[5]);
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * bridge_rtnode_insert:
 *
 *	Insert the specified bridge node into the route table.  We
 *	assume the entry is not already in the table.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_rtnode_insert</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">struct</span> bridge_rtnode *brt)
{
	<span class="enscript-type">int</span> error;

	error = bridge_rtnode_hash(sc, brt);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);

	LIST_INSERT_HEAD(&amp;sc-&gt;sc_rtlist, brt, brt_list);
	sc-&gt;sc_brtcnt++;

	bridge_rthash_resize(sc);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * bridge_rtnode_destroy:
 *
 *	Destroy a bridge rtnode.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_rtnode_destroy</span>(<span class="enscript-type">struct</span> bridge_softc *sc, <span class="enscript-type">struct</span> bridge_rtnode *brt)
{
	BRIDGE_LOCK_ASSERT_HELD(sc);

	LIST_REMOVE(brt, brt_hash);

	LIST_REMOVE(brt, brt_list);
	sc-&gt;sc_brtcnt--;
	brt-&gt;brt_dst-&gt;bif_addrcnt--;
	zfree(bridge_rtnode_pool, brt);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
<span class="enscript-comment">/*
 * bridge_rtable_expire:
 *
 *	Set the expiry time for all routes on an interface.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_rtable_expire</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> age)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = ifp-&gt;if_bridge;
	<span class="enscript-type">struct</span> bridge_rtnode *brt;

	BRIDGE_LOCK(sc);

	<span class="enscript-comment">/*
	 * If the age is zero then flush, otherwise set all the expiry times to
	 * age for the interface
	 */</span>
	<span class="enscript-keyword">if</span> (age == 0) {
		bridge_rtdelete(sc, ifp, IFBF_FLUSHDYN);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> now;

		now = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) net_uptime();

		LIST_FOREACH(brt, &amp;sc-&gt;sc_rtlist, brt_list) {
			<span class="enscript-comment">/* Cap the expiry time to 'age' */</span>
			<span class="enscript-keyword">if</span> (brt-&gt;brt_ifp == ifp &amp;&amp;
			    brt-&gt;brt_expire &gt; now + age &amp;&amp;
			    (brt-&gt;brt_flags &amp; IFBAF_TYPEMASK) == IFBAF_DYNAMIC)
				brt-&gt;brt_expire = now + age;
		}
	}
	BRIDGE_UNLOCK(sc);
}

<span class="enscript-comment">/*
 * bridge_state_change:
 *
 *	Callback from the bridgestp code when a port changes states.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_state_change</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> state)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = ifp-&gt;if_bridge;
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *stpstates[] = {
		<span class="enscript-string">&quot;disabled&quot;</span>,
		<span class="enscript-string">&quot;listening&quot;</span>,
		<span class="enscript-string">&quot;learning&quot;</span>,
		<span class="enscript-string">&quot;forwarding&quot;</span>,
		<span class="enscript-string">&quot;blocking&quot;</span>,
		<span class="enscript-string">&quot;discarding&quot;</span>
	};

	<span class="enscript-keyword">if</span> (log_stp)
		log(LOG_NOTICE, <span class="enscript-string">&quot;%s: state changed to %s on %s\n&quot;</span>,
		    sc-&gt;sc_ifp-&gt;if_xname,
		    stpstates[state], ifp-&gt;if_xname);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PFIL_HOOKS</span>
<span class="enscript-comment">/*
 * Send bridge packets through pfil if they are one of the types pfil can deal
 * with, or if they are ARP or REVARP.  (pfil will pass ARP and REVARP without
 * question.) If *bifp or *ifp are NULL then packet filtering is skipped for
 * that interface.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_pfil</span>(<span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">struct</span> ifnet *bifp, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> dir)
{
	<span class="enscript-type">int</span> snap, error, i, hlen;
	<span class="enscript-type">struct</span> ether_header *eh1, eh2;
	<span class="enscript-type">struct</span> ip_fw_args args;
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">struct</span> llc llc1;
	u_int16_t ether_type;

	snap = 0;
	error = -1;	<span class="enscript-comment">/* Default error if not error == 0 */</span>

#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/* we may return with the IP fields swapped, ensure its not shared */</span>
	KASSERT(M_WRITABLE(*mp), (<span class="enscript-string">&quot;%s: modifying a shared mbuf&quot;</span>, __func__));
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (pfil_bridge == 0 &amp;&amp; pfil_member == 0 &amp;&amp; pfil_ipfw == 0)
		<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* filtering is disabled */</span>

	i = min((*mp)-&gt;m_pkthdr.len, max_protohdr);
	<span class="enscript-keyword">if</span> ((*mp)-&gt;m_len &lt; i) {
		*mp = m_pullup(*mp, i);
		<span class="enscript-keyword">if</span> (*mp == NULL) {
			printf(<span class="enscript-string">&quot;%s: m_pullup failed\n&quot;</span>, __func__);
			<span class="enscript-keyword">return</span> (-1);
		}
	}

	eh1 = mtod(*mp, <span class="enscript-type">struct</span> ether_header *);
	ether_type = ntohs(eh1-&gt;ether_type);

	<span class="enscript-comment">/*
	 * Check for SNAP/LLC.
	 */</span>
	<span class="enscript-keyword">if</span> (ether_type &lt; ETHERMTU) {
		<span class="enscript-type">struct</span> llc *llc2 = (<span class="enscript-type">struct</span> llc *)(eh1 + 1);

		<span class="enscript-keyword">if</span> ((*mp)-&gt;m_len &gt;= ETHER_HDR_LEN + 8 &amp;&amp;
		    llc2-&gt;llc_dsap == LLC_SNAP_LSAP &amp;&amp;
		    llc2-&gt;llc_ssap == LLC_SNAP_LSAP &amp;&amp;
		    llc2-&gt;llc_control == LLC_UI) {
			ether_type = htons(llc2-&gt;llc_un.type_snap.ether_type);
			snap = 1;
		}
	}

	<span class="enscript-comment">/*
	 * If we're trying to filter bridge traffic, don't look at anything
	 * other than IP and ARP traffic.  If the filter doesn't understand
	 * IPv6, don't allow IPv6 through the bridge either.  This is lame
	 * since if we really wanted, say, an AppleTalk filter, we are hosed,
	 * but of course we don't have an AppleTalk filter to begin with.
	 * (Note that since pfil doesn't understand ARP it will pass *ALL*
	 * ARP traffic.)
	 */</span>
	<span class="enscript-keyword">switch</span> (ether_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ETHERTYPE_ARP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ETHERTYPE_REVARP</span>:
			<span class="enscript-keyword">if</span> (pfil_ipfw_arp == 0)
				<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* Automatically pass */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">ETHERTYPE_IP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ETHERTYPE_IPV6</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/*
			 * Check to see if the user wants to pass non-ip
			 * packets, these will not be checked by pfil(9) and
			 * passed unconditionally so the default is to drop.
			 */</span>
			<span class="enscript-keyword">if</span> (pfil_onlyip)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* Strip off the Ethernet header and keep a copy. */</span>
	m_copydata(*mp, 0, ETHER_HDR_LEN, (caddr_t)&amp;eh2);
	m_adj(*mp, ETHER_HDR_LEN);

	<span class="enscript-comment">/* Strip off snap header, if present */</span>
	<span class="enscript-keyword">if</span> (snap) {
		m_copydata(*mp, 0, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> llc), (caddr_t)&amp;llc1);
		m_adj(*mp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> llc));
	}

	<span class="enscript-comment">/*
	 * Check the IP header for alignment and errors
	 */</span>
	<span class="enscript-keyword">if</span> (dir == PFIL_IN) {
		<span class="enscript-keyword">switch</span> (ether_type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ETHERTYPE_IP</span>:
				error = bridge_ip_checkbasic(mp);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ETHERTYPE_IPV6</span>:
				error = bridge_ip6_checkbasic(mp);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			<span class="enscript-reference">default</span>:
				error = 0;
		}
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (IPFW_LOADED &amp;&amp; pfil_ipfw != 0 &amp;&amp; dir == PFIL_OUT &amp;&amp; ifp != NULL) {
		error = -1;
		args.rule = ip_dn_claim_rule(*mp);
		<span class="enscript-keyword">if</span> (args.rule != NULL &amp;&amp; fw_one_pass)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ipfwpass</span>; <span class="enscript-comment">/* packet already partially processed */</span>

		args.m = *mp;
		args.oif = ifp;
		args.next_hop = NULL;
		args.eh = &amp;eh2;
		args.inp = NULL;	<span class="enscript-comment">/* used by ipfw uid/gid/jail rules */</span>
		i = ip_fw_chk_ptr(&amp;args);
		*mp = args.m;

		<span class="enscript-keyword">if</span> (*mp == NULL)
			<span class="enscript-keyword">return</span> (error);

		<span class="enscript-keyword">if</span> (DUMMYNET_LOADED &amp;&amp; (i == IP_FW_DUMMYNET)) {

			<span class="enscript-comment">/* put the Ethernet header back on */</span>
			M_PREPEND(*mp, ETHER_HDR_LEN, M_DONTWAIT, 0);
			<span class="enscript-keyword">if</span> (*mp == NULL)
				<span class="enscript-keyword">return</span> (error);
			bcopy(&amp;eh2, mtod(*mp, caddr_t), ETHER_HDR_LEN);

			<span class="enscript-comment">/*
			 * Pass the pkt to dummynet, which consumes it. The
			 * packet will return to us via bridge_dummynet().
			 */</span>
			args.oif = ifp;
			ip_dn_io_ptr(mp, DN_TO_IFB_FWD, &amp;args, DN_CLIENT_IPFW);
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-keyword">if</span> (i != IP_FW_PASS) <span class="enscript-comment">/* drop */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

<span class="enscript-reference">ipfwpass</span>:
	error = 0;

	<span class="enscript-comment">/*
	 * Run the packet through pfil
	 */</span>
	<span class="enscript-keyword">switch</span> (ether_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ETHERTYPE_IP</span>:
		<span class="enscript-comment">/*
		 * before calling the firewall, swap fields the same as
		 * IP does. here we assume the header is contiguous
		 */</span>
		ip = mtod(*mp, <span class="enscript-type">struct</span> ip *);

		ip-&gt;ip_len = ntohs(ip-&gt;ip_len);
		ip-&gt;ip_off = ntohs(ip-&gt;ip_off);

		<span class="enscript-comment">/*
		 * Run pfil on the member interface and the bridge, both can
		 * be skipped by clearing pfil_member or pfil_bridge.
		 *
		 * Keep the order:
		 *   in_if -&gt; bridge_if -&gt; out_if
		 */</span>
		<span class="enscript-keyword">if</span> (pfil_bridge &amp;&amp; dir == PFIL_OUT &amp;&amp; bifp != NULL)
			error = pfil_run_hooks(&amp;inet_pfil_hook, mp, bifp,
			    dir, NULL);

		<span class="enscript-keyword">if</span> (*mp == NULL || error != 0) <span class="enscript-comment">/* filter may consume */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (pfil_member &amp;&amp; ifp != NULL)
			error = pfil_run_hooks(&amp;inet_pfil_hook, mp, ifp,
			    dir, NULL);

		<span class="enscript-keyword">if</span> (*mp == NULL || error != 0) <span class="enscript-comment">/* filter may consume */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (pfil_bridge &amp;&amp; dir == PFIL_IN &amp;&amp; bifp != NULL)
			error = pfil_run_hooks(&amp;inet_pfil_hook, mp, bifp,
			    dir, NULL);

		<span class="enscript-keyword">if</span> (*mp == NULL || error != 0) <span class="enscript-comment">/* filter may consume */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* check if we need to fragment the packet */</span>
		<span class="enscript-keyword">if</span> (pfil_member &amp;&amp; ifp != NULL &amp;&amp; dir == PFIL_OUT) {
			i = (*mp)-&gt;m_pkthdr.len;
			<span class="enscript-keyword">if</span> (i &gt; ifp-&gt;if_mtu) {
				error = bridge_fragment(ifp, *mp, &amp;eh2, snap,
				    &amp;llc1);
				<span class="enscript-keyword">return</span> (error);
			}
		}

		<span class="enscript-comment">/* Recalculate the ip checksum and restore byte ordering */</span>
		ip = mtod(*mp, <span class="enscript-type">struct</span> ip *);
		hlen = ip-&gt;ip_hl &lt;&lt; 2;
		<span class="enscript-keyword">if</span> (hlen &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		<span class="enscript-keyword">if</span> (hlen &gt; (*mp)-&gt;m_len) {
			<span class="enscript-keyword">if</span> ((*mp = m_pullup(*mp, hlen)) == 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			ip = mtod(*mp, <span class="enscript-type">struct</span> ip *);
			<span class="enscript-keyword">if</span> (ip == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		ip-&gt;ip_len = htons(ip-&gt;ip_len);
		ip-&gt;ip_off = htons(ip-&gt;ip_off);
		ip-&gt;ip_sum = 0;
		<span class="enscript-keyword">if</span> (hlen == <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip))
			ip-&gt;ip_sum = in_cksum_hdr(ip);
		<span class="enscript-keyword">else</span>
			ip-&gt;ip_sum = in_cksum(*mp, hlen);

		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ETHERTYPE_IPV6</span>:
		<span class="enscript-keyword">if</span> (pfil_bridge &amp;&amp; dir == PFIL_OUT &amp;&amp; bifp != NULL)
			error = pfil_run_hooks(&amp;inet6_pfil_hook, mp, bifp,
			    dir, NULL);

		<span class="enscript-keyword">if</span> (*mp == NULL || error != 0) <span class="enscript-comment">/* filter may consume */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (pfil_member &amp;&amp; ifp != NULL)
			error = pfil_run_hooks(&amp;inet6_pfil_hook, mp, ifp,
			    dir, NULL);

		<span class="enscript-keyword">if</span> (*mp == NULL || error != 0) <span class="enscript-comment">/* filter may consume */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (pfil_bridge &amp;&amp; dir == PFIL_IN &amp;&amp; bifp != NULL)
			error = pfil_run_hooks(&amp;inet6_pfil_hook, mp, bifp,
			    dir, NULL);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
	<span class="enscript-reference">default</span>:
		error = 0;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (*mp == NULL)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	error = -1;

	<span class="enscript-comment">/*
	 * Finally, put everything back the way it was and return
	 */</span>
	<span class="enscript-keyword">if</span> (snap) {
		M_PREPEND(*mp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> llc), M_DONTWAIT, 0);
		<span class="enscript-keyword">if</span> (*mp == NULL)
			<span class="enscript-keyword">return</span> (error);
		bcopy(&amp;llc1, mtod(*mp, caddr_t), <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> llc));
	}

	M_PREPEND(*mp, ETHER_HDR_LEN, M_DONTWAIT, 0);
	<span class="enscript-keyword">if</span> (*mp == NULL)
		<span class="enscript-keyword">return</span> (error);
	bcopy(&amp;eh2, mtod(*mp, caddr_t), ETHER_HDR_LEN);

	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">bad</span>:
	m_freem(*mp);
	*mp = NULL;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Perform basic checks on header size since
 * pfil assumes ip_input has already processed
 * it for it.  Cut-and-pasted from ip_input.c.
 * Given how simple the IPv6 version is,
 * does the IPv4 version really need to be
 * this complicated?
 *
 * XXX Should we update ipstat here, or not?
 * XXX Right now we update ipstat but not
 * XXX csum_counter.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ip_checkbasic</span>(<span class="enscript-type">struct</span> mbuf **mp)
{
	<span class="enscript-type">struct</span> mbuf *m = *mp;
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">int</span> len, hlen;
	u_short sum;

	<span class="enscript-keyword">if</span> (*mp == NULL)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">if</span> (IP_HDR_ALIGNED_P(mtod(m, caddr_t)) == 0) {
		<span class="enscript-comment">/* max_linkhdr is already rounded up to nearest 4-byte */</span>
		<span class="enscript-keyword">if</span> ((m = m_copyup(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip),
		    max_linkhdr)) == NULL) {
			<span class="enscript-comment">/* XXXJRT new stat, please */</span>
			ipstat.ips_toosmall++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (__predict_false(m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip))) {
		<span class="enscript-keyword">if</span> ((m = m_pullup(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip))) == NULL) {
			ipstat.ips_toosmall++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	<span class="enscript-keyword">if</span> (ip == NULL) <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (ip-&gt;ip_v != IPVERSION) {
		ipstat.ips_badvers++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	hlen = ip-&gt;ip_hl &lt;&lt; 2;
	<span class="enscript-keyword">if</span> (hlen &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip)) { <span class="enscript-comment">/* minimum header length */</span>
		ipstat.ips_badhlen++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">if</span> (hlen &gt; m-&gt;m_len) {
		<span class="enscript-keyword">if</span> ((m = m_pullup(m, hlen)) == 0) {
			ipstat.ips_badhlen++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		<span class="enscript-keyword">if</span> (ip == NULL) <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_IP_CHECKED) {
		sum = !(m-&gt;m_pkthdr.csum_flags &amp; CSUM_IP_VALID);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (hlen == <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip)) {
			sum = in_cksum_hdr(ip);
		} <span class="enscript-keyword">else</span> {
			sum = in_cksum(m, hlen);
		}
	}
	<span class="enscript-keyword">if</span> (sum) {
		ipstat.ips_badsum++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* Retrieve the packet length. */</span>
	len = ntohs(ip-&gt;ip_len);

	<span class="enscript-comment">/*
	 * Check for additional length bogosity
	 */</span>
	<span class="enscript-keyword">if</span> (len &lt; hlen) {
		ipstat.ips_badlen++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/*
	 * Check that the amount of data in the buffers
	 * is as at least much as the IP header would have us expect.
	 * Drop packet if shorter than we expect.
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; len) {
		ipstat.ips_tooshort++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* Checks out, proceed */</span>
	*mp = m;
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">bad</span>:
	*mp = m;
	<span class="enscript-keyword">return</span> (-1);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-comment">/*
 * Same as above, but for IPv6.
 * Cut-and-pasted from ip6_input.c.
 * XXX Should we update ip6stat, or not?
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_ip6_checkbasic</span>(<span class="enscript-type">struct</span> mbuf **mp)
{
	<span class="enscript-type">struct</span> mbuf *m = *mp;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;

	<span class="enscript-comment">/*
	 * If the IPv6 header is not aligned, slurp it up into a new
	 * mbuf with space for link headers, in the event we forward
	 * it.  Otherwise, if it is aligned, make sure the entire base
	 * IPv6 header is in the first mbuf of the chain.
	 */</span>
	<span class="enscript-keyword">if</span> (IP6_HDR_ALIGNED_P(mtod(m, caddr_t)) == 0) {
		<span class="enscript-type">struct</span> ifnet *inifp = m-&gt;m_pkthdr.rcvif;
		<span class="enscript-comment">/* max_linkhdr is already rounded up to nearest 4-byte */</span>
		<span class="enscript-keyword">if</span> ((m = m_copyup(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr),
		    max_linkhdr)) == NULL) {
			<span class="enscript-comment">/* XXXJRT new stat, please */</span>
			ip6stat.ip6s_toosmall++;
			in6_ifstat_inc(inifp, ifs6_in_hdrerr);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (__predict_false(m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr))) {
		<span class="enscript-type">struct</span> ifnet *inifp = m-&gt;m_pkthdr.rcvif;
		<span class="enscript-keyword">if</span> ((m = m_pullup(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr))) == NULL) {
			ip6stat.ip6s_toosmall++;
			in6_ifstat_inc(inifp, ifs6_in_hdrerr);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

	<span class="enscript-keyword">if</span> ((ip6-&gt;ip6_vfc &amp; IPV6_VERSION_MASK) != IPV6_VERSION) {
		ip6stat.ip6s_badvers++;
		in6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_hdrerr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* Checks out, proceed */</span>
	*mp = m;
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">bad</span>:
	*mp = m;
	<span class="enscript-keyword">return</span> (-1);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-comment">/*
 * bridge_fragment:
 *
 *	Return a fragmented mbuf chain.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_fragment</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> ether_header *eh,
	<span class="enscript-type">int</span> snap, <span class="enscript-type">struct</span> llc *llc)
{
	<span class="enscript-type">struct</span> mbuf *m0;
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">int</span> error = -1;

	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) &amp;&amp;
	    (m = m_pullup(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip))) == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);

	error = ip_fragment(ip, &amp;m, ifp-&gt;if_mtu, ifp-&gt;if_hwassist,
	    CSUM_DELAY_IP);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* walk the chain and re-add the Ethernet header */</span>
	<span class="enscript-keyword">for</span> (m0 = m; m0; m0 = m0-&gt;m_nextpkt) {
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-keyword">if</span> (snap) {
				M_PREPEND(m0, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> llc), M_DONTWAIT, 0);
				<span class="enscript-keyword">if</span> (m0 == NULL) {
					error = ENOBUFS;
					<span class="enscript-keyword">continue</span>;
				}
				bcopy(llc, mtod(m0, caddr_t),
				    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> llc));
			}
			M_PREPEND(m0, ETHER_HDR_LEN, M_DONTWAIT, 0);
			<span class="enscript-keyword">if</span> (m0 == NULL) {
				error = ENOBUFS;
				<span class="enscript-keyword">continue</span>;
			}
			bcopy(eh, mtod(m0, caddr_t), ETHER_HDR_LEN);
		} <span class="enscript-keyword">else</span> {
			m_freem(m);
		}
	}

	<span class="enscript-keyword">if</span> (error == 0)
		ipstat.ips_fragmented++;

	<span class="enscript-keyword">return</span> (error);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (m != NULL)
		m_freem(m);
	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFIL_HOOKS */</span>

<span class="enscript-comment">/*
 * bridge_set_bpf_tap:
 *
 *	Sets ups the BPF callbacks.
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">bridge_set_bpf_tap</span>(ifnet_t ifp, bpf_tap_mode mode, bpf_packet_func bpf_callback)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = (<span class="enscript-type">struct</span> bridge_softc *)ifnet_softc(ifp);

	<span class="enscript-comment">/* TBD locking */</span>
	<span class="enscript-keyword">if</span> (sc == NULL || (sc-&gt;sc_flags &amp; SCF_DETACHING)) {
		<span class="enscript-keyword">return</span> (ENODEV);
	}

	<span class="enscript-keyword">switch</span> (mode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BPF_TAP_DISABLE</span>:
			sc-&gt;sc_bpf_input = sc-&gt;sc_bpf_output = NULL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BPF_TAP_INPUT</span>:
			sc-&gt;sc_bpf_input = bpf_callback;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BPF_TAP_OUTPUT</span>:
			sc-&gt;sc_bpf_output = bpf_callback;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BPF_TAP_INPUT_OUTPUT</span>:
			sc-&gt;sc_bpf_input = sc-&gt;sc_bpf_output = bpf_callback;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * bridge_detach:
 *
 *	Callback when interface has been detached.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_detach</span>(ifnet_t ifp)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = (<span class="enscript-type">struct</span> bridge_softc *)ifnet_softc(ifp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGESTP</span>
	bstp_detach(&amp;sc-&gt;sc_stp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGESTP */</span>

	<span class="enscript-comment">/* Tear down the routing table. */</span>
	bridge_rtable_fini(sc);

	lck_mtx_lock(&amp;bridge_list_mtx);
	LIST_REMOVE(sc, sc_list);
	lck_mtx_unlock(&amp;bridge_list_mtx);

	ifnet_release(ifp);

	lck_mtx_destroy(&amp;sc-&gt;sc_mtx, bridge_lock_grp);

	_FREE(sc, M_DEVBUF);
}

<span class="enscript-comment">/*
 * bridge_bpf_input:
 *
 *	Invoke the input BPF callback if enabled
 */</span>
__private_extern__ errno_t
<span class="enscript-function-name">bridge_bpf_input</span>(ifnet_t ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = (<span class="enscript-type">struct</span> bridge_softc *)ifnet_softc(ifp);

	<span class="enscript-keyword">if</span> (sc-&gt;sc_bpf_input) {
		<span class="enscript-keyword">if</span> (mbuf_pkthdr_rcvif(m) != ifp) {
			printf(<span class="enscript-string">&quot;%s: rcvif: 0x%llx != ifp 0x%llx\n&quot;</span>, __func__,
			    (uint64_t)VM_KERNEL_ADDRPERM(mbuf_pkthdr_rcvif(m)),
			    (uint64_t)VM_KERNEL_ADDRPERM(ifp));
		}
		(*sc-&gt;sc_bpf_input)(ifp, m);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * bridge_bpf_output:
 *
 *	Invoke the output BPF callback if enabled
 */</span>
__private_extern__ errno_t
<span class="enscript-function-name">bridge_bpf_output</span>(ifnet_t ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> bridge_softc *sc = (<span class="enscript-type">struct</span> bridge_softc *)ifnet_softc(ifp);

	<span class="enscript-keyword">if</span> (sc-&gt;sc_bpf_output) {
		(*sc-&gt;sc_bpf_output)(ifp, m);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * bridge_link_event:
 *
 *	Report a data link event on an interface
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bridge_link_event</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t event_code)
{
	<span class="enscript-type">struct</span> {
		<span class="enscript-type">struct</span> kern_event_msg	header;
		u_int32_t		unit;
		<span class="enscript-type">char</span>			if_name[IFNAMSIZ];
	} event;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BRIDGE_DEBUG</span>
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_LIFECYCLE)
		printf(<span class="enscript-string">&quot;%s: %s event_code %u - %s\n&quot;</span>, __func__, ifp-&gt;if_xname,
		    event_code, dlil_kev_dl_code_str(event_code));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BRIDGE_DEBUG */</span>

	bzero(&amp;event, <span class="enscript-keyword">sizeof</span> (event));
	event.header.total_size		= <span class="enscript-keyword">sizeof</span> (event);
	event.header.vendor_code	= KEV_VENDOR_APPLE;
	event.header.kev_class		= KEV_NETWORK_CLASS;
	event.header.kev_subclass	= KEV_DL_SUBCLASS;
	event.header.event_code		= event_code;
	event.header.event_data[0]	= ifnet_family(ifp);
	event.unit			= (u_int32_t)ifnet_unit(ifp);
	strlcpy(event.if_name, ifnet_name(ifp), IFNAMSIZ);
	ifnet_event(ifp, &amp;event.header);
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BRIDGE_HF_DROP</span>(reason, func, line) { \
	bridge_hostfilter_stats.reason++; \
	<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_HOSTFILTER) \
		printf(<span class="enscript-string">&quot;%s.%d&quot;</span> #reason, func, line); \
	error = EINVAL; \
}

<span class="enscript-comment">/*
 * Make sure this is a DHCP or Bootp request that match the host filter
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_dhcp_filter</span>(<span class="enscript-type">struct</span> bridge_iflist *bif, <span class="enscript-type">struct</span> mbuf *m, size_t offset)
{
	<span class="enscript-type">int</span> error = EINVAL;
	<span class="enscript-type">struct</span> dhcp dhcp;

	<span class="enscript-comment">/*
	 * Note: We use the dhcp structure because bootp structure definition
	 * is larger and some vendors do not pad the request
	 */</span>
	error = mbuf_copydata(m, offset, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> dhcp), &amp;dhcp);
	<span class="enscript-keyword">if</span> (error != 0) {
		BRIDGE_HF_DROP(brhf_dhcp_too_small, __func__, __LINE__);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (dhcp.dp_op != BOOTREQUEST) {
		BRIDGE_HF_DROP(brhf_dhcp_bad_op, __func__, __LINE__);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * The hardware address must be an exact match
	 */</span>
	<span class="enscript-keyword">if</span> (dhcp.dp_htype != ARPHRD_ETHER) {
		BRIDGE_HF_DROP(brhf_dhcp_bad_htype, __func__, __LINE__);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (dhcp.dp_hlen != ETHER_ADDR_LEN) {
		BRIDGE_HF_DROP(brhf_dhcp_bad_hlen, __func__, __LINE__);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (bcmp(dhcp.dp_chaddr, bif-&gt;bif_hf_hwsrc,
	    ETHER_ADDR_LEN) != 0) {
		BRIDGE_HF_DROP(brhf_dhcp_bad_chaddr, __func__, __LINE__);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * Client address must match the host address or be not specified
	 */</span>
	<span class="enscript-keyword">if</span> (dhcp.dp_ciaddr.s_addr != bif-&gt;bif_hf_ipsrc.s_addr &amp;&amp;
	    dhcp.dp_ciaddr.s_addr != INADDR_ANY) {
		BRIDGE_HF_DROP(brhf_dhcp_bad_ciaddr, __func__, __LINE__);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	error = 0;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bridge_host_filter</span>(<span class="enscript-type">struct</span> bridge_iflist *bif, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">int</span> error = EINVAL;
	<span class="enscript-type">struct</span> ether_header *eh;
	<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in_addr inaddr_any = { .s_addr = INADDR_ANY };

	<span class="enscript-comment">/*
	 * Check the Ethernet header is large enough
	 */</span>
	<span class="enscript-keyword">if</span> (mbuf_pkthdr_len(m) &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header)) {
		BRIDGE_HF_DROP(brhf_ether_too_small, __func__, __LINE__);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (mbuf_len(m) &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header) &amp;&amp;
	    mbuf_pullup(&amp;m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header)) != 0) {
		BRIDGE_HF_DROP(brhf_ether_pullup_failed, __func__, __LINE__);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	eh = mtod(m, <span class="enscript-type">struct</span> ether_header *);

	<span class="enscript-comment">/*
	 * Restrict the source hardware address
	 */</span>
	<span class="enscript-keyword">if</span> ((bif-&gt;bif_flags &amp; BIFF_HF_HWSRC) == 0 ||
	    bcmp(eh-&gt;ether_shost, bif-&gt;bif_hf_hwsrc,
	    ETHER_ADDR_LEN) != 0) {
		BRIDGE_HF_DROP(brhf_bad_ether_srchw_addr, __func__, __LINE__);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Restrict Ethernet protocols to ARP and IP
	 */</span>
	<span class="enscript-keyword">if</span> (eh-&gt;ether_type == htons(ETHERTYPE_ARP)) {
		<span class="enscript-type">struct</span> ether_arp *ea;
		size_t minlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header) +
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_arp);

		<span class="enscript-comment">/*
		 * Make the Ethernet and ARP headers contiguous
		 */</span>
		<span class="enscript-keyword">if</span> (mbuf_pkthdr_len(m) &lt; minlen) {
			BRIDGE_HF_DROP(brhf_arp_too_small, __func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">if</span> (mbuf_len(m) &lt; minlen &amp;&amp; mbuf_pullup(&amp;m, minlen) != 0) {
			BRIDGE_HF_DROP(brhf_arp_pullup_failed,
				__func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/*
		 * Verify this is an ethernet/ip arp
		 */</span>
		eh = mtod(m, <span class="enscript-type">struct</span> ether_header *);
		ea = (<span class="enscript-type">struct</span> ether_arp *)(eh + 1);
		<span class="enscript-keyword">if</span> (ea-&gt;arp_hrd != htons(ARPHRD_ETHER)) {
			BRIDGE_HF_DROP(brhf_arp_bad_hw_type,
				__func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">if</span> (ea-&gt;arp_pro != htons(ETHERTYPE_IP)) {
			BRIDGE_HF_DROP(brhf_arp_bad_pro_type,
				__func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/*
		 * Verify the address lengths are correct
		 */</span>
		<span class="enscript-keyword">if</span> (ea-&gt;arp_hln != ETHER_ADDR_LEN) {
			BRIDGE_HF_DROP(brhf_arp_bad_hw_len, __func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">if</span> (ea-&gt;arp_pln != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr)) {
			BRIDGE_HF_DROP(brhf_arp_bad_pro_len,
				__func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		<span class="enscript-comment">/*
		 * Allow only ARP request or ARP reply
		 */</span>
		<span class="enscript-keyword">if</span> (ea-&gt;arp_op != htons(ARPOP_REQUEST) &amp;&amp;
		    ea-&gt;arp_op != htons(ARPOP_REPLY)) {
			BRIDGE_HF_DROP(brhf_arp_bad_op, __func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/*
		 * Verify source hardware address matches
		 */</span>
		<span class="enscript-keyword">if</span> (bcmp(ea-&gt;arp_sha, bif-&gt;bif_hf_hwsrc,
		    ETHER_ADDR_LEN) != 0) {
			BRIDGE_HF_DROP(brhf_arp_bad_sha, __func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/*
		 * Verify source protocol address:
		 * May be null for an ARP probe
		 */</span>
		<span class="enscript-keyword">if</span> (bcmp(ea-&gt;arp_spa, &amp;bif-&gt;bif_hf_ipsrc.s_addr,
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr)) != 0 &amp;&amp;
		    bcmp(ea-&gt;arp_spa, &amp;inaddr_any,
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr)) != 0) {
			BRIDGE_HF_DROP(brhf_arp_bad_spa, __func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/*
		 *
		 */</span>
		bridge_hostfilter_stats.brhf_arp_ok += 1;
		error = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (eh-&gt;ether_type == htons(ETHERTYPE_IP)) {
		size_t minlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
		<span class="enscript-type">struct</span> ip iphdr;
		size_t offset;

		<span class="enscript-comment">/*
		 * Make the Ethernet and IP headers contiguous
		 */</span>
		<span class="enscript-keyword">if</span> (mbuf_pkthdr_len(m) &lt; minlen) {
			BRIDGE_HF_DROP(brhf_ip_too_small, __func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		offset = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header);
		error = mbuf_copydata(m, offset, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip), &amp;iphdr);
		<span class="enscript-keyword">if</span> (error != 0) {
			BRIDGE_HF_DROP(brhf_ip_too_small, __func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/*
		 * Verify the source IP address
		 */</span>
		<span class="enscript-keyword">if</span> (iphdr.ip_p == IPPROTO_UDP) {
			<span class="enscript-type">struct</span> udphdr udp;

			minlen += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr);
			<span class="enscript-keyword">if</span> (mbuf_pkthdr_len(m) &lt; minlen) {
				BRIDGE_HF_DROP(brhf_ip_too_small,
					__func__, __LINE__);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}

			<span class="enscript-comment">/*
			 * Allow all zero addresses for DHCP requests
			 */</span>
			<span class="enscript-keyword">if</span> (iphdr.ip_src.s_addr != bif-&gt;bif_hf_ipsrc.s_addr &amp;&amp;
			    iphdr.ip_src.s_addr != INADDR_ANY) {
				BRIDGE_HF_DROP(brhf_ip_bad_srcaddr,
					__func__, __LINE__);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			offset = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header) +
			    (IP_VHL_HL(iphdr.ip_vhl) &lt;&lt; 2);
			error = mbuf_copydata(m, offset,
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr), &amp;udp);
			<span class="enscript-keyword">if</span> (error != 0) {
				BRIDGE_HF_DROP(brhf_ip_too_small,
					__func__, __LINE__);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-comment">/*
			 * Either it's a Bootp/DHCP packet that we like or
			 * it's a UDP packet from the host IP as source address
			 */</span>
			<span class="enscript-keyword">if</span> (udp.uh_sport == htons(IPPORT_BOOTPC) &amp;&amp;
			    udp.uh_dport == htons(IPPORT_BOOTPS)) {
				minlen += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> dhcp);
				<span class="enscript-keyword">if</span> (mbuf_pkthdr_len(m) &lt; minlen) {
					BRIDGE_HF_DROP(brhf_ip_too_small,
						__func__, __LINE__);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
				offset += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr);
				error = bridge_dhcp_filter(bif, m, offset);
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (iphdr.ip_src.s_addr == INADDR_ANY) {
				BRIDGE_HF_DROP(brhf_ip_bad_srcaddr,
					__func__, __LINE__);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (iphdr.ip_src.s_addr != bif-&gt;bif_hf_ipsrc.s_addr ||
		    bif-&gt;bif_hf_ipsrc.s_addr == INADDR_ANY) {

			BRIDGE_HF_DROP(brhf_ip_bad_srcaddr, __func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/*
		 * Allow only boring IP protocols
		 */</span>
		<span class="enscript-keyword">if</span> (iphdr.ip_p != IPPROTO_TCP &amp;&amp;
		    iphdr.ip_p != IPPROTO_UDP &amp;&amp;
		    iphdr.ip_p != IPPROTO_ICMP &amp;&amp;
		    iphdr.ip_p != IPPROTO_ESP &amp;&amp;
		    iphdr.ip_p != IPPROTO_AH &amp;&amp;
		    iphdr.ip_p != IPPROTO_GRE) {
			BRIDGE_HF_DROP(brhf_ip_bad_proto, __func__, __LINE__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		bridge_hostfilter_stats.brhf_ip_ok += 1;
		error = 0;
	} <span class="enscript-keyword">else</span> {
		BRIDGE_HF_DROP(brhf_bad_ether_type, __func__, __LINE__);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">if</span> (if_bridge_debug &amp; BR_DBGF_HOSTFILTER) {
			<span class="enscript-keyword">if</span> (m) {
				printf_mbuf_data(m, 0,
				    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ether_header) +
				    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip));
			}
			printf(<span class="enscript-string">&quot;\n&quot;</span>);
		}

		<span class="enscript-keyword">if</span> (m != NULL)
			m_freem(m);
	}
	<span class="enscript-keyword">return</span> (error);
}
</pre>
<hr />
</body></html>