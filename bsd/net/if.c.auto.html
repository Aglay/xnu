<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>if.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">if.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1980, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)if.c	8.3 (Berkeley) 1/4/94
 * $FreeBSD: src/sys/net/if.c,v 1.85.2.9 2001/07/24 19:10:17 brooks Exp $
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2006 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/endian.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_arp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_ppp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ethernet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/network_agent.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/radix.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span> || <span class="enscript-variable-name">INET6</span>
<span class="enscript-comment">/*XXX*/</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_ifattach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET || INET6 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/altq/if_altq.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !PF_ALTQ */</span>

<span class="enscript-comment">/*
 * System initialization
 */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">proc_name_address</span>(<span class="enscript-type">void</span> *);

<span class="enscript-comment">/* Lock group and attribute for ifaddr lock */</span>
lck_attr_t	*ifa_mtx_attr;
lck_grp_t	*ifa_mtx_grp;
<span class="enscript-type">static</span> lck_grp_attr_t	*ifa_mtx_grp_attr;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifioctl_ifreq</span>(<span class="enscript-type">struct</span> socket *, u_long, <span class="enscript-type">struct</span> ifreq *,
    <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifioctl_ifconf</span>(u_long, caddr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifioctl_ifclone</span>(u_long, caddr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifioctl_ifdesc</span>(<span class="enscript-type">struct</span> ifnet *, u_long, caddr_t, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifioctl_linkparams</span>(<span class="enscript-type">struct</span> ifnet *, u_long, caddr_t, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifioctl_qstats</span>(<span class="enscript-type">struct</span> ifnet *, u_long, caddr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifioctl_throttle</span>(<span class="enscript-type">struct</span> ifnet *, u_long, caddr_t, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifioctl_netsignature</span>(<span class="enscript-type">struct</span> ifnet *, u_long, caddr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ifconf</span>(u_long cmd, user_addr_t ifrp, <span class="enscript-type">int</span> * ret_space);
__private_extern__ <span class="enscript-type">void</span> link_rtrequest(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">void</span> <span class="enscript-function-name">if_rtproto_del</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> protocol);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_addmulti_common</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">struct</span> ifmultiaddr **, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_delmulti_common</span>(<span class="enscript-type">struct</span> ifmultiaddr *, <span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_rtmtu</span>(<span class="enscript-type">struct</span> radix_node *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_rtmtu_update</span>(<span class="enscript-type">struct</span> ifnet *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_clone_list</span>(<span class="enscript-type">int</span>, <span class="enscript-type">int</span> *, user_addr_t);

<span class="enscript-function-name">MALLOC_DEFINE</span>(M_IFADDR, <span class="enscript-string">&quot;ifaddr&quot;</span>, <span class="enscript-string">&quot;interface address&quot;</span>);

<span class="enscript-type">struct</span>	ifnethead ifnet_head = TAILQ_HEAD_INITIALIZER(ifnet_head);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	if_cloners_count;
<span class="enscript-function-name">LIST_HEAD</span>(, if_clone) if_cloners = LIST_HEAD_INITIALIZER(if_cloners);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">ifa_ifwithnet_common</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_attach_ifa_common</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> ifaddr *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_detach_ifa_common</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> ifaddr *, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">if_attach_ifma</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> ifmultiaddr *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">if_detach_ifma</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> ifmultiaddr *, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifmultiaddr *<span class="enscript-function-name">ifma_alloc</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifma_free</span>(<span class="enscript-type">struct</span> ifmultiaddr *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ifma_trace</span>(<span class="enscript-type">struct</span> ifmultiaddr *, <span class="enscript-type">int</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifma_debug = 1;	<span class="enscript-comment">/* debugging (enabled) */</span>
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifma_debug;		<span class="enscript-comment">/* debugging (disabled) */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !DEBUG */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifma_size;		<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *ifma_zone;		<span class="enscript-comment">/* zone for ifmultiaddr */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFMA_TRACE_HIST_SIZE</span>	32	<span class="enscript-comment">/* size of trace history */</span>

<span class="enscript-comment">/* For gdb */</span>
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifma_trace_hist_size = IFMA_TRACE_HIST_SIZE;

<span class="enscript-type">struct</span> ifmultiaddr_dbg {
	<span class="enscript-type">struct</span> ifmultiaddr	ifma;			<span class="enscript-comment">/* ifmultiaddr */</span>
	u_int16_t		ifma_refhold_cnt;	<span class="enscript-comment">/* # of ref */</span>
	u_int16_t		ifma_refrele_cnt;	<span class="enscript-comment">/* # of rele */</span>
	<span class="enscript-comment">/*
	 * Circular lists of IFA_ADDREF and IFA_REMREF callers.
	 */</span>
	ctrace_t		ifma_refhold[IFMA_TRACE_HIST_SIZE];
	ctrace_t		ifma_refrele[IFMA_TRACE_HIST_SIZE];
	<span class="enscript-comment">/*
	 * Trash list linkage
	 */</span>
	TAILQ_ENTRY(ifmultiaddr_dbg) ifma_trash_link;
};

<span class="enscript-comment">/* List of trash ifmultiaddr entries protected by ifma_trash_lock */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(, ifmultiaddr_dbg) ifma_trash_head;
<span class="enscript-type">static</span> <span class="enscript-function-name">decl_lck_mtx_data</span>(, ifma_trash_lock);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFMA_ZONE_MAX</span>		64		<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IFMA_ZONE_NAME</span>		<span class="enscript-string">&quot;ifmultiaddr&quot;</span>	<span class="enscript-comment">/* zone name */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-comment">/*
 * XXX: declare here to avoid to include many inet6 related files..
 * should be more generalized?
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	nd6_setmtu(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">extern</span> lck_mtx_t *nd6_mutex;
#<span class="enscript-reference">endif</span>

<span class="enscript-function-name">SYSCTL_NODE</span>(_net, PF_LINK, link, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;Link layers&quot;</span>);
<span class="enscript-function-name">SYSCTL_NODE</span>(_net_link, 0, generic, CTLFLAG_RW|CTLFLAG_LOCKED, 0,
	<span class="enscript-string">&quot;Generic link-management&quot;</span>);

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_link_generic_system);

<span class="enscript-type">static</span> uint32_t if_verbose = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_link_generic_system, OID_AUTO, if_verbose,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;if_verbose, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifa_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* Setup lock group and attribute for ifaddr */</span>
	ifa_mtx_grp_attr = lck_grp_attr_alloc_init();
	ifa_mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;ifaddr&quot;</span>, ifa_mtx_grp_attr);
	ifa_mtx_attr = lck_attr_alloc_init();

	PE_parse_boot_argn(<span class="enscript-string">&quot;ifa_debug&quot;</span>, &amp;ifma_debug, <span class="enscript-keyword">sizeof</span> (ifma_debug));

	ifma_size = (ifma_debug == 0) ? <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifmultiaddr) :
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifmultiaddr_dbg);

	ifma_zone = zinit(ifma_size, IFMA_ZONE_MAX * ifma_size, 0,
	    IFMA_ZONE_NAME);
	<span class="enscript-keyword">if</span> (ifma_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__, IFMA_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(ifma_zone, Z_EXPAND, TRUE);
	zone_change(ifma_zone, Z_CALLERACCT, FALSE);

	lck_mtx_init(&amp;ifma_trash_lock, ifa_mtx_grp, ifa_mtx_attr);
	TAILQ_INIT(&amp;ifma_trash_head);
}

<span class="enscript-comment">/*
 * Network interface utility routines.
 *
 * Routines with ifa_ifwith* names take sockaddr *'s as
 * parameters.
 */</span>

<span class="enscript-type">int</span> if_index;
<span class="enscript-type">struct</span> ifaddr **ifnet_addrs;
<span class="enscript-type">struct</span> ifnet **ifindex2ifnet;

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_attach_ifa</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifaddr *ifa)
{
	if_attach_ifa_common(ifp, ifa, 0);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_attach_link_ifa</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifaddr *ifa)
{
	if_attach_ifa_common(ifp, ifa, 1);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">if_attach_ifa_common</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifaddr *ifa, <span class="enscript-type">int</span> link)
{
	ifnet_lock_assert(ifp, IFNET_LCK_ASSERT_EXCLUSIVE);
	IFA_LOCK_ASSERT_HELD(ifa);

	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_ifp != ifp) {
		panic(<span class="enscript-string">&quot;%s: Mismatch ifa_ifp=%p != ifp=%p&quot;</span>, __func__,
		    ifa-&gt;ifa_ifp, ifp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa-&gt;ifa_debug &amp; IFD_ATTACHED) {
		panic(<span class="enscript-string">&quot;%s: Attempt to attach an already attached ifa=%p&quot;</span>,
		    __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (link &amp;&amp; !(ifa-&gt;ifa_debug &amp; IFD_LINK)) {
		panic(<span class="enscript-string">&quot;%s: Unexpected non-link address ifa=%p&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!link &amp;&amp; (ifa-&gt;ifa_debug &amp; IFD_LINK)) {
		panic(<span class="enscript-string">&quot;%s: Unexpected link address ifa=%p&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	IFA_ADDREF_LOCKED(ifa);
	ifa-&gt;ifa_debug |= IFD_ATTACHED;
	<span class="enscript-keyword">if</span> (link)
		TAILQ_INSERT_HEAD(&amp;ifp-&gt;if_addrhead, ifa, ifa_link);
	<span class="enscript-keyword">else</span>
		TAILQ_INSERT_TAIL(&amp;ifp-&gt;if_addrhead, ifa, ifa_link);

	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_attached != NULL)
		(*ifa-&gt;ifa_attached)(ifa);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_detach_ifa</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifaddr *ifa)
{
	if_detach_ifa_common(ifp, ifa, 0);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_detach_link_ifa</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifaddr *ifa)
{
	if_detach_ifa_common(ifp, ifa, 1);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">if_detach_ifa_common</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifaddr *ifa, <span class="enscript-type">int</span> link)
{
	ifnet_lock_assert(ifp, IFNET_LCK_ASSERT_EXCLUSIVE);
	IFA_LOCK_ASSERT_HELD(ifa);

	<span class="enscript-keyword">if</span> (link &amp;&amp; !(ifa-&gt;ifa_debug &amp; IFD_LINK)) {
		panic(<span class="enscript-string">&quot;%s: Unexpected non-link address ifa=%p&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (link &amp;&amp; ifa != TAILQ_FIRST(&amp;ifp-&gt;if_addrhead)) {
		panic(<span class="enscript-string">&quot;%s: Link address ifa=%p not first&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!link &amp;&amp; (ifa-&gt;ifa_debug &amp; IFD_LINK)) {
		panic(<span class="enscript-string">&quot;%s: Unexpected link address ifa=%p&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifa-&gt;ifa_debug &amp; IFD_ATTACHED)) {
		panic(<span class="enscript-string">&quot;%s: Attempt to detach an unattached address ifa=%p&quot;</span>,
		    __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa-&gt;ifa_ifp != ifp) {
		panic(<span class="enscript-string">&quot;%s: Mismatch ifa_ifp=%p, ifp=%p&quot;</span>, __func__,
		    ifa-&gt;ifa_ifp, ifp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa-&gt;ifa_debug &amp; IFD_DEBUG) {
		<span class="enscript-type">struct</span> ifaddr *ifa2;
		TAILQ_FOREACH(ifa2, &amp;ifp-&gt;if_addrhead, ifa_link) {
			<span class="enscript-keyword">if</span> (ifa2 == ifa)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (ifa2 != ifa) {
			panic(<span class="enscript-string">&quot;%s: Attempt to detach a stray address ifa=%p&quot;</span>,
			    __func__, ifa);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
	}
	TAILQ_REMOVE(&amp;ifp-&gt;if_addrhead, ifa, ifa_link);
	<span class="enscript-comment">/* This must not be the last reference to the ifaddr */</span>
	<span class="enscript-keyword">if</span> (IFA_REMREF_LOCKED(ifa) == NULL) {
		panic(<span class="enscript-string">&quot;%s: unexpected (missing) refcnt ifa=%p&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	ifa-&gt;ifa_debug &amp;= ~IFD_ATTACHED;

	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_detached != NULL)
		(*ifa-&gt;ifa_detached)(ifa);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INITIAL_IF_INDEXLIM</span>	8

<span class="enscript-comment">/*
 * Function: if_next_index
 * Purpose:
 *   Return the next available interface index.  
 *   Grow the ifnet_addrs[] and ifindex2ifnet[] arrays to accomodate the 
 *   added entry when necessary.
 *
 * Note:
 *   ifnet_addrs[] is indexed by (if_index - 1), whereas
 *   ifindex2ifnet[] is indexed by ifp-&gt;if_index.  That requires us to
 *   always allocate one extra element to hold ifindex2ifnet[0], which
 *   is unused.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">if_next_index</span>(<span class="enscript-type">void</span>);

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">if_next_index</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> 	if_indexlim = 0;
	<span class="enscript-type">int</span>		new_index;

	new_index = ++if_index;
	<span class="enscript-keyword">if</span> (if_index &gt; if_indexlim) {
		<span class="enscript-type">unsigned</span> 	n;
		<span class="enscript-type">int</span>		new_if_indexlim;
		caddr_t		new_ifnet_addrs;
		caddr_t		new_ifindex2ifnet;
		caddr_t		old_ifnet_addrs;

		old_ifnet_addrs = (caddr_t)ifnet_addrs;
		<span class="enscript-keyword">if</span> (ifnet_addrs == NULL) {
			new_if_indexlim = INITIAL_IF_INDEXLIM;
		} <span class="enscript-keyword">else</span> {
			new_if_indexlim = if_indexlim &lt;&lt; 1;
		}

		<span class="enscript-comment">/* allocate space for the larger arrays */</span>
		n = (2 * new_if_indexlim + 1) * <span class="enscript-keyword">sizeof</span>(caddr_t);
		new_ifnet_addrs = _MALLOC(n, M_IFADDR, M_WAITOK | M_ZERO);
		<span class="enscript-keyword">if</span> (new_ifnet_addrs == NULL) {
			--if_index;
			<span class="enscript-keyword">return</span> -1;
		}

		new_ifindex2ifnet = new_ifnet_addrs 
			+ new_if_indexlim * <span class="enscript-keyword">sizeof</span>(caddr_t);
		<span class="enscript-keyword">if</span> (ifnet_addrs != NULL) {
			<span class="enscript-comment">/* copy the existing data */</span>
			bcopy((caddr_t)ifnet_addrs, new_ifnet_addrs,
			      if_indexlim * <span class="enscript-keyword">sizeof</span>(caddr_t));
			bcopy((caddr_t)ifindex2ifnet,
			      new_ifindex2ifnet,
			      (if_indexlim + 1) * <span class="enscript-keyword">sizeof</span>(caddr_t));
		}

		<span class="enscript-comment">/* switch to the new tables and size */</span>
		ifnet_addrs = (<span class="enscript-type">struct</span> ifaddr **)(<span class="enscript-type">void</span> *)new_ifnet_addrs;
		ifindex2ifnet = (<span class="enscript-type">struct</span> ifnet **)(<span class="enscript-type">void</span> *)new_ifindex2ifnet;
		if_indexlim = new_if_indexlim;

		<span class="enscript-comment">/* release the old data */</span>
		<span class="enscript-keyword">if</span> (old_ifnet_addrs != NULL) {
			_FREE((caddr_t)old_ifnet_addrs, M_IFADDR);
		}
	}
	<span class="enscript-keyword">return</span> (new_index);
}

<span class="enscript-comment">/*
 * Create a clone network interface.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">if_clone_create</span>(<span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> len, <span class="enscript-type">void</span> *params)
{
	<span class="enscript-type">struct</span> if_clone *ifc;
	<span class="enscript-type">char</span> *dp;
	<span class="enscript-type">int</span> wildcard;
	u_int32_t bytoff, bitoff;
	u_int32_t unit;
	<span class="enscript-type">int</span> err;

	ifc = if_clone_lookup(name, &amp;unit);
	<span class="enscript-keyword">if</span> (ifc == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (ifunit(name) != NULL)
		<span class="enscript-keyword">return</span> (EEXIST);

	bytoff = bitoff = 0;
	wildcard = (unit == UINT32_MAX);
	<span class="enscript-comment">/*
	 * Find a free unit if none was given.
	 */</span>
	<span class="enscript-keyword">if</span> (wildcard) {
		<span class="enscript-keyword">while</span> ((bytoff &lt; ifc-&gt;ifc_bmlen)
		    &amp;&amp; (ifc-&gt;ifc_units[bytoff] == 0xff))
			bytoff++;
		<span class="enscript-keyword">if</span> (bytoff &gt;= ifc-&gt;ifc_bmlen)
			<span class="enscript-keyword">return</span> (ENOSPC);
		<span class="enscript-keyword">while</span> ((ifc-&gt;ifc_units[bytoff] &amp; (1 &lt;&lt; bitoff)) != 0)
			bitoff++;
		unit = (bytoff &lt;&lt; 3) + bitoff;
	}

	<span class="enscript-keyword">if</span> (unit &gt; ifc-&gt;ifc_maxunit)
		<span class="enscript-keyword">return</span> (ENXIO);

	err = (*ifc-&gt;ifc_create)(ifc, unit, params);
	<span class="enscript-keyword">if</span> (err != 0)
		<span class="enscript-keyword">return</span> (err);

	<span class="enscript-keyword">if</span> (!wildcard) {
		bytoff = unit &gt;&gt; 3;
		bitoff = unit - (bytoff &lt;&lt; 3);
	}

	<span class="enscript-comment">/*
	 * Allocate the unit in the bitmap.
	 */</span>
	KASSERT((ifc-&gt;ifc_units[bytoff] &amp; (1 &lt;&lt; bitoff)) == 0,
	    (<span class="enscript-string">&quot;%s: bit is already set&quot;</span>, __func__));
	ifc-&gt;ifc_units[bytoff] |= (1 &lt;&lt; bitoff);

	<span class="enscript-comment">/* In the wildcard case, we need to update the name. */</span>
	<span class="enscript-keyword">if</span> (wildcard) {
		<span class="enscript-keyword">for</span> (dp = name; *dp != <span class="enscript-string">'\0'</span>; dp++);
		<span class="enscript-keyword">if</span> (snprintf(dp, len - (dp-name), <span class="enscript-string">&quot;%d&quot;</span>, unit) &gt;
		    len - (dp-name) - 1) {
			<span class="enscript-comment">/*
			 * This can only be a programmer error and
			 * there's no straightforward way to recover if
			 * it happens.
			 */</span>
			panic(<span class="enscript-string">&quot;%s: interface name too long&quot;</span>, __func__);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}

	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Destroy a clone network interface.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">if_clone_destroy</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	<span class="enscript-type">struct</span> if_clone *ifc;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">int</span> bytoff, bitoff;
	u_int32_t unit;

	ifc = if_clone_lookup(name, &amp;unit);
	<span class="enscript-keyword">if</span> (ifc == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (unit &lt; ifc-&gt;ifc_minifs)
		<span class="enscript-keyword">return</span> (EINVAL);

	ifp = ifunit(name);
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (ifc-&gt;ifc_destroy == NULL)
		<span class="enscript-keyword">return</span> (EOPNOTSUPP);

	(*ifc-&gt;ifc_destroy)(ifp);

	<span class="enscript-comment">/*
	 * Compute offset in the bitmap and deallocate the unit.
	 */</span>
	bytoff = unit &gt;&gt; 3;
	bitoff = unit - (bytoff &lt;&lt; 3);
	KASSERT((ifc-&gt;ifc_units[bytoff] &amp; (1 &lt;&lt; bitoff)) != 0,
	    (<span class="enscript-string">&quot;%s: bit is already cleared&quot;</span>, __func__));
	ifc-&gt;ifc_units[bytoff] &amp;= ~(1 &lt;&lt; bitoff);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Look up a network interface cloner.
 */</span>

__private_extern__ <span class="enscript-type">struct</span> if_clone *
<span class="enscript-function-name">if_clone_lookup</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, u_int32_t *unitp)
{
	<span class="enscript-type">struct</span> if_clone *ifc;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *cp;
	u_int32_t i;

	<span class="enscript-keyword">for</span> (ifc = LIST_FIRST(&amp;if_cloners); ifc != NULL;) {
		<span class="enscript-keyword">for</span> (cp = name, i = 0; i &lt; ifc-&gt;ifc_namelen; i++, cp++) {
			<span class="enscript-keyword">if</span> (ifc-&gt;ifc_name[i] != *cp)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next_ifc</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">found_name</span>;
 <span class="enscript-reference">next_ifc</span>:
		ifc = LIST_NEXT(ifc, ifc_list);
	}

	<span class="enscript-comment">/* No match. */</span>
	<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> if_clone *)NULL);

 <span class="enscript-reference">found_name</span>:
	<span class="enscript-keyword">if</span> (*cp == <span class="enscript-string">'\0'</span>) {
		i = UINT32_MAX;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">for</span> (i = 0; *cp != <span class="enscript-string">'\0'</span>; cp++) {
			<span class="enscript-keyword">if</span> (*cp &lt; <span class="enscript-string">'0'</span> || *cp &gt; <span class="enscript-string">'9'</span>) {
				<span class="enscript-comment">/* Bogus unit number. */</span>
				<span class="enscript-keyword">return</span> (NULL);
			}
			i = (i * 10) + (*cp - <span class="enscript-string">'0'</span>);
		}
	}

	<span class="enscript-keyword">if</span> (unitp != NULL)
		*unitp = i;
	<span class="enscript-keyword">return</span> (ifc);
}

<span class="enscript-comment">/*
 * Register a network interface cloner.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">if_clone_attach</span>(<span class="enscript-type">struct</span> if_clone *ifc)
{
	<span class="enscript-type">int</span> bytoff, bitoff;
	<span class="enscript-type">int</span> err;
	<span class="enscript-type">int</span> len, maxclone;
	u_int32_t unit;

	KASSERT(ifc-&gt;ifc_minifs - 1 &lt;= ifc-&gt;ifc_maxunit,
	    (<span class="enscript-string">&quot;%s: %s requested more units then allowed (%d &gt; %d)&quot;</span>,
	    __func__, ifc-&gt;ifc_name, ifc-&gt;ifc_minifs,
	    ifc-&gt;ifc_maxunit + 1));
	<span class="enscript-comment">/*
	 * Compute bitmap size and allocate it.
	 */</span>
	maxclone = ifc-&gt;ifc_maxunit + 1;
	len = maxclone &gt;&gt; 3;
	<span class="enscript-keyword">if</span> ((len &lt;&lt; 3) &lt; maxclone)
		len++;
	ifc-&gt;ifc_units = _MALLOC(len, M_CLONE, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (ifc-&gt;ifc_units == NULL)
		<span class="enscript-keyword">return</span> ENOBUFS;
	ifc-&gt;ifc_bmlen = len;

	LIST_INSERT_HEAD(&amp;if_cloners, ifc, ifc_list);
	if_cloners_count++;

	<span class="enscript-keyword">for</span> (unit = 0; unit &lt; ifc-&gt;ifc_minifs; unit++) {
		err = (*ifc-&gt;ifc_create)(ifc, unit, NULL);
		KASSERT(err == 0,
		    (<span class="enscript-string">&quot;%s: failed to create required interface %s%d&quot;</span>,
		    __func__, ifc-&gt;ifc_name, unit));

		<span class="enscript-comment">/* Allocate the unit in the bitmap. */</span>
		bytoff = unit &gt;&gt; 3;
		bitoff = unit - (bytoff &lt;&lt; 3);
		ifc-&gt;ifc_units[bytoff] |= (1 &lt;&lt; bitoff);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Unregister a network interface cloner.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">if_clone_detach</span>(<span class="enscript-type">struct</span> if_clone *ifc)
{
	LIST_REMOVE(ifc, ifc_list);
	FREE(ifc-&gt;ifc_units, M_CLONE);
	if_cloners_count--;
}

<span class="enscript-comment">/*
 * Provide list of interface cloners to userspace.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">if_clone_list</span>(<span class="enscript-type">int</span> count, <span class="enscript-type">int</span> *ret_total, user_addr_t dst)
{
	<span class="enscript-type">char</span> outbuf[IFNAMSIZ];
	<span class="enscript-type">struct</span> if_clone *ifc;
	<span class="enscript-type">int</span> error = 0;

	*ret_total = if_cloners_count;
	<span class="enscript-keyword">if</span> (dst == USER_ADDR_NULL) {
		<span class="enscript-comment">/* Just asking how many there are. */</span>
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (count &lt; 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	count = (if_cloners_count &lt; count) ? if_cloners_count : count;

	<span class="enscript-keyword">for</span> (ifc = LIST_FIRST(&amp;if_cloners); ifc != NULL &amp;&amp; count != 0;
	     ifc = LIST_NEXT(ifc, ifc_list), count--, dst += IFNAMSIZ) {
		strlcpy(outbuf, ifc-&gt;ifc_name, IFNAMSIZ);
		error = copyout(outbuf, dst, IFNAMSIZ);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

u_int32_t
<span class="enscript-function-name">if_functional_type</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	u_int32_t ret = IFRTYPE_FUNCTIONAL_UNKNOWN;
	<span class="enscript-keyword">if</span> (ifp != NULL) {
		<span class="enscript-keyword">if</span> (ifp-&gt;if_flags &amp; IFF_LOOPBACK) {
			ret = IFRTYPE_FUNCTIONAL_LOOPBACK;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IFNET_IS_WIFI(ifp)) {
			<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_AWDL)
				ret = IFRTYPE_FUNCTIONAL_WIFI_AWDL;
			<span class="enscript-keyword">else</span>
				ret = IFRTYPE_FUNCTIONAL_WIFI_INFRA;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IFNET_IS_CELLULAR(ifp)) {
			ret = IFRTYPE_FUNCTIONAL_CELLULAR;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IFNET_IS_WIRED(ifp)) {
			ret = IFRTYPE_FUNCTIONAL_WIRED;
		}
	}

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/*
 * Similar to ifa_ifwithaddr, except that this is IPv4 specific
 * and that it matches only the local (not broadcast) address.
 */</span>
__private_extern__ <span class="enscript-type">struct</span> in_ifaddr *
<span class="enscript-function-name">ifa_foraddr</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> addr)
{
	<span class="enscript-keyword">return</span> (ifa_foraddr_scoped(addr, IFSCOPE_NONE));
}

<span class="enscript-comment">/*
 * Similar to ifa_foraddr, except with the added interface scope
 * constraint (unless the caller passes in IFSCOPE_NONE in which
 * case there is no scope restriction).
 */</span>
__private_extern__ <span class="enscript-type">struct</span> in_ifaddr *
<span class="enscript-function-name">ifa_foraddr_scoped</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> addr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> scope)
{
	<span class="enscript-type">struct</span> in_ifaddr *ia = NULL;

	lck_rw_lock_shared(in_ifaddr_rwlock);
	TAILQ_FOREACH(ia, INADDR_HASH(addr), ia_hash) {
		IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (ia-&gt;ia_addr.sin_addr.s_addr == addr &amp;&amp;
		    (scope == IFSCOPE_NONE || ia-&gt;ia_ifp-&gt;if_index == scope)) {
			IFA_ADDREF_LOCKED(&amp;ia-&gt;ia_ifa);	<span class="enscript-comment">/* for caller */</span>
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			<span class="enscript-keyword">break</span>;
		}
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	}
	lck_rw_done(in_ifaddr_rwlock);
	<span class="enscript-keyword">return</span> (ia);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-comment">/*
 * Similar to ifa_foraddr, except that this for IPv6.
 */</span>
__private_extern__ <span class="enscript-type">struct</span> in6_ifaddr *
<span class="enscript-function-name">ifa_foraddr6</span>(<span class="enscript-type">struct</span> in6_addr *addr6)
{
	<span class="enscript-keyword">return</span> (ifa_foraddr6_scoped(addr6, IFSCOPE_NONE));
}

__private_extern__ <span class="enscript-type">struct</span> in6_ifaddr *
<span class="enscript-function-name">ifa_foraddr6_scoped</span>(<span class="enscript-type">struct</span> in6_addr *addr6, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> scope)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia = NULL;

	lck_rw_lock_shared(&amp;in6_ifaddr_rwlock);
	<span class="enscript-keyword">for</span> (ia = in6_ifaddrs; ia; ia = ia-&gt;ia_next) {
		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;ia-&gt;ia_addr.sin6_addr, addr6) &amp;&amp;
		    (scope == IFSCOPE_NONE || ia-&gt;ia_ifp-&gt;if_index == scope)) {
			IFA_ADDREF_LOCKED(&amp;ia-&gt;ia_ifa); <span class="enscript-comment">/* for caller */</span>
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			<span class="enscript-keyword">break</span>;
		}
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	}
	lck_rw_done(&amp;in6_ifaddr_rwlock);

	<span class="enscript-keyword">return</span> (ia);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-comment">/*
 * Return the first (primary) address of a given family on an interface.
 */</span>
__private_extern__ <span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifa_ifpgetprimary</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> family)
{
	<span class="enscript-type">struct</span> ifaddr *ifa;

	ifnet_lock_shared(ifp);
	TAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrhead, ifa_link) {
		IFA_LOCK_SPIN(ifa);
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family == family) {
			IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for caller */</span>
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">break</span>;
		}
		IFA_UNLOCK(ifa);
	}
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">return</span> (ifa);
}

<span class="enscript-comment">/*
 * Locate an interface based on a complete address.
 */</span>
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifa_ifwithaddr</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *addr)
{
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> ifaddr *result = NULL;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">equal</span>(a1, a2)							\
	(bcmp((<span class="enscript-type">const</span> <span class="enscript-type">void</span>*)(a1), (<span class="enscript-type">const</span> <span class="enscript-type">void</span>*)(a2),			\
	    ((<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *)(a1))-&gt;sa_len) == 0)

	ifnet_head_lock_shared();
	<span class="enscript-keyword">for</span> (ifp = ifnet_head.tqh_first; ifp &amp;&amp; !result;
	    ifp = ifp-&gt;if_link.tqe_next) {
		ifnet_lock_shared(ifp);
		<span class="enscript-keyword">for</span> (ifa = ifp-&gt;if_addrhead.tqh_first; ifa;
		    ifa = ifa-&gt;ifa_link.tqe_next) {
			IFA_LOCK_SPIN(ifa);
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != addr-&gt;sa_family) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (equal(addr, ifa-&gt;ifa_addr)) {
				result = ifa;
				IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for caller */</span>
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_BROADCAST) &amp;&amp;
			    ifa-&gt;ifa_broadaddr != NULL &amp;&amp;
			    <span class="enscript-comment">/* IP6 doesn't have broadcast */</span>
			    ifa-&gt;ifa_broadaddr-&gt;sa_len != 0 &amp;&amp;
			    equal(ifa-&gt;ifa_broadaddr, addr)) {
				result = ifa;
				IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for caller */</span>
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">break</span>;
			}
			IFA_UNLOCK(ifa);
		}
		ifnet_lock_done(ifp);
	}
	ifnet_head_done();

	<span class="enscript-keyword">return</span> (result);
}
<span class="enscript-comment">/*
 * Locate the point to point interface with a given destination address.
 */</span>
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifa_ifwithdstaddr</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *addr)
{
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> ifaddr *result = NULL;

	ifnet_head_lock_shared();
	<span class="enscript-keyword">for</span> (ifp = ifnet_head.tqh_first; ifp &amp;&amp; !result;
	    ifp = ifp-&gt;if_link.tqe_next) {
	    <span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_POINTOPOINT)) {
			ifnet_lock_shared(ifp);
			<span class="enscript-keyword">for</span> (ifa = ifp-&gt;if_addrhead.tqh_first; ifa;
			    ifa = ifa-&gt;ifa_link.tqe_next) {
				IFA_LOCK_SPIN(ifa);
				<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family !=
				    addr-&gt;sa_family) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">if</span> (ifa-&gt;ifa_dstaddr &amp;&amp;
				    equal(addr, ifa-&gt;ifa_dstaddr)) {
					result = ifa;
					IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for caller */</span>
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">break</span>;
				}
				IFA_UNLOCK(ifa);
			}
			ifnet_lock_done(ifp);
		}
	}
	ifnet_head_done();
	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/*
 * Locate the source address of an interface based on a complete address.
 */</span>
<span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifa_ifwithaddr_scoped</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">struct</span> ifaddr *result = NULL;
	<span class="enscript-type">struct</span> ifnet *ifp;

	<span class="enscript-keyword">if</span> (ifscope == IFSCOPE_NONE)
		<span class="enscript-keyword">return</span> (ifa_ifwithaddr(addr));

	ifnet_head_lock_shared();
	<span class="enscript-keyword">if</span> (ifscope &gt; (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)if_index) {
		ifnet_head_done();
		<span class="enscript-keyword">return</span> (NULL);
	}

	ifp = ifindex2ifnet[ifscope];
	<span class="enscript-keyword">if</span> (ifp != NULL) {
		<span class="enscript-type">struct</span> ifaddr *ifa = NULL;

		<span class="enscript-comment">/*
		 * This is suboptimal; there should be a better way
		 * to search for a given address of an interface
		 * for any given address family.
		 */</span>
		ifnet_lock_shared(ifp);
		<span class="enscript-keyword">for</span> (ifa = ifp-&gt;if_addrhead.tqh_first; ifa != NULL;
		    ifa = ifa-&gt;ifa_link.tqe_next) {
			IFA_LOCK_SPIN(ifa);
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != addr-&gt;sa_family) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (equal(addr, ifa-&gt;ifa_addr)) {
				result = ifa;
				IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for caller */</span>
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_BROADCAST) &amp;&amp;
			    ifa-&gt;ifa_broadaddr != NULL &amp;&amp;
			    <span class="enscript-comment">/* IP6 doesn't have broadcast */</span>
			    ifa-&gt;ifa_broadaddr-&gt;sa_len != 0 &amp;&amp;
			    equal(ifa-&gt;ifa_broadaddr, addr)) {
				result = ifa;
				IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for caller */</span>
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">break</span>;
			}
			IFA_UNLOCK(ifa);
		}
		ifnet_lock_done(ifp);
	}
	ifnet_head_done();

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifa_ifwithnet</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *addr)
{
	<span class="enscript-keyword">return</span> (ifa_ifwithnet_common(addr, IFSCOPE_NONE));
}

<span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifa_ifwithnet_scoped</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-keyword">return</span> (ifa_ifwithnet_common(addr, ifscope));
}

<span class="enscript-comment">/*
 * Find an interface on a specific network.  If many, choice
 * is most specific found.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifa_ifwithnet_common</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> ifaddr *ifa = NULL;
	<span class="enscript-type">struct</span> ifaddr *ifa_maybe = NULL;
	u_int af = addr-&gt;sa_family;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *addr_data = addr-&gt;sa_data, *cplim;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> ((af != AF_INET &amp;&amp; af != AF_INET6) ||
	    (af == AF_INET &amp;&amp; !ip_doscopedroute) ||
	    (af == AF_INET6 &amp;&amp; !ip6_doscopedroute))
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (af != AF_INET || !ip_doscopedroute)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
		ifscope = IFSCOPE_NONE;

	ifnet_head_lock_shared();
	<span class="enscript-comment">/*
	 * AF_LINK addresses can be looked up directly by their index number,
	 * so do that if we can.
	 */</span>
	<span class="enscript-keyword">if</span> (af == AF_LINK) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *sdl =
		    (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *)(uintptr_t)(size_t)addr;
		<span class="enscript-keyword">if</span> (sdl-&gt;sdl_index &amp;&amp; sdl-&gt;sdl_index &lt;= if_index) {
			ifa = ifnet_addrs[sdl-&gt;sdl_index - 1];
			<span class="enscript-keyword">if</span> (ifa != NULL)
				IFA_ADDREF(ifa);

			ifnet_head_done();
			<span class="enscript-keyword">return</span> (ifa);
		}
	}

	<span class="enscript-comment">/*
	 * Scan though each interface, looking for ones that have
	 * addresses in this address family.
	 */</span>
	<span class="enscript-keyword">for</span> (ifp = ifnet_head.tqh_first; ifp; ifp = ifp-&gt;if_link.tqe_next) {
		ifnet_lock_shared(ifp);
		<span class="enscript-keyword">for</span> (ifa = ifp-&gt;if_addrhead.tqh_first; ifa;
		     ifa = ifa-&gt;ifa_link.tqe_next) {
			<span class="enscript-type">const</span> <span class="enscript-type">char</span> *cp, *cp2, *cp3;

			IFA_LOCK(ifa);
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr == NULL ||
			    ifa-&gt;ifa_addr-&gt;sa_family != af) {
<span class="enscript-reference">next</span>:
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/*
			 * If we're looking up with a scope,
			 * find using a matching interface.
			 */</span>
			<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE &amp;&amp;
			    ifp-&gt;if_index != ifscope) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 * Scan all the bits in the ifa's address.
			 * If a bit dissagrees with what we are
			 * looking for, mask it with the netmask
			 * to see if it really matters.
			 * (A byte at a time)
			 */</span>
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_netmask == 0) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			cp = addr_data;
			cp2 = ifa-&gt;ifa_addr-&gt;sa_data;
			cp3 = ifa-&gt;ifa_netmask-&gt;sa_data;
			cplim = ifa-&gt;ifa_netmask-&gt;sa_len +
			    (<span class="enscript-type">char</span> *)ifa-&gt;ifa_netmask;
			<span class="enscript-keyword">while</span> (cp3 &lt; cplim)
				<span class="enscript-keyword">if</span> ((*cp++ ^ *cp2++) &amp; *cp3++)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>; <span class="enscript-comment">/* next address! */</span>
			<span class="enscript-comment">/*
			 * If the netmask of what we just found
			 * is more specific than what we had before
			 * (if we had one) then remember the new one
			 * before continuing to search
			 * for an even better one.
			 */</span>
			<span class="enscript-keyword">if</span> (ifa_maybe == NULL ||
			    rn_refines((caddr_t)ifa-&gt;ifa_netmask,
			    (caddr_t)ifa_maybe-&gt;ifa_netmask)) {
				IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* ifa_maybe */</span>
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">if</span> (ifa_maybe != NULL)
					IFA_REMREF(ifa_maybe);
				ifa_maybe = ifa;
			} <span class="enscript-keyword">else</span> {
				IFA_UNLOCK(ifa);
			}
			IFA_LOCK_ASSERT_NOTHELD(ifa);
		}
		ifnet_lock_done(ifp);

		<span class="enscript-keyword">if</span> (ifa != NULL)
			<span class="enscript-keyword">break</span>;
	}
	ifnet_head_done();

	<span class="enscript-keyword">if</span> (ifa == NULL)
		ifa = ifa_maybe;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa_maybe != NULL)
		IFA_REMREF(ifa_maybe);

	<span class="enscript-keyword">return</span> (ifa);
}

<span class="enscript-comment">/*
 * Find an interface address specific to an interface best matching
 * a given address.
 */</span>
<span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifaof_ifpforaddr</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> ifaddr *ifa = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *cp, *cp2, *cp3;
	<span class="enscript-type">char</span> *cplim;
	<span class="enscript-type">struct</span> ifaddr *ifa_maybe = NULL;
	<span class="enscript-type">struct</span> ifaddr *better_ifa_maybe = NULL;
	u_int af = addr-&gt;sa_family;

	<span class="enscript-keyword">if</span> (af &gt;= AF_MAX)
		<span class="enscript-keyword">return</span> (NULL);

	ifnet_lock_shared(ifp);
	<span class="enscript-keyword">for</span> (ifa = ifp-&gt;if_addrhead.tqh_first; ifa;
	     ifa = ifa-&gt;ifa_link.tqe_next) {
		IFA_LOCK(ifa);
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != af) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (ifa_maybe == NULL) {
			IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for ifa_maybe */</span>
			ifa_maybe = ifa;
		}
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_netmask == 0) {
			<span class="enscript-keyword">if</span> (equal(addr, ifa-&gt;ifa_addr) || (ifa-&gt;ifa_dstaddr &amp;&amp;
			    equal(addr, ifa-&gt;ifa_dstaddr))) {
				IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for caller */</span>
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">break</span>;
			}
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (ifp-&gt;if_flags &amp; IFF_POINTOPOINT) {
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_dstaddr &amp;&amp; equal(addr, ifa-&gt;ifa_dstaddr)) {
				IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for caller */</span>
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (equal(addr, ifa-&gt;ifa_addr)) {
				<span class="enscript-comment">/* exact match */</span>
				IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for caller */</span>
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">break</span>;
			}
			cp = addr-&gt;sa_data;
			cp2 = ifa-&gt;ifa_addr-&gt;sa_data;
			cp3 = ifa-&gt;ifa_netmask-&gt;sa_data;
			cplim = ifa-&gt;ifa_netmask-&gt;sa_len +
			    (<span class="enscript-type">char</span> *)ifa-&gt;ifa_netmask;
			<span class="enscript-keyword">for</span> (; cp3 &lt; cplim; cp3++)
				<span class="enscript-keyword">if</span> ((*cp++ ^ *cp2++) &amp; *cp3)
					<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (cp3 == cplim) {
				<span class="enscript-comment">/* subnet match */</span>
				<span class="enscript-keyword">if</span> (better_ifa_maybe == NULL) {
					<span class="enscript-comment">/* for better_ifa_maybe */</span>
					IFA_ADDREF_LOCKED(ifa);
					better_ifa_maybe = ifa;
				}
			}
		}
		IFA_UNLOCK(ifa);
	}

	<span class="enscript-keyword">if</span> (ifa == NULL) {
		<span class="enscript-keyword">if</span> (better_ifa_maybe != NULL) {
			ifa = better_ifa_maybe;
			better_ifa_maybe = NULL;
		} <span class="enscript-keyword">else</span> {
			ifa = ifa_maybe;
			ifa_maybe = NULL;
		}
	}

	ifnet_lock_done(ifp);

	<span class="enscript-keyword">if</span> (better_ifa_maybe != NULL)
		IFA_REMREF(better_ifa_maybe);
	<span class="enscript-keyword">if</span> (ifa_maybe != NULL)
		IFA_REMREF(ifa_maybe);

	<span class="enscript-keyword">return</span> (ifa);
}

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

<span class="enscript-comment">/*
 * Default action when installing a route with a Link Level gateway.
 * Lookup an appropriate real ifa to point to.
 * This should be moved to /sys/net/link.c eventually.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">link_rtrequest</span>(<span class="enscript-type">int</span> cmd, <span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> sockaddr *sa)
{
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> sockaddr *dst;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">void</span> (*ifa_rtrequest)(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> sockaddr *);

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-keyword">if</span> (cmd != RTM_ADD || ((ifa = rt-&gt;rt_ifa) == 0) ||
	    ((ifp = ifa-&gt;ifa_ifp) == 0) || ((dst = rt_key(rt)) == 0))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Become a regular mutex, just in case */</span>
	RT_CONVERT_LOCK(rt);

	ifa = ifaof_ifpforaddr(dst, ifp);
	<span class="enscript-keyword">if</span> (ifa) {
		rtsetifa(rt, ifa);
		IFA_LOCK_SPIN(ifa);
		ifa_rtrequest = ifa-&gt;ifa_rtrequest;
		IFA_UNLOCK(ifa);
		<span class="enscript-keyword">if</span> (ifa_rtrequest != NULL &amp;&amp; ifa_rtrequest != link_rtrequest)
			ifa_rtrequest(cmd, rt, sa);
		IFA_REMREF(ifa);
	}
}

<span class="enscript-comment">/*
 * if_updown will set the interface up or down. It will
 * prevent other up/down events from occurring until this
 * up/down event has completed.
 *
 * Caller must lock ifnet. This function will drop the
 * lock. This allows ifnet_set_flags to set the rest of
 * the flags after we change the up/down state without
 * dropping the interface lock between setting the
 * up/down state and updating the rest of the flags.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_updown</span>(
	<span class="enscript-type">struct</span> ifnet	*ifp,
	<span class="enscript-type">int</span>				up)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> ifaddr **ifa;
	<span class="enscript-type">struct</span> timespec	tv;
	<span class="enscript-type">struct</span> ifclassq *ifq = &amp;ifp-&gt;if_snd;

	<span class="enscript-comment">/* Wait until no one else is changing the up/down state */</span>
	<span class="enscript-keyword">while</span> ((ifp-&gt;if_eflags &amp; IFEF_UPDOWNCHANGE) != 0) {
		tv.tv_sec = 0;
		tv.tv_nsec = NSEC_PER_SEC / 10;
		ifnet_lock_done(ifp);
		msleep(&amp;ifp-&gt;if_eflags, NULL, 0, <span class="enscript-string">&quot;if_updown&quot;</span>, &amp;tv);
		ifnet_lock_exclusive(ifp);
	}

	<span class="enscript-comment">/* Verify that the interface isn't already in the right state */</span>
	<span class="enscript-keyword">if</span> ((!up &amp;&amp; (ifp-&gt;if_flags &amp; IFF_UP) == 0) ||
		(up &amp;&amp; (ifp-&gt;if_flags &amp; IFF_UP) == IFF_UP)) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Indicate that the up/down state is changing */</span>
	ifp-&gt;if_eflags |= IFEF_UPDOWNCHANGE;

	<span class="enscript-comment">/* Mark interface up or down */</span>
	<span class="enscript-keyword">if</span> (up) {
		ifp-&gt;if_flags |= IFF_UP;
	}
	<span class="enscript-keyword">else</span> {
		ifp-&gt;if_flags &amp;= ~IFF_UP;
	}

	ifnet_touch_lastchange(ifp);

	<span class="enscript-comment">/* Drop the lock to notify addresses and route */</span>
	ifnet_lock_done(ifp);
	<span class="enscript-keyword">if</span> (ifnet_get_address_list(ifp, &amp;ifa) == 0) {
		<span class="enscript-keyword">for</span> (i = 0; ifa[i] != 0; i++) {
			pfctlinput(up ? PRC_IFUP : PRC_IFDOWN, ifa[i]-&gt;ifa_addr);
		}
		ifnet_free_address_list(ifa);
	}
	rt_ifmsg(ifp);

	<span class="enscript-keyword">if</span> (!up)
		if_qflush(ifp, 0);

	<span class="enscript-comment">/* Inform all transmit queues about the new link state */</span>
	IFCQ_LOCK(ifq);
	ifnet_update_sndq(ifq, up ? CLASSQ_EV_LINK_UP : CLASSQ_EV_LINK_DOWN);
	IFCQ_UNLOCK(ifq);

	<span class="enscript-comment">/* Aquire the lock to clear the changing flag */</span>
	ifnet_lock_exclusive(ifp);
	ifp-&gt;if_eflags &amp;= ~IFEF_UPDOWNCHANGE;
	wakeup(&amp;ifp-&gt;if_eflags);
}

<span class="enscript-comment">/*
 * Mark an interface down and notify protocols of
 * the transition.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">if_down</span>(
	<span class="enscript-type">struct</span> ifnet *ifp)
{
	ifnet_lock_exclusive(ifp);
	if_updown(ifp, 0);
	ifnet_lock_done(ifp);
}

<span class="enscript-comment">/*
 * Mark an interface up and notify protocols of
 * the transition.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">if_up</span>(
	<span class="enscript-type">struct</span> ifnet *ifp)
{
	ifnet_lock_exclusive(ifp);
	if_updown(ifp, 1);
	ifnet_lock_done(ifp);
}

<span class="enscript-comment">/*
 * Flush an interface queue.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">if_qflush</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> ifq_locked)
{
	<span class="enscript-type">struct</span> ifclassq *ifq = &amp;ifp-&gt;if_snd;

	<span class="enscript-keyword">if</span> (!ifq_locked)
		IFCQ_LOCK(ifq);

	<span class="enscript-keyword">if</span> (IFCQ_IS_ENABLED(ifq))
		IFCQ_PURGE(ifq);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">if</span> (IFCQ_IS_DRAINING(ifq))
		ifq-&gt;ifcq_drain = 0;
	<span class="enscript-keyword">if</span> (ALTQ_IS_ENABLED(IFCQ_ALTQ(ifq)))
		ALTQ_PURGE(IFCQ_ALTQ(ifq));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

	VERIFY(IFCQ_IS_EMPTY(ifq));

	<span class="enscript-keyword">if</span> (!ifq_locked)
		IFCQ_UNLOCK(ifq);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">if_qflush_sc</span>(<span class="enscript-type">struct</span> ifnet *ifp, mbuf_svc_class_t sc, u_int32_t flow,
    u_int32_t *packets, u_int32_t *bytes, <span class="enscript-type">int</span> ifq_locked)
{
	<span class="enscript-type">struct</span> ifclassq *ifq = &amp;ifp-&gt;if_snd;
	u_int32_t cnt = 0, len = 0;
	u_int32_t a_cnt = 0, a_len = 0;

	VERIFY(sc == MBUF_SC_UNSPEC || MBUF_VALID_SC(sc));
	VERIFY(flow != 0);

	<span class="enscript-keyword">if</span> (!ifq_locked)
		IFCQ_LOCK(ifq);

	<span class="enscript-keyword">if</span> (IFCQ_IS_ENABLED(ifq))
		IFCQ_PURGE_SC(ifq, sc, flow, cnt, len);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">if</span> (IFCQ_IS_DRAINING(ifq)) {
		VERIFY((<span class="enscript-type">signed</span>)(ifq-&gt;ifcq_drain - cnt) &gt;= 0);
		ifq-&gt;ifcq_drain -= cnt;
	}
	<span class="enscript-keyword">if</span> (ALTQ_IS_ENABLED(IFCQ_ALTQ(ifq)))
		ALTQ_PURGE_SC(IFCQ_ALTQ(ifq), sc, flow, a_cnt, a_len);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

	<span class="enscript-keyword">if</span> (!ifq_locked)
		IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">if</span> (packets != NULL)
		*packets = cnt + a_cnt;
	<span class="enscript-keyword">if</span> (bytes != NULL)
		*bytes = len + a_len;
}

<span class="enscript-comment">/*
 * Map interface name to
 * interface structure pointer.
 */</span>
<span class="enscript-type">struct</span> ifnet *
<span class="enscript-function-name">ifunit</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	<span class="enscript-type">char</span> namebuf[IFNAMSIZ + 1];
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *cp;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">int</span> unit;
	<span class="enscript-type">unsigned</span> len, m;
	<span class="enscript-type">char</span> c;

	len = strlen(name);
	<span class="enscript-keyword">if</span> (len &lt; 2 || len &gt; IFNAMSIZ)
		<span class="enscript-keyword">return</span> (NULL);
	cp = name + len - 1;
	c = *cp;
	<span class="enscript-keyword">if</span> (c &lt; <span class="enscript-string">'0'</span> || c &gt; <span class="enscript-string">'9'</span>)
		<span class="enscript-keyword">return</span> (NULL);		<span class="enscript-comment">/* trailing garbage */</span>
	unit = 0;
	m = 1;
	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (cp == name)
			<span class="enscript-keyword">return</span> (NULL);	<span class="enscript-comment">/* no interface name */</span>
		unit += (c - <span class="enscript-string">'0'</span>) * m;
		<span class="enscript-keyword">if</span> (unit &gt; 1000000)
			<span class="enscript-keyword">return</span> (NULL);	<span class="enscript-comment">/* number is unreasonable */</span>
		m *= 10;
		c = *--cp;
	} <span class="enscript-keyword">while</span> (c &gt;= <span class="enscript-string">'0'</span> &amp;&amp; c &lt;= <span class="enscript-string">'9'</span>);
	len = cp - name + 1;
	bcopy(name, namebuf, len);
	namebuf[len] = <span class="enscript-string">'\0'</span>;
	<span class="enscript-comment">/*
	 * Now search all the interfaces for this name/number
	 */</span>
	ifnet_head_lock_shared();
	TAILQ_FOREACH(ifp, &amp;ifnet_head, if_link) {
		<span class="enscript-keyword">if</span> (strncmp(ifp-&gt;if_name, namebuf, len))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (unit == ifp-&gt;if_unit)
			<span class="enscript-keyword">break</span>;
	}
	ifnet_head_done();
	<span class="enscript-keyword">return</span> (ifp);
}


<span class="enscript-comment">/*
 * Map interface name in a sockaddr_dl to
 * interface structure pointer.
 */</span>
<span class="enscript-type">struct</span> ifnet *
<span class="enscript-function-name">if_withname</span>(<span class="enscript-type">struct</span> sockaddr *sa)
{
	<span class="enscript-type">char</span> ifname[IFNAMSIZ+1];
	<span class="enscript-type">struct</span> sockaddr_dl *sdl = (<span class="enscript-type">struct</span> sockaddr_dl *)(<span class="enscript-type">void</span> *)sa;

	<span class="enscript-keyword">if</span> ( (sa-&gt;sa_family != AF_LINK) || (sdl-&gt;sdl_nlen == 0) ||
	     (sdl-&gt;sdl_nlen &gt; IFNAMSIZ) )
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-comment">/*
	 * ifunit wants a null-terminated name.  It may not be null-terminated
	 * in the sockaddr.  We don't want to change the caller's sockaddr,
	 * and there might not be room to put the trailing null anyway, so we
	 * make a local copy that we know we can null terminate safely.
	 */</span>

	bcopy(sdl-&gt;sdl_data, ifname, sdl-&gt;sdl_nlen);
	ifname[sdl-&gt;sdl_nlen] = <span class="enscript-string">'\0'</span>;
	<span class="enscript-keyword">return</span> (ifunit(ifname));
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">ifioctl_ifconf</span>(u_long cmd, caddr_t data)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFCONF32</span>:			<span class="enscript-comment">/* struct ifconf32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFCONF32</span>: {			<span class="enscript-comment">/* struct ifconf32 */</span>
		<span class="enscript-type">struct</span> ifconf32 ifc;
		bcopy(data, &amp;ifc, <span class="enscript-keyword">sizeof</span> (ifc));
		error = ifconf(cmd, CAST_USER_ADDR_T(ifc.ifc_req),
		    &amp;ifc.ifc_len);
		bcopy(&amp;ifc, data, <span class="enscript-keyword">sizeof</span> (ifc));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFCONF64</span>:			<span class="enscript-comment">/* struct ifconf64 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFCONF64</span>: {			<span class="enscript-comment">/* struct ifconf64 */</span>
		<span class="enscript-type">struct</span> ifconf64 ifc;
		bcopy(data, &amp;ifc, <span class="enscript-keyword">sizeof</span> (ifc));
		error = ifconf(cmd, ifc.ifc_req, &amp;ifc.ifc_len);
		bcopy(&amp;ifc, data, <span class="enscript-keyword">sizeof</span> (ifc));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">ifioctl_ifclone</span>(u_long cmd, caddr_t data)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFGCLONERS32</span>: {		<span class="enscript-comment">/* struct if_clonereq32 */</span>
		<span class="enscript-type">struct</span> if_clonereq32 ifcr;
		bcopy(data, &amp;ifcr, <span class="enscript-keyword">sizeof</span> (ifcr));
		error = if_clone_list(ifcr.ifcr_count, &amp;ifcr.ifcr_total,
		    CAST_USER_ADDR_T(ifcr.ifcru_buffer));
		bcopy(&amp;ifcr, data, <span class="enscript-keyword">sizeof</span> (ifcr));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFGCLONERS64</span>: {		<span class="enscript-comment">/* struct if_clonereq64 */</span>
		<span class="enscript-type">struct</span> if_clonereq64 ifcr;
		bcopy(data, &amp;ifcr, <span class="enscript-keyword">sizeof</span> (ifcr));
		error = if_clone_list(ifcr.ifcr_count, &amp;ifcr.ifcr_total,
		    ifcr.ifcru_buffer);
		bcopy(&amp;ifcr, data, <span class="enscript-keyword">sizeof</span> (ifcr));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">ifioctl_ifdesc</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, caddr_t data, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> if_descreq *ifdr = (<span class="enscript-type">struct</span> if_descreq *)(<span class="enscript-type">void</span> *)data;
	u_int32_t ifdr_len;
	<span class="enscript-type">int</span> error = 0;

	VERIFY(ifp != NULL);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFDESC</span>: {			<span class="enscript-comment">/* struct if_descreq */</span>
		<span class="enscript-keyword">if</span> ((error = proc_suser(p)) != 0)
                        <span class="enscript-keyword">break</span>;

		ifnet_lock_exclusive(ifp);
		bcopy(&amp;ifdr-&gt;ifdr_len, &amp;ifdr_len, <span class="enscript-keyword">sizeof</span> (ifdr_len));
		<span class="enscript-keyword">if</span> (ifdr_len &gt; <span class="enscript-keyword">sizeof</span> (ifdr-&gt;ifdr_desc) ||
		    ifdr_len &gt; ifp-&gt;if_desc.ifd_maxlen) {
			error = EINVAL;
			ifnet_lock_done(ifp);
			<span class="enscript-keyword">break</span>;
		}

		bzero(ifp-&gt;if_desc.ifd_desc, ifp-&gt;if_desc.ifd_maxlen);
		<span class="enscript-keyword">if</span> ((ifp-&gt;if_desc.ifd_len = ifdr_len) &gt; 0) {
			bcopy(ifdr-&gt;ifdr_desc, ifp-&gt;if_desc.ifd_desc,
			    MIN(ifdr_len, ifp-&gt;if_desc.ifd_maxlen));
		}
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDESC</span>: {			<span class="enscript-comment">/* struct if_descreq */</span>
		ifnet_lock_shared(ifp);
		ifdr_len = MIN(ifp-&gt;if_desc.ifd_len, <span class="enscript-keyword">sizeof</span> (ifdr-&gt;ifdr_desc));
		bcopy(&amp;ifdr_len, &amp;ifdr-&gt;ifdr_len, <span class="enscript-keyword">sizeof</span> (ifdr_len));
		bzero(&amp;ifdr-&gt;ifdr_desc, <span class="enscript-keyword">sizeof</span> (ifdr-&gt;ifdr_desc));
		<span class="enscript-keyword">if</span> (ifdr_len &gt; 0) {
			bcopy(ifp-&gt;if_desc.ifd_desc, ifdr-&gt;ifdr_desc, ifdr_len);
		}
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">ifioctl_linkparams</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, caddr_t data, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> if_linkparamsreq *iflpr =
	    (<span class="enscript-type">struct</span> if_linkparamsreq *)(<span class="enscript-type">void</span> *)data;
	<span class="enscript-type">struct</span> ifclassq *ifq;
	<span class="enscript-type">int</span> error = 0;

	VERIFY(ifp != NULL);
	ifq = &amp;ifp-&gt;if_snd;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFLINKPARAMS</span>: {		<span class="enscript-comment">/* struct if_linkparamsreq */</span>
		<span class="enscript-type">struct</span> tb_profile tb = { 0, 0, 0 };

		<span class="enscript-keyword">if</span> ((error = proc_suser(p)) != 0)
                        <span class="enscript-keyword">break</span>;

		IFCQ_LOCK(ifq);
		<span class="enscript-keyword">if</span> (!IFCQ_IS_READY(ifq)) {
			error = ENXIO;
			IFCQ_UNLOCK(ifq);
			<span class="enscript-keyword">break</span>;
		}
		bcopy(&amp;iflpr-&gt;iflpr_output_tbr_rate, &amp;tb.rate,
		    <span class="enscript-keyword">sizeof</span> (tb.rate));
		bcopy(&amp;iflpr-&gt;iflpr_output_tbr_percent, &amp;tb.percent,
		    <span class="enscript-keyword">sizeof</span> (tb.percent));
		error = ifclassq_tbr_set(ifq, &amp;tb, TRUE);
		IFCQ_UNLOCK(ifq);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLINKPARAMS</span>: {		<span class="enscript-comment">/* struct if_linkparamsreq */</span>
		u_int32_t sched_type = PKTSCHEDT_NONE, flags = 0;
		u_int64_t tbr_bw = 0, tbr_pct = 0;

		IFCQ_LOCK(ifq);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
		<span class="enscript-keyword">if</span> (ALTQ_IS_ENABLED(IFCQ_ALTQ(ifq))) {
			sched_type = IFCQ_ALTQ(ifq)-&gt;altq_type;
			flags |= IFLPRF_ALTQ;
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
		{
			<span class="enscript-keyword">if</span> (IFCQ_IS_ENABLED(ifq))
				sched_type = ifq-&gt;ifcq_type;
		}
		bcopy(&amp;sched_type, &amp;iflpr-&gt;iflpr_output_sched,
		    <span class="enscript-keyword">sizeof</span> (iflpr-&gt;iflpr_output_sched));

		<span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq)) {
			tbr_bw = ifq-&gt;ifcq_tbr.tbr_rate_raw;
			tbr_pct = ifq-&gt;ifcq_tbr.tbr_percent;
		}
		bcopy(&amp;tbr_bw, &amp;iflpr-&gt;iflpr_output_tbr_rate,
		    <span class="enscript-keyword">sizeof</span> (iflpr-&gt;iflpr_output_tbr_rate));
		bcopy(&amp;tbr_pct, &amp;iflpr-&gt;iflpr_output_tbr_percent,
		    <span class="enscript-keyword">sizeof</span> (iflpr-&gt;iflpr_output_tbr_percent));
		IFCQ_UNLOCK(ifq);

		<span class="enscript-keyword">if</span> (ifp-&gt;if_output_sched_model ==
		    IFNET_SCHED_MODEL_DRIVER_MANAGED)
			flags |= IFLPRF_DRVMANAGED;
		bcopy(&amp;flags, &amp;iflpr-&gt;iflpr_flags, <span class="enscript-keyword">sizeof</span> (iflpr-&gt;iflpr_flags));
		bcopy(&amp;ifp-&gt;if_output_bw, &amp;iflpr-&gt;iflpr_output_bw,
		    <span class="enscript-keyword">sizeof</span> (iflpr-&gt;iflpr_output_bw));
		bcopy(&amp;ifp-&gt;if_input_bw, &amp;iflpr-&gt;iflpr_input_bw,
		    <span class="enscript-keyword">sizeof</span> (iflpr-&gt;iflpr_input_bw));
		bcopy(&amp;ifp-&gt;if_output_lt, &amp;iflpr-&gt;iflpr_output_lt,
		    <span class="enscript-keyword">sizeof</span> (iflpr-&gt;iflpr_output_lt));
		bcopy(&amp;ifp-&gt;if_input_lt, &amp;iflpr-&gt;iflpr_input_lt,
		    <span class="enscript-keyword">sizeof</span> (iflpr-&gt;iflpr_input_lt));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">ifioctl_qstats</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, caddr_t data)
{
	<span class="enscript-type">struct</span> if_qstatsreq *ifqr = (<span class="enscript-type">struct</span> if_qstatsreq *)(<span class="enscript-type">void</span> *)data;
	u_int32_t ifqr_len, ifqr_slot;
	<span class="enscript-type">int</span> error = 0;

	VERIFY(ifp != NULL);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFQUEUESTATS</span>: {		<span class="enscript-comment">/* struct if_qstatsreq */</span>
		bcopy(&amp;ifqr-&gt;ifqr_slot, &amp;ifqr_slot, <span class="enscript-keyword">sizeof</span> (ifqr_slot));
		bcopy(&amp;ifqr-&gt;ifqr_len, &amp;ifqr_len, <span class="enscript-keyword">sizeof</span> (ifqr_len));
		error = ifclassq_getqstats(&amp;ifp-&gt;if_snd, ifqr_slot,
		    ifqr-&gt;ifqr_buf, &amp;ifqr_len);
		<span class="enscript-keyword">if</span> (error != 0)
			ifqr_len = 0;
		bcopy(&amp;ifqr_len, &amp;ifqr-&gt;ifqr_len, <span class="enscript-keyword">sizeof</span> (ifqr_len));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">ifioctl_throttle</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, caddr_t data, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> if_throttlereq *ifthr = (<span class="enscript-type">struct</span> if_throttlereq *)(<span class="enscript-type">void</span> *)data;
	u_int32_t ifthr_level;
	<span class="enscript-type">int</span> error = 0;

	VERIFY(ifp != NULL);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFTHROTTLE</span>: {			<span class="enscript-comment">/* struct if_throttlereq */</span>
		<span class="enscript-comment">/*
		 * XXX: Use priv_check_cred() instead of root check?
		 */</span>
		<span class="enscript-keyword">if</span> ((error = proc_suser(p)) != 0)
                        <span class="enscript-keyword">break</span>;

		bcopy(&amp;ifthr-&gt;ifthr_level, &amp;ifthr_level, <span class="enscript-keyword">sizeof</span> (ifthr_level));
		error = ifnet_set_throttle(ifp, ifthr_level);
		<span class="enscript-keyword">if</span> (error == EALREADY)
			error = 0;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFTHROTTLE</span>: {			<span class="enscript-comment">/* struct if_throttlereq */</span>
		<span class="enscript-keyword">if</span> ((error = ifnet_get_throttle(ifp, &amp;ifthr_level)) == 0) {
			bcopy(&amp;ifthr_level, &amp;ifthr-&gt;ifthr_level,
			    <span class="enscript-keyword">sizeof</span> (ifthr_level));
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ifioctl_getnetagents</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t *count, user_addr_t uuid_p)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> index = 0;
	u_int32_t valid_netagent_count = 0;
	*count = 0;
	<span class="enscript-keyword">for</span> (index = 0; index &lt; IF_MAXAGENTS; index++) {
		uuid_t *netagent_uuid = &amp;(ifp-&gt;if_agentids[index]);
		<span class="enscript-keyword">if</span> (!uuid_is_null(*netagent_uuid)) {
			<span class="enscript-keyword">if</span> (uuid_p != USER_ADDR_NULL) {
				<span class="enscript-keyword">if</span> ((error = copyout(netagent_uuid,
						     uuid_p + <span class="enscript-keyword">sizeof</span>(uuid_t) * valid_netagent_count,
						     <span class="enscript-keyword">sizeof</span>(uuid_t))) != 0) {
					<span class="enscript-keyword">return</span> (error);
				}
			}
			valid_netagent_count++;
		}
	}
	*count = valid_netagent_count;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">ifioctl_netagent</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, caddr_t data, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> if_agentidreq *ifar = (<span class="enscript-type">struct</span> if_agentidreq *)(<span class="enscript-type">void</span> *)data;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> if_agentidsreq32 s32;
		<span class="enscript-type">struct</span> if_agentidsreq64 s64;
	} u;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> index = 0;

	VERIFY(ifp != NULL);

	<span class="enscript-keyword">switch</span> (cmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFAGENTID</span>: {		<span class="enscript-comment">/* struct if_agentidreq */</span>
			uuid_t *first_empty_slot = NULL;
			<span class="enscript-comment">// TODO: Use priv_check_cred() instead of root check
</span>			<span class="enscript-keyword">if</span> ((error = proc_suser(p)) != 0) {
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">for</span> (index = 0; index &lt; IF_MAXAGENTS; index++) {
				uuid_t *netagent_uuid = &amp;(ifp-&gt;if_agentids[index]);
				<span class="enscript-keyword">if</span> (uuid_compare(*netagent_uuid, ifar-&gt;ifar_uuid) == 0) {
					<span class="enscript-comment">/* Already present, ignore */</span>
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-keyword">if</span> (first_empty_slot == NULL &amp;&amp;
					uuid_is_null(*netagent_uuid)) {
					first_empty_slot = netagent_uuid;
				}
			}
			<span class="enscript-keyword">if</span> (first_empty_slot == NULL) {
				error = ENOMEM; <span class="enscript-comment">/* No empty slot for a netagent UUID, bail */</span>
				<span class="enscript-keyword">break</span>;
			}
			uuid_copy(*first_empty_slot, ifar-&gt;ifar_uuid);
			netagent_post_updated_interfaces(ifar-&gt;ifar_uuid);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFAGENTID</span>: {			<span class="enscript-comment">/* struct if_agentidreq */</span>
			bool removed_agent_id = FALSE;
			<span class="enscript-comment">// TODO: Use priv_check_cred() instead of root check
</span>			<span class="enscript-keyword">if</span> ((error = proc_suser(p)) != 0) {
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">for</span> (index = 0; index &lt; IF_MAXAGENTS; index++) {
				uuid_t *netagent_uuid = &amp;(ifp-&gt;if_agentids[index]);
				<span class="enscript-keyword">if</span> (uuid_compare(*netagent_uuid, ifar-&gt;ifar_uuid) == 0) {
					uuid_clear(*netagent_uuid);
					removed_agent_id = TRUE;
					<span class="enscript-keyword">break</span>;
				}
			}
			<span class="enscript-keyword">if</span> (removed_agent_id) {
				netagent_post_updated_interfaces(ifar-&gt;ifar_uuid);
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTIDS32</span>: {			<span class="enscript-comment">/* struct if_agentidsreq32 */</span>
			bcopy(data, &amp;u.s32, <span class="enscript-keyword">sizeof</span>(u.s32));
			error = ifioctl_getnetagents(ifp, &amp;u.s32.ifar_count, u.s32.ifar_uuids);
			<span class="enscript-keyword">if</span> (error == 0) {
				bcopy(&amp;u.s32, data, <span class="enscript-keyword">sizeof</span>(u.s32));
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTIDS64</span>: {			<span class="enscript-comment">/* struct if_agentidsreq64 */</span>
			bcopy(data, &amp;u.s64, <span class="enscript-keyword">sizeof</span>(u.s64));
			error = ifioctl_getnetagents(ifp, &amp;u.s64.ifar_count, u.s64.ifar_uuids);
			<span class="enscript-keyword">if</span> (error == 0) {
				bcopy(&amp;u.s64, data, <span class="enscript-keyword">sizeof</span>(u.s64));
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>:
			VERIFY(0);
			<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifnet_clear_netagent</span>(uuid_t netagent_uuid)
{
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	<span class="enscript-type">int</span> index = 0;
	bool removed_agent_id = FALSE;

	ifnet_head_lock_shared();

	TAILQ_FOREACH(ifp, &amp;ifnet_head, if_link) {
		<span class="enscript-keyword">for</span> (index = 0; index &lt; IF_MAXAGENTS; index++) {
			uuid_t *ifp_netagent_uuid = &amp;(ifp-&gt;if_agentids[index]);
			<span class="enscript-keyword">if</span> (uuid_compare(*ifp_netagent_uuid, netagent_uuid) == 0) {
				uuid_clear(*ifp_netagent_uuid);
				removed_agent_id = TRUE;
			}
		}
	}

	ifnet_head_done();
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">ifioctl_netsignature</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, caddr_t data)
{
	<span class="enscript-type">struct</span> if_nsreq *ifnsr = (<span class="enscript-type">struct</span> if_nsreq *)(<span class="enscript-type">void</span> *)data;
	u_int16_t flags;
	<span class="enscript-type">int</span> error = 0;

	VERIFY(ifp != NULL);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFNETSIGNATURE</span>:		<span class="enscript-comment">/* struct if_nsreq */</span>
		<span class="enscript-keyword">if</span> (ifnsr-&gt;ifnsr_len &gt; <span class="enscript-keyword">sizeof</span> (ifnsr-&gt;ifnsr_data)) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		bcopy(&amp;ifnsr-&gt;ifnsr_flags, &amp;flags, <span class="enscript-keyword">sizeof</span> (flags));
		error = ifnet_set_netsignature(ifp, ifnsr-&gt;ifnsr_family,
		    ifnsr-&gt;ifnsr_len, flags, ifnsr-&gt;ifnsr_data);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFNETSIGNATURE</span>:		<span class="enscript-comment">/* struct if_nsreq */</span>
		ifnsr-&gt;ifnsr_len = <span class="enscript-keyword">sizeof</span> (ifnsr-&gt;ifnsr_data);
		error = ifnet_get_netsignature(ifp, ifnsr-&gt;ifnsr_family,
		    &amp;ifnsr-&gt;ifnsr_len, &amp;flags, ifnsr-&gt;ifnsr_data);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;flags, &amp;ifnsr-&gt;ifnsr_flags, <span class="enscript-keyword">sizeof</span> (flags));
		<span class="enscript-keyword">else</span>
			ifnsr-&gt;ifnsr_len = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Interface ioctls.
 *
 * Most of the routines called to handle the ioctls would end up being
 * tail-call optimized, which unfortunately causes this routine to
 * consume too much stack space; this is the reason for the &quot;noinline&quot;
 * attribute used on those routines.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ifioctl</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">char</span> ifname[IFNAMSIZ + 1];
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	<span class="enscript-type">struct</span> ifstat *ifs = NULL;
	<span class="enscript-type">int</span> error = 0;

	bzero(ifname, <span class="enscript-keyword">sizeof</span> (ifname));

	<span class="enscript-comment">/*
	 * ioctls which don't require ifp, or ifreq ioctls
	 */</span>
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFCONF32</span>:			<span class="enscript-comment">/* struct ifconf32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFCONF32</span>:			<span class="enscript-comment">/* struct ifconf32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFCONF64</span>:			<span class="enscript-comment">/* struct ifconf64 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFCONF64</span>:			<span class="enscript-comment">/* struct ifconf64 */</span>
		error = ifioctl_ifconf(cmd, data);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFGCLONERS32</span>:			<span class="enscript-comment">/* struct if_clonereq32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFGCLONERS64</span>:			<span class="enscript-comment">/* struct if_clonereq64 */</span>
		error = ifioctl_ifclone(cmd, data);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTDATA32</span>:		<span class="enscript-comment">/* struct netagent_req32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTDATA64</span>:		<span class="enscript-comment">/* struct netagent_req64 */</span>
		error = netagent_ioctl(cmd, data);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFDSTADDR</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFADDR</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFBRDADDR</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFNETMASK</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFADDR</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFDSTADDR</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFBRDADDR</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFNETMASK</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFKPI</span>:			<span class="enscript-comment">/* struct ifreq */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_proto == NULL) {
			error = EOPNOTSUPP;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFCREATE</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFCREATE2</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFDESTROY</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFFLAGS</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFEFLAGS</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFCAP</span>:			<span class="enscript-comment">/* struct ifreq */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMAC</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMAC</span>:			<span class="enscript-comment">/* struct ifreq */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMETRIC</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMTU</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPHYS</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFFLAGS</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFCAP</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMETRIC</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPHYS</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMTU</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCADDMULTI</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDELMULTI</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFPHYADDR</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMEDIA</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFGENERIC</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFLLADDR</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFALTMTU</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFVLAN</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFBOND</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLLADDR</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFTYPE</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFFUNCTIONALTYPE</span>:		<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPSRCADDR</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPDSTADDR</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFGENERIC</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDEVMTU</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFVLAN</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFBOND</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFWAKEFLAGS</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFGETRTREFCNT</span>:		<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFOPPORTUNISTIC</span>:		<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFOPPORTUNISTIC</span>:		<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLINKQUALITYMETRIC</span>:		<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFLOG</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLOG</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDELEGATE</span>: 			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFEXPENSIVE</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFEXPENSIVE</span>: 			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIF2KCL</span>:			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIF2KCL</span>: 			<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFINTERFACESTATE</span>:		<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFINTERFACESTATE</span>:		<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPROBECONNECTIVITY</span>:		<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPROBECONNECTIVITY</span>:		<span class="enscript-comment">/* struct ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGSTARTDELAY</span>: {			<span class="enscript-comment">/* struct ifreq */</span>
		<span class="enscript-type">struct</span> ifreq ifr;
		bcopy(data, &amp;ifr, <span class="enscript-keyword">sizeof</span> (ifr));
		ifr.ifr_name[IFNAMSIZ - 1] = <span class="enscript-string">'\0'</span>;
		bcopy(&amp;ifr.ifr_name, ifname, IFNAMSIZ);
		error = ifioctl_ifreq(so, cmd, &amp;ifr, p);
		bcopy(&amp;ifr, data, <span class="enscript-keyword">sizeof</span> (ifr));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	}

	<span class="enscript-comment">/*
	 * ioctls which require ifp.  Note that we acquire dlil_ifnet_lock
	 * here to ensure that the ifnet, if found, has been fully attached.
	 */</span>
	dlil_if_lock();
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPHYADDR</span>:			<span class="enscript-comment">/* struct {if,in_}aliasreq */</span>
		bcopy(((<span class="enscript-type">struct</span> in_aliasreq *)(<span class="enscript-type">void</span> *)data)-&gt;ifra_name,
		    ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPHYADDR_IN6_32</span>:		<span class="enscript-comment">/* struct in6_aliasreq_32 */</span>
		bcopy(((<span class="enscript-type">struct</span> in6_aliasreq_32 *)(<span class="enscript-type">void</span> *)data)-&gt;ifra_name,
		    ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPHYADDR_IN6_64</span>:		<span class="enscript-comment">/* struct in6_aliasreq_64 */</span>
		bcopy(((<span class="enscript-type">struct</span> in6_aliasreq_64 *)(<span class="enscript-type">void</span> *)data)-&gt;ifra_name,
		    ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFSTATUS</span>:			<span class="enscript-comment">/* struct ifstat */</span>
		ifs = _MALLOC(<span class="enscript-keyword">sizeof</span> (*ifs), M_DEVBUF, M_WAITOK);
		<span class="enscript-keyword">if</span> (ifs == NULL) {
			error = ENOMEM;
			dlil_if_unlock();
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		bcopy(data, ifs, <span class="enscript-keyword">sizeof</span> (*ifs));
		ifs-&gt;ifs_name[IFNAMSIZ - 1] = <span class="enscript-string">'\0'</span>;
		bcopy(ifs-&gt;ifs_name, ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMEDIA32</span>:			<span class="enscript-comment">/* struct ifmediareq32 */</span>
		bcopy(((<span class="enscript-type">struct</span> ifmediareq32 *)(<span class="enscript-type">void</span> *)data)-&gt;ifm_name,
		    ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMEDIA64</span>:			<span class="enscript-comment">/* struct ifmediareq64 */</span>
		bcopy(((<span class="enscript-type">struct</span> ifmediareq64 *)(<span class="enscript-type">void</span> *)data)-&gt;ifm_name,
		    ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFDESC</span>:			<span class="enscript-comment">/* struct if_descreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDESC</span>:			<span class="enscript-comment">/* struct if_descreq */</span>
		bcopy(((<span class="enscript-type">struct</span> if_descreq *)(<span class="enscript-type">void</span> *)data)-&gt;ifdr_name,
		    ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFLINKPARAMS</span>:			<span class="enscript-comment">/* struct if_linkparamsreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLINKPARAMS</span>:			<span class="enscript-comment">/* struct if_linkparamsreq */</span>
		bcopy(((<span class="enscript-type">struct</span> if_linkparamsreq *)(<span class="enscript-type">void</span> *)data)-&gt;iflpr_name,
		    ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFQUEUESTATS</span>:			<span class="enscript-comment">/* struct if_qstatsreq */</span>
		bcopy(((<span class="enscript-type">struct</span> if_qstatsreq *)(<span class="enscript-type">void</span> *)data)-&gt;ifqr_name,
		    ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFTHROTTLE</span>:			<span class="enscript-comment">/* struct if_throttlereq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFTHROTTLE</span>:			<span class="enscript-comment">/* struct if_throttlereq */</span>
		bcopy(((<span class="enscript-type">struct</span> if_throttlereq *)(<span class="enscript-type">void</span> *)data)-&gt;ifthr_name,
		    ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFAGENTID</span>:			<span class="enscript-comment">/* struct if_agentidreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFAGENTID</span>:			<span class="enscript-comment">/* struct if_agentidreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTIDS32</span>:		<span class="enscript-comment">/* struct if_agentidsreq32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTIDS64</span>:		<span class="enscript-comment">/* struct if_agentidsreq64 */</span>
		bcopy(((<span class="enscript-type">struct</span> if_agentidreq *)(<span class="enscript-type">void</span> *)data)-&gt;ifar_name,
			  ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFNETSIGNATURE</span>:		<span class="enscript-comment">/* struct if_nsreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFNETSIGNATURE</span>:		<span class="enscript-comment">/* struct if_nsreq */</span>
		bcopy(((<span class="enscript-type">struct</span> if_nsreq *)(<span class="enscript-type">void</span> *)data)-&gt;ifnsr_name,
			  ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/*
		 * This is a bad assumption, but the code seems to
		 * have been doing this in the past; caveat emptor.
		 */</span>
		bcopy(((<span class="enscript-type">struct</span> ifreq *)(<span class="enscript-type">void</span> *)data)-&gt;ifr_name,
		    ifname, IFNAMSIZ);
		ifp = ifunit(ifname);
		<span class="enscript-keyword">break</span>;
	}
	dlil_if_unlock();

	<span class="enscript-keyword">if</span> (ifp == NULL) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPHYADDR</span>:			<span class="enscript-comment">/* struct {if,in_}aliasreq */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPHYADDR_IN6_32</span>:		<span class="enscript-comment">/* struct in6_aliasreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPHYADDR_IN6_64</span>:		<span class="enscript-comment">/* struct in6_aliasreq_64 */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		error = proc_suser(p);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		error = ifnet_ioctl(ifp, SOCK_DOM(so), cmd, data);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		ifnet_touch_lastchange(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFSTATUS</span>:			<span class="enscript-comment">/* struct ifstat */</span>
		VERIFY(ifs != NULL);
		ifs-&gt;ascii[0] = <span class="enscript-string">'\0'</span>;

		error = ifnet_ioctl(ifp, SOCK_DOM(so), cmd, (caddr_t)ifs);

		bcopy(ifs, data, <span class="enscript-keyword">sizeof</span> (*ifs));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMEDIA32</span>:			<span class="enscript-comment">/* struct ifmediareq32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMEDIA64</span>:			<span class="enscript-comment">/* struct ifmediareq64 */</span>
		error = ifnet_ioctl(ifp, SOCK_DOM(so), cmd, data);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFDESC</span>:			<span class="enscript-comment">/* struct if_descreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDESC</span>:			<span class="enscript-comment">/* struct if_descreq */</span>
		error = ifioctl_ifdesc(ifp, cmd, data, p);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFLINKPARAMS</span>:			<span class="enscript-comment">/* struct if_linkparamsreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLINKPARAMS</span>:			<span class="enscript-comment">/* struct if_linkparamsreq */</span>
		error = ifioctl_linkparams(ifp, cmd, data, p);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFQUEUESTATS</span>:			<span class="enscript-comment">/* struct if_qstatsreq */</span>
		error = ifioctl_qstats(ifp, cmd, data);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFTHROTTLE</span>:			<span class="enscript-comment">/* struct if_throttlereq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFTHROTTLE</span>:			<span class="enscript-comment">/* struct if_throttlereq */</span>
		error = ifioctl_throttle(ifp, cmd, data, p);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFAGENTID</span>:			<span class="enscript-comment">/* struct if_agentidreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFAGENTID</span>:			<span class="enscript-comment">/* struct if_agentidreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTIDS32</span>:		<span class="enscript-comment">/* struct if_agentidsreq32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTIDS64</span>:		<span class="enscript-comment">/* struct if_agentidsreq64 */</span>
		error = ifioctl_netagent(ifp, cmd, data, p);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFNETSIGNATURE</span>:		<span class="enscript-comment">/* struct if_nsreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFNETSIGNATURE</span>:		<span class="enscript-comment">/* struct if_nsreq */</span>
		error = ifioctl_netsignature(ifp, cmd, data);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">if</span> (so-&gt;so_proto == NULL) {
			error = EOPNOTSUPP;
			<span class="enscript-keyword">break</span>;
		}

		socket_lock(so, 1);
		error = ((*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_control)(so, cmd,
		    data, ifp, p));
		socket_unlock(so, 1);

		<span class="enscript-keyword">if</span> (error == EOPNOTSUPP || error == ENOTSUP) {
			error = ifnet_ioctl(ifp, SOCK_DOM(so), cmd, data);
		}
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (ifs != NULL)
		_FREE(ifs, M_DEVBUF);

	<span class="enscript-keyword">if</span> (if_verbose) {
		<span class="enscript-keyword">if</span> (ifname[0] == <span class="enscript-string">'\0'</span>)
			(<span class="enscript-type">void</span>) snprintf(ifname, <span class="enscript-keyword">sizeof</span> (ifname), <span class="enscript-string">&quot;%s&quot;</span>,
			    <span class="enscript-string">&quot;NULL&quot;</span>);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp != NULL)
			(<span class="enscript-type">void</span>) snprintf(ifname, <span class="enscript-keyword">sizeof</span> (ifname), <span class="enscript-string">&quot;%s&quot;</span>,
			    if_name(ifp));

		<span class="enscript-keyword">if</span> (error != 0) {
			printf(<span class="enscript-string">&quot;%s[%s,%d]: ifp %s cmd 0x%08lx (%c%c [%lu] &quot;</span>
			    <span class="enscript-string">&quot;%c %lu) error %d\n&quot;</span>, __func__,
			    proc_name_address(p), proc_pid(p),
			    ifname, cmd, (cmd &amp; IOC_IN) ? <span class="enscript-string">'I'</span> : <span class="enscript-string">' '</span>,
			    (cmd &amp; IOC_OUT) ? <span class="enscript-string">'O'</span> : <span class="enscript-string">' '</span>, IOCPARM_LEN(cmd),
			    (<span class="enscript-type">char</span>)IOCGROUP(cmd), cmd &amp; 0xff, error);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (if_verbose &gt; 1) {
			printf(<span class="enscript-string">&quot;%s[%s,%d]: ifp %s cmd 0x%08lx (%c%c [%lu] &quot;</span>
			    <span class="enscript-string">&quot;%c %lu) OK\n&quot;</span>, __func__,
			    proc_name_address(p), proc_pid(p),
			    ifname, cmd, (cmd &amp; IOC_IN) ? <span class="enscript-string">'I'</span> : <span class="enscript-string">' '</span>,
			    (cmd &amp; IOC_OUT) ? <span class="enscript-string">'O'</span> : <span class="enscript-string">' '</span>, IOCPARM_LEN(cmd),
			    (<span class="enscript-type">char</span>)IOCGROUP(cmd), cmd &amp; 0xff);
		}
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">ifioctl_ifreq</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, <span class="enscript-type">struct</span> ifreq *ifr, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> ifnet *ifp;
	u_long ocmd = cmd;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> kev_msg ev_msg;
	<span class="enscript-type">struct</span> net_event_data ev_data;

	bzero(&amp;ev_data, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> net_event_data));
	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kev_msg));

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFCREATE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFCREATE2</span>:
                error = proc_suser(p);
                <span class="enscript-keyword">if</span> (error)
                        <span class="enscript-keyword">return</span> (error);
                <span class="enscript-keyword">return</span> (if_clone_create(ifr-&gt;ifr_name, <span class="enscript-keyword">sizeof</span>(ifr-&gt;ifr_name),
		    cmd == SIOCIFCREATE2 ? ifr-&gt;ifr_data : NULL));
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFDESTROY</span>:
		error = proc_suser(p);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">return</span> (if_clone_destroy(ifr-&gt;ifr_name));
	}

	<span class="enscript-comment">/*
	 * ioctls which require ifp.  Note that we acquire dlil_ifnet_lock
	 * here to ensure that the ifnet, if found, has been fully attached.
	 */</span>
	dlil_if_lock();
	ifp = ifunit(ifr-&gt;ifr_name);
	dlil_if_unlock();

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFFLAGS</span>:
		ifnet_lock_shared(ifp);
		ifr-&gt;ifr_flags = ifp-&gt;if_flags;
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFEFLAGS</span>:
		ifnet_lock_shared(ifp);
		ifr-&gt;ifr_eflags = ifp-&gt;if_eflags;
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFCAP</span>:
		ifnet_lock_shared(ifp);
		ifr-&gt;ifr_reqcap = ifp-&gt;if_capabilities;
		ifr-&gt;ifr_curcap = ifp-&gt;if_capenable;
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMAC</span>:
		error = mac_ifnet_label_get(kauth_cred_get(), ifr, ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMAC</span>:
		error = mac_ifnet_label_set(kauth_cred_get(), ifr, ifp);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMETRIC</span>:
		ifnet_lock_shared(ifp);
		ifr-&gt;ifr_metric = ifp-&gt;if_metric;
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMTU</span>:
		ifnet_lock_shared(ifp);
		ifr-&gt;ifr_mtu = ifp-&gt;if_mtu;
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPHYS</span>:
		ifnet_lock_shared(ifp);
		ifr-&gt;ifr_phys = ifp-&gt;if_physical;
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFFLAGS</span>:
		error = proc_suser(p);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		(<span class="enscript-type">void</span>) ifnet_set_flags(ifp, ifr-&gt;ifr_flags,
		    (u_int16_t)~IFF_CANTCHANGE);

		<span class="enscript-comment">/*
		 * Note that we intentionally ignore any error from below
		 * for the SIOCSIFFLAGS case.
		 */</span>
		(<span class="enscript-type">void</span>) ifnet_ioctl(ifp, SOCK_DOM(so), cmd, (caddr_t)ifr);

		<span class="enscript-comment">/*
		 * Send the event even upon error from the driver because
		 * we changed the flags.
		 */</span>
		ev_msg.vendor_code    = KEV_VENDOR_APPLE;
		ev_msg.kev_class      = KEV_NETWORK_CLASS;
		ev_msg.kev_subclass   = KEV_DL_SUBCLASS;

		ev_msg.event_code = KEV_DL_SIFFLAGS;
		strlcpy(&amp;ev_data.if_name[0], ifp-&gt;if_name, IFNAMSIZ);
		ev_data.if_family = ifp-&gt;if_family;
		ev_data.if_unit   = (u_int32_t) ifp-&gt;if_unit;
		ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> net_event_data);
		ev_msg.dv[0].data_ptr    = &amp;ev_data;
		ev_msg.dv[1].data_length = 0;
		kev_post_msg(&amp;ev_msg);

		ifnet_touch_lastchange(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFCAP</span>:
		error = proc_suser(p);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> ((ifr-&gt;ifr_reqcap &amp; ~ifp-&gt;if_capabilities)) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		error = ifnet_ioctl(ifp, SOCK_DOM(so), cmd, (caddr_t)ifr);

		ifnet_touch_lastchange(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMETRIC</span>:
		error = proc_suser(p);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		ifp-&gt;if_metric = ifr-&gt;ifr_metric;

		ev_msg.vendor_code    = KEV_VENDOR_APPLE;
		ev_msg.kev_class      = KEV_NETWORK_CLASS;
		ev_msg.kev_subclass   = KEV_DL_SUBCLASS;

		ev_msg.event_code = KEV_DL_SIFMETRICS;
		strlcpy(&amp;ev_data.if_name[0], ifp-&gt;if_name, IFNAMSIZ);
		ev_data.if_family = ifp-&gt;if_family;
		ev_data.if_unit   = (u_int32_t) ifp-&gt;if_unit;
		ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> net_event_data);
		ev_msg.dv[0].data_ptr    = &amp;ev_data;

		ev_msg.dv[1].data_length = 0;
		kev_post_msg(&amp;ev_msg);

		ifnet_touch_lastchange(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPHYS</span>:
		error = proc_suser(p);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		error = ifnet_ioctl(ifp, SOCK_DOM(so), cmd, (caddr_t)ifr);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		ev_msg.vendor_code    = KEV_VENDOR_APPLE;
		ev_msg.kev_class      = KEV_NETWORK_CLASS;
		ev_msg.kev_subclass   = KEV_DL_SUBCLASS;

		ev_msg.event_code = KEV_DL_SIFPHYS;
		strlcpy(&amp;ev_data.if_name[0], ifp-&gt;if_name, IFNAMSIZ);
		ev_data.if_family = ifp-&gt;if_family;
		ev_data.if_unit   = (u_int32_t) ifp-&gt;if_unit;
		ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> net_event_data);
		ev_msg.dv[0].data_ptr    = &amp;ev_data;
		ev_msg.dv[1].data_length = 0;
		kev_post_msg(&amp;ev_msg);

		ifnet_touch_lastchange(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMTU</span>: {
		u_int32_t oldmtu = ifp-&gt;if_mtu;
		<span class="enscript-type">struct</span> ifclassq *ifq = &amp;ifp-&gt;if_snd;

		error = proc_suser(p);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (ifp-&gt;if_ioctl == NULL) {
			error = EOPNOTSUPP;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (ifr-&gt;ifr_mtu &lt; IF_MINMTU || ifr-&gt;ifr_mtu &gt; IF_MAXMTU) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		error = ifnet_ioctl(ifp, SOCK_DOM(so), cmd, (caddr_t)ifr);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		ev_msg.vendor_code    = KEV_VENDOR_APPLE;
		ev_msg.kev_class      = KEV_NETWORK_CLASS;
		ev_msg.kev_subclass   = KEV_DL_SUBCLASS;

		ev_msg.event_code = KEV_DL_SIFMTU;
		strlcpy(&amp;ev_data.if_name[0], ifp-&gt;if_name, IFNAMSIZ);
		ev_data.if_family = ifp-&gt;if_family;
		ev_data.if_unit   = (u_int32_t) ifp-&gt;if_unit;
		ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> net_event_data);
		ev_msg.dv[0].data_ptr    = &amp;ev_data;
		ev_msg.dv[1].data_length = 0;
		kev_post_msg(&amp;ev_msg);

		ifnet_touch_lastchange(ifp);
		rt_ifmsg(ifp);

		<span class="enscript-comment">/*
		 * If the link MTU changed, do network layer specific procedure
		 * and update all route entries associated with the interface,
		 * so that their MTU metric gets updated.
		 */</span>
		<span class="enscript-keyword">if</span> (ifp-&gt;if_mtu != oldmtu) {
			if_rtmtu_update(ifp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			nd6_setmtu(ifp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			<span class="enscript-comment">/* Inform all transmit queues about the new MTU */</span>
			IFCQ_LOCK(ifq);
			ifnet_update_sndq(ifq, CLASSQ_EV_LINK_MTU);
			IFCQ_UNLOCK(ifq);
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCADDMULTI</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDELMULTI</span>:
		error = proc_suser(p);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* Don't allow group membership on non-multicast interfaces. */</span>
		<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_MULTICAST) == 0) {
			error = EOPNOTSUPP;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* Don't let users screw up protocols' entries. */</span>
		<span class="enscript-keyword">if</span> (ifr-&gt;ifr_addr.sa_family != AF_UNSPEC &amp;&amp;
		    ifr-&gt;ifr_addr.sa_family != AF_LINK) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * User is permitted to anonymously join a particular link
		 * multicast group via SIOCADDMULTI.  Subsequent join requested
		 * for the same record which has an outstanding refcnt from a
		 * past if_addmulti_anon() will not result in EADDRINUSE error
		 * (unlike other BSDs.)  Anonymously leaving a group is also
		 * allowed only as long as there is an outstanding refcnt held
		 * by a previous anonymous request, or else ENOENT (even if the
		 * link-layer multicast membership exists for a network-layer
		 * membership.)
		 */</span>
		<span class="enscript-keyword">if</span> (cmd == SIOCADDMULTI) {
			error = if_addmulti_anon(ifp, &amp;ifr-&gt;ifr_addr, NULL);
			ev_msg.event_code = KEV_DL_ADDMULTI;
		} <span class="enscript-keyword">else</span> {
			error = if_delmulti_anon(ifp, &amp;ifr-&gt;ifr_addr);
			ev_msg.event_code = KEV_DL_DELMULTI;
		}
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		ev_msg.vendor_code    = KEV_VENDOR_APPLE;
		ev_msg.kev_class      = KEV_NETWORK_CLASS;
		ev_msg.kev_subclass   = KEV_DL_SUBCLASS;
		strlcpy(&amp;ev_data.if_name[0], ifp-&gt;if_name, IFNAMSIZ);

		ev_data.if_family = ifp-&gt;if_family;
		ev_data.if_unit   = (u_int32_t) ifp-&gt;if_unit;
		ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> net_event_data);
		ev_msg.dv[0].data_ptr    = &amp;ev_data;
		ev_msg.dv[1].data_length = 0;
		kev_post_msg(&amp;ev_msg);

		ifnet_touch_lastchange(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFPHYADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMEDIA</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFGENERIC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFLLADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFALTMTU</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFVLAN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFBOND</span>:
		error = proc_suser(p);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		error = ifnet_ioctl(ifp, SOCK_DOM(so), cmd, (caddr_t)ifr);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		ifnet_touch_lastchange(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLLADDR</span>: {
		<span class="enscript-type">struct</span> sockaddr_dl *sdl = SDL(ifp-&gt;if_lladdr-&gt;ifa_addr);

		<span class="enscript-keyword">if</span> (sdl-&gt;sdl_alen == 0) {
			error = EADDRNOTAVAIL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* If larger than 14-bytes we'll need another mechanism */</span>
		<span class="enscript-keyword">if</span> (sdl-&gt;sdl_alen &gt; <span class="enscript-keyword">sizeof</span> (ifr-&gt;ifr_addr.sa_data)) {
			error = EMSGSIZE;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* Follow the same convention used by SIOCSIFLLADDR */</span>
		bzero(&amp;ifr-&gt;ifr_addr, <span class="enscript-keyword">sizeof</span> (ifr-&gt;ifr_addr));
		ifr-&gt;ifr_addr.sa_family = AF_LINK;
		ifr-&gt;ifr_addr.sa_len = sdl-&gt;sdl_alen;
		error = ifnet_guarded_lladdr_copy_bytes(ifp,
		    &amp;ifr-&gt;ifr_addr.sa_data, sdl-&gt;sdl_alen);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFTYPE</span>:
		ifr-&gt;ifr_type.ift_type = ifp-&gt;if_type;
		ifr-&gt;ifr_type.ift_family = ifp-&gt;if_family;
		ifr-&gt;ifr_type.ift_subfamily = ifp-&gt;if_subfamily;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFFUNCTIONALTYPE</span>:
		ifr-&gt;ifr_functional_type = if_functional_type(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPSRCADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPDSTADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFGENERIC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDEVMTU</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFVLAN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFBOND</span>:
		error = ifnet_ioctl(ifp, SOCK_DOM(so), cmd, (caddr_t)ifr);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFWAKEFLAGS</span>:
		ifnet_lock_shared(ifp);
		ifr-&gt;ifr_wake_flags = ifnet_get_wake_flags(ifp);
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFGETRTREFCNT</span>:
		ifnet_lock_shared(ifp);
		ifr-&gt;ifr_route_refcnt = ifp-&gt;if_route_refcnt;
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFOPPORTUNISTIC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFOPPORTUNISTIC</span>:
		error = ifnet_getset_opportunistic(ifp, cmd, ifr, p);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLINKQUALITYMETRIC</span>:
		ifnet_lock_shared(ifp);
		<span class="enscript-keyword">if</span> ((ifp-&gt;if_interface_state.valid_bitmask &amp; 
		    IF_INTERFACE_STATE_LQM_STATE_VALID))
			ifr-&gt;ifr_link_quality_metric =
			   ifp-&gt;if_interface_state.lqm_state;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ifp-&gt;if_refflags &amp; IFRF_ATTACHED)) {
			ifr-&gt;ifr_link_quality_metric =
			    IFNET_LQM_THRESH_UNKNOWN;
		} <span class="enscript-keyword">else</span> {
			ifr-&gt;ifr_link_quality_metric =
			    IFNET_LQM_THRESH_OFF;
		}
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFLOG</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLOG</span>:
		error = ifnet_getset_log(ifp, cmd, ifr, p);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDELEGATE</span>:
		ifnet_lock_shared(ifp);
		ifr-&gt;ifr_delegated = ((ifp-&gt;if_delegated.ifp != NULL) ?
		    ifp-&gt;if_delegated.ifp-&gt;if_index : 0);
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFEXPENSIVE</span>:
		ifnet_lock_shared(ifp);
		<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_EXPENSIVE)
			ifr-&gt;ifr_expensive = 1;
		<span class="enscript-keyword">else</span> 
			ifr-&gt;ifr_expensive = 0;
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFEXPENSIVE</span>:
	{
		<span class="enscript-type">struct</span> ifnet *difp;

		<span class="enscript-keyword">if</span> ((error = priv_check_cred(kauth_cred_get(),
		    PRIV_NET_INTERFACE_CONTROL, 0)) != 0)
			<span class="enscript-keyword">return</span> (error);
		ifnet_lock_exclusive(ifp);
		<span class="enscript-keyword">if</span> (ifr-&gt;ifr_expensive)
			ifp-&gt;if_eflags |= IFEF_EXPENSIVE;
		<span class="enscript-keyword">else</span> 
			ifp-&gt;if_eflags &amp;= ~IFEF_EXPENSIVE;
		ifnet_lock_done(ifp);
		<span class="enscript-comment">/*
		 * Update the expensive bit in the delegated interface
		 * structure.
		 */</span>
		ifnet_head_lock_shared();
		TAILQ_FOREACH(difp, &amp;ifnet_head, if_link) {
			ifnet_lock_exclusive(difp);
			<span class="enscript-keyword">if</span> (difp-&gt;if_delegated.ifp == ifp) {
				difp-&gt;if_delegated.expensive = 
				    ifp-&gt;if_eflags &amp; IFEF_EXPENSIVE ? 1 : 0;

			}
			ifnet_lock_done(difp);
		}
		ifnet_head_done();
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIF2KCL</span>:
		ifnet_lock_shared(ifp);
		<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_2KCL)
			ifr-&gt;ifr_2kcl = 1;
		<span class="enscript-keyword">else</span>
			ifr-&gt;ifr_2kcl = 0;
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIF2KCL</span>:
		<span class="enscript-keyword">if</span> ((error = priv_check_cred(kauth_cred_get(),
		    PRIV_NET_INTERFACE_CONTROL, 0)) != 0)
			<span class="enscript-keyword">return</span> (error);
		ifnet_lock_exclusive(ifp);
		<span class="enscript-keyword">if</span> (ifr-&gt;ifr_2kcl)
			ifp-&gt;if_eflags |= IFEF_2KCL;
		<span class="enscript-keyword">else</span>
			ifp-&gt;if_eflags &amp;= ~IFEF_2KCL;
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGSTARTDELAY</span>:
		ifnet_lock_shared(ifp);
		<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_ENQUEUE_MULTI) {
			ifr-&gt;ifr_start_delay_qlen =
			    ifp-&gt;if_start_delay_qlen;
			ifr-&gt;ifr_start_delay_timeout =
			    ifp-&gt;if_start_delay_timeout;
		} <span class="enscript-keyword">else</span> {
			ifr-&gt;ifr_start_delay_qlen = 0;
			ifr-&gt;ifr_start_delay_timeout = 0;
		}
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFDSTADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFBRDADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFNETMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFDSTADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFBRDADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFNETMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFKPI</span>:
		VERIFY(so-&gt;so_proto != NULL);

		<span class="enscript-keyword">if</span> (cmd == SIOCSIFDSTADDR || cmd == SIOCSIFADDR ||
		    cmd == SIOCSIFBRDADDR || cmd == SIOCSIFNETMASK) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
			<span class="enscript-keyword">if</span> (ifr-&gt;ifr_addr.sa_family == 0 &amp;&amp;
			    ifr-&gt;ifr_addr.sa_len &lt; 16) {
				ifr-&gt;ifr_addr.sa_family = ifr-&gt;ifr_addr.sa_len;
				ifr-&gt;ifr_addr.sa_len = 16;
			}
#<span class="enscript-reference">else</span>
			<span class="enscript-keyword">if</span> (ifr-&gt;ifr_addr.sa_len == 0)
				ifr-&gt;ifr_addr.sa_len = 16;
#<span class="enscript-reference">endif</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd == OSIOCGIFADDR) {
			cmd = SIOCGIFADDR;	<span class="enscript-comment">/* struct ifreq */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd == OSIOCGIFDSTADDR) {
			cmd = SIOCGIFDSTADDR;	<span class="enscript-comment">/* struct ifreq */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd == OSIOCGIFBRDADDR) {
			cmd = SIOCGIFBRDADDR;	<span class="enscript-comment">/* struct ifreq */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd == OSIOCGIFNETMASK) {
			cmd = SIOCGIFNETMASK;	<span class="enscript-comment">/* struct ifreq */</span>
		}

		socket_lock(so, 1);
		error = ((*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_control)(so, cmd,
		    (caddr_t)ifr, ifp, p));
		socket_unlock(so, 1);

		<span class="enscript-keyword">switch</span> (ocmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFDSTADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFBRDADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFNETMASK</span>:
			bcopy(&amp;ifr-&gt;ifr_addr.sa_family, &amp;ifr-&gt;ifr_addr,
			    <span class="enscript-keyword">sizeof</span> (u_short));
		}

		<span class="enscript-keyword">if</span> (cmd == SIOCSIFKPI) {
			<span class="enscript-type">int</span> temperr = proc_suser(p);
			<span class="enscript-keyword">if</span> (temperr != 0)
				error = temperr;
		}

		<span class="enscript-keyword">if</span> (error == EOPNOTSUPP || error == ENOTSUP) {
			error = ifnet_ioctl(ifp, SOCK_DOM(so), cmd,
			    (caddr_t)ifr);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFINTERFACESTATE</span>:
		if_get_state(ifp, &amp;ifr-&gt;ifr_interface_state);
		
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFINTERFACESTATE</span>:
		<span class="enscript-keyword">if</span> ((error = priv_check_cred(kauth_cred_get(),
		    PRIV_NET_INTERFACE_CONTROL, 0)) != 0)
			<span class="enscript-keyword">return</span> (error);

		error = if_state_update(ifp, &amp;ifr-&gt;ifr_interface_state);

		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPROBECONNECTIVITY</span>:
		<span class="enscript-keyword">if</span> ((error = priv_check_cred(kauth_cred_get(),
		    PRIV_NET_INTERFACE_CONTROL, 0)) != 0)
			<span class="enscript-keyword">return</span> (error);
		error = if_probe_connectivity(ifp,
		    ifr-&gt;ifr_probe_connectivity);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPROBECONNECTIVITY</span>:
		<span class="enscript-keyword">if</span> ((error = priv_check_cred(kauth_cred_get(),
		    PRIV_NET_INTERFACE_CONTROL, 0)) != 0)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_PROBE_CONNECTIVITY)
			ifr-&gt;ifr_probe_connectivity = 1;
		<span class="enscript-keyword">else</span>
			ifr-&gt;ifr_probe_connectivity = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifioctllocked</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error;

	socket_unlock(so, 0);
	error = ifioctl(so, cmd, data, p);
	socket_lock(so, 0);
	<span class="enscript-keyword">return</span>(error);
}
	
<span class="enscript-comment">/*
 * Set/clear promiscuous mode on interface ifp based on the truth value
 * of pswitch.  The calls are reference counted so that only the first
 * &quot;on&quot; request actually has an effect, as does the final &quot;off&quot; request.
 * Results are undefined if the &quot;off&quot; and &quot;on&quot; requests are not matched.
 */</span>
errno_t
<span class="enscript-function-name">ifnet_set_promiscuous</span>(
	ifnet_t	ifp,
	<span class="enscript-type">int</span> pswitch)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> oldflags = 0;
	<span class="enscript-type">int</span> newflags = 0;

	ifnet_lock_exclusive(ifp);
	oldflags = ifp-&gt;if_flags;
	ifp-&gt;if_pcount += pswitch ? 1 : -1;
	
	<span class="enscript-keyword">if</span> (ifp-&gt;if_pcount &gt; 0)
		ifp-&gt;if_flags |= IFF_PROMISC;
	<span class="enscript-keyword">else</span>
		ifp-&gt;if_flags &amp;= ~IFF_PROMISC;
	
	newflags = ifp-&gt;if_flags;
	ifnet_lock_done(ifp);
	
	<span class="enscript-keyword">if</span> (newflags != oldflags &amp;&amp; (newflags &amp; IFF_UP) != 0) {
		error = ifnet_ioctl(ifp, 0, SIOCSIFFLAGS, NULL);
		<span class="enscript-keyword">if</span> (error == 0) {
			rt_ifmsg(ifp);
		} <span class="enscript-keyword">else</span> {
			ifnet_lock_exclusive(ifp);
			<span class="enscript-comment">// revert the flags
</span>			ifp-&gt;if_pcount -= pswitch ? 1 : -1;
			<span class="enscript-keyword">if</span> (ifp-&gt;if_pcount &gt; 0)
			    ifp-&gt;if_flags |= IFF_PROMISC;
			<span class="enscript-keyword">else</span>
			    ifp-&gt;if_flags &amp;= ~IFF_PROMISC;
			ifnet_lock_done(ifp);
		}
	}
	
	<span class="enscript-keyword">if</span> (newflags != oldflags) {
		log(LOG_INFO, <span class="enscript-string">&quot;%s: promiscuous mode %s%s\n&quot;</span>,
		    if_name(ifp),
		    (newflags &amp; IFF_PROMISC) != 0 ? <span class="enscript-string">&quot;enable&quot;</span> : <span class="enscript-string">&quot;disable&quot;</span>,
		    error != 0 ? <span class="enscript-string">&quot; failed&quot;</span> : <span class="enscript-string">&quot; succeeded&quot;</span>);
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Return interface configuration
 * of system.  List may be used
 * in later ioctl's (above) to get
 * other information.
 */</span>
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ifconf</span>(u_long cmd, user_addr_t ifrp, <span class="enscript-type">int</span> *ret_space)
{
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> ifreq ifr;
	<span class="enscript-type">int</span> error = 0;
	size_t space;
	net_thread_marks_t marks;

	marks = net_thread_marks_push(NET_THREAD_CKREQ_LLADDR);

	<span class="enscript-comment">/*
	 * Zero the ifr buffer to make sure we don't
	 * disclose the contents of the stack.
	 */</span>
	bzero(&amp;ifr, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifreq));

	space = *ret_space;
	ifnet_head_lock_shared();
	<span class="enscript-keyword">for</span> (ifp = ifnet_head.tqh_first; space &gt; <span class="enscript-keyword">sizeof</span> (ifr) &amp;&amp;
	    ifp; ifp = ifp-&gt;if_link.tqe_next) {
		<span class="enscript-type">char</span> workbuf[64];
		size_t ifnlen, addrs;

		ifnlen = snprintf(workbuf, <span class="enscript-keyword">sizeof</span> (workbuf),
		    <span class="enscript-string">&quot;%s&quot;</span>, if_name(ifp));
		<span class="enscript-keyword">if</span> (ifnlen + 1 &gt; <span class="enscript-keyword">sizeof</span> (ifr.ifr_name)) {
			error = ENAMETOOLONG;
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> {
			strlcpy(ifr.ifr_name, workbuf, IFNAMSIZ);
		}

		ifnet_lock_shared(ifp);

		addrs = 0;
		ifa = ifp-&gt;if_addrhead.tqh_first;
		<span class="enscript-keyword">for</span> (; space &gt; <span class="enscript-keyword">sizeof</span> (ifr) &amp;&amp; ifa;
		    ifa = ifa-&gt;ifa_link.tqe_next) {
			<span class="enscript-type">struct</span> sockaddr *sa;
			<span class="enscript-type">union</span> {
				<span class="enscript-type">struct</span> sockaddr sa;
				<span class="enscript-type">struct</span> sockaddr_dl sdl;
				uint8_t buf[SOCK_MAXADDRLEN + 1];
			} u;

			<span class="enscript-comment">/*
			 * Make sure to accomodate the largest possible
			 * size of SA(if_lladdr)-&gt;sa_len.
			 */</span>
			_CASSERT(<span class="enscript-keyword">sizeof</span> (u) == (SOCK_MAXADDRLEN + 1));

			IFA_LOCK(ifa);
			sa = ifa-&gt;ifa_addr;
			addrs++;

			<span class="enscript-keyword">if</span> (ifa == ifp-&gt;if_lladdr) {
				VERIFY(sa-&gt;sa_family == AF_LINK);
				bcopy(sa, &amp;u, sa-&gt;sa_len);
				IFA_UNLOCK(ifa);
				ifnet_guarded_lladdr_copy_bytes(ifp,
				    LLADDR(&amp;u.sdl), u.sdl.sdl_alen);
				IFA_LOCK(ifa);
				sa = &amp;u.sa;
			}

			<span class="enscript-keyword">if</span> (cmd == OSIOCGIFCONF32 || cmd == OSIOCGIFCONF64) {
				<span class="enscript-type">struct</span> osockaddr *osa =
				    (<span class="enscript-type">struct</span> osockaddr *)(<span class="enscript-type">void</span> *)&amp;ifr.ifr_addr;
				ifr.ifr_addr = *sa;
				osa-&gt;sa_family = sa-&gt;sa_family;
				error = copyout((caddr_t)&amp;ifr, ifrp,
				    <span class="enscript-keyword">sizeof</span> (ifr));
				ifrp += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifreq);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;sa_len &lt;= <span class="enscript-keyword">sizeof</span> (*sa)) {
				ifr.ifr_addr = *sa;
				error = copyout((caddr_t)&amp;ifr, ifrp,
				    <span class="enscript-keyword">sizeof</span> (ifr));
				ifrp += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifreq);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (space &lt;
				    <span class="enscript-keyword">sizeof</span> (ifr) + sa-&gt;sa_len - <span class="enscript-keyword">sizeof</span> (*sa)) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">break</span>;
				}
				space -= sa-&gt;sa_len - <span class="enscript-keyword">sizeof</span> (*sa);
				error = copyout((caddr_t)&amp;ifr, ifrp,
				    <span class="enscript-keyword">sizeof</span> (ifr.ifr_name));
				<span class="enscript-keyword">if</span> (error == 0) {
					error = copyout((caddr_t)sa, (ifrp +
					    offsetof(<span class="enscript-type">struct</span> ifreq, ifr_addr)),
					    sa-&gt;sa_len);
				}
				ifrp += (sa-&gt;sa_len + offsetof(<span class="enscript-type">struct</span> ifreq,
				    ifr_addr));
			}
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			space -= <span class="enscript-keyword">sizeof</span> (ifr);
		}
		ifnet_lock_done(ifp);

		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (!addrs) {
			bzero((caddr_t)&amp;ifr.ifr_addr, <span class="enscript-keyword">sizeof</span> (ifr.ifr_addr));
			error = copyout((caddr_t)&amp;ifr, ifrp, <span class="enscript-keyword">sizeof</span> (ifr));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			space -= <span class="enscript-keyword">sizeof</span> (ifr);
			ifrp += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifreq);
		}
	}
	ifnet_head_done();
	*ret_space -= space;
	net_thread_marks_pop(marks);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Just like if_promisc(), but for all-multicast-reception mode.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">if_allmulti</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> onswitch)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span>	modified = 0;

	ifnet_lock_exclusive(ifp);

	<span class="enscript-keyword">if</span> (onswitch) {
		<span class="enscript-keyword">if</span> (ifp-&gt;if_amcount++ == 0) {
			ifp-&gt;if_flags |= IFF_ALLMULTI;
			modified = 1;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (ifp-&gt;if_amcount &gt; 1) {
			ifp-&gt;if_amcount--;
		} <span class="enscript-keyword">else</span> {
			ifp-&gt;if_amcount = 0;
			ifp-&gt;if_flags &amp;= ~IFF_ALLMULTI;
			modified = 1;
		}
	}
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">if</span> (modified)
		error = ifnet_ioctl(ifp, 0, SIOCSIFFLAGS, NULL);

	<span class="enscript-keyword">if</span> (error == 0)
		rt_ifmsg(ifp);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifmultiaddr *
<span class="enscript-function-name">ifma_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> ifmultiaddr *ifma;

	ifma = (how == M_WAITOK) ? zalloc(ifma_zone) :
	    zalloc_noblock(ifma_zone);

	<span class="enscript-keyword">if</span> (ifma != NULL) {
		bzero(ifma, ifma_size);
		lck_mtx_init(&amp;ifma-&gt;ifma_lock, ifa_mtx_grp, ifa_mtx_attr);
		ifma-&gt;ifma_debug |= IFD_ALLOC;
		<span class="enscript-keyword">if</span> (ifma_debug != 0) {
			ifma-&gt;ifma_debug |= IFD_DEBUG;
			ifma-&gt;ifma_trace = ifma_trace;
		}
	}
	<span class="enscript-keyword">return</span> (ifma);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifma_free</span>(<span class="enscript-type">struct</span> ifmultiaddr *ifma)
{
	IFMA_LOCK(ifma);

	<span class="enscript-keyword">if</span> (ifma-&gt;ifma_protospec != NULL) {
		panic(<span class="enscript-string">&quot;%s: Protospec not NULL for ifma=%p&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ifma-&gt;ifma_flags &amp; IFMAF_ANONYMOUS) ||
	    ifma-&gt;ifma_anoncnt != 0) {
		panic(<span class="enscript-string">&quot;%s: Freeing ifma=%p with outstanding anon req&quot;</span>,
		    __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifma-&gt;ifma_debug &amp; IFD_ATTACHED) {
		panic(<span class="enscript-string">&quot;%s: ifma=%p attached to ifma_ifp=%p is being freed&quot;</span>,
		    __func__, ifma, ifma-&gt;ifma_ifp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifma-&gt;ifma_debug &amp; IFD_ALLOC)) {
		panic(<span class="enscript-string">&quot;%s: ifma %p cannot be freed&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifma-&gt;ifma_refcount != 0) {
		panic(<span class="enscript-string">&quot;%s: non-zero refcount ifma=%p&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifma-&gt;ifma_reqcnt != 0) {
		panic(<span class="enscript-string">&quot;%s: non-zero reqcnt ifma=%p&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifma-&gt;ifma_ifp != NULL) {
		panic(<span class="enscript-string">&quot;%s: non-NULL ifma_ifp=%p for ifma=%p&quot;</span>, __func__,
		    ifma-&gt;ifma_ifp, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifma-&gt;ifma_ll != NULL) {
		panic(<span class="enscript-string">&quot;%s: non-NULL ifma_ll=%p for ifma=%p&quot;</span>, __func__,
		    ifma-&gt;ifma_ll, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	ifma-&gt;ifma_debug &amp;= ~IFD_ALLOC;
	<span class="enscript-keyword">if</span> ((ifma-&gt;ifma_debug &amp; (IFD_DEBUG | IFD_TRASHED)) ==
	    (IFD_DEBUG | IFD_TRASHED)) {
		lck_mtx_lock(&amp;ifma_trash_lock);
		TAILQ_REMOVE(&amp;ifma_trash_head, (<span class="enscript-type">struct</span> ifmultiaddr_dbg *)ifma,
		    ifma_trash_link);
		lck_mtx_unlock(&amp;ifma_trash_lock);
		ifma-&gt;ifma_debug &amp;= ~IFD_TRASHED;
	}
	IFMA_UNLOCK(ifma);

	<span class="enscript-keyword">if</span> (ifma-&gt;ifma_addr != NULL) {
		FREE(ifma-&gt;ifma_addr, M_IFADDR);
		ifma-&gt;ifma_addr = NULL;
	}
	lck_mtx_destroy(&amp;ifma-&gt;ifma_lock, ifa_mtx_grp);
	zfree(ifma_zone, ifma);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ifma_trace</span>(<span class="enscript-type">struct</span> ifmultiaddr *ifma, <span class="enscript-type">int</span> refhold)
{
	<span class="enscript-type">struct</span> ifmultiaddr_dbg *ifma_dbg = (<span class="enscript-type">struct</span> ifmultiaddr_dbg *)ifma;
	ctrace_t *tr;
	u_int32_t idx;
	u_int16_t *cnt;

	<span class="enscript-keyword">if</span> (!(ifma-&gt;ifma_debug &amp; IFD_DEBUG)) {
		panic(<span class="enscript-string">&quot;%s: ifma %p has no debug structure&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (refhold) {
		cnt = &amp;ifma_dbg-&gt;ifma_refhold_cnt;
		tr = ifma_dbg-&gt;ifma_refhold;
	} <span class="enscript-keyword">else</span> {
		cnt = &amp;ifma_dbg-&gt;ifma_refrele_cnt;
		tr = ifma_dbg-&gt;ifma_refrele;
	}

	idx = atomic_add_16_ov(cnt, 1) % IFMA_TRACE_HIST_SIZE;
	ctrace_record(&amp;tr[idx]);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifma_addref</span>(<span class="enscript-type">struct</span> ifmultiaddr *ifma, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (!locked)
		IFMA_LOCK(ifma);
	<span class="enscript-keyword">else</span>
		IFMA_LOCK_ASSERT_HELD(ifma);

	<span class="enscript-keyword">if</span> (++ifma-&gt;ifma_refcount == 0) {
		panic(<span class="enscript-string">&quot;%s: ifma=%p wraparound refcnt&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifma-&gt;ifma_trace != NULL) {
		(*ifma-&gt;ifma_trace)(ifma, TRUE);
	}
	<span class="enscript-keyword">if</span> (!locked)
		IFMA_UNLOCK(ifma);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifma_remref</span>(<span class="enscript-type">struct</span> ifmultiaddr *ifma)
{
	<span class="enscript-type">struct</span> ifmultiaddr *ll;

	IFMA_LOCK(ifma);

	<span class="enscript-keyword">if</span> (ifma-&gt;ifma_refcount == 0) {
		panic(<span class="enscript-string">&quot;%s: ifma=%p negative refcnt&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifma-&gt;ifma_trace != NULL) {
		(*ifma-&gt;ifma_trace)(ifma, FALSE);
	}

	--ifma-&gt;ifma_refcount;
	<span class="enscript-keyword">if</span> (ifma-&gt;ifma_refcount &gt; 0) {
		IFMA_UNLOCK(ifma);
		<span class="enscript-keyword">return</span>;
	}

	ll = ifma-&gt;ifma_ll;
	ifma-&gt;ifma_ifp = NULL;
	ifma-&gt;ifma_ll = NULL;
	IFMA_UNLOCK(ifma);
	ifma_free(ifma);	<span class="enscript-comment">/* deallocate it */</span>

	<span class="enscript-keyword">if</span> (ll != NULL)
		IFMA_REMREF(ll);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">if_attach_ifma</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifmultiaddr *ifma, <span class="enscript-type">int</span> anon)
{
	ifnet_lock_assert(ifp, IFNET_LCK_ASSERT_EXCLUSIVE);
	IFMA_LOCK_ASSERT_HELD(ifma);

	<span class="enscript-keyword">if</span> (ifma-&gt;ifma_ifp != ifp) {
		panic(<span class="enscript-string">&quot;%s: Mismatch ifma_ifp=%p != ifp=%p&quot;</span>, __func__,
		    ifma-&gt;ifma_ifp, ifp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifma-&gt;ifma_debug &amp; IFD_ATTACHED) {
		panic(<span class="enscript-string">&quot;%s: Attempt to attach an already attached ifma=%p&quot;</span>,
		    __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (anon &amp;&amp; (ifma-&gt;ifma_flags &amp; IFMAF_ANONYMOUS)) {
		panic(<span class="enscript-string">&quot;%s: ifma=%p unexpected IFMAF_ANONYMOUS&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifma-&gt;ifma_debug &amp; IFD_TRASHED) {
		panic(<span class="enscript-string">&quot;%s: Attempt to reattach a detached ifma=%p&quot;</span>,
		    __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	ifma-&gt;ifma_reqcnt++;
	VERIFY(ifma-&gt;ifma_reqcnt == 1);
	IFMA_ADDREF_LOCKED(ifma);
	ifma-&gt;ifma_debug |= IFD_ATTACHED;
	<span class="enscript-keyword">if</span> (anon) {
		ifma-&gt;ifma_anoncnt++;
		VERIFY(ifma-&gt;ifma_anoncnt == 1);
		ifma-&gt;ifma_flags |= IFMAF_ANONYMOUS;
	}

	LIST_INSERT_HEAD(&amp;ifp-&gt;if_multiaddrs, ifma, ifma_link);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">if_detach_ifma</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifmultiaddr *ifma, <span class="enscript-type">int</span> anon)
{
	ifnet_lock_assert(ifp, IFNET_LCK_ASSERT_EXCLUSIVE);
	IFMA_LOCK_ASSERT_HELD(ifma);

	<span class="enscript-keyword">if</span> (ifma-&gt;ifma_reqcnt == 0) {
		panic(<span class="enscript-string">&quot;%s: ifma=%p negative reqcnt&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (anon &amp;&amp; !(ifma-&gt;ifma_flags &amp; IFMAF_ANONYMOUS)) {
		panic(<span class="enscript-string">&quot;%s: ifma=%p missing IFMAF_ANONYMOUS&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (anon &amp;&amp; ifma-&gt;ifma_anoncnt == 0) {
		panic(<span class="enscript-string">&quot;%s: ifma=%p negative anonreqcnt&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifma-&gt;ifma_ifp != ifp) {
		panic(<span class="enscript-string">&quot;%s: Mismatch ifma_ifp=%p, ifp=%p&quot;</span>, __func__,
		    ifma-&gt;ifma_ifp, ifp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (anon) {
		--ifma-&gt;ifma_anoncnt;
		<span class="enscript-keyword">if</span> (ifma-&gt;ifma_anoncnt &gt; 0)
			<span class="enscript-keyword">return</span> (0);
		ifma-&gt;ifma_flags &amp;= ~IFMAF_ANONYMOUS;
	}

	--ifma-&gt;ifma_reqcnt;
	<span class="enscript-keyword">if</span> (ifma-&gt;ifma_reqcnt &gt; 0)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (ifma-&gt;ifma_protospec != NULL) {
		panic(<span class="enscript-string">&quot;%s: Protospec not NULL for ifma=%p&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ifma-&gt;ifma_flags &amp; IFMAF_ANONYMOUS) ||
	    ifma-&gt;ifma_anoncnt != 0) {
		panic(<span class="enscript-string">&quot;%s: Detaching ifma=%p with outstanding anon req&quot;</span>,
		    __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifma-&gt;ifma_debug &amp; IFD_ATTACHED)) {
		panic(<span class="enscript-string">&quot;%s: Attempt to detach an unattached address ifma=%p&quot;</span>,
		    __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifma-&gt;ifma_debug &amp; IFD_TRASHED) {
		panic(<span class="enscript-string">&quot;%s: ifma %p is already in trash list&quot;</span>, __func__, ifma);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/*
	 * NOTE: Caller calls IFMA_REMREF
	 */</span>
	ifma-&gt;ifma_debug &amp;= ~IFD_ATTACHED;
	LIST_REMOVE(ifma, ifma_link);
	<span class="enscript-keyword">if</span> (LIST_EMPTY(&amp;ifp-&gt;if_multiaddrs))
		ifp-&gt;if_updatemcasts = 0;

	<span class="enscript-keyword">if</span> (ifma-&gt;ifma_debug &amp; IFD_DEBUG) {
		<span class="enscript-comment">/* Become a regular mutex, just in case */</span>
		IFMA_CONVERT_LOCK(ifma);
		lck_mtx_lock(&amp;ifma_trash_lock);
		TAILQ_INSERT_TAIL(&amp;ifma_trash_head,
		    (<span class="enscript-type">struct</span> ifmultiaddr_dbg *)ifma, ifma_trash_link);
		lck_mtx_unlock(&amp;ifma_trash_lock);
		ifma-&gt;ifma_debug |= IFD_TRASHED;
	}

	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * Find an ifmultiaddr that matches a socket address on an interface. 
 *
 * Caller is responsible for holding the ifnet_lock while calling
 * this function.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">if_addmulti_doesexist</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sa,
    <span class="enscript-type">struct</span> ifmultiaddr **retifma, <span class="enscript-type">int</span> anon)
{
	<span class="enscript-type">struct</span> ifmultiaddr *ifma;

	<span class="enscript-keyword">for</span> (ifma = LIST_FIRST(&amp;ifp-&gt;if_multiaddrs); ifma != NULL;
	     ifma = LIST_NEXT(ifma, ifma_link)) {
		IFMA_LOCK_SPIN(ifma);
		<span class="enscript-keyword">if</span> (!equal(sa, ifma-&gt;ifma_addr)) {
			IFMA_UNLOCK(ifma);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (anon) {
			VERIFY(!(ifma-&gt;ifma_flags &amp; IFMAF_ANONYMOUS) ||
			    ifma-&gt;ifma_anoncnt != 0);
			VERIFY((ifma-&gt;ifma_flags &amp; IFMAF_ANONYMOUS) ||
			    ifma-&gt;ifma_anoncnt == 0);
			ifma-&gt;ifma_anoncnt++;
			<span class="enscript-keyword">if</span> (!(ifma-&gt;ifma_flags &amp; IFMAF_ANONYMOUS)) {
				VERIFY(ifma-&gt;ifma_anoncnt == 1);
				ifma-&gt;ifma_flags |= IFMAF_ANONYMOUS;
			}
		}
		<span class="enscript-keyword">if</span> (!anon || ifma-&gt;ifma_anoncnt == 1) {
			ifma-&gt;ifma_reqcnt++;
			VERIFY(ifma-&gt;ifma_reqcnt &gt; 1);
		}
		<span class="enscript-keyword">if</span> (retifma != NULL) {
			*retifma = ifma;
			IFMA_ADDREF_LOCKED(ifma);
		}
		IFMA_UNLOCK(ifma);
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">return</span> (ENOENT);
}

<span class="enscript-comment">/*
 * Radar 3642395, make sure all multicasts are in a standard format.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr*
<span class="enscript-function-name">copy_and_normalize</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *original)
{
	<span class="enscript-type">int</span>			alen = 0;
	<span class="enscript-type">const</span> u_char		*aptr = NULL;
	<span class="enscript-type">struct</span> sockaddr		*copy = NULL;
	<span class="enscript-type">struct</span> sockaddr_dl	*sdl_new = NULL;
	<span class="enscript-type">int</span>			len = 0;

	<span class="enscript-keyword">if</span> (original-&gt;sa_family != AF_LINK &amp;&amp;
	    original-&gt;sa_family != AF_UNSPEC) {
		<span class="enscript-comment">/* Just make a copy */</span>
		MALLOC(copy, <span class="enscript-type">struct</span> sockaddr*, original-&gt;sa_len,
		    M_IFADDR, M_WAITOK);
		<span class="enscript-keyword">if</span> (copy != NULL)
			bcopy(original, copy, original-&gt;sa_len);
		<span class="enscript-keyword">return</span> (copy);
	}

	<span class="enscript-keyword">switch</span> (original-&gt;sa_family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_LINK</span>: {
			<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_dl *sdl_original =
			    (<span class="enscript-type">struct</span> sockaddr_dl*)(uintptr_t)(size_t)original;

			<span class="enscript-keyword">if</span> (sdl_original-&gt;sdl_nlen + sdl_original-&gt;sdl_alen +
			    sdl_original-&gt;sdl_slen +
			    offsetof(<span class="enscript-type">struct</span> sockaddr_dl, sdl_data) &gt;
			    sdl_original-&gt;sdl_len)
				<span class="enscript-keyword">return</span> (NULL);

			alen = sdl_original-&gt;sdl_alen;
			aptr = CONST_LLADDR(sdl_original);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_UNSPEC</span>: {
			<span class="enscript-keyword">if</span> (original-&gt;sa_len &lt; ETHER_ADDR_LEN +
			    offsetof(<span class="enscript-type">struct</span> sockaddr, sa_data)) {
				<span class="enscript-keyword">return</span> (NULL);
			}

			alen = ETHER_ADDR_LEN;
			aptr = (<span class="enscript-type">const</span> u_char*)original-&gt;sa_data;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (alen == 0 || aptr == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	len = alen + offsetof(<span class="enscript-type">struct</span> sockaddr_dl, sdl_data);
	MALLOC(sdl_new, <span class="enscript-type">struct</span> sockaddr_dl*, len, M_IFADDR, M_WAITOK);

	<span class="enscript-keyword">if</span> (sdl_new != NULL) {
		bzero(sdl_new, len);
		sdl_new-&gt;sdl_len = len;
		sdl_new-&gt;sdl_family = AF_LINK;
		sdl_new-&gt;sdl_alen = alen;
		bcopy(aptr, LLADDR(sdl_new), alen);
	}

	<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> sockaddr*)sdl_new);
}

<span class="enscript-comment">/*
 * Network-layer protocol domains which hold references to the underlying
 * link-layer record must use this routine.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">if_addmulti</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sa,
    <span class="enscript-type">struct</span> ifmultiaddr **retifma)
{
	<span class="enscript-keyword">return</span> (if_addmulti_common(ifp, sa, retifma, 0));
}

<span class="enscript-comment">/*
 * Anything other than network-layer protocol domains which hold references
 * to the underlying link-layer record must use this routine: SIOCADDMULTI
 * ioctl, ifnet_add_multicast(), if_bond.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">if_addmulti_anon</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sa,
    <span class="enscript-type">struct</span> ifmultiaddr **retifma)
{
	<span class="enscript-keyword">return</span> (if_addmulti_common(ifp, sa, retifma, 1));
}

<span class="enscript-comment">/*
 * Register an additional multicast address with a network interface.
 *
 * - If the address is already present, bump the reference count on the
 *   address and return.
 * - If the address is not link-layer, look up a link layer address.
 * - Allocate address structures for one or both addresses, and attach to the
 *   multicast address list on the interface.  If automatically adding a link
 *   layer address, the protocol address will own a reference to the link
 *   layer address, to be freed when it is freed.
 * - Notify the network device driver of an addition to the multicast address
 *   list.
 *
 * 'sa' points to caller-owned memory with the desired multicast address.
 *
 * 'retifma' will be used to return a pointer to the resulting multicast
 * address reference, if desired.
 *
 * 'anon' indicates a link-layer address with no protocol address reference
 * made to it.  Anything other than network-layer protocol domain requests
 * are considered as anonymous.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">if_addmulti_common</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sa,
    <span class="enscript-type">struct</span> ifmultiaddr **retifma, <span class="enscript-type">int</span> anon)
{
	<span class="enscript-type">struct</span> sockaddr_storage storage;
	<span class="enscript-type">struct</span> sockaddr *llsa = NULL;
	<span class="enscript-type">struct</span> sockaddr *dupsa = NULL;
	<span class="enscript-type">int</span> error = 0, ll_firstref = 0, lladdr;
	<span class="enscript-type">struct</span> ifmultiaddr *ifma = NULL;
	<span class="enscript-type">struct</span> ifmultiaddr *llifma = NULL;

	<span class="enscript-comment">/* Only AF_UNSPEC/AF_LINK is allowed for an &quot;anonymous&quot; address */</span>
	VERIFY(!anon || sa-&gt;sa_family == AF_UNSPEC ||
	    sa-&gt;sa_family == AF_LINK);

	<span class="enscript-comment">/* If sa is a AF_LINK or AF_UNSPEC, duplicate and normalize it */</span>
	<span class="enscript-keyword">if</span> (sa-&gt;sa_family == AF_LINK || sa-&gt;sa_family == AF_UNSPEC) {
		dupsa = copy_and_normalize(sa);
		<span class="enscript-keyword">if</span> (dupsa == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
		}
		sa = dupsa;
	}

	ifnet_lock_exclusive(ifp);
	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; IFF_MULTICAST)) {
		error = EADDRNOTAVAIL;
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	}

	<span class="enscript-comment">/* If the address is already present, return a new reference to it */</span>
	error = if_addmulti_doesexist(ifp, sa, retifma, anon);
	ifnet_lock_done(ifp);
	<span class="enscript-keyword">if</span> (error == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

	<span class="enscript-comment">/*
	 * The address isn't already present; give the link layer a chance
	 * to accept/reject it, and also find out which AF_LINK address this
	 * maps to, if it isn't one already.
	 */</span>
	error = dlil_resolve_multi(ifp, sa, (<span class="enscript-type">struct</span> sockaddr *)&amp;storage,
	    <span class="enscript-keyword">sizeof</span> (storage));
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; storage.ss_len != 0) {
		llsa = copy_and_normalize((<span class="enscript-type">struct</span> sockaddr *)&amp;storage);
		<span class="enscript-keyword">if</span> (llsa == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
		}

		llifma = ifma_alloc(M_WAITOK);
		<span class="enscript-keyword">if</span> (llifma == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
		}
	}

	<span class="enscript-comment">/* to be similar to FreeBSD */</span>
	<span class="enscript-keyword">if</span> (error == EOPNOTSUPP)
		error = 0;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

	<span class="enscript-comment">/* Allocate while we aren't holding any locks */</span>
	<span class="enscript-keyword">if</span> (dupsa == NULL) {
		dupsa = copy_and_normalize(sa);
		<span class="enscript-keyword">if</span> (dupsa == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
		}
	}
	ifma = ifma_alloc(M_WAITOK);
	<span class="enscript-keyword">if</span> (ifma == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	}

	ifnet_lock_exclusive(ifp);
	<span class="enscript-comment">/*
	 * Check again for the matching multicast.
	 */</span>
	error = if_addmulti_doesexist(ifp, sa, retifma, anon);
	<span class="enscript-keyword">if</span> (error == 0) {
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
	}

	<span class="enscript-keyword">if</span> (llifma != NULL) {
		VERIFY(!anon);	<span class="enscript-comment">/* must not get here if &quot;anonymous&quot; */</span>
		<span class="enscript-keyword">if</span> (if_addmulti_doesexist(ifp, llsa, &amp;ifma-&gt;ifma_ll, 0) == 0) {
			FREE(llsa, M_IFADDR);
			llsa = NULL;
			ifma_free(llifma);
			llifma = NULL;
			VERIFY(ifma-&gt;ifma_ll-&gt;ifma_ifp == ifp);
		} <span class="enscript-keyword">else</span> {
			ll_firstref = 1;
			llifma-&gt;ifma_addr = llsa;
			llifma-&gt;ifma_ifp = ifp;
			IFMA_LOCK(llifma);
			if_attach_ifma(ifp, llifma, 0);
			<span class="enscript-comment">/* add extra refcnt for ifma */</span>
			IFMA_ADDREF_LOCKED(llifma);
			IFMA_UNLOCK(llifma);
			ifma-&gt;ifma_ll = llifma;
		}
	}

	<span class="enscript-comment">/* &quot;anonymous&quot; request should not result in network address */</span>
	VERIFY(!anon || ifma-&gt;ifma_ll == NULL);

	ifma-&gt;ifma_addr = dupsa;
	ifma-&gt;ifma_ifp = ifp;
	IFMA_LOCK(ifma);
	if_attach_ifma(ifp, ifma, anon);
	IFMA_ADDREF_LOCKED(ifma);		<span class="enscript-comment">/* for this routine */</span>
	<span class="enscript-keyword">if</span> (retifma != NULL) {
		*retifma = ifma;
		IFMA_ADDREF_LOCKED(*retifma);	<span class="enscript-comment">/* for caller */</span>
	}
	lladdr = (ifma-&gt;ifma_addr-&gt;sa_family == AF_UNSPEC ||
	    ifma-&gt;ifma_addr-&gt;sa_family == AF_LINK);
	IFMA_UNLOCK(ifma);
	ifnet_lock_done(ifp);

	rt_newmaddrmsg(RTM_NEWMADDR, ifma);
	IFMA_REMREF(ifma);			<span class="enscript-comment">/* for this routine */</span>

	<span class="enscript-comment">/*
	 * We are certain we have added something, so call down to the
	 * interface to let them know about it.  Do this only for newly-
	 * added AF_LINK/AF_UNSPEC address in the if_multiaddrs set.
	 */</span>
	<span class="enscript-keyword">if</span> (lladdr || ll_firstref)
		(<span class="enscript-type">void</span>) ifnet_ioctl(ifp, 0, SIOCADDMULTI, NULL);

	<span class="enscript-keyword">if</span> (ifp-&gt;if_updatemcasts &gt; 0)
		ifp-&gt;if_updatemcasts = 0;

	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">cleanup</span>:
	<span class="enscript-keyword">if</span> (ifma != NULL)
		ifma_free(ifma);
	<span class="enscript-keyword">if</span> (dupsa != NULL)
		FREE(dupsa, M_IFADDR);
	<span class="enscript-keyword">if</span> (llifma != NULL)
		ifma_free(llifma);
	<span class="enscript-keyword">if</span> (llsa != NULL)
		FREE(llsa, M_IFADDR);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Delete a multicast group membership by network-layer group address.
 * This routine is deprecated.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">if_delmulti</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sa)
{
	<span class="enscript-keyword">return</span> (if_delmulti_common(NULL, ifp, sa, 0));
}

<span class="enscript-comment">/*
 * Delete a multicast group membership by group membership pointer.
 * Network-layer protocol domains must use this routine.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">if_delmulti_ifma</span>(<span class="enscript-type">struct</span> ifmultiaddr *ifma)
{
	<span class="enscript-keyword">return</span> (if_delmulti_common(ifma, NULL, NULL, 0));
}

<span class="enscript-comment">/*
 * Anything other than network-layer protocol domains which hold references
 * to the underlying link-layer record must use this routine: SIOCDELMULTI
 * ioctl, ifnet_remove_multicast(), if_bond.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">if_delmulti_anon</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sa)
{
	<span class="enscript-keyword">return</span> (if_delmulti_common(NULL, ifp, sa, 1));
}

<span class="enscript-comment">/*
 * Delete a multicast group membership by network-layer group address.
 *
 * Returns ENOENT if the entry could not be found.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">if_delmulti_common</span>(<span class="enscript-type">struct</span> ifmultiaddr *ifma, <span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *sa, <span class="enscript-type">int</span> anon)
{
	<span class="enscript-type">struct</span> sockaddr		*dupsa = NULL;
	<span class="enscript-type">int</span>			lastref, ll_lastref = 0, lladdr;
	<span class="enscript-type">struct</span> ifmultiaddr	*ll = NULL;

	<span class="enscript-comment">/* sanity check for callers */</span>
	VERIFY(ifma != NULL || (ifp != NULL &amp;&amp; sa != NULL));

	<span class="enscript-keyword">if</span> (ifma != NULL)
		ifp = ifma-&gt;ifma_ifp;

	<span class="enscript-keyword">if</span> (sa != NULL &amp;&amp;
	    (sa-&gt;sa_family == AF_LINK || sa-&gt;sa_family == AF_UNSPEC)) {
		dupsa = copy_and_normalize(sa);
		<span class="enscript-keyword">if</span> (dupsa == NULL)
			<span class="enscript-keyword">return</span> (ENOMEM);
		sa = dupsa;
	}

	ifnet_lock_exclusive(ifp);
	<span class="enscript-keyword">if</span> (ifma == NULL) {
		<span class="enscript-keyword">for</span> (ifma = LIST_FIRST(&amp;ifp-&gt;if_multiaddrs); ifma != NULL;
		     ifma = LIST_NEXT(ifma, ifma_link)) {
			IFMA_LOCK(ifma);
			<span class="enscript-keyword">if</span> (!equal(sa, ifma-&gt;ifma_addr) ||
			    (anon &amp;&amp; !(ifma-&gt;ifma_flags &amp; IFMAF_ANONYMOUS))) {
				VERIFY(!(ifma-&gt;ifma_flags &amp; IFMAF_ANONYMOUS) ||
				    ifma-&gt;ifma_anoncnt != 0);
				IFMA_UNLOCK(ifma);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/* found; keep it locked */</span>
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (ifma == NULL) {
			<span class="enscript-keyword">if</span> (dupsa != NULL)
				FREE(dupsa, M_IFADDR);
			ifnet_lock_done(ifp);
			<span class="enscript-keyword">return</span> (ENOENT);
		}
	} <span class="enscript-keyword">else</span> {
		IFMA_LOCK(ifma);
	}
	IFMA_LOCK_ASSERT_HELD(ifma);
	IFMA_ADDREF_LOCKED(ifma);	<span class="enscript-comment">/* for this routine */</span>
	lastref = if_detach_ifma(ifp, ifma, anon);
	VERIFY(!lastref || (!(ifma-&gt;ifma_debug &amp; IFD_ATTACHED) &amp;&amp;
	    ifma-&gt;ifma_reqcnt == 0));
	VERIFY(!anon || ifma-&gt;ifma_ll == NULL);
	ll = ifma-&gt;ifma_ll;
	lladdr = (ifma-&gt;ifma_addr-&gt;sa_family == AF_UNSPEC ||
	    ifma-&gt;ifma_addr-&gt;sa_family == AF_LINK);
	IFMA_UNLOCK(ifma);
	<span class="enscript-keyword">if</span> (lastref &amp;&amp; ll != NULL) {
		IFMA_LOCK(ll);
		ll_lastref = if_detach_ifma(ifp, ll, 0);
		IFMA_UNLOCK(ll);
	}
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">if</span> (lastref)
		rt_newmaddrmsg(RTM_DELMADDR, ifma);

	<span class="enscript-keyword">if</span> ((ll == NULL &amp;&amp; lastref &amp;&amp; lladdr) || ll_lastref) {
		<span class="enscript-comment">/*
		 * Make sure the interface driver is notified in the
		 * case of a link layer mcast group being left.  Do
		 * this only for a AF_LINK/AF_UNSPEC address that has
		 * been removed from the if_multiaddrs set.
		 */</span>
		ifnet_ioctl(ifp, 0, SIOCDELMULTI, NULL);
	}

	<span class="enscript-keyword">if</span> (lastref)
		IFMA_REMREF(ifma);	<span class="enscript-comment">/* for if_multiaddrs list */</span>
	<span class="enscript-keyword">if</span> (ll_lastref)
		IFMA_REMREF(ll);	<span class="enscript-comment">/* for if_multiaddrs list */</span>

	IFMA_REMREF(ifma);		<span class="enscript-comment">/* for this routine */</span>
	<span class="enscript-keyword">if</span> (dupsa != NULL)
		FREE(dupsa, M_IFADDR);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Shutdown all network activity.  Used boot() when halting
 * system.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">if_down_all</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> ifnet **ifp;
	u_int32_t	count;
	u_int32_t	i;

	<span class="enscript-keyword">if</span> (ifnet_list_get_all(IFNET_FAMILY_ANY, &amp;ifp, &amp;count) == 0) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
			if_down(ifp[i]);
			dlil_proto_unplumb_all(ifp[i]);
		}
		ifnet_list_free(ifp);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Delete Routes for a Network Interface
 * 
 * Called for each routing entry via the rnh-&gt;rnh_walktree() call above
 * to delete all route entries referencing a detaching network interface.
 *
 * Arguments:
 *	rn	pointer to node in the routing table
 *	arg	argument passed to rnh-&gt;rnh_walktree() - detaching interface
 *
 * Returns:
 *	0	successful
 *	errno	failed - reason indicated
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">if_rtdel</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> rtentry	*rt = (<span class="enscript-type">struct</span> rtentry *)rn;
	<span class="enscript-type">struct</span> ifnet	*ifp = arg;
	<span class="enscript-type">int</span>		err;

	<span class="enscript-keyword">if</span> (rt == NULL)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-comment">/*
	 * Checking against RTF_UP protects against walktree
	 * recursion problems with cloned routes.
	 */</span>
	RT_LOCK(rt);
	<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp == ifp &amp;&amp; (rt-&gt;rt_flags &amp; RTF_UP)) {
		<span class="enscript-comment">/*
		 * Safe to drop rt_lock and use rt_key, rt_gateway,
		 * since holding rnh_lock here prevents another thread
		 * from calling rt_setgate() on this route.
		 */</span>
		RT_UNLOCK(rt);
		err = rtrequest_locked(RTM_DELETE, rt_key(rt), rt-&gt;rt_gateway,
		    rt_mask(rt), rt-&gt;rt_flags, NULL);
		<span class="enscript-keyword">if</span> (err) {
			log(LOG_WARNING, <span class="enscript-string">&quot;if_rtdel: error %d\n&quot;</span>, err);
		}
	} <span class="enscript-keyword">else</span> {
		RT_UNLOCK(rt);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Removes routing table reference to a given interface
 * for a given protocol family
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">if_rtproto_del</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> protocol)
{
	<span class="enscript-type">struct</span> radix_node_head  *rnh;

	<span class="enscript-keyword">if</span> ((protocol &lt;= AF_MAX) &amp;&amp; (protocol &gt;= 0) &amp;&amp;
		((rnh = rt_tables[protocol]) != NULL) &amp;&amp; (ifp != NULL)) {
		lck_mtx_lock(rnh_lock);
		(<span class="enscript-type">void</span>) rnh-&gt;rnh_walktree(rnh, if_rtdel, ifp);
		lck_mtx_unlock(rnh_lock);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">if_rtmtu</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)rn;
	<span class="enscript-type">struct</span> ifnet *ifp = arg;

	RT_LOCK(rt);
	<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp == ifp) {
		<span class="enscript-comment">/*
		 * Update the MTU of this entry only if the MTU
		 * has not been locked (RTV_MTU is not set) and
		 * if it was non-zero to begin with.
		 */</span>
		<span class="enscript-keyword">if</span> (!(rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU) &amp;&amp; rt-&gt;rt_rmx.rmx_mtu)
			rt-&gt;rt_rmx.rmx_mtu = ifp-&gt;if_mtu;
	}
	RT_UNLOCK(rt);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Update the MTU metric of all route entries in all protocol tables
 * associated with a particular interface; this is called when the
 * MTU of that interface has changed.
 */</span>
<span class="enscript-type">static</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">if_rtmtu_update</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	<span class="enscript-type">int</span> p;

	<span class="enscript-keyword">for</span> (p = 0; p &lt; AF_MAX + 1; p++) {
		<span class="enscript-keyword">if</span> ((rnh = rt_tables[p]) == NULL)
			<span class="enscript-keyword">continue</span>;

		lck_mtx_lock(rnh_lock);
		(<span class="enscript-type">void</span>) rnh-&gt;rnh_walktree(rnh, if_rtmtu, ifp);
		lck_mtx_unlock(rnh_lock);
	}
	routegenid_update();
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_data_internal_to_if_data</span>(<span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> if_data_internal *if_data_int, <span class="enscript-type">struct</span> if_data *if_data)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">COPYFIELD</span>(fld)		if_data-&gt;fld = if_data_int-&gt;fld
#<span class="enscript-reference">define</span> <span class="enscript-function-name">COPYFIELD32</span>(fld)	if_data-&gt;fld = (u_int32_t)(if_data_int-&gt;fld)
<span class="enscript-comment">/* compiler will cast down to 32-bit */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">COPYFIELD32_ATOMIC</span>(fld) do {					\
	atomic_get_64(if_data-&gt;fld,					\
	    (u_int64_t *)(<span class="enscript-type">void</span> *)(uintptr_t)&amp;if_data_int-&gt;fld);		\
} <span class="enscript-keyword">while</span> (0)

	COPYFIELD(ifi_type);
	COPYFIELD(ifi_typelen);
	COPYFIELD(ifi_physical);
	COPYFIELD(ifi_addrlen);
	COPYFIELD(ifi_hdrlen);
	COPYFIELD(ifi_recvquota);
	COPYFIELD(ifi_xmitquota);
	if_data-&gt;ifi_unused1 = 0;
	COPYFIELD(ifi_mtu);
	COPYFIELD(ifi_metric);
	<span class="enscript-keyword">if</span> (if_data_int-&gt;ifi_baudrate &amp; 0xFFFFFFFF00000000LL) {
		if_data-&gt;ifi_baudrate = 0xFFFFFFFF;
	} <span class="enscript-keyword">else</span> {
		COPYFIELD32(ifi_baudrate);
	}

	COPYFIELD32_ATOMIC(ifi_ipackets);
	COPYFIELD32_ATOMIC(ifi_ierrors);
	COPYFIELD32_ATOMIC(ifi_opackets);
	COPYFIELD32_ATOMIC(ifi_oerrors);
	COPYFIELD32_ATOMIC(ifi_collisions);
	COPYFIELD32_ATOMIC(ifi_ibytes);
	COPYFIELD32_ATOMIC(ifi_obytes);
	COPYFIELD32_ATOMIC(ifi_imcasts);
	COPYFIELD32_ATOMIC(ifi_omcasts);
	COPYFIELD32_ATOMIC(ifi_iqdrops);
	COPYFIELD32_ATOMIC(ifi_noproto);

	COPYFIELD(ifi_recvtiming);
	COPYFIELD(ifi_xmittiming);

	if_data-&gt;ifi_lastchange.tv_sec = if_data_int-&gt;ifi_lastchange.tv_sec;
	if_data-&gt;ifi_lastchange.tv_usec = if_data_int-&gt;ifi_lastchange.tv_usec;

	if_data-&gt;ifi_lastchange.tv_sec += boottime_sec();

	if_data-&gt;ifi_unused2 = 0;
	COPYFIELD(ifi_hwassist);
	if_data-&gt;ifi_reserved1 = 0;
	if_data-&gt;ifi_reserved2 = 0;
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">COPYFIELD32_ATOMIC</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">COPYFIELD32</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">COPYFIELD</span>
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_data_internal_to_if_data64</span>(<span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> if_data_internal *if_data_int,
    <span class="enscript-type">struct</span> if_data64 *if_data64)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">COPYFIELD64</span>(fld)	if_data64-&gt;fld = if_data_int-&gt;fld
#<span class="enscript-reference">define</span> <span class="enscript-function-name">COPYFIELD64_ATOMIC</span>(fld) do {					\
	atomic_get_64(if_data64-&gt;fld,					\
	    (u_int64_t *)(<span class="enscript-type">void</span> *)(uintptr_t)&amp;if_data_int-&gt;fld);		\
} <span class="enscript-keyword">while</span> (0)

	COPYFIELD64(ifi_type);
	COPYFIELD64(ifi_typelen);
	COPYFIELD64(ifi_physical);
	COPYFIELD64(ifi_addrlen);
	COPYFIELD64(ifi_hdrlen);
	COPYFIELD64(ifi_recvquota);
	COPYFIELD64(ifi_xmitquota);
	if_data64-&gt;ifi_unused1 = 0;
	COPYFIELD64(ifi_mtu);
	COPYFIELD64(ifi_metric);
	COPYFIELD64(ifi_baudrate);

	COPYFIELD64_ATOMIC(ifi_ipackets);
	COPYFIELD64_ATOMIC(ifi_ierrors);
	COPYFIELD64_ATOMIC(ifi_opackets);
	COPYFIELD64_ATOMIC(ifi_oerrors);
	COPYFIELD64_ATOMIC(ifi_collisions);
	COPYFIELD64_ATOMIC(ifi_ibytes);
	COPYFIELD64_ATOMIC(ifi_obytes);
	COPYFIELD64_ATOMIC(ifi_imcasts);
	COPYFIELD64_ATOMIC(ifi_omcasts);
	COPYFIELD64_ATOMIC(ifi_iqdrops);
	COPYFIELD64_ATOMIC(ifi_noproto);

	<span class="enscript-comment">/* Note these two fields are actually 32 bit, so doing COPYFIELD64_ATOMIC will
	 * cause them to be misaligned
	 */</span>
	COPYFIELD64(ifi_recvtiming);
	COPYFIELD64(ifi_xmittiming);

	if_data64-&gt;ifi_lastchange.tv_sec = if_data_int-&gt;ifi_lastchange.tv_sec;
	if_data64-&gt;ifi_lastchange.tv_usec = if_data_int-&gt;ifi_lastchange.tv_usec;

	if_data64-&gt;ifi_lastchange.tv_sec += boottime_sec();

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">COPYFIELD64</span>
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">if_copy_traffic_class</span>(<span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">struct</span> if_traffic_class *if_tc)
{
#<span class="enscript-reference">define</span> <span class="enscript-function-name">COPY_IF_TC_FIELD64_ATOMIC</span>(fld) do {			\
	atomic_get_64(if_tc-&gt;fld,				\
	    (u_int64_t *)(<span class="enscript-type">void</span> *)(uintptr_t)&amp;ifp-&gt;if_tc.fld);	\
} <span class="enscript-keyword">while</span> (0)

	bzero(if_tc, <span class="enscript-keyword">sizeof</span> (*if_tc));
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ibepackets);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ibebytes);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_obepackets);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_obebytes);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ibkpackets);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ibkbytes);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_obkpackets);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_obkbytes);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ivipackets);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ivibytes);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ovipackets);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ovibytes);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ivopackets);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ivobytes);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ovopackets);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ovobytes);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ipvpackets);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_ipvbytes);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_opvpackets);
	COPY_IF_TC_FIELD64_ATOMIC(ifi_opvbytes);

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">COPY_IF_TC_FIELD64_ATOMIC</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">if_copy_data_extended</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> if_data_extended *if_de)
{
#<span class="enscript-reference">define</span> <span class="enscript-function-name">COPY_IF_DE_FIELD64_ATOMIC</span>(fld) do {			\
	atomic_get_64(if_de-&gt;fld,				\
	    (u_int64_t *)(<span class="enscript-type">void</span> *)(uintptr_t)&amp;ifp-&gt;if_data.fld);	\
} <span class="enscript-keyword">while</span> (0)

	bzero(if_de, <span class="enscript-keyword">sizeof</span> (*if_de));
	COPY_IF_DE_FIELD64_ATOMIC(ifi_alignerrs);
	COPY_IF_DE_FIELD64_ATOMIC(ifi_dt_bytes);
	COPY_IF_DE_FIELD64_ATOMIC(ifi_fpackets);
	COPY_IF_DE_FIELD64_ATOMIC(ifi_fbytes);

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">COPY_IF_DE_FIELD64_ATOMIC</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">if_copy_packet_stats</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> if_packet_stats *if_ps)
{
#<span class="enscript-reference">define</span> <span class="enscript-function-name">COPY_IF_PS_TCP_FIELD64_ATOMIC</span>(fld) do {				\
	atomic_get_64(if_ps-&gt;ifi_tcp_##fld,				\
	    (u_int64_t *)(<span class="enscript-type">void</span> *)(uintptr_t)&amp;ifp-&gt;if_tcp_stat-&gt;fld);	\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">COPY_IF_PS_UDP_FIELD64_ATOMIC</span>(fld) do {				\
	atomic_get_64(if_ps-&gt;ifi_udp_##fld,				\
	    (u_int64_t *)(<span class="enscript-type">void</span> *)(uintptr_t)&amp;ifp-&gt;if_udp_stat-&gt;fld);	\
} <span class="enscript-keyword">while</span> (0)

	COPY_IF_PS_TCP_FIELD64_ATOMIC(badformat);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(unspecv6);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(synfin);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(badformatipsec);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(noconnnolist);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(noconnlist);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(listbadsyn);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(icmp6unreach);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(deprecate6);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(ooopacket);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(rstinsynrcv);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(dospacket);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(cleanup);
	COPY_IF_PS_TCP_FIELD64_ATOMIC(synwindow);

	COPY_IF_PS_UDP_FIELD64_ATOMIC(port_unreach);
	COPY_IF_PS_UDP_FIELD64_ATOMIC(faithprefix);
	COPY_IF_PS_UDP_FIELD64_ATOMIC(port0);
	COPY_IF_PS_UDP_FIELD64_ATOMIC(badlength);
	COPY_IF_PS_UDP_FIELD64_ATOMIC(badchksum);
	COPY_IF_PS_UDP_FIELD64_ATOMIC(badmcast);
	COPY_IF_PS_UDP_FIELD64_ATOMIC(cleanup);
	COPY_IF_PS_UDP_FIELD64_ATOMIC(badipsec);

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">COPY_IF_PS_TCP_FIELD64_ATOMIC</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">COPY_IF_PS_UDP_FIELD64_ATOMIC</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">if_copy_rxpoll_stats</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> if_rxpoll_stats *if_rs)
{
	bzero(if_rs, <span class="enscript-keyword">sizeof</span> (*if_rs));
	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_RXPOLL) || !ifnet_is_attached(ifp, 1))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* by now, ifnet will stay attached so if_inp must be valid */</span>
	VERIFY(ifp-&gt;if_inp != NULL);
	bcopy(&amp;ifp-&gt;if_inp-&gt;pstats, if_rs, <span class="enscript-keyword">sizeof</span> (*if_rs));

	<span class="enscript-comment">/* Release the IO refcnt */</span>
	ifnet_decr_iorefcnt(ifp);
}

<span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">ifa_remref</span>(<span class="enscript-type">struct</span> ifaddr *ifa, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (!locked)
		IFA_LOCK_SPIN(ifa);
	<span class="enscript-keyword">else</span>
		IFA_LOCK_ASSERT_HELD(ifa);

	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_refcnt == 0)
		panic(<span class="enscript-string">&quot;%s: ifa %p negative refcnt\n&quot;</span>, __func__, ifa);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa-&gt;ifa_trace != NULL)
		(*ifa-&gt;ifa_trace)(ifa, FALSE);
	<span class="enscript-keyword">if</span> (--ifa-&gt;ifa_refcnt == 0) {
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_debug &amp; IFD_ATTACHED)
			panic(<span class="enscript-string">&quot;ifa %p attached to ifp is being freed\n&quot;</span>, ifa);
		<span class="enscript-comment">/*
		 * Some interface addresses are allocated either statically
		 * or carved out of a larger block.  Only free it if it was
		 * allocated via MALLOC or via the corresponding per-address
		 * family allocator.  Otherwise, leave it alone.
		 */</span>
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_debug &amp; IFD_ALLOC) {
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_free == NULL) {
				IFA_UNLOCK(ifa);
				FREE(ifa, M_IFADDR);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Become a regular mutex */</span>
				IFA_CONVERT_LOCK(ifa);
				<span class="enscript-comment">/* callee will unlock */</span>
				(*ifa-&gt;ifa_free)(ifa);
			}
		} <span class="enscript-keyword">else</span> {
			IFA_UNLOCK(ifa);
		}
		ifa = NULL;
	}

	<span class="enscript-keyword">if</span> (!locked &amp;&amp; ifa != NULL)
		IFA_UNLOCK(ifa);

	<span class="enscript-keyword">return</span> (ifa);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifa_addref</span>(<span class="enscript-type">struct</span> ifaddr *ifa, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (!locked)
		IFA_LOCK_SPIN(ifa);
	<span class="enscript-keyword">else</span>
		IFA_LOCK_ASSERT_HELD(ifa);

	<span class="enscript-keyword">if</span> (++ifa-&gt;ifa_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s: ifa %p wraparound refcnt\n&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa-&gt;ifa_trace != NULL) {
		(*ifa-&gt;ifa_trace)(ifa, TRUE);
	}
	<span class="enscript-keyword">if</span> (!locked)
		IFA_UNLOCK(ifa);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifa_lock_init</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	lck_mtx_init(&amp;ifa-&gt;ifa_lock, ifa_mtx_grp, ifa_mtx_attr);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifa_lock_destroy</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	IFA_LOCK_ASSERT_NOTHELD(ifa);
	lck_mtx_destroy(&amp;ifa-&gt;ifa_lock, ifa_mtx_grp);
}

<span class="enscript-comment">/*
 * 'i' group ioctls.
 *
 * The switch statement below does nothing at runtime, as it serves as a
 * compile time check to ensure that all of the socket 'i' ioctls (those
 * in the 'i' group going thru soo_ioctl) that are made available by the
 * networking stack is unique.  This works as long as this routine gets
 * updated each time a new interface ioctl gets added.
 *
 * Any failures at compile time indicates duplicated ioctl values.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((unused)) <span class="enscript-type">void</span>
<span class="enscript-function-name">ifioctl_cassert</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * This is equivalent to _CASSERT() and the compiler wouldn't
	 * generate any instructions, thus for compile time only.
	 */</span>
	<span class="enscript-keyword">switch</span> ((u_long)0) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:

	<span class="enscript-comment">/* bsd/net/if_ppp.h */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGPPPSTATS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGPPPCSTATS</span>:

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-comment">/* bsd/netinet6/in6_var.h */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFADDR_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFADDR_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFDSTADDR_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFNETMASK_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDSTADDR_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFNETMASK_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFADDR_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFADDR_IN6_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFADDR_IN6_64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPHYADDR_IN6_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPHYADDR_IN6_64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPSRCADDR_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPDSTADDR_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAFLAG_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDRLST_IN6_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDRLST_IN6_64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGPRLST_IN6_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGPRLST_IN6_64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFINFO_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFINFO_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSNDFLUSH_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGNBRINFO_IN6_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGNBRINFO_IN6_64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSPFXFLUSH_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSRTRFLUSH_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFALIFETIME_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFALIFETIME_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFSTAT_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFSTAT_ICMP6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSDEFIFACE_IN6_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSDEFIFACE_IN6_64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDEFIFACE_IN6_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDEFIFACE_IN6_64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFINFO_FLAGS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSSCOPE6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGSCOPE6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGSCOPE6DEF</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPREFIX_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPREFIX_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFPREFIX_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFPREFIX_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCCIFPREFIX_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSGIFPREFIX_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCPROTOATTACH_IN6_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCPROTOATTACH_IN6_64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCPROTODETACH_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_START_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_START_64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_STOP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAUTOCONF_START</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAUTOCONF_STOP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSETROUTERMODE_IN6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_CGASTART_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_CGASTART_64</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	<span class="enscript-comment">/* bsd/sys/sockio.h */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFDSTADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFDSTADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFFLAGS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFFLAGS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFBRDADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFBRDADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFCONF32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFCONF64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFNETMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFNETMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMETRIC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMETRIC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDSTADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFBRDADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFCONF32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFCONF64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFNETMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAUTOADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAUTONETMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCARPIPLL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCADDMULTI</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDELMULTI</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMTU</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMTU</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPHYS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPHYS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMEDIA</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMEDIA32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMEDIA64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFGENERIC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFGENERIC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCRSLVMULTI</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFLLADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFSTATUS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPHYADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPSRCADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPDSTADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFPHYADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDEVMTU</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFALTMTU</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFALTMTU</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFBOND</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFBOND</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCPROTOATTACH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCPROTODETACH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFCAP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFCAP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFCREATE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFDESTROY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFCREATE2</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSDRVSPEC32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDRVSPEC32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSDRVSPEC64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDRVSPEC64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFVLAN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFVLAN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFGCLONERS32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCIFGCLONERS64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFASYNCMAP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFASYNCMAP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFMAC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFMAC</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFKPI</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFKPI</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFWAKEFLAGS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFGETRTREFCNT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLINKQUALITYMETRIC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFOPPORTUNISTIC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFOPPORTUNISTIC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSETROUTERMODE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFEFLAGS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFDESC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDESC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFLINKPARAMS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLINKPARAMS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFQUEUESTATS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFTHROTTLE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFTHROTTLE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFLOG</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLOG</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDELEGATE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFLLADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFTYPE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFFUNCTIONALTYPE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFAGENTID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFAGENTID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTIDS32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTIDS64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTDATA32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAGENTDATA64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFINTERFACESTATE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFINTERFACESTATE</span>:
		;
	}
}
</pre>
<hr />
</body></html>