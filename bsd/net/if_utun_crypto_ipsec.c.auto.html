<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>if_utun_crypto_ipsec.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">if_utun_crypto_ipsec.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2011-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_utun.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span> 
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_utun.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_utun_crypto_ipsec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/bpf.h&gt;</span>

<span class="enscript-type">extern</span> lck_mtx_t *sadb_mutex;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>        esp_udp_encap_port; <span class="enscript-comment">// udp encap listening port
</span><span class="enscript-type">extern</span> <span class="enscript-type">int</span>        ipsec_policy_count;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>        ipsec_bypass;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>        natt_keepalive_interval;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>        utun_punt_rx_keepalive = 0; <span class="enscript-comment">// optional global control
</span>
<span class="enscript-type">extern</span> errno_t <span class="enscript-function-name">utun_pkt_input</span> (<span class="enscript-type">struct</span> utun_pcb *pcb, mbuf_t m);

<span class="enscript-type">static</span> u_int8_t
<span class="enscript-function-name">utun_ipsec_mode_to_sadb_mode</span> (if_utun_crypto_ipsec_mode_t mode)
{
	<span class="enscript-keyword">switch</span> (mode) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_MODE_TRANSPORT</span>:
		<span class="enscript-keyword">return</span> IPSEC_MODE_TRANSPORT;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_MODE_TUNNEL</span>:
		<span class="enscript-keyword">return</span> IPSEC_MODE_TUNNEL;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> 0;
	}
}

<span class="enscript-type">static</span> u_int16_t
<span class="enscript-function-name">utun_ipsec_proto_to_sadb_proto</span> (if_utun_crypto_ipsec_proto_t proto)
{
	<span class="enscript-keyword">switch</span> (proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_PROTO_ESP</span>:
			<span class="enscript-keyword">return</span> IPPROTO_ESP;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_PROTO_AH</span>:
			<span class="enscript-keyword">return</span> IPPROTO_AH;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> 0;
    }
}

<span class="enscript-type">static</span> u_int8_t
<span class="enscript-function-name">utun_ipsec_proto_to_sadb_satype</span> (if_utun_crypto_ipsec_proto_t proto)
{
	<span class="enscript-keyword">switch</span> (proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_PROTO_ESP</span>:
		<span class="enscript-keyword">return</span> SADB_SATYPE_ESP;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_PROTO_AH</span>:
		<span class="enscript-keyword">return</span> SADB_SATYPE_AH;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> 0;
    }
}

<span class="enscript-type">static</span> u_int8_t
<span class="enscript-function-name">utun_ipsec_auth_to_sadb_aalg</span> (if_utun_crypto_ipsec_auth_t auth)
{
	<span class="enscript-keyword">switch</span> (auth) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_AUTH_MD5</span>:
		<span class="enscript-keyword">return</span> SADB_AALG_MD5HMAC;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_AUTH_SHA1</span>:
		<span class="enscript-keyword">return</span> SADB_AALG_SHA1HMAC;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_AUTH_SHA256</span>:
		<span class="enscript-keyword">return</span> SADB_X_AALG_SHA2_256;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_AUTH_SHA384</span>:
		<span class="enscript-keyword">return</span> SADB_X_AALG_SHA2_384;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_AUTH_SHA512</span>:
		<span class="enscript-keyword">return</span> SADB_X_AALG_SHA2_512;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> 0;
	}
}

<span class="enscript-type">static</span> u_int8_t
<span class="enscript-function-name">utun_ipsec_enc_to_sadb_ealg</span> (if_utun_crypto_ipsec_enc_t enc)
{
	<span class="enscript-keyword">switch</span> (enc) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_ENC_DES</span>:
		<span class="enscript-keyword">return</span> SADB_EALG_DESCBC;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_ENC_3DES</span>:
		<span class="enscript-keyword">return</span> SADB_EALG_3DESCBC;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_ENC_AES128</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_ENC_AES256</span>:
		<span class="enscript-keyword">return</span> SADB_X_EALG_AESCBC;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> 0;
	}
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">utun_ipsec_keepalive_and_nat_info_to_sadb_flags</span> (if_utun_crypto_ipsec_keepalive_t keepalive,
						 <span class="enscript-type">int</span>                              punt_rx_keepalive,
						 if_utun_crypto_ipsec_natd_t      natd,
						 u_int16_t                        natt_port)
{
	u_int32_t flags = 0;

	<span class="enscript-keyword">if</span> (natt_port &amp;&amp; natt_port != 500) {
		flags |= SADB_X_EXT_NATT;

		<span class="enscript-keyword">switch</span> (keepalive) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_KEEPALIVE_NATT</span>:
			flags |= SADB_X_EXT_NATT_KEEPALIVE; <span class="enscript-comment">// normal keepalive packet
</span>			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_KEEPALIVE_ESP</span>:
			flags |= (SADB_X_EXT_ESP_KEEPALIVE | SADB_X_EXT_PUNT_RX_KEEPALIVE); <span class="enscript-comment">// use an EMPTY ESP as a keepalive 
</span>			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">switch</span> (natd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IF_UTUN_CRYPTO_IPSEC_NATD_PEER</span>:
			flags |= SADB_X_EXT_NATT_DETECTED_PEER;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (punt_rx_keepalive) {
		flags |= SADB_X_EXT_PUNT_RX_KEEPALIVE;
	}

	<span class="enscript-keyword">return</span> flags;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">utun_ipsec_set_sah</span> (<span class="enscript-type">struct</span> secashead        **sah,
		    u_int8_t                  dir,
		    u_int16_t                 proto,
		    u_int8_t                  mode,
		    u_int32_t                 reqid,
		    <span class="enscript-type">struct</span> sockaddr_storage  *src_addr,
		    <span class="enscript-type">struct</span> sockaddr_storage  *dst_addr)
{
	<span class="enscript-type">struct</span> secasindex saidx;

	<span class="enscript-comment">// currently only support tunnel mode and ESP
</span>	<span class="enscript-keyword">if</span> (proto != IPPROTO_ESP ||
	    mode != IPSEC_MODE_TUNNEL) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> ((((<span class="enscript-type">struct</span> sockaddr *)src_addr)-&gt;sa_family != AF_INET &amp;&amp;
	     ((<span class="enscript-type">struct</span> sockaddr *)src_addr)-&gt;sa_family != AF_INET6) ||
	    (((<span class="enscript-type">struct</span> sockaddr *)dst_addr)-&gt;sa_family != AF_INET &amp;&amp;
	     ((<span class="enscript-type">struct</span> sockaddr *)dst_addr)-&gt;sa_family != AF_INET6)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	bzero(&amp;saidx, <span class="enscript-keyword">sizeof</span>(saidx));
	saidx.proto = proto;
	saidx.mode = mode;
	saidx.reqid = reqid;
	bcopy(src_addr, &amp;saidx.src, <span class="enscript-keyword">sizeof</span>(saidx.src)); 
	bcopy(dst_addr, &amp;saidx.dst, <span class="enscript-keyword">sizeof</span>(saidx.dst)); 

	lck_mtx_lock(sadb_mutex);
	<span class="enscript-comment">// TODO: add sah and policy (collision) check and prevention. ensure that there is no conflicting policy.
</span>	<span class="enscript-comment">// TDDO: ensure that key_spdaddxxx doesn't add a policy that's conflicting with any of our sahs.
</span>	*sah = key_newsah2(&amp;saidx, dir);
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">utun_ipsec_clr_sahs</span> (<span class="enscript-type">struct</span> secashead **sah)
{
	<span class="enscript-type">struct</span> secasvar *sav;
	<span class="enscript-type">struct</span> secasvar *nextsav;
	u_int            state;

	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">for</span> (state = 0; state &lt; SADB_SASTATE_MAX; state++) {
		<span class="enscript-keyword">for</span> (sav = LIST_FIRST(&amp;(*sah)-&gt;savtree[state]);
		     sav != NULL;
		     sav = nextsav) {
			nextsav = LIST_NEXT(sav, chain);
			<span class="enscript-keyword">if</span> (sav-&gt;state == SADB_SASTATE_LARVAL ||
				sav-&gt;state == SADB_SASTATE_DEAD) {
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (sav-&gt;utun_pcb) {
				sav-&gt;utun_pcb = NULL;
				sav-&gt;utun_is_keepalive_fn = NULL;
				sav-&gt;utun_in_fn = NULL;
				sav-&gt;refcnt--; <span class="enscript-comment">// unlinked from pcb
</span>			} <span class="enscript-keyword">else</span> {
				printf(<span class="enscript-string">&quot;%s: SAV inconsistency\n&quot;</span>, __FUNCTION__);
			}

			key_sa_chgstate(sav, SADB_SASTATE_DEAD);
			key_freesav(sav, KEY_SADB_LOCKED);
		}
	}

	<span class="enscript-comment">// clear the rest of the SAs
</span>	key_delsah(*sah);
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ipsec_set_udp_encap_listen_port</span> (utun_crypto_dir_t dir,
				      u_int16_t         natt_port)
{
	<span class="enscript-keyword">if</span> (dir == UTUN_CRYPTO_DIR_IN) {
		<span class="enscript-keyword">if</span> (natt_port &amp;&amp; natt_port != 500) {
			esp_udp_encap_port = natt_port;
		}
	}	
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">utun_set_lifetime</span> (<span class="enscript-type">struct</span> sadb_lifetime *lfh,
		   <span class="enscript-type">int</span>                   type,
		   u_int64_t             l_time)
{
	lfh-&gt;sadb_lifetime_len = (<span class="enscript-keyword">sizeof</span>(*lfh) &gt;&gt; 3); <span class="enscript-comment">// convert to words
</span>	lfh-&gt;sadb_lifetime_exttype = type;
	lfh-&gt;sadb_lifetime_allocations = 0;
	lfh-&gt;sadb_lifetime_bytes = 0;
	lfh-&gt;sadb_lifetime_addtime = l_time;
	lfh-&gt;sadb_lifetime_usetime = l_time;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sadb_key *
<span class="enscript-function-name">utun_ipsec_set_keybuf</span> (u_int16_t  type,
		       u_int8_t  *key,
		       u_int16_t  key_len)
{
	<span class="enscript-type">struct</span> sadb_key *new;
	<span class="enscript-type">int</span> len = <span class="enscript-keyword">sizeof</span>(*new) + BITSTOBYTES(key_len);

	lck_mtx_lock(sadb_mutex);
	new = utun_alloc(len);
	<span class="enscript-keyword">if</span> (new == NULL) {
		<span class="enscript-keyword">return</span> NULL;
	}
	lck_mtx_unlock(sadb_mutex);
	bzero(new, len);
	new-&gt;sadb_key_len = BITSTOBYTES(key_len);
	new-&gt;sadb_key_exttype = type;
	new-&gt;sadb_key_bits = key_len;
	bcopy(key, &amp;new[1], new-&gt;sadb_key_len);
	<span class="enscript-keyword">return</span> new;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">utun_ipsec_alloc_sav</span> (<span class="enscript-type">struct</span> secashead                *sah,
		      <span class="enscript-type">struct</span> secasvar                **sav,
		      <span class="enscript-type">struct</span> utun_pcb                 *pcb,
		      u_int8_t                         satype,
		      u_int8_t                         alg_auth,
		      u_int8_t                         alg_enc,
		      u_int32_t                        flags,
		      u_int8_t                         replay,
		      u_int8_t                        *key_auth,
		      u_int16_t                        key_auth_len,
		      u_int8_t                        *key_enc,
		      u_int16_t                        key_enc_len,
		      u_int16_t                        natt_port,
		      u_int32_t                        seq,
		      u_int32_t                        spi,
		      u_int32_t                        pid,
		      u_int64_t                        lifetime_hard,
		      u_int64_t                        lifetime_soft)
{
	<span class="enscript-type">struct</span> sadb_key      *keye, *keya;
	<span class="enscript-type">struct</span> sadb_lifetime  lfh, lfs;

	<span class="enscript-keyword">if</span> (*sav) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	bzero(&amp;lfh, <span class="enscript-keyword">sizeof</span>(lfh));
	utun_set_lifetime(&amp;lfh, SADB_EXT_LIFETIME_HARD, lifetime_hard);
	bzero(&amp;lfs, <span class="enscript-keyword">sizeof</span>(lfs));
	utun_set_lifetime(&amp;lfs, SADB_EXT_LIFETIME_SOFT, lifetime_soft);

	<span class="enscript-keyword">if</span> ((keya = utun_ipsec_set_keybuf(SADB_EXT_KEY_AUTH, key_auth, key_auth_len)) == NULL) {
		<span class="enscript-keyword">return</span> ENOBUFS;
	}
	<span class="enscript-keyword">if</span> ((keye = utun_ipsec_set_keybuf(SADB_EXT_KEY_ENCRYPT, key_enc, key_enc_len)) == NULL) {
		utun_free(keya);
		<span class="enscript-keyword">return</span> ENOBUFS;
	}

	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> ((*sav = key_newsav2(sah,
				satype,
				alg_auth,
				alg_enc,
				flags,
				replay,
				keya,
				key_auth_len,
				keye,
				key_enc_len,
				natt_port,
				seq,
				spi,
				pid,
				&amp;lfh,
				&amp;lfs)) == NULL) {
		lck_mtx_unlock(sadb_mutex);
		utun_free(keya);
		utun_free(keye);
		<span class="enscript-keyword">return</span> ENOBUFS;
	}
	(*sav)-&gt;utun_pcb = (__typeof__((*sav)-&gt;utun_pcb))pcb;
	(*sav)-&gt;utun_is_keepalive_fn = (__typeof__((*sav)-&gt;utun_is_keepalive_fn))utun_pkt_is_ipsec_keepalive;
	(*sav)-&gt;utun_in_fn = (__typeof__((*sav)-&gt;utun_in_fn))utun_pkt_ipsec_input;
	(*sav)-&gt;refcnt++; <span class="enscript-comment">// for the pcb
</span>	lck_mtx_unlock(sadb_mutex);
	utun_free(keya);
	utun_free(keye);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">utun_ipsec_free_sav</span> (<span class="enscript-type">struct</span> secasvar  **sav)
{
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> ((*sav)-&gt;utun_pcb) {
		(*sav)-&gt;utun_pcb = NULL;
		(*sav)-&gt;utun_is_keepalive_fn = NULL;
		(*sav)-&gt;utun_in_fn = NULL;
	}
	(*sav)-&gt;refcnt--; <span class="enscript-comment">// unlinked from pcb
</span>	key_sa_chgstate(*sav, SADB_SASTATE_DEAD);
	key_freesav(*sav, KEY_SADB_LOCKED);
	lck_mtx_unlock(sadb_mutex);
	*sav = NULL;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">utun_ipsec_num_savs</span> (<span class="enscript-type">struct</span> secashead **sah)
{
	<span class="enscript-type">struct</span> secasvar *sav;
	<span class="enscript-type">struct</span> secasvar *nextsav;
	u_int            state;
	<span class="enscript-type">int</span>              n = 0;

	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">for</span> (state = 0; state &lt; SADB_SASTATE_MAX; state++) {
		<span class="enscript-keyword">for</span> (sav = LIST_FIRST(&amp;(*sah)-&gt;savtree[state]);
		     sav != NULL;
		     sav = nextsav) {
			nextsav = LIST_NEXT(sav, chain);
			<span class="enscript-keyword">if</span> (sav-&gt;state == SADB_SASTATE_LARVAL ||
			    sav-&gt;state == SADB_SASTATE_DYING ||
			    sav-&gt;state == SADB_SASTATE_DEAD) {
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (sav-&gt;utun_pcb) {
				n++;
			} <span class="enscript-keyword">else</span> {
				printf(<span class="enscript-string">&quot;%s: SAV inconsistency\n&quot;</span>, __FUNCTION__);
			}
		}
	}
	lck_mtx_unlock(sadb_mutex);

	<span class="enscript-keyword">return</span> n;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">utun_ctl_config_crypto_keys_ipsec_v1</span> (<span class="enscript-type">struct</span> utun_pcb         *pcb,
				      utun_crypto_keys_args_t *args,
				      utun_crypto_keys_t      *crypto_keys)
{
	utun_crypto_keys_ipsec_args_v1_t *args_ipsec_v1 = &amp;args-&gt;u.ipsec_v1;
	u_int8_t                         *varargs_buf = UTUN_CRYPTO_KEYS_ARGS_VARARGS_BUF(args);
	errno_t                           err;
	<span class="enscript-type">struct</span> secashead                 *sah;
	u_int16_t                         proto;
	u_int8_t                          mode;
	u_int8_t                          satype, aalg, ealg;
	u_int32_t                         flags;
	
	<span class="enscript-keyword">if</span> (args_ipsec_v1-&gt;key_auth_len &gt; MAX_KEY_AUTH_LEN_BITS) {
		printf(<span class="enscript-string">&quot;%s: invalid auth key len %d, max %d\n&quot;</span>, __FUNCTION__,
		       args_ipsec_v1-&gt;key_auth_len, MAX_KEY_AUTH_LEN_BITS);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> (args_ipsec_v1-&gt;key_enc_len &gt; MAX_KEY_ENC_LEN_BITS) {
		printf(<span class="enscript-string">&quot;%s: invalid enc key len %d, max %d\n&quot;</span>, __FUNCTION__,
		       args_ipsec_v1-&gt;key_enc_len, MAX_KEY_ENC_LEN_BITS);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> (args-&gt;varargs_buflen != (__typeof__(args-&gt;varargs_buflen))((BITSTOBYTES(args_ipsec_v1-&gt;key_auth_len) + 
									BITSTOBYTES(args_ipsec_v1-&gt;key_enc_len)))) {
		printf(<span class="enscript-string">&quot;%s: len check failed (%d,%d, %d)\n&quot;</span>, __FUNCTION__,
		       args-&gt;varargs_buflen, args_ipsec_v1-&gt;key_auth_len, args_ipsec_v1-&gt;key_enc_len);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	sah = IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAH(crypto_keys);
	<span class="enscript-keyword">if</span> (!sah) {
		<span class="enscript-comment">// TODO: make sure we pass through this once
</span>		proto = utun_ipsec_proto_to_sadb_proto(args_ipsec_v1-&gt;proto);
		mode = utun_ipsec_mode_to_sadb_mode(args_ipsec_v1-&gt;mode);

		<span class="enscript-keyword">if</span> ((err = utun_ipsec_set_sah(&amp;IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAH(crypto_keys),
					      UTUN_CRYPTO_DIR_TO_IPSEC_DIR(args-&gt;dir),
					      proto,
					      mode,
					      args_ipsec_v1-&gt;reqid,
					      &amp;args_ipsec_v1-&gt;src_addr,
					      &amp;args_ipsec_v1-&gt;dst_addr))) {
			<span class="enscript-keyword">return</span> err;
		}
		sah = IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAH(crypto_keys);
		<span class="enscript-keyword">if</span> (!sah) {
			<span class="enscript-keyword">return</span> EBADF;
		}
	}

	satype = utun_ipsec_proto_to_sadb_satype(args_ipsec_v1-&gt;proto);
	aalg = utun_ipsec_auth_to_sadb_aalg(args_ipsec_v1-&gt;alg_auth);
	ealg = utun_ipsec_enc_to_sadb_ealg(args_ipsec_v1-&gt;alg_enc);
	flags = utun_ipsec_keepalive_and_nat_info_to_sadb_flags(args_ipsec_v1-&gt;keepalive,
								args_ipsec_v1-&gt;punt_rx_keepalive,
								args_ipsec_v1-&gt;natd,
								args_ipsec_v1-&gt;natt_port);

	<span class="enscript-keyword">if</span> ((err = utun_ipsec_alloc_sav(sah,
					&amp;IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAV(crypto_keys),
					pcb,
					satype,
					aalg,
					ealg,
					flags,
					args_ipsec_v1-&gt;replay,
					varargs_buf,
					args_ipsec_v1-&gt;key_auth_len,
					(varargs_buf + BITSTOBYTES(args_ipsec_v1-&gt;key_auth_len)),
					args_ipsec_v1-&gt;key_enc_len,
					args_ipsec_v1-&gt;natt_port,
					args_ipsec_v1-&gt;seq,
					args_ipsec_v1-&gt;spi,
					args_ipsec_v1-&gt;pid,
					args_ipsec_v1-&gt;lifetime_hard,
					args_ipsec_v1-&gt;lifetime_soft))) {
		<span class="enscript-keyword">return</span> err;
	}
	crypto_keys-&gt;state.u.ipsec.proto = sah-&gt;saidx.proto;
	crypto_keys-&gt;state.u.ipsec.mode = sah-&gt;saidx.mode;
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;sah-&gt;saidx.src)-&gt;sa_family == AF_INET) {
		crypto_keys-&gt;state.u.ipsec.ifamily = IPPROTO_IPV4;
	} <span class="enscript-keyword">else</span> {
		crypto_keys-&gt;state.u.ipsec.ifamily = IPPROTO_IPV6;
	}
	crypto_keys-&gt;state.u.ipsec.spi = args_ipsec_v1-&gt;spi;
	utun_ipsec_set_udp_encap_listen_port(args-&gt;dir, args_ipsec_v1-&gt;natt_port);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">utun_ctl_unconfig_crypto_keys_ipsec_v1</span> (utun_crypto_keys_t *crypto_keys)
{
	<span class="enscript-keyword">if</span> (!IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAH(crypto_keys)) {
		<span class="enscript-keyword">return</span> EBADF;
	}
	<span class="enscript-keyword">if</span> (!IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAV(crypto_keys)) {
		<span class="enscript-keyword">return</span> EBADF;
	}
	<span class="enscript-keyword">if</span> (utun_ipsec_free_sav(&amp;IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAV(crypto_keys))) {
		<span class="enscript-keyword">return</span> EADDRNOTAVAIL;
	}
	<span class="enscript-keyword">if</span> (!utun_ipsec_num_savs(&amp;IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAH(crypto_keys))) {
		(<span class="enscript-type">void</span>)utun_ipsec_clr_sahs(&amp;IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAH(crypto_keys));

		<span class="enscript-comment">// release sah
</span>		IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAH(crypto_keys) = NULL;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">utun_set_spirange</span> (<span class="enscript-type">struct</span> sadb_spirange *spirange,
		   u_int32_t             spirange_min,
		   u_int32_t             spirange_max)
{
	spirange-&gt;sadb_spirange_min = spirange_min;
	spirange-&gt;sadb_spirange_max = spirange_max;
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">utun_ipsec_get_spi</span> (<span class="enscript-type">struct</span> sockaddr_storage  *src_addr,
		    <span class="enscript-type">struct</span> sockaddr_storage  *dst_addr,
		    u_int16_t                 proto,
		    u_int8_t                  mode,
		    u_int32_t                 reqid,
		    u_int32_t         spirange_min,
		    u_int32_t         spirange_max)
{
	<span class="enscript-type">struct</span> sadb_spirange spirange;
	utun_set_spirange(&amp;spirange, spirange_min, spirange_max);
	<span class="enscript-comment">// TODO: should this allocate an SAH?
</span>	<span class="enscript-keyword">return</span> key_getspi2((<span class="enscript-type">struct</span> sockaddr *)src_addr,
			   (<span class="enscript-type">struct</span> sockaddr *)dst_addr,
			   proto,
			   mode,
			   reqid,
			   &amp;spirange);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">utun_ctl_generate_crypto_keys_idx_ipsec_v1</span> (utun_crypto_keys_idx_args_t *args)
{
	utun_crypto_keys_idx_ipsec_args_v1_t *args_ipsec_v1 = &amp;args-&gt;u.ipsec_v1;
	u_int16_t                             proto;
	u_int8_t                              mode;

	proto = utun_ipsec_proto_to_sadb_proto(args_ipsec_v1-&gt;proto);
	mode = utun_ipsec_mode_to_sadb_mode(args_ipsec_v1-&gt;mode);

	args_ipsec_v1-&gt;spi = 0;
	<span class="enscript-keyword">if</span> ((args_ipsec_v1-&gt;spi = utun_ipsec_get_spi(&amp;args_ipsec_v1-&gt;src_addr,
						     &amp;args_ipsec_v1-&gt;dst_addr,
						     proto,
						     mode,
						     args_ipsec_v1-&gt;reqid,
						     args_ipsec_v1-&gt;spirange_min,
						     args_ipsec_v1-&gt;spirange_max)) == 0) {
		<span class="enscript-keyword">return</span> ENOBUFS;
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">utun_cleanup_all_crypto_ipsec</span> (<span class="enscript-type">struct</span> utun_pcb   *pcb)
{
	<span class="enscript-type">int</span>                 idx;
	utun_crypto_ctx_t  *crypto_ctx;
	utun_crypto_keys_t *cur_crypto_keys, *nxt_crypto_keys;

	<span class="enscript-keyword">for</span> (idx = 0; idx &lt; UTUN_CRYPTO_DIR_TO_IDX(UTUN_CRYPTO_DIR_MAX); idx++) {
		crypto_ctx = &amp;pcb-&gt;utun_crypto_ctx[idx];
		<span class="enscript-keyword">if</span> (!crypto_ctx-&gt;valid ||
		    crypto_ctx-&gt;type != UTUN_CRYPTO_TYPE_IPSEC) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">// flush all crypto materials
</span>		<span class="enscript-keyword">for</span> (cur_crypto_keys = (__typeof__(cur_crypto_keys))LIST_FIRST(&amp;crypto_ctx-&gt;keys_listhead);
		     cur_crypto_keys != NULL;
		     cur_crypto_keys = nxt_crypto_keys) {
			nxt_crypto_keys = (__typeof__(nxt_crypto_keys))LIST_NEXT(cur_crypto_keys, chain);

			<span class="enscript-keyword">if</span> (!cur_crypto_keys-&gt;valid) {
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAV(cur_crypto_keys)) {
				(<span class="enscript-type">void</span>)utun_ipsec_free_sav(&amp;IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAV(cur_crypto_keys));
			}

			<span class="enscript-keyword">if</span> (IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAH(cur_crypto_keys)) {		
				(<span class="enscript-type">void</span>)utun_ipsec_clr_sahs(&amp;IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAH(cur_crypto_keys));
			}
			
			LIST_REMOVE(cur_crypto_keys, chain);
			bzero(cur_crypto_keys, <span class="enscript-keyword">sizeof</span>(*cur_crypto_keys));
			utun_free(cur_crypto_keys);
		}

		bzero(crypto_ctx, <span class="enscript-keyword">sizeof</span>(*crypto_ctx));
	}
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">utun_ctl_enable_crypto_ipsec_v1</span> (__unused utun_crypto_args_t *args)
{
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Summary: enables ipsec crypto info for the specified utun.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_enable_crypto_ipsec</span>(__unused <span class="enscript-type">struct</span> utun_pcb    *pcb,
			     utun_crypto_args_t *args)
{
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-comment">/* Turn off the ipsec bypass, if already on */</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass) {
		ipsec_bypass = 0;
	}
	<span class="enscript-keyword">if</span> (args-&gt;ver == UTUN_CRYPTO_KEYS_IPSEC_VER_1) {
		(<span class="enscript-type">void</span>)utun_ctl_enable_crypto_ipsec_v1(args);
	}
	lck_mtx_unlock(sadb_mutex);
}

<span class="enscript-comment">/*
 * Summary: disables ipsec crypto info for the specified utun.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">utun_ctl_disable_crypto_ipsec</span>(__unused <span class="enscript-type">struct</span> utun_pcb   *pcb)
{
	utun_cleanup_all_crypto_ipsec(pcb);
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-comment">/* Turn on the ipsec bypass, if there are no other policies */</span>
	<span class="enscript-keyword">if</span> (!ipsec_policy_count &amp;&amp; !ipsec_bypass) <span class="enscript-comment">// TODO: ipsec_policy_count may be 1 by default
</span>		ipsec_bypass = 1;
	utun_punt_rx_keepalive = 0;
	lck_mtx_unlock(sadb_mutex);
}

errno_t
<span class="enscript-function-name">utun_ctl_config_crypto_keys_ipsec</span> (<span class="enscript-type">struct</span> utun_pcb         *pcb,
				   utun_crypto_keys_args_t *args,
				   utun_crypto_keys_t      *crypto_keys)
{
	<span class="enscript-keyword">if</span> (args-&gt;ver == UTUN_CRYPTO_KEYS_IPSEC_VER_1) {
		<span class="enscript-keyword">return</span>(utun_ctl_config_crypto_keys_ipsec_v1(pcb, args, crypto_keys));			   
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;%s: ver unsupported (%d, %d)\n&quot;</span>, __FUNCTION__, args-&gt;ver, UTUN_CRYPTO_KEYS_IPSEC_VER_1);
		<span class="enscript-keyword">return</span> EINVAL;
	}
}

errno_t
<span class="enscript-function-name">utun_ctl_unconfig_crypto_keys_ipsec</span> (utun_crypto_keys_args_t *args,
				     utun_crypto_keys_t      *crypto_keys)
{
	<span class="enscript-keyword">if</span> (args-&gt;ver == UTUN_CRYPTO_KEYS_IPSEC_VER_1) {
		<span class="enscript-keyword">return</span>(utun_ctl_unconfig_crypto_keys_ipsec_v1(crypto_keys));			   
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;%s: ver unsupported (%d, %d)\n&quot;</span>, __FUNCTION__, args-&gt;ver, UTUN_CRYPTO_KEYS_IPSEC_VER_1);
		<span class="enscript-keyword">return</span> EINVAL;
	}
}

errno_t
<span class="enscript-function-name">utun_ctl_generate_crypto_keys_idx_ipsec</span> (utun_crypto_keys_idx_args_t *args)
{
	<span class="enscript-keyword">if</span> (args-&gt;ver == UTUN_CRYPTO_KEYS_IPSEC_VER_1) {
		<span class="enscript-keyword">return</span>(utun_ctl_generate_crypto_keys_idx_ipsec_v1(args));			   
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;%s: ver unsupported (%d, %d)\n&quot;</span>, __FUNCTION__, args-&gt;ver, UTUN_CRYPTO_KEYS_IPSEC_VER_1);
		<span class="enscript-keyword">return</span> EINVAL;
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">utun_pkt_ipsec_output</span> (<span class="enscript-type">struct</span> utun_pcb *pcb, mbuf_t *pkt)
{
	utun_crypto_keys_t *crypto_keys = IF_UTUN_GET_TX_CRYPTO_KEYS(pcb);
	<span class="enscript-type">struct</span> secasvar    *sav;
	protocol_family_t   proto;
	mbuf_t              new;
	<span class="enscript-type">int</span>                 err;
	<span class="enscript-type">struct</span> route       *ro = NULL;
	<span class="enscript-type">struct</span> route        ro_copy;
	<span class="enscript-type">struct</span> ip_out_args  ipoa =
	    { IFSCOPE_NONE, { 0 }, IPOAF_SELECT_SRCIF, 0 };

	<span class="enscript-keyword">if</span> (crypto_keys &amp;&amp;
	    crypto_keys-&gt;state.u.ipsec.proto == IPPROTO_ESP &amp;&amp;
	    (sav = IF_UTUN_GET_CRYPTO_KEYS_IPSEC_SAV(crypto_keys)) &amp;&amp;
	    sav-&gt;state == SADB_SASTATE_MATURE) {
		<span class="enscript-comment">// TODO: update stats to increment outgoing packets
</span>		<span class="enscript-comment">// TODO: allow empty packets thru
</span>
		proto = *(mtod(*pkt, protocol_family_t *));
		m_adj(*pkt, <span class="enscript-keyword">sizeof</span>(protocol_family_t));

		bzero(&amp;ro_copy, <span class="enscript-keyword">sizeof</span>(ro_copy));

		<span class="enscript-keyword">if</span> ((proto == AF_UTUN || proto == AF_INET) &amp;&amp; crypto_keys-&gt;state.u.ipsec.ifamily == IPPROTO_IPV4) {
			<span class="enscript-type">struct</span> ip          *ip;
			<span class="enscript-type">struct</span> sockaddr_in *dst4;

			<span class="enscript-keyword">if</span> (proto == AF_INET) {
				<span class="enscript-keyword">if</span> ((*pkt)-&gt;m_len &lt; (__typeof__((*pkt)-&gt;m_len))<span class="enscript-keyword">sizeof</span>(*ip)) {
					<span class="enscript-keyword">if</span> (!(*pkt = m_pullup(*pkt, <span class="enscript-keyword">sizeof</span>(*ip)))) {
						printf(<span class="enscript-string">&quot;%s: m_pullup failed\n&quot;</span>, __FUNCTION__);
						<span class="enscript-keyword">return</span> 0;
					}
				}

				<span class="enscript-comment">// split the mbuf chain to put the ip header and payloads in separate mbufs
</span>				new = ipsec4_splithdr(*pkt);
				<span class="enscript-keyword">if</span> (!new) {
					printf(<span class="enscript-string">&quot;%s: ipsec4_splithdr(1) failed\n&quot;</span>, __FUNCTION__);
					ROUTE_RELEASE(&amp;ro_copy);
					*pkt = NULL;
					<span class="enscript-keyword">return</span> 0;
				}
				*pkt = new;

				<span class="enscript-comment">// encapsulate with the outer header
</span>				<span class="enscript-keyword">if</span> ((err = ipsec4_encapsulate(new, sav))) {
					printf(<span class="enscript-string">&quot;%s: ipsec4_encapsulate failed (%d)\n&quot;</span>, __FUNCTION__, err);
					*pkt = NULL;
					<span class="enscript-keyword">return</span> 0;
				}

			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// otherwise it's AF_UTUN which will be a keepalive packet to be encapsulated, encrypted and sent
</span>				<span class="enscript-comment">// encapsulate with the outer header
</span>				<span class="enscript-keyword">if</span> ((err = ipsec4_encapsulate_utun_esp_keepalive(pkt, sav))) {
					printf(<span class="enscript-string">&quot;%s: ipsec4_encapsulate failed (%d)\n&quot;</span>, __FUNCTION__, err);
					<span class="enscript-keyword">return</span> 0;
				}
				new = *pkt;
			}

			ip = mtod(new, __typeof__(ip));
			<span class="enscript-comment">// grab sadb_mutex, to update sah's route cache and get a local copy of it
</span>			lck_mtx_lock(sadb_mutex);
			ro = &amp;sav-&gt;sah-&gt;sa_route;
			dst4 = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;ro-&gt;ro_dst;
			<span class="enscript-keyword">if</span> (ro-&gt;ro_rt) {
				RT_LOCK(ro-&gt;ro_rt);
			}
			<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro) ||
			    dst4-&gt;sin_addr.s_addr != ip-&gt;ip_dst.s_addr) {
				<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
					RT_UNLOCK(ro-&gt;ro_rt);
				ROUTE_RELEASE(ro);
			}
			<span class="enscript-keyword">if</span> (ro-&gt;ro_rt == NULL) {
				dst4-&gt;sin_family = AF_INET;
				dst4-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(*dst4);
				dst4-&gt;sin_addr = ip-&gt;ip_dst;
				rtalloc(ro);
				<span class="enscript-keyword">if</span> (ro-&gt;ro_rt) {
					RT_LOCK(ro-&gt;ro_rt);
				} <span class="enscript-keyword">else</span> {
					printf(<span class="enscript-string">&quot;%s: rtalloc(1) failed\n&quot;</span>, __FUNCTION__);
					mbuf_freem(new);
					*pkt = NULL;
					<span class="enscript-keyword">return</span> 0;
				}
			}
			<span class="enscript-keyword">if</span> (ro-&gt;ro_rt-&gt;rt_flags &amp; RTF_GATEWAY) {
				dst4 = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)ro-&gt;ro_rt-&gt;rt_gateway;
			}
			RT_UNLOCK(ro-&gt;ro_rt);
			route_copyout(&amp;ro_copy, ro, <span class="enscript-keyword">sizeof</span>(ro_copy));
			<span class="enscript-comment">// release sadb_mutex, after updating sah's route cache and getting a local copy
</span>			lck_mtx_unlock(sadb_mutex);

			<span class="enscript-comment">// split the mbuf chain to put the ip header and payloads in separate mbufs
</span>			new = ipsec4_splithdr(*pkt);
			<span class="enscript-keyword">if</span> (!new) {
				printf(<span class="enscript-string">&quot;%s: ipsec4_splithdr(2) failed\n&quot;</span>, __FUNCTION__);
				ROUTE_RELEASE(&amp;ro_copy);
				*pkt = NULL;
				<span class="enscript-keyword">return</span> 0;
			}
			*pkt = new;

			<span class="enscript-keyword">if</span> ((err = esp4_output(new, sav))) {
				printf(<span class="enscript-string">&quot;%s: esp4_output failed (%d)\n&quot;</span>, __FUNCTION__, err);
				ROUTE_RELEASE(&amp;ro_copy);
				*pkt = NULL;
				<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">// drop
</span>			}

			ip = mtod(new, __typeof__(ip));
			ip-&gt;ip_len = ntohs(ip-&gt;ip_len);  <span class="enscript-comment">/* flip len field before calling ip_output */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((proto == AF_UTUN || proto == AF_INET6) &amp;&amp; crypto_keys-&gt;state.u.ipsec.ifamily == IPPROTO_IPV6) {
			<span class="enscript-type">int</span>                  plen;
			<span class="enscript-type">struct</span> ip6_hdr      *ip6;
			<span class="enscript-type">struct</span> sockaddr_in6 *dst6;

			<span class="enscript-keyword">if</span> (proto == AF_INET6) {
				<span class="enscript-comment">// split the mbuf chain to put the ip header and payloads in separate mbufs
</span>				new = ipsec6_splithdr(*pkt);
				<span class="enscript-keyword">if</span> (!new) {
					printf(<span class="enscript-string">&quot;%s: ipsec6_splithdr(1) failed\n&quot;</span>, __FUNCTION__);
					ROUTE_RELEASE(&amp;ro_copy);
					*pkt = NULL;
					<span class="enscript-keyword">return</span> 0;
				}
				*pkt = new;

				<span class="enscript-comment">// encapsulate with the outer header
</span>				<span class="enscript-keyword">if</span> ((err = ipsec6_encapsulate(new, sav))) {
					printf(<span class="enscript-string">&quot;%s: ipsec6_encapsulate failed (%d)\n&quot;</span>, __FUNCTION__, err);
					*pkt = NULL;
					<span class="enscript-keyword">return</span> 0;
				}

			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// otherwise it's AF_UTUN which will be a keepalive packet to be encapsulated, encrypted and sent
</span>				<span class="enscript-comment">// encapsulate with the outer header
</span>				<span class="enscript-keyword">if</span> ((err = ipsec6_encapsulate_utun_esp_keepalive(pkt, sav))) {
					printf(<span class="enscript-string">&quot;%s: ipsec6_encapsulate failed (%d)\n&quot;</span>, __FUNCTION__, err);
					<span class="enscript-keyword">return</span> 0;
				}
				new = *pkt;
			}

			ip6 = mtod(new, __typeof__(ip6));
			<span class="enscript-comment">// grab sadb_mutex, before updating sah's route cache
</span>			lck_mtx_lock(sadb_mutex);
			ro = &amp;sav-&gt;sah-&gt;sa_route;
			dst6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)&amp;ro-&gt;ro_dst;
			<span class="enscript-keyword">if</span> (ro-&gt;ro_rt) {
				RT_LOCK(ro-&gt;ro_rt);
			}
			<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro) ||
			    !IN6_ARE_ADDR_EQUAL(&amp;dst6-&gt;sin6_addr, &amp;ip6-&gt;ip6_dst)) {
				<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
					RT_UNLOCK(ro-&gt;ro_rt);
				ROUTE_RELEASE(ro);
			}
			<span class="enscript-keyword">if</span> (ro-&gt;ro_rt == NULL) {
				bzero(dst6, <span class="enscript-keyword">sizeof</span>(*dst6));
				dst6-&gt;sin6_family = AF_INET6;
				dst6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(*dst6);
				dst6-&gt;sin6_addr = ip6-&gt;ip6_dst;
				rtalloc(ro);
				<span class="enscript-keyword">if</span> (ro-&gt;ro_rt) {
					RT_LOCK(ro-&gt;ro_rt);
				} <span class="enscript-keyword">else</span> {
					printf(<span class="enscript-string">&quot;%s: rtalloc(2) failed\n&quot;</span>, __FUNCTION__);
					mbuf_freem(new);
					*pkt = NULL;
					<span class="enscript-keyword">return</span> 0;
				}
			}
			<span class="enscript-keyword">if</span> (ro-&gt;ro_rt-&gt;rt_flags &amp; RTF_GATEWAY) {
				dst6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)ro-&gt;ro_rt-&gt;rt_gateway;
			}
			RT_UNLOCK(ro-&gt;ro_rt);
			route_copyout(&amp;ro_copy, ro, <span class="enscript-keyword">sizeof</span>(ro_copy));
			<span class="enscript-comment">// release sadb_mutex, after updating sah's route cache and getting a local copy
</span>			lck_mtx_unlock(sadb_mutex);

			<span class="enscript-comment">// split the mbuf chain to put the ip header and payloads in separate mbufs
</span>			new = ipsec6_splithdr(*pkt);
			<span class="enscript-keyword">if</span> (!new) {
				printf(<span class="enscript-string">&quot;%s: ipsec6_splithdr failed\n&quot;</span>, __FUNCTION__);
				ROUTE_RELEASE(&amp;ro_copy);
				*pkt = NULL;
				<span class="enscript-keyword">return</span> 0;
			}
			*pkt = new;
			
			<span class="enscript-keyword">if</span> ((err = esp6_output(new, mtod(new, u_char *), new-&gt;m_next, sav))) {
				printf(<span class="enscript-string">&quot;%s: esp6_output failed (%d)\n&quot;</span>, __FUNCTION__, err);
				ROUTE_RELEASE(&amp;ro_copy);
				*pkt = NULL;
				<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">// drop
</span>			}

			plen = new-&gt;m_pkthdr.len - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
			<span class="enscript-keyword">if</span> (plen &gt; IPV6_MAXPACKET) {
				printf(<span class="enscript-string">&quot;%s: esp6_output failed due to invalid len (%d)\n&quot;</span>, __FUNCTION__, plen);
				ROUTE_RELEASE(&amp;ro_copy);
				mbuf_freem(new);
				*pkt = NULL;
				<span class="enscript-keyword">return</span> 0;
			}
			ip6 = mtod(new, __typeof__(ip6));
			ip6-&gt;ip6_plen = ntohs(ip6-&gt;ip6_plen);  <span class="enscript-comment">/* flip len field before calling ip_output */</span>
		} <span class="enscript-keyword">else</span> {
			printf(<span class="enscript-string">&quot;%s: packet's proto (%d) mismatched the context's proto (%d)\n&quot;</span>, __FUNCTION__,
				   proto, crypto_keys-&gt;state.u.ipsec.ifamily);
			mbuf_freem(*pkt);
			*pkt = NULL;
			<span class="enscript-keyword">return</span> 0;
		}

		<span class="enscript-keyword">if</span> (pcb-&gt;utun_ifp) {
			ifnet_stat_increment_out(pcb-&gt;utun_ifp, 1, mbuf_pkthdr_len(new), 0);
		}

		<span class="enscript-keyword">if</span> ((err = ip_output(new, NULL, &amp;ro_copy,
		    (IP_OUTARGS | IP_NOIPSEC), NULL, &amp;ipoa))) {
			printf(<span class="enscript-string">&quot;%s: ip_output failed (%d)\n&quot;</span>, __FUNCTION__, err);
		}
		lck_mtx_lock(sadb_mutex);
		route_copyin(&amp;ro_copy, ro, <span class="enscript-keyword">sizeof</span>(*ro));
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> 0;
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;%s: no suitable crypto-mat\n&quot;</span>, __FUNCTION__);
	}
	<span class="enscript-keyword">return</span> -1;
}

<span class="enscript-comment">// returns 0 if false, 1 if true, and -1 if there was a failure
</span><span class="enscript-type">int</span>
<span class="enscript-function-name">utun_pkt_is_ipsec_keepalive</span> (<span class="enscript-type">struct</span> utun_pcb *pcb, mbuf_t *pkt, u_int16_t nxt, u_int32_t flags, size_t offs)
{
	<span class="enscript-type">int</span> result;
	u_int8_t *data;
	<span class="enscript-type">int</span> size_diff;

	<span class="enscript-keyword">if</span> (!pcb-&gt;utun_ctlref) {
		printf(<span class="enscript-string">&quot;%s - utun ctlref cleared\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (!(pcb-&gt;utun_flags &amp; UTUN_FLAGS_CRYPTO)) {
		printf(<span class="enscript-string">&quot;%s - crypto disabled\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> ((*pkt)-&gt;m_pkthdr.len &lt; 0) {
		printf(<span class="enscript-string">&quot;%s - invalid hdr len, len %d, offs %lu\n&quot;</span>, __FUNCTION__, (*pkt)-&gt;m_pkthdr.len, offs);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> ((size_t)(*pkt)-&gt;m_pkthdr.len &lt;= offs) {
		printf(<span class="enscript-string">&quot;%s - invalid offset, len %d, offs %lu\n&quot;</span>, __FUNCTION__, (*pkt)-&gt;m_pkthdr.len, offs);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> ((*pkt)-&gt;m_len &lt; 0) {
		printf(<span class="enscript-string">&quot;%s - invalid len, len %d, offs %lu\n&quot;</span>, __FUNCTION__, (*pkt)-&gt;m_len, offs);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">// pullup offs + 1 bytes
</span>	<span class="enscript-keyword">if</span> ((size_t)(*pkt)-&gt;m_len &lt; (offs + 1)) {
		<span class="enscript-keyword">if</span> ((*pkt = m_pullup(*pkt, (offs + 1))) == NULL) {
			printf(<span class="enscript-string">&quot;%s: m_pullup failed\n&quot;</span>, __FUNCTION__);
			<span class="enscript-keyword">return</span> -1;
		}
	}

	<span class="enscript-keyword">if</span> (pcb-&gt;utun_ifp) {
		ifnet_stat_increment_in(pcb-&gt;utun_ifp, 1, mbuf_pkthdr_len(*pkt), 0);
	}

	size_diff = (*pkt)-&gt;m_pkthdr.len - offs;
	data = mtod(*pkt, __typeof(data));
	data += offs;

	<span class="enscript-comment">// ESP keepalive meets all these conditions: ESP trailer's next proto indicates IP, the decrypted packet only has one zero'd byte in it.
</span>	<span class="enscript-keyword">if</span> (flags &amp; SADB_X_EXT_ESP_KEEPALIVE &amp;&amp;
	    nxt == IPPROTO_IPV4 &amp;&amp;
	    size_diff == 1 &amp;&amp;
	    *data == 0) {
		<span class="enscript-comment">// TODO: update stats to increment keepalives and current timestamp
</span>		<span class="enscript-keyword">if</span> (utun_punt_rx_keepalive ||
			flags &amp; SADB_X_EXT_PUNT_RX_KEEPALIVE) {

			<span class="enscript-comment">// strip all headers
</span>			<span class="enscript-keyword">if</span> ((size_t)(*pkt)-&gt;m_len &gt;= (offs + size_diff)) {
				ovbcopy((caddr_t)data, (data + offs), size_diff);
				(*pkt)-&gt;m_data += offs;
				(*pkt)-&gt;m_len -= offs;
				(*pkt)-&gt;m_pkthdr.len -= offs;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-type">struct</span> mbuf *n;

				n = m_split(*pkt, offs, M_DONTWAIT);
				<span class="enscript-keyword">if</span> (n == NULL) {
					<span class="enscript-comment">/* *pkt is retained by m_split */</span>
					mbuf_freem(*pkt);
					*pkt = NULL;
					<span class="enscript-keyword">return</span> -1;
				}
				m_adj(n, offs);
				mbuf_freem(*pkt);
				*pkt = n;
			}

			<span class="enscript-comment">// keepalive is being punted up to the control socket, prepend with a special packet type (PF_UTUN)
</span>			<span class="enscript-keyword">if</span> (mbuf_prepend(pkt, <span class="enscript-keyword">sizeof</span>(protocol_family_t), MBUF_DONTWAIT) != 0) {
				printf(<span class="enscript-string">&quot;%s - ifnet_output prepend failed\n&quot;</span>, __FUNCTION__);
				<span class="enscript-keyword">return</span> -1;
			}
			<span class="enscript-keyword">if</span> ((size_t)(*pkt)-&gt;m_len &lt; (<span class="enscript-keyword">sizeof</span>(protocol_family_t) + size_diff)) {
				<span class="enscript-keyword">if</span> ((*pkt = m_pullup(*pkt, (<span class="enscript-keyword">sizeof</span>(protocol_family_t) + size_diff))) == NULL) {
					printf(<span class="enscript-string">&quot;%s: m_pullup failed\n&quot;</span>, __FUNCTION__);
					<span class="enscript-keyword">return</span> -1;
				}
			}

			<span class="enscript-comment">// mark UTUN/Keepalive packet
</span>			*(protocol_family_t *)mbuf_data(*pkt) = htonl(PF_UTUN);

			result = ctl_enqueuembuf(pcb-&gt;utun_ctlref, pcb-&gt;utun_unit, *pkt, CTL_DATA_EOR);
			<span class="enscript-keyword">if</span> (result != 0) {
				printf(<span class="enscript-string">&quot;%s: - ctl_enqueuembuf failed: %d\n&quot;</span>, __FUNCTION__, result);
				mbuf_freem(*pkt);
				<span class="enscript-keyword">return</span> -1;
			}
			*pkt = NULL;
		}
		<span class="enscript-keyword">return</span> 1;
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">utun_pkt_ipsec_input</span> (<span class="enscript-type">struct</span> utun_pcb *pcb, mbuf_t *pkt, protocol_family_t family)
{
	<span class="enscript-keyword">if</span> (!m_tag_locate(*pkt, KERNEL_MODULE_TAG_ID, KERNEL_TAG_TYPE_IPSEC, NULL)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (!(pcb-&gt;utun_flags &amp; UTUN_FLAGS_CRYPTO)) {
		printf(<span class="enscript-string">&quot;%s - crypto disabled\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (!pcb-&gt;utun_ifp) {
		printf(<span class="enscript-string">&quot;%s - utun ifp cleared\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">// place protocol number at the beginning of the mbuf
</span>	<span class="enscript-keyword">if</span> (mbuf_prepend(pkt, <span class="enscript-keyword">sizeof</span>(protocol_family_t), MBUF_DONTWAIT) != 0) {
		printf(<span class="enscript-string">&quot;%s - ifnet_output prepend failed\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> ENOBUFS;
	}
	*(protocol_family_t *)mbuf_data(*pkt) = family;

	(<span class="enscript-type">void</span>)utun_pkt_input(pcb, *pkt);
	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
</pre>
<hr />
</body></html>