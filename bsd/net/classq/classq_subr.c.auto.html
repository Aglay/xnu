<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>classq_subr.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">classq_subr.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2011-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/random.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/classq.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RED</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/classq_red.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RED */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RIO</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/classq_rio.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RIO */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_BLUE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/classq_blue.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_BLUE */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/classq_sfb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pktsched/pktsched.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/altq/altq.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">ifclassq_dequeue_common</span>(<span class="enscript-type">struct</span> ifclassq *, mbuf_svc_class_t,
    u_int32_t, <span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> mbuf **, u_int32_t *, u_int32_t *,
    boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">ifclassq_poll_common</span>(<span class="enscript-type">struct</span> ifclassq *,
    mbuf_svc_class_t, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">ifclassq_tbr_dequeue_common</span>(<span class="enscript-type">struct</span> ifclassq *, <span class="enscript-type">int</span>,
    mbuf_svc_class_t, boolean_t);

<span class="enscript-type">void</span>
<span class="enscript-function-name">classq_init</span>(<span class="enscript-type">void</span>)
{
	_CASSERT(MBUF_TC_BE == 0);
	_CASSERT(MBUF_SC_BE == 0);
	_CASSERT(IFCQ_SC_MAX == MBUF_SC_MAX_CLASSES);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RED</span>
	red_init();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RED */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_RIO</span>
	rio_init();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_RIO */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CLASSQ_BLUE</span>
	blue_init();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CLASSQ_BLUE */</span>
	sfb_init();
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifclassq_setup</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t sflags, boolean_t reuse)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">reuse</span>)
	<span class="enscript-type">struct</span> ifclassq *ifq = &amp;ifp-&gt;if_snd;
	<span class="enscript-type">int</span> err = 0;

	IFCQ_LOCK(ifq);
	VERIFY(IFCQ_IS_EMPTY(ifq));
	ifq-&gt;ifcq_ifp = ifp;
	IFCQ_LEN(ifq) = 0;
	IFCQ_BYTES(ifq) = 0;
	bzero(&amp;ifq-&gt;ifcq_xmitcnt, <span class="enscript-keyword">sizeof</span> (ifq-&gt;ifcq_xmitcnt));
	bzero(&amp;ifq-&gt;ifcq_dropcnt, <span class="enscript-keyword">sizeof</span> (ifq-&gt;ifcq_dropcnt));

	VERIFY(!IFCQ_TBR_IS_ENABLED(ifq));
	VERIFY(ifq-&gt;ifcq_type == PKTSCHEDT_NONE);
	VERIFY(ifq-&gt;ifcq_flags == 0);
	VERIFY(ifq-&gt;ifcq_sflags == 0);
	VERIFY(ifq-&gt;ifcq_disc == NULL);
	VERIFY(ifq-&gt;ifcq_enqueue == NULL);
	VERIFY(ifq-&gt;ifcq_dequeue == NULL);
	VERIFY(ifq-&gt;ifcq_dequeue_sc == NULL);
	VERIFY(ifq-&gt;ifcq_request == NULL);

	<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_TXSTART) {
		u_int32_t maxlen = 0;

		<span class="enscript-keyword">if</span> ((maxlen = IFCQ_MAXLEN(ifq)) == 0)
			maxlen = if_sndq_maxlen;
		IFCQ_SET_MAXLEN(ifq, maxlen);

		<span class="enscript-keyword">if</span> (IFCQ_MAXLEN(ifq) != if_sndq_maxlen &amp;&amp;
		    IFCQ_TARGET_QDELAY(ifq) == 0) {
			<span class="enscript-comment">/*
			 * Choose static queues because the interface has
			 * maximum queue size set
			 */</span>
			sflags &amp;= ~PKTSCHEDF_QALG_DELAYBASED;
		}
		ifq-&gt;ifcq_sflags = sflags;
		err = ifclassq_pktsched_setup(ifq);
		<span class="enscript-keyword">if</span> (err == 0)
			ifq-&gt;ifcq_flags = (IFCQF_READY | IFCQF_ENABLED);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	ifq-&gt;ifcq_drain = 0;
	IFCQ_ALTQ(ifq)-&gt;altq_ifcq = ifq;
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_type == ALTQT_NONE);
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_flags == 0);
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_disc == NULL);
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_enqueue == NULL);
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_dequeue == NULL);
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_dequeue_sc == NULL);
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_request == NULL);

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_eflags &amp; IFEF_TXSTART) &amp;&amp;
	    ifp-&gt;if_output_sched_model != IFNET_SCHED_MODEL_DRIVER_MANAGED)
		ALTQ_SET_READY(IFCQ_ALTQ(ifq));
	<span class="enscript-keyword">else</span>
		ALTQ_CLEAR_READY(IFCQ_ALTQ(ifq));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
	IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifclassq_teardown</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> ifclassq *ifq = &amp;ifp-&gt;if_snd;

	IFCQ_LOCK(ifq);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">if</span> (ALTQ_IS_READY(IFCQ_ALTQ(ifq))) {
		<span class="enscript-keyword">if</span> (ALTQ_IS_ENABLED(IFCQ_ALTQ(ifq)))
			altq_disable(IFCQ_ALTQ(ifq));
		<span class="enscript-keyword">if</span> (ALTQ_IS_ATTACHED(IFCQ_ALTQ(ifq)))
			altq_detach(IFCQ_ALTQ(ifq));
		IFCQ_ALTQ(ifq)-&gt;altq_flags = 0;
	}
	ifq-&gt;ifcq_drain = 0;
	IFCQ_ALTQ(ifq)-&gt;altq_ifcq = NULL;
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_type == ALTQT_NONE);
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_flags == 0);
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_disc == NULL);
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_enqueue == NULL);
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_dequeue == NULL);
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_dequeue_sc == NULL);
	VERIFY(IFCQ_ALTQ(ifq)-&gt;altq_request == NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

	<span class="enscript-keyword">if</span> (IFCQ_IS_READY(ifq)) {
		<span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq)) {
			<span class="enscript-type">struct</span> tb_profile tb = { 0, 0, 0 };
			(<span class="enscript-type">void</span>) ifclassq_tbr_set(ifq, &amp;tb, FALSE);
		}
		(<span class="enscript-type">void</span>) pktsched_teardown(ifq);
		ifq-&gt;ifcq_flags = 0;
	}
	ifq-&gt;ifcq_sflags = 0;

	VERIFY(IFCQ_IS_EMPTY(ifq));
	VERIFY(!IFCQ_TBR_IS_ENABLED(ifq));
	VERIFY(ifq-&gt;ifcq_type == PKTSCHEDT_NONE);
	VERIFY(ifq-&gt;ifcq_flags == 0);
	VERIFY(ifq-&gt;ifcq_sflags == 0);
	VERIFY(ifq-&gt;ifcq_disc == NULL);
	VERIFY(ifq-&gt;ifcq_enqueue == NULL);
	VERIFY(ifq-&gt;ifcq_dequeue == NULL);
	VERIFY(ifq-&gt;ifcq_dequeue_sc == NULL);
	VERIFY(ifq-&gt;ifcq_request == NULL);
	IFCQ_LEN(ifq) = 0;
	IFCQ_BYTES(ifq) = 0;
	IFCQ_MAXLEN(ifq) = 0;
	bzero(&amp;ifq-&gt;ifcq_xmitcnt, <span class="enscript-keyword">sizeof</span> (ifq-&gt;ifcq_xmitcnt));
	bzero(&amp;ifq-&gt;ifcq_dropcnt, <span class="enscript-keyword">sizeof</span> (ifq-&gt;ifcq_dropcnt));

	IFCQ_UNLOCK(ifq);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifclassq_pktsched_setup</span>(<span class="enscript-type">struct</span> ifclassq *ifq)
{
	<span class="enscript-type">struct</span> ifnet *ifp = ifq-&gt;ifcq_ifp;
	<span class="enscript-type">int</span> err = 0;

	IFCQ_LOCK_ASSERT_HELD(ifq);
	VERIFY(ifp-&gt;if_eflags &amp; IFEF_TXSTART);

	<span class="enscript-keyword">switch</span> (ifp-&gt;if_output_sched_model) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFNET_SCHED_MODEL_DRIVER_MANAGED</span>:
		err = pktsched_setup(ifq, PKTSCHEDT_TCQ, ifq-&gt;ifcq_sflags);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFNET_SCHED_MODEL_NORMAL</span>:
		err = pktsched_setup(ifq, PKTSCHEDT_QFQ, ifq-&gt;ifcq_sflags);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifclassq_set_maxlen</span>(<span class="enscript-type">struct</span> ifclassq *ifq, u_int32_t maxqlen)
{
	IFCQ_LOCK(ifq);
	<span class="enscript-keyword">if</span> (maxqlen == 0)
		maxqlen = if_sndq_maxlen;
	IFCQ_SET_MAXLEN(ifq, maxqlen);
	IFCQ_UNLOCK(ifq);
}

u_int32_t
<span class="enscript-function-name">ifclassq_get_maxlen</span>(<span class="enscript-type">struct</span> ifclassq *ifq)
{
	<span class="enscript-keyword">return</span> (IFCQ_MAXLEN(ifq));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifclassq_get_len</span>(<span class="enscript-type">struct</span> ifclassq *ifq, mbuf_svc_class_t sc, u_int32_t *packets,
    u_int32_t *bytes)
{
	<span class="enscript-type">int</span> err = 0;

	IFCQ_LOCK(ifq);
	<span class="enscript-keyword">if</span> (sc == MBUF_SC_UNSPEC) {
		VERIFY(packets != NULL);
		*packets = IFCQ_LEN(ifq);
	} <span class="enscript-keyword">else</span> {
		VERIFY(MBUF_VALID_SC(sc));
		VERIFY(packets != NULL &amp;&amp; bytes != NULL);
		IFCQ_LEN_SC(ifq, sc, packets, bytes, err);
	}
	IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">return</span> (err);
}

errno_t
<span class="enscript-function-name">ifclassq_enqueue</span>(<span class="enscript-type">struct</span> ifclassq *ifq, <span class="enscript-type">struct</span> mbuf *m)
{
	errno_t err;

	IFCQ_LOCK_SPIN(ifq);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">if</span> (ALTQ_IS_ENABLED(IFCQ_ALTQ(ifq))) {
		ALTQ_ENQUEUE(IFCQ_ALTQ(ifq), m, err);
	} <span class="enscript-keyword">else</span> {
		u_int32_t qlen = IFCQ_LEN(ifq);
		IFCQ_ENQUEUE(ifq, m, err);
		<span class="enscript-keyword">if</span> (IFCQ_LEN(ifq) &gt; qlen)
			ifq-&gt;ifcq_drain += (IFCQ_LEN(ifq) - qlen);
	}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !PF_ALTQ */</span>
	IFCQ_ENQUEUE(ifq, m, err);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

	IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">return</span> (err);
}

errno_t
<span class="enscript-function-name">ifclassq_dequeue</span>(<span class="enscript-type">struct</span> ifclassq *ifq, u_int32_t limit, <span class="enscript-type">struct</span> mbuf **head,
    <span class="enscript-type">struct</span> mbuf **tail, u_int32_t *cnt, u_int32_t *len)
{
	<span class="enscript-keyword">return</span> (ifclassq_dequeue_common(ifq, MBUF_SC_UNSPEC, limit, head, tail,
	    cnt, len, FALSE));
}

errno_t
<span class="enscript-function-name">ifclassq_dequeue_sc</span>(<span class="enscript-type">struct</span> ifclassq *ifq, mbuf_svc_class_t sc,
    u_int32_t limit, <span class="enscript-type">struct</span> mbuf **head, <span class="enscript-type">struct</span> mbuf **tail, u_int32_t *cnt,
    u_int32_t *len)
{
	<span class="enscript-keyword">return</span> (ifclassq_dequeue_common(ifq, sc, limit, head, tail,
	    cnt, len, TRUE));
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ifclassq_dequeue_common</span>(<span class="enscript-type">struct</span> ifclassq *ifq, mbuf_svc_class_t sc,
    u_int32_t limit, <span class="enscript-type">struct</span> mbuf **head, <span class="enscript-type">struct</span> mbuf **tail, u_int32_t *cnt,
    u_int32_t *len, boolean_t drvmgt)
{
	<span class="enscript-type">struct</span> ifnet *ifp = ifq-&gt;ifcq_ifp;
	u_int32_t i = 0, l = 0;
	<span class="enscript-type">struct</span> mbuf **first, *last;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-type">struct</span> ifaltq *altq = IFCQ_ALTQ(ifq);
	boolean_t draining;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

	VERIFY(!drvmgt || MBUF_VALID_SC(sc));

	*head = NULL;
	first = &amp;(*head);
	last = NULL;

	ifq = &amp;ifp-&gt;if_snd;
	IFCQ_LOCK_SPIN(ifq);

	<span class="enscript-keyword">while</span> (i &lt; limit) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
		u_int32_t qlen;

		qlen = IFCQ_LEN(ifq);
		draining = IFCQ_IS_DRAINING(ifq);

		<span class="enscript-keyword">if</span> (drvmgt) {
			<span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq))
				IFCQ_TBR_DEQUEUE_SC(ifq, sc, *head);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (draining)
				IFCQ_DEQUEUE_SC(ifq, sc, *head);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ALTQ_IS_ENABLED(altq))
				ALTQ_DEQUEUE_SC(altq, sc, *head);
			<span class="enscript-keyword">else</span>
				*head = NULL;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq))
				IFCQ_TBR_DEQUEUE(ifq, *head);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (draining)
				IFCQ_DEQUEUE(ifq, *head);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ALTQ_IS_ENABLED(altq))
				ALTQ_DEQUEUE(altq, *head);
			<span class="enscript-keyword">else</span>
				*head = NULL;
		}

		<span class="enscript-keyword">if</span> (draining &amp;&amp; *head != NULL) {
			VERIFY(ifq-&gt;ifcq_drain &gt;= (qlen - IFCQ_LEN(ifq)));
			ifq-&gt;ifcq_drain -= (qlen - IFCQ_LEN(ifq));
		}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* ! PF_ALTQ */</span>
		<span class="enscript-keyword">if</span> (drvmgt) {
			<span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq))
				IFCQ_TBR_DEQUEUE_SC(ifq, sc, *head);
			<span class="enscript-keyword">else</span>
				IFCQ_DEQUEUE_SC(ifq, sc, *head);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq))
				IFCQ_TBR_DEQUEUE(ifq, *head);
			<span class="enscript-keyword">else</span>
				IFCQ_DEQUEUE(ifq, *head);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !PF_ALTQ */</span>

		<span class="enscript-keyword">if</span> (*head == NULL)
			<span class="enscript-keyword">break</span>;

		(*head)-&gt;m_nextpkt = NULL;
		last = *head;

		l += (*head)-&gt;m_pkthdr.len;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MEASURE_BW</span>
		(*head)-&gt;m_pkthdr.pkt_bwseq =
		    atomic_add_64_ov(&amp;(ifp-&gt;if_bw.cur_seq), m_pktlen(*head));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MEASURE_BW */</span>
		<span class="enscript-keyword">if</span> (IFNET_IS_CELLULAR(ifp)) {
			(*head)-&gt;m_pkthdr.pkt_flags |= PKTF_VALID_UNSENT_DATA;
			(*head)-&gt;m_pkthdr.pkt_unsent_databytes =
			    (total_snd_byte_count &lt;&lt; MSIZESHIFT) +
			    ifq-&gt;ifcq_bytes;
		}
		head = &amp;(*head)-&gt;m_nextpkt;
		i++;
	}

	IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">if</span> (tail != NULL)
		*tail = last;
	<span class="enscript-keyword">if</span> (cnt != NULL)
		*cnt = i;
	<span class="enscript-keyword">if</span> (len != NULL)
		*len = l;

	<span class="enscript-keyword">return</span> ((*first != NULL) ? 0 : EAGAIN);
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ifclassq_poll</span>(<span class="enscript-type">struct</span> ifclassq *ifq)
{
	<span class="enscript-keyword">return</span> (ifclassq_poll_common(ifq, MBUF_SC_UNSPEC, FALSE));
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ifclassq_poll_sc</span>(<span class="enscript-type">struct</span> ifclassq *ifq, mbuf_svc_class_t sc)
{
	<span class="enscript-keyword">return</span> (ifclassq_poll_common(ifq, sc, TRUE));
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ifclassq_poll_common</span>(<span class="enscript-type">struct</span> ifclassq *ifq, mbuf_svc_class_t sc,
    boolean_t drvmgt)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-type">struct</span> ifaltq *altq = IFCQ_ALTQ(ifq);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
	<span class="enscript-type">struct</span> mbuf *m;

	VERIFY(!drvmgt || MBUF_VALID_SC(sc));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">if</span> (drvmgt) {
		<span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq))
			IFCQ_TBR_POLL_SC(ifq, sc, m);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IFCQ_IS_DRAINING(ifq))
			IFCQ_POLL_SC(ifq, sc, m);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ALTQ_IS_ENABLED(altq))
			ALTQ_POLL_SC(altq, sc, m);
		<span class="enscript-keyword">else</span>
			m = NULL;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq))
			IFCQ_TBR_POLL(ifq, m);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IFCQ_IS_DRAINING(ifq))
			IFCQ_POLL(ifq, m);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ALTQ_IS_ENABLED(altq))
			ALTQ_POLL(altq, m);
		<span class="enscript-keyword">else</span>
			m = NULL;
	}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* ! PF_ALTQ */</span>
	<span class="enscript-keyword">if</span> (drvmgt) {
		<span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq))
			IFCQ_TBR_POLL_SC(ifq, sc, m);
		<span class="enscript-keyword">else</span>
			IFCQ_POLL_SC(ifq, sc, m);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (IFCQ_TBR_IS_ENABLED(ifq))
			IFCQ_TBR_POLL(ifq, m);
		<span class="enscript-keyword">else</span>
			IFCQ_POLL(ifq, m);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !PF_ALTQ */</span>

	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ifclassq_update</span>(<span class="enscript-type">struct</span> ifclassq *ifq, cqev_t ev)
{
	IFCQ_LOCK_ASSERT_HELD(ifq);
	VERIFY(IFCQ_IS_READY(ifq));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">if</span> (ALTQ_IS_ENABLED(IFCQ_ALTQ(ifq)))
		ALTQ_UPDATE(IFCQ_ALTQ(ifq), ev);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
	IFCQ_UPDATE(ifq, ev);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifclassq_attach</span>(<span class="enscript-type">struct</span> ifclassq *ifq, u_int32_t type, <span class="enscript-type">void</span> *discipline,
    ifclassq_enq_func enqueue, ifclassq_deq_func dequeue,
    ifclassq_deq_sc_func dequeue_sc, ifclassq_req_func request)
{
	IFCQ_LOCK_ASSERT_HELD(ifq);

	VERIFY(ifq-&gt;ifcq_disc == NULL);
	VERIFY(enqueue != NULL);
	VERIFY(!(dequeue != NULL &amp;&amp; dequeue_sc != NULL));
	VERIFY(request != NULL);

	ifq-&gt;ifcq_type = type;
	ifq-&gt;ifcq_disc = discipline;
	ifq-&gt;ifcq_enqueue = enqueue;
	ifq-&gt;ifcq_dequeue = dequeue;
	ifq-&gt;ifcq_dequeue_sc = dequeue_sc;
	ifq-&gt;ifcq_request = request;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifclassq_detach</span>(<span class="enscript-type">struct</span> ifclassq *ifq)
{
	IFCQ_LOCK_ASSERT_HELD(ifq);

	VERIFY(ifq-&gt;ifcq_disc == NULL);

	ifq-&gt;ifcq_type = PKTSCHEDT_NONE;
	ifq-&gt;ifcq_disc = NULL;
	ifq-&gt;ifcq_enqueue = NULL;
	ifq-&gt;ifcq_dequeue = NULL;
	ifq-&gt;ifcq_dequeue_sc = NULL;
	ifq-&gt;ifcq_request = NULL;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ifclassq_getqstats</span>(<span class="enscript-type">struct</span> ifclassq *ifq, u_int32_t qid, <span class="enscript-type">void</span> *ubuf,
    u_int32_t *nbytes)
{
	<span class="enscript-type">struct</span> if_ifclassq_stats *ifqs;
	<span class="enscript-type">int</span> err;

	<span class="enscript-keyword">if</span> (*nbytes &lt; <span class="enscript-keyword">sizeof</span> (*ifqs))
		<span class="enscript-keyword">return</span> (EINVAL);

	ifqs = _MALLOC(<span class="enscript-keyword">sizeof</span> (*ifqs), M_TEMP, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (ifqs == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	IFCQ_LOCK(ifq);
	<span class="enscript-keyword">if</span> (!IFCQ_IS_READY(ifq)) {
		IFCQ_UNLOCK(ifq);
		_FREE(ifqs, M_TEMP);
		<span class="enscript-keyword">return</span> (ENXIO);
	}

	ifqs-&gt;ifqs_len = IFCQ_LEN(ifq);
	ifqs-&gt;ifqs_maxlen = IFCQ_MAXLEN(ifq);
	*(&amp;ifqs-&gt;ifqs_xmitcnt) = *(&amp;ifq-&gt;ifcq_xmitcnt);
	*(&amp;ifqs-&gt;ifqs_dropcnt) = *(&amp;ifq-&gt;ifcq_dropcnt);
	ifqs-&gt;ifqs_scheduler = ifq-&gt;ifcq_type;

	err = pktsched_getqstats(ifq, qid, ifqs);
	IFCQ_UNLOCK(ifq);

	<span class="enscript-keyword">if</span> (err == 0 &amp;&amp; (err = copyout((caddr_t)ifqs,
	    (user_addr_t)(uintptr_t)ubuf, <span class="enscript-keyword">sizeof</span> (*ifqs))) == 0)
		*nbytes = <span class="enscript-keyword">sizeof</span> (*ifqs);

	_FREE(ifqs, M_TEMP);

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">ifclassq_ev2str</span>(cqev_t ev)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *c;

	<span class="enscript-keyword">switch</span> (ev) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">CLASSQ_EV_LINK_BANDWIDTH</span>:
		c = <span class="enscript-string">&quot;LINK_BANDWIDTH&quot;</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">CLASSQ_EV_LINK_LATENCY</span>:
		c = <span class="enscript-string">&quot;LINK_LATENCY&quot;</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">CLASSQ_EV_LINK_MTU</span>:
		c = <span class="enscript-string">&quot;LINK_MTU&quot;</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">CLASSQ_EV_LINK_UP</span>:
		c = <span class="enscript-string">&quot;LINK_UP&quot;</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">CLASSQ_EV_LINK_DOWN</span>:
		c = <span class="enscript-string">&quot;LINK_DOWN&quot;</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		c = <span class="enscript-string">&quot;UNKNOWN&quot;</span>;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (c);
}

<span class="enscript-comment">/*
 * internal representation of token bucket parameters
 *	rate:	byte_per_unittime &lt;&lt; 32
 *		(((bits_per_sec) / 8) &lt;&lt; 32) / machclk_freq
 *	depth:	byte &lt;&lt; 32
 *
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TBR_SHIFT</span>	32
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TBR_SCALE</span>(x)	((int64_t)(x) &lt;&lt; TBR_SHIFT)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TBR_UNSCALE</span>(x)	((x) &gt;&gt; TBR_SHIFT)

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ifclassq_tbr_dequeue</span>(<span class="enscript-type">struct</span> ifclassq *ifq, <span class="enscript-type">int</span> op)
{
	<span class="enscript-keyword">return</span> (ifclassq_tbr_dequeue_common(ifq, op, MBUF_SC_UNSPEC, FALSE));
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ifclassq_tbr_dequeue_sc</span>(<span class="enscript-type">struct</span> ifclassq *ifq, <span class="enscript-type">int</span> op, mbuf_svc_class_t sc)
{
	<span class="enscript-keyword">return</span> (ifclassq_tbr_dequeue_common(ifq, op, sc, TRUE));
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ifclassq_tbr_dequeue_common</span>(<span class="enscript-type">struct</span> ifclassq *ifq, <span class="enscript-type">int</span> op,
    mbuf_svc_class_t sc, boolean_t drvmgt)
{
	<span class="enscript-type">struct</span> tb_regulator *tbr;
	<span class="enscript-type">struct</span> mbuf *m;
	int64_t interval;
	u_int64_t now;

	IFCQ_LOCK_ASSERT_HELD(ifq);

	VERIFY(!drvmgt || MBUF_VALID_SC(sc));
	VERIFY(IFCQ_TBR_IS_ENABLED(ifq));

	tbr = &amp;ifq-&gt;ifcq_tbr;
	<span class="enscript-keyword">if</span> (op == CLASSQDQ_REMOVE &amp;&amp; tbr-&gt;tbr_lastop == CLASSQDQ_POLL) {
		<span class="enscript-comment">/* if this is a remove after poll, bypass tbr check */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* update token only when it is negative */</span>
		<span class="enscript-keyword">if</span> (tbr-&gt;tbr_token &lt;= 0) {
			now = read_machclk();
			interval = now - tbr-&gt;tbr_last;
			<span class="enscript-keyword">if</span> (interval &gt;= tbr-&gt;tbr_filluptime) {
				tbr-&gt;tbr_token = tbr-&gt;tbr_depth;
			} <span class="enscript-keyword">else</span> {
				tbr-&gt;tbr_token += interval * tbr-&gt;tbr_rate;
				<span class="enscript-keyword">if</span> (tbr-&gt;tbr_token &gt; tbr-&gt;tbr_depth)
					tbr-&gt;tbr_token = tbr-&gt;tbr_depth;
			}
			tbr-&gt;tbr_last = now;
		}
		<span class="enscript-comment">/* if token is still negative, don't allow dequeue */</span>
		<span class="enscript-keyword">if</span> (tbr-&gt;tbr_token &lt;= 0)
			<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-comment">/*
	 * ifclassq takes precedence over ALTQ queue;
	 * ifcq_drain count is adjusted by the caller.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	<span class="enscript-keyword">if</span> (IFCQ_IS_DRAINING(ifq)) {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
		<span class="enscript-keyword">if</span> (op == CLASSQDQ_POLL) {
			<span class="enscript-keyword">if</span> (drvmgt)
				IFCQ_POLL_SC(ifq, sc, m);
			<span class="enscript-keyword">else</span>
				IFCQ_POLL(ifq, m);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (drvmgt)
				IFCQ_DEQUEUE_SC(ifq, sc, m);
			<span class="enscript-keyword">else</span>
				IFCQ_DEQUEUE(ifq, m);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> ifaltq *altq = IFCQ_ALTQ(ifq);
		<span class="enscript-keyword">if</span> (ALTQ_IS_ENABLED(altq)) {
			<span class="enscript-keyword">if</span> (drvmgt)
				m = (*altq-&gt;altq_dequeue_sc)(altq, sc, op);
			<span class="enscript-keyword">else</span>
				m = (*altq-&gt;altq_dequeue)(altq, op);
		} <span class="enscript-keyword">else</span> {
			m = NULL;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>

	<span class="enscript-keyword">if</span> (m != NULL &amp;&amp; op == CLASSQDQ_REMOVE)
		tbr-&gt;tbr_token -= TBR_SCALE(m_pktlen(m));
	tbr-&gt;tbr_lastop = op;

	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-comment">/*
 * set a token bucket regulator.
 * if the specified rate is zero, the token bucket regulator is deleted.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ifclassq_tbr_set</span>(<span class="enscript-type">struct</span> ifclassq *ifq, <span class="enscript-type">struct</span> tb_profile *profile,
    boolean_t update)
{
	<span class="enscript-type">struct</span> tb_regulator *tbr;
	<span class="enscript-type">struct</span> ifnet *ifp = ifq-&gt;ifcq_ifp;
	u_int64_t rate, old_rate;

	IFCQ_LOCK_ASSERT_HELD(ifq);
	VERIFY(IFCQ_IS_READY(ifq));

	VERIFY(machclk_freq != 0);

	tbr = &amp;ifq-&gt;ifcq_tbr;
	old_rate = tbr-&gt;tbr_rate_raw;

	rate = profile-&gt;rate;
	<span class="enscript-keyword">if</span> (profile-&gt;percent &gt; 0) {
		u_int64_t eff_rate;

		<span class="enscript-keyword">if</span> (profile-&gt;percent &gt; 100)
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> ((eff_rate = ifp-&gt;if_output_bw.eff_bw) == 0)
			<span class="enscript-keyword">return</span> (ENODEV);
		rate = (eff_rate * profile-&gt;percent) / 100;
	}

	<span class="enscript-keyword">if</span> (rate == 0) {
		<span class="enscript-keyword">if</span> (!IFCQ_TBR_IS_ENABLED(ifq))
			<span class="enscript-keyword">return</span> (ENOENT);

		<span class="enscript-keyword">if</span> (pktsched_verbose)
			printf(<span class="enscript-string">&quot;%s: TBR disabled\n&quot;</span>, if_name(ifp));

		<span class="enscript-comment">/* disable this TBR */</span>
		ifq-&gt;ifcq_flags &amp;= ~IFCQF_TBR;
		bzero(tbr, <span class="enscript-keyword">sizeof</span> (*tbr));
		ifnet_set_start_cycle(ifp, NULL);
		<span class="enscript-keyword">if</span> (update)
			ifclassq_update(ifq, CLASSQ_EV_LINK_BANDWIDTH);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (pktsched_verbose) {
		printf(<span class="enscript-string">&quot;%s: TBR %s (rate %llu bps depth %u)\n&quot;</span>, if_name(ifp),
		    (ifq-&gt;ifcq_flags &amp; IFCQF_TBR) ? <span class="enscript-string">&quot;reconfigured&quot;</span> :
		    <span class="enscript-string">&quot;enabled&quot;</span>, rate, profile-&gt;depth);
	}

	<span class="enscript-comment">/* set the new TBR */</span>
	bzero(tbr, <span class="enscript-keyword">sizeof</span> (*tbr));
	tbr-&gt;tbr_rate_raw = rate;
	tbr-&gt;tbr_percent = profile-&gt;percent;
	ifq-&gt;ifcq_flags |= IFCQF_TBR;

	<span class="enscript-comment">/*
	 * Note that the TBR fill up time (hence the ifnet restart time)
	 * is directly related to the specified TBR depth.  The ideal
	 * depth value should be computed such that the interval time
	 * between each successive wakeup is adequately spaced apart,
	 * in order to reduce scheduling overheads.  A target interval
	 * of 10 ms seems to provide good performance balance.  This can be
	 * overridden by specifying the depth profile.  Values smaller than
	 * the ideal depth will reduce delay at the expense of CPU cycles.
	 */</span>
	tbr-&gt;tbr_rate = TBR_SCALE(rate / 8) / machclk_freq;
	<span class="enscript-keyword">if</span> (tbr-&gt;tbr_rate &gt; 0) {
		u_int32_t mtu = ifp-&gt;if_mtu;
		int64_t ival, idepth = 0;
		<span class="enscript-type">int</span> i;

		<span class="enscript-keyword">if</span> (mtu &lt; IF_MINMTU)
			mtu = IF_MINMTU;

		ival = pktsched_nsecs_to_abstime(10 * NSEC_PER_MSEC); <span class="enscript-comment">/* 10ms */</span>

		<span class="enscript-keyword">for</span> (i = 1; ; i++) {
			idepth = TBR_SCALE(i * mtu);
			<span class="enscript-keyword">if</span> ((idepth / tbr-&gt;tbr_rate) &gt; ival)
				<span class="enscript-keyword">break</span>;
		}
		VERIFY(idepth &gt; 0);

		tbr-&gt;tbr_depth = TBR_SCALE(profile-&gt;depth);
		<span class="enscript-keyword">if</span> (tbr-&gt;tbr_depth == 0) {
			tbr-&gt;tbr_filluptime = idepth / tbr-&gt;tbr_rate;
			<span class="enscript-comment">/* a little fudge factor to get closer to rate */</span>
			tbr-&gt;tbr_depth = idepth + (idepth &gt;&gt; 3);
		} <span class="enscript-keyword">else</span> {
			tbr-&gt;tbr_filluptime = tbr-&gt;tbr_depth / tbr-&gt;tbr_rate;
		}
	} <span class="enscript-keyword">else</span> {
		tbr-&gt;tbr_depth = TBR_SCALE(profile-&gt;depth);
		tbr-&gt;tbr_filluptime = 0xffffffffffffffffLL;
	}
	tbr-&gt;tbr_token = tbr-&gt;tbr_depth;
	tbr-&gt;tbr_last = read_machclk();
	tbr-&gt;tbr_lastop = CLASSQDQ_REMOVE;

	<span class="enscript-keyword">if</span> (tbr-&gt;tbr_rate &gt; 0 &amp;&amp; (ifp-&gt;if_flags &amp; IFF_UP)) {
		<span class="enscript-type">struct</span> timespec ts =
		    { 0, pktsched_abs_to_nsecs(tbr-&gt;tbr_filluptime) };
		<span class="enscript-keyword">if</span> (pktsched_verbose) {
			printf(<span class="enscript-string">&quot;%s: TBR calculated tokens %lld &quot;</span>
			    <span class="enscript-string">&quot;filluptime %llu ns\n&quot;</span>, if_name(ifp),
			    TBR_UNSCALE(tbr-&gt;tbr_token),
			    pktsched_abs_to_nsecs(tbr-&gt;tbr_filluptime));
		}
		ifnet_set_start_cycle(ifp, &amp;ts);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (pktsched_verbose) {
			<span class="enscript-keyword">if</span> (tbr-&gt;tbr_rate == 0) {
				printf(<span class="enscript-string">&quot;%s: TBR calculated tokens %lld &quot;</span>
				    <span class="enscript-string">&quot;infinite filluptime\n&quot;</span>, if_name(ifp),
				    TBR_UNSCALE(tbr-&gt;tbr_token));
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; IFF_UP)) {
				printf(<span class="enscript-string">&quot;%s: TBR suspended (link is down)\n&quot;</span>,
				    if_name(ifp));
			}
		}
		ifnet_set_start_cycle(ifp, NULL);
	}
	<span class="enscript-keyword">if</span> (update &amp;&amp; tbr-&gt;tbr_rate_raw != old_rate)
		ifclassq_update(ifq, CLASSQ_EV_LINK_BANDWIDTH);

	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>