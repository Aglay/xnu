<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vnode_internal.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vnode_internal.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)vnode.h	8.17 (Berkeley) 5/20/95
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_SYS_VNODE_INTERNAL_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_SYS_VNODE_INTERNAL_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vfs_context.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>


<span class="enscript-type">struct</span> lockf;
<span class="enscript-type">struct</span> label;

<span class="enscript-function-name">LIST_HEAD</span>(buflists, buf);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
<span class="enscript-comment">/*
 * VFS Internal (private) trigger vnode resolver info.
 */</span>
<span class="enscript-type">struct</span> vnode_resolve {
	lck_mtx_t				vr_lock;   <span class="enscript-comment">/* protects vnode_resolve_t fields */</span>
	trigger_vnode_resolve_callback_t	vr_resolve_func;
	trigger_vnode_unresolve_callback_t	vr_unresolve_func;
	trigger_vnode_rearm_callback_t		vr_rearm_func;
	trigger_vnode_reclaim_callback_t	vr_reclaim_func;
	<span class="enscript-type">void</span> *					vr_data;   <span class="enscript-comment">/* private data for resolver */</span>
	uint32_t				vr_flags;
	uint32_t				vr_lastseq;
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> vnode_resolve *vnode_resolve_t;

<span class="enscript-comment">/* private vr_flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNT_RESOLVED</span>        (1UL &lt;&lt; 31)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNT_VFS_UNMOUNTED</span>   (1UL &lt;&lt; 30)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNT_EXTERNAL</span>	    (1UL &lt;&lt; 29)

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_TRIGGERS */</span>

<span class="enscript-comment">/*
 * Reading or writing any of these items requires holding the appropriate lock.
 * v_freelist is locked by the global vnode_list_lock
 * v_mntvnodes is locked by the mount_lock
 * v_nclinks and v_ncchildren are protected by the global name_cache_lock
 * v_cleanblkhd and v_dirtyblkhd and v_iterblkflags are locked via the global buf_mtxp
 * the rest of the structure is protected by the vnode_lock
 */</span>
<span class="enscript-type">struct</span> vnode {
	lck_mtx_t v_lock;			<span class="enscript-comment">/* vnode mutex */</span>
	TAILQ_ENTRY(vnode) v_freelist;		<span class="enscript-comment">/* vnode freelist */</span>
	TAILQ_ENTRY(vnode) v_mntvnodes;		<span class="enscript-comment">/* vnodes for mount point */</span>
        LIST_HEAD(, namecache) v_nclinks;	<span class="enscript-comment">/* name cache entries that name this vnode */</span>
        LIST_HEAD(, namecache) v_ncchildren;	<span class="enscript-comment">/* name cache entries that regard us as their parent */</span>
        vnode_t	 v_defer_reclaimlist;		<span class="enscript-comment">/* in case we have to defer the reclaim to avoid recursion */</span>
        uint32_t v_listflag;			<span class="enscript-comment">/* flags protected by the vnode_list_lock (see below) */</span>
	uint32_t v_flag;			<span class="enscript-comment">/* vnode flags (see below) */</span>
	uint16_t v_lflag;			<span class="enscript-comment">/* vnode local and named ref flags */</span>
	uint8_t	 v_iterblkflags;		<span class="enscript-comment">/* buf iterator flags */</span>
	uint8_t	 v_references;			<span class="enscript-comment">/* number of times io_count has been granted */</span>
	int32_t	 v_kusecount;			<span class="enscript-comment">/* count of in-kernel refs */</span>
	int32_t	 v_usecount;			<span class="enscript-comment">/* reference count of users */</span>
	int32_t	 v_iocount;			<span class="enscript-comment">/* iocounters */</span>
	<span class="enscript-type">void</span> *   v_owner;			<span class="enscript-comment">/* act that owns the vnode */</span>
	uint16_t v_type;			<span class="enscript-comment">/* vnode type */</span>
	uint16_t v_tag;				<span class="enscript-comment">/* type of underlying data */</span>
	uint32_t v_id;				<span class="enscript-comment">/* identity of vnode contents */</span>
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> mount	*vu_mountedhere;<span class="enscript-comment">/* ptr to mounted vfs (VDIR) */</span>
		<span class="enscript-type">struct</span> socket	*vu_socket;	<span class="enscript-comment">/* unix ipc (VSOCK) */</span>
		<span class="enscript-type">struct</span> specinfo	*vu_specinfo;	<span class="enscript-comment">/* device (VCHR, VBLK) */</span>
		<span class="enscript-type">struct</span> fifoinfo	*vu_fifoinfo;	<span class="enscript-comment">/* fifo (VFIFO) */</span>
	        <span class="enscript-type">struct</span> ubc_info *vu_ubcinfo;	<span class="enscript-comment">/* valid for (VREG) */</span>
	} v_un;
	<span class="enscript-type">struct</span>	buflists v_cleanblkhd;		<span class="enscript-comment">/* clean blocklist head */</span>
	<span class="enscript-type">struct</span>	buflists v_dirtyblkhd;		<span class="enscript-comment">/* dirty blocklist head */</span>
	<span class="enscript-type">struct</span> klist v_knotes;			<span class="enscript-comment">/* knotes attached to this vnode */</span>
        <span class="enscript-comment">/*
	 * the following 4 fields are protected
	 * by the name_cache_lock held in 
	 * excluive mode
	 */</span>
        kauth_cred_t	v_cred;			<span class="enscript-comment">/* last authorized credential */</span>
        kauth_action_t	v_authorized_actions;	<span class="enscript-comment">/* current authorized actions for v_cred */</span>
        <span class="enscript-type">int</span>		v_cred_timestamp;	<span class="enscript-comment">/* determine if entry is stale for MNTK_AUTH_OPAQUE */</span>
        <span class="enscript-type">int</span>		v_nc_generation;	<span class="enscript-comment">/* changes when nodes are removed from the name cache */</span>
        <span class="enscript-comment">/*
	 * back to the vnode lock for protection
	 */</span>
	int32_t		v_numoutput;			<span class="enscript-comment">/* num of writes in progress */</span>
	int32_t		v_writecount;			<span class="enscript-comment">/* reference count of writers */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *v_name;			<span class="enscript-comment">/* name component of the vnode */</span>
	vnode_t v_parent;			<span class="enscript-comment">/* pointer to parent vnode */</span>
	<span class="enscript-type">struct</span> lockf	*v_lockf;		<span class="enscript-comment">/* advisory lock list head */</span>
	<span class="enscript-type">int</span> 	(**v_op)(<span class="enscript-type">void</span> *);		<span class="enscript-comment">/* vnode operations vector */</span>
	mount_t v_mount;			<span class="enscript-comment">/* ptr to vfs we are in */</span>
	<span class="enscript-type">void</span> *	v_data;				<span class="enscript-comment">/* private data for fs */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">struct</span> label *v_label;			<span class="enscript-comment">/* MAC security label */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	vnode_resolve_t v_resolve;		<span class="enscript-comment">/* trigger vnode resolve info (VDIR only) */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_TRIGGERS */</span>
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">v_mountedhere</span>	v_un.vu_mountedhere
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">v_socket</span>	v_un.vu_socket
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">v_specinfo</span>	v_un.vu_specinfo
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">v_fifoinfo</span>	v_un.vu_fifoinfo
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">v_ubcinfo</span>	v_un.vu_ubcinfo


<span class="enscript-comment">/*
 * v_iterblkflags
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VBI_ITER</span>		0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VBI_ITERWANT</span>		0x2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VBI_CLEAN</span>		0x4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VBI_DIRTY</span>		0x8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VBI_NEWBUF</span>		0x10

<span class="enscript-comment">/*
 * v_listflag
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VLIST_RAGE</span>		  0x01		<span class="enscript-comment">/* vnode is currently in the rapid age list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VLIST_DEAD</span>		  0x02		<span class="enscript-comment">/* vnode is currently in the dead list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VLIST_ASYNC_WORK</span>	  0x04		<span class="enscript-comment">/* vnode is currently on the deferred async work queue */</span>

<span class="enscript-comment">/*
 * v_lflags
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VL_SUSPENDED</span> 	0x0001		<span class="enscript-comment">/* vnode is suspended */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VL_DRAIN</span>	0x0002		<span class="enscript-comment">/* vnode is being drained */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VL_TERMINATE</span>	0x0004		<span class="enscript-comment">/* vnode is in the process of being recycled */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VL_TERMWANT</span>	0x0008		<span class="enscript-comment">/* there's a waiter  for recycle finish (vnode_getiocount)*/</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VL_DEAD</span>		0x0010		<span class="enscript-comment">/* vnode is dead, cleaned of filesystem-specific info */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VL_MARKTERM</span>	0x0020		<span class="enscript-comment">/* vnode should be recycled when no longer referenced */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VL_NEEDINACTIVE</span>	0x0080		<span class="enscript-comment">/* delay VNOP_INACTIVE until iocount goes to 0 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VL_LABEL</span>	0x0100		<span class="enscript-comment">/* vnode is marked for labeling */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VL_LABELWAIT</span>	0x0200		<span class="enscript-comment">/* vnode is marked for labeling */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VL_LABELED</span>	0x0400		<span class="enscript-comment">/* vnode is labeled */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VL_LWARNED</span>	0x0800
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VL_HASSTREAMS</span>	0x1000		<span class="enscript-comment">/* vnode has had at least one associated named stream vnode (may not have one any longer) */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNAMED_UBC</span>	0x2000		<span class="enscript-comment">/* ubc named reference */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNAMED_MOUNT</span>	0x4000		<span class="enscript-comment">/* mount point named reference */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNAMED_FSHASH</span>	0x8000		<span class="enscript-comment">/* FS hash named reference */</span>

<span class="enscript-comment">/*
 * v_flags
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VROOT</span>		0x000001	<span class="enscript-comment">/* root of its file system */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VTEXT</span>		0x000002	<span class="enscript-comment">/* vnode is a pure text prototype */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VSYSTEM</span>		0x000004	<span class="enscript-comment">/* vnode being used by kernel */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VISTTY</span>		0x000008	<span class="enscript-comment">/* vnode represents a tty */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VRAGE</span>		0x000010	<span class="enscript-comment">/* vnode is in rapid age state */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VBDEVVP</span>		0x000020        <span class="enscript-comment">/* vnode created by bdevvp */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VDEVFLUSH</span>	0x000040        <span class="enscript-comment">/* device vnode after vflush */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VMOUNT</span>		0x000080	<span class="enscript-comment">/* mount operation in progress */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VBWAIT</span>		0x000100	<span class="enscript-comment">/* waiting for output to complete */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VSHARED_DYLD</span>	0x000200	<span class="enscript-comment">/* vnode is a dyld shared cache file */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNOCACHE_DATA</span>	0x000400	<span class="enscript-comment">/* don't keep data cached once it's been consumed */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VSTANDARD</span>	0x000800	<span class="enscript-comment">/* vnode obtained from common pool */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VAGE</span>		0x001000	<span class="enscript-comment">/* Insert vnode at head of free list */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VRAOFF</span>		0x002000	<span class="enscript-comment">/* read ahead disabled */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNCACHEABLE</span>	0x004000	<span class="enscript-comment">/* vnode is allowed to be put back in name cache */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VISSHADOW</span>	0x008000	<span class="enscript-comment">/* vnode is a shadow file */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VSWAP</span>		0x010000	<span class="enscript-comment">/* vnode is being used as swapfile */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VTHROTTLED</span>	0x020000	<span class="enscript-comment">/* writes or pageouts have been throttled */</span>
		<span class="enscript-comment">/* wakeup tasks waiting when count falls below threshold */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNOFLUSH</span>	0x040000	<span class="enscript-comment">/* don't vflush() if SKIPSYSTEM */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VLOCKLOCAL</span>	0x080000	<span class="enscript-comment">/* this vnode does adv locking in vfs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VISHARDLINK</span>	0x100000	<span class="enscript-comment">/* hard link needs special processing on lookup and in volfs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VISUNION</span>	0x200000	<span class="enscript-comment">/* union special processing */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VISNAMEDSTREAM</span>	0x400000	<span class="enscript-comment">/* vnode is a named stream (eg HFS resource fork) */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VOPENEVT</span>        0x800000        <span class="enscript-comment">/* if process is P_CHECKOPENEVT, then or in the O_EVTONLY flag on open */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNEEDSSNAPSHOT</span> 0x1000000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNOCS</span>	       0x2000000	<span class="enscript-comment">/* is there no code signature available */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VISDIRTY</span>       0x4000000        <span class="enscript-comment">/* vnode will need IO if reclaimed */</span>	
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFASTDEVCANDIDATE</span>  0x8000000        <span class="enscript-comment">/* vnode is a candidate to store on a fast device */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VAUTOCANDIDATE</span> 0x10000000       <span class="enscript-comment">/* vnode was automatically marked as a fast-dev candidate */</span>
<span class="enscript-comment">/*
  0x20000000 not used
  0x40000000 not used
  0x80000000 not used.
*/</span>

<span class="enscript-comment">/*
 * This structure describes vnode data which is specific to a file descriptor.
 * It is currently used only for file descriptors which are for opened for
 * directories.
 */</span>
<span class="enscript-type">struct</span> fd_vn_data {
	lck_mtx_t fv_lock;   <span class="enscript-comment">/* Used to serialize directory enumeration on fd */</span>
	off_t     fv_offset; <span class="enscript-comment">/* Offset to be used */</span>
	<span class="enscript-type">void</span>      *fv_dircookie; <span class="enscript-comment">/* If FS doesn't like offsets in directories */</span>
	caddr_t   fv_buf;    <span class="enscript-comment">/* Temporary buffer to store directory entries */</span>
	size_t    fv_bufsiz;  <span class="enscript-comment">/* Valid size of fv_buf */</span>
	size_t    fv_bufdone; <span class="enscript-comment">/* How much of fv_buf is processed */</span>
	size_t    fv_bufallocsiz; <span class="enscript-comment">/* Allocation size determined for Buffer*/</span>
	off_t     fv_soff;   <span class="enscript-comment">/* Starting FS offset for this buffer */</span>
	off_t     fv_eoff;   <span class="enscript-comment">/* Ending FS offset for this buffer */</span>
	<span class="enscript-type">int</span>       fv_eofflag;<span class="enscript-comment">/* Does fv_eoff represent EOF ? */</span>
};

<span class="enscript-comment">/*
 * FV_DIRBUF_START_SIZ is the initial size of the buffer passed to VNOP_READDIR.
 * That may not be enough for some filesytems so the current algorithm works its
 * way upto FV_DIRBUF_MAX_SIZ
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FV_DIRBUF_DIRENTRY_SIZ</span>	(sizeof(struct direntry))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FV_DIRBUF_START_SIZ</span>	FV_DIRBUF_DIRENTRY_SIZ
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FV_DIRBUF_MAX_SIZ</span>	(4*(sizeof(struct direntry)))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FV_LOCK</span>(fvd) lck_mtx_lock(&amp;(((struct fd_vn_data *)fvd)-&gt;fv_lock))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">FV_UNLOCK</span>(fvd) lck_mtx_unlock(&amp;(((struct fd_vn_data *)fvd)-&gt;fv_lock))

<span class="enscript-comment">/*
 * Global vnode data.
 */</span>
<span class="enscript-type">extern</span>	<span class="enscript-type">struct</span> vnode *rootvnode;	<span class="enscript-comment">/* root (i.e. &quot;/&quot;) vnode */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_IMGSRC_ACCESS</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_IMAGEBOOT_NESTING</span>	2
<span class="enscript-type">extern</span>	<span class="enscript-type">struct</span> vnode *imgsrc_rootvnodes[];
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IMGSRC_ACCESS */</span>


<span class="enscript-comment">/*
 * Mods for exensibility.
 */</span>

<span class="enscript-comment">/*
 * Flags for vdesc_flags:
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VDESC_MAX_VPS</span>		16
<span class="enscript-comment">/* Low order 16 flag bits are reserved for willrele flags for vp arguments. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VDESC_VP0_WILLRELE</span>	0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VDESC_VP1_WILLRELE</span>	0x0002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VDESC_VP2_WILLRELE</span>	0x0004
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VDESC_VP3_WILLRELE</span>	0x0008
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VDESC_NOMAP_VPP</span>		0x0100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VDESC_VPP_WILLRELE</span>	0x0200

<span class="enscript-comment">/*
 * VDESC_NO_OFFSET is used to identify the end of the offset list
 * and in places where no such field exists.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VDESC_NO_OFFSET</span> -1

<span class="enscript-comment">/*
 * This structure describes the vnode operation taking place.
 */</span>
<span class="enscript-type">struct</span> vnodeop_desc {
	<span class="enscript-type">int</span>	vdesc_offset;		<span class="enscript-comment">/* offset in vector--first for speed */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *vdesc_name;		<span class="enscript-comment">/* a readable name for debugging */</span>
	<span class="enscript-type">int</span>	vdesc_flags;		<span class="enscript-comment">/* VDESC_* flags */</span>

	<span class="enscript-comment">/*
	 * These ops are used by bypass routines to map and locate arguments.
	 * Creds and procs are not needed in bypass routines, but sometimes
	 * they are useful to (for example) transport layers.
	 * Nameidata is useful because it has a cred in it.
	 */</span>
	<span class="enscript-type">int</span>	*vdesc_vp_offsets;	<span class="enscript-comment">/* list ended by VDESC_NO_OFFSET */</span>
	<span class="enscript-type">int</span>	vdesc_vpp_offset;	<span class="enscript-comment">/* return vpp location */</span>
	<span class="enscript-type">int</span>	vdesc_cred_offset;	<span class="enscript-comment">/* cred location, if any */</span>
	<span class="enscript-type">int</span>	vdesc_proc_offset;	<span class="enscript-comment">/* proc location, if any */</span>
	<span class="enscript-type">int</span>	vdesc_componentname_offset; <span class="enscript-comment">/* if any */</span>
	<span class="enscript-type">int</span>	vdesc_context_offset;	<span class="enscript-comment">/* context location, if any */</span>
	<span class="enscript-comment">/*
	 * Finally, we've got a list of private data (about each operation)
	 * for each transport layer.  (Support to manage this list is not
	 * yet part of BSD.)
	 */</span>
	caddr_t	*vdesc_transports;
};

<span class="enscript-comment">/*
 * A list of all the operation descs.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> vnodeop_desc *vnodeop_descs[];


<span class="enscript-comment">/*
 * This macro is very helpful in defining those offsets in the vdesc struct.
 *
 * This is stolen from X11R4.  I ingored all the fancy stuff for
 * Crays, so if you decide to port this to such a serious machine,
 * you might want to consult Intrisics.h's XtOffset{,Of,To}.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VOPARG_OFFSET</span>(p_type,field) \
        ((<span class="enscript-type">int</span>) (((<span class="enscript-type">char</span> *) (&amp;(((p_type)NULL)-&gt;field))) - ((<span class="enscript-type">char</span> *) NULL)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VOPARG_OFFSETOF</span>(s_type,field) \
	VOPARG_OFFSET(s_type*,field)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VOPARG_OFFSETTO</span>(S_TYPE,S_OFFSET,STRUCT_P) \
	((S_TYPE)(((<span class="enscript-type">char</span>*)(STRUCT_P))+(S_OFFSET)))



<span class="enscript-comment">/*
 * VOCALL calls an op given an ops vector.  We break it out because BSD's
 * vclean changes the ops vector and then wants to call ops with the old
 * vector.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VOCALL</span>(OPSV,OFF,AP) (( *((OPSV)[(OFF)])) (AP))

<span class="enscript-comment">/*
 * This call works for vnodes in the kernel.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VCALL</span>(VP,OFF,AP) VOCALL((VP)-&gt;v_op,(OFF),(AP))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VDESC</span>(OP) (&amp; __CONCAT(OP,_desc))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VOFFSET</span>(OP) (VDESC(OP)-&gt;vdesc_offset)

<span class="enscript-type">struct</span> ostat;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BUILDPATH_NO_FS_ENTER</span>     0x1 <span class="enscript-comment">/* Use cache values, do not enter file system */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BUILDPATH_CHECKACCESS</span>     0x2 <span class="enscript-comment">/* Check if parents have search rights */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BUILDPATH_CHECK_MOVED</span>     0x4 <span class="enscript-comment">/* Return EAGAIN if the parent hierarchy is modified */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BUILDPATH_VOLUME_RELATIVE</span> 0x8 <span class="enscript-comment">/* Return path relative to the nearest mount point */</span>

<span class="enscript-type">int</span>	build_path(vnode_t first_vp, <span class="enscript-type">char</span> *buff, <span class="enscript-type">int</span> buflen, <span class="enscript-type">int</span> *outlen, <span class="enscript-type">int</span> flags, vfs_context_t ctx);

<span class="enscript-type">int</span> 	bdevvp(dev_t dev, <span class="enscript-type">struct</span> vnode **vpp);
<span class="enscript-type">void</span>	cvtstat(<span class="enscript-type">struct</span> stat *st, <span class="enscript-type">struct</span> ostat *ost);
<span class="enscript-type">void</span>	vprint(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *label, <span class="enscript-type">struct</span> vnode *vp);


__private_extern__ <span class="enscript-type">int</span> is_package_name(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> len);
__private_extern__ <span class="enscript-type">int</span> set_package_extensions_table(user_addr_t data, <span class="enscript-type">int</span> nentries, <span class="enscript-type">int</span> maxwidth);
<span class="enscript-type">int</span> 	vn_rdwr_64(<span class="enscript-type">enum</span> uio_rw rw, <span class="enscript-type">struct</span> vnode *vp, uint64_t base,
	    		int64_t len, off_t offset, <span class="enscript-type">enum</span> uio_seg segflg,
			<span class="enscript-type">int</span> ioflg, kauth_cred_t cred, int64_t *aresid,
			<span class="enscript-type">struct</span> proc *p);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
<span class="enscript-type">int</span>	vn_setlabel (<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> label *intlabel,
	    vfs_context_t context);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">void</span>	fifo_printinfo(<span class="enscript-type">struct</span> vnode *vp);
<span class="enscript-type">int</span> 	vn_open(<span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">int</span> fmode, <span class="enscript-type">int</span> cmode);
<span class="enscript-type">int</span>	vn_open_modflags(<span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">int</span> *fmode, <span class="enscript-type">int</span> cmode);
<span class="enscript-type">int</span>	vn_open_auth(<span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">int</span> *fmode, <span class="enscript-type">struct</span> vnode_attr *);
<span class="enscript-type">int</span> 	vn_close(vnode_t, <span class="enscript-type">int</span> flags, vfs_context_t ctx);
errno_t <span class="enscript-function-name">vn_remove</span>(vnode_t dvp, vnode_t *vpp, <span class="enscript-type">struct</span> nameidata *ndp, int32_t flags, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx);
errno_t <span class="enscript-function-name">vn_rename</span>(<span class="enscript-type">struct</span> vnode *fdvp, <span class="enscript-type">struct</span> vnode **fvpp, <span class="enscript-type">struct</span> componentname *fcnp, <span class="enscript-type">struct</span> vnode_attr *fvap,
       	     <span class="enscript-type">struct</span> vnode *tdvp, <span class="enscript-type">struct</span> vnode **tvpp, <span class="enscript-type">struct</span> componentname *tcnp, <span class="enscript-type">struct</span> vnode_attr *tvap,
       	     uint32_t flags, vfs_context_t ctx);

<span class="enscript-type">void</span>	lock_vnode_and_post(vnode_t, <span class="enscript-type">int</span>);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">post_event_if_success</span>(_vp, _error, _event) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (0 == (_error)) {	\
			lock_vnode_and_post((_vp), (_event)); \
		} \
	} <span class="enscript-keyword">while</span> (0) 
		
<span class="enscript-comment">/* Authorization subroutines */</span>
<span class="enscript-type">int</span>	vn_authorize_open_existing(vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">int</span> fmode, vfs_context_t ctx, <span class="enscript-type">void</span> *reserved);
<span class="enscript-type">int</span>	vn_authorize_create(vnode_t, <span class="enscript-type">struct</span> componentname *, <span class="enscript-type">struct</span> vnode_attr *, vfs_context_t, <span class="enscript-type">void</span>*); 
<span class="enscript-type">int</span>	vn_attribute_prepare(vnode_t dvp, <span class="enscript-type">struct</span> vnode_attr *vap, uint32_t *defaulted_fieldsp, vfs_context_t ctx);
<span class="enscript-type">void</span>	vn_attribute_cleanup(<span class="enscript-type">struct</span> vnode_attr *vap, uint32_t defaulted_fields);
<span class="enscript-type">int</span>	vn_authorize_unlink(vnode_t dvp, vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp, vfs_context_t ctx, <span class="enscript-type">void</span> *reserved);
<span class="enscript-type">int</span> 	vn_authorize_rename(<span class="enscript-type">struct</span> vnode *fdvp, <span class="enscript-type">struct</span> vnode *fvp, <span class="enscript-type">struct</span> componentname *fcnp,
       		<span class="enscript-type">struct</span> vnode *tdvp, <span class="enscript-type">struct</span> vnode *tvp, <span class="enscript-type">struct</span> componentname *tcnp,
            	vfs_context_t ctx, <span class="enscript-type">void</span> *reserved);
<span class="enscript-type">int</span>	vn_authorize_rmdir(vnode_t dvp, vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp, vfs_context_t ctx, <span class="enscript-type">void</span> *reserved);

<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*vn_create_authorizer_t)(vnode_t, <span class="enscript-type">struct</span> componentname *, <span class="enscript-type">struct</span> vnode_attr *, vfs_context_t, <span class="enscript-type">void</span>*);
<span class="enscript-type">int</span> <span class="enscript-function-name">vn_authorize_mkdir</span>(vnode_t, <span class="enscript-type">struct</span> componentname *, <span class="enscript-type">struct</span> vnode_attr *, vfs_context_t, <span class="enscript-type">void</span>*);
<span class="enscript-type">int</span> <span class="enscript-function-name">vn_authorize_null</span>(vnode_t, <span class="enscript-type">struct</span> componentname *, <span class="enscript-type">struct</span> vnode_attr *, vfs_context_t, <span class="enscript-type">void</span>*);
<span class="enscript-comment">/* End of authorization subroutines */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VN_CREATE_NOAUTH</span>		(1&lt;&lt;0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VN_CREATE_NOINHERIT</span>		(1&lt;&lt;1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VN_CREATE_UNION</span>			(1&lt;&lt;2)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VN_CREATE_NOLABEL</span>		(1&lt;&lt;3)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VN_CREATE_DOOPEN</span>		(1&lt;&lt;4)	<span class="enscript-comment">/* Open file if a batched operation is available */</span>
errno_t <span class="enscript-function-name">vn_create</span>(vnode_t, vnode_t *, <span class="enscript-type">struct</span> nameidata *, <span class="enscript-type">struct</span> vnode_attr *, uint32_t, <span class="enscript-type">int</span>, uint32_t*, vfs_context_t);
<span class="enscript-type">int</span>	vn_mkdir(vnode_t dvp, vnode_t *vpp, <span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx);
<span class="enscript-type">int</span> 	vn_rmdir(vnode_t dvp, vnode_t *vpp, <span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx);

<span class="enscript-type">int</span>	vn_getxattr(vnode_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, uio_t, size_t *, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span>	vn_setxattr(vnode_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, uio_t, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span>	vn_removexattr(vnode_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span>	vn_listxattr(vnode_t, uio_t, size_t *, <span class="enscript-type">int</span>, vfs_context_t);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
errno_t  <span class="enscript-function-name">vnode_getnamedstream</span>(vnode_t, vnode_t *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">enum</span> nsoperation, <span class="enscript-type">int</span>, vfs_context_t);
errno_t  <span class="enscript-function-name">vnode_makenamedstream</span>(vnode_t, vnode_t *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vfs_context_t);
errno_t  <span class="enscript-function-name">vnode_removenamedstream</span>(vnode_t, vnode_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vfs_context_t);
errno_t  <span class="enscript-function-name">vnode_flushnamedstream</span>(vnode_t vp, vnode_t svp, vfs_context_t context);
errno_t  <span class="enscript-function-name">vnode_relenamedstream</span>(vnode_t vp, vnode_t svp);
errno_t  <span class="enscript-function-name">vnode_verifynamedstream</span> (vnode_t vp);
#<span class="enscript-reference">endif</span>


<span class="enscript-type">void</span>	nchinit(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span>	resize_namecache(uint32_t newsize);
<span class="enscript-type">void</span>	name_cache_lock_shared(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	name_cache_lock(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	name_cache_unlock(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	cache_enter_with_gen(vnode_t dvp, vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">int</span> gen);
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">cache_enter_create</span>(vnode_t dvp, vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp);

<span class="enscript-type">int</span> <span class="enscript-function-name">vn_pathconf</span>(vnode_t, <span class="enscript-type">int</span>, int32_t *, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nc_disabled; 	

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vnode_lock_convert</span>(v)	lck_mtx_convert_spin(&amp;(v)-&gt;v_lock)

<span class="enscript-type">void</span>	vnode_lock_spin(vnode_t);


<span class="enscript-type">void</span>	vnode_list_lock(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	vnode_list_unlock(<span class="enscript-type">void</span>);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_REF_FORCE</span>	0x1
<span class="enscript-type">int</span>	vnode_ref_ext(vnode_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);

<span class="enscript-type">void</span>	vnode_rele_ext(vnode_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	vnode_rele_internal(vnode_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
<span class="enscript-type">int</span>	vnode_getalways(vnode_t);
<span class="enscript-type">int</span> 	vget_internal(vnode_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
errno_t <span class="enscript-function-name">vnode_getiocount</span>(vnode_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>
<span class="enscript-type">int</span>	vnode_get_locked(vnode_t);
<span class="enscript-type">int</span>	vnode_put_locked(vnode_t);

<span class="enscript-type">int</span>	vnode_issock(vnode_t);
<span class="enscript-type">int</span>	vnode_isaliased(vnode_t);

<span class="enscript-type">void</span>	unlock_fsnode(vnode_t, <span class="enscript-type">int</span> *);
<span class="enscript-type">int</span>	lock_fsnode(vnode_t, <span class="enscript-type">int</span> *);

errno_t	vnode_resume(vnode_t);
errno_t	vnode_suspend(vnode_t);


errno_t	vnode_mtime(vnode_t, <span class="enscript-type">struct</span> timespec *, vfs_context_t);
errno_t <span class="enscript-function-name">vnode_flags</span>(vnode_t, uint32_t *, vfs_context_t);

errno_t	vnode_size(vnode_t, off_t *, vfs_context_t);
errno_t	vnode_setsize(vnode_t, off_t, <span class="enscript-type">int</span> ioflag, vfs_context_t);
<span class="enscript-type">int</span>	vnode_setattr_fallback(vnode_t vp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx);
<span class="enscript-type">int</span>	vnode_isspec(vnode_t vp);


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>

<span class="enscript-type">typedef</span> uint32_t compound_vnop_id_t;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">COMPOUND_VNOP_OPEN</span>		0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">COMPOUND_VNOP_MKDIR</span>		0x02
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">COMPOUND_VNOP_RENAME</span>		0x04
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">COMPOUND_VNOP_REMOVE</span>		0x08
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">COMPOUND_VNOP_RMDIR</span>		0x10

<span class="enscript-type">int</span> 	vnode_compound_rename_available(vnode_t vp);
<span class="enscript-type">int</span> 	vnode_compound_rmdir_available(vnode_t vp);
<span class="enscript-type">int</span> 	vnode_compound_mkdir_available(vnode_t vp);
<span class="enscript-type">int</span> 	vnode_compound_remove_available(vnode_t vp);
<span class="enscript-type">int</span> 	vnode_compound_open_available(vnode_t vp);
<span class="enscript-type">int</span>    	vnode_compound_op_available(vnode_t, compound_vnop_id_t);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">vn_setunionwait</span>(vnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">vn_checkunionwait</span>(vnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">vn_clearunionwait</span>(vnode_t, <span class="enscript-type">int</span>);

<span class="enscript-type">void</span> <span class="enscript-function-name">SPECHASH_LOCK</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">SPECHASH_UNLOCK</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span>	vnode_authorize_init(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span>	vfsinit(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_lock</span>(vnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_unlock</span>(vnode_t);

<span class="enscript-type">void</span> <span class="enscript-function-name">vn_print_state</span>(vnode_t <span class="enscript-comment">/* vp */</span>, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * <span class="enscript-comment">/* fmt */</span>, ...)
    __printflike(2,3);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VNASSERT</span>(exp, vp, msg)						\
<span class="enscript-keyword">do</span> {									\
	<span class="enscript-keyword">if</span> (__improbable(!(exp))) {					\
		vn_print_state(vp, <span class="enscript-string">&quot;VNASSERT failed %s:%d\n&quot;</span>, __FILE__,	\
		    __LINE__);						\
		panic msg;						\
	}								\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VNASSERT</span>(exp, vp, msg)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

<span class="enscript-comment">/*
 * XXX exported symbols; should be static
 */</span>
<span class="enscript-type">void</span>	vfs_op_init(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	vfs_opv_init(<span class="enscript-type">void</span>);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
<span class="enscript-type">int</span> vfs_sysctl_node SYSCTL_HANDLER_ARGS;
<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_setneedinactive</span>(vnode_t);
<span class="enscript-type">int</span> 	vnode_hasnamedstreams(vnode_t); <span class="enscript-comment">/* Does this vnode have associated named streams? */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">nspace_proc_exit</span>(<span class="enscript-type">struct</span> proc *p);

errno_t
<span class="enscript-function-name">vnode_readdir64</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> *eofflag,
                <span class="enscript-type">int</span> *numdirent, vfs_context_t ctxp);

<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_setswapmount</span>(vnode_t);
int64_t	vnode_getswappin_avail(vnode_t);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
<span class="enscript-comment">/* VFS Internal Vnode Trigger Interfaces (Private) */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">vnode_trigger_resolve</span>(vnode_t, <span class="enscript-type">struct</span> nameidata *, vfs_context_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_trigger_rearm</span>(vnode_t, vfs_context_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">vfs_nested_trigger_unmounts</span>(mount_t, <span class="enscript-type">int</span>, vfs_context_t);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_TRIGGERS */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_SYS_VNODE_INTERNAL_H_ */</span>
</pre>
<hr />
</body></html>