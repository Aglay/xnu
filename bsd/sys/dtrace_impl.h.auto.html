<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>dtrace_impl.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">dtrace_impl.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or <a href="http://www.opensolaris.org/os/licensing.">http://www.opensolaris.org/os/licensing.</a>
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets &quot;[]&quot; replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */</span>

<span class="enscript-comment">/*
 * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 * Portions Copyright (c) 2012 by Delphix. All rights reserved.
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_SYS_DTRACE_IMPL_H</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_SYS_DTRACE_IMPL_H</span>

<span class="enscript-comment">/* #pragma ident	&quot;@(#)dtrace_impl.h	1.23	07/02/16 SMI&quot; */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">__cplusplus</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * DTrace Dynamic Tracing Software: Kernel Implementation Interfaces
 *
 * Note: The contents of this file are private to the implementation of the
 * Solaris system and DTrace subsystem and are subject to change at any time
 * without notice.  Applications and drivers using these interfaces will fail
 * to run on future releases.  These interfaces should not be used for any
 * purpose except those expressly outlined in dtrace(7D) and libdtrace(3LIB).
 * Please refer to the &quot;Solaris Dynamic Tracing Guide&quot; for more information.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace.h&gt;</span>

<span class="enscript-comment">/*
 * DTrace Implementation Locks
 */</span>
<span class="enscript-type">extern</span> lck_mtx_t dtrace_procwaitfor_lock;

<span class="enscript-comment">/*
 * DTrace Implementation Constants and Typedefs
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MAXPROPLEN</span>		128
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_DYNVAR_CHUNKSIZE</span>		256

<span class="enscript-type">struct</span> dtrace_probe;
<span class="enscript-type">struct</span> dtrace_ecb;
<span class="enscript-type">struct</span> dtrace_predicate;
<span class="enscript-type">struct</span> dtrace_action;
<span class="enscript-type">struct</span> dtrace_provider;
<span class="enscript-type">struct</span> dtrace_state;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_probe dtrace_probe_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_ecb dtrace_ecb_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_predicate dtrace_predicate_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_action dtrace_action_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_provider dtrace_provider_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_meta dtrace_meta_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_state dtrace_state_t;
<span class="enscript-type">typedef</span> uint32_t dtrace_optid_t;
<span class="enscript-type">typedef</span> uint32_t dtrace_specid_t;
<span class="enscript-type">typedef</span> uint64_t dtrace_genid_t;

<span class="enscript-comment">/*
 * DTrace Probes
 *
 * The probe is the fundamental unit of the DTrace architecture.  Probes are
 * created by DTrace providers, and managed by the DTrace framework.  A probe
 * is identified by a unique &lt;provider, module, function, name&gt; tuple, and has
 * a unique probe identifier assigned to it.  (Some probes are not associated
 * with a specific point in text; these are called _unanchored probes_ and have
 * no module or function associated with them.)  Probes are represented as a
 * dtrace_probe structure.  To allow quick lookups based on each element of the
 * probe tuple, probes are hashed by each of provider, module, function and
 * name.  (If a lookup is performed based on a regular expression, a
 * dtrace_probekey is prepared, and a linear search is performed.) Each probe
 * is additionally pointed to by a linear array indexed by its identifier.  The
 * identifier is the provider's mechanism for indicating to the DTrace
 * framework that a probe has fired:  the identifier is passed as the first
 * argument to dtrace_probe(), where it is then mapped into the corresponding
 * dtrace_probe structure.  From the dtrace_probe structure, dtrace_probe() can
 * iterate over the probe's list of enabling control blocks; see &quot;DTrace
 * Enabling Control Blocks&quot;, below.)
 */</span>
<span class="enscript-type">struct</span> dtrace_probe {
	dtrace_id_t dtpr_id;			<span class="enscript-comment">/* probe identifier */</span>
	dtrace_ecb_t *dtpr_ecb;			<span class="enscript-comment">/* ECB list; see below */</span>
	dtrace_ecb_t *dtpr_ecb_last;		<span class="enscript-comment">/* last ECB in list */</span>
	<span class="enscript-type">void</span> *dtpr_arg;				<span class="enscript-comment">/* provider argument */</span>
	dtrace_cacheid_t dtpr_predcache;	<span class="enscript-comment">/* predicate cache ID */</span>
	<span class="enscript-type">int</span> dtpr_aframes;			<span class="enscript-comment">/* artificial frames */</span>
	dtrace_provider_t *dtpr_provider;	<span class="enscript-comment">/* pointer to provider */</span>
	<span class="enscript-type">char</span> *dtpr_mod;				<span class="enscript-comment">/* probe's module name */</span>
	<span class="enscript-type">char</span> *dtpr_func;			<span class="enscript-comment">/* probe's function name */</span>
	<span class="enscript-type">char</span> *dtpr_name;			<span class="enscript-comment">/* probe's name */</span>
	dtrace_probe_t *dtpr_nextmod;		<span class="enscript-comment">/* next in module hash */</span>
	dtrace_probe_t *dtpr_prevmod;		<span class="enscript-comment">/* previous in module hash */</span>
	dtrace_probe_t *dtpr_nextfunc;		<span class="enscript-comment">/* next in function hash */</span>
	dtrace_probe_t *dtpr_prevfunc;		<span class="enscript-comment">/* previous in function hash */</span>
	dtrace_probe_t *dtpr_nextname;		<span class="enscript-comment">/* next in name hash */</span>
	dtrace_probe_t *dtpr_prevname;		<span class="enscript-comment">/* previous in name hash */</span>
	dtrace_genid_t dtpr_gen;		<span class="enscript-comment">/* probe generation ID */</span>
};

<span class="enscript-type">typedef</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_probekey_f</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>);

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_probekey {
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *dtpk_prov;			<span class="enscript-comment">/* provider name to match */</span>
	dtrace_probekey_f *dtpk_pmatch;		<span class="enscript-comment">/* provider matching function */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *dtpk_mod;			<span class="enscript-comment">/* module name to match */</span>
	dtrace_probekey_f *dtpk_mmatch;		<span class="enscript-comment">/* module matching function */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *dtpk_func;			<span class="enscript-comment">/* func name to match */</span>
	dtrace_probekey_f *dtpk_fmatch;		<span class="enscript-comment">/* func matching function */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *dtpk_name;			<span class="enscript-comment">/* name to match */</span>
	dtrace_probekey_f *dtpk_nmatch;		<span class="enscript-comment">/* name matching function */</span>
	dtrace_id_t dtpk_id;			<span class="enscript-comment">/* identifier to match */</span>
} dtrace_probekey_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_hashbucket {
	<span class="enscript-type">struct</span> dtrace_hashbucket *dthb_next;	<span class="enscript-comment">/* next on hash chain */</span>
	dtrace_probe_t *dthb_chain;		<span class="enscript-comment">/* chain of probes */</span>
	<span class="enscript-type">int</span> dthb_len;				<span class="enscript-comment">/* number of probes here */</span>
} dtrace_hashbucket_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_hash {
	dtrace_hashbucket_t **dth_tab;		<span class="enscript-comment">/* hash table */</span>
	<span class="enscript-type">int</span> dth_size;				<span class="enscript-comment">/* size of hash table */</span>
	<span class="enscript-type">int</span> dth_mask;				<span class="enscript-comment">/* mask to index into table */</span>
	<span class="enscript-type">int</span> dth_nbuckets;			<span class="enscript-comment">/* total number of buckets */</span>
	uintptr_t dth_nextoffs;			<span class="enscript-comment">/* offset of next in probe */</span>
	uintptr_t dth_prevoffs;			<span class="enscript-comment">/* offset of prev in probe */</span>
	uintptr_t dth_stroffs;			<span class="enscript-comment">/* offset of str in probe */</span>
} dtrace_hash_t;

<span class="enscript-comment">/*
 * DTrace Enabling Control Blocks
 *
 * When a provider wishes to fire a probe, it calls into dtrace_probe(),
 * passing the probe identifier as the first argument.  As described above,
 * dtrace_probe() maps the identifier into a pointer to a dtrace_probe_t
 * structure.  This structure contains information about the probe, and a
 * pointer to the list of Enabling Control Blocks (ECBs).  Each ECB points to
 * DTrace consumer state, and contains an optional predicate, and a list of
 * actions.  (Shown schematically below.)  The ECB abstraction allows a single
 * probe to be multiplexed across disjoint consumers, or across disjoint
 * enablings of a single probe within one consumer.
 *
 *   Enabling Control Block
 *        dtrace_ecb_t
 * +------------------------+
 * | dtrace_epid_t ---------+--------------&gt; Enabled Probe ID (EPID)
 * | dtrace_state_t * ------+--------------&gt; State associated with this ECB
 * | dtrace_predicate_t * --+---------+
 * | dtrace_action_t * -----+----+    |
 * | dtrace_ecb_t * ---+    |    |    |       Predicate (if any)
 * +-------------------+----+    |    |       dtrace_predicate_t
 *                     |         |    +---&gt; +--------------------+
 *                     |         |          | dtrace_difo_t * ---+----&gt; DIFO
 *                     |         |          +--------------------+
 *                     |         |
 *            Next ECB |         |           Action
 *            (if any) |         |       dtrace_action_t
 *                     :         +--&gt; +-------------------+
 *                     :              | dtrace_actkind_t -+------&gt; kind
 *                     v              | dtrace_difo_t * --+------&gt; DIFO (if any)
 *                                    | dtrace_recdesc_t -+------&gt; record descr.
 *                                    | dtrace_action_t * +------+
 *                                    +-------------------+      |
 *                                                               | Next action
 *                               +-------------------------------+  (if any)
 *                               |
 *                               |           Action
 *                               |       dtrace_action_t
 *                               +--&gt; +-------------------+
 *                                    | dtrace_actkind_t -+------&gt; kind
 *                                    | dtrace_difo_t * --+------&gt; DIFO (if any)
 *                                    | dtrace_action_t * +------+
 *                                    +-------------------+      |
 *                                                               | Next action
 *                               +-------------------------------+  (if any)
 *                               |
 *                               :
 *                               v
 *
 *
 * dtrace_probe() iterates over the ECB list.  If the ECB needs less space
 * than is available in the principal buffer, the ECB is processed:  if the
 * predicate is non-NULL, the DIF object is executed.  If the result is
 * non-zero, the action list is processed, with each action being executed
 * accordingly.  When the action list has been completely executed, processing
 * advances to the next ECB. The ECB abstraction allows disjoint consumers
 * to multiplex on single probes.
 *
 * Execution of the ECB results in consuming dte_size bytes in the buffer
 * to record data.  During execution, dte_needed bytes must be available in
 * the buffer.  This space is used for both recorded data and tuple data.
 */</span>
<span class="enscript-type">struct</span> dtrace_ecb {
	dtrace_epid_t dte_epid;			<span class="enscript-comment">/* enabled probe ID */</span>
	uint32_t dte_alignment;			<span class="enscript-comment">/* required alignment */</span>
	size_t dte_needed;			<span class="enscript-comment">/* space needed for execution */</span>
	size_t dte_size;			<span class="enscript-comment">/* size of recorded payload */</span>
	dtrace_predicate_t *dte_predicate;	<span class="enscript-comment">/* predicate, if any */</span>
	dtrace_action_t *dte_action;		<span class="enscript-comment">/* actions, if any */</span>
	dtrace_ecb_t *dte_next;			<span class="enscript-comment">/* next ECB on probe */</span>
	dtrace_state_t *dte_state;		<span class="enscript-comment">/* pointer to state */</span>
	uint32_t dte_cond;			<span class="enscript-comment">/* security condition */</span>
	dtrace_probe_t *dte_probe;		<span class="enscript-comment">/* pointer to probe */</span>
	dtrace_action_t *dte_action_last;	<span class="enscript-comment">/* last action on ECB */</span>
	uint64_t dte_uarg;			<span class="enscript-comment">/* library argument */</span>
};

<span class="enscript-type">struct</span> dtrace_predicate {
	dtrace_difo_t *dtp_difo;		<span class="enscript-comment">/* DIF object */</span>
	dtrace_cacheid_t dtp_cacheid;		<span class="enscript-comment">/* cache identifier */</span>
	<span class="enscript-type">int</span> dtp_refcnt;				<span class="enscript-comment">/* reference count */</span>
};

<span class="enscript-type">struct</span> dtrace_action {
	dtrace_actkind_t dta_kind;		<span class="enscript-comment">/* kind of action */</span>
	uint16_t dta_intuple;			<span class="enscript-comment">/* boolean:  in aggregation */</span>
	uint32_t dta_refcnt;			<span class="enscript-comment">/* reference count */</span>
	dtrace_difo_t *dta_difo;		<span class="enscript-comment">/* pointer to DIFO */</span>
	dtrace_recdesc_t dta_rec;		<span class="enscript-comment">/* record description */</span>
	dtrace_action_t *dta_prev;		<span class="enscript-comment">/* previous action */</span>
	dtrace_action_t *dta_next;		<span class="enscript-comment">/* next action */</span>
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_aggregation {
	dtrace_action_t dtag_action;		<span class="enscript-comment">/* action; must be first */</span>
	dtrace_aggid_t dtag_id;			<span class="enscript-comment">/* identifier */</span>
	dtrace_ecb_t *dtag_ecb;			<span class="enscript-comment">/* corresponding ECB */</span>
	dtrace_action_t *dtag_first;		<span class="enscript-comment">/* first action in tuple */</span>
	uint32_t dtag_base;			<span class="enscript-comment">/* base of aggregation */</span>
	uint8_t dtag_hasarg;			<span class="enscript-comment">/* boolean:  has argument */</span>
	uint64_t dtag_initial;			<span class="enscript-comment">/* initial value */</span>
	<span class="enscript-type">void</span> (*dtag_aggregate)(uint64_t *, uint64_t, uint64_t);
} dtrace_aggregation_t;

<span class="enscript-comment">/*
 * DTrace Buffers
 *
 * Principal buffers, aggregation buffers, and speculative buffers are all
 * managed with the dtrace_buffer structure.  By default, this structure
 * includes twin data buffers -- dtb_tomax and dtb_xamot -- that serve as the
 * active and passive buffers, respectively.  For speculative buffers,
 * dtb_xamot will be NULL; for &quot;ring&quot; and &quot;fill&quot; buffers, dtb_xamot will point
 * to a scratch buffer.  For all buffer types, the dtrace_buffer structure is
 * always allocated on a per-CPU basis; a single dtrace_buffer structure is
 * never shared among CPUs.  (That is, there is never true sharing of the
 * dtrace_buffer structure; to prevent false sharing of the structure, it must
 * always be aligned to the coherence granularity -- generally 64 bytes.)
 *
 * One of the critical design decisions of DTrace is that a given ECB always
 * stores the same quantity and type of data.  This is done to assure that the
 * only metadata required for an ECB's traced data is the EPID.  That is, from
 * the EPID, the consumer can determine the data layout.  (The data buffer
 * layout is shown schematically below.)  By assuring that one can determine
 * data layout from the EPID, the metadata stream can be separated from the
 * data stream -- simplifying the data stream enormously.  The ECB always
 * proceeds the recorded data as part of the dtrace_rechdr_t structure that
 * includes the EPID and a high-resolution timestamp used for output ordering
 * consistency.
 *
 *      base of data buffer ---&gt;  +--------+--------------------+--------+
 *                                | rechdr | data               | rechdr |
 *                                +--------+------+--------+----+--------+
 *                                | data          | rechdr | data        |
 *                                +---------------+--------+-------------+
 *                                | data, cont.                          |
 *                                +--------+--------------------+--------+
 *                                | rechdr | data               |        |
 *                                +--------+--------------------+        |
 *                                |                ||                    |
 *                                |                ||                    |
 *                                |                \/                    |
 *                                :                                      :
 *                                .                                      .
 *                                .                                      .
 *                                .                                      .
 *                                :                                      :
 *                                |                                      |
 *     limit of data buffer ---&gt;  +--------------------------------------+
 *
 * When evaluating an ECB, dtrace_probe() determines if the ECB's needs of the
 * principal buffer (both scratch and payload) exceed the available space.  If
 * the ECB's needs exceed available space (and if the principal buffer policy
 * is the default &quot;switch&quot; policy), the ECB is dropped, the buffer's drop count
 * is incremented, and processing advances to the next ECB.  If the ECB's needs
 * can be met with the available space, the ECB is processed, but the offset in
 * the principal buffer is only advanced if the ECB completes processing
 * without error.
 *
 * When a buffer is to be switched (either because the buffer is the principal
 * buffer with a &quot;switch&quot; policy or because it is an aggregation buffer), a
 * cross call is issued to the CPU associated with the buffer.  In the cross
 * call context, interrupts are disabled, and the active and the inactive
 * buffers are atomically switched.  This involves switching the data pointers,
 * copying the various state fields (offset, drops, errors, etc.) into their
 * inactive equivalents, and clearing the state fields.  Because interrupts are
 * disabled during this procedure, the switch is guaranteed to appear atomic to
 * dtrace_probe().
 *
 * DTrace Ring Buffering
 *
 * To process a ring buffer correctly, one must know the oldest valid record.
 * Processing starts at the oldest record in the buffer and continues until
 * the end of the buffer is reached.  Processing then resumes starting with
 * the record stored at offset 0 in the buffer, and continues until the
 * youngest record is processed.  If trace records are of a fixed-length,
 * determining the oldest record is trivial:
 *
 *   - If the ring buffer has not wrapped, the oldest record is the record
 *     stored at offset 0.
 *
 *   - If the ring buffer has wrapped, the oldest record is the record stored
 *     at the current offset.
 *
 * With variable length records, however, just knowing the current offset
 * doesn't suffice for determining the oldest valid record:  assuming that one
 * allows for arbitrary data, one has no way of searching forward from the
 * current offset to find the oldest valid record.  (That is, one has no way
 * of separating data from metadata.) It would be possible to simply refuse to
 * process any data in the ring buffer between the current offset and the
 * limit, but this leaves (potentially) an enormous amount of otherwise valid
 * data unprocessed.
 *
 * To effect ring buffering, we track two offsets in the buffer:  the current
 * offset and the _wrapped_ offset.  If a request is made to reserve some
 * amount of data, and the buffer has wrapped, the wrapped offset is
 * incremented until the wrapped offset minus the current offset is greater
 * than or equal to the reserve request.  This is done by repeatedly looking
 * up the ECB corresponding to the EPID at the current wrapped offset, and
 * incrementing the wrapped offset by the size of the data payload
 * corresponding to that ECB.  If this offset is greater than or equal to the
 * limit of the data buffer, the wrapped offset is set to 0.  Thus, the
 * current offset effectively &quot;chases&quot; the wrapped offset around the buffer.
 * Schematically:
 *
 *      base of data buffer ---&gt;  +------+--------------------+------+
 *                                | EPID | data               | EPID |
 *                                +------+--------+------+----+------+
 *                                | data          | EPID | data      |
 *                                +---------------+------+-----------+
 *                                | data, cont.                      |
 *                                +------+---------------------------+
 *                                | EPID | data                      |
 *           current offset ---&gt;  +------+---------------------------+
 *                                | invalid data                     |
 *           wrapped offset ---&gt;  +------+--------------------+------+
 *                                | EPID | data               | EPID |
 *                                +------+--------+------+----+------+
 *                                | data          | EPID | data      |
 *                                +---------------+------+-----------+
 *                                :                                  :
 *                                .                                  .
 *                                .        ... valid data ...        .
 *                                .                                  .
 *                                :                                  :
 *                                +------+-------------+------+------+
 *                                | EPID | data        | EPID | data |
 *                                +------+------------++------+------+
 *                                | data, cont.       | leftover     |
 *     limit of data buffer ---&gt;  +-------------------+--------------+
 *
 * If the amount of requested buffer space exceeds the amount of space
 * available between the current offset and the end of the buffer:
 *
 *  (1)  all words in the data buffer between the current offset and the limit
 *       of the data buffer (marked &quot;leftover&quot;, above) are set to
 *       DTRACE_EPIDNONE
 *
 *  (2)  the wrapped offset is set to zero
 *
 *  (3)  the iteration process described above occurs until the wrapped offset
 *       is greater than the amount of desired space.
 *
 * The wrapped offset is implemented by (re-)using the inactive offset.
 * In a &quot;switch&quot; buffer policy, the inactive offset stores the offset in
 * the inactive buffer; in a &quot;ring&quot; buffer policy, it stores the wrapped
 * offset.
 *
 * DTrace Scratch Buffering
 *
 * Some ECBs may wish to allocate dynamically-sized temporary scratch memory.
 * To accommodate such requests easily, scratch memory may be allocated in
 * the buffer beyond the current offset plus the needed memory of the current
 * ECB.  If there isn't sufficient room in the buffer for the requested amount
 * of scratch space, the allocation fails and an error is generated.  Scratch
 * memory is tracked in the dtrace_mstate_t and is automatically freed when
 * the ECB ceases processing.  Note that ring buffers cannot allocate their
 * scratch from the principal buffer -- lest they needlessly overwrite older,
 * valid data.  Ring buffers therefore have their own dedicated scratch buffer
 * from which scratch is allocated.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEBUF_RING</span>		0x0001		<span class="enscript-comment">/* bufpolicy set to &quot;ring&quot; */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEBUF_FILL</span>		0x0002		<span class="enscript-comment">/* bufpolicy set to &quot;fill&quot; */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEBUF_NOSWITCH</span>	0x0004		<span class="enscript-comment">/* do not switch buffer */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEBUF_WRAPPED</span>	0x0008		<span class="enscript-comment">/* ring buffer has wrapped */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEBUF_DROPPED</span>	0x0010		<span class="enscript-comment">/* drops occurred */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEBUF_ERROR</span>		0x0020		<span class="enscript-comment">/* errors occurred */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEBUF_FULL</span>		0x0040		<span class="enscript-comment">/* &quot;fill&quot; buffer is full */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEBUF_CONSUMED</span>	0x0080		<span class="enscript-comment">/* buffer has been consumed */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEBUF_INACTIVE</span>	0x0100		<span class="enscript-comment">/* buffer is not yet active */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_buffer {
	uint64_t dtb_offset;			<span class="enscript-comment">/* current offset in buffer */</span>
	uint64_t dtb_size;			<span class="enscript-comment">/* size of buffer */</span>
	uint32_t dtb_flags;			<span class="enscript-comment">/* flags */</span>
	uint32_t dtb_drops;			<span class="enscript-comment">/* number of drops */</span>
	caddr_t dtb_tomax;			<span class="enscript-comment">/* active buffer */</span>
	caddr_t dtb_xamot;			<span class="enscript-comment">/* inactive buffer */</span>
	uint32_t dtb_xamot_flags;		<span class="enscript-comment">/* inactive flags */</span>
	uint32_t dtb_xamot_drops;		<span class="enscript-comment">/* drops in inactive buffer */</span>
	uint64_t dtb_xamot_offset;		<span class="enscript-comment">/* offset in inactive buffer */</span>
	uint32_t dtb_errors;			<span class="enscript-comment">/* number of errors */</span>
	uint32_t dtb_xamot_errors;		<span class="enscript-comment">/* errors in inactive buffer */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_LP64</span>
	uint64_t dtb_pad1;
#<span class="enscript-reference">endif</span>
	uint64_t dtb_switched;			<span class="enscript-comment">/* time of last switch */</span>
	uint64_t dtb_interval;			<span class="enscript-comment">/* observed switch interval */</span>
} dtrace_buffer_t;

<span class="enscript-comment">/*
 * DTrace Aggregation Buffers
 *
 * Aggregation buffers use much of the same mechanism as described above
 * (&quot;DTrace Buffers&quot;).  However, because an aggregation is fundamentally a
 * hash, there exists dynamic metadata associated with an aggregation buffer
 * that is not associated with other kinds of buffers.  This aggregation
 * metadata is _only_ relevant for the in-kernel implementation of
 * aggregations; it is not actually relevant to user-level consumers.  To do
 * this, we allocate dynamic aggregation data (hash keys and hash buckets)
 * starting below the _limit_ of the buffer, and we allocate data from the
 * _base_ of the buffer.  When the aggregation buffer is copied out, _only_ the
 * data is copied out; the metadata is simply discarded.  Schematically,
 * aggregation buffers look like:
 *
 *      base of data buffer ---&gt;  +-------+------+-----------+-------+
 *                                | aggid | key  | value     | aggid |
 *                                +-------+------+-----------+-------+
 *                                | key                              |
 *                                +-------+-------+-----+------------+
 *                                | value | aggid | key | value      |
 *                                +-------+------++-----+------+-----+
 *                                | aggid | key  | value       |     |
 *                                +-------+------+-------------+     |
 *                                |                ||                |
 *                                |                ||                |
 *                                |                \/                |
 *                                :                                  :
 *                                .                                  .
 *                                .                                  .
 *                                .                                  .
 *                                :                                  :
 *                                |                /\                |
 *                                |                ||   +------------+
 *                                |                ||   |            |
 *                                +---------------------+            |
 *                                | hash keys                        |
 *                                | (dtrace_aggkey structures)       |
 *                                |                                  |
 *                                +----------------------------------+
 *                                | hash buckets                     |
 *                                | (dtrace_aggbuffer structure)     |
 *                                |                                  |
 *     limit of data buffer ---&gt;  +----------------------------------+
 *
 *
 * As implied above, just as we assure that ECBs always store a constant
 * amount of data, we assure that a given aggregation -- identified by its
 * aggregation ID -- always stores data of a constant quantity and type.
 * As with EPIDs, this allows the aggregation ID to serve as the metadata for a
 * given record.
 *
 * Note that the size of the dtrace_aggkey structure must be sizeof (uintptr_t)
 * aligned.  (If this the structure changes such that this becomes false, an
 * assertion will fail in dtrace_aggregate().)
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_aggkey {
	uint32_t dtak_hashval;			<span class="enscript-comment">/* hash value */</span>
	uint32_t dtak_action:4;			<span class="enscript-comment">/* action -- 4 bits */</span>
	uint32_t dtak_size:28;			<span class="enscript-comment">/* size -- 28 bits */</span>
	caddr_t dtak_data;			<span class="enscript-comment">/* data pointer */</span>
	<span class="enscript-type">struct</span> dtrace_aggkey *dtak_next;	<span class="enscript-comment">/* next in hash chain */</span>
} dtrace_aggkey_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_aggbuffer {
	uintptr_t dtagb_hashsize;		<span class="enscript-comment">/* number of buckets */</span>
	uintptr_t dtagb_free;			<span class="enscript-comment">/* free list of keys */</span>
	dtrace_aggkey_t **dtagb_hash;		<span class="enscript-comment">/* hash table */</span>
} dtrace_aggbuffer_t;

<span class="enscript-comment">/*
 * DTrace Speculations
 *
 * Speculations have a per-CPU buffer and a global state.  Once a speculation
 * buffer has been comitted or discarded, it cannot be reused until all CPUs
 * have taken the same action (commit or discard) on their respective
 * speculative buffer.  However, because DTrace probes may execute in arbitrary
 * context, other CPUs cannot simply be cross-called at probe firing time to
 * perform the necessary commit or discard.  The speculation states thus
 * optimize for the case that a speculative buffer is only active on one CPU at
 * the time of a commit() or discard() -- for if this is the case, other CPUs
 * need not take action, and the speculation is immediately available for
 * reuse.  If the speculation is active on multiple CPUs, it must be
 * asynchronously cleaned -- potentially leading to a higher rate of dirty
 * speculative drops.  The speculation states are as follows:
 *
 *  DTRACESPEC_INACTIVE       &lt;= Initial state; inactive speculation
 *  DTRACESPEC_ACTIVE         &lt;= Allocated, but not yet speculatively traced to
 *  DTRACESPEC_ACTIVEONE      &lt;= Speculatively traced to on one CPU
 *  DTRACESPEC_ACTIVEMANY     &lt;= Speculatively traced to on more than one CPU
 *  DTRACESPEC_COMMITTING     &lt;= Currently being commited on one CPU
 *  DTRACESPEC_COMMITTINGMANY &lt;= Currently being commited on many CPUs
 *  DTRACESPEC_DISCARDING     &lt;= Currently being discarded on many CPUs
 *
 * The state transition diagram is as follows:
 *
 *     +----------------------------------------------------------+
 *     |                                                          |
 *     |                      +------------+                      |
 *     |  +-------------------| COMMITTING |&lt;-----------------+   |
 *     |  |                   +------------+                  |   |
 *     |  | copied spec.            ^             commit() on |   | discard() on
 *     |  | into principal          |              active CPU |   | active CPU
 *     |  |                         | commit()                |   |
 *     V  V                         |                         |   |
 * +----------+                 +--------+                +-----------+
 * | INACTIVE |----------------&gt;| ACTIVE |---------------&gt;| ACTIVEONE |
 * +----------+  speculation()  +--------+  speculate()   +-----------+
 *     ^  ^                         |                         |   |
 *     |  |                         | discard()               |   |
 *     |  | asynchronously          |            discard() on |   | speculate()
 *     |  | cleaned                 V            inactive CPU |   | on inactive
 *     |  |                   +------------+                  |   | CPU
 *     |  +-------------------| DISCARDING |&lt;-----------------+   |
 *     |                      +------------+                      |
 *     | asynchronously             ^                             |
 *     | copied spec.               |       discard()             |
 *     | into principal             +------------------------+    |
 *     |                                                     |    V
 *  +----------------+             commit()              +------------+
 *  | COMMITTINGMANY |&lt;----------------------------------| ACTIVEMANY |
 *  +----------------+                                   +------------+
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> dtrace_speculation_state {
	DTRACESPEC_INACTIVE = 0,
	DTRACESPEC_ACTIVE,
	DTRACESPEC_ACTIVEONE,
	DTRACESPEC_ACTIVEMANY,
	DTRACESPEC_COMMITTING,
	DTRACESPEC_COMMITTINGMANY,
	DTRACESPEC_DISCARDING
} dtrace_speculation_state_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_speculation {
	dtrace_speculation_state_t dtsp_state;	<span class="enscript-comment">/* current speculation state */</span>
	<span class="enscript-type">int</span> dtsp_cleaning;			<span class="enscript-comment">/* non-zero if being cleaned */</span>
	dtrace_buffer_t *dtsp_buffer;		<span class="enscript-comment">/* speculative buffer */</span>
} dtrace_speculation_t;

<span class="enscript-comment">/*
 * DTrace Dynamic Variables
 *
 * The dynamic variable problem is obviously decomposed into two subproblems:
 * allocating new dynamic storage, and freeing old dynamic storage.  The
 * presence of the second problem makes the first much more complicated -- or
 * rather, the absence of the second renders the first trivial.  This is the
 * case with aggregations, for which there is effectively no deallocation of
 * dynamic storage.  (Or more accurately, all dynamic storage is deallocated
 * when a snapshot is taken of the aggregation.)  As DTrace dynamic variables
 * allow for both dynamic allocation and dynamic deallocation, the
 * implementation of dynamic variables is quite a bit more complicated than
 * that of their aggregation kin.
 *
 * We observe that allocating new dynamic storage is tricky only because the
 * size can vary -- the allocation problem is much easier if allocation sizes
 * are uniform.  We further observe that in D, the size of dynamic variables is
 * actually _not_ dynamic -- dynamic variable sizes may be determined by static
 * analysis of DIF text.  (This is true even of putatively dynamically-sized
 * objects like strings and stacks, the sizes of which are dictated by the
 * &quot;stringsize&quot; and &quot;stackframes&quot; variables, respectively.)  We exploit this by
 * performing this analysis on all DIF before enabling any probes.  For each
 * dynamic load or store, we calculate the dynamically-allocated size plus the
 * size of the dtrace_dynvar structure plus the storage required to key the
 * data.  For all DIF, we take the largest value and dub it the _chunksize_.
 * We then divide dynamic memory into two parts:  a hash table that is wide
 * enough to have every chunk in its own bucket, and a larger region of equal
 * chunksize units.  Whenever we wish to dynamically allocate a variable, we
 * always allocate a single chunk of memory.  Depending on the uniformity of
 * allocation, this will waste some amount of memory -- but it eliminates the
 * non-determinism inherent in traditional heap fragmentation.
 *
 * Dynamic objects are allocated by storing a non-zero value to them; they are
 * deallocated by storing a zero value to them.  Dynamic variables are
 * complicated enormously by being shared between CPUs.  In particular,
 * consider the following scenario:
 *
 *                 CPU A                                 CPU B
 *  +---------------------------------+   +---------------------------------+
 *  |                                 |   |                                 |
 *  | allocates dynamic object a[123] |   |                                 |
 *  | by storing the value 345 to it  |   |                                 |
 *  |                               ---------&gt;                              |
 *  |                                 |   | wishing to load from object     |
 *  |                                 |   | a[123], performs lookup in      |
 *  |                                 |   | dynamic variable space          |
 *  |                               &lt;---------                              |
 *  | deallocates object a[123] by    |   |                                 |
 *  | storing 0 to it                 |   |                                 |
 *  |                                 |   |                                 |
 *  | allocates dynamic object b[567] |   | performs load from a[123]       |
 *  | by storing the value 789 to it  |   |                                 |
 *  :                                 :   :                                 :
 *  .                                 .   .                                 .
 *
 * This is obviously a race in the D program, but there are nonetheless only
 * two valid values for CPU B's load from a[123]:  345 or 0.  Most importantly,
 * CPU B may _not_ see the value 789 for a[123].
 *
 * There are essentially two ways to deal with this:
 *
 *  (1)  Explicitly spin-lock variables.  That is, if CPU B wishes to load
 *       from a[123], it needs to lock a[123] and hold the lock for the
 *       duration that it wishes to manipulate it.
 *
 *  (2)  Avoid reusing freed chunks until it is known that no CPU is referring
 *       to them.
 *
 * The implementation of (1) is rife with complexity, because it requires the
 * user of a dynamic variable to explicitly decree when they are done using it.
 * Were all variables by value, this perhaps wouldn't be debilitating -- but
 * dynamic variables of non-scalar types are tracked by reference.  That is, if
 * a dynamic variable is, say, a string, and that variable is to be traced to,
 * say, the principal buffer, the DIF emulation code returns to the main
 * dtrace_probe() loop a pointer to the underlying storage, not the contents of
 * the storage.  Further, code calling on DIF emulation would have to be aware
 * that the DIF emulation has returned a reference to a dynamic variable that
 * has been potentially locked.  The variable would have to be unlocked after
 * the main dtrace_probe() loop is finished with the variable, and the main
 * dtrace_probe() loop would have to be careful to not call any further DIF
 * emulation while the variable is locked to avoid deadlock.  More generally,
 * if one were to implement (1), DIF emulation code dealing with dynamic
 * variables could only deal with one dynamic variable at a time (lest deadlock
 * result).  To sum, (1) exports too much subtlety to the users of dynamic
 * variables -- increasing maintenance burden and imposing serious constraints
 * on future DTrace development.
 *
 * The implementation of (2) is also complex, but the complexity is more
 * manageable.  We need to be sure that when a variable is deallocated, it is
 * not placed on a traditional free list, but rather on a _dirty_ list.  Once a
 * variable is on a dirty list, it cannot be found by CPUs performing a
 * subsequent lookup of the variable -- but it may still be in use by other
 * CPUs.  To assure that all CPUs that may be seeing the old variable have
 * cleared out of probe context, a dtrace_sync() can be issued.  Once the
 * dtrace_sync() has completed, it can be known that all CPUs are done
 * manipulating the dynamic variable -- the dirty list can be atomically
 * appended to the free list.  Unfortunately, there's a slight hiccup in this
 * mechanism:  dtrace_sync() may not be issued from probe context.  The
 * dtrace_sync() must be therefore issued asynchronously from non-probe
 * context.  For this we rely on the DTrace cleaner, a cyclic that runs at the
 * &quot;cleanrate&quot; frequency.  To ease this implementation, we define several chunk
 * lists:
 *
 *   - Dirty.  Deallocated chunks, not yet cleaned.  Not available.
 *
 *   - Rinsing.  Formerly dirty chunks that are currently being asynchronously
 *     cleaned.  Not available, but will be shortly.  Dynamic variable
 *     allocation may not spin or block for availability, however.
 *
 *   - Clean.  Clean chunks, ready for allocation -- but not on the free list.
 *
 *   - Free.  Available for allocation.
 *
 * Moreover, to avoid absurd contention, _each_ of these lists is implemented
 * on a per-CPU basis.  This is only for performance, not correctness; chunks
 * may be allocated from another CPU's free list.  The algorithm for allocation
 * then is this:
 *
 *   (1)  Attempt to atomically allocate from current CPU's free list.  If list
 *        is non-empty and allocation is successful, allocation is complete.
 *
 *   (2)  If the clean list is non-empty, atomically move it to the free list,
 *        and reattempt (1).
 *
 *   (3)  If the dynamic variable space is in the CLEAN state, look for free
 *        and clean lists on other CPUs by setting the current CPU to the next
 *        CPU, and reattempting (1).  If the next CPU is the current CPU (that
 *        is, if all CPUs have been checked), atomically switch the state of
 *        the dynamic variable space based on the following:
 *
 *        - If no free chunks were found and no dirty chunks were found,
 *          atomically set the state to EMPTY.
 *
 *        - If dirty chunks were found, atomically set the state to DIRTY.
 *
 *        - If rinsing chunks were found, atomically set the state to RINSING.
 *
 *   (4)  Based on state of dynamic variable space state, increment appropriate
 *        counter to indicate dynamic drops (if in EMPTY state) vs. dynamic
 *        dirty drops (if in DIRTY state) vs. dynamic rinsing drops (if in
 *        RINSING state).  Fail the allocation.
 *
 * The cleaning cyclic operates with the following algorithm:  for all CPUs
 * with a non-empty dirty list, atomically move the dirty list to the rinsing
 * list.  Perform a dtrace_sync().  For all CPUs with a non-empty rinsing list,
 * atomically move the rinsing list to the clean list.  Perform another
 * dtrace_sync().  By this point, all CPUs have seen the new clean list; the
 * state of the dynamic variable space can be restored to CLEAN.
 *
 * There exist two final races that merit explanation.  The first is a simple
 * allocation race:
 *
 *                 CPU A                                 CPU B
 *  +---------------------------------+   +---------------------------------+
 *  |                                 |   |                                 |
 *  | allocates dynamic object a[123] |   | allocates dynamic object a[123] |
 *  | by storing the value 345 to it  |   | by storing the value 567 to it  |
 *  |                                 |   |                                 |
 *  :                                 :   :                                 :
 *  .                                 .   .                                 .
 *
 * Again, this is a race in the D program.  It can be resolved by having a[123]
 * hold the value 345 or a[123] hold the value 567 -- but it must be true that
 * a[123] have only _one_ of these values.  (That is, the racing CPUs may not
 * put the same element twice on the same hash chain.)  This is resolved
 * simply:  before the allocation is undertaken, the start of the new chunk's
 * hash chain is noted.  Later, after the allocation is complete, the hash
 * chain is atomically switched to point to the new element.  If this fails
 * (because of either concurrent allocations or an allocation concurrent with a
 * deletion), the newly allocated chunk is deallocated to the dirty list, and
 * the whole process of looking up (and potentially allocating) the dynamic
 * variable is reattempted.
 *
 * The final race is a simple deallocation race:
 *
 *                 CPU A                                 CPU B
 *  +---------------------------------+   +---------------------------------+
 *  |                                 |   |                                 |
 *  | deallocates dynamic object      |   | deallocates dynamic object      |
 *  | a[123] by storing the value 0   |   | a[123] by storing the value 0   |
 *  | to it                           |   | to it                           |
 *  |                                 |   |                                 |
 *  :                                 :   :                                 :
 *  .                                 .   .                                 .
 *
 * Once again, this is a race in the D program, but it is one that we must
 * handle without corrupting the underlying data structures.  Because
 * deallocations require the deletion of a chunk from the middle of a hash
 * chain, we cannot use a single-word atomic operation to remove it.  For this,
 * we add a spin lock to the hash buckets that is _only_ used for deallocations
 * (allocation races are handled as above).  Further, this spin lock is _only_
 * held for the duration of the delete; before control is returned to the DIF
 * emulation code, the hash bucket is unlocked.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_key {
	uint64_t dttk_value;			<span class="enscript-comment">/* data value or data pointer */</span>
	uint64_t dttk_size;			<span class="enscript-comment">/* 0 if by-val, &gt;0 if by-ref */</span>
} dtrace_key_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_tuple {
	uint32_t dtt_nkeys;			<span class="enscript-comment">/* number of keys in tuple */</span>
	uint32_t dtt_pad;			<span class="enscript-comment">/* padding */</span>
	dtrace_key_t dtt_key[1];		<span class="enscript-comment">/* array of tuple keys */</span>
} dtrace_tuple_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_dynvar {
	uint64_t dtdv_hashval;			<span class="enscript-comment">/* hash value -- 0 if free */</span>
	<span class="enscript-type">struct</span> dtrace_dynvar *dtdv_next;	<span class="enscript-comment">/* next on list or hash chain */</span>
	<span class="enscript-type">void</span> *dtdv_data;			<span class="enscript-comment">/* pointer to data */</span>
	dtrace_tuple_t dtdv_tuple;		<span class="enscript-comment">/* tuple key */</span>
} dtrace_dynvar_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> dtrace_dynvar_op {
	DTRACE_DYNVAR_ALLOC,
	DTRACE_DYNVAR_NOALLOC,
	DTRACE_DYNVAR_DEALLOC
} dtrace_dynvar_op_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_dynhash {
	dtrace_dynvar_t *dtdh_chain;		<span class="enscript-comment">/* hash chain for this bucket */</span>
	uintptr_t dtdh_lock;			<span class="enscript-comment">/* deallocation lock */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LP64</span>
	uintptr_t dtdh_pad[6];			<span class="enscript-comment">/* pad to avoid false sharing */</span>
#<span class="enscript-reference">else</span>
	uintptr_t dtdh_pad[14];			<span class="enscript-comment">/* pad to avoid false sharing */</span>
#<span class="enscript-reference">endif</span>
} dtrace_dynhash_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_dstate_percpu {
	dtrace_dynvar_t *dtdsc_free;		<span class="enscript-comment">/* free list for this CPU */</span>
	dtrace_dynvar_t *dtdsc_dirty;		<span class="enscript-comment">/* dirty list for this CPU */</span>
	dtrace_dynvar_t *dtdsc_rinsing;		<span class="enscript-comment">/* rinsing list for this CPU */</span>
	dtrace_dynvar_t *dtdsc_clean;		<span class="enscript-comment">/* clean list for this CPU */</span>
	uint64_t dtdsc_drops;			<span class="enscript-comment">/* number of capacity drops */</span>
	uint64_t dtdsc_dirty_drops;		<span class="enscript-comment">/* number of dirty drops */</span>
	uint64_t dtdsc_rinsing_drops;		<span class="enscript-comment">/* number of rinsing drops */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LP64</span>
	uint64_t dtdsc_pad;			<span class="enscript-comment">/* pad to avoid false sharing */</span>
#<span class="enscript-reference">else</span>
	uint64_t dtdsc_pad[2];			<span class="enscript-comment">/* pad to avoid false sharing */</span>
#<span class="enscript-reference">endif</span>
} dtrace_dstate_percpu_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> dtrace_dstate_state {
	DTRACE_DSTATE_CLEAN = 0,
	DTRACE_DSTATE_EMPTY,
	DTRACE_DSTATE_DIRTY,
	DTRACE_DSTATE_RINSING
} dtrace_dstate_state_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_dstate {
	<span class="enscript-type">void</span> *dtds_base;			<span class="enscript-comment">/* base of dynamic var. space */</span>
	size_t dtds_size;			<span class="enscript-comment">/* size of dynamic var. space */</span>
	size_t dtds_hashsize;			<span class="enscript-comment">/* number of buckets in hash */</span>
	size_t dtds_chunksize;			<span class="enscript-comment">/* size of each chunk */</span>
	dtrace_dynhash_t *dtds_hash;		<span class="enscript-comment">/* pointer to hash table */</span>
	dtrace_dstate_state_t dtds_state;	<span class="enscript-comment">/* current dynamic var. state */</span>
	dtrace_dstate_percpu_t *dtds_percpu;	<span class="enscript-comment">/* per-CPU dyn. var. state */</span>
} dtrace_dstate_t;

<span class="enscript-comment">/*
 * DTrace Variable State
 *
 * The DTrace variable state tracks user-defined variables in its dtrace_vstate
 * structure.  Each DTrace consumer has exactly one dtrace_vstate structure,
 * but some dtrace_vstate structures may exist without a corresponding DTrace
 * consumer (see &quot;DTrace Helpers&quot;, below).  As described in &lt;sys/dtrace.h&gt;,
 * user-defined variables can have one of three scopes:
 *
 *  DIFV_SCOPE_GLOBAL  =&gt;  global scope
 *  DIFV_SCOPE_THREAD  =&gt;  thread-local scope (i.e. &quot;self-&gt;&quot; variables)
 *  DIFV_SCOPE_LOCAL   =&gt;  clause-local scope (i.e. &quot;this-&gt;&quot; variables)
 *
 * The variable state tracks variables by both their scope and their allocation
 * type:
 *
 *  - The dtvs_globals and dtvs_locals members each point to an array of
 *    dtrace_statvar structures.  These structures contain both the variable
 *    metadata (dtrace_difv structures) and the underlying storage for all
 *    statically allocated variables, including statically allocated
 *    DIFV_SCOPE_GLOBAL variables and all DIFV_SCOPE_LOCAL variables.
 *
 *  - The dtvs_tlocals member points to an array of dtrace_difv structures for
 *    DIFV_SCOPE_THREAD variables.  As such, this array tracks _only_ the
 *    variable metadata for DIFV_SCOPE_THREAD variables; the underlying storage
 *    is allocated out of the dynamic variable space.
 *
 *  - The dtvs_dynvars member is the dynamic variable state associated with the
 *    variable state.  The dynamic variable state (described in &quot;DTrace Dynamic
 *    Variables&quot;, above) tracks all DIFV_SCOPE_THREAD variables and all
 *    dynamically-allocated DIFV_SCOPE_GLOBAL variables.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_statvar {
	uint64_t dtsv_data;			<span class="enscript-comment">/* data or pointer to it */</span>
	size_t dtsv_size;			<span class="enscript-comment">/* size of pointed-to data */</span>
	<span class="enscript-type">int</span> dtsv_refcnt;			<span class="enscript-comment">/* reference count */</span>
	dtrace_difv_t dtsv_var;			<span class="enscript-comment">/* variable metadata */</span>
} dtrace_statvar_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_vstate {
	dtrace_state_t *dtvs_state;		<span class="enscript-comment">/* back pointer to state */</span>
	dtrace_statvar_t **dtvs_globals;	<span class="enscript-comment">/* statically-allocated glbls */</span>
	<span class="enscript-type">int</span> dtvs_nglobals;			<span class="enscript-comment">/* number of globals */</span>
	dtrace_difv_t *dtvs_tlocals;		<span class="enscript-comment">/* thread-local metadata */</span>
	<span class="enscript-type">int</span> dtvs_ntlocals;			<span class="enscript-comment">/* number of thread-locals */</span>
	dtrace_statvar_t **dtvs_locals;		<span class="enscript-comment">/* clause-local data */</span>
	<span class="enscript-type">int</span> dtvs_nlocals;			<span class="enscript-comment">/* number of clause-locals */</span>
	dtrace_dstate_t dtvs_dynvars;		<span class="enscript-comment">/* dynamic variable state */</span>
} dtrace_vstate_t;

<span class="enscript-comment">/*
 * DTrace Machine State
 *
 * In the process of processing a fired probe, DTrace needs to track and/or
 * cache some per-CPU state associated with that particular firing.  This is
 * state that is always discarded after the probe firing has completed, and
 * much of it is not specific to any DTrace consumer, remaining valid across
 * all ECBs.  This state is tracked in the dtrace_mstate structure.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MSTATE_ARGS</span>		0x00000001
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MSTATE_PROBE</span>		0x00000002
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MSTATE_EPID</span>		0x00000004
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MSTATE_TIMESTAMP</span>		0x00000008
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MSTATE_STACKDEPTH</span>	0x00000010
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MSTATE_CALLER</span>		0x00000020
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MSTATE_IPL</span>		0x00000040
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MSTATE_FLTOFFS</span>		0x00000080
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MSTATE_WALLTIMESTAMP</span>	0x00000100
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MSTATE_USTACKDEPTH</span>	0x00000200
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MSTATE_UCALLER</span>		0x00000400
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MSTATE_MACHTIMESTAMP</span>	0x00000800

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_mstate {
	uintptr_t dtms_scratch_base;		<span class="enscript-comment">/* base of scratch space */</span>
	uintptr_t dtms_scratch_ptr;		<span class="enscript-comment">/* current scratch pointer */</span>
	size_t dtms_scratch_size;		<span class="enscript-comment">/* scratch size */</span>
	uint32_t dtms_present;			<span class="enscript-comment">/* variables that are present */</span>
	uint64_t dtms_arg[5];			<span class="enscript-comment">/* cached arguments */</span>
	dtrace_epid_t dtms_epid;		<span class="enscript-comment">/* current EPID */</span>
	uint64_t dtms_timestamp;		<span class="enscript-comment">/* cached timestamp */</span>
	hrtime_t dtms_walltimestamp;		<span class="enscript-comment">/* cached wall timestamp */</span>
	uint64_t dtms_machtimestamp;		<span class="enscript-comment">/* cached mach absolute timestamp */</span>
	<span class="enscript-type">int</span> dtms_stackdepth;			<span class="enscript-comment">/* cached stackdepth */</span>
	<span class="enscript-type">int</span> dtms_ustackdepth;			<span class="enscript-comment">/* cached ustackdepth */</span>
	<span class="enscript-type">struct</span> dtrace_probe *dtms_probe;	<span class="enscript-comment">/* current probe */</span>
	uintptr_t dtms_caller;			<span class="enscript-comment">/* cached caller */</span>
	uint64_t dtms_ucaller;			<span class="enscript-comment">/* cached user-level caller */</span>
	<span class="enscript-type">int</span> dtms_ipl;				<span class="enscript-comment">/* cached interrupt pri lev */</span>
	<span class="enscript-type">int</span> dtms_fltoffs;			<span class="enscript-comment">/* faulting DIFO offset */</span>
	uintptr_t dtms_strtok;			<span class="enscript-comment">/* saved strtok() pointer */</span>
	uint32_t dtms_access;			<span class="enscript-comment">/* memory access rights */</span>
	dtrace_difo_t *dtms_difo;		<span class="enscript-comment">/* current dif object */</span>
} dtrace_mstate_t;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_COND_OWNER</span>	0x1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_COND_USERMODE</span>	0x2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_COND_ZONEOWNER</span>	0x4

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_PROBEKEY_MAXDEPTH</span>	8	<span class="enscript-comment">/* max glob recursion depth */</span>

<span class="enscript-comment">/*
 * Access flag used by dtrace_mstate.dtms_access.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_ACCESS_KERNEL</span>	0x1		<span class="enscript-comment">/* the priv to read kmem */</span>


<span class="enscript-comment">/*
 * DTrace Activity
 *
 * Each DTrace consumer is in one of several states, which (for purposes of
 * avoiding yet-another overloading of the noun &quot;state&quot;) we call the current
 * _activity_.  The activity transitions on dtrace_go() (from DTRACIOCGO), on
 * dtrace_stop() (from DTRACIOCSTOP) and on the exit() action.  Activities may
 * only transition in one direction; the activity transition diagram is a
 * directed acyclic graph.  The activity transition diagram is as follows:
 *
 *
 * +----------+                   +--------+                   +--------+
 * | INACTIVE |------------------&gt;| WARMUP |------------------&gt;| ACTIVE |
 * +----------+   dtrace_go(),    +--------+   dtrace_go(),    +--------+
 *                before BEGIN        |        after BEGIN       |  |  |
 *                                    |                          |  |  |
 *                      exit() action |                          |  |  |
 *                     from BEGIN ECB |                          |  |  |
 *                                    |                          |  |  |
 *                                    v                          |  |  |
 *                               +----------+     exit() action  |  |  |
 * +-----------------------------| DRAINING |&lt;-------------------+  |  |
 * |                             +----------+                       |  |
 * |                                  |                             |  |
 * |                   dtrace_stop(), |                             |  |
 * |                     before END   |                             |  |
 * |                                  |                             |  |
 * |                                  v                             |  |
 * | +---------+                 +----------+                       |  |
 * | | STOPPED |&lt;----------------| COOLDOWN |&lt;----------------------+  |
 * | +---------+  dtrace_stop(), +----------+     dtrace_stop(),       |
 * |                after END                       before END         |
 * |                                                                   |
 * |                              +--------+                           |
 * +-----------------------------&gt;| KILLED |&lt;--------------------------+
 *       deadman timeout or       +--------+     deadman timeout or
 *        killed consumer                         killed consumer
 *
 * Note that once a DTrace consumer has stopped tracing, there is no way to
 * restart it; if a DTrace consumer wishes to restart tracing, it must reopen
 * the DTrace pseudodevice.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> dtrace_activity {
	DTRACE_ACTIVITY_INACTIVE = 0,		<span class="enscript-comment">/* not yet running */</span>
	DTRACE_ACTIVITY_WARMUP,			<span class="enscript-comment">/* while starting */</span>
	DTRACE_ACTIVITY_ACTIVE,			<span class="enscript-comment">/* running */</span>
	DTRACE_ACTIVITY_DRAINING,		<span class="enscript-comment">/* before stopping */</span>
	DTRACE_ACTIVITY_COOLDOWN,		<span class="enscript-comment">/* while stopping */</span>
	DTRACE_ACTIVITY_STOPPED,		<span class="enscript-comment">/* after stopping */</span>
	DTRACE_ACTIVITY_KILLED			<span class="enscript-comment">/* killed */</span>
} dtrace_activity_t;


<span class="enscript-comment">/*
 * APPLE NOTE:  DTrace dof modes implementation
 *
 * DTrace has four &quot;dof modes&quot;. They are:
 *
 * DTRACE_DOF_MODE_NEVER	Never load any dof, period.
 * DTRACE_DOF_MODE_LAZY_ON	Defer loading dof until later
 * DTRACE_DOF_MODE_LAZY_OFF	Load all deferred dof now, and any new dof 
 * DTRACE_DOF_MODE_NON_LAZY	Load all dof immediately.
 *
 * It is legal to transition between the two lazy modes. The NEVER and
 * NON_LAZY modes are permanent, and must not change once set.
 *
 * The current dof mode is kept in dtrace_dof_mode, which is protected by the
 * dtrace_dof_mode_lock. This is a RW lock, reads require shared access, writes
 * require exclusive access. Because NEVER and NON_LAZY are permanent states,
 * it is legal to test for those modes without holding the dof mode lock.
 *
 * Lock ordering is dof mode lock before any dtrace lock, and before the
 * process p_dtrace_sprlock. In general, other locks should not be held when
 * taking the dof mode lock. Acquiring the dof mode lock in exclusive mode
 * will block process fork, exec, and exit, so it should be held exclusive
 * for as short a time as possible.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_DOF_MODE_NEVER</span> 		0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_DOF_MODE_LAZY_ON</span>		1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_DOF_MODE_LAZY_OFF</span>	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_DOF_MODE_NON_LAZY</span>	3

<span class="enscript-comment">/*
 * dtrace kernel symbol modes are used to control when the kernel may dispose of
 * symbol information used by the fbt/sdt provider. The kernel itself, as well as
 * every kext, has symbol table/nlist info that has historically been preserved
 * for dtrace's use. This allowed dtrace to be lazy about allocating fbt/sdt probes,
 * at the expense of keeping the symbol info in the kernel permanently.
 *
 * Starting in 10.7+, fbt probes may be created from userspace, in the same
 * fashion as pid probes. The kernel allows dtrace &quot;first right of refusal&quot;
 * whenever symbol data becomes available (such as a kext load). If dtrace is
 * active, it will immediately read/copy the needed data, and then the kernel
 * may free it. If dtrace is not active, it returns immediately, having done
 * no work or allocations, and the symbol data is freed. Should dtrace need
 * this data later, it is expected that the userspace client will push the
 * data into the kernel via ioctl calls.
 *
 * The kernel symbol modes are used to control what dtrace does with symbol data:
 *
 * DTRACE_KERNEL_SYMBOLS_NEVER			Effectively disables fbt/sdt
 * DTRACE_KERNEL_SYMBOLS_FROM_KERNEL		Immediately read/copy symbol data
 * DTRACE_KERNEL_SYMBOLS_FROM_USERSPACE		Wait for symbols from userspace
 * DTRACE_KERNEL_SYMBOLS_ALWAYS_FROM_KERNEL	Immediately read/copy symbol data
 *
 * It is legal to transition between DTRACE_KERNEL_SYMBOLS_FROM_KERNEL and 
 * DTRACE_KERNEL_SYMBOLS_FROM_USERSPACE. The DTRACE_KERNEL_SYMBOLS_NEVER and
 * DTRACE_KERNEL_SYMBOLS_ALWAYS_FROM_KERNEL are permanent modes, intended to
 * disable fbt probes entirely, or prevent any symbols being loaded from
 * userspace.
*
 * The kernel symbol mode is kept in dtrace_kernel_symbol_mode, which is protected
 * by the dtrace_lock.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_KERNEL_SYMBOLS_NEVER</span> 			0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_KERNEL_SYMBOLS_FROM_KERNEL</span>		1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_KERNEL_SYMBOLS_FROM_USERSPACE</span>		2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_KERNEL_SYMBOLS_ALWAYS_FROM_KERNEL</span>	3
	

<span class="enscript-comment">/*
 * DTrace Helper Implementation
 *
 * A description of the helper architecture may be found in &lt;sys/dtrace.h&gt;.
 * Each process contains a pointer to its helpers in its p_dtrace_helpers
 * member.  This is a pointer to a dtrace_helpers structure, which contains an
 * array of pointers to dtrace_helper structures, helper variable state (shared
 * among a process's helpers) and a generation count.  (The generation count is
 * used to provide an identifier when a helper is added so that it may be
 * subsequently removed.)  The dtrace_helper structure is self-explanatory,
 * containing pointers to the objects needed to execute the helper.  Note that
 * helpers are _duplicated_ across fork(2), and destroyed on exec(2).  No more
 * than dtrace_helpers_max are allowed per-process.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_HELPER_ACTION_USTACK</span>	0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_NHELPER_ACTIONS</span>		1

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_helper_action {
	<span class="enscript-type">int</span> dtha_generation;			<span class="enscript-comment">/* helper action generation */</span>
	<span class="enscript-type">int</span> dtha_nactions;			<span class="enscript-comment">/* number of actions */</span>
	dtrace_difo_t *dtha_predicate;		<span class="enscript-comment">/* helper action predicate */</span>
	dtrace_difo_t **dtha_actions;		<span class="enscript-comment">/* array of actions */</span>
	<span class="enscript-type">struct</span> dtrace_helper_action *dtha_next;	<span class="enscript-comment">/* next helper action */</span>
} dtrace_helper_action_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_helper_provider {
	<span class="enscript-type">int</span> dthp_generation;			<span class="enscript-comment">/* helper provider generation */</span>
	uint32_t dthp_ref;			<span class="enscript-comment">/* reference count */</span>
	dof_helper_t dthp_prov;			<span class="enscript-comment">/* DOF w/ provider and probes */</span>
} dtrace_helper_provider_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_helpers {
	dtrace_helper_action_t **dthps_actions;	<span class="enscript-comment">/* array of helper actions */</span>
	dtrace_vstate_t dthps_vstate;		<span class="enscript-comment">/* helper action var. state */</span>
	dtrace_helper_provider_t **dthps_provs;	<span class="enscript-comment">/* array of providers */</span>
	uint_t dthps_nprovs;			<span class="enscript-comment">/* count of providers */</span>
	uint_t dthps_maxprovs;			<span class="enscript-comment">/* provider array size */</span>
	<span class="enscript-type">int</span> dthps_generation;			<span class="enscript-comment">/* current generation */</span>
	pid_t dthps_pid;			<span class="enscript-comment">/* pid of associated proc */</span>
	<span class="enscript-type">int</span> dthps_deferred;			<span class="enscript-comment">/* helper in deferred list */</span>
	<span class="enscript-type">struct</span> dtrace_helpers *dthps_next;	<span class="enscript-comment">/* next pointer */</span>
	<span class="enscript-type">struct</span> dtrace_helpers *dthps_prev;	<span class="enscript-comment">/* prev pointer */</span>
} dtrace_helpers_t;

<span class="enscript-comment">/*
 * DTrace Helper Action Tracing
 *
 * Debugging helper actions can be arduous.  To ease the development and
 * debugging of helpers, DTrace contains a tracing-framework-within-a-tracing-
 * framework: helper tracing.  If dtrace_helptrace_enabled is non-zero (which
 * it is by default on DEBUG kernels), all helper activity will be traced to a
 * global, in-kernel ring buffer.  Each entry includes a pointer to the specific
 * helper, the location within the helper, and a trace of all local variables.
 * The ring buffer may be displayed in a human-readable format with the
 * ::dtrace_helptrace mdb(1) dcmd.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_HELPTRACE_NEXT</span>	(-1)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_HELPTRACE_DONE</span>	(-2)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_HELPTRACE_ERR</span>	(-3)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_helptrace {
	dtrace_helper_action_t	*dtht_helper;	<span class="enscript-comment">/* helper action */</span>
	<span class="enscript-type">int</span> dtht_where;				<span class="enscript-comment">/* where in helper action */</span>
	<span class="enscript-type">int</span> dtht_nlocals;			<span class="enscript-comment">/* number of locals */</span>
	<span class="enscript-type">int</span> dtht_fault;				<span class="enscript-comment">/* type of fault (if any) */</span>
	<span class="enscript-type">int</span> dtht_fltoffs;			<span class="enscript-comment">/* DIF offset */</span>
	uint64_t dtht_illval;			<span class="enscript-comment">/* faulting value */</span>
	uint64_t dtht_locals[1];		<span class="enscript-comment">/* local variables */</span>
} dtrace_helptrace_t;

<span class="enscript-comment">/*
 * DTrace Credentials
 *
 * In probe context, we have limited flexibility to examine the credentials
 * of the DTrace consumer that created a particular enabling.  We use
 * the Least Privilege interfaces to cache the consumer's cred pointer and
 * some facts about that credential in a dtrace_cred_t structure. These
 * can limit the consumer's breadth of visibility and what actions the
 * consumer may take.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CRV_ALLPROC</span>		0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CRV_KERNEL</span>		0x02
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CRV_ALLZONE</span>		0x04

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CRV_ALL</span>		(DTRACE_CRV_ALLPROC | DTRACE_CRV_KERNEL | \
	DTRACE_CRV_ALLZONE)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CRA_PROC</span>				0x0001
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CRA_PROC_CONTROL</span>			0x0002
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER</span>	0x0004
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CRA_PROC_DESTRUCTIVE_ALLZONE</span>	0x0008
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG</span>	0x0010
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CRA_KERNEL</span>			0x0020
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CRA_KERNEL_DESTRUCTIVE</span>		0x0040

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CRA_ALL</span>		(DTRACE_CRA_PROC | \
	DTRACE_CRA_PROC_CONTROL | \
	DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER | \
	DTRACE_CRA_PROC_DESTRUCTIVE_ALLZONE | \
	DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG | \
	DTRACE_CRA_KERNEL | \
	DTRACE_CRA_KERNEL_DESTRUCTIVE)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_cred {
	cred_t			*dcr_cred;
	uint8_t			dcr_destructive;
	uint8_t			dcr_visible;
	uint16_t		dcr_action;
} dtrace_cred_t;

<span class="enscript-comment">/*
 * DTrace Consumer State
 *
 * Each DTrace consumer has an associated dtrace_state structure that contains
 * its in-kernel DTrace state -- including options, credentials, statistics and
 * pointers to ECBs, buffers, speculations and formats.  A dtrace_state
 * structure is also allocated for anonymous enablings.  When anonymous state
 * is grabbed, the grabbing consumers dts_anon pointer is set to the grabbed
 * dtrace_state structure.
 */</span>
<span class="enscript-type">struct</span> dtrace_state {
	dev_t dts_dev;				<span class="enscript-comment">/* device */</span>
	<span class="enscript-type">int</span> dts_necbs;				<span class="enscript-comment">/* total number of ECBs */</span>
	dtrace_ecb_t **dts_ecbs;		<span class="enscript-comment">/* array of ECBs */</span>
	dtrace_epid_t dts_epid;			<span class="enscript-comment">/* next EPID to allocate */</span>
	size_t dts_needed;			<span class="enscript-comment">/* greatest needed space */</span>
	<span class="enscript-type">struct</span> dtrace_state *dts_anon;		<span class="enscript-comment">/* anon. state, if grabbed */</span>
	dtrace_activity_t dts_activity;		<span class="enscript-comment">/* current activity */</span>
	dtrace_vstate_t dts_vstate;		<span class="enscript-comment">/* variable state */</span>
	dtrace_buffer_t *dts_buffer;		<span class="enscript-comment">/* principal buffer */</span>
	dtrace_buffer_t *dts_aggbuffer;		<span class="enscript-comment">/* aggregation buffer */</span>
	dtrace_speculation_t *dts_speculations;	<span class="enscript-comment">/* speculation array */</span>
	<span class="enscript-type">int</span> dts_nspeculations;			<span class="enscript-comment">/* number of speculations */</span>
	<span class="enscript-type">int</span> dts_naggregations;			<span class="enscript-comment">/* number of aggregations */</span>
	dtrace_aggregation_t **dts_aggregations; <span class="enscript-comment">/* aggregation array */</span>
	vmem_t *dts_aggid_arena;		<span class="enscript-comment">/* arena for aggregation IDs */</span>
	uint64_t dts_errors;			<span class="enscript-comment">/* total number of errors */</span>
	uint32_t dts_speculations_busy;		<span class="enscript-comment">/* number of spec. busy */</span>
	uint32_t dts_speculations_unavail;	<span class="enscript-comment">/* number of spec unavail */</span>
	uint32_t dts_stkstroverflows;		<span class="enscript-comment">/* stack string tab overflows */</span>
	uint32_t dts_dblerrors;			<span class="enscript-comment">/* errors in ERROR probes */</span>
	uint32_t dts_reserve;			<span class="enscript-comment">/* space reserved for END */</span>
	hrtime_t dts_laststatus;		<span class="enscript-comment">/* time of last status */</span>
	cyclic_id_t dts_cleaner;		<span class="enscript-comment">/* cleaning cyclic */</span>
	cyclic_id_t dts_deadman;		<span class="enscript-comment">/* deadman cyclic */</span>
	hrtime_t dts_alive;			<span class="enscript-comment">/* time last alive */</span>
	<span class="enscript-type">char</span> dts_speculates;			<span class="enscript-comment">/* boolean: has speculations */</span>
	<span class="enscript-type">char</span> dts_destructive;			<span class="enscript-comment">/* boolean: has dest. actions */</span>
	<span class="enscript-type">int</span> dts_nformats;			<span class="enscript-comment">/* number of formats */</span>
	<span class="enscript-type">char</span> **dts_formats;			<span class="enscript-comment">/* format string array */</span>
	dtrace_optval_t dts_options[DTRACEOPT_MAX]; <span class="enscript-comment">/* options */</span>
	dtrace_cred_t dts_cred;			<span class="enscript-comment">/* credentials */</span>
	size_t dts_nretained;			<span class="enscript-comment">/* number of retained enabs */</span>
	uint64_t dts_arg_error_illval;
};

<span class="enscript-type">struct</span> dtrace_provider {
	dtrace_pattr_t dtpv_attr;		<span class="enscript-comment">/* provider attributes */</span>
	dtrace_ppriv_t dtpv_priv;		<span class="enscript-comment">/* provider privileges */</span>
	dtrace_pops_t dtpv_pops;		<span class="enscript-comment">/* provider operations */</span>
	<span class="enscript-type">char</span> *dtpv_name;			<span class="enscript-comment">/* provider name */</span>
	<span class="enscript-type">void</span> *dtpv_arg;				<span class="enscript-comment">/* provider argument */</span>
	uint_t dtpv_defunct;			<span class="enscript-comment">/* boolean: defunct provider */</span>
	<span class="enscript-type">struct</span> dtrace_provider *dtpv_next;	<span class="enscript-comment">/* next provider */</span>
	uint64_t dtpv_probe_count;		<span class="enscript-comment">/* number of associated probes */</span>
	uint64_t dtpv_ecb_count;		<span class="enscript-comment">/* number of associated enabled ECBs */</span>
};

<span class="enscript-type">struct</span> dtrace_meta {
	dtrace_mops_t dtm_mops;			<span class="enscript-comment">/* meta provider operations */</span>
	<span class="enscript-type">char</span> *dtm_name;				<span class="enscript-comment">/* meta provider name */</span>
	<span class="enscript-type">void</span> *dtm_arg;				<span class="enscript-comment">/* meta provider user arg */</span>
	uint64_t dtm_count;			<span class="enscript-comment">/* number of associated providers */</span>
};

<span class="enscript-comment">/*
 * DTrace Enablings
 *
 * A dtrace_enabling structure is used to track a collection of ECB
 * descriptions -- before they have been turned into actual ECBs.  This is
 * created as a result of DOF processing, and is generally used to generate
 * ECBs immediately thereafter.  However, enablings are also generally
 * retained should the probes they describe be created at a later time; as
 * each new module or provider registers with the framework, the retained
 * enablings are reevaluated, with any new match resulting in new ECBs.  To
 * prevent probes from being matched more than once, the enabling tracks the
 * last probe generation matched, and only matches probes from subsequent
 * generations.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_enabling {
	dtrace_ecbdesc_t **dten_desc;		<span class="enscript-comment">/* all ECB descriptions */</span>
	<span class="enscript-type">int</span> dten_ndesc;				<span class="enscript-comment">/* number of ECB descriptions */</span>
	<span class="enscript-type">int</span> dten_maxdesc;			<span class="enscript-comment">/* size of ECB array */</span>
	dtrace_vstate_t *dten_vstate;		<span class="enscript-comment">/* associated variable state */</span>
	dtrace_genid_t dten_probegen;		<span class="enscript-comment">/* matched probe generation */</span>
	dtrace_ecbdesc_t *dten_current;		<span class="enscript-comment">/* current ECB description */</span>
	<span class="enscript-type">int</span> dten_error;				<span class="enscript-comment">/* current error value */</span>
	<span class="enscript-type">int</span> dten_primed;			<span class="enscript-comment">/* boolean: set if primed */</span>
	<span class="enscript-type">struct</span> dtrace_enabling *dten_prev;	<span class="enscript-comment">/* previous enabling */</span>
	<span class="enscript-type">struct</span> dtrace_enabling *dten_next;	<span class="enscript-comment">/* next enabling */</span>
} dtrace_enabling_t;

<span class="enscript-comment">/*
 * DTrace Anonymous Enablings
 *
 * Anonymous enablings are DTrace enablings that are not associated with a
 * controlling process, but rather derive their enabling from DOF stored as
 * properties in the dtrace.conf file.  If there is an anonymous enabling, a
 * DTrace consumer state and enabling are created on attach.  The state may be
 * subsequently grabbed by the first consumer specifying the &quot;grabanon&quot;
 * option.  As long as an anonymous DTrace enabling exists, dtrace(7D) will
 * refuse to unload.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_anon {
	dtrace_state_t *dta_state;		<span class="enscript-comment">/* DTrace consumer state */</span>
	dtrace_enabling_t *dta_enabling;	<span class="enscript-comment">/* pointer to enabling */</span>
	processorid_t dta_beganon;		<span class="enscript-comment">/* which CPU BEGIN ran on */</span>
} dtrace_anon_t;

<span class="enscript-comment">/*
 * DTrace Error Debugging
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_ERRDEBUG</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DTRACE_ERRDEBUG</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_errhash {
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*dter_msg;	<span class="enscript-comment">/* error message */</span>
	<span class="enscript-type">int</span>		dter_count;	<span class="enscript-comment">/* number of times seen */</span>
} dtrace_errhash_t;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_ERRHASHSZ</span>	256	<span class="enscript-comment">/* must be &gt; number of err msgs */</span>

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* DTRACE_ERRDEBUG */</span>

<span class="enscript-comment">/*
 * DTrace Toxic Ranges
 *
 * DTrace supports safe loads from probe context; if the address turns out to
 * be invalid, a bit will be set by the kernel indicating that DTrace
 * encountered a memory error, and DTrace will propagate the error to the user
 * accordingly.  However, there may exist some regions of memory in which an
 * arbitrary load can change system state, and from which it is impossible to
 * recover from such a load after it has been attempted.  Examples of this may
 * include memory in which programmable I/O registers are mapped (for which a
 * read may have some implications for the device) or (in the specific case of
 * UltraSPARC-I and -II) the virtual address hole.  The platform is required
 * to make DTrace aware of these toxic ranges; DTrace will then check that
 * target addresses are not in a toxic range before attempting to issue a
 * safe load.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_toxrange {
	uintptr_t	dtt_base;		<span class="enscript-comment">/* base of toxic range */</span>
	uintptr_t	dtt_limit;		<span class="enscript-comment">/* limit of toxic range */</span>
} dtrace_toxrange_t;

<span class="enscript-type">extern</span> uint64_t <span class="enscript-function-name">dtrace_getarg</span>(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_getipl</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> uintptr_t <span class="enscript-function-name">dtrace_caller</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">dtrace_cas32</span>(uint32_t *, uint32_t, uint32_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *<span class="enscript-function-name">dtrace_casptr</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_copyin</span>(user_addr_t, uintptr_t, size_t, <span class="enscript-type">volatile</span> uint16_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_copyinstr</span>(user_addr_t, uintptr_t, size_t, <span class="enscript-type">volatile</span> uint16_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_copyout</span>(uintptr_t, user_addr_t, size_t, <span class="enscript-type">volatile</span> uint16_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_copyoutstr</span>(uintptr_t, user_addr_t, size_t, <span class="enscript-type">volatile</span> uint16_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_getpcstack</span>(pc_t *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, uint32_t *);
<span class="enscript-type">extern</span> uint64_t <span class="enscript-function-name">dtrace_getreg</span>(<span class="enscript-type">struct</span> regs *, uint_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_getstackdepth</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_getupcstack</span>(uint64_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_getufpstack</span>(uint64_t *, uint64_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_getustackdepth</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> uintptr_t <span class="enscript-function-name">dtrace_fulword</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> uint8_t <span class="enscript-function-name">dtrace_fuword8</span>(user_addr_t);
<span class="enscript-type">extern</span> uint16_t <span class="enscript-function-name">dtrace_fuword16</span>(user_addr_t);
<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">dtrace_fuword32</span>(user_addr_t);
<span class="enscript-type">extern</span> uint64_t <span class="enscript-function-name">dtrace_fuword64</span>(user_addr_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_proc_waitfor</span>(dtrace_procdesc_t*);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_probe_error</span>(dtrace_state_t *, dtrace_epid_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>,
    <span class="enscript-type">int</span>, uint64_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_assfail</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_attached</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> hrtime_t <span class="enscript-function-name">dtrace_gethrestime</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_isa_init</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_copy</span>(uintptr_t, uintptr_t, size_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_copystr</span>(uintptr_t, uintptr_t, size_t, <span class="enscript-type">volatile</span> uint16_t *);

<span class="enscript-comment">/*
 * DTrace restriction checks
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_restriction_policy_load</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">dtrace_is_restricted</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">dtrace_is_running_apple_internal</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">dtrace_fbt_probes_restricted</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">dtrace_can_attach_to_proc</span>(proc_t);

<span class="enscript-comment">/*
 * DTrace Assertions
 *
 * DTrace calls ASSERT from probe context.  To assure that a failed ASSERT
 * does not induce a markedly more catastrophic failure (e.g., one from which
 * a dump cannot be gleaned), DTrace must define its own ASSERT to be one that
 * may safely be called from probe context.  This header file must thus be
 * included by any DTrace component that calls ASSERT from probe context, and
 * _only_ by those components.  (The only exception to this is kernel
 * debugging infrastructure at user-level that doesn't depend on calling
 * ASSERT.)
 */</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ASSERT</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ASSERT</span>(EX)	((void)((EX) || \
			dtrace_assfail(#EX, __FILE__, __LINE__)))
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ASSERT</span>(X)	((void)0)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">__cplusplus</span>
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _SYS_DTRACE_IMPL_H */</span>

</pre>
<hr />
</body></html>