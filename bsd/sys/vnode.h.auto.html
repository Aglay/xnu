<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vnode.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vnode.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)vnode.h	8.17 (Berkeley) 5/20/95
 */</span>
 
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_VNODE_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_VNODE_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signal.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * The vnode is the focus of all file activity in UNIX.  There is a
 * unique vnode allocated for each active file, each current directory,
 * each mounted-on file, text file, and the root.
 */</span>

<span class="enscript-comment">/*
 * Vnode types.  VNON means no type.
 */</span>
<span class="enscript-type">enum</span> vtype	{ 
	<span class="enscript-comment">/* 0 */</span>
	VNON, 
	<span class="enscript-comment">/* 1 - 5 */</span>
	VREG, VDIR, VBLK, VCHR, VLNK, 
	<span class="enscript-comment">/* 6 - 10 */</span>
	VSOCK, VFIFO, VBAD, VSTR, VCPLX 
};

<span class="enscript-comment">/*
 * Vnode tag types.
 * These are for the benefit of external programs only (e.g., pstat)
 * and should NEVER be inspected by the kernel.
 */</span>
<span class="enscript-type">enum</span> vtagtype	{
	<span class="enscript-comment">/* 0 */</span>
	VT_NON,
	<span class="enscript-comment">/* 1 reserved, overlaps with (CTL_VFS, VFS_NUMMNTOPS) */</span>
	VT_UFS,
	<span class="enscript-comment">/* 2 - 5 */</span>
	VT_NFS, VT_MFS, VT_MSDOSFS, VT_LFS,
	<span class="enscript-comment">/* 6 - 10 */</span>
	VT_LOFS, VT_FDESC, VT_PORTAL, VT_NULL, VT_UMAP, 
	<span class="enscript-comment">/* 11 - 15 */</span>
	VT_KERNFS, VT_PROCFS, VT_AFS, VT_ISOFS, VT_MOCKFS,
	<span class="enscript-comment">/* 16 - 20 */</span>
	VT_HFS, VT_ZFS, VT_DEVFS, VT_WEBDAV, VT_UDF, 
	<span class="enscript-comment">/* 21 - 24 */</span>
	VT_AFP, VT_CDDA, VT_CIFS, VT_OTHER
};


<span class="enscript-comment">/*
 * flags for VNOP_BLOCKMAP
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_READ</span>	0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_WRITE</span>	0x02



<span class="enscript-comment">/* flags for VNOP_ALLOCATE */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PREALLOCATE</span>		0x00000001	<span class="enscript-comment">/* preallocate allocation blocks */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ALLOCATECONTIG</span>	0x00000002	<span class="enscript-comment">/* allocate contigious space */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ALLOCATEALL</span>		0x00000004	<span class="enscript-comment">/* allocate all requested space */</span>
									<span class="enscript-comment">/* or no space at all */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FREEREMAINDER</span>	0x00000008	<span class="enscript-comment">/* deallocate allocated but */</span>
									<span class="enscript-comment">/* unfilled blocks */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ALLOCATEFROMPEOF</span>	0x00000010	<span class="enscript-comment">/* allocate from the physical eof */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ALLOCATEFROMVOL</span>		0x00000020	<span class="enscript-comment">/* allocate from the volume offset */</span>

<span class="enscript-comment">/*
 * Token indicating no attribute value yet assigned. some user source uses this
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNOVAL</span>	(-1)


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>

<span class="enscript-comment">/*
 * Flags for ioflag.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_UNIT</span>		0x0001		<span class="enscript-comment">/* do I/O as atomic unit */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_APPEND</span>	0x0002		<span class="enscript-comment">/* append write to end */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_SYNC</span>		0x0004		<span class="enscript-comment">/* do I/O synchronously */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_NODELOCKED</span>	0x0008		<span class="enscript-comment">/* underlying node already locked */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_NDELAY</span>	0x0010		<span class="enscript-comment">/* FNDELAY flag set in file table */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_NOZEROFILL</span>	0x0020		<span class="enscript-comment">/* F_SETSIZE fcntl uses to prevent zero filling */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_REVOKE</span>	IO_NOZEROFILL	<span class="enscript-comment">/* revoked close for tty, will Not be used in conjunction */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_TAILZEROFILL</span>	0x0040		<span class="enscript-comment">/* zero fills at the tail of write */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_HEADZEROFILL</span>	0x0080		<span class="enscript-comment">/* zero fills at the head of write */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_NOZEROVALID</span>	0x0100		<span class="enscript-comment">/* do not zero fill if valid page */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_NOZERODIRTY</span>	0x0200		<span class="enscript-comment">/* do not zero fill if page is dirty */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_CLOSE</span>	0x0400		<span class="enscript-comment">/* I/O issued from close path */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_NOCACHE</span>	0x0800		<span class="enscript-comment">/* same effect as VNOCACHE_DATA, but only for this 1 I/O */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_RAOFF</span>	0x1000		<span class="enscript-comment">/* same effect as VRAOFF, but only for this 1 I/O */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_DEFWRITE</span>	0x2000		<span class="enscript-comment">/* defer write if vfs.defwrite is set */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_PASSIVE</span>	0x4000		<span class="enscript-comment">/* this I/O is marked as background I/O so it won't throttle Throttleable I/O */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_BACKGROUND</span> IO_PASSIVE <span class="enscript-comment">/* used for backward compatibility.  to be removed after IO_BACKGROUND is no longer
								  * used by DiskImages in-kernel mode */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_NOAUTH</span>	0x8000		<span class="enscript-comment">/* No authorization checks. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_NODIRECT</span>     0x10000		<span class="enscript-comment">/* don't use direct synchronous writes if IO_NOCACHE is specified */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_ENCRYPTED</span>	0x20000		<span class="enscript-comment">/* Retrieve encrypted blocks from the filesystem */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_RETURN_ON_THROTTLE</span>	0x40000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_SINGLE_WRITER</span>	0x80000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_SYSCALL_DISPATCH</span>		0x100000	<span class="enscript-comment">/* I/O was originated from a file table syscall */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_SWAP_DISPATCH</span>		0x200000	<span class="enscript-comment">/* I/O was originated from the swap layer */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_SKIP_ENCRYPTION</span>		0x400000	<span class="enscript-comment">/* Skips en(de)cryption on the IO. Must be initiated from kernel */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_EVTONLY</span>                      0x800000        <span class="enscript-comment">/* the i/o is being done on an fd that's marked O_EVTONLY */</span>

<span class="enscript-comment">/*
 * Component Name: this structure describes the pathname
 * information that is passed through the VNOP interface.
 */</span>
<span class="enscript-type">struct</span> componentname {
	<span class="enscript-comment">/*
	 * Arguments to lookup.
	 */</span>
	uint32_t	cn_nameiop;	<span class="enscript-comment">/* lookup operation */</span>
	uint32_t	cn_flags;	<span class="enscript-comment">/* flags (see below) */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
	vfs_context_t	cn_context;
	<span class="enscript-type">struct</span> nameidata *cn_ndp;	<span class="enscript-comment">/* pointer back to nameidata */</span>

<span class="enscript-comment">/* XXX use of these defines are deprecated */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">cn_proc</span>		(cn_context-&gt;vc_proc + 0)	<span class="enscript-comment">/* non-lvalue */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">cn_cred</span>		(cn_context-&gt;vc_ucred + 0)	<span class="enscript-comment">/* non-lvalue */</span>

#<span class="enscript-reference">else</span>
	<span class="enscript-type">void</span> * cn_reserved1;	<span class="enscript-comment">/* use vfs_context_t */</span>
	<span class="enscript-type">void</span> * cn_reserved2;	<span class="enscript-comment">/* use vfs_context_t */</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Shared between lookup and commit routines.
	 */</span>
	<span class="enscript-type">char</span>	*cn_pnbuf;	<span class="enscript-comment">/* pathname buffer */</span>
	<span class="enscript-type">int</span>	cn_pnlen;	<span class="enscript-comment">/* length of allocated buffer */</span>
	<span class="enscript-type">char</span>	*cn_nameptr;	<span class="enscript-comment">/* pointer to looked up name */</span>
	<span class="enscript-type">int</span>	cn_namelen;	<span class="enscript-comment">/* length of looked up component */</span>
	uint32_t	cn_hash;	<span class="enscript-comment">/* hash value of looked up name */</span>
	uint32_t	cn_consume;	<span class="enscript-comment">/* chars to consume in lookup() */</span>
};

<span class="enscript-comment">/*
 * component name operations (for VNOP_LOOKUP)
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LOOKUP</span>		0	<span class="enscript-comment">/* perform name lookup only */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CREATE</span>		1	<span class="enscript-comment">/* setup for file creation */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DELETE</span>		2	<span class="enscript-comment">/* setup for file deletion */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RENAME</span>		3	<span class="enscript-comment">/* setup for file renaming */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">OPMASK</span>		3	<span class="enscript-comment">/* mask for operation */</span>

<span class="enscript-comment">/*
 * component name operational modifier flags
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FOLLOW</span>		0x00000040 <span class="enscript-comment">/* follow symbolic links */</span>

<span class="enscript-comment">/*
 * component name parameter descriptors.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ISDOTDOT</span>	0x00002000 <span class="enscript-comment">/* current component name is .. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAKEENTRY</span>	0x00004000 <span class="enscript-comment">/* entry is to be added to name cache */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ISLASTCN</span>	0x00008000 <span class="enscript-comment">/* this is last component of pathname */</span>

<span class="enscript-comment">/* The following structure specifies a vnode for creation */</span>
<span class="enscript-type">struct</span> vnode_fsparam {
	<span class="enscript-type">struct</span> mount * vnfs_mp;		<span class="enscript-comment">/* mount point to which this vnode_t is part of */</span>
	<span class="enscript-type">enum</span> vtype	vnfs_vtype;		<span class="enscript-comment">/* vnode type */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> * vnfs_str;		<span class="enscript-comment">/* File system Debug aid */</span>
	<span class="enscript-type">struct</span> vnode * vnfs_dvp;			<span class="enscript-comment">/* The parent vnode */</span>
	<span class="enscript-type">void</span> * vnfs_fsnode;			<span class="enscript-comment">/* inode */</span>
	<span class="enscript-type">int</span> (**vnfs_vops)(<span class="enscript-type">void</span> *);		<span class="enscript-comment">/* vnode dispatch table */</span>
	<span class="enscript-type">int</span> vnfs_markroot;			<span class="enscript-comment">/* is this a root vnode in FS (not a system wide one) */</span>
	<span class="enscript-type">int</span> vnfs_marksystem;		<span class="enscript-comment">/* is  a system vnode */</span>
	dev_t vnfs_rdev;			<span class="enscript-comment">/* dev_t  for block or char vnodes */</span>
	off_t vnfs_filesize;		<span class="enscript-comment">/* that way no need for getattr in UBC */</span>
	<span class="enscript-type">struct</span> componentname * vnfs_cnp; <span class="enscript-comment">/* component name to add to namecache */</span>
	uint32_t vnfs_flags;		<span class="enscript-comment">/* flags */</span>
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNFS_NOCACHE</span>	0x01	<span class="enscript-comment">/* do not add to name cache at this time */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNFS_CANTCACHE</span>	0x02	<span class="enscript-comment">/* never add this instance to the name cache */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNFS_ADDFSREF</span>	0x04	<span class="enscript-comment">/* take fs (named) reference */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNCREATE_FLAVOR</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VCREATESIZE</span> sizeof(struct vnode_fsparam)
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
<span class="enscript-comment">/*
 * For use with SPI to create trigger vnodes.
 */</span>
<span class="enscript-type">struct</span> vnode_trigger_param;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNCREATE_TRIGGER</span>	((<span class="enscript-string">'T'</span> &lt;&lt; 8) + (<span class="enscript-string">'V'</span>))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNCREATE_TRIGGER_SIZE</span>	sizeof(struct vnode_trigger_param)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
<span class="enscript-comment">/*
 * Resolver callback SPI for trigger vnodes
 *
 * Only available from kernels built with CONFIG_TRIGGERS option
 */</span>

<span class="enscript-comment">/*!
 @enum Pathname Lookup Operations
 @abstract Constants defining pathname operations (passed to resolver callbacks)
 */</span>
<span class="enscript-type">enum</span> path_operation	{
	OP_LOOKUP,
	OP_MOUNT,
	OP_UNMOUNT,
	OP_STATFS,
	OP_OPEN,
	OP_LINK,
	OP_UNLINK,
	OP_RENAME,
	OP_CHDIR,
	OP_CHROOT,
	OP_MKNOD,
	OP_MKFIFO,
	OP_SYMLINK,
	OP_ACCESS,
	OP_PATHCONF,
	OP_READLINK,
	OP_GETATTR,
	OP_SETATTR,
	OP_TRUNCATE,
	OP_COPYFILE,
	OP_MKDIR,
	OP_RMDIR,
	OP_REVOKE,
	OP_EXCHANGEDATA,
	OP_SEARCHFS,
	OP_FSCTL,
	OP_GETXATTR,
	OP_SETXATTR,
	OP_REMOVEXATTR,
	OP_LISTXATTR,
	OP_MAXOP	<span class="enscript-comment">/* anything beyond previous entry is invalid */</span>
};

<span class="enscript-comment">/*!
 @enum resolver status
 @abstract Constants defining resolver status
 @constant RESOLVER_RESOLVED  the resolver has finished (typically means a successful mount)
 @constant RESOLVER_NOCHANGE  the resolver status didn't change
 @constant RESOLVER_UNRESOLVED  the resolver has finished (typically means a successful unmount)
 @constant RESOLVER_ERROR  the resolver encountered an error (errno passed in aux value)
 @constant RESOLVER_STOP  a request to destroy trigger XXX do we need this???
 */</span>
<span class="enscript-type">enum</span> resolver_status {
	RESOLVER_RESOLVED,
	RESOLVER_NOCHANGE,
	RESOLVER_UNRESOLVED,
	RESOLVER_ERROR,
	RESOLVER_STOP
};

<span class="enscript-type">typedef</span> uint64_t resolver_result_t;

<span class="enscript-comment">/*
 * Compound resolver result
 *
 * The trigger vnode callbacks use a compound result value. In addition
 * to the resolver status, it contains a sequence number and an auxiliary
 * value.
 *
 * The sequence value is used by VFS to sequence-stamp trigger vnode
 * state transitions. It is expected to be incremented each time a
 * resolver changes state (ie resolved or unresolved). A result
 * containing a stale sequence (older than a trigger vnode's current
 * value) will be ignored by VFS.
 *
 * The auxiliary value is currently only used to deliver the errno
 * value for RESOLVER_ERROR status conditions. When a RESOLVER_ERROR
 * occurs, VFS will propagate this error back to the syscall that
 * encountered the trigger vnode.
 */</span>
<span class="enscript-type">extern</span> resolver_result_t <span class="enscript-function-name">vfs_resolver_result</span>(uint32_t seq, <span class="enscript-type">enum</span> resolver_status stat, <span class="enscript-type">int</span> aux);

<span class="enscript-comment">/*
 * Extract values from a compound resolver result
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">enum</span> resolver_status <span class="enscript-function-name">vfs_resolver_status</span>(resolver_result_t);
<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">vfs_resolver_sequence</span>(resolver_result_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vfs_resolver_auxiliary</span>(resolver_result_t);


<span class="enscript-comment">/*!
 @typedef trigger_vnode_resolve_callback_t
 @abstract function prototype for a trigger vnode resolve callback
 @discussion This function is associated with a trigger vnode during a vnode create.  It is
 typically called when a lookup operation occurs for a trigger vnode
 @param vp The trigger vnode which needs resolving
 @param cnp Various data about lookup, e.g. filename and state flags
 @param pop The pathname operation that initiated the lookup (see enum path_operation).
 @param flags
 @param data Arbitrary data supplied by vnode trigger creator
 @param ctx Context for authentication.
 @return RESOLVER_RESOLVED, RESOLVER_NOCHANGE, RESOLVER_UNRESOLVED or RESOLVER_ERROR
*/</span>
<span class="enscript-type">typedef</span> <span class="enscript-function-name">resolver_result_t</span> (* trigger_vnode_resolve_callback_t)(
	vnode_t				vp,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> componentname *	cnp,
	<span class="enscript-type">enum</span> path_operation		pop,
	<span class="enscript-type">int</span>				flags,
	<span class="enscript-type">void</span> *				data,
	vfs_context_t			ctx);

<span class="enscript-comment">/*!
 @typedef trigger_vnode_unresolve_callback_t
 @abstract function prototype for a trigger vnode unresolve callback
 @discussion This function is associated with a trigger vnode during a vnode create.  It is
 called to unresolve a trigger vnode (typically this means unmount).
 @param vp The trigger vnode which needs unresolving
 @param flags Unmount flags
 @param data Arbitrary data supplied by vnode trigger creator
 @param ctx Context for authentication.
 @return RESOLVER_NOCHANGE, RESOLVER_UNRESOLVED or RESOLVER_ERROR
*/</span>
<span class="enscript-type">typedef</span> <span class="enscript-function-name">resolver_result_t</span> (* trigger_vnode_unresolve_callback_t)(
	vnode_t		vp,
	<span class="enscript-type">int</span>		flags,
	<span class="enscript-type">void</span> *		data,
	vfs_context_t	ctx);

<span class="enscript-comment">/*!
 @typedef trigger_vnode_rearm_callback_t
 @abstract function prototype for a trigger vnode rearm callback
 @discussion This function is associated with a trigger vnode during a vnode create.  It is
 called to verify a rearm from VFS (i.e. should VFS rearm the trigger?).
 @param vp The trigger vnode which needs rearming
 @param flags
 @param data Arbitrary data supplied by vnode trigger creator
 @param ctx Context for authentication.
 @return RESOLVER_NOCHANGE or RESOLVER_ERROR
*/</span>
<span class="enscript-type">typedef</span> <span class="enscript-function-name">resolver_result_t</span> (* trigger_vnode_rearm_callback_t)(
	vnode_t		vp,
	<span class="enscript-type">int</span>		flags,
	<span class="enscript-type">void</span> *		data,
	vfs_context_t	ctx);

<span class="enscript-comment">/*!
 @typedef trigger_vnode_reclaim_callback_t
 @abstract function prototype for a trigger vnode reclaim callback
 @discussion This function is associated with a trigger vnode during a vnode create.  It is
 called to deallocate private callback argument data
 @param vp The trigger vnode associated with the data
 @param data The arbitrary data supplied by vnode trigger creator
*/</span>
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (* trigger_vnode_reclaim_callback_t)(
	vnode_t		vp,
	<span class="enscript-type">void</span> *		data);

<span class="enscript-comment">/*!
 @function vnode_trigger_update
 @abstract Update a trigger vnode's state.
 @discussion This allows a resolver to notify VFS of a state change in a trigger vnode.
 @param vp The trigger vnode whose information to update.
 @param result A compound resolver result value
 @return EINVAL if result value is invalid or vp isn't a trigger vnode
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vnode_trigger_update</span>(vnode_t vp, resolver_result_t result);

<span class="enscript-type">struct</span> vnode_trigger_info {
	trigger_vnode_resolve_callback_t	vti_resolve_func;
	trigger_vnode_unresolve_callback_t	vti_unresolve_func;
	trigger_vnode_rearm_callback_t		vti_rearm_func;
	trigger_vnode_reclaim_callback_t	vti_reclaim_func;
	<span class="enscript-type">void</span> *					vti_data;   <span class="enscript-comment">/* auxiliary data (optional) */</span>
	uint32_t				vti_flags;  <span class="enscript-comment">/* optional flags (see below) */</span>
};

<span class="enscript-comment">/*
 * SPI for creating a trigger vnode
 *
 * Uses the VNCREATE_TRIGGER flavor with existing vnode_create() KPI
 *
 * Only one resolver per vnode.
 *
 * ERRORS (in addition to vnode_create errors):
 *	EINVAL (invalid resolver info, like invalid flags)
 *	ENOTDIR (only directories can have a resolver)
 *	EPERM (vnode cannot be a trigger - eg root dir of a file system)
 *	ENOMEM
 */</span>
<span class="enscript-type">struct</span> vnode_trigger_param {
	<span class="enscript-type">struct</span> vnode_fsparam			vnt_params; <span class="enscript-comment">/* same as for VNCREATE_FLAVOR */</span>
	trigger_vnode_resolve_callback_t	vnt_resolve_func;
	trigger_vnode_unresolve_callback_t	vnt_unresolve_func;
	trigger_vnode_rearm_callback_t		vnt_rearm_func;
	trigger_vnode_reclaim_callback_t	vnt_reclaim_func;
	<span class="enscript-type">void</span> *					vnt_data;   <span class="enscript-comment">/* auxiliary data (optional) */</span>
	uint32_t				vnt_flags;  <span class="enscript-comment">/* optional flags (see below) */</span>
};

<span class="enscript-comment">/*
 * vnode trigger flags (vnt_flags)
 *
 * VNT_AUTO_REARM:
 * On unmounts of a trigger mount, automatically re-arm the trigger.
 *
 * VNT_NO_DIRECT_MOUNT:
 * A trigger vnode instance that doesn't directly trigger a mount,
 * instead it triggers the mounting of sub-trigger nodes.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNT_AUTO_REARM</span>    	(1 &lt;&lt; 0)	
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNT_NO_DIRECT_MOUNT</span>	(1 &lt;&lt; 1)	
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNT_VALID_MASK</span>    	(VNT_AUTO_REARM | VNT_NO_DIRECT_MOUNT)

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>


<span class="enscript-comment">/*
 * Vnode attributes, new-style.
 *
 * The vnode_attr structure is used to transact attribute changes and queries
 * with the filesystem.
 *
 * Note that this structure may be extended, but existing fields must not move.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_INIT</span>(v)			do {(v)-&gt;va_supported = (v)-&gt;va_active = 0ll; (v)-&gt;va_vaflags = 0; } while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_SET_ACTIVE</span>(v, a)		((v)-&gt;va_active |= VNODE_ATTR_ ## a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_SET_SUPPORTED</span>(v, a)	((v)-&gt;va_supported |= VNODE_ATTR_ ## a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_IS_SUPPORTED</span>(v, a)	((v)-&gt;va_supported &amp; VNODE_ATTR_ ## a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_CLEAR_ACTIVE</span>(v, a)	((v)-&gt;va_active &amp;= ~VNODE_ATTR_ ## a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_CLEAR_SUPPORTED</span>(v, a)	((v)-&gt;va_supported &amp;= ~VNODE_ATTR_ ## a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_CLEAR_SUPPORTED_ALL</span>(v)	((v)-&gt;va_supported = 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_IS_ACTIVE</span>(v, a)		((v)-&gt;va_active &amp; VNODE_ATTR_ ## a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_ALL_SUPPORTED</span>(v)		(((v)-&gt;va_active &amp; (v)-&gt;va_supported) == (v)-&gt;va_active)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_INACTIVE_SUPPORTED</span>(v)	do {(v)-&gt;va_active &amp;= ~(v)-&gt;va_supported; (v)-&gt;va_supported = 0;} while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_SET</span>(v, a, x)		do { (v)-&gt; a = (x); VATTR_SET_ACTIVE(v, a);} while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_WANTED</span>(v, a)		VATTR_SET_ACTIVE(v, a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_RETURN</span>(v, a, x)		do { (v)-&gt; a = (x); VATTR_SET_SUPPORTED(v, a);} while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_NOT_RETURNED</span>(v, a)	(VATTR_IS_ACTIVE(v, a) &amp;&amp; !VATTR_IS_SUPPORTED(v, a))

<span class="enscript-comment">/*
 * Two macros to simplify conditional checking in kernel code.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_IS</span>(v, a, x)		(VATTR_IS_SUPPORTED(v, a) &amp;&amp; (v)-&gt; a == (x))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_IS_NOT</span>(v, a, x)		(VATTR_IS_SUPPORTED(v, a) &amp;&amp; (v)-&gt; a != (x))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_rdev</span>		(1LL&lt;&lt; 0)	<span class="enscript-comment">/* 00000001 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_nlink</span>		(1LL&lt;&lt; 1)	<span class="enscript-comment">/* 00000002 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_total_size</span>	(1LL&lt;&lt; 2)	<span class="enscript-comment">/* 00000004 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_total_alloc</span>	(1LL&lt;&lt; 3)	<span class="enscript-comment">/* 00000008 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_data_size</span>		(1LL&lt;&lt; 4)	<span class="enscript-comment">/* 00000010 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_data_alloc</span>	(1LL&lt;&lt; 5)	<span class="enscript-comment">/* 00000020 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_iosize</span>		(1LL&lt;&lt; 6)	<span class="enscript-comment">/* 00000040 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_uid</span>		(1LL&lt;&lt; 7)	<span class="enscript-comment">/* 00000080 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_gid</span>		(1LL&lt;&lt; 8)	<span class="enscript-comment">/* 00000100 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_mode</span>		(1LL&lt;&lt; 9)	<span class="enscript-comment">/* 00000200 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_flags</span>		(1LL&lt;&lt;10)	<span class="enscript-comment">/* 00000400 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_acl</span>		(1LL&lt;&lt;11)	<span class="enscript-comment">/* 00000800 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_create_time</span>	(1LL&lt;&lt;12)	<span class="enscript-comment">/* 00001000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_access_time</span>	(1LL&lt;&lt;13)	<span class="enscript-comment">/* 00002000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_modify_time</span>	(1LL&lt;&lt;14)	<span class="enscript-comment">/* 00004000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_change_time</span>	(1LL&lt;&lt;15)	<span class="enscript-comment">/* 00008000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_backup_time</span>	(1LL&lt;&lt;16)	<span class="enscript-comment">/* 00010000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_fileid</span>		(1LL&lt;&lt;17)	<span class="enscript-comment">/* 00020000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_linkid</span>		(1LL&lt;&lt;18)	<span class="enscript-comment">/* 00040000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_parentid</span>		(1LL&lt;&lt;19)	<span class="enscript-comment">/* 00080000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_fsid</span>		(1LL&lt;&lt;20)	<span class="enscript-comment">/* 00100000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_filerev</span>		(1LL&lt;&lt;21)	<span class="enscript-comment">/* 00200000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_gen</span>		(1LL&lt;&lt;22)	<span class="enscript-comment">/* 00400000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_encoding</span>		(1LL&lt;&lt;23)	<span class="enscript-comment">/* 00800000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_type</span>		(1LL&lt;&lt;24)	<span class="enscript-comment">/* 01000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_name</span>		(1LL&lt;&lt;25)       <span class="enscript-comment">/* 02000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_uuuid</span>		(1LL&lt;&lt;26)	<span class="enscript-comment">/* 04000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_guuid</span>		(1LL&lt;&lt;27)	<span class="enscript-comment">/* 08000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_nchildren</span>		(1LL&lt;&lt;28)       <span class="enscript-comment">/* 10000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_dirlinkcount</span>	(1LL&lt;&lt;29)       <span class="enscript-comment">/* 20000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_addedtime</span>		(1LL&lt;&lt;30)	<span class="enscript-comment">/* 40000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_dataprotect_class</span>	(1LL&lt;&lt;31)	<span class="enscript-comment">/* 80000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_dataprotect_flags</span>	(1LL&lt;&lt;32)	<span class="enscript-comment">/* 100000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_document_id</span>	(1LL&lt;&lt;33)	<span class="enscript-comment">/* 200000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_devid</span>		(1LL&lt;&lt;34)	<span class="enscript-comment">/* 400000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_objtype</span>		(1LL&lt;&lt;35)	<span class="enscript-comment">/* 800000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_objtag</span>		(1LL&lt;&lt;36)	<span class="enscript-comment">/* 1000000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_user_access</span>	(1LL&lt;&lt;37)	<span class="enscript-comment">/* 2000000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_finderinfo</span>	(1LL&lt;&lt;38)	<span class="enscript-comment">/* 4000000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_rsrc_length</span>	(1LL&lt;&lt;39)	<span class="enscript-comment">/* 8000000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_rsrc_alloc</span>	(1LL&lt;&lt;40)	<span class="enscript-comment">/* 10000000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_fsid64</span>		(1LL&lt;&lt;41)	<span class="enscript-comment">/* 20000000000 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_va_write_gencount</span>    (1LL&lt;&lt;42)	<span class="enscript-comment">/* 40000000000 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VNODE_ATTR_BIT</span>(n)	(VNODE_ATTR_ ## n)
<span class="enscript-comment">/*
 * Read-only attributes.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_RDONLY</span>	(VNODE_ATTR_BIT(va_rdev) |		\
				VNODE_ATTR_BIT(va_nlink) |		\
				VNODE_ATTR_BIT(va_total_size) |		\
				VNODE_ATTR_BIT(va_total_alloc) |	\
				VNODE_ATTR_BIT(va_data_alloc) |		\
				VNODE_ATTR_BIT(va_iosize) |		\
				VNODE_ATTR_BIT(va_fileid) |		\
				VNODE_ATTR_BIT(va_linkid) |		\
				VNODE_ATTR_BIT(va_parentid) |		\
				VNODE_ATTR_BIT(va_fsid) |		\
				VNODE_ATTR_BIT(va_filerev) |		\
				VNODE_ATTR_BIT(va_gen) |		\
				VNODE_ATTR_BIT(va_name) |		\
				VNODE_ATTR_BIT(va_type) |		\
				VNODE_ATTR_BIT(va_nchildren) |		\
				VNODE_ATTR_BIT(va_dirlinkcount) |	\
				VNODE_ATTR_BIT(va_addedtime) |		\
				VNODE_ATTR_BIT(va_devid) |		\
				VNODE_ATTR_BIT(va_objtype) |		\
				VNODE_ATTR_BIT(va_objtag) |		\
				VNODE_ATTR_BIT(va_user_access) |	\
				VNODE_ATTR_BIT(va_finderinfo) |		\
				VNODE_ATTR_BIT(va_rsrc_length) |	\
				VNODE_ATTR_BIT(va_rsrc_alloc) |		\
				VNODE_ATTR_BIT(va_fsid64) |		\
				VNODE_ATTR_BIT(va_write_gencount))
<span class="enscript-comment">/*
 * Attributes that can be applied to a new file object.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_NEWOBJ</span>	(VNODE_ATTR_BIT(va_rdev) |		\
				VNODE_ATTR_BIT(va_uid)	|		\
				VNODE_ATTR_BIT(va_gid) |		\
				VNODE_ATTR_BIT(va_mode) |		\
				VNODE_ATTR_BIT(va_flags) |		\
				VNODE_ATTR_BIT(va_acl) |		\
				VNODE_ATTR_BIT(va_create_time) |	\
				VNODE_ATTR_BIT(va_modify_time) |	\
				VNODE_ATTR_BIT(va_change_time) |	\
				VNODE_ATTR_BIT(va_encoding) |		\
				VNODE_ATTR_BIT(va_type) |		\
				VNODE_ATTR_BIT(va_uuuid) |		\
				VNODE_ATTR_BIT(va_guuid) |		\
				VNODE_ATTR_BIT(va_dataprotect_class) |	\
				VNODE_ATTR_BIT(va_dataprotect_flags) |	\
				VNODE_ATTR_BIT(va_document_id))

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/_types/_fsid_t.h&gt;</span>

<span class="enscript-type">struct</span> vnode_attr {
	<span class="enscript-comment">/* bitfields */</span>
	uint64_t	va_supported;
	uint64_t	va_active;

	<span class="enscript-comment">/*
	 * Control flags.  The low 16 bits are reserved for the
	 * ioflags being passed for truncation operations.
	 */</span>
	<span class="enscript-type">int</span>		va_vaflags;
	
	<span class="enscript-comment">/* traditional stat(2) parameter fields */</span>
	dev_t		va_rdev;	<span class="enscript-comment">/* device id (device nodes only) */</span>
	uint64_t	va_nlink;	<span class="enscript-comment">/* number of references to this file */</span>
	uint64_t	va_total_size;	<span class="enscript-comment">/* size in bytes of all forks */</span>
	uint64_t	va_total_alloc;	<span class="enscript-comment">/* disk space used by all forks */</span>
	uint64_t	va_data_size;	<span class="enscript-comment">/* size in bytes of the fork managed by current vnode */</span>
	uint64_t	va_data_alloc;	<span class="enscript-comment">/* disk space used by the fork managed by current vnode */</span>
	uint32_t	va_iosize;	<span class="enscript-comment">/* optimal I/O blocksize */</span>

	<span class="enscript-comment">/* file security information */</span>
	uid_t		va_uid;		<span class="enscript-comment">/* owner UID */</span>
	gid_t		va_gid;		<span class="enscript-comment">/* owner GID */</span>
	mode_t		va_mode;	<span class="enscript-comment">/* posix permissions */</span>
	uint32_t	va_flags;	<span class="enscript-comment">/* file flags */</span>
	<span class="enscript-type">struct</span> kauth_acl *va_acl;	<span class="enscript-comment">/* access control list */</span>

	<span class="enscript-comment">/* timestamps */</span>
	<span class="enscript-type">struct</span> timespec	va_create_time;	<span class="enscript-comment">/* time of creation */</span>
	<span class="enscript-type">struct</span> timespec	va_access_time;	<span class="enscript-comment">/* time of last access */</span>
	<span class="enscript-type">struct</span> timespec	va_modify_time;	<span class="enscript-comment">/* time of last data modification */</span>
	<span class="enscript-type">struct</span> timespec	va_change_time;	<span class="enscript-comment">/* time of last metadata change */</span>
	<span class="enscript-type">struct</span> timespec	va_backup_time;	<span class="enscript-comment">/* time of last backup */</span>
	
	<span class="enscript-comment">/* file parameters */</span>
	uint64_t	va_fileid;	<span class="enscript-comment">/* file unique ID in filesystem */</span>
	uint64_t	va_linkid;	<span class="enscript-comment">/* file link unique ID */</span>
	uint64_t	va_parentid;	<span class="enscript-comment">/* parent ID */</span>
	uint32_t	va_fsid;	<span class="enscript-comment">/* filesystem ID */</span>
	uint64_t	va_filerev;	<span class="enscript-comment">/* file revision counter */</span>	<span class="enscript-comment">/* XXX */</span>
	uint32_t	va_gen;		<span class="enscript-comment">/* file generation count */</span>	<span class="enscript-comment">/* XXX - relationship of
									* these two? */</span>
	<span class="enscript-comment">/* misc parameters */</span>
	uint32_t	va_encoding;	<span class="enscript-comment">/* filename encoding script */</span>

	<span class="enscript-type">enum</span> vtype	va_type;	<span class="enscript-comment">/* file type (create only) */</span>
	<span class="enscript-type">char</span> *		va_name;	<span class="enscript-comment">/* Name for ATTR_CMN_NAME; MAXPATHLEN bytes */</span>
	guid_t		va_uuuid;	<span class="enscript-comment">/* file owner UUID */</span>
	guid_t		va_guuid;	<span class="enscript-comment">/* file group UUID */</span>
	
	<span class="enscript-comment">/* Meaningful for directories only */</span>
	uint64_t	va_nchildren;     <span class="enscript-comment">/* Number of items in a directory */</span>
	uint64_t	va_dirlinkcount;  <span class="enscript-comment">/* Real references to dir (i.e. excluding &quot;.&quot; and &quot;..&quot; refs) */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
	<span class="enscript-type">struct</span> kauth_acl *va_base_acl;
#<span class="enscript-reference">else</span>
	<span class="enscript-type">void</span> * 		va_reserved1;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>
	<span class="enscript-type">struct</span> timespec va_addedtime;	<span class="enscript-comment">/* timestamp when item was added to parent directory */</span>
		
	<span class="enscript-comment">/* Data Protection fields */</span>
	uint32_t va_dataprotect_class;	<span class="enscript-comment">/* class specified for this file if it didn't exist */</span>
	uint32_t va_dataprotect_flags;	<span class="enscript-comment">/* flags from NP open(2) to the filesystem */</span>

	<span class="enscript-comment">/* Document revision tracking */</span>
	uint32_t va_document_id;

	<span class="enscript-comment">/* Fields for Bulk args */</span>
	uint32_t 	va_devid;	<span class="enscript-comment">/* devid of filesystem */</span>
	uint32_t 	va_objtype;	<span class="enscript-comment">/* type of object */</span>
	uint32_t 	va_objtag;	<span class="enscript-comment">/* vnode tag of filesystem */</span>
	uint32_t 	va_user_access;	<span class="enscript-comment">/* access for user */</span>
	uint8_t  	va_finderinfo[32];	<span class="enscript-comment">/* Finder Info */</span>
	uint64_t 	va_rsrc_length;	<span class="enscript-comment">/* Resource Fork length */</span>
	uint64_t 	va_rsrc_alloc;	<span class="enscript-comment">/* Resource Fork allocation size */</span>
	fsid_t 		va_fsid64;	<span class="enscript-comment">/* fsid, of the correct type  */</span>

	uint32_t va_write_gencount;     <span class="enscript-comment">/* counter that increments each time the file changes */</span>

	<span class="enscript-comment">/* add new fields here only */</span>
};

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
<span class="enscript-comment">/* 
 * Flags for va_dataprotect_flags
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VA_DP_RAWENCRYPTED</span>   0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VA_DP_RAWUNENCRYPTED</span> 0x0002

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Flags for va_vaflags.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VA_UTIMES_NULL</span>		0x010000	<span class="enscript-comment">/* utimes argument was NULL */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VA_EXCLUSIVE</span>		0x020000	<span class="enscript-comment">/* exclusive create request */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VA_NOINHERIT</span>		0x040000	<span class="enscript-comment">/* Don't inherit ACLs from parent */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VA_NOAUTH</span>		0x080000	

<span class="enscript-comment">/*
 *  Modes.  Some values same as Ixxx entries from inode.h for now.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VSUID</span>	0x800 <span class="enscript-comment">/*04000*/</span>	<span class="enscript-comment">/* set user id on execution */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VSGID</span>	0x400 <span class="enscript-comment">/*02000*/</span>	<span class="enscript-comment">/* set group id on execution */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VSVTX</span>	0x200 <span class="enscript-comment">/*01000*/</span>	<span class="enscript-comment">/* save swapped text even after use */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VREAD</span>	0x100 <span class="enscript-comment">/*00400*/</span>	<span class="enscript-comment">/* read, write, execute permissions */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VWRITE</span>	0x080 <span class="enscript-comment">/*00200*/</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VEXEC</span>	0x040 <span class="enscript-comment">/*00100*/</span>

<span class="enscript-comment">/*
 * Convert between vnode types and inode formats (since POSIX.1
 * defines mode word of stat structure in terms of inode formats).
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">enum</span> vtype	iftovt_tab[];
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		vttoif_tab[];
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IFTOVT</span>(mode)	(iftovt_tab[((mode) &amp; S_IFMT) &gt;&gt; 12])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VTTOIF</span>(indx)	(vttoif_tab[(int)(indx)])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MAKEIMODE</span>(indx, mode)	(int)(VTTOIF(indx) | (mode))

<span class="enscript-comment">/*
 * Flags to various vnode functions.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SKIPSYSTEM</span>	0x0001		<span class="enscript-comment">/* vflush: skip vnodes marked VSYSTEM */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FORCECLOSE</span>	0x0002		<span class="enscript-comment">/* vflush: force file closeure */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">WRITECLOSE</span>	0x0004		<span class="enscript-comment">/* vflush: only close writeable files */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SKIPSWAP</span>	0x0008		<span class="enscript-comment">/* vflush: skip vnodes marked VSWAP */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SKIPROOT</span>	0x0010		<span class="enscript-comment">/* vflush: skip root vnodes marked VROOT */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOCLOSE</span>		0x0008		<span class="enscript-comment">/* vclean: close active files */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">V_SAVE</span>		0x0001		<span class="enscript-comment">/* vinvalbuf: sync file first */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">V_SAVEMETA</span>	0x0002		<span class="enscript-comment">/* vinvalbuf: leave indirect blocks */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">REVOKEALL</span>	0x0001		<span class="enscript-comment">/* vnop_revoke: revoke all aliases */</span>

<span class="enscript-comment">/* VNOP_REMOVE/unlink flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_REMOVE_NODELETEBUSY</span>  			0x0001 <span class="enscript-comment">/* Don't delete busy files (Carbon) */</span>  
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_REMOVE_SKIP_NAMESPACE_EVENT</span>	0x0002 <span class="enscript-comment">/* Do not upcall to userland handlers */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_REMOVE_NO_AUDIT_PATH</span>		0x0004 <span class="enscript-comment">/* Do not audit the path */</span>

<span class="enscript-comment">/* VNOP_READDIR flags: */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_READDIR_EXTENDED</span>    0x0001   <span class="enscript-comment">/* use extended directory entries */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_READDIR_REQSEEKOFF</span>  0x0002   <span class="enscript-comment">/* requires seek offset (cookies) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_READDIR_SEEKOFF32</span>   0x0004   <span class="enscript-comment">/* seek offset values should fit in 32 bits */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_READDIR_NAMEMAX</span>     0x0008   <span class="enscript-comment">/* For extended readdir, try to limit names to NAME_MAX bytes */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NULLVP</span>	((struct vnode *)NULL)

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
<span class="enscript-type">struct</span> vnodeop_desc;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span>	<span class="enscript-type">int</span> desiredvnodes;		<span class="enscript-comment">/* number of vnodes desired */</span>


<span class="enscript-comment">/*
 * This structure is used to configure the new vnodeops vector.
 */</span>
<span class="enscript-type">struct</span> vnodeopv_entry_desc {
	<span class="enscript-type">struct</span> vnodeop_desc *opve_op;   <span class="enscript-comment">/* which operation this is */</span>
	<span class="enscript-type">int</span> (*opve_impl)(<span class="enscript-type">void</span> *);		<span class="enscript-comment">/* code implementing this operation */</span>
};
<span class="enscript-type">struct</span> vnodeopv_desc {
			<span class="enscript-comment">/* ptr to the ptr to the vector where op should go */</span>
	<span class="enscript-type">int</span> (***opv_desc_vector_p)(<span class="enscript-type">void</span> *);
	<span class="enscript-type">struct</span> vnodeopv_entry_desc *opv_desc_ops;   <span class="enscript-comment">/* null terminated list */</span>
};

<span class="enscript-comment">/*!
 @function vn_default_error
 @abstract Default vnode operation to fill unsupported slots in vnode operation vectors.
 @return ENOTSUP
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">vn_default_error</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 * A generic structure.
 * This can be used by bypass routines to identify generic arguments.
 */</span>
<span class="enscript-type">struct</span> vnop_generic_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	<span class="enscript-comment">/* other random data follows, presumably */</span>
};

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_KAUTH_ACTION_T</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">int</span> kauth_action_t;
# <span class="enscript-reference">define</span> <span class="enscript-variable-name">_KAUTH_ACTION_T</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_if.h&gt;</span>

__BEGIN_DECLS

<span class="enscript-comment">/*!
 @function vnode_create
 @abstract Create and initialize a vnode.
 @discussion Returns wth an iocount held on the vnode which must eventually be dropped with vnode_put().
 @param flavor Should be VNCREATE_FLAVOR.
 @param size  Size of the struct vnode_fsparam in &quot;data&quot;.
 @param data  Pointer to a struct vnode_fsparam containing initialization information.
 @param vpp  Pointer to a vnode pointer, to be filled in with newly created vnode.
 @return 0 for success, error code otherwise.
 */</span>
errno_t	vnode_create(uint32_t, uint32_t, <span class="enscript-type">void</span>  *, vnode_t *);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
<span class="enscript-comment">/*!
 @function vnode_create_empty
 @abstract Create an empty, uninitialized vnode.
 @discussion Returns with an iocount held on the vnode which must eventually be
 dropped with vnode_put(). The next operation performed on the vnode must be
 vnode_initialize (or vnode_put if the vnode is not needed anymore).
 This interface is provided as a mechanism to pre-flight obtaining a vnode for
 certain filesystem operations which may need to get a vnode without filesystem
 locks held. It is imperative that nothing be done with the vnode till the
 succeeding vnode_initialize (or vnode_put as the case may be) call.
 @param vpp  Pointer to a vnode pointer, to be filled in with newly created vnode.
 @return 0 for success, error code otherwise.
 */</span>
errno_t	vnode_create_empty(vnode_t *);

<span class="enscript-comment">/*!
 @function vnode_initialize
 @abstract Initialize a vnode obtained by vnode_create_empty
 @discussion Does not drop iocount held on the vnode which must eventually be
 dropped with vnode_put().  In case of an error however, the vnode's iocount is
 dropped and the vnode must not be referenced again by the caller.
 @param flavor Should be VNCREATE_FLAVOR.
 @param size  Size of the struct vnode_fsparam in &quot;data&quot;.
 @param data  Pointer to a struct vnode_fsparam containing initialization information.
 @param vpp  Pointer to a vnode pointer, to be filled in with newly created vnode.
 @return 0 for success, error code otherwise.
 */</span>
errno_t	vnode_initialize(uint32_t, uint32_t, <span class="enscript-type">void</span>  *, vnode_t *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>

<span class="enscript-comment">/*!
 @function vnode_addfsref
 @abstract Mark a vnode as being stored in a filesystem hash.
 @discussion Should only be called once on a vnode, and never if that vnode was created with VNFS_ADDFSREF.
 There should be a corresponding call to vnode_removefsref() when the vnode is reclaimed; VFS assumes that a
 n unused vnode will not be marked as referenced by a filesystem.
 @param vp The vnode to mark.
 @return Always 0.
 */</span>
<span class="enscript-type">int</span>	vnode_addfsref(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_removefsref
 @abstract Mark a vnode as no longer being stored in a filesystem hash.
 @discussion Should only be called once on a vnode (during a reclaim), and only after the vnode has either been created with VNFS_ADDFSREF or marked by vnode_addfsref().
 @param vp The vnode to unmark.
 @return Always 0.
 */</span>
<span class="enscript-type">int</span>	vnode_removefsref(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_hasdirtyblks 
 @abstract Check if a vnode has dirty data waiting to be written to disk.
 @discussion Note that this routine is unsynchronized; it is only a snapshot and its result may cease to be true at the moment it is returned..
 @param vp The vnode to test.
 @return Nonzero if there are dirty blocks, 0 otherwise
 */</span>
<span class="enscript-type">int</span>	vnode_hasdirtyblks(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_hascleanblks
 @abstract Check if a vnode has clean buffers associated with it.
 @discussion Note that this routine is unsynchronized; it is only a snapshot and its result may cease to be true at the moment it is returned..
 @param vp The vnode to test.
 @return Nonzero if there are clean blocks, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_hascleanblks(vnode_t);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_ASYNC_THROTTLE</span>	15
<span class="enscript-comment">/*!
 @function vnode_waitforwrites
 @abstract Wait for the number of pending writes on a vnode to drop below a target.
 @param vp The vnode to monitor.
 @param output_target Max pending write count with which to return.
 @param slpflag Flags for msleep().
 @param slptimeout Frequency with which to force a check for completion; increments of 10 ms.
 @param msg String to pass  msleep() .
 @return 0 for success, or an error value from msleep().
 */</span>
<span class="enscript-type">int</span>	vnode_waitforwrites(vnode_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *);

<span class="enscript-comment">/*!
 @function vnode_startwrite
 @abstract Increment the count of pending writes on a vnode.
 @param vp The vnode whose count to increment.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_startwrite(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_startwrite
 @abstract Decrement the count of pending writes on a vnode .
 @discussion Also wakes up threads waiting for the write count to drop, as in vnode_waitforwrites.
 @param vp The vnode whose count to decrement.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_writedone(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_vtype
 @abstract Return a vnode's type.
 @param vp The vnode whose type to grab.
 @return The vnode's type.
 */</span>
<span class="enscript-type">enum</span> vtype	vnode_vtype(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_vid
 @abstract Return a vnode's vid (generation number), which is constant from creation until reclaim. 
 @param vp The vnode whose vid to grab.
 @return The vnode's vid.
 */</span>
uint32_t	vnode_vid(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_mountedhere
 @abstract Returns a pointer to a mount placed on top of a vnode, should it exist.
 @param vp The vnode from whom to take the covering mount.
 @return Pointer to mount covering a vnode, or NULL if none exists.
 */</span>
mount_t	vnode_mountedhere(vnode_t vp);

<span class="enscript-comment">/*!
 @function vnode_mount
 @abstract Get the mount structure for the filesystem that a vnode belongs to.
 @param vp The vnode whose mount to grab.
 @return The mount, directly.
 */</span>
mount_t	vnode_mount(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_specrdev
 @abstract Return the device id of the device associated with a special file.
 @param vp The vnode whose device id to extract--vnode must be a special file.
 @return The device id.
 */</span>
dev_t	vnode_specrdev(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_fsnode
 @abstract Gets the filesystem-specific data associated with a vnode.
 @param vp The vnode whose data to grab.
 @return The filesystem-specific data, directly.
 */</span>
<span class="enscript-type">void</span> *	vnode_fsnode(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_clearfsnode
 @abstract Sets a vnode's filesystem-specific data to be NULL.
 @discussion This routine should only be called when a vnode is no longer in use, i.e. during a VNOP_RECLAIM.
 @param vp The vnode whose data to clear out.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_clearfsnode(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isvroot
 @abstract Determine if a vnode is the root of its filesystem.
 @param vp The vnode to test.
 @return Nonzero if the vnode is the root, 0 if it is not.
 */</span>
<span class="enscript-type">int</span>	vnode_isvroot(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_issystem
 @abstract Determine if a vnode is marked as a System vnode.
 @param vp The vnode to test.
 @return Nonzero if the vnode is a system vnode, 0 if it is not.
 */</span>
<span class="enscript-type">int</span>	vnode_issystem(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_ismount
 @abstract Determine if there is currently a mount occurring which will cover this vnode.
 @discussion Note that this is only a snapshot; a mount may begin or end at any time.
 @param vp The vnode to test.
 @return Nonzero if there is a mount in progress, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_ismount(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isreg
 @abstract Determine if a vnode is a regular file.
 @param vp The vnode to test.
 @return Nonzero if the vnode is of type VREG, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_isreg(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isdir
 @abstract Determine if a vnode is a directory.
 @param vp The vnode to test.
 @return Nonzero if the vnode is of type VDIR, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_isdir(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_islnk
 @abstract Determine if a vnode is a symbolic link.
 @param vp The vnode to test.
 @return Nonzero if the vnode is of type VLNK, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_islnk(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isfifo
 @abstract Determine if a vnode is a named pipe.
 @param vp The vnode to test.
 @return Nonzero if the vnode is of type VFIFO, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_isfifo(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isblk
 @abstract Determine if a vnode is a block device special file.
 @param vp The vnode to test.
 @return Nonzero if the vnode is of type VBLK, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_isblk(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_ischr
 @abstract Determine if a vnode is a character device special file.
 @param vp The vnode to test.
 @return Nonzero if the vnode is of type VCHR, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_ischr(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isswap
 @abstract Determine if a vnode is being used as a swap file.
 @param vp The vnode to test.
 @return Nonzero if the vnode is being used as swap, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_isswap(vnode_t vp);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_UNSTABLE</span>
<span class="enscript-comment">/*!
 @function vnode_isnamedstream
 @abstract Determine if a vnode is a named stream.
 @param vp The vnode to test.
 @return Nonzero if the vnode is a named stream, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_isnamedstream(vnode_t);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*!
 @function vnode_ismountedon
 @abstract Determine if a vnode is a block device on which a filesystem has been mounted.
 @discussion A block device marked as being mounted on cannot be opened.
 @param vp The vnode to test.
 @return Nonzero if the vnode is a block device on which an filesystem is mounted, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_ismountedon(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_setmountedon
 @abstract Set flags indicating that a block device vnode has been mounted as a filesystem.
 @discussion A block device marked as being mounted on cannot be opened.
 @param vp The vnode to set flags on, a block device.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_setmountedon(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_clearmountedon
 @abstract Clear flags indicating that a block device vnode has been mounted as a filesystem.
 @param vp The vnode to clear flags on, a block device.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_clearmountedon(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isrecycled
 @abstract Check if a vnode is dead or in the process of being killed (recycled).
 @discussion This is only a snapshot: a vnode may start to be recycled, or go from dead to in use, at any time.
 @param vp The vnode to test.
 @return Nonzero if vnode is dead or being recycled, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_isrecycled(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isnocache
 @abstract Check if a vnode is set to not have its data cached in memory  (i.e. we write-through to disk and always read from disk).
 @param vp The vnode to test.
 @return Nonzero if vnode is set to not have data chached, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_isnocache(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_israge
 @abstract Check if a vnode is marked for rapid aging
 @param vp The vnode to test.
 @return Nonzero if vnode is marked for rapid aging, 0 otherwise
 */</span>
<span class="enscript-type">int</span>	vnode_israge(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_needssnapshots
 @abstract Check if a vnode needs snapshots events (regardless of its ctime status)
 @param vp The vnode to test.
 @return Nonzero if vnode needs snapshot events, 0 otherwise
 */</span>
<span class="enscript-type">int</span>	vnode_needssnapshots(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_setnocache
 @abstract Set a vnode to not have its data cached in memory (i.e. we write-through to disk and always read from disk).
 @param vp The vnode whose flags to set.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_setnocache(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_clearnocache
 @abstract Clear the flag on a vnode indicating that data should not be cached in memory (i.e. we write-through to disk and always read from disk).
 @param vp The vnode whose flags to clear.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_clearnocache(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isnoreadahead
 @abstract Check if a vnode is set to not have data speculatively read in in hopes of future cache hits.
 @param vp The vnode to test.
 @return Nonzero if readahead is disabled, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_isnoreadahead(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_setnoreadahead
 @abstract Set a vnode to not have data speculatively read in in hopes of hitting in cache.
 @param vp The vnode on which to prevent readahead.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_setnoreadahead(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_clearnoreadahead
 @abstract Clear the flag indicating that a vnode should not have data speculatively read in.
 @param vp The vnode whose flag to clear.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_clearnoreadahead(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isfastdevicecandidate
 @abstract Check if a vnode is a candidate to store on the fast device of a composite disk system
 @param vp The vnode which you want to test.
 @return Nonzero if the vnode is marked as a fast-device candidate
 @return void.
 */</span>
<span class="enscript-type">int</span>	vnode_isfastdevicecandidate(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_setfastdevicecandidate
 @abstract Mark a vnode as a candidate to store on the fast device of a composite disk system
 @abstract If the vnode is a directory, all its children will inherit this bit.
 @param vp The vnode which you want marked.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_setfastdevicecandidate(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_clearfastdevicecandidate
 @abstract Clear the status of a vnode being a candidate to store on the fast device of a composite disk system.
 @param vp The vnode whose flag to clear.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_clearfastdevicecandidate(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isautocandidate
 @abstract Check if a vnode was automatically selected to be fast-dev candidate (see vnode_setfastdevicecandidate)
 @param vp The vnode which you want to test.
 @return Nonzero if the vnode was automatically marked as a fast-device candidate
 @return void.
 */</span>
<span class="enscript-type">int</span>	vnode_isautocandidate(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_setfastdevicecandidate
 @abstract Mark a vnode as an automatically selected candidate for storing on the fast device of a composite disk system
 @abstract If the vnode is a directory, all its children will inherit this bit.
 @param vp The vnode which you want marked.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_setautocandidate(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_clearautocandidate
 @abstract Clear the status of a vnode being an automatic candidate (see above)
 @param vp The vnode whose flag to clear.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_clearautocandidate(vnode_t);

<span class="enscript-comment">/* left only for compat reasons as User code depends on this from getattrlist, for ex */</span>

<span class="enscript-comment">/*!
 @function vnode_settag
 @abstract Set a vnode filesystem-specific &quot;tag.&quot;
 @discussion Sets a tag indicating which filesystem a vnode belongs to, e.g. VT_HFS, VT_UDF, VT_ZFS.  The kernel never inspects this data, though the filesystem tags are defined in vnode.h; it is for the benefit of user programs via getattrlist.
 @param vp The vnode whose tag to set.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_settag(vnode_t, <span class="enscript-type">int</span>);

<span class="enscript-comment">/*!
 @function vnode_tag
 @abstract Get the vnode filesystem-specific &quot;tag.&quot;
 @discussion Gets the tag indicating which filesystem a vnode belongs to, e.g. VT_HFS, VT_UDF, VT_ZFS.  The kernel never inspects this data, though the filesystem tags are defined in vnode.h; it is for the benefit of user programs via getattrlist.
 @param vp The vnode whose tag to grab.
 @return The tag.
 */</span>
<span class="enscript-type">int</span>	vnode_tag(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_getattr
 @abstract Get vnode attributes.
 @discussion Desired attributes are set with VATTR_SET_ACTIVE and VNODE_ATTR* macros.  Supported attributes are determined after call with VATTR_IS_SUPPORTED.
 @param vp The vnode whose attributes to grab.
 @param vap Structure containing: 1) A list of requested attributes 2) Space to indicate which attributes are supported and being returned 3) Space to return attributes.
 @param ctx Context for authentication.
 @return 0 for success or an error code.
 */</span>
<span class="enscript-type">int</span>	vnode_getattr(vnode_t vp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx);

<span class="enscript-comment">/*!
 @function vnode_setattr
 @abstract Set vnode attributes.
 @discussion Attributes to set are marked with VATTR_SET_ACTIVE and VNODE_ATTR* macros.  Attributes successfully set are determined after call with VATTR_IS_SUPPORTED.
 @param vp The vnode whose attributes to set.
 @param vap Structure containing: 1) A list of attributes to set 2) Space for values for those attributes 3) Space to indicate which attributes were set.
 @param ctx Context for authentication.
 @return 0 for success or an error code.
 */</span>
<span class="enscript-type">int</span>	vnode_setattr(vnode_t vp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx);

<span class="enscript-comment">/*!
 @function vfs_rootvnode
 @abstract Returns the root vnode with an iocount.
 @discussion Caller must vnode_put() the root node when done.
 @return Pointer to root vnode if successful; error code if there is a problem taking an iocount.
 */</span>
vnode_t <span class="enscript-function-name">vfs_rootvnode</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*!
 @function vnode_uncache_credentials
 @abstract Clear out cached credentials on a vnode.
 @discussion When we authorize an action on a vnode, we cache the credential that was authorized and the actions it was authorized for in case a similar request follows.  This function destroys that caching.
 @param vp The vnode whose cache to clear.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_uncache_credentials(vnode_t vp);

<span class="enscript-comment">/*!
 @function vnode_setmultipath
 @abstract Mark a vnode as being reachable by multiple paths, i.e. as a hard link.
 @discussion &quot;Multipath&quot; vnodes can be reached through more than one entry in the filesystem, and so must be handled differently for caching and event notification purposes.  A filesystem should mark a vnode with multiple hardlinks this way.
 @param vp The vnode to mark.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_setmultipath(vnode_t vp);

<span class="enscript-comment">/*!
 @function vnode_vfsmaxsymlen
 @abstract Determine the maximum length of a symbolic link for the filesystem on which a vnode resides.
 @param vp The vnode for which to get filesystem symlink size cap.
 @return Max symlink length.
 */</span>
uint32_t  <span class="enscript-function-name">vnode_vfsmaxsymlen</span>(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_vfsisrdonly
 @abstract Determine if the filesystem to which a vnode belongs is mounted read-only.
 @param vp The vnode for which to get filesystem writeability.
 @return Nonzero if the filesystem is read-only, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_vfsisrdonly(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_vfstypenum
 @abstract Get the &quot;type number&quot; of the filesystem to which a vnode belongs.
 @discussion This is an archaic construct; most filesystems are assigned a type number based on the order in which they are registered with the system.
 @param vp The vnode whose filesystem to examine.
 @return The type number of the fileystem to which the vnode belongs.
 */</span>
<span class="enscript-type">int</span>	vnode_vfstypenum(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_vfsname
 @abstract Get the name of the filesystem to which a vnode belongs.
 @param vp The vnode whose filesystem to examine.
 @param buf Destination for vfs name: should have size MFSNAMELEN or greater.
 @return The name of the fileystem to which the vnode belongs.
 */</span>
<span class="enscript-type">void</span>	vnode_vfsname(vnode_t, <span class="enscript-type">char</span> *);

<span class="enscript-comment">/*!
 @function vnode_vfs64bitready
 @abstract Determine if the filesystem to which a vnode belongs is marked as ready to interact with 64-bit user processes.
 @param vp The vnode whose filesystem to examine.
 @return Nonzero if filesystem is marked ready for 64-bit interactions; 0 otherwise.
 */</span>
<span class="enscript-type">int</span> 	vnode_vfs64bitready(vnode_t);

<span class="enscript-comment">/* These should move to private ... not documenting for now */</span>
<span class="enscript-type">int</span>	vfs_context_get_special_port(vfs_context_t, <span class="enscript-type">int</span>, ipc_port_t *);
<span class="enscript-type">int</span>	vfs_context_set_special_port(vfs_context_t, <span class="enscript-type">int</span>, ipc_port_t);

<span class="enscript-comment">/*!
 @function vfs_context_proc
 @abstract Get the BSD process structure associated with a vfs_context_t.
 @param ctx Context whose associated process to find.
 @return Process if available, NULL otherwise.
 */</span>
proc_t	vfs_context_proc(vfs_context_t);

<span class="enscript-comment">/*!
 @function vfs_context_ucred
 @abstract Get the credential associated with a vfs_context_t.
 @discussion Succeeds if and only if the context has a thread, the thread has a task, and the task has a BSD proc.
 @param ctx Context whose associated process to find.
 @returns credential if process available; NULL otherwise
 */</span>
kauth_cred_t	vfs_context_ucred(vfs_context_t);

<span class="enscript-comment">/*!
 @function vfs_context_pid
 @abstract Get the process id of the BSD process associated with a vfs_context_t.
 @param ctx Context whose associated process to find.
 @return Process id.
 */</span>
<span class="enscript-type">int</span>	vfs_context_pid(vfs_context_t);

<span class="enscript-comment">/*!
 @function vfs_context_issignal
 @abstract Get a bitfield of pending signals for the BSD process associated with a vfs_context_t.
 @discussion The bitfield is constructed using the sigmask() macro, in the sense of bits |= sigmask(SIGSEGV).
 @param ctx Context whose associated process to find.
 @return Bitfield of pending signals.
 */</span>
<span class="enscript-type">int</span>	vfs_context_issignal(vfs_context_t, sigset_t);

<span class="enscript-comment">/*!
 @function vfs_context_suser
 @abstract Determine if a vfs_context_t corresponds to the superuser.
 @param ctx Context to examine.
 @return Nonzero if context belongs to superuser, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vfs_context_suser(vfs_context_t);

<span class="enscript-comment">/*!
 @function vfs_context_is64bit
 @abstract Determine if a vfs_context_t corresponds to a 64-bit user process.
 @param ctx Context to examine.
 @return Nonzero if context is of 64-bit process, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vfs_context_is64bit(vfs_context_t);

<span class="enscript-comment">/*!
 @function vfs_context_create
 @abstract Create a new vfs_context_t with appropriate references held.
 @discussion The context must be released with vfs_context_rele() when no longer in use.
 @param ctx Context to copy, or NULL to use information from running thread.
 @return The new context, or NULL in the event of failure.
 */</span>
vfs_context_t <span class="enscript-function-name">vfs_context_create</span>(vfs_context_t);

<span class="enscript-comment">/*!
 @function vfs_context_rele
 @abstract Release references on components of a context and deallocate it.
 @discussion A context should not be referenced after vfs_context_rele has been called.
 @param ctx Context to release.
 @return Always 0.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">vfs_context_rele</span>(vfs_context_t);

<span class="enscript-comment">/*!
 @function vfs_context_current
 @abstract Get the vfs_context for the current thread, or the kernel context if there is no context for current thread.
 @discussion Kexts should not use this function--it is preferred to use vfs_context_create(NULL) and vfs_context_rele(), which ensure proper reference counting of underlying structures.
 @return Context for current thread, or kernel context if thread context is unavailable.
 */</span>
vfs_context_t <span class="enscript-function-name">vfs_context_current</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
<span class="enscript-type">int</span>	vfs_context_bind(vfs_context_t);

<span class="enscript-comment">/*!
 @function vfs_ctx_skipatime
 @abstract Check to see if this context should skip updating a vnode's access times.
 @discussion  This is currently tied to the vnode rapid aging process.  If the process is marked for rapid aging, 
 then the kernel should not update vnodes it touches for access time purposes.  This will check to see if the
 specified process and/or thread is marked for rapid aging when it manipulates vnodes. 
 @param ctx The context being investigated. 
 @return 1 if we should skip access time updates.  
 @return 0 if we should NOT skip access time updates.
 */</span>

<span class="enscript-type">int</span>	vfs_ctx_skipatime(vfs_context_t ctx);

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*!
 @function vflush
 @abstract Reclaim the vnodes associated with a mount.
 @param mp The mount whose vnodes to kill.
 @param skipvp A specific vnode to not reclaim or to let interrupt an un-forced flush
 @param flags  Control which 
 @discussion This function is used to clear out the vnodes associated with a mount as part of the unmount process.  
 Its parameters can determine which vnodes to skip in the process and whether in-use vnodes should be forcibly reclaimed.
 Filesystems should call this function from their unmount code, because VFS code will always call it with SKIPROOT | SKIPSWAP | SKIPSYSTEM; filesystems
 must take care of such vnodes themselves.
 	SKIPSYSTEM skip vnodes marked VSYSTEM 
	FORCECLOSE force file closeure 
	WRITECLOSE only close writeable files 
	SKIPSWAP   skip vnodes marked VSWAP 
	SKIPROOT   skip root vnodes marked VROOT 
 @return 0 for success, EBUSY if vnodes were busy and FORCECLOSE was not set.
 */</span>
<span class="enscript-type">int</span>	vflush(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vnode *skipvp, <span class="enscript-type">int</span> flags);

<span class="enscript-comment">/*!
 @function vnode_get
 @abstract Increase the iocount on a vnode.
 @discussion If vnode_get() succeeds, the resulting io-reference must be dropped with vnode_put().
 This function succeeds unless the vnode in question is dead or in the process of dying AND the current iocount is zero.  
 This means that it can block an ongoing reclaim which is blocked behind some other iocount.

 On success, vnode_get() returns with an iocount held on the vnode; this type of reference is intended to be held only for short periods of time (e.g.
 across a function call) and provides a strong guarantee about the life of the vnode; vnodes with positive iocounts cannot be
 recycled, and an iocount is required for any  operation on a vnode.  However, vnode_get() does not provide any guarantees 
 about the identity of the vnode it is called on; unless there is a known existing iocount on the vnode at time the call is made,
 it could be recycled and put back in use before the vnode_get() succeeds, so the caller may be referencing a 
 completely different vnode than was intended.  vnode_getwithref() and vnode_getwithvid()
 provide guarantees about vnode identity.

 @return 0 for success, ENOENT if the vnode is dead and without existing io-reference.
 */</span>
<span class="enscript-type">int</span> 	vnode_get(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_getwithvid
 @abstract Increase the iocount on a vnode, checking that the vnode is alive and has not changed vid (i.e. been recycled)
 @discussion If vnode_getwithvid() succeeds, the resulting io-reference must be dropped with vnode_put().
 This function succeeds unless the vnode in question is dead, in the process of dying, or has been recycled (and given a different vnode id).
 The intended usage is that a vnode is stored and its vid (vnode_vid(vp)) recorded while an iocount is held (example: a filesystem hash).  The
 iocount is then dropped, and time passes (perhaps locks are dropped and picked back up). Subsequently, vnode_getwithvid() is called to get an iocount, 
 but we are alerted if the vnode has been recycled.

 On success, vnode_getwithvid()  returns with an iocount held on the vnode; this type of reference is intended to be held only for short periods of time (e.g.
 across a function call) and provides a strong guarantee about the life of the vnode. vnodes with positive iocounts cannot be
 recycled. An iocount is required for any operation on a vnode.
 @return 0 for success, ENOENT if the vnode is dead, in the process of being reclaimed, or has been recycled and reused.
 */</span>
<span class="enscript-type">int</span> 	vnode_getwithvid(vnode_t, uint32_t);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">vnode_getwithvid_drainok</span>(vnode_t, uint32_t);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>

<span class="enscript-comment">/*!
 @function vnode_getwithref
 @abstract Increase the iocount on a vnode on which a usecount (persistent reference) is held.
 @discussion If vnode_getwithref() succeeds, the resulting io-reference must be dropped with vnode_put().
 vnode_getwithref() will succeed on dead vnodes; it should fail with ENOENT on vnodes which are in the process of being reclaimed.  
 Because it is only called with a usecount on the vnode, the caller is guaranteed that the vnode has not been 
 reused for a different file, though it may now be dead and have deadfs vnops (which return errors like EIO, ENXIO, ENOTDIR).
 On success, vnode_getwithref() returns with an iocount held on the vnode; this type of reference is intended to be held only for short periods of time (e.g.
 across a function call) and provides a strong guarantee about the life of the vnode. vnodes with positive iocounts cannot be
 recycled. An iocount is required for any operation on a vnode.
 @return 0 for success, ENOENT if the vnode is dead, in the process of being reclaimed, or has been recycled and reused.
 */</span>
<span class="enscript-type">int</span>	vnode_getwithref(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_put
 @abstract Decrement the iocount on a vnode.
 @discussion vnode_put() is called to indicate that a vnode is no longer in active use.  It removes the guarantee that a
 vnode will not be recycled.  This routine should be used to release io references no matter how they were obtained.
 @param vp The vnode whose iocount to drop.
 @return Always 0.
 */</span>
<span class="enscript-type">int</span> 	vnode_put(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_ref
 @abstract Increment the usecount on a vnode.
 @discussion If vnode_ref() succeeds, the resulting usecount must be released with vnode_rele(). vnode_ref() is called to obtain 
 a persistent reference on a vnode.  This type of reference does not provide the same strong guarantee that a vnode will persist
 as does an iocount--it merely ensures that a vnode will not be reused to represent a different file.  However, a usecount may be
 held for extended periods of time, whereas an iocount is intended to be obtained and released quickly as part of performing a
 vnode operation.  A holder of a usecount must call vnode_getwithref()/vnode_put() in order to perform any operations on that vnode.
 @param vp The vnode on which to obtain a persistent reference.
 @return 0 for success; ENOENT if the vnode is dead or in the process of being recycled AND the calling thread is not the vnode owner.
 */</span>
<span class="enscript-type">int</span> 	vnode_ref(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_rele
 @abstract Decrement the usecount on a vnode.
 @discussion vnode_rele() is called to relese a persistent reference on a vnode.  Releasing the last usecount 
 opens the door for a vnode to be reused as a new file; it also triggers a VNOP_INACTIVE call to the filesystem,
 though that will not happen immediately if there are outstanding iocount references.
 @param vp The vnode whose usecount to drop.
 @return void.
 */</span>
<span class="enscript-type">void</span> 	vnode_rele(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isinuse
 @abstract Determine if the number of persistent (usecount) references on a vnode is greater than a given count.
 @discussion vnode_isinuse() compares a vnode's  usecount (corresponding to vnode_ref() calls) to its refcnt parameter 
 (the number of references the caller expects to be on the vnode).  Note that &quot;kusecount&quot; references, corresponding
 to parties interested only in event notifications, e.g. open(..., O_EVTONLY), are not counted towards the total; the comparison is
 (usecount - kusecount &gt; recnt).  It is
 also important to note that the result is only a snapshot; usecounts can change from moment to moment, and the result of vnode_isinuse
 may no longer be correct the very moment that the caller receives it.
 @param vp The vnode whose use-status to check.
 @param refcnt The threshold for saying that a vnode is in use.
 @return void.
 */</span>
<span class="enscript-type">int</span> 	vnode_isinuse(vnode_t, <span class="enscript-type">int</span>);

<span class="enscript-comment">/*!
 @function vnode_recycle
 @abstract Cause a vnode to be reclaimed and prepared for reuse.
 @discussion Like all vnode KPIs, must be called with an iocount on the target vnode.
 vnode_recycle() will mark that vnode for reclaim when all existing references are dropped.
 @param vp The vnode to recycle.
 @return 1 if the vnode was reclaimed (i.e. there were no existing references), 0 if it was only marked for future reclaim.
 */</span>
<span class="enscript-type">int</span>	vnode_recycle(vnode_t);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_EVENT_DELETE</span>		0x00000001	<span class="enscript-comment">/* file was removed */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_EVENT_WRITE</span>		0x00000002	<span class="enscript-comment">/* file or directory contents changed */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_EVENT_EXTEND</span>		0x00000004	<span class="enscript-comment">/* ubc size increased */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_EVENT_ATTRIB</span>		0x00000008	<span class="enscript-comment">/* attributes changed (suitable for permission changes if type unknown)*/</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_EVENT_LINK</span>		0x00000010	<span class="enscript-comment">/* link count changed */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_EVENT_RENAME</span>		0x00000020	<span class="enscript-comment">/* vnode was renamed */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_EVENT_PERMS</span>		0x00000040	<span class="enscript-comment">/* permissions changed: will cause a NOTE_ATTRIB */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_EVENT_FILE_CREATED</span>	0x00000080	<span class="enscript-comment">/* file created in directory: will cause NOTE_WRITE */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_EVENT_DIR_CREATED</span>		0x00000100	<span class="enscript-comment">/* directory created inside this directory: will cause NOTE_WRITE */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_EVENT_FILE_REMOVED</span>	0x00000200	<span class="enscript-comment">/* file removed from this directory: will cause NOTE_WRITE */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_EVENT_DIR_REMOVED</span>		0x00000400	<span class="enscript-comment">/* subdirectory from this directory: will cause NOTE_WRITE */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span> 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_NOTIFY_ATTRS</span>		(VNODE_ATTR_BIT(va_fsid) | \
			        	VNODE_ATTR_BIT(va_fileid)| \
				    	VNODE_ATTR_BIT(va_mode)  | \
				        VNODE_ATTR_BIT(va_uid)   | \
					VNODE_ATTR_BIT(va_gid)   | \
	    				VNODE_ATTR_BIT(va_dirlinkcount) | \
					VNODE_ATTR_BIT(va_nlink))

					

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE  */</span>

<span class="enscript-comment">/*!
 @function vnode_ismonitored
 @abstract Check whether a file has watchers that would make it useful to query a server
 for file changes.
 @param vp Vnode to examine.
 @discussion Will not reenter the filesystem.
 @return Zero if not monitored, nonzero if monitored.
 */</span> 
<span class="enscript-type">int</span>	vnode_ismonitored(vnode_t);


<span class="enscript-comment">/*!
 @function vnode_isdyldsharedcache
 @abstract Check whether a file is a dyld shared cache file.
 @param vp Vnode to examine.
 @discussion Will not reenter the filesystem.
 @return nonzero if a dyld shared cache file, zero otherwise.
 */</span> 
<span class="enscript-type">int</span>	vnode_isdyldsharedcache(vnode_t);


<span class="enscript-comment">/*!
 @function vn_getpath_fsenter
 @abstract Attempt to get a vnode's path, willing to enter the filesystem.
 @discussion Paths to vnodes are not always straightforward: a file with multiple hard-links will have multiple pathnames,
 and it is sometimes impossible to determine a vnode's full path.  vn_getpath_fsenter() may enter the filesystem
 to try to construct a path, so filesystems should be wary of calling it.
 @param vp Vnode whose path to get
 @param pathbuf Buffer in which to store path.
 @param len Destination for length of resulting path string.  Result will include NULL-terminator in count--that is, &quot;len&quot;
 will be strlen(pathbuf) + 1.
 @return 0 for success or an error.
 */</span>
<span class="enscript-type">int</span> 	vn_getpath_fsenter(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">char</span> *pathbuf, <span class="enscript-type">int</span> *len);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_UPDATE_PARENT</span>	0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_UPDATE_NAME</span>	0x02
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_UPDATE_CACHE</span>	0x04
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_UPDATE_PURGE</span>	0x08
<span class="enscript-comment">/*!
 @function vnode_update_identity
 @abstract Update vnode data associated with the vfs cache.
 @discussion The vfs namecache is central to tracking vnode-identifying data and to locating files on the system.  vnode_update_identity()
 is used to update vnode data associated with the cache. It can set a vnode's parent and/or name (also potentially set by vnode_create())
 or flush cache data.
 @param vp The vnode whose information to update.
 @param dvp Parent to set on the vnode if VNODE_UPDATE_PARENT is used.
 @param name Name to set in the cache for the vnode if VNODE_UPDATE_NAME is used.  The buffer passed in can be subsequently freed, as the cache
 does its own name storage.  String should be NULL-terminated unless length and hash value are specified.
 @param name_len Length of name, if known.  Passing 0 causes the cache to determine the length itself.
 @param name_hashval Hash value of name, if known.  Passing 0 causes the cache to hash the name itself.
 @param flags VNODE_UPDATE_PARENT: set parent.  VNODE_UPDATE_NAME: set name.  VNODE_UPDATE_CACHE: flush cache entries for hard links
 associated with this file.  VNODE_UPDATE_PURGE: flush cache entries for hard links and children of this file.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_update_identity(vnode_t vp, vnode_t dvp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> name_len, uint32_t name_hashval, <span class="enscript-type">int</span> flags);

<span class="enscript-comment">/*!
 @function vn_bwrite
 @abstract System-provided implementation of &quot;bwrite&quot; vnop.
 @discussion This routine is available for filesystems which do not want to implement their own &quot;bwrite&quot; vnop.  It just calls
 buf_bwrite() without modifying its arguments.
 @param ap Standard parameters to a bwrite vnop.
 @return Results of buf_bwrite directly.
 */</span>
<span class="enscript-type">int</span>	vn_bwrite(<span class="enscript-type">struct</span> vnop_bwrite_args *ap);

<span class="enscript-comment">/*!
 @function vnode_authorize
 @abstract Authorize a kauth-style action on a vnode.
 @discussion Operations on dead vnodes are always allowed (though never do anything).
 @param vp Vnode on which to authorize action.
 @param dvp Parent of &quot;vp,&quot; can be NULL.
 @param action Action to authorize, e.g. KAUTH_VNODE_READ_DATA.  See bsd/sys/kauth.h.
 @param ctx Context for which to authorize actions.
 @return EACCESS if permission is denied.  0 if operation allowed.  Various errors from lower layers.
 */</span>
<span class="enscript-type">int</span>	vnode_authorize(vnode_t <span class="enscript-comment">/*vp*/</span>, vnode_t <span class="enscript-comment">/*dvp*/</span>, kauth_action_t, vfs_context_t);

<span class="enscript-comment">/*!
 @function vnode_authattr
 @abstract Given a vnode_attr structure, determine what kauth-style actions must be authorized in order to set those attributes.
 @discussion vnode_authorize requires kauth-style actions; if we want to set a vnode_attr structure on a vnode, we need to translate
 the set of attributes to a set of kauth-style actions.  This routine will return errors for certain obviously disallowed, or 
 incoherent, actions.
 @param vp The vnode on which to authorize action.
 @param vap Pointer to vnode_attr struct containing desired attributes to set and their values.
 @param actionp Destination for set of actions to authorize
 @param ctx Context for which to authorize actions.
 @return 0 (and a result in &quot;actionp&quot; for success.  Otherwise, an error code.
 */</span>
<span class="enscript-type">int</span>	vnode_authattr(vnode_t, <span class="enscript-type">struct</span> vnode_attr *, kauth_action_t *, vfs_context_t);

<span class="enscript-comment">/*!
 @function vnode_authattr_new
 @abstract Initialize and validate file creation parameters with respect to the current context.
 @discussion vnode_authattr_new() will fill in unitialized values in the vnode_attr struct with defaults, and will validate the structure
 with respect to the current context for file creation.
 @param dvp The directory in which creation will occur.
 @param vap Pointer to vnode_attr struct containing desired attributes to set and their values.
 @param noauth If 1, treat the caller as the superuser, i.e. do not check permissions.
 @param ctx Context for which to authorize actions.
 @return KAUTH_RESULT_ALLOW for success, an error to indicate invalid or disallowed attributes.
 */</span>
<span class="enscript-type">int</span>	vnode_authattr_new(vnode_t <span class="enscript-comment">/*dvp*/</span>, <span class="enscript-type">struct</span> vnode_attr *, <span class="enscript-type">int</span> <span class="enscript-comment">/*noauth*/</span>, vfs_context_t);

<span class="enscript-comment">/*!
 @function vnode_close
 @abstract Close a file as opened with vnode_open().
 @discussion vnode_close() drops the refcount (persistent reference) picked up in vnode_open() and calls down to the filesystem with VNOP_CLOSE.  It should
 be called with both an iocount and a refcount on the vnode and will drop both.
 @param vp The vnode to close.
 @param flags Flags to close: FWASWRITTEN indicates that the file was written to.
 @param ctx Context against which to validate operation.
 @return 0 for success or an error from the filesystem.
 */</span>
errno_t <span class="enscript-function-name">vnode_close</span>(vnode_t, <span class="enscript-type">int</span>, vfs_context_t);

<span class="enscript-comment">/*!
 @function vn_getpath
 @abstract Construct the path to a vnode.
 @discussion Paths to vnodes are not always straightforward: a file with multiple hard-links will have multiple pathnames,
 and it is sometimes impossible to determine a vnode's full path.  vn_getpath() will not enter the filesystem.
 @param vp The vnode whose path to obtain.
 @param pathbuf Destination for pathname; should be of size MAXPATHLEN
 @param len Destination for length of resulting path string.  Result will include NULL-terminator in count--that is, &quot;len&quot;
 will be strlen(pathbuf) + 1.
 @return 0 for success or an error code.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">vn_getpath</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">char</span> *pathbuf, <span class="enscript-type">int</span> *len);

<span class="enscript-comment">/*!
 @function vnode_notify
 @abstract Send a notification up to VFS.  
 @param vp Vnode for which to provide notification.
 @param vap Attributes for that vnode, to be passed to fsevents.
 @discussion Filesystem determines which attributes to pass up using 
 vfs_get_notify_attributes(&amp;vap).  The most specific events possible should be passed,
 e.g. VNODE_EVENT_FILE_CREATED on a directory rather than just VNODE_EVENT_WRITE, but
 a less specific event can be passed up if more specific information is not available.
 Will not reenter the filesystem.
 @return 0 for success, else an error code.
 */</span> 
<span class="enscript-type">int</span> 	vnode_notify(vnode_t, uint32_t, <span class="enscript-type">struct</span> vnode_attr*);

<span class="enscript-comment">/*!
 @function vfs_get_notify_attributes
 @abstract Determine what attributes are required to send up a notification with vnode_notify().
 @param vap Structure to initialize and activate required attributes on.
 @discussion Will not reenter the filesystem.
 @return 0 for success, nonzero for error (currently always succeeds).
 */</span> 
<span class="enscript-type">int</span>	vfs_get_notify_attributes(<span class="enscript-type">struct</span> vnode_attr *vap);

<span class="enscript-comment">/*
 * Flags for the vnode_lookup and vnode_open
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_LOOKUP_NOFOLLOW</span>		0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_LOOKUP_NOCROSSMOUNT</span>	0x02
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNODE_LOOKUP_CROSSMOUNTNOWAIT</span>	0x04
<span class="enscript-comment">/*!
 @function vnode_lookup
 @abstract Convert a path into a vnode.
 @discussion This routine is a thin wrapper around xnu-internal lookup routines; if successful, 
 it returns with an iocount held on the resulting vnode which must be dropped with vnode_put().
 @param path Path to look up.
 @param flags VNODE_LOOKUP_NOFOLLOW: do not follow symbolic links.  VNODE_LOOKUP_NOCROSSMOUNT: do not cross mount points.
 @return Results 0 for success or an error code.
 */</span>
errno_t <span class="enscript-function-name">vnode_lookup</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vnode_t *, vfs_context_t);

<span class="enscript-comment">/*!
 @function vnode_open
 @abstract Open a file identified by a path--roughly speaking an in-kernel open(2).
 @discussion If vnode_open() succeeds, it returns with both an iocount and a usecount on the returned vnode.  These must 
 be released eventually; the iocount should be released with vnode_put() as soon as any initial operations
 on the vnode are over, whereas the usecount should be released via vnode_close().
 @param path Path to look up.
 @param fmode e.g. O_NONBLOCK, O_APPEND; see bsd/sys/fcntl.h.
 @param cmode Permissions with which to create file if it does not exist.
 @param flags Same as vnode_lookup().
 @param vpp Destination for vnode.
 @param ctx Context with which to authorize open/creation.
 @return 0 for success or an error code.
 */</span>
errno_t <span class="enscript-function-name">vnode_open</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, vnode_t *, vfs_context_t);

<span class="enscript-comment">/*
 * exported vnode operations
 */</span>

<span class="enscript-comment">/*!
 @function vnode_iterate
 @abstract Perform an operation on (almost) all vnodes from a given mountpoint.
 @param mp Mount whose vnodes to operate on.
 @param flags
 VNODE_RELOAD			Mark inactive vnodes for recycle.
 VNODE_WAIT			
 VNODE_WRITEABLE 		Only examine vnodes with writes in progress.
 VNODE_WITHID			No effect.
 VNODE_NOLOCK_INTERNAL	No effect.
 VNODE_NODEAD			No effect.
 VNODE_NOSUSPEND		No effect.
 VNODE_ITERATE_ALL 		No effect.
 VNODE_ITERATE_ACTIVE 	No effect.
 VNODE_ITERATE_INACTIVE	No effect.
 
 @param callout Function to call on each vnode.
 @param arg Argument which will be passed to callout along with each vnode.
 @return Zero for success, else an error code.  Will return 0 immediately if there are no vnodes hooked into the mount.
 @discussion Skips vnodes which are dead, in the process of reclaim, suspended, or of type VNON.
 */</span>
<span class="enscript-type">int</span>	vnode_iterate(<span class="enscript-type">struct</span> mount *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> (*)(<span class="enscript-type">struct</span> vnode *, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *);

<span class="enscript-comment">/*
 * flags passed into vnode_iterate
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_RELOAD</span>			0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_WAIT</span>				0x02
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_WRITEABLE</span> 		0x04
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_WITHID</span>			0x08
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_NOLOCK_INTERNAL</span>	0x10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_NODEAD</span>			0x20
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_NOSUSPEND</span>			0x40
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ITERATE_ALL</span> 		0x80
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ITERATE_ACTIVE</span> 	0x100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ITERATE_INACTIVE</span>	0x200
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ALWAYS</span>		0x400
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_DRAINO</span>		0x800
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>

<span class="enscript-comment">/*
 * return values from callback
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_RETURNED</span>		0	<span class="enscript-comment">/* done with vnode, reference can be dropped */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_RETURNED_DONE</span>	1	<span class="enscript-comment">/* done with vnode, reference can be dropped, terminate iteration */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_CLAIMED</span>		2	<span class="enscript-comment">/* don't drop reference */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_CLAIMED_DONE</span>	3	<span class="enscript-comment">/* don't drop reference, terminate iteration */</span>

<span class="enscript-comment">/*!
 @function vn_revoke
 @abstract Invalidate all references to a vnode.
 @discussion Reclaims the vnode, giving it deadfs vnops (though not halting operations which are already in progress).  
 Also reclaims all aliased vnodes (important for devices).  People holding usecounts on the vnode, e.g. processes
 with the file open, will find that all subsequent operations but closing the file fail.
 @param vp The vnode to revoke.
 @param flags Unused.
 @param ctx Context against which to validate operation.
 @return 0 always.
 */</span>
<span class="enscript-type">int</span>	vn_revoke(vnode_t vp, <span class="enscript-type">int</span> flags, vfs_context_t);

<span class="enscript-comment">/* namecache function prototypes */</span>
<span class="enscript-comment">/*!
 @function cache_lookup
 @abstract Check for a filename in a directory using the VFS name cache.
 @discussion cache_lookup() will flush negative cache entries and return 0 if the operation of the cn_nameiop is CREATE or RENAME.
 Often used from the filesystem during a lookup vnop.  The filesystem will be called to if there is a negative cache entry for a file,
 so it can make sense to initially check for negative entries (and possibly lush them).
 @param dvp Directory in which lookup is occurring.
 @param vpp Destination for vnode pointer.
 @param cnp Various data about lookup, e.g. filename and intended operation.
 @return ENOENT: the filesystem has previously added a negative entry with cache_enter() to indicate that there is no
 file of the given name in &quot;dp.&quot;  -1: successfully found a cached vnode (vpp is set).  0: No data in the cache, or operation is CRETE/RENAME.
 */</span>
<span class="enscript-type">int</span>	cache_lookup(vnode_t dvp, vnode_t *vpp,	<span class="enscript-type">struct</span> componentname *cnp);

<span class="enscript-comment">/*!
 @function cache_enter
 @abstract Add a (name,vnode) entry to the VFS namecache.
 @discussion Generally used to add a cache entry after a successful filesystem-level lookup or to add a 
 negative entry after one which did not find its target.
 @param dvp Directory in which file lives.
 @param vp File to add to cache. A non-NULL vp is stored for rapid access; a NULL vp indicates 
 that there is no such file in the directory and speeds future failed lookups.
 @param cnp Various data about lookup, e.g. filename and intended operation.
 @return void.  
 */</span>
<span class="enscript-type">void</span>	cache_enter(vnode_t dvp, vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp);

<span class="enscript-comment">/*!
 @function cache_purge
 @abstract Remove all data relating to a vnode from the namecache.
 @discussion Will flush all hardlinks to the vnode as well as all children (should any exist).  Logical 
 to use when cached data about a vnode becomes invalid, for instance in an unlink.
 @param vp The vnode to purge.
 @return void.  
 */</span>
<span class="enscript-type">void</span>	cache_purge(vnode_t vp);

<span class="enscript-comment">/*!
 @function cache_purge_negatives
 @abstract Remove all negative cache entries which are children of a given vnode.
 @discussion Appropriate to use when negative cache information for a directory could have
 become invalid, e.g. after file creation.
 @param vp The vnode whose negative children to purge.
 @return void.  
 */</span>
<span class="enscript-type">void</span>	cache_purge_negatives(vnode_t vp);


<span class="enscript-comment">/*
 * Global string-cache routines.  You can pass zero for nc_hash
 * if you don't know it (add_name() will then compute the hash).
 * There are no flags for now but maybe someday.
 */</span>
<span class="enscript-comment">/*!
 @function vfs_addname
 @abstract Deprecated
 @discussion vnode_update_identity() and vnode_create() make vfs_addname() unnecessary for kexts.
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">vfs_addname</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, uint32_t len, uint32_t nc_hash, uint32_t flags);

<span class="enscript-comment">/*!
 @function vfs_removename
 @abstract Deprecated
 @discussion vnode_update_identity() and vnode_create() make vfs_addname() unnecessary for kexts.
 */</span>
<span class="enscript-type">int</span>   <span class="enscript-function-name">vfs_removename</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name);

<span class="enscript-comment">/*!
 @function vcount
 @abstract Count total references to a given file, disregarding &quot;kusecount&quot; (event listener, as with O_EVTONLY) references.
 @discussion For a regular file, just return (usecount-kusecount); for device files, return the sum over all
 vnodes 'v' which reference that device of (usecount(v) - kusecount(v)).  Note that this is merely a snapshot and could be
 invalid by the time the caller checks the result.
 @param vp The vnode whose references to count.
 @return Count of references.
 */</span>
<span class="enscript-type">int</span>	vcount(vnode_t vp);

<span class="enscript-comment">/*!
 @function vn_path_package_check
 @abstract Figure out if a path corresponds to a Mac OS X package.
 @discussion  Determines if the extension on a path is a known OS X extension type.
 @param vp Unused.
 @param path Path to check.
 @param pathlen Size of path buffer.
 @param component Set to index of start of last path component if the path is found to be a package. Set to -1 if
 the path is not a known package type.
 @return 0 unless some parameter was invalid, in which case EINVAL is returned.  Determine package-ness by checking
 what *component is set to.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">vn_path_package_check</span>(vnode_t vp, <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> pathlen, <span class="enscript-type">int</span> *component);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
<span class="enscript-comment">/*!
  @function vn_searchfs_inappropriate_name
  @abstract Figure out if the component is inappropriate for a SearchFS query.
  @param name component to check
  @param len length of component.
  @return 0 if no match, 1 if inappropriate. 
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">vn_searchfs_inappropriate_name</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> len); 
#<span class="enscript-reference">endif</span> 

<span class="enscript-comment">/*!
 @function vn_rdwr
 @abstract Read from or write to a file.
 @discussion vn_rdwr() abstracts the details of constructing a uio and picking a vnode operation to allow
 simple in-kernel file I/O.
 @param rw UIO_READ for a read, UIO_WRITE for a write.
 @param vp The vnode on which to perform I/O.
 @param base Start of buffer into which to read or from which to write data.
 @param len Length of buffer.
 @param offset Offset within the file at which to start I/O.
 @param segflg What kind of address &quot;base&quot; is.   See uio_seg definition in sys/uio.h.  UIO_SYSSPACE for kernelspace, UIO_USERSPACE for userspace.
 UIO_USERSPACE32 and UIO_USERSPACE64 are in general preferred, but vn_rdwr will make sure that has the correct address sizes.
 @param ioflg Defined in vnode.h, e.g. IO_NOAUTH, IO_NOCACHE.
 @param cred Credential to pass down to filesystem for authentication.
 @param aresid Destination for amount of requested I/O which was not completed, as with uio_resid().
 @param p Process requesting I/O.
 @return 0 for success; errors from filesystem, and EIO if did not perform all requested I/O and the &quot;aresid&quot; parameter is NULL.
 */</span>
<span class="enscript-type">int</span> 	vn_rdwr(<span class="enscript-type">enum</span> uio_rw, vnode_t, caddr_t, <span class="enscript-type">int</span>, off_t, <span class="enscript-type">enum</span> uio_seg, <span class="enscript-type">int</span>, kauth_cred_t, <span class="enscript-type">int</span> *, proc_t);

<span class="enscript-comment">/*!
 @function vnode_getname
 @abstract Get the name of a vnode from the VFS namecache.
 @discussion Not all vnodes have names, and vnode names can change (notably, hardlinks).  Use this routine at your own risk.
 The string is returned with a refcount incremented in the cache; callers must call vnode_putname() to release that reference.
 @param vp The vnode whose name to grab.
 @return The name, or NULL if unavailable.
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*vnode_getname(vnode_t vp);

<span class="enscript-comment">/*!
 @function vnode_putname
 @abstract Release a reference on a name from the VFS cache.
 @discussion Should be called on a string obtained with vnode_getname().
 @param name String to release.
 @return void.
 */</span>
<span class="enscript-type">void</span>	vnode_putname(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name);

<span class="enscript-comment">/*!
 @function vnode_getparent
 @abstract Get an iocount on the parent of a vnode.
 @discussion A vnode's parent may change over time or be reclaimed, so vnode_getparent() may return different
 results at different times (e.g. a multiple-hardlink file). The parent is returned with an iocount which must
 subsequently be dropped with vnode_put().
 @param vp The vnode whose parent to grab.
 @return Parent if available, else NULL.
 */</span>
vnode_t	vnode_getparent(vnode_t vp);

<span class="enscript-comment">/*!
 @function vnode_setdirty
 @abstract Mark the vnode as having data or metadata that needs to be written out during reclaim
 @discussion The vnode should be marked as dirty anytime a file system defers flushing of data or meta-data associated with it. 
 @param the vnode to mark as dirty
 @return 0 if successful else an error code.
 */</span>
<span class="enscript-type">int</span>	vnode_setdirty(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_cleardirty
 @abstract Mark the vnode as clean i.e. all its data or metadata has been flushed
 @discussion The vnode should be marked as clean whenever the file system is done flushing data or meta-data associated with it.
 @param the vnode to clear as being dirty
 @return 0 if successful else an error code.
 */</span>
<span class="enscript-type">int</span>	vnode_cleardirty(vnode_t);

<span class="enscript-comment">/*!
 @function vnode_isdirty
 @abstract Determine if a vnode is marked dirty.
 @discussion The vnode should be marked as clean whenever the file system is done flushing data or meta-data associated with it.
 @param vp the vnode to test.
 @return Non-zero if the vnode is dirty, 0 otherwise.
 */</span>
<span class="enscript-type">int</span>	vnode_isdirty(vnode_t);



#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
<span class="enscript-comment">/*! 
 @function vnode_lookup_continue_needed
 @abstract Determine whether vnode needs additional processing in VFS before being opened.
 @discussion If result is zero, filesystem can open this vnode.  If result is nonzero,
 additional processing is needed in VFS (e.g. symlink, mountpoint).  Nonzero results should
 be passed up to VFS.
 @param vp Vnode to consider opening (found by filesystem).
 @param cnp Componentname as passed to filesystem from VFS.
 @result 0 to indicate that a vnode can be opened, or an error that should be passed up to VFS.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">vnode_lookup_continue_needed</span>(vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp);

<span class="enscript-comment">/*!
 @function vnode_istty
 @abstract Determine if the given vnode represents a tty device.
 @param vp Vnode to examine.
 @result Non-zero to indicate that the vnode represents a tty device. Zero otherwise.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">vnode_istty</span>(vnode_t vp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
<span class="enscript-comment">/* Not in export list so can be private */</span>
<span class="enscript-type">struct</span> stat;
<span class="enscript-type">int</span>	vn_stat(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">void</span> * sb, kauth_filesec_t *xsec, <span class="enscript-type">int</span> isstat64, vfs_context_t ctx);
<span class="enscript-type">int</span>	vn_stat_noauth(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">void</span> * sb, kauth_filesec_t *xsec, <span class="enscript-type">int</span> isstat64, vfs_context_t ctx);
<span class="enscript-type">int</span>	vaccess(mode_t file_mode, uid_t uid, gid_t gid,
	  		mode_t acc_mode, kauth_cred_t cred);
<span class="enscript-type">int</span>	check_mountedon(dev_t dev, <span class="enscript-type">enum</span> vtype type, <span class="enscript-type">int</span>  *errorp);
<span class="enscript-type">int</span> <span class="enscript-function-name">vn_getcdhash</span>(<span class="enscript-type">struct</span> vnode *vp, off_t offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *cdhash);
<span class="enscript-type">void</span>	vnode_reclaim(vnode_t);
vfs_context_t <span class="enscript-function-name">vfs_context_kernel</span>(<span class="enscript-type">void</span>);		<span class="enscript-comment">/* get from 1st kernel thread */</span>
<span class="enscript-type">int</span>	vfs_context_issuser(vfs_context_t);
vnode_t <span class="enscript-function-name">vfs_context_cwd</span>(vfs_context_t);
vnode_t	current_rootdir(<span class="enscript-type">void</span>);
vnode_t	current_workingdir(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	*vnode_vfsfsprivate(vnode_t);
<span class="enscript-type">struct</span> vfsstatfs *<span class="enscript-function-name">vnode_vfsstatfs</span>(vnode_t);
uint32_t <span class="enscript-function-name">vnode_vfsvisflags</span>(vnode_t);
uint32_t <span class="enscript-function-name">vnode_vfscmdflags</span>(vnode_t);
<span class="enscript-type">int</span>	vnode_is_openevt(vnode_t);
<span class="enscript-type">void</span>	vnode_set_openevt(vnode_t);
<span class="enscript-type">void</span>	vnode_clear_openevt(vnode_t);
<span class="enscript-type">int</span>	vnode_isstandard(vnode_t);
<span class="enscript-type">int</span>	vnode_makeimode(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">enum</span> vtype	vnode_iftovt(<span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	vnode_vttoif(<span class="enscript-type">enum</span> vtype);
<span class="enscript-type">int</span> 	vnode_isshadow(vnode_t);
boolean_t <span class="enscript-function-name">vnode_on_reliable_media</span>(vnode_t);
<span class="enscript-comment">/*
 * Indicate that a file has multiple hard links.  VFS will always call
 * VNOP_LOOKUP on this vnode.  Volfs will always ask for it's parent
 * object ID (instead of using the v_parent pointer).
 */</span>
vnode_t <span class="enscript-function-name">vnode_parent</span>(vnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_setparent</span>(vnode_t, vnode_t);
<span class="enscript-comment">/*!
 @function vnode_getname_printable
 @abstract Get a non-null printable name of a vnode.
 @Used to make sure a printable name is returned for all vnodes. If a name exists or can be artificially created, the routine creates a new entry in the VFS namecache. Otherwise, the function returns an artificially created vnode name which is safer and easier to use. vnode_putname_printable() should be used to release names obtained by this routine. 
 @param vp The vnode whose name to grab.
 @return The printable name.
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">vnode_getname_printable</span>(vnode_t vp);

<span class="enscript-comment">/*!
 @function vnode_putname_printable
 @abstract Release a reference on a name from the VFS cache if it was added by the matching vnode_getname_printable() call.
 @param name String to release.
 @return void.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_putname_printable</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name);
<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_setname</span>(vnode_t, <span class="enscript-type">char</span> *);
<span class="enscript-type">int</span> <span class="enscript-function-name">vnode_isnoflush</span>(vnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_setnoflush</span>(vnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_clearnoflush</span>(vnode_t);
<span class="enscript-comment">/* XXX temporary until we can arrive at a KPI for NFS, Seatbelt */</span>
thread_t <span class="enscript-function-name">vfs_context_thread</span>(vfs_context_t);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
vnode_t <span class="enscript-function-name">vnode_mountdevvp</span>(vnode_t);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>

<span class="enscript-comment">/*
 * Helper functions for implementing VNOP_GETATTRLISTBULK for a filesystem
 */</span>

<span class="enscript-comment">/*!
 @function vfs_setup_vattr_from_attrlist
 @abstract Setup a vnode_attr structure given an attrlist structure.
 @Used by a VNOP_GETATTRLISTBULK implementation to setup a vnode_attr structure from a attribute list. It also returns the fixed size of the attribute buffer required.
 @param alp Pointer to attribute list structure.
 @param vap Pointer to vnode_attr structure.
 @param obj_vtype Type of object - If VNON is passed, then the type is ignored and common, file and dir attrs are used to initialise the vattrs. If set to VDIR, only common and directory attributes are used. For all other types, only common and file attrbutes are used.
 @param attr_fixed_sizep. Returns the fixed length required in the attrbute buffer for the object. NULL should be passed if it is not required.
 @param ctx vfs context of caller.
 @return error.
 */</span>
errno_t <span class="enscript-function-name">vfs_setup_vattr_from_attrlist</span>(<span class="enscript-type">struct</span> attrlist * <span class="enscript-comment">/* alp */</span>, <span class="enscript-type">struct</span> vnode_attr * <span class="enscript-comment">/* vap */</span>, <span class="enscript-type">enum</span> vtype <span class="enscript-comment">/* obj_vtype */</span>, ssize_t * <span class="enscript-comment">/* attr_fixed_sizep */</span>, vfs_context_t <span class="enscript-comment">/* ctx */</span>);

<span class="enscript-comment">/*!
 @function vfs_attr_pack
 @abstract Pack a vnode_attr structure into a buffer in the same format as getattrlist(2).
 @Used by a VNOP_GETATTRLISTBULK implementation to pack data provided into a vnode_attr structure into a buffer the way getattrlist(2) does.
 @param vp If available, the vnode for which the attributes are being given, NULL if vnode is not available (which will usually be the case for a VNOP_GETATTRLISTBULK implementation.
 @param auio - a uio_t initialised with one iovec..
 @param alp - Pointer to an attrlist structure.
 @param options - options for call (same as options for getattrlistbulk(2)).
 @param vap Pointer to a filled in vnode_attr structure. Data from the vnode_attr structure will be used to copy and lay out the data in the required format for getatrlistbulk(2) by this function.
 @param fndesc Currently unused
 @param ctx vfs context of caller.
 @return error.
 */</span>
errno_t <span class="enscript-function-name">vfs_attr_pack</span>(vnode_t <span class="enscript-comment">/* vp */</span>, uio_t <span class="enscript-comment">/* uio */</span>, <span class="enscript-type">struct</span> attrlist * <span class="enscript-comment">/* alp */</span>, uint64_t <span class="enscript-comment">/* options */</span>, <span class="enscript-type">struct</span> vnode_attr * <span class="enscript-comment">/* vap */</span>, <span class="enscript-type">void</span> * <span class="enscript-comment">/* fndesc */</span>, vfs_context_t <span class="enscript-comment">/* ctx */</span>);

__END_DECLS

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_VNODE_H_ */</span>
</pre>
<hr />
</body></html>