<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mcache.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mcache.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2006-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_SYS_MCACHE_H</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_SYS_MCACHE_H</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>

#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">__cplusplus</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ASSERT</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ASSERT</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VERIFY</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">VERIFY</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Unlike VERIFY(), ASSERT() is evaluated only in DEBUG build.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VERIFY</span>(EX)	((void)((EX) || assfail(#EX, __FILE__, __LINE__)))
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ASSERT</span>(EX)	VERIFY(EX)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ASSERT</span>(EX)	((void)0)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Compile time assert; this should be on its own someday.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">_CASSERT</span>(x)	\
	<span class="enscript-keyword">switch</span> (0) { <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>: <span class="enscript-keyword">case</span> (x): ; }

<span class="enscript-comment">/*
 * Atomic macros; these should be on their own someday.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_add_16_ov</span>(a, n)						\
	((u_int16_t) OSAddAtomic16(n, (<span class="enscript-type">volatile</span> SInt16 *)a))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_add_16</span>(a, n)						\
	((<span class="enscript-type">void</span>) atomic_add_16_ov(a, n))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_add_32_ov</span>(a, n)						\
	((u_int32_t) OSAddAtomic(n, (<span class="enscript-type">volatile</span> SInt32 *)a))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_add_32</span>(a, n)						\
	((<span class="enscript-type">void</span>) atomic_add_32_ov(a, n))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_add_64_ov</span>(a, n)						\
	((u_int64_t) OSAddAtomic64(n, (<span class="enscript-type">volatile</span> SInt64 *)a))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_add_64</span>(a, n)						\
	((<span class="enscript-type">void</span>) atomic_add_64_ov(a, n))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_set_64</span>(a, n) do {					\
	<span class="enscript-keyword">while</span> (!OSCompareAndSwap64(*a, n, (<span class="enscript-type">volatile</span> UInt64 *)a))	\
		;							\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_get_64</span>(n, a) do {					\
	(n) = *(a);							\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_get_64</span>(n, a) do {					\
	(n) = atomic_add_64_ov(a, 0);					\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __LP64__ */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_or_8_ov</span>(a, n)						\
	((u_int8_t) OSBitOrAtomic8(n, (<span class="enscript-type">volatile</span> UInt8 *)a))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_or_8</span>(a, n)						\
	((<span class="enscript-type">void</span>) atomic_or_8_ov(a, n))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_bitset_8</span>(a, n)						\
	atomic_or_8(a, n)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_or_16_ov</span>(a, n)						\
	((u_int16_t) OSBitOrAtomic16(n, (<span class="enscript-type">volatile</span> UInt16 *)a))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_or_16</span>(a, n)						\
	((<span class="enscript-type">void</span>) atomic_or_16_ov(a, n))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_bitset_16</span>(a, n)						\
	atomic_or_16(a, n)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_or_32_ov</span>(a, n)						\
	((u_int32_t) OSBitOrAtomic(n, (<span class="enscript-type">volatile</span> UInt32 *)a))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_or_32</span>(a, n)						\
	((<span class="enscript-type">void</span>) atomic_or_32_ov(a, n))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_bitset_32</span>(a, n)						\
	atomic_or_32(a, n)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_and_8_ov</span>(a, n)						\
	((u_int8_t) OSBitAndAtomic8(n, (<span class="enscript-type">volatile</span> UInt8 *)a))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_and_8</span>(a, n)						\
	((<span class="enscript-type">void</span>) atomic_and_8_ov(a, n))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_bitclear_8</span>(a, n)						\
	atomic_and_8(a, ~(n))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_and_16_ov</span>(a, n)						\
	((u_int16_t) OSBitAndAtomic16(n, (<span class="enscript-type">volatile</span> UInt16 *)a))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_and_16</span>(a, n)						\
	((<span class="enscript-type">void</span>) atomic_and_16_ov(a, n))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_bitclear_16</span>(a, n)					\
	atomic_and_16(a, ~(n))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_and_32_ov</span>(a, n)						\
	((u_int32_t) OSBitAndAtomic(n, (<span class="enscript-type">volatile</span> UInt32 *)a))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_and_32</span>(a, n)						\
	((<span class="enscript-type">void</span>) atomic_and_32_ov(a, n))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">atomic_bitclear_32</span>(a, n)					\
	atomic_and_32(a, ~(n))

<span class="enscript-comment">/*
 * Use CPU_CACHE_LINE_SIZE instead of MAX_CPU_CACHE_LINE_SIZE, unless
 * wasting space is of no concern.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_CPU_CACHE_LINE_SIZE</span>	64
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CPU_CACHE_LINE_SIZE</span>	mcache_cache_line_size()

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IS_P2ALIGNED</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IS_P2ALIGNED</span>(v, a) \
	((((uintptr_t)(v)) &amp; ((uintptr_t)(a) - 1)) == 0)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IS_P2ALIGNED */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">P2ROUNDUP</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">P2ROUNDUP</span>(x, align) \
	(-(-((uintptr_t)(x)) &amp; -((uintptr_t)align)))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* P2ROUNDUP */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">P2ROUNDDOWN</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">P2ROUNDDOWN</span>(x, align) \
	(((uintptr_t)(x)) &amp; ~((uintptr_t)(align) - 1))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* P2ROUNDDOWN */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCACHE_FREE_PATTERN</span>		0xdeadbeefdeadbeefULL
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCACHE_UNINITIALIZED_PATTERN</span>	0xbaddcafebaddcafeULL

<span class="enscript-comment">/*
 * mcache allocation request flags.
 *
 * MCR_NOSLEEP and MCR_FAILOK are mutually exclusive.  The latter is used
 * by the mbuf allocator to handle the implementation of several caches that
 * involve multiple layers of mcache.  It implies a best effort blocking
 * allocation request; if the request cannot be satisfied, the caller will
 * be blocked until further notice, similar to MCR_SLEEP, except that upon
 * a wake up it will return immediately to the caller regardless of whether
 * the request can been fulfilled.
 *
 * MCR_TRYHARD implies a non-blocking allocation request, regardless of
 * whether MCR_NOSLEEP is set.  It informs the allocator that the request
 * should not cause the calling thread to block, and that it must have
 * exhausted all possible schemes to fulfill the request, including doing
 * reclaims and/or purges, before returning to the caller.
 *
 * Regular mcache clients should only use MCR_SLEEP or MCR_NOSLEEP.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCR_SLEEP</span>	0x0000		<span class="enscript-comment">/* same as M_WAITOK */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCR_NOSLEEP</span>	0x0001		<span class="enscript-comment">/* same as M_NOWAIT */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCR_FAILOK</span>	0x0100		<span class="enscript-comment">/* private, for internal use only */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCR_TRYHARD</span>	0x0200		<span class="enscript-comment">/* private, for internal use only */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCR_USR1</span>	0x1000		<span class="enscript-comment">/* private, for internal use only */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCR_NONBLOCKING</span>	(MCR_NOSLEEP | MCR_FAILOK | MCR_TRYHARD)

<span class="enscript-comment">/*
 * Generic one-way linked list element structure.  This is used to handle
 * mcache_alloc_ext() requests in order to chain the allocated objects
 * together before returning them to the caller.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mcache_obj {
	<span class="enscript-type">struct</span> mcache_obj	*obj_next;
} mcache_obj_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mcache_bkt {
	<span class="enscript-type">void</span>		*bkt_next;	<span class="enscript-comment">/* next bucket in list */</span>
	<span class="enscript-type">void</span>		*bkt_obj[1];	<span class="enscript-comment">/* one or more objects */</span>
} mcache_bkt_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mcache_bktlist {
	mcache_bkt_t	*bl_list;	<span class="enscript-comment">/* bucket list */</span>
	u_int32_t	bl_total;	<span class="enscript-comment">/* number of buckets */</span>
	u_int32_t	bl_min;		<span class="enscript-comment">/* min since last update */</span>
	u_int32_t	bl_reaplimit;	<span class="enscript-comment">/* max reapable buckets */</span>
	u_int64_t	bl_alloc;	<span class="enscript-comment">/* allocations from this list */</span>
} mcache_bktlist_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mcache_bkttype {
	<span class="enscript-type">int</span>		bt_bktsize;	<span class="enscript-comment">/* bucket size (number of elements) */</span>
	size_t		bt_minbuf;	<span class="enscript-comment">/* all smaller buffers qualify */</span>
	size_t		bt_maxbuf;	<span class="enscript-comment">/* no larger bfufers qualify */</span>
	<span class="enscript-type">struct</span> mcache	*bt_cache;	<span class="enscript-comment">/* bucket cache */</span>
} mcache_bkttype_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mcache_cpu {
	decl_lck_mtx_data(, cc_lock);
	mcache_bkt_t	*cc_filled;	<span class="enscript-comment">/* the currently filled bucket */</span>
	mcache_bkt_t	*cc_pfilled;	<span class="enscript-comment">/* the previously filled bucket */</span>
	u_int64_t	cc_alloc;	<span class="enscript-comment">/* allocations from this cpu */</span>
	u_int64_t	cc_free;	<span class="enscript-comment">/* frees to this cpu */</span>
	<span class="enscript-type">int</span>		cc_objs;	<span class="enscript-comment">/* number of objects in filled bkt */</span>
	<span class="enscript-type">int</span>		cc_pobjs;	<span class="enscript-comment">/* number of objects in previous bkt */</span>
	<span class="enscript-type">int</span>		cc_bktsize;	<span class="enscript-comment">/* number of elements in a full bkt */</span>
} __attribute__((aligned(MAX_CPU_CACHE_LINE_SIZE), packed)) mcache_cpu_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-function-name">int</span> (*mcache_allocfn_t)(<span class="enscript-type">void</span> *, mcache_obj_t ***,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*mcache_freefn_t)(<span class="enscript-type">void</span> *, mcache_obj_t *, boolean_t);
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*mcache_auditfn_t)(<span class="enscript-type">void</span> *, mcache_obj_t *, boolean_t);
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*mcache_logfn_t)(u_int32_t, mcache_obj_t *, boolean_t);
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*mcache_notifyfn_t)(<span class="enscript-type">void</span> *, u_int32_t);

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mcache {
	<span class="enscript-comment">/*
	 * Cache properties
	 */</span>
	LIST_ENTRY(mcache) mc_list;	<span class="enscript-comment">/* cache linkage */</span>
	<span class="enscript-type">char</span>		mc_name[32];	<span class="enscript-comment">/* cache name */</span>
	<span class="enscript-type">struct</span> zone	*mc_slab_zone;	<span class="enscript-comment">/* backend zone allocator */</span>
	mcache_allocfn_t mc_slab_alloc;	<span class="enscript-comment">/* slab layer allocate callback */</span>
	mcache_freefn_t	mc_slab_free;	<span class="enscript-comment">/* slab layer free callback */</span>
	mcache_auditfn_t mc_slab_audit;	<span class="enscript-comment">/* slab layer audit callback */</span>
	mcache_logfn_t mc_slab_log;	<span class="enscript-comment">/* slab layer log callback */</span>
	mcache_notifyfn_t mc_slab_notify; <span class="enscript-comment">/* slab layer notify callback */</span>
	<span class="enscript-type">void</span>		*mc_private;	<span class="enscript-comment">/* opaque arg to callbacks */</span>
	size_t		mc_bufsize;	<span class="enscript-comment">/* object size */</span>
	size_t		mc_align;	<span class="enscript-comment">/* object alignment */</span>
	u_int32_t	mc_flags;	<span class="enscript-comment">/* cache creation flags */</span>
	u_int32_t	mc_purge_cnt;	<span class="enscript-comment">/* # of purges requested by slab */</span>
	u_int32_t	mc_enable_cnt;	<span class="enscript-comment">/* # of reenables due to purges */</span>
	u_int32_t	mc_waiter_cnt;	<span class="enscript-comment">/* # of slab layer waiters */</span>
	u_int32_t	mc_wretry_cnt;	<span class="enscript-comment">/* # of wait retries */</span>
	u_int32_t	mc_nwretry_cnt;	<span class="enscript-comment">/* # of no-wait retry attempts */</span>
	u_int32_t	mc_nwfail_cnt;	<span class="enscript-comment">/* # of no-wait retries that failed */</span>
	decl_lck_mtx_data(, mc_sync_lock); <span class="enscript-comment">/* protects purges and reenables */</span>
	lck_attr_t	*mc_sync_lock_attr;
	lck_grp_t	*mc_sync_lock_grp;
	lck_grp_attr_t	*mc_sync_lock_grp_attr;
	<span class="enscript-comment">/*
	 * Keep CPU and buckets layers lock statistics separate.
	 */</span>
	lck_attr_t	*mc_cpu_lock_attr;
	lck_grp_t	*mc_cpu_lock_grp;
	lck_grp_attr_t	*mc_cpu_lock_grp_attr;

	<span class="enscript-comment">/*
	 * Bucket layer common to all CPUs
	 */</span>
	decl_lck_mtx_data(, mc_bkt_lock);
	lck_attr_t	*mc_bkt_lock_attr;
	lck_grp_t	*mc_bkt_lock_grp;
	lck_grp_attr_t  *mc_bkt_lock_grp_attr;
	mcache_bkttype_t *cache_bkttype;	<span class="enscript-comment">/* bucket type */</span>
	mcache_bktlist_t mc_full;		<span class="enscript-comment">/* full buckets */</span>
	mcache_bktlist_t mc_empty;		<span class="enscript-comment">/* empty buckets */</span>
	size_t		mc_chunksize;		<span class="enscript-comment">/* bufsize + alignment */</span>
	u_int32_t	mc_bkt_contention;	<span class="enscript-comment">/* lock contention count */</span>
	u_int32_t	mc_bkt_contention_prev;	<span class="enscript-comment">/* previous snapshot */</span>

	<span class="enscript-comment">/*
	 * Per-CPU layer, aligned at cache line boundary
	 */</span>
	mcache_cpu_t	mc_cpu[1];
} mcache_t;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCACHE_ALIGN</span>	8	<span class="enscript-comment">/* default guaranteed alignment */</span>

<span class="enscript-comment">/* Valid values for mc_flags */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCF_VERIFY</span>	0x00000001	<span class="enscript-comment">/* enable verification */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCF_TRACE</span>	0x00000002	<span class="enscript-comment">/* enable transaction auditing */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCF_NOCPUCACHE</span>	0x00000010	<span class="enscript-comment">/* disable CPU layer caching */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCF_NOLEAKLOG</span>	0x00000100	<span class="enscript-comment">/* disable leak logging */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCF_EXPLEAKLOG</span>	0x00000200	<span class="enscript-comment">/* expose leak info to user space */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCF_DEBUG</span>	(MCF_VERIFY | MCF_TRACE)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCF_FLAGS_MASK</span>	\
	(MCF_DEBUG | MCF_NOCPUCACHE | MCF_NOLEAKLOG | MCF_EXPLEAKLOG)

<span class="enscript-comment">/* Valid values for notify callback */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCN_RETRYALLOC</span>	0x00000001	<span class="enscript-comment">/* Allocation should be retried */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCACHE_STACK_DEPTH</span> 16

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCA_TRN_MAX</span>	2		<span class="enscript-comment">/* Number of transactions to record */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mcache_audit {
	<span class="enscript-type">struct</span> mcache_audit *mca_next;	<span class="enscript-comment">/* next audit struct */</span>
	<span class="enscript-type">void</span>		*mca_addr;	<span class="enscript-comment">/* address of buffer */</span>
	mcache_t	*mca_cache;	<span class="enscript-comment">/* parent cache of the buffer */</span>
	size_t		mca_contents_size; <span class="enscript-comment">/* size of saved contents */</span>
	<span class="enscript-type">void</span>		*mca_contents;	<span class="enscript-comment">/* user-specific saved contents */</span>
	<span class="enscript-type">void</span>		*mca_uptr;	<span class="enscript-comment">/* user-specific pointer */</span>
	uint32_t	mca_uflags;	<span class="enscript-comment">/* user-specific flags */</span>
	uint32_t	mca_next_trn;
	<span class="enscript-type">struct</span> mca_trn {
		<span class="enscript-type">struct</span> thread	*mca_thread;	<span class="enscript-comment">/* thread doing transaction */</span>
		uint32_t	mca_tstamp;
		uint16_t	mca_depth;
		<span class="enscript-type">void</span>		*mca_stack[MCACHE_STACK_DEPTH];
	} mca_trns[MCA_TRN_MAX];
} mcache_audit_t;

__private_extern__ <span class="enscript-type">int</span> assfail(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">void</span> mcache_init(<span class="enscript-type">void</span>);
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mcache_getflags(<span class="enscript-type">void</span>);
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mcache_cache_line_size(<span class="enscript-type">void</span>);
__private_extern__ mcache_t *mcache_create(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, size_t,
    size_t, u_int32_t, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">void</span> *mcache_alloc(mcache_t *, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">void</span> mcache_free(mcache_t *, <span class="enscript-type">void</span> *);
__private_extern__ mcache_t *mcache_create_ext(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, size_t,
    mcache_allocfn_t, mcache_freefn_t, mcache_auditfn_t, mcache_logfn_t,
    mcache_notifyfn_t, <span class="enscript-type">void</span> *, u_int32_t, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">void</span> mcache_destroy(mcache_t *);
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mcache_alloc_ext(mcache_t *, mcache_obj_t **,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">void</span> mcache_free_ext(mcache_t *, mcache_obj_t *);
__private_extern__ <span class="enscript-type">void</span> mcache_reap(<span class="enscript-type">void</span>);
__private_extern__ boolean_t mcache_purge_cache(mcache_t *, boolean_t);
__private_extern__ <span class="enscript-type">void</span> mcache_waiter_inc(mcache_t *);
__private_extern__ <span class="enscript-type">void</span> mcache_waiter_dec(mcache_t *);
__private_extern__ boolean_t mcache_bkt_isempty(mcache_t *);

__private_extern__ <span class="enscript-type">void</span> mcache_buffer_log(mcache_audit_t *, <span class="enscript-type">void</span> *, mcache_t *,
    <span class="enscript-type">struct</span> timeval *);
__private_extern__ <span class="enscript-type">void</span> mcache_set_pattern(u_int64_t, <span class="enscript-type">void</span> *, size_t);
__private_extern__ <span class="enscript-type">void</span> *mcache_verify_pattern(u_int64_t, <span class="enscript-type">void</span> *, size_t);
__private_extern__ <span class="enscript-type">void</span> *mcache_verify_set_pattern(u_int64_t, u_int64_t,
    <span class="enscript-type">void</span> *, size_t);
__private_extern__ <span class="enscript-type">void</span> mcache_audit_free_verify(mcache_audit_t *,
    <span class="enscript-type">void</span> *, size_t, size_t);
__private_extern__ <span class="enscript-type">void</span> mcache_audit_free_verify_set(mcache_audit_t *,
    <span class="enscript-type">void</span> *, size_t, size_t);
__private_extern__ <span class="enscript-type">char</span> *mcache_dump_mca(mcache_audit_t *);
__private_extern__ <span class="enscript-type">void</span> mcache_audit_panic(mcache_audit_t *, <span class="enscript-type">void</span> *, size_t,
    int64_t, int64_t);

<span class="enscript-type">extern</span> int32_t total_sbmb_cnt;
<span class="enscript-type">extern</span> int32_t total_sbmb_cnt_peak;
<span class="enscript-type">extern</span> int64_t sbmb_limreached;
<span class="enscript-type">extern</span> mcache_t *mcache_audit_cache;

#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">__cplusplus</span>
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _SYS_MCACHE_H */</span>
</pre>
<hr />
</body></html>