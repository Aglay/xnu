<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>queue.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">queue.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)queue.h	8.5 (Berkeley) 8/20/94
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_SYS_QUEUE_H_</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_SYS_QUEUE_H_</span>

<span class="enscript-comment">/*
 * This file defines five types of data structures: singly-linked lists,
 * singly-linked tail queues, lists, tail queues, and circular queues.
 *
 * A singly-linked list is headed by a single forward pointer. The elements
 * are singly linked for minimum space and pointer manipulation overhead at
 * the expense of O(n) removal for arbitrary elements. New elements can be
 * added to the list after an existing element or at the head of the list.
 * Elements being removed from the head of the list should use the explicit
 * macro for this purpose for optimum efficiency. A singly-linked list may
 * only be traversed in the forward direction.  Singly-linked lists are ideal
 * for applications with large datasets and few or no removals or for
 * implementing a LIFO queue.
 *
 * A singly-linked tail queue is headed by a pair of pointers, one to the
 * head of the list and the other to the tail of the list. The elements are
 * singly linked for minimum space and pointer manipulation overhead at the
 * expense of O(n) removal for arbitrary elements. New elements can be added
 * to the list after an existing element, at the head of the list, or at the
 * end of the list. Elements being removed from the head of the tail queue
 * should use the explicit macro for this purpose for optimum efficiency.
 * A singly-linked tail queue may only be traversed in the forward direction.
 * Singly-linked tail queues are ideal for applications with large datasets
 * and few or no removals or for implementing a FIFO queue.
 *
 * A list is headed by a single forward pointer (or an array of forward
 * pointers for a hash table header). The elements are doubly linked
 * so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before
 * or after an existing element or at the head of the list. A list
 * may only be traversed in the forward direction.
 *
 * A tail queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or
 * after an existing element, at the head of the list, or at the end of
 * the list. A tail queue may be traversed in either direction.
 *
 * A circle queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or after
 * an existing element, at the head of the list, or at the end of the list.
 * A circle queue may be traversed in either direction, but has a more
 * complex end of list detection.
 * Note that circle queues are deprecated, because, as the removal log
 * in FreeBSD states, &quot;CIRCLEQs are a disgrace to everything Knuth taught
 * us in Volume 1 Chapter 2. [...] Use TAILQ instead, it provides the same
 * functionality.&quot; Code using them will continue to compile, but they
 * are no longer documented on the man page.
 *
 * For details on the use of these macros, see the queue(3) manual page.
 *
 *
 *				SLIST	LIST	STAILQ	TAILQ	CIRCLEQ
 * _HEAD			+	+	+	+	+
 * _HEAD_INITIALIZER		+	+	+	+	-
 * _ENTRY			+	+	+	+	+
 * _INIT			+	+	+	+	+
 * _EMPTY			+	+	+	+	+
 * _FIRST			+	+	+	+	+
 * _NEXT			+	+	+	+	+
 * _PREV			-	-	-	+	+
 * _LAST			-	-	+	+	+
 * _FOREACH			+	+	+	+	+
 * _FOREACH_SAFE		+	+	+	+	-
 * _FOREACH_REVERSE		-	-	-	+	-
 * _FOREACH_REVERSE_SAFE	-	-	-	+	-
 * _INSERT_HEAD			+	+	+	+	+
 * _INSERT_BEFORE		-	+	-	+	+
 * _INSERT_AFTER		+	+	+	+	+
 * _INSERT_TAIL			-	-	+	+	+
 * _CONCAT			-	-	+	+	-
 * _REMOVE_AFTER		+	-	+	-	-
 * _REMOVE_HEAD			+	-	+	-	-
 * _REMOVE_HEAD_UNTIL		-	-	+	-	-
 * _REMOVE			+	+	+	+	+
 * _SWAP			-	+	+	+	-
 *
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">QUEUE_MACRO_DEBUG</span>
<span class="enscript-comment">/* Store the last 2 places the queue element or head was altered */</span>
<span class="enscript-type">struct</span> qm_trace {
	<span class="enscript-type">char</span> * lastfile;
	<span class="enscript-type">int</span> lastline;
	<span class="enscript-type">char</span> * prevfile;
	<span class="enscript-type">int</span> prevline;
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TRACEBUF</span>	struct qm_trace trace;
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TRASHIT</span>(x)	do {(x) = (void *)-1;} while (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">QMD_TRACE_HEAD</span>(head) do {					\
	(head)-&gt;trace.prevline = (head)-&gt;trace.lastline;		\
	(head)-&gt;trace.prevfile = (head)-&gt;trace.lastfile;		\
	(head)-&gt;trace.lastline = __LINE__;				\
	(head)-&gt;trace.lastfile = __FILE__;				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">QMD_TRACE_ELEM</span>(elem) do {					\
	(elem)-&gt;trace.prevline = (elem)-&gt;trace.lastline;		\
	(elem)-&gt;trace.prevfile = (elem)-&gt;trace.lastfile;		\
	(elem)-&gt;trace.lastline = __LINE__;				\
	(elem)-&gt;trace.lastfile = __FILE__;				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">QMD_TRACE_ELEM</span>(elem)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">QMD_TRACE_HEAD</span>(head)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TRACEBUF</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TRASHIT</span>(x)
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* QUEUE_MACRO_DEBUG */</span>

<span class="enscript-comment">/*
 * Horrible macros to enable use of code that was meant to be C-specific
 *   (and which push struct onto type) in C++; without these, C++ code
 *   that uses these macros in the context of a class will blow up
 *   due to &quot;struct&quot; being preprended to &quot;type&quot; by the macros, causing
 *   inconsistent use of tags.
 *
 * This approach is necessary because these are macros; we have to use
 *   these on a per-macro basis (because the queues are implemented as
 *   macros, disabling this warning in the scope of the header file is
 *   insufficient), whuch means we can't use #pragma, and have to use
 *   _Pragma.  We only need to use these for the queue macros that
 *   prepend &quot;struct&quot; to &quot;type&quot; and will cause C++ to blow up.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__clang__</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__cplusplus</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__MISMATCH_TAGS_PUSH</span>						\
	_Pragma(<span class="enscript-string">&quot;clang diagnostic push&quot;</span>)				\
	_Pragma(<span class="enscript-string">&quot;clang diagnostic ignored \&quot;-Wmismatched-tags\&quot;&quot;</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__MISMATCH_TAGS_POP</span>						\
	_Pragma(<span class="enscript-string">&quot;clang diagnostic pop&quot;</span>)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__MISMATCH_TAGS_PUSH</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__MISMATCH_TAGS_POP</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Singly-linked List declarations.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_HEAD</span>(name, type)						\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-type">struct</span> name {								\
	<span class="enscript-type">struct</span> type *slh_first;	<span class="enscript-comment">/* first element */</span>			\
}									\
__MISMATCH_TAGS_POP

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_HEAD_INITIALIZER</span>(head)					\
	{ NULL }

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_ENTRY</span>(type)						\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-type">struct</span> {								\
	<span class="enscript-type">struct</span> type *sle_next;	<span class="enscript-comment">/* next element */</span>			\
}									\
__MISMATCH_TAGS_POP

<span class="enscript-comment">/*
 * Singly-linked List functions.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_EMPTY</span>(head)	((head)-&gt;slh_first == NULL)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_FIRST</span>(head)	((head)-&gt;slh_first)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_FOREACH</span>(var, head, field)					\
	<span class="enscript-keyword">for</span> ((var) = SLIST_FIRST((head));				\
	    (var);							\
	    (var) = SLIST_NEXT((var), field))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_FOREACH_SAFE</span>(var, head, field, tvar)			\
	<span class="enscript-keyword">for</span> ((var) = SLIST_FIRST((head));				\
	    (var) &amp;&amp; ((tvar) = SLIST_NEXT((var), field), 1);		\
	    (var) = (tvar))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_FOREACH_PREVPTR</span>(var, varp, head, field)			\
	<span class="enscript-keyword">for</span> ((varp) = &amp;SLIST_FIRST((head));				\
	    ((var) = *(varp)) != NULL;					\
	    (varp) = &amp;SLIST_NEXT((var), field))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_INIT</span>(head) do {						\
	SLIST_FIRST((head)) = NULL;					\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_INSERT_AFTER</span>(slistelm, elm, field) do {			\
	SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field);	\
	SLIST_NEXT((slistelm), field) = (elm);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_INSERT_HEAD</span>(head, elm, field) do {			\
	SLIST_NEXT((elm), field) = SLIST_FIRST((head));			\
	SLIST_FIRST((head)) = (elm);					\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_NEXT</span>(elm, field)	((elm)-&gt;field.sle_next)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_REMOVE</span>(head, elm, type, field)				\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-keyword">do</span> {									\
	<span class="enscript-keyword">if</span> (SLIST_FIRST((head)) == (elm)) {				\
		SLIST_REMOVE_HEAD((head), field);			\
	}								\
	<span class="enscript-keyword">else</span> {								\
		<span class="enscript-type">struct</span> type *curelm = SLIST_FIRST((head));		\
		<span class="enscript-keyword">while</span> (SLIST_NEXT(curelm, field) != (elm))		\
			curelm = SLIST_NEXT(curelm, field);		\
		SLIST_REMOVE_AFTER(curelm, field);			\
	}								\
	TRASHIT((elm)-&gt;field.sle_next);					\
} <span class="enscript-keyword">while</span> (0)								\
__MISMATCH_TAGS_POP

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SLIST_REMOVE_AFTER</span>(elm, field) do {				\
	SLIST_NEXT(elm, field) =					\
	    SLIST_NEXT(SLIST_NEXT(elm, field), field);			\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SLIST_REMOVE_HEAD</span>(head, field) do {				\
	SLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field);	\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Singly-linked Tail queue declarations.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_HEAD</span>(name, type)						\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-type">struct</span> name {								\
	<span class="enscript-type">struct</span> type *stqh_first;<span class="enscript-comment">/* first element */</span>			\
	<span class="enscript-type">struct</span> type **stqh_last;<span class="enscript-comment">/* addr of last next element */</span>		\
}									\
__MISMATCH_TAGS_POP

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_HEAD_INITIALIZER</span>(head)					\
	{ NULL, &amp;(head).stqh_first }

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_ENTRY</span>(type)						\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-type">struct</span> {								\
	<span class="enscript-type">struct</span> type *stqe_next;	<span class="enscript-comment">/* next element */</span>			\
}									\
__MISMATCH_TAGS_POP

<span class="enscript-comment">/*
 * Singly-linked Tail queue functions.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_CONCAT</span>(head1, head2) do {				\
	<span class="enscript-keyword">if</span> (!STAILQ_EMPTY((head2))) {					\
		*(head1)-&gt;stqh_last = (head2)-&gt;stqh_first;		\
		(head1)-&gt;stqh_last = (head2)-&gt;stqh_last;		\
		STAILQ_INIT((head2));					\
	}								\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_EMPTY</span>(head)	((head)-&gt;stqh_first == NULL)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_FIRST</span>(head)	((head)-&gt;stqh_first)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_FOREACH</span>(var, head, field)				\
	<span class="enscript-keyword">for</span>((var) = STAILQ_FIRST((head));				\
	   (var);							\
	   (var) = STAILQ_NEXT((var), field))


#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_FOREACH_SAFE</span>(var, head, field, tvar)			\
	<span class="enscript-keyword">for</span> ((var) = STAILQ_FIRST((head));				\
	    (var) &amp;&amp; ((tvar) = STAILQ_NEXT((var), field), 1);		\
	    (var) = (tvar))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_INIT</span>(head) do {						\
	STAILQ_FIRST((head)) = NULL;					\
	(head)-&gt;stqh_last = &amp;STAILQ_FIRST((head));			\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_INSERT_AFTER</span>(head, tqelm, elm, field) do {		\
	<span class="enscript-keyword">if</span> ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL)\
		(head)-&gt;stqh_last = &amp;STAILQ_NEXT((elm), field);		\
	STAILQ_NEXT((tqelm), field) = (elm);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_INSERT_HEAD</span>(head, elm, field) do {			\
	<span class="enscript-keyword">if</span> ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL)	\
		(head)-&gt;stqh_last = &amp;STAILQ_NEXT((elm), field);		\
	STAILQ_FIRST((head)) = (elm);					\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_INSERT_TAIL</span>(head, elm, field) do {			\
	STAILQ_NEXT((elm), field) = NULL;				\
	*(head)-&gt;stqh_last = (elm);					\
	(head)-&gt;stqh_last = &amp;STAILQ_NEXT((elm), field);			\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_LAST</span>(head, type, field)					\
__MISMATCH_TAGS_PUSH							\
	(STAILQ_EMPTY((head)) ?						\
		NULL :							\
	        ((<span class="enscript-type">struct</span> type *)(<span class="enscript-type">void</span> *)				\
		((<span class="enscript-type">char</span> *)((head)-&gt;stqh_last) - __offsetof(<span class="enscript-type">struct</span> type, field))))\
__MISMATCH_TAGS_POP

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_NEXT</span>(elm, field)	((elm)-&gt;field.stqe_next)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_REMOVE</span>(head, elm, type, field)				\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-keyword">do</span> {									\
	<span class="enscript-keyword">if</span> (STAILQ_FIRST((head)) == (elm)) {				\
		STAILQ_REMOVE_HEAD((head), field);			\
	}								\
	<span class="enscript-keyword">else</span> {								\
		<span class="enscript-type">struct</span> type *curelm = STAILQ_FIRST((head));		\
		<span class="enscript-keyword">while</span> (STAILQ_NEXT(curelm, field) != (elm))		\
			curelm = STAILQ_NEXT(curelm, field);		\
		STAILQ_REMOVE_AFTER(head, curelm, field);		\
	}								\
	TRASHIT((elm)-&gt;field.stqe_next);				\
} <span class="enscript-keyword">while</span> (0)								\
__MISMATCH_TAGS_POP

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">STAILQ_REMOVE_HEAD</span>(head, field) do {				\
	<span class="enscript-keyword">if</span> ((STAILQ_FIRST((head)) =					\
	     STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL)		\
		(head)-&gt;stqh_last = &amp;STAILQ_FIRST((head));		\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">STAILQ_REMOVE_HEAD_UNTIL</span>(head, elm, field) do {                 \
       <span class="enscript-keyword">if</span> ((STAILQ_FIRST((head)) = STAILQ_NEXT((elm), field)) == NULL) \
               (head)-&gt;stqh_last = &amp;STAILQ_FIRST((head));              \
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">STAILQ_REMOVE_AFTER</span>(head, elm, field) do {			\
	<span class="enscript-keyword">if</span> ((STAILQ_NEXT(elm, field) =					\
	     STAILQ_NEXT(STAILQ_NEXT(elm, field), field)) == NULL)	\
		(head)-&gt;stqh_last = &amp;STAILQ_NEXT((elm), field);		\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">STAILQ_SWAP</span>(head1, head2, type)					\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-keyword">do</span> {									\
	<span class="enscript-type">struct</span> type *swap_first = STAILQ_FIRST(head1);			\
	<span class="enscript-type">struct</span> type **swap_last = (head1)-&gt;stqh_last;			\
	STAILQ_FIRST(head1) = STAILQ_FIRST(head2);			\
	(head1)-&gt;stqh_last = (head2)-&gt;stqh_last;			\
	STAILQ_FIRST(head2) = swap_first;				\
	(head2)-&gt;stqh_last = swap_last;					\
	<span class="enscript-keyword">if</span> (STAILQ_EMPTY(head1))					\
		(head1)-&gt;stqh_last = &amp;STAILQ_FIRST(head1);		\
	<span class="enscript-keyword">if</span> (STAILQ_EMPTY(head2))					\
		(head2)-&gt;stqh_last = &amp;STAILQ_FIRST(head2);		\
} <span class="enscript-keyword">while</span> (0)								\
__MISMATCH_TAGS_POP


<span class="enscript-comment">/*
 * List declarations.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_HEAD</span>(name, type)						\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-type">struct</span> name {								\
	<span class="enscript-type">struct</span> type *lh_first;	<span class="enscript-comment">/* first element */</span>			\
}									\
__MISMATCH_TAGS_POP

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_HEAD_INITIALIZER</span>(head)					\
	{ NULL }

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_ENTRY</span>(type)						\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-type">struct</span> {								\
	<span class="enscript-type">struct</span> type *le_next;	<span class="enscript-comment">/* next element */</span>			\
	<span class="enscript-type">struct</span> type **le_prev;	<span class="enscript-comment">/* address of previous next element */</span>	\
}									\
__MISMATCH_TAGS_POP

<span class="enscript-comment">/*
 * List functions.
 */</span>

#<span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_KERNEL</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">INVARIANTS</span>)) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">QUEUE_MACRO_DEBUG</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">QMD_LIST_CHECK_HEAD</span>(head, field) do {				\
	<span class="enscript-keyword">if</span> (LIST_FIRST((head)) != NULL &amp;&amp;				\
	    LIST_FIRST((head))-&gt;field.le_prev !=			\
	     &amp;LIST_FIRST((head)))					\
		panic(<span class="enscript-string">&quot;Bad list head %p first-&gt;prev != head&quot;</span>, (head));	\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">QMD_LIST_CHECK_NEXT</span>(elm, field) do {				\
	<span class="enscript-keyword">if</span> (LIST_NEXT((elm), field) != NULL &amp;&amp;				\
	    LIST_NEXT((elm), field)-&gt;field.le_prev !=			\
	     &amp;((elm)-&gt;field.le_next))					\
	     	panic(<span class="enscript-string">&quot;Bad link elm %p next-&gt;prev != elm&quot;</span>, (elm));	\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">QMD_LIST_CHECK_PREV</span>(elm, field) do {				\
	<span class="enscript-keyword">if</span> (*(elm)-&gt;field.le_prev != (elm))				\
		panic(<span class="enscript-string">&quot;Bad link elm %p prev-&gt;next != elm&quot;</span>, (elm));	\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">QMD_LIST_CHECK_HEAD</span>(head, field)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">QMD_LIST_CHECK_NEXT</span>(elm, field)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">QMD_LIST_CHECK_PREV</span>(elm, field)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* (_KERNEL &amp;&amp; INVARIANTS) || QUEUE_MACRO_DEBUG */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_EMPTY</span>(head)	((head)-&gt;lh_first == NULL)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_FIRST</span>(head)	((head)-&gt;lh_first)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_FOREACH</span>(var, head, field)					\
	<span class="enscript-keyword">for</span> ((var) = LIST_FIRST((head));				\
	    (var);							\
	    (var) = LIST_NEXT((var), field))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_FOREACH_SAFE</span>(var, head, field, tvar)			\
	<span class="enscript-keyword">for</span> ((var) = LIST_FIRST((head));				\
	    (var) &amp;&amp; ((tvar) = LIST_NEXT((var), field), 1);		\
	    (var) = (tvar))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_INIT</span>(head) do {						\
	LIST_FIRST((head)) = NULL;					\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_INSERT_AFTER</span>(listelm, elm, field) do {			\
	QMD_LIST_CHECK_NEXT(listelm, field);				\
	<span class="enscript-keyword">if</span> ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL)\
		LIST_NEXT((listelm), field)-&gt;field.le_prev =		\
		    &amp;LIST_NEXT((elm), field);				\
	LIST_NEXT((listelm), field) = (elm);				\
	(elm)-&gt;field.le_prev = &amp;LIST_NEXT((listelm), field);		\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_INSERT_BEFORE</span>(listelm, elm, field) do {			\
	QMD_LIST_CHECK_PREV(listelm, field);				\
	(elm)-&gt;field.le_prev = (listelm)-&gt;field.le_prev;		\
	LIST_NEXT((elm), field) = (listelm);				\
	*(listelm)-&gt;field.le_prev = (elm);				\
	(listelm)-&gt;field.le_prev = &amp;LIST_NEXT((elm), field);		\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_INSERT_HEAD</span>(head, elm, field) do {				\
	QMD_LIST_CHECK_HEAD((head), field);				\
	<span class="enscript-keyword">if</span> ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)	\
		LIST_FIRST((head))-&gt;field.le_prev = &amp;LIST_NEXT((elm), field);\
	LIST_FIRST((head)) = (elm);					\
	(elm)-&gt;field.le_prev = &amp;LIST_FIRST((head));			\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_NEXT</span>(elm, field)	((elm)-&gt;field.le_next)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LIST_REMOVE</span>(elm, field) do {					\
	QMD_LIST_CHECK_NEXT(elm, field);				\
	QMD_LIST_CHECK_PREV(elm, field);				\
	<span class="enscript-keyword">if</span> (LIST_NEXT((elm), field) != NULL)				\
		LIST_NEXT((elm), field)-&gt;field.le_prev = 		\
		    (elm)-&gt;field.le_prev;				\
	*(elm)-&gt;field.le_prev = LIST_NEXT((elm), field);		\
	TRASHIT((elm)-&gt;field.le_next);					\
	TRASHIT((elm)-&gt;field.le_prev);					\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">LIST_SWAP</span>(head1, head2, type, field)				\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-keyword">do</span> {									\
	<span class="enscript-type">struct</span> type *swap_tmp = LIST_FIRST((head1));			\
	LIST_FIRST((head1)) = LIST_FIRST((head2));			\
	LIST_FIRST((head2)) = swap_tmp;					\
	<span class="enscript-keyword">if</span> ((swap_tmp = LIST_FIRST((head1))) != NULL)			\
		swap_tmp-&gt;field.le_prev = &amp;LIST_FIRST((head1));		\
	<span class="enscript-keyword">if</span> ((swap_tmp = LIST_FIRST((head2))) != NULL)			\
		swap_tmp-&gt;field.le_prev = &amp;LIST_FIRST((head2));		\
} <span class="enscript-keyword">while</span> (0)								\
__MISMATCH_TAGS_POP

<span class="enscript-comment">/*
 * Tail queue declarations.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_HEAD</span>(name, type)						\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-type">struct</span> name {								\
	<span class="enscript-type">struct</span> type *tqh_first;	<span class="enscript-comment">/* first element */</span>			\
	<span class="enscript-type">struct</span> type **tqh_last;	<span class="enscript-comment">/* addr of last next element */</span>		\
	TRACEBUF							\
}									\
__MISMATCH_TAGS_POP

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_HEAD_INITIALIZER</span>(head)					\
	{ NULL, &amp;(head).tqh_first }

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_ENTRY</span>(type)						\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-type">struct</span> {								\
	<span class="enscript-type">struct</span> type *tqe_next;	<span class="enscript-comment">/* next element */</span>			\
	<span class="enscript-type">struct</span> type **tqe_prev;	<span class="enscript-comment">/* address of previous next element */</span>	\
	TRACEBUF							\
}									\
__MISMATCH_TAGS_POP

<span class="enscript-comment">/*
 * Tail queue functions.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_CONCAT</span>(head1, head2, field) do {				\
	<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(head2)) {					\
		*(head1)-&gt;tqh_last = (head2)-&gt;tqh_first;		\
		(head2)-&gt;tqh_first-&gt;field.tqe_prev = (head1)-&gt;tqh_last;	\
		(head1)-&gt;tqh_last = (head2)-&gt;tqh_last;			\
		TAILQ_INIT((head2));					\
		QMD_TRACE_HEAD(head1);					\
		QMD_TRACE_HEAD(head2);					\
	}								\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_EMPTY</span>(head)	((head)-&gt;tqh_first == NULL)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_FIRST</span>(head)	((head)-&gt;tqh_first)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_FOREACH</span>(var, head, field)					\
	<span class="enscript-keyword">for</span> ((var) = TAILQ_FIRST((head));				\
	    (var);							\
	    (var) = TAILQ_NEXT((var), field))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_FOREACH_SAFE</span>(var, head, field, tvar)			\
	<span class="enscript-keyword">for</span> ((var) = TAILQ_FIRST((head));				\
	    (var) &amp;&amp; ((tvar) = TAILQ_NEXT((var), field), 1);		\
	    (var) = (tvar))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_FOREACH_REVERSE</span>(var, head, headname, field)		\
	<span class="enscript-keyword">for</span> ((var) = TAILQ_LAST((head), headname);			\
	    (var);							\
	    (var) = TAILQ_PREV((var), headname, field))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_FOREACH_REVERSE_SAFE</span>(var, head, headname, field, tvar)	\
	<span class="enscript-keyword">for</span> ((var) = TAILQ_LAST((head), headname);			\
	    (var) &amp;&amp; ((tvar) = TAILQ_PREV((var), headname, field), 1);	\
	    (var) = (tvar))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_INIT</span>(head) do {						\
	TAILQ_FIRST((head)) = NULL;					\
	(head)-&gt;tqh_last = &amp;TAILQ_FIRST((head));			\
	QMD_TRACE_HEAD(head);						\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_INSERT_AFTER</span>(head, listelm, elm, field) do {		\
	<span class="enscript-keyword">if</span> ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL)\
		TAILQ_NEXT((elm), field)-&gt;field.tqe_prev = 		\
		    &amp;TAILQ_NEXT((elm), field);				\
	<span class="enscript-keyword">else</span> {								\
		(head)-&gt;tqh_last = &amp;TAILQ_NEXT((elm), field);		\
		QMD_TRACE_HEAD(head);					\
	}								\
	TAILQ_NEXT((listelm), field) = (elm);				\
	(elm)-&gt;field.tqe_prev = &amp;TAILQ_NEXT((listelm), field);		\
	QMD_TRACE_ELEM(&amp;(elm)-&gt;field);					\
	QMD_TRACE_ELEM(&amp;listelm-&gt;field);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_INSERT_BEFORE</span>(listelm, elm, field) do {			\
	(elm)-&gt;field.tqe_prev = (listelm)-&gt;field.tqe_prev;		\
	TAILQ_NEXT((elm), field) = (listelm);				\
	*(listelm)-&gt;field.tqe_prev = (elm);				\
	(listelm)-&gt;field.tqe_prev = &amp;TAILQ_NEXT((elm), field);		\
	QMD_TRACE_ELEM(&amp;(elm)-&gt;field);					\
	QMD_TRACE_ELEM(&amp;listelm-&gt;field);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_INSERT_HEAD</span>(head, elm, field) do {			\
	<span class="enscript-keyword">if</span> ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL)	\
		TAILQ_FIRST((head))-&gt;field.tqe_prev =			\
		    &amp;TAILQ_NEXT((elm), field);				\
	<span class="enscript-keyword">else</span>								\
		(head)-&gt;tqh_last = &amp;TAILQ_NEXT((elm), field);		\
	TAILQ_FIRST((head)) = (elm);					\
	(elm)-&gt;field.tqe_prev = &amp;TAILQ_FIRST((head));			\
	QMD_TRACE_HEAD(head);						\
	QMD_TRACE_ELEM(&amp;(elm)-&gt;field);					\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_INSERT_TAIL</span>(head, elm, field) do {			\
	TAILQ_NEXT((elm), field) = NULL;				\
	(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;			\
	*(head)-&gt;tqh_last = (elm);					\
	(head)-&gt;tqh_last = &amp;TAILQ_NEXT((elm), field);			\
	QMD_TRACE_HEAD(head);						\
	QMD_TRACE_ELEM(&amp;(elm)-&gt;field);					\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_LAST</span>(head, headname)					\
__MISMATCH_TAGS_PUSH							\
	(*(((<span class="enscript-type">struct</span> headname *)((head)-&gt;tqh_last))-&gt;tqh_last))		\
__MISMATCH_TAGS_POP

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_NEXT</span>(elm, field) ((elm)-&gt;field.tqe_next)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_PREV</span>(elm, headname, field)				\
__MISMATCH_TAGS_PUSH							\
	(*(((<span class="enscript-type">struct</span> headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last))	\
__MISMATCH_TAGS_POP

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TAILQ_REMOVE</span>(head, elm, field) do {				\
	<span class="enscript-keyword">if</span> ((TAILQ_NEXT((elm), field)) != NULL)				\
		TAILQ_NEXT((elm), field)-&gt;field.tqe_prev = 		\
		    (elm)-&gt;field.tqe_prev;				\
	<span class="enscript-keyword">else</span> {								\
		(head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;		\
		QMD_TRACE_HEAD(head);					\
	}								\
	*(elm)-&gt;field.tqe_prev = TAILQ_NEXT((elm), field);		\
	TRASHIT((elm)-&gt;field.tqe_next);					\
	TRASHIT((elm)-&gt;field.tqe_prev);					\
	QMD_TRACE_ELEM(&amp;(elm)-&gt;field);					\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Why did they switch to spaces for this one macro?
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TAILQ_SWAP</span>(head1, head2, type, field)                           \
__MISMATCH_TAGS_PUSH                                                    \
<span class="enscript-keyword">do</span> {                                                                    \
	<span class="enscript-type">struct</span> type *swap_first = (head1)-&gt;tqh_first;                   \
	<span class="enscript-type">struct</span> type **swap_last = (head1)-&gt;tqh_last;                    \
	(head1)-&gt;tqh_first = (head2)-&gt;tqh_first;                        \
	(head1)-&gt;tqh_last = (head2)-&gt;tqh_last;                          \
	(head2)-&gt;tqh_first = swap_first;                                \
	(head2)-&gt;tqh_last = swap_last;                                  \
	<span class="enscript-keyword">if</span> ((swap_first = (head1)-&gt;tqh_first) != NULL)                  \
		swap_first-&gt;field.tqe_prev = &amp;(head1)-&gt;tqh_first;       \
	<span class="enscript-keyword">else</span>                                                            \
		(head1)-&gt;tqh_last = &amp;(head1)-&gt;tqh_first;                \
	<span class="enscript-keyword">if</span> ((swap_first = (head2)-&gt;tqh_first) != NULL)                  \
		swap_first-&gt;field.tqe_prev = &amp;(head2)-&gt;tqh_first;       \
	<span class="enscript-keyword">else</span>                                                            \
		(head2)-&gt;tqh_last = &amp;(head2)-&gt;tqh_first;                \
} <span class="enscript-keyword">while</span> (0)                                                             \
__MISMATCH_TAGS_POP

<span class="enscript-comment">/*
 * Circular queue definitions.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CIRCLEQ_HEAD</span>(name, type)					\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-type">struct</span> name {								\
	<span class="enscript-type">struct</span> type *cqh_first;		<span class="enscript-comment">/* first element */</span>		\
	<span class="enscript-type">struct</span> type *cqh_last;		<span class="enscript-comment">/* last element */</span>		\
}									\
__MISMATCH_TAGS_POP

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CIRCLEQ_ENTRY</span>(type)						\
__MISMATCH_TAGS_PUSH							\
<span class="enscript-type">struct</span> {								\
	<span class="enscript-type">struct</span> type *cqe_next;		<span class="enscript-comment">/* next element */</span>		\
	<span class="enscript-type">struct</span> type *cqe_prev;		<span class="enscript-comment">/* previous element */</span>		\
}									\
__MISMATCH_TAGS_POP

<span class="enscript-comment">/*
 * Circular queue functions.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CIRCLEQ_EMPTY</span>(head) ((head)-&gt;cqh_first == (void *)(head))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CIRCLEQ_FIRST</span>(head) ((head)-&gt;cqh_first)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CIRCLEQ_FOREACH</span>(var, head, field)				\
	<span class="enscript-keyword">for</span>((var) = (head)-&gt;cqh_first;					\
	    (var) != (<span class="enscript-type">void</span> *)(head);					\
	    (var) = (var)-&gt;field.cqe_next)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">CIRCLEQ_INIT</span>(head) do {						\
	(head)-&gt;cqh_first = (<span class="enscript-type">void</span> *)(head);				\
	(head)-&gt;cqh_last = (<span class="enscript-type">void</span> *)(head);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CIRCLEQ_INSERT_AFTER</span>(head, listelm, elm, field) do {		\
	(elm)-&gt;field.cqe_next = (listelm)-&gt;field.cqe_next;		\
	(elm)-&gt;field.cqe_prev = (listelm);				\
	<span class="enscript-keyword">if</span> ((listelm)-&gt;field.cqe_next == (<span class="enscript-type">void</span> *)(head))		\
		(head)-&gt;cqh_last = (elm);				\
	<span class="enscript-keyword">else</span>								\
		(listelm)-&gt;field.cqe_next-&gt;field.cqe_prev = (elm);	\
	(listelm)-&gt;field.cqe_next = (elm);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CIRCLEQ_INSERT_BEFORE</span>(head, listelm, elm, field) do {		\
	(elm)-&gt;field.cqe_next = (listelm);				\
	(elm)-&gt;field.cqe_prev = (listelm)-&gt;field.cqe_prev;		\
	<span class="enscript-keyword">if</span> ((listelm)-&gt;field.cqe_prev == (<span class="enscript-type">void</span> *)(head))		\
		(head)-&gt;cqh_first = (elm);				\
	<span class="enscript-keyword">else</span>								\
		(listelm)-&gt;field.cqe_prev-&gt;field.cqe_next = (elm);	\
	(listelm)-&gt;field.cqe_prev = (elm);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CIRCLEQ_INSERT_HEAD</span>(head, elm, field) do {			\
	(elm)-&gt;field.cqe_next = (head)-&gt;cqh_first;			\
	(elm)-&gt;field.cqe_prev = (<span class="enscript-type">void</span> *)(head);				\
	<span class="enscript-keyword">if</span> ((head)-&gt;cqh_last == (<span class="enscript-type">void</span> *)(head))				\
		(head)-&gt;cqh_last = (elm);				\
	<span class="enscript-keyword">else</span>								\
		(head)-&gt;cqh_first-&gt;field.cqe_prev = (elm);		\
	(head)-&gt;cqh_first = (elm);					\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CIRCLEQ_INSERT_TAIL</span>(head, elm, field) do {			\
	(elm)-&gt;field.cqe_next = (<span class="enscript-type">void</span> *)(head);				\
	(elm)-&gt;field.cqe_prev = (head)-&gt;cqh_last;			\
	<span class="enscript-keyword">if</span> ((head)-&gt;cqh_first == (<span class="enscript-type">void</span> *)(head))			\
		(head)-&gt;cqh_first = (elm);				\
	<span class="enscript-keyword">else</span>								\
		(head)-&gt;cqh_last-&gt;field.cqe_next = (elm);		\
	(head)-&gt;cqh_last = (elm);					\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CIRCLEQ_LAST</span>(head) ((head)-&gt;cqh_last)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CIRCLEQ_NEXT</span>(elm,field) ((elm)-&gt;field.cqe_next)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CIRCLEQ_PREV</span>(elm,field) ((elm)-&gt;field.cqe_prev)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">CIRCLEQ_REMOVE</span>(head, elm, field) do {				\
	<span class="enscript-keyword">if</span> ((elm)-&gt;field.cqe_next == (<span class="enscript-type">void</span> *)(head))			\
		(head)-&gt;cqh_last = (elm)-&gt;field.cqe_prev;		\
	<span class="enscript-keyword">else</span>								\
		(elm)-&gt;field.cqe_next-&gt;field.cqe_prev =			\
		    (elm)-&gt;field.cqe_prev;				\
	<span class="enscript-keyword">if</span> ((elm)-&gt;field.cqe_prev == (<span class="enscript-type">void</span> *)(head))			\
		(head)-&gt;cqh_first = (elm)-&gt;field.cqe_next;		\
	<span class="enscript-keyword">else</span>								\
		(elm)-&gt;field.cqe_prev-&gt;field.cqe_next =			\
		    (elm)-&gt;field.cqe_next;				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_KERNEL</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NOTFB31</span>

<span class="enscript-comment">/*
 * XXX insque() and remque() are an old way of handling certain queues.
 * They bogusly assumes that all queue heads look alike.
 */</span>

<span class="enscript-type">struct</span> quehead {
	<span class="enscript-type">struct</span> quehead *qh_link;
	<span class="enscript-type">struct</span> quehead *qh_rlink;
};

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__GNUC__</span>

<span class="enscript-type">static</span> __inline <span class="enscript-type">void</span>
<span class="enscript-function-name">insque</span>(<span class="enscript-type">void</span> *a, <span class="enscript-type">void</span> *b)
{
	<span class="enscript-type">struct</span> quehead *element = (<span class="enscript-type">struct</span> quehead *)a,
		 *head = (<span class="enscript-type">struct</span> quehead *)b;

	element-&gt;qh_link = head-&gt;qh_link;
	element-&gt;qh_rlink = head;
	head-&gt;qh_link = element;
	element-&gt;qh_link-&gt;qh_rlink = element;
}

<span class="enscript-type">static</span> __inline <span class="enscript-type">void</span>
<span class="enscript-function-name">remque</span>(<span class="enscript-type">void</span> *a)
{
	<span class="enscript-type">struct</span> quehead *element = (<span class="enscript-type">struct</span> quehead *)a;

	element-&gt;qh_link-&gt;qh_rlink = element-&gt;qh_rlink;
	element-&gt;qh_rlink-&gt;qh_link = element-&gt;qh_link;
	element-&gt;qh_rlink = 0;
}

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__GNUC__ */</span>

<span class="enscript-type">void</span>	insque(<span class="enscript-type">void</span> *a, <span class="enscript-type">void</span> *b);
<span class="enscript-type">void</span>	remque(<span class="enscript-type">void</span> *a);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __GNUC__ */</span>

#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _KERNEL */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_SYS_QUEUE_H_ */</span>
</pre>
<hr />
</body></html>