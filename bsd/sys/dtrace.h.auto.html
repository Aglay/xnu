<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>dtrace.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">dtrace.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or <a href="http://www.opensolaris.org/os/licensing.">http://www.opensolaris.org/os/licensing.</a>
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets &quot;[]&quot; replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */</span>

<span class="enscript-comment">/*
 * Portions copyright (c) 2013, Joyent, Inc. All rights reserved.
 * Portions Copyright (c) 2013 by Delphix. All rights reserved.
 */</span>

<span class="enscript-comment">/*
 * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 * Portions Copyright (c) 2012 by Delphix. All rights reserved.
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_SYS_DTRACE_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_SYS_DTRACE_H</span>

<span class="enscript-comment">/* #pragma ident	&quot;@(#)dtrace.h	1.37	07/06/05 SMI&quot; */</span>

#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">__cplusplus</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * DTrace Dynamic Tracing Software: Kernel Interfaces
 *
 * Note: The contents of this file are private to the implementation of the
 * Solaris system and DTrace subsystem and are subject to change at any time
 * without notice.  Applications and drivers using these interfaces will fail
 * to run on future releases.  These interfaces should not be used for any
 * purpose except those expressly outlined in dtrace(7D) and libdtrace(3LIB).
 * Please refer to the &quot;Solaris Dynamic Tracing Guide&quot; for more information.
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_ASM</span>

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/modctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ctf_api.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cyclic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/int_limits.h&gt;</span>
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* is Apple Mac OS X */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_LP64</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_LP64</span> <span class="enscript-comment">/* Solaris vs. Darwin */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_ILP32</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_ILP32</span> <span class="enscript-comment">/* Solaris vs. Darwin */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_KERNEL</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_KERNEL</span> <span class="enscript-comment">/* Solaris vs. Darwin */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__BIG_ENDIAN__</span>)
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_BIG_ENDIAN</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_BIG_ENDIAN</span> <span class="enscript-comment">/* Solaris vs. Darwin */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LITTLE_ENDIAN__</span>)
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_LITTLE_ENDIAN</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_LITTLE_ENDIAN</span> <span class="enscript-comment">/* Solaris vs. Darwin */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">endian</span>-<span class="enscript-variable-name">ness</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NULL</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NULL</span> ((void *)0) <span class="enscript-comment">/* quiets many warnings */</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SEC</span>			1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MILLISEC</span>	1000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MICROSEC</span>	1000000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NANOSEC</span>		1000000000

#<span class="enscript-reference">define</span> <span class="enscript-function-name">S_ROUND</span>(x, a)   ((x) + (((a) ? (a) : 1) - 1) &amp; ~(((a) ? (a) : 1) - 1))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">P2ROUNDUP</span>(x, align)             (-(-(x) &amp; -(align)))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">P2PHASEUP</span>(x, align, phase)	((phase) - (((phase) - (x)) &amp; -(align)))

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CTF_MODEL_ILP32</span>	1	<span class="enscript-comment">/* object data model is ILP32 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CTF_MODEL_LP64</span>	2	<span class="enscript-comment">/* object data model is LP64 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CTF_MODEL_NATIVE</span>	CTF_MODEL_LP64
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CTF_MODEL_NATIVE</span>	CTF_MODEL_ILP32
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> uint8_t		uchar_t;
<span class="enscript-type">typedef</span> uint16_t	ushort_t;
<span class="enscript-type">typedef</span> uint32_t	uint_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>	ulong_t;
<span class="enscript-type">typedef</span> uint64_t	u_longlong_t;
<span class="enscript-type">typedef</span> int64_t		longlong_t;
<span class="enscript-type">typedef</span> int64_t		off64_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">int</span>			processorid_t;
<span class="enscript-type">typedef</span> int64_t		hrtime_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> { B_FALSE = 0, B_TRUE = 1 } _dtrace_boolean;

<span class="enscript-type">typedef</span> uint8_t UUID[16]; <span class="enscript-comment">/* For modctl use in dtrace.h */</span>

<span class="enscript-type">struct</span> modctl; <span class="enscript-comment">/* In lieu of Solaris &lt;sys/modctl.h&gt; */</span>
<span class="enscript-comment">/* NOTHING */</span>  <span class="enscript-comment">/* In lieu of Solaris &lt;sys/processor.h&gt; */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span> <span class="enscript-comment">/* In lieu of Solaris &lt;sys/systm.h&gt; */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
<span class="enscript-comment">/* NOTHING */</span> <span class="enscript-comment">/* In lieu of Solaris &lt;sys/ctf_api.h&gt; */</span>
#<span class="enscript-reference">else</span>
<span class="enscript-comment">/* In lieu of Solaris &lt;sys/ctf_api.h&gt; */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ctf_file ctf_file_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">long</span> ctf_id_t;
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/* NOTHING */</span> <span class="enscript-comment">/* In lieu of Solaris &lt;sys/cyclic.h&gt; */</span>
<span class="enscript-comment">/* NOTHING */</span> <span class="enscript-comment">/* In lieu of Solaris &lt;sys/int_limits.h&gt; */</span>

<span class="enscript-type">typedef</span> uint32_t        zoneid_t;

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace_glue.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span> 
<span class="enscript-type">typedef</span> va_list __va_list;

<span class="enscript-comment">/* Solaris proc_t is the struct. Darwin's proc_t is a pointer to it. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">proc_t</span> struct proc <span class="enscript-comment">/* Steer clear of the Darwin typedef for proc_t */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

<span class="enscript-comment">/*
 * DTrace Universal Constants and Typedefs
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CPUALL</span>		-1	<span class="enscript-comment">/* all CPUs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_IDNONE</span>		0	<span class="enscript-comment">/* invalid probe identifier */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_EPIDNONE</span>		0	<span class="enscript-comment">/* invalid enabled probe identifier */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_AGGIDNONE</span>	0	<span class="enscript-comment">/* invalid aggregation identifier */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_AGGVARIDNONE</span>	0	<span class="enscript-comment">/* invalid aggregation variable ID */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CACHEIDNONE</span>	0	<span class="enscript-comment">/* invalid predicate cache */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_PROVNONE</span>		0	<span class="enscript-comment">/* invalid provider identifier */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_METAPROVNONE</span>	0	<span class="enscript-comment">/* invalid meta-provider identifier */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_ARGNONE</span>		-1	<span class="enscript-comment">/* invalid argument index */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_PROVNAMELEN</span>	64
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MODNAMELEN</span>	64
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_FUNCNAMELEN</span>	128
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_NAMELEN</span>		64
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_FULLNAMELEN</span>	(DTRACE_PROVNAMELEN + DTRACE_MODNAMELEN + \
				DTRACE_FUNCNAMELEN + DTRACE_NAMELEN + 4)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_ARGTYPELEN</span>	128

<span class="enscript-type">typedef</span> uint32_t dtrace_id_t;		<span class="enscript-comment">/* probe identifier */</span>
<span class="enscript-type">typedef</span> uint32_t dtrace_epid_t;		<span class="enscript-comment">/* enabled probe identifier */</span>
<span class="enscript-type">typedef</span> uint32_t dtrace_aggid_t;	<span class="enscript-comment">/* aggregation identifier */</span>
<span class="enscript-type">typedef</span> int64_t dtrace_aggvarid_t;	<span class="enscript-comment">/* aggregation variable identifier */</span>
<span class="enscript-type">typedef</span> uint16_t dtrace_actkind_t;	<span class="enscript-comment">/* action kind */</span>
<span class="enscript-type">typedef</span> int64_t dtrace_optval_t;	<span class="enscript-comment">/* option value */</span>
<span class="enscript-type">typedef</span> uint32_t dtrace_cacheid_t;	<span class="enscript-comment">/* predicate cache identifier */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> dtrace_probespec {
        DTRACE_PROBESPEC_NONE = -1,
        DTRACE_PROBESPEC_PROVIDER = 0,
        DTRACE_PROBESPEC_MOD,
        DTRACE_PROBESPEC_FUNC,
        DTRACE_PROBESPEC_NAME
} dtrace_probespec_t;

<span class="enscript-comment">/*
 * DTrace Intermediate Format (DIF)
 *
 * The following definitions describe the DTrace Intermediate Format (DIF), a
 * a RISC-like instruction set and program encoding used to represent
 * predicates and actions that can be bound to DTrace probes.  The constants
 * below defining the number of available registers are suggested minimums; the
 * compiler should use DTRACEIOC_CONF to dynamically obtain the number of
 * registers provided by the current DTrace implementation.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VERSION_1</span>	1		<span class="enscript-comment">/* DIF version 1: Solaris 10 Beta */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VERSION_2</span>	2		<span class="enscript-comment">/* DIF version 2: Solaris 10 FCS */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VERSION</span>	DIF_VERSION_2	<span class="enscript-comment">/* latest DIF instruction set version */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_DIR_NREGS</span>	8		<span class="enscript-comment">/* number of DIF integer registers */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_DTR_NREGS</span>	8		<span class="enscript-comment">/* number of DIF tuple registers */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_OR</span>	1		<span class="enscript-comment">/* or	r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_XOR</span>	2		<span class="enscript-comment">/* xor	r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_AND</span>	3		<span class="enscript-comment">/* and	r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_SLL</span>	4		<span class="enscript-comment">/* sll	r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_SRL</span>	5		<span class="enscript-comment">/* srl	r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_SUB</span>	6		<span class="enscript-comment">/* sub	r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_ADD</span>	7		<span class="enscript-comment">/* add	r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_MUL</span>	8		<span class="enscript-comment">/* mul	r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_SDIV</span>	9		<span class="enscript-comment">/* sdiv	r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_UDIV</span>	10		<span class="enscript-comment">/* udiv r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_SREM</span>	11		<span class="enscript-comment">/* srem r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_UREM</span>	12		<span class="enscript-comment">/* urem r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_NOT</span>	13		<span class="enscript-comment">/* not	r1, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_MOV</span>	14		<span class="enscript-comment">/* mov	r1, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_CMP</span>	15		<span class="enscript-comment">/* cmp	r1, r2 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_TST</span>	16		<span class="enscript-comment">/* tst  r1 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_BA</span>	17		<span class="enscript-comment">/* ba	label */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_BE</span>	18		<span class="enscript-comment">/* be	label */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_BNE</span>	19		<span class="enscript-comment">/* bne	label */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_BG</span>	20		<span class="enscript-comment">/* bg	label */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_BGU</span>	21		<span class="enscript-comment">/* bgu	label */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_BGE</span>	22		<span class="enscript-comment">/* bge	label */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_BGEU</span>	23		<span class="enscript-comment">/* bgeu	label */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_BL</span>	24		<span class="enscript-comment">/* bl	label */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_BLU</span>	25		<span class="enscript-comment">/* blu	label */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_BLE</span>	26		<span class="enscript-comment">/* ble	label */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_BLEU</span>	27		<span class="enscript-comment">/* bleu	label */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDSB</span>	28		<span class="enscript-comment">/* ldsb	[r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDSH</span>	29		<span class="enscript-comment">/* ldsh	[r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDSW</span>	30		<span class="enscript-comment">/* ldsw [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDUB</span>	31		<span class="enscript-comment">/* ldub	[r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDUH</span>	32		<span class="enscript-comment">/* lduh	[r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDUW</span>	33		<span class="enscript-comment">/* lduw	[r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDX</span>	34		<span class="enscript-comment">/* ldx	[r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_RET</span>	35		<span class="enscript-comment">/* ret	rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_NOP</span>	36		<span class="enscript-comment">/* nop */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_SETX</span>	37		<span class="enscript-comment">/* setx	intindex, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_SETS</span>	38		<span class="enscript-comment">/* sets strindex, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_SCMP</span>	39		<span class="enscript-comment">/* scmp	r1, r2 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDGA</span>	40		<span class="enscript-comment">/* ldga	var, ri, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDGS</span>	41		<span class="enscript-comment">/* ldgs var, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_STGS</span>	42		<span class="enscript-comment">/* stgs var, rs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDTA</span>	43		<span class="enscript-comment">/* ldta var, ri, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDTS</span>	44		<span class="enscript-comment">/* ldts var, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_STTS</span>	45		<span class="enscript-comment">/* stts var, rs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_SRA</span>	46		<span class="enscript-comment">/* sra	r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_CALL</span>	47		<span class="enscript-comment">/* call	subr, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_PUSHTR</span>	48		<span class="enscript-comment">/* pushtr type, rs, rr */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_PUSHTV</span>	49		<span class="enscript-comment">/* pushtv type, rs, rv */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_POPTS</span>	50		<span class="enscript-comment">/* popts */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_FLUSHTS</span>	51		<span class="enscript-comment">/* flushts */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDGAA</span>	52		<span class="enscript-comment">/* ldgaa var, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDTAA</span>	53		<span class="enscript-comment">/* ldtaa var, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_STGAA</span>	54		<span class="enscript-comment">/* stgaa var, rs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_STTAA</span>	55		<span class="enscript-comment">/* sttaa var, rs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_LDLS</span>	56		<span class="enscript-comment">/* ldls	var, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_STLS</span>	57		<span class="enscript-comment">/* stls	var, rs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_ALLOCS</span>	58		<span class="enscript-comment">/* allocs r1, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_COPYS</span>	59		<span class="enscript-comment">/* copys  r1, r2, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_STB</span>	60		<span class="enscript-comment">/* stb	r1, [rd] */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_STH</span>	61		<span class="enscript-comment">/* sth	r1, [rd] */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_STW</span>	62		<span class="enscript-comment">/* stw	r1, [rd] */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_STX</span>	63		<span class="enscript-comment">/* stx	r1, [rd] */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_ULDSB</span>	64		<span class="enscript-comment">/* uldsb [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_ULDSH</span>	65		<span class="enscript-comment">/* uldsh [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_ULDSW</span>	66		<span class="enscript-comment">/* uldsw [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_ULDUB</span>	67		<span class="enscript-comment">/* uldub [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_ULDUH</span>	68		<span class="enscript-comment">/* ulduh [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_ULDUW</span>	69		<span class="enscript-comment">/* ulduw [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_ULDX</span>	70		<span class="enscript-comment">/* uldx  [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_RLDSB</span>	71		<span class="enscript-comment">/* rldsb [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_RLDSH</span>	72		<span class="enscript-comment">/* rldsh [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_RLDSW</span>	73		<span class="enscript-comment">/* rldsw [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_RLDUB</span>	74		<span class="enscript-comment">/* rldub [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_RLDUH</span>	75		<span class="enscript-comment">/* rlduh [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_RLDUW</span>	76		<span class="enscript-comment">/* rlduw [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_RLDX</span>	77		<span class="enscript-comment">/* rldx  [r1], rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_XLATE</span>	78		<span class="enscript-comment">/* xlate xlrindex, rd */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_OP_XLARG</span>	79		<span class="enscript-comment">/* xlarg xlrindex, rd */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_INTOFF_MAX</span>		0xffff	<span class="enscript-comment">/* highest integer table offset */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_STROFF_MAX</span>		0xffff	<span class="enscript-comment">/* highest string table offset */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_REGISTER_MAX</span>	0xff	<span class="enscript-comment">/* highest register number */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VARIABLE_MAX</span>	0xffff	<span class="enscript-comment">/* highest variable identifier */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBROUTINE_MAX</span>	0xffff	<span class="enscript-comment">/* highest subroutine code */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARRAY_MIN</span>	0x0000	<span class="enscript-comment">/* lowest numbered array variable */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARRAY_UBASE</span>	0x0080	<span class="enscript-comment">/* lowest user-defined array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARRAY_MAX</span>	0x00ff	<span class="enscript-comment">/* highest numbered array variable */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_OTHER_MIN</span>	0x0100	<span class="enscript-comment">/* lowest numbered scalar or assc */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_OTHER_UBASE</span>	0x0500	<span class="enscript-comment">/* lowest user-defined scalar or assc */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_OTHER_MAX</span>	0xffff	<span class="enscript-comment">/* highest numbered scalar or assc */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARGS</span>		0x0000	<span class="enscript-comment">/* arguments array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_REGS</span>		0x0001	<span class="enscript-comment">/* registers array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_UREGS</span>		0x0002	<span class="enscript-comment">/* user registers array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_CURTHREAD</span>	0x0100	<span class="enscript-comment">/* thread pointer */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_TIMESTAMP</span>	0x0101	<span class="enscript-comment">/* timestamp */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_VTIMESTAMP</span>	0x0102	<span class="enscript-comment">/* virtual timestamp */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_IPL</span>		0x0103	<span class="enscript-comment">/* interrupt priority level */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_EPID</span>		0x0104	<span class="enscript-comment">/* enabled probe ID */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ID</span>		0x0105	<span class="enscript-comment">/* probe ID */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARG0</span>		0x0106	<span class="enscript-comment">/* first argument */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARG1</span>		0x0107	<span class="enscript-comment">/* second argument */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARG2</span>		0x0108	<span class="enscript-comment">/* third argument */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARG3</span>		0x0109	<span class="enscript-comment">/* fourth argument */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARG4</span>		0x010a	<span class="enscript-comment">/* fifth argument */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARG5</span>		0x010b	<span class="enscript-comment">/* sixth argument */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARG6</span>		0x010c	<span class="enscript-comment">/* seventh argument */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARG7</span>		0x010d	<span class="enscript-comment">/* eighth argument */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARG8</span>		0x010e	<span class="enscript-comment">/* ninth argument */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ARG9</span>		0x010f	<span class="enscript-comment">/* tenth argument */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_STACKDEPTH</span>	0x0110	<span class="enscript-comment">/* stack depth */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_CALLER</span>		0x0111	<span class="enscript-comment">/* caller */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_PROBEPROV</span>	0x0112	<span class="enscript-comment">/* probe provider */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_PROBEMOD</span>	0x0113	<span class="enscript-comment">/* probe module */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_PROBEFUNC</span>	0x0114	<span class="enscript-comment">/* probe function */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_PROBENAME</span>	0x0115	<span class="enscript-comment">/* probe name */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_PID</span>		0x0116	<span class="enscript-comment">/* process ID */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_TID</span>		0x0117	<span class="enscript-comment">/* (per-process) thread ID */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_EXECNAME</span>	0x0118	<span class="enscript-comment">/* name of executable */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ZONENAME</span>	0x0119	<span class="enscript-comment">/* zone name associated with process */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_WALLTIMESTAMP</span>	0x011a	<span class="enscript-comment">/* wall-clock timestamp */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_USTACKDEPTH</span>	0x011b	<span class="enscript-comment">/* user-land stack depth */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_UCALLER</span>		0x011c	<span class="enscript-comment">/* user-level caller */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_PPID</span>		0x011d	<span class="enscript-comment">/* parent process ID */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_UID</span>		0x011e	<span class="enscript-comment">/* process user ID */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_GID</span>		0x011f	<span class="enscript-comment">/* process group ID */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_VAR_ERRNO</span>		0x0120	<span class="enscript-comment">/* thread errno */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_VAR_PTHREAD_SELF</span>	0x0200	<span class="enscript-comment">/* Apple specific PTHREAD_SELF (Not currently supported!) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_VAR_DISPATCHQADDR</span>	0x0201	<span class="enscript-comment">/* Apple specific dispatch queue addr */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_VAR_MACHTIMESTAMP</span>	0x0202	<span class="enscript-comment">/* mach_absolute_timestamp() */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_VAR_CPU</span>		0x0203	<span class="enscript-comment">/* cpu number */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE __ */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_RAND</span>			0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_MUTEX_OWNED</span>		1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_MUTEX_OWNER</span>		2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_MUTEX_TYPE_ADAPTIVE</span>	3
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_MUTEX_TYPE_SPIN</span>	4
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_RW_READ_HELD</span>		5
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_RW_WRITE_HELD</span>		6
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_RW_ISWRITER</span>		7
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_COPYIN</span>			8
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_COPYINSTR</span>		9
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_SPECULATION</span>		10
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_PROGENYOF</span>		11
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_STRLEN</span>			12
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_COPYOUT</span>		13
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_COPYOUTSTR</span>		14
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_ALLOCA</span>			15
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_BCOPY</span>			16
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_COPYINTO</span>		17
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_MSGDSIZE</span>		18
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_MSGSIZE</span>		19
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_GETMAJOR</span>		20
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_GETMINOR</span>		21
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_DDI_PATHNAME</span>		22
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_STRJOIN</span>		23
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_LLTOSTR</span>		24
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_BASENAME</span>		25
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_DIRNAME</span>		26
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_CLEANPATH</span>		27
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_STRCHR</span>			28
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_STRRCHR</span>		29
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_STRSTR</span>			30
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_STRTOK</span>			31
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_SUBSTR</span>			32
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_INDEX</span>			33
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_RINDEX</span>			34
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_HTONS</span>			35
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_HTONL</span>			36
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_HTONLL</span>			37
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_NTOHS</span>			38
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_NTOHL</span>			39
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_NTOHLL</span>			40
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_INET_NTOP</span>		41
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_INET_NTOA</span>		42
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_INET_NTOA6</span>		43
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_TOUPPER</span>		44
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_TOLOWER</span>		45
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIF_SUBR_VM_KERNEL_ADDRPERM</span>	46
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_SUBR_MAX</span>			46      <span class="enscript-comment">/* max subroutine value */</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_SUBR_COREPROFILE</span>		47

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_SUBR_MAX</span>			47      <span class="enscript-comment">/* max subroutine value */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

<span class="enscript-type">typedef</span> uint32_t dif_instr_t;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_OP</span>(i)                 (((i) &gt;&gt; 24) &amp; 0xff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_R1</span>(i)                 (((i) &gt;&gt; 16) &amp; 0xff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_R2</span>(i)                 (((i) &gt;&gt;  8) &amp; 0xff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_RD</span>(i)                 ((i) &amp; 0xff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_RS</span>(i)                 ((i) &amp; 0xff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_LABEL</span>(i)              ((i) &amp; 0xffffff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_VAR</span>(i)                (((i) &gt;&gt;  8) &amp; 0xffff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_INTEGER</span>(i)            (((i) &gt;&gt;  8) &amp; 0xffff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_STRING</span>(i)             (((i) &gt;&gt;  8) &amp; 0xffff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_SUBR</span>(i)               (((i) &gt;&gt;  8) &amp; 0xffff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_TYPE</span>(i)               (((i) &gt;&gt; 16) &amp; 0xff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_XLREF</span>(i)              (((i) &gt;&gt;  8) &amp; 0xffff)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_FMT</span>(op, r1, r2, d) \
        (((op) &lt;&lt; 24) | ((r1) &lt;&lt; 16) | ((r2) &lt;&lt; 8) | (d))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_NOT</span>(r1, d)            (DIF_INSTR_FMT(DIF_OP_NOT, r1, 0, d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_MOV</span>(r1, d)            (DIF_INSTR_FMT(DIF_OP_MOV, r1, 0, d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_CMP</span>(op, r1, r2)       (DIF_INSTR_FMT(op, r1, r2, 0))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_TST</span>(r1)               (DIF_INSTR_FMT(DIF_OP_TST, r1, 0, 0))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_BRANCH</span>(op, label)     (((op) &lt;&lt; 24) | (label))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_LOAD</span>(op, r1, d)       (DIF_INSTR_FMT(op, r1, 0, d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_STORE</span>(op, r1, d)      (DIF_INSTR_FMT(op, r1, 0, d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_SETX</span>(i, d)            ((DIF_OP_SETX &lt;&lt; 24) | ((i) &lt;&lt; 8) | (d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_SETS</span>(s, d)            ((DIF_OP_SETS &lt;&lt; 24) | ((s) &lt;&lt; 8) | (d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_RET</span>(d)                (DIF_INSTR_FMT(DIF_OP_RET, 0, 0, d))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_INSTR_NOP</span>                   (DIF_OP_NOP &lt;&lt; 24)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_LDA</span>(op, v, r, d)      (DIF_INSTR_FMT(op, v, r, d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_LDV</span>(op, v, d)         (((op) &lt;&lt; 24) | ((v) &lt;&lt; 8) | (d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_STV</span>(op, v, rs)        (((op) &lt;&lt; 24) | ((v) &lt;&lt; 8) | (rs))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_CALL</span>(s, d)            ((DIF_OP_CALL &lt;&lt; 24) | ((s) &lt;&lt; 8) | (d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_PUSHTS</span>(op, t, r2, rs) (DIF_INSTR_FMT(op, t, r2, rs))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_INSTR_POPTS</span>                 (DIF_OP_POPTS &lt;&lt; 24)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_INSTR_FLUSHTS</span>               (DIF_OP_FLUSHTS &lt;&lt; 24)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_ALLOCS</span>(r1, d)         (DIF_INSTR_FMT(DIF_OP_ALLOCS, r1, 0, d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_COPYS</span>(r1, r2, d)      (DIF_INSTR_FMT(DIF_OP_COPYS, r1, r2, d))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIF_INSTR_XLATE</span>(op, r, d)       (((op) &lt;&lt; 24) | ((r) &lt;&lt; 8) | (d))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_REG_R0</span>      0               <span class="enscript-comment">/* %r0 is always set to zero */</span>

<span class="enscript-comment">/*
 * A DTrace Intermediate Format Type (DIF Type) is used to represent the types
 * of variables, function and associative array arguments, and the return type
 * for each DIF object (shown below).  It contains a description of the type,
 * its size in bytes, and a module identifier.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_diftype {
        uint8_t dtdt_kind;              <span class="enscript-comment">/* type kind (see below) */</span>
        uint8_t dtdt_ckind;             <span class="enscript-comment">/* type kind in CTF */</span>
        uint8_t dtdt_flags;             <span class="enscript-comment">/* type flags (see below) */</span>
        uint8_t dtdt_pad;               <span class="enscript-comment">/* reserved for future use */</span>
        uint32_t dtdt_size;             <span class="enscript-comment">/* type size in bytes (unless string) */</span>
} dtrace_diftype_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_TYPE_CTF</span>            0       <span class="enscript-comment">/* type is a CTF type */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_TYPE_STRING</span>         1       <span class="enscript-comment">/* type is a D string */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_TF_BYREF</span>            0x1     <span class="enscript-comment">/* type is passed by reference */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIF_TF_BYUREF</span>           0x2     <span class="enscript-comment">/* user type is passed by reference */</span>

<span class="enscript-comment">/*
 * A DTrace Intermediate Format variable record is used to describe each of the
 * variables referenced by a given DIF object.  It contains an integer variable
 * identifier along with variable scope and properties, as shown below.  The
 * size of this structure must be sizeof (int) aligned.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_difv {
        uint32_t dtdv_name;             <span class="enscript-comment">/* variable name index in dtdo_strtab */</span>
        uint32_t dtdv_id;               <span class="enscript-comment">/* variable reference identifier */</span>
        uint8_t dtdv_kind;              <span class="enscript-comment">/* variable kind (see below) */</span>
        uint8_t dtdv_scope;             <span class="enscript-comment">/* variable scope (see below) */</span>
        uint16_t dtdv_flags;            <span class="enscript-comment">/* variable flags (see below) */</span>
        dtrace_diftype_t dtdv_type;     <span class="enscript-comment">/* variable type (see above) */</span>
} dtrace_difv_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIFV_KIND_ARRAY</span>         0       <span class="enscript-comment">/* variable is an array of quantities */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIFV_KIND_SCALAR</span>        1       <span class="enscript-comment">/* variable is a scalar quantity */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIFV_SCOPE_GLOBAL</span>       0       <span class="enscript-comment">/* variable has global scope */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIFV_SCOPE_THREAD</span>       1       <span class="enscript-comment">/* variable has thread scope */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIFV_SCOPE_LOCAL</span>        2       <span class="enscript-comment">/* variable has local scope */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIFV_F_REF</span>              0x1     <span class="enscript-comment">/* variable is referenced by DIFO */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DIFV_F_MOD</span>              0x2     <span class="enscript-comment">/* variable is written by DIFO */</span>

<span class="enscript-comment">/*
 * DTrace Actions
 *
 * The upper byte determines the class of the action; the low bytes determines
 * the specific action within that class.  The classes of actions are as
 * follows:
 *
 *   [ no class ]                  &lt;= May record process- or kernel-related data
 *   DTRACEACT_PROC                &lt;= Only records process-related data
 *   DTRACEACT_PROC_DESTRUCTIVE    &lt;= Potentially destructive to processes
 *   DTRACEACT_KERNEL              &lt;= Only records kernel-related data
 *   DTRACEACT_KERNEL_DESTRUCTIVE  &lt;= Potentially destructive to the kernel
 *   DTRACEACT_SPECULATIVE         &lt;= Speculation-related action
 *   DTRACEACT_AGGREGATION         &lt;= Aggregating action
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_NONE</span>                  0       <span class="enscript-comment">/* no action */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_DIFEXPR</span>               1       <span class="enscript-comment">/* action is DIF expression */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_EXIT</span>                  2       <span class="enscript-comment">/* exit() action */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_PRINTF</span>                3       <span class="enscript-comment">/* printf() action */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_PRINTA</span>                4       <span class="enscript-comment">/* printa() action */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_LIBACT</span>                5       <span class="enscript-comment">/* library-controlled action */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_TRACEMEM</span>              6       <span class="enscript-comment">/* tracemem() action */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_TRACEMEM_DYNSIZE</span>      7       <span class="enscript-comment">/* dynamic tracemem() size */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_APPLEBINARY</span>           50      <span class="enscript-comment">/* Apple DT perf. tool action */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_PROC</span>                  0x0100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_USTACK</span>                (DTRACEACT_PROC + 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_JSTACK</span>                (DTRACEACT_PROC + 2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_USYM</span>                  (DTRACEACT_PROC + 3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_UMOD</span>                  (DTRACEACT_PROC + 4)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_UADDR</span>                 (DTRACEACT_PROC + 5)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_PROC_DESTRUCTIVE</span>      0x0200
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_STOP</span>                  (DTRACEACT_PROC_DESTRUCTIVE + 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_RAISE</span>                 (DTRACEACT_PROC_DESTRUCTIVE + 2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_SYSTEM</span>                (DTRACEACT_PROC_DESTRUCTIVE + 3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_FREOPEN</span>               (DTRACEACT_PROC_DESTRUCTIVE + 4)
	
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
<span class="enscript-comment">/*
 * Dtrace stop() will task_suspend the currently running process.
 * Dtrace pidresume(pid) will task_resume it.
 */</span>
	
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_PIDRESUME</span>		(DTRACEACT_PROC_DESTRUCTIVE + 50)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>	

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_PROC_CONTROL</span>          0x0300

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_KERNEL</span>                0x0400
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_STACK</span>                 (DTRACEACT_KERNEL + 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_SYM</span>                   (DTRACEACT_KERNEL + 2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_MOD</span>                   (DTRACEACT_KERNEL + 3)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_KERNEL_DESTRUCTIVE</span>    0x0500
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_BREAKPOINT</span>            (DTRACEACT_KERNEL_DESTRUCTIVE + 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_PANIC</span>                 (DTRACEACT_KERNEL_DESTRUCTIVE + 2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_CHILL</span>                 (DTRACEACT_KERNEL_DESTRUCTIVE + 3)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_SPECULATIVE</span>           0x0600
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_SPECULATE</span>             (DTRACEACT_SPECULATIVE + 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_COMMIT</span>                (DTRACEACT_SPECULATIVE + 2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_DISCARD</span>               (DTRACEACT_SPECULATIVE + 3)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACEACT_CLASS</span>(x)              ((x) &amp; 0xff00)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACEACT_ISDESTRUCTIVE</span>(x)      \
        (DTRACEACT_CLASS(x) == DTRACEACT_PROC_DESTRUCTIVE || \
        DTRACEACT_CLASS(x) == DTRACEACT_KERNEL_DESTRUCTIVE)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACEACT_ISSPECULATIVE</span>(x)      \
        (DTRACEACT_CLASS(x) == DTRACEACT_SPECULATIVE)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACEACT_ISPRINTFLIKE</span>(x)       \
        ((x) == DTRACEACT_PRINTF || (x) == DTRACEACT_PRINTA || \
        (x) == DTRACEACT_SYSTEM || (x) == DTRACEACT_FREOPEN)

<span class="enscript-comment">/*
 * DTrace Aggregating Actions
 *
 * These are functions f(x) for which the following is true:
 *
 *    f(f(x_0) U f(x_1) U ... U f(x_n)) = f(x_0 U x_1 U ... U x_n)
 *
 * where x_n is a set of arbitrary data.  Aggregating actions are in their own
 * DTrace action class, DTTRACEACT_AGGREGATION.  The macros provided here allow
 * for easier processing of the aggregation argument and data payload for a few
 * aggregating actions (notably:  quantize(), lquantize(), and ustack()).
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEACT_AGGREGATION</span>           0x0700
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEAGG_COUNT</span>                 (DTRACEACT_AGGREGATION + 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEAGG_MIN</span>                   (DTRACEACT_AGGREGATION + 2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEAGG_MAX</span>                   (DTRACEACT_AGGREGATION + 3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEAGG_AVG</span>                   (DTRACEACT_AGGREGATION + 4)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEAGG_SUM</span>                   (DTRACEACT_AGGREGATION + 5)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEAGG_STDDEV</span>                (DTRACEACT_AGGREGATION + 6)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEAGG_QUANTIZE</span>              (DTRACEACT_AGGREGATION + 7)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEAGG_LQUANTIZE</span>             (DTRACEACT_AGGREGATION + 8)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEAGG_LLQUANTIZE</span>            (DTRACEACT_AGGREGATION + 9)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACEACT_ISAGG</span>(x)              \
        (DTRACEACT_CLASS(x) == DTRACEACT_AGGREGATION)

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)  <span class="enscript-comment">/* Quiet compiler warning. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_QUANTIZE_NBUCKETS</span>        \
        (((<span class="enscript-keyword">sizeof</span> (uint64_t) * NBBY) - 1) * 2 + 1)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_QUANTIZE_ZEROBUCKET</span>      ((sizeof (uint64_t) * NBBY) - 1)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_QUANTIZE_NBUCKETS</span>        \
        (<span class="enscript-type">int</span>)(((<span class="enscript-keyword">sizeof</span> (uint64_t) * NBBY) - 1) * 2 + 1)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_QUANTIZE_ZEROBUCKET</span>      (int64_t)((sizeof (uint64_t) * NBBY) - 1)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE __*/</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_QUANTIZE_BUCKETVAL</span>(buck)                                 \
        (int64_t)((buck) &lt; DTRACE_QUANTIZE_ZEROBUCKET ?                 \
        -(1LL &lt;&lt; (DTRACE_QUANTIZE_ZEROBUCKET - 1 - (buck))) :           \
        (buck) == DTRACE_QUANTIZE_ZEROBUCKET ? 0 :                      \
        1LL &lt;&lt; ((buck) - DTRACE_QUANTIZE_ZEROBUCKET - 1))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_LQUANTIZE_STEPSHIFT</span>              48
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_LQUANTIZE_STEPMASK</span>               ((uint64_t)UINT16_MAX &lt;&lt; 48)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_LQUANTIZE_LEVELSHIFT</span>             32
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_LQUANTIZE_LEVELMASK</span>              ((uint64_t)UINT16_MAX &lt;&lt; 32)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_LQUANTIZE_BASESHIFT</span>              0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_LQUANTIZE_BASEMASK</span>               UINT32_MAX

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_LQUANTIZE_STEP</span>(x)                \
        (uint16_t)(((x) &amp; DTRACE_LQUANTIZE_STEPMASK) &gt;&gt; \
        DTRACE_LQUANTIZE_STEPSHIFT)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_LQUANTIZE_LEVELS</span>(x)              \
        (uint16_t)(((x) &amp; DTRACE_LQUANTIZE_LEVELMASK) &gt;&gt; \
        DTRACE_LQUANTIZE_LEVELSHIFT)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_LQUANTIZE_BASE</span>(x)                \
        (int32_t)(((x) &amp; DTRACE_LQUANTIZE_BASEMASK) &gt;&gt; \
        DTRACE_LQUANTIZE_BASESHIFT)

#<span class="enscript-reference">define</span>  <span class="enscript-variable-name">DTRACE_LLQUANTIZE_FACTORSHIFT</span>          48
#<span class="enscript-reference">define</span>  <span class="enscript-variable-name">DTRACE_LLQUANTIZE_FACTORMASK</span>           ((uint64_t)UINT16_MAX &lt;&lt; 48)
#<span class="enscript-reference">define</span>  <span class="enscript-variable-name">DTRACE_LLQUANTIZE_LOWSHIFT</span>             32
#<span class="enscript-reference">define</span>  <span class="enscript-variable-name">DTRACE_LLQUANTIZE_LOWMASK</span>              ((uint64_t)UINT16_MAX &lt;&lt; 32)
#<span class="enscript-reference">define</span>  <span class="enscript-variable-name">DTRACE_LLQUANTIZE_HIGHSHIFT</span>            16
#<span class="enscript-reference">define</span>  <span class="enscript-variable-name">DTRACE_LLQUANTIZE_HIGHMASK</span>             ((uint64_t)UINT16_MAX &lt;&lt; 16)
#<span class="enscript-reference">define</span>  <span class="enscript-variable-name">DTRACE_LLQUANTIZE_NSTEPSHIFT</span>           0
#<span class="enscript-reference">define</span>  <span class="enscript-variable-name">DTRACE_LLQUANTIZE_NSTEPMASK</span>            UINT16_MAX

#<span class="enscript-reference">define</span>  <span class="enscript-function-name">DTRACE_LLQUANTIZE_FACTOR</span>(x)   \
        (uint16_t)(((x) &amp; DTRACE_LLQUANTIZE_FACTORMASK) &gt;&gt; \
        DTRACE_LLQUANTIZE_FACTORSHIFT)

#<span class="enscript-reference">define</span>  <span class="enscript-function-name">DTRACE_LLQUANTIZE_LOW</span>(x)    \
        (uint16_t)(((x) &amp; DTRACE_LLQUANTIZE_LOWMASK) &gt;&gt; \
        DTRACE_LLQUANTIZE_LOWSHIFT)

#<span class="enscript-reference">define</span>  <span class="enscript-function-name">DTRACE_LLQUANTIZE_HIGH</span>(x)   \
        (uint16_t)(((x) &amp; DTRACE_LLQUANTIZE_HIGHMASK) &gt;&gt; \
        DTRACE_LLQUANTIZE_HIGHSHIFT)

#<span class="enscript-reference">define</span>  <span class="enscript-function-name">DTRACE_LLQUANTIZE_NSTEP</span>(x)    \
        (uint16_t)(((x) &amp; DTRACE_LLQUANTIZE_NSTEPMASK) &gt;&gt; \
        DTRACE_LLQUANTIZE_NSTEPSHIFT)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_USTACK_NFRAMES</span>(x)        (uint32_t)((x) &amp; UINT32_MAX)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_USTACK_STRSIZE</span>(x)        (uint32_t)((x) &gt;&gt; 32)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_USTACK_ARG</span>(x, y)         \
        ((((uint64_t)(y)) &lt;&lt; 32) | ((x) &amp; UINT32_MAX))

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_LP64</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_LITTLE_ENDIAN</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_PTR</span>(type, name)  uint32_t name##pad; type *name
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_PTR</span>(type, name)  type *name; uint32_t name##pad
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_PTR</span>(type, name)  type *name
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">else</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_LP64</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_PTR</span>(type, name)  user_addr_t name
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_PTR</span>(type, name)  type *name
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

<span class="enscript-comment">/*
 * DTrace Object Format (DOF)
 *
 * DTrace programs can be persistently encoded in the DOF format so that they
 * may be embedded in other programs (for example, in an ELF file) or in the
 * dtrace driver configuration file for use in anonymous tracing.  The DOF
 * format is versioned and extensible so that it can be revised and so that
 * internal data structures can be modified or extended compatibly.  All DOF
 * structures use fixed-size types, so the 32-bit and 64-bit representations
 * are identical and consumers can use either data model transparently.
 *
 * The file layout is structured as follows:
 *
 * +---------------+-------------------+----- ... ----+---- ... ------+
 * |   dof_hdr_t   |  dof_sec_t[ ... ] |   loadable   | non-loadable  |
 * | (file header) | (section headers) | section data | section data  |
 * +---------------+-------------------+----- ... ----+---- ... ------+
 * |&lt;------------ dof_hdr.dofh_loadsz ---------------&gt;|               |
 * |&lt;------------ dof_hdr.dofh_filesz -------------------------------&gt;|
 *
 * The file header stores meta-data including a magic number, data model for
 * the instrumentation, data encoding, and properties of the DIF code within.
 * The header describes its own size and the size of the section headers.  By
 * convention, an array of section headers follows the file header, and then
 * the data for all loadable sections and unloadable sections.  This permits
 * consumer code to easily download the headers and all loadable data into the
 * DTrace driver in one contiguous chunk, omitting other extraneous sections.
 *
 * The section headers describe the size, offset, alignment, and section type
 * for each section.  Sections are described using a set of #defines that tell
 * the consumer what kind of data is expected.  Sections can contain links to
 * other sections by storing a dof_secidx_t, an index into the section header
 * array, inside of the section data structures.  The section header includes
 * an entry size so that sections with data arrays can grow their structures.
 *
 * The DOF data itself can contain many snippets of DIF (i.e. &gt;1 DIFOs), which
 * are represented themselves as a collection of related DOF sections.  This
 * permits us to change the set of sections associated with a DIFO over time,
 * and also permits us to encode DIFOs that contain different sets of sections.
 * When a DOF section wants to refer to a DIFO, it stores the dof_secidx_t of a
 * section of type DOF_SECT_DIFOHDR.  This section's data is then an array of
 * dof_secidx_t's which in turn denote the sections associated with this DIFO.
 *
 * This loose coupling of the file structure (header and sections) to the
 * structure of the DTrace program itself (ECB descriptions, action
 * descriptions, and DIFOs) permits activities such as relocation processing
 * to occur in a single pass without having to understand D program structure.
 *
 * Finally, strings are always stored in ELF-style string tables along with a
 * string table section index and string table offset.  Therefore strings in
 * DOF are always arbitrary-length and not bound to the current implementation.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ID_SIZE</span>     16      <span class="enscript-comment">/* total size of dofh_ident[] in bytes */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_hdr {
        uint8_t dofh_ident[DOF_ID_SIZE]; <span class="enscript-comment">/* identification bytes (see below) */</span>
        uint32_t dofh_flags;            <span class="enscript-comment">/* file attribute flags (if any) */</span>
        uint32_t dofh_hdrsize;          <span class="enscript-comment">/* size of file header in bytes */</span>
        uint32_t dofh_secsize;          <span class="enscript-comment">/* size of section header in bytes */</span>
        uint32_t dofh_secnum;           <span class="enscript-comment">/* number of section headers */</span>
        uint64_t dofh_secoff;           <span class="enscript-comment">/* file offset of section headers */</span>
        uint64_t dofh_loadsz;           <span class="enscript-comment">/* file size of loadable portion */</span>
        uint64_t dofh_filesz;           <span class="enscript-comment">/* file size of entire DOF file */</span>
        uint64_t dofh_pad;              <span class="enscript-comment">/* reserved for future use */</span>
} dof_hdr_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ID_MAG0</span>     0       <span class="enscript-comment">/* first byte of magic number */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ID_MAG1</span>     1       <span class="enscript-comment">/* second byte of magic number */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ID_MAG2</span>     2       <span class="enscript-comment">/* third byte of magic number */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ID_MAG3</span>     3       <span class="enscript-comment">/* fourth byte of magic number */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ID_MODEL</span>    4       <span class="enscript-comment">/* DOF data model (see below) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ID_ENCODING</span> 5       <span class="enscript-comment">/* DOF data encoding (see below) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ID_VERSION</span>  6       <span class="enscript-comment">/* DOF file format major version (see below) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ID_DIFVERS</span>  7       <span class="enscript-comment">/* DIF instruction set version */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ID_DIFIREG</span>  8       <span class="enscript-comment">/* DIF integer registers used by compiler */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ID_DIFTREG</span>  9       <span class="enscript-comment">/* DIF tuple registers used by compiler */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ID_PAD</span>      10      <span class="enscript-comment">/* start of padding bytes (all zeroes) */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_MAG_MAG0</span>    0x7F    <span class="enscript-comment">/* DOF_ID_MAG[0-3] */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_MAG_MAG1</span>    <span class="enscript-string">'D'</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_MAG_MAG2</span>    <span class="enscript-string">'O'</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_MAG_MAG3</span>    <span class="enscript-string">'F'</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_MAG_STRING</span>  <span class="enscript-string">&quot;\177DOF&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_MAG_STRLEN</span>  4

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_MODEL_NONE</span>  0       <span class="enscript-comment">/* DOF_ID_MODEL */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_MODEL_ILP32</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_MODEL_LP64</span>  2

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_LP64</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_MODEL_NATIVE</span>        DOF_MODEL_LP64
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_MODEL_NATIVE</span>        DOF_MODEL_ILP32
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ENCODE_NONE</span> 0       <span class="enscript-comment">/* DOF_ID_ENCODING */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ENCODE_LSB</span>  1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ENCODE_MSB</span>  2

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_BIG_ENDIAN</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ENCODE_NATIVE</span>       DOF_ENCODE_MSB
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_ENCODE_NATIVE</span>       DOF_ENCODE_LSB
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_VERSION_1</span>	1	<span class="enscript-comment">/* DOF version 1: Solaris 10 FCS */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_VERSION_2</span>	2	<span class="enscript-comment">/* DOF version 2: Solaris Express 6/06 */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_VERSION</span>	DOF_VERSION_2	<span class="enscript-comment">/* Latest DOF version */</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_VERSION_3</span>	3	<span class="enscript-comment">/* DOF version 3: Minimum version for Leopard */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_VERSION</span>	DOF_VERSION_3	<span class="enscript-comment">/* Latest DOF version */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_FL_VALID</span>    0       <span class="enscript-comment">/* mask of all valid dofh_flags bits */</span>

<span class="enscript-type">typedef</span> uint32_t dof_secidx_t;  <span class="enscript-comment">/* section header table index type */</span>
<span class="enscript-type">typedef</span> uint32_t dof_stridx_t;  <span class="enscript-comment">/* string table index type */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_SECIDX_NONE</span> (-1U)   <span class="enscript-comment">/* null value for section indices */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_STRIDX_NONE</span> (-1U)   <span class="enscript-comment">/* null value for string indices */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_sec {
        uint32_t dofs_type;     <span class="enscript-comment">/* section type (see below) */</span>
        uint32_t dofs_align;    <span class="enscript-comment">/* section data memory alignment */</span>
        uint32_t dofs_flags;    <span class="enscript-comment">/* section flags (if any) */</span>
        uint32_t dofs_entsize;  <span class="enscript-comment">/* size of section entry (if table) */</span>
        uint64_t dofs_offset;   <span class="enscript-comment">/* offset of section data within file */</span>
        uint64_t dofs_size;     <span class="enscript-comment">/* size of section data in bytes */</span>
} dof_sec_t;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_NONE</span>		0	<span class="enscript-comment">/* null section */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_COMMENTS</span>	1	<span class="enscript-comment">/* compiler comments */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_SOURCE</span>		2	<span class="enscript-comment">/* D program source code */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_ECBDESC</span>	3	<span class="enscript-comment">/* dof_ecbdesc_t */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_PROBEDESC</span>	4	<span class="enscript-comment">/* dof_probedesc_t */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_ACTDESC</span>	5	<span class="enscript-comment">/* dof_actdesc_t array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_DIFOHDR</span>	6	<span class="enscript-comment">/* dof_difohdr_t (variable length) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_DIF</span>		7	<span class="enscript-comment">/* uint32_t array of byte code */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_STRTAB</span>		8	<span class="enscript-comment">/* string table */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_VARTAB</span>		9	<span class="enscript-comment">/* dtrace_difv_t array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_RELTAB</span>		10	<span class="enscript-comment">/* dof_relodesc_t array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_TYPTAB</span>		11	<span class="enscript-comment">/* dtrace_diftype_t array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_URELHDR</span>	12	<span class="enscript-comment">/* dof_relohdr_t (user relocations) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_KRELHDR</span>	13	<span class="enscript-comment">/* dof_relohdr_t (kernel relocations) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_OPTDESC</span>	14	<span class="enscript-comment">/* dof_optdesc_t array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_PROVIDER</span>	15	<span class="enscript-comment">/* dof_provider_t */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_PROBES</span>		16	<span class="enscript-comment">/* dof_probe_t array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_PRARGS</span>		17	<span class="enscript-comment">/* uint8_t array (probe arg mappings) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_PROFFS</span>		18	<span class="enscript-comment">/* uint32_t array (probe arg offsets) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_INTTAB</span>		19	<span class="enscript-comment">/* uint64_t array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_UTSNAME</span>	20	<span class="enscript-comment">/* struct utsname */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_XLTAB</span>		21	<span class="enscript-comment">/* dof_xlref_t array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_XLMEMBERS</span>	22	<span class="enscript-comment">/* dof_xlmember_t array */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_XLIMPORT</span>	23	<span class="enscript-comment">/* dof_xlator_t */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_XLEXPORT</span>	24	<span class="enscript-comment">/* dof_xlator_t */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_PREXPORT</span>	25	<span class="enscript-comment">/* dof_secidx_t array (exported objs) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOF_SECT_PRENOFFS</span>	26	<span class="enscript-comment">/* uint32_t array (enabled offsets) */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_SECF_LOAD</span>           1       <span class="enscript-comment">/* section should be loaded */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_ecbdesc {
        dof_secidx_t dofe_probes;       <span class="enscript-comment">/* link to DOF_SECT_PROBEDESC */</span>
        dof_secidx_t dofe_pred;         <span class="enscript-comment">/* link to DOF_SECT_DIFOHDR */</span>
        dof_secidx_t dofe_actions;      <span class="enscript-comment">/* link to DOF_SECT_ACTDESC */</span>
        uint32_t dofe_pad;              <span class="enscript-comment">/* reserved for future use */</span>
        uint64_t dofe_uarg;             <span class="enscript-comment">/* user-supplied library argument */</span>
} dof_ecbdesc_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_probedesc {
        dof_secidx_t dofp_strtab;       <span class="enscript-comment">/* link to DOF_SECT_STRTAB section */</span>
        dof_stridx_t dofp_provider;     <span class="enscript-comment">/* provider string */</span>
        dof_stridx_t dofp_mod;          <span class="enscript-comment">/* module string */</span>
        dof_stridx_t dofp_func;         <span class="enscript-comment">/* function string */</span>
        dof_stridx_t dofp_name;         <span class="enscript-comment">/* name string */</span>
        uint32_t dofp_id;               <span class="enscript-comment">/* probe identifier (or zero) */</span>
} dof_probedesc_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_actdesc {
        dof_secidx_t dofa_difo;         <span class="enscript-comment">/* link to DOF_SECT_DIFOHDR */</span>
        dof_secidx_t dofa_strtab;       <span class="enscript-comment">/* link to DOF_SECT_STRTAB section */</span>
        uint32_t dofa_kind;             <span class="enscript-comment">/* action kind (DTRACEACT_* constant) */</span>
        uint32_t dofa_ntuple;           <span class="enscript-comment">/* number of subsequent tuple actions */</span>
        uint64_t dofa_arg;              <span class="enscript-comment">/* kind-specific argument */</span>
        uint64_t dofa_uarg;             <span class="enscript-comment">/* user-supplied argument */</span>
} dof_actdesc_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_difohdr {
        dtrace_diftype_t dofd_rtype;    <span class="enscript-comment">/* return type for this fragment */</span>
        dof_secidx_t dofd_links[1];     <span class="enscript-comment">/* variable length array of indices */</span>
} dof_difohdr_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_relohdr {
        dof_secidx_t dofr_strtab;       <span class="enscript-comment">/* link to DOF_SECT_STRTAB for names */</span>
        dof_secidx_t dofr_relsec;       <span class="enscript-comment">/* link to DOF_SECT_RELTAB for relos */</span>
        dof_secidx_t dofr_tgtsec;       <span class="enscript-comment">/* link to section we are relocating */</span>
} dof_relohdr_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_relodesc {
        dof_stridx_t dofr_name;         <span class="enscript-comment">/* string name of relocation symbol */</span>
        uint32_t dofr_type;             <span class="enscript-comment">/* relo type (DOF_RELO_* constant) */</span>
        uint64_t dofr_offset;           <span class="enscript-comment">/* byte offset for relocation */</span>
        uint64_t dofr_data;             <span class="enscript-comment">/* additional type-specific data */</span>
} dof_relodesc_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_RELO_NONE</span>   0               <span class="enscript-comment">/* empty relocation entry */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DOF_RELO_SETX</span>   1               <span class="enscript-comment">/* relocate setx value */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_optdesc {
        uint32_t dofo_option;           <span class="enscript-comment">/* option identifier */</span>
        dof_secidx_t dofo_strtab;       <span class="enscript-comment">/* string table, if string option */</span>
        uint64_t dofo_value;            <span class="enscript-comment">/* option value or string index */</span>
} dof_optdesc_t;

<span class="enscript-type">typedef</span> uint32_t dof_attr_t;            <span class="enscript-comment">/* encoded stability attributes */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DOF_ATTR</span>(n, d, c)       (((n) &lt;&lt; 24) | ((d) &lt;&lt; 16) | ((c) &lt;&lt; 8))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DOF_ATTR_NAME</span>(a)        (((a) &gt;&gt; 24) &amp; 0xff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DOF_ATTR_DATA</span>(a)        (((a) &gt;&gt; 16) &amp; 0xff)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DOF_ATTR_CLASS</span>(a)       (((a) &gt;&gt;  8) &amp; 0xff)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_provider {
	dof_secidx_t dofpv_strtab;	<span class="enscript-comment">/* link to DOF_SECT_STRTAB section */</span>
	dof_secidx_t dofpv_probes;	<span class="enscript-comment">/* link to DOF_SECT_PROBES section */</span>
	dof_secidx_t dofpv_prargs;	<span class="enscript-comment">/* link to DOF_SECT_PRARGS section */</span>
	dof_secidx_t dofpv_proffs;	<span class="enscript-comment">/* link to DOF_SECT_PROFFS section */</span>
	dof_stridx_t dofpv_name;	<span class="enscript-comment">/* provider name string */</span>
	dof_attr_t dofpv_provattr;	<span class="enscript-comment">/* provider attributes */</span>
	dof_attr_t dofpv_modattr;	<span class="enscript-comment">/* module attributes */</span>
	dof_attr_t dofpv_funcattr;	<span class="enscript-comment">/* function attributes */</span>
	dof_attr_t dofpv_nameattr;	<span class="enscript-comment">/* name attributes */</span>
	dof_attr_t dofpv_argsattr;	<span class="enscript-comment">/* args attributes */</span>
	dof_secidx_t dofpv_prenoffs;	<span class="enscript-comment">/* link to DOF_SECT_PRENOFFS section */</span>
} dof_provider_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_probe {
	uint64_t dofpr_addr;		<span class="enscript-comment">/* probe base address or offset */</span>
	dof_stridx_t dofpr_func;	<span class="enscript-comment">/* probe function string */</span>
	dof_stridx_t dofpr_name;	<span class="enscript-comment">/* probe name string */</span>
	dof_stridx_t dofpr_nargv;	<span class="enscript-comment">/* native argument type strings */</span>
	dof_stridx_t dofpr_xargv;	<span class="enscript-comment">/* translated argument type strings */</span>
	uint32_t dofpr_argidx;		<span class="enscript-comment">/* index of first argument mapping */</span>
	uint32_t dofpr_offidx;		<span class="enscript-comment">/* index of first offset entry */</span>
	uint8_t dofpr_nargc;		<span class="enscript-comment">/* native argument count */</span>
	uint8_t dofpr_xargc;		<span class="enscript-comment">/* translated argument count */</span>
	uint16_t dofpr_noffs;		<span class="enscript-comment">/* number of offset entries for probe */</span>
	uint32_t dofpr_enoffidx;	<span class="enscript-comment">/* index of first is-enabled offset */</span>
	uint16_t dofpr_nenoffs;		<span class="enscript-comment">/* number of is-enabled offsets */</span>
	uint16_t dofpr_pad1;		<span class="enscript-comment">/* reserved for future use */</span>
	uint32_t dofpr_pad2;		<span class="enscript-comment">/* reserved for future use */</span>
} dof_probe_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_xlator {
        dof_secidx_t dofxl_members;     <span class="enscript-comment">/* link to DOF_SECT_XLMEMBERS section */</span>
        dof_secidx_t dofxl_strtab;      <span class="enscript-comment">/* link to DOF_SECT_STRTAB section */</span>
        dof_stridx_t dofxl_argv;        <span class="enscript-comment">/* input parameter type strings */</span>
        uint32_t dofxl_argc;            <span class="enscript-comment">/* input parameter list length */</span>
        dof_stridx_t dofxl_type;        <span class="enscript-comment">/* output type string name */</span>
        dof_attr_t dofxl_attr;          <span class="enscript-comment">/* output stability attributes */</span>
} dof_xlator_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_xlmember {
        dof_secidx_t dofxm_difo;        <span class="enscript-comment">/* member link to DOF_SECT_DIFOHDR */</span>
        dof_stridx_t dofxm_name;        <span class="enscript-comment">/* member name */</span>
        dtrace_diftype_t dofxm_type;    <span class="enscript-comment">/* member type */</span>
} dof_xlmember_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_xlref {
        dof_secidx_t dofxr_xlator;      <span class="enscript-comment">/* link to DOF_SECT_XLATORS section */</span>
        uint32_t dofxr_member;          <span class="enscript-comment">/* index of referenced dof_xlmember */</span>
        uint32_t dofxr_argn;            <span class="enscript-comment">/* index of argument for DIF_OP_XLARG */</span>
} dof_xlref_t;

<span class="enscript-comment">/*
 * DTrace Intermediate Format Object (DIFO)
 *
 * A DIFO is used to store the compiled DIF for a D expression, its return
 * type, and its string and variable tables.  The string table is a single
 * buffer of character data into which sets instructions and variable
 * references can reference strings using a byte offset.  The variable table
 * is an array of dtrace_difv_t structures that describe the name and type of
 * each variable and the id used in the DIF code.  This structure is described
 * above in the DIF section of this header file.  The DIFO is used at both
 * user-level (in the library) and in the kernel, but the structure is never
 * passed between the two: the DOF structures form the only interface.  As a
 * result, the definition can change depending on the presence of _KERNEL.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_difo {
        dif_instr_t *dtdo_buf;          <span class="enscript-comment">/* instruction buffer */</span>
        uint64_t *dtdo_inttab;          <span class="enscript-comment">/* integer table (optional) */</span>
        <span class="enscript-type">char</span> *dtdo_strtab;              <span class="enscript-comment">/* string table (optional) */</span>
        dtrace_difv_t *dtdo_vartab;     <span class="enscript-comment">/* variable table (optional) */</span>
        uint_t dtdo_len;                <span class="enscript-comment">/* length of instruction buffer */</span>
        uint_t dtdo_intlen;             <span class="enscript-comment">/* length of integer table */</span>
        uint_t dtdo_strlen;             <span class="enscript-comment">/* length of string table */</span>
        uint_t dtdo_varlen;             <span class="enscript-comment">/* length of variable table */</span>
        dtrace_diftype_t dtdo_rtype;    <span class="enscript-comment">/* return type */</span>
        uint_t dtdo_refcnt;             <span class="enscript-comment">/* owner reference count */</span>
        uint_t dtdo_destructive;        <span class="enscript-comment">/* invokes destructive subroutines */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_KERNEL</span>
        dof_relodesc_t *dtdo_kreltab;   <span class="enscript-comment">/* kernel relocations */</span>
        dof_relodesc_t *dtdo_ureltab;   <span class="enscript-comment">/* user relocations */</span>
        <span class="enscript-type">struct</span> dt_node **dtdo_xlmtab;   <span class="enscript-comment">/* translator references */</span>
        uint_t dtdo_krelen;             <span class="enscript-comment">/* length of krelo table */</span>
        uint_t dtdo_urelen;             <span class="enscript-comment">/* length of urelo table */</span>
        uint_t dtdo_xlmlen;             <span class="enscript-comment">/* length of translator table */</span>
#<span class="enscript-reference">endif</span>
} dtrace_difo_t;

<span class="enscript-comment">/*
 * DTrace Enabling Description Structures
 *
 * When DTrace is tracking the description of a DTrace enabling entity (probe,
 * predicate, action, ECB, record, etc.), it does so in a description
 * structure.  These structures all end in &quot;desc&quot;, and are used at both
 * user-level and in the kernel -- but (with the exception of
 * dtrace_probedesc_t) they are never passed between them.  Typically,
 * user-level will use the description structures when assembling an enabling.
 * It will then distill those description structures into a DOF object (see
 * above), and send it into the kernel.  The kernel will again use the
 * description structures to create a description of the enabling as it reads
 * the DOF.  When the description is complete, the enabling will be actually
 * created -- turning it into the structures that represent the enabling
 * instead of merely describing it.  Not surprisingly, the description
 * structures bear a strong resemblance to the DOF structures that act as their
 * conduit.
 */</span>
<span class="enscript-type">struct</span> dtrace_predicate;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_probedesc {
        dtrace_id_t dtpd_id;                    <span class="enscript-comment">/* probe identifier */</span>
        <span class="enscript-type">char</span> dtpd_provider[DTRACE_PROVNAMELEN]; <span class="enscript-comment">/* probe provider name */</span>
        <span class="enscript-type">char</span> dtpd_mod[DTRACE_MODNAMELEN];       <span class="enscript-comment">/* probe module name */</span>
        <span class="enscript-type">char</span> dtpd_func[DTRACE_FUNCNAMELEN];     <span class="enscript-comment">/* probe function name */</span>
        <span class="enscript-type">char</span> dtpd_name[DTRACE_NAMELEN];         <span class="enscript-comment">/* probe name */</span>
} dtrace_probedesc_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_repldesc {
        dtrace_probedesc_t dtrpd_match;         <span class="enscript-comment">/* probe descr. to match */</span>
        dtrace_probedesc_t dtrpd_create;        <span class="enscript-comment">/* probe descr. to create */</span>
} dtrace_repldesc_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_preddesc {
        dtrace_difo_t *dtpdd_difo;              <span class="enscript-comment">/* pointer to DIF object */</span>
        <span class="enscript-type">struct</span> dtrace_predicate *dtpdd_predicate; <span class="enscript-comment">/* pointer to predicate */</span>
} dtrace_preddesc_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_actdesc {
        dtrace_difo_t *dtad_difo;               <span class="enscript-comment">/* pointer to DIF object */</span>
        <span class="enscript-type">struct</span> dtrace_actdesc *dtad_next;       <span class="enscript-comment">/* next action */</span>
        dtrace_actkind_t dtad_kind;             <span class="enscript-comment">/* kind of action */</span>
        uint32_t dtad_ntuple;                   <span class="enscript-comment">/* number in tuple */</span>
        uint64_t dtad_arg;                      <span class="enscript-comment">/* action argument */</span>
        uint64_t dtad_uarg;                     <span class="enscript-comment">/* user argument */</span>
        <span class="enscript-type">int</span> dtad_refcnt;                        <span class="enscript-comment">/* reference count */</span>
} dtrace_actdesc_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_ecbdesc {
        dtrace_actdesc_t *dted_action;          <span class="enscript-comment">/* action description(s) */</span>
        dtrace_preddesc_t dted_pred;            <span class="enscript-comment">/* predicate description */</span>
        dtrace_probedesc_t dted_probe;          <span class="enscript-comment">/* probe description */</span>
        uint64_t dted_uarg;                     <span class="enscript-comment">/* library argument */</span>
        <span class="enscript-type">int</span> dted_refcnt;                        <span class="enscript-comment">/* reference count */</span>
} dtrace_ecbdesc_t;

<span class="enscript-comment">/*
 * DTrace Metadata Description Structures
 *
 * DTrace separates the trace data stream from the metadata stream.  The only
 * metadata tokens placed in the data stream are the dtrace_rechdr_t (EPID +
 * timestamp) or (in the case of aggregations) aggregation identifiers.  To
 * determine the structure of the data, DTrace consumers pass the token to the
 * kernel, and receive in return a corresponding description of the enabled
 * probe (via the dtrace_eprobedesc structure) or the aggregation (via the
 * dtrace_aggdesc structure).  Both of these structures are expressed in terms
 * of record descriptions (via the dtrace_recdesc structure) that describe the
 * exact structure of the data.  Some record descriptions may also contain a
 * format identifier; this additional bit of metadata can be retrieved from the
 * kernel, for which a format description is returned via the dtrace_fmtdesc
 * structure.  Note that all four of these structures must be bitness-neutral
 * to allow for a 32-bit DTrace consumer on a 64-bit kernel.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_recdesc {
        dtrace_actkind_t dtrd_action;           <span class="enscript-comment">/* kind of action */</span>
        uint32_t dtrd_size;                     <span class="enscript-comment">/* size of record */</span>
        uint32_t dtrd_offset;                   <span class="enscript-comment">/* offset in ECB's data */</span>
        uint16_t dtrd_alignment;                <span class="enscript-comment">/* required alignment */</span>
        uint16_t dtrd_format;                   <span class="enscript-comment">/* format, if any */</span>
        uint64_t dtrd_arg;                      <span class="enscript-comment">/* action argument */</span>
        uint64_t dtrd_uarg;                     <span class="enscript-comment">/* user argument */</span>
} dtrace_recdesc_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_eprobedesc {
        dtrace_epid_t dtepd_epid;               <span class="enscript-comment">/* enabled probe ID */</span>
        dtrace_id_t dtepd_probeid;              <span class="enscript-comment">/* probe ID */</span>
        uint64_t dtepd_uarg;                    <span class="enscript-comment">/* library argument */</span>
        uint32_t dtepd_size;                    <span class="enscript-comment">/* total size */</span>
        <span class="enscript-type">int</span> dtepd_nrecs;                        <span class="enscript-comment">/* number of records */</span>
        dtrace_recdesc_t dtepd_rec[1];          <span class="enscript-comment">/* records themselves */</span>
} dtrace_eprobedesc_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_aggdesc {
	DTRACE_PTR(<span class="enscript-type">char</span>, dtagd_name);		<span class="enscript-comment">/* not filled in by kernel */</span>
	dtrace_aggvarid_t dtagd_varid;		<span class="enscript-comment">/* not filled in by kernel */</span>
	<span class="enscript-type">int</span> dtagd_flags;			<span class="enscript-comment">/* not filled in by kernel */</span>
	dtrace_aggid_t dtagd_id;		<span class="enscript-comment">/* aggregation ID */</span>
	dtrace_epid_t dtagd_epid;		<span class="enscript-comment">/* enabled probe ID */</span>
	uint32_t dtagd_size;			<span class="enscript-comment">/* size in bytes */</span>
	<span class="enscript-type">int</span> dtagd_nrecs;			<span class="enscript-comment">/* number of records */</span>
	uint32_t dtagd_pad;			<span class="enscript-comment">/* explicit padding */</span>
	dtrace_recdesc_t dtagd_rec[1];		<span class="enscript-comment">/* record descriptions */</span>
} dtrace_aggdesc_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_fmtdesc {
        DTRACE_PTR(<span class="enscript-type">char</span>, dtfd_string);          <span class="enscript-comment">/* format string */</span>
        <span class="enscript-type">int</span> dtfd_length;                        <span class="enscript-comment">/* length of format string */</span>
        uint16_t dtfd_format;                   <span class="enscript-comment">/* format identifier */</span>
} dtrace_fmtdesc_t;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_SIZEOF_EPROBEDESC</span>(desc)                          \
        (<span class="enscript-keyword">sizeof</span> (dtrace_eprobedesc_t) + ((desc)-&gt;dtepd_nrecs ?  \
        (((desc)-&gt;dtepd_nrecs - 1) * <span class="enscript-keyword">sizeof</span> (dtrace_recdesc_t)) : 0))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_SIZEOF_AGGDESC</span>(desc)                             \
        (<span class="enscript-keyword">sizeof</span> (dtrace_aggdesc_t) + ((desc)-&gt;dtagd_nrecs ?     \
        (((desc)-&gt;dtagd_nrecs - 1) * <span class="enscript-keyword">sizeof</span> (dtrace_recdesc_t)) : 0))

<span class="enscript-comment">/*
 * DTrace Option Interface
 *
 * Run-time DTrace options are set and retrieved via DOF_SECT_OPTDESC sections
 * in a DOF image.  The dof_optdesc structure contains an option identifier and
 * an option value.  The valid option identifiers are found below; the mapping
 * between option identifiers and option identifying strings is maintained at
 * user-level.  Note that the value of DTRACEOPT_UNSET is such that all of the
 * following are potentially valid option values:  all positive integers, zero
 * and negative one.  Some options (notably &quot;bufpolicy&quot; and &quot;bufresize&quot;) take
 * predefined tokens as their values; these are defined with
 * DTRACEOPT_{option}_{token}.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_BUFSIZE</span>	0	<span class="enscript-comment">/* buffer size */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_BUFPOLICY</span>	1	<span class="enscript-comment">/* buffer policy */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_DYNVARSIZE</span>	2	<span class="enscript-comment">/* dynamic variable size */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_AGGSIZE</span>	3	<span class="enscript-comment">/* aggregation size */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_SPECSIZE</span>	4	<span class="enscript-comment">/* speculation size */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_NSPEC</span>		5	<span class="enscript-comment">/* number of speculations */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_STRSIZE</span>	6	<span class="enscript-comment">/* string size */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_CLEANRATE</span>	7	<span class="enscript-comment">/* dynvar cleaning rate */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_CPU</span>		8	<span class="enscript-comment">/* CPU to trace */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_BUFRESIZE</span>	9	<span class="enscript-comment">/* buffer resizing policy */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_GRABANON</span>	10	<span class="enscript-comment">/* grab anonymous state, if any */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_FLOWINDENT</span>	11	<span class="enscript-comment">/* indent function entry/return */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_QUIET</span>		12	<span class="enscript-comment">/* only output explicitly traced data */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_STACKFRAMES</span>	13	<span class="enscript-comment">/* number of stack frames */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_USTACKFRAMES</span>	14	<span class="enscript-comment">/* number of user stack frames */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_AGGRATE</span>	15	<span class="enscript-comment">/* aggregation snapshot rate */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_SWITCHRATE</span>	16	<span class="enscript-comment">/* buffer switching rate */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_STATUSRATE</span>	17	<span class="enscript-comment">/* status rate */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_DESTRUCTIVE</span>	18	<span class="enscript-comment">/* destructive actions allowed */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_STACKINDENT</span>	19	<span class="enscript-comment">/* output indent for stack traces */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_RAWBYTES</span>	20	<span class="enscript-comment">/* always print bytes in raw form */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_JSTACKFRAMES</span>	21	<span class="enscript-comment">/* number of jstack() frames */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_JSTACKSTRSIZE</span>	22	<span class="enscript-comment">/* size of jstack() string table */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_AGGSORTKEY</span>	23	<span class="enscript-comment">/* sort aggregations by key */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_AGGSORTREV</span>	24	<span class="enscript-comment">/* reverse-sort aggregations */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_AGGSORTPOS</span>	25	<span class="enscript-comment">/* agg. position to sort on */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_AGGSORTKEYPOS</span>	26	<span class="enscript-comment">/* agg. key position to sort on */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_AGGHIST</span>	27 	<span class="enscript-comment">/* histogram aggregation output */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_AGGPACK</span>	28 	<span class="enscript-comment">/* packed aggregation output */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_AGGZOOM</span>	29 	<span class="enscript-comment">/* zoomed aggregation scaling */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_TEMPORAL</span>	30	<span class="enscript-comment">/* temporally ordered output */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEOPT_MAX</span>           31      <span class="enscript-comment">/* number of options */</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEOPT_STACKSYMBOLS</span>  31      <span class="enscript-comment">/* clear to prevent stack symbolication */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEOPT_MAX</span>           32      <span class="enscript-comment">/* number of options */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_UNSET</span>		(dtrace_optval_t)-2	<span class="enscript-comment">/* unset option */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_BUFPOLICY_RING</span>	0	<span class="enscript-comment">/* ring buffer */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_BUFPOLICY_FILL</span>	1	<span class="enscript-comment">/* fill buffer, then stop */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEOPT_BUFPOLICY_SWITCH</span>	2	<span class="enscript-comment">/* switch buffers */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEOPT_BUFRESIZE_AUTO</span>        0       <span class="enscript-comment">/* automatic resizing */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEOPT_BUFRESIZE_MANUAL</span>      1       <span class="enscript-comment">/* manual resizing */</span>

<span class="enscript-comment">/*
 * DTrace Buffer Interface
 *
 * In order to get a snapshot of the principal or aggregation buffer,
 * user-level passes a buffer description to the kernel with the dtrace_bufdesc
 * structure.  This describes which CPU user-level is interested in, and
 * where user-level wishes the kernel to snapshot the buffer to (the
 * dtbd_data field).  The kernel uses the same structure to pass back some
 * information regarding the buffer:  the size of data actually copied out, the
 * number of drops, the number of errors, the offset of the oldest record,
 * and the time of the snapshot.
 *
 * If the buffer policy is a &quot;switch&quot; policy, taking a snapshot of the
 * principal buffer has the additional effect of switching the active and
 * inactive buffers.  Taking a snapshot of the aggregation buffer _always_ has
 * the additional effect of switching the active and inactive buffers.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_bufdesc {
        uint64_t dtbd_size;                     <span class="enscript-comment">/* size of buffer */</span>
        uint32_t dtbd_cpu;                      <span class="enscript-comment">/* CPU or DTRACE_CPUALL */</span>
        uint32_t dtbd_errors;                   <span class="enscript-comment">/* number of errors */</span>
        uint64_t dtbd_drops;                    <span class="enscript-comment">/* number of drops */</span>
        DTRACE_PTR(<span class="enscript-type">char</span>, dtbd_data);            <span class="enscript-comment">/* data */</span>
        uint64_t dtbd_oldest;                   <span class="enscript-comment">/* offset of oldest record */</span>
	uint64_t dtbd_timestamp;		<span class="enscript-comment">/* hrtime of snapshot */</span>
} dtrace_bufdesc_t;

<span class="enscript-comment">/*
 * Each record in the buffer (dtbd_data) begins with a header that includes
 * the epid and a timestamp.  The timestamp is split into two 4-byte parts
 * so that we do not require 8-byte alignment.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_rechdr {
	dtrace_epid_t dtrh_epid;		<span class="enscript-comment">/* enabled probe id */</span>
	uint32_t dtrh_timestamp_hi;		<span class="enscript-comment">/* high bits of hrtime_t */</span>
	uint32_t dtrh_timestamp_lo;		<span class="enscript-comment">/* low bits of hrtime_t */</span>
} dtrace_rechdr_t;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_RECORD_LOAD_TIMESTAMP</span>(dtrh)			\
	((dtrh)-&gt;dtrh_timestamp_lo +				\
	((uint64_t)(dtrh)-&gt;dtrh_timestamp_hi &lt;&lt; 32))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_RECORD_STORE_TIMESTAMP</span>(dtrh, hrtime) {		\
	(dtrh)-&gt;dtrh_timestamp_lo = (uint32_t)hrtime;		\
	(dtrh)-&gt;dtrh_timestamp_hi = hrtime &gt;&gt; 32;		\
}

<span class="enscript-comment">/*
 * DTrace Status
 *
 * The status of DTrace is relayed via the dtrace_status structure.  This
 * structure contains members to count drops other than the capacity drops
 * available via the buffer interface (see above).  This consists of dynamic
 * drops (including capacity dynamic drops, rinsing drops and dirty drops), and
 * speculative drops (including capacity speculative drops, drops due to busy
 * speculative buffers and drops due to unavailable speculative buffers).
 * Additionally, the status structure contains a field to indicate the number
 * of &quot;fill&quot;-policy buffers have been filled and a boolean field to indicate
 * that exit() has been called.  If the dtst_exiting field is non-zero, no
 * further data will be generated until tracing is stopped (at which time any
 * enablings of the END action will be processed); if user-level sees that
 * this field is non-zero, tracing should be stopped as soon as possible.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_status {
        uint64_t dtst_dyndrops;                 <span class="enscript-comment">/* dynamic drops */</span>
        uint64_t dtst_dyndrops_rinsing;         <span class="enscript-comment">/* dyn drops due to rinsing */</span>
        uint64_t dtst_dyndrops_dirty;           <span class="enscript-comment">/* dyn drops due to dirty */</span>
        uint64_t dtst_specdrops;                <span class="enscript-comment">/* speculative drops */</span>
        uint64_t dtst_specdrops_busy;           <span class="enscript-comment">/* spec drops due to busy */</span>
        uint64_t dtst_specdrops_unavail;        <span class="enscript-comment">/* spec drops due to unavail */</span>
        uint64_t dtst_errors;                   <span class="enscript-comment">/* total errors */</span>
        uint64_t dtst_filled;                   <span class="enscript-comment">/* number of filled bufs */</span>
        uint64_t dtst_stkstroverflows;          <span class="enscript-comment">/* stack string tab overflows */</span>
        uint64_t dtst_dblerrors;                <span class="enscript-comment">/* errors in ERROR probes */</span>
        <span class="enscript-type">char</span> dtst_killed;                       <span class="enscript-comment">/* non-zero if killed */</span>
        <span class="enscript-type">char</span> dtst_exiting;                      <span class="enscript-comment">/* non-zero if exit() called */</span>
        <span class="enscript-type">char</span> dtst_pad[6];                       <span class="enscript-comment">/* pad out to 64-bit align */</span>
} dtrace_status_t;

<span class="enscript-comment">/*
 * DTrace Configuration
 *
 * User-level may need to understand some elements of the kernel DTrace
 * configuration in order to generate correct DIF.  This information is
 * conveyed via the dtrace_conf structure.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_conf {
        uint_t dtc_difversion;                  <span class="enscript-comment">/* supported DIF version */</span>
        uint_t dtc_difintregs;                  <span class="enscript-comment">/* # of DIF integer registers */</span>
        uint_t dtc_diftupregs;                  <span class="enscript-comment">/* # of DIF tuple registers */</span>
        uint_t dtc_ctfmodel;                    <span class="enscript-comment">/* CTF data model */</span>
        uint_t dtc_pad[8];                      <span class="enscript-comment">/* reserved for future use */</span>
} dtrace_conf_t;

<span class="enscript-comment">/*
 * DTrace Faults
 *
 * The constants below DTRACEFLT_LIBRARY indicate probe processing faults;
 * constants at or above DTRACEFLT_LIBRARY indicate faults in probe
 * postprocessing at user-level.  Probe processing faults induce an ERROR
 * probe and are replicated in unistd.d to allow users' ERROR probes to decode
 * the error condition using thse symbolic labels.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEFLT_UNKNOWN</span>               0       <span class="enscript-comment">/* Unknown fault */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEFLT_BADADDR</span>               1       <span class="enscript-comment">/* Bad address */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEFLT_BADALIGN</span>              2       <span class="enscript-comment">/* Bad alignment */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEFLT_ILLOP</span>                 3       <span class="enscript-comment">/* Illegal operation */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEFLT_DIVZERO</span>               4       <span class="enscript-comment">/* Divide-by-zero */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEFLT_NOSCRATCH</span>             5       <span class="enscript-comment">/* Out of scratch space */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEFLT_KPRIV</span>                 6       <span class="enscript-comment">/* Illegal kernel access */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEFLT_UPRIV</span>                 7       <span class="enscript-comment">/* Illegal user access */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEFLT_TUPOFLOW</span>              8       <span class="enscript-comment">/* Tuple stack overflow */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEFLT_BADSTACK</span>		9	<span class="enscript-comment">/* Bad stack */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEFLT_LIBRARY</span>               1000    <span class="enscript-comment">/* Library-level fault */</span>

<span class="enscript-comment">/*
 * DTrace Argument Types
 *
 * Because it would waste both space and time, argument types do not reside
 * with the probe.  In order to determine argument types for args[X]
 * variables, the D compiler queries for argument types on a probe-by-probe
 * basis.  (This optimizes for the common case that arguments are either not
 * used or used in an untyped fashion.)  Typed arguments are specified with a
 * string of the type name in the dtragd_native member of the argument
 * description structure.  Typed arguments may be further translated to types
 * of greater stability; the provider indicates such a translated argument by
 * filling in the dtargd_xlate member with the string of the translated type.
 * Finally, the provider may indicate which argument value a given argument
 * maps to by setting the dtargd_mapping member -- allowing a single argument
 * to map to multiple args[X] variables.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_argdesc {
        dtrace_id_t dtargd_id;                  <span class="enscript-comment">/* probe identifier */</span>
        <span class="enscript-type">int</span> dtargd_ndx;                         <span class="enscript-comment">/* arg number (-1 iff none) */</span>
        <span class="enscript-type">int</span> dtargd_mapping;                     <span class="enscript-comment">/* value mapping */</span>
        <span class="enscript-type">char</span> dtargd_native[DTRACE_ARGTYPELEN];  <span class="enscript-comment">/* native type name */</span>
        <span class="enscript-type">char</span> dtargd_xlate[DTRACE_ARGTYPELEN];   <span class="enscript-comment">/* translated type name */</span>
} dtrace_argdesc_t;

<span class="enscript-comment">/*
 * DTrace Stability Attributes
 *
 * Each DTrace provider advertises the name and data stability of each of its
 * probe description components, as well as its architectural dependencies.
 * The D compiler can query the provider attributes (dtrace_pattr_t below) in
 * order to compute the properties of an input program and report them.
 */</span>
<span class="enscript-type">typedef</span> uint8_t dtrace_stability_t;     <span class="enscript-comment">/* stability code (see attributes(5)) */</span>
<span class="enscript-type">typedef</span> uint8_t dtrace_class_t;         <span class="enscript-comment">/* architectural dependency class */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_STABILITY_INTERNAL</span>	0	<span class="enscript-comment">/* private to DTrace itself */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_STABILITY_PRIVATE</span>	1	<span class="enscript-comment">/* private to Sun (see docs) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_STABILITY_OBSOLETE</span>	2	<span class="enscript-comment">/* scheduled for removal */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_STABILITY_EXTERNAL</span>	3	<span class="enscript-comment">/* not controlled by Sun */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_STABILITY_UNSTABLE</span>	4	<span class="enscript-comment">/* new or rapidly changing */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_STABILITY_EVOLVING</span>	5	<span class="enscript-comment">/* less rapidly changing */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_STABILITY_STABLE</span>		6	<span class="enscript-comment">/* mature interface from Sun */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_STABILITY_STANDARD</span>	7	<span class="enscript-comment">/* industry standard */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_STABILITY_MAX</span>		7	<span class="enscript-comment">/* maximum valid stability */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CLASS_UNKNOWN</span>	0	<span class="enscript-comment">/* unknown architectural dependency */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CLASS_CPU</span>	1	<span class="enscript-comment">/* CPU-module-specific */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CLASS_PLATFORM</span>	2	<span class="enscript-comment">/* platform-specific (uname -i) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CLASS_GROUP</span>	3	<span class="enscript-comment">/* hardware-group-specific (uname -m) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CLASS_ISA</span>	4	<span class="enscript-comment">/* ISA-specific (uname -p) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CLASS_COMMON</span>	5	<span class="enscript-comment">/* common to all systems */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_CLASS_MAX</span>	5	<span class="enscript-comment">/* maximum valid class */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_PRIV_NONE</span>	0x0000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_PRIV_KERNEL</span>	0x0001
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_PRIV_USER</span>	0x0002
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_PRIV_PROC</span>	0x0004
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_PRIV_OWNER</span>	0x0008
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_PRIV_ZONEOWNER</span>	0x0010

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_PRIV_ALL</span>	\
	(DTRACE_PRIV_KERNEL | DTRACE_PRIV_USER | \
	DTRACE_PRIV_PROC | DTRACE_PRIV_OWNER | DTRACE_PRIV_ZONEOWNER)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_ppriv {
	uint32_t dtpp_flags;			<span class="enscript-comment">/* privilege flags */</span>
	uid_t dtpp_uid;				<span class="enscript-comment">/* user ID */</span>
	zoneid_t dtpp_zoneid;			<span class="enscript-comment">/* zone ID */</span>
} dtrace_ppriv_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_attribute {
        dtrace_stability_t dtat_name;           <span class="enscript-comment">/* entity name stability */</span>
        dtrace_stability_t dtat_data;           <span class="enscript-comment">/* entity data stability */</span>
        dtrace_class_t dtat_class;              <span class="enscript-comment">/* entity data dependency */</span>
} dtrace_attribute_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_pattr {
        dtrace_attribute_t dtpa_provider;       <span class="enscript-comment">/* provider attributes */</span>
        dtrace_attribute_t dtpa_mod;            <span class="enscript-comment">/* module attributes */</span>
        dtrace_attribute_t dtpa_func;           <span class="enscript-comment">/* function attributes */</span>
        dtrace_attribute_t dtpa_name;           <span class="enscript-comment">/* name attributes */</span>
        dtrace_attribute_t dtpa_args;           <span class="enscript-comment">/* args[] attributes */</span>
} dtrace_pattr_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_providerdesc {
        <span class="enscript-type">char</span> dtvd_name[DTRACE_PROVNAMELEN];     <span class="enscript-comment">/* provider name */</span>
        dtrace_pattr_t dtvd_attr;               <span class="enscript-comment">/* stability attributes */</span>
        dtrace_ppriv_t dtvd_priv;               <span class="enscript-comment">/* privileges required */</span>
} dtrace_providerdesc_t;

<span class="enscript-comment">/*
 * DTrace Pseudodevice Interface
 *
 * DTrace is controlled through ioctl(2)'s to the in-kernel dtrace:dtrace
 * pseudodevice driver.  These ioctls comprise the user-kernel interface to
 * DTrace.
 */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC</span>               ((<span class="enscript-string">'d'</span> &lt;&lt; 24) | (<span class="enscript-string">'t'</span> &lt;&lt; 16) | (<span class="enscript-string">'r'</span> &lt;&lt; 8))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_PROVIDER</span>      (DTRACEIOC | 1)         <span class="enscript-comment">/* provider query */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_PROBES</span>        (DTRACEIOC | 2)         <span class="enscript-comment">/* probe query */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_BUFSNAP</span>       (DTRACEIOC | 4)         <span class="enscript-comment">/* snapshot buffer */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_PROBEMATCH</span>    (DTRACEIOC | 5)         <span class="enscript-comment">/* match probes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_ENABLE</span>        (DTRACEIOC | 6)         <span class="enscript-comment">/* enable probes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_AGGSNAP</span>       (DTRACEIOC | 7)         <span class="enscript-comment">/* snapshot agg. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_EPROBE</span>        (DTRACEIOC | 8)         <span class="enscript-comment">/* get eprobe desc. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_PROBEARG</span>      (DTRACEIOC | 9)         <span class="enscript-comment">/* get probe arg */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_CONF</span>          (DTRACEIOC | 10)        <span class="enscript-comment">/* get config. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_STATUS</span>        (DTRACEIOC | 11)        <span class="enscript-comment">/* get status */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_GO</span>            (DTRACEIOC | 12)        <span class="enscript-comment">/* start tracing */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_STOP</span>          (DTRACEIOC | 13)        <span class="enscript-comment">/* stop tracing */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_AGGDESC</span>       (DTRACEIOC | 15)        <span class="enscript-comment">/* get agg. desc. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_FORMAT</span>        (DTRACEIOC | 16)        <span class="enscript-comment">/* get format str */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_DOFGET</span>        (DTRACEIOC | 17)        <span class="enscript-comment">/* get DOF */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_REPLICATE</span>     (DTRACEIOC | 18)        <span class="enscript-comment">/* replicate enab */</span>
#<span class="enscript-reference">else</span>
<span class="enscript-comment">/* coding this as IOC_VOID allows this driver to handle its own copyin/copuout */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC</span>               _IO(<span class="enscript-string">'d'</span>,0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_PROVIDER</span>      (DTRACEIOC | 1)         <span class="enscript-comment">/* provider query */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_PROBES</span>        (DTRACEIOC | 2)         <span class="enscript-comment">/* probe query */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_BUFSNAP</span>       (DTRACEIOC | 4)         <span class="enscript-comment">/* snapshot buffer */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_PROBEMATCH</span>    (DTRACEIOC | 5)         <span class="enscript-comment">/* match probes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_ENABLE</span>        (DTRACEIOC | 6)         <span class="enscript-comment">/* enable probes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_AGGSNAP</span>       (DTRACEIOC | 7)         <span class="enscript-comment">/* snapshot agg. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_EPROBE</span>        (DTRACEIOC | 8)         <span class="enscript-comment">/* get eprobe desc. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_PROBEARG</span>      (DTRACEIOC | 9)         <span class="enscript-comment">/* get probe arg */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_CONF</span>          (DTRACEIOC | 10)        <span class="enscript-comment">/* get config. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_STATUS</span>        (DTRACEIOC | 11)        <span class="enscript-comment">/* get status */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_GO</span>            (DTRACEIOC | 12)        <span class="enscript-comment">/* start tracing */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_STOP</span>          (DTRACEIOC | 13)        <span class="enscript-comment">/* stop tracing */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_AGGDESC</span>       (DTRACEIOC | 15)        <span class="enscript-comment">/* get agg. desc. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_FORMAT</span>        (DTRACEIOC | 16)        <span class="enscript-comment">/* get format str */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_DOFGET</span>        (DTRACEIOC | 17)        <span class="enscript-comment">/* get DOF */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_REPLICATE</span>     (DTRACEIOC | 18)        <span class="enscript-comment">/* replicate enab */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_MODUUIDSLIST</span>	(DTRACEIOC | 30)	<span class="enscript-comment">/* APPLE ONLY, query for modules with missing symbols */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_PROVMODSYMS</span>	(DTRACEIOC | 31)	<span class="enscript-comment">/* APPLE ONLY, provide missing symbols for a given module */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEIOC_PROCWAITFOR</span>	(DTRACEIOC | 32)	<span class="enscript-comment">/* APPLE ONLY, wait for process exec */</span>

<span class="enscript-comment">/*
 * The following structs are used to provide symbol information to the kernel from userspace.
 */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_symbol {
	uint64_t	dtsym_addr;			<span class="enscript-comment">/* address of the symbol */</span>
	uint64_t	dtsym_size;			<span class="enscript-comment">/* size of the symbol, must be uint64_t to maintain alignment when called by 64b uproc in i386 kernel */</span>
	<span class="enscript-type">char</span> 		dtsym_name[DTRACE_FUNCNAMELEN];	<span class="enscript-comment">/* symbol name */</span>
} dtrace_symbol_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_module_symbols {
	UUID		dtmodsyms_uuid;
	uint64_t	dtmodsyms_count;
	dtrace_symbol_t	dtmodsyms_symbols[1];
} dtrace_module_symbols_t;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_MODULE_SYMBOLS_SIZE</span>(count) (sizeof(dtrace_module_symbols_t) + ((count - 1) * sizeof(dtrace_symbol_t)))

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_module_uuids_list {
	uint64_t	dtmul_count;
	UUID		dtmul_uuid[1];
} dtrace_module_uuids_list_t;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_MODULE_UUIDS_LIST_SIZE</span>(count) (sizeof(dtrace_module_uuids_list_t) + ((count - 1) * sizeof(UUID)))

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_procdesc {
	<span class="enscript-comment">/* Must be specified by user-space */</span>
	<span class="enscript-type">char</span>		p_name[128];
	<span class="enscript-comment">/* Set or modified by the Kernel */</span>
	<span class="enscript-type">int</span>		p_name_length;
	pid_t		p_pid;
} dtrace_procdesc_t;

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

<span class="enscript-comment">/*
 * DTrace Helpers
 *
 * In general, DTrace establishes probes in processes and takes actions on
 * processes without knowing their specific user-level structures.  Instead of
 * existing in the framework, process-specific knowledge is contained by the
 * enabling D program -- which can apply process-specific knowledge by making
 * appropriate use of DTrace primitives like copyin() and copyinstr() to
 * operate on user-level data.  However, there may exist some specific probes
 * of particular semantic relevance that the application developer may wish to
 * explicitly export.  For example, an application may wish to export a probe
 * at the point that it begins and ends certain well-defined transactions.  In
 * addition to providing probes, programs may wish to offer assistance for
 * certain actions.  For example, in highly dynamic environments (e.g., Java),
 * it may be difficult to obtain a stack trace in terms of meaningful symbol
 * names (the translation from instruction addresses to corresponding symbol
 * names may only be possible in situ); these environments may wish to define
 * a series of actions to be applied in situ to obtain a meaningful stack
 * trace.
 *
 * These two mechanisms -- user-level statically defined tracing and assisting
 * DTrace actions -- are provided via DTrace _helpers_.  Helpers are specified
 * via DOF, but unlike enabling DOF, helper DOF may contain definitions of
 * providers, probes and their arguments.  If a helper wishes to provide
 * action assistance, probe descriptions and corresponding DIF actions may be
 * specified in the helper DOF.  For such helper actions, however, the probe
 * description describes the specific helper:  all DTrace helpers have the
 * provider name &quot;dtrace&quot; and the module name &quot;helper&quot;, and the name of the
 * helper is contained in the function name (for example, the ustack() helper
 * is named &quot;ustack&quot;).  Any helper-specific name may be contained in the name
 * (for example, if a helper were to have a constructor, it might be named
 * &quot;dtrace:helper:&lt;helper&gt;:init&quot;).  Helper actions are only called when the
 * action that they are helping is taken.  Helper actions may only return DIF
 * expressions, and may only call the following subroutines:
 *
 *    alloca()      &lt;= Allocates memory out of the consumer's scratch space
 *    bcopy()       &lt;= Copies memory to scratch space
 *    copyin()      &lt;= Copies memory from user-level into consumer's scratch
 *    copyinto()    &lt;= Copies memory into a specific location in scratch
 *    copyinstr()   &lt;= Copies a string into a specific location in scratch
 *
 * Helper actions may only access the following built-in variables:
 *
 *    curthread     &lt;= Current kthread_t pointer
 *    tid           &lt;= Current thread identifier
 *    pid           &lt;= Current process identifier
 *    ppid          &lt;= Parent process identifier
 *    uid           &lt;= Current user ID
 *    gid           &lt;= Current group ID
 *    execname      &lt;= Current executable name
 *    zonename      &lt;= Current zone name
 *
 * Helper actions may not manipulate or allocate dynamic variables, but they
 * may have clause-local and statically-allocated global variables.  The
 * helper action variable state is specific to the helper action -- variables
 * used by the helper action may not be accessed outside of the helper
 * action, and the helper action may not access variables that like outside
 * of it.  Helper actions may not load from kernel memory at-large; they are
 * restricting to loading current user state (via copyin() and variants) and
 * scratch space.  As with probe enablings, helper actions are executed in
 * program order.  The result of the helper action is the result of the last
 * executing helper expression.
 *
 * Helpers -- composed of either providers/probes or probes/actions (or both)
 * -- are added by opening the &quot;helper&quot; minor node, and issuing an ioctl(2)
 * (DTRACEHIOC_ADDDOF) that specifies the dof_helper_t structure. This
 * encapsulates the name and base address of the user-level library or
 * executable publishing the helpers and probes as well as the DOF that
 * contains the definitions of those helpers and probes.
 *
 * The DTRACEHIOC_ADD and DTRACEHIOC_REMOVE are left in place for legacy
 * helpers and should no longer be used.  No other ioctls are valid on the
 * helper minor node.
 */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEHIOC</span>              ((<span class="enscript-string">'d'</span> &lt;&lt; 24) | (<span class="enscript-string">'t'</span> &lt;&lt; 16) | (<span class="enscript-string">'h'</span> &lt;&lt; 8))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEHIOC_ADD</span>          (DTRACEHIOC | 1)        <span class="enscript-comment">/* add helper */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEHIOC_REMOVE</span>       (DTRACEHIOC | 2)        <span class="enscript-comment">/* remove helper */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEHIOC_ADDDOF</span>       (DTRACEHIOC | 3)        <span class="enscript-comment">/* add helper DOF */</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEHIOC_REMOVE</span>	_IO(<span class="enscript-string">'h'</span>, 2)			<span class="enscript-comment">/* remove helper */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEHIOC_ADDDOF</span>	_IOW(<span class="enscript-string">'h'</span>, 4, user_addr_t)	<span class="enscript-comment">/* add helper DOF */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_helper {
        <span class="enscript-type">char</span> dofhp_mod[DTRACE_MODNAMELEN];      <span class="enscript-comment">/* executable or library name */</span>
        uint64_t dofhp_addr;                    <span class="enscript-comment">/* base address of object */</span>
        uint64_t dofhp_dof;                     <span class="enscript-comment">/* address of helper DOF */</span>
} dof_helper_t;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
<span class="enscript-comment">/*
 * This structure is used to register one or more dof_helper_t(s).
 * For counts greater than one, malloc the structure as if the
 * dofiod_helpers field was &quot;count&quot; sized. The kernel will copyin
 * data of size:
 *
 * sizeof(dof_ioctl_data_t) + ((count - 1) * sizeof(dof_helper_t))
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dof_ioctl_data {
	<span class="enscript-comment">/*
	 * This field must be 64 bits to keep the alignment the same
	 * when 64 bit user procs are sending data to 32 bit xnu
	 */</span>
	uint64_t dofiod_count;
	dof_helper_t dofiod_helpers[1];
} dof_ioctl_data_t;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DOF_IOCTL_DATA_T_SIZE</span>(count) (sizeof(dof_ioctl_data_t) + ((count - 1) * sizeof(dof_helper_t)))

#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEMNR_DTRACE</span>        <span class="enscript-string">&quot;dtrace&quot;</span>        <span class="enscript-comment">/* node for DTrace ops */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACEMNR_HELPER</span>	<span class="enscript-string">&quot;helper&quot;</span>	<span class="enscript-comment">/* node for helpers */</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEMNR_HELPER</span>        <span class="enscript-string">&quot;dtracehelper&quot;</span>  <span class="enscript-comment">/* node for helpers */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEMNRN_DTRACE</span>       0               <span class="enscript-comment">/* minor for DTrace ops */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEMNRN_HELPER</span>       1               <span class="enscript-comment">/* minor for helpers */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACEMNRN_CLONE</span>        2               <span class="enscript-comment">/* first clone minor */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_KERNEL</span>

<span class="enscript-comment">/*
 * DTrace Provider API
 *
 * The following functions are implemented by the DTrace framework and are
 * used to implement separate in-kernel DTrace providers.  Common functions
 * are provided in uts/common/os/dtrace.c.  ISA-dependent subroutines are
 * defined in uts/&lt;isa&gt;/dtrace/dtrace_asm.s or uts/&lt;isa&gt;/dtrace/dtrace_isa.c.
 *
 * The provider API has two halves:  the API that the providers consume from
 * DTrace, and the API that providers make available to DTrace.
 *
 * 1 Framework-to-Provider API
 *
 * 1.1  Overview
 *
 * The Framework-to-Provider API is represented by the dtrace_pops structure
 * that the provider passes to the framework when registering itself.  This
 * structure consists of the following members:
 *
 *   dtps_provide()          &lt;-- Provide all probes, all modules
 *   dtps_provide_module()   &lt;-- Provide all probes in specified module
 *   dtps_enable()           &lt;-- Enable specified probe
 *   dtps_disable()          &lt;-- Disable specified probe
 *   dtps_suspend()          &lt;-- Suspend specified probe
 *   dtps_resume()           &lt;-- Resume specified probe
 *   dtps_getargdesc()       &lt;-- Get the argument description for args[X]
 *   dtps_getargval()        &lt;-- Get the value for an argX or args[X] variable
 *   dtps_usermode()         &lt;-- Find out if the probe was fired in user mode
 *   dtps_destroy()          &lt;-- Destroy all state associated with this probe
 *
 * 1.2  void dtps_provide(void *arg, const dtrace_probedesc_t *spec)
 *
 * 1.2.1  Overview
 *
 *   Called to indicate that the provider should provide all probes.  If the
 *   specified description is non-NULL, dtps_provide() is being called because
 *   no probe matched a specified probe -- if the provider has the ability to
 *   create custom probes, it may wish to create a probe that matches the
 *   specified description.
 *
 * 1.2.2  Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_register().  The
 *   second argument is a pointer to a probe description that the provider may
 *   wish to consider when creating custom probes.  The provider is expected to
 *   call back into the DTrace framework via dtrace_probe_create() to create
 *   any necessary probes.  dtps_provide() may be called even if the provider
 *   has made available all probes; the provider should check the return value
 *   of dtrace_probe_create() to handle this case.  Note that the provider need
 *   not implement both dtps_provide() and dtps_provide_module(); see
 *   &quot;Arguments and Notes&quot; for dtrace_register(), below.
 *
 * 1.2.3  Return value
 *
 *   None.
 *
 * 1.2.4  Caller's context
 *
 *   dtps_provide() is typically called from open() or ioctl() context, but may
 *   be called from other contexts as well.  The DTrace framework is locked in
 *   such a way that providers may not register or unregister.  This means that
 *   the provider may not call any DTrace API that affects its registration with
 *   the framework, including dtrace_register(), dtrace_unregister(),
 *   dtrace_invalidate(), and dtrace_condense().  However, the context is such
 *   that the provider may (and indeed, is expected to) call probe-related
 *   DTrace routines, including dtrace_probe_create(), dtrace_probe_lookup(),
 *   and dtrace_probe_arg().
 *
 * 1.3  void dtps_provide_module(void *arg, struct modctl *mp)
 *
 * 1.3.1  Overview
 *
 *   Called to indicate that the provider should provide all probes in the
 *   specified module.
 *
 * 1.3.2  Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_register().  The
 *   second argument is a pointer to a modctl structure that indicates the
 *   module for which probes should be created.
 *
 * 1.3.3  Return value
 *
 *   None.
 *
 * 1.3.4  Caller's context
 *
 *   dtps_provide_module() may be called from open() or ioctl() context, but
 *   may also be called from a module loading context.  mod_lock is held, and
 *   the DTrace framework is locked in such a way that providers may not
 *   register or unregister.  This means that the provider may not call any
 *   DTrace API that affects its registration with the framework, including
 *   dtrace_register(), dtrace_unregister(), dtrace_invalidate(), and
 *   dtrace_condense().  However, the context is such that the provider may (and
 *   indeed, is expected to) call probe-related DTrace routines, including
 *   dtrace_probe_create(), dtrace_probe_lookup(), and dtrace_probe_arg().  Note
 *   that the provider need not implement both dtps_provide() and
 *   dtps_provide_module(); see &quot;Arguments and Notes&quot; for dtrace_register(),
 *   below.
 *
 * 1.4  int dtps_enable(void *arg, dtrace_id_t id, void *parg)
 *
 * 1.4.1  Overview
 *
 *   Called to enable the specified probe.
 *
 * 1.4.2  Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_register().  The
 *   second argument is the identifier of the probe to be enabled.  The third
 *   argument is the probe argument as passed to dtrace_probe_create().
 *   dtps_enable() will be called when a probe transitions from not being
 *   enabled at all to having one or more ECB.  The number of ECBs associated
 *   with the probe may change without subsequent calls into the provider.
 *   When the number of ECBs drops to zero, the provider will be explicitly
 *   told to disable the probe via dtps_disable().  dtrace_probe() should never
 *   be called for a probe identifier that hasn't been explicitly enabled via
 *   dtps_enable().
 *
 * 1.4.3  Return value
 *
 *   On success, dtps_enable() should return 0. On failure, -1 should be
 *   returned.
 *
 * 1.4.4  Caller's context
 *
 *   The DTrace framework is locked in such a way that it may not be called
 *   back into at all.  cpu_lock is held.  mod_lock is not held and may not
 *   be acquired.
 *
 * 1.5  void dtps_disable(void *arg, dtrace_id_t id, void *parg)
 *
 * 1.5.1  Overview
 *
 *   Called to disable the specified probe.
 *
 * 1.5.2  Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_register().  The
 *   second argument is the identifier of the probe to be disabled.  The third
 *   argument is the probe argument as passed to dtrace_probe_create().
 *   dtps_disable() will be called when a probe transitions from being enabled
 *   to having zero ECBs.  dtrace_probe() should never be called for a probe
 *   identifier that has been explicitly enabled via dtps_disable().
 *
 * 1.5.3  Return value
 *
 *   None.
 *
 * 1.5.4  Caller's context
 *
 *   The DTrace framework is locked in such a way that it may not be called
 *   back into at all.  cpu_lock is held.  mod_lock is not held and may not
 *   be acquired.
 *
 * 1.6  void dtps_suspend(void *arg, dtrace_id_t id, void *parg)
 *
 * 1.6.1  Overview
 *
 *   Called to suspend the specified enabled probe.  This entry point is for
 *   providers that may need to suspend some or all of their probes when CPUs
 *   are being powered on or when the boot monitor is being entered for a
 *   prolonged period of time.
 *
 * 1.6.2  Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_register().  The
 *   second argument is the identifier of the probe to be suspended.  The
 *   third argument is the probe argument as passed to dtrace_probe_create().
 *   dtps_suspend will only be called on an enabled probe.  Providers that
 *   provide a dtps_suspend entry point will want to take roughly the action
 *   that it takes for dtps_disable.
 *
 * 1.6.3  Return value
 *
 *   None.
 *
 * 1.6.4  Caller's context
 *
 *   Interrupts are disabled.  The DTrace framework is in a state such that the
 *   specified probe cannot be disabled or destroyed for the duration of
 *   dtps_suspend().  As interrupts are disabled, the provider is afforded
 *   little latitude; the provider is expected to do no more than a store to
 *   memory.
 *
 * 1.7  void dtps_resume(void *arg, dtrace_id_t id, void *parg)
 *
 * 1.7.1  Overview
 *
 *   Called to resume the specified enabled probe.  This entry point is for
 *   providers that may need to resume some or all of their probes after the
 *   completion of an event that induced a call to dtps_suspend().
 *
 * 1.7.2  Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_register().  The
 *   second argument is the identifier of the probe to be resumed.  The
 *   third argument is the probe argument as passed to dtrace_probe_create().
 *   dtps_resume will only be called on an enabled probe.  Providers that
 *   provide a dtps_resume entry point will want to take roughly the action
 *   that it takes for dtps_enable.
 *
 * 1.7.3  Return value
 *
 *   None.
 *
 * 1.7.4  Caller's context
 *
 *   Interrupts are disabled.  The DTrace framework is in a state such that the
 *   specified probe cannot be disabled or destroyed for the duration of
 *   dtps_resume().  As interrupts are disabled, the provider is afforded
 *   little latitude; the provider is expected to do no more than a store to
 *   memory.
 *
 * 1.8  void dtps_getargdesc(void *arg, dtrace_id_t id, void *parg,
 *           dtrace_argdesc_t *desc)
 *
 * 1.8.1  Overview
 *
 *   Called to retrieve the argument description for an args[X] variable.
 *
 * 1.8.2  Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_register(). The
 *   second argument is the identifier of the current probe. The third
 *   argument is the probe argument as passed to dtrace_probe_create(). The
 *   fourth argument is a pointer to the argument description.  This
 *   description is both an input and output parameter:  it contains the
 *   index of the desired argument in the dtargd_ndx field, and expects
 *   the other fields to be filled in upon return.  If there is no argument
 *   corresponding to the specified index, the dtargd_ndx field should be set
 *   to DTRACE_ARGNONE.
 *
 * 1.8.3  Return value
 *
 *   None.  The dtargd_ndx, dtargd_native, dtargd_xlate and dtargd_mapping
 *   members of the dtrace_argdesc_t structure are all output values.
 *
 * 1.8.4  Caller's context
 *
 *   dtps_getargdesc() is called from ioctl() context. mod_lock is held, and
 *   the DTrace framework is locked in such a way that providers may not
 *   register or unregister.  This means that the provider may not call any
 *   DTrace API that affects its registration with the framework, including
 *   dtrace_register(), dtrace_unregister(), dtrace_invalidate(), and
 *   dtrace_condense().
 *
 * 1.9  uint64_t dtps_getargval(void *arg, dtrace_id_t id, void *parg,
 *               int argno, int aframes)
 *
 * 1.9.1  Overview
 *
 *   Called to retrieve a value for an argX or args[X] variable.
 *
 * 1.9.2  Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_register(). The
 *   second argument is the identifier of the current probe. The third
 *   argument is the probe argument as passed to dtrace_probe_create(). The
 *   fourth argument is the number of the argument (the X in the example in
 *   1.9.1). The fifth argument is the number of stack frames that were used
 *   to get from the actual place in the code that fired the probe to
 *   dtrace_probe() itself, the so-called artificial frames. This argument may
 *   be used to descend an appropriate number of frames to find the correct
 *   values. If this entry point is left NULL, the dtrace_getarg() built-in
 *   function is used.
 *
 * 1.9.3  Return value
 *
 *   The value of the argument.
 *
 * 1.9.4  Caller's context
 *
 *   This is called from within dtrace_probe() meaning that interrupts
 *   are disabled. No locks should be taken within this entry point.
 *
 * 1.10  int dtps_usermode(void *arg, dtrace_id_t id, void *parg)
 *
 * 1.10.1  Overview
 *
 *   Called to determine if the probe was fired in a user context.
 *
 * 1.10.2  Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_register(). The
 *   second argument is the identifier of the current probe. The third
 *   argument is the probe argument as passed to dtrace_probe_create().  This
 *   entry point must not be left NULL for providers whose probes allow for
 *   mixed mode tracing, that is to say those probes that can fire during
 *   kernel- _or_ user-mode execution
 *
 * 1.10.3  Return value
 *
 *   A boolean value.
 *
 * 1.10.4  Caller's context
 *
 *   This is called from within dtrace_probe() meaning that interrupts
 *   are disabled. No locks should be taken within this entry point.
 *
 * 1.11 void dtps_destroy(void *arg, dtrace_id_t id, void *parg)
 *
 * 1.11.1 Overview
 *
 *   Called to destroy the specified probe.
 *
 * 1.11.2 Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_register().  The
 *   second argument is the identifier of the probe to be destroyed.  The third
 *   argument is the probe argument as passed to dtrace_probe_create().  The
 *   provider should free all state associated with the probe.  The framework
 *   guarantees that dtps_destroy() is only called for probes that have either
 *   been disabled via dtps_disable() or were never enabled via dtps_enable().
 *   Once dtps_disable() has been called for a probe, no further call will be
 *   made specifying the probe.
 *
 * 1.11.3 Return value
 *
 *   None.
 *
 * 1.11.4 Caller's context
 *
 *   The DTrace framework is locked in such a way that it may not be called
 *   back into at all.  mod_lock is held.  cpu_lock is not held, and may not be
 *   acquired.
 *
 *
 * 2 Provider-to-Framework API
 *
 * 2.1  Overview
 *
 * The Provider-to-Framework API provides the mechanism for the provider to
 * register itself with the DTrace framework, to create probes, to lookup
 * probes and (most importantly) to fire probes.  The Provider-to-Framework
 * consists of:
 *
 *   dtrace_register()       &lt;-- Register a provider with the DTrace framework
 *   dtrace_unregister()     &lt;-- Remove a provider's DTrace registration
 *   dtrace_invalidate()     &lt;-- Invalidate the specified provider
 *   dtrace_condense()       &lt;-- Remove a provider's unenabled probes
 *   dtrace_attached()       &lt;-- Indicates whether or not DTrace has attached
 *   dtrace_probe_create()   &lt;-- Create a DTrace probe
 *   dtrace_probe_lookup()   &lt;-- Lookup a DTrace probe based on its name
 *   dtrace_probe_arg()      &lt;-- Return the probe argument for a specific probe
 *   dtrace_probe()          &lt;-- Fire the specified probe
 *
 * 2.2  int dtrace_register(const char *name, const dtrace_pattr_t *pap,
 *          uint32_t priv, cred_t *cr, const dtrace_pops_t *pops, void *arg,
 *          dtrace_provider_id_t *idp)
 *
 * 2.2.1  Overview
 *
 *   dtrace_register() registers the calling provider with the DTrace
 *   framework.  It should generally be called by DTrace providers in their
 *   attach(9E) entry point.
 *
 * 2.2.2  Arguments and Notes
 *
 *   The first argument is the name of the provider.  The second argument is a
 *   pointer to the stability attributes for the provider.  The third argument
 *   is the privilege flags for the provider, and must be some combination of:
 *
 *     DTRACE_PRIV_NONE     &lt;= All users may enable probes from this provider
 *
 *     DTRACE_PRIV_PROC     &lt;= Any user with privilege of PRIV_DTRACE_PROC may
 *                             enable probes from this provider
 *
 *     DTRACE_PRIV_USER     &lt;= Any user with privilege of PRIV_DTRACE_USER may
 *                             enable probes from this provider
 *
 *     DTRACE_PRIV_KERNEL   &lt;= Any user with privilege of PRIV_DTRACE_KERNEL
 *                             may enable probes from this provider
 *
 *     DTRACE_PRIV_OWNER    &lt;= This flag places an additional constraint on
 *                             the privilege requirements above. These probes
 *                             require either (a) a user ID matching the user
 *                             ID of the cred passed in the fourth argument
 *                             or (b) the PRIV_PROC_OWNER privilege.
 *
 *     DTRACE_PRIV_ZONEOWNER&lt;= This flag places an additional constraint on
 *                             the privilege requirements above. These probes
 *                             require either (a) a zone ID matching the zone
 *                             ID of the cred passed in the fourth argument
 *                             or (b) the PRIV_PROC_ZONE privilege.
 *
 *   Note that these flags designate the _visibility_ of the probes, not
 *   the conditions under which they may or may not fire.
 *
 *   The fourth argument is the credential that is associated with the
 *   provider.  This argument should be NULL if the privilege flags don't
 *   include DTRACE_PRIV_OWNER or DTRACE_PRIV_ZONEOWNER.  If non-NULL, the
 *   framework stashes the uid and zoneid represented by this credential
 *   for use at probe-time, in implicit predicates.  These limit visibility
 *   of the probes to users and/or zones which have sufficient privilege to
 *   access them.
 *
 *   The fifth argument is a DTrace provider operations vector, which provides
 *   the implementation for the Framework-to-Provider API.  (See Section 1,
 *   above.)  This must be non-NULL, and each member must be non-NULL.  The
 *   exceptions to this are (1) the dtps_provide() and dtps_provide_module()
 *   members (if the provider so desires, _one_ of these members may be left
 *   NULL -- denoting that the provider only implements the other) and (2)
 *   the dtps_suspend() and dtps_resume() members, which must either both be
 *   NULL or both be non-NULL.
 *
 *   The sixth argument is a cookie to be specified as the first argument for
 *   each function in the Framework-to-Provider API.  This argument may have
 *   any value.
 *
 *   The final argument is a pointer to dtrace_provider_id_t.  If
 *   dtrace_register() successfully completes, the provider identifier will be
 *   stored in the memory pointed to be this argument.  This argument must be
 *   non-NULL.
 *
 * 2.2.3  Return value
 *
 *   On success, dtrace_register() returns 0 and stores the new provider's
 *   identifier into the memory pointed to by the idp argument.  On failure,
 *   dtrace_register() returns an errno:
 *
 *     EINVAL   The arguments passed to dtrace_register() were somehow invalid.
 *              This may because a parameter that must be non-NULL was NULL,
 *              because the name was invalid (either empty or an illegal
 *              provider name) or because the attributes were invalid.
 *
 *   No other failure code is returned.
 *
 * 2.2.4  Caller's context
 *
 *   dtrace_register() may induce calls to dtrace_provide(); the provider must
 *   hold no locks across dtrace_register() that may also be acquired by
 *   dtrace_provide().  cpu_lock and mod_lock must not be held.
 *
 * 2.3  int dtrace_unregister(dtrace_provider_t id)
 *
 * 2.3.1  Overview
 *
 *   Unregisters the specified provider from the DTrace framework.  It should
 *   generally be called by DTrace providers in their detach(9E) entry point.
 *
 * 2.3.2  Arguments and Notes
 *
 *   The only argument is the provider identifier, as returned from a
 *   successful call to dtrace_register().  As a result of calling
 *   dtrace_unregister(), the DTrace framework will call back into the provider
 *   via the dtps_destroy() entry point.  Once dtrace_unregister() successfully
 *   completes, however, the DTrace framework will no longer make calls through
 *   the Framework-to-Provider API.
 *
 * 2.3.3  Return value
 *
 *   On success, dtrace_unregister returns 0.  On failure, dtrace_unregister()
 *   returns an errno:
 *
 *     EBUSY    There are currently processes that have the DTrace pseudodevice
 *              open, or there exists an anonymous enabling that hasn't yet
 *              been claimed.
 *
 *   No other failure code is returned.
 *
 * 2.3.4  Caller's context
 *
 *   Because a call to dtrace_unregister() may induce calls through the
 *   Framework-to-Provider API, the caller may not hold any lock across
 *   dtrace_register() that is also acquired in any of the Framework-to-
 *   Provider API functions.  Additionally, mod_lock may not be held.
 *
 * 2.4  void dtrace_invalidate(dtrace_provider_id_t id)
 *
 * 2.4.1  Overview
 *
 *   Invalidates the specified provider.  All subsequent probe lookups for the
 *   specified provider will fail, but its probes will not be removed.
 *
 * 2.4.2  Arguments and note
 *
 *   The only argument is the provider identifier, as returned from a
 *   successful call to dtrace_register().  In general, a provider's probes
 *   always remain valid; dtrace_invalidate() is a mechanism for invalidating
 *   an entire provider, regardless of whether or not probes are enabled or
 *   not.  Note that dtrace_invalidate() will _not_ prevent already enabled
 *   probes from firing -- it will merely prevent any new enablings of the
 *   provider's probes.
 *
 * 2.5 int dtrace_condense(dtrace_provider_id_t id)
 *
 * 2.5.1  Overview
 *
 *   Removes all the unenabled probes for the given provider. This function is
 *   not unlike dtrace_unregister(), except that it doesn't remove the
 *   provider just as many of its associated probes as it can.
 *
 * 2.5.2  Arguments and Notes
 *
 *   As with dtrace_unregister(), the sole argument is the provider identifier
 *   as returned from a successful call to dtrace_register().  As a result of
 *   calling dtrace_condense(), the DTrace framework will call back into the
 *   given provider's dtps_destroy() entry point for each of the provider's
 *   unenabled probes.
 *
 * 2.5.3  Return value
 *
 *   Currently, dtrace_condense() always returns 0.  However, consumers of this
 *   function should check the return value as appropriate; its behavior may
 *   change in the future.
 *
 * 2.5.4  Caller's context
 *
 *   As with dtrace_unregister(), the caller may not hold any lock across
 *   dtrace_condense() that is also acquired in the provider's entry points.
 *   Also, mod_lock may not be held.
 *
 * 2.6 int dtrace_attached()
 *
 * 2.6.1  Overview
 *
 *   Indicates whether or not DTrace has attached.
 *
 * 2.6.2  Arguments and Notes
 *
 *   For most providers, DTrace makes initial contact beyond registration.
 *   That is, once a provider has registered with DTrace, it waits to hear
 *   from DTrace to create probes.  However, some providers may wish to
 *   proactively create probes without first being told by DTrace to do so.
 *   If providers wish to do this, they must first call dtrace_attached() to
 *   determine if DTrace itself has attached.  If dtrace_attached() returns 0,
 *   the provider must not make any other Provider-to-Framework API call.
 *
 * 2.6.3  Return value
 *
 *   dtrace_attached() returns 1 if DTrace has attached, 0 otherwise.
 *
 * 2.7  int dtrace_probe_create(dtrace_provider_t id, const char *mod,
 *          const char *func, const char *name, int aframes, void *arg)
 *
 * 2.7.1  Overview
 *
 *   Creates a probe with specified module name, function name, and name.
 *
 * 2.7.2  Arguments and Notes
 *
 *   The first argument is the provider identifier, as returned from a
 *   successful call to dtrace_register().  The second, third, and fourth
 *   arguments are the module name, function name, and probe name,
 *   respectively.  Of these, module name and function name may both be NULL
 *   (in which case the probe is considered to be unanchored), or they may both
 *   be non-NULL.  The name must be non-NULL, and must point to a non-empty
 *   string.
 *
 *   The fifth argument is the number of artificial stack frames that will be
 *   found on the stack when dtrace_probe() is called for the new probe.  These
 *   artificial frames will be automatically be pruned should the stack() or
 *   stackdepth() functions be called as part of one of the probe's ECBs.  If
 *   the parameter doesn't add an artificial frame, this parameter should be
 *   zero.
 *
 *   The final argument is a probe argument that will be passed back to the
 *   provider when a probe-specific operation is called.  (e.g., via
 *   dtps_enable(), dtps_disable(), etc.)
 *
 *   Note that it is up to the provider to be sure that the probe that it
 *   creates does not already exist -- if the provider is unsure of the probe's
 *   existence, it should assure its absence with dtrace_probe_lookup() before
 *   calling dtrace_probe_create().
 *
 * 2.7.3  Return value
 *
 *   dtrace_probe_create() always succeeds, and always returns the identifier
 *   of the newly-created probe.
 *
 * 2.7.4  Caller's context
 *
 *   While dtrace_probe_create() is generally expected to be called from
 *   dtps_provide() and/or dtps_provide_module(), it may be called from other
 *   non-DTrace contexts.  Neither cpu_lock nor mod_lock may be held.
 *
 * 2.8  dtrace_id_t dtrace_probe_lookup(dtrace_provider_t id, const char *mod,
 *          const char *func, const char *name)
 *
 * 2.8.1  Overview
 *
 *   Looks up a probe based on provdider and one or more of module name,
 *   function name and probe name.
 *
 * 2.8.2  Arguments and Notes
 *
 *   The first argument is the provider identifier, as returned from a
 *   successful call to dtrace_register().  The second, third, and fourth
 *   arguments are the module name, function name, and probe name,
 *   respectively.  Any of these may be NULL; dtrace_probe_lookup() will return
 *   the identifier of the first probe that is provided by the specified
 *   provider and matches all of the non-NULL matching criteria.
 *   dtrace_probe_lookup() is generally used by a provider to be check the
 *   existence of a probe before creating it with dtrace_probe_create().
 *
 * 2.8.3  Return value
 *
 *   If the probe exists, returns its identifier.  If the probe does not exist,
 *   return DTRACE_IDNONE.
 *
 * 2.8.4  Caller's context
 *
 *   While dtrace_probe_lookup() is generally expected to be called from
 *   dtps_provide() and/or dtps_provide_module(), it may also be called from
 *   other non-DTrace contexts.  Neither cpu_lock nor mod_lock may be held.
 *
 * 2.9  void *dtrace_probe_arg(dtrace_provider_t id, dtrace_id_t probe)
 *
 * 2.9.1  Overview
 *
 *   Returns the probe argument associated with the specified probe.
 *
 * 2.9.2  Arguments and Notes
 *
 *   The first argument is the provider identifier, as returned from a
 *   successful call to dtrace_register().  The second argument is a probe
 *   identifier, as returned from dtrace_probe_lookup() or
 *   dtrace_probe_create().  This is useful if a probe has multiple
 *   provider-specific components to it:  the provider can create the probe
 *   once with provider-specific state, and then add to the state by looking
 *   up the probe based on probe identifier.
 *
 * 2.9.3  Return value
 *
 *   Returns the argument associated with the specified probe.  If the
 *   specified probe does not exist, or if the specified probe is not provided
 *   by the specified provider, NULL is returned.
 *
 * 2.9.4  Caller's context
 *
 *   While dtrace_probe_arg() is generally expected to be called from
 *   dtps_provide() and/or dtps_provide_module(), it may also be called from
 *   other non-DTrace contexts.  Neither cpu_lock nor mod_lock may be held.
 *
 * 2.10  void dtrace_probe(dtrace_id_t probe, uintptr_t arg0, uintptr_t arg1,
 *              uintptr_t arg2, uintptr_t arg3, uintptr_t arg4)
 *
 * 2.10.1  Overview
 *
 *   The epicenter of DTrace:  fires the specified probes with the specified
 *   arguments.
 *
 * 2.10.2  Arguments and Notes
 *
 *   The first argument is a probe identifier as returned by
 *   dtrace_probe_create() or dtrace_probe_lookup().  The second through sixth
 *   arguments are the values to which the D variables &quot;arg0&quot; through &quot;arg4&quot;
 *   will be mapped.
 *
 *   dtrace_probe() should be called whenever the specified probe has fired --
 *   however the provider defines it.
 *
 * 2.10.3  Return value
 *
 *   None.
 *
 * 2.10.4  Caller's context
 *
 *   dtrace_probe() may be called in virtually any context:  kernel, user,
 *   interrupt, high-level interrupt, with arbitrary adaptive locks held, with
 *   dispatcher locks held, with interrupts disabled, etc.  The only latitude
 *   that must be afforded to DTrace is the ability to make calls within
 *   itself (and to its in-kernel subroutines) and the ability to access
 *   arbitrary (but mapped) memory.  On some platforms, this constrains
 *   context.  For example, on UltraSPARC, dtrace_probe() cannot be called
 *   from any context in which TL is greater than zero.  dtrace_probe() may
 *   also not be called from any routine which may be called by dtrace_probe()
 *   -- which includes functions in the DTrace framework and some in-kernel
 *   DTrace subroutines.  All such functions &quot;dtrace_&quot;; providers that
 *   instrument the kernel arbitrarily should be sure to not instrument these
 *   routines.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_pops {
        <span class="enscript-type">void</span> (*dtps_provide)(<span class="enscript-type">void</span> *arg, <span class="enscript-type">const</span> dtrace_probedesc_t *spec);
        <span class="enscript-type">void</span> (*dtps_provide_module)(<span class="enscript-type">void</span> *arg, <span class="enscript-type">struct</span> modctl *mp);
        <span class="enscript-type">int</span> (*dtps_enable)(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg);
        <span class="enscript-type">void</span> (*dtps_disable)(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg);
        <span class="enscript-type">void</span> (*dtps_suspend)(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg);
        <span class="enscript-type">void</span> (*dtps_resume)(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg);
        <span class="enscript-type">void</span> (*dtps_getargdesc)(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg,
            dtrace_argdesc_t *desc);
        uint64_t (*dtps_getargval)(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg,
            <span class="enscript-type">int</span> argno, <span class="enscript-type">int</span> aframes);
        <span class="enscript-type">int</span> (*dtps_usermode)(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg);
        <span class="enscript-type">void</span> (*dtps_destroy)(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg);
} dtrace_pops_t;

<span class="enscript-type">typedef</span> uintptr_t       dtrace_provider_id_t;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_register</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> dtrace_pattr_t *, uint32_t,
    cred_t *, <span class="enscript-type">const</span> dtrace_pops_t *, <span class="enscript-type">void</span> *, dtrace_provider_id_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_unregister</span>(dtrace_provider_id_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_condense</span>(dtrace_provider_id_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_invalidate</span>(dtrace_provider_id_t);
<span class="enscript-type">extern</span> dtrace_id_t <span class="enscript-function-name">dtrace_probe_lookup</span>(dtrace_provider_id_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *);
<span class="enscript-type">extern</span> dtrace_id_t <span class="enscript-function-name">dtrace_probe_create</span>(dtrace_provider_id_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *<span class="enscript-function-name">dtrace_probe_arg</span>(dtrace_provider_id_t, dtrace_id_t);
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_probe</span>(dtrace_id_t, uintptr_t arg0, uintptr_t arg1,
    uintptr_t arg2, uintptr_t arg3, uintptr_t arg4);
#<span class="enscript-reference">else</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_probe</span>(dtrace_id_t, uint64_t arg0, uint64_t arg1,
    uint64_t arg2, uint64_t arg3, uint64_t arg4);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

<span class="enscript-comment">/*
 * DTrace Meta Provider API
 *
 * The following functions are implemented by the DTrace framework and are
 * used to implement meta providers. Meta providers plug into the DTrace
 * framework and are used to instantiate new providers on the fly. At
 * present, there is only one type of meta provider and only one meta
 * provider may be registered with the DTrace framework at a time. The
 * sole meta provider type provides user-land static tracing facilities
 * by taking meta probe descriptions and adding a corresponding provider
 * into the DTrace framework.
 *
 * 1 Framework-to-Provider
 *
 * 1.1 Overview
 *
 * The Framework-to-Provider API is represented by the dtrace_mops structure
 * that the meta provider passes to the framework when registering itself as
 * a meta provider. This structure consists of the following members:
 *
 *   dtms_create_probe()        &lt;-- Add a new probe to a created provider
 *   dtms_provide_pid()         &lt;-- Create a new provider for a given process
 *   dtms_remove_pid()          &lt;-- Remove a previously created provider
 *
 * 1.2  void dtms_create_probe(void *arg, void *parg,
 *           dtrace_helper_probedesc_t *probedesc);
 *
 * 1.2.1  Overview
 *
 *   Called by the DTrace framework to create a new probe in a provider
 *   created by this meta provider.
 *
 * 1.2.2  Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_meta_register().
 *   The second argument is the provider cookie for the associated provider;
 *   this is obtained from the return value of dtms_provide_pid(). The third
 *   argument is the helper probe description.
 *
 * 1.2.3  Return value
 *
 *   None
 *
 * 1.2.4  Caller's context
 *
 *   dtms_create_probe() is called from either ioctl() or module load context.
 *   The DTrace framework is locked in such a way that meta providers may not
 *   register or unregister. This means that the meta provider cannot call
 *   dtrace_meta_register() or dtrace_meta_unregister(). However, the context is
 *   such that the provider may (and is expected to) call provider-related
 *   DTrace provider APIs including dtrace_probe_create().
 *
 * 1.3  void *dtms_provide_pid(void *arg, dtrace_meta_provider_t *mprov,
 *            pid_t pid)
 *
 * 1.3.1  Overview
 *
 *   Called by the DTrace framework to instantiate a new provider given the
 *   description of the provider and probes in the mprov argument. The
 *   meta provider should call dtrace_register() to insert the new provider
 *   into the DTrace framework.
 *
 * 1.3.2  Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_meta_register().
 *   The second argument is a pointer to a structure describing the new
 *   helper provider. The third argument is the process identifier for
 *   process associated with this new provider. Note that the name of the
 *   provider as passed to dtrace_register() should be the contatenation of
 *   the dtmpb_provname member of the mprov argument and the processs
 *   identifier as a string.
 *
 * 1.3.3  Return value
 *
 *   The cookie for the provider that the meta provider creates. This is
 *   the same value that it passed to dtrace_register().
 *
 * 1.3.4  Caller's context
 *
 *   dtms_provide_pid() is called from either ioctl() or module load context.
 *   The DTrace framework is locked in such a way that meta providers may not
 *   register or unregister. This means that the meta provider cannot call
 *   dtrace_meta_register() or dtrace_meta_unregister(). However, the context
 *   is such that the provider may -- and is expected to --  call
 *   provider-related DTrace provider APIs including dtrace_register().
 *
 * 1.4  void dtms_remove_pid(void *arg, dtrace_meta_provider_t *mprov,
 *           pid_t pid)
 *
 * 1.4.1  Overview
 *
 *   Called by the DTrace framework to remove a provider that had previously
 *   been instantiated via the dtms_provide_pid() entry point. The meta
 *   provider need not remove the provider immediately, but this entry
 *   point indicates that the provider should be removed as soon as possible
 *   using the dtrace_unregister() API.
 *
 * 1.4.2  Arguments and notes
 *
 *   The first argument is the cookie as passed to dtrace_meta_register().
 *   The second argument is a pointer to a structure describing the helper
 *   provider. The third argument is the process identifier for process
 *   associated with this new provider.
 *
 * 1.4.3  Return value
 *
 *   None
 *
 * 1.4.4  Caller's context
 *
 *   dtms_remove_pid() is called from either ioctl() or exit() context.
 *   The DTrace framework is locked in such a way that meta providers may not
 *   register or unregister. This means that the meta provider cannot call
 *   dtrace_meta_register() or dtrace_meta_unregister(). However, the context
 *   is such that the provider may -- and is expected to -- call
 *   provider-related DTrace provider APIs including dtrace_unregister().
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_helper_probedesc {
	<span class="enscript-type">char</span> *dthpb_mod;			<span class="enscript-comment">/* probe module */</span>
	<span class="enscript-type">char</span> *dthpb_func; 			<span class="enscript-comment">/* probe function */</span>
	<span class="enscript-type">char</span> *dthpb_name; 			<span class="enscript-comment">/* probe name */</span>
	uint64_t dthpb_base;			<span class="enscript-comment">/* base address */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
	uint32_t *dthpb_offs;			<span class="enscript-comment">/* offsets array */</span>
	uint32_t *dthpb_enoffs;			<span class="enscript-comment">/* is-enabled offsets array */</span>
#<span class="enscript-reference">else</span>
	int32_t *dthpb_offs;			<span class="enscript-comment">/* (signed) offsets array */</span>
	int32_t *dthpb_enoffs;			<span class="enscript-comment">/* (signed) is-enabled offsets array */</span>
#<span class="enscript-reference">endif</span>
	uint32_t dthpb_noffs;			<span class="enscript-comment">/* offsets count */</span>
	uint32_t dthpb_nenoffs;			<span class="enscript-comment">/* is-enabled offsets count */</span>
	uint8_t *dthpb_args;			<span class="enscript-comment">/* argument mapping array */</span>
	uint8_t dthpb_xargc;			<span class="enscript-comment">/* translated argument count */</span>
	uint8_t dthpb_nargc;			<span class="enscript-comment">/* native argument count */</span>
	<span class="enscript-type">char</span> *dthpb_xtypes;			<span class="enscript-comment">/* translated types strings */</span>
	<span class="enscript-type">char</span> *dthpb_ntypes;			<span class="enscript-comment">/* native types strings */</span>
} dtrace_helper_probedesc_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_helper_provdesc {
        <span class="enscript-type">char</span> *dthpv_provname;                   <span class="enscript-comment">/* provider name */</span>
        dtrace_pattr_t dthpv_pattr;             <span class="enscript-comment">/* stability attributes */</span>
} dtrace_helper_provdesc_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> dtrace_mops {
        <span class="enscript-type">void</span> (*dtms_create_probe)(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, dtrace_helper_probedesc_t *);
        <span class="enscript-type">void</span> *(*dtms_provide_pid)(<span class="enscript-type">void</span> *, dtrace_helper_provdesc_t *, pid_t);
        <span class="enscript-type">void</span> (*dtms_remove_pid)(<span class="enscript-type">void</span> *, dtrace_helper_provdesc_t *, pid_t);
} dtrace_mops_t;

<span class="enscript-type">typedef</span> uintptr_t       dtrace_meta_provider_id_t;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_meta_register</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> dtrace_mops_t *, <span class="enscript-type">void</span> *,
    dtrace_meta_provider_id_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_meta_unregister</span>(dtrace_meta_provider_id_t);

<span class="enscript-comment">/*
 * DTrace Kernel Hooks
 *
 * The following functions are implemented by the base kernel and form a set of
 * hooks used by the DTrace framework.  DTrace hooks are implemented in either
 * uts/common/os/dtrace_subr.c, an ISA-specific assembly file, or in a
 * uts/&lt;platform&gt;/os/dtrace_subr.c corresponding to each hardware platform.
 */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> dtrace_vtime_state {
        DTRACE_VTIME_INACTIVE = 0,      <span class="enscript-comment">/* No DTrace, no TNF */</span>
        DTRACE_VTIME_ACTIVE,            <span class="enscript-comment">/* DTrace virtual time, no TNF */</span>
        DTRACE_VTIME_INACTIVE_TNF,      <span class="enscript-comment">/* No DTrace, TNF active */</span>
        DTRACE_VTIME_ACTIVE_TNF         <span class="enscript-comment">/* DTrace virtual time _and_ TNF */</span>
} dtrace_vtime_state_t;

<span class="enscript-type">extern</span> dtrace_vtime_state_t dtrace_vtime_active;
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_vtime_switch</span>(kthread_t *next);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_vtime_enable_tnf</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_vtime_disable_tnf</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_vtime_enable</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_vtime_disable</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
<span class="enscript-type">struct</span> regs;

<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (*dtrace_pid_probe_ptr)(<span class="enscript-type">struct</span> regs *);
<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (*dtrace_return_probe_ptr)(<span class="enscript-type">struct</span> regs *);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (*dtrace_pid_probe_ptr)(x86_saved_state_t *regs);
<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (*dtrace_return_probe_ptr)(x86_saved_state_t* regs);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">architecture</span> <span class="enscript-variable-name">not</span> <span class="enscript-variable-name">supported</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_fasttrap_fork_ptr)(proc_t *, proc_t *);
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_fasttrap_exec_ptr)(proc_t *);
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_fasttrap_exit_ptr)(proc_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_fasttrap_fork</span>(proc_t *, proc_t *);

<span class="enscript-type">typedef</span> uintptr_t dtrace_icookie_t;
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*dtrace_xcall_t)(<span class="enscript-type">void</span> *);

<span class="enscript-type">extern</span> dtrace_icookie_t <span class="enscript-function-name">dtrace_interrupt_disable</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_interrupt_enable</span>(dtrace_icookie_t);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_membar_producer</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_membar_consumer</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_cpu_init)(processorid_t);
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_modload)(<span class="enscript-type">struct</span> modctl *);
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_modunload)(<span class="enscript-type">struct</span> modctl *);
#<span class="enscript-reference">else</span>
<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (*dtrace_modload)(<span class="enscript-type">struct</span> kmod_info *, uint32_t);
<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (*dtrace_modunload)(<span class="enscript-type">struct</span> kmod_info *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_helpers_cleanup)(proc_t*);
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_helpers_fork)(proc_t *parent, proc_t *child);
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_cpustart_init)(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_cpustart_fini)(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_kreloc_init)(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_kreloc_fini)(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_debugger_init)(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_debugger_fini)(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> dtrace_cacheid_t dtrace_predcache_id;

<span class="enscript-type">extern</span> hrtime_t <span class="enscript-function-name">dtrace_gethrtime</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_sync</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_toxic_ranges</span>(<span class="enscript-type">void</span> (*)(uintptr_t, uintptr_t));
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_xcall</span>(processorid_t, dtrace_xcall_t, <span class="enscript-type">void</span> *);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_safe_defer_signal</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_safe_synchronous_signal</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_mach_aframes</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__amd64</span>)
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_instr_size</span>(uchar_t *instr);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_instr_size_isa</span>(uchar_t *, model_t, <span class="enscript-type">int</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_invop_add</span>(<span class="enscript-type">int</span> (*)(uintptr_t, uintptr_t *, uintptr_t));
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_invop_remove</span>(<span class="enscript-type">int</span> (*)(uintptr_t, uintptr_t *, uintptr_t));
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_invop_callsite</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__sparc</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_blksuword32</span>(uintptr_t, uint32_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_getfsr</span>(uint64_t *);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_instr_size</span>(uchar_t *instr);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_instr_size_isa</span>(uchar_t *, model_t, <span class="enscript-type">int</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_invop_add</span>(<span class="enscript-type">int</span> (*)(uintptr_t, uintptr_t *, uintptr_t));
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_invop_remove</span>(<span class="enscript-type">int</span> (*)(uintptr_t, uintptr_t *, uintptr_t));
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *dtrace_invop_callsite_pre;
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *dtrace_invop_callsite_post;
#<span class="enscript-reference">endif</span>

    
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">proc_t</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_CPUFLAG_ISSET</span>(flag) \
        (cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags &amp; (flag))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_CPUFLAG_SET</span>(flag) \
        (cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags |= (flag))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DTRACE_CPUFLAG_CLEAR</span>(flag) \
        (cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags &amp;= ~(flag))

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _KERNEL */</span>

#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* _ASM */</span>

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__amd64</span>)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_INVOP_PUSHL_EBP</span>		1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_INVOP_POPL_EBP</span>		2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_INVOP_LEAVE</span>		3
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_INVOP_NOP</span>		4
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_INVOP_RET</span>		5

#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_PUSHL_EBP</span>          1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_POPL_EBP</span>           2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_LEAVE</span>              3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_NOP</span>                4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_RET</span>                5

#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">__cplusplus</span>
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* _SYS_DTRACE_H */</span>
</pre>
<hr />
</body></html>