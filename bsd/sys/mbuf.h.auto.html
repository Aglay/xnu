<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mbuf.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mbuf.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1999-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1998, 1999 Apple Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Mach Operating System
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1994 NeXT Computer, Inc. All rights reserved.
 *
 * Copyright (c) 1982, 1986, 1988 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)mbuf.h	8.3 (Berkeley) 1/21/94
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">_SYS_MBUF_H_</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_SYS_MBUF_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/endian.h&gt;</span>
<span class="enscript-comment">/*
 * Mbufs are of a single size, MSIZE (machine/param.h), which
 * includes overhead.  An mbuf may add a single &quot;mbuf cluster&quot; of size
 * MCLBYTES/MBIGCLBYTES/M16KCLBYTES (also in machine/param.h), which has
 * no additional overhead and is used instead of the internal data area;
 * this is done when at least MINCLSIZE of data must be stored.
 */</span>

<span class="enscript-comment">/*
 * The following _MLEN and _MHLEN macros are private to xnu.  Private code
 * that are outside of xnu must use the mbuf_get_{mlen,mhlen} routines since
 * the sizes of the structures are dependent upon specific xnu configs.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_MLEN</span>		(MSIZE - sizeof(struct m_hdr))	<span class="enscript-comment">/* normal data len */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_MHLEN</span>		(_MLEN - sizeof(struct pkthdr))	<span class="enscript-comment">/* data len w/pkthdr */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NMBPGSHIFT</span>	(PAGE_SHIFT - MSIZESHIFT)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NMBPG</span>		(1 &lt;&lt; NMBPGSHIFT)	<span class="enscript-comment">/* # of mbufs per page */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NCLPGSHIFT</span>	(PAGE_SHIFT - MCLSHIFT)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NCLPG</span>		(1 &lt;&lt; NCLPGSHIFT)	<span class="enscript-comment">/* # of cl per page */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBCLPGSHIFT</span>	(PAGE_SHIFT - MBIGCLSHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBCLPG</span>		(1 &lt;&lt; NBCLPGSHIFT)	<span class="enscript-comment">/* # of big cl per page */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NMBPCLSHIFT</span>	(MCLSHIFT - MSIZESHIFT)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NMBPCL</span>		(1 &lt;&lt; NMBPCLSHIFT)	<span class="enscript-comment">/* # of mbufs per cl */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NCLPJCLSHIFT</span>	(M16KCLSHIFT - MCLSHIFT)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NCLPJCL</span>		(1 &lt;&lt; NCLPJCLSHIFT)	<span class="enscript-comment">/* # of cl per jumbo cl */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NCLPBGSHIFT</span>	(MBIGCLSHIFT - MCLSHIFT)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NCLPBG</span>		(1 &lt;&lt; NCLPBGSHIFT)	<span class="enscript-comment">/* # of cl per big cl */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NMBPBGSHIFT</span>	(MBIGCLSHIFT - MSIZESHIFT)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NMBPBG</span>		(1 &lt;&lt; NMBPBGSHIFT)	<span class="enscript-comment">/* # of mbufs per big cl */</span>

<span class="enscript-comment">/*
 * Macros for type conversion
 * mtod(m,t) -	convert mbuf pointer to data pointer of correct type
 * dtom(x) -	convert data pointer within mbuf to mbuf pointer (XXX)
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">mtod</span>(m, t)	((t)m_mtod(m))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">dtom</span>(x)		m_dtom(x)

<span class="enscript-comment">/* header at beginning of each mbuf: */</span>
<span class="enscript-type">struct</span> m_hdr {
	<span class="enscript-type">struct</span> mbuf	*mh_next;	<span class="enscript-comment">/* next buffer in chain */</span>
	<span class="enscript-type">struct</span> mbuf	*mh_nextpkt;	<span class="enscript-comment">/* next chain in queue/record */</span>
	caddr_t		mh_data;	<span class="enscript-comment">/* location of data */</span>
	int32_t		mh_len;		<span class="enscript-comment">/* amount of data in this mbuf */</span>
	u_int16_t	mh_type;	<span class="enscript-comment">/* type of data in this mbuf */</span>
	u_int16_t	mh_flags;	<span class="enscript-comment">/* flags; see below */</span>
};

<span class="enscript-comment">/*
 * Packet tag structure (see below for details).
 */</span>
<span class="enscript-type">struct</span> m_tag {
	u_int64_t		m_tag_cookie;	<span class="enscript-comment">/* Error checking */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
	u_int32_t		pad;		<span class="enscript-comment">/* For structure alignment */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
	SLIST_ENTRY(m_tag)	m_tag_link;	<span class="enscript-comment">/* List of packet tags */</span>
	u_int16_t		m_tag_type;	<span class="enscript-comment">/* Module specific type */</span>
	u_int16_t		m_tag_len;	<span class="enscript-comment">/* Length of data */</span>
	u_int32_t		m_tag_id;	<span class="enscript-comment">/* Module ID */</span>
};

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">M_TAG_ALIGN</span>(len) \
	(P2ROUNDUP(len, <span class="enscript-keyword">sizeof</span> (u_int64_t)) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> m_tag))

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_TAG_VALID_PATTERN</span>	0xfeedfacefeedfaceULL
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_TAG_FREE_PATTERN</span>	0xdeadbeefdeadbeefULL

<span class="enscript-comment">/*
 * Packet tag header structure (at the top of mbuf).  Pointers are
 * 32-bit in ILP32; m_tag needs 64-bit alignment, hence padded.
 */</span>
<span class="enscript-type">struct</span> m_taghdr {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
	u_int32_t		pad;		<span class="enscript-comment">/* For structure alignment */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
	u_int64_t		refcnt;		<span class="enscript-comment">/* Number of tags in this mbuf */</span>
};

<span class="enscript-comment">/*
 * Driver auxiliary metadata tag (KERNEL_TAG_TYPE_DRVAUX).
 */</span>
<span class="enscript-type">struct</span> m_drvaux_tag {
	u_int32_t	da_family;	<span class="enscript-comment">/* IFNET_FAMILY values */</span>
	u_int32_t	da_subfamily;	<span class="enscript-comment">/* IFNET_SUBFAMILY values */</span>
	u_int32_t	da_reserved;	<span class="enscript-comment">/* for future */</span>
	u_int32_t	da_length;	<span class="enscript-comment">/* length of following data */</span>
};

<span class="enscript-comment">/* Values for pftag_flags (16-bit wide) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PF_TAG_GENERATED</span>		0x1	<span class="enscript-comment">/* pkt generated by PF */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PF_TAG_FRAGCACHE</span>		0x2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PF_TAG_TRANSLATE_LOCALHOST</span>	0x4
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ECN</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PF_TAG_HDR_INET</span>			0x8	<span class="enscript-comment">/* hdr points to IPv4 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PF_TAG_HDR_INET6</span>		0x10	<span class="enscript-comment">/* hdr points to IPv6 */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ECN */</span>
<span class="enscript-comment">/*
 * PF mbuf tag
 */</span>
<span class="enscript-type">struct</span> pf_mtag {
	u_int16_t	pftag_flags;	<span class="enscript-comment">/* PF_TAG flags */</span>
	u_int16_t	pftag_rtableid;	<span class="enscript-comment">/* alternate routing table id */</span>
	u_int16_t	pftag_tag;
	u_int16_t	pftag_routed;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ALTQ</span>
	u_int32_t	pftag_qid;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ALTQ */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ECN</span>
	<span class="enscript-type">void</span>		*pftag_hdr;	<span class="enscript-comment">/* saved hdr pos in mbuf, for ECN */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ECN */</span>
};

<span class="enscript-comment">/*
 * TCP mbuf tag
 */</span>
<span class="enscript-type">struct</span> tcp_pktinfo {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			u_int32_t segsz;	<span class="enscript-comment">/* segment size (actual MSS) */</span>
		} __tx;
		<span class="enscript-type">struct</span> {
			u_int16_t lro_pktlen;	<span class="enscript-comment">/* max seg size encountered */</span>
			u_int8_t  lro_npkts;	<span class="enscript-comment">/* # of coalesced TCP pkts */</span>
			u_int8_t  lro_timediff;	<span class="enscript-comment">/* time spent in LRO */</span>
		} __rx;
	} __offload;
	<span class="enscript-type">union</span> {
		u_int32_t	pri;		<span class="enscript-comment">/* send msg priority */</span>
		u_int32_t	seq;		<span class="enscript-comment">/* recv msg sequence # */</span>
	} __msgattr;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">tso_segsz</span>	proto_mtag.__pr_u.tcp.tm_tcp.__offload.__tx.segsz
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">lro_pktlen</span>	proto_mtag.__pr_u.tcp.tm_tcp.__offload.__rx.lro_pktlen
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">lro_npkts</span>	proto_mtag.__pr_u.tcp.tm_tcp.__offload.__rx.lro_npkts
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">lro_elapsed</span>	proto_mtag.__pr_u.tcp.tm_tcp.__offload.__rx.lro_timediff
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">msg_pri</span>		proto_mtag.__pr_u.tcp.tm_tcp.__msgattr.pri
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">msg_seq</span>		proto_mtag.__pr_u.tcp.tm_tcp.__msgattr.seq
};

<span class="enscript-comment">/*
 * MPTCP mbuf tag
 */</span>
<span class="enscript-type">struct</span> mptcp_pktinfo {
	u_int64_t	mtpi_dsn;	<span class="enscript-comment">/* MPTCP Data Sequence Number */</span>
	<span class="enscript-type">union</span> {
		u_int64_t	mtpi_dan;	<span class="enscript-comment">/* MPTCP Data Ack Number */</span>
		<span class="enscript-type">struct</span> {
			u_int32_t mtpi_rel_seq;	<span class="enscript-comment">/* Relative Seq Number */</span>
			u_int32_t mtpi_length;	<span class="enscript-comment">/* Length of mapping */</span>
		} mtpi_subf;
	};
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">mp_dsn</span>		proto_mtag.__pr_u.tcp.tm_mptcp.mtpi_dsn
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">mp_rseq</span>		proto_mtag.__pr_u.tcp.tm_mptcp.mtpi_subf.mtpi_rel_seq
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">mp_rlen</span>		proto_mtag.__pr_u.tcp.tm_mptcp.mtpi_subf.mtpi_length
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">mp_dack</span>		proto_mtag.__pr_u.tcp.tm_mptcp.mtpi_subf.mtpi_dan
};

<span class="enscript-comment">/*
 * TCP specific mbuf tag.  Note that the current implementation uses
 * MPTCP metadata strictly between MPTCP and the TCP subflow layers,
 * hence tm_tcp and tm_mptcp are mutually exclusive.  This also means
 * that TCP messages functionality is currently incompatible with MPTCP.
 */</span>
<span class="enscript-type">struct</span> tcp_mtag {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> tcp_pktinfo	tm_tcp;		<span class="enscript-comment">/* TCP and below */</span>
		<span class="enscript-type">struct</span> mptcp_pktinfo	tm_mptcp;	<span class="enscript-comment">/* MPTCP-TCP only */</span>
	};
};

<span class="enscript-comment">/*
 * Protocol specific mbuf tag (at most one protocol metadata per mbuf).
 *
 * Care must be taken to ensure that they are mutually exclusive, e.g.
 * IPSec policy ID implies no TCP segment offload (which is fine given
 * that the former is used on the virtual ipsec interface that does
 * not advertise the TSO capability.)
 */</span>
<span class="enscript-type">struct</span> proto_mtag {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> tcp_mtag	tcp;		<span class="enscript-comment">/* TCP specific */</span>
	} __pr_u;
};

<span class="enscript-comment">/*
 * NECP specific mbuf tag.
 */</span>
<span class="enscript-type">struct</span> necp_mtag {
	u_int32_t	necp_policy_id;
	u_int32_t	necp_last_interface_index;
	u_int32_t	necp_route_rule_id;
};

<span class="enscript-comment">/*
 * Record/packet header in first mbuf of chain; valid only if M_PKTHDR set.
 */</span>
<span class="enscript-type">struct</span>	pkthdr {
	<span class="enscript-type">struct</span>	ifnet *rcvif;		<span class="enscript-comment">/* rcv interface */</span>
	<span class="enscript-comment">/* variables for ip and tcp reassembly */</span>
	<span class="enscript-type">void</span>	*pkt_hdr;		<span class="enscript-comment">/* pointer to packet header */</span>
	int32_t	len;			<span class="enscript-comment">/* total packet length */</span>
	<span class="enscript-comment">/* variables for hardware checksum */</span>
	<span class="enscript-comment">/* Note: csum_flags is used for hardware checksum and VLAN */</span>
	u_int32_t csum_flags;		<span class="enscript-comment">/* flags regarding checksum */</span>
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			u_int16_t val;	 <span class="enscript-comment">/* checksum value */</span>
			u_int16_t start; <span class="enscript-comment">/* checksum start offset */</span>
		} _csum_rx;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">csum_rx_val</span>	_csum_rx.val
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">csum_rx_start</span>	_csum_rx.start
		<span class="enscript-type">struct</span> {
			u_int16_t start; <span class="enscript-comment">/* checksum start offset */</span>
			u_int16_t stuff; <span class="enscript-comment">/* checksum stuff offset */</span>
		} _csum_tx;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">csum_tx_start</span>	_csum_tx.start
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">csum_tx_stuff</span>	_csum_tx.stuff
		u_int32_t csum_data;	<span class="enscript-comment">/* data field used by csum routines */</span>
	};
	u_int16_t vlan_tag;		<span class="enscript-comment">/* VLAN tag, host byte order */</span>
	<span class="enscript-comment">/*
	 * Packet classifier info
	 *
	 * PKTF_FLOW_ID set means valid flow ID.  A non-zero flow ID value
	 * means the packet has been classified by one of the flow sources.
	 * It is also a prerequisite for flow control advisory, which is
	 * enabled by additionally setting PKTF_FLOW_ADV.
	 *
	 * The protocol value is a best-effort representation of the payload.
	 * It is opportunistically updated and used only for optimization.
	 * It is not a substitute for parsing the protocol header(s); use it
	 * only as a hint.
	 *
	 * If PKTF_IFAINFO is set, pkt_ifainfo contains one or both of the
	 * indices of interfaces which own the source and/or destination
	 * addresses of the packet.  For the local/loopback case (PKTF_LOOP),
	 * both should be valid, and thus allows for the receiving end to
	 * quickly determine the actual interfaces used by the the addresses;
	 * they may not necessarily be the same or refer to the loopback
	 * interface.  Otherwise, in the non-local/loopback case, the indices
	 * are opportunistically set, and because of that only one may be set
	 * (0 means the index has not been determined.)  In addition, the
	 * interface address flags are also recorded.  This allows us to avoid
	 * storing the corresponding {in,in6}_ifaddr in an mbuf tag.  Ideally
	 * this would be a superset of {ia,ia6}_flags, but the namespaces are
	 * overlapping at present, so we'll need a new set of values in future
	 * to achieve this.  For now, we will just rely on the address family
	 * related code paths examining this mbuf to interpret the flags.
	 */</span>
	u_int8_t pkt_proto;		<span class="enscript-comment">/* IPPROTO value */</span>
	u_int8_t pkt_flowsrc;		<span class="enscript-comment">/* FLOWSRC values */</span>
	u_int32_t pkt_flowid;		<span class="enscript-comment">/* flow ID */</span>
	u_int32_t pkt_flags;		<span class="enscript-comment">/* PKTF flags (see below) */</span>
	u_int32_t pkt_svc;		<span class="enscript-comment">/* MBUF_SVC value */</span>
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			u_int16_t src;		<span class="enscript-comment">/* ifindex of src addr i/f */</span>
			u_int16_t src_flags;	<span class="enscript-comment">/* src PKT_IFAIFF flags */</span>
			u_int16_t dst;		<span class="enscript-comment">/* ifindex of dst addr i/f */</span>
			u_int16_t dst_flags;	<span class="enscript-comment">/* dst PKT_IFAIFF flags */</span>
		} _pkt_iaif;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">src_ifindex</span>	_pkt_iaif.src
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">src_iff</span>		_pkt_iaif.src_flags
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">dst_ifindex</span>	_pkt_iaif.dst
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">dst_iff</span>		_pkt_iaif.dst_flags
		u_int64_t pkt_ifainfo;	<span class="enscript-comment">/* data field used by ifainfo */</span>
		u_int32_t pkt_unsent_databytes; <span class="enscript-comment">/* unsent data */</span>
	};
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MEASURE_BW</span>
	u_int64_t pkt_bwseq;		<span class="enscript-comment">/* sequence # */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MEASURE_BW */</span>
	u_int64_t pkt_enqueue_ts;	<span class="enscript-comment">/* enqueue time */</span>

	<span class="enscript-comment">/*
	 * Tags (external and built-in)
	 */</span>
	SLIST_HEAD(packet_tags, m_tag) tags; <span class="enscript-comment">/* list of external tags */</span>
	<span class="enscript-type">struct</span> proto_mtag proto_mtag;	<span class="enscript-comment">/* built-in protocol-specific tag */</span>
	<span class="enscript-type">struct</span> pf_mtag	pf_mtag;	<span class="enscript-comment">/* built-in PF tag */</span>
	<span class="enscript-type">struct</span> necp_mtag necp_mtag; <span class="enscript-comment">/* built-in NECP tag */</span>
	<span class="enscript-comment">/*
	 * Module private scratch space (32-bit aligned), currently 16-bytes
	 * large.  Anything stored here is not guaranteed to survive across
	 * modules.  This should be the penultimate structure right before
	 * the red zone.  Add new fields above this.
	 */</span>
	<span class="enscript-type">struct</span> {
		<span class="enscript-type">union</span> {
			u_int8_t	__mpriv8[16];
			u_int16_t	__mpriv16[8];
			<span class="enscript-type">struct</span> {
				<span class="enscript-type">union</span> {
					u_int8_t	__val8[4];
					u_int16_t	__val16[2];
					u_int32_t	__val32;
				} __mpriv32_u;
			}		__mpriv32[4];
			u_int64_t	__mpriv64[2];
		} __mpriv_u;
	} pkt_mpriv __attribute__((aligned(4)));
	u_int32_t redzone;		<span class="enscript-comment">/* red zone */</span>
};

<span class="enscript-comment">/*
 * Flow data source type.  A data source module is responsible for generating
 * a unique flow ID and associating it to each data flow as pkt_flowid.
 * This is required for flow control/advisory, as it allows the output queue
 * to identify the data source object and inform that it can resume its
 * transmission (in the event it was flow controlled.)
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FLOWSRC_INPCB</span>		1	<span class="enscript-comment">/* flow ID generated by INPCB */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FLOWSRC_IFNET</span>		2	<span class="enscript-comment">/* flow ID generated by interface */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FLOWSRC_PF</span>		3	<span class="enscript-comment">/* flow ID generated by PF */</span>

<span class="enscript-comment">/*
 * Packet flags.  Unlike m_flags, all packet flags are copied along when
 * copying m_pkthdr, i.e. no equivalent of M_COPYFLAGS here.  These flags
 * (and other classifier info) will be cleared during DLIL input.
 *
 * Some notes about M_LOOP and PKTF_LOOP:
 *
 *    - M_LOOP flag is overloaded, and its use is discouraged.  Historically,
 *	that flag was used by the KAME implementation for allowing certain
 *	certain exceptions to be made in the IP6_EXTHDR_CHECK() logic; this
 *	was originally meant to be set as the packet is looped back to the
 *	system, and in some circumstances temporarily set in ip6_output().
 *	Over time, this flag was used by the pre-output routines to indicate
 *	to the DLIL frameout and output routines, that the packet may be
 *	looped back to the system under the right conditions.  In addition,
 *	this is an mbuf flag rather than an mbuf packet header flag.
 *
 *    - PKTF_LOOP is an mbuf packet header flag, which is set if and only
 *	if the packet was looped back to the system.  This flag should be
 *	used instead for newer code.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_FLOW_ID</span>		0x1	<span class="enscript-comment">/* pkt has valid flowid value */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_FLOW_ADV</span>		0x2	<span class="enscript-comment">/* pkt triggers local flow advisory */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_FLOW_LOCALSRC</span>	0x4	<span class="enscript-comment">/* pkt is locally originated  */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_FLOW_RAWSOCK</span>	0x8	<span class="enscript-comment">/* pkt locally generated by raw sock */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_PRIO_PRIVILEGED</span>	0x10	<span class="enscript-comment">/* packet priority is privileged */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_PROXY_DST</span>		0x20	<span class="enscript-comment">/* processed but not locally destined */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_INET_RESOLVE</span>	0x40	<span class="enscript-comment">/* IPv4 resolver packet */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_INET6_RESOLVE</span>	0x80	<span class="enscript-comment">/* IPv6 resolver packet */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_RESOLVE_RTR</span>	0x100	<span class="enscript-comment">/* pkt is for resolving router */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_SW_LRO_PKT</span>		0x200	<span class="enscript-comment">/* pkt is a large coalesced pkt */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_SW_LRO_DID_CSUM</span>	0x400	<span class="enscript-comment">/* IP and TCP checksums done by LRO */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_MPTCP</span>		0x800	<span class="enscript-comment">/* TCP with MPTCP metadata */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_MPSO</span>		0x1000	<span class="enscript-comment">/* MPTCP socket meta data */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_LOOP</span>		0x2000	<span class="enscript-comment">/* loopbacked packet */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_IFAINFO</span>		0x4000	<span class="enscript-comment">/* pkt has valid interface addr info */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_SO_BACKGROUND</span>	0x8000	<span class="enscript-comment">/* data is from background source */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_FORWARDED</span>		0x10000	<span class="enscript-comment">/* pkt was forwarded from another i/f */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_PRIV_GUARDED</span>	0x20000	<span class="enscript-comment">/* pkt_mpriv area guard enabled */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_KEEPALIVE</span>		0x40000	<span class="enscript-comment">/* pkt is kernel-generated keepalive */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_SO_REALTIME</span>	0x80000	<span class="enscript-comment">/* data is realtime traffic */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_VALID_UNSENT_DATA</span>	0x100000 <span class="enscript-comment">/* unsent data is valid */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_TCP_REXMT</span>		0x200000 <span class="enscript-comment">/* packet is TCP retransmission */</span>

<span class="enscript-comment">/* flags related to flow control/advisory and identification */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PKTF_FLOW_MASK</span>	\
	(PKTF_FLOW_ID | PKTF_FLOW_ADV | PKTF_FLOW_LOCALSRC | PKTF_FLOW_RAWSOCK)

<span class="enscript-comment">/*
 * Description of external storage mapped into mbuf, valid only if M_EXT set.
 */</span>
<span class="enscript-type">struct</span> m_ext {
	caddr_t	ext_buf;		<span class="enscript-comment">/* start of buffer */</span>
	<span class="enscript-type">void</span>	(*ext_free)		<span class="enscript-comment">/* free routine if not the usual */</span>
		    (caddr_t, u_int, caddr_t);
	u_int	ext_size;		<span class="enscript-comment">/* size of buffer, for ext_free */</span>
	caddr_t	ext_arg;		<span class="enscript-comment">/* additional ext_free argument */</span>
	<span class="enscript-type">struct</span>	ext_refsq {		<span class="enscript-comment">/* references held */</span>
		<span class="enscript-type">struct</span> ext_refsq *forward, *backward;
	} ext_refs;
	<span class="enscript-type">struct</span> ext_ref {
		u_int32_t refcnt;
		u_int32_t flags;
	} *ext_refflags;
};

<span class="enscript-comment">/* define m_ext to a type since it gets redefined below */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> m_ext _m_ext_t;

<span class="enscript-comment">/*
 * The mbuf object
 */</span>
<span class="enscript-type">struct</span> mbuf {
	<span class="enscript-type">struct</span>	m_hdr m_hdr;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			<span class="enscript-type">struct</span>	pkthdr MH_pkthdr;	<span class="enscript-comment">/* M_PKTHDR set */</span>
			<span class="enscript-type">union</span> {
				<span class="enscript-type">struct</span>	m_ext MH_ext;	<span class="enscript-comment">/* M_EXT set */</span>
				<span class="enscript-type">char</span>	MH_databuf[_MHLEN];
			} MH_dat;
		} MH;
		<span class="enscript-type">char</span>	M_databuf[_MLEN];		<span class="enscript-comment">/* !M_PKTHDR, !M_EXT */</span>
	} M_dat;
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">m_next</span>		m_hdr.mh_next
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">m_len</span>		m_hdr.mh_len
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">m_data</span>		m_hdr.mh_data
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">m_type</span>		m_hdr.mh_type
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">m_flags</span>		m_hdr.mh_flags
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">m_nextpkt</span>	m_hdr.mh_nextpkt
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">m_act</span>		m_nextpkt
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">m_pkthdr</span>	M_dat.MH.MH_pkthdr
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">m_ext</span>		M_dat.MH.MH_dat.MH_ext
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">m_pktdat</span>	M_dat.MH.MH_dat.MH_databuf
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">m_dat</span>		M_dat.M_databuf
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_pktlen</span>(_m)	((_m)-&gt;m_pkthdr.len)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_pftag</span>(_m)	(&amp;(_m)-&gt;m_pkthdr.pf_mtag)

<span class="enscript-comment">/* mbuf flags (private) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_EXT</span>		0x0001	<span class="enscript-comment">/* has associated external storage */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_PKTHDR</span>	0x0002	<span class="enscript-comment">/* start of record */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_EOR</span>		0x0004	<span class="enscript-comment">/* end of record */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_PROTO1</span>	0x0008	<span class="enscript-comment">/* protocol-specific */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_PROTO2</span>	0x0010	<span class="enscript-comment">/* protocol-specific */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_PROTO3</span>	0x0020	<span class="enscript-comment">/* protocol-specific */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_LOOP</span>		0x0040	<span class="enscript-comment">/* packet is looped back (also see PKTF_LOOP) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_PROTO5</span>	0x0080	<span class="enscript-comment">/* protocol-specific */</span>

<span class="enscript-comment">/* mbuf pkthdr flags, also in m_flags (private) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_BCAST</span>		0x0100	<span class="enscript-comment">/* send/received as link-level broadcast */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_MCAST</span>		0x0200	<span class="enscript-comment">/* send/received as link-level multicast */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_FRAG</span>		0x0400	<span class="enscript-comment">/* packet is a fragment of a larger packet */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_FIRSTFRAG</span>	0x0800	<span class="enscript-comment">/* packet is first fragment */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_LASTFRAG</span>	0x1000	<span class="enscript-comment">/* packet is last fragment */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_PROMISC</span>	0x2000	<span class="enscript-comment">/* packet is promiscuous (shouldn't go to stack) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_HASFCS</span>	0x4000	<span class="enscript-comment">/* packet has FCS */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_TAGHDR</span>	0x8000	<span class="enscript-comment">/* m_tag hdr structure at top of mbuf data */</span>

<span class="enscript-comment">/*
 * Flags to purge when crossing layers.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_PROTOFLAGS</span> \
	(M_PROTO1|M_PROTO2|M_PROTO3|M_PROTO5)

<span class="enscript-comment">/* flags copied when copying m_pkthdr */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_COPYFLAGS</span>							\
	(M_PKTHDR|M_EOR|M_PROTO1|M_PROTO2|M_PROTO3 |			\
	M_LOOP|M_PROTO5|M_BCAST|M_MCAST|M_FRAG |			\
	M_FIRSTFRAG|M_LASTFRAG|M_PROMISC|M_HASFCS)

<span class="enscript-comment">/* flags indicating hw checksum support and sw checksum requirements */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_IP</span>			0x0001		<span class="enscript-comment">/* will csum IP */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_TCP</span>		0x0002		<span class="enscript-comment">/* will csum TCP */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_UDP</span>		0x0004		<span class="enscript-comment">/* will csum UDP */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_IP_FRAGS</span>		0x0008		<span class="enscript-comment">/* will csum IP fragments */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_FRAGMENT</span>		0x0010		<span class="enscript-comment">/* will do IP fragmentation */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_TCPIPV6</span>		0x0020		<span class="enscript-comment">/* will csum TCP for IPv6 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_UDPIPV6</span>		0x0040		<span class="enscript-comment">/* will csum UDP for IPv6 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_FRAGMENT_IPV6</span>	0x0080		<span class="enscript-comment">/* will do IPv6 fragmentation */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_IP_CHECKED</span>		0x0100		<span class="enscript-comment">/* did csum IP */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_IP_VALID</span>		0x0200		<span class="enscript-comment">/*   ... the csum is valid */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_DATA_VALID</span>		0x0400		<span class="enscript-comment">/* csum_data field is valid */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_PSEUDO_HDR</span>		0x0800		<span class="enscript-comment">/* csum_data has pseudo hdr */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_PARTIAL</span>		0x1000		<span class="enscript-comment">/* simple Sum16 computation */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_DELAY_DATA</span>		(CSUM_TCP | CSUM_UDP)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_DELAY_IP</span>		(CSUM_IP)	<span class="enscript-comment">/* IPv4 only: no IPv6 IP cksum */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_DELAY_IPV6_DATA</span>	(CSUM_TCPIPV6 | CSUM_UDPIPV6)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_DATA_IPV6_VALID</span>    CSUM_DATA_VALID	<span class="enscript-comment">/* csum_data field is valid */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_TX_FLAGS</span>							\
	(CSUM_DELAY_IP | CSUM_DELAY_DATA | CSUM_DELAY_IPV6_DATA |	\
	CSUM_DATA_VALID | CSUM_PARTIAL)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_RX_FLAGS</span>							\
	(CSUM_IP_CHECKED | CSUM_IP_VALID | CSUM_PSEUDO_HDR |		\
	CSUM_DATA_VALID | CSUM_PARTIAL)

<span class="enscript-comment">/*
 * Note: see also IF_HWASSIST_CSUM defined in &lt;net/if_var.h&gt;
 */</span>

<span class="enscript-comment">/* VLAN tag present */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_VLAN_TAG_VALID</span>	0x10000		<span class="enscript-comment">/* vlan_tag field is valid */</span>

<span class="enscript-comment">/* TCP Segment Offloading requested on this mbuf */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_TSO_IPV4</span>		0x100000	<span class="enscript-comment">/* This mbuf needs to be segmented by the NIC */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CSUM_TSO_IPV6</span>		0x200000	<span class="enscript-comment">/* This mbuf needs to be segmented by the NIC */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TSO_IPV4_OK</span>(_ifp, _m)						\
    (((_ifp)-&gt;if_hwassist &amp; IFNET_TSO_IPV4) &amp;&amp;				\
    ((_m)-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO_IPV4))			\

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TSO_IPV4_NOTOK</span>(_ifp, _m)					\
    (!((_ifp)-&gt;if_hwassist &amp; IFNET_TSO_IPV4) &amp;&amp;				\
    ((_m)-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO_IPV4))			\

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TSO_IPV6_OK</span>(_ifp, _m)						\
    (((_ifp)-&gt;if_hwassist &amp; IFNET_TSO_IPV6) &amp;&amp;				\
    ((_m)-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO_IPV6))			\

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TSO_IPV6_NOTOK</span>(_ifp, _m)					\
    (!((_ifp)-&gt;if_hwassist &amp; IFNET_TSO_IPV6) &amp;&amp;				\
    ((_m)-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO_IPV6))			\

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

<span class="enscript-comment">/* mbuf types */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_FREE</span>		0	<span class="enscript-comment">/* should be on free list */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_DATA</span>		1	<span class="enscript-comment">/* dynamic (data) allocation */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_HEADER</span>	2	<span class="enscript-comment">/* packet header */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_SOCKET</span>	3	<span class="enscript-comment">/* socket structure */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_PCB</span>		4	<span class="enscript-comment">/* protocol control block */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_RTABLE</span>	5	<span class="enscript-comment">/* routing tables */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_HTABLE</span>	6	<span class="enscript-comment">/* IMP host tables */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_ATABLE</span>	7	<span class="enscript-comment">/* address resolution tables */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_SONAME</span>	8	<span class="enscript-comment">/* socket name */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_SOOPTS</span>	10	<span class="enscript-comment">/* socket options */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_FTABLE</span>	11	<span class="enscript-comment">/* fragment reassembly header */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_RIGHTS</span>	12	<span class="enscript-comment">/* access rights */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_IFADDR</span>	13	<span class="enscript-comment">/* interface address */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_CONTROL</span>	14	<span class="enscript-comment">/* extra-data protocol message */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_OOBDATA</span>	15	<span class="enscript-comment">/* expedited data  */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_TAG</span>		16	<span class="enscript-comment">/* volatile metadata associated to pkts */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MT_MAX</span>		32	<span class="enscript-comment">/* enough? */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-comment">/*
 * mbuf allocation/deallocation macros:
 *
 *	MGET(struct mbuf *m, int how, int type)
 * allocates an mbuf and initializes it to contain internal data.
 *
 *	MGETHDR(struct mbuf *m, int how, int type)
 * allocates an mbuf and initializes it to contain a packet header
 * and internal data.
 */</span>

#<span class="enscript-reference">if</span> 1
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCHECK</span>(m) m_mcheck(m)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCHECK</span>(m)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MGET</span>(m, how, type) ((m) = m_get((how), (type)))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MGETHDR</span>(m, how, type)	((m) = m_gethdr((how), (type)))

<span class="enscript-comment">/*
 * Mbuf cluster macros.
 * MCLALLOC(caddr_t p, int how) allocates an mbuf cluster.
 * MCLGET adds such clusters to a normal mbuf;
 * the flag M_EXT is set upon success.
 * MCLFREE releases a reference to a cluster allocated by MCLALLOC,
 * freeing the cluster if the reference count has reached 0.
 *
 * Normal mbuf clusters are normally treated as character arrays
 * after allocation, but use the first word of the buffer as a free list
 * pointer while on the free list.
 */</span>
<span class="enscript-type">union</span> mcluster {
	<span class="enscript-type">union</span>	mcluster *mcl_next;
	<span class="enscript-type">char</span>	mcl_buf[MCLBYTES];
};

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCLALLOC</span>(p, how)	((p) = m_mclalloc(how))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCLFREE</span>(p)		m_mclfree(p)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCLGET</span>(m, how)		((m) = m_mclget(m, how))

<span class="enscript-comment">/*
 * Mbuf big cluster
 */</span>
<span class="enscript-type">union</span> mbigcluster {
	<span class="enscript-type">union</span> mbigcluster	*mbc_next;
	<span class="enscript-type">char</span>			mbc_buf[MBIGCLBYTES];
};

<span class="enscript-comment">/*
 * Mbuf jumbo cluster
 */</span>
<span class="enscript-type">union</span> m16kcluster {
	<span class="enscript-type">union</span> m16kcluster	*m16kcl_next;
	<span class="enscript-type">char</span>			m16kcl_buf[M16KCLBYTES];
};

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCLHASREFERENCE</span>(m)	m_mclhasreference(m)

<span class="enscript-comment">/*
 * MFREE(struct mbuf *m, struct mbuf *n)
 * Free a single mbuf and associated external storage.
 * Place the successor, if any, in n.
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MFREE</span>(m, n) ((n) = m_free(m))

<span class="enscript-comment">/*
 * Copy mbuf pkthdr from from to to.
 * from must have M_PKTHDR set, and to must be empty.
 * aux pointer will be moved to `to'.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">M_COPY_PKTHDR</span>(to, from)		m_copy_pkthdr(to, from)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">M_COPY_PFTAG</span>(to, from)		m_copy_pftag(to, from)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">M_COPY_CLASSIFIER</span>(to, from)	m_copy_classifier(to, from)

<span class="enscript-comment">/*
 * Set the m_data pointer of a newly-allocated mbuf (m_get/MGET) to place
 * an object of the specified size at the end of the mbuf, longword aligned.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">M_ALIGN</span>(m, len)							\
<span class="enscript-keyword">do</span> {									\
	(m)-&gt;m_data += (MLEN - (len)) &amp;~ (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">long</span>) - 1);		\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * As above, for mbufs allocated with m_gethdr/MGETHDR
 * or initialized by M_COPY_PKTHDR.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MH_ALIGN</span>(m, len)						\
<span class="enscript-keyword">do</span> {									\
	(m)-&gt;m_data += (MHLEN - (len)) &amp;~ (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">long</span>) - 1);		\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Compute the amount of space available
 * before the current start of data in an mbuf.
 * Subroutine - data not available if certain references.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">M_LEADINGSPACE</span>(m)	m_leadingspace(m)

<span class="enscript-comment">/*
 * Compute the amount of space available
 * after the end of data in an mbuf.
 * Subroutine - data not available if certain references.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">M_TRAILINGSPACE</span>(m)	m_trailingspace(m)

<span class="enscript-comment">/*
 * Arrange to prepend space of size plen to mbuf m.
 * If a new mbuf must be allocated, how specifies whether to wait.
 * If how is M_DONTWAIT and allocation fails, the original mbuf chain
 * is freed and m is set to NULL.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">M_PREPEND</span>(m, plen, how, align)	\
    ((m) = m_prepend_2((m), (plen), (how), (align)))

<span class="enscript-comment">/* change mbuf to new type */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCHTYPE</span>(m, t)		m_mchtype(m, t)

<span class="enscript-comment">/* compatiblity with 4.3 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_copy</span>(m, o, l)		m_copym((m), (o), (l), M_DONTWAIT)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBSHIFT</span>		20				<span class="enscript-comment">/* 1MB */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBSIZE</span>		(1 &lt;&lt; MBSHIFT)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">GBSHIFT</span>		30				<span class="enscript-comment">/* 1GB */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">GBSIZE</span>		(1 &lt;&lt; GBSHIFT)

<span class="enscript-comment">/*
 * M_STRUCT_GET ensures that intermediate protocol header (from &quot;off&quot; to
 * &quot;off+len&quot;) is located in single mbuf, on contiguous memory region.
 * The pointer to the region will be returned to pointer variable &quot;val&quot;,
 * with type &quot;typ&quot;.
 *
 * M_STRUCT_GET0 does the same, except that it aligns the structure at
 * very top of mbuf.  GET0 is likely to make memory copy than GET.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">M_STRUCT_GET</span>(val, typ, m, off, len)				\
<span class="enscript-keyword">do</span> {									\
	<span class="enscript-type">struct</span> mbuf *t;							\
	<span class="enscript-type">int</span> tmp;							\
									\
	<span class="enscript-keyword">if</span> ((m)-&gt;m_len &gt;= (off) + (len)) {				\
		(val) = (typ)(mtod((m), caddr_t) + (off));		\
	} <span class="enscript-keyword">else</span> {							\
		t = m_pulldown((m), (off), (len), &amp;tmp);		\
		<span class="enscript-keyword">if</span> (t != NULL) {					\
			<span class="enscript-keyword">if</span> (t-&gt;m_len &lt; tmp + (len))			\
				panic(<span class="enscript-string">&quot;m_pulldown malfunction&quot;</span>);	\
			(val) = (typ)(mtod(t, caddr_t) + tmp);		\
		} <span class="enscript-keyword">else</span> {						\
			(val) = (typ)NULL;				\
			(m) = NULL;					\
		}							\
	}								\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">M_STRUCT_GET0</span>(val, typ, m, off, len)				\
<span class="enscript-keyword">do</span> {									\
	<span class="enscript-type">struct</span> mbuf *t;							\
									\
	<span class="enscript-keyword">if</span> ((off) == 0 &amp;&amp; ((m)-&gt;m_len &gt;= (len))) {			\
		(val) = (typ)(<span class="enscript-type">void</span> *)mtod(m, caddr_t);			\
	} <span class="enscript-keyword">else</span> {							\
		t = m_pulldown((m), (off), (len), NULL);		\
		<span class="enscript-keyword">if</span> (t != NULL) {					\
			<span class="enscript-keyword">if</span> (t-&gt;m_len &lt; (len))				\
				panic(<span class="enscript-string">&quot;m_pulldown malfunction&quot;</span>);	\
			(val) = (typ)(<span class="enscript-type">void</span> *)mtod(t, caddr_t);		\
		} <span class="enscript-keyword">else</span> {						\
			(val) = (typ)NULL;				\
			(m) = NULL;					\
		}							\
	}								\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_INPUT_CHECK</span>(m, rcvif)					\
<span class="enscript-keyword">do</span> {									\
	<span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; MBUF_PKTHDR) ||				\
	    m-&gt;m_len &lt; 0 ||						\
	    m-&gt;m_len &gt; ((njcl &gt; 0) ? njclbytes : MBIGCLBYTES) ||	\
	    m-&gt;m_type == MT_FREE ||					\
	    ((m-&gt;m_flags &amp; M_EXT) != 0 &amp;&amp; m-&gt;m_ext.ext_buf == NULL)) {	\
		panic_plain(<span class="enscript-string">&quot;Failed mbuf validity check: mbuf %p len %d &quot;</span>  \
		    <span class="enscript-string">&quot;type %d flags 0x%x data %p rcvif %s ifflags 0x%x&quot;</span>,  \
		    m, m-&gt;m_len, m-&gt;m_type, m-&gt;m_flags,			   \
		    ((m-&gt;m_flags &amp; M_EXT) ? m-&gt;m_ext.ext_buf : m-&gt;m_data), \
		    if_name(rcvif),					\
		    (rcvif-&gt;if_flags &amp; 0xffff));			\
	}								\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Simple mbuf queueing system
 *
 * This is basically a SIMPLEQ adapted to mbuf use (i.e. using
 * m_nextpkt instead of field.sqe_next).
 *
 * m_next is ignored, so queueing chains of mbufs is possible
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MBUFQ_HEAD</span>(name)					\
<span class="enscript-type">struct</span> name {							\
	<span class="enscript-type">struct</span> mbuf *mq_first;	<span class="enscript-comment">/* first packet */</span>		\
	<span class="enscript-type">struct</span> mbuf **mq_last;	<span class="enscript-comment">/* addr of last next packet */</span>	\
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MBUFQ_INIT</span>(q)		do {				\
	MBUFQ_FIRST(q) = NULL;					\
	(q)-&gt;mq_last = &amp;MBUFQ_FIRST(q);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MBUFQ_PREPEND</span>(q, m)	do {				\
	<span class="enscript-keyword">if</span> ((MBUFQ_NEXT(m) = MBUFQ_FIRST(q)) == NULL)		\
		(q)-&gt;mq_last = &amp;MBUFQ_NEXT(m);			\
	MBUFQ_FIRST(q) = (m);					\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MBUFQ_ENQUEUE</span>(q, m)	do {				\
	MBUFQ_NEXT(m) = NULL;					\
	*(q)-&gt;mq_last = (m);					\
	(q)-&gt;mq_last = &amp;MBUFQ_NEXT(m);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MBUFQ_ENQUEUE_MULTI</span>(q, m, n)	do {			\
	MBUFQ_NEXT(n) = NULL;					\
	*(q)-&gt;mq_last = (m);					\
	(q)-&gt;mq_last = &amp;MBUFQ_NEXT(n);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MBUFQ_DEQUEUE</span>(q, m)	do {				\
	<span class="enscript-keyword">if</span> (((m) = MBUFQ_FIRST(q)) != NULL) {			\
		<span class="enscript-keyword">if</span> ((MBUFQ_FIRST(q) = MBUFQ_NEXT(m)) == NULL)	\
			(q)-&gt;mq_last = &amp;MBUFQ_FIRST(q);		\
		<span class="enscript-keyword">else</span>						\
			MBUFQ_NEXT(m) = NULL;			\
	}							\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUFQ_REMOVE</span>(q, m)	do {				\
	<span class="enscript-keyword">if</span> (MBUFQ_FIRST(q) == (m)) {				\
		MBUFQ_DEQUEUE(q, m);				\
	} <span class="enscript-keyword">else</span> {						\
		<span class="enscript-type">struct</span> mbuf *_m = MBUFQ_FIRST(q);		\
		<span class="enscript-keyword">while</span> (MBUFQ_NEXT(_m) != (m))			\
			_m = MBUFQ_NEXT(_m);			\
		<span class="enscript-keyword">if</span> ((MBUFQ_NEXT(_m) =				\
		    MBUFQ_NEXT(MBUFQ_NEXT(_m))) == NULL)	\
			(q)-&gt;mq_last = &amp;MBUFQ_NEXT(_m);		\
	}							\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MBUFQ_DRAIN</span>(q)		do {				\
	<span class="enscript-type">struct</span> mbuf *__m0;					\
	<span class="enscript-keyword">while</span> ((__m0 = MBUFQ_FIRST(q)) != NULL) {		\
		MBUFQ_FIRST(q) = MBUFQ_NEXT(__m0);		\
		MBUFQ_NEXT(__m0) = NULL;			\
		m_freem(__m0);					\
	}							\
	(q)-&gt;mq_last = &amp;MBUFQ_FIRST(q);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUFQ_FOREACH</span>(m, q)					\
	<span class="enscript-keyword">for</span> ((m) = MBUFQ_FIRST(q);				\
	    (m);						\
	    (m) = MBUFQ_NEXT(m))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUFQ_FOREACH_SAFE</span>(m, q, tvar)				\
	<span class="enscript-keyword">for</span> ((m) = MBUFQ_FIRST(q);				\
	    (m) &amp;&amp; ((tvar) = MBUFQ_NEXT(m), 1);			\
	    (m) = (tvar))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUFQ_EMPTY</span>(q)		((q)-&gt;mq_first == NULL)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MBUFQ_FIRST</span>(q)		((q)-&gt;mq_first)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MBUFQ_NEXT</span>(m)		((m)-&gt;m_nextpkt)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MBUFQ_LAST</span>(q)		(*(q)-&gt;mq_last)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">max_linkhdr</span>	P2ROUNDUP(_max_linkhdr, sizeof (u_int32_t))
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">max_protohdr</span>	P2ROUNDUP(_max_protohdr, sizeof (u_int32_t))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

<span class="enscript-comment">/*
 * Mbuf statistics (legacy).
 */</span>
<span class="enscript-type">struct</span> mbstat {
	u_int32_t	m_mbufs;	<span class="enscript-comment">/* mbufs obtained from page pool */</span>
	u_int32_t	m_clusters;	<span class="enscript-comment">/* clusters obtained from page pool */</span>
	u_int32_t	m_spare;	<span class="enscript-comment">/* spare field */</span>
	u_int32_t	m_clfree;	<span class="enscript-comment">/* free clusters */</span>
	u_int32_t	m_drops;	<span class="enscript-comment">/* times failed to find space */</span>
	u_int32_t	m_wait;		<span class="enscript-comment">/* times waited for space */</span>
	u_int32_t	m_drain;	<span class="enscript-comment">/* times drained protocols for space */</span>
	u_short		m_mtypes[256];	<span class="enscript-comment">/* type specific mbuf allocations */</span>
	u_int32_t	m_mcfail;	<span class="enscript-comment">/* times m_copym failed */</span>
	u_int32_t	m_mpfail;	<span class="enscript-comment">/* times m_pullup failed */</span>
	u_int32_t	m_msize;	<span class="enscript-comment">/* length of an mbuf */</span>
	u_int32_t	m_mclbytes;	<span class="enscript-comment">/* length of an mbuf cluster */</span>
	u_int32_t	m_minclsize;	<span class="enscript-comment">/* min length of data to allocate a cluster */</span>
	u_int32_t	m_mlen;		<span class="enscript-comment">/* length of data in an mbuf */</span>
	u_int32_t	m_mhlen;	<span class="enscript-comment">/* length of data in a header mbuf */</span>
	u_int32_t	m_bigclusters;	<span class="enscript-comment">/* clusters obtained from page pool */</span>
	u_int32_t	m_bigclfree;	<span class="enscript-comment">/* free clusters */</span>
	u_int32_t	m_bigmclbytes;	<span class="enscript-comment">/* length of an mbuf cluster */</span>
};

<span class="enscript-comment">/* Compatibillity with 10.3 */</span>
<span class="enscript-type">struct</span> ombstat {
	u_int32_t	m_mbufs;	<span class="enscript-comment">/* mbufs obtained from page pool */</span>
	u_int32_t	m_clusters;	<span class="enscript-comment">/* clusters obtained from page pool */</span>
	u_int32_t	m_spare;	<span class="enscript-comment">/* spare field */</span>
	u_int32_t	m_clfree;	<span class="enscript-comment">/* free clusters */</span>
	u_int32_t	m_drops;	<span class="enscript-comment">/* times failed to find space */</span>
	u_int32_t	m_wait;		<span class="enscript-comment">/* times waited for space */</span>
	u_int32_t	m_drain;	<span class="enscript-comment">/* times drained protocols for space */</span>
	u_short		m_mtypes[256];	<span class="enscript-comment">/* type specific mbuf allocations */</span>
	u_int32_t	m_mcfail;	<span class="enscript-comment">/* times m_copym failed */</span>
	u_int32_t	m_mpfail;	<span class="enscript-comment">/* times m_pullup failed */</span>
	u_int32_t	m_msize;	<span class="enscript-comment">/* length of an mbuf */</span>
	u_int32_t	m_mclbytes;	<span class="enscript-comment">/* length of an mbuf cluster */</span>
	u_int32_t	m_minclsize;	<span class="enscript-comment">/* min length of data to allocate a cluster */</span>
	u_int32_t	m_mlen;		<span class="enscript-comment">/* length of data in an mbuf */</span>
	u_int32_t	m_mhlen;	<span class="enscript-comment">/* length of data in a header mbuf */</span>
};

<span class="enscript-comment">/*
 * mbuf class statistics.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_MBUF_CNAME</span>	15

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>)
<span class="enscript-comment">/* For backwards compatibility with 32-bit userland process */</span>
<span class="enscript-type">struct</span> omb_class_stat {
	<span class="enscript-type">char</span>		mbcl_cname[MAX_MBUF_CNAME + 1]; <span class="enscript-comment">/* class name */</span>
	u_int32_t	mbcl_size;	<span class="enscript-comment">/* buffer size */</span>
	u_int32_t	mbcl_total;	<span class="enscript-comment">/* # of buffers created */</span>
	u_int32_t	mbcl_active;	<span class="enscript-comment">/* # of active buffers */</span>
	u_int32_t	mbcl_infree;	<span class="enscript-comment">/* # of available buffers */</span>
	u_int32_t	mbcl_slab_cnt;	<span class="enscript-comment">/* # of available slabs */</span>
	u_int64_t	mbcl_alloc_cnt;	<span class="enscript-comment">/* # of times alloc is called */</span>
	u_int64_t	mbcl_free_cnt;	<span class="enscript-comment">/* # of times free is called */</span>
	u_int64_t	mbcl_notified;	<span class="enscript-comment">/* # of notified wakeups */</span>
	u_int64_t	mbcl_purge_cnt;	<span class="enscript-comment">/* # of purges so far */</span>
	u_int64_t	mbcl_fail_cnt;	<span class="enscript-comment">/* # of allocation failures */</span>
	u_int32_t	mbcl_ctotal;	<span class="enscript-comment">/* total only for this class */</span>
	u_int32_t	mbcl_release_cnt; <span class="enscript-comment">/* amount of memory returned */</span>
	<span class="enscript-comment">/*
	 * Cache layer statistics
	 */</span>
	u_int32_t	mbcl_mc_state;	<span class="enscript-comment">/* cache state (see below) */</span>
	u_int32_t	mbcl_mc_cached;	<span class="enscript-comment">/* # of cached buffers */</span>
	u_int32_t	mbcl_mc_waiter_cnt;  <span class="enscript-comment">/* # waiters on the cache */</span>
	u_int32_t	mbcl_mc_wretry_cnt;  <span class="enscript-comment">/* # of wait retries */</span>
	u_int32_t	mbcl_mc_nwretry_cnt; <span class="enscript-comment">/* # of no-wait retry attempts */</span>
	u_int64_t	mbcl_reserved[4];    <span class="enscript-comment">/* for future use */</span>
} __attribute__((__packed__));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mb_class_stat {
	<span class="enscript-type">char</span>		mbcl_cname[MAX_MBUF_CNAME + 1]; <span class="enscript-comment">/* class name */</span>
	u_int32_t	mbcl_size;	<span class="enscript-comment">/* buffer size */</span>
	u_int32_t	mbcl_total;	<span class="enscript-comment">/* # of buffers created */</span>
	u_int32_t	mbcl_active;	<span class="enscript-comment">/* # of active buffers */</span>
	u_int32_t	mbcl_infree;	<span class="enscript-comment">/* # of available buffers */</span>
	u_int32_t	mbcl_slab_cnt;	<span class="enscript-comment">/* # of available slabs */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">KERNEL</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	u_int32_t	mbcl_pad;	<span class="enscript-comment">/* padding */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL || __LP64__ */</span>
	u_int64_t	mbcl_alloc_cnt;	<span class="enscript-comment">/* # of times alloc is called */</span>
	u_int64_t	mbcl_free_cnt;	<span class="enscript-comment">/* # of times free is called */</span>
	u_int64_t	mbcl_notified;	<span class="enscript-comment">/* # of notified wakeups */</span>
	u_int64_t	mbcl_purge_cnt;	<span class="enscript-comment">/* # of purges so far */</span>
	u_int64_t	mbcl_fail_cnt;	<span class="enscript-comment">/* # of allocation failures */</span>
	u_int32_t	mbcl_ctotal;	<span class="enscript-comment">/* total only for this class */</span>
	u_int32_t	mbcl_release_cnt; <span class="enscript-comment">/* amount of memory returned */</span>
	<span class="enscript-comment">/*
	 * Cache layer statistics
	 */</span>
	u_int32_t	mbcl_mc_state;	<span class="enscript-comment">/* cache state (see below) */</span>
	u_int32_t	mbcl_mc_cached;	<span class="enscript-comment">/* # of cached buffers */</span>
	u_int32_t	mbcl_mc_waiter_cnt;  <span class="enscript-comment">/* # waiters on the cache */</span>
	u_int32_t	mbcl_mc_wretry_cnt;  <span class="enscript-comment">/* # of wait retries */</span>
	u_int32_t	mbcl_mc_nwretry_cnt; <span class="enscript-comment">/* # of no-wait retry attempts */</span>
	u_int32_t	mbcl_peak_reported; <span class="enscript-comment">/* last usage peak reported */</span>
	u_int32_t	mbcl_reserved[7];    <span class="enscript-comment">/* for future use */</span>
} mb_class_stat_t;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCS_DISABLED</span>	0	<span class="enscript-comment">/* cache is permanently disabled */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCS_ONLINE</span>	1	<span class="enscript-comment">/* cache is online */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCS_PURGING</span>	2	<span class="enscript-comment">/* cache is being purged */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCS_OFFLINE</span>	3	<span class="enscript-comment">/* cache is offline (resizing) */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>)
<span class="enscript-comment">/* For backwards compatibility with 32-bit userland process */</span>
<span class="enscript-type">struct</span> omb_stat {
	u_int32_t		mbs_cnt;	<span class="enscript-comment">/* number of classes */</span>
	<span class="enscript-type">struct</span> omb_class_stat	mbs_class[1];	<span class="enscript-comment">/* class array */</span>
} __attribute__((__packed__));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mb_stat {
	u_int32_t	mbs_cnt;	<span class="enscript-comment">/* number of classes */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">KERNEL</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	u_int32_t	mbs_pad;	<span class="enscript-comment">/* padding */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL || __LP64__ */</span>
	mb_class_stat_t	mbs_class[1];	<span class="enscript-comment">/* class array */</span>
} mb_stat_t;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PRIVATE</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MLEAK_STACK_DEPTH</span>	16	<span class="enscript-comment">/* Max PC stack depth */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mleak_trace_stat {
	u_int64_t	mltr_collisions;
	u_int64_t	mltr_hitcount;
	u_int64_t	mltr_allocs;
	u_int64_t	mltr_depth;
	u_int64_t	mltr_addr[MLEAK_STACK_DEPTH];
} mleak_trace_stat_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mleak_stat {
	u_int32_t		ml_isaddr64;	<span class="enscript-comment">/* 64-bit KVA? */</span>
	u_int32_t		ml_cnt;		<span class="enscript-comment">/* number of traces */</span>
	mleak_trace_stat_t	ml_trace[1];	<span class="enscript-comment">/* trace array */</span>
} mleak_stat_t;

<span class="enscript-type">struct</span> mleak_table {
	u_int32_t mleak_capture;	<span class="enscript-comment">/* sampling capture counter */</span>
	u_int32_t mleak_sample_factor;	<span class="enscript-comment">/* sample factor */</span>

	<span class="enscript-comment">/* Times two active records want to occupy the same spot */</span>
	u_int64_t alloc_collisions;
	u_int64_t trace_collisions;

	<span class="enscript-comment">/* Times new record lands on spot previously occupied by freed alloc */</span>
	u_int64_t alloc_overwrites;
	u_int64_t trace_overwrites;

	<span class="enscript-comment">/* Times a new alloc or trace is put into the hash table */</span>
	u_int64_t alloc_recorded;
	u_int64_t trace_recorded;

	<span class="enscript-comment">/* Total number of outstanding allocs */</span>
	u_int64_t outstanding_allocs;

	<span class="enscript-comment">/* Times mleak_log returned false because couldn't acquire the lock */</span>
	u_int64_t total_conflicts;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRIVATE */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
__BEGIN_DECLS

<span class="enscript-comment">/*
 * Exported (private)
 */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mbstat mbstat;			<span class="enscript-comment">/* statistics */</span>

__END_DECLS
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
__BEGIN_DECLS

<span class="enscript-comment">/*
 * Not exported (xnu private)
 */</span>

<span class="enscript-comment">/* flags to m_get/MGET */</span>
<span class="enscript-comment">/* Need to include malloc.h to get right options for malloc  */</span>
#<span class="enscript-reference">include</span>	<span class="enscript-string">&lt;sys/malloc.h&gt;</span>

<span class="enscript-type">struct</span> mbuf;

<span class="enscript-comment">/* length to m_copy to copy all */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_COPYALL</span>	1000000000

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_DONTWAIT</span>	M_NOWAIT
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_WAIT</span>		M_WAITOK

<span class="enscript-comment">/* modes for m_copym and variants */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_COPYM_NOOP_HDR</span>	0	<span class="enscript-comment">/* don't copy/move pkthdr contents */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_COPYM_COPY_HDR</span>	1	<span class="enscript-comment">/* copy pkthdr from old to new */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_COPYM_MOVE_HDR</span>	2	<span class="enscript-comment">/* move pkthdr from old to new */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_COPYM_MUST_COPY_HDR</span>	3	<span class="enscript-comment">/* MUST copy pkthdr from old to new */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_COPYM_MUST_MOVE_HDR</span>	4	<span class="enscript-comment">/* MUST move pkthdr from old to new */</span>

<span class="enscript-comment">/*
 * These macros are mapped to the appropriate KPIs, so that private code
 * can be simply recompiled in order to be forward-compatible with future
 * changes toward the struture sizes.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MLEN</span>		mbuf_get_mlen()		<span class="enscript-comment">/* normal data len */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MHLEN</span>		mbuf_get_mhlen()	<span class="enscript-comment">/* data len w/pkthdr */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MINCLSIZE</span>	mbuf_get_minclsize()	<span class="enscript-comment">/* cluster usage threshold */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">m_freem</span>(<span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">extern</span> u_int64_t <span class="enscript-function-name">mcl_to_paddr</span>(<span class="enscript-type">char</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">m_adj</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">m_cat</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">m_copydata</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">m_copym</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">m_copym_mode</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, uint32_t);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">m_get</span>(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">m_gethdr</span>(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">m_getpacket</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">m_getpackets</span>(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">m_mclget</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *<span class="enscript-function-name">m_mtod</span>(<span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">m_prepend_2</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">m_pullup</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">m_split</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">m_mclfree</span>(caddr_t p);

<span class="enscript-comment">/*
 * On platforms which require strict alignment (currently for anything but
 * i386 or x86_64), this macro checks whether the data pointer of an mbuf
 * is 32-bit aligned (this is the expected minimum alignment for protocol
 * headers), and assert otherwise.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_STRICT_DATA_ALIGNMENT_CHECK_32</span>(_m)
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__i386__ &amp;&amp; !__x86_64__ */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_STRICT_DATA_ALIGNMENT_CHECK_32</span>(_m) do {			\
	<span class="enscript-keyword">if</span> (!IS_P2ALIGNED((_m)-&gt;m_data, <span class="enscript-keyword">sizeof</span> (u_int32_t))) {		\
		<span class="enscript-keyword">if</span> (((_m)-&gt;m_flags &amp; M_PKTHDR) &amp;&amp;			\
		    (_m)-&gt;m_pkthdr.rcvif != NULL) {			\
			panic_plain(<span class="enscript-string">&quot;\n%s: mbuf %p data ptr %p is not &quot;</span>	\
			    <span class="enscript-string">&quot;32-bit aligned [%s: alignerrs=%lld]\n&quot;</span>,	\
			    __func__, (_m), (_m)-&gt;m_data,		\
			    if_name((_m)-&gt;m_pkthdr.rcvif),		\
			    (_m)-&gt;m_pkthdr.rcvif-&gt;if_alignerrs);	\
		} <span class="enscript-keyword">else</span> {						\
			panic_plain(<span class="enscript-string">&quot;\n%s: mbuf %p data ptr %p is not &quot;</span>	\
			    <span class="enscript-string">&quot;32-bit aligned\n&quot;</span>,				\
			    __func__, (_m), (_m)-&gt;m_data);		\
		}							\
	}								\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__i386__ &amp;&amp; !__x86_64__ */</span>

<span class="enscript-comment">/* Maximum number of MBUF_SC values (excluding MBUF_SC_UNSPEC) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBUF_SC_MAX_CLASSES</span>	10

<span class="enscript-comment">/*
 * These conversion macros rely on the corresponding MBUF_SC and
 * MBUF_TC values in order to establish the following mapping:
 *
 *	MBUF_SC_BK_SYS	] ==&gt;	MBUF_TC_BK
 *	MBUF_SC_BK	]
 *
 *	MBUF_SC_BE	] ==&gt;	MBUF_TC_BE
 *	MBUF_SC_RD	]
 *	MBUF_SC_OAM	]
 *
 *	MBUF_SC_AV	] ==&gt;	MBUF_TC_VI
 *	MBUF_SC_RV	]
 *	MBUF_SC_VI	]
 *
 *	MBUF_SC_VO	] ==&gt;	MBUF_TC_VO
 *	MBUF_SC_CTL	]
 *
 * The values assigned to each service class allows for a fast mapping to
 * the corresponding MBUF_TC traffic class values, as well as to retrieve the
 * assigned index; therefore care must be taken when comparing against these
 * values.  Use the corresponding class and index macros to retrieve the
 * corresponding portion, and never assume that a higher class corresponds
 * to a higher index.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_SCVAL</span>(x)		((x) &amp; 0xffff)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_SCIDX</span>(x)		((((x) &gt;&gt; 16) &amp; 0xff) &gt;&gt; 3)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_SC2TC</span>(_sc)		(MBUF_SCVAL(_sc) &gt;&gt; 7)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_TC2SCVAL</span>(_tc)	((_tc) &lt;&lt; 7)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_MBUF_SC_BACKGROUND</span>(_sc) (((_sc) == MBUF_SC_BK_SYS) || \
	((_sc) == MBUF_SC_BK))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IS_MBUF_SC_REALTIME</span>(_sc)	((_sc) &gt;= MBUF_SC_AV &amp;&amp; (_sc) &lt;= MBUF_SC_VO)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_MBUF_SC_BESTEFFORT</span>(_sc)	((_sc) == MBUF_SC_BE || \
    (_sc) == MBUF_SC_RD || (_sc) == MBUF_SC_OAM)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCIDX_BK_SYS</span>		MBUF_SCIDX(MBUF_SC_BK_SYS)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCIDX_BK</span>		MBUF_SCIDX(MBUF_SC_BK)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCIDX_BE</span>		MBUF_SCIDX(MBUF_SC_BE)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCIDX_RD</span>		MBUF_SCIDX(MBUF_SC_RD)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCIDX_OAM</span>		MBUF_SCIDX(MBUF_SC_OAM)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCIDX_AV</span>		MBUF_SCIDX(MBUF_SC_AV)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCIDX_RV</span>		MBUF_SCIDX(MBUF_SC_RV)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCIDX_VI</span>		MBUF_SCIDX(MBUF_SC_VI)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCIDX_VO</span>		MBUF_SCIDX(MBUF_SC_VO)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCIDX_CTL</span>		MBUF_SCIDX(MBUF_SC_CTL)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCVAL_BK_SYS</span>		MBUF_SCVAL(MBUF_SC_BK_SYS)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCVAL_BK</span>		MBUF_SCVAL(MBUF_SC_BK)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCVAL_BE</span>		MBUF_SCVAL(MBUF_SC_BE)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCVAL_RD</span>		MBUF_SCVAL(MBUF_SC_RD)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCVAL_OAM</span>		MBUF_SCVAL(MBUF_SC_OAM)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCVAL_AV</span>		MBUF_SCVAL(MBUF_SC_AV)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCVAL_RV</span>		MBUF_SCVAL(MBUF_SC_RV)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCVAL_VI</span>		MBUF_SCVAL(MBUF_SC_VI)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCVAL_VO</span>		MBUF_SCVAL(MBUF_SC_VO)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SCVAL_CTL</span>		MBUF_SCVAL(MBUF_SC_CTL)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_VALID_SC</span>(c)						\
	(c == MBUF_SC_BK_SYS || c == MBUF_SC_BK || c == MBUF_SC_BE ||	\
	c == MBUF_SC_RD || c == MBUF_SC_OAM || c == MBUF_SC_AV ||	\
	c == MBUF_SC_RV || c == MBUF_SC_VI || c == MBUF_SC_VO ||	\
	c == MBUF_SC_CTL)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_VALID_SCIDX</span>(c)						\
	(c == SCIDX_BK_SYS || c == SCIDX_BK || c == SCIDX_BE ||		\
	c == SCIDX_RD || c == SCIDX_OAM || c == SCIDX_AV ||		\
	c == SCIDX_RV || c == SCIDX_VI || c == SCIDX_VO ||		\
	c == SCIDX_CTL)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_VALID_SCVAL</span>(c)						\
	(c == SCVAL_BK_SYS || c == SCVAL_BK || c == SCVAL_BE ||		\
	c == SCVAL_RD || c == SCVAL_OAM || c == SCVAL_AV ||		\
	c == SCVAL_RV || c == SCVAL_VI || c == SCVAL_VO ||		\
	c == SCVAL_CTL)

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *mbutl;	<span class="enscript-comment">/* start VA of mbuf pool */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *embutl;	<span class="enscript-comment">/* end VA of mbuf pool */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> nmbclusters;	<span class="enscript-comment">/* number of mapped clusters */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> njcl;		<span class="enscript-comment">/* # of jumbo clusters  */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> njclbytes;	<span class="enscript-comment">/* size of a jumbo cluster */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> max_hdr;		<span class="enscript-comment">/* largest link+protocol header */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> max_datalen;	<span class="enscript-comment">/* MHLEN - max_hdr */</span>

<span class="enscript-comment">/* Use max_linkhdr instead of _max_linkhdr */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> _max_linkhdr;	<span class="enscript-comment">/* largest link-level header */</span>

<span class="enscript-comment">/* Use max_protohdr instead of _max_protohdr */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> _max_protohdr;	<span class="enscript-comment">/* largest protocol header */</span>

__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mbuf_default_ncl(<span class="enscript-type">int</span>, u_int64_t);
__private_extern__ <span class="enscript-type">void</span> mbinit(<span class="enscript-type">void</span>);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_clattach(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, caddr_t,
    <span class="enscript-type">void</span> (*)(caddr_t, u_int, caddr_t), u_int, caddr_t, <span class="enscript-type">int</span>);
__private_extern__ caddr_t m_bigalloc(<span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">void</span> m_bigfree(caddr_t, u_int, caddr_t);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_mbigget(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
__private_extern__ caddr_t m_16kalloc(<span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">void</span> m_16kfree(caddr_t, u_int, caddr_t);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_m16kget(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">int</span> m_reinit(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_free(<span class="enscript-type">struct</span> mbuf *);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_getclr(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_getptr(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> *);
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> m_length(<span class="enscript-type">struct</span> mbuf *);
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> m_length2(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> mbuf **);
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> m_fixhdr(<span class="enscript-type">struct</span> mbuf *);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_defrag(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_defrag_offset(<span class="enscript-type">struct</span> mbuf *, u_int32_t, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_prepend(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_copyup(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_retry(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_retryhdr(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">int</span> m_freem_list(<span class="enscript-type">struct</span> mbuf *);
__private_extern__ <span class="enscript-type">int</span> m_append(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, caddr_t);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_last(<span class="enscript-type">struct</span> mbuf *);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_devget(<span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">void</span> (*)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, size_t));
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_pulldown(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> *);

__private_extern__ <span class="enscript-type">struct</span> mbuf *m_getcl(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
__private_extern__ caddr_t m_mclalloc(<span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">int</span> m_mclhasreference(<span class="enscript-type">struct</span> mbuf *);
__private_extern__ <span class="enscript-type">void</span> m_copy_pkthdr(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> mbuf *);
__private_extern__ <span class="enscript-type">void</span> m_copy_pftag(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> mbuf *);
__private_extern__ <span class="enscript-type">void</span> m_copy_classifier(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> mbuf *);

__private_extern__ <span class="enscript-type">struct</span> mbuf *m_dtom(<span class="enscript-type">void</span> *);
__private_extern__ <span class="enscript-type">int</span> m_mtocl(<span class="enscript-type">void</span> *);
__private_extern__ <span class="enscript-type">union</span> mcluster *m_cltom(<span class="enscript-type">int</span>);

__private_extern__ <span class="enscript-type">int</span> m_trailingspace(<span class="enscript-type">struct</span> mbuf *);
__private_extern__ <span class="enscript-type">int</span> m_leadingspace(<span class="enscript-type">struct</span> mbuf *);

__private_extern__ <span class="enscript-type">struct</span> mbuf *m_normalize(<span class="enscript-type">struct</span> mbuf *m);
__private_extern__ <span class="enscript-type">void</span> m_mchtype(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> t);
__private_extern__ <span class="enscript-type">void</span> m_mcheck(<span class="enscript-type">struct</span> mbuf *);

__private_extern__ <span class="enscript-type">void</span> m_copyback(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_copyback_cow(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>,
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">int</span> m_makewritable(<span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_dup(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> how);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_copym_with_hdrs(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>,
    <span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">int</span> *, uint32_t);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_getpackethdrs(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_getpacket_how(<span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_getpackets_internal(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *, <span class="enscript-type">int</span>,
    <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, size_t);
__private_extern__ <span class="enscript-type">struct</span> mbuf *m_allocpacket_internal(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *, size_t,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, size_t);

__private_extern__ <span class="enscript-type">void</span> m_drain(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 * Packets may have annotations attached by affixing a list of &quot;packet
 * tags&quot; to the pkthdr structure.  Packet tags are dynamically allocated
 * semi-opaque data structures that have a fixed header (struct m_tag)
 * that specifies the size of the memory block and an &lt;id,type&gt; pair that
 * identifies it. The id identifies the module and the type identifies the
 * type of data for that module. The id of zero is reserved for the kernel.
 *
 * Note that the packet tag returned by m_tag_allocate has the default
 * memory alignment implemented by malloc.  To reference private data one
 * can use a construct like:
 *
 *      struct m_tag *mtag = m_tag_allocate(...);
 *      struct foo *p = (struct foo *)(mtag+1);
 *
 * if the alignment of struct m_tag is sufficient for referencing members
 * of struct foo.  Otherwise it is necessary to embed struct m_tag within
 * the private data structure to insure proper alignment; e.g.
 *
 *      struct foo {
 *              struct m_tag    tag;
 *              ...
 *      };
 *      struct foo *p = (struct foo *) m_tag_allocate(...);
 *      struct m_tag *mtag = &amp;p-&gt;tag;
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KERNEL_MODULE_TAG_ID</span>	0

<span class="enscript-type">enum</span> {
	KERNEL_TAG_TYPE_NONE			= 0,
	KERNEL_TAG_TYPE_DUMMYNET		= 1,
	KERNEL_TAG_TYPE_DIVERT			= 2,
	KERNEL_TAG_TYPE_IPFORWARD		= 3,
	KERNEL_TAG_TYPE_IPFILT			= 4,
	KERNEL_TAG_TYPE_MACLABEL		= 5,
	KERNEL_TAG_TYPE_MAC_POLICY_LABEL	= 6,
	KERNEL_TAG_TYPE_ENCAP			= 8,
	KERNEL_TAG_TYPE_INET6			= 9,
	KERNEL_TAG_TYPE_IPSEC			= 10,
	KERNEL_TAG_TYPE_DRVAUX			= 11,
};

<span class="enscript-comment">/* Packet tag routines */</span>
__private_extern__ <span class="enscript-type">struct</span>  m_tag *m_tag_alloc(u_int32_t, u_int16_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span>  m_tag *m_tag_create(u_int32_t, u_int16_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>,
	<span class="enscript-type">struct</span> mbuf *);
__private_extern__ <span class="enscript-type">void</span> m_tag_free(<span class="enscript-type">struct</span> m_tag *);
__private_extern__ <span class="enscript-type">void</span> m_tag_prepend(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> m_tag *);
__private_extern__ <span class="enscript-type">void</span> m_tag_unlink(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> m_tag *);
__private_extern__ <span class="enscript-type">void</span> m_tag_delete(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> m_tag *);
__private_extern__ <span class="enscript-type">void</span> m_tag_delete_chain(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> m_tag *);
__private_extern__ <span class="enscript-type">struct</span> m_tag *m_tag_locate(<span class="enscript-type">struct</span> mbuf *, u_int32_t,
    u_int16_t, <span class="enscript-type">struct</span> m_tag *);
__private_extern__ <span class="enscript-type">struct</span> m_tag *m_tag_copy(<span class="enscript-type">struct</span> m_tag *, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">int</span> m_tag_copy_chain(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">void</span> m_tag_init(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">struct</span>  m_tag *m_tag_first(<span class="enscript-type">struct</span> mbuf *);
__private_extern__ <span class="enscript-type">struct</span>  m_tag *m_tag_next(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> m_tag *);

__END_DECLS
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
__BEGIN_DECLS

__private_extern__ <span class="enscript-type">void</span> m_scratch_init(<span class="enscript-type">struct</span> mbuf *);
__private_extern__ u_int32_t m_scratch_get(<span class="enscript-type">struct</span> mbuf *, u_int8_t **);

__private_extern__ <span class="enscript-type">void</span> m_classifier_init(<span class="enscript-type">struct</span> mbuf *, uint32_t);

__private_extern__ <span class="enscript-type">int</span> m_set_service_class(<span class="enscript-type">struct</span> mbuf *, mbuf_svc_class_t);
__private_extern__ mbuf_svc_class_t m_get_service_class(<span class="enscript-type">struct</span> mbuf *);
__private_extern__ mbuf_svc_class_t m_service_class_from_idx(u_int32_t);
__private_extern__ mbuf_svc_class_t m_service_class_from_val(u_int32_t);
__private_extern__ <span class="enscript-type">int</span> m_set_traffic_class(<span class="enscript-type">struct</span> mbuf *, mbuf_traffic_class_t);
__private_extern__ mbuf_traffic_class_t m_get_traffic_class(<span class="enscript-type">struct</span> mbuf *);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ADDCARRY</span>(_x)  do {						\
	<span class="enscript-keyword">while</span> (((_x) &gt;&gt; 16) != 0)					\
		(_x) = ((_x) &gt;&gt; 16) + ((_x) &amp; 0xffff);			\
} <span class="enscript-keyword">while</span> (0)

__private_extern__ u_int16_t m_adj_sum16(<span class="enscript-type">struct</span> mbuf *, u_int32_t,
    u_int32_t, u_int32_t);
__private_extern__ u_int16_t m_sum16(<span class="enscript-type">struct</span> mbuf *, u_int32_t, u_int32_t);

__END_DECLS
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !_SYS_MBUF_H_ */</span>
</pre>
<hr />
</body></html>