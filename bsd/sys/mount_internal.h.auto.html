<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mount_internal.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mount_internal.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)mount.h	8.21 (Berkeley) 5/20/95
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_SYS_MOUNT_INTERNAL_H_</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_SYS_MOUNT_INTERNAL_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/radix.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>		<span class="enscript-comment">/* XXX for AF_MAX */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vfs_context.h&gt;</span>		<span class="enscript-comment">/* XXX for AF_MAX */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>

<span class="enscript-type">struct</span> label;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">typedef</span> uint64_t  pending_io_t;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">INCR_PENDING_IO</span>(a, b) OSAddAtomic64((int64_t)(a), (int64_t *)&amp;(b));
#<span class="enscript-reference">else</span>
<span class="enscript-type">typedef</span> uint32_t  pending_io_t;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">INCR_PENDING_IO</span>(a, b) OSAddAtomic((int32_t)(a), (int32_t *)&amp;(b));
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 * Structure per mounted file system.  Each mounted file system has an
 * array of operations and an instance record.  The file systems are
 * put on a doubly linked list.
 */</span>
<span class="enscript-function-name">TAILQ_HEAD</span>(vnodelst, vnode);

<span class="enscript-type">struct</span> mount {
	TAILQ_ENTRY(mount) mnt_list;		<span class="enscript-comment">/* mount list */</span>
	int32_t		mnt_count;		<span class="enscript-comment">/* reference on the mount */</span>
	lck_mtx_t	mnt_mlock;		<span class="enscript-comment">/* mutex that protects mount point */</span>
	<span class="enscript-type">struct</span> vfsops	*mnt_op;		<span class="enscript-comment">/* operations on fs */</span>
	<span class="enscript-type">struct</span> vfstable	*mnt_vtable;		<span class="enscript-comment">/* configuration info */</span>
	<span class="enscript-type">struct</span> vnode	*mnt_vnodecovered;	<span class="enscript-comment">/* vnode we mounted on */</span>
	<span class="enscript-type">struct</span> vnodelst	mnt_vnodelist;		<span class="enscript-comment">/* list of vnodes this mount */</span>
	<span class="enscript-type">struct</span> vnodelst	mnt_workerqueue;		<span class="enscript-comment">/* list of vnodes this mount */</span>
	<span class="enscript-type">struct</span> vnodelst	mnt_newvnodes;		<span class="enscript-comment">/* list of vnodes this mount */</span>
	uint32_t		mnt_flag;		<span class="enscript-comment">/* flags */</span>
	uint32_t		mnt_kern_flag;		<span class="enscript-comment">/* kernel only flags */</span>
	uint32_t		mnt_compound_ops;	<span class="enscript-comment">/* Available compound operations */</span>
	uint32_t		mnt_lflag;			<span class="enscript-comment">/* mount life cycle flags */</span>
	uint32_t		mnt_maxsymlinklen;	<span class="enscript-comment">/* max size of short symlink */</span>
	<span class="enscript-type">struct</span> vfsstatfs	mnt_vfsstat;		<span class="enscript-comment">/* cache of filesystem stats */</span>
	qaddr_t		mnt_data;		<span class="enscript-comment">/* private data */</span>
	<span class="enscript-comment">/* Cached values of the IO constraints for the device */</span>
	uint32_t	mnt_maxreadcnt;		<span class="enscript-comment">/* Max. byte count for read */</span>
	uint32_t	mnt_maxwritecnt;	<span class="enscript-comment">/* Max. byte count for write */</span>
	uint32_t	mnt_segreadcnt;		<span class="enscript-comment">/* Max. segment count for read */</span>
	uint32_t	mnt_segwritecnt;	<span class="enscript-comment">/* Max. segment count for write */</span>
	uint32_t	mnt_maxsegreadsize;	<span class="enscript-comment">/* Max. segment read size  */</span>
	uint32_t	mnt_maxsegwritesize;	<span class="enscript-comment">/* Max. segment write size */</span>
	uint32_t	mnt_alignmentmask;	<span class="enscript-comment">/* Mask of bits that aren't addressable via DMA */</span>
	uint32_t	mnt_devblocksize;	<span class="enscript-comment">/* the underlying device block size */</span>
	uint32_t	mnt_ioqueue_depth;	<span class="enscript-comment">/* the maxiumum number of commands a device can accept */</span>
        uint32_t	mnt_ioscale;		<span class="enscript-comment">/* scale the various throttles/limits imposed on the amount of I/O in flight */</span>
	uint32_t	mnt_ioflags;		<span class="enscript-comment">/* flags for  underlying device */</span>
	pending_io_t	mnt_pending_write_size __attribute__((aligned(<span class="enscript-keyword">sizeof</span>(pending_io_t))));	<span class="enscript-comment">/* byte count of pending writes */</span>
	pending_io_t	mnt_pending_read_size  __attribute__((aligned(<span class="enscript-keyword">sizeof</span>(pending_io_t))));	<span class="enscript-comment">/* byte count of pending reads */</span>
	<span class="enscript-type">struct</span> timeval	mnt_last_write_issued_timestamp;
	<span class="enscript-type">struct</span> timeval	mnt_last_write_completed_timestamp;
	int64_t		mnt_max_swappin_available;
	
	lck_rw_t	mnt_rwlock;		<span class="enscript-comment">/* mutex readwrite lock */</span>
	lck_mtx_t	mnt_renamelock;		<span class="enscript-comment">/* mutex that serializes renames that change shape of tree */</span>
	vnode_t		mnt_devvp;		<span class="enscript-comment">/* the device mounted on for local file systems */</span>
	uint32_t	mnt_devbsdunit;		<span class="enscript-comment">/* the BSD unit number of the device */</span>
	uint64_t	mnt_throttle_mask;	<span class="enscript-comment">/* the throttle mask of what devices will be affected by I/O from this mnt */</span>
	<span class="enscript-type">void</span>		*mnt_throttle_info;	<span class="enscript-comment">/* used by the throttle code */</span>
	int32_t		mnt_crossref;		<span class="enscript-comment">/* refernces to cover lookups  crossing into mp */</span>
	int32_t		mnt_iterref;		<span class="enscript-comment">/* refernces to cover iterations; drained makes it -ve  */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	int32_t		mnt_numtriggers; 	<span class="enscript-comment">/* num of trigger vnodes for this mount */</span>
	vfs_trigger_callback_t *mnt_triggercallback;
	<span class="enscript-type">void</span>		*mnt_triggerdata;
#<span class="enscript-reference">endif</span>
 	<span class="enscript-comment">/* XXX 3762912 hack to support HFS filesystem 'owner' */</span>
 	uid_t		mnt_fsowner;
 	gid_t		mnt_fsgroup;

	<span class="enscript-type">struct</span> label	*mnt_mntlabel;		<span class="enscript-comment">/* MAC mount label */</span>
	<span class="enscript-type">struct</span> label	*mnt_fslabel;		<span class="enscript-comment">/* MAC default fs label */</span>

	<span class="enscript-comment">/*
	 * cache the rootvp of the last mount point
	 * in the chain in the mount struct pointed
	 * to by the vnode sitting in '/'
	 * this cache is used to shortcircuit the
	 * mount chain traversal and allows us
	 * to traverse to the true underlying rootvp
	 * in 1 easy step inside of 'cache_lookup_path'
	 *
	 * make sure to validate against the cached vid
	 * in case the rootvp gets stolen away since
	 * we don't take an explicit long term reference
	 * on it when we mount it
	 */</span>
	vnode_t		mnt_realrootvp;
	uint32_t	mnt_realrootvp_vid;
	<span class="enscript-comment">/*
	 * bumped each time a mount or unmount
	 * occurs... its used to invalidate
	 * 'mnt_realrootvp' from the cache
	 */</span>
	uint32_t             mnt_generation;
        <span class="enscript-comment">/*
	 * if 'MNTK_AUTH_CACHE_TIMEOUT' is 
	 * set, then 'mnt_authcache_ttl' is
	 * the time-to-live for the per-vnode authentication cache
	 * on this mount... if zero, no cache is maintained...
	 * if 'MNTK_AUTH_CACHE_TIMEOUT' isn't set, its the
	 * time-to-live for the cached lookup right for
	 * volumes marked 'MNTK_AUTH_OPAQUE'.
	 */</span>
	<span class="enscript-type">int</span>		mnt_authcache_ttl;
	<span class="enscript-type">char</span>		fstypename_override[MFSTYPENAMELEN];
};

<span class="enscript-comment">/*
 * default number of seconds to keep cached lookup
 * rights valid on mounts marked MNTK_AUTH_OPAQUE
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CACHED_LOOKUP_RIGHT_TTL</span>		2

<span class="enscript-comment">/*
 * ioflags
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_IOFLAGS_FUA_SUPPORTED</span>	0x00000001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_IOFLAGS_UNMAP_SUPPORTED</span>	0x00000002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_IOFLAGS_IOSCHED_SUPPORTED</span>	0x00000004
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_IOFLAGS_CSUNMAP_SUPPORTED</span>	0x00000008
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_IOFLAGS_SWAPPIN_SUPPORTED</span>	0x00000010
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_IOFLAGS_FUSION_DRIVE</span>	0x00000020

<span class="enscript-comment">/*
 * ioqueue depth for devices that don't report one
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_DEFAULT_IOQUEUE_DEPTH</span>	32

  
<span class="enscript-comment">/* XXX 3762912 hack to support HFS filesystem 'owner' */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vfs_setowner</span>(_mp, _uid, _gid)	do {(_mp)-&gt;mnt_fsowner = (_uid); (_mp)-&gt;mnt_fsgroup = (_gid); } while (0)


<span class="enscript-comment">/* mount point to which dead vps point to */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mount * dead_mountp;

<span class="enscript-comment">/*
 * Internal filesystem control flags stored in mnt_kern_flag.
 *
 * MNTK_UNMOUNT locks the mount entry so that name lookup cannot proceed
 * past the mount point.  This keeps the subtree stable during mounts
 * and unmounts.
 *
 * Note:	We are counting down on new bit assignments.  This is
 *		because the bits here were broken out from the high bits
 *		of the mount flags.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_SWAP_MOUNT</span>		0x00000100	<span class="enscript-comment">/* we are swapping to this mount */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_DENY_READDIREXT</span> 0x00000200 <span class="enscript-comment">/* Deny Extended-style readdir's for this volume */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_PERMIT_UNMOUNT</span>	0x00000400	<span class="enscript-comment">/* Allow (non-forced) unmounts by UIDs other than the one that mounted the volume */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFSCLIENT</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_TYPENAME_OVERRIDE</span>  0x00000800      <span class="enscript-comment">/* override the fstypename for statfs() */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSCLIENT */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_KERNEL_MOUNT</span>	0x00001000	<span class="enscript-comment">/* mount came from kernel side */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_IMGSRC_ACCESS</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_HAS_MOVED</span>		0x00002000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_BACKS_ROOT</span>		0x00004000
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IMGSRC_ACCESS */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_AUTH_CACHE_TTL</span>	0x00008000      <span class="enscript-comment">/* rights cache has TTL - TTL of 0 disables cache */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNTK_PATH_FROM_ID</span>	0x00010000	<span class="enscript-comment">/* mounted file system supports id-to-path lookups */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNTK_UNMOUNT_PREFLIGHT</span>	0x00020000	<span class="enscript-comment">/* mounted file system wants preflight check during unmount */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNTK_NAMED_STREAMS</span>	0x00040000	<span class="enscript-comment">/* mounted file system supports Named Streams VNOPs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNTK_EXTENDED_ATTRS</span>	0x00080000	<span class="enscript-comment">/* mounted file system supports Extended Attributes VNOPs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNTK_LOCK_LOCAL</span>		0x00100000	<span class="enscript-comment">/* advisory locking is done above the VFS itself */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_VIRTUALDEV</span> 	0x00200000      <span class="enscript-comment">/* mounted on a virtual device i.e. a disk image */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_ROOTDEV</span>    	0x00400000      <span class="enscript-comment">/* this filesystem resides on the same device as the root */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_SSD</span>		0x00800000	<span class="enscript-comment">/* underlying device is of the solid state variety */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_UNMOUNT</span>		0x01000000	<span class="enscript-comment">/* unmount in progress */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNTK_MWAIT</span>		0x02000000	<span class="enscript-comment">/* waiting for unmount to finish */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_WANTRDWR</span>		0x04000000	<span class="enscript-comment">/* upgrade to read/write requested */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">REV_ENDIAN_FS</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_REVEND</span>		0x08000000	<span class="enscript-comment">/* Reverse endian FS */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* REV_ENDIAN_FS */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_AUTH_OPAQUE</span>        0x20000000      <span class="enscript-comment">/* authorisation decisions are not made locally */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_AUTH_OPAQUE_ACCESS</span> 0x40000000      <span class="enscript-comment">/* VNOP_ACCESS is reliable for remote auth */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNTK_EXTENDED_SECURITY</span>	0x80000000	<span class="enscript-comment">/* extended security supported */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_LNOTRESP</span>		0x00000001	<span class="enscript-comment">/* mount not responding */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_LUNMOUNT</span>		0x00000002	<span class="enscript-comment">/* mount in unmount */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_LFORCE</span>		0x00000004	<span class="enscript-comment">/* mount in forced unmount */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_LDRAIN</span>		0x00000008	<span class="enscript-comment">/* mount in drain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_LITER</span>		0x00000010	<span class="enscript-comment">/* mount in iteration */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_LNEWVN</span>		0x00000020	<span class="enscript-comment">/* mount has new vnodes created */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_LWAIT</span>		0x00000040	<span class="enscript-comment">/* wait for unmount op */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_LITERWAIT</span>		0x00000080	<span class="enscript-comment">/* mount in iteration */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_LDEAD</span>		0x00000100	<span class="enscript-comment">/* mount already unmounted*/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_LNOSUB</span>		0x00000200	<span class="enscript-comment">/* submount - no recursion */</span>


<span class="enscript-comment">/*
 * Generic file handle
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MAX_FH_SIZE</span>		NFSV4_MAX_FH_SIZE
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSV4_MAX_FH_SIZE</span>	128
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSV3_MAX_FH_SIZE</span>	64
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSV2_MAX_FH_SIZE</span>	32
<span class="enscript-type">struct</span> fhandle {
	<span class="enscript-type">int</span>		fh_len;				<span class="enscript-comment">/* length of file handle */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>	fh_data[NFS_MAX_FH_SIZE];	<span class="enscript-comment">/* file handle value */</span>
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> fhandle	fhandle_t;



<span class="enscript-comment">/*
 * Filesystem configuration information. One of these exists for each
 * type of filesystem supported by the kernel. These are searched at
 * mount time to identify the requested filesystem.
 */</span>
<span class="enscript-type">struct</span> vfstable {
	<span class="enscript-type">struct</span>	vfsops *vfc_vfsops;	<span class="enscript-comment">/* filesystem operations vector */</span>
	<span class="enscript-type">char</span>	vfc_name[MFSNAMELEN];	<span class="enscript-comment">/* filesystem type name */</span>
	<span class="enscript-type">int</span>	vfc_typenum;		<span class="enscript-comment">/* historic filesystem type number */</span>
	<span class="enscript-type">int</span>	vfc_refcount;		<span class="enscript-comment">/* number mounted of this type */</span>
	<span class="enscript-type">int</span>	vfc_flags;		<span class="enscript-comment">/* permanent flags */</span>
	<span class="enscript-type">int</span>	(*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);	<span class="enscript-comment">/* if != NULL, routine to mount root */</span>
	<span class="enscript-type">struct</span>	vfstable *vfc_next;	<span class="enscript-comment">/* next in list */</span>
	int32_t	vfc_reserved1;
	int32_t vfc_reserved2;
	<span class="enscript-type">int</span> 		vfc_vfsflags;	<span class="enscript-comment">/* for optional types */</span>
	<span class="enscript-type">void</span> *		vfc_descptr;	<span class="enscript-comment">/* desc table allocated address */</span>
	<span class="enscript-type">int</span>			vfc_descsize;	<span class="enscript-comment">/* size allocated for desc table */</span>
	<span class="enscript-type">struct</span> sysctl_oid	*vfc_sysctl;	<span class="enscript-comment">/* dynamically registered sysctl node */</span>
};

<span class="enscript-comment">/* vfc_vfsflags: */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFC_VFSLOCALARGS</span>	0x002
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFC_VFSGENERICARGS</span>	0x004
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFC_VFSNATIVEXATTR</span>	0x010
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFC_VFSDIRLINKS</span>		0x020
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFC_VFSPREFLIGHT</span>	0x040
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFC_VFSREADDIR_EXTENDED</span>	0x080
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFC_VFS64BITREADY</span>	0x100
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFC_VFSNOMACLABEL</span>	0x1000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFC_VFSVNOP_PAGEINV2</span>	0x2000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFC_VFSVNOP_PAGEOUTV2</span>	0x4000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFC_VFSVNOP_NOUPDATEID_RENAME</span>	0x8000
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SECLUDED_RENAME</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFC_VFSVNOP_SECLUDE_RENAME</span> 	0x10000
#<span class="enscript-reference">endif</span>


<span class="enscript-type">extern</span> <span class="enscript-type">int</span> maxvfstypenum;		<span class="enscript-comment">/* highest defined filesystem type */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> vfstable  *vfsconf;	<span class="enscript-comment">/* head of list of filesystem types */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> maxvfsslots;		<span class="enscript-comment">/* Maximum statically allocated slots available to be used */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> numused_vfsslots;	<span class="enscript-comment">/* number of statically allocated slots already used */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> numregistered_fses;	<span class="enscript-comment">/* number of total registered filesystems */</span>

<span class="enscript-comment">/* the following two are xnu private */</span>
<span class="enscript-type">struct</span> vfstable *	vfstable_add(<span class="enscript-type">struct</span>	vfstable *);
<span class="enscript-type">int</span>	vfstable_del(<span class="enscript-type">struct</span> vfstable *);


<span class="enscript-type">struct</span> vfsmount_args {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			<span class="enscript-type">char</span> * mnt_fspec;
			<span class="enscript-type">void</span> * mnt_fsdata;
		} mnt_localfs_args;
		<span class="enscript-type">struct</span> {
			<span class="enscript-type">void</span> *  mnt_fsdata;		<span class="enscript-comment">/* FS specific */</span>
		} mnt_remotefs_args;
	} mountfs_args;
};


<span class="enscript-comment">/*
 * LP64 *user* version of statfs structure.
 * NOTE - must be kept in sync with struct statfs in mount.h
 */</span>
<span class="enscript-type">struct</span> user64_statfs {
	<span class="enscript-type">short</span>		f_otype;		<span class="enscript-comment">/* TEMPORARY SHADOW COPY OF f_type */</span>
	<span class="enscript-type">short</span>		f_oflags;		<span class="enscript-comment">/* TEMPORARY SHADOW COPY OF f_flags */</span>
	user64_long_t	f_bsize;		<span class="enscript-comment">/* fundamental file system block size */</span>
	user64_long_t	f_iosize;		<span class="enscript-comment">/* optimal transfer block size */</span>
	user64_long_t	f_blocks;		<span class="enscript-comment">/* total data blocks in file system */</span>
	user64_long_t	f_bfree;		<span class="enscript-comment">/* free blocks in fs */</span>
	user64_long_t	f_bavail;		<span class="enscript-comment">/* free blocks avail to non-superuser */</span>
	user64_long_t	f_files;		<span class="enscript-comment">/* total file nodes in file system */</span>
	user64_long_t	f_ffree;		<span class="enscript-comment">/* free file nodes in fs */</span>
	fsid_t		f_fsid;			<span class="enscript-comment">/* file system id */</span>
	uid_t		f_owner;		<span class="enscript-comment">/* user that mounted the filesystem */</span>
	<span class="enscript-type">short</span>		f_reserved1;	<span class="enscript-comment">/* spare for later */</span>
	<span class="enscript-type">short</span>		f_type;			<span class="enscript-comment">/* type of filesystem */</span>
    user64_long_t	f_flags;		<span class="enscript-comment">/* copy of mount exported flags */</span>
	user64_long_t f_reserved2[2];	<span class="enscript-comment">/* reserved for future use */</span>
	<span class="enscript-type">char</span>		f_fstypename[MFSNAMELEN]; <span class="enscript-comment">/* fs type name */</span>
	<span class="enscript-type">char</span>		f_mntonname[MNAMELEN];	<span class="enscript-comment">/* directory on which mounted */</span>
	<span class="enscript-type">char</span>		f_mntfromname[MNAMELEN];<span class="enscript-comment">/* mounted filesystem */</span>
	<span class="enscript-type">char</span>		f_reserved3;	<span class="enscript-comment">/* For alignment */</span>
	user64_long_t	f_reserved4[4];	<span class="enscript-comment">/* For future use */</span>
};

<span class="enscript-comment">/*
 * ILP32 *user* version of statfs structure.
 * NOTE - must be kept in sync with struct statfs in mount.h
 */</span>
<span class="enscript-type">struct</span> user32_statfs {
	<span class="enscript-type">short</span>		f_otype;		<span class="enscript-comment">/* TEMPORARY SHADOW COPY OF f_type */</span>
	<span class="enscript-type">short</span>		f_oflags;		<span class="enscript-comment">/* TEMPORARY SHADOW COPY OF f_flags */</span>
	user32_long_t	f_bsize;		<span class="enscript-comment">/* fundamental file system block size */</span>
	user32_long_t	f_iosize;		<span class="enscript-comment">/* optimal transfer block size */</span>
	user32_long_t	f_blocks;		<span class="enscript-comment">/* total data blocks in file system */</span>
	user32_long_t	f_bfree;		<span class="enscript-comment">/* free blocks in fs */</span>
	user32_long_t	f_bavail;		<span class="enscript-comment">/* free blocks avail to non-superuser */</span>
	user32_long_t	f_files;		<span class="enscript-comment">/* total file nodes in file system */</span>
	user32_long_t	f_ffree;		<span class="enscript-comment">/* free file nodes in fs */</span>
	fsid_t		f_fsid;			<span class="enscript-comment">/* file system id */</span>
	uid_t		f_owner;		<span class="enscript-comment">/* user that mounted the filesystem */</span>
	<span class="enscript-type">short</span>		f_reserved1;	<span class="enscript-comment">/* spare for later */</span>
	<span class="enscript-type">short</span>		f_type;			<span class="enscript-comment">/* type of filesystem */</span>
    user32_long_t	f_flags;		<span class="enscript-comment">/* copy of mount exported flags */</span>
	user32_long_t f_reserved2[2];	<span class="enscript-comment">/* reserved for future use */</span>
	<span class="enscript-type">char</span>		f_fstypename[MFSNAMELEN]; <span class="enscript-comment">/* fs type name */</span>
	<span class="enscript-type">char</span>		f_mntonname[MNAMELEN];	<span class="enscript-comment">/* directory on which mounted */</span>
	<span class="enscript-type">char</span>		f_mntfromname[MNAMELEN];<span class="enscript-comment">/* mounted filesystem */</span>
	<span class="enscript-type">char</span>		f_reserved3;	<span class="enscript-comment">/* For alignment */</span>
	user32_long_t	f_reserved4[4];	<span class="enscript-comment">/* For future use */</span>
};

<span class="enscript-comment">/*
 * throttle I/Os are affected only by normal I/Os happening on the same spindle.  Currently we use a 64-bit integer to
 * represent what devices are affected, so we can handle at most 64 different spindles.  Since
 * throttled I/O is usually useful in non-server environment only, this number is enough in most cases.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOWPRI_MAX_NUM_DEV</span> 64

__BEGIN_DECLS

<span class="enscript-type">extern</span> boolean_t root_is_CF_drive;
<span class="enscript-type">extern</span> uint32_t mount_generation;
<span class="enscript-type">extern</span> <span class="enscript-function-name">TAILQ_HEAD</span>(mntlist, mount) mountlist;
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_list_lock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_list_unlock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_lock_init</span>(mount_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_lock_destroy</span>(mount_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_lock</span>(mount_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_lock_spin</span>(mount_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_unlock</span>(mount_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_lock_renames</span>(mount_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_unlock_renames</span>(mount_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_ref</span>(mount_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_drop</span>(mount_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>  <span class="enscript-function-name">mount_refdrain</span>(mount_t);

<span class="enscript-comment">/* vfs_rootmountalloc should be kept as a private api */</span>
errno_t <span class="enscript-function-name">vfs_rootmountalloc</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, mount_t *mpp);

<span class="enscript-type">int</span>	vfs_mountroot(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	vfs_unmountall(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span>	safedounmount(<span class="enscript-type">struct</span> mount *, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span>	dounmount(<span class="enscript-type">struct</span> mount *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">void</span>	dounmount_submounts(<span class="enscript-type">struct</span> mount *, <span class="enscript-type">int</span>, vfs_context_t);

<span class="enscript-comment">/* xnu internal api */</span>
<span class="enscript-type">void</span>  <span class="enscript-function-name">mount_dropcrossref</span>(mount_t, vnode_t, <span class="enscript-type">int</span>);
mount_t <span class="enscript-function-name">mount_lookupby_volfsid</span>(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
mount_t <span class="enscript-function-name">mount_list_lookupby_fsid</span>(fsid_t *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>  <span class="enscript-function-name">mount_list_add</span>(mount_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_list_remove</span>(mount_t);
<span class="enscript-type">int</span>  <span class="enscript-function-name">mount_iterref</span>(mount_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>  <span class="enscript-function-name">mount_isdrained</span>(mount_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_iterdrop</span>(mount_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_iterdrain</span>(mount_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_iterreset</span>(mount_t);

<span class="enscript-comment">/* tags a volume as not supporting extended readdir for NFS exports */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">mount_set_noreaddirext</span> (mount_t);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Private NFS spi */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_MOUNT_NOAUTH</span>		0x01 <span class="enscript-comment">/* Don't check the UID of the directory we are mounting on */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_MOUNT_PERMIT_UNMOUNT</span>	0x02 <span class="enscript-comment">/* Allow (non-forced) unmounts by users other the one who mounted the volume */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span> || <span class="enscript-variable-name">DEVFS</span>
<span class="enscript-comment">/*
 * NOTE: kernel_mount() does not force MNT_NOSUID, MNT_NOEXEC, or MNT_NODEC for non-privileged
 * mounting credentials, as the mount(2) system call does.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">kernel_mount</span>(<span class="enscript-type">char</span> *, vnode_t, vnode_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">void</span> *, size_t, <span class="enscript-type">int</span>, uint32_t, vfs_context_t);
boolean_t <span class="enscript-function-name">vfs_iskernelmount</span>(mount_t);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* throttled I/O api */</span>

<span class="enscript-comment">/* returned by throttle_io_will_be_throttled */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">THROTTLE_DISENGAGED</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">THROTTLE_ENGAGED</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">THROTTLE_NOW</span>		2

<span class="enscript-type">int</span>  <span class="enscript-function-name">throttle_get_io_policy</span>(<span class="enscript-type">struct</span> uthread **ut);
<span class="enscript-type">int</span>  <span class="enscript-function-name">throttle_get_passive_io_policy</span>(<span class="enscript-type">struct</span> uthread **ut);
<span class="enscript-type">int</span>  <span class="enscript-function-name">throttle_io_will_be_throttled</span>(<span class="enscript-type">int</span> lowpri_window_msecs, mount_t mp);
<span class="enscript-type">void</span> *<span class="enscript-function-name">throttle_info_update_by_mount</span>(mount_t mp);
<span class="enscript-type">void</span> <span class="enscript-function-name">rethrottle_thread</span>(uthread_t ut);
<span class="enscript-type">void</span> <span class="enscript-function-name">throttle_info_reset_window</span>(uthread_t ut);


<span class="enscript-comment">/* throttled I/O helper function */</span>
<span class="enscript-comment">/* convert the lowest bit to a device index */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">num_trailing_0</span>(uint64_t n);

<span class="enscript-comment">/* sync lock */</span>
<span class="enscript-type">extern</span> lck_mtx_t * sync_mtx_lck;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> sync_timeout;

__END_DECLS

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_SYS_MOUNT_INTERNAL_H_ */</span>
</pre>
<hr />
</body></html>