<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mount.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mount.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)mount.h	8.21 (Berkeley) 5/20/95
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>


#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_SYS_MOUNT_H_</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_SYS_MOUNT_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/attr.h&gt;</span>		<span class="enscript-comment">/* needed for vol_capabilities_attr_t */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>		<span class="enscript-comment">/* XXX needed for user builds */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;Availability.h&gt;</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;uuid/uuid.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/_types/_fsid_t.h&gt;</span> <span class="enscript-comment">/* file system id type */</span>

<span class="enscript-comment">/*
 * file system statistics
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MFSNAMELEN</span>	15	<span class="enscript-comment">/* length of fs type name, not inc. null */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MFSTYPENAMELEN</span>	16	<span class="enscript-comment">/* length of fs type name including null */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__DARWIN_64_BIT_INO_T</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNAMELEN</span>	MAXPATHLEN	<span class="enscript-comment">/* length of buffer for returned name */</span>
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* ! __DARWIN_64_BIT_INO_T */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNAMELEN</span>	90		<span class="enscript-comment">/* length of buffer for returned name */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __DARWIN_64_BIT_INO_T */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__DARWIN_STRUCT_STATFS64</span> { \
	uint32_t	f_bsize;	<span class="enscript-comment">/* fundamental file system block size */</span> \
	int32_t		f_iosize;	<span class="enscript-comment">/* optimal transfer block size */</span> \
	uint64_t	f_blocks;	<span class="enscript-comment">/* total data blocks in file system */</span> \
	uint64_t	f_bfree;	<span class="enscript-comment">/* free blocks in fs */</span> \
	uint64_t	f_bavail;	<span class="enscript-comment">/* free blocks avail to non-superuser */</span> \
	uint64_t	f_files;	<span class="enscript-comment">/* total file nodes in file system */</span> \
	uint64_t	f_ffree;	<span class="enscript-comment">/* free file nodes in fs */</span> \
	fsid_t		f_fsid;		<span class="enscript-comment">/* file system id */</span> \
	uid_t		f_owner;	<span class="enscript-comment">/* user that mounted the filesystem */</span> \
	uint32_t	f_type;		<span class="enscript-comment">/* type of filesystem */</span> \
	uint32_t	f_flags;	<span class="enscript-comment">/* copy of mount exported flags */</span> \
	uint32_t	f_fssubtype;	<span class="enscript-comment">/* fs sub-type (flavor) */</span> \
	<span class="enscript-type">char</span>		f_fstypename[MFSTYPENAMELEN];	<span class="enscript-comment">/* fs type name */</span> \
	<span class="enscript-type">char</span>		f_mntonname[MAXPATHLEN];	<span class="enscript-comment">/* directory on which mounted */</span> \
	<span class="enscript-type">char</span>		f_mntfromname[MAXPATHLEN];	<span class="enscript-comment">/* mounted filesystem */</span> \
	uint32_t	f_reserved[8];	<span class="enscript-comment">/* For future use */</span> \
}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">__DARWIN_ONLY_64_BIT_INO_T</span>

<span class="enscript-type">struct</span> statfs64 __DARWIN_STRUCT_STATFS64;

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__DARWIN_ONLY_64_BIT_INO_T */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__DARWIN_64_BIT_INO_T</span>

<span class="enscript-type">struct</span> statfs __DARWIN_STRUCT_STATFS64;

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__DARWIN_64_BIT_INO_T */</span>

<span class="enscript-comment">/*
 * LP64 - WARNING - must be kept in sync with struct user_statfs in mount_internal.h.
 */</span>
<span class="enscript-type">struct</span> statfs {
	<span class="enscript-type">short</span>	f_otype;		<span class="enscript-comment">/* TEMPORARY SHADOW COPY OF f_type */</span>
	<span class="enscript-type">short</span>	f_oflags;		<span class="enscript-comment">/* TEMPORARY SHADOW COPY OF f_flags */</span>
	<span class="enscript-type">long</span>	f_bsize;		<span class="enscript-comment">/* fundamental file system block size */</span>
	<span class="enscript-type">long</span>	f_iosize;		<span class="enscript-comment">/* optimal transfer block size */</span>
	<span class="enscript-type">long</span>	f_blocks;		<span class="enscript-comment">/* total data blocks in file system */</span>
	<span class="enscript-type">long</span>	f_bfree;		<span class="enscript-comment">/* free blocks in fs */</span>
	<span class="enscript-type">long</span>	f_bavail;		<span class="enscript-comment">/* free blocks avail to non-superuser */</span>
	<span class="enscript-type">long</span>	f_files;		<span class="enscript-comment">/* total file nodes in file system */</span>
	<span class="enscript-type">long</span>	f_ffree;		<span class="enscript-comment">/* free file nodes in fs */</span>
	fsid_t	f_fsid;			<span class="enscript-comment">/* file system id */</span>
	uid_t	f_owner;		<span class="enscript-comment">/* user that mounted the filesystem */</span>
	<span class="enscript-type">short</span>	f_reserved1;	<span class="enscript-comment">/* spare for later */</span>
	<span class="enscript-type">short</span>	f_type;			<span class="enscript-comment">/* type of filesystem */</span>
	<span class="enscript-type">long</span>	f_flags;		<span class="enscript-comment">/* copy of mount exported flags */</span>
	<span class="enscript-type">long</span>    f_reserved2[2];	<span class="enscript-comment">/* reserved for future use */</span>
	<span class="enscript-type">char</span>	f_fstypename[MFSNAMELEN]; <span class="enscript-comment">/* fs type name */</span>
	<span class="enscript-type">char</span>	f_mntonname[MNAMELEN];	<span class="enscript-comment">/* directory on which mounted */</span>
	<span class="enscript-type">char</span>	f_mntfromname[MNAMELEN];<span class="enscript-comment">/* mounted filesystem */</span>
	<span class="enscript-type">char</span>	f_reserved3;	<span class="enscript-comment">/* For alignment */</span>
	<span class="enscript-type">long</span>	f_reserved4[4];	<span class="enscript-comment">/* For future use */</span>
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __DARWIN_64_BIT_INO_T */</span>

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>(4)

<span class="enscript-type">struct</span> vfsstatfs {
	uint32_t	f_bsize;	<span class="enscript-comment">/* fundamental file system block size */</span>
	size_t		f_iosize;	<span class="enscript-comment">/* optimal transfer block size */</span>
	uint64_t	f_blocks;	<span class="enscript-comment">/* total data blocks in file system */</span>
	uint64_t	f_bfree;	<span class="enscript-comment">/* free blocks in fs */</span>
	uint64_t	f_bavail;	<span class="enscript-comment">/* free blocks avail to non-superuser */</span>
	uint64_t	f_bused;	<span class="enscript-comment">/* free blocks avail to non-superuser */</span>
	uint64_t	f_files;	<span class="enscript-comment">/* total file nodes in file system */</span>
	uint64_t	f_ffree;	<span class="enscript-comment">/* free file nodes in fs */</span>
	fsid_t		f_fsid;		<span class="enscript-comment">/* file system id */</span>
	uid_t		f_owner;	<span class="enscript-comment">/* user that mounted the filesystem */</span>
	uint64_t	f_flags;	<span class="enscript-comment">/* copy of mount exported flags */</span> 
	<span class="enscript-type">char</span>		f_fstypename[MFSTYPENAMELEN];<span class="enscript-comment">/* fs type name inclus */</span>
	<span class="enscript-type">char</span>		f_mntonname[MAXPATHLEN];<span class="enscript-comment">/* directory on which mounted */</span>
	<span class="enscript-type">char</span>		f_mntfromname[MAXPATHLEN];<span class="enscript-comment">/* mounted filesystem */</span>
	uint32_t	f_fssubtype;     <span class="enscript-comment">/* fs sub-type (flavor) */</span>
	<span class="enscript-type">void</span>		*f_reserved[2];		<span class="enscript-comment">/* For future use == 0 */</span>
};

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>()

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
<span class="enscript-comment">/*
 * Kernel level support for the VFS_GETATTR(), VFS_SETATTR() for use in
 * implementation of filesystem KEXTs, and by the vfs_getattr() and
 * vfs_setattr() KPIs.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VFSATTR_INIT</span>(s)			((s)-&gt;f_supported = (s)-&gt;f_active = 0LL)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VFSATTR_SET_SUPPORTED</span>(s, a)	((s)-&gt;f_supported |= VFSATTR_ ## a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VFSATTR_IS_SUPPORTED</span>(s, a)	((s)-&gt;f_supported &amp; VFSATTR_ ## a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VFSATTR_CLEAR_ACTIVE</span>(s, a)	((s)-&gt;f_active &amp;= ~VFSATTR_ ## a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VFSATTR_IS_ACTIVE</span>(s, a)		((s)-&gt;f_active &amp; VFSATTR_ ## a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VFSATTR_ALL_SUPPORTED</span>(s)	(((s)-&gt;f_active &amp; (s)-&gt;f_supported) == (s)-&gt;f_active)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VFSATTR_WANTED</span>(s, a)		((s)-&gt;f_active |= VFSATTR_ ## a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VFSATTR_RETURN</span>(s, a, x)		do { (s)-&gt; a = (x); VFSATTR_SET_SUPPORTED(s, a);} while(0)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_objcount</span>		(1LL&lt;&lt;  0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_filecount</span>		(1LL&lt;&lt;  1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_dircount</span>		(1LL&lt;&lt;  2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_maxobjcount</span>		(1LL&lt;&lt;  3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_bsize</span>			(1LL&lt;&lt; 4)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_iosize</span>		(1LL&lt;&lt;  5)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_blocks</span>		(1LL&lt;&lt;  6)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_bfree</span>			(1LL&lt;&lt;  7)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_bavail</span>		(1LL&lt;&lt;  8)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_bused</span>			(1LL&lt;&lt;  9)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_files</span>			(1LL&lt;&lt; 10)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_ffree</span>			(1LL&lt;&lt; 11)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_fsid</span>			(1LL&lt;&lt; 12)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_owner</span>			(1LL&lt;&lt; 13)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_capabilities</span>		(1LL&lt;&lt; 14)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_attributes</span>		(1LL&lt;&lt; 15)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_create_time</span>		(1LL&lt;&lt; 16)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_modify_time</span>		(1LL&lt;&lt; 17)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_access_time</span>		(1LL&lt;&lt; 18)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_backup_time</span>		(1LL&lt;&lt; 19)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_fssubtype</span>		(1LL&lt;&lt; 20)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_vol_name</span>		(1LL&lt;&lt; 21)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_signature</span>		(1LL&lt;&lt; 22)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_carbon_fsid</span>		(1LL&lt;&lt; 23)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFSATTR_f_uuid</span>			(1LL&lt;&lt; 24)

<span class="enscript-comment">/*
 * Argument structure.
 */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>(4)
<span class="enscript-comment">/*
 * Note: the size of the vfs_attr structure can change.
 * A kext should only reference the fields that are
 * marked as active; it should not depend on the actual
 * size of the structure or attempt to copy it.
 */</span>
<span class="enscript-type">struct</span> vfs_attr {
	uint64_t	f_supported;
	uint64_t	f_active;

	uint64_t	f_objcount;	<span class="enscript-comment">/* number of filesystem objects in volume */</span>
	uint64_t	f_filecount;	<span class="enscript-comment">/* ... files */</span>
	uint64_t	f_dircount;	<span class="enscript-comment">/* ... directories */</span>
	uint64_t	f_maxobjcount;	<span class="enscript-comment">/* maximum number of filesystem objects */</span>
	
	uint32_t	f_bsize;	<span class="enscript-comment">/* block size for the below size values */</span>
	size_t		f_iosize;	<span class="enscript-comment">/* optimal transfer block size */</span>
	uint64_t	f_blocks;	<span class="enscript-comment">/* total data blocks in file system */</span>
	uint64_t	f_bfree;	<span class="enscript-comment">/* free blocks in fs */</span>
	uint64_t	f_bavail;	<span class="enscript-comment">/* free blocks avail to non-superuser */</span>
	uint64_t	f_bused;	<span class="enscript-comment">/* blocks in use */</span>
	uint64_t	f_files;	<span class="enscript-comment">/* total file nodes in file system */</span>
	uint64_t	f_ffree;	<span class="enscript-comment">/* free file nodes in fs */</span>
	fsid_t		f_fsid;		<span class="enscript-comment">/* file system id */</span>
	uid_t		f_owner;	<span class="enscript-comment">/* user that mounted the filesystem */</span>

 	vol_capabilities_attr_t f_capabilities;
	vol_attributes_attr_t f_attributes;

	<span class="enscript-type">struct</span> timespec	f_create_time;	<span class="enscript-comment">/* creation time */</span>
	<span class="enscript-type">struct</span> timespec	f_modify_time;	<span class="enscript-comment">/* last modification time */</span>
	<span class="enscript-type">struct</span> timespec f_access_time;	<span class="enscript-comment">/* time of last access */</span>
	<span class="enscript-type">struct</span> timespec	f_backup_time;	<span class="enscript-comment">/* last backup time */</span>

	uint32_t	f_fssubtype;	<span class="enscript-comment">/* filesystem subtype */</span>

	<span class="enscript-type">char</span>		*f_vol_name;	<span class="enscript-comment">/* volume name */</span>

	uint16_t	f_signature;	<span class="enscript-comment">/* used for ATTR_VOL_SIGNATURE, Carbon's FSVolumeInfo.signature */</span>
	uint16_t	f_carbon_fsid;	<span class="enscript-comment">/* same as Carbon's FSVolumeInfo.filesystemID */</span>
	uuid_t		f_uuid;		<span class="enscript-comment">/* file system UUID (version 3 or 5), available in 10.6 and later */</span>
};

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>()

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KERNEL */</span>

<span class="enscript-comment">/*
 * User specifiable flags.
 *
 * Unmount uses MNT_FORCE flag.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_RDONLY</span>	0x00000001	<span class="enscript-comment">/* read only filesystem */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_SYNCHRONOUS</span>	0x00000002	<span class="enscript-comment">/* file system written synchronously */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_NOEXEC</span>	0x00000004	<span class="enscript-comment">/* can't exec from filesystem */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_NOSUID</span>	0x00000008	<span class="enscript-comment">/* don't honor setuid bits on fs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_NODEV</span>	0x00000010	<span class="enscript-comment">/* don't interpret special files */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_UNION</span>	0x00000020	<span class="enscript-comment">/* union with underlying filesystem */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_ASYNC</span>	0x00000040	<span class="enscript-comment">/* file system written asynchronously */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_CPROTECT</span>	0x00000080	<span class="enscript-comment">/* file system supports content protection */</span>

<span class="enscript-comment">/*
 * NFS export related mount flags.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_EXPORTED</span>	0x00000100	<span class="enscript-comment">/* file system is exported */</span>

<span class="enscript-comment">/*
 * MAC labeled / &quot;quarantined&quot; flag
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_QUARANTINE</span>	0x00000400	<span class="enscript-comment">/* file system is quarantined */</span>

<span class="enscript-comment">/*
 * Flags set by internal operations.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_LOCAL</span>	0x00001000	<span class="enscript-comment">/* filesystem is stored locally */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_QUOTA</span>	0x00002000	<span class="enscript-comment">/* quotas are enabled on filesystem */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_ROOTFS</span>	0x00004000	<span class="enscript-comment">/* identifies the root filesystem */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_DOVOLFS</span>	0x00008000	<span class="enscript-comment">/* FS supports volfs (deprecated flag in Mac OS X 10.5) */</span>


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_DONTBROWSE</span>	0x00100000	<span class="enscript-comment">/* file system is not appropriate path to user data */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_IGNORE_OWNERSHIP</span> 0x00200000 <span class="enscript-comment">/* VFS will ignore ownership information on filesystem objects */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_AUTOMOUNTED</span> 0x00400000	<span class="enscript-comment">/* filesystem was mounted by automounter */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_JOURNALED</span>   0x00800000  	<span class="enscript-comment">/* filesystem is journaled */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_NOUSERXATTR</span>	0x01000000	<span class="enscript-comment">/* Don't allow user extended attributes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_DEFWRITE</span>	0x02000000	<span class="enscript-comment">/* filesystem should defer writes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_MULTILABEL</span>	0x04000000	<span class="enscript-comment">/* MAC support for individual labels */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_NOATIME</span>	0x10000000	<span class="enscript-comment">/* disable update of file access time */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
<span class="enscript-comment">/* #define MNT_IMGSRC_BY_INDEX 0x20000000 see sys/imgsrc.h */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>

<span class="enscript-comment">/* backwards compatibility only */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_UNKNOWNPERMISSIONS</span> MNT_IGNORE_OWNERSHIP


<span class="enscript-comment">/*
 * XXX I think that this could now become (~(MNT_CMDFLAGS))
 * but the 'mount' program may need changing to handle this.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_VISFLAGMASK</span>	(MNT_RDONLY	| MNT_SYNCHRONOUS | MNT_NOEXEC	| \
			MNT_NOSUID	| MNT_NODEV	| MNT_UNION	| \
			MNT_ASYNC	| MNT_EXPORTED	| MNT_QUARANTINE | \
			MNT_LOCAL	| MNT_QUOTA | \
			MNT_ROOTFS	| MNT_DOVOLFS	| MNT_DONTBROWSE | \
			MNT_IGNORE_OWNERSHIP | MNT_AUTOMOUNTED | MNT_JOURNALED | \
			MNT_NOUSERXATTR | MNT_DEFWRITE	| MNT_MULTILABEL | \
			MNT_NOATIME | MNT_CPROTECT)
<span class="enscript-comment">/*
 * External filesystem command modifier flags.
 * Unmount can use the MNT_FORCE flag.
 * XXX These are not STATES and really should be somewhere else.
 * External filesystem control flags.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_UPDATE</span>	0x00010000	<span class="enscript-comment">/* not a real mount, just an update */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_NOBLOCK</span>	0x00020000	<span class="enscript-comment">/* don't block unmount if not responding */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_RELOAD</span>	0x00040000	<span class="enscript-comment">/* reload filesystem data */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_FORCE</span>	0x00080000	<span class="enscript-comment">/* force unmount or readonly change */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_CMDFLAGS</span>	(MNT_UPDATE|MNT_NOBLOCK|MNT_RELOAD|MNT_FORCE)



<span class="enscript-comment">/*
 * Sysctl CTL_VFS definitions.
 *
 * Second level identifier specifies which filesystem. Second level
 * identifier VFS_GENERIC returns information about all filesystems.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFS_GENERIC</span>		0	<span class="enscript-comment">/* generic filesystem information */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_NUMMNTOPS</span>		1	<span class="enscript-comment">/* int: total num of vfs mount/unmount operations */</span>
<span class="enscript-comment">/*
 * Third level identifiers for VFS_GENERIC are given below; third
 * level identifiers for specific filesystems are given in their
 * mount specific header files.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_MAXTYPENUM</span>	1	<span class="enscript-comment">/* int: highest defined filesystem type */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CONF</span>	2	<span class="enscript-comment">/* struct: vfsconf for filesystem given
				   as next argument */</span>

<span class="enscript-comment">/*
 * Flags for various system call interfaces.
 *
 * waitfor flags to vfs_sync() and getfsstat()
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_WAIT</span>	1	<span class="enscript-comment">/* synchronized I/O file integrity completion */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MNT_NOWAIT</span>	2	<span class="enscript-comment">/* start all I/O, but do not wait for it */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MNT_DWAIT</span>	4	<span class="enscript-comment">/* synchronized I/O data integrity completion */</span>


#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">KERNEL</span>
<span class="enscript-type">struct</span> mount;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mount * mount_t;
<span class="enscript-type">struct</span> vnode;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> vnode * vnode_t;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Reserved fields preserve binary compatibility */</span>
<span class="enscript-type">struct</span> vfsconf {
	uint32_t vfc_reserved1;		<span class="enscript-comment">/* opaque */</span>
	<span class="enscript-type">char</span>	vfc_name[MFSNAMELEN];	<span class="enscript-comment">/* filesystem type name */</span>
	<span class="enscript-type">int</span>	vfc_typenum;		<span class="enscript-comment">/* historic filesystem type number */</span>
	<span class="enscript-type">int</span>	vfc_refcount;		<span class="enscript-comment">/* number mounted of this type */</span>
	<span class="enscript-type">int</span>	vfc_flags;		<span class="enscript-comment">/* permanent flags */</span>
	uint32_t vfc_reserved2;		<span class="enscript-comment">/* opaque */</span>
	uint32_t vfc_reserved3;		<span class="enscript-comment">/* opaque */</span>
};

<span class="enscript-type">struct</span> vfsidctl {
	<span class="enscript-type">int</span>		vc_vers;	<span class="enscript-comment">/* should be VFSIDCTL_VERS1 (below) */</span>
	fsid_t		vc_fsid;	<span class="enscript-comment">/* fsid to operate on. */</span>
	<span class="enscript-type">void</span>		*vc_ptr;	<span class="enscript-comment">/* pointer to data structure. */</span>
	size_t		vc_len;		<span class="enscript-comment">/* sizeof said structure. */</span>
	u_int32_t	vc_spare[12];	<span class="enscript-comment">/* spare (must be zero). */</span>
};


<span class="enscript-comment">/* vfsidctl API version. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CTL_VERS1</span>	0x01

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
<span class="enscript-type">struct</span> user_vfsidctl {
       <span class="enscript-type">int</span>				vc_vers;        <span class="enscript-comment">/* should be VFSIDCTL_VERS1 (below) */</span>
       fsid_t			vc_fsid;		<span class="enscript-comment">/* fsid to operate on. */</span>
       user_addr_t 		vc_ptr __attribute((aligned(8)));	<span class="enscript-comment">/* pointer to data structure. */</span>
       user_size_t 		vc_len;			<span class="enscript-comment">/* sizeof said structure. */</span>
       u_int32_t		vc_spare[12];   <span class="enscript-comment">/* spare (must be zero). */</span>
};

<span class="enscript-type">struct</span> user32_vfsidctl {
       <span class="enscript-type">int</span>				vc_vers;        <span class="enscript-comment">/* should be VFSIDCTL_VERS1 (below) */</span>
       fsid_t			vc_fsid;		<span class="enscript-comment">/* fsid to operate on. */</span>
       user32_addr_t 	vc_ptr;			<span class="enscript-comment">/* pointer to data structure. */</span>
       user32_size_t 	vc_len;			<span class="enscript-comment">/* sizeof said structure. */</span>
       u_int32_t		vc_spare[12];   <span class="enscript-comment">/* spare (must be zero). */</span>
};

<span class="enscript-type">union</span> union_vfsidctl { <span class="enscript-comment">/* the fields vc_vers and vc_fsid are compatible */</span>
		<span class="enscript-type">struct</span> user32_vfsidctl vc32;
		<span class="enscript-type">struct</span> user_vfsidctl vc64;
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

<span class="enscript-comment">/*
 * New style VFS sysctls, do not reuse/conflict with the namespace for
 * private sysctls.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CTL_STATFS</span>	0x00010001	<span class="enscript-comment">/* statfs */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CTL_UMOUNT</span>	0x00010002	<span class="enscript-comment">/* unmount */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CTL_QUERY</span>	0x00010003	<span class="enscript-comment">/* anything wrong? (vfsquery) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CTL_NEWADDR</span>	0x00010004	<span class="enscript-comment">/* reconnect to new address */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CTL_TIMEO</span>	0x00010005	<span class="enscript-comment">/* set timeout for vfs notification */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CTL_NOLOCKS</span>	0x00010006	<span class="enscript-comment">/* disable file locking */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CTL_SADDR</span>	0x00010007	<span class="enscript-comment">/* get server address */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CTL_DISC</span>    0x00010008	<span class="enscript-comment">/* server disconnected */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CTL_SERVERINFO</span>  0x00010009  <span class="enscript-comment">/* information about fs server */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CTL_NSTATUS</span> 0x0001000A	<span class="enscript-comment">/* netfs mount status */</span>

<span class="enscript-type">struct</span> vfsquery {
	u_int32_t	vq_flags;
	u_int32_t	vq_spare[31];
};

<span class="enscript-type">struct</span> vfs_server {
     int32_t  vs_minutes;                       <span class="enscript-comment">/* minutes until server goes down. */</span>
     u_int8_t vs_server_name[MAXHOSTNAMELEN*3]; <span class="enscript-comment">/* UTF8 server name to display (null terminated) */</span>
};

<span class="enscript-comment">/*
 * NetFS mount status - returned by VFS_CTL_NSTATUS
 */</span>
<span class="enscript-type">struct</span> netfs_status {
	u_int32_t	ns_status;		<span class="enscript-comment">// Current status of mount (vfsquery flags)
</span>	<span class="enscript-type">char</span>		ns_mountopts[512];	<span class="enscript-comment">// Significant mount options
</span>	uint32_t	ns_waittime;		<span class="enscript-comment">// Time waiting for reply (sec)
</span>	uint32_t	ns_threadcount;		<span class="enscript-comment">// Number of threads blocked on network calls
</span>	uint64_t	ns_threadids[0];	<span class="enscript-comment">// Thread IDs of those blocked threads
</span>};

<span class="enscript-comment">/* vfsquery flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_NOTRESP</span>	0x0001	<span class="enscript-comment">/* server down */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_NEEDAUTH</span>	0x0002	<span class="enscript-comment">/* server bad auth */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_LOWDISK</span>	0x0004	<span class="enscript-comment">/* we're low on space */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_MOUNT</span>	0x0008	<span class="enscript-comment">/* new filesystem arrived */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_UNMOUNT</span>	0x0010	<span class="enscript-comment">/* filesystem has left */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_DEAD</span>		0x0020	<span class="enscript-comment">/* filesystem is dead, needs force unmount */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_ASSIST</span>	0x0040	<span class="enscript-comment">/* filesystem needs assistance from external program */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_NOTRESPLOCK</span>	0x0080	<span class="enscript-comment">/* server lockd down */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_UPDATE</span>	0x0100	<span class="enscript-comment">/* filesystem information has changed */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_VERYLOWDISK</span>	0x0200	<span class="enscript-comment">/* file system has *very* little disk space left */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_SYNCEVENT</span>	0x0400	<span class="enscript-comment">/* a sync just happened (not set by kernel starting Mac OS X 10.9) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_SERVEREVENT</span>  0x0800  <span class="enscript-comment">/* server issued notification/warning */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_FLAG1000</span>	0x1000	<span class="enscript-comment">/* placeholder */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_FLAG2000</span>	0x2000	<span class="enscript-comment">/* placeholder */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_FLAG4000</span>	0x4000	<span class="enscript-comment">/* placeholder */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VQ_FLAG8000</span>	0x8000	<span class="enscript-comment">/* placeholder */</span>


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>

<span class="enscript-comment">/* Structure for setting device IO parameters per mount point */</span>
<span class="enscript-type">struct</span> vfsioattr {
	u_int32_t	io_maxreadcnt;		<span class="enscript-comment">/* Max. byte count for read */</span>
	u_int32_t	io_maxwritecnt;		<span class="enscript-comment">/* Max. byte count for write */</span>
	u_int32_t	io_segreadcnt;		<span class="enscript-comment">/* Max. segment count for read */</span>
	u_int32_t	io_segwritecnt;		<span class="enscript-comment">/* Max. segment count for write */</span>
	u_int32_t	io_maxsegreadsize;	<span class="enscript-comment">/* Max. segment read size  */</span>
	u_int32_t	io_maxsegwritesize;	<span class="enscript-comment">/* Max. segment write size */</span>
	u_int32_t	io_devblocksize;	<span class="enscript-comment">/* the underlying device block size */</span>
	u_int32_t	io_flags;			<span class="enscript-comment">/* flags for underlying device */</span>
	<span class="enscript-type">void</span> *		io_reserved[2];		<span class="enscript-comment">/* extended attribute information */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_IOATTR_FLAGS_FUA</span>	0x01	<span class="enscript-comment">/* Write-through cache supported */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_IOATTR_FLAGS_UNMAP</span>		0x02	<span class="enscript-comment">/* Unmap (trim) supported */</span>

<span class="enscript-comment">/*
 * Filesystem Registration information
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBLTHREADSAFE</span>		0x0001	<span class="enscript-comment">/* Only threadsafe filesystems are supported */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBLFSNODELOCK</span>		0x0002	<span class="enscript-comment">/* Only threadsafe filesystems are supported */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBLNOTYPENUM</span>		0x0008
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBLLOCALVOL</span>			0x0010
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBL64BITREADY</span>		0x0020
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBLNATIVEXATTR</span>		0x0040
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBLDIRLINKS</span>			0x0080
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBLUNMOUNT_PREFLIGHT</span>	0x0100	<span class="enscript-comment">/* does a preflight check before unmounting */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBLGENERICMNTARGS</span>		0x0200  <span class="enscript-comment">/* force generic mount args for local fs */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBLREADDIR_EXTENDED</span>		0x0400  <span class="enscript-comment">/* fs supports VNODE_READDIR_EXTENDED */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFS_TBLNOMACLABEL</span>		0x1000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBLVNOP_PAGEINV2</span>		0x2000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBLVNOP_PAGEOUTV2</span>		0x4000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_TBLVNOP_NOUPDATEID_RENAME</span>	0x8000	<span class="enscript-comment">/* vfs should not call vnode_update_ident on rename */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SECLUDED_RENAME</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFS_TBLVNOP_SECLUDE_RENAME</span> 	0x10000
#<span class="enscript-reference">endif</span>


<span class="enscript-type">struct</span> vfs_fsentry {
	<span class="enscript-type">struct</span> vfsops * vfe_vfsops;	<span class="enscript-comment">/* vfs operations */</span>
	<span class="enscript-type">int</span>		vfe_vopcnt;	<span class="enscript-comment">/* # of vnodeopv_desc being registered (reg, spec, fifo ...) */</span>
	<span class="enscript-type">struct</span> vnodeopv_desc ** vfe_opvdescs; <span class="enscript-comment">/* null terminated;  */</span>
	<span class="enscript-type">int</span>			vfe_fstypenum;	<span class="enscript-comment">/* historic filesystem type number */</span>
	<span class="enscript-type">char</span>		vfe_fsname[MFSNAMELEN];	<span class="enscript-comment">/* filesystem type name */</span>
	uint32_t	vfe_flags;		<span class="enscript-comment">/* defines the FS capabilities */</span>
    <span class="enscript-type">void</span> *		vfe_reserv[2];	<span class="enscript-comment">/* reserved for future use; set this to zero*/</span>
 };



<span class="enscript-type">struct</span> vfsops {
	<span class="enscript-comment">/*!
	 @function vfs_mount
	 @abstract Perform filesystem-specific operations required for mounting.
	 @discussion Typical operations include setting the mount-specific data with vfs_setfsprivate().
	 Note that if a mount call fails, the filesystem must clean up any state it has constructed, because
	 vfs-level mount code will not clean it up.  
	 @param mp Mount structure for the newly mounted filesystem.
	 @param devvp Device that the filesystem is mounted from.
	 @param data Filesystem-specific data passed down from userspace.
	 @param context Context to authenticate for mount.
	 @return 0 for success, else an error code.  Once success is returned, the filesystem should be ready to go active;
	 VFS will not ask again.
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_mount)(<span class="enscript-type">struct</span> mount *mp, vnode_t devvp, user_addr_t data, vfs_context_t context);
	
	<span class="enscript-comment">/*!
	 @function vfs_start
	 @abstract Mark a mount as ready to be used.
	 @discussion After receiving this calldown, a filesystem will be hooked into the mount list and should expect 
	 calls down from the VFS layer.  
	 @param mp Mount structure being activated.
	 @param flags Unused.
	 @param context Context to authenticate for mount.
	 @return Return value is ignored.
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_start)(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> flags, vfs_context_t context);
	
	<span class="enscript-comment">/*!
	 @function vfs_unmount
	 @abstract Perform filesystem-specific cleanup as part of unmount.
	 @discussion If the unmount downcall succeeds, VFS considers itself authorized to destroy all
	 state related to the mount.
	 @param mp Mount structure to unmount.
	 @param mntflags MNT_FORCE indicates that we wish to unmount even if there are active vnodes.
	 @param context Context to authenticate for unmount.
	 @return 0 for success, else an error code.  
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_unmount)(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> mntflags, vfs_context_t context);
	
	<span class="enscript-comment">/*!
	 @function vfs_root
	 @abstract Get the root vnode of a filesystem.
	 @discussion Upon success, should return with an iocount held on the root vnode which the caller will
	 drop with vnode_put().
	 @param mp Mount for which to get the root.
	 @param vpp Destination for root vnode.
	 @param context Context to authenticate for getting the root.
	 @return 0 for success, else an error code.  
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_root)(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vnode **vpp, vfs_context_t context);
	
	<span class="enscript-comment">/*!
	 @function vfs_quotactl
	 @abstract Manipulate quotas for a volume.
	 @param mp Mount for which to manipulate quotas.
	 @param cmds Detailed in &quot;quotactl&quot; manual page. 	 
	 @param uid Detailed in &quot;quotactl&quot; manual page.
	 @param arg Detailed in &quot;quotactl&quot; manual page.
	 @param context Context to authenticate for changing quotas.
	 @return 0 for success, else an error code.  
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_quotactl)(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> cmds, uid_t uid, caddr_t arg, vfs_context_t context);

	<span class="enscript-comment">/*!
	 @function vfs_getattr
	 @abstract Get filesystem attributes.
	 @discussion See VFSATTR_RETURN, VFSATTR_ACTIVE, VFSATTR_SET_SUPPORTED, VFSATTR_WANTED macros.
	 @param mp Mount for which to get parameters.
	 @param vfa Container for specifying which attributes are desired and which attributes the filesystem
	 supports, as well as for returning results.
	 @param ctx Context to authenticate for getting filesystem attributes.
	 @return 0 for success, else an error code.  
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_getattr)(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vfs_attr *, vfs_context_t context);
<span class="enscript-comment">/*	int  (*vfs_statfs)(struct mount *mp, struct vfsstatfs *sbp, vfs_context_t context);*/</span>

	<span class="enscript-comment">/*!
	 @function vfs_sync
	 @abstract Flush all filesystem data to backing store.
	 @discussion vfs_sync will be called as part of the sync() system call and during unmount.
	 @param mp Mountpoint to sync.
	 @param waitfor MNT_WAIT: flush synchronously, waiting for all data to be written before returning. MNT_NOWAIT: start I/O but do not wait for it.
	 @param ctx Context to authenticate for the sync.
	 @return 0 for success, else an error code.  
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_sync)(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> waitfor, vfs_context_t context);
	
	<span class="enscript-comment">/*!
	 @function vfs_vget
	 @abstract Get a vnode by file id (inode number).
	 @discussion This routine is chiefly used to build paths to vnodes.  Result should be turned with an iocount that the 
	 caller will drop with vnode_put().
	 @param mp Mount against which to look up inode number.
	 @param ino File ID for desired file, as found through a readdir.
	 @param vpp Destination for vnode.
	 @return 0 for success, else an error code.  
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_vget)(<span class="enscript-type">struct</span> mount *mp, ino64_t ino, <span class="enscript-type">struct</span> vnode **vpp, vfs_context_t context);
	
	<span class="enscript-comment">/*!
	 @function vfs_fhtovp
	 @abstract Get the vnode corresponding to a file handle.
	 @discussion Filesystems can return handles to files which are independent of their (transient) vnode identities.
	 vfs_thtovp converts that persistent handle back to a vnode.  The vnode should be returned with an iocount which 
	 the caller will drop with vnode_put().
	 @param mp Mount against which to look up file handle.
	 @param fhlen Size of file handle structure, as returned by vfs_vptofh.
	 @param fhp Pointer to handle.
	 @param vpp Destination for vnode.
	 @param ctx Context against which to authenticate the file-handle conversion.
	 @return 0 for success, else an error code.  
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_fhtovp)(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> fhlen, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *fhp, <span class="enscript-type">struct</span> vnode **vpp,
	                   vfs_context_t context);

	<span class="enscript-comment">/*!
	 @function vfs_vptofh
	 @abstract Get a persistent handle corresponding to a vnode.
	 @param mp Mount against which to convert the vnode to a handle.
	 @param fhlen Size of buffer provided for handle; set to size of actual handle returned.
	 @param fhp Pointer to buffer in which to place handle data.
	 @param ctx Context against which to authenticate the file-handle request.
	 @return 0 for success, else an error code.  
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_vptofh)(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> *fhlen, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *fhp, vfs_context_t context);

	<span class="enscript-comment">/*!
	 @function vfs_init
	 @abstract Prepare a filesystem for having instances mounted.
	 @discussion This routine is called once, before any particular instance of a filesystem
	 is mounted; it allows the filesystem to initialize whatever global data structures
	 are shared across all mounts.  If this returns successfully, a filesystem should be ready to have
	 instances mounted.
	 @param vfsconf Configuration information.  Currently, the only useful data are the filesystem name,
	 typenum, and flags.  The flags field will be either 0 or MNT_LOCAL.  Many filesystems ignore this
	 parameter.
	 @return 0 for success, else an error code.  
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_init)(<span class="enscript-type">struct</span> vfsconf *);
	
	<span class="enscript-comment">/*!
	 @function vfs_sysctl
	 @abstract Broad interface for querying and controlling filesystem.
	 @discussion VFS defines VFS_CTL_QUERY as a generic status request which is answered
	 with the VQ_* macros in a &quot;struct vfsquery.&quot;
	 A filesystem may also define implementation-specific commands.  See &quot;man 3 sysctl&quot; 
	 for the meaning of sysctl parameters.
	 @param context Context against which to authenticate command.
	 @return 0 for success, else an error code.  
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_sysctl)(<span class="enscript-type">int</span> *, u_int, user_addr_t, size_t *, user_addr_t, size_t, vfs_context_t context);

	<span class="enscript-comment">/*!
	 @function vfs_setattr
	 @abstract Set filesystem attributes.
	 @discussion The other side of the vfs_getattr coin.  Currently only called to set volume name.
	 @param mp Mount on which to set attributes.
	 @param vfa VFS attribute structure containing requested attributes to set and their values.  Currently
	 will only be called with f_vol_name set.
	 @param context Context against which to authenticate attribute change.
	 @return 0 for success, else an error code.  
	 */</span>
	<span class="enscript-type">int</span>  (*vfs_setattr)(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vfs_attr *, vfs_context_t context);
	<span class="enscript-type">void</span> *vfs_reserved[7];
};


<span class="enscript-comment">/*
 * flags passed into vfs_iterate
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PRIVATE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_ITERATE_TAIL_FIRST</span>	(1 &lt;&lt; 0)	
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_ITERATE_CB_DROPREF</span>	(1 &lt;&lt; 1)	// Callback will drop the iterref
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRIVATE */</span>

<span class="enscript-comment">/*
 * return values from callback
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_RETURNED</span>		0	<span class="enscript-comment">/* done with vnode, reference can be dropped */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_RETURNED_DONE</span>	1	<span class="enscript-comment">/* done with vnode, reference can be dropped, terminate iteration */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CLAIMED</span>		2	<span class="enscript-comment">/* don't drop reference */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_CLAIMED_DONE</span>	3	<span class="enscript-comment">/* don't drop reference, terminate iteration */</span>


__BEGIN_DECLS
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">VFS_MOUNT</span>(mount_t, vnode_t, user_addr_t, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">VFS_START</span>(mount_t, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">VFS_UNMOUNT</span>(mount_t, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">VFS_ROOT</span>(mount_t, vnode_t *, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">VFS_QUOTACTL</span>(mount_t, <span class="enscript-type">int</span>, uid_t, caddr_t, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">VFS_GETATTR</span>(mount_t, <span class="enscript-type">struct</span> vfs_attr *, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">VFS_SETATTR</span>(mount_t, <span class="enscript-type">struct</span> vfs_attr *, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">VFS_SYNC</span>(mount_t, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">VFS_VGET</span>(mount_t, ino64_t, vnode_t *, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">VFS_FHTOVP</span>(mount_t, <span class="enscript-type">int</span>, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *, vnode_t *, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">VFS_VPTOFH</span>(vnode_t, <span class="enscript-type">int</span> *, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *, vfs_context_t);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>
<span class="enscript-comment">/*
 * prototypes for exported VFS operations
 */</span>

<span class="enscript-comment">/*!
  @function vfs_fsadd
  @abstract Register a filesystem with VFS.
  @discussion Typically called by a filesystem Kernel Extension when it is loaded.
  @param vfe Filesystem information: table of vfs operations, list of vnode operation tables, 
  filesystem type number (can be omitted with VFS_TBLNOTYPENUM flag), name, flags.
  @param handle Opaque handle which will be passed to vfs_fsremove.
  @return 0 for success, else an error code.  
  */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">vfs_fsadd</span>(<span class="enscript-type">struct</span> vfs_fsentry *, vfstable_t *);

<span class="enscript-comment">/*!
  @function vfs_fsremove
  @abstract Unregister a filesystem with VFS.
  @discussion Typically called by a filesystem Kernel Extension when it is unloaded.
  @param handle Handle which was returned by vfs_fsadd.
  @return 0 for success, else an error code.  
  */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">vfs_fsremove</span>(vfstable_t);

<span class="enscript-comment">/*!
  @function vfs_iterate
  @abstract Iterate over all mountpoints with a callback.  Used, for example, by sync().
  @param flags Unused.
  @param callback Function which takes a mount and arbitrary passed-in &quot;arg,&quot; and returns one of VFS_RETURNED_DONE or VFS_CLAIMED_DONE: end
  iteration and return success.  VFS_RETURNED or VFS_CLAIMED: continue iterating. Anything else: continue iterating. 
  @param arg Arbitrary data to pass to callback.
  @return 0 for success, else an error code.  
  */</span>
<span class="enscript-type">int</span>	vfs_iterate(<span class="enscript-type">int</span>, <span class="enscript-type">int</span> (*)(<span class="enscript-type">struct</span> mount *, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *);

<span class="enscript-comment">/*!
  @function vfs_init_io_attributes
  @abstract Set I/O attributes on a mountpoint based on device properties.
  @param devvp Block device vnode from which a filesystem is being mounted.
  @param mp Mountpoint whose I/O parameters to initialize.
  @return 0 for success, else an error code.  
  */</span>
<span class="enscript-type">int</span>	vfs_init_io_attributes(vnode_t, mount_t);

<span class="enscript-comment">/*!
  @function vfs_flags
  @abstract Retrieve mount flags.
  @discussion Results will be in the bitwise &quot;OR&quot; of MNT_VISFLAGMASK and MNT_CMDFLAGS.
  @param mp Mount whose flags to grab.  
  @return Flags.
  */</span>
uint64_t <span class="enscript-function-name">vfs_flags</span>(mount_t);

<span class="enscript-comment">/*!
  @function vfs_setflags
  @abstract Set flags on a mount.
  @discussion Sets mount flags to the bitwise &quot;OR&quot; of their current value and the specified bits. Often 
  used by a filesystem as part of the mount process.
  @param mp Mount whose flags to set.
  @param flags Flags to activate.  Must be in the bitwise &quot;OR&quot; of MNT_VISFLAGMASK and MNT_CMDFLAGS.
  @return Flags.
  */</span>
<span class="enscript-type">void</span>	vfs_setflags(mount_t, uint64_t);

<span class="enscript-comment">/*!
  @function vfs_clearflags
  @abstract Clear flags on a mount.
  @discussion Sets mount flags to the bitwise &quot;AND&quot; of their current value and the complement of the specified bits.
  @param mp Mount whose flags to set.
  @param flags Flags to deactivate.  Must be in the bitwise &quot;OR&quot; of MNT_VISFLAGMASK and MNT_CMDFLAGS.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_clearflags(mount_t, uint64_t);

<span class="enscript-comment">/*!
  @function vfs_issynchronous
  @abstract Determine if writes to a filesystem occur synchronously.
  @param mp Mount to test.
  @return Nonzero if writes occur synchronously, else 0.
  */</span>
<span class="enscript-type">int</span>	vfs_issynchronous(mount_t);

<span class="enscript-comment">/*!
  @function vfs_iswriteupgrade
  @abstract Determine if a filesystem is mounted read-only but a request has been made to upgrade
  to read-write.
  @param mp Mount to test.
  @return Nonzero if a request has been made to update from read-only to read-write, else 0.
  */</span>
<span class="enscript-type">int</span>	vfs_iswriteupgrade(mount_t);

<span class="enscript-comment">/*!
  @function vfs_isupdate
  @abstract Determine if a mount update is in progress.
  @param mp Mount to test.
  @return Nonzero if a mount update is in progress, 0 otherwise.
  */</span>
<span class="enscript-type">int</span>	vfs_isupdate(mount_t); 

<span class="enscript-comment">/*!
  @function vfs_isreload
  @abstract Determine if a reload of filesystem data is in progress.  This can only be the case
  for a read-only filesystem; all data is brought in from secondary storage.
  @param mp Mount to test.
  @return Nonzero if a request has been made to reload data, else 0.
  */</span>
<span class="enscript-type">int</span>	vfs_isreload(mount_t);

<span class="enscript-comment">/*!
  @function vfs_isforce
  @abstract Determine if a forced unmount is in progress.
  @discussion A forced unmount invalidates open files.
  @param mp Mount to test.
  @return Nonzero if a request has been made to forcibly unmount, else 0.
  */</span>
<span class="enscript-type">int</span>	vfs_isforce(mount_t);

<span class="enscript-comment">/*!
  @function vfs_isunmount
  @abstract Determine if an unmount is in progress.
  @discussion This is an unsynchronized snapshot of the mount state.  It should only be called
  if the mount is known to be valid, e.g. there are known to be live files on that volume.
  @param mp Mount to test.
  @return Nonzero if an unmount is in progress, else zero.
  */</span>
<span class="enscript-type">int</span> 	vfs_isunmount(mount_t mp);

<span class="enscript-comment">/*!
  @function vfs_isrdonly
  @abstract Determine if a filesystem is mounted read-only.
  @param mp Mount to test.
  @return Nonzero if filesystem is mounted read-only, else 0.
  */</span>
<span class="enscript-type">int</span>	vfs_isrdonly(mount_t);

<span class="enscript-comment">/*!
  @function vfs_isrdwr
  @abstract Determine if a filesystem is mounted with writes enabled.
  @param mp Mount to test.
  @return Nonzero if filesystem is mounted read-write, else 0.
  */</span>
<span class="enscript-type">int</span>	vfs_isrdwr(mount_t);

<span class="enscript-comment">/*!
  @function vfs_authopaque
  @abstract Determine if a filesystem's authorization decisions occur remotely.
  @param mp Mount to test.
  @return Nonzero if filesystem authorization is controlled remotely, else 0.
  */</span>
<span class="enscript-type">int</span>	vfs_authopaque(mount_t);

<span class="enscript-comment">/*!
  @function vfs_authopaqueaccess
  @abstract Check if a filesystem is marked as having reliable remote VNOP_ACCESS support.
  @param mp Mount to test.
  @return Nonzero if VNOP_ACCESS is supported remotely, else 0.
  */</span>
<span class="enscript-type">int</span>	vfs_authopaqueaccess(mount_t);

<span class="enscript-comment">/*!
  @function vfs_setauthopaque
  @abstract Mark a filesystem as having authorization decisions controlled remotely.
  @param mp Mount to mark.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_setauthopaque(mount_t);

<span class="enscript-comment">/*!
  @function vfs_setauthopaqueaccess
  @abstract Mark a filesystem as having remote VNOP_ACCESS support.
  @param mp Mount to mark.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_setauthopaqueaccess(mount_t);

<span class="enscript-comment">/*!
  @function vfs_clearauthopaque
  @abstract Mark a filesystem as not having remote authorization decisions.
  @param mp Mount to mark.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_clearauthopaque(mount_t);

<span class="enscript-comment">/*!
  @function vfs_clearauthopaque
  @abstract Mark a filesystem as not having remote VNOP_ACCESS support.
  @param mp Mount to mark.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_clearauthopaqueaccess(mount_t);

<span class="enscript-comment">/*!
  @function vfs_setextendedsecurity
  @abstract Mark a filesystem as supporting security controls beyond POSIX permissions.
  @discussion Specific controls include ACLs, file owner UUIDs, and group UUIDs.
  @param mp Mount to test.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_setextendedsecurity(mount_t);

<span class="enscript-comment">/*!
  @function vfs_clearextendedsecurity
  @abstract Mark a filesystem as NOT supporting security controls beyond POSIX permissions.
  @discussion Specific controls include ACLs, file owner UUIDs, and group UUIDs.
  @param mp Mount to test.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_clearextendedsecurity(mount_t);

<span class="enscript-comment">/*!
  @function vfs_setlocklocal
  @abstract Mark a filesystem as using VFS-level advisory locking support.
  @discussion Advisory locking operations will not call down to the filesystem if this flag is set.
  @param mp Mount to mark.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_setlocklocal(mount_t);

<span class="enscript-comment">/*!
  @function vfs_authcache_ttl
  @abstract Determine the time-to-live of cached authorized credentials for files in this filesystem.
  @discussion If a filesystem is set to allow caching credentials, the VFS layer can authorize
  previously-authorized actions from the same vfs_context_t without calling down to the filesystem (though
  it will not deny based on the cache).
  @param mp Mount for which to check cache lifetime.
  @return  Cache lifetime in seconds.  CACHED_RIGHT_INFINITE_TTL indicates that credentials never expire.
  */</span>
<span class="enscript-type">int</span>	vfs_authcache_ttl(mount_t);

<span class="enscript-comment">/*!
  @function vfs_setauthcache_ttl
  @abstract Enable credential caching and set  time-to-live of cached authorized credentials for files in this filesystem.
  @discussion If a filesystem is set to allow caching credentials, the VFS layer can authorize
  previously-authorized actions from the same vfs_context_t without calling down to the filesystem (though
  it will not deny based on the cache).
  @param mp Mount for which to set cache lifetime.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_setauthcache_ttl(mount_t, <span class="enscript-type">int</span>);

<span class="enscript-comment">/*!
  @function vfs_clearauthcache_ttl
  @abstract Remove time-to-live controls for cached credentials on a filesytem.  Filesystems with remote authorization
  decisions (opaque) will still have KAUTH_VNODE_SEARCH rights cached for a default of CACHED_LOOKUP_RIGHT_TTL seconds.
  @param mp Mount for which to clear cache lifetime.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_clearauthcache_ttl(mount_t);

<span class="enscript-comment">/*
 * return value from vfs_cachedrights_ttl if
 * neither MNTK_AUTH_OPAQUE | MNTK_AUTH_CACHE_TTL
 * is set in mnt_kern_flag.. it indicates
 * that no TTL is being applied to the vnode rights cache
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CACHED_RIGHT_INFINITE_TTL</span>	~0

<span class="enscript-comment">/*!
  @function vfs_maxsymlen
  @abstract Get the maximum length of a symbolic link on a filesystem.
  @param mp Mount from which to get symlink length cap.
  @return Max symlink length.
  */</span>
uint32_t <span class="enscript-function-name">vfs_maxsymlen</span>(mount_t);

<span class="enscript-comment">/*!
  @function vfs_setmaxsymlen
  @abstract Set the maximum length of a symbolic link on a filesystem.
  @param mp Mount on which to set symlink length cap.
  @param symlen Length to set.
  @return Max symlink length.
  */</span>
<span class="enscript-type">void</span>	vfs_setmaxsymlen(mount_t, uint32_t);

<span class="enscript-comment">/*!
  @function vfs_fsprivate
  @abstract Get filesystem-private mount data.
  @discussion A filesystem generally has an internal mount structure which it attaches to the VFS-level mount structure
  as part of the mounting process.
  @param mp Mount for which to get private data.
  @return Private data.
  */</span>
<span class="enscript-type">void</span> *	vfs_fsprivate(mount_t);

<span class="enscript-comment">/*!
  @function vfs_setfsprivate
  @abstract Set filesystem-private mount data.
  @discussion A filesystem generally has an internal mount structure which it attaches to the VFS-level mount structure
  as part of the mounting process.
  @param mp Mount for which to set private data.
  @return Void.
  */</span>
<span class="enscript-type">void</span>	vfs_setfsprivate(mount_t, <span class="enscript-type">void</span> *mntdata);

<span class="enscript-comment">/*!
  @function vfs_statfs
  @abstract Get information about filesystem status.
  @discussion Each filesystem has a struct vfsstatfs associated with it which is updated as events occur; this function
  returns a pointer to it.  Note that the data in the structure will continue to change over time and also that it may
  be quite stale of vfs_update_vfsstat has not been called recently.
  @param mp Mount for which to get vfsstatfs pointer.
  @return Pointer to vfsstatfs.
  */</span>
<span class="enscript-type">struct</span> vfsstatfs *	vfs_statfs(mount_t);
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFS_USER_EVENT</span>		0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VFS_KERNEL_EVENT</span>	1

<span class="enscript-comment">/*!
  @function vfs_update_vfsstat
  @abstract Update cached filesystem status information in the VFS mount structure.
  @discussion Each filesystem has a struct vfsstatfs associated with it which is updated as events occur; this function
  updates it so that the structure pointer returned by vfs_statfs() returns a pointer to fairly recent data.
  @param mp Mount for which to update cached status information.
  @param ctx Context to authenticate against for call down to filesystem.
  @param eventtype VFS_USER_EVENT: need for update is driven by user-level request; perform additional authentication.
  VFS_KERNEL_EVENT: need for update is driven by in-kernel events.  Skip extra authentication.
  @return 0 for success, or an error code for authentication failure or problem with call to filesystem to 
  request information.
  */</span>
<span class="enscript-type">int</span>	vfs_update_vfsstat(mount_t, vfs_context_t, <span class="enscript-type">int</span> eventtype);

<span class="enscript-comment">/*!
  @function vfs_typenum
  @abstract Get (archaic) filesystem type number.
  @discussion Filesystem type numbers are an old construct; most filesystems just get a number assigned based on 
  the order in which they are registered with the system.
  @param mp Mount for which to get type number.
  @return Type number.
  */</span>
<span class="enscript-type">int</span>	vfs_typenum(mount_t);

<span class="enscript-comment">/*!
  @function vfs_name
  @abstract Copy filesystem name into a buffer.
  @discussion Get filesystem name; this refers to the filesystem type of which a mount is an instantiation,
  rather than a name specific to the mountpoint.
  @param mp Mount for which to get name.
  @param buffer Destination for name; length should be at least MFSNAMELEN.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_name(mount_t, <span class="enscript-type">char</span> *);

<span class="enscript-comment">/*!
  @function vfs_devblocksize
  @abstract Get the block size of the device underlying a mount.
  @param mp Mount for which to get block size.
  @return Block size.
  */</span>
<span class="enscript-type">int</span>	vfs_devblocksize(mount_t);

<span class="enscript-comment">/*!
  @function vfs_ioattr
  @abstract Get I/O attributes associated with a mounpoint.
  @param mp Mount for which to get attributes.  If NULL, system defaults are filled into ioattrp.
  @param ioattrp Destination for results.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_ioattr(mount_t, <span class="enscript-type">struct</span> vfsioattr *);

<span class="enscript-comment">/*!
  @function vfs_setioattr
  @abstract Set I/O attributes associated with a mounpoint.
  @param mp Mount for which to set attributes.  
  @param ioattrp Structure containing I/O parameters; all fields must be filled in.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_setioattr(mount_t, <span class="enscript-type">struct</span> vfsioattr *);

<span class="enscript-comment">/*!
  @function vfs_64bitready
  @abstract Check if the filesystem associated with a mountpoint is marked ready for interaction with 64-bit user processes.
  @param mp Mount to test.
  @return Nonzero if filesystem is ready for 64-bit; 0 otherwise.
  */</span>
<span class="enscript-type">int</span> 	vfs_64bitready(mount_t);


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LK_NOWAIT</span> 1
<span class="enscript-comment">/*!
  @function vfs_busy
  @abstract &quot;Busy&quot; a mountpoint.
  @discussion vfs_busy() will &quot;busy&quot; a mountpoint, preventing unmounts from taking off, by taking its reader-writer lock 
  in a shared manner.  If a mount is dead,
  it will fail; if an unmount is in progress, depending on flags, it will either fail immediately or block
  until the unmount completes (then failing if the unmount has succeeded, or potentially succeeding if unmounting failed).
  A successful vfs_busy() must be followed by a vfs_unbusy() to release the lock on the mount.
  @param mp Mount to busy.
  @param flags LK_NOWAIT: fail with ENOENT if an unmount is in progress.
  @return 0 for success, with a lock held; an error code otherwise, with no lock held.
  */</span>
<span class="enscript-type">int</span>	vfs_busy(mount_t, <span class="enscript-type">int</span>);

<span class="enscript-comment">/*!
  @function vfs_unbusy
  @abstract &quot;Unbusy&quot; a mountpoint by releasing its read-write lock.
  @discussion A successful vfs_busy() must be followed by a vfs_unbusy() to release the lock on the mount.
  @param mp Mount to unbusy.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_unbusy(mount_t);

<span class="enscript-comment">/*!
  @function vfs_getnewfsid
  @abstract Generate a unique filesystem ID for a mount and store it in the mount structure.
  @discussion Filesystem IDs are returned as part of &quot;struct statfs.&quot;  This function is typically
  called as part of file-system specific mount code (i.e. through VFS_MOUNT).
  @param mp Mount to set an ID for.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_getnewfsid(<span class="enscript-type">struct</span> mount *);

<span class="enscript-comment">/*!
  @function vfs_getvfs
  @abstract Given a filesystem ID, look up a mount structure.
  @param fsid Filesystem ID to look up.
  @return Mountpoint if found, else NULL.  Note unmounting mountpoints can be returned.
  */</span>
mount_t	vfs_getvfs(fsid_t *);

<span class="enscript-comment">/*!
  @function vfs_mountedon
  @abstract Check whether a given block device has a filesystem mounted on it.
  @discussion Note that this is NOT a check for a covered vnode (the directory upon which 
  a filesystem is mounted)--it is a test for whether a block device is being used as the source
  of a filesystem.  Note that a block device marked as being mounted on cannot be opened.
  @param vp The vnode to test.
  @return EBUSY if vnode is indeed the source of a filesystem; 0 if it is not.
  */</span>
<span class="enscript-type">int</span>	vfs_mountedon(<span class="enscript-type">struct</span> vnode *);

<span class="enscript-comment">/*!
  @function vfs_unmountbyfsid
  @abstract Find a filesystem by ID and unmount it.
  @param fsid ID of filesystem to unmount, as found through (for example) statfs.
  @param flags MNT_FORCE: forcibly invalidate files open on the mount (though in-flight I/O operations 
  will be allowed to complete).
  @param ctx Context against which to authenticate unmount operation.
  @return 0 for succcess, nonero for failure.
  */</span>
<span class="enscript-type">int</span>	vfs_unmountbyfsid(fsid_t *, <span class="enscript-type">int</span>, vfs_context_t);

<span class="enscript-comment">/*!
  @function vfs_event_signal
  @abstract Post a kqueue-style event on a filesystem (EVFILT_FS).
  @param fsid Unused.
  @param event Events to post.
  @param data Unused.
  @return void.
  */</span>
<span class="enscript-type">void</span>	vfs_event_signal(fsid_t *, u_int32_t, intptr_t);
<span class="enscript-comment">/*!
  @function vfs_event_init
  @abstract This function should not be called by kexts.
  */</span>
<span class="enscript-type">void</span>	vfs_event_init(<span class="enscript-type">void</span>); <span class="enscript-comment">/* XXX We should not export this */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
<span class="enscript-type">int</span>	vfs_getbyid(fsid_t *fsid, ino64_t ino, vnode_t *vpp, vfs_context_t ctx);
<span class="enscript-type">int</span>	vfs_getattr(mount_t mp, <span class="enscript-type">struct</span> vfs_attr *vfa, vfs_context_t ctx);
<span class="enscript-type">int</span>	vfs_setattr(mount_t mp, <span class="enscript-type">struct</span> vfs_attr *vfa, vfs_context_t ctx);
<span class="enscript-type">int</span>	vfs_extendedsecurity(mount_t);
mount_t	vfs_getvfs_by_mntonname(<span class="enscript-type">char</span> *);
vnode_t <span class="enscript-function-name">vfs_vnodecovered</span>(mount_t mp); <span class="enscript-comment">/* Returns vnode with an iocount that must be released with vnode_put() */</span>
vnode_t <span class="enscript-function-name">vfs_devvp</span>(mount_t mp); <span class="enscript-comment">/* Please see block comment with implementation */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">vfs_nativexattrs</span> (mount_t mp); <span class="enscript-comment">/* whether or not the FS supports EAs natively */</span>
<span class="enscript-type">void</span> *  <span class="enscript-function-name">vfs_mntlabel</span>(mount_t mp); <span class="enscript-comment">/* Safe to cast to &quot;struct label*&quot;; returns &quot;void*&quot; to limit dependence of mount.h on security headers.  */</span>
<span class="enscript-type">void</span>	vfs_setcompoundopen(mount_t mp);
uint64_t <span class="enscript-function-name">vfs_throttle_mask</span>(mount_t mp);

<span class="enscript-type">struct</span> vnode_trigger_info;

<span class="enscript-comment">/*!
 @function vfs_addtrigger
 @abstract Create an &quot;external&quot; trigger vnode: look up a vnode and mark it as
 a trigger.  Can only safely be called in the context of a callback set by
 vfs_settriggercallback().  May only be used on a file which is not already
 marked as a trigger. 
 @param relpath Path relative to root of mountpoint at which to mark trigger.
 @param vtip Information about trigger; analogous to &quot;vnode_trigger_param&quot;
 	argument to vnode_create.
 @param ctx Authorization context.
 */</span>
<span class="enscript-type">int</span> 	vfs_addtrigger(mount_t mp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *relpath, <span class="enscript-type">struct</span> vnode_trigger_info *vtip, vfs_context_t ctx);


<span class="enscript-comment">/*!
 @enum vfs_trigger_callback_op_t
 @abstract Operation to perform after an attempted unmount (successful or otherwise).
 @constant VTC_REPLACE Unmount failed: attempt to replace triggers.  Only valid 
 	VFS operation to perform in this context is vfs_addtrigger().
 @constant VTC_RELEASE Unmount succeeded: release external triggering context.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> { 
	VTC_REPLACE,
	VTC_RELEASE
} vfs_trigger_callback_op_t;

<span class="enscript-comment">/*!
 @typedef vfs_trigger_callback_t
 @abstract Callback to be passed to vfs_settriggercallback() and invoked from 
 	unmount context.  
 @param mp Mountpoint on which unmount is occurring.
 @param op Operation (see vfs_trigger_callback_op_t)
 @param data Context passed to vfs_settriggercallback()
 @param ctx Authorization context in which unmount is occurring.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vfs_trigger_callback_t</span>(mount_t mp, vfs_trigger_callback_op_t op, <span class="enscript-type">void</span> *data, vfs_context_t ctx);

<span class="enscript-comment">/*!
  @function vfs_settriggercallback
  @abstract Install a callback to be called after unmount attempts on a volume, 
  to restore triggers for failed unmounts and release state for successful ones.
  @discussion Installs a callback which will be called in two situations: a 
  failed unmount where vnodes may have been reclaimed and a successful unmount.
  Gives an external trigger-marking entity an opportunity to replace triggers
  which may have been reclaimed.  The callback can only be installed (not 
  cleared), and only one callback can be installed.  The callback will be called
  with a read-write lock held on the mount point; in the VTC_REPLACE case, the 
  &lt;em&gt;only&lt;/em&gt; valid VFS operation to perform in the context of the callback is
  vfs_addtrigger() on the mountpoint in question.  This rwlock is held in order
  to attempt to provide some modicum of coverage from lookups which might find
  missing trigger vnodes and receive spurious ENOENTs.  Note that this 
  protection is incomplete--current working directories, or traversals up into a
  volume via &quot;..&quot; may still find missing triggers.  As of this writing, no
  serialization mechanism exists to do better than this.
  When the &quot;op&quot; is VTC_RELEASE, the mountpoint is going away, and the only valid
  VFS operation is to free the  private data pointer if needed.  The callback 
  will be called immediately, with VTC_REPLACE, from vfs_settriggercallback(), 
  if installation is successful.
  @param fsid FSID for filesystem in question.
  @param vtc Callback pointer.
  @param data Context pointer to be passed to callback.
  @param flags Currently unused.
  @param ctx Authorization context.
  @return 0 for success.  EBUSY if a trigger has already been installed.
  */</span>
<span class="enscript-type">int</span> 	vfs_settriggercallback(fsid_t *fsid, vfs_trigger_callback_t vtc, <span class="enscript-type">void</span> *data, uint32_t flags, vfs_context_t ctx);

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KERNEL_PRIVATE */</span>
__END_DECLS

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">KERNEL</span>

<span class="enscript-comment">/*
 * Generic file handle
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MAX_FH_SIZE</span>		NFSV4_MAX_FH_SIZE
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSV4_MAX_FH_SIZE</span>	128
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSV3_MAX_FH_SIZE</span>	64
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSV2_MAX_FH_SIZE</span>	32
<span class="enscript-type">struct</span> fhandle {
	<span class="enscript-type">int</span>		fh_len;				<span class="enscript-comment">/* length of file handle */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>	fh_data[NFS_MAX_FH_SIZE];	<span class="enscript-comment">/* file handle value */</span>
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> fhandle	fhandle_t;


__BEGIN_DECLS
<span class="enscript-type">int</span>	fhopen(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> fhandle *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	fstatfs(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> statfs *) __DARWIN_INODE64(fstatfs);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">__DARWIN_ONLY_64_BIT_INO_T</span>
<span class="enscript-type">int</span>	fstatfs64(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> statfs64 *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__DARWIN_ONLY_64_BIT_INO_T */</span>
<span class="enscript-type">int</span>	getfh(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, fhandle_t *);
<span class="enscript-type">int</span>	getfsstat(<span class="enscript-type">struct</span> statfs *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>) __DARWIN_INODE64(getfsstat);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">__DARWIN_ONLY_64_BIT_INO_T</span>
<span class="enscript-type">int</span>	getfsstat64(<span class="enscript-type">struct</span> statfs64 *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__DARWIN_ONLY_64_BIT_INO_T */</span>
<span class="enscript-type">int</span>	getmntinfo(<span class="enscript-type">struct</span> statfs **, <span class="enscript-type">int</span>) __DARWIN_INODE64(getmntinfo);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">__DARWIN_ONLY_64_BIT_INO_T</span>
<span class="enscript-type">int</span>	getmntinfo64(<span class="enscript-type">struct</span> statfs64 **, <span class="enscript-type">int</span>) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__DARWIN_ONLY_64_BIT_INO_T */</span>
<span class="enscript-type">int</span>	mount(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *);
<span class="enscript-type">int</span>	statfs(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">struct</span> statfs *) __DARWIN_INODE64(statfs);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">__DARWIN_ONLY_64_BIT_INO_T</span>
<span class="enscript-type">int</span>	statfs64(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">struct</span> statfs64 *) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_5,__MAC_10_6,__IPHONE_NA,__IPHONE_NA);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__DARWIN_ONLY_64_BIT_INO_T */</span>
<span class="enscript-type">int</span>	unmount(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	getvfsbyname(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">struct</span> vfsconf *);
__END_DECLS

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_SYS_MOUNT_H_ */</span>
</pre>
<hr />
</body></html>