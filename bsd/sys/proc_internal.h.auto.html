<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>proc_internal.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">proc_internal.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995, 1997 Apple Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*-
 * Copyright (c) 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)proc_internal.h	8.15 (Berkeley) 5/19/95
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_SYS_PROC_INTERNAL_H_</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_SYS_PROC_INTERNAL_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
__BEGIN_DECLS
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PSYNCH</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PSYNCH */</span>
__END_DECLS

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">__PROC_INTERNAL_DEBUG</span> 1
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* 
 * The short form for various locks that protect fields in the data structures.
 * PL = Process Lock
 * PGL = Process Group Lock
 * PFDL = Process File Desc Lock
 * PSL = Process Spin Lock
 * PPL = Parent Process Lock (planed for later usage)
 * LL = List Lock
 * SL = Session Lock
*/</span>
<span class="enscript-type">struct</span> label;

<span class="enscript-comment">/*
 * One structure allocated per session.
 */</span>
<span class="enscript-type">struct</span>	session {
	<span class="enscript-type">int</span>			s_count;		<span class="enscript-comment">/* Ref cnt; pgrps in session. (LL) */</span>
	<span class="enscript-type">struct</span>	proc *		s_leader;		<span class="enscript-comment">/* Session leader.(static) */</span>
	<span class="enscript-type">struct</span>	vnode *		s_ttyvp;		<span class="enscript-comment">/* Vnode of controlling terminal.(SL) */</span>
	<span class="enscript-type">int</span>			s_ttyvid;		<span class="enscript-comment">/* Vnode id of the controlling terminal (SL) */</span>
	<span class="enscript-type">struct</span>	tty *		s_ttyp;			<span class="enscript-comment">/* Controlling terminal. (SL + ttyvp != NULL) */</span>
	pid_t			s_ttypgrpid;		<span class="enscript-comment">/* tty's pgrp id */</span>
	pid_t			s_sid;			<span class="enscript-comment">/* Session ID (static) */</span>
	<span class="enscript-type">char</span>			s_login[MAXLOGNAME];	<span class="enscript-comment">/* Setlogin() name.(SL) */</span>
	<span class="enscript-type">int</span>			s_flags;		<span class="enscript-comment">/* Session flags (s_mlock)  */</span>
	LIST_ENTRY(session)	s_hash;			<span class="enscript-comment">/* Hash chain.(LL) */</span>
	lck_mtx_t		s_mlock;		<span class="enscript-comment">/* mutex lock to protect session */</span>
	<span class="enscript-type">int</span>			s_listflags;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SESSION_NULL</span> (struct session *)0

<span class="enscript-comment">/*
 * accessor for s_ttyp which treats it as invalid if s_ttyvp is not valid;
 * note that s_ttyp is not a reference in the session structre, so it can
 * become invalid out from under the session if the device is closed, without
 * this protection.  We can't safely make it into a reference without reflexive
 * close notification of tty devices through cdevsw[].
 *
 * NB:	&lt;sys/tty.h&gt; is not in scope and there is not typedef type enforcement,
 *	or '0' below would be 'TTY_NULL'.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SESSION_TP</span>(sp)	(((sp)-&gt;s_ttyvp != 0) ? (sp)-&gt;s_ttyp : 0)

<span class="enscript-comment">/*
 * Session flags; used to tunnel information to lower layers and line
 * disciplines, etc.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_DEFAULT</span>	0x00000000	<span class="enscript-comment">/* No flags set */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_NOCTTY</span>	0x00000001	<span class="enscript-comment">/* Do not associate controlling tty */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_CTTYREF</span>	0x00000010	<span class="enscript-comment">/* vnode ref taken by cttyopen */</span>


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">S_LIST_TERM</span>	1		<span class="enscript-comment">/* marked for termination */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_LIST_DEAD</span>	2		<span class="enscript-comment">/* already dead */</span>
<span class="enscript-comment">/*
 * One structure allocated per process group.
 */</span>
<span class="enscript-type">struct</span>	pgrp {
	LIST_ENTRY(pgrp)	pg_hash;	<span class="enscript-comment">/* Hash chain. (LL) */</span>
	LIST_HEAD(, proc) 	pg_members;	<span class="enscript-comment">/* Pointer to pgrp members. (PGL) */</span>
	<span class="enscript-type">struct</span>	session *	pg_session;	<span class="enscript-comment">/* Pointer to session. (LL ) */</span>
	pid_t			pg_id;		<span class="enscript-comment">/* Pgrp id. (static) */</span>
	<span class="enscript-type">int</span>			pg_jobc;	<span class="enscript-comment">/* # procs qualifying pgrp for job control (PGL) */</span>
	<span class="enscript-type">int</span>			pg_membercnt;	<span class="enscript-comment">/* Number of processes in the pgrocess group (PGL) */</span>
	<span class="enscript-type">int</span>			pg_refcount;	<span class="enscript-comment">/* number of current iterators (LL) */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		pg_listflags;	<span class="enscript-comment">/* (LL) */</span>
	lck_mtx_t		pg_mlock;	<span class="enscript-comment">/* mutex lock to protect pgrp */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PGRP_FLAG_TERMINATE</span> 	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PGRP_FLAG_WAITTERMINATE</span> 2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PGRP_FLAG_DEAD</span> 		4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PGRP_FLAG_ITERABEGIN</span> 	8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PGRP_FLAG_ITERWAIT</span> 	0x10

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PGRP_NULL</span> (struct pgrp *)0
<span class="enscript-type">struct</span> proc;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROC_NULL</span> (struct proc *)0

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PROC_UPDATE_CREDS_ONPROC</span>(p) { \
	p-&gt;p_uid =  kauth_cred_getuid(p-&gt;p_ucred); \
	p-&gt;p_gid =  kauth_cred_getgid(p-&gt;p_ucred); \
	p-&gt;p_ruid =  kauth_cred_getruid(p-&gt;p_ucred); \
	p-&gt;p_rgid =  kauth_cred_getrgid(p-&gt;p_ucred); \
	p-&gt;p_svuid =  kauth_cred_getsvuid(p-&gt;p_ucred); \
	p-&gt;p_svgid =  kauth_cred_getsvgid(p-&gt;p_ucred); \
	}
<span class="enscript-comment">/*
 * Description of a process.
 *
 * This structure contains the information needed to manage a thread of
 * control, known in UN*X as a process; it has references to substructures
 * containing descriptions of things that the process uses, but may share
 * with related processes.  The process structure and the substructures
 * are always addressible except for those marked &quot;(PROC ONLY)&quot; below,
 * which might be addressible only on a processor on which the process
 * is running.
 */</span>
<span class="enscript-type">struct</span>	proc {
	LIST_ENTRY(proc) p_list;		<span class="enscript-comment">/* List of all processes. */</span>

	pid_t		p_pid;			<span class="enscript-comment">/* Process identifier. (static)*/</span>
	<span class="enscript-type">void</span> * 		task;			<span class="enscript-comment">/* corresponding task (static)*/</span>
	<span class="enscript-type">struct</span>	proc *	p_pptr;		 	<span class="enscript-comment">/* Pointer to parent process.(LL) */</span>
	pid_t		p_ppid;			<span class="enscript-comment">/* process's parent pid number */</span>
	pid_t		p_pgrpid;		<span class="enscript-comment">/* process group id of the process (LL)*/</span>
	uid_t		p_uid;
	gid_t		p_gid;
	uid_t		p_ruid;
	gid_t		p_rgid;
	uid_t		p_svuid;
	gid_t		p_svgid;
	uint64_t	p_uniqueid;		<span class="enscript-comment">/* process unique ID - incremented on fork/spawn/vfork, remains same across exec. */</span>
	uint64_t	p_puniqueid;		<span class="enscript-comment">/* parent's unique ID - set on fork/spawn/vfork, doesn't change if reparented. */</span>

	lck_mtx_t 	p_mlock;		<span class="enscript-comment">/* mutex lock for proc */</span>

	<span class="enscript-type">char</span>		p_stat;			<span class="enscript-comment">/* S* process status. (PL)*/</span>
	<span class="enscript-type">char</span>		p_shutdownstate;
	<span class="enscript-type">char</span>		p_kdebug;		<span class="enscript-comment">/* P_KDEBUG eq (CC)*/</span> 
	<span class="enscript-type">char</span>		p_btrace;		<span class="enscript-comment">/* P_BTRACE eq (CC)*/</span>

	LIST_ENTRY(proc) p_pglist;		<span class="enscript-comment">/* List of processes in pgrp.(PGL) */</span>
	LIST_ENTRY(proc) p_sibling;		<span class="enscript-comment">/* List of sibling processes. (LL)*/</span>
	LIST_HEAD(, proc) p_children;		<span class="enscript-comment">/* Pointer to list of children. (LL)*/</span>
	TAILQ_HEAD( , uthread) p_uthlist; 	<span class="enscript-comment">/* List of uthreads  (PL) */</span>

	LIST_ENTRY(proc) p_hash;		<span class="enscript-comment">/* Hash chain. (LL)*/</span>
	TAILQ_HEAD( ,eventqelt) p_evlist;	<span class="enscript-comment">/* (PL) */</span>

	lck_mtx_t	p_fdmlock;		<span class="enscript-comment">/* proc lock to protect fdesc */</span>

	<span class="enscript-comment">/* substructures: */</span>
	kauth_cred_t	p_ucred;		<span class="enscript-comment">/* Process owner's identity. (PL) */</span>
	<span class="enscript-type">struct</span>	filedesc *p_fd;			<span class="enscript-comment">/* Ptr to open files structure. (PFDL) */</span>
	<span class="enscript-type">struct</span>	pstats *p_stats;		<span class="enscript-comment">/* Accounting/statistics (PL). */</span>
	<span class="enscript-type">struct</span>	plimit *p_limit;		<span class="enscript-comment">/* Process limits.(PL) */</span>

	<span class="enscript-type">struct</span>	sigacts *p_sigacts;		<span class="enscript-comment">/* Signal actions, state (PL) */</span>
	 <span class="enscript-type">int</span>		p_siglist;		<span class="enscript-comment">/* signals captured back from threads */</span>
	lck_spin_t	p_slock;		<span class="enscript-comment">/* spin lock for itimer/profil protection */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">p_rlimit</span>	p_limit-&gt;pl_rlimit

	<span class="enscript-type">struct</span>	plimit *p_olimit;		<span class="enscript-comment">/* old process limits  - not inherited by child  (PL) */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	p_flag;			<span class="enscript-comment">/* P_* flags. (atomic bit ops) */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	p_lflag;		<span class="enscript-comment">/* local flags  (PL) */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	p_listflag;		<span class="enscript-comment">/* list flags (LL) */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	p_ladvflag;		<span class="enscript-comment">/* local adv flags (atomic) */</span>
	<span class="enscript-type">int</span>		p_refcount;		<span class="enscript-comment">/* number of outstanding users(LL) */</span>
	<span class="enscript-type">int</span>		p_childrencnt;		<span class="enscript-comment">/* children holding ref on parent (LL) */</span>
	<span class="enscript-type">int</span>		p_parentref;		<span class="enscript-comment">/* children lookup ref on parent (LL) */</span>

	pid_t		p_oppid;	 	<span class="enscript-comment">/* Save parent pid during ptrace. XXX */</span>
	u_int		p_xstat;		<span class="enscript-comment">/* Exit status for wait; also stop signal. */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_PROC_HAS_SCHEDINFO_</span>
	<span class="enscript-comment">/* may need cleanup, not used */</span>
	u_int		p_estcpu;	 	<span class="enscript-comment">/* Time averaged value of p_cpticks.(used by aio and proc_comapre) */</span>
	fixpt_t		p_pctcpu;	 	<span class="enscript-comment">/* %cpu for this process during p_swtime (used by aio)*/</span>
	u_int		p_slptime;		<span class="enscript-comment">/* used by proc_compare */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _PROC_HAS_SCHEDINFO_ */</span>

	<span class="enscript-type">struct</span>	itimerval p_realtimer;		<span class="enscript-comment">/* Alarm timer. (PSL) */</span>
	<span class="enscript-type">struct</span>	timeval p_rtime;		<span class="enscript-comment">/* Real time.(PSL)  */</span>
	<span class="enscript-type">struct</span>	itimerval p_vtimer_user;	<span class="enscript-comment">/* Virtual timers.(PSL)  */</span>
	<span class="enscript-type">struct</span>	itimerval p_vtimer_prof;	<span class="enscript-comment">/* (PSL) */</span>

	<span class="enscript-type">struct</span>	timeval	p_rlim_cpu;		<span class="enscript-comment">/* Remaining rlim cpu value.(PSL) */</span>
	<span class="enscript-type">int</span>		p_debugger;		<span class="enscript-comment">/*  NU 1: can exec set-bit programs if suser */</span>
	boolean_t	sigwait;	<span class="enscript-comment">/* indication to suspend (PL) */</span>
	<span class="enscript-type">void</span>	*sigwait_thread;	<span class="enscript-comment">/* 'thread' holding sigwait(PL)  */</span>
	<span class="enscript-type">void</span>	*exit_thread;		<span class="enscript-comment">/* Which thread is exiting(PL)  */</span>
	<span class="enscript-type">int</span>	p_vforkcnt;		<span class="enscript-comment">/* number of outstanding vforks(PL)  */</span>
    	<span class="enscript-type">void</span> *  p_vforkact;     	<span class="enscript-comment">/* activation running this vfork proc)(static)  */</span>
	<span class="enscript-type">int</span>	p_fpdrainwait;		<span class="enscript-comment">/* (PFDL) */</span>
	pid_t	p_contproc;	<span class="enscript-comment">/* last PID to send us a SIGCONT (PL) */</span>

	<span class="enscript-comment">/* Following fields are info from SIGCHLD (PL) */</span>
	pid_t	si_pid;			<span class="enscript-comment">/* (PL) */</span>
	u_int   si_status;		<span class="enscript-comment">/* (PL) */</span>
	u_int	si_code;		<span class="enscript-comment">/* (PL) */</span>
	uid_t	si_uid;			<span class="enscript-comment">/* (PL) */</span>

	<span class="enscript-type">void</span> * vm_shm;			<span class="enscript-comment">/* (SYSV SHM Lock) for sysV shared memory */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	user_addr_t			p_dtrace_argv;			<span class="enscript-comment">/* (write once, read only after that) */</span>
	user_addr_t			p_dtrace_envp;			<span class="enscript-comment">/* (write once, read only after that) */</span>
	lck_mtx_t			p_dtrace_sprlock;		<span class="enscript-comment">/* sun proc lock emulation */</span>
	<span class="enscript-type">int</span>				p_dtrace_probes;		<span class="enscript-comment">/* (PL) are there probes for this proc? */</span>
	u_int				p_dtrace_count;			<span class="enscript-comment">/* (sprlock) number of DTrace tracepoints */</span>
        uint8_t                         p_dtrace_stop;                  <span class="enscript-comment">/* indicates a DTrace-desired stop */</span>
	<span class="enscript-type">struct</span> dtrace_ptss_page*	p_dtrace_ptss_pages;		<span class="enscript-comment">/* (sprlock) list of user ptss pages */</span>
	<span class="enscript-type">struct</span> dtrace_ptss_page_entry*	p_dtrace_ptss_free_list;	<span class="enscript-comment">/* (atomic) list of individual ptss entries */</span>
	<span class="enscript-type">struct</span> dtrace_helpers*		p_dtrace_helpers;		<span class="enscript-comment">/* (dtrace_lock) DTrace per-proc private */</span>
	<span class="enscript-type">struct</span> dof_ioctl_data*		p_dtrace_lazy_dofs;		<span class="enscript-comment">/* (sprlock) unloaded dof_helper_t's */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>

<span class="enscript-comment">/* XXXXXXXXXXXXX BCOPY'ed on fork XXXXXXXXXXXXXXXX */</span>
<span class="enscript-comment">/* The following fields are all copied upon creation in fork. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">p_startcopy</span>	p_argslen

	u_int	p_argslen;	 <span class="enscript-comment">/* Length of process arguments. */</span>
	<span class="enscript-type">int</span>  	p_argc;			<span class="enscript-comment">/* saved argc for sysctl_procargs() */</span>
	user_addr_t user_stack;		<span class="enscript-comment">/* where user stack was allocated */</span>
	<span class="enscript-type">struct</span>	vnode *p_textvp;	<span class="enscript-comment">/* Vnode of executable. */</span>
	off_t	p_textoff;		<span class="enscript-comment">/* offset in executable vnode */</span>

	sigset_t p_sigmask;		<span class="enscript-comment">/* DEPRECATED */</span>
	sigset_t p_sigignore;	<span class="enscript-comment">/* Signals being ignored. (PL) */</span>
	sigset_t p_sigcatch;	<span class="enscript-comment">/* Signals being caught by user.(PL)  */</span>

	u_char	p_priority;	<span class="enscript-comment">/* (NU) Process priority. */</span>
	u_char	p_resv0;	<span class="enscript-comment">/* (NU) User-priority based on p_cpu and p_nice. */</span>
	<span class="enscript-type">char</span>	p_nice;		<span class="enscript-comment">/* Process &quot;nice&quot; value.(PL) */</span>
	u_char	p_resv1;	<span class="enscript-comment">/* (NU) User-priority based on p_cpu and p_nice. */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">int</span>	p_mac_enforce;			<span class="enscript-comment">/* MAC policy enforcement control */</span>
#<span class="enscript-reference">endif</span>

	<span class="enscript-type">char</span>	p_comm[MAXCOMLEN+1];
	<span class="enscript-type">char</span>	p_name[(2*MAXCOMLEN)+1];	<span class="enscript-comment">/* PL */</span>

	<span class="enscript-type">struct</span> 	pgrp *p_pgrp;	<span class="enscript-comment">/* Pointer to process group. (LL) */</span>
	uint32_t	p_csflags;	<span class="enscript-comment">/* flags for codesign (PL) */</span>
	uint32_t	p_pcaction;	<span class="enscript-comment">/* action  for process control on starvation */</span>
	uint8_t p_uuid[16];		<span class="enscript-comment">/* from LC_UUID load command */</span>

	<span class="enscript-comment">/* 
	 * CPU type and subtype of binary slice executed in
	 * this process.  Protected by proc lock.
	 */</span>
	cpu_type_t	p_cputype;
	cpu_subtype_t	p_cpusubtype;

<span class="enscript-comment">/* End area that is copied on creation. */</span>
<span class="enscript-comment">/* XXXXXXXXXXXXX End of BCOPY'ed on fork (AIOLOCK)XXXXXXXXXXXXXXXX */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">p_endcopy</span>	p_aio_total_count
	<span class="enscript-type">int</span>		p_aio_total_count;		<span class="enscript-comment">/* all allocated AIO requests for this proc */</span>
	<span class="enscript-type">int</span>		p_aio_active_count;		<span class="enscript-comment">/* all unfinished AIO requests for this proc */</span>
	TAILQ_HEAD( , aio_workq_entry ) p_aio_activeq; 	<span class="enscript-comment">/* active async IO requests */</span>
	TAILQ_HEAD( , aio_workq_entry ) p_aio_doneq;	<span class="enscript-comment">/* completed async IO requests */</span>

	<span class="enscript-type">struct</span> klist p_klist;  <span class="enscript-comment">/* knote list (PL ?)*/</span>

	<span class="enscript-type">struct</span>	rusage_superset *p_ru;	<span class="enscript-comment">/* Exit information. (PL) */</span>
	<span class="enscript-type">int</span>		p_sigwaitcnt;
	thread_t 	p_signalholder;
	thread_t 	p_transholder;

	<span class="enscript-comment">/* DEPRECATE following field  */</span>
	u_short	p_acflag;	<span class="enscript-comment">/* Accounting flags. */</span>
	<span class="enscript-type">volatile</span> u_short p_vfs_iopolicy;	<span class="enscript-comment">/* VFS iopolicy flags. (atomic bit ops) */</span>

	user_addr_t 	p_threadstart;		<span class="enscript-comment">/* pthread start fn */</span>
	user_addr_t 	p_wqthread;		<span class="enscript-comment">/* pthread workqueue fn */</span>
	<span class="enscript-type">int</span> 	p_pthsize;			<span class="enscript-comment">/* pthread size */</span>
	uint32_t	p_pth_tsd_offset;	<span class="enscript-comment">/* offset from pthread_t to TSD for new threads */</span>
	user_addr_t	p_targconc;		<span class="enscript-comment">/* target concurrency ptr */</span>
	user_addr_t	p_stack_addr_hint;	<span class="enscript-comment">/* stack allocation hint for wq threads */</span>
	<span class="enscript-type">void</span> * 	p_wqptr;			<span class="enscript-comment">/* workq ptr */</span>
	<span class="enscript-type">int</span> 	p_wqsize;			<span class="enscript-comment">/* allocated size */</span>
	boolean_t       p_wqiniting;            <span class="enscript-comment">/* semaphore to serialze wq_open */</span>
	lck_spin_t	p_wqlock;		<span class="enscript-comment">/* lock to protect work queue */</span>
	<span class="enscript-type">struct</span> kqueue * p_wqkqueue;             <span class="enscript-comment">/* private workq kqueue */</span>

	<span class="enscript-type">struct</span>  timeval p_start;        	<span class="enscript-comment">/* starting time */</span>
	<span class="enscript-type">void</span> *	p_rcall;
	<span class="enscript-type">int</span>		p_ractive;
	<span class="enscript-type">int</span>	p_idversion;		<span class="enscript-comment">/* version of process identity */</span>
	<span class="enscript-type">void</span> *	p_pthhash;			<span class="enscript-comment">/* pthread waitqueue hash */</span>
	<span class="enscript-type">volatile</span> uint64_t was_throttled __attribute__((aligned(8))); <span class="enscript-comment">/* Counter for number of throttled I/Os */</span>
	<span class="enscript-type">volatile</span> uint64_t did_throttle __attribute__((aligned(8)));  <span class="enscript-comment">/* Counter for number of I/Os this proc throttled */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> p_fdlock_pc[4];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> p_fdunlock_pc[4];
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SIGNAL_DEBUG</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> lockpc[8];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> unlockpc[8];
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SIGNAL_DEBUG */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAGNOSTIC */</span>
	uint64_t	p_dispatchqueue_offset;
	uint64_t	p_dispatchqueue_serialno_offset;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>
	<span class="enscript-type">struct</span> timeval	vm_pressure_last_notify_tstamp;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
	<span class="enscript-comment">/* Fields protected by proc list lock */</span>
	TAILQ_ENTRY(proc) p_memstat_list;               <span class="enscript-comment">/* priority bucket link */</span>
	uint32_t          p_memstat_state;              <span class="enscript-comment">/* state */</span>
	int32_t           p_memstat_effectivepriority;  <span class="enscript-comment">/* priority after transaction state accounted for */</span>
	int32_t           p_memstat_requestedpriority;  <span class="enscript-comment">/* active priority */</span>
	uint32_t          p_memstat_dirty;              <span class="enscript-comment">/* dirty state */</span>
	uint64_t          p_memstat_userdata;           <span class="enscript-comment">/* user state */</span>
	uint64_t          p_memstat_idledeadline;       <span class="enscript-comment">/* time at which process became clean */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
	int32_t           p_memstat_memlimit;           <span class="enscript-comment">/* cached memory limit, toggles between active and inactive limits */</span>
	int32_t           p_memstat_memlimit_active;	<span class="enscript-comment">/* memory limit enforced when process is in active jetsam state */</span>
	int32_t           p_memstat_memlimit_inactive;	<span class="enscript-comment">/* memory limit enforced when process is in inactive jetsam state */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	uint32_t          p_memstat_suspendedfootprint; <span class="enscript-comment">/* footprint at time of suspensions */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MEMORYSTATUS */</span>

	<span class="enscript-comment">/* cached proc-specific data required for corpse inspection */</span>
	pid_t             p_responsible_pid;	<span class="enscript-comment">/* pid resonsible for this process */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PGRPID_DEAD</span> 0xdeaddead

<span class="enscript-comment">/* p_listflag */</span> 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_DRAIN</span>   			0x00000001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_DRAINWAIT</span> 		0x00000002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_DRAINED</span>   		0x00000004
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_DEAD</span>				0x00000008
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_WAITING</span>   		0x00000010
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_EXITED</span>    		0x00000040 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_CHILDDRSTART</span>    	0x00000080 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_CHILDDRAINED</span>    	0x00000100 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_CHILDDRWAIT</span>    	0x00000200 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_CHILDLKWAIT</span>    	0x00000400 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_DEADPARENT</span>    	0x00000800 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_PARENTREFWAIT</span>   	0x00001000 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_INCREATE</span>   		0x00002000 
<span class="enscript-comment">/* 0x4000 &amp;  0x8000 Not used */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_INHASH</span>	 		0x00010000	<span class="enscript-comment">/* process is in hash */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_INPGRP</span>	 		0x00020000	<span class="enscript-comment">/* process is in pgrp */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_PGRPTRANS</span> 		0x00040000	<span class="enscript-comment">/* pgrp is getting replaced */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_PGRPTRWAIT</span> 		0x00080000	<span class="enscript-comment">/* wait for pgrp replacement */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LIST_EXITCOUNT</span> 		0x00100000	<span class="enscript-comment">/* counted for process exit */</span> 
 

<span class="enscript-comment">/* local flags */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">P_LDELAYTERM</span>	0x00000001	<span class="enscript-comment">/* */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">P_LNOZOMB</span>	0x00000002 	<span class="enscript-comment">/* */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LTERM</span>		0x00000004      <span class="enscript-comment">/* */</span> 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LEXIT</span>		0x00000008      <span class="enscript-comment">/* */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LPEXIT</span>	0x00000010
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">P_LTRANSCOMMIT</span>	0x00000020	<span class="enscript-comment">/* process is committed to trans */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">P_LINTRANSIT</span>	0x00000040	<span class="enscript-comment">/* process in exec or in creation */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">P_LTRANSWAIT</span>	0x00000080	<span class="enscript-comment">/* waiting for trans to complete */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LVFORK</span>        0x00000100      <span class="enscript-comment">/* parent proc of a vfork */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LINVFORK</span>      0x00000200      <span class="enscript-comment">/* child proc of a vfork */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LTRACED</span>       0x00000400      <span class="enscript-comment">/* */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LSIGEXC</span>       0x00000800      <span class="enscript-comment">/* */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LNOATTACH</span>     0x00001000      <span class="enscript-comment">/* */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LPPWAIT</span>       0x00002000      <span class="enscript-comment">/* */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">P_LKQWDRAIN</span>	0x00004000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">P_LKQWDRAINWAIT</span>	0x00008000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">P_LKQWDEAD</span>	0x00010000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">P_LLIMCHANGE</span>	0x00020000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">P_LLIMWAIT</span>	0x00040000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LWAITED</span>   	0x00080000 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LINSIGNAL</span>    	0x00100000 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LRETURNWAIT</span>  	0x00200000 	<span class="enscript-comment">/* process is completing spawn/vfork-exec/fork */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LRAGE_VNODES</span>	0x00400000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LREGISTER</span>	0x00800000	<span class="enscript-comment">/* thread start fns registered  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LVMRSRCOWNER</span>	0x01000000	<span class="enscript-comment">/* can handle the resource ownership of  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LRETURNWAITER</span> 0x02000000	<span class="enscript-comment">/* thread is waiting on P_LRETURNWAIT being cleared */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LTERM_DECRYPTFAIL</span>	0x04000000	<span class="enscript-comment">/* process terminating due to key failure to decrypt */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">P_LTERM_JETSAM</span>		0x08000000	<span class="enscript-comment">/* process is being jetsam'd */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_JETSAM_VMPAGESHORTAGE</span>	0x00000000	<span class="enscript-comment">/* jetsam: lowest jetsam priority proc, killed due to vm page shortage */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_JETSAM_VMTHRASHING</span>	0x10000000	<span class="enscript-comment">/* jetsam: lowest jetsam priority proc, killed due to vm thrashing */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_JETSAM_HIWAT</span>		0x20000000	<span class="enscript-comment">/* jetsam: high water mark */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_JETSAM_PID</span>		0x30000000	<span class="enscript-comment">/* jetsam: pid */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_JETSAM_IDLEEXIT</span>	0x40000000	<span class="enscript-comment">/* jetsam: idle exit */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_JETSAM_VNODE</span>		0x50000000	<span class="enscript-comment">/* jetsam: vnode kill */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_JETSAM_FCTHRASHING</span>	0x60000000	<span class="enscript-comment">/* jetsam: lowest jetsam priority proc, killed due to filecache thrashing */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_JETSAM_MASK</span>		0x70000000	<span class="enscript-comment">/* jetsam type mask */</span>

<span class="enscript-comment">/* Process control state for resource starvation */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_PCTHROTTLE</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_PCSUSP</span>	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_PCKILL</span>	3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_PCMAX</span>		3

<span class="enscript-comment">/* Process control action state on resrouce starvation */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROC_ACTION_MASK</span> 0xffff0000;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PROC_CONTROL_STATE</span>(p) (p-&gt;p_pcaction &amp; P_PCMAX)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PROC_ACTION_STATE</span>(p) ((p-&gt;p_pcaction &gt;&gt; 16) &amp; P_PCMAX)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PROC_SETACTION_STATE</span>(p) (p-&gt;p_pcaction = (PROC_CONTROL_STATE(p) | (PROC_CONTROL_STATE(p) &lt;&lt; 16)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PROC_RESETACTION_STATE</span>(p) (p-&gt;p_pcaction = PROC_CONTROL_STATE(p))

<span class="enscript-comment">/* additional process flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LADVLOCK</span>		0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_LXBKIDLEINPROG</span>	0x02

<span class="enscript-comment">/* p_vfs_iopolicy flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">P_VFS_IOPOLICY_FORCE_HFS_CASE_SENSITIVITY</span> 0x0001

<span class="enscript-comment">/* defns for proc_iterate */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROC_ALLPROCLIST</span>        1		<span class="enscript-comment">/* walk the allproc list (procs not exited yet) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROC_ZOMBPROCLIST</span>       2		<span class="enscript-comment">/*  walk the zombie list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROC_NOWAITTRANS</span>       4		<span class="enscript-comment">/* do not wait for transitions (checkdirs only)  */</span>
 
<span class="enscript-comment">/* defns for pgrp_iterate */</span> 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PGRP_DROPREF</span>    	1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PGRP_BLOCKITERATE</span> 	2
 
<span class="enscript-comment">/* return values of the proc iteration callback routine */</span> 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROC_RETURNED</span>           0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROC_RETURNED_DONE</span>      1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROC_CLAIMED</span>            2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROC_CLAIMED_DONE</span>       3

<span class="enscript-comment">/* process creation arguments */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PROC_CREATE_FORK</span>	0	<span class="enscript-comment">/* independent child (running) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PROC_CREATE_SPAWN</span>	1	<span class="enscript-comment">/* independent child (suspended) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PROC_CREATE_VFORK</span>	2	<span class="enscript-comment">/* child borrows context */</span>


<span class="enscript-comment">/* LP64 version of extern_proc.  all pointers 
 * grow when we're dealing with a 64-bit process.
 * WARNING - keep in sync with extern_proc
 * but use native alignment of 64-bit process.
 */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>	<span class="enscript-comment">/* user_timeval, user_itimerval */</span>

<span class="enscript-comment">/* This packing breaks symmetry with userspace side (struct extern_proc 
 * of proc.h) for the ARMV7K ABI where 64-bit types are 64-bit aligned
 */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>(4)
<span class="enscript-type">struct</span> user32_extern_proc {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			uint32_t __p_forw;	<span class="enscript-comment">/* Doubly-linked run/sleep queue. */</span>
			uint32_t __p_back;
		} p_st1;
		<span class="enscript-type">struct</span> user32_timeval __p_starttime; 	<span class="enscript-comment">/* process start time */</span>
	} p_un;
	uint32_t 	p_vmspace;	<span class="enscript-comment">/* Address space. */</span>
	uint32_t	p_sigacts;	<span class="enscript-comment">/* Signal actions, state (PROC ONLY). */</span>
	<span class="enscript-type">int</span>		p_flag;			<span class="enscript-comment">/* P_* flags. */</span>
	<span class="enscript-type">char</span>	p_stat;			<span class="enscript-comment">/* S* process status. */</span>
	pid_t	p_pid;			<span class="enscript-comment">/* Process identifier. */</span>
	pid_t	p_oppid;		<span class="enscript-comment">/* Save parent pid during ptrace. XXX */</span>
	<span class="enscript-type">int</span>		p_dupfd;		<span class="enscript-comment">/* Sideways return value from fdopen. XXX */</span>
	<span class="enscript-comment">/* Mach related  */</span>
	uint32_t user_stack;	<span class="enscript-comment">/* where user stack was allocated */</span>
	uint32_t exit_thread;  <span class="enscript-comment">/* XXX Which thread is exiting? */</span>
	<span class="enscript-type">int</span>		p_debugger;		<span class="enscript-comment">/* allow to debug */</span>
	boolean_t	sigwait;	<span class="enscript-comment">/* indication to suspend */</span>
	<span class="enscript-comment">/* scheduling */</span>
	u_int	p_estcpu;	 <span class="enscript-comment">/* Time averaged value of p_cpticks. */</span>
	<span class="enscript-type">int</span>		p_cpticks;	 <span class="enscript-comment">/* Ticks of cpu time. */</span>
	fixpt_t	p_pctcpu;	 <span class="enscript-comment">/* %cpu for this process during p_swtime */</span>
	uint32_t	p_wchan;	 <span class="enscript-comment">/* Sleep address. */</span>
	uint32_t	p_wmesg;	 <span class="enscript-comment">/* Reason for sleep. */</span>
	u_int	p_swtime;	 <span class="enscript-comment">/* Time swapped in or out. */</span>
	u_int	p_slptime;	 <span class="enscript-comment">/* Time since last blocked. */</span>
	<span class="enscript-type">struct</span>	user32_itimerval p_realtimer;	<span class="enscript-comment">/* Alarm timer. */</span>
	<span class="enscript-type">struct</span>	user32_timeval p_rtime;	<span class="enscript-comment">/* Real time. */</span>
	u_quad_t p_uticks;		<span class="enscript-comment">/* Statclock hits in user mode. */</span>
	u_quad_t p_sticks;		<span class="enscript-comment">/* Statclock hits in system mode. */</span>
	u_quad_t p_iticks;		<span class="enscript-comment">/* Statclock hits processing intr. */</span>
	<span class="enscript-type">int</span>		p_traceflag;		<span class="enscript-comment">/* Kernel trace points. */</span>
	uint32_t	p_tracep;	<span class="enscript-comment">/* Trace to vnode. */</span>
	<span class="enscript-type">int</span>		p_siglist;		<span class="enscript-comment">/* DEPRECATED */</span>
	uint32_t	p_textvp;	<span class="enscript-comment">/* Vnode of executable. */</span>
	<span class="enscript-type">int</span>		p_holdcnt;		<span class="enscript-comment">/* If non-zero, don't swap. */</span>
	sigset_t p_sigmask;	<span class="enscript-comment">/* DEPRECATED. */</span>
	sigset_t p_sigignore;	<span class="enscript-comment">/* Signals being ignored. */</span>
	sigset_t p_sigcatch;	<span class="enscript-comment">/* Signals being caught by user. */</span>
	u_char	p_priority;	<span class="enscript-comment">/* Process priority. */</span>
	u_char	p_usrpri;	<span class="enscript-comment">/* User-priority based on p_cpu and p_nice. */</span>
	<span class="enscript-type">char</span>	p_nice;		<span class="enscript-comment">/* Process &quot;nice&quot; value. */</span>
	<span class="enscript-type">char</span>	p_comm[MAXCOMLEN+1];
	uint32_t	p_pgrp;	<span class="enscript-comment">/* Pointer to process group. */</span>
	uint32_t	p_addr;	<span class="enscript-comment">/* Kernel virtual addr of u-area (PROC ONLY). */</span>
	u_short	p_xstat;	<span class="enscript-comment">/* Exit status for wait; also stop signal. */</span>
	u_short	p_acflag;	<span class="enscript-comment">/* Accounting flags. */</span>
	uint32_t	p_ru;	<span class="enscript-comment">/* Exit information. XXX */</span>
};
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>()
<span class="enscript-type">struct</span> user64_extern_proc {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			user_addr_t __p_forw;	<span class="enscript-comment">/* Doubly-linked run/sleep queue. */</span>
			user_addr_t __p_back;
		} p_st1;
		<span class="enscript-type">struct</span> user64_timeval __p_starttime; 	<span class="enscript-comment">/* process start time */</span>
	} p_un;
	user_addr_t 	p_vmspace;	<span class="enscript-comment">/* Address space. */</span>
	user_addr_t		p_sigacts;	<span class="enscript-comment">/* Signal actions, state (PROC ONLY). */</span>
	<span class="enscript-type">int</span>		p_flag;			<span class="enscript-comment">/* P_* flags. */</span>
	<span class="enscript-type">char</span>	p_stat;			<span class="enscript-comment">/* S* process status. */</span>
	pid_t	p_pid;			<span class="enscript-comment">/* Process identifier. */</span>
	pid_t	p_oppid;		<span class="enscript-comment">/* Save parent pid during ptrace. XXX */</span>
	<span class="enscript-type">int</span>		p_dupfd;		<span class="enscript-comment">/* Sideways return value from fdopen. XXX */</span>
	<span class="enscript-comment">/* Mach related  */</span>
	user_addr_t user_stack __attribute((aligned(8)));	<span class="enscript-comment">/* where user stack was allocated */</span>
	user_addr_t exit_thread;  <span class="enscript-comment">/* XXX Which thread is exiting? */</span>
	<span class="enscript-type">int</span>		p_debugger;		<span class="enscript-comment">/* allow to debug */</span>
	boolean_t	sigwait;	<span class="enscript-comment">/* indication to suspend */</span>
	<span class="enscript-comment">/* scheduling */</span>
	u_int	p_estcpu;	 <span class="enscript-comment">/* Time averaged value of p_cpticks. */</span>
	<span class="enscript-type">int</span>		p_cpticks;	 <span class="enscript-comment">/* Ticks of cpu time. */</span>
	fixpt_t	p_pctcpu;	 <span class="enscript-comment">/* %cpu for this process during p_swtime */</span>
	user_addr_t	p_wchan __attribute((aligned(8)));	 <span class="enscript-comment">/* Sleep address. */</span>
	user_addr_t	p_wmesg;	 <span class="enscript-comment">/* Reason for sleep. */</span>
	u_int	p_swtime;	 <span class="enscript-comment">/* Time swapped in or out. */</span>
	u_int	p_slptime;	 <span class="enscript-comment">/* Time since last blocked. */</span>
	<span class="enscript-type">struct</span>	user64_itimerval p_realtimer;	<span class="enscript-comment">/* Alarm timer. */</span>
	<span class="enscript-type">struct</span>	user64_timeval p_rtime;	<span class="enscript-comment">/* Real time. */</span>
	u_quad_t p_uticks;		<span class="enscript-comment">/* Statclock hits in user mode. */</span>
	u_quad_t p_sticks;		<span class="enscript-comment">/* Statclock hits in system mode. */</span>
	u_quad_t p_iticks;		<span class="enscript-comment">/* Statclock hits processing intr. */</span>
	<span class="enscript-type">int</span>		p_traceflag;		<span class="enscript-comment">/* Kernel trace points. */</span>
	user_addr_t	p_tracep __attribute((aligned(8)));	<span class="enscript-comment">/* Trace to vnode. */</span>
	<span class="enscript-type">int</span>		p_siglist;		<span class="enscript-comment">/* DEPRECATED */</span>
	user_addr_t	p_textvp __attribute((aligned(8)));	<span class="enscript-comment">/* Vnode of executable. */</span>
	<span class="enscript-type">int</span>		p_holdcnt;		<span class="enscript-comment">/* If non-zero, don't swap. */</span>
	sigset_t p_sigmask;	<span class="enscript-comment">/* DEPRECATED. */</span>
	sigset_t p_sigignore;	<span class="enscript-comment">/* Signals being ignored. */</span>
	sigset_t p_sigcatch;	<span class="enscript-comment">/* Signals being caught by user. */</span>
	u_char	p_priority;	<span class="enscript-comment">/* Process priority. */</span>
	u_char	p_usrpri;	<span class="enscript-comment">/* User-priority based on p_cpu and p_nice. */</span>
	<span class="enscript-type">char</span>	p_nice;		<span class="enscript-comment">/* Process &quot;nice&quot; value. */</span>
	<span class="enscript-type">char</span>	p_comm[MAXCOMLEN+1];
	user_addr_t	p_pgrp __attribute((aligned(8)));	<span class="enscript-comment">/* Pointer to process group. */</span>
	user_addr_t	p_addr;	<span class="enscript-comment">/* Kernel virtual addr of u-area (PROC ONLY). */</span>
	u_short	p_xstat;	<span class="enscript-comment">/* Exit status for wait; also stop signal. */</span>
	u_short	p_acflag;	<span class="enscript-comment">/* Accounting flags. */</span>
	user_addr_t	p_ru __attribute((aligned(8)));	<span class="enscript-comment">/* Exit information. XXX */</span>
};
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KERNEL */</span>

<span class="enscript-comment">/*
 * We use process IDs &lt;= PID_MAX; PID_MAX + 1 must also fit in a pid_t,
 * as it is used to represent &quot;no process group&quot;.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nprocs, maxproc;		<span class="enscript-comment">/* Current and max number of procs. */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> maxprocperuid;		<span class="enscript-comment">/* Current number of procs per uid */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> hard_maxproc;	<span class="enscript-comment">/* hard limit */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> proc_shutdown_exitcount;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PID_MAX</span>		99999
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NO_PID</span>		100000
<span class="enscript-type">extern</span> lck_mtx_t * proc_list_mlock;
<span class="enscript-type">extern</span> lck_mtx_t * proc_klist_mlock;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BSD_SIMUL_EXECS</span>		33 <span class="enscript-comment">/* 32 , allow for rounding */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BSD_PAGEABLE_SIZE_PER_EXEC</span>	(NCARGS + PAGE_SIZE + PAGE_SIZE) <span class="enscript-comment">/* page for apple vars, page for executable header */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> execargs_cache_size;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> execargs_free_count;
<span class="enscript-type">extern</span> vm_offset_t * execargs_cache;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SESS_LEADER</span>(p, sessp)	((sessp)-&gt;s_leader == (p))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PIDHASH</span>(pid)	(&amp;pidhashtbl[(pid) &amp; pidhash])
<span class="enscript-type">extern</span> <span class="enscript-function-name">LIST_HEAD</span>(pidhashhead, proc) *pidhashtbl;
<span class="enscript-type">extern</span> u_long pidhash;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PGRPHASH</span>(pgid)	(&amp;pgrphashtbl[(pgid) &amp; pgrphash])
<span class="enscript-type">extern</span> <span class="enscript-function-name">LIST_HEAD</span>(pgrphashhead, pgrp) *pgrphashtbl;
<span class="enscript-type">extern</span> u_long pgrphash;
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SESSHASH</span>(sessid) (&amp;sesshashtbl[(sessid) &amp; sesshash])
<span class="enscript-type">extern</span> <span class="enscript-function-name">LIST_HEAD</span>(sesshashhead, session) *sesshashtbl;
<span class="enscript-type">extern</span> u_long sesshash;

<span class="enscript-type">extern</span> lck_grp_t * proc_lck_grp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FINE_LOCK_GROUPS</span>
<span class="enscript-type">extern</span> lck_grp_t * proc_mlock_grp;
<span class="enscript-type">extern</span> lck_grp_t * proc_fdmlock_grp;
<span class="enscript-type">extern</span> lck_grp_t * proc_slock_grp;
#<span class="enscript-reference">endif</span>
<span class="enscript-type">extern</span> lck_grp_attr_t * proc_lck_grp_attr;
<span class="enscript-type">extern</span> lck_attr_t * proc_lck_attr;

<span class="enscript-function-name">LIST_HEAD</span>(proclist, proc);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> proclist allproc;		<span class="enscript-comment">/* List of all processes. */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> proclist zombproc;	<span class="enscript-comment">/* List of zombie processes. */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> proc *initproc;
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	procinit(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_lock</span>(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_unlock</span>(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_spinlock</span>(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_spinunlock</span>(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_list_lock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_list_unlock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_klist_lock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_klist_unlock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_fdlock</span>(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_fdlock_spin</span>(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_fdunlock</span>(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_fdlock_assert</span>(proc_t p, <span class="enscript-type">int</span> assertflags);
__private_extern__ <span class="enscript-type">int</span> proc_core_name(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, uid_t uid, pid_t pid,
		<span class="enscript-type">char</span> *cr_name, size_t cr_name_len);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">isinferior</span>(<span class="enscript-type">struct</span> proc *, <span class="enscript-type">struct</span> proc *);
__private_extern__ <span class="enscript-type">struct</span> proc *pzfind(pid_t);	<span class="enscript-comment">/* Find zombie by id. */</span>
__private_extern__ <span class="enscript-type">struct</span> proc *proc_find_zombref(pid_t);	<span class="enscript-comment">/* Find zombie by id. */</span>
__private_extern__ <span class="enscript-type">void</span> proc_drop_zombref(<span class="enscript-type">struct</span> proc * p);	<span class="enscript-comment">/* Find zombie by id. */</span>


<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	chgproccnt(uid_t uid, <span class="enscript-type">int</span> diff);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	pinsertchild(<span class="enscript-type">struct</span> proc *parent, <span class="enscript-type">struct</span> proc *child);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	enterpgrp(<span class="enscript-type">struct</span> proc *p, pid_t pgid, <span class="enscript-type">int</span> mksess);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	fixjobc(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> pgrp *pgrp, <span class="enscript-type">int</span> entering);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	inferior(<span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	leavepgrp(<span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	resetpriority(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	setrunnable(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	setrunqueue(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	sleep(<span class="enscript-type">void</span> *chan, <span class="enscript-type">int</span> pri);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	tsleep0(<span class="enscript-type">void</span> *chan, <span class="enscript-type">int</span> pri, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *wmesg, <span class="enscript-type">int</span> timo, <span class="enscript-type">int</span> (*continuation)(<span class="enscript-type">int</span>));
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	tsleep1(<span class="enscript-type">void</span> *chan, <span class="enscript-type">int</span> pri, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *wmesg, u_int64_t abstime, <span class="enscript-type">int</span> (*continuation)(<span class="enscript-type">int</span>));
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	msleep0(<span class="enscript-type">void</span> *chan, lck_mtx_t *mtx, <span class="enscript-type">int</span> pri, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *wmesg, <span class="enscript-type">int</span> timo, <span class="enscript-type">int</span> (*continuation)(<span class="enscript-type">int</span>));
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	vfork_return(<span class="enscript-type">struct</span> proc *child, int32_t *retval, <span class="enscript-type">int</span> rval);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	exit1(<span class="enscript-type">struct</span> proc *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	exit1_internal(<span class="enscript-type">struct</span> proc *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> *, boolean_t, boolean_t, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	fork1(proc_t, thread_t *, <span class="enscript-type">int</span>, coalition_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vfork_exit_internal</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> rv, <span class="enscript-type">int</span> forced);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_reparentlocked</span>(<span class="enscript-type">struct</span> proc *child, <span class="enscript-type">struct</span> proc * newparent, <span class="enscript-type">int</span> cansignal, <span class="enscript-type">int</span> locked);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pgrp_iterate</span>(<span class="enscript-type">struct</span> pgrp * pgrp, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callout)(proc_t , <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *arg, <span class="enscript-type">int</span> (*filterfn)(proc_t , <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *filterarg);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_iterate</span>(<span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callout)(proc_t , <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *arg, <span class="enscript-type">int</span> (*filterfn)(proc_t , <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *filterarg);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_rebootscan</span>(<span class="enscript-type">int</span> (*callout)(proc_t , <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *arg, <span class="enscript-type">int</span> (*filterfn)(proc_t , <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *filterarg);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_childrenwalk</span>(proc_t p, <span class="enscript-type">int</span> (*callout)(proc_t , <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *arg);
<span class="enscript-type">extern</span> proc_t <span class="enscript-function-name">proc_findinternal</span>(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> locked);
<span class="enscript-type">extern</span> proc_t <span class="enscript-function-name">proc_findthread</span>(thread_t thread);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_refdrain</span>(proc_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_childdrainlocked</span>(proc_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_childdrainstart</span>(proc_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_childdrainend</span>(proc_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">proc_checkdeadrefs</span>(proc_t);
<span class="enscript-type">struct</span> proc *<span class="enscript-function-name">pfind_locked</span>(pid_t);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> pgrp *<span class="enscript-function-name">pgfind</span>(pid_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pg_rele</span>(<span class="enscript-type">struct</span> pgrp * pgrp);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> session * <span class="enscript-function-name">session_find_internal</span>(pid_t sessid);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> pgrp * <span class="enscript-function-name">proc_pgrp</span>(proc_t);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> pgrp * <span class="enscript-function-name">tty_pgrp</span>(<span class="enscript-type">struct</span> tty * tp);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> pgrp * <span class="enscript-function-name">pgfind_internal</span>(pid_t);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> session * <span class="enscript-function-name">proc_session</span>(proc_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pgrp_lock</span>(<span class="enscript-type">struct</span> pgrp * pgrp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pgrp_unlock</span>(<span class="enscript-type">struct</span> pgrp * pgrp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">session_lock</span>(<span class="enscript-type">struct</span> session * sess);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">session_unlock</span>(<span class="enscript-type">struct</span> session * sess);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> session * <span class="enscript-function-name">pgrp_session</span>(<span class="enscript-type">struct</span> pgrp * pgrp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	session_rele(<span class="enscript-type">struct</span> session *sess);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">isbackground</span>(proc_t p, <span class="enscript-type">struct</span> tty  *tp);
<span class="enscript-type">extern</span> proc_t <span class="enscript-function-name">proc_parent</span>(proc_t);
<span class="enscript-type">extern</span> proc_t <span class="enscript-function-name">proc_parentholdref</span>(proc_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_parentdropref</span>(proc_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>     <span class="enscript-function-name">itimerfix</span>(<span class="enscript-type">struct</span> timeval *tv);
<span class="enscript-type">int</span>     <span class="enscript-function-name">itimerdecr</span>(<span class="enscript-type">struct</span> proc * p, <span class="enscript-type">struct</span> itimerval *itp, <span class="enscript-type">int</span> usec);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_signalstart</span>(<span class="enscript-type">struct</span> proc *, <span class="enscript-type">int</span> locked);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_signalend</span>(<span class="enscript-type">struct</span> proc *, <span class="enscript-type">int</span> locked);
<span class="enscript-type">int</span>  <span class="enscript-function-name">proc_transstart</span>(<span class="enscript-type">struct</span> proc *, <span class="enscript-type">int</span> locked, <span class="enscript-type">int</span> non_blocking);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_transcommit</span>(<span class="enscript-type">struct</span> proc *, <span class="enscript-type">int</span> locked);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_transend</span>(<span class="enscript-type">struct</span> proc *, <span class="enscript-type">int</span> locked);
<span class="enscript-type">int</span>  <span class="enscript-function-name">proc_transwait</span>(<span class="enscript-type">struct</span> proc *, <span class="enscript-type">int</span> locked);
<span class="enscript-type">void</span>  <span class="enscript-function-name">proc_rele_locked</span>(<span class="enscript-type">struct</span> proc *  p);
<span class="enscript-type">struct</span> proc *<span class="enscript-function-name">proc_ref_locked</span>(<span class="enscript-type">struct</span> proc *  p);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_knote</span>(<span class="enscript-type">struct</span> proc * p, <span class="enscript-type">long</span> hint);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_knote_drain</span>(<span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">void</span> <span class="enscript-function-name">workqueue_init_lock</span>(proc_t p);
<span class="enscript-type">void</span> <span class="enscript-function-name">workqueue_destroy_lock</span>(proc_t p);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_setregister</span>(proc_t p);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_resetregister</span>(proc_t p);
<span class="enscript-comment">/* returns the first thread_t in the process, or NULL XXX for NFS, DO NOT USE */</span>
thread_t <span class="enscript-function-name">proc_thread</span>(proc_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_pendingsignals</span>(proc_t, sigset_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">proc_getpcontrol</span>(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> * pcontrolp);
<span class="enscript-type">int</span> <span class="enscript-function-name">proc_dopcontrol</span>(proc_t p);
<span class="enscript-type">int</span> <span class="enscript-function-name">proc_resetpcontrol</span>(<span class="enscript-type">int</span> pid);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PSYNCH</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">pth_proc_hashinit</span>(proc_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">pth_proc_hashdelete</span>(proc_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">pth_global_hashinit</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> thread_call_t psynch_thcall;
<span class="enscript-type">void</span> <span class="enscript-function-name">psynch_wq_cleanup</span>(__unused <span class="enscript-type">void</span> *  param, __unused <span class="enscript-type">void</span> * param1);
<span class="enscript-type">extern</span> lck_mtx_t * pthread_list_mlock;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PSYNCH */</span>
<span class="enscript-type">struct</span> uthread * <span class="enscript-function-name">current_uthread</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span> <span class="enscript-function-name">proc_set_return_wait</span>(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_clear_return_wait</span>(proc_t p, thread_t child_thread);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_wait_to_return</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/* return 1 if process is forcing case-sensitive HFS+ access, 0 for default */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_is_forcing_hfs_case_sensitivity</span>(proc_t);

pid_t <span class="enscript-function-name">dtrace_proc_selfpid</span>(<span class="enscript-type">void</span>);
pid_t <span class="enscript-function-name">dtrace_proc_selfppid</span>(<span class="enscript-type">void</span>);
uid_t <span class="enscript-function-name">dtrace_proc_selfruid</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !_SYS_PROC_INTERNAL_H_ */</span>
</pre>
<hr />
</body></html>