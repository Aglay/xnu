<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_utfconv.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_utfconv.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
 
 <span class="enscript-comment">/*
 	Includes Unicode 3.2 decomposition code derived from Core Foundation
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/utfconv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSByteOrder.h&gt;</span>

<span class="enscript-comment">/*
 * UTF-8 (Unicode Transformation Format)
 *
 * UTF-8 is the Unicode Transformation Format that serializes a Unicode
 * character as a sequence of one to four bytes. Only the shortest form
 * required to represent the significant Unicode bits is legal.
 * 
 * UTF-8 Multibyte Codes
 *
 * Bytes   Bits   Unicode Min  Unicode Max   UTF-8 Byte Sequence (binary)
 * -----------------------------------------------------------------------------
 *   1       7       0x0000        0x007F    0xxxxxxx
 *   2      11       0x0080        0x07FF    110xxxxx 10xxxxxx
 *   3      16       0x0800        0xFFFF    1110xxxx 10xxxxxx 10xxxxxx
 *   4      21      0x10000      0x10FFFF    11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
 * -----------------------------------------------------------------------------
 */</span>


#<span class="enscript-reference">define</span> <span class="enscript-function-name">UNICODE_TO_UTF8_LEN</span>(c)  \
	((c) &lt; 0x0080 ? 1 : ((c) &lt; 0x0800 ? 2 : (((c) &amp; 0xf800) == 0xd800 ? 2 : 3)))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UCS_ALT_NULL</span>	0x2400

<span class="enscript-comment">/* Surrogate Pair Constants */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SP_HALF_SHIFT</span>	10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SP_HALF_BASE</span>	0x0010000u
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SP_HALF_MASK</span>	0x3FFu

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SP_HIGH_FIRST</span>	0xD800u
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SP_HIGH_LAST</span>	0xDBFFu
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SP_LOW_FIRST</span>	0xDC00u
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SP_LOW_LAST</span>		0xDFFFu


#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;vfs_utfconvdata.h&quot;</span>


<span class="enscript-comment">/*
 * Test for a combining character.
 *
 * Similar to __CFUniCharIsNonBaseCharacter except that
 * unicode_combinable also includes Hangul Jamo characters.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">unicode_combinable</span>(u_int16_t character)
{
	<span class="enscript-type">const</span> u_int8_t *bitmap = __CFUniCharCombiningBitmap;
	u_int8_t value;

	<span class="enscript-keyword">if</span> (character &lt; 0x0300)
		<span class="enscript-keyword">return</span> (0);

	value = bitmap[(character &gt;&gt; 8) &amp; 0xFF];

	<span class="enscript-keyword">if</span> (value == 0xFF) {
		<span class="enscript-keyword">return</span> (1);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (value) {
		bitmap = bitmap + ((value - 1) * 32) + 256;
		<span class="enscript-keyword">return</span> (bitmap[(character &amp; 0xFF) / 8] &amp; (1 &lt;&lt; (character % 8)) ? 1 : 0);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Test for a precomposed character.
 *
 * Similar to __CFUniCharIsDecomposableCharacter.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">unicode_decomposeable</span>(u_int16_t character) {
	<span class="enscript-type">const</span> u_int8_t *bitmap = __CFUniCharDecomposableBitmap;
	u_int8_t value;
	
	<span class="enscript-keyword">if</span> (character &lt; 0x00C0)
		<span class="enscript-keyword">return</span> (0);

	value = bitmap[(character &gt;&gt; 8) &amp; 0xFF];

	<span class="enscript-keyword">if</span> (value == 0xFF) {
		<span class="enscript-keyword">return</span> (1);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (value) {
		bitmap = bitmap + ((value - 1) * 32) + 256;
		<span class="enscript-keyword">return</span> (bitmap[(character &amp; 0xFF) / 8] &amp; (1 &lt;&lt; (character % 8)) ? 1 : 0);
	}
    	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Get the combing class.
 *
 * Similar to CFUniCharGetCombiningPropertyForCharacter.
 */</span>
<span class="enscript-type">static</span> inline u_int8_t
<span class="enscript-function-name">get_combining_class</span>(u_int16_t character) {
	<span class="enscript-type">const</span> u_int8_t *bitmap = __CFUniCharCombiningPropertyBitmap;

	u_int8_t value = bitmap[(character &gt;&gt; 8)];

	<span class="enscript-keyword">if</span> (value) {
		bitmap = bitmap + (value * 256);
		<span class="enscript-keyword">return</span> bitmap[character % 256];
	}
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">unicode_decompose</span>(u_int16_t character, u_int16_t *convertedChars);

<span class="enscript-type">static</span> u_int16_t <span class="enscript-function-name">unicode_combine</span>(u_int16_t base, u_int16_t combining);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">prioritysort</span>(u_int16_t* characters, <span class="enscript-type">int</span> count);

<span class="enscript-type">static</span> u_int16_t  <span class="enscript-function-name">ucs_to_sfm</span>(u_int16_t ucs_ch, <span class="enscript-type">int</span> lastchar);

<span class="enscript-type">static</span> u_int16_t  <span class="enscript-function-name">sfm_to_ucs</span>(u_int16_t ucs_ch);


<span class="enscript-type">char</span> utf_extrabytes[32] = {
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	-1, -1, -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  2,  2,  3, -1
};

<span class="enscript-type">const</span> <span class="enscript-type">char</span> hexdigits[16] = {
	 <span class="enscript-string">'0'</span>,  <span class="enscript-string">'1'</span>,  <span class="enscript-string">'2'</span>,  <span class="enscript-string">'3'</span>,  <span class="enscript-string">'4'</span>,  <span class="enscript-string">'5'</span>,  <span class="enscript-string">'6'</span>, <span class="enscript-string">'7'</span>,
	 <span class="enscript-string">'8'</span>,  <span class="enscript-string">'9'</span>,  <span class="enscript-string">'A'</span>,  <span class="enscript-string">'B'</span>,  <span class="enscript-string">'C'</span>,  <span class="enscript-string">'D'</span>,  <span class="enscript-string">'E'</span>, <span class="enscript-string">'F'</span>
};

<span class="enscript-comment">/*
 * utf8_encodelen - Calculate the UTF-8 encoding length
 *
 * This function takes a Unicode input string, ucsp, of ucslen bytes
 * and calculates the size of the UTF-8 output in bytes (not including
 * a NULL termination byte). The string must reside in kernel memory.
 *
 * If '/' chars are possible in the Unicode input then an alternate
 * (replacement) char should be provided in altslash.
 *
 * FLAGS
 *    UTF_REVERSE_ENDIAN:  Unicode byte order is opposite current runtime
 *
 *    UTF_BIG_ENDIAN:  Unicode byte order is always big endian
 *
 *    UTF_LITTLE_ENDIAN:  Unicode byte order is always little endian
 *
 *    UTF_DECOMPOSED:  generate fully decomposed output
 *
 *    UTF_PRECOMPOSED is ignored since utf8_encodestr doesn't support it
 *
 * ERRORS
 *    None
 */</span>
size_t
<span class="enscript-function-name">utf8_encodelen</span>(<span class="enscript-type">const</span> u_int16_t * ucsp, size_t ucslen, u_int16_t altslash, <span class="enscript-type">int</span> flags)
{
	u_int16_t ucs_ch;
	u_int16_t * chp = NULL;
	u_int16_t sequence[8];
	<span class="enscript-type">int</span> extra = 0;
	size_t charcnt;
	<span class="enscript-type">int</span> swapbytes = (flags &amp; UTF_REVERSE_ENDIAN);
	<span class="enscript-type">int</span> decompose = (flags &amp; UTF_DECOMPOSED);
	size_t len;

	charcnt = ucslen / 2;
	len = 0;

	<span class="enscript-keyword">while</span> (charcnt-- &gt; 0) {
		<span class="enscript-keyword">if</span> (extra &gt; 0) {
			--extra;
			ucs_ch = *chp++;
		} <span class="enscript-keyword">else</span> {
			ucs_ch = *ucsp++;
			<span class="enscript-keyword">if</span> (swapbytes) {
				ucs_ch = OSSwapInt16(ucs_ch);
			}
			<span class="enscript-keyword">if</span> (ucs_ch == <span class="enscript-string">'/'</span>) {
				ucs_ch = altslash ? altslash : <span class="enscript-string">'_'</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ucs_ch == <span class="enscript-string">'\0'</span>) {
				ucs_ch = UCS_ALT_NULL;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (decompose &amp;&amp; unicode_decomposeable(ucs_ch)) {
				extra = unicode_decompose(ucs_ch, sequence) - 1;
				charcnt += extra;
				ucs_ch = sequence[0];
				chp = &amp;sequence[1];
			}
		}
		len += UNICODE_TO_UTF8_LEN(ucs_ch);
	}

	<span class="enscript-keyword">return</span> (len);
}


<span class="enscript-comment">/*
 * utf8_encodestr - Encodes a Unicode string to UTF-8
 *
 * NOTES:
 *    The resulting UTF-8 string is NULL terminated.
 *
 *    If '/' chars are allowed on disk then an alternate
 *    (replacement) char must be provided in altslash.
 *
 * input flags:
 *    UTF_REVERSE_ENDIAN: Unicode byteorder is opposite current runtime
 *
 *    UTF_BIG_ENDIAN:  Unicode byte order is always big endian
 *
 *    UTF_LITTLE_ENDIAN:  Unicode byte order is always little endian
 *
 *    UTF_DECOMPOSED:  generate fully decomposed output
 *
 *    UTF_NO_NULL_TERM:  don't add NULL termination to UTF-8 output
 *
 * result:
 *    ENAMETOOLONG: Name didn't fit; only buflen bytes were encoded
 *
 *    EINVAL: Illegal char found; char was replaced by an '_'.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">utf8_encodestr</span>(<span class="enscript-type">const</span> u_int16_t * ucsp, size_t ucslen, u_int8_t * utf8p,
               size_t * utf8len, size_t buflen, u_int16_t altslash, <span class="enscript-type">int</span> flags)
{
	u_int8_t * bufstart;
	u_int8_t * bufend;
	u_int16_t ucs_ch;
	u_int16_t * chp = NULL;
	u_int16_t sequence[8];
	<span class="enscript-type">int</span> extra = 0;
	size_t charcnt;
	<span class="enscript-type">int</span> swapbytes = (flags &amp; UTF_REVERSE_ENDIAN);
	<span class="enscript-type">int</span> nullterm  = ((flags &amp; UTF_NO_NULL_TERM) == 0);
	<span class="enscript-type">int</span> decompose = (flags &amp; UTF_DECOMPOSED);
	<span class="enscript-type">int</span> sfmconv = (flags &amp; UTF_SFM_CONVERSIONS);
	<span class="enscript-type">int</span> result = 0;

	bufstart = utf8p;
	bufend = bufstart + buflen;
	<span class="enscript-keyword">if</span> (nullterm)
		--bufend;
	charcnt = ucslen / 2;

	<span class="enscript-keyword">while</span> (charcnt-- &gt; 0) {
		<span class="enscript-keyword">if</span> (extra &gt; 0) {
			--extra;
			ucs_ch = *chp++;
		} <span class="enscript-keyword">else</span> {
			ucs_ch = swapbytes ? OSSwapInt16(*ucsp++) : *ucsp++;

			<span class="enscript-keyword">if</span> (decompose &amp;&amp; unicode_decomposeable(ucs_ch)) {
				extra = unicode_decompose(ucs_ch, sequence) - 1;
				charcnt += extra;
				ucs_ch = sequence[0];
				chp = &amp;sequence[1];
			}
		}

		<span class="enscript-comment">/* Slash and NULL are not permitted */</span>
		<span class="enscript-keyword">if</span> (ucs_ch == <span class="enscript-string">'/'</span>) {
			<span class="enscript-keyword">if</span> (altslash)
				ucs_ch = altslash;
			<span class="enscript-keyword">else</span> {
				ucs_ch = <span class="enscript-string">'_'</span>;
				result = EINVAL;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ucs_ch == <span class="enscript-string">'\0'</span>) {
			ucs_ch = UCS_ALT_NULL;
		}

		<span class="enscript-keyword">if</span> (ucs_ch &lt; 0x0080) {
			<span class="enscript-keyword">if</span> (utf8p &gt;= bufend) {
				result = ENAMETOOLONG;
				<span class="enscript-keyword">break</span>;
			}			
			*utf8p++ = ucs_ch;

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ucs_ch &lt; 0x800) {
			<span class="enscript-keyword">if</span> ((utf8p + 1) &gt;= bufend) {
				result = ENAMETOOLONG;
				<span class="enscript-keyword">break</span>;
			}
			*utf8p++ = 0xc0 | (ucs_ch &gt;&gt; 6);
			*utf8p++ = 0x80 | (0x3f &amp; ucs_ch);

		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* These chars never valid Unicode. */</span>
			<span class="enscript-keyword">if</span> (ucs_ch == 0xFFFE || ucs_ch == 0xFFFF) {
				result = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/* Combine valid surrogate pairs */</span>
			<span class="enscript-keyword">if</span> (ucs_ch &gt;= SP_HIGH_FIRST &amp;&amp; ucs_ch &lt;= SP_HIGH_LAST
				&amp;&amp; charcnt &gt; 0) {
				u_int16_t ch2;
				u_int32_t pair;

				ch2 = swapbytes ? OSSwapInt16(*ucsp) : *ucsp;
				<span class="enscript-keyword">if</span> (ch2 &gt;= SP_LOW_FIRST &amp;&amp; ch2 &lt;= SP_LOW_LAST) {
					pair = ((ucs_ch - SP_HIGH_FIRST) &lt;&lt; SP_HALF_SHIFT)
						+ (ch2 - SP_LOW_FIRST) + SP_HALF_BASE;
					<span class="enscript-keyword">if</span> ((utf8p + 3) &gt;= bufend) {
						result = ENAMETOOLONG;
						<span class="enscript-keyword">break</span>;
					}
					--charcnt;
					++ucsp;				
					*utf8p++ = 0xf0 | (pair &gt;&gt; 18);
					*utf8p++ = 0x80 | (0x3f &amp; (pair &gt;&gt; 12));
					*utf8p++ = 0x80 | (0x3f &amp; (pair &gt;&gt; 6));
					*utf8p++ = 0x80 | (0x3f &amp; pair);
					<span class="enscript-keyword">continue</span>;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sfmconv) {
				ucs_ch = sfm_to_ucs(ucs_ch);
				<span class="enscript-keyword">if</span> (ucs_ch &lt; 0x0080) {
					<span class="enscript-keyword">if</span> (utf8p &gt;= bufend) {
						result = ENAMETOOLONG;
						<span class="enscript-keyword">break</span>;
					}			
					*utf8p++ = ucs_ch;
					<span class="enscript-keyword">continue</span>;
				}
			}
			<span class="enscript-keyword">if</span> ((utf8p + 2) &gt;= bufend) {
				result = ENAMETOOLONG;
				<span class="enscript-keyword">break</span>;
			}
			*utf8p++ = 0xe0 | (ucs_ch &gt;&gt; 12);
			*utf8p++ = 0x80 | (0x3f &amp; (ucs_ch &gt;&gt; 6));
			*utf8p++ = 0x80 | (0x3f &amp; ucs_ch);
		}	
	}
	
	*utf8len = utf8p - bufstart;
	<span class="enscript-keyword">if</span> (nullterm)
		*utf8p++ = <span class="enscript-string">'\0'</span>;

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">// Pushes a character taking account of combining character sequences
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">push</span>(uint16_t ucs_ch, <span class="enscript-type">int</span> *combcharcnt, uint16_t **ucsp)
{
	<span class="enscript-comment">/*
	 * Make multiple combining character sequences canonical
	 */</span>
	<span class="enscript-keyword">if</span> (unicode_combinable(ucs_ch)) {
		++*combcharcnt;		<span class="enscript-comment">/* start tracking a run */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*combcharcnt) {
		<span class="enscript-keyword">if</span> (*combcharcnt &gt; 1) {
			prioritysort(*ucsp - *combcharcnt, *combcharcnt);
		}
		*combcharcnt = 0;	<span class="enscript-comment">/* start over */</span>
	}

	*(*ucsp)++ = ucs_ch;
}

<span class="enscript-comment">/*
 * utf8_decodestr - Decodes a UTF-8 string back to Unicode
 *
 * NOTES:
 *    The input UTF-8 string does not need to be null terminated
 *    if utf8len is set.
 *
 *    If '/' chars are allowed on disk then an alternate
 *    (replacement) char must be provided in altslash.
 *
 * input flags:
 *    UTF_REV_ENDIAN:  Unicode byte order is opposite current runtime
 *
 *    UTF_BIG_ENDIAN:  Unicode byte order is always big endian
 *
 *    UTF_LITTLE_ENDIAN:  Unicode byte order is always little endian
 *
 *    UTF_DECOMPOSED:  generate fully decomposed output (NFD)
 *
 *    UTF_PRECOMPOSED:  generate precomposed output (NFC)
 *
 *    UTF_ESCAPE_ILLEGAL:  percent escape any illegal UTF-8 input
 *
 * result:
 *    ENAMETOOLONG: Name didn't fit; only ucslen chars were decoded.
 *
 *    EINVAL: Illegal UTF-8 sequence found.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">utf8_decodestr</span>(<span class="enscript-type">const</span> u_int8_t* utf8p, size_t utf8len, u_int16_t* ucsp,
               size_t *ucslen, size_t buflen, u_int16_t altslash, <span class="enscript-type">int</span> flags)
{
	u_int16_t* bufstart;
	u_int16_t* bufend;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ucs_ch;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> byte;
	<span class="enscript-type">int</span> combcharcnt = 0;
	<span class="enscript-type">int</span> result = 0;
	<span class="enscript-type">int</span> decompose, precompose, escaping;
	<span class="enscript-type">int</span> sfmconv;
	<span class="enscript-type">int</span> extrabytes;

	decompose  = (flags &amp; UTF_DECOMPOSED);
	precompose = (flags &amp; UTF_PRECOMPOSED);
	escaping   = (flags &amp; UTF_ESCAPE_ILLEGAL);
	sfmconv    = (flags &amp; UTF_SFM_CONVERSIONS);

	bufstart = ucsp;
	bufend = (u_int16_t *)((u_int8_t *)ucsp + buflen);

	<span class="enscript-keyword">while</span> (utf8len-- &gt; 0 &amp;&amp; (byte = *utf8p++) != <span class="enscript-string">'\0'</span>) {
		<span class="enscript-keyword">if</span> (ucsp &gt;= bufend)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">toolong</span>;

		<span class="enscript-comment">/* check for ascii */</span>
		<span class="enscript-keyword">if</span> (byte &lt; 0x80) {
			ucs_ch = sfmconv ? ucs_to_sfm(byte, utf8len == 0) : byte;
		} <span class="enscript-keyword">else</span> {
			u_int32_t ch;

			extrabytes = utf_extrabytes[byte &gt;&gt; 3];
			<span class="enscript-keyword">if</span> ((extrabytes &lt; 0) || ((<span class="enscript-type">int</span>)utf8len &lt; extrabytes)) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape</span>;
			}
			utf8len -= extrabytes;

			<span class="enscript-keyword">switch</span> (extrabytes) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
				ch = byte; ch &lt;&lt;= 6;   <span class="enscript-comment">/* 1st byte */</span>
				byte = *utf8p++;       <span class="enscript-comment">/* 2nd byte */</span>
				<span class="enscript-keyword">if</span> ((byte &gt;&gt; 6) != 2)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape2</span>;
				ch += byte;
				ch -= 0x00003080UL;
				<span class="enscript-keyword">if</span> (ch &lt; 0x0080)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape2</span>;
				ucs_ch = ch;
			        <span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
				ch = byte; ch &lt;&lt;= 6;   <span class="enscript-comment">/* 1st byte */</span>
				byte = *utf8p++;       <span class="enscript-comment">/* 2nd byte */</span>
				<span class="enscript-keyword">if</span> ((byte &gt;&gt; 6) != 2)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape2</span>;
				ch += byte; ch &lt;&lt;= 6;
				byte = *utf8p++;       <span class="enscript-comment">/* 3rd byte */</span>
				<span class="enscript-keyword">if</span> ((byte &gt;&gt; 6) != 2)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape3</span>;
				ch += byte;
				ch -= 0x000E2080UL;
				<span class="enscript-keyword">if</span> (ch &lt; 0x0800)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape3</span>;
				<span class="enscript-keyword">if</span> (ch &gt;= 0xD800) {
					<span class="enscript-keyword">if</span> (ch &lt;= 0xDFFF)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape3</span>;
					<span class="enscript-keyword">if</span> (ch == 0xFFFE || ch == 0xFFFF)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape3</span>;
				}
				ucs_ch = ch;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
				ch = byte; ch &lt;&lt;= 6;   <span class="enscript-comment">/* 1st byte */</span>
				byte = *utf8p++;       <span class="enscript-comment">/* 2nd byte */</span>
				<span class="enscript-keyword">if</span> ((byte &gt;&gt; 6) != 2)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape2</span>;
				ch += byte; ch &lt;&lt;= 6;
				byte = *utf8p++;       <span class="enscript-comment">/* 3rd byte */</span>
				<span class="enscript-keyword">if</span> ((byte &gt;&gt; 6) != 2)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape3</span>;
				ch += byte; ch &lt;&lt;= 6;
				byte = *utf8p++;       <span class="enscript-comment">/* 4th byte */</span>
				<span class="enscript-keyword">if</span> ((byte &gt;&gt; 6) != 2)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape4</span>;
			        ch += byte;
				ch -= 0x03C82080UL + SP_HALF_BASE;
				ucs_ch = (ch &gt;&gt; SP_HALF_SHIFT) + SP_HIGH_FIRST;
				<span class="enscript-keyword">if</span> (ucs_ch &lt; SP_HIGH_FIRST || ucs_ch &gt; SP_HIGH_LAST)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape4</span>;
				push(ucs_ch, &amp;combcharcnt, &amp;ucsp);
				<span class="enscript-keyword">if</span> (ucsp &gt;= bufend)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">toolong</span>;
				ucs_ch = (ch &amp; SP_HALF_MASK) + SP_LOW_FIRST;
				<span class="enscript-keyword">if</span> (ucs_ch &lt; SP_LOW_FIRST || ucs_ch &gt; SP_LOW_LAST) {
					--ucsp;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape4</span>;
				}
				*ucsp++ = ucs_ch;
			        <span class="enscript-keyword">continue</span>;
			<span class="enscript-reference">default</span>:
				result = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}
			<span class="enscript-keyword">if</span> (decompose) {
				<span class="enscript-keyword">if</span> (unicode_decomposeable(ucs_ch)) {
					u_int16_t sequence[8];
					<span class="enscript-type">int</span> count, i;

					count = unicode_decompose(ucs_ch, sequence);

					<span class="enscript-keyword">for</span> (i = 0; i &lt; count; ++i) {
						<span class="enscript-keyword">if</span> (ucsp &gt;= bufend)
							<span class="enscript-keyword">goto</span> <span class="enscript-reference">toolong</span>;

						push(sequence[i], &amp;combcharcnt, &amp;ucsp);
					}

					<span class="enscript-keyword">continue</span>;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (precompose &amp;&amp; (ucsp != bufstart)) {
				u_int16_t composite, base;

				<span class="enscript-keyword">if</span> (unicode_combinable(ucs_ch)) {
					base = ucsp[-1];
					composite = unicode_combine(base, ucs_ch);
					<span class="enscript-keyword">if</span> (composite) {
						--ucsp;
						ucs_ch = composite;
					}
				}
			}
			<span class="enscript-keyword">if</span> (ucs_ch == UCS_ALT_NULL)
				ucs_ch = <span class="enscript-string">'\0'</span>;
		}
		<span class="enscript-keyword">if</span> (ucs_ch == altslash)
			ucs_ch = <span class="enscript-string">'/'</span>;

		push(ucs_ch, &amp;combcharcnt, &amp;ucsp);
		<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* 
		 * Escape illegal UTF-8 into something legal.
		 */</span>
<span class="enscript-reference">escape4</span>:
		utf8p -= 3;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape</span>;
<span class="enscript-reference">escape3</span>:
		utf8p -= 2;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">escape</span>;
<span class="enscript-reference">escape2</span>:
		utf8p -= 1;
<span class="enscript-reference">escape</span>:
		<span class="enscript-keyword">if</span> (!escaping) {
			result = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		<span class="enscript-keyword">if</span> (extrabytes &gt; 0)
			utf8len += extrabytes;
		byte = *(utf8p - 1);

		<span class="enscript-keyword">if</span> ((ucsp + 2) &gt;= bufend)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">toolong</span>;

		<span class="enscript-comment">/* Make a previous combining sequence canonical. */</span>
		<span class="enscript-keyword">if</span> (combcharcnt &gt; 1) {
			prioritysort(ucsp - combcharcnt, combcharcnt);
		}
		combcharcnt = 0;
		
		ucs_ch = <span class="enscript-string">'%'</span>;
		*ucsp++ = ucs_ch;
		ucs_ch =  hexdigits[byte &gt;&gt; 4];
		*ucsp++ = ucs_ch;
		ucs_ch =  hexdigits[byte &amp; 0x0F];
		*ucsp++ = ucs_ch;
	}
	<span class="enscript-comment">/*
	 * Make a previous combining sequence canonical
	 */</span>
	<span class="enscript-keyword">if</span> (combcharcnt &gt; 1) {
		prioritysort(ucsp - combcharcnt, combcharcnt);
	}

	<span class="enscript-keyword">if</span> (flags &amp; UTF_REVERSE_ENDIAN) {
		uint16_t *p = bufstart;
		<span class="enscript-keyword">while</span> (p &lt; ucsp) {
			*p = OSSwapInt16(*p);
			++p;
		}
	}

<span class="enscript-reference">exit</span>:
	*ucslen = (u_int8_t*)ucsp - (u_int8_t*)bufstart;

	<span class="enscript-keyword">return</span> (result);

<span class="enscript-reference">toolong</span>:
	result = ENAMETOOLONG;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
}


<span class="enscript-comment">/*
 * utf8_validatestr - Check for a valid UTF-8 string.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">utf8_validatestr</span>(<span class="enscript-type">const</span> u_int8_t* utf8p, size_t utf8len)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> byte;
	u_int32_t ch;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ucs_ch;
	size_t extrabytes;

	<span class="enscript-keyword">while</span> (utf8len-- &gt; 0 &amp;&amp; (byte = *utf8p++) != <span class="enscript-string">'\0'</span>) {
		<span class="enscript-keyword">if</span> (byte &lt; 0x80)
			<span class="enscript-keyword">continue</span>;  <span class="enscript-comment">/* plain ascii */</span>

		extrabytes = utf_extrabytes[byte &gt;&gt; 3];

		<span class="enscript-keyword">if</span> (utf8len &lt; extrabytes)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
		utf8len -= extrabytes;

		<span class="enscript-keyword">switch</span> (extrabytes) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
			ch = byte; ch &lt;&lt;= 6;   <span class="enscript-comment">/* 1st byte */</span>
			byte = *utf8p++;       <span class="enscript-comment">/* 2nd byte */</span>
			<span class="enscript-keyword">if</span> ((byte &gt;&gt; 6) != 2)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
			ch += byte;
			ch -= 0x00003080UL;
			<span class="enscript-keyword">if</span> (ch &lt; 0x0080)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
			ch = byte; ch &lt;&lt;= 6;   <span class="enscript-comment">/* 1st byte */</span>
			byte = *utf8p++;       <span class="enscript-comment">/* 2nd byte */</span>
			<span class="enscript-keyword">if</span> ((byte &gt;&gt; 6) != 2)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
			ch += byte; ch &lt;&lt;= 6;
			byte = *utf8p++;       <span class="enscript-comment">/* 3rd byte */</span>
			<span class="enscript-keyword">if</span> ((byte &gt;&gt; 6) != 2)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
			ch += byte;
			ch -= 0x000E2080UL;
			<span class="enscript-keyword">if</span> (ch &lt; 0x0800)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
			<span class="enscript-keyword">if</span> (ch &gt;= 0xD800) {
				<span class="enscript-keyword">if</span> (ch &lt;= 0xDFFF)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
				<span class="enscript-keyword">if</span> (ch == 0xFFFE || ch == 0xFFFF)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
			ch = byte; ch &lt;&lt;= 6;   <span class="enscript-comment">/* 1st byte */</span>
			byte = *utf8p++;       <span class="enscript-comment">/* 2nd byte */</span>
			<span class="enscript-keyword">if</span> ((byte &gt;&gt; 6) != 2)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
			ch += byte; ch &lt;&lt;= 6;
			byte = *utf8p++;       <span class="enscript-comment">/* 3rd byte */</span>
			<span class="enscript-keyword">if</span> ((byte &gt;&gt; 6) != 2)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
			ch += byte; ch &lt;&lt;= 6;
			byte = *utf8p++;       <span class="enscript-comment">/* 4th byte */</span>
			<span class="enscript-keyword">if</span> ((byte &gt;&gt; 6) != 2)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
			ch += byte;
			ch -= 0x03C82080UL + SP_HALF_BASE;
			ucs_ch = (ch &gt;&gt; SP_HALF_SHIFT) + SP_HIGH_FIRST;
			<span class="enscript-keyword">if</span> (ucs_ch &lt; SP_HIGH_FIRST || ucs_ch &gt; SP_HIGH_LAST)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
			ucs_ch = (ch &amp; SP_HALF_MASK) + SP_LOW_FIRST;
			<span class="enscript-keyword">if</span> (ucs_ch &lt; SP_LOW_FIRST || ucs_ch &gt; SP_LOW_LAST)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">invalid</span>;
		}
		
	}
	<span class="enscript-keyword">return</span> (0);
<span class="enscript-reference">invalid</span>:
	<span class="enscript-keyword">return</span> (EINVAL);
}

<span class="enscript-comment">/*
 * utf8_normalizestr - Normalize a UTF-8 string (NFC or NFD)
 *
 * This function takes an UTF-8 input string, instr, of inlen bytes
 * and produces normalized UTF-8 output into a buffer of buflen bytes
 * pointed to by outstr. The size of the output in bytes (not including
 * a NULL termination byte) is returned in outlen. In-place conversions
 * are not supported (i.e. instr != outstr).]
 
 * FLAGS
 *    UTF_DECOMPOSED:  output string will be fully decomposed (NFD)
 *
 *    UTF_PRECOMPOSED:  output string will be precomposed (NFC)
 *
 *    UTF_NO_NULL_TERM:  do not add null termination to output string
 *
 *    UTF_ESCAPE_ILLEGAL:  percent escape any illegal UTF-8 input
 *
 * ERRORS
 *    ENAMETOOLONG:  output did not fit or input exceeded MAXPATHLEN bytes
 *
 *    EINVAL:  illegal UTF-8 sequence encountered or invalid flags
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">utf8_normalizestr</span>(<span class="enscript-type">const</span> u_int8_t* instr, size_t inlen, u_int8_t* outstr,
                  size_t *outlen, size_t buflen, <span class="enscript-type">int</span> flags)
{
	u_int16_t unicodebuf[32];
	u_int16_t* unistr = NULL;
	size_t unicode_bytes;
	size_t uft8_bytes;
	size_t inbuflen;
	u_int8_t *outbufstart, *outbufend;
	<span class="enscript-type">const</span> u_int8_t *inbufstart;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> byte;
	<span class="enscript-type">int</span> decompose, precompose;
	<span class="enscript-type">int</span> result = 0;

	<span class="enscript-keyword">if</span> (flags &amp; ~(UTF_DECOMPOSED | UTF_PRECOMPOSED | UTF_NO_NULL_TERM | UTF_ESCAPE_ILLEGAL)) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	decompose = (flags &amp; UTF_DECOMPOSED);
	precompose = (flags &amp; UTF_PRECOMPOSED);
	<span class="enscript-keyword">if</span> ((decompose &amp;&amp; precompose) || (!decompose &amp;&amp; !precompose)) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	outbufstart = outstr;
	outbufend = outbufstart + buflen;
	inbufstart = instr;
	inbuflen = inlen;

	<span class="enscript-keyword">while</span> (inlen-- &gt; 0 &amp;&amp; (byte = *instr++) != <span class="enscript-string">'\0'</span>) {
		<span class="enscript-keyword">if</span> (outstr &gt;= outbufend) {
			result = ENAMETOOLONG;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		<span class="enscript-keyword">if</span> (byte &gt;= 0x80) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nonASCII</span>;
		}
		<span class="enscript-comment">/* ASCII is already normalized. */</span>
		*outstr++ = byte;
	}
<span class="enscript-reference">exit</span>:
	*outlen = outstr - outbufstart;
	<span class="enscript-keyword">if</span> (((flags &amp; UTF_NO_NULL_TERM) == 0)) {
		<span class="enscript-keyword">if</span> (outstr &lt; outbufend)
			*outstr++ = <span class="enscript-string">'\0'</span>;
		<span class="enscript-keyword">else</span>
			result = ENAMETOOLONG;
	}
	<span class="enscript-keyword">return</span> (result);


	<span class="enscript-comment">/* 
	 * Non-ASCII uses the existing utf8_encodestr/utf8_decodestr
	 * functions to perform the normalization.  Since this will
	 * presumably be used to normalize filenames in the back-end
	 * (on disk or over-the-wire), it should be fast enough.
	 */</span>
<span class="enscript-reference">nonASCII</span>:

	<span class="enscript-comment">/* Make sure the input size is reasonable. */</span>
	<span class="enscript-keyword">if</span> (inbuflen &gt; MAXPATHLEN) {
		result = ENAMETOOLONG;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	<span class="enscript-comment">/*
	 * Compute worst case Unicode buffer size.
	 *
	 * For pre-composed output, every UTF-8 input byte will be at
	 * most 2 Unicode bytes.  For decomposed output, 2 UTF-8 bytes
	 * (smallest composite char sequence) may yield 6 Unicode bytes
	 * (1 base char + 2 combining chars).
	 */</span>
	unicode_bytes = precompose ? (inbuflen * 2) : (inbuflen * 3);

	<span class="enscript-keyword">if</span> (unicode_bytes &lt;= <span class="enscript-keyword">sizeof</span>(unicodebuf))
		unistr = &amp;unicodebuf[0];
	<span class="enscript-keyword">else</span>
		MALLOC(unistr, uint16_t *, unicode_bytes, M_TEMP, M_WAITOK);

	<span class="enscript-comment">/* Normalize the string. */</span>
	result = utf8_decodestr(inbufstart, inbuflen, unistr, &amp;unicode_bytes,
	                        unicode_bytes, 0, flags &amp; ~UTF_NO_NULL_TERM);
	<span class="enscript-keyword">if</span> (result == 0) {
		<span class="enscript-comment">/* Put results back into UTF-8. */</span>
		result = utf8_encodestr(unistr, unicode_bytes, outbufstart,
		                        &amp;uft8_bytes, buflen, 0, UTF_NO_NULL_TERM);
		outstr = outbufstart + uft8_bytes;
	}
	<span class="enscript-keyword">if</span> (unistr &amp;&amp; unistr != &amp;unicodebuf[0]) {
		FREE(unistr, M_TEMP);
	}
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
}


 <span class="enscript-comment">/*
  * Unicode 3.2 decomposition code (derived from Core Foundation)
  */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	u_int32_t _key;
	u_int32_t _value;
} unicode_mappings32;

<span class="enscript-type">static</span> inline u_int32_t
<span class="enscript-function-name">getmappedvalue32</span>(<span class="enscript-type">const</span> unicode_mappings32 *theTable, u_int32_t numElem,
		u_int16_t character)
{
	<span class="enscript-type">const</span> unicode_mappings32 *p, *q, *divider;

	<span class="enscript-keyword">if</span> ((character &lt; theTable[0]._key) || (character &gt; theTable[numElem-1]._key))
		<span class="enscript-keyword">return</span> (0);

	p = theTable;
	q = p + (numElem-1);
	<span class="enscript-keyword">while</span> (p &lt;= q) {
		divider = p + ((q - p) &gt;&gt; 1);	<span class="enscript-comment">/* divide by 2 */</span>
		<span class="enscript-keyword">if</span> (character &lt; divider-&gt;_key) { q = divider - 1; }
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (character &gt; divider-&gt;_key) { p = divider + 1; }
		<span class="enscript-keyword">else</span> { <span class="enscript-keyword">return</span> (divider-&gt;_value); }
	}
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RECURSIVE_DECOMPOSITION</span>	(1 &lt;&lt; 15)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">EXTRACT_COUNT</span>(value)	(((value) &gt;&gt; 12) &amp; 0x0007)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	u_int16_t _key;
	u_int16_t _value;
} unicode_mappings16;

<span class="enscript-type">static</span> inline u_int16_t
<span class="enscript-function-name">getmappedvalue16</span>(<span class="enscript-type">const</span> unicode_mappings16 *theTable, u_int32_t numElem,
		u_int16_t character)
{
	<span class="enscript-type">const</span> unicode_mappings16 *p, *q, *divider;

	<span class="enscript-keyword">if</span> ((character &lt; theTable[0]._key) || (character &gt; theTable[numElem-1]._key))
		<span class="enscript-keyword">return</span> (0);

	p = theTable;
	q = p + (numElem-1);
	<span class="enscript-keyword">while</span> (p &lt;= q) {
		divider = p + ((q - p) &gt;&gt; 1);	<span class="enscript-comment">/* divide by 2 */</span>
		<span class="enscript-keyword">if</span> (character &lt; divider-&gt;_key)
			q = divider - 1;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (character &gt; divider-&gt;_key)
			p = divider + 1;
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> (divider-&gt;_value);
	}
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">unicode_recursive_decompose</span>(u_int16_t character, u_int16_t *convertedChars)
{
	u_int16_t value;
	u_int32_t length;
	u_int16_t firstChar;
	u_int16_t theChar;
	<span class="enscript-type">const</span> u_int16_t *bmpMappings;
	u_int32_t usedLength;

	value = getmappedvalue16(
		(<span class="enscript-type">const</span> unicode_mappings16 *)__CFUniCharDecompositionTable,
		__UniCharDecompositionTableLength, character);
	length = EXTRACT_COUNT(value);
	firstChar = value &amp; 0x0FFF;
	theChar = firstChar;
	bmpMappings = (length == 1 ? &amp;theChar : __CFUniCharMultipleDecompositionTable + firstChar);
	usedLength = 0;

	<span class="enscript-keyword">if</span> (value &amp; RECURSIVE_DECOMPOSITION) {
	    usedLength = unicode_recursive_decompose((u_int16_t)*bmpMappings, convertedChars);
	
	    --length;	<span class="enscript-comment">/* Decrement for the first char */</span>
	    <span class="enscript-keyword">if</span> (!usedLength)
	    	<span class="enscript-keyword">return</span> 0;
	    ++bmpMappings;
	    convertedChars += usedLength;
	}
	
	usedLength += length;
	
	<span class="enscript-keyword">while</span> (length--)
		*(convertedChars++) = *(bmpMappings++);
	
	<span class="enscript-keyword">return</span> (usedLength);
}
    
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HANGUL_SBASE</span> 0xAC00
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HANGUL_LBASE</span> 0x1100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HANGUL_VBASE</span> 0x1161
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HANGUL_TBASE</span> 0x11A7

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HANGUL_SCOUNT</span> 11172
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HANGUL_LCOUNT</span> 19
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HANGUL_VCOUNT</span> 21
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HANGUL_TCOUNT</span> 28
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HANGUL_NCOUNT</span> (HANGUL_VCOUNT * HANGUL_TCOUNT)

<span class="enscript-comment">/*
 * unicode_decompose - decompose a composed Unicode char
 *
 * Composed Unicode characters are forbidden on
 * HFS Plus volumes. ucs_decompose will convert a
 * composed character into its correct decomposed
 * sequence.
 *
 * Similar to CFUniCharDecomposeCharacter
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">unicode_decompose</span>(u_int16_t character, u_int16_t *convertedChars)
{
	<span class="enscript-keyword">if</span> ((character &gt;= HANGUL_SBASE) &amp;&amp;
	    (character &lt;= (HANGUL_SBASE + HANGUL_SCOUNT))) {
		u_int32_t length;

		character -= HANGUL_SBASE;
		length = (character % HANGUL_TCOUNT ? 3 : 2);

		*(convertedChars++) =
			character / HANGUL_NCOUNT + HANGUL_LBASE;
		*(convertedChars++) =
			(character % HANGUL_NCOUNT) / HANGUL_TCOUNT + HANGUL_VBASE;
		<span class="enscript-keyword">if</span> (length &gt; 2)
			*convertedChars = (character % HANGUL_TCOUNT) + HANGUL_TBASE;
		<span class="enscript-keyword">return</span> (length);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (unicode_recursive_decompose(character, convertedChars));
	}
}

<span class="enscript-comment">/*
 * unicode_combine - generate a precomposed Unicode char
 *
 * Precomposed Unicode characters are required for some volume
 * formats and network protocols.  unicode_combine will combine
 * a decomposed character sequence into a single precomposed
 * (composite) character.
 *
 * Similar toCFUniCharPrecomposeCharacter but unicode_combine
 * also handles Hangul Jamo characters.
 */</span>
<span class="enscript-type">static</span> u_int16_t
<span class="enscript-function-name">unicode_combine</span>(u_int16_t base, u_int16_t combining)
{
	u_int32_t value;

	<span class="enscript-comment">/* Check HANGUL */</span>
	<span class="enscript-keyword">if</span> ((combining &gt;= HANGUL_VBASE) &amp;&amp; (combining &lt; (HANGUL_TBASE + HANGUL_TCOUNT))) {
		<span class="enscript-comment">/* 2 char Hangul sequences */</span>
		<span class="enscript-keyword">if</span> ((combining &lt; (HANGUL_VBASE + HANGUL_VCOUNT)) &amp;&amp;
		    (base &gt;= HANGUL_LBASE &amp;&amp; base &lt; (HANGUL_LBASE + HANGUL_LCOUNT))) {
		    <span class="enscript-keyword">return</span> (HANGUL_SBASE +
		            ((base - HANGUL_LBASE)*(HANGUL_VCOUNT*HANGUL_TCOUNT)) +
		            ((combining  - HANGUL_VBASE)*HANGUL_TCOUNT));
		}
	
		<span class="enscript-comment">/* 3 char Hangul sequences */</span>
		<span class="enscript-keyword">if</span> ((combining &gt; HANGUL_TBASE) &amp;&amp;
		    (base &gt;= HANGUL_SBASE &amp;&amp; base &lt; (HANGUL_SBASE + HANGUL_SCOUNT))) {
			<span class="enscript-keyword">if</span> ((base - HANGUL_SBASE) % HANGUL_TCOUNT)
				<span class="enscript-keyword">return</span> (0);
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">return</span> (base + (combining - HANGUL_TBASE));
		}
	}

	value = getmappedvalue32(
		(<span class="enscript-type">const</span> unicode_mappings32 *)__CFUniCharPrecompSourceTable,
		__CFUniCharPrecompositionTableLength, combining);

	<span class="enscript-keyword">if</span> (value) {
		value = getmappedvalue16(
			(<span class="enscript-type">const</span> unicode_mappings16 *)
			((<span class="enscript-type">const</span> u_int32_t *)__CFUniCharBMPPrecompDestinationTable + (value &amp; 0xFFFF)),
			(value &gt;&gt; 16), base);
	}
	<span class="enscript-keyword">return</span> (value);
}


<span class="enscript-comment">/*
 * prioritysort - order combining chars into canonical order
 *
 * Similar to CFUniCharPrioritySort
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">prioritysort</span>(u_int16_t* characters, <span class="enscript-type">int</span> count)
{
	u_int32_t p1, p2;
	u_int16_t *ch1, *ch2;
	u_int16_t *end;
	<span class="enscript-type">int</span> changes = 0;

	end = characters + count;
	<span class="enscript-keyword">do</span> {
		changes = 0;
		ch1 = characters;
		ch2 = characters + 1;
		p2 = get_combining_class(*ch1);
		<span class="enscript-keyword">while</span> (ch2 &lt; end) {
			p1 = p2;
			p2 = get_combining_class(*ch2);
			<span class="enscript-keyword">if</span> (p1 &gt; p2 &amp;&amp; p2 != 0) {
				u_int32_t tmp;

				tmp = *ch1;
				*ch1 = *ch2;
				*ch2 = tmp;
				changes = 1;
				
				<span class="enscript-comment">/*
				 * Make sure that p2 contains the combining class for the
				 * character now stored at *ch2.  This isn't required for
				 * correctness, but it will be more efficient if a character
				 * with a large combining class has to &quot;bubble past&quot; several
				 * characters with lower combining classes.
				 */</span>
				p2 = p1;
			}
			++ch1;
			++ch2;
		}
	} <span class="enscript-keyword">while</span> (changes);
}


<span class="enscript-comment">/*
 * Invalid NTFS filename characters are encodeded using the
 * SFM (Services for Macintosh) private use Unicode characters.
 *
 * These should only be used for SMB, MSDOS or NTFS.
 *
 *    Illegal NTFS Char   SFM Unicode Char
 *  ----------------------------------------
 *    0x01-0x1f           0xf001-0xf01f
 *    '&quot;'                 0xf020
 *    '*'                 0xf021
 *    '/'                 0xf022
 *    '&lt;'                 0xf023
 *    '&gt;'                 0xf024
 *    '?'                 0xf025
 *    '\'                 0xf026
 *    '|'                 0xf027
 *    ' '                 0xf028  (Only if last char of the name)
 *    '.'                 0xf029  (Only if last char of the name)
 *  ----------------------------------------
 *
 *  Reference: <a href="http://support.microsoft.com/kb/q117258/">http://support.microsoft.com/kb/q117258/</a>
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_SFM2MAC</span>           0x29
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SFMCODE_PREFIX_MASK</span>   0xf000 

<span class="enscript-comment">/*
 * In the Mac OS 9 days the colon was illegal in a file name. For that reason
 * SFM had no conversion for the colon. There is a conversion for the
 * slash. In Mac OS X the slash is illegal in a file name. So for us the colon
 * is a slash and a slash is a colon. So we can just replace the slash with the
 * colon in our tables and everything will just work. 
 */</span>
<span class="enscript-type">static</span> u_int8_t
sfm2mac[42] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,   <span class="enscript-comment">/* 00 - 07 */</span>
	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,   <span class="enscript-comment">/* 08 - 0F */</span>
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,   <span class="enscript-comment">/* 10 - 17 */</span>
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,   <span class="enscript-comment">/* 18 - 1F */</span>
	0x22, 0x2a, 0x3a, 0x3c, 0x3e, 0x3f, 0x5c, 0x7c,   <span class="enscript-comment">/* 20 - 27 */</span>
	0x20, 0x2e                                        <span class="enscript-comment">/* 28 - 29 */</span>
};

<span class="enscript-type">static</span> u_int8_t
mac2sfm[112] = {
	0x20, 0x21, 0x20, 0x23, 0x24, 0x25, 0x26, 0x27,	  <span class="enscript-comment">/* 20 - 27 */</span>
	0x28, 0x29, 0x21, 0x2b, 0x2c, 0x2d, 0x2e, 0x22,   <span class="enscript-comment">/* 28 - 2f */</span>
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,   <span class="enscript-comment">/* 30 - 37 */</span>
	0x38, 0x39, 0x22, 0x3b, 0x23, 0x3d, 0x24, 0x25,   <span class="enscript-comment">/* 38 - 3f */</span>
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,   <span class="enscript-comment">/* 40 - 47 */</span>
	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,   <span class="enscript-comment">/* 48 - 4f */</span>
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,   <span class="enscript-comment">/* 50 - 57 */</span>
	0x58, 0x59, 0x5a, 0x5b, 0x26, 0x5d, 0x5e, 0x5f,   <span class="enscript-comment">/* 58 - 5f */</span>
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,   <span class="enscript-comment">/* 60 - 67 */</span>
	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,   <span class="enscript-comment">/* 68 - 6f */</span>
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,   <span class="enscript-comment">/* 70 - 77 */</span>
	0x78, 0x79, 0x7a, 0x7b, 0x27, 0x7d, 0x7e, 0x7f    <span class="enscript-comment">/* 78 - 7f */</span>
};


<span class="enscript-comment">/*
 * Encode illegal NTFS filename characters into SFM Private Unicode characters
 *
 * Assumes non-zero ASCII input.
 */</span>
<span class="enscript-type">static</span> u_int16_t
<span class="enscript-function-name">ucs_to_sfm</span>(u_int16_t ucs_ch, <span class="enscript-type">int</span> lastchar)
{
	<span class="enscript-comment">/* The last character of filename cannot be a space or period. */</span>
	<span class="enscript-keyword">if</span> (lastchar) {
		<span class="enscript-keyword">if</span> (ucs_ch == 0x20)
			<span class="enscript-keyword">return</span> (0xf028);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ucs_ch == 0x2e)
			<span class="enscript-keyword">return</span> (0xf029);
	}
	<span class="enscript-comment">/* 0x01 - 0x1f is simple transformation. */</span>
	<span class="enscript-keyword">if</span> (ucs_ch &lt;= 0x1f) {
		<span class="enscript-keyword">return</span> (ucs_ch | 0xf000);
	} <span class="enscript-keyword">else</span> <span class="enscript-comment">/* 0x20 - 0x7f */</span> {
		u_int16_t lsb;

		lsb = mac2sfm[ucs_ch - 0x0020];
		<span class="enscript-keyword">if</span> (lsb != ucs_ch)
			<span class="enscript-keyword">return</span>(0xf000 | lsb); 
	}
	<span class="enscript-keyword">return</span> (ucs_ch);
}

<span class="enscript-comment">/*
 * Decode any SFM Private Unicode characters
 */</span>
<span class="enscript-type">static</span> u_int16_t
<span class="enscript-function-name">sfm_to_ucs</span>(u_int16_t ucs_ch)
{
	<span class="enscript-keyword">if</span> (((ucs_ch &amp; 0xffC0) == SFMCODE_PREFIX_MASK) &amp;&amp; 
	    ((ucs_ch &amp; 0x003f) &lt;= MAX_SFM2MAC)) {
		ucs_ch = sfm2mac[ucs_ch &amp; 0x003f];
	}
	<span class="enscript-keyword">return</span> (ucs_ch);
}


</pre>
<hr />
</body></html>