<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_cache.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_cache.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Poul-Henning Kamp of the FreeBSD Project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *
 *	@(#)vfs_cache.c	8.5 (Berkeley) 3/22/95
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/paths.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Name caching works as follows:
 *
 * Names found by directory scans are retained in a cache
 * for future reference.  It is managed LRU, so frequently
 * used names will hang around.  Cache is indexed by hash value
 * obtained from (vp, name) where vp refers to the directory
 * containing name.
 *
 * If it is a &quot;negative&quot; entry, (i.e. for a name that is known NOT to
 * exist) the vnode pointer will be NULL.
 *
 * Upon reaching the last segment of a path, if the reference
 * is for DELETE, or NOCACHE is set (rewrite), and the
 * name is located in the cache, it will be dropped.
 */</span>

<span class="enscript-comment">/*
 * Structures associated with name cacheing.
 */</span>

<span class="enscript-function-name">LIST_HEAD</span>(nchashhead, namecache) *nchashtbl;	<span class="enscript-comment">/* Hash Table */</span>
u_long	nchashmask;
u_long	nchash;				<span class="enscript-comment">/* size of hash table - 1 */</span>
<span class="enscript-type">long</span>	numcache;			<span class="enscript-comment">/* number of cache entries allocated */</span>
<span class="enscript-type">int</span> 	desiredNodes;
<span class="enscript-type">int</span> 	desiredNegNodes;
<span class="enscript-type">int</span>	ncs_negtotal;
<span class="enscript-type">int</span>	nc_disabled = 0;
<span class="enscript-function-name">TAILQ_HEAD</span>(, namecache) nchead;		<span class="enscript-comment">/* chain of all name cache entries */</span>
<span class="enscript-function-name">TAILQ_HEAD</span>(, namecache) neghead;	<span class="enscript-comment">/* chain of only negative cache entries */</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COLLECT_STATS</span>

<span class="enscript-type">struct</span>	nchstats nchstats;		<span class="enscript-comment">/* cache effectiveness statistics */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NCHSTAT</span>(v) {		\
        nchstats.v++;		\
}
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NAME_CACHE_LOCK</span>()		name_cache_lock()
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NAME_CACHE_UNLOCK</span>()		name_cache_unlock()
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NAME_CACHE_LOCK_SHARED</span>()	name_cache_lock()

#<span class="enscript-reference">else</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NCHSTAT</span>(v)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NAME_CACHE_LOCK</span>()		name_cache_lock()
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NAME_CACHE_UNLOCK</span>()		name_cache_unlock()
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NAME_CACHE_LOCK_SHARED</span>()	name_cache_lock_shared()

#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* vars for name cache list lock */</span>
lck_grp_t * namecache_lck_grp;
lck_grp_attr_t * namecache_lck_grp_attr;
lck_attr_t * namecache_lck_attr;

lck_grp_t * strcache_lck_grp;
lck_grp_attr_t * strcache_lck_grp_attr;
lck_attr_t * strcache_lck_attr;

lck_rw_t  * namecache_rw_lock;
lck_rw_t  * strtable_rw_lock;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NUM_STRCACHE_LOCKS</span> 1024

lck_mtx_t strcache_mtx_locks[NUM_STRCACHE_LOCKS];


<span class="enscript-type">static</span> vnode_t <span class="enscript-function-name">cache_lookup_locked</span>(vnode_t dvp, <span class="enscript-type">struct</span> componentname *cnp);
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">add_name_internal</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, uint32_t, u_int, boolean_t, u_int);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">init_string_table</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cache_delete</span>(<span class="enscript-type">struct</span> namecache *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cache_enter_locked</span>(vnode_t dvp, vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *strname);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DUMP_STRING_TABLE</span>
<span class="enscript-comment">/*
 * Internal dump function used for debugging
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">dump_string_table</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* DUMP_STRING_TABLE */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">init_crc32</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> crc32tab[256];


#<span class="enscript-reference">define</span> <span class="enscript-function-name">NCHHASH</span>(dvp, hash_val) \
	(&amp;nchashtbl[(dvp-&gt;v_id ^ (hash_val)) &amp; nchashmask])



<span class="enscript-comment">/*
 * This function builds the path to a filename in &quot;buff&quot;.  The
 * length of the buffer *INCLUDING* the trailing zero byte is
 * returned in outlen.  NOTE: the length includes the trailing
 * zero byte and thus the length is one greater than what strlen
 * would return.  This is important and lots of code elsewhere
 * in the kernel assumes this behavior.
 * 
 * This function can call vnop in file system if the parent vnode 
 * does not exist or when called for hardlinks via volfs path.  
 * If BUILDPATH_NO_FS_ENTER is set in flags, it only uses values present
 * in the name cache and does not enter the file system.
 *
 * If BUILDPATH_CHECK_MOVED is set in flags, we return EAGAIN when 
 * we encounter ENOENT during path reconstruction.  ENOENT means that 
 * one of the parents moved while we were building the path.  The 
 * caller can special handle this case by calling build_path again.
 *
 * If BUILDPATH_VOLUME_RELATIVE is set in flags, we return path 
 * that is relative to the nearest mount point, i.e. do not 
 * cross over mount points during building the path. 
 *
 * passed in vp must have a valid io_count reference
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">build_path</span>(vnode_t first_vp, <span class="enscript-type">char</span> *buff, <span class="enscript-type">int</span> buflen, <span class="enscript-type">int</span> *outlen, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
        vnode_t vp, tvp;
	vnode_t vp_with_iocount;
        vnode_t proc_root_dir_vp;
	<span class="enscript-type">char</span> *end;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *str;
	<span class="enscript-type">int</span>  len;
	<span class="enscript-type">int</span>  ret = 0;
	<span class="enscript-type">int</span>  fixhardlink;

	<span class="enscript-keyword">if</span> (first_vp == NULLVP)
		<span class="enscript-keyword">return</span> (EINVAL);
		
	<span class="enscript-keyword">if</span> (buflen &lt;= 1)
		<span class="enscript-keyword">return</span> (ENOSPC);

	<span class="enscript-comment">/*
	 * Grab the process fd so we can evaluate fd_rdir.
	 */</span>
	<span class="enscript-keyword">if</span> (vfs_context_proc(ctx)-&gt;p_fd)
		proc_root_dir_vp = vfs_context_proc(ctx)-&gt;p_fd-&gt;fd_rdir;
	<span class="enscript-keyword">else</span>
		proc_root_dir_vp = NULL;

	vp_with_iocount = NULLVP;
<span class="enscript-reference">again</span>:
	vp = first_vp;

	end = &amp;buff[buflen-1];
	*end = <span class="enscript-string">'\0'</span>;

	<span class="enscript-comment">/*
	 * holding the NAME_CACHE_LOCK in shared mode is
	 * sufficient to stabilize both the vp-&gt;v_parent chain
	 * and the 'vp-&gt;v_mount-&gt;mnt_vnodecovered' chain
	 *
	 * if we need to drop this lock, we must first grab the v_id
	 * from the vnode we're currently working with... if that
	 * vnode doesn't already have an io_count reference (the vp
	 * passed in comes with one), we must grab a reference
	 * after we drop the NAME_CACHE_LOCK via vnode_getwithvid...
	 * deadlocks may result if you call vnode_get while holding
	 * the NAME_CACHE_LOCK... we lazily release the reference
	 * we pick up the next time we encounter a need to drop 
	 * the NAME_CACHE_LOCK or before we return from this routine
	 */</span>
	NAME_CACHE_LOCK_SHARED();

	<span class="enscript-comment">/*
	 * Check if this is the root of a file system.
	 */</span>
	<span class="enscript-keyword">while</span> (vp &amp;&amp; vp-&gt;v_flag &amp; VROOT) {
		<span class="enscript-keyword">if</span> (vp-&gt;v_mount == NULL) {
			ret = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
		}
	        <span class="enscript-keyword">if</span> ((vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_ROOTFS) || (vp == proc_root_dir_vp)) {
			<span class="enscript-comment">/*
			 * It's the root of the root file system, so it's
			 * just &quot;/&quot;.
			 */</span>
		        *--end = <span class="enscript-string">'/'</span>;

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* 
			 * This the root of the volume and the caller does not 
			 * want to cross mount points.  Therefore just return 
			 * '/' as the relative path. 
			 */</span>
			<span class="enscript-keyword">if</span> (flags &amp; BUILDPATH_VOLUME_RELATIVE) {
				*--end = <span class="enscript-string">'/'</span>;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
			} <span class="enscript-keyword">else</span> {
				vp = vp-&gt;v_mount-&gt;mnt_vnodecovered;
			}
		}
	}

	<span class="enscript-keyword">while</span> ((vp != NULLVP) &amp;&amp; (vp-&gt;v_parent != vp)) {
		<span class="enscript-type">int</span>  vid;

		<span class="enscript-comment">/*
		 * For hardlinks the v_name may be stale, so if its OK
		 * to enter a file system, ask the file system for the
		 * name and parent (below).
		 */</span>
		fixhardlink = (vp-&gt;v_flag &amp; VISHARDLINK) &amp;&amp;
		              (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_PATH_FROM_ID) &amp;&amp;
		              !(flags &amp; BUILDPATH_NO_FS_ENTER);

		<span class="enscript-keyword">if</span> (!fixhardlink) {
			str = vp-&gt;v_name;

			<span class="enscript-keyword">if</span> (str == NULL || *str == <span class="enscript-string">'\0'</span>) {
				<span class="enscript-keyword">if</span> (vp-&gt;v_parent != NULL)
					ret = EINVAL;
				<span class="enscript-keyword">else</span>
					ret = ENOENT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
			}
			len = strlen(str);
			<span class="enscript-comment">/*
			 * Check that there's enough space (including space for the '/')
			 */</span>
			<span class="enscript-keyword">if</span> ((end - buff) &lt; (len + 1)) {
				ret = ENOSPC;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
			}
			<span class="enscript-comment">/*
			 * Copy the name backwards.
			 */</span>
			str += len;
	
			<span class="enscript-keyword">for</span> (; len &gt; 0; len--)
			       *--end = *--str;
			<span class="enscript-comment">/*
			 * Add a path separator.
			 */</span>
			*--end = <span class="enscript-string">'/'</span>;
		}

		<span class="enscript-comment">/*
		 * Walk up the parent chain.
		 */</span>
		<span class="enscript-keyword">if</span> (((vp-&gt;v_parent != NULLVP) &amp;&amp; !fixhardlink) ||
				(flags &amp; BUILDPATH_NO_FS_ENTER)) {

			<span class="enscript-comment">/*
			 * In this if () block we are not allowed to enter the filesystem
			 * to conclusively get the most accurate parent identifier.
			 * As a result, if 'vp' does not identify '/' and it
			 * does not have a valid v_parent, then error out
			 * and disallow further path construction
			 */</span>
			<span class="enscript-keyword">if</span> ((vp-&gt;v_parent == NULLVP) &amp;&amp; (rootvnode != vp)) {
				<span class="enscript-comment">/*
				 * Only '/' is allowed to have a NULL parent
				 * pointer. Upper level callers should ideally
				 * re-drive name lookup on receiving a ENOENT.
				 */</span>
				ret = ENOENT;

				<span class="enscript-comment">/* The code below will exit early if 'tvp = vp' == NULL */</span>
			}
			vp = vp-&gt;v_parent;

			<span class="enscript-comment">/*
			 * if the vnode we have in hand isn't a directory and it
			 * has a v_parent, then we started with the resource fork
			 * so skip up to avoid getting a duplicate copy of the
			 * file name in the path.
			 */</span>
			<span class="enscript-keyword">if</span> (vp &amp;&amp; !vnode_isdir(vp) &amp;&amp; vp-&gt;v_parent) {
				vp = vp-&gt;v_parent;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * No parent, go get it if supported.
			 */</span>
			<span class="enscript-type">struct</span> vnode_attr  va;
			vnode_t  dvp;

			<span class="enscript-comment">/*
			 * Make sure file system supports obtaining a path from id.
			 */</span>
			<span class="enscript-keyword">if</span> (!(vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_PATH_FROM_ID)) {
				ret = ENOENT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
			}
			vid = vp-&gt;v_id;

			NAME_CACHE_UNLOCK();

			<span class="enscript-keyword">if</span> (vp != first_vp &amp;&amp; vp != vp_with_iocount) {
				<span class="enscript-keyword">if</span> (vp_with_iocount) {
					vnode_put(vp_with_iocount);
					vp_with_iocount = NULLVP;
				}
				<span class="enscript-keyword">if</span> (vnode_getwithvid(vp, vid))
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
				vp_with_iocount = vp;
			}
			VATTR_INIT(&amp;va);
			VATTR_WANTED(&amp;va, va_parentid);

			<span class="enscript-keyword">if</span> (fixhardlink) {
				VATTR_WANTED(&amp;va, va_name);
				MALLOC_ZONE(va.va_name, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
			} <span class="enscript-keyword">else</span> {
				va.va_name = NULL;
			}
			<span class="enscript-comment">/*
			 * Ask the file system for its parent id and for its name (optional).
			 */</span>
			ret = vnode_getattr(vp, &amp;va, ctx);

			<span class="enscript-keyword">if</span> (fixhardlink) {
				<span class="enscript-keyword">if</span> ((ret == 0) &amp;&amp; (VATTR_IS_SUPPORTED(&amp;va, va_name))) {
					str = va.va_name;
					vnode_update_identity(vp, NULL, str, strlen(str), 0, VNODE_UPDATE_NAME);
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vp-&gt;v_name) {
					str = vp-&gt;v_name;
					ret = 0;
				} <span class="enscript-keyword">else</span> {
					ret = ENOENT;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_news</span>;
				}
				len = strlen(str);

				<span class="enscript-comment">/*
				 * Check that there's enough space.
				 */</span>
				<span class="enscript-keyword">if</span> ((end - buff) &lt; (len + 1)) {
					ret = ENOSPC;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* Copy the name backwards. */</span>
					str += len;

					<span class="enscript-keyword">for</span> (; len &gt; 0; len--) {
						*--end = *--str;
					}
					<span class="enscript-comment">/*
					 * Add a path separator.
					 */</span>
					*--end = <span class="enscript-string">'/'</span>;
				}
<span class="enscript-reference">bad_news</span>:
				FREE_ZONE(va.va_name, MAXPATHLEN, M_NAMEI);
			}
			<span class="enscript-keyword">if</span> (ret || !VATTR_IS_SUPPORTED(&amp;va, va_parentid)) {
				ret = ENOENT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-comment">/*
			 * Ask the file system for the parent vnode.
			 */</span>
			<span class="enscript-keyword">if</span> ((ret = VFS_VGET(vp-&gt;v_mount, (ino64_t)va.va_parentid, &amp;dvp, ctx)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

			<span class="enscript-keyword">if</span> (!fixhardlink &amp;&amp; (vp-&gt;v_parent != dvp))
				vnode_update_identity(vp, dvp, NULL, 0, 0, VNODE_UPDATE_PARENT);

			<span class="enscript-keyword">if</span> (vp_with_iocount)
				vnode_put(vp_with_iocount);
			vp = dvp;
			vp_with_iocount = vp;

			NAME_CACHE_LOCK_SHARED();

			<span class="enscript-comment">/*
			 * if the vnode we have in hand isn't a directory and it
			 * has a v_parent, then we started with the resource fork
			 * so skip up to avoid getting a duplicate copy of the
			 * file name in the path.
			 */</span>
			<span class="enscript-keyword">if</span> (vp &amp;&amp; !vnode_isdir(vp) &amp;&amp; vp-&gt;v_parent)
				vp = vp-&gt;v_parent;
		}

		<span class="enscript-comment">/*
		 * When a mount point is crossed switch the vp.
		 * Continue until we find the root or we find
		 * a vnode that's not the root of a mounted
		 * file system.
		 */</span>
		tvp = vp;

		<span class="enscript-keyword">while</span> (tvp) {
			<span class="enscript-keyword">if</span> (tvp == proc_root_dir_vp)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;	<span class="enscript-comment">/* encountered the root */</span>

			<span class="enscript-keyword">if</span> (!(tvp-&gt;v_flag &amp; VROOT) || !tvp-&gt;v_mount)
				<span class="enscript-keyword">break</span>;			<span class="enscript-comment">/* not the root of a mounted FS */</span>

			<span class="enscript-keyword">if</span> (flags &amp; BUILDPATH_VOLUME_RELATIVE) {
				<span class="enscript-comment">/* Do not cross over mount points */</span>
				tvp = NULL;
			} <span class="enscript-keyword">else</span> {
				tvp = tvp-&gt;v_mount-&gt;mnt_vnodecovered;
			}
		}
		<span class="enscript-keyword">if</span> (tvp == NULLVP)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
		vp = tvp;

		<span class="enscript-keyword">if</span> (vp &amp;&amp; (flags &amp; BUILDPATH_CHECKACCESS)) {
			vid = vp-&gt;v_id;

			NAME_CACHE_UNLOCK();

			<span class="enscript-keyword">if</span> (vp != first_vp &amp;&amp; vp != vp_with_iocount) {
				<span class="enscript-keyword">if</span> (vp_with_iocount) {
					vnode_put(vp_with_iocount);
					vp_with_iocount = NULLVP;
				}
				<span class="enscript-keyword">if</span> (vnode_getwithvid(vp, vid))
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
				vp_with_iocount = vp;
			}
			<span class="enscript-keyword">if</span> ((ret = vnode_authorize(vp, NULL, KAUTH_VNODE_SEARCH, ctx)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;  	<span class="enscript-comment">/* no peeking */</span>

			NAME_CACHE_LOCK_SHARED();
		}
	}
<span class="enscript-reference">out_unlock</span>:
	NAME_CACHE_UNLOCK();
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (vp_with_iocount)
		vnode_put(vp_with_iocount);
	<span class="enscript-comment">/*
	 * Slide the name down to the beginning of the buffer.
	 */</span>
	memmove(buff, end, &amp;buff[buflen] - end);

	<span class="enscript-comment">/*
	 * length includes the trailing zero byte
	 */</span>
	*outlen = &amp;buff[buflen] - end;
 
	<span class="enscript-comment">/* One of the parents was moved during path reconstruction. 
	 * The caller is interested in knowing whether any of the 
	 * parents moved via BUILDPATH_CHECK_MOVED, so return EAGAIN.
	 */</span>
	<span class="enscript-keyword">if</span> ((ret == ENOENT) &amp;&amp; (flags &amp; BUILDPATH_CHECK_MOVED)) {
		ret = EAGAIN;
	}

	<span class="enscript-keyword">return</span> (ret);
}


<span class="enscript-comment">/*
 * return NULLVP if vp's parent doesn't
 * exist, or we can't get a valid iocount
 * else return the parent of vp
 */</span>
vnode_t
<span class="enscript-function-name">vnode_getparent</span>(vnode_t vp)
{
        vnode_t pvp = NULLVP;
	<span class="enscript-type">int</span>	pvid;

	NAME_CACHE_LOCK_SHARED();
	<span class="enscript-comment">/*
	 * v_parent is stable behind the name_cache lock
	 * however, the only thing we can really guarantee
	 * is that we've grabbed a valid iocount on the
	 * parent of 'vp' at the time we took the name_cache lock...
	 * once we drop the lock, vp could get re-parented
	 */</span>
	<span class="enscript-keyword">if</span> ( (pvp = vp-&gt;v_parent) != NULLVP ) {
	        pvid = pvp-&gt;v_id;

		NAME_CACHE_UNLOCK();

		<span class="enscript-keyword">if</span> (vnode_getwithvid(pvp, pvid) != 0)
		        pvp = NULL;
	} <span class="enscript-keyword">else</span>
	        NAME_CACHE_UNLOCK();
	<span class="enscript-keyword">return</span> (pvp);
}

<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">vnode_getname</span>(vnode_t vp)
{
        <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = NULL;
	
	NAME_CACHE_LOCK_SHARED();
	
	<span class="enscript-keyword">if</span> (vp-&gt;v_name)
	        name = vfs_addname(vp-&gt;v_name, strlen(vp-&gt;v_name), 0, 0);
	NAME_CACHE_UNLOCK();

	<span class="enscript-keyword">return</span> (name);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_putname</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	vfs_removename(name);
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> unknown_vnodename[] = <span class="enscript-string">&quot;(unknown vnode name)&quot;</span>;

<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">vnode_getname_printable</span>(vnode_t vp)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = vnode_getname(vp);
	<span class="enscript-keyword">if</span> (name != NULL)
		<span class="enscript-keyword">return</span> name;
	
	<span class="enscript-keyword">switch</span> (vp-&gt;v_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:
			{
			<span class="enscript-comment">/*
			 * Create an artificial dev name from
			 * major and minor device number
			 */</span>
			<span class="enscript-type">char</span> dev_name[64];
			(<span class="enscript-type">void</span>) snprintf(dev_name, <span class="enscript-keyword">sizeof</span>(dev_name),
					<span class="enscript-string">&quot;%c(%u, %u)&quot;</span>, VCHR == vp-&gt;v_type ? <span class="enscript-string">'c'</span>:<span class="enscript-string">'b'</span>,
					major(vp-&gt;v_rdev), minor(vp-&gt;v_rdev));
			<span class="enscript-comment">/*
			 * Add the newly created dev name to the name
			 * cache to allow easier cleanup. Also,
			 * vfs_addname allocates memory for the new name
			 * and returns it.
			 */</span>
			NAME_CACHE_LOCK_SHARED();
			name = vfs_addname(dev_name, strlen(dev_name), 0, 0);
			NAME_CACHE_UNLOCK();
			<span class="enscript-keyword">return</span> name;
			}
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> unknown_vnodename;
	}
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">vnode_putname_printable</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	<span class="enscript-keyword">if</span> (name == unknown_vnodename)
		<span class="enscript-keyword">return</span>;
	vnode_putname(name);
}
		

<span class="enscript-comment">/*
 * if VNODE_UPDATE_PARENT, and we can take
 * a reference on dvp, then update vp with
 * it's new parent... if vp already has a parent,
 * then drop the reference vp held on it
 *
 * if VNODE_UPDATE_NAME,
 * then drop string ref on v_name if it exists, and if name is non-NULL
 * then pick up a string reference on name and record it in v_name...
 * optionally pass in the length and hashval of name if known
 *
 * if VNODE_UPDATE_CACHE, flush the name cache entries associated with vp
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_update_identity</span>(vnode_t vp, vnode_t dvp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> name_len, uint32_t name_hashval, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span>	namecache *ncp;
        vnode_t	old_parentvp = NULLVP;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-type">int</span> isstream = (vp-&gt;v_flag &amp; VISNAMEDSTREAM);
	<span class="enscript-type">int</span> kusecountbumped = 0;
#<span class="enscript-reference">endif</span>
	kauth_cred_t tcred = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *vname = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *tname = NULL;

	<span class="enscript-keyword">if</span> (flags &amp; VNODE_UPDATE_PARENT) {
	        <span class="enscript-keyword">if</span> (dvp &amp;&amp; vnode_ref(dvp) != 0) {
			dvp = NULLVP;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
		<span class="enscript-comment">/* Don't count a stream's parent ref during unmounts */</span>
		<span class="enscript-keyword">if</span> (isstream &amp;&amp; dvp &amp;&amp; (dvp != vp) &amp;&amp; (dvp != vp-&gt;v_parent) &amp;&amp; (dvp-&gt;v_type == VREG)) {
			vnode_lock_spin(dvp);
			++dvp-&gt;v_kusecount;
			kusecountbumped = 1;
			vnode_unlock(dvp);
		}
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span> {
	        dvp = NULLVP;
	}
	<span class="enscript-keyword">if</span> ( (flags &amp; VNODE_UPDATE_NAME) ) {
		<span class="enscript-keyword">if</span> (name != vp-&gt;v_name) {
			<span class="enscript-keyword">if</span> (name &amp;&amp; *name) {
				<span class="enscript-keyword">if</span> (name_len == 0)
					name_len = strlen(name);
			        tname = vfs_addname(name, name_len, name_hashval, 0);
			}
		} <span class="enscript-keyword">else</span>
			flags &amp;= ~VNODE_UPDATE_NAME;
	}
	<span class="enscript-keyword">if</span> ( (flags &amp; (VNODE_UPDATE_PURGE | VNODE_UPDATE_PARENT | VNODE_UPDATE_CACHE | VNODE_UPDATE_NAME)) ) {

		NAME_CACHE_LOCK();

		<span class="enscript-keyword">if</span> ( (flags &amp; VNODE_UPDATE_PURGE) ) {

			<span class="enscript-keyword">if</span> (vp-&gt;v_parent)
				vp-&gt;v_parent-&gt;v_nc_generation++;

			<span class="enscript-keyword">while</span> ( (ncp = LIST_FIRST(&amp;vp-&gt;v_nclinks)) )
				cache_delete(ncp, 1);

			<span class="enscript-keyword">while</span> ( (ncp = LIST_FIRST(&amp;vp-&gt;v_ncchildren)) )
				cache_delete(ncp, 1);

			<span class="enscript-comment">/*
			 * Use a temp variable to avoid kauth_cred_unref() while NAME_CACHE_LOCK is held
			 */</span>
			tcred = vp-&gt;v_cred;
			vp-&gt;v_cred = NOCRED;
			vp-&gt;v_authorized_actions = 0;
		}
		<span class="enscript-keyword">if</span> ( (flags &amp; VNODE_UPDATE_NAME) ) {
			vname = vp-&gt;v_name;
			vp-&gt;v_name = tname;
		}
		<span class="enscript-keyword">if</span> (flags &amp; VNODE_UPDATE_PARENT) {
			<span class="enscript-keyword">if</span> (dvp != vp &amp;&amp; dvp != vp-&gt;v_parent) {
				old_parentvp = vp-&gt;v_parent;
				vp-&gt;v_parent = dvp;
				dvp = NULLVP;

				<span class="enscript-keyword">if</span> (old_parentvp)
					flags |= VNODE_UPDATE_CACHE;
			}
		}
		<span class="enscript-keyword">if</span> (flags &amp; VNODE_UPDATE_CACHE) {
			<span class="enscript-keyword">while</span> ( (ncp = LIST_FIRST(&amp;vp-&gt;v_nclinks)) )
				cache_delete(ncp, 1);
		}
		NAME_CACHE_UNLOCK();
	
		<span class="enscript-keyword">if</span> (vname != NULL)
			vfs_removename(vname);

		<span class="enscript-keyword">if</span> (IS_VALID_CRED(tcred))
			kauth_cred_unref(&amp;tcred);
	}
	<span class="enscript-keyword">if</span> (dvp != NULLVP) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
		<span class="enscript-comment">/* Back-out the ref we took if we lost a race for vp-&gt;v_parent. */</span>
		<span class="enscript-keyword">if</span> (kusecountbumped) {
			vnode_lock_spin(dvp);
			<span class="enscript-keyword">if</span> (dvp-&gt;v_kusecount &gt; 0)
				--dvp-&gt;v_kusecount;  
			vnode_unlock(dvp);
		}
#<span class="enscript-reference">endif</span>
	        vnode_rele(dvp);
	}
	<span class="enscript-keyword">if</span> (old_parentvp) {
	        <span class="enscript-type">struct</span>  uthread *ut;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
		<span class="enscript-keyword">if</span> (isstream) {
		        vnode_lock_spin(old_parentvp);
			<span class="enscript-keyword">if</span> ((old_parentvp-&gt;v_type != VDIR) &amp;&amp; (old_parentvp-&gt;v_kusecount &gt; 0))
				--old_parentvp-&gt;v_kusecount;
			vnode_unlock(old_parentvp);
		}
#<span class="enscript-reference">endif</span>
	        ut = get_bsdthread_info(current_thread());

		<span class="enscript-comment">/*
		 * indicated to vnode_rele that it shouldn't do a
		 * vnode_reclaim at this time... instead it will
		 * chain the vnode to the uu_vreclaims list...
		 * we'll be responsible for calling vnode_reclaim
		 * on each of the vnodes in this list...
		 */</span>
		ut-&gt;uu_defer_reclaims = 1;
		ut-&gt;uu_vreclaims = NULLVP;

	        <span class="enscript-keyword">while</span> ( (vp = old_parentvp) != NULLVP ) {
	  
		        vnode_lock_spin(vp);
			vnode_rele_internal(vp, 0, 0, 1);

			<span class="enscript-comment">/*
			 * check to see if the vnode is now in the state
			 * that would have triggered a vnode_reclaim in vnode_rele
			 * if it is, we save it's parent pointer and then NULL
			 * out the v_parent field... we'll drop the reference
			 * that was held on the next iteration of this loop...
			 * this short circuits a potential deep recursion if we
			 * have a long chain of parents in this state... 
			 * we'll sit in this loop until we run into
			 * a parent in this chain that is not in this state
			 *
			 * make our check and the vnode_rele atomic
			 * with respect to the current vnode we're working on
			 * by holding the vnode lock
			 * if vnode_rele deferred the vnode_reclaim and has put
			 * this vnode on the list to be reaped by us, than
			 * it has left this vnode with an iocount == 1
			 */</span>
			<span class="enscript-keyword">if</span> ( (vp-&gt;v_iocount == 1) &amp;&amp; (vp-&gt;v_usecount == 0) &amp;&amp;
			     ((vp-&gt;v_lflag &amp; (VL_MARKTERM | VL_TERMINATE | VL_DEAD)) == VL_MARKTERM)) {
			        <span class="enscript-comment">/*
				 * vnode_rele wanted to do a vnode_reclaim on this vnode
				 * it should be sitting on the head of the uu_vreclaims chain
				 * pull the parent pointer now so that when we do the
				 * vnode_reclaim for each of the vnodes in the uu_vreclaims
				 * list, we won't recurse back through here
				 *
				 * need to do a convert here in case vnode_rele_internal
				 * returns with the lock held in the spin mode... it 
				 * can drop and retake the lock under certain circumstances
				 */</span>
			        vnode_lock_convert(vp);

			        NAME_CACHE_LOCK();
				old_parentvp = vp-&gt;v_parent;
				vp-&gt;v_parent = NULLVP;
				NAME_CACHE_UNLOCK();
			} <span class="enscript-keyword">else</span> {
			        <span class="enscript-comment">/*
				 * we're done... we ran into a vnode that isn't
				 * being terminated
				 */</span>
			        old_parentvp = NULLVP;
			}
			vnode_unlock(vp);
		}
		ut-&gt;uu_defer_reclaims = 0;

		<span class="enscript-keyword">while</span> ( (vp = ut-&gt;uu_vreclaims) != NULLVP) {
		        ut-&gt;uu_vreclaims = vp-&gt;v_defer_reclaimlist;
			
			<span class="enscript-comment">/*
			 * vnode_put will drive the vnode_reclaim if
			 * we are still the only reference on this vnode
			 */</span>
			vnode_put(vp);
		}
	}
}


<span class="enscript-comment">/*
 * Mark a vnode as having multiple hard links.  HFS makes use of this
 * because it keeps track of each link separately, and wants to know
 * which link was actually used.
 *
 * This will cause the name cache to force a VNOP_LOOKUP on the vnode
 * so that HFS can post-process the lookup.  Also, volfs will call
 * VNOP_GETATTR2 to determine the parent, instead of using v_parent.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_setmultipath</span>(vnode_t vp)
{
	vnode_lock_spin(vp);

	<span class="enscript-comment">/*
	 * In theory, we're changing the vnode's identity as far as the
	 * name cache is concerned, so we ought to grab the name cache lock
	 * here.  However, there is already a race, and grabbing the name
	 * cache lock only makes the race window slightly smaller.
	 *
	 * The race happens because the vnode already exists in the name
	 * cache, and could be found by one thread before another thread
	 * can set the hard link flag.
	 */</span>

	vp-&gt;v_flag |= VISHARDLINK;

	vnode_unlock(vp);
}



<span class="enscript-comment">/*
 * backwards compatibility
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_uncache_credentials</span>(vnode_t vp)
{
        vnode_uncache_authorized_action(vp, KAUTH_INVALIDATE_CACHED_RIGHTS);
}


<span class="enscript-comment">/*
 * use the exclusive form of NAME_CACHE_LOCK to protect the update of the
 * following fields in the vnode: v_cred_timestamp, v_cred, v_authorized_actions
 * we use this lock so that we can look at the v_cred and v_authorized_actions
 * atomically while behind the NAME_CACHE_LOCK in shared mode in 'cache_lookup_path',
 * which is the super-hot path... if we are updating the authorized actions for this
 * vnode, we are already in the super-slow and far less frequented path so its not
 * that bad that we take the lock exclusive for this case... of course we strive
 * to hold it for the minimum amount of time possible
 */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_uncache_authorized_action</span>(vnode_t vp, kauth_action_t action)
{
        kauth_cred_t tcred = NOCRED;

	NAME_CACHE_LOCK();

	vp-&gt;v_authorized_actions &amp;= ~action;

	<span class="enscript-keyword">if</span> (action == KAUTH_INVALIDATE_CACHED_RIGHTS &amp;&amp;
	    IS_VALID_CRED(vp-&gt;v_cred)) {
	        <span class="enscript-comment">/*
		 * Use a temp variable to avoid kauth_cred_unref() while NAME_CACHE_LOCK is held
		 */</span>
	        tcred = vp-&gt;v_cred;
		vp-&gt;v_cred = NOCRED;
	}
	NAME_CACHE_UNLOCK();

	<span class="enscript-keyword">if</span> (tcred != NOCRED)
		kauth_cred_unref(&amp;tcred);
}


<span class="enscript-type">extern</span> <span class="enscript-type">int</span> bootarg_vnode_cache_defeat;	<span class="enscript-comment">/* default = 0, from bsd_init.c */</span>

boolean_t
<span class="enscript-function-name">vnode_cache_is_authorized</span>(vnode_t vp, vfs_context_t ctx, kauth_action_t action)
{
	kauth_cred_t	ucred;
	boolean_t	retval = FALSE;

	<span class="enscript-comment">/* Boot argument to defeat rights caching */</span>
	<span class="enscript-keyword">if</span> (bootarg_vnode_cache_defeat)
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">if</span> ( (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; (MNTK_AUTH_OPAQUE | MNTK_AUTH_CACHE_TTL)) ) {
	        <span class="enscript-comment">/*
		 * a TTL is enabled on the rights cache... handle it here
		 * a TTL of 0 indicates that no rights should be cached
		 */</span>
	        <span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_authcache_ttl) {
		        <span class="enscript-keyword">if</span> ( !(vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_AUTH_CACHE_TTL) ) {
			        <span class="enscript-comment">/*
				 * For filesystems marked only MNTK_AUTH_OPAQUE (generally network ones),
				 * we will only allow a SEARCH right on a directory to be cached...
				 * that cached right always has a default TTL associated with it
				 */</span>
			        <span class="enscript-keyword">if</span> (action != KAUTH_VNODE_SEARCH || vp-&gt;v_type != VDIR)
				        vp = NULLVP;
			}
			<span class="enscript-keyword">if</span> (vp != NULLVP &amp;&amp; vnode_cache_is_stale(vp) == TRUE) {
			        vnode_uncache_authorized_action(vp, vp-&gt;v_authorized_actions);
				vp = NULLVP;
			}
		} <span class="enscript-keyword">else</span>
		        vp = NULLVP;
	}
	<span class="enscript-keyword">if</span> (vp != NULLVP) {
	        ucred = vfs_context_ucred(ctx);

		NAME_CACHE_LOCK_SHARED();

		<span class="enscript-keyword">if</span> (vp-&gt;v_cred == ucred &amp;&amp; (vp-&gt;v_authorized_actions &amp; action) == action)
		        retval = TRUE;
		
		NAME_CACHE_UNLOCK();
	}
	<span class="enscript-keyword">return</span> retval;
}


<span class="enscript-type">void</span> <span class="enscript-function-name">vnode_cache_authorized_action</span>(vnode_t vp, vfs_context_t ctx, kauth_action_t action)
{
	kauth_cred_t tcred = NOCRED;
	kauth_cred_t ucred;
	<span class="enscript-type">struct</span> timeval tv;
	boolean_t ttl_active = FALSE;

	ucred = vfs_context_ucred(ctx);

	<span class="enscript-keyword">if</span> (!IS_VALID_CRED(ucred) || action == 0)
	        <span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ( (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; (MNTK_AUTH_OPAQUE | MNTK_AUTH_CACHE_TTL)) ) {
	        <span class="enscript-comment">/*
		 * a TTL is enabled on the rights cache... handle it here
		 * a TTL of 0 indicates that no rights should be cached
		 */</span>
	        <span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_authcache_ttl == 0) 
		        <span class="enscript-keyword">return</span>;

		<span class="enscript-keyword">if</span> ( !(vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_AUTH_CACHE_TTL) ) {
		        <span class="enscript-comment">/*
			 * only cache SEARCH action for filesystems marked
			 * MNTK_AUTH_OPAQUE on VDIRs...
			 * the lookup_path code will time these out
			 */</span>
		        <span class="enscript-keyword">if</span> ( (action &amp; ~KAUTH_VNODE_SEARCH) || vp-&gt;v_type != VDIR )
			        <span class="enscript-keyword">return</span>;
		}
		ttl_active = TRUE;

		microuptime(&amp;tv);
	}
	NAME_CACHE_LOCK();

	<span class="enscript-keyword">if</span> (vp-&gt;v_cred != ucred) {
	        kauth_cred_ref(ucred);
	        <span class="enscript-comment">/*
		 * Use a temp variable to avoid kauth_cred_unref() while NAME_CACHE_LOCK is held
		 */</span>
		tcred = vp-&gt;v_cred;
		vp-&gt;v_cred = ucred;
		vp-&gt;v_authorized_actions = 0;
	}
	<span class="enscript-keyword">if</span> (ttl_active == TRUE &amp;&amp; vp-&gt;v_authorized_actions == 0) {
	        <span class="enscript-comment">/*
		 * only reset the timestamnp on the
		 * first authorization cached after the previous
		 * timer has expired or we're switching creds...
		 * 'vnode_cache_is_authorized' will clear the 
		 * authorized actions if the TTL is active and
		 * it has expired
		 */</span>
	        vp-&gt;v_cred_timestamp = tv.tv_sec;
	}
	vp-&gt;v_authorized_actions |= action;

	NAME_CACHE_UNLOCK();

	<span class="enscript-keyword">if</span> (IS_VALID_CRED(tcred))
		kauth_cred_unref(&amp;tcred);
}


boolean_t <span class="enscript-function-name">vnode_cache_is_stale</span>(vnode_t vp)
{
	<span class="enscript-type">struct</span> timeval	tv;
	boolean_t	retval;

	microuptime(&amp;tv);

	<span class="enscript-keyword">if</span> ((tv.tv_sec - vp-&gt;v_cred_timestamp) &gt; vp-&gt;v_mount-&gt;mnt_authcache_ttl)
	        retval = TRUE;
	<span class="enscript-keyword">else</span>
	        retval = FALSE;

	<span class="enscript-keyword">return</span> retval;
}



<span class="enscript-comment">/*
 * Returns:	0			Success
 *		ERECYCLE		vnode was recycled from underneath us.  Force lookup to be re-driven from namei.
 * 						This errno value should not be seen by anyone outside of the kernel.
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">cache_lookup_path</span>(<span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">struct</span> componentname *cnp, vnode_t dp, 
		vfs_context_t ctx, <span class="enscript-type">int</span> *dp_authorized, vnode_t last_dp)
{
	<span class="enscript-type">char</span>		*cp;		<span class="enscript-comment">/* pointer into pathname argument */</span>
	<span class="enscript-type">int</span>		vid;
	<span class="enscript-type">int</span>		vvid = 0;	<span class="enscript-comment">/* protected by vp != NULLVP */</span>
	vnode_t		vp = NULLVP;
	vnode_t		tdp = NULLVP;
	kauth_cred_t	ucred;
	boolean_t	ttl_enabled = FALSE;
	<span class="enscript-type">struct</span> timeval	tv;
        mount_t		mp;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	hash;
	<span class="enscript-type">int</span>		error = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	vnode_t 	trigger_vp;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_TRIGGERS */</span>

	ucred = vfs_context_ucred(ctx);
	ndp-&gt;ni_flag &amp;= ~(NAMEI_TRAILINGSLASH);

	NAME_CACHE_LOCK_SHARED();

	<span class="enscript-keyword">if</span> ( dp-&gt;v_mount &amp;&amp; (dp-&gt;v_mount-&gt;mnt_kern_flag &amp; (MNTK_AUTH_OPAQUE | MNTK_AUTH_CACHE_TTL)) ) {
		ttl_enabled = TRUE;
		microuptime(&amp;tv);
	}
	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-comment">/*
		 * Search a directory.
		 *
		 * The cn_hash value is for use by cache_lookup
		 * The last component of the filename is left accessible via
		 * cnp-&gt;cn_nameptr for callers that need the name.
		 */</span>
	        hash = 0;
		cp = cnp-&gt;cn_nameptr;

		<span class="enscript-keyword">while</span> (*cp &amp;&amp; (*cp != <span class="enscript-string">'/'</span>)) {
			hash = crc32tab[((hash &gt;&gt; 24) ^ (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>)*cp++)] ^ hash &lt;&lt; 8;
		}
		<span class="enscript-comment">/*
		 * the crc generator can legitimately generate
		 * a 0... however, 0 for us means that we
		 * haven't computed a hash, so use 1 instead
		 */</span>
		<span class="enscript-keyword">if</span> (hash == 0)
		        hash = 1;
		cnp-&gt;cn_hash = hash;
		cnp-&gt;cn_namelen = cp - cnp-&gt;cn_nameptr;

		ndp-&gt;ni_pathlen -= cnp-&gt;cn_namelen;
		ndp-&gt;ni_next = cp;

		<span class="enscript-comment">/*
		 * Replace multiple slashes by a single slash and trailing slashes
		 * by a null.  This must be done before VNOP_LOOKUP() because some
		 * fs's don't know about trailing slashes.  Remember if there were
		 * trailing slashes to handle symlinks, existing non-directories
		 * and non-existing files that won't be directories specially later.
		 */</span>
		<span class="enscript-keyword">while</span> (*cp == <span class="enscript-string">'/'</span> &amp;&amp; (cp[1] == <span class="enscript-string">'/'</span> || cp[1] == <span class="enscript-string">'\0'</span>)) {
		        cp++;
			ndp-&gt;ni_pathlen--;

			<span class="enscript-keyword">if</span> (*cp == <span class="enscript-string">'\0'</span>) {
			        ndp-&gt;ni_flag |= NAMEI_TRAILINGSLASH;
				*ndp-&gt;ni_next = <span class="enscript-string">'\0'</span>;
			}
		}
		ndp-&gt;ni_next = cp;

		cnp-&gt;cn_flags &amp;= ~(MAKEENTRY | ISLASTCN | ISDOTDOT);

		<span class="enscript-keyword">if</span> (*cp == <span class="enscript-string">'\0'</span>)
		        cnp-&gt;cn_flags |= ISLASTCN;

		<span class="enscript-keyword">if</span> (cnp-&gt;cn_namelen == 2 &amp;&amp; cnp-&gt;cn_nameptr[1] == <span class="enscript-string">'.'</span> &amp;&amp; cnp-&gt;cn_nameptr[0] == <span class="enscript-string">'.'</span>)
		        cnp-&gt;cn_flags |= ISDOTDOT;

		*dp_authorized = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
		<span class="enscript-comment">/*
		 * Process a request for a file's resource fork.
		 *
		 * Consume the _PATH_RSRCFORKSPEC suffix and tag the path.
		 */</span>
		<span class="enscript-keyword">if</span> ((ndp-&gt;ni_pathlen == <span class="enscript-keyword">sizeof</span>(_PATH_RSRCFORKSPEC)) &amp;&amp;
		    (cp[1] == <span class="enscript-string">'.'</span> &amp;&amp; cp[2] == <span class="enscript-string">'.'</span>) &amp;&amp;
		    bcmp(cp, _PATH_RSRCFORKSPEC, <span class="enscript-keyword">sizeof</span>(_PATH_RSRCFORKSPEC)) == 0) {
		    	<span class="enscript-comment">/* Skip volfs file systems that don't support native streams. */</span>
			<span class="enscript-keyword">if</span> ((dp-&gt;v_mount != NULL) &amp;&amp;
			    (dp-&gt;v_mount-&gt;mnt_flag &amp; MNT_DOVOLFS) &amp;&amp;
			    (dp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_NAMED_STREAMS) == 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skiprsrcfork</span>;
			}
			cnp-&gt;cn_flags |= CN_WANTSRSRCFORK;
			cnp-&gt;cn_flags |= ISLASTCN;
			ndp-&gt;ni_next[0] = <span class="enscript-string">'\0'</span>;
			ndp-&gt;ni_pathlen = 1;
		}
<span class="enscript-reference">skiprsrcfork</span>:
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>

		<span class="enscript-comment">/* 
		 * Name cache provides authorization caching (see below)
		 * that will short circuit MAC checks in lookup().
		 * We must perform MAC check here.  On denial
		 * dp_authorized will remain 0 and second check will
		 * be perfomed in lookup().
		 */</span>
		<span class="enscript-keyword">if</span> (!(cnp-&gt;cn_flags &amp; DONOTAUTH)) {
			error = mac_vnode_check_lookup(ctx, dp, cnp);
			<span class="enscript-keyword">if</span> (error) {
				NAME_CACHE_UNLOCK();
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">errorout</span>;
			}
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>
		<span class="enscript-keyword">if</span> (ttl_enabled &amp;&amp; ((tv.tv_sec - dp-&gt;v_cred_timestamp) &gt; dp-&gt;v_mount-&gt;mnt_authcache_ttl))
		        <span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * NAME_CACHE_LOCK holds these fields stable
		 */</span>
		<span class="enscript-keyword">if</span> ((dp-&gt;v_cred != ucred || !(dp-&gt;v_authorized_actions &amp; KAUTH_VNODE_SEARCH)) &amp;&amp;
		    !(dp-&gt;v_authorized_actions &amp; KAUTH_VNODE_SEARCHBYANYONE))
		        <span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * indicate that we're allowed to traverse this directory...
		 * even if we fail the cache lookup or decide to bail for
		 * some other reason, this information is valid and is used
		 * to avoid doing a vnode_authorize before the call to VNOP_LOOKUP
		 */</span>
		*dp_authorized = 1;

		<span class="enscript-keyword">if</span> ( (cnp-&gt;cn_flags &amp; (ISLASTCN | ISDOTDOT)) ) {
			<span class="enscript-keyword">if</span> (cnp-&gt;cn_nameiop != LOOKUP)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (cnp-&gt;cn_flags &amp; LOCKPARENT) 
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (cnp-&gt;cn_flags &amp; NOCACHE)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (cnp-&gt;cn_flags &amp; ISDOTDOT) {
				<span class="enscript-comment">/*
				 * Force directory hardlinks to go to
				 * file system for &quot;..&quot; requests.
				 */</span>
				<span class="enscript-keyword">if</span> (dp &amp;&amp; (dp-&gt;v_flag &amp; VISHARDLINK)) {
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-comment">/*
				 * Quit here only if we can't use
				 * the parent directory pointer or
				 * don't have one.  Otherwise, we'll
				 * use it below.
				 */</span>
				<span class="enscript-keyword">if</span> ((dp-&gt;v_flag &amp; VROOT)  ||
				    dp == ndp-&gt;ni_rootdir ||
				    dp-&gt;v_parent == NULLVP)
					<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> ((cnp-&gt;cn_flags &amp; CN_SKIPNAMECACHE)) {
			<span class="enscript-comment">/*
			 * Force lookup to go to the filesystem with
			 * all cnp fields set up.
			 */</span>
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * &quot;.&quot; and &quot;..&quot; aren't supposed to be cached, so check
		 * for them before checking the cache.
		 */</span>
		<span class="enscript-keyword">if</span> (cnp-&gt;cn_namelen == 1 &amp;&amp; cnp-&gt;cn_nameptr[0] == <span class="enscript-string">'.'</span>)
			vp = dp;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( (cnp-&gt;cn_flags &amp; ISDOTDOT) )
			vp = dp-&gt;v_parent;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> ( (vp = cache_lookup_locked(dp, cnp)) == NULLVP)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> ( (vp-&gt;v_flag &amp; VISHARDLINK) ) {
				<span class="enscript-comment">/*
				 * The file system wants a VNOP_LOOKUP on this vnode
				 */</span>
				vp = NULL;
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> ( (cnp-&gt;cn_flags &amp; ISLASTCN) )
		        <span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (vp-&gt;v_type != VDIR) {
		        <span class="enscript-keyword">if</span> (vp-&gt;v_type != VLNK)
			        vp = NULL;
		        <span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> ( (mp = vp-&gt;v_mountedhere) &amp;&amp; ((cnp-&gt;cn_flags &amp; NOCROSSMOUNT) == 0)) {
			vnode_t tmp_vp = mp-&gt;mnt_realrootvp;
			<span class="enscript-keyword">if</span> (tmp_vp == NULLVP || mp-&gt;mnt_generation != mount_generation ||
				mp-&gt;mnt_realrootvp_vid != tmp_vp-&gt;v_id)
				<span class="enscript-keyword">break</span>;
			vp = tmp_vp;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
		<span class="enscript-comment">/*
		 * After traversing all mountpoints stacked here, if we have a
		 * trigger in hand, resolve it.  Note that we don't need to 
		 * leave the fast path if the mount has already happened.
		 */</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_resolve)
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_TRIGGERS */</span>


		dp = vp;
		vp = NULLVP;

		cnp-&gt;cn_nameptr = ndp-&gt;ni_next + 1;
		ndp-&gt;ni_pathlen--;
		<span class="enscript-keyword">while</span> (*cnp-&gt;cn_nameptr == <span class="enscript-string">'/'</span>) {
		        cnp-&gt;cn_nameptr++;
			ndp-&gt;ni_pathlen--;
		}
	}
	<span class="enscript-keyword">if</span> (vp != NULLVP)
	        vvid = vp-&gt;v_id;
	vid = dp-&gt;v_id;
	
	NAME_CACHE_UNLOCK();

	<span class="enscript-keyword">if</span> ((vp != NULLVP) &amp;&amp; (vp-&gt;v_type != VLNK) &amp;&amp;
	    ((cnp-&gt;cn_flags &amp; (ISLASTCN | LOCKPARENT | WANTPARENT | SAVESTART)) == ISLASTCN)) {
	        <span class="enscript-comment">/*
		 * if we've got a child and it's the last component, and 
		 * the lookup doesn't need to return the parent then we
		 * can skip grabbing an iocount on the parent, since all
		 * we're going to do with it is a vnode_put just before
		 * we return from 'lookup'.  If it's a symbolic link,
		 * we need the parent in case the link happens to be
		 * a relative pathname.
		 */</span>
	        tdp = dp;
	        dp = NULLVP;
	} <span class="enscript-keyword">else</span> {
<span class="enscript-reference">need_dp</span>:
		<span class="enscript-comment">/*
		 * return the last directory we looked at
		 * with an io reference held. If it was the one passed
		 * in as a result of the last iteration of VNOP_LOOKUP,
		 * it should already hold an io ref. No need to increase ref.
		 */</span>
		<span class="enscript-keyword">if</span> (last_dp != dp){
			
			<span class="enscript-keyword">if</span> (dp == ndp-&gt;ni_usedvp) {
				<span class="enscript-comment">/*
				 * if this vnode matches the one passed in via USEDVP
				 * than this context already holds an io_count... just
				 * use vnode_get to get an extra ref for lookup to play
				 * with... can't use the getwithvid variant here because
				 * it will block behind a vnode_drain which would result
				 * in a deadlock (since we already own an io_count that the
				 * vnode_drain is waiting on)... vnode_get grabs the io_count
				 * immediately w/o waiting... it always succeeds
				 */</span>
				vnode_get(dp);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((error = vnode_getwithvid_drainok(dp, vid))) {
				<span class="enscript-comment">/*
				 * failure indicates the vnode
				 * changed identity or is being
				 * TERMINATED... in either case
				 * punt this lookup.
				 * 
				 * don't necessarily return ENOENT, though, because
				 * we really want to go back to disk and make sure it's
				 * there or not if someone else is changing this
				 * vnode. That being said, the one case where we do want
				 * to return ENOENT is when the vnode's mount point is
				 * in the process of unmounting and we might cause a deadlock
				 * in our attempt to take an iocount. An ENODEV error return
				 * is from vnode_get* is an indication this but we change that
				 * ENOENT for upper layers.
				 */</span>
				<span class="enscript-keyword">if</span> (error == ENODEV) {
					error = ENOENT;
				} <span class="enscript-keyword">else</span> {
					error = ERECYCLE;
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">errorout</span>;
			}
		}
	}
	<span class="enscript-keyword">if</span> (vp != NULLVP) {
	        <span class="enscript-keyword">if</span> ( (vnode_getwithvid_drainok(vp, vvid)) ) {
		        vp = NULLVP;

		        <span class="enscript-comment">/*
			 * can't get reference on the vp we'd like
			 * to return... if we didn't grab a reference
			 * on the directory (due to fast path bypass),
			 * then we need to do it now... we can't return
			 * with both ni_dvp and ni_vp NULL, and no 
			 * error condition
			 */</span>
			<span class="enscript-keyword">if</span> (dp == NULLVP) {
			        dp = tdp;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">need_dp</span>;
			}
		}
	}

	ndp-&gt;ni_dvp = dp;
	ndp-&gt;ni_vp  = vp;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	trigger_vp = vp ? vp : dp;
	<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; (trigger_vp != NULLVP) &amp;&amp; vnode_isdir(trigger_vp)) {
		error = vnode_trigger_resolve(trigger_vp, ndp, ctx);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (vp)
				vnode_put(vp);
			<span class="enscript-keyword">if</span> (dp) 
				vnode_put(dp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">errorout</span>;
		}
	} 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_TRIGGERS */</span>

<span class="enscript-reference">errorout</span>:
	<span class="enscript-comment">/* 
	 * If we came into cache_lookup_path after an iteration of the lookup loop that
	 * resulted in a call to VNOP_LOOKUP, then VNOP_LOOKUP returned a vnode with a io ref
	 * on it.  It is now the job of cache_lookup_path to drop the ref on this vnode 
	 * when it is no longer needed.  If we get to this point, and last_dp is not NULL
	 * and it is ALSO not the dvp we want to return to caller of this function, it MUST be
	 * the case that we got to a subsequent path component and this previous vnode is 
	 * no longer needed.  We can then drop the io ref on it.
	 */</span>
	<span class="enscript-keyword">if</span> ((last_dp != NULLVP) &amp;&amp; (last_dp != ndp-&gt;ni_dvp)){
		vnode_put(last_dp);
	}
	
	<span class="enscript-comment">//initialized to 0, should be the same if no error cases occurred.
</span>	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">static</span> vnode_t
<span class="enscript-function-name">cache_lookup_locked</span>(vnode_t dvp, <span class="enscript-type">struct</span> componentname *cnp)
{
	<span class="enscript-type">struct</span> namecache *ncp;
	<span class="enscript-type">struct</span> nchashhead *ncpp;
	<span class="enscript-type">long</span> namelen = cnp-&gt;cn_namelen;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> hashval = cnp-&gt;cn_hash;
	
	<span class="enscript-keyword">if</span> (nc_disabled) {
		<span class="enscript-keyword">return</span> NULL;
	}

	ncpp = NCHHASH(dvp, cnp-&gt;cn_hash);
	LIST_FOREACH(ncp, ncpp, nc_hash) {
	        <span class="enscript-keyword">if</span> ((ncp-&gt;nc_dvp == dvp) &amp;&amp; (ncp-&gt;nc_hashval == hashval)) {
			<span class="enscript-keyword">if</span> (memcmp(ncp-&gt;nc_name, cnp-&gt;cn_nameptr, namelen) == 0 &amp;&amp; ncp-&gt;nc_name[namelen] == 0)
			        <span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span> (ncp == 0) {
		<span class="enscript-comment">/*
		 * We failed to find an entry
		 */</span>
		NCHSTAT(ncs_miss);
		<span class="enscript-keyword">return</span> (NULL);
	}
	NCHSTAT(ncs_goodhits);

	<span class="enscript-keyword">return</span> (ncp-&gt;nc_vp);
}


<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hash_string</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *cp, <span class="enscript-type">int</span> len);
<span class="enscript-comment">//
</span><span class="enscript-comment">// Have to take a len argument because we may only need to
</span><span class="enscript-comment">// hash part of a componentname.
</span><span class="enscript-comment">//
</span><span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hash_string</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *cp, <span class="enscript-type">int</span> len)
{
    <span class="enscript-type">unsigned</span> hash = 0;

    <span class="enscript-keyword">if</span> (len) {
            <span class="enscript-keyword">while</span> (len--) {
		    hash = crc32tab[((hash &gt;&gt; 24) ^ (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>)*cp++)] ^ hash &lt;&lt; 8;
	    }
    } <span class="enscript-keyword">else</span> {
            <span class="enscript-keyword">while</span> (*cp != <span class="enscript-string">'\0'</span>) {
		    hash = crc32tab[((hash &gt;&gt; 24) ^ (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>)*cp++)] ^ hash &lt;&lt; 8;
	    }
    }
    <span class="enscript-comment">/*
     * the crc generator can legitimately generate
     * a 0... however, 0 for us means that we
     * haven't computed a hash, so use 1 instead
     */</span>
    <span class="enscript-keyword">if</span> (hash == 0)
            hash = 1;
    <span class="enscript-keyword">return</span> hash;
}


<span class="enscript-comment">/*
 * Lookup an entry in the cache 
 *
 * We don't do this if the segment name is long, simply so the cache 
 * can avoid holding long names (which would either waste space, or
 * add greatly to the complexity).
 *
 * Lookup is called with dvp pointing to the directory to search,
 * cnp pointing to the name of the entry being sought. If the lookup
 * succeeds, the vnode is returned in *vpp, and a status of -1 is
 * returned. If the lookup determines that the name does not exist
 * (negative cacheing), a status of ENOENT is returned. If the lookup
 * fails, a status of zero is returned.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">cache_lookup</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">struct</span> componentname *cnp)
{
	<span class="enscript-type">struct</span> namecache *ncp;
	<span class="enscript-type">struct</span> nchashhead *ncpp;
	<span class="enscript-type">long</span> namelen = cnp-&gt;cn_namelen;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> hashval;
	boolean_t	have_exclusive = FALSE;
	uint32_t vid;
	vnode_t	 vp;

	<span class="enscript-keyword">if</span> (cnp-&gt;cn_hash == 0)
		cnp-&gt;cn_hash = hash_string(cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen);
	hashval = cnp-&gt;cn_hash;

	<span class="enscript-keyword">if</span> (nc_disabled) {
		<span class="enscript-keyword">return</span> 0;
	}

	NAME_CACHE_LOCK_SHARED();

<span class="enscript-reference">relook</span>:
	ncpp = NCHHASH(dvp, cnp-&gt;cn_hash);
	LIST_FOREACH(ncp, ncpp, nc_hash) {
	        <span class="enscript-keyword">if</span> ((ncp-&gt;nc_dvp == dvp) &amp;&amp; (ncp-&gt;nc_hashval == hashval)) {
			<span class="enscript-keyword">if</span> (memcmp(ncp-&gt;nc_name, cnp-&gt;cn_nameptr, namelen) == 0 &amp;&amp; ncp-&gt;nc_name[namelen] == 0)
			        <span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-comment">/* We failed to find an entry */</span>
	<span class="enscript-keyword">if</span> (ncp == 0) {
		NCHSTAT(ncs_miss);
		NAME_CACHE_UNLOCK();
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* We don't want to have an entry, so dump it */</span>
	<span class="enscript-keyword">if</span> ((cnp-&gt;cn_flags &amp; MAKEENTRY) == 0) {
	        <span class="enscript-keyword">if</span> (have_exclusive == TRUE) {
		        NCHSTAT(ncs_badhits);
			cache_delete(ncp, 1);
			NAME_CACHE_UNLOCK();
			<span class="enscript-keyword">return</span> (0);
		}
		NAME_CACHE_UNLOCK();
		NAME_CACHE_LOCK();
		have_exclusive = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">relook</span>;
	} 
	vp = ncp-&gt;nc_vp;

	<span class="enscript-comment">/* We found a &quot;positive&quot; match, return the vnode */</span>
        <span class="enscript-keyword">if</span> (vp) {
		NCHSTAT(ncs_goodhits);

		vid = vp-&gt;v_id;
		NAME_CACHE_UNLOCK();

		<span class="enscript-keyword">if</span> (vnode_getwithvid(vp, vid)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COLLECT_STATS</span>
		        NAME_CACHE_LOCK();
			NCHSTAT(ncs_badvid);
			NAME_CACHE_UNLOCK();
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">return</span> (0);
		}
		*vpp = vp;
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-comment">/* We found a negative match, and want to create it, so purge */</span>
	<span class="enscript-keyword">if</span> (cnp-&gt;cn_nameiop == CREATE || cnp-&gt;cn_nameiop == RENAME) {
	        <span class="enscript-keyword">if</span> (have_exclusive == TRUE) {
		        NCHSTAT(ncs_badhits);
			cache_delete(ncp, 1);
			NAME_CACHE_UNLOCK();
			<span class="enscript-keyword">return</span> (0);
		}
		NAME_CACHE_UNLOCK();
		NAME_CACHE_LOCK();
		have_exclusive = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">relook</span>;
	}

	<span class="enscript-comment">/*
	 * We found a &quot;negative&quot; match, ENOENT notifies client of this match.
	 */</span>
	NCHSTAT(ncs_neghits);

	NAME_CACHE_UNLOCK();
	<span class="enscript-keyword">return</span> (ENOENT);
}

<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">cache_enter_create</span>(vnode_t dvp, vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *strname;

        <span class="enscript-keyword">if</span> (cnp-&gt;cn_hash == 0)
	        cnp-&gt;cn_hash = hash_string(cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen);

	<span class="enscript-comment">/*
	 * grab 2 references on the string entered
	 * one for the cache_enter_locked to consume
	 * and the second to be consumed by v_name (vnode_create call point)
	 */</span>
	strname = add_name_internal(cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, cnp-&gt;cn_hash, TRUE, 0);

	NAME_CACHE_LOCK();

	cache_enter_locked(dvp, vp, cnp, strname);

	NAME_CACHE_UNLOCK();

	<span class="enscript-keyword">return</span> (strname);
}


<span class="enscript-comment">/*
 * Add an entry to the cache...
 * but first check to see if the directory
 * that this entry is to be associated with has
 * had any cache_purges applied since we took
 * our identity snapshot... this check needs to
 * be done behind the name cache lock
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">cache_enter_with_gen</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">int</span> gen)
{

        <span class="enscript-keyword">if</span> (cnp-&gt;cn_hash == 0)
	        cnp-&gt;cn_hash = hash_string(cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen);

	NAME_CACHE_LOCK();

	<span class="enscript-keyword">if</span> (dvp-&gt;v_nc_generation == gen)
	        (<span class="enscript-type">void</span>)cache_enter_locked(dvp, vp, cnp, NULL);

	NAME_CACHE_UNLOCK();
}


<span class="enscript-comment">/*
 * Add an entry to the cache.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">cache_enter</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> componentname *cnp)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *strname;

        <span class="enscript-keyword">if</span> (cnp-&gt;cn_hash == 0)
	        cnp-&gt;cn_hash = hash_string(cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen);

	<span class="enscript-comment">/*
	 * grab 1 reference on the string entered
	 * for the cache_enter_locked to consume
	 */</span>
	strname = add_name_internal(cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, cnp-&gt;cn_hash, FALSE, 0);

	NAME_CACHE_LOCK();

	cache_enter_locked(dvp, vp, cnp, strname);

	NAME_CACHE_UNLOCK();
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cache_enter_locked</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *strname)
{
        <span class="enscript-type">struct</span> namecache *ncp, *negp;
	<span class="enscript-type">struct</span> nchashhead *ncpp;

	<span class="enscript-keyword">if</span> (nc_disabled) 
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * if the entry is for -ve caching vp is null
	 */</span>
	<span class="enscript-keyword">if</span> ((vp != NULLVP) &amp;&amp; (LIST_FIRST(&amp;vp-&gt;v_nclinks))) {
	        <span class="enscript-comment">/*
		 * someone beat us to the punch..
		 * this vnode is already in the cache
		 */</span>
		<span class="enscript-keyword">if</span> (strname != NULL)
			vfs_removename(strname);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/*
	 * We allocate a new entry if we are less than the maximum
	 * allowed and the one at the front of the list is in use.
	 * Otherwise we use the one at the front of the list.
	 */</span>
	<span class="enscript-keyword">if</span> (numcache &lt; desiredNodes &amp;&amp;
	    ((ncp = nchead.tqh_first) == NULL ||
	      ncp-&gt;nc_hash.le_prev != 0)) {
		<span class="enscript-comment">/*
		 * Allocate one more entry
		 */</span>
		ncp = (<span class="enscript-type">struct</span> namecache *)_MALLOC_ZONE(<span class="enscript-keyword">sizeof</span>(*ncp), M_CACHE, M_WAITOK);
		numcache++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * reuse an old entry
		 */</span>
	        ncp = TAILQ_FIRST(&amp;nchead);
		TAILQ_REMOVE(&amp;nchead, ncp, nc_entry);

		<span class="enscript-keyword">if</span> (ncp-&gt;nc_hash.le_prev != 0) {
		       <span class="enscript-comment">/*
			* still in use... we need to
			* delete it before re-using it
			*/</span>
			NCHSTAT(ncs_stolen);
			cache_delete(ncp, 0);
		}
	}
	NCHSTAT(ncs_enters);

	<span class="enscript-comment">/*
	 * Fill in cache info, if vp is NULL this is a &quot;negative&quot; cache entry.
	 */</span>
	ncp-&gt;nc_vp = vp;
	ncp-&gt;nc_dvp = dvp;
	ncp-&gt;nc_hashval = cnp-&gt;cn_hash;

	<span class="enscript-keyword">if</span> (strname == NULL)
		ncp-&gt;nc_name = add_name_internal(cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, cnp-&gt;cn_hash, FALSE, 0);
	<span class="enscript-keyword">else</span>
		ncp-&gt;nc_name = strname;

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// If the bytes of the name associated with the vnode differ,
</span>	<span class="enscript-comment">// use the name associated with the vnode since the file system
</span>	<span class="enscript-comment">// may have set that explicitly in the case of a lookup on a
</span>	<span class="enscript-comment">// case-insensitive file system where the case of the looked up
</span>	<span class="enscript-comment">// name differs from what is on disk.  For more details, see:
</span>	<span class="enscript-comment">//   &lt;rdar://problem/8044697&gt; FSEvents doesn't always decompose diacritical unicode chars in the paths of the changed directories
</span>	<span class="enscript-comment">// 
</span>	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *vn_name = vp ? vp-&gt;v_name : NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len = vn_name ? strlen(vn_name) : 0;
	<span class="enscript-keyword">if</span> (vn_name &amp;&amp; ncp &amp;&amp; ncp-&gt;nc_name &amp;&amp; strncmp(ncp-&gt;nc_name, vn_name, len) != 0) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> hash = hash_string(vn_name, len);
		
		vfs_removename(ncp-&gt;nc_name);
		ncp-&gt;nc_name = add_name_internal(vn_name, len, hash, FALSE, 0);
		ncp-&gt;nc_hashval = hash;
	}

	<span class="enscript-comment">/*
	 * make us the newest entry in the cache
	 * i.e. we'll be the last to be stolen
	 */</span>
	TAILQ_INSERT_TAIL(&amp;nchead, ncp, nc_entry);

	ncpp = NCHHASH(dvp, cnp-&gt;cn_hash);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	{
		<span class="enscript-type">struct</span> namecache *p;

		<span class="enscript-keyword">for</span> (p = ncpp-&gt;lh_first; p != 0; p = p-&gt;nc_hash.le_next)
			<span class="enscript-keyword">if</span> (p == ncp)
				panic(<span class="enscript-string">&quot;cache_enter: duplicate&quot;</span>);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * make us available to be found via lookup
	 */</span>
	LIST_INSERT_HEAD(ncpp, ncp, nc_hash);

	<span class="enscript-keyword">if</span> (vp) {
	       <span class="enscript-comment">/*
		* add to the list of name cache entries
		* that point at vp
		*/</span>
		LIST_INSERT_HEAD(&amp;vp-&gt;v_nclinks, ncp, nc_un.nc_link);
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-comment">/*
		 * this is a negative cache entry (vp == NULL)
		 * stick it on the negative cache list.
		 */</span>
	        TAILQ_INSERT_TAIL(&amp;neghead, ncp, nc_un.nc_negentry);
	  
		ncs_negtotal++;

		<span class="enscript-keyword">if</span> (ncs_negtotal &gt; desiredNegNodes) {
		       <span class="enscript-comment">/*
			* if we've reached our desired limit
			* of negative cache entries, delete
			* the oldest
			*/</span>
		        negp = TAILQ_FIRST(&amp;neghead);
			cache_delete(negp, 1);
		}
	}
	<span class="enscript-comment">/*
	 * add us to the list of name cache entries that
	 * are children of dvp
	 */</span>
	LIST_INSERT_HEAD(&amp;dvp-&gt;v_ncchildren, ncp, nc_child);
}


<span class="enscript-comment">/*
 * Initialize CRC-32 remainder table.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">init_crc32</span>(<span class="enscript-type">void</span>)
{
        <span class="enscript-comment">/*
	 * the CRC-32 generator polynomial is:
	 *   x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^10
	 *        + x^8  + x^7  + x^5  + x^4  + x^2  + x + 1
	 */</span>
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> crc32_polynomial = 0x04c11db7;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i,j;

	<span class="enscript-comment">/*
	 * pre-calculate the CRC-32 remainder for each possible octet encoding
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0;  i &lt; 256;  i++) {
	        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> crc_rem = i &lt;&lt; 24;

		<span class="enscript-keyword">for</span> (j = 0;  j &lt; 8;  j++) {
		        <span class="enscript-keyword">if</span> (crc_rem &amp; 0x80000000)
			        crc_rem = (crc_rem &lt;&lt; 1) ^ crc32_polynomial;
			<span class="enscript-keyword">else</span>
			        crc_rem = (crc_rem &lt;&lt; 1);
		}
		crc32tab[i] = crc_rem;
	}
}


<span class="enscript-comment">/*
 * Name cache initialization, from vfs_init() when we are booting
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nchinit</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span>	i;

	desiredNegNodes = (desiredvnodes / 10);
	desiredNodes = desiredvnodes + desiredNegNodes;

	TAILQ_INIT(&amp;nchead);
	TAILQ_INIT(&amp;neghead);

	init_crc32();

	nchashtbl = hashinit(MAX(CONFIG_NC_HASH, (2 *desiredNodes)), M_CACHE, &amp;nchash);
	nchashmask = nchash;
	nchash++;

	init_string_table();
	
	<span class="enscript-comment">/* Allocate name cache lock group attribute and group */</span>
	namecache_lck_grp_attr= lck_grp_attr_alloc_init();

	namecache_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;Name Cache&quot;</span>,  namecache_lck_grp_attr);
	
	<span class="enscript-comment">/* Allocate name cache lock attribute */</span>
	namecache_lck_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/* Allocate name cache lock */</span>
	namecache_rw_lock = lck_rw_alloc_init(namecache_lck_grp, namecache_lck_attr);


	<span class="enscript-comment">/* Allocate string cache lock group attribute and group */</span>
	strcache_lck_grp_attr= lck_grp_attr_alloc_init();

	strcache_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;String Cache&quot;</span>,  strcache_lck_grp_attr);
	
	<span class="enscript-comment">/* Allocate string cache lock attribute */</span>
	strcache_lck_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/* Allocate string cache lock */</span>
	strtable_rw_lock = lck_rw_alloc_init(strcache_lck_grp, strcache_lck_attr);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; NUM_STRCACHE_LOCKS; i++)
		lck_mtx_init(&amp;strcache_mtx_locks[i], strcache_lck_grp, strcache_lck_attr);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">name_cache_lock_shared</span>(<span class="enscript-type">void</span>)
{
	lck_rw_lock_shared(namecache_rw_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">name_cache_lock</span>(<span class="enscript-type">void</span>)
{
	lck_rw_lock_exclusive(namecache_rw_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">name_cache_unlock</span>(<span class="enscript-type">void</span>)
{
	lck_rw_done(namecache_rw_lock);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">resize_namecache</span>(u_int newsize)
{
    <span class="enscript-type">struct</span> nchashhead	*new_table;
    <span class="enscript-type">struct</span> nchashhead	*old_table;
    <span class="enscript-type">struct</span> nchashhead	*old_head, *head;
    <span class="enscript-type">struct</span> namecache 	*entry, *next;
    uint32_t		i, hashval;
    <span class="enscript-type">int</span>			dNodes, dNegNodes;
    u_long		new_size, old_size;

    dNegNodes = (newsize / 10);
    dNodes = newsize + dNegNodes;

    <span class="enscript-comment">// we don't support shrinking yet
</span>    <span class="enscript-keyword">if</span> (dNodes &lt;= desiredNodes) {
	<span class="enscript-keyword">return</span> 0;
    }
    new_table = hashinit(2 * dNodes, M_CACHE, &amp;nchashmask);
    new_size  = nchashmask + 1;

    <span class="enscript-keyword">if</span> (new_table == NULL) {
	<span class="enscript-keyword">return</span> ENOMEM;
    }

    NAME_CACHE_LOCK();
    <span class="enscript-comment">// do the switch!
</span>    old_table = nchashtbl;
    nchashtbl = new_table;
    old_size  = nchash;
    nchash    = new_size;

    <span class="enscript-comment">// walk the old table and insert all the entries into
</span>    <span class="enscript-comment">// the new table
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-keyword">for</span>(i=0; i &lt; old_size; i++) {
	old_head = &amp;old_table[i];
	<span class="enscript-keyword">for</span> (entry=old_head-&gt;lh_first; entry != NULL; entry=next) {
	    <span class="enscript-comment">//
</span>	    <span class="enscript-comment">// XXXdbg - Beware: this assumes that hash_string() does
</span>	    <span class="enscript-comment">//                  the same thing as what happens in
</span>	    <span class="enscript-comment">//                  lookup() over in vfs_lookup.c
</span>	    hashval = hash_string(entry-&gt;nc_name, 0);
	    entry-&gt;nc_hashval = hashval;
	    head = NCHHASH(entry-&gt;nc_dvp, hashval);
	    
	    next = entry-&gt;nc_hash.le_next;
	    LIST_INSERT_HEAD(head, entry, nc_hash);
	}
    }
    desiredNodes = dNodes;
    desiredNegNodes = dNegNodes;
    
    NAME_CACHE_UNLOCK();
    FREE(old_table, M_CACHE);

    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cache_delete</span>(<span class="enscript-type">struct</span> namecache *ncp, <span class="enscript-type">int</span> age_entry)
{
        NCHSTAT(ncs_deletes);

        <span class="enscript-keyword">if</span> (ncp-&gt;nc_vp) {
	        LIST_REMOVE(ncp, nc_un.nc_link);
	} <span class="enscript-keyword">else</span> {
	        TAILQ_REMOVE(&amp;neghead, ncp, nc_un.nc_negentry);
	        ncs_negtotal--;
	}
        LIST_REMOVE(ncp, nc_child);

	LIST_REMOVE(ncp, nc_hash);
	<span class="enscript-comment">/*
	 * this field is used to indicate
	 * that the entry is in use and
	 * must be deleted before it can 
	 * be reused...
	 */</span>
	ncp-&gt;nc_hash.le_prev = NULL;

	<span class="enscript-keyword">if</span> (age_entry) {
	        <span class="enscript-comment">/*
		 * make it the next one available
		 * for cache_enter's use
		 */</span>
	        TAILQ_REMOVE(&amp;nchead, ncp, nc_entry);
	        TAILQ_INSERT_HEAD(&amp;nchead, ncp, nc_entry);
	}
	vfs_removename(ncp-&gt;nc_name);
	ncp-&gt;nc_name = NULL;
}


<span class="enscript-comment">/*
 * purge the entry associated with the 
 * specified vnode from the name cache
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">cache_purge</span>(vnode_t vp)
{
        <span class="enscript-type">struct</span> namecache *ncp;
	kauth_cred_t tcred = NULL;

	<span class="enscript-keyword">if</span> ((LIST_FIRST(&amp;vp-&gt;v_nclinks) == NULL) &amp;&amp; 
			(LIST_FIRST(&amp;vp-&gt;v_ncchildren) == NULL) &amp;&amp; 
			(vp-&gt;v_cred == NOCRED) &amp;&amp;
			(vp-&gt;v_parent == NULLVP))
	        <span class="enscript-keyword">return</span>;

	NAME_CACHE_LOCK();

	<span class="enscript-keyword">if</span> (vp-&gt;v_parent)
	        vp-&gt;v_parent-&gt;v_nc_generation++;

	<span class="enscript-keyword">while</span> ( (ncp = LIST_FIRST(&amp;vp-&gt;v_nclinks)) )
	        cache_delete(ncp, 1);

	<span class="enscript-keyword">while</span> ( (ncp = LIST_FIRST(&amp;vp-&gt;v_ncchildren)) )
	        cache_delete(ncp, 1);

	<span class="enscript-comment">/*
	 * Use a temp variable to avoid kauth_cred_unref() while NAME_CACHE_LOCK is held
	 */</span>
	tcred = vp-&gt;v_cred;
	vp-&gt;v_cred = NOCRED;
	vp-&gt;v_authorized_actions = 0;

	NAME_CACHE_UNLOCK();

	<span class="enscript-keyword">if</span> (IS_VALID_CRED(tcred))
	        kauth_cred_unref(&amp;tcred);
}

<span class="enscript-comment">/*
 * Purge all negative cache entries that are children of the
 * given vnode.  A case-insensitive file system (or any file
 * system that has multiple equivalent names for the same
 * directory entry) can use this when creating or renaming
 * to remove negative entries that may no longer apply.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">cache_purge_negatives</span>(vnode_t vp)
{
	<span class="enscript-type">struct</span> namecache *ncp, *next_ncp;

	NAME_CACHE_LOCK();

	LIST_FOREACH_SAFE(ncp, &amp;vp-&gt;v_ncchildren, nc_child, next_ncp)
		<span class="enscript-keyword">if</span> (ncp-&gt;nc_vp == NULL)
			cache_delete(ncp , 1);

	NAME_CACHE_UNLOCK();
}

<span class="enscript-comment">/*
 * Flush all entries referencing a particular filesystem.
 *
 * Since we need to check it anyway, we will flush all the invalid
 * entries at the same time.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">cache_purgevfs</span>(<span class="enscript-type">struct</span> mount *mp)
{
	<span class="enscript-type">struct</span> nchashhead *ncpp;
	<span class="enscript-type">struct</span> namecache *ncp;

	NAME_CACHE_LOCK();
	<span class="enscript-comment">/* Scan hash tables for applicable entries */</span>
	<span class="enscript-keyword">for</span> (ncpp = &amp;nchashtbl[nchash - 1]; ncpp &gt;= nchashtbl; ncpp--) {
<span class="enscript-reference">restart</span>:	  
		<span class="enscript-keyword">for</span> (ncp = ncpp-&gt;lh_first; ncp != 0; ncp = ncp-&gt;nc_hash.le_next) {
			<span class="enscript-keyword">if</span> (ncp-&gt;nc_dvp-&gt;v_mount == mp) {
				cache_delete(ncp, 0);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
			}
		}
	}
	NAME_CACHE_UNLOCK();
}



<span class="enscript-comment">//
</span><span class="enscript-comment">// String ref routines
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(stringhead, string_t) *string_ref_table;
<span class="enscript-type">static</span> u_long   string_table_mask;
<span class="enscript-type">static</span> uint32_t filled_buckets=0;


<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> string_t {
    LIST_ENTRY(string_t)  hash_chain;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *str;
    uint32_t              refcount;
} string_t;


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">resize_string_ref_table</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> stringhead *new_table;
	<span class="enscript-type">struct</span> stringhead *old_table;
	<span class="enscript-type">struct</span> stringhead *old_head, *head;
	string_t          *entry, *next;
	uint32_t           i, hashval;
	u_long             new_mask, old_mask;

	<span class="enscript-comment">/*
	 * need to hold the table lock exclusively
	 * in order to grow the table... need to recheck
	 * the need to resize again after we've taken
	 * the lock exclusively in case some other thread
	 * beat us to the punch
	 */</span>
	lck_rw_lock_exclusive(strtable_rw_lock);

	<span class="enscript-keyword">if</span> (4 * filled_buckets &lt; ((string_table_mask + 1) * 3)) {
		lck_rw_done(strtable_rw_lock);
		<span class="enscript-keyword">return</span>;
	}
	new_table = hashinit((string_table_mask + 1) * 2, M_CACHE, &amp;new_mask);

	<span class="enscript-keyword">if</span> (new_table == NULL) {
		printf(<span class="enscript-string">&quot;failed to resize the hash table.\n&quot;</span>);
		lck_rw_done(strtable_rw_lock);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">// do the switch!
</span>	old_table         = string_ref_table;
	string_ref_table  = new_table;
	old_mask          = string_table_mask;
	string_table_mask = new_mask;
	filled_buckets	  = 0;

	<span class="enscript-comment">// walk the old table and insert all the entries into
</span>	<span class="enscript-comment">// the new table
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">for</span> (i = 0; i &lt;= old_mask; i++) {
		old_head = &amp;old_table[i];
		<span class="enscript-keyword">for</span> (entry = old_head-&gt;lh_first; entry != NULL; entry = next) {
			hashval = hash_string((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)entry-&gt;str, 0);
			head = &amp;string_ref_table[hashval &amp; string_table_mask];
			<span class="enscript-keyword">if</span> (head-&gt;lh_first == NULL) {
				filled_buckets++;
			}
			next = entry-&gt;hash_chain.le_next;
			LIST_INSERT_HEAD(head, entry, hash_chain);
		}
	}
	lck_rw_done(strtable_rw_lock);

	FREE(old_table, M_CACHE);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">init_string_table</span>(<span class="enscript-type">void</span>)
{
	string_ref_table = hashinit(CONFIG_VFS_NAMES, M_CACHE, &amp;string_table_mask);
}


<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">vfs_addname</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, uint32_t len, u_int hashval, u_int flags)
{
	<span class="enscript-keyword">return</span> (add_name_internal(name, len, hashval, FALSE, flags));
}


<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">add_name_internal</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, uint32_t len, u_int hashval, boolean_t need_extra_ref, __unused u_int flags)
{
	<span class="enscript-type">struct</span> stringhead *head;
	string_t          *entry;
	uint32_t          chain_len = 0;
	uint32_t	  hash_index;
        uint32_t	  lock_index;
	<span class="enscript-type">char</span>              *ptr;
    
	<span class="enscript-comment">/*
	 * if the length already accounts for the null-byte, then
	 * subtract one so later on we don't index past the end
	 * of the string.
	 */</span>
	<span class="enscript-keyword">if</span> (len &gt; 0 &amp;&amp; name[len-1] == <span class="enscript-string">'\0'</span>) {
		len--;
	}
	<span class="enscript-keyword">if</span> (hashval == 0) {
		hashval = hash_string(name, len);
	}

	<span class="enscript-comment">/*
	 * take this lock 'shared' to keep the hash stable
	 * if someone else decides to grow the pool they
	 * will take this lock exclusively
	 */</span>
	lck_rw_lock_shared(strtable_rw_lock);

	<span class="enscript-comment">/*
	 * If the table gets more than 3/4 full, resize it
	 */</span>
	<span class="enscript-keyword">if</span> (4 * filled_buckets &gt;= ((string_table_mask + 1) * 3)) {
		lck_rw_done(strtable_rw_lock);

		resize_string_ref_table();

		lck_rw_lock_shared(strtable_rw_lock);
	}
	hash_index = hashval &amp; string_table_mask;
	lock_index = hash_index % NUM_STRCACHE_LOCKS;

	head = &amp;string_ref_table[hash_index];

	lck_mtx_lock_spin(&amp;strcache_mtx_locks[lock_index]);

	<span class="enscript-keyword">for</span> (entry = head-&gt;lh_first; entry != NULL; chain_len++, entry = entry-&gt;hash_chain.le_next) {
		<span class="enscript-keyword">if</span> (memcmp(entry-&gt;str, name, len) == 0 &amp;&amp; entry-&gt;str[len] == 0) {
			entry-&gt;refcount++;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span> (entry == NULL) {
		lck_mtx_convert_spin(&amp;strcache_mtx_locks[lock_index]);
		<span class="enscript-comment">/*
		 * it wasn't already there so add it.
		 */</span>
		MALLOC(entry, string_t *, <span class="enscript-keyword">sizeof</span>(string_t) + len + 1, M_TEMP, M_WAITOK);

		<span class="enscript-keyword">if</span> (head-&gt;lh_first == NULL) {
			OSAddAtomic(1, &amp;filled_buckets);
		}
		ptr = (<span class="enscript-type">char</span> *)((<span class="enscript-type">char</span> *)entry + <span class="enscript-keyword">sizeof</span>(string_t));
		strncpy(ptr, name, len);
		ptr[len] = <span class="enscript-string">'\0'</span>;
		entry-&gt;str = ptr;
		entry-&gt;refcount = 1;
		LIST_INSERT_HEAD(head, entry, hash_chain);
	}
	<span class="enscript-keyword">if</span> (need_extra_ref == TRUE)
		entry-&gt;refcount++;
    
	lck_mtx_unlock(&amp;strcache_mtx_locks[lock_index]);
	lck_rw_done(strtable_rw_lock);

	<span class="enscript-keyword">return</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)entry-&gt;str;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_removename</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *nameref)
{
	<span class="enscript-type">struct</span> stringhead *head;
	string_t          *entry;
	uint32_t           hashval;
	uint32_t	   hash_index;
        uint32_t	   lock_index;
	<span class="enscript-type">int</span>		   retval = ENOENT;

	hashval = hash_string(nameref, 0);

	<span class="enscript-comment">/*
	 * take this lock 'shared' to keep the hash stable
	 * if someone else decides to grow the pool they
	 * will take this lock exclusively
	 */</span>
	lck_rw_lock_shared(strtable_rw_lock);
	<span class="enscript-comment">/*
	 * must compute the head behind the table lock
	 * since the size and location of the table
	 * can change on the fly
	 */</span>
	hash_index = hashval &amp; string_table_mask;
	lock_index = hash_index % NUM_STRCACHE_LOCKS;

	head = &amp;string_ref_table[hash_index];

	lck_mtx_lock_spin(&amp;strcache_mtx_locks[lock_index]);

	<span class="enscript-keyword">for</span> (entry = head-&gt;lh_first; entry != NULL; entry = entry-&gt;hash_chain.le_next) {
		<span class="enscript-keyword">if</span> (entry-&gt;str == nameref) {
			entry-&gt;refcount--;

			<span class="enscript-keyword">if</span> (entry-&gt;refcount == 0) {
				LIST_REMOVE(entry, hash_chain);

				<span class="enscript-keyword">if</span> (head-&gt;lh_first == NULL) {
					OSAddAtomic(-1, &amp;filled_buckets);
				}
			} <span class="enscript-keyword">else</span> {
				entry = NULL;
			}
			retval = 0;
			<span class="enscript-keyword">break</span>;
		}
	}
	lck_mtx_unlock(&amp;strcache_mtx_locks[lock_index]);
	lck_rw_done(strtable_rw_lock);

	<span class="enscript-keyword">if</span> (entry != NULL)
		FREE(entry, M_TEMP);

	<span class="enscript-keyword">return</span> retval;
}


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DUMP_STRING_TABLE</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dump_string_table</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">struct</span> stringhead *head;
    string_t          *entry;
    u_long            i;
    
    lck_rw_lock_shared(strtable_rw_lock);

    <span class="enscript-keyword">for</span> (i = 0; i &lt;= string_table_mask; i++) {
	head = &amp;string_ref_table[i];
	<span class="enscript-keyword">for</span> (entry=head-&gt;lh_first; entry != NULL; entry=entry-&gt;hash_chain.le_next) {
	    printf(<span class="enscript-string">&quot;%6d - %s\n&quot;</span>, entry-&gt;refcount, entry-&gt;str);
	}
    }
    lck_rw_done(strtable_rw_lock);
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* DUMP_STRING_TABLE */</span>
</pre>
<hr />
</body></html>