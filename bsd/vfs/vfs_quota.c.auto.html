<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_quota.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_quota.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2002-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1990, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Elz at The University of Melbourne.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)vfs_quota.c
 *	derived from @(#)ufs_quota.c	8.5 (Berkeley) 5/20/95
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/quota.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSByteOrder.h&gt;</span>


<span class="enscript-comment">/* vars for quota file lock */</span>
lck_grp_t	* qf_lck_grp;
lck_grp_attr_t	* qf_lck_grp_attr;
lck_attr_t	* qf_lck_attr;

<span class="enscript-comment">/* vars for quota list lock */</span>
lck_grp_t	* quota_list_lck_grp;
lck_grp_attr_t	* quota_list_lck_grp_attr;
lck_attr_t	* quota_list_lck_attr;
lck_mtx_t	* quota_list_mtx_lock;

<span class="enscript-comment">/* Routines to lock and unlock the quota global data */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dq_list_lock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dq_list_unlock</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dq_lock_internal</span>(<span class="enscript-type">struct</span> dquot *dq);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dq_unlock_internal</span>(<span class="enscript-type">struct</span> dquot *dq);

<span class="enscript-type">static</span> u_int32_t quotamagic[MAXQUOTAS] = INITQMAGICS;


<span class="enscript-comment">/*
 * Code pertaining to management of the in-core dquot data structures.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DQHASH</span>(dqvp, id) \
	(&amp;dqhashtbl[((((intptr_t)(dqvp)) &gt;&gt; 8) + id) &amp; dqhash])
<span class="enscript-function-name">LIST_HEAD</span>(dqhash, dquot) *dqhashtbl;
u_long dqhash;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DQUOTINC</span>	5	<span class="enscript-comment">/* minimum free dquots desired */</span>
<span class="enscript-type">long</span> numdquot, desireddquot = DQUOTINC;

<span class="enscript-comment">/*
 * Dquot free list.
 */</span>
<span class="enscript-function-name">TAILQ_HEAD</span>(dqfreelist, dquot) dqfreelist;
<span class="enscript-comment">/*
 * Dquot dirty orphans list
 */</span>
<span class="enscript-function-name">TAILQ_HEAD</span>(dqdirtylist, dquot) dqdirtylist;


<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">dqlookup</span>(<span class="enscript-type">struct</span> quotafile *, u_int32_t, <span class="enscript-type">struct</span>	dqblk *, u_int32_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">dqsync_locked</span>(<span class="enscript-type">struct</span> dquot *dq);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">qf_lock</span>(<span class="enscript-type">struct</span> quotafile *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">qf_unlock</span>(<span class="enscript-type">struct</span> quotafile *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">qf_ref</span>(<span class="enscript-type">struct</span> quotafile *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">qf_rele</span>(<span class="enscript-type">struct</span> quotafile *);


<span class="enscript-comment">/*
 * Initialize locks for the quota system.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dqinit</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * Allocate quota list lock group attribute and group
	 */</span>
	quota_list_lck_grp_attr= lck_grp_attr_alloc_init();
	quota_list_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;quota list&quot;</span>,  quota_list_lck_grp_attr);
	
	<span class="enscript-comment">/*
	 * Allocate qouta list lock attribute
	 */</span>
	quota_list_lck_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/*
	 * Allocate quota list lock
	 */</span>
	quota_list_mtx_lock = lck_mtx_alloc_init(quota_list_lck_grp, quota_list_lck_attr);


	<span class="enscript-comment">/*
	 * allocate quota file lock group attribute and group
	 */</span>
	qf_lck_grp_attr= lck_grp_attr_alloc_init();
	qf_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;quota file&quot;</span>, qf_lck_grp_attr);

	<span class="enscript-comment">/*
	 * Allocate quota file lock attribute
	 */</span>
	qf_lck_attr = lck_attr_alloc_init();
}

<span class="enscript-comment">/*
 * Report whether dqhashinit has been run.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dqisinitialized</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (dqhashtbl != NULL);
}

<span class="enscript-comment">/*
 * Initialize hash table for dquot structures.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dqhashinit</span>(<span class="enscript-type">void</span>)
{
	dq_list_lock();
	<span class="enscript-keyword">if</span> (dqisinitialized())
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	TAILQ_INIT(&amp;dqfreelist);
	TAILQ_INIT(&amp;dqdirtylist);
	dqhashtbl = hashinit(desiredvnodes, M_DQUOT, &amp;dqhash);
<span class="enscript-reference">out</span>:
	dq_list_unlock();
}


<span class="enscript-type">static</span> <span class="enscript-type">volatile</span> <span class="enscript-type">int</span> dq_list_lock_cnt = 0;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dq_list_lock</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock(quota_list_mtx_lock);
	<span class="enscript-keyword">return</span> ++dq_list_lock_cnt;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dq_list_lock_changed</span>(<span class="enscript-type">int</span> oldval) {
	<span class="enscript-keyword">return</span> (dq_list_lock_cnt != oldval);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dq_list_lock_val</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">return</span> dq_list_lock_cnt;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dq_list_unlock</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_unlock(quota_list_mtx_lock);
}


<span class="enscript-comment">/*
 * must be called with the quota_list_lock held
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dq_lock_internal</span>(<span class="enscript-type">struct</span> dquot *dq)
{
        <span class="enscript-keyword">while</span> (dq-&gt;dq_lflags &amp; DQ_LLOCK) {
	        dq-&gt;dq_lflags |= DQ_LWANT;
	        msleep(&amp;dq-&gt;dq_lflags, quota_list_mtx_lock, PVFS, <span class="enscript-string">&quot;dq_lock_internal&quot;</span>, NULL);
	}
	dq-&gt;dq_lflags |= DQ_LLOCK;
}

<span class="enscript-comment">/*
 * must be called with the quota_list_lock held
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dq_unlock_internal</span>(<span class="enscript-type">struct</span> dquot *dq)
{
        <span class="enscript-type">int</span> wanted = dq-&gt;dq_lflags &amp; DQ_LWANT;

	dq-&gt;dq_lflags &amp;= ~(DQ_LLOCK | DQ_LWANT);

	<span class="enscript-keyword">if</span> (wanted)
	        wakeup(&amp;dq-&gt;dq_lflags);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dqlock</span>(<span class="enscript-type">struct</span> dquot *dq) {

	lck_mtx_lock(quota_list_mtx_lock);

	dq_lock_internal(dq);

	lck_mtx_unlock(quota_list_mtx_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dqunlock</span>(<span class="enscript-type">struct</span> dquot *dq) {

	lck_mtx_lock(quota_list_mtx_lock);

	dq_unlock_internal(dq);

	lck_mtx_unlock(quota_list_mtx_lock);
}



<span class="enscript-type">int</span>
<span class="enscript-function-name">qf_get</span>(<span class="enscript-type">struct</span> quotafile *qfp, <span class="enscript-type">int</span> type)
{
        <span class="enscript-type">int</span> error = 0;

        dq_list_lock();
  
        <span class="enscript-keyword">switch</span> (type) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">QTF_OPENING</span>:
	        <span class="enscript-keyword">while</span> ( (qfp-&gt;qf_qflags &amp; (QTF_OPENING | QTF_CLOSING)) ) {
	                <span class="enscript-keyword">if</span> ( (qfp-&gt;qf_qflags &amp; QTF_OPENING) ) {
		                error = EBUSY;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> ( (qfp-&gt;qf_qflags &amp; QTF_CLOSING) ) {
		                qfp-&gt;qf_qflags |= QTF_WANTED;
				msleep(&amp;qfp-&gt;qf_qflags, quota_list_mtx_lock, PVFS, <span class="enscript-string">&quot;qf_get&quot;</span>, NULL);
			}
		}
		<span class="enscript-keyword">if</span> (qfp-&gt;qf_vp != NULLVP)
		        error = EBUSY;
		<span class="enscript-keyword">if</span> (error == 0)
		        qfp-&gt;qf_qflags |= QTF_OPENING;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">QTF_CLOSING</span>:
	        <span class="enscript-keyword">if</span> ( (qfp-&gt;qf_qflags &amp; QTF_CLOSING) ) {
		        error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		qfp-&gt;qf_qflags |= QTF_CLOSING;

		<span class="enscript-keyword">while</span> ( (qfp-&gt;qf_qflags &amp; QTF_OPENING) || qfp-&gt;qf_refcnt ) {
		        qfp-&gt;qf_qflags |= QTF_WANTED;
			msleep(&amp;qfp-&gt;qf_qflags, quota_list_mtx_lock, PVFS, <span class="enscript-string">&quot;qf_get&quot;</span>, NULL);
		}
		<span class="enscript-keyword">if</span> (qfp-&gt;qf_vp == NULLVP) {
		        qfp-&gt;qf_qflags &amp;= ~QTF_CLOSING;
			error = EBUSY;
		}
		<span class="enscript-keyword">break</span>;
	}
	dq_list_unlock();

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">qf_put</span>(<span class="enscript-type">struct</span> quotafile *qfp, <span class="enscript-type">int</span> type)
{

        dq_list_lock();

        <span class="enscript-keyword">switch</span> (type) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">QTF_OPENING</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">QTF_CLOSING</span>:
	        qfp-&gt;qf_qflags &amp;= ~type;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> ( (qfp-&gt;qf_qflags &amp; QTF_WANTED) ) {
	        qfp-&gt;qf_qflags &amp;= ~QTF_WANTED;
		wakeup(&amp;qfp-&gt;qf_qflags);
	}
	dq_list_unlock();
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">qf_lock</span>(<span class="enscript-type">struct</span> quotafile *qfp)
{
	lck_mtx_lock(&amp;qfp-&gt;qf_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">qf_unlock</span>(<span class="enscript-type">struct</span> quotafile *qfp)
{
	lck_mtx_unlock(&amp;qfp-&gt;qf_lock);
}


<span class="enscript-comment">/*
 * take a reference on the quota file while we're
 * in dqget... this will prevent a quota_off from
 * occurring while we're potentially playing with
 * the quota file... the quota_off will stall until
 * all the current references 'die'... once we start
 * into quoto_off, all new references will be rejected
 * we also don't want any dqgets being processed while
 * we're in the middle of the quota_on... once we've
 * actually got the quota file open and the associated
 * struct quotafile inited, we can let them come through
 *
 * quota list lock must be held on entry
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">qf_ref</span>(<span class="enscript-type">struct</span> quotafile *qfp)
{
        <span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> ( (qfp-&gt;qf_qflags &amp; (QTF_OPENING | QTF_CLOSING)) || (qfp-&gt;qf_vp == NULLVP) )
	        error = EINVAL;
	<span class="enscript-keyword">else</span>
	        qfp-&gt;qf_refcnt++;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * drop our reference and wakeup any waiters if 
 * we were the last one holding a ref
 *
 * quota list lock must be held on entry
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">qf_rele</span>(<span class="enscript-type">struct</span> quotafile *qfp)
{
	qfp-&gt;qf_refcnt--;

	<span class="enscript-keyword">if</span> ( (qfp-&gt;qf_qflags &amp; QTF_WANTED) &amp;&amp; qfp-&gt;qf_refcnt == 0) {
	        qfp-&gt;qf_qflags &amp;= ~QTF_WANTED;
	        wakeup(&amp;qfp-&gt;qf_qflags);
	}
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">dqfileinit</span>(<span class="enscript-type">struct</span> quotafile *qfp)
{
        qfp-&gt;qf_vp = NULLVP;
	qfp-&gt;qf_qflags = 0;

	lck_mtx_init(&amp;qfp-&gt;qf_lock, qf_lck_grp, qf_lck_attr);
}


<span class="enscript-comment">/*
 * Initialize a quota file
 *
 * must be called with the quota file lock held
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dqfileopen</span>(<span class="enscript-type">struct</span> quotafile *qfp, <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> dqfilehdr header;
	<span class="enscript-type">struct</span> vfs_context context;
	off_t file_size;
	uio_t auio;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];

	context.vc_thread = current_thread();
	context.vc_ucred = qfp-&gt;qf_cred;
	
	<span class="enscript-comment">/* Obtain the file size */</span>
	<span class="enscript-keyword">if</span> ((error = vnode_size(qfp-&gt;qf_vp, &amp;file_size, &amp;context)) != 0)
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* Read the file header */</span>
	auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_READ, 
				    &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, CAST_USER_ADDR_T(&amp;header), <span class="enscript-keyword">sizeof</span> (header));
	error = VNOP_READ(qfp-&gt;qf_vp, auio, 0, &amp;context);
	<span class="enscript-keyword">if</span> (error)
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uio_resid(auio)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/* Sanity check the quota file header. */</span>
	<span class="enscript-keyword">if</span> ((OSSwapBigToHostInt32(header.dqh_magic) != quotamagic[type]) ||
	    (OSSwapBigToHostInt32(header.dqh_version) &gt; QF_VERSION) ||
	    (!powerof2(OSSwapBigToHostInt32(header.dqh_maxentries))) ||
	    (OSSwapBigToHostInt32(header.dqh_maxentries) &gt; (file_size / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> dqblk)))) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/* Set up the time limits for this quota. */</span>
	<span class="enscript-keyword">if</span> (header.dqh_btime != 0)
		qfp-&gt;qf_btime = OSSwapBigToHostInt32(header.dqh_btime);
	<span class="enscript-keyword">else</span>
		qfp-&gt;qf_btime = MAX_DQ_TIME;
	<span class="enscript-keyword">if</span> (header.dqh_itime != 0)
		qfp-&gt;qf_itime = OSSwapBigToHostInt32(header.dqh_itime);
	<span class="enscript-keyword">else</span>
		qfp-&gt;qf_itime = MAX_IQ_TIME;

	<span class="enscript-comment">/* Calculate the hash table constants. */</span>
	qfp-&gt;qf_maxentries = OSSwapBigToHostInt32(header.dqh_maxentries);
	qfp-&gt;qf_entrycnt = OSSwapBigToHostInt32(header.dqh_entrycnt);
	qfp-&gt;qf_shift = dqhashshift(qfp-&gt;qf_maxentries);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Close down a quota file
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dqfileclose</span>(<span class="enscript-type">struct</span> quotafile *qfp, __unused <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> dqfilehdr header;
	<span class="enscript-type">struct</span> vfs_context context;
	uio_t auio;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];

	auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_READ, 
								  &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, CAST_USER_ADDR_T(&amp;header), <span class="enscript-keyword">sizeof</span> (header));

	context.vc_thread = current_thread();
	context.vc_ucred = qfp-&gt;qf_cred;
	
	<span class="enscript-keyword">if</span> (VNOP_READ(qfp-&gt;qf_vp, auio, 0, &amp;context) == 0) {
		header.dqh_entrycnt = OSSwapHostToBigInt32(qfp-&gt;qf_entrycnt);
		uio_reset(auio, 0, UIO_SYSSPACE, UIO_WRITE);
		uio_addiov(auio, CAST_USER_ADDR_T(&amp;header), <span class="enscript-keyword">sizeof</span> (header));
		(<span class="enscript-type">void</span>) VNOP_WRITE(qfp-&gt;qf_vp, auio, 0, &amp;context);
	}
}


<span class="enscript-comment">/*
 * Obtain a dquot structure for the specified identifier and quota file
 * reading the information from the file if necessary.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dqget</span>(u_int32_t id, <span class="enscript-type">struct</span> quotafile *qfp, <span class="enscript-type">int</span> type, <span class="enscript-type">struct</span> dquot **dqp)
{
	<span class="enscript-type">struct</span> dquot *dq;
	<span class="enscript-type">struct</span> dquot *ndq = NULL;
	<span class="enscript-type">struct</span> dquot *fdq = NULL;
	<span class="enscript-type">struct</span> dqhash *dqh;
	<span class="enscript-type">struct</span> vnode *dqvp;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> listlockval = 0;

	<span class="enscript-keyword">if</span> (!dqisinitialized()) {
		*dqp = NODQUOT;
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> ( id == 0 || qfp-&gt;qf_vp == NULLVP ) {
		*dqp = NODQUOT;
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	dq_list_lock();

	<span class="enscript-keyword">if</span> ( (qf_ref(qfp)) ) {
	        dq_list_unlock();

		*dqp = NODQUOT;
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> ( (dqvp = qfp-&gt;qf_vp) == NULLVP ) {
	        qf_rele(qfp);
		dq_list_unlock();

		*dqp = NODQUOT;
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	dqh = DQHASH(dqvp, id);

<span class="enscript-reference">relookup</span>:
	listlockval = dq_list_lock_val();

	<span class="enscript-comment">/*
	 * Check the cache first.
	 */</span>
	<span class="enscript-keyword">for</span> (dq = dqh-&gt;lh_first; dq; dq = dq-&gt;dq_hash.le_next) {
		<span class="enscript-keyword">if</span> (dq-&gt;dq_id != id ||
		    dq-&gt;dq_qfile-&gt;qf_vp != dqvp)
			<span class="enscript-keyword">continue</span>;

		dq_lock_internal(dq);
		<span class="enscript-keyword">if</span> (dq_list_lock_changed(listlockval)) {
			dq_unlock_internal(dq);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">relookup</span>;
		}

		<span class="enscript-comment">/*
		 * dq_lock_internal may drop the quota_list_lock to msleep, so
		 * we need to re-evaluate the identity of this dq
		 */</span>
		<span class="enscript-keyword">if</span> (dq-&gt;dq_id != id || dq-&gt;dq_qfile == NULL ||
		    dq-&gt;dq_qfile-&gt;qf_vp != dqvp) {
		        dq_unlock_internal(dq);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">relookup</span>;
		}
		<span class="enscript-comment">/*
		 * Cache hit with no references.  Take
		 * the structure off the free list.
		 */</span>
		<span class="enscript-keyword">if</span> (dq-&gt;dq_cnt++ == 0) {
			<span class="enscript-keyword">if</span> (dq-&gt;dq_flags &amp; DQ_MOD)
				TAILQ_REMOVE(&amp;dqdirtylist, dq, dq_freelist);
			<span class="enscript-keyword">else</span>
				TAILQ_REMOVE(&amp;dqfreelist, dq, dq_freelist);
		}
		dq_unlock_internal(dq);

		<span class="enscript-keyword">if</span> (fdq != NULL) {
		        <span class="enscript-comment">/*
			 * we grabbed this from the free list in the first pass
			 * but we found the dq we were looking for in
			 * the cache the 2nd time through
			 * so stick it back on the free list and return the cached entry
			 */</span>
		        TAILQ_INSERT_HEAD(&amp;dqfreelist, fdq, dq_freelist);
		}
		qf_rele(qfp);
	        dq_list_unlock();
		
		<span class="enscript-keyword">if</span> (ndq != NULL) {
		        <span class="enscript-comment">/*
			 * we allocated this in the first pass
			 * but we found the dq we were looking for in
			 * the cache the 2nd time through so free it
			 */</span>
		        _FREE(ndq, M_DQUOT);
		}
		*dqp = dq;

		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-comment">/*
	 * Not in cache, allocate a new one.
	 */</span>
	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;dqfreelist) &amp;&amp;
	    numdquot &lt; MAXQUOTAS * desiredvnodes)
		desireddquot += DQUOTINC;

	<span class="enscript-keyword">if</span> (fdq != NULL) {
	        <span class="enscript-comment">/*
		 * we captured this from the free list
		 * in the first pass through, so go
		 * ahead and use it
		 */</span>
	        dq = fdq;
		fdq = NULL;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (numdquot &lt; desireddquot) {
	        <span class="enscript-keyword">if</span> (ndq == NULL) {
		        <span class="enscript-comment">/*
			 * drop the quota list lock since MALLOC may block
			 */</span>
		        dq_list_unlock();

			ndq = (<span class="enscript-type">struct</span> dquot *)_MALLOC(<span class="enscript-keyword">sizeof</span> *dq, M_DQUOT, M_WAITOK);
			bzero((<span class="enscript-type">char</span> *)ndq, <span class="enscript-keyword">sizeof</span> *dq);

		        listlockval = dq_list_lock();
			<span class="enscript-comment">/*
			 * need to look for the entry again in the cache
			 * since we dropped the quota list lock and
			 * someone else may have beaten us to creating it
			 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">relookup</span>;
		} <span class="enscript-keyword">else</span> {
		        <span class="enscript-comment">/*
			 * we allocated this in the first pass through
			 * and we're still under out target, so go
			 * ahead and use it
			 */</span>
		        dq = ndq;
			ndq = NULL;
			numdquot++;
		}
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;dqfreelist)) {
		        qf_rele(qfp);
		        dq_list_unlock();

			<span class="enscript-keyword">if</span> (ndq) {
			        <span class="enscript-comment">/*
				 * we allocated this in the first pass through
				 * but we're now at the limit of our cache size
				 * so free it
				 */</span>
			        _FREE(ndq, M_DQUOT);
			}
			tablefull(<span class="enscript-string">&quot;dquot&quot;</span>);
			*dqp = NODQUOT;
			<span class="enscript-keyword">return</span> (EUSERS);
		}
		dq = TAILQ_FIRST(&amp;dqfreelist);

		dq_lock_internal(dq);

		<span class="enscript-keyword">if</span> (dq_list_lock_changed(listlockval) || dq-&gt;dq_cnt || (dq-&gt;dq_flags &amp; DQ_MOD)) {
		        <span class="enscript-comment">/*
			 * we lost the race while we weren't holding
			 * the quota list lock... dq_lock_internal
			 * will drop it to msleep... this dq has been
			 * reclaimed... go find another
			 */</span>
		        dq_unlock_internal(dq);

			<span class="enscript-comment">/*
			 * need to look for the entry again in the cache
			 * since we dropped the quota list lock and
			 * someone else may have beaten us to creating it
			 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">relookup</span>;
		}
		TAILQ_REMOVE(&amp;dqfreelist, dq, dq_freelist);

		<span class="enscript-keyword">if</span> (dq-&gt;dq_qfile != NULL) {
		        LIST_REMOVE(dq, dq_hash);
			dq-&gt;dq_qfile = NULL;
			dq-&gt;dq_id = 0;
		}
		dq_unlock_internal(dq);

		<span class="enscript-comment">/*
		 * because we may have dropped the quota list lock
		 * in the call to dq_lock_internal, we need to 
		 * relookup in the hash in case someone else
		 * caused a dq with this identity to be created...
		 * if we don't find it, we'll use this one
		 */</span>
		fdq = dq;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">relookup</span>;
	}
	<span class="enscript-comment">/*
	 * we've either freshly allocated a dq
	 * or we've atomically pulled it out of
	 * the hash and freelists... no one else
	 * can have a reference, which means no
	 * one else can be trying to use this dq
	 */</span>
	dq_lock_internal(dq);
	<span class="enscript-keyword">if</span> (dq_list_lock_changed(listlockval)) {
		dq_unlock_internal(dq);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">relookup</span>;
	}

	<span class="enscript-comment">/*
	 * Initialize the contents of the dquot structure.
	 */</span>
	dq-&gt;dq_cnt = 1;
	dq-&gt;dq_flags = 0;
	dq-&gt;dq_id = id;
	dq-&gt;dq_qfile = qfp;
	dq-&gt;dq_type = type;
	<span class="enscript-comment">/*
	 * once we insert it in the hash and
	 * drop the quota_list_lock, it can be
	 * 'found'... however, we're still holding
	 * the dq_lock which will keep us from doing
	 * anything with it until we've finished
	 * initializing it...
	 */</span>
	LIST_INSERT_HEAD(dqh, dq, dq_hash);
	dq_list_unlock();

	<span class="enscript-keyword">if</span> (ndq) {
	        <span class="enscript-comment">/*
		 * we allocated this in the first pass through
		 * but we didn't need it, so free it after
		 * we've droped the quota list lock
		 */</span>
	        _FREE(ndq, M_DQUOT);
	}

	error = dqlookup(qfp, id, &amp;dq-&gt;dq_dqb, &amp;dq-&gt;dq_index);

	<span class="enscript-comment">/*
	 * I/O error in reading quota file, release
	 * quota structure and reflect problem to caller.
	 */</span>
	<span class="enscript-keyword">if</span> (error) {
	        dq_list_lock();

		dq-&gt;dq_id = 0;
		dq-&gt;dq_qfile = NULL;
		LIST_REMOVE(dq, dq_hash);

		dq_unlock_internal(dq);
		qf_rele(qfp);
	        dq_list_unlock();

		dqrele(dq);

		*dqp = NODQUOT;
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-comment">/*
	 * Check for no limit to enforce.
	 * Initialize time values if necessary.
	 */</span>
	<span class="enscript-keyword">if</span> (dq-&gt;dq_isoftlimit == 0 &amp;&amp; dq-&gt;dq_bsoftlimit == 0 &amp;&amp;
	    dq-&gt;dq_ihardlimit == 0 &amp;&amp; dq-&gt;dq_bhardlimit == 0)
		dq-&gt;dq_flags |= DQ_FAKE;
	<span class="enscript-keyword">if</span> (dq-&gt;dq_id != 0) {
		<span class="enscript-type">struct</span> timeval tv;

		microtime(&amp;tv);
		<span class="enscript-keyword">if</span> (dq-&gt;dq_btime == 0)
			dq-&gt;dq_btime = tv.tv_sec + qfp-&gt;qf_btime;
		<span class="enscript-keyword">if</span> (dq-&gt;dq_itime == 0)
			dq-&gt;dq_itime = tv.tv_sec + qfp-&gt;qf_itime;
	}
	dq_list_lock();
	dq_unlock_internal(dq);
	qf_rele(qfp);
	dq_list_unlock();

	*dqp = dq;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Lookup a dqblk structure for the specified identifier and
 * quota file.  If there is no entry for this identifier then
 * one is inserted.  The actual hash table index is returned.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dqlookup</span>(<span class="enscript-type">struct</span> quotafile *qfp, u_int32_t id, <span class="enscript-type">struct</span> dqblk *dqb, uint32_t *index)
{
	<span class="enscript-type">struct</span> vnode *dqvp;
	<span class="enscript-type">struct</span> vfs_context context;
	uio_t auio;
	<span class="enscript-type">int</span> i, skip, last;
	u_int32_t mask;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];


	qf_lock(qfp);

	dqvp = qfp-&gt;qf_vp;

	context.vc_thread = current_thread();
	context.vc_ucred = qfp-&gt;qf_cred;

	mask = qfp-&gt;qf_maxentries - 1;
	i = dqhash1(id, qfp-&gt;qf_shift, mask);
	skip = dqhash2(id, mask);

	<span class="enscript-keyword">for</span> (last = (i + (qfp-&gt;qf_maxentries-1) * skip) &amp; mask;
	     i != last;
	     i = (i + skip) &amp; mask) {
		auio = uio_createwithbuffer(1, dqoffset(i), UIO_SYSSPACE, UIO_READ, 
									  &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
		uio_addiov(auio, CAST_USER_ADDR_T(dqb), <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> dqblk));
		error = VNOP_READ(dqvp, auio, 0, &amp;context);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;dqlookup: error %d looking up id %u at index %d\n&quot;</span>, error, id, i);
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uio_resid(auio)) {
			error = EIO;
			printf(<span class="enscript-string">&quot;dqlookup: error looking up id %u at index %d\n&quot;</span>, id, i);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * An empty entry means there is no entry
		 * with that id.  In this case a new dqb
		 * record will be inserted.
		 */</span>
		<span class="enscript-keyword">if</span> (dqb-&gt;dqb_id == 0) {
			bzero(dqb, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> dqblk));
			dqb-&gt;dqb_id = OSSwapHostToBigInt32(id);
			<span class="enscript-comment">/*
			 * Write back to reserve entry for this id
			 */</span>
			uio_reset(auio, dqoffset(i), UIO_SYSSPACE, UIO_WRITE);
			uio_addiov(auio, CAST_USER_ADDR_T(dqb), <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> dqblk));
			error = VNOP_WRITE(dqvp, auio, 0, &amp;context);
			<span class="enscript-keyword">if</span> (uio_resid(auio) &amp;&amp; error == 0)
				error = EIO;
			<span class="enscript-keyword">if</span> (error == 0)
				++qfp-&gt;qf_entrycnt;
			dqb-&gt;dqb_id = id;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* An id match means an entry was found. */</span>
		<span class="enscript-keyword">if</span> (OSSwapBigToHostInt32(dqb-&gt;dqb_id) == id) {
			dqb-&gt;dqb_bhardlimit = OSSwapBigToHostInt64(dqb-&gt;dqb_bhardlimit);
			dqb-&gt;dqb_bsoftlimit = OSSwapBigToHostInt64(dqb-&gt;dqb_bsoftlimit);
			dqb-&gt;dqb_curbytes   = OSSwapBigToHostInt64(dqb-&gt;dqb_curbytes);
			dqb-&gt;dqb_ihardlimit = OSSwapBigToHostInt32(dqb-&gt;dqb_ihardlimit);
			dqb-&gt;dqb_isoftlimit = OSSwapBigToHostInt32(dqb-&gt;dqb_isoftlimit);
			dqb-&gt;dqb_curinodes  = OSSwapBigToHostInt32(dqb-&gt;dqb_curinodes);
			dqb-&gt;dqb_btime      = OSSwapBigToHostInt32(dqb-&gt;dqb_btime);
			dqb-&gt;dqb_itime      = OSSwapBigToHostInt32(dqb-&gt;dqb_itime);
			dqb-&gt;dqb_id         = OSSwapBigToHostInt32(dqb-&gt;dqb_id);
			<span class="enscript-keyword">break</span>;
		}
	}
	qf_unlock(qfp);

	*index = i;  <span class="enscript-comment">/* remember index so we don't have to recompute it later */</span>

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Release a reference to a dquot.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dqrele</span>(<span class="enscript-type">struct</span> dquot *dq)
{

	<span class="enscript-keyword">if</span> (dq == NODQUOT)
		<span class="enscript-keyword">return</span>;
	dqlock(dq);

	<span class="enscript-keyword">if</span> (dq-&gt;dq_cnt &gt; 1) {
		dq-&gt;dq_cnt--;

		dqunlock(dq);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (dq-&gt;dq_flags &amp; DQ_MOD)
		(<span class="enscript-type">void</span>) dqsync_locked(dq);
	dq-&gt;dq_cnt--;

	dq_list_lock();
	TAILQ_INSERT_TAIL(&amp;dqfreelist, dq, dq_freelist);
        dq_unlock_internal(dq);
	dq_list_unlock();
}

<span class="enscript-comment">/*
 * Release a reference to a dquot but don't do any I/O.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dqreclaim</span>(<span class="enscript-type">struct</span> dquot *dq)
{

	<span class="enscript-keyword">if</span> (dq == NODQUOT)
		<span class="enscript-keyword">return</span>;

	dq_list_lock();
	dq_lock_internal(dq);

	<span class="enscript-keyword">if</span> (--dq-&gt;dq_cnt &gt; 0) {
	        dq_unlock_internal(dq);
		dq_list_unlock();
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (dq-&gt;dq_flags &amp; DQ_MOD)
		TAILQ_INSERT_TAIL(&amp;dqdirtylist, dq, dq_freelist);
	<span class="enscript-keyword">else</span>
		TAILQ_INSERT_TAIL(&amp;dqfreelist, dq, dq_freelist);

	dq_unlock_internal(dq);
	dq_list_unlock();
}

<span class="enscript-comment">/*
 * Update a quota file's orphaned disk quotas.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dqsync_orphans</span>(<span class="enscript-type">struct</span> quotafile *qfp)
{
	<span class="enscript-type">struct</span> dquot *dq;
	
	dq_list_lock();
  <span class="enscript-reference">loop</span>:
	TAILQ_FOREACH(dq, &amp;dqdirtylist, dq_freelist) {
		<span class="enscript-keyword">if</span> (dq-&gt;dq_qfile != qfp)
		        <span class="enscript-keyword">continue</span>;

		dq_lock_internal(dq);

		<span class="enscript-keyword">if</span> (dq-&gt;dq_qfile != qfp) {
		        <span class="enscript-comment">/*
			 * the identity of this dq changed while
			 * the quota_list_lock was dropped
			 * dq_lock_internal can drop it to msleep
			 */</span>
		        dq_unlock_internal(dq);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
		}
		<span class="enscript-keyword">if</span> ((dq-&gt;dq_flags &amp; DQ_MOD) == 0) {
		        <span class="enscript-comment">/*
			 * someone cleaned and removed this from
			 * the dq from the dirty list while the
			 * quota_list_lock was dropped
			 */</span>
		        dq_unlock_internal(dq);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
		}
		<span class="enscript-keyword">if</span> (dq-&gt;dq_cnt != 0)
			panic(<span class="enscript-string">&quot;dqsync_orphans: dquot in use&quot;</span>);

		TAILQ_REMOVE(&amp;dqdirtylist, dq, dq_freelist);

		dq_list_unlock();
		<span class="enscript-comment">/*
		 * we're still holding the dqlock at this point
		 * with the reference count == 0
		 * we shouldn't be able
		 * to pick up another one since we hold dqlock
		 */</span>
		(<span class="enscript-type">void</span>) dqsync_locked(dq);
			
		dq_list_lock();

		TAILQ_INSERT_TAIL(&amp;dqfreelist, dq, dq_freelist);

		dq_unlock_internal(dq);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
	}
	dq_list_unlock();
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">dqsync</span>(<span class="enscript-type">struct</span> dquot *dq)
{
        <span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (dq != NODQUOT) {
	        dqlock(dq);

		<span class="enscript-keyword">if</span> ( (dq-&gt;dq_flags &amp; DQ_MOD) )
	        error = dqsync_locked(dq);

		dqunlock(dq);
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Update the disk quota in the quota file.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dqsync_locked</span>(<span class="enscript-type">struct</span> dquot *dq)
{
	<span class="enscript-type">struct</span> vfs_context context;
	<span class="enscript-type">struct</span> vnode *dqvp;
	<span class="enscript-type">struct</span> dqblk dqb, *dqblkp;
	uio_t auio;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];

	<span class="enscript-keyword">if</span> (dq-&gt;dq_id == 0) {
	        dq-&gt;dq_flags &amp;= ~DQ_MOD;
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> (dq-&gt;dq_qfile == NULL)
		panic(<span class="enscript-string">&quot;dqsync: NULL dq_qfile&quot;</span>);
	<span class="enscript-keyword">if</span> ((dqvp = dq-&gt;dq_qfile-&gt;qf_vp) == NULLVP)
		panic(<span class="enscript-string">&quot;dqsync: NULL qf_vp&quot;</span>);

	auio = uio_createwithbuffer(1, dqoffset(dq-&gt;dq_index), UIO_SYSSPACE, 
								  UIO_WRITE, &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, CAST_USER_ADDR_T(&amp;dqb), <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> dqblk));

	context.vc_thread = current_thread();	<span class="enscript-comment">/* XXX */</span>
	context.vc_ucred = dq-&gt;dq_qfile-&gt;qf_cred;

	dqblkp = &amp;dq-&gt;dq_dqb;
	dqb.dqb_bhardlimit = OSSwapHostToBigInt64(dqblkp-&gt;dqb_bhardlimit);
	dqb.dqb_bsoftlimit = OSSwapHostToBigInt64(dqblkp-&gt;dqb_bsoftlimit);
	dqb.dqb_curbytes   = OSSwapHostToBigInt64(dqblkp-&gt;dqb_curbytes);
	dqb.dqb_ihardlimit = OSSwapHostToBigInt32(dqblkp-&gt;dqb_ihardlimit);
	dqb.dqb_isoftlimit = OSSwapHostToBigInt32(dqblkp-&gt;dqb_isoftlimit);
	dqb.dqb_curinodes  = OSSwapHostToBigInt32(dqblkp-&gt;dqb_curinodes);
	dqb.dqb_btime      = OSSwapHostToBigInt32(dqblkp-&gt;dqb_btime);
	dqb.dqb_itime      = OSSwapHostToBigInt32(dqblkp-&gt;dqb_itime);
	dqb.dqb_id         = OSSwapHostToBigInt32(dqblkp-&gt;dqb_id);
	dqb.dqb_spare[0]   = 0;
	dqb.dqb_spare[1]   = 0;
	dqb.dqb_spare[2]   = 0;
	dqb.dqb_spare[3]   = 0;

	error = VNOP_WRITE(dqvp, auio, 0, &amp;context);
	<span class="enscript-keyword">if</span> (uio_resid(auio) &amp;&amp; error == 0)
		error = EIO;
	dq-&gt;dq_flags &amp;= ~DQ_MOD;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Flush all entries from the cache for a particular vnode.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dqflush</span>(<span class="enscript-type">struct</span> vnode *vp)
{
	<span class="enscript-type">struct</span> dquot *dq, *nextdq;
	<span class="enscript-type">struct</span> dqhash *dqh;

	<span class="enscript-keyword">if</span> (!dqisinitialized())
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Move all dquot's that used to refer to this quota
	 * file off their hash chains (they will eventually
	 * fall off the head of the free list and be re-used).
	 */</span>
	dq_list_lock();

	<span class="enscript-keyword">for</span> (dqh = &amp;dqhashtbl[dqhash]; dqh &gt;= dqhashtbl; dqh--) {
		<span class="enscript-keyword">for</span> (dq = dqh-&gt;lh_first; dq; dq = nextdq) {
			nextdq = dq-&gt;dq_hash.le_next;
			<span class="enscript-keyword">if</span> (dq-&gt;dq_qfile-&gt;qf_vp != vp)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (dq-&gt;dq_cnt)
				panic(<span class="enscript-string">&quot;dqflush: stray dquot&quot;</span>);
			LIST_REMOVE(dq, dq_hash);
			dq-&gt;dq_qfile = NULL;
		}
	}
	dq_list_unlock();
}

<span class="enscript-comment">/*
 * LP64 support for munging dqblk structure.
 * XXX conversion of user_time_t to time_t loses precision; not an issue for 
 * XXX us now, since we are only ever setting 32 bits worth of time into it.
 */</span>
__private_extern__ <span class="enscript-type">void</span> 
<span class="enscript-function-name">munge_dqblk</span>(<span class="enscript-type">struct</span> dqblk *dqblkp, <span class="enscript-type">struct</span> user_dqblk *user_dqblkp, boolean_t to64)
{
	<span class="enscript-keyword">if</span> (to64) {
		<span class="enscript-comment">/* munge kernel (32 bit) dqblk into user (64 bit) dqblk */</span>
		bcopy((caddr_t)dqblkp, (caddr_t)user_dqblkp, offsetof(<span class="enscript-type">struct</span> dqblk, dqb_btime));
		user_dqblkp-&gt;dqb_id = dqblkp-&gt;dqb_id;
		user_dqblkp-&gt;dqb_itime = dqblkp-&gt;dqb_itime;
		user_dqblkp-&gt;dqb_btime = dqblkp-&gt;dqb_btime;
	}
	<span class="enscript-keyword">else</span> {
		
		<span class="enscript-comment">/* munge user (64 bit) dqblk into kernel (32 bit) dqblk */</span>
		bcopy((caddr_t)user_dqblkp, (caddr_t)dqblkp, offsetof(<span class="enscript-type">struct</span> dqblk, dqb_btime));
		dqblkp-&gt;dqb_id = user_dqblkp-&gt;dqb_id;
		dqblkp-&gt;dqb_itime = user_dqblkp-&gt;dqb_itime;	<span class="enscript-comment">/* XXX - lose precision */</span>
		dqblkp-&gt;dqb_btime = user_dqblkp-&gt;dqb_btime;	<span class="enscript-comment">/* XXX - lose precision */</span>
	}
}
</pre>
<hr />
</body></html>