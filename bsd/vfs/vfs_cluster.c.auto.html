<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_cluster.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_cluster.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)vfs_cluster.c	8.10 (Berkeley) 3/28/95
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/trace.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vnode_pager.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/upl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_fault.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>  

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sdt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">KERNEL_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_DEBUG</span> KERNEL_DEBUG_CONSTANT
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_READ</span>		0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_WRITE</span>	0x02
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_ASYNC</span>	0x04
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_COMMIT</span>	0x08
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_PAGEOUT</span>	0x10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_AGE</span>		0x20
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_NOZERO</span>	0x40
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_PAGEIN</span>	0x80
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_DEV_MEMORY</span>	0x100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_PRESERVE</span>	0x200
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_THROTTLE</span>	0x400
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_KEEPCACHED</span>	0x800
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_DIRECT_IO</span>	0x1000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_PASSIVE</span>	0x2000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_IOSTREAMING</span>	0x4000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_CLOSE</span>	0x8000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CL_ENCRYPTED</span>	0x10000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_RAW_ENCRYPTED</span>	0x20000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_NOCACHE</span>	0x40000

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_VECTOR_UPL_ELEMENTS</span>	8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_VECTOR_UPL_SIZE</span>	(2 * MAX_UPL_SIZE_BYTES)

<span class="enscript-type">extern</span> upl_t <span class="enscript-function-name">vector_upl_create</span>(vm_offset_t);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">vector_upl_is_valid</span>(upl_t);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">vector_upl_set_subupl</span>(upl_t,upl_t, u_int32_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vector_upl_set_pagelist</span>(upl_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vector_upl_set_iostate</span>(upl_t, upl_t, vm_offset_t, u_int32_t);

<span class="enscript-type">struct</span> clios {
	lck_mtx_t io_mtxp;
        u_int  io_completed;       <span class="enscript-comment">/* amount of io that has currently completed */</span>
        u_int  io_issued;          <span class="enscript-comment">/* amount of io that was successfully issued */</span>
        <span class="enscript-type">int</span>    io_error;           <span class="enscript-comment">/* error code of first error encountered */</span>
        <span class="enscript-type">int</span>    io_wanted;          <span class="enscript-comment">/* someone is sleeping waiting for a change in state */</span>
};

<span class="enscript-type">struct</span> cl_direct_read_lock {
	LIST_ENTRY(cl_direct_read_lock)		chain;
	int32_t								ref_count;
	vnode_t								vp;
	lck_rw_t							rw_lock;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CL_DIRECT_READ_LOCK_BUCKETS</span> 61

<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(cl_direct_read_locks, cl_direct_read_lock)
	cl_direct_read_locks[CL_DIRECT_READ_LOCK_BUCKETS];

<span class="enscript-type">static</span> lck_spin_t cl_direct_read_spin_lock;

<span class="enscript-type">static</span> lck_grp_t	*cl_mtx_grp;
<span class="enscript-type">static</span> lck_attr_t	*cl_mtx_attr;
<span class="enscript-type">static</span> lck_grp_attr_t   *cl_mtx_grp_attr;
<span class="enscript-type">static</span> lck_mtx_t	*cl_transaction_mtxp;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_UNKNOWN</span>	0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IO_DIRECT</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_CONTIG</span>	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_COPY</span>		3

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PUSH_DELAY</span>	0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PUSH_ALL</span>	0x02
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PUSH_SYNC</span>	0x04


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cluster_EOT</span>(buf_t cbp_head, buf_t cbp_tail, <span class="enscript-type">int</span> zero_offset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cluster_wait_IO</span>(buf_t cbp_head, <span class="enscript-type">int</span> async);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cluster_complete_transaction</span>(buf_t *cbp_head, <span class="enscript-type">void</span> *callback_arg, <span class="enscript-type">int</span> *retval, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> needwait);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_io_type</span>(<span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> *io_type, u_int32_t *io_length, u_int32_t min_length);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_io</span>(vnode_t vp, upl_t upl, vm_offset_t upl_offset, off_t f_offset, <span class="enscript-type">int</span> non_rounded_size,
		      <span class="enscript-type">int</span> flags, buf_t real_bp, <span class="enscript-type">struct</span> clios *iostate, <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_iodone</span>(buf_t bp, <span class="enscript-type">void</span> *callback_arg);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_ioerror</span>(upl_t upl, <span class="enscript-type">int</span> upl_offset, <span class="enscript-type">int</span> abort_size, <span class="enscript-type">int</span> error, <span class="enscript-type">int</span> io_flags, vnode_t vp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_is_throttled</span>(vnode_t vp);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cluster_iostate_wait</span>(<span class="enscript-type">struct</span> clios *iostate, u_int target, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *wait_name);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cluster_syncup</span>(vnode_t vp, off_t newEOF, <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg, <span class="enscript-type">int</span> flags);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cluster_read_upl_release</span>(upl_t upl, <span class="enscript-type">int</span> start_pg, <span class="enscript-type">int</span> last_pg, <span class="enscript-type">int</span> take_reference);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_copy_ubc_data_internal</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> *io_resid, <span class="enscript-type">int</span> mark_dirty, <span class="enscript-type">int</span> take_reference);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_read_copy</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, u_int32_t io_req_size,  off_t filesize, <span class="enscript-type">int</span> flags,
			     <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_read_direct</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, off_t filesize, <span class="enscript-type">int</span> *read_type, u_int32_t *read_length,
			       <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_read_contig</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, off_t filesize, <span class="enscript-type">int</span> *read_type, u_int32_t *read_length,
			       <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg, <span class="enscript-type">int</span> flags);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_write_copy</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, u_int32_t io_req_size, off_t oldEOF, off_t newEOF,
			      off_t headOff, off_t tailOff, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_write_direct</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, off_t oldEOF, off_t newEOF,
				<span class="enscript-type">int</span> *write_type, u_int32_t *write_length, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_write_contig</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, off_t newEOF,
				<span class="enscript-type">int</span> *write_type, u_int32_t *write_length, <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg, <span class="enscript-type">int</span> bflag);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cluster_align_phys_io</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, addr64_t usr_paddr, u_int32_t xsize, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 	cluster_read_prefetch(vnode_t vp, off_t f_offset, u_int size, off_t filesize, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg, <span class="enscript-type">int</span> bflag);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	cluster_read_ahead(vnode_t vp, <span class="enscript-type">struct</span> cl_extent *extent, off_t filesize, <span class="enscript-type">struct</span> cl_readahead *ra, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg, <span class="enscript-type">int</span> bflag);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	cluster_push_now(vnode_t vp, <span class="enscript-type">struct</span> cl_extent *, off_t EOF, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	cluster_try_push(<span class="enscript-type">struct</span> cl_writebehind *, vnode_t vp, off_t EOF, <span class="enscript-type">int</span> push_flag, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	sparse_cluster_switch(<span class="enscript-type">struct</span> cl_writebehind *, vnode_t vp, off_t EOF, <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	sparse_cluster_push(<span class="enscript-type">void</span> **cmapp, vnode_t vp, off_t EOF, <span class="enscript-type">int</span> push_flag, <span class="enscript-type">int</span> io_flags, <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	sparse_cluster_add(<span class="enscript-type">void</span> **cmapp, vnode_t vp, <span class="enscript-type">struct</span> cl_extent *, off_t EOF, <span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg);

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">vfs_drt_mark_pages</span>(<span class="enscript-type">void</span> **cmapp, off_t offset, u_int length, u_int *setcountp);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">vfs_drt_get_cluster</span>(<span class="enscript-type">void</span> **cmapp, off_t *offsetp, u_int *lengthp);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">vfs_drt_control</span>(<span class="enscript-type">void</span> **cmapp, <span class="enscript-type">int</span> op_type);


<span class="enscript-comment">/*
 * For throttled IO to check whether
 * a block is cached by the boot cache
 * and thus it can avoid delaying the IO.
 *
 * bootcache_contains_block is initially
 * NULL. The BootCache will set it while
 * the cache is active and clear it when
 * the cache is jettisoned.
 *
 * Returns 0 if the block is not
 * contained in the cache, 1 if it is
 * contained.
 *
 * The function pointer remains valid
 * after the cache has been evicted even
 * if bootcache_contains_block has been
 * cleared.
 *
 * See rdar://9974130 The new throttling mechanism breaks the boot cache for throttled IOs
 */</span>
<span class="enscript-function-name">int</span> (*bootcache_contains_block)(dev_t device, u_int64_t blkno) = NULL;


<span class="enscript-comment">/*
 * limit the internal I/O size so that we
 * can represent it in a 32 bit int
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_IO_REQUEST_SIZE</span>	(1024 * 1024 * 512)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_IO_CONTIG_SIZE</span>	MAX_UPL_SIZE_BYTES
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_VECTS</span>		16
<span class="enscript-comment">/*
 * The MIN_DIRECT_WRITE_SIZE governs how much I/O should be issued before we consider
 * allowing the caller to bypass the buffer cache.  For small I/Os (less than 16k), 
 * we have not historically allowed the write to bypass the UBC. 
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MIN_DIRECT_WRITE_SIZE</span>	(16384)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WRITE_THROTTLE</span>		6
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WRITE_THROTTLE_SSD</span>	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WRITE_BEHIND</span>		1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WRITE_BEHIND_SSD</span>	1

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PREFETCH</span>		3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PREFETCH_SSD</span>		2
uint32_t speculative_prefetch_max = (MAX_UPL_SIZE_BYTES * 3);	<span class="enscript-comment">/* maximum bytes in a specluative read-ahead */</span>
uint32_t speculative_prefetch_max_iosize = (512 * 1024);	<span class="enscript-comment">/* maximum I/O size to use in a specluative read-ahead on SSDs*/</span>


#<span class="enscript-reference">define</span> <span class="enscript-function-name">IO_SCALE</span>(vp, base)		(vp-&gt;v_mount-&gt;mnt_ioscale * (base))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MAX_CLUSTER_SIZE</span>(vp)		(cluster_max_io_size(vp-&gt;v_mount, CL_WRITE))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MAX_PREFETCH</span>(vp, size, is_ssd)	(size * IO_SCALE(vp, ((is_ssd &amp;&amp; !ignore_is_ssd) ? PREFETCH_SSD : PREFETCH)))

<span class="enscript-type">int</span>	ignore_is_ssd = 0;
<span class="enscript-type">int</span>	speculative_reads_disabled = 0;

<span class="enscript-comment">/*
 * throttle the number of async writes that
 * can be outstanding on a single vnode
 * before we issue a synchronous write 
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">THROTTLE_MAXCNT</span>	0

uint32_t throttle_max_iosize = (128 * 1024);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">THROTTLE_MAX_IOSIZE</span> (throttle_max_iosize)

<span class="enscript-function-name">SYSCTL_INT</span>(_debug, OID_AUTO, lowpri_throttle_max_iosize, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;throttle_max_iosize, 0, <span class="enscript-string">&quot;&quot;</span>);


<span class="enscript-type">void</span>
<span class="enscript-function-name">cluster_init</span>(<span class="enscript-type">void</span>) {
        <span class="enscript-comment">/*
	 * allocate lock group attribute and group
	 */</span>
        cl_mtx_grp_attr = lck_grp_attr_alloc_init();
	cl_mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;cluster I/O&quot;</span>, cl_mtx_grp_attr);
		
	<span class="enscript-comment">/*
	 * allocate the lock attribute
	 */</span>
	cl_mtx_attr = lck_attr_alloc_init();

	cl_transaction_mtxp = lck_mtx_alloc_init(cl_mtx_grp, cl_mtx_attr);

	<span class="enscript-keyword">if</span> (cl_transaction_mtxp == NULL)
	        panic(<span class="enscript-string">&quot;cluster_init: failed to allocate cl_transaction_mtxp&quot;</span>);

	lck_spin_init(&amp;cl_direct_read_spin_lock, cl_mtx_grp, cl_mtx_attr);

	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; CL_DIRECT_READ_LOCK_BUCKETS; ++i)
		LIST_INIT(&amp;cl_direct_read_locks[i]);
}


uint32_t
<span class="enscript-function-name">cluster_max_io_size</span>(mount_t mp, <span class="enscript-type">int</span> type)
{
	uint32_t	max_io_size;
	uint32_t	segcnt;
	uint32_t	maxcnt;

	<span class="enscript-keyword">switch</span>(type) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">CL_READ</span>:
		segcnt = mp-&gt;mnt_segreadcnt;
		maxcnt = mp-&gt;mnt_maxreadcnt;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">CL_WRITE</span>:
		segcnt = mp-&gt;mnt_segwritecnt;
		maxcnt = mp-&gt;mnt_maxwritecnt;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		segcnt = min(mp-&gt;mnt_segreadcnt, mp-&gt;mnt_segwritecnt);
		maxcnt = min(mp-&gt;mnt_maxreadcnt, mp-&gt;mnt_maxwritecnt);
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (segcnt &gt; (MAX_UPL_SIZE_BYTES &gt;&gt; PAGE_SHIFT)) {
	       <span class="enscript-comment">/*
		* don't allow a size beyond the max UPL size we can create
		*/</span>
               segcnt = MAX_UPL_SIZE_BYTES &gt;&gt; PAGE_SHIFT;
       }
       max_io_size = min((segcnt * PAGE_SIZE), maxcnt);

       <span class="enscript-keyword">if</span> (max_io_size &lt; MAX_UPL_TRANSFER_BYTES) {
	       <span class="enscript-comment">/*
		* don't allow a size smaller than the old fixed limit
		*/</span>
	       max_io_size = MAX_UPL_TRANSFER_BYTES;
       } <span class="enscript-keyword">else</span> {
	       <span class="enscript-comment">/*
		* make sure the size specified is a multiple of PAGE_SIZE
		*/</span>
	       max_io_size &amp;= ~PAGE_MASK;
       }
       <span class="enscript-keyword">return</span> (max_io_size);
}




#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CLW_ALLOCATE</span>		0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CLW_RETURNLOCKED</span>	0x02
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CLW_IONOCACHE</span>		0x04
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CLW_IOPASSIVE</span>	0x08

<span class="enscript-comment">/*
 * if the read ahead context doesn't yet exist,
 * allocate and initialize it...
 * the vnode lock serializes multiple callers
 * during the actual assignment... first one
 * to grab the lock wins... the other callers
 * will release the now unnecessary storage
 * 
 * once the context is present, try to grab (but don't block on)
 * the lock associated with it... if someone
 * else currently owns it, than the read
 * will run without read-ahead.  this allows
 * multiple readers to run in parallel and
 * since there's only 1 read ahead context,
 * there's no real loss in only allowing 1
 * reader to have read-ahead enabled.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cl_readahead *
<span class="enscript-function-name">cluster_get_rap</span>(vnode_t vp)
{
        <span class="enscript-type">struct</span> ubc_info		*ubc;
	<span class="enscript-type">struct</span> cl_readahead	*rap;

	ubc = vp-&gt;v_ubcinfo;

        <span class="enscript-keyword">if</span> ((rap = ubc-&gt;cl_rahead) == NULL) {
	        MALLOC_ZONE(rap, <span class="enscript-type">struct</span> cl_readahead *, <span class="enscript-keyword">sizeof</span> *rap, M_CLRDAHEAD, M_WAITOK);

		bzero(rap, <span class="enscript-keyword">sizeof</span> *rap);
		rap-&gt;cl_lastr = -1;
		lck_mtx_init(&amp;rap-&gt;cl_lockr, cl_mtx_grp, cl_mtx_attr);

		vnode_lock(vp);
		
		<span class="enscript-keyword">if</span> (ubc-&gt;cl_rahead == NULL)
		        ubc-&gt;cl_rahead = rap;
		<span class="enscript-keyword">else</span> {
		        lck_mtx_destroy(&amp;rap-&gt;cl_lockr, cl_mtx_grp);
		        FREE_ZONE((<span class="enscript-type">void</span> *)rap, <span class="enscript-keyword">sizeof</span> *rap, M_CLRDAHEAD);
			rap = ubc-&gt;cl_rahead;
		}
		vnode_unlock(vp);
	}
	<span class="enscript-keyword">if</span> (lck_mtx_try_lock(&amp;rap-&gt;cl_lockr) == TRUE)
	        <span class="enscript-keyword">return</span>(rap);
	
	<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> cl_readahead *)NULL);
}


<span class="enscript-comment">/*
 * if the write behind context doesn't yet exist,
 * and CLW_ALLOCATE is specified, allocate and initialize it...
 * the vnode lock serializes multiple callers
 * during the actual assignment... first one
 * to grab the lock wins... the other callers
 * will release the now unnecessary storage
 * 
 * if CLW_RETURNLOCKED is set, grab (blocking if necessary)
 * the lock associated with the write behind context before
 * returning
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cl_writebehind *
<span class="enscript-function-name">cluster_get_wbp</span>(vnode_t vp, <span class="enscript-type">int</span> flags)
{
        <span class="enscript-type">struct</span> ubc_info *ubc;
	<span class="enscript-type">struct</span> cl_writebehind *wbp;

	ubc = vp-&gt;v_ubcinfo;

        <span class="enscript-keyword">if</span> ((wbp = ubc-&gt;cl_wbehind) == NULL) {

	        <span class="enscript-keyword">if</span> ( !(flags &amp; CLW_ALLOCATE))
		        <span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> cl_writebehind *)NULL);
	  
	        MALLOC_ZONE(wbp, <span class="enscript-type">struct</span> cl_writebehind *, <span class="enscript-keyword">sizeof</span> *wbp, M_CLWRBEHIND, M_WAITOK);

		bzero(wbp, <span class="enscript-keyword">sizeof</span> *wbp);
		lck_mtx_init(&amp;wbp-&gt;cl_lockw, cl_mtx_grp, cl_mtx_attr);

		vnode_lock(vp);
		
		<span class="enscript-keyword">if</span> (ubc-&gt;cl_wbehind == NULL)
		        ubc-&gt;cl_wbehind = wbp;
		<span class="enscript-keyword">else</span> {
		        lck_mtx_destroy(&amp;wbp-&gt;cl_lockw, cl_mtx_grp);
		        FREE_ZONE((<span class="enscript-type">void</span> *)wbp, <span class="enscript-keyword">sizeof</span> *wbp, M_CLWRBEHIND);
			wbp = ubc-&gt;cl_wbehind;
		}
		vnode_unlock(vp);
	}
	<span class="enscript-keyword">if</span> (flags &amp; CLW_RETURNLOCKED)
	        lck_mtx_lock(&amp;wbp-&gt;cl_lockw);

	<span class="enscript-keyword">return</span> (wbp);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cluster_syncup</span>(vnode_t vp, off_t newEOF, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> cl_writebehind *wbp;

	<span class="enscript-keyword">if</span> ((wbp = cluster_get_wbp(vp, 0)) != NULL) {
	  
	        <span class="enscript-keyword">if</span> (wbp-&gt;cl_number) {
		        lck_mtx_lock(&amp;wbp-&gt;cl_lockw);

			cluster_try_push(wbp, vp, newEOF, PUSH_ALL | flags, 0, callback, callback_arg);

			lck_mtx_unlock(&amp;wbp-&gt;cl_lockw);
		}
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_io_present_in_BC</span>(vnode_t vp, off_t f_offset)
{
	daddr64_t blkno;
	size_t	  io_size;
	<span class="enscript-type">int</span> (*bootcache_check_fn)(dev_t device, u_int64_t blkno) = bootcache_contains_block;
	
	<span class="enscript-keyword">if</span> (bootcache_check_fn) {
		<span class="enscript-keyword">if</span> (VNOP_BLOCKMAP(vp, f_offset, PAGE_SIZE, &amp;blkno, &amp;io_size, NULL, VNODE_READ, NULL))
			<span class="enscript-keyword">return</span>(0);

		<span class="enscript-keyword">if</span> (io_size == 0)
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">if</span> (bootcache_check_fn(vp-&gt;v_mount-&gt;mnt_devvp-&gt;v_rdev, blkno))
			<span class="enscript-keyword">return</span>(1);
	}
	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">cluster_is_throttled</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> (throttle_io_will_be_throttled(-1, vp-&gt;v_mount));
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cluster_iostate_wait</span>(<span class="enscript-type">struct</span> clios *iostate, u_int target, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *wait_name)
{

	lck_mtx_lock(&amp;iostate-&gt;io_mtxp);

	<span class="enscript-keyword">while</span> ((iostate-&gt;io_issued - iostate-&gt;io_completed) &gt; target) {

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 95)) | DBG_FUNC_START,
			     iostate-&gt;io_issued, iostate-&gt;io_completed, target, 0, 0);

		iostate-&gt;io_wanted = 1;
		msleep((caddr_t)&amp;iostate-&gt;io_wanted, &amp;iostate-&gt;io_mtxp, PRIBIO + 1, wait_name, NULL);

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 95)) | DBG_FUNC_END,
			     iostate-&gt;io_issued, iostate-&gt;io_completed, target, 0, 0);
	}	
	lck_mtx_unlock(&amp;iostate-&gt;io_mtxp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cluster_handle_associated_upl</span>(<span class="enscript-type">struct</span> clios *iostate, upl_t upl,
										  upl_offset_t upl_offset, upl_size_t size)
{
	<span class="enscript-keyword">if</span> (!size)
		<span class="enscript-keyword">return</span>;

	upl_t associated_upl = upl_associated_upl(upl);

	<span class="enscript-keyword">if</span> (!associated_upl)
		<span class="enscript-keyword">return</span>;

#<span class="enscript-reference">if</span> 0
	printf(<span class="enscript-string">&quot;1: %d %d\n&quot;</span>, upl_offset, upl_offset + size);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * The associated UPL is page aligned to file offsets whereas the
	 * UPL it's attached to has different alignment requirements.  The
	 * upl_offset that we have refers to @upl.  The code that follows
	 * has to deal with the first and last pages in this transaction
	 * which might straddle pages in the associated UPL.  To keep
	 * track of these pages, we use the mark bits: if the mark bit is
	 * set, we know another transaction has completed its part of that
	 * page and so we can unlock that page here.
	 *
	 * The following illustrates what we have to deal with:
	 *
	 *    MEM u &lt;------------ 1 PAGE ------------&gt; e
	 *        +-------------+----------------------+-----------------
	 *        |             |######################|#################
	 *        +-------------+----------------------+-----------------
	 *   FILE | &lt;--- a ---&gt; o &lt;------------ 1 PAGE ------------&gt;
	 *
	 * So here we show a write to offset @o.  The data that is to be
	 * written is in a buffer that is not page aligned; it has offset
	 * @a in the page.  The upl that carries the data starts in memory
	 * at @u.  The associated upl starts in the file at offset @o.  A
	 * transaction will always end on a page boundary (like @e above)
	 * except for the very last transaction in the group.  We cannot
	 * unlock the page at @o in the associated upl until both the
	 * transaction ending at @e and the following transaction (that
	 * starts at @e) has completed.
	 */</span>

	<span class="enscript-comment">/*
	 * We record whether or not the two UPLs are aligned as the mark
	 * bit in the first page of @upl.
	 */</span>
	upl_page_info_t *pl = UPL_GET_INTERNAL_PAGE_LIST(upl);
	bool is_unaligned = upl_page_get_mark(pl, 0);

	<span class="enscript-keyword">if</span> (is_unaligned) {
		upl_page_info_t *assoc_pl = UPL_GET_INTERNAL_PAGE_LIST(associated_upl);

		upl_offset_t upl_end = upl_offset + size;
		assert(upl_end &gt;= PAGE_SIZE);

		upl_size_t assoc_upl_size = upl_get_size(associated_upl);

		<span class="enscript-comment">/*
		 * In the very first transaction in the group, upl_offset will
		 * not be page aligned, but after that it will be and in that
		 * case we want the preceding page in the associated UPL hence
		 * the minus one.
		 */</span>
		assert(upl_offset);
		<span class="enscript-keyword">if</span> (upl_offset)
			upl_offset = trunc_page_32(upl_offset - 1);

		lck_mtx_lock_spin(&amp;iostate-&gt;io_mtxp);

		<span class="enscript-comment">// Look at the first page...
</span>		<span class="enscript-keyword">if</span> (upl_offset
			&amp;&amp; !upl_page_get_mark(assoc_pl, upl_offset &gt;&gt; PAGE_SHIFT)) {
			<span class="enscript-comment">/*
			 * The first page isn't marked so let another transaction
			 * completion handle it.
			 */</span>
			upl_page_set_mark(assoc_pl, upl_offset &gt;&gt; PAGE_SHIFT, true);
			upl_offset += PAGE_SIZE;
		}

		<span class="enscript-comment">// And now the last page...
</span>
		<span class="enscript-comment">/*
		 * This needs to be &gt; rather than &gt;= because if it's equal, it
		 * means there's another transaction that is sharing the last
		 * page.
		 */</span>
		<span class="enscript-keyword">if</span> (upl_end &gt; assoc_upl_size)
			upl_end = assoc_upl_size;
		<span class="enscript-keyword">else</span> {
			upl_end = trunc_page_32(upl_end);
			<span class="enscript-type">const</span> <span class="enscript-type">int</span> last_pg = (upl_end &gt;&gt; PAGE_SHIFT) - 1;

			<span class="enscript-keyword">if</span> (!upl_page_get_mark(assoc_pl, last_pg)) {
				<span class="enscript-comment">/*
				 * The last page isn't marked so mark the page and let another
				 * transaction completion handle it.
				 */</span>
				upl_page_set_mark(assoc_pl, last_pg, true);
				upl_end -= PAGE_SIZE;
			}
		}

		lck_mtx_unlock(&amp;iostate-&gt;io_mtxp);

#<span class="enscript-reference">if</span> 0
		printf(<span class="enscript-string">&quot;2: %d %d\n&quot;</span>, upl_offset, upl_end);
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">if</span> (upl_end &lt;= upl_offset)
			<span class="enscript-keyword">return</span>;

		size = upl_end - upl_offset;
	} <span class="enscript-keyword">else</span> {
		assert(!(upl_offset &amp; PAGE_MASK));
		assert(!(size &amp; PAGE_MASK));
	}

	boolean_t empty;

	<span class="enscript-comment">/*
	 * We can unlock these pages now and as this is for a
	 * direct/uncached write, we want to dump the pages too.
	 */</span>
	kern_return_t kr = upl_abort_range(associated_upl, upl_offset, size,
									   UPL_ABORT_DUMP_PAGES, &amp;empty);

	assert(!kr);

	<span class="enscript-keyword">if</span> (!kr &amp;&amp; empty) {
		upl_set_associated_upl(upl, NULL);
		upl_deallocate(associated_upl);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_ioerror</span>(upl_t upl, <span class="enscript-type">int</span> upl_offset, <span class="enscript-type">int</span> abort_size, <span class="enscript-type">int</span> error, <span class="enscript-type">int</span> io_flags, vnode_t vp)
{
        <span class="enscript-type">int</span> upl_abort_code = 0;
	<span class="enscript-type">int</span> page_in  = 0;
	<span class="enscript-type">int</span> page_out = 0;

	<span class="enscript-keyword">if</span> ((io_flags &amp; (B_PHYS | B_CACHE)) == (B_PHYS | B_CACHE))
	        <span class="enscript-comment">/*
		 * direct write of any flavor, or a direct read that wasn't aligned
		 */</span>
	        ubc_upl_commit_range(upl, upl_offset, abort_size, UPL_COMMIT_FREE_ON_EMPTY);
	<span class="enscript-keyword">else</span> {
	        <span class="enscript-keyword">if</span> (io_flags &amp; B_PAGEIO) {
		        <span class="enscript-keyword">if</span> (io_flags &amp; B_READ)
			        page_in  = 1;
			<span class="enscript-keyword">else</span>
			        page_out = 1;
		}
		<span class="enscript-keyword">if</span> (io_flags &amp; B_CACHE)
		        <span class="enscript-comment">/*
			 * leave pages in the cache unchanged on error
			 */</span>
		        upl_abort_code = UPL_ABORT_FREE_ON_EMPTY;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (page_out &amp;&amp; ((error != ENXIO) || vnode_isswap(vp)))
		        <span class="enscript-comment">/*
			 * transient error... leave pages unchanged
			 */</span>
		        upl_abort_code = UPL_ABORT_FREE_ON_EMPTY;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (page_in)
		        upl_abort_code = UPL_ABORT_FREE_ON_EMPTY | UPL_ABORT_ERROR;
		<span class="enscript-keyword">else</span>
		        upl_abort_code = UPL_ABORT_FREE_ON_EMPTY | UPL_ABORT_DUMP_PAGES;

		ubc_upl_abort_range(upl, upl_offset, abort_size, upl_abort_code);
	}
	<span class="enscript-keyword">return</span> (upl_abort_code);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_iodone</span>(buf_t bp, <span class="enscript-type">void</span> *callback_arg)
{
        <span class="enscript-type">int</span>	b_flags;
        <span class="enscript-type">int</span>	error;
	<span class="enscript-type">int</span>	total_size;
	<span class="enscript-type">int</span>	total_resid;
	<span class="enscript-type">int</span>	upl_offset;
	<span class="enscript-type">int</span>	zero_offset;
	<span class="enscript-type">int</span>	pg_offset = 0;
        <span class="enscript-type">int</span>	commit_size = 0;
        <span class="enscript-type">int</span>	upl_flags = 0;
	<span class="enscript-type">int</span>	transaction_size = 0;
	upl_t	upl;
	buf_t	cbp;
	buf_t	cbp_head;
	buf_t	cbp_next;
	buf_t	real_bp;
	vnode_t	vp;
	<span class="enscript-type">struct</span>	clios *iostate;
	boolean_t	transaction_complete = FALSE;

	__IGNORE_WCASTALIGN(cbp_head = (buf_t)(bp-&gt;b_trans_head));

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 20)) | DBG_FUNC_START,
		     cbp_head, bp-&gt;b_lblkno, bp-&gt;b_bcount, bp-&gt;b_flags, 0);

	<span class="enscript-keyword">if</span> (cbp_head-&gt;b_trans_next || !(cbp_head-&gt;b_flags &amp; B_EOT)) {
		boolean_t	need_wakeup = FALSE;

		lck_mtx_lock_spin(cl_transaction_mtxp);

		bp-&gt;b_flags |= B_TDONE;

		<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_TWANTED) {
			CLR(bp-&gt;b_flags, B_TWANTED);
			need_wakeup = TRUE;
		}
		<span class="enscript-keyword">for</span> (cbp = cbp_head; cbp; cbp = cbp-&gt;b_trans_next) {
			<span class="enscript-comment">/*
			 * all I/O requests that are part of this transaction
			 * have to complete before we can process it
			 */</span>
			<span class="enscript-keyword">if</span> ( !(cbp-&gt;b_flags &amp; B_TDONE)) {

				KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 20)) | DBG_FUNC_END,
					     cbp_head, cbp, cbp-&gt;b_bcount, cbp-&gt;b_flags, 0);

				lck_mtx_unlock(cl_transaction_mtxp);

				<span class="enscript-keyword">if</span> (need_wakeup == TRUE)
					wakeup(bp);

				<span class="enscript-keyword">return</span> 0;
			}
			<span class="enscript-keyword">if</span> (cbp-&gt;b_flags &amp; B_EOT)
				transaction_complete = TRUE;
		}
		lck_mtx_unlock(cl_transaction_mtxp);

		<span class="enscript-keyword">if</span> (need_wakeup == TRUE)
			wakeup(bp);

		<span class="enscript-keyword">if</span> (transaction_complete == FALSE) {
			KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 20)) | DBG_FUNC_END,
				     cbp_head, 0, 0, 0, 0);
			<span class="enscript-keyword">return</span> 0;
		}
	}
	error       = 0;
	total_size  = 0;
	total_resid = 0;

	cbp        = cbp_head;
	vp	   = cbp-&gt;b_vp;
	upl_offset = cbp-&gt;b_uploffset;
	upl        = cbp-&gt;b_upl;
	b_flags    = cbp-&gt;b_flags;
	real_bp    = cbp-&gt;b_real_bp;
	zero_offset= cbp-&gt;b_validend;
	iostate    = (<span class="enscript-type">struct</span> clios *)cbp-&gt;b_iostate;

	<span class="enscript-keyword">if</span> (real_bp)
	        real_bp-&gt;b_dev = cbp-&gt;b_dev;

	<span class="enscript-keyword">while</span> (cbp) {
		<span class="enscript-keyword">if</span> ((cbp-&gt;b_flags &amp; B_ERROR) &amp;&amp; error == 0)
		        error = cbp-&gt;b_error;

		total_resid += cbp-&gt;b_resid;
		total_size  += cbp-&gt;b_bcount;

		cbp_next = cbp-&gt;b_trans_next;

		<span class="enscript-keyword">if</span> (cbp_next == NULL)
		        <span class="enscript-comment">/*
			 * compute the overall size of the transaction
			 * in case we created one that has 'holes' in it
			 * 'total_size' represents the amount of I/O we
			 * did, not the span of the transaction w/r to the UPL
			 */</span>
			transaction_size = cbp-&gt;b_uploffset + cbp-&gt;b_bcount - upl_offset;

		<span class="enscript-keyword">if</span> (cbp != cbp_head)
		        free_io_buf(cbp);

		cbp = cbp_next;
	}

	<span class="enscript-keyword">if</span> (ISSET(b_flags, B_COMMIT_UPL)) {
		cluster_handle_associated_upl(iostate,
									  cbp_head-&gt;b_upl,
									  upl_offset,
									  transaction_size);
	}

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; total_resid)
		error = EIO;

	<span class="enscript-keyword">if</span> (error == 0) {
	        <span class="enscript-type">int</span>	(*cliodone_func)(buf_t, <span class="enscript-type">void</span> *) = (<span class="enscript-type">int</span> (*)(buf_t, <span class="enscript-type">void</span> *))(cbp_head-&gt;b_cliodone);

		<span class="enscript-keyword">if</span> (cliodone_func != NULL) {
		        cbp_head-&gt;b_bcount = transaction_size;

		        error = (*cliodone_func)(cbp_head, callback_arg);
		}
	}
	<span class="enscript-keyword">if</span> (zero_offset)
	        cluster_zero(upl, zero_offset, PAGE_SIZE - (zero_offset &amp; PAGE_MASK), real_bp);

        free_io_buf(cbp_head);

	<span class="enscript-keyword">if</span> (iostate) {
	        <span class="enscript-type">int</span> need_wakeup = 0;

	        <span class="enscript-comment">/*
		 * someone has issued multiple I/Os asynchrounsly
		 * and is waiting for them to complete (streaming)
		 */</span>
		lck_mtx_lock_spin(&amp;iostate-&gt;io_mtxp);

	        <span class="enscript-keyword">if</span> (error &amp;&amp; iostate-&gt;io_error == 0)
		        iostate-&gt;io_error = error;

		iostate-&gt;io_completed += total_size;

		<span class="enscript-keyword">if</span> (iostate-&gt;io_wanted) {
		        <span class="enscript-comment">/*
		         * someone is waiting for the state of
			 * this io stream to change
			 */</span>
		        iostate-&gt;io_wanted = 0;
			need_wakeup = 1;
		}
		lck_mtx_unlock(&amp;iostate-&gt;io_mtxp);

		<span class="enscript-keyword">if</span> (need_wakeup)
		        wakeup((caddr_t)&amp;iostate-&gt;io_wanted);
	}

	<span class="enscript-keyword">if</span> (b_flags &amp; B_COMMIT_UPL) {
		pg_offset   = upl_offset &amp; PAGE_MASK;
		commit_size = (pg_offset + transaction_size + (PAGE_SIZE - 1)) &amp; ~PAGE_MASK;

		<span class="enscript-keyword">if</span> (error)
			upl_flags = cluster_ioerror(upl, upl_offset - pg_offset, commit_size, error, b_flags, vp);
		<span class="enscript-keyword">else</span> {
			upl_flags = UPL_COMMIT_FREE_ON_EMPTY;

			<span class="enscript-keyword">if</span> ((b_flags &amp; B_PHYS) &amp;&amp; (b_flags &amp; B_READ)) 
			        upl_flags |= UPL_COMMIT_SET_DIRTY;

			<span class="enscript-keyword">if</span> (b_flags &amp; B_AGE)
			        upl_flags |= UPL_COMMIT_INACTIVATE;

			ubc_upl_commit_range(upl, upl_offset - pg_offset, commit_size, upl_flags);
		}
	}
	<span class="enscript-keyword">if</span> (real_bp) {
		<span class="enscript-keyword">if</span> (error) {
			real_bp-&gt;b_flags |= B_ERROR;
			real_bp-&gt;b_error = error;
		}
		real_bp-&gt;b_resid = total_resid;

		buf_biodone(real_bp);
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 20)) | DBG_FUNC_END,
		     upl, upl_offset - pg_offset, commit_size, (error &lt;&lt; 24) | upl_flags, 0);

	<span class="enscript-keyword">return</span> (error);
}


uint32_t
<span class="enscript-function-name">cluster_throttle_io_limit</span>(vnode_t vp, uint32_t *limit)
{
	<span class="enscript-keyword">if</span> (cluster_is_throttled(vp)) {
		*limit = THROTTLE_MAX_IOSIZE;
		<span class="enscript-keyword">return</span> 1;
	}
	<span class="enscript-keyword">return</span> 0;   
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">cluster_zero</span>(upl_t upl, upl_offset_t upl_offset, <span class="enscript-type">int</span> size, buf_t bp)
{

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 23)) | DBG_FUNC_START,
		     upl_offset, size, bp, 0, 0);

	<span class="enscript-keyword">if</span> (bp == NULL || bp-&gt;b_datap == 0) {
	        upl_page_info_t *pl;
	        addr64_t	zero_addr;

	        pl = ubc_upl_pageinfo(upl);

		<span class="enscript-keyword">if</span> (upl_device_page(pl) == TRUE) {
		        zero_addr = ((addr64_t)upl_phys_page(pl, 0) &lt;&lt; PAGE_SHIFT) + upl_offset;

			bzero_phys_nc(zero_addr, size);
		} <span class="enscript-keyword">else</span> {
		        <span class="enscript-keyword">while</span> (size) {
			        <span class="enscript-type">int</span>	page_offset;
				<span class="enscript-type">int</span>	page_index;
				<span class="enscript-type">int</span>	zero_cnt;

				page_index  = upl_offset / PAGE_SIZE;
				page_offset = upl_offset &amp; PAGE_MASK;

				zero_addr = ((addr64_t)upl_phys_page(pl, page_index) &lt;&lt; PAGE_SHIFT) + page_offset;
				zero_cnt  = min(PAGE_SIZE - page_offset, size);

				bzero_phys(zero_addr, zero_cnt);

				size       -= zero_cnt;
				upl_offset += zero_cnt;
			}
		}
	} <span class="enscript-keyword">else</span>
		bzero((caddr_t)((vm_offset_t)bp-&gt;b_datap + upl_offset), size);

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 23)) | DBG_FUNC_END,
		     upl_offset, size, 0, 0, 0);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cluster_EOT</span>(buf_t cbp_head, buf_t cbp_tail, <span class="enscript-type">int</span> zero_offset)
{
        cbp_head-&gt;b_validend = zero_offset;
        cbp_tail-&gt;b_flags |= B_EOT;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cluster_wait_IO</span>(buf_t cbp_head, <span class="enscript-type">int</span> async)
{
        buf_t	cbp;

	<span class="enscript-keyword">if</span> (async) {
	        <span class="enscript-comment">/*
		 * async callback completion will not normally
		 * generate a wakeup upon I/O completion...
		 * by setting B_TWANTED, we will force a wakeup
		 * to occur as any outstanding I/Os complete... 
		 * I/Os already completed will have B_TDONE already
		 * set and we won't cause us to block
		 * note that we're actually waiting for the bp to have
		 * completed the callback function... only then
		 * can we safely take back ownership of the bp
		 */</span>
		lck_mtx_lock_spin(cl_transaction_mtxp);

		<span class="enscript-keyword">for</span> (cbp = cbp_head; cbp; cbp = cbp-&gt;b_trans_next)
		      cbp-&gt;b_flags |= B_TWANTED;

		lck_mtx_unlock(cl_transaction_mtxp);
	}
	<span class="enscript-keyword">for</span> (cbp = cbp_head; cbp; cbp = cbp-&gt;b_trans_next) {

	        <span class="enscript-keyword">if</span> (async) {
			<span class="enscript-keyword">while</span> (!ISSET(cbp-&gt;b_flags, B_TDONE)) {

				lck_mtx_lock_spin(cl_transaction_mtxp);

				<span class="enscript-keyword">if</span> (!ISSET(cbp-&gt;b_flags, B_TDONE)) {
					DTRACE_IO1(wait__start, buf_t, cbp);
					(<span class="enscript-type">void</span>) msleep(cbp, cl_transaction_mtxp, PDROP | (PRIBIO+1), <span class="enscript-string">&quot;cluster_wait_IO&quot;</span>, NULL);
					DTRACE_IO1(wait__done, buf_t, cbp);
				} <span class="enscript-keyword">else</span>
					lck_mtx_unlock(cl_transaction_mtxp);
			}
		} <span class="enscript-keyword">else</span>
		        buf_biowait(cbp);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cluster_complete_transaction</span>(buf_t *cbp_head, <span class="enscript-type">void</span> *callback_arg, <span class="enscript-type">int</span> *retval, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> needwait)
{
        buf_t	cbp;
	<span class="enscript-type">int</span>	error;
	boolean_t isswapout = FALSE;

	<span class="enscript-comment">/*
	 * cluster_complete_transaction will
	 * only be called if we've issued a complete chain in synchronous mode
	 * or, we've already done a cluster_wait_IO on an incomplete chain
	 */</span>
        <span class="enscript-keyword">if</span> (needwait) {
	        <span class="enscript-keyword">for</span> (cbp = *cbp_head; cbp; cbp = cbp-&gt;b_trans_next)
		        buf_biowait(cbp);
	}
	<span class="enscript-comment">/*
	 * we've already waited on all of the I/Os in this transaction,
	 * so mark all of the buf_t's in this transaction as B_TDONE
	 * so that cluster_iodone sees the transaction as completed
	 */</span>
	<span class="enscript-keyword">for</span> (cbp = *cbp_head; cbp; cbp = cbp-&gt;b_trans_next)
		cbp-&gt;b_flags |= B_TDONE;
	cbp = *cbp_head;

	<span class="enscript-keyword">if</span> ((flags &amp; (CL_ASYNC | CL_PAGEOUT)) == CL_PAGEOUT &amp;&amp; vnode_isswap(cbp-&gt;b_vp))
		isswapout = TRUE;

	error = cluster_iodone(cbp, callback_arg);

	<span class="enscript-keyword">if</span> ( !(flags &amp; CL_ASYNC) &amp;&amp; error &amp;&amp; *retval == 0) {
		<span class="enscript-keyword">if</span> (((flags &amp; (CL_PAGEOUT | CL_KEEPCACHED)) != CL_PAGEOUT) || (error != ENXIO))
			*retval = error;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (isswapout == TRUE)
			*retval = error;
	}
	*cbp_head = (buf_t)NULL;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_io</span>(vnode_t vp, upl_t upl, vm_offset_t upl_offset, off_t f_offset, <span class="enscript-type">int</span> non_rounded_size,
	   <span class="enscript-type">int</span> flags, buf_t real_bp, <span class="enscript-type">struct</span> clios *iostate, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
	buf_t	cbp;
	u_int	size;
	u_int	io_size;
	<span class="enscript-type">int</span>	io_flags;
	<span class="enscript-type">int</span>	bmap_flags;
	<span class="enscript-type">int</span>	error = 0;
	<span class="enscript-type">int</span>	retval = 0;
	buf_t	cbp_head = NULL;
	buf_t	cbp_tail = NULL;
	<span class="enscript-type">int</span>	trans_count = 0;
	<span class="enscript-type">int</span>	max_trans_count;
	u_int	pg_count;
	<span class="enscript-type">int</span>	pg_offset;
	u_int	max_iosize;
	u_int	max_vectors;
	<span class="enscript-type">int</span>	priv;
	<span class="enscript-type">int</span>	zero_offset = 0;
	<span class="enscript-type">int</span>	async_throttle = 0;
	mount_t	mp;
	vm_offset_t upl_end_offset;
	boolean_t   need_EOT = FALSE;

	<span class="enscript-comment">/*
	 * we currently don't support buffers larger than a page
	 */</span>
	<span class="enscript-keyword">if</span> (real_bp &amp;&amp; non_rounded_size &gt; PAGE_SIZE)
		panic(<span class="enscript-string">&quot;%s(): Called with real buffer of size %d bytes which &quot;</span>
				<span class="enscript-string">&quot;is greater than the maximum allowed size of &quot;</span>
				<span class="enscript-string">&quot;%d bytes (the system PAGE_SIZE).\n&quot;</span>,
				__FUNCTION__, non_rounded_size, PAGE_SIZE);

	mp = vp-&gt;v_mount;

	<span class="enscript-comment">/*
	 * we don't want to do any funny rounding of the size for IO requests
	 * coming through the DIRECT or CONTIGUOUS paths...  those pages don't
	 * belong to us... we can't extend (nor do we need to) the I/O to fill
	 * out a page
	 */</span>
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_devblocksize &gt; 1 &amp;&amp; !(flags &amp; (CL_DEV_MEMORY | CL_DIRECT_IO))) {
	        <span class="enscript-comment">/*
		 * round the requested size up so that this I/O ends on a
		 * page boundary in case this is a 'write'... if the filesystem
		 * has blocks allocated to back the page beyond the EOF, we want to
		 * make sure to write out the zero's that are sitting beyond the EOF
		 * so that in case the filesystem doesn't explicitly zero this area
		 * if a hole is created via a lseek/write beyond the current EOF,
		 * it will return zeros when it's read back from the disk.  If the
		 * physical allocation doesn't extend for the whole page, we'll
		 * only write/read from the disk up to the end of this allocation
		 * via the extent info returned from the VNOP_BLOCKMAP call.
		 */</span>
	        pg_offset = upl_offset &amp; PAGE_MASK;

		size = (((non_rounded_size + pg_offset) + (PAGE_SIZE - 1)) &amp; ~PAGE_MASK) - pg_offset;
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-comment">/*
		 * anyone advertising a blocksize of 1 byte probably
		 * can't deal with us rounding up the request size
		 * AFP is one such filesystem/device
		 */</span>
	        size = non_rounded_size;
	}
	upl_end_offset = upl_offset + size;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 22)) | DBG_FUNC_START, (<span class="enscript-type">int</span>)f_offset, size, upl_offset, flags, 0);

	<span class="enscript-comment">/*
	 * Set the maximum transaction size to the maximum desired number of
	 * buffers.
	 */</span>
	max_trans_count = 8;
	<span class="enscript-keyword">if</span> (flags &amp; CL_DEV_MEMORY)
		max_trans_count = 16;

	<span class="enscript-keyword">if</span> (flags &amp; CL_READ) {
	        io_flags = B_READ;
		bmap_flags = VNODE_READ;

		max_iosize  = mp-&gt;mnt_maxreadcnt;
		max_vectors = mp-&gt;mnt_segreadcnt;
	} <span class="enscript-keyword">else</span> {
	        io_flags = B_WRITE;
		bmap_flags = VNODE_WRITE;

		max_iosize  = mp-&gt;mnt_maxwritecnt;
		max_vectors = mp-&gt;mnt_segwritecnt;
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 22)) | DBG_FUNC_NONE, max_iosize, max_vectors, mp-&gt;mnt_devblocksize, 0, 0);

	<span class="enscript-comment">/*
	 * make sure the maximum iosize is a
	 * multiple of the page size
	 */</span>
	max_iosize  &amp;= ~PAGE_MASK;

	<span class="enscript-comment">/*
	 * Ensure the maximum iosize is sensible.
	 */</span>
	<span class="enscript-keyword">if</span> (!max_iosize)
		max_iosize = PAGE_SIZE;

	<span class="enscript-keyword">if</span> (flags &amp; CL_THROTTLE) {
	        <span class="enscript-keyword">if</span> ( !(flags &amp; CL_PAGEOUT) &amp;&amp; cluster_is_throttled(vp)) {
		        <span class="enscript-keyword">if</span> (max_iosize &gt; THROTTLE_MAX_IOSIZE)
			        max_iosize = THROTTLE_MAX_IOSIZE;
			async_throttle = THROTTLE_MAXCNT;
		} <span class="enscript-keyword">else</span> {
		        <span class="enscript-keyword">if</span> ( (flags &amp; CL_DEV_MEMORY) )
			        async_throttle = IO_SCALE(vp, VNODE_ASYNC_THROTTLE);
			<span class="enscript-keyword">else</span> {
			        u_int max_cluster;
				u_int max_cluster_size;
				u_int scale;

				max_cluster_size = MAX_CLUSTER_SIZE(vp);

				<span class="enscript-keyword">if</span> (max_iosize &gt; max_cluster_size)
				        max_cluster = max_cluster_size;
				<span class="enscript-keyword">else</span>
				        max_cluster = max_iosize;

				<span class="enscript-keyword">if</span> (size &lt; max_cluster)
				        max_cluster = size;
				
				<span class="enscript-keyword">if</span> ((vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_SSD) &amp;&amp; !ignore_is_ssd)
					scale = WRITE_THROTTLE_SSD;
				<span class="enscript-keyword">else</span>
					scale = WRITE_THROTTLE;

				<span class="enscript-keyword">if</span> (flags &amp; CL_CLOSE)
					scale += MAX_CLUSTERS;

			        async_throttle = min(IO_SCALE(vp, VNODE_ASYNC_THROTTLE), ((scale * max_cluster_size) / max_cluster) - 1);
			}
		}
	}
	<span class="enscript-keyword">if</span> (flags &amp; CL_AGE)
	        io_flags |= B_AGE;
	<span class="enscript-keyword">if</span> (flags &amp; (CL_PAGEIN | CL_PAGEOUT))
		io_flags |= B_PAGEIO;
	<span class="enscript-keyword">if</span> (flags &amp; (CL_IOSTREAMING))
		io_flags |= B_IOSTREAMING;
	<span class="enscript-keyword">if</span> (flags &amp; CL_COMMIT)
	        io_flags |= B_COMMIT_UPL;
	<span class="enscript-keyword">if</span> (flags &amp; CL_DIRECT_IO)
	        io_flags |= B_PHYS;
	<span class="enscript-keyword">if</span> (flags &amp; (CL_PRESERVE | CL_KEEPCACHED))
		io_flags |= B_CACHE;
	<span class="enscript-keyword">if</span> (flags &amp; CL_PASSIVE)
	        io_flags |= B_PASSIVE;
	<span class="enscript-keyword">if</span> (flags &amp; CL_ENCRYPTED)
		io_flags |= B_ENCRYPTED_IO;	

	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VSYSTEM)
	        io_flags |= B_META;

	<span class="enscript-keyword">if</span> ((flags &amp; CL_READ) &amp;&amp; ((upl_offset + non_rounded_size) &amp; PAGE_MASK) &amp;&amp; (!(flags &amp; CL_NOZERO))) {
	        <span class="enscript-comment">/*
		 * then we are going to end up
		 * with a page that we can't complete (the file size wasn't a multiple
		 * of PAGE_SIZE and we're trying to read to the end of the file
		 * so we'll go ahead and zero out the portion of the page we can't
		 * read in from the file
		 */</span>
	        zero_offset = upl_offset + non_rounded_size;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!ISSET(flags, CL_READ) &amp;&amp; ISSET(flags, CL_DIRECT_IO)) {
		assert(ISSET(flags, CL_COMMIT));

		<span class="enscript-comment">// For a direct/uncached write, we need to lock pages...
</span>
		upl_t cached_upl;

		<span class="enscript-comment">/*
		 * Create a UPL to lock the pages in the cache whilst the
		 * write is in progress.
		 */</span>
		ubc_create_upl(vp, f_offset, non_rounded_size, &amp;cached_upl,
					   NULL, UPL_SET_LITE);

		<span class="enscript-comment">/*
		 * Attach this UPL to the other UPL so that we can find it
		 * later.
		 */</span>
		upl_set_associated_upl(upl, cached_upl);

		<span class="enscript-keyword">if</span> (upl_offset &amp; PAGE_MASK) {
			<span class="enscript-comment">/*
			 * The two UPLs are not aligned, so mark the first page in
			 * @upl so that cluster_handle_associated_upl can handle
			 * it accordingly.
			 */</span>
			upl_page_info_t *pl = UPL_GET_INTERNAL_PAGE_LIST(upl);
			upl_page_set_mark(pl, 0, true);
		}
	}

	<span class="enscript-keyword">while</span> (size) {
		daddr64_t blkno;
		daddr64_t lblkno;
		u_int	io_size_wanted;
		size_t	io_size_tmp;

		<span class="enscript-keyword">if</span> (size &gt; max_iosize)
		        io_size = max_iosize;
		<span class="enscript-keyword">else</span>
		        io_size = size;

		io_size_wanted = io_size;
		io_size_tmp = (size_t)io_size;
		
		<span class="enscript-keyword">if</span> ((error = VNOP_BLOCKMAP(vp, f_offset, io_size, &amp;blkno, &amp;io_size_tmp, NULL, bmap_flags, NULL)))
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (io_size_tmp &gt; io_size_wanted)
		        io_size = io_size_wanted;
		<span class="enscript-keyword">else</span>
		        io_size = (u_int)io_size_tmp;

		<span class="enscript-keyword">if</span> (real_bp &amp;&amp; (real_bp-&gt;b_blkno == real_bp-&gt;b_lblkno))
		        real_bp-&gt;b_blkno = blkno;

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 24)) | DBG_FUNC_NONE,
			     (<span class="enscript-type">int</span>)f_offset, (<span class="enscript-type">int</span>)(blkno&gt;&gt;32), (<span class="enscript-type">int</span>)blkno, io_size, 0);

		<span class="enscript-keyword">if</span> (io_size == 0) {
		        <span class="enscript-comment">/*
			 * vnop_blockmap didn't return an error... however, it did
			 * return an extent size of 0 which means we can't
			 * make forward progress on this I/O... a hole in the
			 * file would be returned as a blkno of -1 with a non-zero io_size
			 * a real extent is returned with a blkno != -1 and a non-zero io_size
			 */</span>
	        	error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> ( !(flags &amp; CL_READ) &amp;&amp; blkno == -1) {
		        off_t	e_offset;
			<span class="enscript-type">int</span>	pageout_flags;

			<span class="enscript-keyword">if</span> (upl_get_internal_vectorupl(upl))
				panic(<span class="enscript-string">&quot;Vector UPLs should not take this code-path\n&quot;</span>);
		        <span class="enscript-comment">/*
			 * we're writing into a 'hole'
			 */</span>
			<span class="enscript-keyword">if</span> (flags &amp; CL_PAGEOUT) {
			        <span class="enscript-comment">/*
				 * if we got here via cluster_pageout 
				 * then just error the request and return
				 * the 'hole' should already have been covered
				 */</span>
		        	error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*
			 * we can get here if the cluster code happens to 
			 * pick up a page that was dirtied via mmap vs
			 * a 'write' and the page targets a 'hole'...
			 * i.e. the writes to the cluster were sparse
			 * and the file was being written for the first time
			 *
			 * we can also get here if the filesystem supports
			 * 'holes' that are less than PAGE_SIZE.... because
			 * we can't know if the range in the page that covers
			 * the 'hole' has been dirtied via an mmap or not,
			 * we have to assume the worst and try to push the
			 * entire page to storage.
			 *
			 * Try paging out the page individually before
			 * giving up entirely and dumping it (the pageout
			 * path will insure that the zero extent accounting
			 * has been taken care of before we get back into cluster_io)
			 *
			 * go direct to vnode_pageout so that we don't have to
			 * unbusy the page from the UPL... we used to do this
			 * so that we could call ubc_msync, but that results
			 * in a potential deadlock if someone else races us to acquire
			 * that page and wins and in addition needs one of the pages
			 * we're continuing to hold in the UPL
			 */</span>
			pageout_flags = UPL_MSYNC | UPL_VNODE_PAGER | UPL_NESTED_PAGEOUT;

			<span class="enscript-keyword">if</span> ( !(flags &amp; CL_ASYNC))
			        pageout_flags |= UPL_IOSYNC;
			<span class="enscript-keyword">if</span> ( !(flags &amp; CL_COMMIT))
			        pageout_flags |= UPL_NOCOMMIT;

			<span class="enscript-keyword">if</span> (cbp_head) {
			        buf_t last_cbp;

				<span class="enscript-comment">/*
				 * first we have to wait for the the current outstanding I/Os
				 * to complete... EOT hasn't been set yet on this transaction
				 * so the pages won't be released just because all of the current
				 * I/O linked to this transaction has completed...
				 */</span>
				cluster_wait_IO(cbp_head, (flags &amp; CL_ASYNC));

			        <span class="enscript-comment">/*
				 * we've got a transcation that
				 * includes the page we're about to push out through vnode_pageout...
				 * find the last bp in the list which will be the one that
				 * includes the head of this page and round it's iosize down
				 * to a page boundary...
				 */</span>
                                <span class="enscript-keyword">for</span> (last_cbp = cbp = cbp_head; cbp-&gt;b_trans_next; cbp = cbp-&gt;b_trans_next)
				        last_cbp = cbp;

				cbp-&gt;b_bcount &amp;= ~PAGE_MASK;

				<span class="enscript-keyword">if</span> (cbp-&gt;b_bcount == 0) {
				        <span class="enscript-comment">/*
					 * this buf no longer has any I/O associated with it
					 */</span>
				        free_io_buf(cbp);

					<span class="enscript-keyword">if</span> (cbp == cbp_head) {
					        <span class="enscript-comment">/*
						 * the buf we just freed was the only buf in
						 * this transaction... so there's no I/O to do
						 */</span>
					        cbp_head = NULL;
					} <span class="enscript-keyword">else</span> {
					        <span class="enscript-comment">/*
						 * remove the buf we just freed from
						 * the transaction list
						 */</span>
					        last_cbp-&gt;b_trans_next = NULL;
						cbp_tail = last_cbp;
					}
				}
				<span class="enscript-keyword">if</span> (cbp_head) {
				        <span class="enscript-comment">/*
					 * there was more to the current transaction
					 * than just the page we are pushing out via vnode_pageout...
					 * mark it as finished and complete it... we've already
					 * waited for the I/Os to complete above in the call to cluster_wait_IO
					 */</span>
				        cluster_EOT(cbp_head, cbp_tail, 0);

					cluster_complete_transaction(&amp;cbp_head, callback_arg, &amp;retval, flags, 0);

					trans_count = 0;
				}
			}
			<span class="enscript-keyword">if</span> (vnode_pageout(vp, upl, trunc_page(upl_offset), trunc_page_64(f_offset), PAGE_SIZE, pageout_flags, NULL) != PAGER_SUCCESS) {
			        error = EINVAL;
			}
			e_offset = round_page_64(f_offset + 1);
			io_size = e_offset - f_offset;

			f_offset   += io_size;
			upl_offset += io_size;

			<span class="enscript-keyword">if</span> (size &gt;= io_size)
			        size -= io_size;
			<span class="enscript-keyword">else</span>
			        size = 0;
			<span class="enscript-comment">/*
			 * keep track of how much of the original request
			 * that we've actually completed... non_rounded_size
			 * may go negative due to us rounding the request
			 * to a page size multiple (i.e.  size &gt; non_rounded_size)
			 */</span>
			non_rounded_size -= io_size;

			<span class="enscript-keyword">if</span> (non_rounded_size &lt;= 0) {
			        <span class="enscript-comment">/*
				 * we've transferred all of the data in the original
				 * request, but we were unable to complete the tail
				 * of the last page because the file didn't have
				 * an allocation to back that portion... this is ok.
				 */</span>
			        size = 0;
			}
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">if</span> (size == 0)
					flags &amp;= ~CL_COMMIT;
			 	<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">continue</span>;
		}
		lblkno = (daddr64_t)(f_offset / 0x1000);
		<span class="enscript-comment">/*
		 * we have now figured out how much I/O we can do - this is in 'io_size'
		 * pg_offset is the starting point in the first page for the I/O
		 * pg_count is the number of full and partial pages that 'io_size' encompasses
		 */</span>
		pg_offset = upl_offset &amp; PAGE_MASK;

		<span class="enscript-keyword">if</span> (flags &amp; CL_DEV_MEMORY) {
			<span class="enscript-comment">/*
			 * treat physical requests as one 'giant' page
			 */</span>
			pg_count = 1;
		} <span class="enscript-keyword">else</span>
		        pg_count  = (io_size + pg_offset + (PAGE_SIZE - 1)) / PAGE_SIZE;

		<span class="enscript-keyword">if</span> ((flags &amp; CL_READ) &amp;&amp; blkno == -1) {
			vm_offset_t  commit_offset;
		        <span class="enscript-type">int</span> bytes_to_zero;
			<span class="enscript-type">int</span> complete_transaction_now = 0;

		        <span class="enscript-comment">/*
			 * if we're reading and blkno == -1, then we've got a
			 * 'hole' in the file that we need to deal with by zeroing
			 * out the affected area in the upl
			 */</span>
			<span class="enscript-keyword">if</span> (io_size &gt;= (u_int)non_rounded_size) {
			        <span class="enscript-comment">/*
				 * if this upl contains the EOF and it is not a multiple of PAGE_SIZE
				 * than 'zero_offset' will be non-zero
				 * if the 'hole' returned by vnop_blockmap extends all the way to the eof
				 * (indicated by the io_size finishing off the I/O request for this UPL)
				 * than we're not going to issue an I/O for the
				 * last page in this upl... we need to zero both the hole and the tail
				 * of the page beyond the EOF, since the delayed zero-fill won't kick in 
				 */</span>
				bytes_to_zero = non_rounded_size;
				<span class="enscript-keyword">if</span> (!(flags &amp; CL_NOZERO))
					bytes_to_zero = (((upl_offset + io_size) + (PAGE_SIZE - 1)) &amp; ~PAGE_MASK) - upl_offset;

				zero_offset = 0;
			} <span class="enscript-keyword">else</span>
			        bytes_to_zero = io_size;

			pg_count = 0;

			cluster_zero(upl, upl_offset, bytes_to_zero, real_bp);
			  
			<span class="enscript-keyword">if</span> (cbp_head) {
			        <span class="enscript-type">int</span>	pg_resid;

			        <span class="enscript-comment">/*
				 * if there is a current I/O chain pending
				 * then the first page of the group we just zero'd
				 * will be handled by the I/O completion if the zero
				 * fill started in the middle of the page
				 */</span>
			        commit_offset = (upl_offset + (PAGE_SIZE - 1)) &amp; ~PAGE_MASK;

				pg_resid = commit_offset - upl_offset;
					
				<span class="enscript-keyword">if</span> (bytes_to_zero &gt;= pg_resid) {
				        <span class="enscript-comment">/*
					 * the last page of the current I/O 
					 * has been completed...
					 * compute the number of fully zero'd 
					 * pages that are beyond it
					 * plus the last page if its partial
					 * and we have no more I/O to issue...
					 * otherwise a partial page is left
					 * to begin the next I/O
					 */</span>
				        <span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)io_size &gt;= non_rounded_size)
					        pg_count = (bytes_to_zero - pg_resid + (PAGE_SIZE - 1)) / PAGE_SIZE;
					<span class="enscript-keyword">else</span>
					        pg_count = (bytes_to_zero - pg_resid) / PAGE_SIZE;
					
					complete_transaction_now = 1;
				}
			} <span class="enscript-keyword">else</span> {
			        <span class="enscript-comment">/*
				 * no pending I/O to deal with
				 * so, commit all of the fully zero'd pages
				 * plus the last page if its partial
				 * and we have no more I/O to issue...
				 * otherwise a partial page is left
				 * to begin the next I/O
				 */</span>
			        <span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)io_size &gt;= non_rounded_size)
				        pg_count = (pg_offset + bytes_to_zero + (PAGE_SIZE - 1)) / PAGE_SIZE;
				<span class="enscript-keyword">else</span>
				        pg_count = (pg_offset + bytes_to_zero) / PAGE_SIZE;

				commit_offset = upl_offset &amp; ~PAGE_MASK;
			}

			<span class="enscript-comment">// Associated UPL is currently only used in the direct write path
</span>			assert(!upl_associated_upl(upl));

			<span class="enscript-keyword">if</span> ( (flags &amp; CL_COMMIT) &amp;&amp; pg_count) {
			        ubc_upl_commit_range(upl, commit_offset, pg_count * PAGE_SIZE,
						     UPL_COMMIT_CLEAR_DIRTY | UPL_COMMIT_FREE_ON_EMPTY);
			}
			upl_offset += io_size;
			f_offset   += io_size;
			size       -= io_size;

			<span class="enscript-comment">/*
			 * keep track of how much of the original request
			 * that we've actually completed... non_rounded_size
			 * may go negative due to us rounding the request
			 * to a page size multiple (i.e.  size &gt; non_rounded_size)
			 */</span>
			non_rounded_size -= io_size;

			<span class="enscript-keyword">if</span> (non_rounded_size &lt;= 0) {
			        <span class="enscript-comment">/*
				 * we've transferred all of the data in the original
				 * request, but we were unable to complete the tail
				 * of the last page because the file didn't have
				 * an allocation to back that portion... this is ok.
				 */</span>
			        size = 0;
			}
			<span class="enscript-keyword">if</span> (cbp_head &amp;&amp; (complete_transaction_now || size == 0))  {
			        cluster_wait_IO(cbp_head, (flags &amp; CL_ASYNC));

				cluster_EOT(cbp_head, cbp_tail, size == 0 ? zero_offset : 0);

				cluster_complete_transaction(&amp;cbp_head, callback_arg, &amp;retval, flags, 0);

				trans_count = 0;
			}
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (pg_count &gt; max_vectors) {
		        <span class="enscript-keyword">if</span> (((pg_count - max_vectors) * PAGE_SIZE) &gt; io_size) {
			        io_size = PAGE_SIZE - pg_offset;
				pg_count = 1;
			} <span class="enscript-keyword">else</span> {
			        io_size -= (pg_count - max_vectors) * PAGE_SIZE;
			        pg_count = max_vectors;
			}
		}
		<span class="enscript-comment">/*
		 * If the transaction is going to reach the maximum number of
		 * desired elements, truncate the i/o to the nearest page so
		 * that the actual i/o is initiated after this buffer is
		 * created and added to the i/o chain.
		 *
		 * I/O directed to physically contiguous memory 
		 * doesn't have a requirement to make sure we 'fill' a page
		 */</span>
		<span class="enscript-keyword">if</span> ( !(flags &amp; CL_DEV_MEMORY) &amp;&amp; trans_count &gt;= max_trans_count &amp;&amp;
				((upl_offset + io_size) &amp; PAGE_MASK)) {
			vm_offset_t aligned_ofs;

			aligned_ofs = (upl_offset + io_size) &amp; ~PAGE_MASK;
			<span class="enscript-comment">/*
			 * If the io_size does not actually finish off even a
			 * single page we have to keep adding buffers to the
			 * transaction despite having reached the desired limit.
			 *
			 * Eventually we get here with the page being finished
			 * off (and exceeded) and then we truncate the size of
			 * this i/o request so that it is page aligned so that
			 * we can finally issue the i/o on the transaction.
			 */</span>
			<span class="enscript-keyword">if</span> (aligned_ofs &gt; upl_offset) {
				io_size = aligned_ofs - upl_offset;
				pg_count--;
			}
		}

		<span class="enscript-keyword">if</span> ( !(mp-&gt;mnt_kern_flag &amp; MNTK_VIRTUALDEV))
		        <span class="enscript-comment">/*
			 * if we're not targeting a virtual device i.e. a disk image
			 * it's safe to dip into the reserve pool since real devices
			 * can complete this I/O request without requiring additional
			 * bufs from the alloc_io_buf pool
			 */</span>
			priv = 1;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((flags &amp; CL_ASYNC) &amp;&amp; !(flags &amp; CL_PAGEOUT))
		        <span class="enscript-comment">/*
			 * Throttle the speculative IO
			 */</span>
			priv = 0;
		<span class="enscript-keyword">else</span>
			priv = 1;

		cbp = alloc_io_buf(vp, priv);

		<span class="enscript-keyword">if</span> (flags &amp; CL_PAGEOUT) {
		        u_int i;

			<span class="enscript-comment">/*
			 * since blocks are in offsets of 0x1000, scale
			 * iteration to (PAGE_SIZE * pg_count) of blks.
			 */</span>
			<span class="enscript-keyword">for</span> (i = 0; i &lt; (PAGE_SIZE * pg_count)/0x1000; i++) {
				<span class="enscript-keyword">if</span> (buf_invalblkno(vp, lblkno + i, 0) == EBUSY)
					panic(<span class="enscript-string">&quot;BUSY bp found in cluster_io&quot;</span>);
			}
		}
		<span class="enscript-keyword">if</span> (flags &amp; CL_ASYNC) {
		        <span class="enscript-keyword">if</span> (buf_setcallback(cbp, (<span class="enscript-type">void</span> *)cluster_iodone, callback_arg))
			        panic(<span class="enscript-string">&quot;buf_setcallback failed\n&quot;</span>);
		}
		cbp-&gt;b_cliodone = (<span class="enscript-type">void</span> *)callback;
		cbp-&gt;b_flags |= io_flags;
		<span class="enscript-keyword">if</span> (flags &amp; CL_NOCACHE)
			cbp-&gt;b_attr.ba_flags |= BA_NOCACHE;

		cbp-&gt;b_lblkno = lblkno;
		cbp-&gt;b_blkno  = blkno;
		cbp-&gt;b_bcount = io_size;

		<span class="enscript-keyword">if</span> (buf_setupl(cbp, upl, upl_offset))
		        panic(<span class="enscript-string">&quot;buf_setupl failed\n&quot;</span>);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
		upl_set_blkno(upl, upl_offset, io_size, blkno);
#<span class="enscript-reference">endif</span>
		cbp-&gt;b_trans_next = (buf_t)NULL;

		<span class="enscript-keyword">if</span> ((cbp-&gt;b_iostate = (<span class="enscript-type">void</span> *)iostate))
		        <span class="enscript-comment">/*
			 * caller wants to track the state of this
			 * io... bump the amount issued against this stream
			 */</span>
		        iostate-&gt;io_issued += io_size;

		<span class="enscript-keyword">if</span> (flags &amp; CL_READ) {
			KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 26)) | DBG_FUNC_NONE,
				     (<span class="enscript-type">int</span>)cbp-&gt;b_lblkno, (<span class="enscript-type">int</span>)cbp-&gt;b_blkno, upl_offset, io_size, 0);
		}
		<span class="enscript-keyword">else</span> {
			KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 27)) | DBG_FUNC_NONE,
				     (<span class="enscript-type">int</span>)cbp-&gt;b_lblkno, (<span class="enscript-type">int</span>)cbp-&gt;b_blkno, upl_offset, io_size, 0);
		}

		<span class="enscript-keyword">if</span> (cbp_head) {
		        cbp_tail-&gt;b_trans_next = cbp;
			cbp_tail = cbp;
		} <span class="enscript-keyword">else</span> {
		        cbp_head = cbp;
			cbp_tail = cbp;

			<span class="enscript-keyword">if</span> ( (cbp_head-&gt;b_real_bp = real_bp) )
				real_bp = (buf_t)NULL;
		}
		*(buf_t *)(&amp;cbp-&gt;b_trans_head) = cbp_head;

		trans_count++;

		upl_offset += io_size;
		f_offset   += io_size;
		size       -= io_size;
		<span class="enscript-comment">/*
		 * keep track of how much of the original request
		 * that we've actually completed... non_rounded_size
		 * may go negative due to us rounding the request
		 * to a page size multiple (i.e.  size &gt; non_rounded_size)
		 */</span>
		non_rounded_size -= io_size;

		<span class="enscript-keyword">if</span> (non_rounded_size &lt;= 0) {
		        <span class="enscript-comment">/*
			 * we've transferred all of the data in the original
			 * request, but we were unable to complete the tail
			 * of the last page because the file didn't have
			 * an allocation to back that portion... this is ok.
			 */</span>
		        size = 0;
		}
		<span class="enscript-keyword">if</span> (size == 0) {
		        <span class="enscript-comment">/*
			 * we have no more I/O to issue, so go
			 * finish the final transaction
			 */</span>
		        need_EOT = TRUE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( ((flags &amp; CL_DEV_MEMORY) || (upl_offset &amp; PAGE_MASK) == 0) &amp;&amp;
			    ((flags &amp; CL_ASYNC) || trans_count &gt; max_trans_count) ) {
		        <span class="enscript-comment">/*
			 * I/O directed to physically contiguous memory...
			 * which doesn't have a requirement to make sure we 'fill' a page
			 * or... 
			 * the current I/O we've prepared fully
			 * completes the last page in this request
			 * and ...
			 * it's either an ASYNC request or 
			 * we've already accumulated more than 8 I/O's into
			 * this transaction so mark it as complete so that
			 * it can finish asynchronously or via the cluster_complete_transaction
			 * below if the request is synchronous
			 */</span>
		        need_EOT = TRUE;
		}
		<span class="enscript-keyword">if</span> (need_EOT == TRUE)
		        cluster_EOT(cbp_head, cbp_tail, size == 0 ? zero_offset : 0);

		<span class="enscript-keyword">if</span> (flags &amp; CL_THROTTLE)
		        (<span class="enscript-type">void</span>)vnode_waitforwrites(vp, async_throttle, 0, 0, <span class="enscript-string">&quot;cluster_io&quot;</span>);

		<span class="enscript-keyword">if</span> ( !(io_flags &amp; B_READ))
		        vnode_startwrite(vp);
				
		<span class="enscript-keyword">if</span> (flags &amp; CL_RAW_ENCRYPTED) {
			<span class="enscript-comment">/* 
			 * User requested raw encrypted bytes.
			 * Twiddle the bit in the ba_flags for the buffer
			 */</span>
			cbp-&gt;b_attr.ba_flags |= BA_RAW_ENCRYPTED_IO;
		}
		
		(<span class="enscript-type">void</span>) VNOP_STRATEGY(cbp);

		<span class="enscript-keyword">if</span> (need_EOT == TRUE) {
		        <span class="enscript-keyword">if</span> ( !(flags &amp; CL_ASYNC))
			        cluster_complete_transaction(&amp;cbp_head, callback_arg, &amp;retval, flags, 1);

			need_EOT = FALSE;
			trans_count = 0;
			cbp_head = NULL;
		}
        }
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-type">int</span> abort_size;

		io_size = 0;

		<span class="enscript-keyword">if</span> (cbp_head) {
			<span class="enscript-comment">/*
			 * Wait until all of the outstanding I/O
			 * for this partial transaction has completed
			 */</span>
			cluster_wait_IO(cbp_head, (flags &amp; CL_ASYNC));

			<span class="enscript-comment">/*
			 * Rewind the upl offset to the beginning of the
			 * transaction.
			 */</span>
			upl_offset = cbp_head-&gt;b_uploffset;
		}

		<span class="enscript-keyword">if</span> (ISSET(flags, CL_COMMIT)) {
			cluster_handle_associated_upl(iostate, upl, upl_offset,
										  upl_end_offset - upl_offset);
		}

		<span class="enscript-comment">// Free all the IO buffers in this transaction
</span>		<span class="enscript-keyword">for</span> (cbp = cbp_head; cbp;) {
			buf_t	cbp_next;
 
			size       += cbp-&gt;b_bcount;
			io_size    += cbp-&gt;b_bcount;

			cbp_next = cbp-&gt;b_trans_next;
			free_io_buf(cbp);
			cbp = cbp_next;
		}

		<span class="enscript-keyword">if</span> (iostate) {
		        <span class="enscript-type">int</span> need_wakeup = 0;

		        <span class="enscript-comment">/*
			 * update the error condition for this stream
			 * since we never really issued the io
			 * just go ahead and adjust it back
			 */</span>
		        lck_mtx_lock_spin(&amp;iostate-&gt;io_mtxp);

		        <span class="enscript-keyword">if</span> (iostate-&gt;io_error == 0)
			        iostate-&gt;io_error = error;
			iostate-&gt;io_issued -= io_size;

			<span class="enscript-keyword">if</span> (iostate-&gt;io_wanted) {
			        <span class="enscript-comment">/*
				 * someone is waiting for the state of
				 * this io stream to change
				 */</span>
			        iostate-&gt;io_wanted = 0;
				need_wakeup = 1;
			}
		        lck_mtx_unlock(&amp;iostate-&gt;io_mtxp);

			<span class="enscript-keyword">if</span> (need_wakeup)
			        wakeup((caddr_t)&amp;iostate-&gt;io_wanted);
		}

		<span class="enscript-keyword">if</span> (flags &amp; CL_COMMIT) {
		        <span class="enscript-type">int</span>	upl_flags;

			pg_offset  = upl_offset &amp; PAGE_MASK;
			abort_size = (upl_end_offset - upl_offset + PAGE_MASK) &amp; ~PAGE_MASK;

			upl_flags = cluster_ioerror(upl, upl_offset - pg_offset, abort_size, error, io_flags, vp);
			
			KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 28)) | DBG_FUNC_NONE,
				     upl, upl_offset - pg_offset, abort_size, (error &lt;&lt; 24) | upl_flags, 0);
		}
		<span class="enscript-keyword">if</span> (retval == 0)
		        retval = error;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cbp_head)
			panic(<span class="enscript-string">&quot;%s(): cbp_head is not NULL.\n&quot;</span>, __FUNCTION__);

	<span class="enscript-keyword">if</span> (real_bp) {
	        <span class="enscript-comment">/*
		 * can get here if we either encountered an error
		 * or we completely zero-filled the request and
		 * no I/O was issued
		 */</span>
		<span class="enscript-keyword">if</span> (error) {
			real_bp-&gt;b_flags |= B_ERROR;
			real_bp-&gt;b_error = error;
		}
		buf_biodone(real_bp);
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 22)) | DBG_FUNC_END, (<span class="enscript-type">int</span>)f_offset, size, upl_offset, retval, 0);

	<span class="enscript-keyword">return</span> (retval);
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">reset_vector_run_state</span>()										\
	issueVectorUPL = vector_upl_offset = vector_upl_index = vector_upl_iosize = vector_upl_size = 0;	

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vector_cluster_io</span>(vnode_t vp, upl_t vector_upl, vm_offset_t vector_upl_offset, off_t v_upl_uio_offset, <span class="enscript-type">int</span> vector_upl_iosize,
	   <span class="enscript-type">int</span> io_flag, buf_t real_bp, <span class="enscript-type">struct</span> clios *iostate, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
	vector_upl_set_pagelist(vector_upl);

	<span class="enscript-keyword">if</span>(io_flag &amp; CL_READ) {	
		<span class="enscript-keyword">if</span>(vector_upl_offset == 0 &amp;&amp; ((vector_upl_iosize &amp; PAGE_MASK)==0))
       			io_flag &amp;= ~CL_PRESERVE; <span class="enscript-comment">/*don't zero fill*/</span>
		<span class="enscript-keyword">else</span>
       			io_flag |= CL_PRESERVE; <span class="enscript-comment">/*zero fill*/</span>
	}	
	<span class="enscript-keyword">return</span> (cluster_io(vp, vector_upl, vector_upl_offset, v_upl_uio_offset, vector_upl_iosize, io_flag, real_bp, iostate, callback, callback_arg));

}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_read_prefetch</span>(vnode_t vp, off_t f_offset, u_int size, off_t filesize, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg, <span class="enscript-type">int</span> bflag)
{
	<span class="enscript-type">int</span>           pages_in_prefetch;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 49)) | DBG_FUNC_START,
		     (<span class="enscript-type">int</span>)f_offset, size, (<span class="enscript-type">int</span>)filesize, 0, 0);

	<span class="enscript-keyword">if</span> (f_offset &gt;= filesize) {
	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 49)) | DBG_FUNC_END,
			     (<span class="enscript-type">int</span>)f_offset, 0, 0, 0, 0);
	        <span class="enscript-keyword">return</span>(0);
	}
        <span class="enscript-keyword">if</span> ((off_t)size &gt; (filesize - f_offset))
                size = filesize - f_offset;
	pages_in_prefetch = (size + (PAGE_SIZE - 1)) / PAGE_SIZE;

	advisory_read_ext(vp, filesize, f_offset, size, callback, callback_arg, bflag);

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 49)) | DBG_FUNC_END,
		     (<span class="enscript-type">int</span>)f_offset + size, pages_in_prefetch, 0, 1, 0);

	<span class="enscript-keyword">return</span> (pages_in_prefetch);
}



<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cluster_read_ahead</span>(vnode_t vp, <span class="enscript-type">struct</span> cl_extent *extent, off_t filesize, <span class="enscript-type">struct</span> cl_readahead *rap, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg,
		   <span class="enscript-type">int</span> bflag)
{
	daddr64_t	r_addr;
	off_t		f_offset;
	<span class="enscript-type">int</span>		size_of_prefetch;
	u_int		max_prefetch;


	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 48)) | DBG_FUNC_START,
		     (<span class="enscript-type">int</span>)extent-&gt;b_addr, (<span class="enscript-type">int</span>)extent-&gt;e_addr, (<span class="enscript-type">int</span>)rap-&gt;cl_lastr, 0, 0);

	<span class="enscript-keyword">if</span> (extent-&gt;b_addr == rap-&gt;cl_lastr &amp;&amp; extent-&gt;b_addr == extent-&gt;e_addr) {
		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 48)) | DBG_FUNC_END,
			     rap-&gt;cl_ralen, (<span class="enscript-type">int</span>)rap-&gt;cl_maxra, (<span class="enscript-type">int</span>)rap-&gt;cl_lastr, 0, 0);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (rap-&gt;cl_lastr == -1 || (extent-&gt;b_addr != rap-&gt;cl_lastr &amp;&amp; extent-&gt;b_addr != (rap-&gt;cl_lastr + 1))) {
	        rap-&gt;cl_ralen = 0;
		rap-&gt;cl_maxra = 0;

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 48)) | DBG_FUNC_END,
			     rap-&gt;cl_ralen, (<span class="enscript-type">int</span>)rap-&gt;cl_maxra, (<span class="enscript-type">int</span>)rap-&gt;cl_lastr, 1, 0);

		<span class="enscript-keyword">return</span>;
	}
	max_prefetch = MAX_PREFETCH(vp, cluster_max_io_size(vp-&gt;v_mount, CL_READ), (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_SSD));

	<span class="enscript-keyword">if</span> (max_prefetch &gt; speculative_prefetch_max)
		max_prefetch = speculative_prefetch_max;

	<span class="enscript-keyword">if</span> (max_prefetch &lt;= PAGE_SIZE) {
		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 48)) | DBG_FUNC_END,
			     rap-&gt;cl_ralen, (<span class="enscript-type">int</span>)rap-&gt;cl_maxra, (<span class="enscript-type">int</span>)rap-&gt;cl_lastr, 6, 0);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (extent-&gt;e_addr &lt; rap-&gt;cl_maxra &amp;&amp; rap-&gt;cl_ralen &gt;= 4) {
	        <span class="enscript-keyword">if</span> ((rap-&gt;cl_maxra - extent-&gt;e_addr) &gt; (rap-&gt;cl_ralen / 4)) {

		        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 48)) | DBG_FUNC_END,
				     rap-&gt;cl_ralen, (<span class="enscript-type">int</span>)rap-&gt;cl_maxra, (<span class="enscript-type">int</span>)rap-&gt;cl_lastr, 2, 0);
			<span class="enscript-keyword">return</span>;
		}
	}
	r_addr = max(extent-&gt;e_addr, rap-&gt;cl_maxra) + 1;
	f_offset = (off_t)(r_addr * PAGE_SIZE_64);

        size_of_prefetch = 0;

	ubc_range_op(vp, f_offset, f_offset + PAGE_SIZE_64, UPL_ROP_PRESENT, &amp;size_of_prefetch);

	<span class="enscript-keyword">if</span> (size_of_prefetch) {
	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 48)) | DBG_FUNC_END,
			     rap-&gt;cl_ralen, (<span class="enscript-type">int</span>)rap-&gt;cl_maxra, (<span class="enscript-type">int</span>)rap-&gt;cl_lastr, 3, 0);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (f_offset &lt; filesize) {
	        daddr64_t read_size;

	        rap-&gt;cl_ralen = rap-&gt;cl_ralen ? min(max_prefetch / PAGE_SIZE, rap-&gt;cl_ralen &lt;&lt; 1) : 1;

		read_size = (extent-&gt;e_addr + 1) - extent-&gt;b_addr;

		<span class="enscript-keyword">if</span> (read_size &gt; rap-&gt;cl_ralen) {
		        <span class="enscript-keyword">if</span> (read_size &gt; max_prefetch / PAGE_SIZE)
			        rap-&gt;cl_ralen = max_prefetch / PAGE_SIZE;
			<span class="enscript-keyword">else</span>
			        rap-&gt;cl_ralen = read_size;
		}
		size_of_prefetch = cluster_read_prefetch(vp, f_offset, rap-&gt;cl_ralen * PAGE_SIZE, filesize, callback, callback_arg, bflag);

		<span class="enscript-keyword">if</span> (size_of_prefetch)
		        rap-&gt;cl_maxra = (r_addr + size_of_prefetch) - 1;
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 48)) | DBG_FUNC_END,
		     rap-&gt;cl_ralen, (<span class="enscript-type">int</span>)rap-&gt;cl_maxra, (<span class="enscript-type">int</span>)rap-&gt;cl_lastr, 4, 0);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_pageout</span>(vnode_t vp, upl_t upl, upl_offset_t upl_offset, off_t f_offset,
		<span class="enscript-type">int</span> size, off_t filesize, <span class="enscript-type">int</span> flags)
{
        <span class="enscript-keyword">return</span> cluster_pageout_ext(vp, upl, upl_offset, f_offset, size, filesize, flags, NULL, NULL);

}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_pageout_ext</span>(vnode_t vp, upl_t upl, upl_offset_t upl_offset, off_t f_offset,
		<span class="enscript-type">int</span> size, off_t filesize, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
	<span class="enscript-type">int</span>           io_size;
	<span class="enscript-type">int</span>           rounded_size;
        off_t         max_size;
	<span class="enscript-type">int</span>           local_flags;

	local_flags = CL_PAGEOUT | CL_THROTTLE;

	<span class="enscript-keyword">if</span> ((flags &amp; UPL_IOSYNC) == 0) 
		local_flags |= CL_ASYNC;
	<span class="enscript-keyword">if</span> ((flags &amp; UPL_NOCOMMIT) == 0) 
		local_flags |= CL_COMMIT;
	<span class="enscript-keyword">if</span> ((flags &amp; UPL_KEEPCACHED))
	        local_flags |= CL_KEEPCACHED;
	<span class="enscript-keyword">if</span> (flags &amp; UPL_PAGING_ENCRYPTED)
		local_flags |= CL_ENCRYPTED;


	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 52)) | DBG_FUNC_NONE,
		     (<span class="enscript-type">int</span>)f_offset, size, (<span class="enscript-type">int</span>)filesize, local_flags, 0);

	<span class="enscript-comment">/*
	 * If they didn't specify any I/O, then we are done...
	 * we can't issue an abort because we don't know how
	 * big the upl really is
	 */</span>
	<span class="enscript-keyword">if</span> (size &lt;= 0)
		<span class="enscript-keyword">return</span> (EINVAL);

        <span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_RDONLY) {
		<span class="enscript-keyword">if</span> (local_flags &amp; CL_COMMIT)
		        ubc_upl_abort_range(upl, upl_offset, size, UPL_ABORT_FREE_ON_EMPTY);
		<span class="enscript-keyword">return</span> (EROFS);
	}
	<span class="enscript-comment">/*
	 * can't page-in from a negative offset
	 * or if we're starting beyond the EOF
	 * or if the file offset isn't page aligned
	 * or the size requested isn't a multiple of PAGE_SIZE
	 */</span>
	<span class="enscript-keyword">if</span> (f_offset &lt; 0 || f_offset &gt;= filesize ||
	   (f_offset &amp; PAGE_MASK_64) || (size &amp; PAGE_MASK)) {
		<span class="enscript-keyword">if</span> (local_flags &amp; CL_COMMIT)
			ubc_upl_abort_range(upl, upl_offset, size, UPL_ABORT_FREE_ON_EMPTY);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	max_size = filesize - f_offset;

	<span class="enscript-keyword">if</span> (size &lt; max_size)
	        io_size = size;
	<span class="enscript-keyword">else</span>
	        io_size = max_size;

	rounded_size = (io_size + (PAGE_SIZE - 1)) &amp; ~PAGE_MASK;

	<span class="enscript-keyword">if</span> (size &gt; rounded_size) {
		<span class="enscript-keyword">if</span> (local_flags &amp; CL_COMMIT)
			ubc_upl_abort_range(upl, upl_offset + rounded_size, size - rounded_size,
					UPL_ABORT_FREE_ON_EMPTY);
	}
	<span class="enscript-keyword">return</span> (cluster_io(vp, upl, upl_offset, f_offset, io_size,
			   local_flags, (buf_t)NULL, (<span class="enscript-type">struct</span> clios *)NULL, callback, callback_arg));
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_pagein</span>(vnode_t vp, upl_t upl, upl_offset_t upl_offset, off_t f_offset,
	       <span class="enscript-type">int</span> size, off_t filesize, <span class="enscript-type">int</span> flags)
{
        <span class="enscript-keyword">return</span> cluster_pagein_ext(vp, upl, upl_offset, f_offset, size, filesize, flags, NULL, NULL);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_pagein_ext</span>(vnode_t vp, upl_t upl, upl_offset_t upl_offset, off_t f_offset,
	       <span class="enscript-type">int</span> size, off_t filesize, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
	u_int         io_size;
	<span class="enscript-type">int</span>           rounded_size;
        off_t         max_size;
	<span class="enscript-type">int</span>           retval;
	<span class="enscript-type">int</span>           local_flags = 0;

	<span class="enscript-keyword">if</span> (upl == NULL || size &lt; 0)
	        panic(<span class="enscript-string">&quot;cluster_pagein: NULL upl passed in&quot;</span>);

	<span class="enscript-keyword">if</span> ((flags &amp; UPL_IOSYNC) == 0)
	        local_flags |= CL_ASYNC;
	<span class="enscript-keyword">if</span> ((flags &amp; UPL_NOCOMMIT) == 0) 
		local_flags |= CL_COMMIT;
	<span class="enscript-keyword">if</span> (flags &amp; UPL_IOSTREAMING)
		local_flags |= CL_IOSTREAMING;
	<span class="enscript-keyword">if</span> (flags &amp; UPL_PAGING_ENCRYPTED)
		local_flags |= CL_ENCRYPTED;


	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 56)) | DBG_FUNC_NONE,
		     (<span class="enscript-type">int</span>)f_offset, size, (<span class="enscript-type">int</span>)filesize, local_flags, 0);

	<span class="enscript-comment">/*
	 * can't page-in from a negative offset
	 * or if we're starting beyond the EOF
	 * or if the file offset isn't page aligned
	 * or the size requested isn't a multiple of PAGE_SIZE
	 */</span>
	<span class="enscript-keyword">if</span> (f_offset &lt; 0 || f_offset &gt;= filesize ||
	   (f_offset &amp; PAGE_MASK_64) || (size &amp; PAGE_MASK) || (upl_offset &amp; PAGE_MASK)) {
	        <span class="enscript-keyword">if</span> (local_flags &amp; CL_COMMIT)
		        ubc_upl_abort_range(upl, upl_offset, size, UPL_ABORT_FREE_ON_EMPTY | UPL_ABORT_ERROR);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	max_size = filesize - f_offset;

	<span class="enscript-keyword">if</span> (size &lt; max_size)
	        io_size = size;
	<span class="enscript-keyword">else</span>
	        io_size = max_size;

	rounded_size = (io_size + (PAGE_SIZE - 1)) &amp; ~PAGE_MASK;

	<span class="enscript-keyword">if</span> (size &gt; rounded_size &amp;&amp; (local_flags &amp; CL_COMMIT))
		ubc_upl_abort_range(upl, upl_offset + rounded_size,
				    size - rounded_size, UPL_ABORT_FREE_ON_EMPTY | UPL_ABORT_ERROR);
	
	retval = cluster_io(vp, upl, upl_offset, f_offset, io_size,
			    local_flags | CL_READ | CL_PAGEIN, (buf_t)NULL, (<span class="enscript-type">struct</span> clios *)NULL, callback, callback_arg);

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_bp</span>(buf_t bp)
{
       <span class="enscript-keyword">return</span> cluster_bp_ext(bp, NULL, NULL);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_bp_ext</span>(buf_t bp, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
        off_t  f_offset;
	<span class="enscript-type">int</span>    flags;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 19)) | DBG_FUNC_START,
		     bp, (<span class="enscript-type">int</span>)bp-&gt;b_lblkno, bp-&gt;b_bcount, bp-&gt;b_flags, 0);

	<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_READ)
	        flags = CL_ASYNC | CL_READ;
	<span class="enscript-keyword">else</span>
	        flags = CL_ASYNC;
	<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_PASSIVE) 
		flags |= CL_PASSIVE;

	f_offset = ubc_blktooff(bp-&gt;b_vp, bp-&gt;b_lblkno);

        <span class="enscript-keyword">return</span> (cluster_io(bp-&gt;b_vp, bp-&gt;b_upl, 0, f_offset, bp-&gt;b_bcount, flags, bp, (<span class="enscript-type">struct</span> clios *)NULL, callback, callback_arg));
}



<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_write</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, off_t oldEOF, off_t newEOF, off_t headOff, off_t tailOff, <span class="enscript-type">int</span> xflags)
{
        <span class="enscript-keyword">return</span> cluster_write_ext(vp, uio, oldEOF, newEOF, headOff, tailOff, xflags, NULL, NULL);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_write_ext</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, off_t oldEOF, off_t newEOF, off_t headOff, off_t tailOff,
		  <span class="enscript-type">int</span> xflags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
        user_ssize_t	cur_resid;
	<span class="enscript-type">int</span>		retval = 0;
	<span class="enscript-type">int</span>		flags;
        <span class="enscript-type">int</span>		zflags;
	<span class="enscript-type">int</span>             bflag;
	<span class="enscript-type">int</span>		write_type = IO_COPY;
	u_int32_t	write_length;

	flags = xflags;

	<span class="enscript-keyword">if</span> (flags &amp; IO_PASSIVE)
		bflag = CL_PASSIVE;
	<span class="enscript-keyword">else</span>
		bflag = 0;

	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VNOCACHE_DATA){
	        flags |= IO_NOCACHE;
		bflag |= CL_NOCACHE;
	}
        <span class="enscript-keyword">if</span> (uio == NULL) {
	        <span class="enscript-comment">/*
		 * no user data...
		 * this call is being made to zero-fill some range in the file
		 */</span>
	        retval = cluster_write_copy(vp, NULL, (u_int32_t)0, oldEOF, newEOF, headOff, tailOff, flags, callback, callback_arg);

		<span class="enscript-keyword">return</span>(retval);
	}
        <span class="enscript-comment">/*
         * do a write through the cache if one of the following is true....
         *   NOCACHE is not true or NODIRECT is true
         *   the uio request doesn't target USERSPACE
         * otherwise, find out if we want the direct or contig variant for
         * the first vector in the uio request
         */</span>
	<span class="enscript-keyword">if</span> ( ((flags &amp; (IO_NOCACHE | IO_NODIRECT)) == IO_NOCACHE) &amp;&amp; UIO_SEG_IS_USER_SPACE(uio-&gt;uio_segflg) )
	        retval = cluster_io_type(uio, &amp;write_type, &amp;write_length, MIN_DIRECT_WRITE_SIZE);

        <span class="enscript-keyword">if</span> ( (flags &amp; (IO_TAILZEROFILL | IO_HEADZEROFILL)) &amp;&amp; write_type == IO_DIRECT)
	        <span class="enscript-comment">/*
		 * must go through the cached variant in this case
		 */</span>
	        write_type = IO_COPY;

	<span class="enscript-keyword">while</span> ((cur_resid = uio_resid(uio)) &amp;&amp; uio-&gt;uio_offset &lt; newEOF &amp;&amp; retval == 0) {
	  
	        <span class="enscript-keyword">switch</span> (write_type) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IO_COPY</span>:
		        <span class="enscript-comment">/*
			 * make sure the uio_resid isn't too big...
			 * internally, we want to handle all of the I/O in
			 * chunk sizes that fit in a 32 bit int
			 */</span>
		        <span class="enscript-keyword">if</span> (cur_resid &gt; (user_ssize_t)(MAX_IO_REQUEST_SIZE)) {
			        <span class="enscript-comment">/*
				 * we're going to have to call cluster_write_copy
				 * more than once...
				 *
				 * only want the last call to cluster_write_copy to
				 * have the IO_TAILZEROFILL flag set and only the
				 * first call should have IO_HEADZEROFILL
				 */</span>
			        zflags = flags &amp; ~IO_TAILZEROFILL;
				flags &amp;= ~IO_HEADZEROFILL;

				write_length = MAX_IO_REQUEST_SIZE;
			} <span class="enscript-keyword">else</span> {
		                <span class="enscript-comment">/*
				 * last call to cluster_write_copy
				 */</span>
			        zflags = flags;
			  
				write_length = (u_int32_t)cur_resid;
			}
			retval = cluster_write_copy(vp, uio, write_length, oldEOF, newEOF, headOff, tailOff, zflags, callback, callback_arg);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IO_CONTIG</span>:
		        zflags = flags &amp; ~(IO_TAILZEROFILL | IO_HEADZEROFILL);

			<span class="enscript-keyword">if</span> (flags &amp; IO_HEADZEROFILL) {
		                <span class="enscript-comment">/*
				 * only do this once per request
				 */</span>
		                flags &amp;= ~IO_HEADZEROFILL;

				retval = cluster_write_copy(vp, (<span class="enscript-type">struct</span> uio *)0, (u_int32_t)0, (off_t)0, uio-&gt;uio_offset,
							    headOff, (off_t)0, zflags | IO_HEADZEROFILL | IO_SYNC, callback, callback_arg);
				<span class="enscript-keyword">if</span> (retval)
			                <span class="enscript-keyword">break</span>;
			}
			retval = cluster_write_contig(vp, uio, newEOF, &amp;write_type, &amp;write_length, callback, callback_arg, bflag);

			<span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; (flags &amp; IO_TAILZEROFILL) &amp;&amp; uio_resid(uio) == 0) {
		                <span class="enscript-comment">/*
				 * we're done with the data from the user specified buffer(s)
				 * and we've been requested to zero fill at the tail
				 * treat this as an IO_HEADZEROFILL which doesn't require a uio
				 * by rearranging the args and passing in IO_HEADZEROFILL
				 */</span>
		                retval = cluster_write_copy(vp, (<span class="enscript-type">struct</span> uio *)0, (u_int32_t)0, (off_t)0, tailOff, uio-&gt;uio_offset,
							    (off_t)0, zflags | IO_HEADZEROFILL | IO_SYNC, callback, callback_arg);
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IO_DIRECT</span>:
			<span class="enscript-comment">/*
			 * cluster_write_direct is never called with IO_TAILZEROFILL || IO_HEADZEROFILL
			 */</span>
			retval = cluster_write_direct(vp, uio, oldEOF, newEOF, &amp;write_type, &amp;write_length, flags, callback, callback_arg);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IO_UNKNOWN</span>:
		        retval = cluster_io_type(uio, &amp;write_type, &amp;write_length, MIN_DIRECT_WRITE_SIZE);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * in case we end up calling cluster_write_copy (from cluster_write_direct)
		 * multiple times to service a multi-vector request that is not aligned properly
		 * we need to update the oldEOF so that we
		 * don't zero-fill the head of a page if we've successfully written
		 * data to that area... 'cluster_write_copy' will zero-fill the head of a
		 * page that is beyond the oldEOF if the write is unaligned... we only
		 * want that to happen for the very first page of the cluster_write, 
		 * NOT the first page of each vector making up a multi-vector write.
		 */</span>
		<span class="enscript-keyword">if</span> (uio-&gt;uio_offset &gt; oldEOF)
			oldEOF = uio-&gt;uio_offset;
	}
	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_write_direct</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, off_t oldEOF, off_t newEOF, <span class="enscript-type">int</span> *write_type, u_int32_t *write_length,
		     <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
	upl_t            upl;
	upl_page_info_t  *pl;
	vm_offset_t      upl_offset;
	vm_offset_t	 vector_upl_offset = 0;
	u_int32_t	 io_req_size;
	u_int32_t	 offset_in_file;
	u_int32_t	 offset_in_iovbase;
	u_int32_t        io_size;
	<span class="enscript-type">int</span>              io_flag = 0;
	upl_size_t	 upl_size, vector_upl_size = 0;
	vm_size_t	 upl_needed_size;
	mach_msg_type_number_t	pages_in_pl;
	upl_control_flags_t upl_flags;
	kern_return_t    kret;
	mach_msg_type_number_t	i;
	<span class="enscript-type">int</span>              force_data_sync;
	<span class="enscript-type">int</span>              retval = 0;
	<span class="enscript-type">int</span>		 first_IO = 1;
	<span class="enscript-type">struct</span> clios     iostate;
	user_addr_t	 iov_base;
	u_int32_t	 mem_alignment_mask;
	u_int32_t	 devblocksize;
	u_int32_t	 max_io_size;
	u_int32_t	 max_upl_size;
	u_int32_t        max_vector_size;
	boolean_t	 io_throttled = FALSE;

	u_int32_t	 vector_upl_iosize = 0;
 	<span class="enscript-type">int</span>		 issueVectorUPL = 0,useVectorUPL = (uio-&gt;uio_iovcnt &gt; 1);
 	off_t		 v_upl_uio_offset = 0;
 	<span class="enscript-type">int</span>		 vector_upl_index=0;
 	upl_t		 vector_upl = NULL;


	<span class="enscript-comment">/*
	 * When we enter this routine, we know
	 *  -- the resid will not exceed iov_len
	 */</span>
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 75)) | DBG_FUNC_START,
		     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, *write_length, (<span class="enscript-type">int</span>)newEOF, 0, 0);

	max_upl_size = cluster_max_io_size(vp-&gt;v_mount, CL_WRITE);

	io_flag = CL_ASYNC | CL_PRESERVE | CL_COMMIT | CL_THROTTLE | CL_DIRECT_IO;

	<span class="enscript-keyword">if</span> (flags &amp; IO_PASSIVE)
		io_flag |= CL_PASSIVE;
	
	<span class="enscript-keyword">if</span> (flags &amp; IO_NOCACHE)
		io_flag |= CL_NOCACHE;
	
	<span class="enscript-keyword">if</span> (flags &amp; IO_SKIP_ENCRYPTION)
		io_flag |= CL_ENCRYPTED;

	iostate.io_completed = 0;
	iostate.io_issued = 0;
	iostate.io_error = 0;
	iostate.io_wanted = 0;

	lck_mtx_init(&amp;iostate.io_mtxp, cl_mtx_grp, cl_mtx_attr);

	mem_alignment_mask = (u_int32_t)vp-&gt;v_mount-&gt;mnt_alignmentmask;
	devblocksize = (u_int32_t)vp-&gt;v_mount-&gt;mnt_devblocksize;

	<span class="enscript-keyword">if</span> (devblocksize == 1) {
               <span class="enscript-comment">/*
                * the AFP client advertises a devblocksize of 1
                * however, its BLOCKMAP routine maps to physical
                * blocks that are PAGE_SIZE in size...
                * therefore we can't ask for I/Os that aren't page aligned
                * or aren't multiples of PAGE_SIZE in size
                * by setting devblocksize to PAGE_SIZE, we re-instate
                * the old behavior we had before the mem_alignment_mask
                * changes went in...
                */</span>
               devblocksize = PAGE_SIZE;
	}

<span class="enscript-reference">next_dwrite</span>:
	io_req_size = *write_length;
	iov_base = uio_curriovbase(uio);

	offset_in_file = (u_int32_t)uio-&gt;uio_offset &amp; PAGE_MASK;
	offset_in_iovbase = (u_int32_t)iov_base &amp; mem_alignment_mask;

	<span class="enscript-keyword">if</span> (offset_in_file || offset_in_iovbase) {
	        <span class="enscript-comment">/*
		 * one of the 2 important offsets is misaligned
		 * so fire an I/O through the cache for this entire vector
		 */</span>
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dwrites</span>;
	}
	<span class="enscript-keyword">if</span> (iov_base &amp; (devblocksize - 1)) {
	        <span class="enscript-comment">/*
		 * the offset in memory must be on a device block boundary
		 * so that we can guarantee that we can generate an
		 * I/O that ends on a page boundary in cluster_io
		 */</span>
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dwrites</span>;
        }

	<span class="enscript-keyword">while</span> (io_req_size &gt;= PAGE_SIZE &amp;&amp; uio-&gt;uio_offset &lt; newEOF &amp;&amp; retval == 0) {
		<span class="enscript-type">int</span>	throttle_type;

		<span class="enscript-keyword">if</span> ( (throttle_type = cluster_is_throttled(vp)) ) {
			<span class="enscript-comment">/*
			 * we're in the throttle window, at the very least
			 * we want to limit the size of the I/O we're about
			 * to issue
			 */</span>
			<span class="enscript-keyword">if</span> ( (flags &amp; IO_RETURN_ON_THROTTLE) &amp;&amp; throttle_type == THROTTLE_NOW) {
				<span class="enscript-comment">/*
				 * we're in the throttle window and at least 1 I/O
				 * has already been issued by a throttleable thread
				 * in this window, so return with EAGAIN to indicate
				 * to the FS issuing the cluster_write call that it
				 * should now throttle after dropping any locks
				 */</span>
				throttle_info_update_by_mount(vp-&gt;v_mount);

				io_throttled = TRUE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dwrites</span>;
			}
			max_vector_size = THROTTLE_MAX_IOSIZE;
			max_io_size = THROTTLE_MAX_IOSIZE;
		} <span class="enscript-keyword">else</span> {
			max_vector_size = MAX_VECTOR_UPL_SIZE;
			max_io_size = max_upl_size;
		}

	        <span class="enscript-keyword">if</span> (first_IO) {
		        cluster_syncup(vp, newEOF, callback, callback_arg, callback ? PUSH_SYNC : 0);
			first_IO = 0;
		}
	        io_size  = io_req_size &amp; ~PAGE_MASK;
		iov_base = uio_curriovbase(uio);

		<span class="enscript-keyword">if</span> (io_size &gt; max_io_size)
		        io_size = max_io_size;

		<span class="enscript-keyword">if</span>(useVectorUPL &amp;&amp; (iov_base &amp; PAGE_MASK)) {
			<span class="enscript-comment">/*
			 * We have an iov_base that's not page-aligned.
			 * Issue all I/O's that have been collected within 
			 * this Vectored UPL.
			 */</span>
			<span class="enscript-keyword">if</span>(vector_upl_index) {
				retval = vector_cluster_io(vp, vector_upl, vector_upl_offset, v_upl_uio_offset, vector_upl_iosize, io_flag, (buf_t)NULL, &amp;iostate, callback, callback_arg);
				reset_vector_run_state();
			}
			
		       <span class="enscript-comment">/*
			* After this point, if we are using the Vector UPL path and the base is
			* not page-aligned then the UPL with that base will be the first in the vector UPL.
			*/</span>
		}

		upl_offset = (vm_offset_t)((u_int32_t)iov_base &amp; PAGE_MASK);
		upl_needed_size = (upl_offset + io_size + (PAGE_SIZE -1)) &amp; ~PAGE_MASK;

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 76)) | DBG_FUNC_START,
			     (<span class="enscript-type">int</span>)upl_offset, upl_needed_size, (<span class="enscript-type">int</span>)iov_base, io_size, 0);

		vm_map_t map = UIO_SEG_IS_USER_SPACE(uio-&gt;uio_segflg) ? current_map() : kernel_map;
		<span class="enscript-keyword">for</span> (force_data_sync = 0; force_data_sync &lt; 3; force_data_sync++) {
		        pages_in_pl = 0;
			upl_size = upl_needed_size;
			upl_flags = UPL_FILE_IO | UPL_COPYOUT_FROM | UPL_NO_SYNC |
		                    UPL_CLEAN_IN_PLACE | UPL_SET_INTERNAL | UPL_SET_LITE | UPL_SET_IO_WIRE
				    | UPL_MEMORY_TAG_MAKE(VM_KERN_MEMORY_FILE);

			kret = vm_map_get_upl(map,
					      (vm_map_offset_t)(iov_base &amp; ~((user_addr_t)PAGE_MASK)),
					      &amp;upl_size,
					      &amp;upl, 
					      NULL, 
					      &amp;pages_in_pl,
					      &amp;upl_flags,
					      force_data_sync);

			<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 76)) | DBG_FUNC_END,
					     0, 0, 0, kret, 0);
				<span class="enscript-comment">/*
				 * failed to get pagelist
				 *
				 * we may have already spun some portion of this request
				 * off as async requests... we need to wait for the I/O
				 * to complete before returning
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dwrites</span>;
			}
			pl = UPL_GET_INTERNAL_PAGE_LIST(upl);
			pages_in_pl = upl_size / PAGE_SIZE;

			<span class="enscript-keyword">for</span> (i = 0; i &lt; pages_in_pl; i++) {
			        <span class="enscript-keyword">if</span> (!upl_valid_page(pl, i))
				        <span class="enscript-keyword">break</span>;		  
			}
			<span class="enscript-keyword">if</span> (i == pages_in_pl)
			        <span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/*
			 * didn't get all the pages back that we
			 * needed... release this upl and try again
			 */</span>
			ubc_upl_abort(upl, 0);
		}
		<span class="enscript-keyword">if</span> (force_data_sync &gt;= 3) {
		        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 76)) | DBG_FUNC_END,
				     i, pages_in_pl, upl_size, kret, 0);
			<span class="enscript-comment">/*
			 * for some reason, we couldn't acquire a hold on all
			 * the pages needed in the user's address space
			 *
			 * we may have already spun some portion of this request
			 * off as async requests... we need to wait for the I/O
			 * to complete before returning
			 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dwrites</span>;
		}

		<span class="enscript-comment">/*
		 * Consider the possibility that upl_size wasn't satisfied.
		 */</span>
		<span class="enscript-keyword">if</span> (upl_size &lt; upl_needed_size) {
		        <span class="enscript-keyword">if</span> (upl_size &amp;&amp; upl_offset == 0)
			        io_size = upl_size;
			<span class="enscript-keyword">else</span>
			        io_size = 0;
		}
		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 76)) | DBG_FUNC_END,
			     (<span class="enscript-type">int</span>)upl_offset, upl_size, (<span class="enscript-type">int</span>)iov_base, io_size, 0);		       

		<span class="enscript-keyword">if</span> (io_size == 0) {
		        ubc_upl_abort(upl, 0);
			<span class="enscript-comment">/*
			 * we may have already spun some portion of this request
			 * off as async requests... we need to wait for the I/O
			 * to complete before returning
			 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dwrites</span>;
		}
		
		<span class="enscript-keyword">if</span>(useVectorUPL) {
			vm_offset_t end_off = ((iov_base + io_size) &amp; PAGE_MASK);
			<span class="enscript-keyword">if</span>(end_off)
				issueVectorUPL = 1;
			<span class="enscript-comment">/*
			 * After this point, if we are using a vector UPL, then
			 * either all the UPL elements end on a page boundary OR
			 * this UPL is the last element because it does not end
			 * on a page boundary.
			 */</span>
		}

		<span class="enscript-comment">/*
		 * we want push out these writes asynchronously so that we can overlap
		 * the preparation of the next I/O
		 * if there are already too many outstanding writes
		 * wait until some complete before issuing the next
		 */</span>
		cluster_iostate_wait(&amp;iostate, max_upl_size * IO_SCALE(vp, 2), <span class="enscript-string">&quot;cluster_write_direct&quot;</span>);

		<span class="enscript-keyword">if</span> (iostate.io_error) {
		        <span class="enscript-comment">/*
			 * one of the earlier writes we issued ran into a hard error
			 * don't issue any more writes, cleanup the UPL
			 * that was just created but not used, then
			 * go wait for all writes that are part of this stream
			 * to complete before returning the error to the caller
			 */</span>
		        ubc_upl_abort(upl, 0);

		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dwrites</span>;
	        }

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 77)) | DBG_FUNC_START,
			     (<span class="enscript-type">int</span>)upl_offset, (<span class="enscript-type">int</span>)uio-&gt;uio_offset, io_size, io_flag, 0);

		<span class="enscript-keyword">if</span>(!useVectorUPL)
			retval = cluster_io(vp, upl, upl_offset, uio-&gt;uio_offset,
				   io_size, io_flag, (buf_t)NULL, &amp;iostate, callback, callback_arg);

		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span>(!vector_upl_index) {
				vector_upl = vector_upl_create(upl_offset);
				v_upl_uio_offset = uio-&gt;uio_offset;
				vector_upl_offset = upl_offset;
			}

			vector_upl_set_subupl(vector_upl,upl,upl_size);
			vector_upl_set_iostate(vector_upl, upl, vector_upl_size, upl_size);
			vector_upl_index++;
			vector_upl_iosize += io_size;
			vector_upl_size += upl_size;

			<span class="enscript-keyword">if</span>(issueVectorUPL || vector_upl_index ==  MAX_VECTOR_UPL_ELEMENTS || vector_upl_size &gt;= max_vector_size) {
				retval = vector_cluster_io(vp, vector_upl, vector_upl_offset, v_upl_uio_offset, vector_upl_iosize, io_flag, (buf_t)NULL, &amp;iostate, callback, callback_arg);
				reset_vector_run_state();
			}
		}	

		<span class="enscript-comment">/*
		 * update the uio structure to
		 * reflect the I/O that we just issued
		 */</span>
		uio_update(uio, (user_size_t)io_size);

		<span class="enscript-comment">/*
		 * in case we end up calling through to cluster_write_copy to finish
		 * the tail of this request, we need to update the oldEOF so that we
		 * don't zero-fill the head of a page if we've successfully written
		 * data to that area... 'cluster_write_copy' will zero-fill the head of a
		 * page that is beyond the oldEOF if the write is unaligned... we only
		 * want that to happen for the very first page of the cluster_write, 
		 * NOT the first page of each vector making up a multi-vector write.
		 */</span>
		<span class="enscript-keyword">if</span> (uio-&gt;uio_offset &gt; oldEOF)
			oldEOF = uio-&gt;uio_offset;

		io_req_size -= io_size;

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 77)) | DBG_FUNC_END,
			     (<span class="enscript-type">int</span>)upl_offset, (<span class="enscript-type">int</span>)uio-&gt;uio_offset, io_req_size, retval, 0);

	} <span class="enscript-comment">/* end while */</span>

        <span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; iostate.io_error == 0 &amp;&amp; io_req_size == 0) {

	        retval = cluster_io_type(uio, write_type, write_length, MIN_DIRECT_WRITE_SIZE);

		<span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; *write_type == IO_DIRECT) {

		        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 75)) | DBG_FUNC_NONE,
				     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, *write_length, (<span class="enscript-type">int</span>)newEOF, 0, 0);

		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">next_dwrite</span>;
		}
        }

<span class="enscript-reference">wait_for_dwrites</span>:

	<span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; iostate.io_error == 0 &amp;&amp; useVectorUPL &amp;&amp; vector_upl_index) {
		retval = vector_cluster_io(vp, vector_upl, vector_upl_offset, v_upl_uio_offset, vector_upl_iosize, io_flag, (buf_t)NULL, &amp;iostate, callback, callback_arg);
		reset_vector_run_state();	
	}
	<span class="enscript-comment">/*
	 * make sure all async writes issued as part of this stream
	 * have completed before we return
	 */</span>
	cluster_iostate_wait(&amp;iostate, 0, <span class="enscript-string">&quot;cluster_write_direct&quot;</span>);

	<span class="enscript-keyword">if</span> (iostate.io_error)
	        retval = iostate.io_error;

	lck_mtx_destroy(&amp;iostate.io_mtxp, cl_mtx_grp);

	<span class="enscript-keyword">if</span> (io_throttled == TRUE &amp;&amp; retval == 0)
		retval = EAGAIN;

	<span class="enscript-keyword">if</span> (io_req_size &amp;&amp; retval == 0) {
	        <span class="enscript-comment">/*
		 * we couldn't handle the tail of this request in DIRECT mode
		 * so fire it through the copy path
		 *
		 * note that flags will never have IO_HEADZEROFILL or IO_TAILZEROFILL set
		 * so we can just pass 0 in for the headOff and tailOff
		 */</span>
		<span class="enscript-keyword">if</span> (uio-&gt;uio_offset &gt; oldEOF)
			oldEOF = uio-&gt;uio_offset;

	        retval = cluster_write_copy(vp, uio, io_req_size, oldEOF, newEOF, (off_t)0, (off_t)0, flags, callback, callback_arg);

		*write_type = IO_UNKNOWN;
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 75)) | DBG_FUNC_END,
		     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, io_req_size, retval, 4, 0);

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_write_contig</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, off_t newEOF, <span class="enscript-type">int</span> *write_type, u_int32_t *write_length,
		     <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg, <span class="enscript-type">int</span> bflag)
{
	upl_page_info_t *pl;
	addr64_t	 src_paddr = 0;
 	upl_t            upl[MAX_VECTS];
	vm_offset_t      upl_offset;
	u_int32_t        tail_size = 0;
	u_int32_t	 io_size;
	u_int32_t	 xsize;
	upl_size_t	 upl_size;
	vm_size_t	 upl_needed_size;
	mach_msg_type_number_t	pages_in_pl;
	upl_control_flags_t upl_flags;
	kern_return_t    kret;
        <span class="enscript-type">struct</span> clios     iostate;
	<span class="enscript-type">int</span>              error  = 0;
	<span class="enscript-type">int</span>		 cur_upl = 0;
	<span class="enscript-type">int</span>		 num_upl = 0;
	<span class="enscript-type">int</span>		 n;
	user_addr_t	 iov_base;
	u_int32_t	 devblocksize;
	u_int32_t	 mem_alignment_mask;

	<span class="enscript-comment">/*
	 * When we enter this routine, we know
	 *  -- the io_req_size will not exceed iov_len
	 *  -- the target address is physically contiguous
	 */</span>
	cluster_syncup(vp, newEOF, callback, callback_arg, callback ? PUSH_SYNC : 0);

	devblocksize = (u_int32_t)vp-&gt;v_mount-&gt;mnt_devblocksize;
	mem_alignment_mask = (u_int32_t)vp-&gt;v_mount-&gt;mnt_alignmentmask;

        iostate.io_completed = 0;
        iostate.io_issued = 0;
        iostate.io_error = 0;
        iostate.io_wanted = 0;

	lck_mtx_init(&amp;iostate.io_mtxp, cl_mtx_grp, cl_mtx_attr);

<span class="enscript-reference">next_cwrite</span>:
	io_size = *write_length;

	iov_base = uio_curriovbase(uio);

	upl_offset = (vm_offset_t)((u_int32_t)iov_base &amp; PAGE_MASK);
	upl_needed_size = upl_offset + io_size;

	pages_in_pl = 0;
	upl_size = upl_needed_size;
	upl_flags = UPL_FILE_IO | UPL_COPYOUT_FROM | UPL_NO_SYNC | 
	            UPL_CLEAN_IN_PLACE | UPL_SET_INTERNAL | UPL_SET_LITE | UPL_SET_IO_WIRE
		    | UPL_MEMORY_TAG_MAKE(VM_KERN_MEMORY_FILE);

	vm_map_t map = UIO_SEG_IS_USER_SPACE(uio-&gt;uio_segflg) ? current_map() : kernel_map;
	kret = vm_map_get_upl(map,
			      (vm_map_offset_t)(iov_base &amp; ~((user_addr_t)PAGE_MASK)),
			      &amp;upl_size, &amp;upl[cur_upl], NULL, &amp;pages_in_pl, &amp;upl_flags, 0);

	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
	        <span class="enscript-comment">/*
		 * failed to get pagelist
		 */</span>
	        error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_cwrites</span>;
	}
	num_upl++;

	<span class="enscript-comment">/*
	 * Consider the possibility that upl_size wasn't satisfied.
	 */</span>
	<span class="enscript-keyword">if</span> (upl_size &lt; upl_needed_size) {
		<span class="enscript-comment">/*
		 * This is a failure in the physical memory case.
		 */</span>
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_cwrites</span>;
	}
	pl = ubc_upl_pageinfo(upl[cur_upl]);

	src_paddr = ((addr64_t)upl_phys_page(pl, 0) &lt;&lt; PAGE_SHIFT) + (addr64_t)upl_offset;

	<span class="enscript-keyword">while</span> (((uio-&gt;uio_offset &amp; (devblocksize - 1)) || io_size &lt; devblocksize) &amp;&amp; io_size) {
	        u_int32_t   head_size;

		head_size = devblocksize - (u_int32_t)(uio-&gt;uio_offset &amp; (devblocksize - 1));

		<span class="enscript-keyword">if</span> (head_size &gt; io_size)
		        head_size = io_size;

		error = cluster_align_phys_io(vp, uio, src_paddr, head_size, 0, callback, callback_arg);

		<span class="enscript-keyword">if</span> (error)
		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_cwrites</span>;

		upl_offset += head_size;
		src_paddr  += head_size;
		io_size    -= head_size;

		iov_base   += head_size;
	}
	<span class="enscript-keyword">if</span> ((u_int32_t)iov_base &amp; mem_alignment_mask) {
	        <span class="enscript-comment">/*
		 * request doesn't set up on a memory boundary
		 * the underlying DMA engine can handle...
		 * return an error instead of going through
		 * the slow copy path since the intent of this
		 * path is direct I/O from device memory
		 */</span>
	        error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_cwrites</span>;
	}

	tail_size = io_size &amp; (devblocksize - 1);
	io_size  -= tail_size;

	<span class="enscript-keyword">while</span> (io_size &amp;&amp; error == 0) {

	        <span class="enscript-keyword">if</span> (io_size &gt; MAX_IO_CONTIG_SIZE)
		        xsize = MAX_IO_CONTIG_SIZE;
		<span class="enscript-keyword">else</span>
		        xsize = io_size;
		<span class="enscript-comment">/*
		 * request asynchronously so that we can overlap
		 * the preparation of the next I/O... we'll do
		 * the commit after all the I/O has completed
		 * since its all issued against the same UPL
		 * if there are already too many outstanding writes
		 * wait until some have completed before issuing the next
		 */</span>
		cluster_iostate_wait(&amp;iostate, MAX_IO_CONTIG_SIZE * IO_SCALE(vp, 2), <span class="enscript-string">&quot;cluster_write_contig&quot;</span>);

                <span class="enscript-keyword">if</span> (iostate.io_error) {
                        <span class="enscript-comment">/*
                         * one of the earlier writes we issued ran into a hard error
                         * don't issue any more writes...
                         * go wait for all writes that are part of this stream
                         * to complete before returning the error to the caller
                         */</span>
		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_cwrites</span>;
		}
	        <span class="enscript-comment">/*
		 * issue an asynchronous write to cluster_io
		 */</span>
	        error = cluster_io(vp, upl[cur_upl], upl_offset, uio-&gt;uio_offset,
				   xsize, CL_DEV_MEMORY | CL_ASYNC | bflag, (buf_t)NULL, (<span class="enscript-type">struct</span> clios *)&amp;iostate, callback, callback_arg);

		<span class="enscript-keyword">if</span> (error == 0) {
		        <span class="enscript-comment">/*
			 * The cluster_io write completed successfully,
			 * update the uio structure
			 */</span>
		        uio_update(uio, (user_size_t)xsize);

			upl_offset += xsize;
			src_paddr  += xsize;
			io_size    -= xsize;
		}
	}
        <span class="enscript-keyword">if</span> (error == 0 &amp;&amp; iostate.io_error == 0 &amp;&amp; tail_size == 0 &amp;&amp; num_upl &lt; MAX_VECTS) {

	        error = cluster_io_type(uio, write_type, write_length, 0);

		<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; *write_type == IO_CONTIG) {
		        cur_upl++;
                        <span class="enscript-keyword">goto</span> <span class="enscript-reference">next_cwrite</span>;
		}
	} <span class="enscript-keyword">else</span>
	        *write_type = IO_UNKNOWN;

<span class="enscript-reference">wait_for_cwrites</span>:
	<span class="enscript-comment">/*
         * make sure all async writes that are part of this stream
         * have completed before we proceed
         */</span>
	cluster_iostate_wait(&amp;iostate, 0, <span class="enscript-string">&quot;cluster_write_contig&quot;</span>);

        <span class="enscript-keyword">if</span> (iostate.io_error)
	        error = iostate.io_error;

	lck_mtx_destroy(&amp;iostate.io_mtxp, cl_mtx_grp);

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; tail_size)
	        error = cluster_align_phys_io(vp, uio, src_paddr, tail_size, 0, callback, callback_arg);

        <span class="enscript-keyword">for</span> (n = 0; n &lt; num_upl; n++)
	        <span class="enscript-comment">/*
		 * just release our hold on each physically contiguous
		 * region without changing any state
		 */</span>
	        ubc_upl_abort(upl[n], 0);

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * need to avoid a race between an msync of a range of pages dirtied via mmap
 * vs a filesystem such as HFS deciding to write a 'hole' to disk via cluster_write's
 * zerofill mechanism before it has seen the VNOP_PAGEOUTs for the pages being msync'd
 *
 * we should never force-zero-fill pages that are already valid in the cache...
 * the entire page contains valid data (either from disk, zero-filled or dirtied
 * via an mmap) so we can only do damage by trying to zero-fill
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_zero_range</span>(upl_t upl, upl_page_info_t *pl, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> io_offset, off_t zero_off, off_t upl_f_offset, <span class="enscript-type">int</span> bytes_to_zero)
{
	<span class="enscript-type">int</span> zero_pg_index;
	boolean_t need_cluster_zero = TRUE;

        <span class="enscript-keyword">if</span> ((flags &amp; (IO_NOZEROVALID | IO_NOZERODIRTY))) {

	        bytes_to_zero = min(bytes_to_zero, PAGE_SIZE - (<span class="enscript-type">int</span>)(zero_off &amp; PAGE_MASK_64));
		zero_pg_index = (<span class="enscript-type">int</span>)((zero_off - upl_f_offset) / PAGE_SIZE_64);

		<span class="enscript-keyword">if</span> (upl_valid_page(pl, zero_pg_index)) {
			<span class="enscript-comment">/*
			 * never force zero valid pages - dirty or clean
			 * we'll leave these in the UPL for cluster_write_copy to deal with
			 */</span>
			need_cluster_zero = FALSE;
		} 
	}
	<span class="enscript-keyword">if</span> (need_cluster_zero == TRUE)
		cluster_zero(upl, io_offset, bytes_to_zero, NULL);

	<span class="enscript-keyword">return</span> (bytes_to_zero);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_write_copy</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, u_int32_t io_req_size, off_t oldEOF, off_t newEOF, off_t headOff,
		   off_t tailOff, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
	upl_page_info_t *pl;
	upl_t            upl;
	vm_offset_t      upl_offset = 0;
	vm_size_t	 upl_size;
	off_t 	         upl_f_offset;
	<span class="enscript-type">int</span>              pages_in_upl;
	<span class="enscript-type">int</span>		 start_offset;
	<span class="enscript-type">int</span>              xfer_resid;
	<span class="enscript-type">int</span>              io_size;
	<span class="enscript-type">int</span>              io_offset;
	<span class="enscript-type">int</span>              bytes_to_zero;
	<span class="enscript-type">int</span>              bytes_to_move;
	kern_return_t    kret;
	<span class="enscript-type">int</span>              retval = 0;
	<span class="enscript-type">int</span>              io_resid;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span>        total_size;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span>        zero_cnt;
	off_t            zero_off;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span>        zero_cnt1;
	off_t            zero_off1;
	off_t		 write_off = 0;
	<span class="enscript-type">int</span>		 write_cnt = 0;
	boolean_t	 first_pass = FALSE;
	<span class="enscript-type">struct</span> cl_extent cl;
	<span class="enscript-type">struct</span> cl_writebehind *wbp;
	<span class="enscript-type">int</span>              bflag;
	u_int		 max_cluster_pgcount;
	u_int		 max_io_size;

	<span class="enscript-keyword">if</span> (uio) {
	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 40)) | DBG_FUNC_START,
			     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, io_req_size, (<span class="enscript-type">int</span>)oldEOF, (<span class="enscript-type">int</span>)newEOF, 0);

	        io_resid = io_req_size;
	} <span class="enscript-keyword">else</span> {
	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 40)) | DBG_FUNC_START,
			     0, 0, (<span class="enscript-type">int</span>)oldEOF, (<span class="enscript-type">int</span>)newEOF, 0);

	        io_resid = 0;
	}
	<span class="enscript-keyword">if</span> (flags &amp; IO_PASSIVE)
		bflag = CL_PASSIVE;
	<span class="enscript-keyword">else</span>
		bflag = 0;
	<span class="enscript-keyword">if</span> (flags &amp; IO_NOCACHE)
		bflag |= CL_NOCACHE;
	
	<span class="enscript-keyword">if</span> (flags &amp; IO_SKIP_ENCRYPTION)
		bflag |= CL_ENCRYPTED;

	zero_cnt  = 0;
	zero_cnt1 = 0;
	zero_off  = 0;
	zero_off1 = 0;

	max_cluster_pgcount = MAX_CLUSTER_SIZE(vp) / PAGE_SIZE;
	max_io_size = cluster_max_io_size(vp-&gt;v_mount, CL_WRITE);

	<span class="enscript-keyword">if</span> (flags &amp; IO_HEADZEROFILL) {
	        <span class="enscript-comment">/*
		 * some filesystems (HFS is one) don't support unallocated holes within a file...
		 * so we zero fill the intervening space between the old EOF and the offset
		 * where the next chunk of real data begins.... ftruncate will also use this
		 * routine to zero fill to the new EOF when growing a file... in this case, the
		 * uio structure will not be provided
		 */</span>
	        <span class="enscript-keyword">if</span> (uio) {
		        <span class="enscript-keyword">if</span> (headOff &lt; uio-&gt;uio_offset) {
			        zero_cnt = uio-&gt;uio_offset - headOff;
				zero_off = headOff;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (headOff &lt; newEOF) {	
		        zero_cnt = newEOF - headOff;
			zero_off = headOff;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (uio &amp;&amp; uio-&gt;uio_offset &gt; oldEOF) {
			zero_off = uio-&gt;uio_offset &amp; ~PAGE_MASK_64;

			<span class="enscript-keyword">if</span> (zero_off &gt;= oldEOF) {
				zero_cnt = uio-&gt;uio_offset - zero_off;

				flags |= IO_HEADZEROFILL;
			}
		}
	}
	<span class="enscript-keyword">if</span> (flags &amp; IO_TAILZEROFILL) {
	        <span class="enscript-keyword">if</span> (uio) {
		        zero_off1 = uio-&gt;uio_offset + io_req_size;

			<span class="enscript-keyword">if</span> (zero_off1 &lt; tailOff)
			        zero_cnt1 = tailOff - zero_off1;
		}	
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (uio &amp;&amp; newEOF &gt; oldEOF) {
		        zero_off1 = uio-&gt;uio_offset + io_req_size;

			<span class="enscript-keyword">if</span> (zero_off1 == newEOF &amp;&amp; (zero_off1 &amp; PAGE_MASK_64)) {
				zero_cnt1 = PAGE_SIZE_64 - (zero_off1 &amp; PAGE_MASK_64);

				flags |= IO_TAILZEROFILL;
			}
		}
	}
	<span class="enscript-keyword">if</span> (zero_cnt == 0 &amp;&amp; uio == (<span class="enscript-type">struct</span> uio *) 0) {
	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 40)) | DBG_FUNC_END,
			     retval, 0, 0, 0, 0);
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> (uio) {
		write_off = uio-&gt;uio_offset;
		write_cnt = uio_resid(uio);
		<span class="enscript-comment">/*
		 * delay updating the sequential write info
		 * in the control block until we've obtained
		 * the lock for it
		 */</span>
		first_pass = TRUE;
	}
	<span class="enscript-keyword">while</span> ((total_size = (io_resid + zero_cnt + zero_cnt1)) &amp;&amp; retval == 0) {
	        <span class="enscript-comment">/*
		 * for this iteration of the loop, figure out where our starting point is
		 */</span>
	        <span class="enscript-keyword">if</span> (zero_cnt) {
		        start_offset = (<span class="enscript-type">int</span>)(zero_off &amp; PAGE_MASK_64);
			upl_f_offset = zero_off - start_offset;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (io_resid) {
		        start_offset = (<span class="enscript-type">int</span>)(uio-&gt;uio_offset &amp; PAGE_MASK_64);
			upl_f_offset = uio-&gt;uio_offset - start_offset;
		} <span class="enscript-keyword">else</span> {
		        start_offset = (<span class="enscript-type">int</span>)(zero_off1 &amp; PAGE_MASK_64);
			upl_f_offset = zero_off1 - start_offset;
		}
	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 46)) | DBG_FUNC_NONE,
			     (<span class="enscript-type">int</span>)zero_off, (<span class="enscript-type">int</span>)zero_cnt, (<span class="enscript-type">int</span>)zero_off1, (<span class="enscript-type">int</span>)zero_cnt1, 0);

	        <span class="enscript-keyword">if</span> (total_size &gt; max_io_size)
		        total_size = max_io_size;

		cl.b_addr = (daddr64_t)(upl_f_offset / PAGE_SIZE_64);
		
		<span class="enscript-keyword">if</span> (uio &amp;&amp; ((flags &amp; (IO_SYNC | IO_HEADZEROFILL | IO_TAILZEROFILL)) == 0)) {
		        <span class="enscript-comment">/*
			 * assumption... total_size &lt;= io_resid
			 * because IO_HEADZEROFILL and IO_TAILZEROFILL not set
			 */</span>
		        <span class="enscript-keyword">if</span> ((start_offset + total_size) &gt; max_io_size)
			        total_size = max_io_size - start_offset;
		        xfer_resid = total_size;

		        retval = cluster_copy_ubc_data_internal(vp, uio, &amp;xfer_resid, 1, 1);

			<span class="enscript-keyword">if</span> (retval)
			        <span class="enscript-keyword">break</span>;

			io_resid    -= (total_size - xfer_resid);
			total_size   = xfer_resid;
			start_offset = (<span class="enscript-type">int</span>)(uio-&gt;uio_offset &amp; PAGE_MASK_64);
			upl_f_offset = uio-&gt;uio_offset - start_offset;

			<span class="enscript-keyword">if</span> (total_size == 0) {
			        <span class="enscript-keyword">if</span> (start_offset) {
				        <span class="enscript-comment">/*
					 * the write did not finish on a page boundary
					 * which will leave upl_f_offset pointing to the
					 * beginning of the last page written instead of
					 * the page beyond it... bump it in this case
					 * so that the cluster code records the last page
					 * written as dirty
					 */</span>
				        upl_f_offset += PAGE_SIZE_64;
				}
			        upl_size = 0;
				
			        <span class="enscript-keyword">goto</span> <span class="enscript-reference">check_cluster</span>;
			}
		}
		<span class="enscript-comment">/*
		 * compute the size of the upl needed to encompass
		 * the requested write... limit each call to cluster_io
		 * to the maximum UPL size... cluster_io will clip if
		 * this exceeds the maximum io_size for the device,
		 * make sure to account for 
		 * a starting offset that's not page aligned
		 */</span>
		upl_size = (start_offset + total_size + (PAGE_SIZE - 1)) &amp; ~PAGE_MASK;

	        <span class="enscript-keyword">if</span> (upl_size &gt; max_io_size)
		        upl_size = max_io_size;

		pages_in_upl = upl_size / PAGE_SIZE;
		io_size      = upl_size - start_offset;
		
		<span class="enscript-keyword">if</span> ((<span class="enscript-type">long</span> <span class="enscript-type">long</span>)io_size &gt; total_size)
		        io_size = total_size;

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 41)) | DBG_FUNC_START, upl_size, io_size, total_size, 0, 0);
			

		<span class="enscript-comment">/*
		 * Gather the pages from the buffer cache.
		 * The UPL_WILL_MODIFY flag lets the UPL subsystem know
		 * that we intend to modify these pages.
		 */</span>
		kret = ubc_create_upl(vp, 
				      upl_f_offset,
				      upl_size,
				      &amp;upl,
				      &amp;pl,
				      UPL_SET_LITE | (( uio!=NULL &amp;&amp; (uio-&gt;uio_flags &amp; UIO_FLAGS_IS_COMPRESSED_FILE)) ? 0 : UPL_WILL_MODIFY));
		<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
			panic(<span class="enscript-string">&quot;cluster_write_copy: failed to get pagelist&quot;</span>);

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 41)) | DBG_FUNC_END,
			upl, (<span class="enscript-type">int</span>)upl_f_offset, start_offset, 0, 0);

		<span class="enscript-keyword">if</span> (start_offset &amp;&amp; upl_f_offset &lt; oldEOF &amp;&amp; !upl_valid_page(pl, 0)) {
			<span class="enscript-type">int</span>   read_size;

			<span class="enscript-comment">/*
			 * we're starting in the middle of the first page of the upl
			 * and the page isn't currently valid, so we're going to have
			 * to read it in first... this is a synchronous operation
			 */</span>
			read_size = PAGE_SIZE;

			<span class="enscript-keyword">if</span> ((upl_f_offset + read_size) &gt; oldEOF)
			        read_size = oldEOF - upl_f_offset;

		        retval = cluster_io(vp, upl, 0, upl_f_offset, read_size,
					    CL_READ | bflag, (buf_t)NULL, (<span class="enscript-type">struct</span> clios *)NULL, callback, callback_arg);
			<span class="enscript-keyword">if</span> (retval) {
				<span class="enscript-comment">/*
				 * we had an error during the read which causes us to abort
				 * the current cluster_write request... before we do, we need
				 * to release the rest of the pages in the upl without modifying
				 * there state and mark the failed page in error
				 */</span>
				ubc_upl_abort_range(upl, 0, PAGE_SIZE, UPL_ABORT_DUMP_PAGES|UPL_ABORT_FREE_ON_EMPTY);

				<span class="enscript-keyword">if</span> (upl_size &gt; PAGE_SIZE)
				        ubc_upl_abort_range(upl, 0, upl_size, UPL_ABORT_FREE_ON_EMPTY);

				KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 45)) | DBG_FUNC_NONE,
					     upl, 0, 0, retval, 0);
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> ((start_offset == 0 || upl_size &gt; PAGE_SIZE) &amp;&amp; ((start_offset + io_size) &amp; PAGE_MASK)) {
		        <span class="enscript-comment">/* 
			 * the last offset we're writing to in this upl does not end on a page
			 * boundary... if it's not beyond the old EOF, then we'll also need to
			 * pre-read this page in if it isn't already valid
			 */</span>
		        upl_offset = upl_size - PAGE_SIZE;

		        <span class="enscript-keyword">if</span> ((upl_f_offset + start_offset + io_size) &lt; oldEOF &amp;&amp;
			    !upl_valid_page(pl, upl_offset / PAGE_SIZE)) {
			        <span class="enscript-type">int</span>   read_size;

				read_size = PAGE_SIZE;

				<span class="enscript-keyword">if</span> ((off_t)(upl_f_offset + upl_offset + read_size) &gt; oldEOF)
				        read_size = oldEOF - (upl_f_offset + upl_offset);

			        retval = cluster_io(vp, upl, upl_offset, upl_f_offset + upl_offset, read_size,
						    CL_READ | bflag, (buf_t)NULL, (<span class="enscript-type">struct</span> clios *)NULL, callback, callback_arg);
				<span class="enscript-keyword">if</span> (retval) {
					<span class="enscript-comment">/*
					 * we had an error during the read which causes us to abort
					 * the current cluster_write request... before we do, we
					 * need to release the rest of the pages in the upl without
					 * modifying there state and mark the failed page in error
					 */</span>
					ubc_upl_abort_range(upl, upl_offset, PAGE_SIZE, UPL_ABORT_DUMP_PAGES|UPL_ABORT_FREE_ON_EMPTY);

					<span class="enscript-keyword">if</span> (upl_size &gt; PAGE_SIZE)
					        ubc_upl_abort_range(upl, 0, upl_size, UPL_ABORT_FREE_ON_EMPTY);

					KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 45)) | DBG_FUNC_NONE,
						     upl, 0, 0, retval, 0);
					<span class="enscript-keyword">break</span>;
				}
			}
		}
		xfer_resid = io_size;
		io_offset = start_offset;

		<span class="enscript-keyword">while</span> (zero_cnt &amp;&amp; xfer_resid) {

		        <span class="enscript-keyword">if</span> (zero_cnt &lt; (<span class="enscript-type">long</span> <span class="enscript-type">long</span>)xfer_resid)
			        bytes_to_zero = zero_cnt;
			<span class="enscript-keyword">else</span>
			        bytes_to_zero = xfer_resid;

			bytes_to_zero = cluster_zero_range(upl, pl, flags, io_offset, zero_off, upl_f_offset, bytes_to_zero);

			xfer_resid -= bytes_to_zero;
			zero_cnt   -= bytes_to_zero;
			zero_off   += bytes_to_zero;
			io_offset  += bytes_to_zero;
		}
		<span class="enscript-keyword">if</span> (xfer_resid &amp;&amp; io_resid) {
		        u_int32_t  io_requested;

			bytes_to_move = min(io_resid, xfer_resid);
			io_requested = bytes_to_move;

			retval = cluster_copy_upl_data(uio, upl, io_offset, (<span class="enscript-type">int</span> *)&amp;io_requested);

			<span class="enscript-keyword">if</span> (retval) {
				ubc_upl_abort_range(upl, 0, upl_size, UPL_ABORT_DUMP_PAGES | UPL_ABORT_FREE_ON_EMPTY);

				KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 45)) | DBG_FUNC_NONE,
					     upl, 0, 0, retval, 0);
			} <span class="enscript-keyword">else</span> {
			        io_resid   -= bytes_to_move;
				xfer_resid -= bytes_to_move;
				io_offset  += bytes_to_move;
			}
		}
		<span class="enscript-keyword">while</span> (xfer_resid &amp;&amp; zero_cnt1 &amp;&amp; retval == 0) {

		        <span class="enscript-keyword">if</span> (zero_cnt1 &lt; (<span class="enscript-type">long</span> <span class="enscript-type">long</span>)xfer_resid)
			        bytes_to_zero = zero_cnt1;
			<span class="enscript-keyword">else</span>
			        bytes_to_zero = xfer_resid;

			bytes_to_zero = cluster_zero_range(upl, pl, flags, io_offset, zero_off1, upl_f_offset, bytes_to_zero);

			xfer_resid -= bytes_to_zero;
			zero_cnt1  -= bytes_to_zero;
			zero_off1  += bytes_to_zero;
			io_offset  += bytes_to_zero;
		}
		<span class="enscript-keyword">if</span> (retval == 0) {
			<span class="enscript-type">int</span> cl_index;
			<span class="enscript-type">int</span> ret_cluster_try_push;

		        io_size += start_offset;

			<span class="enscript-keyword">if</span> ((upl_f_offset + io_size) &gt;= newEOF &amp;&amp; (u_int)io_size &lt; upl_size) {
			        <span class="enscript-comment">/*
				 * if we're extending the file with this write
				 * we'll zero fill the rest of the page so that
				 * if the file gets extended again in such a way as to leave a
				 * hole starting at this EOF, we'll have zero's in the correct spot
				 */</span>
			        cluster_zero(upl, io_size, upl_size - io_size, NULL); 
			}
			<span class="enscript-comment">/*
			 * release the upl now if we hold one since...
			 * 1) pages in it may be present in the sparse cluster map
			 *    and may span 2 separate buckets there... if they do and 
			 *    we happen to have to flush a bucket to make room and it intersects
			 *    this upl, a deadlock may result on page BUSY
			 * 2) we're delaying the I/O... from this point forward we're just updating
			 *    the cluster state... no need to hold the pages, so commit them
			 * 3) IO_SYNC is set...
			 *    because we had to ask for a UPL that provides currenty non-present pages, the
			 *    UPL has been automatically set to clear the dirty flags (both software and hardware)
			 *    upon committing it... this is not the behavior we want since it's possible for
			 *    pages currently present as part of a mapped file to be dirtied while the I/O is in flight.
			 *    we'll pick these pages back up later with the correct behavior specified.
			 * 4) we don't want to hold pages busy in a UPL and then block on the cluster lock... if a flush
			 *    of this vnode is in progress, we will deadlock if the pages being flushed intersect the pages
			 *    we hold since the flushing context is holding the cluster lock.
			 */</span>
			ubc_upl_commit_range(upl, 0, upl_size,
					     UPL_COMMIT_SET_DIRTY | UPL_COMMIT_INACTIVATE | UPL_COMMIT_FREE_ON_EMPTY);
<span class="enscript-reference">check_cluster</span>:
			<span class="enscript-comment">/*
			 * calculate the last logical block number 
			 * that this delayed I/O encompassed
			 */</span>
			cl.e_addr = (daddr64_t)((upl_f_offset + (off_t)upl_size) / PAGE_SIZE_64);

			<span class="enscript-keyword">if</span> (flags &amp; IO_SYNC) {
			        <span class="enscript-comment">/*
				 * if the IO_SYNC flag is set than we need to 
				 * bypass any clusters and immediately issue
				 * the I/O
				 */</span>
			        <span class="enscript-keyword">goto</span> <span class="enscript-reference">issue_io</span>;
			}
			<span class="enscript-comment">/*
			 * take the lock to protect our accesses
			 * of the writebehind and sparse cluster state
			 */</span>
			wbp = cluster_get_wbp(vp, CLW_ALLOCATE | CLW_RETURNLOCKED);

			<span class="enscript-keyword">if</span> (wbp-&gt;cl_scmap) {

			        <span class="enscript-keyword">if</span> ( !(flags &amp; IO_NOCACHE)) {
				        <span class="enscript-comment">/*
					 * we've fallen into the sparse
					 * cluster method of delaying dirty pages
					 */</span>
					sparse_cluster_add(&amp;(wbp-&gt;cl_scmap), vp, &amp;cl, newEOF, callback, callback_arg);

					lck_mtx_unlock(&amp;wbp-&gt;cl_lockw);

					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-comment">/*
				 * must have done cached writes that fell into
				 * the sparse cluster mechanism... we've switched
				 * to uncached writes on the file, so go ahead
				 * and push whatever's in the sparse map
				 * and switch back to normal clustering
				 */</span>
				wbp-&gt;cl_number = 0;

				sparse_cluster_push(&amp;(wbp-&gt;cl_scmap), vp, newEOF, PUSH_ALL, 0, callback, callback_arg);
				<span class="enscript-comment">/*
				 * no clusters of either type present at this point
				 * so just go directly to start_new_cluster since
				 * we know we need to delay this I/O since we've
				 * already released the pages back into the cache
				 * to avoid the deadlock with sparse_cluster_push
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">start_new_cluster</span>;
			}
			<span class="enscript-keyword">if</span> (first_pass) {
				<span class="enscript-keyword">if</span> (write_off == wbp-&gt;cl_last_write)
					wbp-&gt;cl_seq_written += write_cnt;
				<span class="enscript-keyword">else</span>
					wbp-&gt;cl_seq_written = write_cnt;

				wbp-&gt;cl_last_write = write_off + write_cnt;

				first_pass = FALSE;
			}
			<span class="enscript-keyword">if</span> (wbp-&gt;cl_number == 0)
			        <span class="enscript-comment">/*
				 * no clusters currently present
				 */</span>
			        <span class="enscript-keyword">goto</span> <span class="enscript-reference">start_new_cluster</span>;

			<span class="enscript-keyword">for</span> (cl_index = 0; cl_index &lt; wbp-&gt;cl_number; cl_index++) {
			        <span class="enscript-comment">/*
				 * check each cluster that we currently hold
				 * try to merge some or all of this write into
				 * one or more of the existing clusters... if
				 * any portion of the write remains, start a
				 * new cluster
				 */</span>
			        <span class="enscript-keyword">if</span> (cl.b_addr &gt;= wbp-&gt;cl_clusters[cl_index].b_addr) {
				        <span class="enscript-comment">/*
					 * the current write starts at or after the current cluster
					 */</span>
				        <span class="enscript-keyword">if</span> (cl.e_addr &lt;= (wbp-&gt;cl_clusters[cl_index].b_addr + max_cluster_pgcount)) {
					        <span class="enscript-comment">/*
						 * we have a write that fits entirely
						 * within the existing cluster limits
						 */</span>
					        <span class="enscript-keyword">if</span> (cl.e_addr &gt; wbp-&gt;cl_clusters[cl_index].e_addr)
						        <span class="enscript-comment">/*
							 * update our idea of where the cluster ends
							 */</span>
						        wbp-&gt;cl_clusters[cl_index].e_addr = cl.e_addr;
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">if</span> (cl.b_addr &lt; (wbp-&gt;cl_clusters[cl_index].b_addr + max_cluster_pgcount)) {
					        <span class="enscript-comment">/*
						 * we have a write that starts in the middle of the current cluster
						 * but extends beyond the cluster's limit... we know this because
						 * of the previous checks
						 * we'll extend the current cluster to the max
						 * and update the b_addr for the current write to reflect that
						 * the head of it was absorbed into this cluster...
						 * note that we'll always have a leftover tail in this case since
						 * full absorbtion would have occurred in the clause above
						 */</span>
					        wbp-&gt;cl_clusters[cl_index].e_addr = wbp-&gt;cl_clusters[cl_index].b_addr + max_cluster_pgcount;

						cl.b_addr = wbp-&gt;cl_clusters[cl_index].e_addr;
					}
					<span class="enscript-comment">/*
					 * we come here for the case where the current write starts
					 * beyond the limit of the existing cluster or we have a leftover
					 * tail after a partial absorbtion
					 *
					 * in either case, we'll check the remaining clusters before 
					 * starting a new one
					 */</span>
				} <span class="enscript-keyword">else</span> {
				        <span class="enscript-comment">/*
					 * the current write starts in front of the cluster we're currently considering
					 */</span>
				        <span class="enscript-keyword">if</span> ((wbp-&gt;cl_clusters[cl_index].e_addr - cl.b_addr) &lt;= max_cluster_pgcount) {
					        <span class="enscript-comment">/*
						 * we can just merge the new request into
						 * this cluster and leave it in the cache
						 * since the resulting cluster is still 
						 * less than the maximum allowable size
						 */</span>
					        wbp-&gt;cl_clusters[cl_index].b_addr = cl.b_addr;

						<span class="enscript-keyword">if</span> (cl.e_addr &gt; wbp-&gt;cl_clusters[cl_index].e_addr) {
						        <span class="enscript-comment">/*
							 * the current write completely
							 * envelops the existing cluster and since
							 * each write is limited to at most max_cluster_pgcount pages
							 * we can just use the start and last blocknos of the write
							 * to generate the cluster limits
							 */</span>
						        wbp-&gt;cl_clusters[cl_index].e_addr = cl.e_addr;
						}
						<span class="enscript-keyword">break</span>;
					}

					<span class="enscript-comment">/*
					 * if we were to combine this write with the current cluster
					 * we would exceed the cluster size limit.... so,
					 * let's see if there's any overlap of the new I/O with
					 * the cluster we're currently considering... in fact, we'll
					 * stretch the cluster out to it's full limit and see if we
					 * get an intersection with the current write
					 * 
					 */</span>
					<span class="enscript-keyword">if</span> (cl.e_addr &gt; wbp-&gt;cl_clusters[cl_index].e_addr - max_cluster_pgcount) {
					        <span class="enscript-comment">/*
						 * the current write extends into the proposed cluster
						 * clip the length of the current write after first combining it's
						 * tail with the newly shaped cluster
						 */</span>
					        wbp-&gt;cl_clusters[cl_index].b_addr = wbp-&gt;cl_clusters[cl_index].e_addr - max_cluster_pgcount;

						cl.e_addr = wbp-&gt;cl_clusters[cl_index].b_addr;
					}
					<span class="enscript-comment">/*
					 * if we get here, there was no way to merge
					 * any portion of this write with this cluster 
					 * or we could only merge part of it which 
					 * will leave a tail...
					 * we'll check the remaining clusters before starting a new one
					 */</span>
				}
			}
			<span class="enscript-keyword">if</span> (cl_index &lt; wbp-&gt;cl_number)
			        <span class="enscript-comment">/*
				 * we found an existing cluster(s) that we
				 * could entirely merge this I/O into
				 */</span>
			        <span class="enscript-keyword">goto</span> <span class="enscript-reference">delay_io</span>;

			<span class="enscript-keyword">if</span> (!((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(vp-&gt;v_mount) &amp; MNT_DEFWRITE) &amp;&amp;
			    wbp-&gt;cl_number == MAX_CLUSTERS &amp;&amp;
			    wbp-&gt;cl_seq_written &gt;= (MAX_CLUSTERS * (max_cluster_pgcount * PAGE_SIZE))) {
				uint32_t	n;

				<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_SSD)
					n = WRITE_BEHIND_SSD;
				<span class="enscript-keyword">else</span>
					n = WRITE_BEHIND;

				<span class="enscript-keyword">while</span> (n--)
					cluster_try_push(wbp, vp, newEOF, 0, 0, callback, callback_arg);
			}
			<span class="enscript-keyword">if</span> (wbp-&gt;cl_number &lt; MAX_CLUSTERS) {
			        <span class="enscript-comment">/*
				 * we didn't find an existing cluster to
				 * merge into, but there's room to start
				 * a new one
				 */</span>
			        <span class="enscript-keyword">goto</span> <span class="enscript-reference">start_new_cluster</span>;
			}
			<span class="enscript-comment">/*
			 * no exisitng cluster to merge with and no
			 * room to start a new one... we'll try 
			 * pushing one of the existing ones... if none of
			 * them are able to be pushed, we'll switch
			 * to the sparse cluster mechanism
			 * cluster_try_push updates cl_number to the
			 * number of remaining clusters... and
			 * returns the number of currently unused clusters
			 */</span>
			ret_cluster_try_push = 0;

			<span class="enscript-comment">/*
			 * if writes are not deferred, call cluster push immediately
			 */</span>
			<span class="enscript-keyword">if</span> (!((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(vp-&gt;v_mount) &amp; MNT_DEFWRITE)) {
				
				ret_cluster_try_push = cluster_try_push(wbp, vp, newEOF, (flags &amp; IO_NOCACHE) ? 0 : PUSH_DELAY, 0, callback, callback_arg);
			}

			<span class="enscript-comment">/*
			 * execute following regardless of writes being deferred or not
			 */</span>
			<span class="enscript-keyword">if</span> (ret_cluster_try_push == 0) {
			        <span class="enscript-comment">/*
				 * no more room in the normal cluster mechanism
				 * so let's switch to the more expansive but expensive
				 * sparse mechanism....
				 */</span>
			        sparse_cluster_switch(wbp, vp, newEOF, callback, callback_arg);
				sparse_cluster_add(&amp;(wbp-&gt;cl_scmap), vp, &amp;cl, newEOF, callback, callback_arg);

				lck_mtx_unlock(&amp;wbp-&gt;cl_lockw);

				<span class="enscript-keyword">continue</span>;
			}
<span class="enscript-reference">start_new_cluster</span>:
			wbp-&gt;cl_clusters[wbp-&gt;cl_number].b_addr = cl.b_addr;
			wbp-&gt;cl_clusters[wbp-&gt;cl_number].e_addr = cl.e_addr;

			wbp-&gt;cl_clusters[wbp-&gt;cl_number].io_flags = 0;

			<span class="enscript-keyword">if</span> (flags &amp; IO_NOCACHE)
			        wbp-&gt;cl_clusters[wbp-&gt;cl_number].io_flags |= CLW_IONOCACHE;

			<span class="enscript-keyword">if</span> (bflag &amp; CL_PASSIVE)
			        wbp-&gt;cl_clusters[wbp-&gt;cl_number].io_flags |= CLW_IOPASSIVE;

			wbp-&gt;cl_number++;
<span class="enscript-reference">delay_io</span>:
			lck_mtx_unlock(&amp;wbp-&gt;cl_lockw);

			<span class="enscript-keyword">continue</span>;
<span class="enscript-reference">issue_io</span>:
			<span class="enscript-comment">/*
			 * we don't hold the lock at this point
			 *
			 * we've already dropped the current upl, so pick it back up with COPYOUT_FROM set
			 * so that we correctly deal with a change in state of the hardware modify bit...
			 * we do this via cluster_push_now... by passing along the IO_SYNC flag, we force
			 * cluster_push_now to wait until all the I/Os have completed... cluster_push_now is also
			 * responsible for generating the correct sized I/O(s)
			 */</span>
			retval = cluster_push_now(vp, &amp;cl, newEOF, flags, callback, callback_arg);
		}
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 40)) | DBG_FUNC_END, retval, 0, io_resid, 0, 0);

	<span class="enscript-keyword">return</span> (retval);
}



<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_read</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, off_t filesize, <span class="enscript-type">int</span> xflags)
{
        <span class="enscript-keyword">return</span> cluster_read_ext(vp, uio, filesize, xflags, NULL, NULL);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_read_ext</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, off_t filesize, <span class="enscript-type">int</span> xflags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
	<span class="enscript-type">int</span>		retval = 0;
	<span class="enscript-type">int</span>		flags;
	user_ssize_t	cur_resid;
        u_int32_t	io_size;
	u_int32_t	read_length = 0;
	<span class="enscript-type">int</span>		read_type = IO_COPY;

	flags = xflags;

	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VNOCACHE_DATA)
	        flags |= IO_NOCACHE;
	<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VRAOFF) || speculative_reads_disabled)
	        flags |= IO_RAOFF;

	<span class="enscript-keyword">if</span> (flags &amp; IO_SKIP_ENCRYPTION)
		flags |= IO_ENCRYPTED;
	<span class="enscript-comment">/* 
	 * If we're doing an encrypted IO, then first check to see
	 * if the IO requested was page aligned.  If not, then bail 
	 * out immediately.
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; IO_ENCRYPTED) {		
		<span class="enscript-keyword">if</span> (read_length &amp; PAGE_MASK) {
			retval = EINVAL;
			<span class="enscript-keyword">return</span> retval;
		}
	}

	<span class="enscript-comment">/*
	 * do a read through the cache if one of the following is true....
	 *   NOCACHE is not true
	 *   the uio request doesn't target USERSPACE
	 * Alternatively, if IO_ENCRYPTED is set, then we want to bypass the cache as well.
	 * Reading encrypted data from a CP filesystem should never result in the data touching
	 * the UBC.
	 *
	 * otherwise, find out if we want the direct or contig variant for
	 * the first vector in the uio request
	 */</span>
	<span class="enscript-keyword">if</span> ( ((flags &amp; IO_NOCACHE) &amp;&amp; UIO_SEG_IS_USER_SPACE(uio-&gt;uio_segflg)) || (flags &amp; IO_ENCRYPTED) ) {

		retval = cluster_io_type(uio, &amp;read_type, &amp;read_length, 0);
	}
	
	<span class="enscript-keyword">while</span> ((cur_resid = uio_resid(uio)) &amp;&amp; uio-&gt;uio_offset &lt; filesize &amp;&amp; retval == 0) {

		<span class="enscript-keyword">switch</span> (read_type) {
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IO_COPY</span>:
		        <span class="enscript-comment">/*
			 * make sure the uio_resid isn't too big...
			 * internally, we want to handle all of the I/O in
			 * chunk sizes that fit in a 32 bit int
			 */</span>
		        <span class="enscript-keyword">if</span> (cur_resid &gt; (user_ssize_t)(MAX_IO_REQUEST_SIZE))
		                io_size = MAX_IO_REQUEST_SIZE;
			<span class="enscript-keyword">else</span>
		                io_size = (u_int32_t)cur_resid;

			retval = cluster_read_copy(vp, uio, io_size, filesize, flags, callback, callback_arg);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IO_DIRECT</span>:
		        retval = cluster_read_direct(vp, uio, filesize, &amp;read_type, &amp;read_length, flags, callback, callback_arg);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IO_CONTIG</span>:
		        retval = cluster_read_contig(vp, uio, filesize, &amp;read_type, &amp;read_length, callback, callback_arg, flags);
			<span class="enscript-keyword">break</span>;
		  
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IO_UNKNOWN</span>:
		        retval = cluster_io_type(uio, &amp;read_type, &amp;read_length, 0);
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> (retval);
}



<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cluster_read_upl_release</span>(upl_t upl, <span class="enscript-type">int</span> start_pg, <span class="enscript-type">int</span> last_pg, <span class="enscript-type">int</span> take_reference)
{
	<span class="enscript-type">int</span> range;
	<span class="enscript-type">int</span> abort_flags = UPL_ABORT_FREE_ON_EMPTY;

	<span class="enscript-keyword">if</span> ((range = last_pg - start_pg)) {
		<span class="enscript-keyword">if</span> (take_reference)
			abort_flags |= UPL_ABORT_REFERENCE;

		ubc_upl_abort_range(upl, start_pg * PAGE_SIZE, range * PAGE_SIZE, abort_flags);
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_read_copy</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, u_int32_t io_req_size, off_t filesize, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
	upl_page_info_t *pl;
	upl_t            upl;
	vm_offset_t      upl_offset;
	u_int32_t	 upl_size;
	off_t 	         upl_f_offset;
	<span class="enscript-type">int</span>		 start_offset;
	<span class="enscript-type">int</span>	         start_pg;
	<span class="enscript-type">int</span>		 last_pg;
	<span class="enscript-type">int</span>              uio_last = 0;
	<span class="enscript-type">int</span>              pages_in_upl;
	off_t            max_size;
	off_t            last_ioread_offset;
	off_t            last_request_offset;
	kern_return_t    kret;
	<span class="enscript-type">int</span>              error  = 0;
	<span class="enscript-type">int</span>              retval = 0;
	u_int32_t        size_of_prefetch;
	u_int32_t        xsize;
	u_int32_t        io_size;
	u_int32_t        max_rd_size;
	u_int32_t        max_io_size;
	u_int32_t        max_prefetch;
	u_int            rd_ahead_enabled = 1;
	u_int            prefetch_enabled = 1;
	<span class="enscript-type">struct</span> cl_readahead *	rap;
	<span class="enscript-type">struct</span> clios		iostate;
	<span class="enscript-type">struct</span> cl_extent	extent;
	<span class="enscript-type">int</span>              bflag;
	<span class="enscript-type">int</span>		 take_reference = 1;
	<span class="enscript-type">int</span>		 policy = IOPOL_DEFAULT;
	boolean_t	 iolock_inited = FALSE;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 32)) | DBG_FUNC_START,
		     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, io_req_size, (<span class="enscript-type">int</span>)filesize, flags, 0);
	
	<span class="enscript-keyword">if</span> (flags &amp; IO_ENCRYPTED) {
		panic (<span class="enscript-string">&quot;encrypted blocks will hit UBC!&quot;</span>);
	}
			 
	policy = throttle_get_io_policy(NULL);

	<span class="enscript-keyword">if</span> (policy == THROTTLE_LEVEL_TIER3 || policy == THROTTLE_LEVEL_TIER2 || (flags &amp; IO_NOCACHE))
		take_reference = 0;

	<span class="enscript-keyword">if</span> (flags &amp; IO_PASSIVE)
		bflag = CL_PASSIVE;
	<span class="enscript-keyword">else</span>
		bflag = 0;

	<span class="enscript-keyword">if</span> (flags &amp; IO_NOCACHE)
		bflag |= CL_NOCACHE;

	<span class="enscript-keyword">if</span> (flags &amp; IO_SKIP_ENCRYPTION)
		bflag |= CL_ENCRYPTED;

	max_io_size = cluster_max_io_size(vp-&gt;v_mount, CL_READ);
	max_prefetch = MAX_PREFETCH(vp, max_io_size, (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_SSD));
	max_rd_size = max_prefetch;

	last_request_offset = uio-&gt;uio_offset + io_req_size;

	<span class="enscript-keyword">if</span> (last_request_offset &gt; filesize)
	        last_request_offset = filesize;

	<span class="enscript-keyword">if</span> ((flags &amp; (IO_RAOFF|IO_NOCACHE)) || ((last_request_offset &amp; ~PAGE_MASK_64) == (uio-&gt;uio_offset &amp; ~PAGE_MASK_64))) {
	        rd_ahead_enabled = 0;
		rap = NULL;
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-keyword">if</span> (cluster_is_throttled(vp)) {
			<span class="enscript-comment">/*
			 * we're in the throttle window, at the very least
			 * we want to limit the size of the I/O we're about
			 * to issue
			 */</span>
		        rd_ahead_enabled = 0;
			prefetch_enabled = 0;

			max_rd_size = THROTTLE_MAX_IOSIZE;
		}
	        <span class="enscript-keyword">if</span> ((rap = cluster_get_rap(vp)) == NULL)
		        rd_ahead_enabled = 0;
		<span class="enscript-keyword">else</span> {
			extent.b_addr = uio-&gt;uio_offset / PAGE_SIZE_64;
			extent.e_addr = (last_request_offset - 1) / PAGE_SIZE_64;
		}
	}
	<span class="enscript-keyword">if</span> (rap != NULL &amp;&amp; rap-&gt;cl_ralen &amp;&amp; (rap-&gt;cl_lastr == extent.b_addr || (rap-&gt;cl_lastr + 1) == extent.b_addr)) {
	        <span class="enscript-comment">/*
		 * determine if we already have a read-ahead in the pipe courtesy of the
		 * last read systemcall that was issued...
		 * if so, pick up it's extent to determine where we should start
		 * with respect to any read-ahead that might be necessary to 
		 * garner all the data needed to complete this read systemcall
		 */</span>
	        last_ioread_offset = (rap-&gt;cl_maxra * PAGE_SIZE_64) + PAGE_SIZE_64;

		<span class="enscript-keyword">if</span> (last_ioread_offset &lt; uio-&gt;uio_offset)
		        last_ioread_offset = (off_t)0;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (last_ioread_offset &gt; last_request_offset)
		        last_ioread_offset = last_request_offset;
	} <span class="enscript-keyword">else</span>
	        last_ioread_offset = (off_t)0;

	<span class="enscript-keyword">while</span> (io_req_size &amp;&amp; uio-&gt;uio_offset &lt; filesize &amp;&amp; retval == 0) {

		max_size = filesize - uio-&gt;uio_offset;

		<span class="enscript-keyword">if</span> ((off_t)(io_req_size) &lt; max_size)
		        io_size = io_req_size;
		<span class="enscript-keyword">else</span>
		        io_size = max_size;

		<span class="enscript-keyword">if</span> (!(flags &amp; IO_NOCACHE)) {

		        <span class="enscript-keyword">while</span> (io_size) {
			        u_int32_t io_resid;
				u_int32_t io_requested;

				<span class="enscript-comment">/*
				 * if we keep finding the pages we need already in the cache, then
				 * don't bother to call cluster_read_prefetch since it costs CPU cycles
				 * to determine that we have all the pages we need... once we miss in
				 * the cache and have issued an I/O, than we'll assume that we're likely
				 * to continue to miss in the cache and it's to our advantage to try and prefetch
				 */</span>
				<span class="enscript-keyword">if</span> (last_request_offset &amp;&amp; last_ioread_offset &amp;&amp; (size_of_prefetch = (last_request_offset - last_ioread_offset))) {
				        <span class="enscript-keyword">if</span> ((last_ioread_offset - uio-&gt;uio_offset) &lt;= max_rd_size &amp;&amp; prefetch_enabled) {
					        <span class="enscript-comment">/*
						 * we've already issued I/O for this request and
						 * there's still work to do and
						 * our prefetch stream is running dry, so issue a
						 * pre-fetch I/O... the I/O latency will overlap
						 * with the copying of the data
						 */</span>
					        <span class="enscript-keyword">if</span> (size_of_prefetch &gt; max_rd_size)
						        size_of_prefetch = max_rd_size;

					        size_of_prefetch = cluster_read_prefetch(vp, last_ioread_offset, size_of_prefetch, filesize, callback, callback_arg, bflag);

						last_ioread_offset += (off_t)(size_of_prefetch * PAGE_SIZE);
				
						<span class="enscript-keyword">if</span> (last_ioread_offset &gt; last_request_offset)
						        last_ioread_offset = last_request_offset;
					}
				}
				<span class="enscript-comment">/*
				 * limit the size of the copy we're about to do so that 
				 * we can notice that our I/O pipe is running dry and 
				 * get the next I/O issued before it does go dry
				 */</span>
				<span class="enscript-keyword">if</span> (last_ioread_offset &amp;&amp; io_size &gt; (max_io_size / 4))
				        io_resid = (max_io_size / 4);
				<span class="enscript-keyword">else</span>
				        io_resid = io_size;

				io_requested = io_resid;

			        retval = cluster_copy_ubc_data_internal(vp, uio, (<span class="enscript-type">int</span> *)&amp;io_resid, 0, take_reference);

				xsize = io_requested - io_resid;

				io_size -= xsize;
				io_req_size -= xsize;

				<span class="enscript-keyword">if</span> (retval || io_resid)
				        <span class="enscript-comment">/*
					 * if we run into a real error or
					 * a page that is not in the cache
					 * we need to leave streaming mode
					 */</span>
				        <span class="enscript-keyword">break</span>;
				
				<span class="enscript-keyword">if</span> (rd_ahead_enabled &amp;&amp; (io_size == 0 || last_ioread_offset == last_request_offset)) {
				        <span class="enscript-comment">/*
					 * we're already finished the I/O for this read request
					 * let's see if we should do a read-ahead
					 */</span>
				        cluster_read_ahead(vp, &amp;extent, filesize, rap, callback, callback_arg, bflag);
				}
			}
			<span class="enscript-keyword">if</span> (retval)
			        <span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (io_size == 0) {
				<span class="enscript-keyword">if</span> (rap != NULL) {
				        <span class="enscript-keyword">if</span> (extent.e_addr &lt; rap-&gt;cl_lastr)
					        rap-&gt;cl_maxra = 0;
					rap-&gt;cl_lastr = extent.e_addr;
				}
			        <span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*
			 * recompute max_size since cluster_copy_ubc_data_internal
			 * may have advanced uio-&gt;uio_offset
			 */</span>
			max_size = filesize - uio-&gt;uio_offset;
		}

		iostate.io_completed = 0;
		iostate.io_issued = 0;
		iostate.io_error = 0;
		iostate.io_wanted = 0;

		<span class="enscript-keyword">if</span> ( (flags &amp; IO_RETURN_ON_THROTTLE) ) {
			<span class="enscript-keyword">if</span> (cluster_is_throttled(vp) == THROTTLE_NOW) {
				<span class="enscript-keyword">if</span> ( !cluster_io_present_in_BC(vp, uio-&gt;uio_offset)) {
					<span class="enscript-comment">/*
					 * we're in the throttle window and at least 1 I/O
					 * has already been issued by a throttleable thread
					 * in this window, so return with EAGAIN to indicate
					 * to the FS issuing the cluster_read call that it
					 * should now throttle after dropping any locks
					 */</span>
					throttle_info_update_by_mount(vp-&gt;v_mount);

					retval = EAGAIN;
					<span class="enscript-keyword">break</span>;
				}
			}
		}

		<span class="enscript-comment">/*
		 * compute the size of the upl needed to encompass
		 * the requested read... limit each call to cluster_io
		 * to the maximum UPL size... cluster_io will clip if
		 * this exceeds the maximum io_size for the device,
		 * make sure to account for 
		 * a starting offset that's not page aligned
		 */</span>
		start_offset = (<span class="enscript-type">int</span>)(uio-&gt;uio_offset &amp; PAGE_MASK_64);
		upl_f_offset = uio-&gt;uio_offset - (off_t)start_offset;

	        <span class="enscript-keyword">if</span> (io_size &gt; max_rd_size)
		        io_size = max_rd_size;

		upl_size = (start_offset + io_size + (PAGE_SIZE - 1)) &amp; ~PAGE_MASK;

		<span class="enscript-keyword">if</span> (flags &amp; IO_NOCACHE) {
		        <span class="enscript-keyword">if</span> (upl_size &gt; max_io_size)
			        upl_size = max_io_size;
		} <span class="enscript-keyword">else</span> {
		        <span class="enscript-keyword">if</span> (upl_size &gt; max_io_size / 4) {
			        upl_size = max_io_size / 4;
				upl_size &amp;= ~PAGE_MASK;
				
				<span class="enscript-keyword">if</span> (upl_size == 0)
					upl_size = PAGE_SIZE;
			}
		}
		pages_in_upl = upl_size / PAGE_SIZE;

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 33)) | DBG_FUNC_START,
			     upl, (<span class="enscript-type">int</span>)upl_f_offset, upl_size, start_offset, 0);

		kret = ubc_create_upl(vp, 
				      upl_f_offset,
				      upl_size,
				      &amp;upl,
				      &amp;pl,
				      UPL_FILE_IO | UPL_SET_LITE);
		<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
			panic(<span class="enscript-string">&quot;cluster_read_copy: failed to get pagelist&quot;</span>);

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 33)) | DBG_FUNC_END,
			     upl, (<span class="enscript-type">int</span>)upl_f_offset, upl_size, start_offset, 0);

		<span class="enscript-comment">/*
		 * scan from the beginning of the upl looking for the first
		 * non-valid page.... this will become the first page in
		 * the request we're going to make to 'cluster_io'... if all
		 * of the pages are valid, we won't call through to 'cluster_io'
		 */</span>
		<span class="enscript-keyword">for</span> (start_pg = 0; start_pg &lt; pages_in_upl; start_pg++) {
			<span class="enscript-keyword">if</span> (!upl_valid_page(pl, start_pg))
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * scan from the starting invalid page looking for a valid
		 * page before the end of the upl is reached, if we 
		 * find one, then it will be the last page of the request to
		 * 'cluster_io'
		 */</span>
		<span class="enscript-keyword">for</span> (last_pg = start_pg; last_pg &lt; pages_in_upl; last_pg++) {
			<span class="enscript-keyword">if</span> (upl_valid_page(pl, last_pg))
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (start_pg &lt; last_pg) {		
		        <span class="enscript-comment">/*
			 * we found a range of 'invalid' pages that must be filled
			 * if the last page in this range is the last page of the file
			 * we may have to clip the size of it to keep from reading past
			 * the end of the last physical block associated with the file
			 */</span>
			<span class="enscript-keyword">if</span> (iolock_inited == FALSE) {
				lck_mtx_init(&amp;iostate.io_mtxp, cl_mtx_grp, cl_mtx_attr);

				iolock_inited = TRUE;
			}
			upl_offset = start_pg * PAGE_SIZE;
			io_size    = (last_pg - start_pg) * PAGE_SIZE;

			<span class="enscript-keyword">if</span> ((off_t)(upl_f_offset + upl_offset + io_size) &gt; filesize)
			        io_size = filesize - (upl_f_offset + upl_offset);

			<span class="enscript-comment">/*
			 * issue an asynchronous read to cluster_io
			 */</span>

			error = cluster_io(vp, upl, upl_offset, upl_f_offset + upl_offset,
					   io_size, CL_READ | CL_ASYNC | bflag, (buf_t)NULL, &amp;iostate, callback, callback_arg);

			<span class="enscript-keyword">if</span> (rap) {
                                <span class="enscript-keyword">if</span> (extent.e_addr &lt; rap-&gt;cl_maxra) {
                                       <span class="enscript-comment">/*
                                        * we've just issued a read for a block that should have been
                                        * in the cache courtesy of the read-ahead engine... something
                                        * has gone wrong with the pipeline, so reset the read-ahead
                                        * logic which will cause us to restart from scratch
                                        */</span>
                                        rap-&gt;cl_maxra = 0;
                               }
                        }
		}
		<span class="enscript-keyword">if</span> (error == 0) {
		        <span class="enscript-comment">/*
			 * if the read completed successfully, or there was no I/O request
			 * issued, than copy the data into user land via 'cluster_upl_copy_data'
			 * we'll first add on any 'valid'
			 * pages that were present in the upl when we acquired it.
			 */</span>
			u_int  val_size;

		        <span class="enscript-keyword">for</span> (uio_last = last_pg; uio_last &lt; pages_in_upl; uio_last++) {
			        <span class="enscript-keyword">if</span> (!upl_valid_page(pl, uio_last))
				        <span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (uio_last &lt; pages_in_upl) {
			        <span class="enscript-comment">/*
				 * there were some invalid pages beyond the valid pages
				 * that we didn't issue an I/O for, just release them
				 * unchanged now, so that any prefetch/readahed can
				 * include them
				 */</span>
			        ubc_upl_abort_range(upl, uio_last * PAGE_SIZE,
						    (pages_in_upl - uio_last) * PAGE_SIZE, UPL_ABORT_FREE_ON_EMPTY);
			}

			<span class="enscript-comment">/*
			 * compute size to transfer this round,  if io_req_size is
			 * still non-zero after this attempt, we'll loop around and
			 * set up for another I/O.
			 */</span>
			val_size = (uio_last * PAGE_SIZE) - start_offset;
		
			<span class="enscript-keyword">if</span> (val_size &gt; max_size)
			        val_size = max_size;

			<span class="enscript-keyword">if</span> (val_size &gt; io_req_size)
			        val_size = io_req_size;

			<span class="enscript-keyword">if</span> ((uio-&gt;uio_offset + val_size) &gt; last_ioread_offset)
			        last_ioread_offset = uio-&gt;uio_offset + val_size;

			<span class="enscript-keyword">if</span> ((size_of_prefetch = (last_request_offset - last_ioread_offset)) &amp;&amp; prefetch_enabled) {

			        <span class="enscript-keyword">if</span> ((last_ioread_offset - (uio-&gt;uio_offset + val_size)) &lt;= upl_size) {
				        <span class="enscript-comment">/*
					 * if there's still I/O left to do for this request, and...
					 * we're not in hard throttle mode, and...
					 * we're close to using up the previous prefetch, then issue a
					 * new pre-fetch I/O... the I/O latency will overlap
					 * with the copying of the data
					 */</span>
				        <span class="enscript-keyword">if</span> (size_of_prefetch &gt; max_rd_size)
					        size_of_prefetch = max_rd_size;

					size_of_prefetch = cluster_read_prefetch(vp, last_ioread_offset, size_of_prefetch, filesize, callback, callback_arg, bflag);

					last_ioread_offset += (off_t)(size_of_prefetch * PAGE_SIZE);
				
					<span class="enscript-keyword">if</span> (last_ioread_offset &gt; last_request_offset)
					        last_ioread_offset = last_request_offset;
				}

			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((uio-&gt;uio_offset + val_size) == last_request_offset) {
			        <span class="enscript-comment">/*
				 * this transfer will finish this request, so...
				 * let's try to read ahead if we're in 
				 * a sequential access pattern and we haven't
				 * explicitly disabled it
				 */</span>
			        <span class="enscript-keyword">if</span> (rd_ahead_enabled)
					cluster_read_ahead(vp, &amp;extent, filesize, rap, callback, callback_arg, bflag);
					
				<span class="enscript-keyword">if</span> (rap != NULL) {
				        <span class="enscript-keyword">if</span> (extent.e_addr &lt; rap-&gt;cl_lastr)
					        rap-&gt;cl_maxra = 0;
					rap-&gt;cl_lastr = extent.e_addr;
				}
			}
			<span class="enscript-keyword">if</span> (iolock_inited == TRUE)
				cluster_iostate_wait(&amp;iostate, 0, <span class="enscript-string">&quot;cluster_read_copy&quot;</span>);

			<span class="enscript-keyword">if</span> (iostate.io_error)
			        error = iostate.io_error;
			<span class="enscript-keyword">else</span> {
			        u_int32_t io_requested;

			        io_requested = val_size;

			        retval = cluster_copy_upl_data(uio, upl, start_offset, (<span class="enscript-type">int</span> *)&amp;io_requested);
				
				io_req_size -= (val_size - io_requested);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (iolock_inited == TRUE)
				cluster_iostate_wait(&amp;iostate, 0, <span class="enscript-string">&quot;cluster_read_copy&quot;</span>);
		}
		<span class="enscript-keyword">if</span> (start_pg &lt; last_pg) {
		        <span class="enscript-comment">/*
			 * compute the range of pages that we actually issued an I/O for
			 * and either commit them as valid if the I/O succeeded
			 * or abort them if the I/O failed or we're not supposed to 
			 * keep them in the cache
			 */</span>
		        io_size = (last_pg - start_pg) * PAGE_SIZE;

			KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 35)) | DBG_FUNC_START, upl, start_pg * PAGE_SIZE, io_size, error, 0);

			<span class="enscript-keyword">if</span> (error || (flags &amp; IO_NOCACHE))
			        ubc_upl_abort_range(upl, start_pg * PAGE_SIZE, io_size,
						    UPL_ABORT_DUMP_PAGES | UPL_ABORT_FREE_ON_EMPTY);
			<span class="enscript-keyword">else</span> {
				<span class="enscript-type">int</span>	commit_flags = UPL_COMMIT_CLEAR_DIRTY | UPL_COMMIT_FREE_ON_EMPTY;

				<span class="enscript-keyword">if</span> (take_reference)
					commit_flags |= UPL_COMMIT_INACTIVATE;
				<span class="enscript-keyword">else</span>
					commit_flags |= UPL_COMMIT_SPECULATE;

			        ubc_upl_commit_range(upl, start_pg * PAGE_SIZE, io_size, commit_flags);
			}
			KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 35)) | DBG_FUNC_END, upl, start_pg * PAGE_SIZE, io_size, error, 0);
		}
		<span class="enscript-keyword">if</span> ((last_pg - start_pg) &lt; pages_in_upl) {
		        <span class="enscript-comment">/*
			 * the set of pages that we issued an I/O for did not encompass
			 * the entire upl... so just release these without modifying
			 * their state
			 */</span>
			<span class="enscript-keyword">if</span> (error)
				ubc_upl_abort_range(upl, 0, upl_size, UPL_ABORT_FREE_ON_EMPTY);
			<span class="enscript-keyword">else</span> {

				KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 35)) | DBG_FUNC_START,
					     upl, -1, pages_in_upl - (last_pg - start_pg), 0, 0);

				<span class="enscript-comment">/*
				 * handle any valid pages at the beginning of
				 * the upl... release these appropriately
				 */</span>
				cluster_read_upl_release(upl, 0, start_pg, take_reference);

				<span class="enscript-comment">/*
				 * handle any valid pages immediately after the
				 * pages we issued I/O for... ... release these appropriately
				 */</span>
				cluster_read_upl_release(upl, last_pg, uio_last, take_reference);

				KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 35)) | DBG_FUNC_END, upl, -1, -1, 0, 0);
			}
		}
		<span class="enscript-keyword">if</span> (retval == 0)
		        retval = error;

		<span class="enscript-keyword">if</span> (io_req_size) {
		        <span class="enscript-keyword">if</span> (cluster_is_throttled(vp)) {
				<span class="enscript-comment">/*
				 * we're in the throttle window, at the very least
				 * we want to limit the size of the I/O we're about
				 * to issue
				 */</span>
			        rd_ahead_enabled = 0;
				prefetch_enabled = 0;
				max_rd_size = THROTTLE_MAX_IOSIZE;
			} <span class="enscript-keyword">else</span> {
			        <span class="enscript-keyword">if</span> (max_rd_size == THROTTLE_MAX_IOSIZE) {
				        <span class="enscript-comment">/*
					 * coming out of throttled state
					 */</span>
					<span class="enscript-keyword">if</span> (policy != THROTTLE_LEVEL_TIER3 &amp;&amp; policy != THROTTLE_LEVEL_TIER2) {
						<span class="enscript-keyword">if</span> (rap != NULL)
							rd_ahead_enabled = 1;
						prefetch_enabled = 1;
					}
					max_rd_size = max_prefetch;
					last_ioread_offset = 0;
				}
			}
		}
	}
	<span class="enscript-keyword">if</span> (iolock_inited == TRUE) {
		<span class="enscript-comment">/*
		 * cluster_io returned an error after it
		 * had already issued some I/O.  we need
		 * to wait for that I/O to complete before
		 * we can destroy the iostate mutex...
		 * 'retval' already contains the early error
		 * so no need to pick it up from iostate.io_error
		 */</span>
		cluster_iostate_wait(&amp;iostate, 0, <span class="enscript-string">&quot;cluster_read_copy&quot;</span>);

		lck_mtx_destroy(&amp;iostate.io_mtxp, cl_mtx_grp);
	}
	<span class="enscript-keyword">if</span> (rap != NULL) {
	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 32)) | DBG_FUNC_END,
			     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, io_req_size, rap-&gt;cl_lastr, retval, 0);

	        lck_mtx_unlock(&amp;rap-&gt;cl_lockr);
	} <span class="enscript-keyword">else</span> {
	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 32)) | DBG_FUNC_END,
			     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, io_req_size, 0, retval, 0);
	}

	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-comment">/*
 * We don't want another read/write lock for every vnode in the system
 * so we keep a hash of them here.  There should never be very many of
 * these around at any point in time.
 */</span>
cl_direct_read_lock_t *<span class="enscript-function-name">cluster_lock_direct_read</span>(vnode_t vp, lck_rw_type_t type)
{
	<span class="enscript-type">struct</span> cl_direct_read_locks *head
		= &amp;cl_direct_read_locks[(uintptr_t)vp / <span class="enscript-keyword">sizeof</span>(*vp)
								% CL_DIRECT_READ_LOCK_BUCKETS];

	<span class="enscript-type">struct</span> cl_direct_read_lock *lck, *new_lck = NULL;

	<span class="enscript-keyword">for</span> (;;) {
		lck_spin_lock(&amp;cl_direct_read_spin_lock);

		LIST_FOREACH(lck, head, chain) {
			<span class="enscript-keyword">if</span> (lck-&gt;vp == vp) {
				++lck-&gt;ref_count;
				lck_spin_unlock(&amp;cl_direct_read_spin_lock);
				<span class="enscript-keyword">if</span> (new_lck) {
					<span class="enscript-comment">// Someone beat us to it, ditch the allocation
</span>					lck_rw_destroy(&amp;new_lck-&gt;rw_lock, cl_mtx_grp);
					FREE(new_lck, M_TEMP);
				}
				lck_rw_lock(&amp;lck-&gt;rw_lock, type);
				<span class="enscript-keyword">return</span> lck;
			}
		}

		<span class="enscript-keyword">if</span> (new_lck) {
			<span class="enscript-comment">// Use the lock we allocated
</span>			LIST_INSERT_HEAD(head, new_lck, chain);
			lck_spin_unlock(&amp;cl_direct_read_spin_lock);
			lck_rw_lock(&amp;new_lck-&gt;rw_lock, type);
			<span class="enscript-keyword">return</span> new_lck;
		}

		lck_spin_unlock(&amp;cl_direct_read_spin_lock);

		<span class="enscript-comment">// Allocate a new lock
</span>		MALLOC(new_lck, cl_direct_read_lock_t *, <span class="enscript-keyword">sizeof</span>(*new_lck),
			   M_TEMP, M_WAITOK);
		lck_rw_init(&amp;new_lck-&gt;rw_lock, cl_mtx_grp, cl_mtx_attr);
		new_lck-&gt;vp = vp;
		new_lck-&gt;ref_count = 1;

		<span class="enscript-comment">// Got to go round again
</span>	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cluster_unlock_direct_read</span>(cl_direct_read_lock_t *lck)
{
	lck_rw_done(&amp;lck-&gt;rw_lock);

	lck_spin_lock(&amp;cl_direct_read_spin_lock);
	<span class="enscript-keyword">if</span> (lck-&gt;ref_count == 1) {
		LIST_REMOVE(lck, chain);
		lck_spin_unlock(&amp;cl_direct_read_spin_lock);
		lck_rw_destroy(&amp;lck-&gt;rw_lock, cl_mtx_grp);
		FREE(lck, M_TEMP);
	} <span class="enscript-keyword">else</span> {
		--lck-&gt;ref_count;
		lck_spin_unlock(&amp;cl_direct_read_spin_lock);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_read_direct</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, off_t filesize, <span class="enscript-type">int</span> *read_type, u_int32_t *read_length,
		    <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
	upl_t            upl;
	upl_page_info_t  *pl;
        off_t		 max_io_size;
	vm_offset_t      upl_offset, vector_upl_offset = 0;
	upl_size_t	 upl_size, vector_upl_size = 0;
	vm_size_t	 upl_needed_size;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	 pages_in_pl;
	upl_control_flags_t upl_flags;
	kern_return_t    kret;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>     i;
	<span class="enscript-type">int</span>              force_data_sync;
	<span class="enscript-type">int</span>              retval = 0;
	<span class="enscript-type">int</span>		 no_zero_fill = 0;
	<span class="enscript-type">int</span>              io_flag = 0;
	<span class="enscript-type">int</span>		 misaligned = 0;
	<span class="enscript-type">struct</span> clios     iostate;
	user_addr_t	 iov_base;
	u_int32_t	 io_req_size;
	u_int32_t	 offset_in_file;
	u_int32_t	 offset_in_iovbase;
	u_int32_t	 io_size;
	u_int32_t	 io_min;
        u_int32_t	 xsize;
	u_int32_t	 devblocksize;
	u_int32_t	 mem_alignment_mask;
	u_int32_t	 max_upl_size;
	u_int32_t        max_rd_size;
	u_int32_t        max_rd_ahead;
	u_int32_t        max_vector_size;
	boolean_t	 strict_uncached_IO = FALSE;
	boolean_t	 io_throttled = FALSE;

	u_int32_t	 vector_upl_iosize = 0;
	<span class="enscript-type">int</span>		 issueVectorUPL = 0,useVectorUPL = (uio-&gt;uio_iovcnt &gt; 1);
	off_t		 v_upl_uio_offset = 0;
	<span class="enscript-type">int</span>		 vector_upl_index=0;
	upl_t		 vector_upl = NULL;
	cl_direct_read_lock_t *lock = NULL;

	user_addr_t	 orig_iov_base = 0;
	user_addr_t	 last_iov_base = 0;
	user_addr_t	 next_iov_base = 0;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 70)) | DBG_FUNC_START,
		     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, (<span class="enscript-type">int</span>)filesize, *read_type, *read_length, 0);

	max_upl_size = cluster_max_io_size(vp-&gt;v_mount, CL_READ);

	max_rd_size = max_upl_size;
	max_rd_ahead = max_rd_size * IO_SCALE(vp, 2);

	io_flag = CL_COMMIT | CL_READ | CL_ASYNC | CL_NOZERO | CL_DIRECT_IO;

	<span class="enscript-keyword">if</span> (flags &amp; IO_PASSIVE)
		io_flag |= CL_PASSIVE;

	<span class="enscript-keyword">if</span> (flags &amp; IO_ENCRYPTED) {
		io_flag |= CL_RAW_ENCRYPTED;
	}

	<span class="enscript-keyword">if</span> (flags &amp; IO_NOCACHE) {
		io_flag |= CL_NOCACHE;
	}

	<span class="enscript-keyword">if</span> (flags &amp; IO_SKIP_ENCRYPTION)
		io_flag |= CL_ENCRYPTED;

	iostate.io_completed = 0;
	iostate.io_issued = 0;
	iostate.io_error = 0;
	iostate.io_wanted = 0;

	lck_mtx_init(&amp;iostate.io_mtxp, cl_mtx_grp, cl_mtx_attr);

	devblocksize = (u_int32_t)vp-&gt;v_mount-&gt;mnt_devblocksize;
	mem_alignment_mask = (u_int32_t)vp-&gt;v_mount-&gt;mnt_alignmentmask;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 70)) | DBG_FUNC_NONE,
		     (<span class="enscript-type">int</span>)devblocksize, (<span class="enscript-type">int</span>)mem_alignment_mask, 0, 0, 0);

	<span class="enscript-keyword">if</span> (devblocksize == 1) {
               <span class="enscript-comment">/*
                * the AFP client advertises a devblocksize of 1
                * however, its BLOCKMAP routine maps to physical
                * blocks that are PAGE_SIZE in size...
                * therefore we can't ask for I/Os that aren't page aligned
                * or aren't multiples of PAGE_SIZE in size
                * by setting devblocksize to PAGE_SIZE, we re-instate
                * the old behavior we had before the mem_alignment_mask
                * changes went in...
                */</span>
               devblocksize = PAGE_SIZE;
	}

	strict_uncached_IO = ubc_strict_uncached_IO(vp);

	orig_iov_base = uio_curriovbase(uio);
	last_iov_base = orig_iov_base;

<span class="enscript-reference">next_dread</span>:
	io_req_size = *read_length;
	iov_base = uio_curriovbase(uio);

        max_io_size = filesize - uio-&gt;uio_offset;

	<span class="enscript-keyword">if</span> ((off_t)io_req_size &gt; max_io_size)
	        io_req_size = max_io_size;

	offset_in_file = (u_int32_t)uio-&gt;uio_offset &amp; (devblocksize - 1);
	offset_in_iovbase = (u_int32_t)iov_base &amp; mem_alignment_mask;

	<span class="enscript-keyword">if</span> (offset_in_file || offset_in_iovbase) {
	        <span class="enscript-comment">/*
		 * one of the 2 important offsets is misaligned
		 * so fire an I/O through the cache for this entire vector
		 */</span>
		misaligned = 1;
	}
	<span class="enscript-keyword">if</span> (iov_base &amp; (devblocksize - 1)) {
	        <span class="enscript-comment">/*
		 * the offset in memory must be on a device block boundary
		 * so that we can guarantee that we can generate an
		 * I/O that ends on a page boundary in cluster_io
		 */</span>
		misaligned = 1;
    }

	<span class="enscript-comment">/* 
	 * The user must request IO in aligned chunks.  If the 
	 * offset into the file is bad, or the userland pointer 
	 * is non-aligned, then we cannot service the encrypted IO request.
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; IO_ENCRYPTED) &amp;&amp; (misaligned)) {
		retval = EINVAL;
	}

	<span class="enscript-comment">/*
	 * When we get to this point, we know...
	 *  -- the offset into the file is on a devblocksize boundary
	 */</span>

	<span class="enscript-keyword">while</span> (io_req_size &amp;&amp; retval == 0) {
	        u_int32_t io_start;

	        <span class="enscript-keyword">if</span> (cluster_is_throttled(vp)) {
			<span class="enscript-comment">/*
			 * we're in the throttle window, at the very least
			 * we want to limit the size of the I/O we're about
			 * to issue
			 */</span>
		        max_rd_size  = THROTTLE_MAX_IOSIZE;
			max_rd_ahead = THROTTLE_MAX_IOSIZE - 1;
			max_vector_size = THROTTLE_MAX_IOSIZE;
		} <span class="enscript-keyword">else</span> {
		        max_rd_size  = max_upl_size;
			max_rd_ahead = max_rd_size * IO_SCALE(vp, 2);
			max_vector_size = MAX_VECTOR_UPL_SIZE;
		}
		io_start = io_size = io_req_size;

		<span class="enscript-comment">/*
		 * First look for pages already in the cache
		 * and move them to user space.  But only do this
		 * check if we are not retrieving encrypted data directly
		 * from the filesystem;  those blocks should never
		 * be in the UBC. 
		 *
		 * cluster_copy_ubc_data returns the resid
		 * in io_size
		 */</span>
		<span class="enscript-keyword">if</span> ((strict_uncached_IO == FALSE) &amp;&amp; ((flags &amp; IO_ENCRYPTED) == 0)) {
			retval = cluster_copy_ubc_data_internal(vp, uio, (<span class="enscript-type">int</span> *)&amp;io_size, 0, 0);
		}
		<span class="enscript-comment">/*
		 * calculate the number of bytes actually copied
		 * starting size - residual
		 */</span>
		xsize = io_start - io_size;

		io_req_size -= xsize;

		<span class="enscript-keyword">if</span>(useVectorUPL &amp;&amp; (xsize || (iov_base &amp; PAGE_MASK))) {
			<span class="enscript-comment">/*
			 * We found something in the cache or we have an iov_base that's not
			 * page-aligned.
			 * 
			 * Issue all I/O's that have been collected within this Vectored UPL.
			 */</span>
			<span class="enscript-keyword">if</span>(vector_upl_index) {
				retval = vector_cluster_io(vp, vector_upl, vector_upl_offset, v_upl_uio_offset, vector_upl_iosize, io_flag, (buf_t)NULL, &amp;iostate, callback, callback_arg);
				reset_vector_run_state();
			}
			
			<span class="enscript-keyword">if</span>(xsize)
				useVectorUPL = 0;

		       <span class="enscript-comment">/*
			* After this point, if we are using the Vector UPL path and the base is
			* not page-aligned then the UPL with that base will be the first in the vector UPL.
			*/</span>
		}

		<span class="enscript-comment">/*
		 * check to see if we are finished with this request.
		 *
		 * If we satisfied this IO already, then io_req_size will be 0.
		 * Otherwise, see if the IO was mis-aligned and needs to go through 
		 * the UBC to deal with the 'tail'.
		 *
		 */</span>
		<span class="enscript-keyword">if</span> (io_req_size == 0 || (misaligned)) {
		        <span class="enscript-comment">/*
			 * see if there's another uio vector to
			 * process that's of type IO_DIRECT
			 *
			 * break out of while loop to get there
			 */</span>
		        <span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * assume the request ends on a device block boundary
		 */</span>
		io_min = devblocksize;

		<span class="enscript-comment">/*
		 * we can handle I/O's in multiples of the device block size
		 * however, if io_size isn't a multiple of devblocksize we
		 * want to clip it back to the nearest page boundary since
		 * we are going to have to go through cluster_read_copy to
		 * deal with the 'overhang'... by clipping it to a PAGE_SIZE
		 * multiple, we avoid asking the drive for the same physical
		 * blocks twice.. once for the partial page at the end of the
		 * request and a 2nd time for the page we read into the cache
		 * (which overlaps the end of the direct read) in order to 
		 * get at the overhang bytes
		 */</span>
		<span class="enscript-keyword">if</span> (io_size &amp; (devblocksize - 1)) {			
			<span class="enscript-keyword">if</span> (flags &amp; IO_ENCRYPTED) {
				<span class="enscript-comment">/* 
				 * Normally, we'd round down to the previous page boundary to 
				 * let the UBC manage the zero-filling of the file past the EOF.
				 * But if we're doing encrypted IO, we can't let any of
				 * the data hit the UBC.  This means we have to do the full
				 * IO to the upper block boundary of the device block that
				 * contains the EOF. The user will be responsible for not
				 * interpreting data PAST the EOF in its buffer.
				 *
				 * So just bump the IO back up to a multiple of devblocksize
				 */</span>
				io_size = ((io_size + devblocksize) &amp; ~(devblocksize - 1));
				io_min = io_size;					
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* 
				 * Clip the request to the previous page size boundary
				 * since request does NOT end on a device block boundary
				 */</span>
				io_size &amp;= ~PAGE_MASK;
				io_min = PAGE_SIZE;
			}
			
		}
		<span class="enscript-keyword">if</span> (retval || io_size &lt; io_min) {
		        <span class="enscript-comment">/*
			 * either an error or we only have the tail left to
			 * complete via the copy path...
			 * we may have already spun some portion of this request
			 * off as async requests... we need to wait for the I/O
			 * to complete before returning
			 */</span>
		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dreads</span>;
		}

		<span class="enscript-comment">/*
		 * Don't re-check the UBC data if we are looking for uncached IO
		 * or asking for encrypted blocks.
		 */</span>
		<span class="enscript-keyword">if</span> ((strict_uncached_IO == FALSE) &amp;&amp; ((flags &amp; IO_ENCRYPTED) == 0)) {

			<span class="enscript-keyword">if</span> ((xsize = io_size) &gt; max_rd_size)
				xsize = max_rd_size;

			io_size = 0;

			<span class="enscript-keyword">if</span> (!lock) {
				<span class="enscript-comment">/*
				 * We hold a lock here between the time we check the
				 * cache and the time we issue I/O.  This saves us
				 * from having to lock the pages in the cache.  Not
				 * all clients will care about this lock but some
				 * clients may want to guarantee stability between
				 * here and when the I/O is issued in which case they
				 * will take the lock exclusively.
				 */</span>
				lock = cluster_lock_direct_read(vp, LCK_RW_TYPE_SHARED);
			}

			ubc_range_op(vp, uio-&gt;uio_offset, uio-&gt;uio_offset + xsize, UPL_ROP_ABSENT, (<span class="enscript-type">int</span> *)&amp;io_size);

			<span class="enscript-keyword">if</span> (io_size == 0) {
				<span class="enscript-comment">/*
				 * a page must have just come into the cache
				 * since the first page in this range is no
				 * longer absent, go back and re-evaluate
				 */</span>
				<span class="enscript-keyword">continue</span>;
			}
		}
		<span class="enscript-keyword">if</span> ( (flags &amp; IO_RETURN_ON_THROTTLE) ) {
			<span class="enscript-keyword">if</span> (cluster_is_throttled(vp) == THROTTLE_NOW) {
				<span class="enscript-keyword">if</span> ( !cluster_io_present_in_BC(vp, uio-&gt;uio_offset)) {
					<span class="enscript-comment">/*
					 * we're in the throttle window and at least 1 I/O
					 * has already been issued by a throttleable thread
					 * in this window, so return with EAGAIN to indicate
					 * to the FS issuing the cluster_read call that it
					 * should now throttle after dropping any locks
					 */</span>
					throttle_info_update_by_mount(vp-&gt;v_mount);

					io_throttled = TRUE;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dreads</span>;
				}
			}
		}
		<span class="enscript-keyword">if</span> (io_size &gt; max_rd_size)
			io_size = max_rd_size;

		iov_base = uio_curriovbase(uio);

		upl_offset = (vm_offset_t)((u_int32_t)iov_base &amp; PAGE_MASK);
		upl_needed_size = (upl_offset + io_size + (PAGE_SIZE -1)) &amp; ~PAGE_MASK;

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 72)) | DBG_FUNC_START,
			     (<span class="enscript-type">int</span>)upl_offset, upl_needed_size, (<span class="enscript-type">int</span>)iov_base, io_size, 0);

		<span class="enscript-keyword">if</span> (upl_offset == 0 &amp;&amp; ((io_size &amp; PAGE_MASK) == 0))
		        no_zero_fill = 1;
		<span class="enscript-keyword">else</span>
		        no_zero_fill = 0;

		vm_map_t map = UIO_SEG_IS_USER_SPACE(uio-&gt;uio_segflg) ? current_map() : kernel_map;
		<span class="enscript-keyword">for</span> (force_data_sync = 0; force_data_sync &lt; 3; force_data_sync++) {
		        pages_in_pl = 0;
			upl_size = upl_needed_size;
			upl_flags = UPL_FILE_IO | UPL_NO_SYNC | UPL_SET_INTERNAL | UPL_SET_LITE | UPL_SET_IO_WIRE
				  | UPL_MEMORY_TAG_MAKE(VM_KERN_MEMORY_FILE);
			<span class="enscript-keyword">if</span> (no_zero_fill)
			        upl_flags |= UPL_NOZEROFILL;
			<span class="enscript-keyword">if</span> (force_data_sync)
			        upl_flags |= UPL_FORCE_DATA_SYNC;

			kret = vm_map_create_upl(map,
						 (vm_map_offset_t)(iov_base &amp; ~((user_addr_t)PAGE_MASK)),
						 &amp;upl_size, &amp;upl, NULL, &amp;pages_in_pl, &amp;upl_flags);

			<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
			        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 72)) | DBG_FUNC_END,
					     (<span class="enscript-type">int</span>)upl_offset, upl_size, io_size, kret, 0);
				<span class="enscript-comment">/*
				 * failed to get pagelist
				 *
				 * we may have already spun some portion of this request
				 * off as async requests... we need to wait for the I/O
				 * to complete before returning
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dreads</span>;
			}
			pages_in_pl = upl_size / PAGE_SIZE;
			pl = UPL_GET_INTERNAL_PAGE_LIST(upl);

			<span class="enscript-keyword">for</span> (i = 0; i &lt; pages_in_pl; i++) {
			        <span class="enscript-keyword">if</span> (!upl_page_present(pl, i))
				        <span class="enscript-keyword">break</span>;		  
			}
			<span class="enscript-keyword">if</span> (i == pages_in_pl)
			        <span class="enscript-keyword">break</span>;

			ubc_upl_abort(upl, 0);
		}
		<span class="enscript-keyword">if</span> (force_data_sync &gt;= 3) {
		        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 72)) | DBG_FUNC_END,
				     (<span class="enscript-type">int</span>)upl_offset, upl_size, io_size, kret, 0);
		  
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dreads</span>;
		}
		<span class="enscript-comment">/*
		 * Consider the possibility that upl_size wasn't satisfied.
		 */</span>
		<span class="enscript-keyword">if</span> (upl_size &lt; upl_needed_size) {
		        <span class="enscript-keyword">if</span> (upl_size &amp;&amp; upl_offset == 0)
			        io_size = upl_size;
			<span class="enscript-keyword">else</span>
			        io_size = 0;
		}
		<span class="enscript-keyword">if</span> (io_size == 0) {
			ubc_upl_abort(upl, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dreads</span>;
		}
		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 72)) | DBG_FUNC_END,
			     (<span class="enscript-type">int</span>)upl_offset, upl_size, io_size, kret, 0);

		<span class="enscript-keyword">if</span>(useVectorUPL) {
			vm_offset_t end_off = ((iov_base + io_size) &amp; PAGE_MASK);
			<span class="enscript-keyword">if</span>(end_off) 
				issueVectorUPL = 1;
			<span class="enscript-comment">/*
			 * After this point, if we are using a vector UPL, then
			 * either all the UPL elements end on a page boundary OR
			 * this UPL is the last element because it does not end
			 * on a page boundary.
			 */</span>
		}

		<span class="enscript-comment">/*
		 * request asynchronously so that we can overlap
		 * the preparation of the next I/O
		 * if there are already too many outstanding reads
		 * wait until some have completed before issuing the next read
		 */</span>
		cluster_iostate_wait(&amp;iostate, max_rd_ahead, <span class="enscript-string">&quot;cluster_read_direct&quot;</span>);

		<span class="enscript-keyword">if</span> (iostate.io_error) {
		        <span class="enscript-comment">/*
			 * one of the earlier reads we issued ran into a hard error
			 * don't issue any more reads, cleanup the UPL
			 * that was just created but not used, then
			 * go wait for any other reads to complete before
			 * returning the error to the caller
			 */</span>
			ubc_upl_abort(upl, 0);

		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_dreads</span>;
	        }
		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 73)) | DBG_FUNC_START,
			     upl, (<span class="enscript-type">int</span>)upl_offset, (<span class="enscript-type">int</span>)uio-&gt;uio_offset, io_size, 0);

		<span class="enscript-keyword">if</span>(!useVectorUPL) {
			<span class="enscript-keyword">if</span> (no_zero_fill)
		        	io_flag &amp;= ~CL_PRESERVE;
			<span class="enscript-keyword">else</span>
		        	io_flag |= CL_PRESERVE;
		
			retval = cluster_io(vp, upl, upl_offset, uio-&gt;uio_offset, io_size, io_flag, (buf_t)NULL, &amp;iostate, callback, callback_arg);

		} <span class="enscript-keyword">else</span> {

			<span class="enscript-keyword">if</span>(!vector_upl_index) {
				vector_upl = vector_upl_create(upl_offset);
				v_upl_uio_offset = uio-&gt;uio_offset;
				vector_upl_offset = upl_offset;
			}

			vector_upl_set_subupl(vector_upl,upl, upl_size);
			vector_upl_set_iostate(vector_upl, upl, vector_upl_size, upl_size);
			vector_upl_index++;
			vector_upl_size += upl_size;
			vector_upl_iosize += io_size;
			
			<span class="enscript-keyword">if</span>(issueVectorUPL || vector_upl_index ==  MAX_VECTOR_UPL_ELEMENTS || vector_upl_size &gt;= max_vector_size) {
				retval = vector_cluster_io(vp, vector_upl, vector_upl_offset, v_upl_uio_offset, vector_upl_iosize,  io_flag, (buf_t)NULL, &amp;iostate, callback, callback_arg);
				reset_vector_run_state();	
			}
		}
		last_iov_base = iov_base + io_size;

		<span class="enscript-keyword">if</span> (lock) {
			<span class="enscript-comment">// We don't need to wait for the I/O to complete
</span>			cluster_unlock_direct_read(lock);
			lock = NULL;
		}

		<span class="enscript-comment">/*
		 * update the uio structure
		 */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; IO_ENCRYPTED) &amp;&amp; (max_io_size &lt; io_size)) {
			uio_update(uio, (user_size_t)max_io_size);
		}
		<span class="enscript-keyword">else</span> {
			uio_update(uio, (user_size_t)io_size);
		}
		<span class="enscript-comment">/*
		 * Under normal circumstances, the io_size should not be
		 * bigger than the io_req_size, but we may have had to round up
		 * to the end of the page in the encrypted IO case.  In that case only,
		 * ensure that we only decrement io_req_size to 0. 
		 */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; IO_ENCRYPTED) &amp;&amp; (io_size &gt; io_req_size)) {
			io_req_size = 0;
		}
		<span class="enscript-keyword">else</span> {
			io_req_size -= io_size;
		}

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 73)) | DBG_FUNC_END,
			     upl, (<span class="enscript-type">int</span>)uio-&gt;uio_offset, io_req_size, retval, 0);

	} <span class="enscript-comment">/* end while */</span>

	<span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; iostate.io_error == 0 &amp;&amp; io_req_size == 0 &amp;&amp; uio-&gt;uio_offset &lt; filesize) {

	        retval = cluster_io_type(uio, read_type, read_length, 0);
	  
		<span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; *read_type == IO_DIRECT) {

		        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 70)) | DBG_FUNC_NONE,
				     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, (<span class="enscript-type">int</span>)filesize, *read_type, *read_length, 0);

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next_dread</span>;
		}
	}

<span class="enscript-reference">wait_for_dreads</span>:

	<span class="enscript-keyword">if</span>(retval == 0 &amp;&amp; iostate.io_error == 0 &amp;&amp; useVectorUPL &amp;&amp; vector_upl_index) {
		retval = vector_cluster_io(vp, vector_upl, vector_upl_offset, v_upl_uio_offset, vector_upl_iosize,  io_flag, (buf_t)NULL, &amp;iostate, callback, callback_arg);
		reset_vector_run_state();
	}

	<span class="enscript-comment">// We don't need to wait for the I/O to complete
</span>	<span class="enscript-keyword">if</span> (lock)
		cluster_unlock_direct_read(lock);

	<span class="enscript-comment">/*
	 * make sure all async reads that are part of this stream
	 * have completed before we return
	 */</span>
	cluster_iostate_wait(&amp;iostate, 0, <span class="enscript-string">&quot;cluster_read_direct&quot;</span>);

	<span class="enscript-keyword">if</span> (iostate.io_error)
	        retval = iostate.io_error;

	lck_mtx_destroy(&amp;iostate.io_mtxp, cl_mtx_grp);

	<span class="enscript-keyword">if</span> (io_throttled == TRUE &amp;&amp; retval == 0)
		retval = EAGAIN;

	<span class="enscript-keyword">for</span> (next_iov_base = orig_iov_base; next_iov_base &lt; last_iov_base; next_iov_base += PAGE_SIZE) {
		<span class="enscript-comment">/*
		 * This is specifically done for pmap accounting purposes.
		 * vm_pre_fault() will call vm_fault() to enter the page into
		 * the pmap if there isn't _a_ physical page for that VA already.
		 */</span>
		vm_pre_fault(vm_map_trunc_page(next_iov_base, PAGE_MASK));
	}

	<span class="enscript-keyword">if</span> (io_req_size &amp;&amp; retval == 0) {
	        <span class="enscript-comment">/*
		 * we couldn't handle the tail of this request in DIRECT mode
		 * so fire it through the copy path
		 */</span>
	        retval = cluster_read_copy(vp, uio, io_req_size, filesize, flags, callback, callback_arg);

		*read_type = IO_UNKNOWN;
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 70)) | DBG_FUNC_END,
		     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, (<span class="enscript-type">int</span>)uio_resid(uio), io_req_size, retval, 0);

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_read_contig</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, off_t filesize, <span class="enscript-type">int</span> *read_type, u_int32_t *read_length,
		    <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg, <span class="enscript-type">int</span> flags)
{
	upl_page_info_t *pl;
	upl_t            upl[MAX_VECTS];
	vm_offset_t      upl_offset;
	addr64_t	 dst_paddr = 0;
	user_addr_t	 iov_base;
	off_t            max_size;
	upl_size_t	 upl_size;
	vm_size_t	 upl_needed_size;
	mach_msg_type_number_t	pages_in_pl;
	upl_control_flags_t upl_flags;
	kern_return_t    kret;
	<span class="enscript-type">struct</span> clios     iostate;
	<span class="enscript-type">int</span>              error= 0;
	<span class="enscript-type">int</span>		 cur_upl = 0;
	<span class="enscript-type">int</span>		 num_upl = 0;
	<span class="enscript-type">int</span>		 n;
        u_int32_t	 xsize;
	u_int32_t	 io_size;
	u_int32_t	 devblocksize;
	u_int32_t	 mem_alignment_mask;
	u_int32_t	 tail_size = 0;
	<span class="enscript-type">int</span>              bflag;

	<span class="enscript-keyword">if</span> (flags &amp; IO_PASSIVE)
		bflag = CL_PASSIVE;
	<span class="enscript-keyword">else</span>
		bflag = 0;
	
	<span class="enscript-keyword">if</span> (flags &amp; IO_NOCACHE)
		bflag |= CL_NOCACHE;
	
	<span class="enscript-comment">/*
	 * When we enter this routine, we know
	 *  -- the read_length will not exceed the current iov_len
	 *  -- the target address is physically contiguous for read_length
	 */</span>
	cluster_syncup(vp, filesize, callback, callback_arg, PUSH_SYNC);

	devblocksize = (u_int32_t)vp-&gt;v_mount-&gt;mnt_devblocksize;
	mem_alignment_mask = (u_int32_t)vp-&gt;v_mount-&gt;mnt_alignmentmask;

	iostate.io_completed = 0;
	iostate.io_issued = 0;
	iostate.io_error = 0;
	iostate.io_wanted = 0;

	lck_mtx_init(&amp;iostate.io_mtxp, cl_mtx_grp, cl_mtx_attr);

<span class="enscript-reference">next_cread</span>:
	io_size = *read_length;

	max_size = filesize - uio-&gt;uio_offset;

	<span class="enscript-keyword">if</span> (io_size &gt; max_size)
	        io_size = max_size;

	iov_base = uio_curriovbase(uio);

	upl_offset = (vm_offset_t)((u_int32_t)iov_base &amp; PAGE_MASK);
	upl_needed_size = upl_offset + io_size;

	pages_in_pl = 0;
	upl_size = upl_needed_size;
	upl_flags = UPL_FILE_IO | UPL_NO_SYNC | UPL_CLEAN_IN_PLACE | UPL_SET_INTERNAL | UPL_SET_LITE | UPL_SET_IO_WIRE
		   | UPL_MEMORY_TAG_MAKE(VM_KERN_MEMORY_FILE);


	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 92)) | DBG_FUNC_START,
		     (<span class="enscript-type">int</span>)upl_offset, (<span class="enscript-type">int</span>)upl_size, (<span class="enscript-type">int</span>)iov_base, io_size, 0);

	vm_map_t map = UIO_SEG_IS_USER_SPACE(uio-&gt;uio_segflg) ? current_map() : kernel_map;
	kret = vm_map_get_upl(map,
			      (vm_map_offset_t)(iov_base &amp; ~((user_addr_t)PAGE_MASK)),
			      &amp;upl_size, &amp;upl[cur_upl], NULL, &amp;pages_in_pl, &amp;upl_flags, 0);

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 92)) | DBG_FUNC_END,
		     (<span class="enscript-type">int</span>)upl_offset, upl_size, io_size, kret, 0);

	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
	        <span class="enscript-comment">/*
		 * failed to get pagelist
		 */</span>
	        error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_creads</span>;
	}
	num_upl++;

	<span class="enscript-keyword">if</span> (upl_size &lt; upl_needed_size) {
	        <span class="enscript-comment">/*
		 * The upl_size wasn't satisfied.
		 */</span>
	        error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_creads</span>;
	}
	pl = ubc_upl_pageinfo(upl[cur_upl]);

	dst_paddr = ((addr64_t)upl_phys_page(pl, 0) &lt;&lt; PAGE_SHIFT) + (addr64_t)upl_offset;

	<span class="enscript-keyword">while</span> (((uio-&gt;uio_offset &amp; (devblocksize - 1)) || io_size &lt; devblocksize) &amp;&amp; io_size) {
	        u_int32_t   head_size;

		head_size = devblocksize - (u_int32_t)(uio-&gt;uio_offset &amp; (devblocksize - 1));

		<span class="enscript-keyword">if</span> (head_size &gt; io_size)
		        head_size = io_size;

		error = cluster_align_phys_io(vp, uio, dst_paddr, head_size, CL_READ, callback, callback_arg);

		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_creads</span>;

		upl_offset += head_size;
		dst_paddr  += head_size;
		io_size    -= head_size;

		iov_base   += head_size;
	}
	<span class="enscript-keyword">if</span> ((u_int32_t)iov_base &amp; mem_alignment_mask) {
	        <span class="enscript-comment">/*
		 * request doesn't set up on a memory boundary
		 * the underlying DMA engine can handle...
		 * return an error instead of going through
		 * the slow copy path since the intent of this
		 * path is direct I/O to device memory
		 */</span>
	        error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_creads</span>;
	}

	tail_size = io_size &amp; (devblocksize - 1);

	io_size  -= tail_size;

	<span class="enscript-keyword">while</span> (io_size &amp;&amp; error == 0) {

		<span class="enscript-keyword">if</span> (io_size &gt; MAX_IO_CONTIG_SIZE)
		        xsize = MAX_IO_CONTIG_SIZE;
		<span class="enscript-keyword">else</span>
		        xsize = io_size;
		<span class="enscript-comment">/*
		 * request asynchronously so that we can overlap
		 * the preparation of the next I/O... we'll do
		 * the commit after all the I/O has completed
		 * since its all issued against the same UPL
		 * if there are already too many outstanding reads
		 * wait until some have completed before issuing the next
		 */</span>
		cluster_iostate_wait(&amp;iostate, MAX_IO_CONTIG_SIZE * IO_SCALE(vp, 2), <span class="enscript-string">&quot;cluster_read_contig&quot;</span>);

		<span class="enscript-keyword">if</span> (iostate.io_error) {
		        <span class="enscript-comment">/*
			 * one of the earlier reads we issued ran into a hard error
			 * don't issue any more reads...
			 * go wait for any other reads to complete before
			 * returning the error to the caller
			 */</span>
		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">wait_for_creads</span>;
		}
	        error = cluster_io(vp, upl[cur_upl], upl_offset, uio-&gt;uio_offset, xsize, 
				   CL_READ | CL_NOZERO | CL_DEV_MEMORY | CL_ASYNC | bflag,
				   (buf_t)NULL, &amp;iostate, callback, callback_arg);
	        <span class="enscript-comment">/*
		 * The cluster_io read was issued successfully,
		 * update the uio structure
		 */</span>
		<span class="enscript-keyword">if</span> (error == 0) {
		        uio_update(uio, (user_size_t)xsize);

			dst_paddr  += xsize;
			upl_offset += xsize;
			io_size    -= xsize;
		}
	}
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; iostate.io_error == 0 &amp;&amp; tail_size == 0 &amp;&amp; num_upl &lt; MAX_VECTS &amp;&amp; uio-&gt;uio_offset &lt; filesize) {

	        error = cluster_io_type(uio, read_type, read_length, 0);
	  
		<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; *read_type == IO_CONTIG) {
		        cur_upl++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next_cread</span>;
		}
	} <span class="enscript-keyword">else</span>
	        *read_type = IO_UNKNOWN;

<span class="enscript-reference">wait_for_creads</span>:
	<span class="enscript-comment">/*
	 * make sure all async reads that are part of this stream
	 * have completed before we proceed
	 */</span>
	cluster_iostate_wait(&amp;iostate, 0, <span class="enscript-string">&quot;cluster_read_contig&quot;</span>);

	<span class="enscript-keyword">if</span> (iostate.io_error)
	        error = iostate.io_error;

	lck_mtx_destroy(&amp;iostate.io_mtxp, cl_mtx_grp);

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; tail_size)
	        error = cluster_align_phys_io(vp, uio, dst_paddr, tail_size, CL_READ, callback, callback_arg);

	<span class="enscript-keyword">for</span> (n = 0; n &lt; num_upl; n++)
	        <span class="enscript-comment">/*
		 * just release our hold on each physically contiguous
		 * region without changing any state
		 */</span>
	        ubc_upl_abort(upl[n], 0);
	
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_io_type</span>(<span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> *io_type, u_int32_t *io_length, u_int32_t min_length)
{
        user_size_t	 iov_len;
  	user_addr_t	 iov_base = 0;
	upl_t            upl;
	upl_size_t       upl_size;
	upl_control_flags_t upl_flags;
	<span class="enscript-type">int</span>		 retval = 0;

        <span class="enscript-comment">/*
	 * skip over any emtpy vectors
	 */</span>
        uio_update(uio, (user_size_t)0);

	iov_len = uio_curriovlen(uio);

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 94)) | DBG_FUNC_START, uio, (<span class="enscript-type">int</span>)iov_len, 0, 0, 0);

	<span class="enscript-keyword">if</span> (iov_len) {
	        iov_base = uio_curriovbase(uio);
	        <span class="enscript-comment">/*
		 * make sure the size of the vector isn't too big...
		 * internally, we want to handle all of the I/O in
		 * chunk sizes that fit in a 32 bit int
		 */</span>
	        <span class="enscript-keyword">if</span> (iov_len &gt; (user_size_t)MAX_IO_REQUEST_SIZE)
		        upl_size = MAX_IO_REQUEST_SIZE;
		<span class="enscript-keyword">else</span>
		        upl_size = (u_int32_t)iov_len;

		upl_flags = UPL_QUERY_OBJECT_TYPE | UPL_MEMORY_TAG_MAKE(VM_KERN_MEMORY_FILE);

		vm_map_t map = UIO_SEG_IS_USER_SPACE(uio-&gt;uio_segflg) ? current_map() : kernel_map;
		<span class="enscript-keyword">if</span> ((vm_map_get_upl(map,
				    (vm_map_offset_t)(iov_base &amp; ~((user_addr_t)PAGE_MASK)),
				    &amp;upl_size, &amp;upl, NULL, NULL, &amp;upl_flags, 0)) != KERN_SUCCESS) {
		        <span class="enscript-comment">/*
			 * the user app must have passed in an invalid address
			 */</span>
		        retval = EFAULT;
		}
		<span class="enscript-keyword">if</span> (upl_size == 0)
		        retval = EFAULT;

		*io_length = upl_size;

		<span class="enscript-keyword">if</span> (upl_flags &amp; UPL_PHYS_CONTIG)
		        *io_type = IO_CONTIG;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (iov_len &gt;= min_length)
		        *io_type = IO_DIRECT;
		<span class="enscript-keyword">else</span>
		        *io_type = IO_COPY;
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-comment">/*
		 * nothing left to do for this uio
		 */</span>
	        *io_length = 0;
		*io_type   = IO_UNKNOWN;
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 94)) | DBG_FUNC_END, iov_base, *io_type, *io_length, retval, 0);

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-comment">/*
 * generate advisory I/O's in the largest chunks possible
 * the completed pages will be released into the VM cache
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">advisory_read</span>(vnode_t vp, off_t filesize, off_t f_offset, <span class="enscript-type">int</span> resid)
{
        <span class="enscript-keyword">return</span> advisory_read_ext(vp, filesize, f_offset, resid, NULL, NULL, CL_PASSIVE);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">advisory_read_ext</span>(vnode_t vp, off_t filesize, off_t f_offset, <span class="enscript-type">int</span> resid, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg, <span class="enscript-type">int</span> bflag)
{
	upl_page_info_t *pl;
	upl_t            upl;
	vm_offset_t      upl_offset;
	<span class="enscript-type">int</span>	         upl_size;
	off_t 	         upl_f_offset;
	<span class="enscript-type">int</span>		 start_offset;
	<span class="enscript-type">int</span>	         start_pg;
	<span class="enscript-type">int</span>		 last_pg;
	<span class="enscript-type">int</span>              pages_in_upl;
	off_t            max_size;
	<span class="enscript-type">int</span>              io_size;
	kern_return_t    kret;
	<span class="enscript-type">int</span>              retval = 0;
	<span class="enscript-type">int</span>              issued_io;
	<span class="enscript-type">int</span>              skip_range;
	uint32_t	 max_io_size;


	<span class="enscript-keyword">if</span> ( !UBCINFOEXISTS(vp))
		<span class="enscript-keyword">return</span>(EINVAL);

	<span class="enscript-keyword">if</span> (resid &lt; 0)
		<span class="enscript-keyword">return</span>(EINVAL);

	max_io_size = cluster_max_io_size(vp-&gt;v_mount, CL_READ);

	<span class="enscript-keyword">if</span> ((vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_SSD) &amp;&amp; !ignore_is_ssd) {
		<span class="enscript-keyword">if</span> (max_io_size &gt; speculative_prefetch_max_iosize)
			max_io_size = speculative_prefetch_max_iosize;
	}

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 60)) | DBG_FUNC_START,
		     (<span class="enscript-type">int</span>)f_offset, resid, (<span class="enscript-type">int</span>)filesize, 0, 0);

	<span class="enscript-keyword">while</span> (resid &amp;&amp; f_offset &lt; filesize &amp;&amp; retval == 0) {
		<span class="enscript-comment">/*
		 * compute the size of the upl needed to encompass
		 * the requested read... limit each call to cluster_io
		 * to the maximum UPL size... cluster_io will clip if
		 * this exceeds the maximum io_size for the device,
		 * make sure to account for 
		 * a starting offset that's not page aligned
		 */</span>
		start_offset = (<span class="enscript-type">int</span>)(f_offset &amp; PAGE_MASK_64);
		upl_f_offset = f_offset - (off_t)start_offset;
		max_size     = filesize - f_offset;

		<span class="enscript-keyword">if</span> (resid &lt; max_size)
		        io_size = resid;
		<span class="enscript-keyword">else</span>
		        io_size = max_size;

		upl_size = (start_offset + io_size + (PAGE_SIZE - 1)) &amp; ~PAGE_MASK;
	        <span class="enscript-keyword">if</span> ((uint32_t)upl_size &gt; max_io_size)
		        upl_size = max_io_size;

		skip_range = 0;
		<span class="enscript-comment">/*
		 * return the number of contiguously present pages in the cache
		 * starting at upl_f_offset within the file
		 */</span>
		ubc_range_op(vp, upl_f_offset, upl_f_offset + upl_size, UPL_ROP_PRESENT, &amp;skip_range);

		<span class="enscript-keyword">if</span> (skip_range) {
		        <span class="enscript-comment">/*
			 * skip over pages already present in the cache
			 */</span>
		        io_size = skip_range - start_offset;

		        f_offset += io_size;
			resid    -= io_size;

			<span class="enscript-keyword">if</span> (skip_range == upl_size)
			        <span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/*
			 * have to issue some real I/O
			 * at this point, we know it's starting on a page boundary
			 * because we've skipped over at least the first page in the request
			 */</span>
			start_offset = 0;
			upl_f_offset += skip_range;
			upl_size     -= skip_range;
		}
		pages_in_upl = upl_size / PAGE_SIZE;

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 61)) | DBG_FUNC_START,
			     upl, (<span class="enscript-type">int</span>)upl_f_offset, upl_size, start_offset, 0);

		kret = ubc_create_upl(vp, 
				      upl_f_offset,
				      upl_size,
				      &amp;upl,
				      &amp;pl,
				      UPL_RET_ONLY_ABSENT | UPL_SET_LITE);
		<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
		        <span class="enscript-keyword">return</span>(retval);
		issued_io = 0;

		<span class="enscript-comment">/*
		 * before we start marching forward, we must make sure we end on 
		 * a present page, otherwise we will be working with a freed
		 * upl
		 */</span>
		<span class="enscript-keyword">for</span> (last_pg = pages_in_upl - 1; last_pg &gt;= 0; last_pg--) {
		        <span class="enscript-keyword">if</span> (upl_page_present(pl, last_pg))
			        <span class="enscript-keyword">break</span>;
		}
		pages_in_upl = last_pg + 1;


		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 61)) | DBG_FUNC_END,
			     upl, (<span class="enscript-type">int</span>)upl_f_offset, upl_size, start_offset, 0);


		<span class="enscript-keyword">for</span> (last_pg = 0; last_pg &lt; pages_in_upl; ) {
		        <span class="enscript-comment">/*
			 * scan from the beginning of the upl looking for the first
			 * page that is present.... this will become the first page in
			 * the request we're going to make to 'cluster_io'... if all
			 * of the pages are absent, we won't call through to 'cluster_io'
			 */</span>
		        <span class="enscript-keyword">for</span> (start_pg = last_pg; start_pg &lt; pages_in_upl; start_pg++) {
			        <span class="enscript-keyword">if</span> (upl_page_present(pl, start_pg))
				        <span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/*
			 * scan from the starting present page looking for an absent
			 * page before the end of the upl is reached, if we 
			 * find one, then it will terminate the range of pages being
			 * presented to 'cluster_io'
			 */</span>
			<span class="enscript-keyword">for</span> (last_pg = start_pg; last_pg &lt; pages_in_upl; last_pg++) {
			        <span class="enscript-keyword">if</span> (!upl_page_present(pl, last_pg))
				        <span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (last_pg &gt; start_pg) {		
			        <span class="enscript-comment">/*
				 * we found a range of pages that must be filled
				 * if the last page in this range is the last page of the file
				 * we may have to clip the size of it to keep from reading past
				 * the end of the last physical block associated with the file
				 */</span>
			        upl_offset = start_pg * PAGE_SIZE;
				io_size    = (last_pg - start_pg) * PAGE_SIZE;

				<span class="enscript-keyword">if</span> ((off_t)(upl_f_offset + upl_offset + io_size) &gt; filesize)
				        io_size = filesize - (upl_f_offset + upl_offset);

				<span class="enscript-comment">/*
				 * issue an asynchronous read to cluster_io
				 */</span>
				retval = cluster_io(vp, upl, upl_offset, upl_f_offset + upl_offset, io_size,
						    CL_ASYNC | CL_READ | CL_COMMIT | CL_AGE | bflag, (buf_t)NULL, (<span class="enscript-type">struct</span> clios *)NULL, callback, callback_arg);

				issued_io = 1;
			}
		}
		<span class="enscript-keyword">if</span> (issued_io == 0)
		        ubc_upl_abort(upl, 0);

		io_size = upl_size - start_offset;
		
		<span class="enscript-keyword">if</span> (io_size &gt; resid)
		        io_size = resid;
		f_offset += io_size;
		resid    -= io_size;
	}

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 60)) | DBG_FUNC_END,
		     (<span class="enscript-type">int</span>)f_offset, resid, retval, 0, 0);

	<span class="enscript-keyword">return</span>(retval);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_push</span>(vnode_t vp, <span class="enscript-type">int</span> flags)
{
        <span class="enscript-keyword">return</span> cluster_push_ext(vp, flags, NULL, NULL);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_push_ext</span>(vnode_t vp, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
        <span class="enscript-type">int</span>	retval;
	<span class="enscript-type">int</span>	my_sparse_wait = 0;
	<span class="enscript-type">struct</span>	cl_writebehind *wbp;

	<span class="enscript-keyword">if</span> ( !UBCINFOEXISTS(vp)) {
	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 53)) | DBG_FUNC_NONE, vp, flags, 0, -1, 0);
	        <span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-comment">/* return if deferred write is set */</span>
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(vp-&gt;v_mount) &amp; MNT_DEFWRITE) &amp;&amp; (flags &amp; IO_DEFWRITE)) {
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> ((wbp = cluster_get_wbp(vp, CLW_RETURNLOCKED)) == NULL) {
	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 53)) | DBG_FUNC_NONE, vp, flags, 0, -2, 0);
	        <span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> (!ISSET(flags, IO_SYNC) &amp;&amp; wbp-&gt;cl_number == 0 &amp;&amp; wbp-&gt;cl_scmap == NULL) {
	        lck_mtx_unlock(&amp;wbp-&gt;cl_lockw);

	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 53)) | DBG_FUNC_NONE, vp, flags, 0, -3, 0);
		<span class="enscript-keyword">return</span>(0);
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 53)) | DBG_FUNC_START,
		     wbp-&gt;cl_scmap, wbp-&gt;cl_number, flags, 0, 0);

	<span class="enscript-comment">/*
	 * if we have an fsync in progress, we don't want to allow any additional
	 * sync/fsync/close(s) to occur until it finishes.
	 * note that its possible for writes to continue to occur to this file
	 * while we're waiting and also once the fsync starts to clean if we're
	 * in the sparse map case
	 */</span>
	<span class="enscript-keyword">while</span> (wbp-&gt;cl_sparse_wait) {
		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 97)) | DBG_FUNC_START, vp, 0, 0, 0, 0);

		msleep((caddr_t)&amp;wbp-&gt;cl_sparse_wait, &amp;wbp-&gt;cl_lockw, PRIBIO + 1, <span class="enscript-string">&quot;cluster_push_ext&quot;</span>, NULL);

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 97)) | DBG_FUNC_END, vp, 0, 0, 0, 0);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IO_SYNC) {
		my_sparse_wait = 1;
		wbp-&gt;cl_sparse_wait = 1;

		<span class="enscript-comment">/*
		 * this is an fsync (or equivalent)... we must wait for any existing async
		 * cleaning operations to complete before we evaulate the current state
		 * and finish cleaning... this insures that all writes issued before this
		 * fsync actually get cleaned to the disk before this fsync returns
		 */</span>
		<span class="enscript-keyword">while</span> (wbp-&gt;cl_sparse_pushes) {
			KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 98)) | DBG_FUNC_START, vp, 0, 0, 0, 0);

			msleep((caddr_t)&amp;wbp-&gt;cl_sparse_pushes, &amp;wbp-&gt;cl_lockw, PRIBIO + 1, <span class="enscript-string">&quot;cluster_push_ext&quot;</span>, NULL);

			KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 98)) | DBG_FUNC_END, vp, 0, 0, 0, 0);
		}
	}
	<span class="enscript-keyword">if</span> (wbp-&gt;cl_scmap) {
		<span class="enscript-type">void</span>	*scmap;

		<span class="enscript-keyword">if</span> (wbp-&gt;cl_sparse_pushes &lt; SPARSE_PUSH_LIMIT) {

			scmap = wbp-&gt;cl_scmap;
			wbp-&gt;cl_scmap = NULL;

			wbp-&gt;cl_sparse_pushes++;

			lck_mtx_unlock(&amp;wbp-&gt;cl_lockw);

			sparse_cluster_push(&amp;scmap, vp, ubc_getsize(vp), PUSH_ALL, flags, callback, callback_arg);

			lck_mtx_lock(&amp;wbp-&gt;cl_lockw);

			wbp-&gt;cl_sparse_pushes--;
			
			<span class="enscript-keyword">if</span> (wbp-&gt;cl_sparse_wait &amp;&amp; wbp-&gt;cl_sparse_pushes == 0)
				wakeup((caddr_t)&amp;wbp-&gt;cl_sparse_pushes);
		} <span class="enscript-keyword">else</span> {
			sparse_cluster_push(&amp;(wbp-&gt;cl_scmap), vp, ubc_getsize(vp), PUSH_ALL, flags, callback, callback_arg);
		}
		retval = 1;
	} <span class="enscript-keyword">else</span>  {
		retval = cluster_try_push(wbp, vp, ubc_getsize(vp), PUSH_ALL, flags, callback, callback_arg);
	}
	lck_mtx_unlock(&amp;wbp-&gt;cl_lockw);

	<span class="enscript-keyword">if</span> (flags &amp; IO_SYNC)
	        (<span class="enscript-type">void</span>)vnode_waitforwrites(vp, 0, 0, 0, <span class="enscript-string">&quot;cluster_push&quot;</span>);

	<span class="enscript-keyword">if</span> (my_sparse_wait) {
		<span class="enscript-comment">/*
		 * I'm the owner of the serialization token
		 * clear it and wakeup anyone that is waiting
		 * for me to finish
		 */</span>
		lck_mtx_lock(&amp;wbp-&gt;cl_lockw);

		wbp-&gt;cl_sparse_wait = 0;
		wakeup((caddr_t)&amp;wbp-&gt;cl_sparse_wait);

		lck_mtx_unlock(&amp;wbp-&gt;cl_lockw);
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 53)) | DBG_FUNC_END,
		     wbp-&gt;cl_scmap, wbp-&gt;cl_number, retval, 0, 0);

	<span class="enscript-keyword">return</span> (retval);
}


__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">cluster_release</span>(<span class="enscript-type">struct</span> ubc_info *ubc)
{
        <span class="enscript-type">struct</span> cl_writebehind *wbp;
	<span class="enscript-type">struct</span> cl_readahead   *rap;

	<span class="enscript-keyword">if</span> ((wbp = ubc-&gt;cl_wbehind)) {

	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 81)) | DBG_FUNC_START, ubc, wbp-&gt;cl_scmap, 0, 0, 0);

		<span class="enscript-keyword">if</span> (wbp-&gt;cl_scmap)
		        vfs_drt_control(&amp;(wbp-&gt;cl_scmap), 0);
	} <span class="enscript-keyword">else</span> {
	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 81)) | DBG_FUNC_START, ubc, 0, 0, 0, 0);
	}

	rap = ubc-&gt;cl_rahead;

	<span class="enscript-keyword">if</span> (wbp != NULL) {
	        lck_mtx_destroy(&amp;wbp-&gt;cl_lockw, cl_mtx_grp);
	        FREE_ZONE((<span class="enscript-type">void</span> *)wbp, <span class="enscript-keyword">sizeof</span> *wbp, M_CLWRBEHIND);
	}
	<span class="enscript-keyword">if</span> ((rap = ubc-&gt;cl_rahead)) {
	        lck_mtx_destroy(&amp;rap-&gt;cl_lockr, cl_mtx_grp);
	        FREE_ZONE((<span class="enscript-type">void</span> *)rap, <span class="enscript-keyword">sizeof</span> *rap, M_CLRDAHEAD);
	}
	ubc-&gt;cl_rahead  = NULL;
	ubc-&gt;cl_wbehind = NULL;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 81)) | DBG_FUNC_END, ubc, rap, wbp, 0, 0);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_try_push</span>(<span class="enscript-type">struct</span> cl_writebehind *wbp, vnode_t vp, off_t EOF, <span class="enscript-type">int</span> push_flag, <span class="enscript-type">int</span> io_flags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
        <span class="enscript-type">int</span> cl_index;
	<span class="enscript-type">int</span> cl_index1;
	<span class="enscript-type">int</span> min_index;
        <span class="enscript-type">int</span> cl_len;
	<span class="enscript-type">int</span> cl_pushed = 0;
	<span class="enscript-type">struct</span> cl_wextent l_clusters[MAX_CLUSTERS];
	u_int  max_cluster_pgcount;


	max_cluster_pgcount = MAX_CLUSTER_SIZE(vp) / PAGE_SIZE;
	<span class="enscript-comment">/*
	 * the write behind context exists and has
	 * already been locked...
	 */</span>
	<span class="enscript-keyword">if</span> (wbp-&gt;cl_number == 0)
	        <span class="enscript-comment">/*
		 * no clusters to push
		 * return number of empty slots
		 */</span>
	        <span class="enscript-keyword">return</span> (MAX_CLUSTERS);
	 
	<span class="enscript-comment">/*
	 * make a local 'sorted' copy of the clusters
	 * and clear wbp-&gt;cl_number so that new clusters can
	 * be developed
	 */</span>
	<span class="enscript-keyword">for</span> (cl_index = 0; cl_index &lt; wbp-&gt;cl_number; cl_index++) {
	        <span class="enscript-keyword">for</span> (min_index = -1, cl_index1 = 0; cl_index1 &lt; wbp-&gt;cl_number; cl_index1++) {
		        <span class="enscript-keyword">if</span> (wbp-&gt;cl_clusters[cl_index1].b_addr == wbp-&gt;cl_clusters[cl_index1].e_addr)
			        <span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (min_index == -1)
			        min_index = cl_index1;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wbp-&gt;cl_clusters[cl_index1].b_addr &lt; wbp-&gt;cl_clusters[min_index].b_addr)
			        min_index = cl_index1;
		}
		<span class="enscript-keyword">if</span> (min_index == -1)
		        <span class="enscript-keyword">break</span>;

	        l_clusters[cl_index].b_addr = wbp-&gt;cl_clusters[min_index].b_addr;
		l_clusters[cl_index].e_addr = wbp-&gt;cl_clusters[min_index].e_addr;
		l_clusters[cl_index].io_flags = wbp-&gt;cl_clusters[min_index].io_flags;

	        wbp-&gt;cl_clusters[min_index].b_addr = wbp-&gt;cl_clusters[min_index].e_addr;
	}
	wbp-&gt;cl_number = 0;

	cl_len = cl_index;

	<span class="enscript-keyword">if</span> ( (push_flag &amp; PUSH_DELAY) &amp;&amp; cl_len == MAX_CLUSTERS ) {
		<span class="enscript-type">int</span>   i;
		
		<span class="enscript-comment">/*
		 * determine if we appear to be writing the file sequentially
		 * if not, by returning without having pushed any clusters
		 * we will cause this vnode to be pushed into the sparse cluster mechanism
		 * used for managing more random I/O patterns
		 *
		 * we know that we've got all clusters currently in use and the next write doesn't fit into one of them...
		 * that's why we're in try_push with PUSH_DELAY...
		 *
		 * check to make sure that all the clusters except the last one are 'full'... and that each cluster
		 * is adjacent to the next (i.e. we're looking for sequential writes) they were sorted above
		 * so we can just make a simple pass through, up to, but not including the last one...
		 * note that e_addr is not inclusive, so it will be equal to the b_addr of the next cluster if they
		 * are sequential
		 * 
		 * we let the last one be partial as long as it was adjacent to the previous one...
		 * we need to do this to deal with multi-threaded servers that might write an I/O or 2 out
		 * of order... if this occurs at the tail of the last cluster, we don't want to fall into the sparse cluster world...
		 */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; MAX_CLUSTERS - 1; i++) {
		        <span class="enscript-keyword">if</span> ((l_clusters[i].e_addr - l_clusters[i].b_addr) != max_cluster_pgcount)
			        <span class="enscript-keyword">goto</span> <span class="enscript-reference">dont_try</span>;
			<span class="enscript-keyword">if</span> (l_clusters[i].e_addr != l_clusters[i+1].b_addr)
		                <span class="enscript-keyword">goto</span> <span class="enscript-reference">dont_try</span>;
		}
	}
	<span class="enscript-keyword">for</span> (cl_index = 0; cl_index &lt; cl_len; cl_index++) {
	        <span class="enscript-type">int</span>	flags;
		<span class="enscript-type">struct</span>	cl_extent cl;

		flags = io_flags &amp; (IO_PASSIVE|IO_CLOSE);

	        <span class="enscript-comment">/*
		 * try to push each cluster in turn...
		 */</span>
		<span class="enscript-keyword">if</span> (l_clusters[cl_index].io_flags &amp; CLW_IONOCACHE)
		        flags |= IO_NOCACHE;

		<span class="enscript-keyword">if</span> (l_clusters[cl_index].io_flags &amp; CLW_IOPASSIVE)
		        flags |= IO_PASSIVE;

		<span class="enscript-keyword">if</span> (push_flag &amp; PUSH_SYNC)
		        flags |= IO_SYNC;

		cl.b_addr = l_clusters[cl_index].b_addr;
		cl.e_addr = l_clusters[cl_index].e_addr;

	        cluster_push_now(vp, &amp;cl, EOF, flags, callback, callback_arg);

		l_clusters[cl_index].b_addr = 0;
		l_clusters[cl_index].e_addr = 0;

		cl_pushed++;

		<span class="enscript-keyword">if</span> ( !(push_flag &amp; PUSH_ALL) )
		        <span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">dont_try</span>:
	<span class="enscript-keyword">if</span> (cl_len &gt; cl_pushed) {
	       <span class="enscript-comment">/*
		* we didn't push all of the clusters, so
		* lets try to merge them back in to the vnode
		*/</span>
	        <span class="enscript-keyword">if</span> ((MAX_CLUSTERS - wbp-&gt;cl_number) &lt; (cl_len - cl_pushed)) {
		        <span class="enscript-comment">/*
			 * we picked up some new clusters while we were trying to
			 * push the old ones... this can happen because I've dropped
			 * the vnode lock... the sum of the
			 * leftovers plus the new cluster count exceeds our ability
			 * to represent them, so switch to the sparse cluster mechanism
			 *
			 * collect the active public clusters...
			 */</span>
		        sparse_cluster_switch(wbp, vp, EOF, callback, callback_arg);

		        <span class="enscript-keyword">for</span> (cl_index = 0, cl_index1 = 0; cl_index &lt; cl_len; cl_index++) {
			        <span class="enscript-keyword">if</span> (l_clusters[cl_index].b_addr == l_clusters[cl_index].e_addr)
				        <span class="enscript-keyword">continue</span>;
			        wbp-&gt;cl_clusters[cl_index1].b_addr = l_clusters[cl_index].b_addr;
				wbp-&gt;cl_clusters[cl_index1].e_addr = l_clusters[cl_index].e_addr;
				wbp-&gt;cl_clusters[cl_index1].io_flags = l_clusters[cl_index].io_flags;

				cl_index1++;
			}
			<span class="enscript-comment">/*
			 * update the cluster count
			 */</span>
			wbp-&gt;cl_number = cl_index1;

		        <span class="enscript-comment">/*
			 * and collect the original clusters that were moved into the 
			 * local storage for sorting purposes
			 */</span>
		        sparse_cluster_switch(wbp, vp, EOF, callback, callback_arg);

		} <span class="enscript-keyword">else</span> {
		        <span class="enscript-comment">/*
			 * we've got room to merge the leftovers back in
			 * just append them starting at the next 'hole'
			 * represented by wbp-&gt;cl_number
			 */</span>
		        <span class="enscript-keyword">for</span> (cl_index = 0, cl_index1 = wbp-&gt;cl_number; cl_index &lt; cl_len; cl_index++) {
			        <span class="enscript-keyword">if</span> (l_clusters[cl_index].b_addr == l_clusters[cl_index].e_addr)
				        <span class="enscript-keyword">continue</span>;

			        wbp-&gt;cl_clusters[cl_index1].b_addr = l_clusters[cl_index].b_addr;
				wbp-&gt;cl_clusters[cl_index1].e_addr = l_clusters[cl_index].e_addr;
				wbp-&gt;cl_clusters[cl_index1].io_flags = l_clusters[cl_index].io_flags;

				cl_index1++;
			}
			<span class="enscript-comment">/*
			 * update the cluster count
			 */</span>
			wbp-&gt;cl_number = cl_index1;
		}
	}
	<span class="enscript-keyword">return</span> (MAX_CLUSTERS - wbp-&gt;cl_number);
}



<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_push_now</span>(vnode_t vp, <span class="enscript-type">struct</span> cl_extent *cl, off_t EOF, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
	upl_page_info_t *pl;
	upl_t            upl;
	vm_offset_t      upl_offset;
	<span class="enscript-type">int</span>              upl_size;
	off_t 	         upl_f_offset;
        <span class="enscript-type">int</span>              pages_in_upl;
	<span class="enscript-type">int</span>              start_pg;
	<span class="enscript-type">int</span>              last_pg;
	<span class="enscript-type">int</span>              io_size;
	<span class="enscript-type">int</span>              io_flags;
	<span class="enscript-type">int</span>              upl_flags;
	<span class="enscript-type">int</span>              bflag;
	<span class="enscript-type">int</span>              size;
	<span class="enscript-type">int</span>              error = 0;
	<span class="enscript-type">int</span>              retval;
	kern_return_t    kret;

	<span class="enscript-keyword">if</span> (flags &amp; IO_PASSIVE)
		bflag = CL_PASSIVE;
	<span class="enscript-keyword">else</span>
		bflag = 0;

	<span class="enscript-keyword">if</span> (flags &amp; IO_SKIP_ENCRYPTION)
		bflag |= CL_ENCRYPTED;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 51)) | DBG_FUNC_START,
		     (<span class="enscript-type">int</span>)cl-&gt;b_addr, (<span class="enscript-type">int</span>)cl-&gt;e_addr, (<span class="enscript-type">int</span>)EOF, flags, 0);

	<span class="enscript-keyword">if</span> ((pages_in_upl = (<span class="enscript-type">int</span>)(cl-&gt;e_addr - cl-&gt;b_addr)) == 0) {
	        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 51)) | DBG_FUNC_END, 1, 0, 0, 0, 0);

	        <span class="enscript-keyword">return</span> (0);
	}
	upl_size = pages_in_upl * PAGE_SIZE;
	upl_f_offset = (off_t)(cl-&gt;b_addr * PAGE_SIZE_64);

	<span class="enscript-keyword">if</span> (upl_f_offset + upl_size &gt;= EOF) {

	        <span class="enscript-keyword">if</span> (upl_f_offset &gt;= EOF) {
		        <span class="enscript-comment">/*
			 * must have truncated the file and missed 
			 * clearing a dangling cluster (i.e. it's completely
			 * beyond the new EOF
			 */</span>
		        KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 51)) | DBG_FUNC_END, 1, 1, 0, 0, 0);

		        <span class="enscript-keyword">return</span>(0);
		}
		size = EOF - upl_f_offset;

		upl_size = (size + (PAGE_SIZE - 1)) &amp; ~PAGE_MASK;
		pages_in_upl = upl_size / PAGE_SIZE;
	} <span class="enscript-keyword">else</span>
	        size = upl_size;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 41)) | DBG_FUNC_START, upl_size, size, 0, 0, 0);

	<span class="enscript-comment">/*
	 * by asking for UPL_COPYOUT_FROM and UPL_RET_ONLY_DIRTY, we get the following desirable behavior
	 * 
	 * - only pages that are currently dirty are returned... these are the ones we need to clean
	 * - the hardware dirty bit is cleared when the page is gathered into the UPL... the software dirty bit is set
	 * - if we have to abort the I/O for some reason, the software dirty bit is left set since we didn't clean the page
	 * - when we commit the page, the software dirty bit is cleared... the hardware dirty bit is untouched so that if 
	 *   someone dirties this page while the I/O is in progress, we don't lose track of the new state
	 *
	 * when the I/O completes, we no longer ask for an explicit clear of the DIRTY state (either soft or hard)
	 */</span>

	<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VNOCACHE_DATA) || (flags &amp; IO_NOCACHE))
	        upl_flags = UPL_COPYOUT_FROM | UPL_RET_ONLY_DIRTY | UPL_SET_LITE | UPL_WILL_BE_DUMPED;
	<span class="enscript-keyword">else</span>
	        upl_flags = UPL_COPYOUT_FROM | UPL_RET_ONLY_DIRTY | UPL_SET_LITE;

	kret = ubc_create_upl(vp, 
			      	upl_f_offset,
			      	upl_size,
			      	&amp;upl,
			        &amp;pl,
			        upl_flags);
	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
	        panic(<span class="enscript-string">&quot;cluster_push: failed to get pagelist&quot;</span>);

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 41)) | DBG_FUNC_END, upl, upl_f_offset, 0, 0, 0);

	<span class="enscript-comment">/*
	 * since we only asked for the dirty pages back
	 * it's possible that we may only get a few or even none, so...
	 * before we start marching forward, we must make sure we know
	 * where the last present page is in the UPL, otherwise we could
	 * end up working with a freed upl due to the FREE_ON_EMPTY semantics
	 * employed by commit_range and abort_range.
	 */</span>
	<span class="enscript-keyword">for</span> (last_pg = pages_in_upl - 1; last_pg &gt;= 0; last_pg--) {
	        <span class="enscript-keyword">if</span> (upl_page_present(pl, last_pg))
		        <span class="enscript-keyword">break</span>;
	}
	pages_in_upl = last_pg + 1;

	<span class="enscript-keyword">if</span> (pages_in_upl == 0) {
	        ubc_upl_abort(upl, 0);

		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 51)) | DBG_FUNC_END, 1, 2, 0, 0, 0);
		<span class="enscript-keyword">return</span>(0);
	}	  

	<span class="enscript-keyword">for</span> (last_pg = 0; last_pg &lt; pages_in_upl; ) {
	        <span class="enscript-comment">/*
		 * find the next dirty page in the UPL
		 * this will become the first page in the 
		 * next I/O to generate
		 */</span>
		<span class="enscript-keyword">for</span> (start_pg = last_pg; start_pg &lt; pages_in_upl; start_pg++) {
			<span class="enscript-keyword">if</span> (upl_dirty_page(pl, start_pg))
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (upl_page_present(pl, start_pg))
			        <span class="enscript-comment">/*
				 * RET_ONLY_DIRTY will return non-dirty 'precious' pages
				 * just release these unchanged since we're not going
				 * to steal them or change their state
				 */</span>
			        ubc_upl_abort_range(upl, start_pg * PAGE_SIZE, PAGE_SIZE, UPL_ABORT_FREE_ON_EMPTY);
		}
		<span class="enscript-keyword">if</span> (start_pg &gt;= pages_in_upl)
		        <span class="enscript-comment">/*
			 * done... no more dirty pages to push
			 */</span>
		        <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (start_pg &gt; last_pg)
		        <span class="enscript-comment">/*
			 * skipped over some non-dirty pages
			 */</span>
			size -= ((start_pg - last_pg) * PAGE_SIZE);

		<span class="enscript-comment">/*
		 * find a range of dirty pages to write
		 */</span>
		<span class="enscript-keyword">for</span> (last_pg = start_pg; last_pg &lt; pages_in_upl; last_pg++) {
			<span class="enscript-keyword">if</span> (!upl_dirty_page(pl, last_pg))
				<span class="enscript-keyword">break</span>;
		}
		upl_offset = start_pg * PAGE_SIZE;

		io_size = min(size, (last_pg - start_pg) * PAGE_SIZE);

		io_flags = CL_THROTTLE | CL_COMMIT | CL_AGE | bflag;

		<span class="enscript-keyword">if</span> ( !(flags &amp; IO_SYNC))
		        io_flags |= CL_ASYNC;

		<span class="enscript-keyword">if</span> (flags &amp; IO_CLOSE)
		        io_flags |= CL_CLOSE;

		<span class="enscript-keyword">if</span> (flags &amp; IO_NOCACHE)
			io_flags |= CL_NOCACHE;

		retval = cluster_io(vp, upl, upl_offset, upl_f_offset + upl_offset, io_size,
				    io_flags, (buf_t)NULL, (<span class="enscript-type">struct</span> clios *)NULL, callback, callback_arg);

		<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; retval)
		        error = retval;

		size -= io_size;
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 51)) | DBG_FUNC_END, 1, 3, 0, 0, 0);

	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * sparse_cluster_switch is called with the write behind lock held
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sparse_cluster_switch</span>(<span class="enscript-type">struct</span> cl_writebehind *wbp, vnode_t vp, off_t EOF, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
        <span class="enscript-type">int</span>	cl_index;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 78)) | DBG_FUNC_START, vp, wbp-&gt;cl_scmap, 0, 0, 0);

	<span class="enscript-keyword">for</span> (cl_index = 0; cl_index &lt; wbp-&gt;cl_number; cl_index++) {
	        <span class="enscript-type">int</span>	  flags;
		<span class="enscript-type">struct</span> cl_extent cl;

	        <span class="enscript-keyword">for</span> (cl.b_addr = wbp-&gt;cl_clusters[cl_index].b_addr; cl.b_addr &lt; wbp-&gt;cl_clusters[cl_index].e_addr; cl.b_addr++) {

		        <span class="enscript-keyword">if</span> (ubc_page_op(vp, (off_t)(cl.b_addr * PAGE_SIZE_64), 0, NULL, &amp;flags) == KERN_SUCCESS) {
			        <span class="enscript-keyword">if</span> (flags &amp; UPL_POP_DIRTY) {
				        cl.e_addr = cl.b_addr + 1;

				        sparse_cluster_add(&amp;(wbp-&gt;cl_scmap), vp, &amp;cl, EOF, callback, callback_arg);
				}
			}
		}
	}
	wbp-&gt;cl_number = 0;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 78)) | DBG_FUNC_END, vp, wbp-&gt;cl_scmap, 0, 0, 0);
}


<span class="enscript-comment">/*
 * sparse_cluster_push must be called with the write-behind lock held if the scmap is
 * still associated with the write-behind context... however, if the scmap has been disassociated
 * from the write-behind context (the cluster_push case), the wb lock is not held
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sparse_cluster_push</span>(<span class="enscript-type">void</span> **scmap, vnode_t vp, off_t EOF, <span class="enscript-type">int</span> push_flag, <span class="enscript-type">int</span> io_flags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
        <span class="enscript-type">struct</span> cl_extent cl;
        off_t		offset;
	u_int		length;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 79)) | DBG_FUNC_START, vp, (*scmap), 0, push_flag, 0);

	<span class="enscript-keyword">if</span> (push_flag &amp; PUSH_ALL)
	        vfs_drt_control(scmap, 1);

	<span class="enscript-keyword">for</span> (;;) {
	        <span class="enscript-keyword">if</span> (vfs_drt_get_cluster(scmap, &amp;offset, &amp;length) != KERN_SUCCESS)
			<span class="enscript-keyword">break</span>;

		cl.b_addr = (daddr64_t)(offset / PAGE_SIZE_64);
		cl.e_addr = (daddr64_t)((offset + length) / PAGE_SIZE_64);

		cluster_push_now(vp, &amp;cl, EOF, io_flags &amp; (IO_PASSIVE|IO_CLOSE), callback, callback_arg);

		<span class="enscript-keyword">if</span> ( !(push_flag &amp; PUSH_ALL) )
		        <span class="enscript-keyword">break</span>;
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 79)) | DBG_FUNC_END, vp, (*scmap), 0, 0, 0);
}


<span class="enscript-comment">/*
 * sparse_cluster_add is called with the write behind lock held
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sparse_cluster_add</span>(<span class="enscript-type">void</span> **scmap, vnode_t vp, <span class="enscript-type">struct</span> cl_extent *cl, off_t EOF, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
        u_int	new_dirty;
	u_int	length;
	off_t	offset;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 80)) | DBG_FUNC_START, (*scmap), 0, cl-&gt;b_addr, (<span class="enscript-type">int</span>)cl-&gt;e_addr, 0);

	offset = (off_t)(cl-&gt;b_addr * PAGE_SIZE_64);
	length = ((u_int)(cl-&gt;e_addr - cl-&gt;b_addr)) * PAGE_SIZE;

	<span class="enscript-keyword">while</span> (vfs_drt_mark_pages(scmap, offset, length, &amp;new_dirty) != KERN_SUCCESS) {
	        <span class="enscript-comment">/*
		 * no room left in the map
		 * only a partial update was done
		 * push out some pages and try again
		 */</span>
	        sparse_cluster_push(scmap, vp, EOF, 0, 0, callback, callback_arg);

		offset += (new_dirty * PAGE_SIZE_64);
		length -= (new_dirty * PAGE_SIZE);
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 80)) | DBG_FUNC_END, vp, (*scmap), 0, 0, 0);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_align_phys_io</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, addr64_t usr_paddr, u_int32_t xsize, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
        upl_page_info_t  *pl;
        upl_t            upl;
        addr64_t	 ubc_paddr;
        kern_return_t    kret;
        <span class="enscript-type">int</span>              error = 0;
	<span class="enscript-type">int</span>		 did_read = 0;
	<span class="enscript-type">int</span>		 abort_flags;
	<span class="enscript-type">int</span>		 upl_flags;
	<span class="enscript-type">int</span>              bflag;

	<span class="enscript-keyword">if</span> (flags &amp; IO_PASSIVE)
		bflag = CL_PASSIVE;
	<span class="enscript-keyword">else</span>
		bflag = 0;

	<span class="enscript-keyword">if</span> (flags &amp; IO_NOCACHE)
		bflag |= CL_NOCACHE;

	upl_flags = UPL_SET_LITE;

	<span class="enscript-keyword">if</span> ( !(flags &amp; CL_READ) ) {
		<span class="enscript-comment">/*
		 * &quot;write&quot; operation:  let the UPL subsystem know
		 * that we intend to modify the buffer cache pages
		 * we're gathering.
		 */</span>
		upl_flags |= UPL_WILL_MODIFY;
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-comment">/*
		 * indicate that there is no need to pull the
		 * mapping for this page... we're only going
		 * to read from it, not modify it.
		 */</span>
		upl_flags |= UPL_FILE_IO;
	}
        kret = ubc_create_upl(vp,
                              uio-&gt;uio_offset &amp; ~PAGE_MASK_64,
                              PAGE_SIZE,
                              &amp;upl,
                              &amp;pl,
                              upl_flags);

        <span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
                <span class="enscript-keyword">return</span>(EINVAL);

        <span class="enscript-keyword">if</span> (!upl_valid_page(pl, 0)) {
                <span class="enscript-comment">/*
                 * issue a synchronous read to cluster_io
                 */</span>
                error = cluster_io(vp, upl, 0, uio-&gt;uio_offset &amp; ~PAGE_MASK_64, PAGE_SIZE,
				   CL_READ | bflag, (buf_t)NULL, (<span class="enscript-type">struct</span> clios *)NULL, callback, callback_arg);
                <span class="enscript-keyword">if</span> (error) {
                          ubc_upl_abort_range(upl, 0, PAGE_SIZE, UPL_ABORT_DUMP_PAGES | UPL_ABORT_FREE_ON_EMPTY);

                          <span class="enscript-keyword">return</span>(error);
                }
		did_read = 1;
        }
        ubc_paddr = ((addr64_t)upl_phys_page(pl, 0) &lt;&lt; PAGE_SHIFT) + (addr64_t)(uio-&gt;uio_offset &amp; PAGE_MASK_64);

<span class="enscript-comment">/*
 *	NOTE:  There is no prototype for the following in BSD. It, and the definitions
 *	of the defines for cppvPsrc, cppvPsnk, cppvFsnk, and cppvFsrc will be found in
 *	osfmk/ppc/mappings.h.  They are not included here because there appears to be no
 *	way to do so without exporting them to kexts as well.
 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; CL_READ)
<span class="enscript-comment">//		copypv(ubc_paddr, usr_paddr, xsize, cppvPsrc | cppvPsnk | cppvFsnk);	/* Copy physical to physical and flush the destination */
</span>		copypv(ubc_paddr, usr_paddr, xsize,        2 |        1 |        4);	<span class="enscript-comment">/* Copy physical to physical and flush the destination */</span>
	<span class="enscript-keyword">else</span>
<span class="enscript-comment">//		copypv(usr_paddr, ubc_paddr, xsize, cppvPsrc | cppvPsnk | cppvFsrc);	/* Copy physical to physical and flush the source */
</span>		copypv(usr_paddr, ubc_paddr, xsize,        2 |        1 |        8);	<span class="enscript-comment">/* Copy physical to physical and flush the source */</span>
	
	<span class="enscript-keyword">if</span> ( !(flags &amp; CL_READ) || (upl_valid_page(pl, 0) &amp;&amp; upl_dirty_page(pl, 0))) {
	        <span class="enscript-comment">/*
		 * issue a synchronous write to cluster_io
		 */</span>
		error = cluster_io(vp, upl, 0, uio-&gt;uio_offset &amp; ~PAGE_MASK_64, PAGE_SIZE,
				   bflag, (buf_t)NULL, (<span class="enscript-type">struct</span> clios *)NULL, callback, callback_arg);
	}
	<span class="enscript-keyword">if</span> (error == 0) 
	        uio_update(uio, (user_size_t)xsize);

	<span class="enscript-keyword">if</span> (did_read)
	        abort_flags = UPL_ABORT_FREE_ON_EMPTY;
	<span class="enscript-keyword">else</span>
	        abort_flags = UPL_ABORT_FREE_ON_EMPTY | UPL_ABORT_DUMP_PAGES;

	ubc_upl_abort_range(upl, 0, PAGE_SIZE, abort_flags);
	
	<span class="enscript-keyword">return</span> (error);
}



<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_copy_upl_data</span>(<span class="enscript-type">struct</span> uio *uio, upl_t upl, <span class="enscript-type">int</span> upl_offset, <span class="enscript-type">int</span> *io_resid)
{
        <span class="enscript-type">int</span>       pg_offset;
	<span class="enscript-type">int</span>       pg_index;
        <span class="enscript-type">int</span>   	  csize;
	<span class="enscript-type">int</span>       segflg;
	<span class="enscript-type">int</span>       retval = 0;
	<span class="enscript-type">int</span>	  xsize;
	upl_page_info_t *pl;

	xsize = *io_resid;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 34)) | DBG_FUNC_START,
		     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, upl_offset, xsize, 0, 0);

	segflg = uio-&gt;uio_segflg;

	<span class="enscript-keyword">switch</span>(segflg) {

	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE32</span>:
	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERISPACE32</span>:
		uio-&gt;uio_segflg = UIO_PHYS_USERSPACE32;
		<span class="enscript-keyword">break</span>;

	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE</span>:
	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERISPACE</span>:
		uio-&gt;uio_segflg = UIO_PHYS_USERSPACE;
		<span class="enscript-keyword">break</span>;

	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE64</span>:
	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERISPACE64</span>:
		uio-&gt;uio_segflg = UIO_PHYS_USERSPACE64;
		<span class="enscript-keyword">break</span>;

	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_SYSSPACE</span>:
		uio-&gt;uio_segflg = UIO_PHYS_SYSSPACE;
		<span class="enscript-keyword">break</span>;

	}
	pl = ubc_upl_pageinfo(upl);

	pg_index  = upl_offset / PAGE_SIZE;
	pg_offset = upl_offset &amp; PAGE_MASK;
	csize     = min(PAGE_SIZE - pg_offset, xsize);

	<span class="enscript-keyword">while</span> (xsize &amp;&amp; retval == 0) {
	        addr64_t  paddr;

		paddr = ((addr64_t)upl_phys_page(pl, pg_index) &lt;&lt; PAGE_SHIFT) + pg_offset;

		retval = uiomove64(paddr, csize, uio);

		pg_index += 1;
		pg_offset = 0;
		xsize    -= csize;
		csize     = min(PAGE_SIZE, xsize);
	}
	*io_resid = xsize;

	uio-&gt;uio_segflg = segflg;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 34)) | DBG_FUNC_END,
		     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, xsize, retval, segflg, 0);

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_copy_ubc_data</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> *io_resid, <span class="enscript-type">int</span> mark_dirty)
{

	<span class="enscript-keyword">return</span> (cluster_copy_ubc_data_internal(vp, uio, io_resid, mark_dirty, 1));
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cluster_copy_ubc_data_internal</span>(vnode_t vp, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> *io_resid, <span class="enscript-type">int</span> mark_dirty, <span class="enscript-type">int</span> take_reference)
{
	<span class="enscript-type">int</span>       segflg;
	<span class="enscript-type">int</span>       io_size;
	<span class="enscript-type">int</span>       xsize;
	<span class="enscript-type">int</span>       start_offset;
	<span class="enscript-type">int</span>       retval = 0;
	memory_object_control_t	 control;

	io_size = *io_resid;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 34)) | DBG_FUNC_START,
		     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, io_size, mark_dirty, take_reference, 0);

	control = ubc_getobject(vp, UBC_FLAGS_NONE);

	<span class="enscript-keyword">if</span> (control == MEMORY_OBJECT_CONTROL_NULL) {
		KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 34)) | DBG_FUNC_END,
			     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, io_size, retval, 3, 0);

		<span class="enscript-keyword">return</span>(0);
	}
	segflg = uio-&gt;uio_segflg;

	<span class="enscript-keyword">switch</span>(segflg) {

	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE32</span>:
	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERISPACE32</span>:
		uio-&gt;uio_segflg = UIO_PHYS_USERSPACE32;
		<span class="enscript-keyword">break</span>;

	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE64</span>:
	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERISPACE64</span>:
		uio-&gt;uio_segflg = UIO_PHYS_USERSPACE64;
		<span class="enscript-keyword">break</span>;

	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE</span>:
	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERISPACE</span>:
		uio-&gt;uio_segflg = UIO_PHYS_USERSPACE;
		<span class="enscript-keyword">break</span>;

	  <span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_SYSSPACE</span>:
		uio-&gt;uio_segflg = UIO_PHYS_SYSSPACE;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> ( (io_size = *io_resid) ) {
	        start_offset = (<span class="enscript-type">int</span>)(uio-&gt;uio_offset &amp; PAGE_MASK_64);
		xsize = uio_resid(uio);

		retval = memory_object_control_uiomove(control, uio-&gt;uio_offset - start_offset, uio,
						       start_offset, io_size, mark_dirty, take_reference);
		xsize -= uio_resid(uio);
		io_size -= xsize;
	}
	uio-&gt;uio_segflg = segflg;
	*io_resid       = io_size;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 34)) | DBG_FUNC_END,
		     (<span class="enscript-type">int</span>)uio-&gt;uio_offset, io_size, retval, 0x80000000 | segflg, 0);

	<span class="enscript-keyword">return</span>(retval);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">is_file_clean</span>(vnode_t vp, off_t filesize)
{
        off_t f_offset;
	<span class="enscript-type">int</span>   flags;
	<span class="enscript-type">int</span>   total_dirty = 0;

	<span class="enscript-keyword">for</span> (f_offset = 0; f_offset &lt; filesize; f_offset += PAGE_SIZE_64) {
	        <span class="enscript-keyword">if</span> (ubc_page_op(vp, f_offset, 0, NULL, &amp;flags) == KERN_SUCCESS) {
		        <span class="enscript-keyword">if</span> (flags &amp; UPL_POP_DIRTY) {
			        total_dirty++;
			}
		}
	}
	<span class="enscript-keyword">if</span> (total_dirty)
	        <span class="enscript-keyword">return</span>(EINVAL);

	<span class="enscript-keyword">return</span> (0);
}



<span class="enscript-comment">/*
 * Dirty region tracking/clustering mechanism.
 *
 * This code (vfs_drt_*) provides a mechanism for tracking and clustering
 * dirty regions within a larger space (file).  It is primarily intended to
 * support clustering in large files with many dirty areas.
 *
 * The implementation assumes that the dirty regions are pages.
 *
 * To represent dirty pages within the file, we store bit vectors in a
 * variable-size circular hash.
 */</span>

<span class="enscript-comment">/*
 * Bitvector size.  This determines the number of pages we group in a
 * single hashtable entry.  Each hashtable entry is aligned to this
 * size within the file.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_BITVECTOR_PAGES</span>		((1024 * 1024) / PAGE_SIZE)

<span class="enscript-comment">/*
 * File offset handling.
 *
  * DRT_ADDRESS_MASK is dependent on DRT_BITVECTOR_PAGES;
 * the correct formula is  (~((DRT_BITVECTOR_PAGES * PAGE_SIZE) - 1))
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_ADDRESS_MASK</span>		(~((DRT_BITVECTOR_PAGES * PAGE_SIZE) - 1))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_ALIGN_ADDRESS</span>(addr)		((addr) &amp; DRT_ADDRESS_MASK)

<span class="enscript-comment">/*
 * Hashtable address field handling.
 *
 * The low-order bits of the hashtable address are used to conserve
 * space.
 *
 * DRT_HASH_COUNT_MASK must be large enough to store the range
 * 0-DRT_BITVECTOR_PAGES inclusive, as well as have one value
 * to indicate that the bucket is actually unoccupied.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH_GET_ADDRESS</span>(scm, i)	((scm)-&gt;scm_hashtable[(i)].dhe_control &amp; DRT_ADDRESS_MASK)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH_SET_ADDRESS</span>(scm, i, a)									\
	<span class="enscript-keyword">do</span> {												\
		(scm)-&gt;scm_hashtable[(i)].dhe_control =							\
		    ((scm)-&gt;scm_hashtable[(i)].dhe_control &amp; ~DRT_ADDRESS_MASK) | DRT_ALIGN_ADDRESS(a);	\
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_HASH_COUNT_MASK</span>		0x1ff
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH_GET_COUNT</span>(scm, i)	((scm)-&gt;scm_hashtable[(i)].dhe_control &amp; DRT_HASH_COUNT_MASK)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH_SET_COUNT</span>(scm, i, c)											\
	<span class="enscript-keyword">do</span> {														\
		(scm)-&gt;scm_hashtable[(i)].dhe_control =									\
		    ((scm)-&gt;scm_hashtable[(i)].dhe_control &amp; ~DRT_HASH_COUNT_MASK) | ((c) &amp; DRT_HASH_COUNT_MASK);	\
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH_CLEAR</span>(scm, i)                                                                                          \
	<span class="enscript-keyword">do</span> {														\
		(scm)-&gt;scm_hashtable[(i)].dhe_control =	0;								\
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH_VACATE</span>(scm, i)		DRT_HASH_SET_COUNT((scm), (i), DRT_HASH_COUNT_MASK)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH_VACANT</span>(scm, i)		(DRT_HASH_GET_COUNT((scm), (i)) == DRT_HASH_COUNT_MASK)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH_COPY</span>(oscm, oi, scm, i)									\
	<span class="enscript-keyword">do</span> {												\
		(scm)-&gt;scm_hashtable[(i)].dhe_control = (oscm)-&gt;scm_hashtable[(oi)].dhe_control;	\
		DRT_BITVECTOR_COPY(oscm, oi, scm, i);							\
	} <span class="enscript-keyword">while</span>(0);


<span class="enscript-comment">/*
 * Hash table moduli.
 *
 * Since the hashtable entry's size is dependent on the size of
 * the bitvector, and since the hashtable size is constrained to
 * both being prime and fitting within the desired allocation
 * size, these values need to be manually determined.
 *
 * For DRT_BITVECTOR_SIZE = 256, the entry size is 40 bytes.
 *
 * The small hashtable allocation is 1024 bytes, so the modulus is 23.
 * The large hashtable allocation is 16384 bytes, so the modulus is 401.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_HASH_SMALL_MODULUS</span>	23
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_HASH_LARGE_MODULUS</span>	401

<span class="enscript-comment">/*
 * Physical memory required before the large hash modulus is permitted.
 *
 * On small memory systems, the large hash modulus can lead to phsyical
 * memory starvation, so we avoid using it there.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_HASH_LARGE_MEMORY_REQUIRED</span>	(1024LL * 1024LL * 1024LL)	<span class="enscript-comment">/* 1GiB */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_SMALL_ALLOCATION</span>	1024	<span class="enscript-comment">/* 104 bytes spare */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_LARGE_ALLOCATION</span>	16384	<span class="enscript-comment">/* 344 bytes spare */</span>

<span class="enscript-comment">/* *** nothing below here has secret dependencies on DRT_BITVECTOR_PAGES *** */</span>

<span class="enscript-comment">/*
 * Hashtable bitvector handling.
 *
 * Bitvector fields are 32 bits long.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH_SET_BIT</span>(scm, i, bit)				\
	(scm)-&gt;scm_hashtable[(i)].dhe_bitvector[(bit) / 32] |= (1 &lt;&lt; ((bit) % 32))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH_CLEAR_BIT</span>(scm, i, bit)				\
	(scm)-&gt;scm_hashtable[(i)].dhe_bitvector[(bit) / 32] &amp;= ~(1 &lt;&lt; ((bit) % 32))
    
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH_TEST_BIT</span>(scm, i, bit) 				\
	((scm)-&gt;scm_hashtable[(i)].dhe_bitvector[(bit) / 32] &amp; (1 &lt;&lt; ((bit) % 32)))
    
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_BITVECTOR_CLEAR</span>(scm, i) 				\
	bzero(&amp;(scm)-&gt;scm_hashtable[(i)].dhe_bitvector[0], (DRT_BITVECTOR_PAGES / 32) * <span class="enscript-keyword">sizeof</span>(u_int32_t))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_BITVECTOR_COPY</span>(oscm, oi, scm, i)			\
	bcopy(&amp;(oscm)-&gt;scm_hashtable[(oi)].dhe_bitvector[0],	\
	    &amp;(scm)-&gt;scm_hashtable[(i)].dhe_bitvector[0],	\
	    (DRT_BITVECTOR_PAGES / 32) * <span class="enscript-keyword">sizeof</span>(u_int32_t))


 
<span class="enscript-comment">/*
 * Hashtable entry.
 */</span>
<span class="enscript-type">struct</span> vfs_drt_hashentry {
	u_int64_t	dhe_control;
<span class="enscript-comment">/*
* dhe_bitvector was declared as dhe_bitvector[DRT_BITVECTOR_PAGES / 32];
* DRT_BITVECTOR_PAGES is defined as ((1024 * 1024) / PAGE_SIZE)
* Since PAGE_SIZE is only known at boot time, 
*	-define MAX_DRT_BITVECTOR_PAGES for smallest supported page size (4k) 
*	-declare dhe_bitvector array for largest possible length
*/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_DRT_BITVECTOR_PAGES</span> (1024 * 1024)/( 4 * 1024)
	u_int32_t	dhe_bitvector[MAX_DRT_BITVECTOR_PAGES/32];
};

<span class="enscript-comment">/*
 * Dirty Region Tracking structure.
 *
 * The hashtable is allocated entirely inside the DRT structure.
 *
 * The hash is a simple circular prime modulus arrangement, the structure
 * is resized from small to large if it overflows.
 */</span>

<span class="enscript-type">struct</span> vfs_drt_clustermap {
	u_int32_t		scm_magic;	<span class="enscript-comment">/* sanity/detection */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_SCM_MAGIC</span>		0x12020003
	u_int32_t		scm_modulus;	<span class="enscript-comment">/* current ring size */</span>
	u_int32_t		scm_buckets;	<span class="enscript-comment">/* number of occupied buckets */</span>
	u_int32_t		scm_lastclean;	<span class="enscript-comment">/* last entry we cleaned */</span>
	u_int32_t		scm_iskips;	<span class="enscript-comment">/* number of slot skips */</span>

	<span class="enscript-type">struct</span> vfs_drt_hashentry scm_hashtable[0];
};


#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH</span>(scm, addr)		((addr) % (scm)-&gt;scm_modulus)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DRT_HASH_NEXT</span>(scm, addr)	(((addr) + 1) % (scm)-&gt;scm_modulus)

<span class="enscript-comment">/*
 * Debugging codes and arguments.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_DEBUG_EMPTYFREE</span>	(FSDBG_CODE(DBG_FSRW, 82)) <span class="enscript-comment">/* nil */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_DEBUG_RETCLUSTER</span>	(FSDBG_CODE(DBG_FSRW, 83)) <span class="enscript-comment">/* offset, length */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_DEBUG_ALLOC</span>		(FSDBG_CODE(DBG_FSRW, 84)) <span class="enscript-comment">/* copycount */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_DEBUG_INSERT</span>	(FSDBG_CODE(DBG_FSRW, 85)) <span class="enscript-comment">/* offset, iskip */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_DEBUG_MARK</span>		(FSDBG_CODE(DBG_FSRW, 86)) <span class="enscript-comment">/* offset, length,
							    * dirty */</span>
							   <span class="enscript-comment">/* 0, setcount */</span>
							   <span class="enscript-comment">/* 1 (clean, no map) */</span>
							   <span class="enscript-comment">/* 2 (map alloc fail) */</span>
							   <span class="enscript-comment">/* 3, resid (partial) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_DEBUG_6</span>		(FSDBG_CODE(DBG_FSRW, 87))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DRT_DEBUG_SCMDATA</span>	(FSDBG_CODE(DBG_FSRW, 88)) <span class="enscript-comment">/* modulus, buckets,
							    * lastclean, iskips */</span>


<span class="enscript-type">static</span> kern_return_t	vfs_drt_alloc_map(<span class="enscript-type">struct</span> vfs_drt_clustermap **cmapp);
<span class="enscript-type">static</span> kern_return_t	vfs_drt_free_map(<span class="enscript-type">struct</span> vfs_drt_clustermap *cmap);
<span class="enscript-type">static</span> kern_return_t	vfs_drt_search_index(<span class="enscript-type">struct</span> vfs_drt_clustermap *cmap,
	u_int64_t offset, <span class="enscript-type">int</span> *indexp);
<span class="enscript-type">static</span> kern_return_t	vfs_drt_get_index(<span class="enscript-type">struct</span> vfs_drt_clustermap **cmapp,
	u_int64_t offset,
	<span class="enscript-type">int</span> *indexp,
	<span class="enscript-type">int</span> recursed);
<span class="enscript-type">static</span> kern_return_t	vfs_drt_do_mark_pages(
	<span class="enscript-type">void</span>		**cmapp,
	u_int64_t	offset,
	u_int    	length,
	u_int		*setcountp,
	<span class="enscript-type">int</span>		dirty);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		vfs_drt_trace(
	<span class="enscript-type">struct</span> vfs_drt_clustermap *cmap,
	<span class="enscript-type">int</span> code,
	<span class="enscript-type">int</span> arg1,
	<span class="enscript-type">int</span> arg2,
	<span class="enscript-type">int</span> arg3,
	<span class="enscript-type">int</span> arg4);


<span class="enscript-comment">/*
 * Allocate and initialise a sparse cluster map.
 *
 * Will allocate a new map, resize or compact an existing map.
 *
 * XXX we should probably have at least one intermediate map size,
 * as the 1:16 ratio seems a bit drastic.
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">vfs_drt_alloc_map</span>(<span class="enscript-type">struct</span> vfs_drt_clustermap **cmapp)
{
	<span class="enscript-type">struct</span> vfs_drt_clustermap *cmap, *ocmap;
	kern_return_t	kret;
	u_int64_t	offset;
	u_int32_t	i;
	<span class="enscript-type">int</span>		nsize, active_buckets, index, copycount;

	ocmap = NULL;
	<span class="enscript-keyword">if</span> (cmapp != NULL)
		ocmap = *cmapp;
	
	<span class="enscript-comment">/*
	 * Decide on the size of the new map.
	 */</span>
	<span class="enscript-keyword">if</span> (ocmap == NULL) {
		nsize = DRT_HASH_SMALL_MODULUS;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* count the number of active buckets in the old map */</span>
		active_buckets = 0;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; ocmap-&gt;scm_modulus; i++) {
			<span class="enscript-keyword">if</span> (!DRT_HASH_VACANT(ocmap, i) &amp;&amp;
			    (DRT_HASH_GET_COUNT(ocmap, i) != 0))
				active_buckets++;
		}
		<span class="enscript-comment">/*
		 * If we're currently using the small allocation, check to
		 * see whether we should grow to the large one.
		 */</span>
		<span class="enscript-keyword">if</span> (ocmap-&gt;scm_modulus == DRT_HASH_SMALL_MODULUS) {
			<span class="enscript-comment">/* 
			 * If the ring is nearly full and we are allowed to
			 * use the large modulus, upgrade.
			 */</span>
			<span class="enscript-keyword">if</span> ((active_buckets &gt; (DRT_HASH_SMALL_MODULUS - 5)) &amp;&amp;
			    (max_mem &gt;= DRT_HASH_LARGE_MEMORY_REQUIRED)) {
				nsize = DRT_HASH_LARGE_MODULUS;
			} <span class="enscript-keyword">else</span> {
				nsize = DRT_HASH_SMALL_MODULUS;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* already using the large modulus */</span>
			nsize = DRT_HASH_LARGE_MODULUS;
			<span class="enscript-comment">/*
			 * If the ring is completely full, there's
			 * nothing useful for us to do.  Behave as
			 * though we had compacted into the new
			 * array and return.
			 */</span>
			<span class="enscript-keyword">if</span> (active_buckets &gt;= DRT_HASH_LARGE_MODULUS)
				<span class="enscript-keyword">return</span>(KERN_SUCCESS);
		}
	}

	<span class="enscript-comment">/*
	 * Allocate and initialise the new map.
	 */</span>

	kret = kmem_alloc(kernel_map, (vm_offset_t *)&amp;cmap,
	    (nsize == DRT_HASH_SMALL_MODULUS) ? DRT_SMALL_ALLOCATION : DRT_LARGE_ALLOCATION, VM_KERN_MEMORY_FILE);
	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
		<span class="enscript-keyword">return</span>(kret);
	cmap-&gt;scm_magic = DRT_SCM_MAGIC;
	cmap-&gt;scm_modulus = nsize;
	cmap-&gt;scm_buckets = 0;
	cmap-&gt;scm_lastclean = 0;
	cmap-&gt;scm_iskips = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; cmap-&gt;scm_modulus; i++) {
	        DRT_HASH_CLEAR(cmap, i);
		DRT_HASH_VACATE(cmap, i);
		DRT_BITVECTOR_CLEAR(cmap, i);
	}

	<span class="enscript-comment">/*
	 * If there's an old map, re-hash entries from it into the new map.
	 */</span>
	copycount = 0;
	<span class="enscript-keyword">if</span> (ocmap != NULL) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; ocmap-&gt;scm_modulus; i++) {
			<span class="enscript-comment">/* skip empty buckets */</span>
			<span class="enscript-keyword">if</span> (DRT_HASH_VACANT(ocmap, i) ||
			    (DRT_HASH_GET_COUNT(ocmap, i) == 0))
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/* get new index */</span>
			offset = DRT_HASH_GET_ADDRESS(ocmap, i);
			kret = vfs_drt_get_index(&amp;cmap, offset, &amp;index, 1);
			<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
				<span class="enscript-comment">/* XXX need to bail out gracefully here */</span>
				panic(<span class="enscript-string">&quot;vfs_drt: new cluster map mysteriously too small&quot;</span>);
				index = 0;
			}
			<span class="enscript-comment">/* copy */</span>
			DRT_HASH_COPY(ocmap, i, cmap, index);
			copycount++;
		}
	}

	<span class="enscript-comment">/* log what we've done */</span>
	vfs_drt_trace(cmap, DRT_DEBUG_ALLOC, copycount, 0, 0, 0);
	
	<span class="enscript-comment">/*
	 * It's important to ensure that *cmapp always points to 
	 * a valid map, so we must overwrite it before freeing
	 * the old map.
	 */</span>
	*cmapp = cmap;
	<span class="enscript-keyword">if</span> (ocmap != NULL) {
		<span class="enscript-comment">/* emit stats into trace buffer */</span>
		vfs_drt_trace(ocmap, DRT_DEBUG_SCMDATA,
			      ocmap-&gt;scm_modulus,
			      ocmap-&gt;scm_buckets,
			      ocmap-&gt;scm_lastclean,
			      ocmap-&gt;scm_iskips);

		vfs_drt_free_map(ocmap);
	}
	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}


<span class="enscript-comment">/*
 * Free a sparse cluster map.
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">vfs_drt_free_map</span>(<span class="enscript-type">struct</span> vfs_drt_clustermap *cmap)
{
	kmem_free(kernel_map, (vm_offset_t)cmap, 
		  (cmap-&gt;scm_modulus == DRT_HASH_SMALL_MODULUS) ? DRT_SMALL_ALLOCATION : DRT_LARGE_ALLOCATION);
	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}


<span class="enscript-comment">/*
 * Find the hashtable slot currently occupied by an entry for the supplied offset.
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">vfs_drt_search_index</span>(<span class="enscript-type">struct</span> vfs_drt_clustermap *cmap, u_int64_t offset, <span class="enscript-type">int</span> *indexp)
{
	<span class="enscript-type">int</span>		index;
	u_int32_t	i;

	offset = DRT_ALIGN_ADDRESS(offset);
	index = DRT_HASH(cmap, offset);

	<span class="enscript-comment">/* traverse the hashtable */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; cmap-&gt;scm_modulus; i++) {

		<span class="enscript-comment">/*
		 * If the slot is vacant, we can stop.
		 */</span>
		<span class="enscript-keyword">if</span> (DRT_HASH_VACANT(cmap, index))
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * If the address matches our offset, we have success.
		 */</span>
		<span class="enscript-keyword">if</span> (DRT_HASH_GET_ADDRESS(cmap, index) == offset) {
			*indexp = index;
			<span class="enscript-keyword">return</span>(KERN_SUCCESS);
		}

		<span class="enscript-comment">/*
		 * Move to the next slot, try again.
		 */</span>
		index = DRT_HASH_NEXT(cmap, index);
	}
	<span class="enscript-comment">/*
	 * It's not there.
	 */</span>
	<span class="enscript-keyword">return</span>(KERN_FAILURE);
}

<span class="enscript-comment">/*
 * Find the hashtable slot for the supplied offset.  If we haven't allocated
 * one yet, allocate one and populate the address field.  Note that it will
 * not have a nonzero page count and thus will still technically be free, so
 * in the case where we are called to clean pages, the slot will remain free.
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">vfs_drt_get_index</span>(<span class="enscript-type">struct</span> vfs_drt_clustermap **cmapp, u_int64_t offset, <span class="enscript-type">int</span> *indexp, <span class="enscript-type">int</span> recursed)
{
	<span class="enscript-type">struct</span> vfs_drt_clustermap *cmap;
	kern_return_t	kret;
	u_int32_t	index;
	u_int32_t	i;

	cmap = *cmapp;

	<span class="enscript-comment">/* look for an existing entry */</span>
	kret = vfs_drt_search_index(cmap, offset, indexp);
	<span class="enscript-keyword">if</span> (kret == KERN_SUCCESS)
		<span class="enscript-keyword">return</span>(kret);

	<span class="enscript-comment">/* need to allocate an entry */</span>
	offset = DRT_ALIGN_ADDRESS(offset);
	index = DRT_HASH(cmap, offset);

	<span class="enscript-comment">/* scan from the index forwards looking for a vacant slot */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; cmap-&gt;scm_modulus; i++) {
		<span class="enscript-comment">/* slot vacant? */</span>
		<span class="enscript-keyword">if</span> (DRT_HASH_VACANT(cmap, index) || DRT_HASH_GET_COUNT(cmap,index) == 0) {
			cmap-&gt;scm_buckets++;
			<span class="enscript-keyword">if</span> (index &lt; cmap-&gt;scm_lastclean)
				cmap-&gt;scm_lastclean = index;
			DRT_HASH_SET_ADDRESS(cmap, index, offset);
			DRT_HASH_SET_COUNT(cmap, index, 0);
			DRT_BITVECTOR_CLEAR(cmap, index);
			*indexp = index;
			vfs_drt_trace(cmap, DRT_DEBUG_INSERT, (<span class="enscript-type">int</span>)offset, i, 0, 0);
			<span class="enscript-keyword">return</span>(KERN_SUCCESS);
		}
		cmap-&gt;scm_iskips += i;
		index = DRT_HASH_NEXT(cmap, index);
	}

	<span class="enscript-comment">/*
	 * We haven't found a vacant slot, so the map is full.  If we're not
	 * already recursed, try reallocating/compacting it.
	 */</span>
	<span class="enscript-keyword">if</span> (recursed)
		<span class="enscript-keyword">return</span>(KERN_FAILURE);
	kret = vfs_drt_alloc_map(cmapp);
	<span class="enscript-keyword">if</span> (kret == KERN_SUCCESS) {
		<span class="enscript-comment">/* now try to insert again */</span>
		kret = vfs_drt_get_index(cmapp, offset, indexp, 1);
	}
	<span class="enscript-keyword">return</span>(kret);
}

<span class="enscript-comment">/*
 * Implementation of set dirty/clean.
 *
 * In the 'clean' case, not finding a map is OK.
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">vfs_drt_do_mark_pages</span>(
	<span class="enscript-type">void</span>		**private,
	u_int64_t	offset,
	u_int    	length,
	u_int		*setcountp,
	<span class="enscript-type">int</span>		dirty)
{
	<span class="enscript-type">struct</span> vfs_drt_clustermap *cmap, **cmapp;
	kern_return_t	kret;
	<span class="enscript-type">int</span>		i, index, pgoff, pgcount, setcount, ecount;

	cmapp = (<span class="enscript-type">struct</span> vfs_drt_clustermap **)private;
	cmap = *cmapp;

	vfs_drt_trace(cmap, DRT_DEBUG_MARK | DBG_FUNC_START, (<span class="enscript-type">int</span>)offset, (<span class="enscript-type">int</span>)length, dirty, 0);

	<span class="enscript-keyword">if</span> (setcountp != NULL)
	        *setcountp = 0;
	
	<span class="enscript-comment">/* allocate a cluster map if we don't already have one */</span>
	<span class="enscript-keyword">if</span> (cmap == NULL) {
		<span class="enscript-comment">/* no cluster map, nothing to clean */</span>
		<span class="enscript-keyword">if</span> (!dirty) {
			vfs_drt_trace(cmap, DRT_DEBUG_MARK | DBG_FUNC_END, 1, 0, 0, 0);
			<span class="enscript-keyword">return</span>(KERN_SUCCESS);
		}
		kret = vfs_drt_alloc_map(cmapp);
		<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
			vfs_drt_trace(cmap, DRT_DEBUG_MARK | DBG_FUNC_END, 2, 0, 0, 0);
			<span class="enscript-keyword">return</span>(kret);
		}
	}
	setcount = 0;

	<span class="enscript-comment">/*
	 * Iterate over the length of the region.
	 */</span>
	<span class="enscript-keyword">while</span> (length &gt; 0) {
		<span class="enscript-comment">/*
		 * Get the hashtable index for this offset.
		 *
		 * XXX this will add blank entries if we are clearing a range
		 * that hasn't been dirtied.
		 */</span>
		kret = vfs_drt_get_index(cmapp, offset, &amp;index, 0);
		cmap = *cmapp;	<span class="enscript-comment">/* may have changed! */</span>
		<span class="enscript-comment">/* this may be a partial-success return */</span>
		<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
		        <span class="enscript-keyword">if</span> (setcountp != NULL)
			        *setcountp = setcount;
			vfs_drt_trace(cmap, DRT_DEBUG_MARK | DBG_FUNC_END, 3, (<span class="enscript-type">int</span>)length, 0, 0);

			<span class="enscript-keyword">return</span>(kret);
		}

		<span class="enscript-comment">/*
		 * Work out how many pages we're modifying in this
		 * hashtable entry.
		 */</span>
		pgoff = (offset - DRT_ALIGN_ADDRESS(offset)) / PAGE_SIZE;
		pgcount = min((length / PAGE_SIZE), (DRT_BITVECTOR_PAGES - pgoff));

		<span class="enscript-comment">/*
		 * Iterate over pages, dirty/clearing as we go.
		 */</span>
		ecount = DRT_HASH_GET_COUNT(cmap, index);
		<span class="enscript-keyword">for</span> (i = 0; i &lt; pgcount; i++) {
			<span class="enscript-keyword">if</span> (dirty) {
				<span class="enscript-keyword">if</span> (!DRT_HASH_TEST_BIT(cmap, index, pgoff + i)) {
					DRT_HASH_SET_BIT(cmap, index, pgoff + i);
					ecount++;
					setcount++;
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (DRT_HASH_TEST_BIT(cmap, index, pgoff + i)) {
					DRT_HASH_CLEAR_BIT(cmap, index, pgoff + i);
					ecount--;
					setcount++;
				}
			}
		}
		DRT_HASH_SET_COUNT(cmap, index, ecount);

		offset += pgcount * PAGE_SIZE;
		length -= pgcount * PAGE_SIZE;
	}
	<span class="enscript-keyword">if</span> (setcountp != NULL)
		*setcountp = setcount;

	vfs_drt_trace(cmap, DRT_DEBUG_MARK | DBG_FUNC_END, 0, setcount, 0, 0);

	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Mark a set of pages as dirty/clean.
 *
 * This is a public interface.
 *
 * cmapp
 *	Pointer to storage suitable for holding a pointer.  Note that
 *	this must either be NULL or a value set by this function.
 *
 * size
 *	Current file size in bytes.
 *
 * offset
 *	Offset of the first page to be marked as dirty, in bytes.  Must be
 *	page-aligned.
 *
 * length
 *	Length of dirty region, in bytes.  Must be a multiple of PAGE_SIZE.
 *
 * setcountp
 *	Number of pages newly marked dirty by this call (optional).
 *
 * Returns KERN_SUCCESS if all the pages were successfully marked.
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">vfs_drt_mark_pages</span>(<span class="enscript-type">void</span> **cmapp, off_t offset, u_int length, u_int *setcountp)
{
	<span class="enscript-comment">/* XXX size unused, drop from interface */</span>
	<span class="enscript-keyword">return</span>(vfs_drt_do_mark_pages(cmapp, offset, length, setcountp, 1));
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">vfs_drt_unmark_pages</span>(<span class="enscript-type">void</span> **cmapp, off_t offset, u_int length)
{
	<span class="enscript-keyword">return</span>(vfs_drt_do_mark_pages(cmapp, offset, length, NULL, 0));
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Get a cluster of dirty pages.
 *
 * This is a public interface.
 *
 * cmapp
 *	Pointer to storage managed by drt_mark_pages.  Note that this must
 *	be NULL or a value set by drt_mark_pages.
 *
 * offsetp
 *	Returns the byte offset into the file of the first page in the cluster.
 *
 * lengthp
 *	Returns the length in bytes of the cluster of dirty pages.
 *
 * Returns success if a cluster was found.  If KERN_FAILURE is returned, there
 * are no dirty pages meeting the minmum size criteria.  Private storage will
 * be released if there are no more dirty pages left in the map
 *
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">vfs_drt_get_cluster</span>(<span class="enscript-type">void</span> **cmapp, off_t *offsetp, u_int *lengthp)
{
	<span class="enscript-type">struct</span> vfs_drt_clustermap *cmap;
	u_int64_t	offset;
	u_int		length;
	u_int32_t	j;
	<span class="enscript-type">int</span>		index, i, fs, ls;

	<span class="enscript-comment">/* sanity */</span>
	<span class="enscript-keyword">if</span> ((cmapp == NULL) || (*cmapp == NULL))
		<span class="enscript-keyword">return</span>(KERN_FAILURE);
	cmap = *cmapp;

	<span class="enscript-comment">/* walk the hashtable */</span>
	<span class="enscript-keyword">for</span> (offset = 0, j = 0; j &lt; cmap-&gt;scm_modulus; offset += (DRT_BITVECTOR_PAGES * PAGE_SIZE), j++) {
	        index = DRT_HASH(cmap, offset);

	        <span class="enscript-keyword">if</span> (DRT_HASH_VACANT(cmap, index) || (DRT_HASH_GET_COUNT(cmap, index) == 0))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* scan the bitfield for a string of bits */</span>
		fs = -1;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; DRT_BITVECTOR_PAGES; i++) {
		        <span class="enscript-keyword">if</span> (DRT_HASH_TEST_BIT(cmap, index, i)) {
			        fs = i;
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (fs == -1) {
		        <span class="enscript-comment">/*  didn't find any bits set */</span>
		        panic(<span class="enscript-string">&quot;vfs_drt: entry summary count &gt; 0 but no bits set in map&quot;</span>);
		}
		<span class="enscript-keyword">for</span> (ls = 0; i &lt; DRT_BITVECTOR_PAGES; i++, ls++) {
			<span class="enscript-keyword">if</span> (!DRT_HASH_TEST_BIT(cmap, index, i))
			        <span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-comment">/* compute offset and length, mark pages clean */</span>
		offset = DRT_HASH_GET_ADDRESS(cmap, index) + (PAGE_SIZE * fs);
		length = ls * PAGE_SIZE;
		vfs_drt_do_mark_pages(cmapp, offset, length, NULL, 0);
		cmap-&gt;scm_lastclean = index;

		<span class="enscript-comment">/* return successful */</span>
		*offsetp = (off_t)offset;
		*lengthp = length;

		vfs_drt_trace(cmap, DRT_DEBUG_RETCLUSTER, (<span class="enscript-type">int</span>)offset, (<span class="enscript-type">int</span>)length, 0, 0);
		<span class="enscript-keyword">return</span>(KERN_SUCCESS);
	}
	<span class="enscript-comment">/*
	 * We didn't find anything... hashtable is empty
	 * emit stats into trace buffer and
	 * then free it
	 */</span>
	vfs_drt_trace(cmap, DRT_DEBUG_SCMDATA,
		      cmap-&gt;scm_modulus,
		      cmap-&gt;scm_buckets,
		      cmap-&gt;scm_lastclean,
		      cmap-&gt;scm_iskips);
	
	vfs_drt_free_map(cmap);
	*cmapp = NULL;

	<span class="enscript-keyword">return</span>(KERN_FAILURE);
}


<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">vfs_drt_control</span>(<span class="enscript-type">void</span> **cmapp, <span class="enscript-type">int</span> op_type)
{
	<span class="enscript-type">struct</span> vfs_drt_clustermap *cmap;

	<span class="enscript-comment">/* sanity */</span>
	<span class="enscript-keyword">if</span> ((cmapp == NULL) || (*cmapp == NULL))
		<span class="enscript-keyword">return</span>(KERN_FAILURE);
	cmap = *cmapp;

	<span class="enscript-keyword">switch</span> (op_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		<span class="enscript-comment">/* emit stats into trace buffer */</span>
		vfs_drt_trace(cmap, DRT_DEBUG_SCMDATA,
			      cmap-&gt;scm_modulus,
			      cmap-&gt;scm_buckets,
			      cmap-&gt;scm_lastclean,
			      cmap-&gt;scm_iskips);

		vfs_drt_free_map(cmap);
		*cmapp = NULL;
	        <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
	        cmap-&gt;scm_lastclean = 0;
	        <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}



<span class="enscript-comment">/*
 * Emit a summary of the state of the clustermap into the trace buffer
 * along with some caller-provided data.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KDEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_drt_trace</span>(__unused <span class="enscript-type">struct</span> vfs_drt_clustermap *cmap, <span class="enscript-type">int</span> code, <span class="enscript-type">int</span> arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">int</span> arg3, <span class="enscript-type">int</span> arg4)
{
	KERNEL_DEBUG(code, arg1, arg2, arg3, arg4, 0);
}
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_drt_trace</span>(__unused <span class="enscript-type">struct</span> vfs_drt_clustermap *cmap, __unused <span class="enscript-type">int</span> code, 
			  __unused <span class="enscript-type">int</span> arg1, __unused <span class="enscript-type">int</span> arg2, __unused <span class="enscript-type">int</span> arg3, 
			  __unused <span class="enscript-type">int</span> arg4)
{
}
#<span class="enscript-reference">endif</span> 

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 * Perform basic sanity check on the hash entry summary count
 * vs. the actual bits set in the entry.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_drt_sanity</span>(<span class="enscript-type">struct</span> vfs_drt_clustermap *cmap)
{
        <span class="enscript-type">int</span> index, i;
	<span class="enscript-type">int</span> bits_on;
	
	<span class="enscript-keyword">for</span> (index = 0; index &lt; cmap-&gt;scm_modulus; index++) {
	        <span class="enscript-keyword">if</span> (DRT_HASH_VACANT(cmap, index))
		        <span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">for</span> (bits_on = 0, i = 0; i &lt; DRT_BITVECTOR_PAGES; i++) {
			<span class="enscript-keyword">if</span> (DRT_HASH_TEST_BIT(cmap, index, i))
			        bits_on++;
		}
		<span class="enscript-keyword">if</span> (bits_on != DRT_HASH_GET_COUNT(cmap, index))
		        panic(<span class="enscript-string">&quot;bits_on = %d,  index = %d\n&quot;</span>, bits_on, index);
	}		
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>