<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_syscalls.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_syscalls.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1995-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)vfs_syscalls.c	8.41 (Berkeley) 6/15/95
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mman.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dirent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/attr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/quota.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsevents.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/imgsrc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/xattr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/content_protection.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/cons.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/limits.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit_kevents.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOBSD.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span> 
#<span class="enscript-reference">define</span> <span class="enscript-function-name">GET_PATH</span>(x) \
	(x) = get_pathbuff(); 
#<span class="enscript-reference">define</span> <span class="enscript-function-name">RELEASE_PATH</span>(x) \
	release_pathbuff(x);
#<span class="enscript-reference">else</span> 
#<span class="enscript-reference">define</span> <span class="enscript-function-name">GET_PATH</span>(x)	\
	MALLOC_ZONE((x), <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK); 
#<span class="enscript-reference">define</span> <span class="enscript-function-name">RELEASE_PATH</span>(x) \
	FREE_ZONE((x), MAXPATHLEN, M_NAMEI);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FSE */</span>

<span class="enscript-comment">/* struct for checkdirs iteration */</span>
<span class="enscript-type">struct</span> cdirargs {
	vnode_t olddp;
	vnode_t newdp;
};
<span class="enscript-comment">/* callback  for checkdirs iteration */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">checkdirs_callback</span>(proc_t p, <span class="enscript-type">void</span> * arg);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">change_dir</span>(<span class="enscript-type">struct</span> nameidata *ndp, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">checkdirs</span>(vnode_t olddp, vfs_context_t ctx);
<span class="enscript-type">void</span> <span class="enscript-function-name">enablequotas</span>(<span class="enscript-type">struct</span> mount *mp, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">getfsstat_callback</span>(mount_t mp, <span class="enscript-type">void</span> * arg);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">getutimes</span>(user_addr_t usrtvp, <span class="enscript-type">struct</span> timespec *tsp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">setutimes</span>(vfs_context_t ctx, vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> timespec *ts, <span class="enscript-type">int</span> nullflag);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sync_callback</span>(mount_t, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">sync_thread</span>(<span class="enscript-type">void</span> *, __unused wait_result_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sync_async</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">munge_statfs</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vfsstatfs *sfsp, 
			user_addr_t bufp, <span class="enscript-type">int</span> *sizep, boolean_t is_64_bit, 
						boolean_t partial_copy);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">statfs64_common</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vfsstatfs *sfsp,
			user_addr_t bufp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">fsync_common</span>(proc_t p, <span class="enscript-type">struct</span> fsync_args *uap, <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mount_common</span>(<span class="enscript-type">char</span> *fstypename, vnode_t pvp, vnode_t vp,
                        <span class="enscript-type">struct</span> componentname *cnp, user_addr_t fsmountargs,
                        <span class="enscript-type">int</span> flags, uint32_t internal_flags, <span class="enscript-type">char</span> *labelstr, boolean_t kernelmount,
                        vfs_context_t ctx);
<span class="enscript-type">void</span> <span class="enscript-function-name">vfs_notify_mount</span>(vnode_t pdvp);

<span class="enscript-type">int</span> <span class="enscript-function-name">prepare_coveredvp</span>(vnode_t vp, vfs_context_t ctx, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fsname, boolean_t skip_auth);

<span class="enscript-type">struct</span> fd_vn_data * <span class="enscript-function-name">fg_vn_data_alloc</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 * Max retries for ENOENT returns from vn_authorize_{rmdir, unlink, rename}
 * Concurrent lookups (or lookups by ids) on hard links can cause the
 * vn_getpath (which does not re-enter the filesystem as vn_getpath_fsenter
 * does) to return ENOENT as the path cannot be returned from the name cache
 * alone. We have no option but to retry and hope to get one namei-&gt;reverse path
 * generation done without an intervening lookup, lookup by id on the hard link
 * item. This is only an issue for MAC hooks which cannot reenter the filesystem
 * which currently are the MAC hooks for rename, unlink and rmdir.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_AUTHORIZE_ENOENT_RETRIES</span> 1024

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rmdirat_internal</span>(vfs_context_t, <span class="enscript-type">int</span>, user_addr_t, <span class="enscript-type">enum</span> uio_seg);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">fsgetpath_internal</span>(vfs_context_t, <span class="enscript-type">int</span>, uint64_t, vm_size_t, caddr_t, <span class="enscript-type">int</span> *);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_IMGSRC_ACCESS</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">authorize_devpath_and_update_mntfromname</span>(mount_t mp, user_addr_t devpath, vnode_t *devvpp, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">place_mount_and_checkdirs</span>(mount_t mp, vnode_t vp, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">undo_place_on_covered_vp</span>(mount_t mp, vnode_t vp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mount_begin_update</span>(mount_t mp, vfs_context_t ctx, <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mount_end_update</span>(mount_t mp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">relocate_imageboot_source</span>(vnode_t pvp, vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fsname, vfs_context_t ctx, boolean_t is64bit, user_addr_t fsmountargs, boolean_t by_index);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IMGSRC_ACCESS */</span>

<span class="enscript-function-name">int</span> (*union_dircheckp)(<span class="enscript-type">struct</span> vnode **, <span class="enscript-type">struct</span> fileproc *, vfs_context_t);

__private_extern__
<span class="enscript-type">int</span> <span class="enscript-function-name">sync_internal</span>(<span class="enscript-type">void</span>);

__private_extern__
<span class="enscript-type">int</span> <span class="enscript-function-name">unlink1</span>(vfs_context_t, vnode_t, user_addr_t, <span class="enscript-type">enum</span> uio_seg, <span class="enscript-type">int</span>);

<span class="enscript-type">extern</span> lck_grp_t *fd_vn_lck_grp;
<span class="enscript-type">extern</span> lck_grp_attr_t *fd_vn_lck_grp_attr;
<span class="enscript-type">extern</span> lck_attr_t *fd_vn_lck_attr;

<span class="enscript-comment">/*
 * incremented each time a mount or unmount operation occurs
 * used to invalidate the cached value of the rootvp in the
 * mount structure utilized by cache_lookup_path
 */</span>
uint32_t mount_generation = 0;

<span class="enscript-comment">/* counts number of mount and unmount operations */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vfs_nummntops=0;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> fileops vnops;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
<span class="enscript-type">extern</span> errno_t <span class="enscript-function-name">rmdir_remove_orphaned_appleDouble</span>(vnode_t, vfs_context_t, <span class="enscript-type">int</span> *); 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>

<span class="enscript-type">typedef</span> uint32_t vfs_rename_flags_t;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SECLUDED_RENAME</span>
<span class="enscript-type">enum</span> {
	VFS_SECLUDE_RENAME		= 0x00000001
};
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Virtual File System System Calls
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span> || <span class="enscript-variable-name">DEVFS</span>
<span class="enscript-comment">/*
 * Private in-kernel mounting spi (NFS only, not exported)
 */</span>
 __private_extern__
boolean_t
<span class="enscript-function-name">vfs_iskernelmount</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span> ((mp-&gt;mnt_kern_flag &amp; MNTK_KERNEL_MOUNT) ? TRUE : FALSE);
}

 __private_extern__
<span class="enscript-type">int</span>
<span class="enscript-function-name">kernel_mount</span>(<span class="enscript-type">char</span> *fstype, vnode_t pvp, vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *path,
             <span class="enscript-type">void</span> *data, __unused size_t datalen, <span class="enscript-type">int</span> syscall_flags, __unused uint32_t kern_flags, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nameidata nd;
	boolean_t did_namei;
	<span class="enscript-type">int</span> error;

	NDINIT(&amp;nd, LOOKUP, OP_MOUNT, FOLLOW | AUDITVNPATH1 | WANTPARENT, 
	       UIO_SYSSPACE, CAST_USER_ADDR_T(path), ctx);

	<span class="enscript-comment">/*
	 * Get the vnode to be covered if it's not supplied
	 */</span>
	<span class="enscript-keyword">if</span> (vp == NULLVP) {
		error = namei(&amp;nd);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		vp = nd.ni_vp;
		pvp = nd.ni_dvp;
		did_namei = TRUE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">char</span> *pnbuf = CAST_DOWN(<span class="enscript-type">char</span> *, path);

		nd.ni_cnd.cn_pnbuf = pnbuf;
		nd.ni_cnd.cn_pnlen = strlen(pnbuf) + 1;
		did_namei = FALSE;
	}

	error = mount_common(fstype, pvp, vp, &amp;nd.ni_cnd, CAST_USER_ADDR_T(data),
	                     syscall_flags, kern_flags, NULL, TRUE, ctx);

	<span class="enscript-keyword">if</span> (did_namei) {
		vnode_put(vp);
		vnode_put(pvp);
		nameidone(&amp;nd);
	}

	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSCLIENT || DEVFS */</span>

<span class="enscript-comment">/*
 * Mount a file system.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mount</span>(proc_t p, <span class="enscript-type">struct</span> mount_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> __mac_mount_args muap;

	muap.type = uap-&gt;type;
	muap.path = uap-&gt;path;
	muap.flags = uap-&gt;flags;
	muap.data = uap-&gt;data;
	muap.mac_p = USER_ADDR_NULL;
	<span class="enscript-keyword">return</span> (__mac_mount(p, &amp;muap, retval));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_notify_mount</span>(vnode_t pdvp) 
{
	vfs_event_signal(NULL, VQ_MOUNT, (intptr_t)NULL);
	lock_vnode_and_post(pdvp, NOTE_WRITE);
}

<span class="enscript-comment">/*
 * __mac_mount:
 *	Mount a file system taking into account MAC label behavior.
 *	See mount(2) man page for more information
 *
 * Parameters:    p                        Process requesting the mount
 *                uap                      User argument descriptor (see below)
 *                retval                   (ignored)  
 *
 * Indirect:      uap-&gt;type                Filesystem type
 *                uap-&gt;path                Path to mount
 *                uap-&gt;data                Mount arguments  
 *                uap-&gt;mac_p               MAC info              
 *                uap-&gt;flags               Mount flags
 *                
 *
 * Returns:        0                       Success
 *                !0                       Not success
 */</span>
boolean_t root_fs_upgrade_try = FALSE;

<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_mount</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">register</span> <span class="enscript-type">struct</span> __mac_mount_args *uap, __unused int32_t *retval)
{
	vnode_t pvp = NULL;
   	vnode_t vp = NULL;
	<span class="enscript-type">int</span> need_nameidone = 0;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">char</span> fstypename[MFSNAMELEN];
	<span class="enscript-type">struct</span> nameidata nd;
	size_t dummy=0;
	<span class="enscript-type">char</span> *labelstr = NULL;
	<span class="enscript-type">int</span> flags = uap-&gt;flags;
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IMGSRC_ACCESS</span> || <span class="enscript-variable-name">CONFIG_MACF</span> 
	boolean_t is_64bit = IS_64BIT_PROCESS(p);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Get the fs type name from user space
	 */</span>
	error = copyinstr(uap-&gt;type, fstypename, MFSNAMELEN, &amp;dummy);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * Get the vnode to be covered
	 */</span>
	NDINIT(&amp;nd, LOOKUP, OP_MOUNT, FOLLOW | AUDITVNPATH1 | WANTPARENT, 
	       UIO_USERSPACE, uap-&gt;path, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	need_nameidone = 1;
	vp = nd.ni_vp;
	pvp = nd.ni_dvp;
	
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_IMGSRC_ACCESS</span>
	<span class="enscript-comment">/* Mounting image source cannot be batched with other operations */</span>
	<span class="enscript-keyword">if</span> (flags == MNT_IMGSRC_BY_INDEX) {
		error = relocate_imageboot_source(pvp, vp, &amp;nd.ni_cnd, fstypename,
		                                  ctx, is_64bit, uap-&gt;data, (flags == MNT_IMGSRC_BY_INDEX));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IMGSRC_ACCESS */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * Get the label string (if any) from user space
	 */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;mac_p != USER_ADDR_NULL) {
		<span class="enscript-type">struct</span> user_mac mac;
		size_t ulen = 0;

		<span class="enscript-keyword">if</span> (is_64bit) {
			<span class="enscript-type">struct</span> user64_mac mac64;
			error = copyin(uap-&gt;mac_p, &amp;mac64, <span class="enscript-keyword">sizeof</span>(mac64));
			mac.m_buflen = mac64.m_buflen;
			mac.m_string = mac64.m_string;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_mac mac32;
			error = copyin(uap-&gt;mac_p, &amp;mac32, <span class="enscript-keyword">sizeof</span>(mac32));
			mac.m_buflen = mac32.m_buflen;
			mac.m_string = mac32.m_string;
		}
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-keyword">if</span> ((mac.m_buflen &gt; MAC_MAX_LABEL_BUF_LEN) ||
		    (mac.m_buflen &lt; 2)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		MALLOC(labelstr, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK);
		error = copyinstr(mac.m_string, labelstr, mac.m_buflen, &amp;ulen);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		AUDIT_ARG(mac_string, labelstr);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF */</span>

	AUDIT_ARG(fflags, flags);

	<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VROOT) &amp;&amp;
			(vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_ROOTFS)) {
		<span class="enscript-keyword">if</span> (!(flags &amp; MNT_UNION)) {
			flags |= MNT_UPDATE;
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* 
			 * For a union mount on '/', treat it as fresh
			 * mount instead of update. 
			 * Otherwise, union mouting on '/' used to panic the 
			 * system before, since mnt_vnodecovered was found to 
			 * be NULL for '/' which is required for unionlookup 
			 * after it gets ENOENT on union mount.
			 */</span>
			flags = (flags &amp; ~(MNT_UPDATE));
		}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SECURE_KERNEL</span>
		<span class="enscript-keyword">if</span> ((flags &amp; MNT_RDONLY) == 0) {
			<span class="enscript-comment">/* Release kernels are not allowed to mount &quot;/&quot; as rw */</span>
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;	
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/*
		 * See 7392553 for more details on why this check exists.
		 * Suffice to say: If this check is ON and something tries
		 * to mount the rootFS RW, we'll turn off the codesign
		 * bitmap optimization.	 
		 */</span>	   
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CHECK_CS_VALIDATION_BITMAP</span>
		<span class="enscript-keyword">if</span> ((flags &amp; MNT_RDONLY) == 0 ) {
			root_fs_upgrade_try = TRUE;
		}
#<span class="enscript-reference">endif</span>
	}

	error = mount_common(fstypename, pvp, vp, &amp;nd.ni_cnd, uap-&gt;data, flags, 0,
	                     labelstr, FALSE, ctx);

<span class="enscript-reference">out</span>:

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (labelstr)
		FREE(labelstr, M_MACTEMP);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF */</span>

	<span class="enscript-keyword">if</span> (vp) {
		vnode_put(vp);
	}
	<span class="enscript-keyword">if</span> (pvp) {
		vnode_put(pvp);
	}
	<span class="enscript-keyword">if</span> (need_nameidone) {
		nameidone(&amp;nd);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * common mount implementation (final stage of mounting)
 
 * Arguments:
 *  fstypename	file system type (ie it's vfs name)
 *  pvp		parent of covered vnode
 *  vp		covered vnode
 *  cnp		component name (ie path) of covered vnode
 *  flags	generic mount flags
 *  fsmountargs	file system specific data
 *  labelstr	optional MAC label
 *  kernelmount	TRUE for mounts initiated from inside the kernel
 *  ctx		caller's context
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mount_common</span>(<span class="enscript-type">char</span> *fstypename, vnode_t pvp, vnode_t vp,
             <span class="enscript-type">struct</span> componentname *cnp, user_addr_t fsmountargs, <span class="enscript-type">int</span> flags, uint32_t internal_flags,
             <span class="enscript-type">char</span> *labelstr, boolean_t kernelmount, vfs_context_t ctx)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">labelstr</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> vnode *devvp = NULLVP;
	<span class="enscript-type">struct</span> vnode *device_vnode = NULLVP;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">struct</span> vnode *rvp;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> mount *mp;
	<span class="enscript-type">struct</span> vfstable *vfsp = (<span class="enscript-type">struct</span> vfstable *)0;
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(ctx);
	<span class="enscript-type">int</span> error, flag = 0;
	user_addr_t devpath = USER_ADDR_NULL;
	<span class="enscript-type">int</span> ronly = 0;
	<span class="enscript-type">int</span> mntalloc = 0;
	boolean_t vfsp_ref = FALSE;
	boolean_t is_rwlock_locked = FALSE;
	boolean_t did_rele = FALSE;
	boolean_t have_usecount = FALSE;

	<span class="enscript-comment">/*
	 * Process an update for an existing mount
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; MNT_UPDATE) {
		<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VROOT) == 0) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
		mp = vp-&gt;v_mount;

		<span class="enscript-comment">/* unmount in progress return error */</span>
		mount_lock_spin(mp);
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; MNT_LUNMOUNT) {
			mount_unlock(mp);
			error = EBUSY;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
		mount_unlock(mp);
		lck_rw_lock_exclusive(&amp;mp-&gt;mnt_rwlock);
		is_rwlock_locked = TRUE;
		<span class="enscript-comment">/*
		 * We only allow the filesystem to be reloaded if it
		 * is currently mounted read-only.
		 */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; MNT_RELOAD) &amp;&amp;
		    ((mp-&gt;mnt_flag &amp; MNT_RDONLY) == 0)) {
			error = ENOTSUP;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}

		<span class="enscript-comment">/*
		 * If content protection is enabled, update mounts are not
		 * allowed to turn it off.
		 */</span>
		<span class="enscript-keyword">if</span> ((mp-&gt;mnt_flag &amp; MNT_CPROTECT) &amp;&amp; 
			   ((flags &amp; MNT_CPROTECT) == 0)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_IMGSRC_ACCESS</span> 
		<span class="enscript-comment">/* Can't downgrade the backer of the root FS */</span>
		<span class="enscript-keyword">if</span> ((mp-&gt;mnt_kern_flag &amp; MNTK_BACKS_ROOT) &amp;&amp;
			(!vfs_isrdonly(mp)) &amp;&amp; (flags &amp; MNT_RDONLY)) {
			error = ENOTSUP;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IMGSRC_ACCESS */</span>

		<span class="enscript-comment">/*
		 * Only root, or the user that did the original mount is
		 * permitted to update it.
		 */</span>
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_vfsstat.f_owner != kauth_cred_getuid(vfs_context_ucred(ctx)) &amp;&amp;
		    (error = suser(vfs_context_ucred(ctx), &amp;p-&gt;p_acflag))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_mount_check_remount(ctx, mp);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/*
		 * For non-root users, silently enforce MNT_NOSUID and MNT_NODEV,
		 * and MNT_NOEXEC if mount point is already MNT_NOEXEC.
		 */</span>
		<span class="enscript-keyword">if</span> ((!kernelmount) &amp;&amp; suser(vfs_context_ucred(ctx), NULL)) {
			flags |= MNT_NOSUID | MNT_NODEV;
			<span class="enscript-keyword">if</span> (mp-&gt;mnt_flag &amp; MNT_NOEXEC)
				flags |= MNT_NOEXEC;
		}
		flag = mp-&gt;mnt_flag;



		mp-&gt;mnt_flag |= flags &amp; (MNT_RELOAD | MNT_FORCE | MNT_UPDATE);

		vfsp = mp-&gt;mnt_vtable;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">update</span>;
	}
	<span class="enscript-comment">/*
	 * For non-root users, silently enforce MNT_NOSUID and MNT_NODEV, and
	 * MNT_NOEXEC if mount point is already MNT_NOEXEC.
	 */</span>
	<span class="enscript-keyword">if</span> ((!kernelmount) &amp;&amp; suser(vfs_context_ucred(ctx), NULL)) {
		flags |= MNT_NOSUID | MNT_NODEV;
		<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_NOEXEC)
			flags |= MNT_NOEXEC;
	}

	<span class="enscript-comment">/* XXXAUDIT: Should we capture the type on the error path as well? */</span>
	AUDIT_ARG(text, fstypename);
	mount_list_lock();
	<span class="enscript-keyword">for</span> (vfsp = vfsconf; vfsp; vfsp = vfsp-&gt;vfc_next)
		<span class="enscript-keyword">if</span> (!strncmp(vfsp-&gt;vfc_name, fstypename, MFSNAMELEN)) {
			vfsp-&gt;vfc_refcount++;
			vfsp_ref = TRUE;
			<span class="enscript-keyword">break</span>;
		}
	mount_list_unlock();
	<span class="enscript-keyword">if</span> (vfsp == NULL) {
		error = ENODEV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}

	<span class="enscript-comment">/*
	 * VFC_VFSLOCALARGS is not currently supported for kernel mounts
	 */</span>
	<span class="enscript-keyword">if</span> (kernelmount &amp;&amp; (vfsp-&gt;vfc_vfsflags &amp; VFC_VFSLOCALARGS)) {
		error = EINVAL;  <span class="enscript-comment">/* unsupported request */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}

	error = prepare_coveredvp(vp, ctx, cnp, fstypename, ((internal_flags &amp; KERNEL_MOUNT_NOAUTH) != 0));
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}

	<span class="enscript-comment">/*
	 * Allocate and initialize the filesystem (mount_t)
	 */</span>
	MALLOC_ZONE(mp, <span class="enscript-type">struct</span> mount *, (u_int32_t)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount),
		M_MOUNT, M_WAITOK);
	bzero((<span class="enscript-type">char</span> *)mp, (u_int32_t)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount));
	mntalloc = 1;

	<span class="enscript-comment">/* Initialize the default IO constraints */</span>
	mp-&gt;mnt_maxreadcnt = mp-&gt;mnt_maxwritecnt = MAXPHYS;
	mp-&gt;mnt_segreadcnt = mp-&gt;mnt_segwritecnt = 32;
	mp-&gt;mnt_maxsegreadsize = mp-&gt;mnt_maxreadcnt;
	mp-&gt;mnt_maxsegwritesize = mp-&gt;mnt_maxwritecnt;
	mp-&gt;mnt_devblocksize = DEV_BSIZE;
	mp-&gt;mnt_alignmentmask = PAGE_MASK;
	mp-&gt;mnt_ioqueue_depth = MNT_DEFAULT_IOQUEUE_DEPTH;
	mp-&gt;mnt_ioscale = 1;
	mp-&gt;mnt_ioflags = 0;
	mp-&gt;mnt_realrootvp = NULLVP;
	mp-&gt;mnt_authcache_ttl = CACHED_LOOKUP_RIGHT_TTL;

	TAILQ_INIT(&amp;mp-&gt;mnt_vnodelist);
	TAILQ_INIT(&amp;mp-&gt;mnt_workerqueue);
	TAILQ_INIT(&amp;mp-&gt;mnt_newvnodes);
	mount_lock_init(mp);
	lck_rw_lock_exclusive(&amp;mp-&gt;mnt_rwlock);
	is_rwlock_locked = TRUE;
	mp-&gt;mnt_op = vfsp-&gt;vfc_vfsops;
	mp-&gt;mnt_vtable = vfsp;
	<span class="enscript-comment">//mp-&gt;mnt_stat.f_type = vfsp-&gt;vfc_typenum;
</span>	mp-&gt;mnt_flag |= vfsp-&gt;vfc_flags &amp; MNT_VISFLAGMASK;
	strlcpy(mp-&gt;mnt_vfsstat.f_fstypename, vfsp-&gt;vfc_name, MFSTYPENAMELEN);
	strlcpy(mp-&gt;mnt_vfsstat.f_mntonname, cnp-&gt;cn_pnbuf, MAXPATHLEN);
	mp-&gt;mnt_vnodecovered = vp;
	mp-&gt;mnt_vfsstat.f_owner = kauth_cred_getuid(vfs_context_ucred(ctx));
	mp-&gt;mnt_throttle_mask = LOWPRI_MAX_NUM_DEV - 1;
	mp-&gt;mnt_devbsdunit = 0;

	<span class="enscript-comment">/* XXX 3762912 hack to support HFS filesystem 'owner' - filesystem may update later */</span>
	vfs_setowner(mp, KAUTH_UID_NONE, KAUTH_GID_NONE);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span> || <span class="enscript-variable-name">DEVFS</span>
	<span class="enscript-keyword">if</span> (kernelmount)
		mp-&gt;mnt_kern_flag |= MNTK_KERNEL_MOUNT;
	<span class="enscript-keyword">if</span> ((internal_flags &amp; KERNEL_MOUNT_PERMIT_UNMOUNT) != 0)
		mp-&gt;mnt_kern_flag |= MNTK_PERMIT_UNMOUNT;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSCLIENT || DEVFS */</span>

<span class="enscript-reference">update</span>:
	<span class="enscript-comment">/*
	 * Set the mount level flags.
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; MNT_RDONLY)
		mp-&gt;mnt_flag |= MNT_RDONLY;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mp-&gt;mnt_flag &amp; MNT_RDONLY) {
		<span class="enscript-comment">// disallow read/write upgrades of file systems that
</span>		<span class="enscript-comment">// had the TYPENAME_OVERRIDE feature set.
</span>		<span class="enscript-keyword">if</span> (mp-&gt;mnt_kern_flag &amp; MNTK_TYPENAME_OVERRIDE) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
		mp-&gt;mnt_kern_flag |= MNTK_WANTRDWR;
	}
	mp-&gt;mnt_flag &amp;= ~(MNT_NOSUID | MNT_NOEXEC | MNT_NODEV |
			  MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC |
			  MNT_UNKNOWNPERMISSIONS | MNT_DONTBROWSE |
			  MNT_AUTOMOUNTED | MNT_DEFWRITE | MNT_NOATIME |
			  MNT_QUARANTINE | MNT_CPROTECT);
	mp-&gt;mnt_flag |= flags &amp; (MNT_NOSUID | MNT_NOEXEC | MNT_NODEV |
				 MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC |
				 MNT_UNKNOWNPERMISSIONS | MNT_DONTBROWSE |
				 MNT_AUTOMOUNTED | MNT_DEFWRITE | MNT_NOATIME |
				 MNT_QUARANTINE | MNT_CPROTECT);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (flags &amp; MNT_MULTILABEL) {
		<span class="enscript-keyword">if</span> (vfsp-&gt;vfc_vfsflags &amp; VFC_VFSNOMACLABEL) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
		mp-&gt;mnt_flag |= MNT_MULTILABEL;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Process device path for local file systems if requested
	 */</span>
	<span class="enscript-keyword">if</span> (vfsp-&gt;vfc_vfsflags &amp; VFC_VFSLOCALARGS) {
		<span class="enscript-keyword">if</span> (vfs_context_is64bit(ctx)) {
			<span class="enscript-keyword">if</span> ( (error = copyin(fsmountargs, (caddr_t)&amp;devpath, <span class="enscript-keyword">sizeof</span>(devpath))) )
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;	
			fsmountargs += <span class="enscript-keyword">sizeof</span>(devpath);
		} <span class="enscript-keyword">else</span> {
			user32_addr_t tmp;
			<span class="enscript-keyword">if</span> ( (error = copyin(fsmountargs, (caddr_t)&amp;tmp, <span class="enscript-keyword">sizeof</span>(tmp))) )
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;	
			<span class="enscript-comment">/* munge into LP64 addr */</span>
			devpath = CAST_USER_ADDR_T(tmp);
			fsmountargs += <span class="enscript-keyword">sizeof</span>(tmp);
		}

		<span class="enscript-comment">/* Lookup device and authorize access to it */</span>
		<span class="enscript-keyword">if</span> ((devpath)) {
			<span class="enscript-type">struct</span> nameidata nd;

			NDINIT(&amp;nd, LOOKUP, OP_MOUNT, FOLLOW, UIO_USERSPACE, devpath, ctx);
			<span class="enscript-keyword">if</span> ( (error = namei(&amp;nd)) )
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;

			strlcpy(mp-&gt;mnt_vfsstat.f_mntfromname, nd.ni_cnd.cn_pnbuf, MAXPATHLEN);
			devvp = nd.ni_vp;

			nameidone(&amp;nd);

			<span class="enscript-keyword">if</span> (devvp-&gt;v_type != VBLK) {
				error = ENOTBLK;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
			}
			<span class="enscript-keyword">if</span> (major(devvp-&gt;v_rdev) &gt;= nblkdev) {
				error = ENXIO;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
			}
			<span class="enscript-comment">/*
			* If mount by non-root, then verify that user has necessary
			* permissions on the device.
			*/</span>
			<span class="enscript-keyword">if</span> (suser(vfs_context_ucred(ctx), NULL) != 0) {
				mode_t accessmode = KAUTH_VNODE_READ_DATA;

				<span class="enscript-keyword">if</span> ((mp-&gt;mnt_flag &amp; MNT_RDONLY) == 0)
					accessmode |= KAUTH_VNODE_WRITE_DATA;
				<span class="enscript-keyword">if</span> ((error = vnode_authorize(devvp, NULL, accessmode, ctx)) != 0)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
			}
		}
		<span class="enscript-comment">/* On first mount, preflight and open device */</span>
		<span class="enscript-keyword">if</span> (devpath &amp;&amp; ((flags &amp; MNT_UPDATE) == 0)) {
			<span class="enscript-keyword">if</span> ( (error = vnode_ref(devvp)) )
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
			<span class="enscript-comment">/*
			* Disallow multiple mounts of the same device.
			* Disallow mounting of a device that is currently in use
			* (except for root, which might share swap device for miniroot).
			* Flush out any old buffers remaining from a previous use.
			*/</span>
			<span class="enscript-keyword">if</span> ( (error = vfs_mountedon(devvp)) )
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out3</span>;
	
			<span class="enscript-keyword">if</span> (vcount(devvp) &gt; 1 &amp;&amp; !(vfs_flags(mp) &amp; MNT_ROOTFS)) {
				error = EBUSY;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out3</span>;
			}
			<span class="enscript-keyword">if</span> ( (error = VNOP_FSYNC(devvp, MNT_WAIT, ctx)) ) {
				error = ENOTBLK;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out3</span>;
			}
			<span class="enscript-keyword">if</span> ( (error = buf_invalidateblks(devvp, BUF_WRITE_DATA, 0, 0)) )
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out3</span>;

			ronly = (mp-&gt;mnt_flag &amp; MNT_RDONLY) != 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
			error = mac_vnode_check_open(ctx,
			    devvp,
			    ronly ? FREAD : FREAD|FWRITE);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out3</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>
			<span class="enscript-keyword">if</span> ( (error = VNOP_OPEN(devvp, ronly ? FREAD : FREAD|FWRITE, ctx)) )
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out3</span>;

			mp-&gt;mnt_devvp = devvp;
			device_vnode = devvp;

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((mp-&gt;mnt_flag &amp; MNT_RDONLY) &amp;&amp;
		           (mp-&gt;mnt_kern_flag &amp; MNTK_WANTRDWR) &amp;&amp;
		           (device_vnode = mp-&gt;mnt_devvp)) {
			dev_t dev;
			<span class="enscript-type">int</span> maj;
			<span class="enscript-comment">/*
			 * If upgrade to read-write by non-root, then verify
			 * that user has necessary permissions on the device.
			 */</span>
			vnode_getalways(device_vnode);

			<span class="enscript-keyword">if</span> (suser(vfs_context_ucred(ctx), NULL) &amp;&amp;
			    (error = vnode_authorize(device_vnode, NULL, 
			     KAUTH_VNODE_READ_DATA | KAUTH_VNODE_WRITE_DATA,
			     ctx)) != 0) {
				vnode_put(device_vnode);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
			}

			<span class="enscript-comment">/* Tell the device that we're upgrading */</span>
			dev = (dev_t)device_vnode-&gt;v_rdev;
			maj = major(dev);

			<span class="enscript-keyword">if</span> ((u_int)maj &gt;= (u_int)nblkdev)
				panic(<span class="enscript-string">&quot;Volume mounted on a device with invalid major number.&quot;</span>);

			error = bdevsw[maj].d_open(dev, FREAD | FWRITE, S_IFBLK, p);
			vnode_put(device_vnode);
			device_vnode = NULLVP;
			<span class="enscript-keyword">if</span> (error != 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
			}
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> ((flags &amp; MNT_UPDATE) == 0) {
		mac_mount_label_init(mp);
		mac_mount_label_associate(ctx, mp);
	}
	<span class="enscript-keyword">if</span> (labelstr) {
		<span class="enscript-keyword">if</span> ((flags &amp; MNT_UPDATE) != 0) {
			error = mac_mount_check_label_update(ctx, mp);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out3</span>;
		}
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Mount the filesystem.
	 */</span>
	error = VFS_MOUNT(mp, device_vnode, fsmountargs, ctx);

	<span class="enscript-keyword">if</span> (flags &amp; MNT_UPDATE) {
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_kern_flag &amp; MNTK_WANTRDWR)
			mp-&gt;mnt_flag &amp;= ~MNT_RDONLY;
		mp-&gt;mnt_flag &amp;=~
		    (MNT_UPDATE | MNT_RELOAD | MNT_FORCE);
		mp-&gt;mnt_kern_flag &amp;=~ MNTK_WANTRDWR;
		<span class="enscript-keyword">if</span> (error)
			mp-&gt;mnt_flag = flag;  <span class="enscript-comment">/* restore flag value */</span>
		vfs_event_signal(NULL, VQ_UPDATE, (intptr_t)NULL);
		lck_rw_done(&amp;mp-&gt;mnt_rwlock);
		is_rwlock_locked = FALSE;
		<span class="enscript-keyword">if</span> (!error)
			enablequotas(mp, ctx);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-comment">/*
	 * Put the new filesystem on the mount list after root.
	 */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-type">struct</span> vfs_attr	vfsattr;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-keyword">if</span> (vfs_flags(mp) &amp; MNT_MULTILABEL) {
			error = VFS_ROOT(mp, &amp;rvp, ctx);
			<span class="enscript-keyword">if</span> (error) {
				printf(<span class="enscript-string">&quot;%s() VFS_ROOT returned %d\n&quot;</span>, __func__, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out3</span>;
			}
			error = vnode_label(mp, NULL, rvp, NULL, 0, ctx);
                        <span class="enscript-comment">/*
			 * drop reference provided by VFS_ROOT
			 */</span>
			vnode_put(rvp);

			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out3</span>;
		}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MAC */</span>

		vnode_lock_spin(vp);
		CLR(vp-&gt;v_flag, VMOUNT);
		vp-&gt;v_mountedhere = mp;
		vnode_unlock(vp);

		<span class="enscript-comment">/*
		 * taking the name_cache_lock exclusively will
		 * insure that everyone is out of the fast path who
		 * might be trying to use a now stale copy of
		 * vp-&gt;v_mountedhere-&gt;mnt_realrootvp
		 * bumping mount_generation causes the cached values
		 * to be invalidated
		 */</span>
		name_cache_lock();
		mount_generation++;
		name_cache_unlock();

		error = vnode_ref(vp);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out4</span>;
		}

		have_usecount = TRUE;

		error = checkdirs(vp, ctx);
		<span class="enscript-keyword">if</span> (error != 0)  {
			<span class="enscript-comment">/* Unmount the filesystem as cdir/rdirs cannot be updated */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out4</span>;
		}
		<span class="enscript-comment">/* 
		 * there is no cleanup code here so I have made it void 
		 * we need to revisit this
		 */</span>
		(<span class="enscript-type">void</span>)VFS_START(mp, 0, ctx);

		<span class="enscript-keyword">if</span> (mount_list_add(mp) != 0) {
			<span class="enscript-comment">/*
			 * The system is shutting down trying to umount
			 * everything, so fail with a plausible errno.
			 */</span>
			error = EBUSY;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out4</span>;
		}
		lck_rw_done(&amp;mp-&gt;mnt_rwlock);
		is_rwlock_locked = FALSE;

		<span class="enscript-comment">/* Check if this mounted file system supports EAs or named streams. */</span>
		<span class="enscript-comment">/* Skip WebDAV file systems for now since they hang in VFS_GETATTR here. */</span>
		VFSATTR_INIT(&amp;vfsattr);
		VFSATTR_WANTED(&amp;vfsattr, f_capabilities);
		<span class="enscript-keyword">if</span> (strncmp(mp-&gt;mnt_vfsstat.f_fstypename, <span class="enscript-string">&quot;webdav&quot;</span>, <span class="enscript-keyword">sizeof</span>(<span class="enscript-string">&quot;webdav&quot;</span>)) != 0 &amp;&amp;
		    vfs_getattr(mp, &amp;vfsattr, ctx) == 0 &amp;&amp; 
		    VFSATTR_IS_SUPPORTED(&amp;vfsattr, f_capabilities)) {
			<span class="enscript-keyword">if</span> ((vfsattr.f_capabilities.capabilities[VOL_CAPABILITIES_INTERFACES] &amp; VOL_CAP_INT_EXTENDED_ATTR) &amp;&amp;
			    (vfsattr.f_capabilities.valid[VOL_CAPABILITIES_INTERFACES] &amp; VOL_CAP_INT_EXTENDED_ATTR)) {
				mp-&gt;mnt_kern_flag |= MNTK_EXTENDED_ATTRS;
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
			<span class="enscript-keyword">if</span> ((vfsattr.f_capabilities.capabilities[VOL_CAPABILITIES_INTERFACES] &amp; VOL_CAP_INT_NAMEDSTREAMS) &amp;&amp;
			    (vfsattr.f_capabilities.valid[VOL_CAPABILITIES_INTERFACES] &amp; VOL_CAP_INT_NAMEDSTREAMS)) {
				mp-&gt;mnt_kern_flag |= MNTK_NAMED_STREAMS;
			}
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/* Check if this file system supports path from id lookups. */</span>
			<span class="enscript-keyword">if</span> ((vfsattr.f_capabilities.capabilities[VOL_CAPABILITIES_FORMAT] &amp; VOL_CAP_FMT_PATH_FROM_ID) &amp;&amp;
			    (vfsattr.f_capabilities.valid[VOL_CAPABILITIES_FORMAT] &amp; VOL_CAP_FMT_PATH_FROM_ID)) {
				mp-&gt;mnt_kern_flag |= MNTK_PATH_FROM_ID;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mp-&gt;mnt_flag &amp; MNT_DOVOLFS) {
				<span class="enscript-comment">/* Legacy MNT_DOVOLFS flag also implies path from id lookups. */</span>
				mp-&gt;mnt_kern_flag |= MNTK_PATH_FROM_ID;
			}
		}
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSNATIVEXATTR) {
			mp-&gt;mnt_kern_flag |= MNTK_EXTENDED_ATTRS;
		}
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSPREFLIGHT) {
			mp-&gt;mnt_kern_flag |= MNTK_UNMOUNT_PREFLIGHT;
		}
		<span class="enscript-comment">/* increment the operations count */</span>
		OSAddAtomic(1, &amp;vfs_nummntops);
		enablequotas(mp, ctx);

		<span class="enscript-keyword">if</span> (device_vnode) {
			device_vnode-&gt;v_specflags |= SI_MOUNTEDON;

			<span class="enscript-comment">/*
			 *   cache the IO attributes for the underlying physical media...
			 *   an error return indicates the underlying driver doesn't
			 *   support all the queries necessary... however, reasonable
			 *   defaults will have been set, so no reason to bail or care
			 */</span>
			vfs_init_io_attributes(device_vnode, mp);
		} 

		<span class="enscript-comment">/* Now that mount is setup, notify the listeners */</span>
		vfs_notify_mount(pvp);
		IOBSDMountChange(mp, kIOMountChangeMount);

	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* If we fail a fresh mount, there should be no vnodes left hooked into the mountpoint. */</span>
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_vnodelist.tqh_first != NULL) {
			panic(<span class="enscript-string">&quot;mount_common(): mount of %s filesystem failed with %d, but vnode list is not empty.&quot;</span>, 
					mp-&gt;mnt_vtable-&gt;vfc_name, error);
		}

		vnode_lock_spin(vp);
		CLR(vp-&gt;v_flag, VMOUNT);
		vnode_unlock(vp);
		mount_list_lock();
		mp-&gt;mnt_vtable-&gt;vfc_refcount--;
		mount_list_unlock();

		<span class="enscript-keyword">if</span> (device_vnode ) {
			vnode_rele(device_vnode);
			VNOP_CLOSE(device_vnode, ronly ? FREAD : FREAD|FWRITE, ctx);
		}
		lck_rw_done(&amp;mp-&gt;mnt_rwlock);
		is_rwlock_locked = FALSE;
		
		<span class="enscript-comment">/*
		 * if we get here, we have a mount structure that needs to be freed,
		 * but since the coveredvp hasn't yet been updated to point at it,
		 * no need to worry about other threads holding a crossref on this mp
		 * so it's ok to just free it
		 */</span>
		mount_lock_destroy(mp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_mount_label_destroy(mp);
#<span class="enscript-reference">endif</span>
		FREE_ZONE((caddr_t)mp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mount), M_MOUNT);
	}
<span class="enscript-reference">exit</span>:
	<span class="enscript-comment">/*
	 * drop I/O count on the device vp if there was one
	 */</span>
	<span class="enscript-keyword">if</span> (devpath &amp;&amp; devvp)
	        vnode_put(devvp);

	<span class="enscript-keyword">return</span>(error);

<span class="enscript-comment">/* Error condition exits */</span>
<span class="enscript-reference">out4</span>:
	(<span class="enscript-type">void</span>)VFS_UNMOUNT(mp, MNT_FORCE, ctx);
	
	<span class="enscript-comment">/* 
	 * If the mount has been placed on the covered vp,
	 * it may have been discovered by now, so we have
	 * to treat this just like an unmount
	 */</span>
	mount_lock_spin(mp);
	mp-&gt;mnt_lflag |= MNT_LDEAD;
	mount_unlock(mp);

	<span class="enscript-keyword">if</span> (device_vnode != NULLVP) {
		vnode_rele(device_vnode);
		VNOP_CLOSE(device_vnode, mp-&gt;mnt_flag &amp; MNT_RDONLY ? FREAD : FREAD|FWRITE,
                       ctx);
		did_rele = TRUE;
	}

	vnode_lock_spin(vp);

	mp-&gt;mnt_crossref++;
	vp-&gt;v_mountedhere = (mount_t) 0;

	vnode_unlock(vp);

	<span class="enscript-keyword">if</span> (have_usecount) {
		vnode_rele(vp);
	}
<span class="enscript-reference">out3</span>:
	<span class="enscript-keyword">if</span> (devpath &amp;&amp; ((flags &amp; MNT_UPDATE) == 0) &amp;&amp; (!did_rele))
		vnode_rele(devvp);
<span class="enscript-reference">out2</span>:
	<span class="enscript-keyword">if</span> (devpath &amp;&amp; devvp)
	        vnode_put(devvp);
<span class="enscript-reference">out1</span>:
	<span class="enscript-comment">/* Release mnt_rwlock only when it was taken */</span>
	<span class="enscript-keyword">if</span> (is_rwlock_locked == TRUE) {
		lck_rw_done(&amp;mp-&gt;mnt_rwlock);
	}
	
	<span class="enscript-keyword">if</span> (mntalloc) {
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_crossref)
			mount_dropcrossref(mp, vp, 0);
		<span class="enscript-keyword">else</span> {
			mount_lock_destroy(mp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
			mac_mount_label_destroy(mp);
#<span class="enscript-reference">endif</span>
			FREE_ZONE((caddr_t)mp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mount), M_MOUNT);
		}
	}
	<span class="enscript-keyword">if</span> (vfsp_ref) {
		mount_list_lock();
		vfsp-&gt;vfc_refcount--;
		mount_list_unlock();
	}

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/* 
 * Flush in-core data, check for competing mount attempts,
 * and set VMOUNT
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">prepare_coveredvp</span>(vnode_t vp, vfs_context_t ctx, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fsname, boolean_t skip_auth)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cnp</span>,<span class="enscript-variable-name">fsname</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (!skip_auth) {
		<span class="enscript-comment">/*
		 * If the user is not root, ensure that they own the directory
		 * onto which we are attempting to mount.
		 */</span>
		VATTR_INIT(&amp;va);
		VATTR_WANTED(&amp;va, va_uid);
		<span class="enscript-keyword">if</span> ((error = vnode_getattr(vp, &amp;va, ctx)) ||
				(va.va_uid != kauth_cred_getuid(vfs_context_ucred(ctx)) &amp;&amp;
				 (!vfs_context_issuser(ctx)))) { 
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-keyword">if</span> ( (error = VNOP_FSYNC(vp, MNT_WAIT, ctx)) )
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> ( (error = buf_invalidateblks(vp, BUF_WRITE_DATA, 0, 0)) )
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (vp-&gt;v_type != VDIR) {
		error = ENOTDIR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (ISSET(vp-&gt;v_flag, VMOUNT) &amp;&amp; (vp-&gt;v_mountedhere != NULL)) {
		error = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_mount_check_mount(ctx, vp,
	    cnp, fsname);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

	vnode_lock_spin(vp);
	SET(vp-&gt;v_flag, VMOUNT);
	vnode_unlock(vp);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IMGSRC_ACCESS</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IMGSRC_DEBUG</span>(args...) printf(args)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IMGSRC_DEBUG</span>(args...) do { } while(0)
#<span class="enscript-reference">endif</span> 

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">authorize_devpath_and_update_mntfromname</span>(mount_t mp, user_addr_t devpath, vnode_t *devvpp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nameidata nd;
	vnode_t vp, realdevvp;
	mode_t accessmode;
	<span class="enscript-type">int</span> error;

	NDINIT(&amp;nd, LOOKUP, OP_LOOKUP, FOLLOW, UIO_USERSPACE, devpath, ctx);
	<span class="enscript-keyword">if</span> ( (error = namei(&amp;nd)) ) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;namei() failed with %d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}

	vp = nd.ni_vp;

	<span class="enscript-keyword">if</span> (!vnode_isblk(vp)) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;Not block device.\n&quot;</span>);
		error = ENOTBLK;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	realdevvp = mp-&gt;mnt_devvp;
	<span class="enscript-keyword">if</span> (realdevvp == NULLVP) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;No device backs the mount.\n&quot;</span>);
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = vnode_getwithref(realdevvp);
	<span class="enscript-keyword">if</span> (error != 0) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;Coudn't get iocount on device.\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (vnode_specrdev(vp) != vnode_specrdev(realdevvp)) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;Wrong dev_t.\n&quot;</span>);
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}

	strlcpy(mp-&gt;mnt_vfsstat.f_mntfromname, nd.ni_cnd.cn_pnbuf, MAXPATHLEN);

	<span class="enscript-comment">/*
	 * If mount by non-root, then verify that user has necessary
	 * permissions on the device.
	 */</span>
	<span class="enscript-keyword">if</span> (!vfs_context_issuser(ctx)) {
		accessmode = KAUTH_VNODE_READ_DATA;
		<span class="enscript-keyword">if</span> ((mp-&gt;mnt_flag &amp; MNT_RDONLY) == 0)
			accessmode |= KAUTH_VNODE_WRITE_DATA;
		<span class="enscript-keyword">if</span> ((error = vnode_authorize(vp, NULL, accessmode, ctx)) != 0) {
			IMGSRC_DEBUG(<span class="enscript-string">&quot;Access denied.\n&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
	}

	*devvpp = vp;

<span class="enscript-reference">out1</span>:
	vnode_put(realdevvp);
<span class="enscript-reference">out</span>:
	nameidone(&amp;nd);
	<span class="enscript-keyword">if</span> (error) {
		vnode_put(vp);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Clear VMOUNT, set v_mountedhere, and mnt_vnodecovered, ref the vnode,
 * and call checkdirs()
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">place_mount_and_checkdirs</span>(mount_t mp, vnode_t vp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	mp-&gt;mnt_vnodecovered = vp; <span class="enscript-comment">/* XXX This is normally only set at init-time ... */</span>

	vnode_lock_spin(vp);
	CLR(vp-&gt;v_flag, VMOUNT);
	vp-&gt;v_mountedhere = mp;
	vnode_unlock(vp);

	<span class="enscript-comment">/*
	 * taking the name_cache_lock exclusively will
	 * insure that everyone is out of the fast path who
	 * might be trying to use a now stale copy of
	 * vp-&gt;v_mountedhere-&gt;mnt_realrootvp
	 * bumping mount_generation causes the cached values
	 * to be invalidated
	 */</span>
	name_cache_lock();
	mount_generation++;
	name_cache_unlock();

	error = vnode_ref(vp);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = checkdirs(vp, ctx);
	<span class="enscript-keyword">if</span> (error != 0)  {
		<span class="enscript-comment">/* Unmount the filesystem as cdir/rdirs cannot be updated */</span>
		vnode_rele(vp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error != 0) {
		mp-&gt;mnt_vnodecovered = NULLVP;
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">undo_place_on_covered_vp</span>(mount_t mp, vnode_t vp)
{
	vnode_rele(vp);
	vnode_lock_spin(vp);
	vp-&gt;v_mountedhere = (mount_t)NULL;
	vnode_unlock(vp);

	mp-&gt;mnt_vnodecovered = NULLVP;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mount_begin_update</span>(mount_t mp, vfs_context_t ctx, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* unmount in progress return error */</span>
	mount_lock_spin(mp);
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; MNT_LUNMOUNT) {
		mount_unlock(mp);
		<span class="enscript-keyword">return</span> EBUSY;
	}
	mount_unlock(mp);
	lck_rw_lock_exclusive(&amp;mp-&gt;mnt_rwlock);

	<span class="enscript-comment">/*
	 * We only allow the filesystem to be reloaded if it
	 * is currently mounted read-only.
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; MNT_RELOAD) &amp;&amp;
			((mp-&gt;mnt_flag &amp; MNT_RDONLY) == 0)) {
		error = ENOTSUP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Only root, or the user that did the original mount is
	 * permitted to update it.
	 */</span>
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_vfsstat.f_owner != kauth_cred_getuid(vfs_context_ucred(ctx)) &amp;&amp;
			(!vfs_context_issuser(ctx))) { 
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_mount_check_remount(ctx, mp);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error) {
		lck_rw_done(&amp;mp-&gt;mnt_rwlock);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">mount_end_update</span>(mount_t mp)
{
	lck_rw_done(&amp;mp-&gt;mnt_rwlock);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">get_imgsrc_rootvnode</span>(uint32_t height, vnode_t *rvpp)
{
	vnode_t vp;

	<span class="enscript-keyword">if</span> (height &gt;= MAX_IMAGEBOOT_NESTING) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	vp = imgsrc_rootvnodes[height];
	<span class="enscript-keyword">if</span> ((vp != NULLVP) &amp;&amp; (vnode_get(vp) == 0)) {
		*rvpp = vp;
		<span class="enscript-keyword">return</span> 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> ENOENT;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">relocate_imageboot_source</span>(vnode_t pvp, vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp, 
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fsname, vfs_context_t ctx, 
		boolean_t is64bit, user_addr_t fsmountargs, boolean_t by_index)
{
	<span class="enscript-type">int</span> error;
	mount_t mp;
	boolean_t placed = FALSE;
	vnode_t devvp = NULLVP;
	<span class="enscript-type">struct</span> vfstable *vfsp;
	user_addr_t devpath;
	<span class="enscript-type">char</span> *old_mntonname;
	vnode_t rvp;
	uint32_t height;
	uint32_t flags;

	<span class="enscript-comment">/* If we didn't imageboot, nothing to move */</span>
	<span class="enscript-keyword">if</span> (imgsrc_rootvnodes[0] == NULLVP) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* Only root can do this */</span>
	<span class="enscript-keyword">if</span> (!vfs_context_issuser(ctx)) {
		<span class="enscript-keyword">return</span> EPERM;
	}

	IMGSRC_DEBUG(<span class="enscript-string">&quot;looking for root vnode.\n&quot;</span>);

	<span class="enscript-comment">/*
	 * Get root vnode of filesystem we're moving.
	 */</span>
	<span class="enscript-keyword">if</span> (by_index) {
		<span class="enscript-keyword">if</span> (is64bit) {
			<span class="enscript-type">struct</span> user64_mnt_imgsrc_args mia64;
			error = copyin(fsmountargs, &amp;mia64, <span class="enscript-keyword">sizeof</span>(mia64));
			<span class="enscript-keyword">if</span> (error != 0) {
				IMGSRC_DEBUG(<span class="enscript-string">&quot;Failed to copy in arguments.\n&quot;</span>);
				<span class="enscript-keyword">return</span> error;
			}

			height = mia64.mi_height;
			flags = mia64.mi_flags;
			devpath = mia64.mi_devpath;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_mnt_imgsrc_args mia32;
			error = copyin(fsmountargs, &amp;mia32, <span class="enscript-keyword">sizeof</span>(mia32));
			<span class="enscript-keyword">if</span> (error != 0) {
				IMGSRC_DEBUG(<span class="enscript-string">&quot;Failed to copy in arguments.\n&quot;</span>);
				<span class="enscript-keyword">return</span> error;
			}

			height = mia32.mi_height;
			flags = mia32.mi_flags;
			devpath = mia32.mi_devpath;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * For binary compatibility--assumes one level of nesting.
		 */</span>
		<span class="enscript-keyword">if</span> (is64bit) {
			<span class="enscript-keyword">if</span> ( (error = copyin(fsmountargs, (caddr_t)&amp;devpath, <span class="enscript-keyword">sizeof</span>(devpath))) )
				<span class="enscript-keyword">return</span> error;
		} <span class="enscript-keyword">else</span> {
			user32_addr_t tmp;
			<span class="enscript-keyword">if</span> ( (error = copyin(fsmountargs, (caddr_t)&amp;tmp, <span class="enscript-keyword">sizeof</span>(tmp))) )
				<span class="enscript-keyword">return</span> error;

			<span class="enscript-comment">/* munge into LP64 addr */</span>
			devpath = CAST_USER_ADDR_T(tmp);
		}

		height = 0;
		flags = 0;
	}

	<span class="enscript-keyword">if</span> (flags != 0) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;%s: Got nonzero flags.\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	error = get_imgsrc_rootvnode(height, &amp;rvp);
	<span class="enscript-keyword">if</span> (error != 0) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;getting root vnode failed with %d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}

	IMGSRC_DEBUG(<span class="enscript-string">&quot;got root vnode.\n&quot;</span>);

	MALLOC(old_mntonname, <span class="enscript-type">char</span>*, MAXPATHLEN, M_TEMP, M_WAITOK);

	<span class="enscript-comment">/* Can only move once */</span>
	mp = vnode_mount(rvp);
	<span class="enscript-keyword">if</span> ((mp-&gt;mnt_kern_flag &amp; MNTK_HAS_MOVED) == MNTK_HAS_MOVED) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;Already moved.\n&quot;</span>);
		error = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out0</span>;
	}

	IMGSRC_DEBUG(<span class="enscript-string">&quot;Starting updated.\n&quot;</span>);

	<span class="enscript-comment">/* Get exclusive rwlock on mount, authorize update on mp */</span>
	error = mount_begin_update(mp , ctx, 0);
	<span class="enscript-keyword">if</span> (error != 0) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;Starting updated failed with %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out0</span>;
	}

	<span class="enscript-comment">/* 
	 * It can only be moved once.  Flag is set under the rwlock,
	 * so we're now safe to proceed.
	 */</span>
	<span class="enscript-keyword">if</span> ((mp-&gt;mnt_kern_flag &amp; MNTK_HAS_MOVED) == MNTK_HAS_MOVED) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;Already moved [2]\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}
		
	
	IMGSRC_DEBUG(<span class="enscript-string">&quot;Preparing coveredvp.\n&quot;</span>);

	<span class="enscript-comment">/* Mark covered vnode as mount in progress, authorize placing mount on top */</span>
	error = prepare_coveredvp(vp, ctx, cnp, fsname, FALSE);
	<span class="enscript-keyword">if</span> (error != 0) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;Preparing coveredvp failed with %d.\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}
	
	IMGSRC_DEBUG(<span class="enscript-string">&quot;Covered vp OK.\n&quot;</span>);

	<span class="enscript-comment">/* Sanity check the name caller has provided */</span>
	vfsp = mp-&gt;mnt_vtable;
	<span class="enscript-keyword">if</span> (strncmp(vfsp-&gt;vfc_name, fsname, MFSNAMELEN) != 0) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;Wrong fs name.\n&quot;</span>);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
	}

	<span class="enscript-comment">/* Check the device vnode and update mount-from name, for local filesystems */</span>
	<span class="enscript-keyword">if</span> (vfsp-&gt;vfc_vfsflags &amp; VFC_VFSLOCALARGS) {
		IMGSRC_DEBUG(<span class="enscript-string">&quot;Local, doing device validation.\n&quot;</span>);

		<span class="enscript-keyword">if</span> (devpath != USER_ADDR_NULL) {
			error = authorize_devpath_and_update_mntfromname(mp, devpath, &amp;devvp, ctx);
			<span class="enscript-keyword">if</span> (error) {
				IMGSRC_DEBUG(<span class="enscript-string">&quot;authorize_devpath_and_update_mntfromname() failed.\n&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
			}

			vnode_put(devvp);
		}
	}

	<span class="enscript-comment">/* 
	 * Place mp on top of vnode, ref the vnode,  call checkdirs(),
	 * and increment the name cache's mount generation 
	 */</span>

	IMGSRC_DEBUG(<span class="enscript-string">&quot;About to call place_mount_and_checkdirs().\n&quot;</span>);
	error = place_mount_and_checkdirs(mp, vp, ctx);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
	}

	placed = TRUE;

	strlcpy(old_mntonname, mp-&gt;mnt_vfsstat.f_mntonname, MAXPATHLEN);
	strlcpy(mp-&gt;mnt_vfsstat.f_mntonname, cnp-&gt;cn_pnbuf, MAXPATHLEN);

	<span class="enscript-comment">/* Forbid future moves */</span>
	mount_lock(mp);
	mp-&gt;mnt_kern_flag |= MNTK_HAS_MOVED;
	mount_unlock(mp);

	<span class="enscript-comment">/* Finally, add to mount list, completely ready to go */</span>
	<span class="enscript-keyword">if</span> (mount_list_add(mp) != 0) {
		<span class="enscript-comment">/*
		 * The system is shutting down trying to umount
		 * everything, so fail with a plausible errno.
		 */</span>
		error = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out3</span>;
	}

	mount_end_update(mp);
	vnode_put(rvp);
	FREE(old_mntonname, M_TEMP);

	vfs_notify_mount(pvp);

	<span class="enscript-keyword">return</span> 0;
<span class="enscript-reference">out3</span>:
	strlcpy(mp-&gt;mnt_vfsstat.f_mntonname, old_mntonname, MAXPATHLEN);

	mount_lock(mp);
	mp-&gt;mnt_kern_flag &amp;= ~(MNTK_HAS_MOVED);
	mount_unlock(mp);

<span class="enscript-reference">out2</span>:
	<span class="enscript-comment">/* 
	 * Placing the mp on the vnode clears VMOUNT,
	 * so cleanup is different after that point 
	 */</span>
	<span class="enscript-keyword">if</span> (placed) {
		<span class="enscript-comment">/* Rele the vp, clear VMOUNT and v_mountedhere */</span>
		undo_place_on_covered_vp(mp, vp);
	} <span class="enscript-keyword">else</span> {
		vnode_lock_spin(vp);
		CLR(vp-&gt;v_flag, VMOUNT);
		vnode_unlock(vp);
	}
<span class="enscript-reference">out1</span>:
	mount_end_update(mp);

<span class="enscript-reference">out0</span>:
	vnode_put(rvp);
	FREE(old_mntonname, M_TEMP);
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IMGSRC_ACCESS */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">enablequotas</span>(<span class="enscript-type">struct</span> mount *mp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nameidata qnd;
	<span class="enscript-type">int</span> type;
	<span class="enscript-type">char</span> qfpath[MAXPATHLEN];
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *qfname = QUOTAFILENAME;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *qfopsname = QUOTAOPSNAME;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *qfextension[] = INITQFNAMES;

	<span class="enscript-comment">/* XXX Shoulkd be an MNTK_ flag, instead of strncmp()'s */</span>
	<span class="enscript-keyword">if</span> (strncmp(mp-&gt;mnt_vfsstat.f_fstypename, <span class="enscript-string">&quot;hfs&quot;</span>, <span class="enscript-keyword">sizeof</span>(<span class="enscript-string">&quot;hfs&quot;</span>)) != 0 ) {
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/* 
	 * Enable filesystem disk quotas if necessary.
	 * We ignore errors as this should not interfere with final mount
	 */</span>
	<span class="enscript-keyword">for</span> (type=0; type &lt; MAXQUOTAS; type++) {
		snprintf(qfpath, <span class="enscript-keyword">sizeof</span>(qfpath), <span class="enscript-string">&quot;%s/%s.%s&quot;</span>, mp-&gt;mnt_vfsstat.f_mntonname, qfopsname, qfextension[type]);
		NDINIT(&amp;qnd, LOOKUP, OP_MOUNT, FOLLOW, UIO_SYSSPACE,
		       CAST_USER_ADDR_T(qfpath), ctx);
		<span class="enscript-keyword">if</span> (namei(&amp;qnd) != 0)
			<span class="enscript-keyword">continue</span>; 	    <span class="enscript-comment">/* option file to trigger quotas is not present */</span>
		vnode_put(qnd.ni_vp);
		nameidone(&amp;qnd);
		snprintf(qfpath, <span class="enscript-keyword">sizeof</span>(qfpath),  <span class="enscript-string">&quot;%s/%s.%s&quot;</span>, mp-&gt;mnt_vfsstat.f_mntonname, qfname, qfextension[type]);

		(<span class="enscript-type">void</span>) VFS_QUOTACTL(mp, QCMD(Q_QUOTAON, type), 0, qfpath, ctx);
	}
	<span class="enscript-keyword">return</span>;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">checkdirs_callback</span>(proc_t p, <span class="enscript-type">void</span> * arg) 
{
	<span class="enscript-type">struct</span> cdirargs * cdrp = (<span class="enscript-type">struct</span> cdirargs * )arg;
	vnode_t olddp = cdrp-&gt;olddp;
	vnode_t newdp = cdrp-&gt;newdp;
	<span class="enscript-type">struct</span> filedesc *fdp;
	vnode_t tvp;
	vnode_t fdp_cvp;
	vnode_t fdp_rvp;
	<span class="enscript-type">int</span> cdir_changed = 0;
	<span class="enscript-type">int</span> rdir_changed = 0;

	<span class="enscript-comment">/*
	 * XXX Also needs to iterate each thread in the process to see if it
	 * XXX is using a per-thread current working directory, and, if so,
	 * XXX update that as well.
	 */</span>

	proc_fdlock(p);
	fdp = p-&gt;p_fd;
	<span class="enscript-keyword">if</span> (fdp == (<span class="enscript-type">struct</span> filedesc *)0) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(PROC_RETURNED);
	}
	fdp_cvp = fdp-&gt;fd_cdir;
	fdp_rvp = fdp-&gt;fd_rdir;
	proc_fdunlock(p);

	<span class="enscript-keyword">if</span> (fdp_cvp == olddp) {
		vnode_ref(newdp);
		tvp = fdp-&gt;fd_cdir;
		fdp_cvp = newdp;
		cdir_changed = 1;
		vnode_rele(tvp);
	}
	<span class="enscript-keyword">if</span> (fdp_rvp == olddp) {
		vnode_ref(newdp);
		tvp = fdp-&gt;fd_rdir;
		fdp_rvp = newdp;
		rdir_changed = 1;
		vnode_rele(tvp);
	}
	<span class="enscript-keyword">if</span> (cdir_changed || rdir_changed) {
		proc_fdlock(p);
		fdp-&gt;fd_cdir = fdp_cvp;
		fdp-&gt;fd_rdir = fdp_rvp;
		proc_fdunlock(p);
	}
	<span class="enscript-keyword">return</span>(PROC_RETURNED);
}



<span class="enscript-comment">/*
 * Scan all active processes to see if any of them have a current
 * or root directory onto which the new filesystem has just been
 * mounted. If so, replace them with the new mount point.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">checkdirs</span>(vnode_t olddp, vfs_context_t ctx)
{
	vnode_t newdp;
	vnode_t tvp;
	<span class="enscript-type">int</span> err;
	<span class="enscript-type">struct</span> cdirargs cdr;

	<span class="enscript-keyword">if</span> (olddp-&gt;v_usecount == 1)
		<span class="enscript-keyword">return</span>(0);
	err = VFS_ROOT(olddp-&gt;v_mountedhere, &amp;newdp, ctx);

	<span class="enscript-keyword">if</span> (err != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		panic(<span class="enscript-string">&quot;mount: lost mount: error %d&quot;</span>, err);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span>(err);
	}

	cdr.olddp = olddp;
	cdr.newdp = newdp;
	<span class="enscript-comment">/* do not block for exec/fork trans as the vp in cwd &amp; rootdir are not changing */</span>
	proc_iterate(PROC_ALLPROCLIST | PROC_NOWAITTRANS, checkdirs_callback, (<span class="enscript-type">void</span> *)&amp;cdr, NULL, NULL);

	<span class="enscript-keyword">if</span> (rootvnode == olddp) {
		vnode_ref(newdp);
		tvp = rootvnode;
		rootvnode = newdp;
		vnode_rele(tvp);
	}

	vnode_put(newdp);
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Unmount a file system.
 *
 * Note: unmount takes a path to the vnode mounted on as argument,
 * not special file (as before).
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">unmount</span>(__unused proc_t p, <span class="enscript-type">struct</span> unmount_args *uap, __unused int32_t *retval)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> mount *mp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	vfs_context_t ctx = vfs_context_current();

	NDINIT(&amp;nd, LOOKUP, OP_UNMOUNT, FOLLOW | AUDITVNPATH1, 
		UIO_USERSPACE, uap-&gt;path, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	vp = nd.ni_vp;
	mp = vp-&gt;v_mount;
	nameidone(&amp;nd);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_mount_check_umount(ctx, mp);
	<span class="enscript-keyword">if</span> (error != 0) {
		vnode_put(vp);
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Must be the root of the filesystem
	 */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VROOT) == 0) {
		vnode_put(vp);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	mount_ref(mp, 0);
	vnode_put(vp);
	<span class="enscript-comment">/* safedounmount consumes the mount ref */</span>
	<span class="enscript-keyword">return</span> (safedounmount(mp, uap-&gt;flags, ctx));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_unmountbyfsid</span>(fsid_t * fsid, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	mount_t mp;

	mp = mount_list_lookupby_fsid(fsid, 0, 1);
	<span class="enscript-keyword">if</span> (mp == (mount_t)0) {
		<span class="enscript-keyword">return</span>(ENOENT);
	}
	mount_ref(mp, 0);
	mount_iterdrop(mp);
	<span class="enscript-comment">/* safedounmount consumes the mount ref */</span>
	<span class="enscript-keyword">return</span>(safedounmount(mp, flags, ctx));
}


<span class="enscript-comment">/*
 * The mount struct comes with a mount ref which will be consumed.
 * Do the actual file system unmount, prevent some common foot shooting.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">safedounmount</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;
	proc_t p = vfs_context_proc(ctx);

	<span class="enscript-comment">/*
	 * If the file system is not responding and MNT_NOBLOCK
	 * is set and not a forced unmount then return EBUSY.
	 */</span>
	<span class="enscript-keyword">if</span> ((mp-&gt;mnt_kern_flag &amp; MNT_LNOTRESP) &amp;&amp;
		(flags &amp; MNT_NOBLOCK) &amp;&amp; ((flags &amp; MNT_FORCE) == 0)) {
		error = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Skip authorization if the mount is tagged as permissive and 
	 * this is not a forced-unmount attempt.
	 */</span>
	<span class="enscript-keyword">if</span> (!(((mp-&gt;mnt_kern_flag &amp; MNTK_PERMIT_UNMOUNT) != 0) &amp;&amp; ((flags &amp; MNT_FORCE) == 0))) {
		<span class="enscript-comment">/*
		 * Only root, or the user that did the original mount is
		 * permitted to unmount this filesystem.
		 */</span>
		<span class="enscript-keyword">if</span> ((mp-&gt;mnt_vfsstat.f_owner != kauth_cred_getuid(kauth_cred_get())) &amp;&amp;
				(error = suser(kauth_cred_get(), &amp;p-&gt;p_acflag)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * Don't allow unmounting the root file system.
	 */</span>
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_flag &amp; MNT_ROOTFS) {
		error = EBUSY; <span class="enscript-comment">/* the root is always busy */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_IMGSRC_ACCESS</span>
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_kern_flag &amp; MNTK_BACKS_ROOT) {
		error = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IMGSRC_ACCESS */</span>

	<span class="enscript-keyword">return</span> (dounmount(mp, flags, 1, ctx));

<span class="enscript-reference">out</span>:
	mount_drop(mp, 0);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Do the actual file system unmount.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dounmount</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> withref, vfs_context_t ctx)
{
	vnode_t coveredvp = (vnode_t)0;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> needwakeup = 0;
	<span class="enscript-type">int</span> forcedunmount = 0;
	<span class="enscript-type">int</span> lflags = 0;
	<span class="enscript-type">struct</span> vnode *devvp = NULLVP;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	proc_t p = vfs_context_proc(ctx);
	<span class="enscript-type">int</span> did_vflush = 0;
	<span class="enscript-type">int</span> pflags_save = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_TRIGGERS */</span>

	mount_lock(mp);

	<span class="enscript-comment">/*
	 * If already an unmount in progress just return EBUSY.
	 * Even a forced unmount cannot override.
	 */</span>
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; MNT_LUNMOUNT) {
		<span class="enscript-keyword">if</span> (withref != 0)
			mount_drop(mp, 1);
		mount_unlock(mp);
		<span class="enscript-keyword">return</span> (EBUSY);
	}

	<span class="enscript-keyword">if</span> (flags &amp; MNT_FORCE) {
		forcedunmount = 1;
		mp-&gt;mnt_lflag |= MNT_LFORCE;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	<span class="enscript-keyword">if</span> (flags &amp; MNT_NOBLOCK &amp;&amp; p != kernproc)
		pflags_save = OSBitOrAtomic(P_NOREMOTEHANG, &amp;p-&gt;p_flag);
#<span class="enscript-reference">endif</span>

	mp-&gt;mnt_kern_flag |= MNTK_UNMOUNT;
	mp-&gt;mnt_lflag |= MNT_LUNMOUNT;
	mp-&gt;mnt_flag &amp;=~ MNT_ASYNC;
	<span class="enscript-comment">/*
	 * anyone currently in the fast path that
	 * trips over the cached rootvp will be
	 * dumped out and forced into the slow path
	 * to regenerate a new cached value
	 */</span>
	mp-&gt;mnt_realrootvp = NULLVP;
	mount_unlock(mp);
 
	<span class="enscript-keyword">if</span> (forcedunmount &amp;&amp; (flags &amp; MNT_LNOSUB) == 0) {
		<span class="enscript-comment">/*
		 * Force unmount any mounts in this filesystem.
		 * If any unmounts fail - just leave them dangling.
		 * Avoids recursion.
		 */</span>
		(<span class="enscript-type">void</span>) dounmount_submounts(mp, flags | MNT_LNOSUB, ctx);
	}

	<span class="enscript-comment">/*
	 * taking the name_cache_lock exclusively will
	 * insure that everyone is out of the fast path who
	 * might be trying to use a now stale copy of
	 * vp-&gt;v_mountedhere-&gt;mnt_realrootvp
	 * bumping mount_generation causes the cached values
	 * to be invalidated
	 */</span>
	name_cache_lock();
	mount_generation++;
	name_cache_unlock();


	lck_rw_lock_exclusive(&amp;mp-&gt;mnt_rwlock);
	<span class="enscript-keyword">if</span> (withref != 0)
		mount_drop(mp, 0);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	fsevent_unmount(mp);  <span class="enscript-comment">/* has to come first! */</span>
#<span class="enscript-reference">endif</span>
	error = 0;
	<span class="enscript-keyword">if</span> (forcedunmount == 0) {
		ubc_umount(mp);	<span class="enscript-comment">/* release cached vnodes */</span>
		<span class="enscript-keyword">if</span> ((mp-&gt;mnt_flag &amp; MNT_RDONLY) == 0) {
			error = VFS_SYNC(mp, MNT_WAIT, ctx);
			<span class="enscript-keyword">if</span> (error) {
				mount_lock(mp);
				mp-&gt;mnt_kern_flag &amp;= ~MNTK_UNMOUNT;
				mp-&gt;mnt_lflag &amp;= ~MNT_LUNMOUNT;
				mp-&gt;mnt_lflag &amp;= ~MNT_LFORCE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}

	IOBSDMountChange(mp, kIOMountChangeUnmount);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	vfs_nested_trigger_unmounts(mp, flags, ctx);
	did_vflush = 1;
#<span class="enscript-reference">endif</span>	
	<span class="enscript-keyword">if</span> (forcedunmount)
		lflags |= FORCECLOSE;
	error = vflush(mp, NULLVP, SKIPSWAP | SKIPSYSTEM  | SKIPROOT | lflags);
	<span class="enscript-keyword">if</span> ((forcedunmount == 0) &amp;&amp; error) {
		mount_lock(mp);
		mp-&gt;mnt_kern_flag &amp;= ~MNTK_UNMOUNT;
		mp-&gt;mnt_lflag &amp;= ~MNT_LUNMOUNT;
		mp-&gt;mnt_lflag &amp;= ~MNT_LFORCE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* make sure there are no one in the mount iterations or lookup */</span>
	mount_iterdrain(mp);

	error = VFS_UNMOUNT(mp, flags, ctx);
	<span class="enscript-keyword">if</span> (error) {
		mount_iterreset(mp);
		mount_lock(mp);
		mp-&gt;mnt_kern_flag &amp;= ~MNTK_UNMOUNT;
		mp-&gt;mnt_lflag &amp;= ~MNT_LUNMOUNT;
		mp-&gt;mnt_lflag &amp;= ~MNT_LFORCE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* increment the operations count */</span>
	<span class="enscript-keyword">if</span> (!error)
		OSAddAtomic(1, &amp;vfs_nummntops);

	<span class="enscript-keyword">if</span> ( mp-&gt;mnt_devvp &amp;&amp; mp-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSLOCALARGS) {
		<span class="enscript-comment">/* hold an io reference and drop the usecount before close */</span>
		devvp = mp-&gt;mnt_devvp;
		vnode_getalways(devvp);
		vnode_rele(devvp);
		VNOP_CLOSE(devvp, mp-&gt;mnt_flag &amp; MNT_RDONLY ? FREAD : FREAD|FWRITE,
                       ctx);
		vnode_clearmountedon(devvp);
		vnode_put(devvp);
	}
	lck_rw_done(&amp;mp-&gt;mnt_rwlock);
	mount_list_remove(mp);
	lck_rw_lock_exclusive(&amp;mp-&gt;mnt_rwlock);

	<span class="enscript-comment">/* mark the mount point hook in the vp but not drop the ref yet */</span>
	<span class="enscript-keyword">if</span> ((coveredvp = mp-&gt;mnt_vnodecovered) != NULLVP) {
		<span class="enscript-comment">/*
		 * The covered vnode needs special handling. Trying to get an
		 * iocount must not block here as this may lead to deadlocks
		 * if the Filesystem to which the covered vnode belongs is
		 * undergoing forced unmounts. Since we hold a usecount, the
		 * vnode cannot be reused (it can, however, still be terminated)
		 */</span>
		vnode_getalways(coveredvp);
		vnode_lock_spin(coveredvp);

		mp-&gt;mnt_crossref++;
		coveredvp-&gt;v_mountedhere = (<span class="enscript-type">struct</span> mount *)0;
		CLR(coveredvp-&gt;v_flag, VMOUNT);

		vnode_unlock(coveredvp);
		vnode_put(coveredvp);
	}

	mount_list_lock();
	mp-&gt;mnt_vtable-&gt;vfc_refcount--;
	mount_list_unlock();

	cache_purgevfs(mp);	<span class="enscript-comment">/* remove cache entries for this file sys */</span>
	vfs_event_signal(NULL, VQ_UNMOUNT, (intptr_t)NULL);
	mount_lock(mp);
	mp-&gt;mnt_lflag |= MNT_LDEAD;

	<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; MNT_LWAIT) {
	        <span class="enscript-comment">/*
		 * do the wakeup here
		 * in case we block in mount_refdrain
		 * which will drop the mount lock
		 * and allow anyone blocked in vfs_busy
		 * to wakeup and see the LDEAD state
		 */</span>
		mp-&gt;mnt_lflag &amp;= ~MNT_LWAIT;
		wakeup((caddr_t)mp);
	}
	mount_refdrain(mp);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; MNT_LWAIT) {
		mp-&gt;mnt_lflag &amp;= ~MNT_LWAIT;
		needwakeup = 1;	
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	<span class="enscript-keyword">if</span> (flags &amp; MNT_NOBLOCK &amp;&amp; p != kernproc) {
	 	<span class="enscript-comment">// Restore P_NOREMOTEHANG bit to its previous value
</span>		<span class="enscript-keyword">if</span> ((pflags_save &amp; P_NOREMOTEHANG) == 0)
			OSBitAndAtomic(~((uint32_t) P_NOREMOTEHANG), &amp;p-&gt;p_flag);
	}

	<span class="enscript-comment">/* 
	 * Callback and context are set together under the mount lock, and
	 * never cleared, so we're safe to examine them here, drop the lock, 
	 * and call out.
	 */</span>
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_triggercallback != NULL) {
		mount_unlock(mp);
		<span class="enscript-keyword">if</span> (error == 0) {
			mp-&gt;mnt_triggercallback(mp, VTC_RELEASE, mp-&gt;mnt_triggerdata, ctx);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (did_vflush) {
			mp-&gt;mnt_triggercallback(mp, VTC_REPLACE, mp-&gt;mnt_triggerdata, ctx);
		}
	} <span class="enscript-keyword">else</span> {
		mount_unlock(mp);
	}
#<span class="enscript-reference">else</span> 
	mount_unlock(mp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_TRIGGERS */</span>

	lck_rw_done(&amp;mp-&gt;mnt_rwlock);

	<span class="enscript-keyword">if</span> (needwakeup)
		wakeup((caddr_t)mp);

	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-keyword">if</span> ((coveredvp != NULLVP)) {
			vnode_t pvp = NULLVP;

			<span class="enscript-comment">/*
			 * The covered vnode needs special handling. Trying to
			 * get an iocount must not block here as this may lead
			 * to deadlocks if the Filesystem to which the covered
			 * vnode belongs is undergoing forced unmounts. Since we
			 * hold a usecount, the  vnode cannot be reused
			 * (it can, however, still be terminated).
			 */</span>
			vnode_getalways(coveredvp);

			mount_dropcrossref(mp, coveredvp, 0);
			<span class="enscript-comment">/*
			 * We'll _try_ to detect if this really needs to be
			 * done. The coveredvp can only be in termination (or
			 * terminated) if the coveredvp's mount point is in a
			 * forced unmount (or has been) since we still hold the
			 * ref.
			 */</span>
			<span class="enscript-keyword">if</span> (!vnode_isrecycled(coveredvp)) {
				pvp = vnode_getparent(coveredvp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
				<span class="enscript-keyword">if</span> (coveredvp-&gt;v_resolve) {
					vnode_trigger_rearm(coveredvp, ctx);
				}
#<span class="enscript-reference">endif</span>
			}

			vnode_rele(coveredvp);
			vnode_put(coveredvp);
			coveredvp = NULLVP;

			<span class="enscript-keyword">if</span> (pvp) {
				lock_vnode_and_post(pvp, NOTE_WRITE);
				vnode_put(pvp);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mp-&gt;mnt_flag &amp; MNT_ROOTFS) {
				mount_lock_destroy(mp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
				mac_mount_label_destroy(mp);
#<span class="enscript-reference">endif</span>
				FREE_ZONE((caddr_t)mp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mount), M_MOUNT);
		} <span class="enscript-keyword">else</span>
			panic(<span class="enscript-string">&quot;dounmount: no coveredvp&quot;</span>);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Unmount any mounts in this filesystem.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dounmount_submounts</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	mount_t	smp;
	fsid_t *fsids, fsid;
	<span class="enscript-type">int</span> fsids_sz;
	<span class="enscript-type">int</span> count = 0, i, m = 0;
	vnode_t vp;

	mount_list_lock();

	<span class="enscript-comment">// Get an array to hold the submounts fsids.
</span>	TAILQ_FOREACH(smp, &amp;mountlist, mnt_list)
		count++;
	fsids_sz = count * <span class="enscript-keyword">sizeof</span>(fsid_t);
	MALLOC(fsids, fsid_t *, fsids_sz, M_TEMP, M_NOWAIT);
	<span class="enscript-keyword">if</span> (fsids == NULL) {
		mount_list_unlock();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	fsids[0] = mp-&gt;mnt_vfsstat.f_fsid;	<span class="enscript-comment">// Prime the pump
</span>
	<span class="enscript-comment">/*
	 * Fill the array with submount fsids.
	 * Since mounts are always added to the tail of the mount list, the
	 * list is always in mount order.  
	 * For each mount check if the mounted-on vnode belongs to a
	 * mount that's already added to our array of mounts to be unmounted.
	 */</span>
	<span class="enscript-keyword">for</span> (smp = TAILQ_NEXT(mp, mnt_list); smp; smp = TAILQ_NEXT(smp, mnt_list)) {
		vp = smp-&gt;mnt_vnodecovered;
		<span class="enscript-keyword">if</span> (vp == NULL)
			<span class="enscript-keyword">continue</span>;
		fsid = vnode_mount(vp)-&gt;mnt_vfsstat.f_fsid;	<span class="enscript-comment">// Underlying fsid
</span>		<span class="enscript-keyword">for</span> (i = 0; i &lt;= m; i++) {
			<span class="enscript-keyword">if</span> (fsids[i].val[0] == fsid.val[0] &amp;&amp;
			    fsids[i].val[1] == fsid.val[1]) {
				fsids[++m] = smp-&gt;mnt_vfsstat.f_fsid;
				<span class="enscript-keyword">break</span>;
			}
		}
	}
	mount_list_unlock();

	<span class="enscript-comment">// Unmount the submounts in reverse order. Ignore errors.
</span>	<span class="enscript-keyword">for</span> (i = m; i &gt; 0; i--) {
		smp = mount_list_lookupby_fsid(&amp;fsids[i], 0, 1);
		<span class="enscript-keyword">if</span> (smp) {
			mount_ref(smp, 0);
			mount_iterdrop(smp);
			(<span class="enscript-type">void</span>) dounmount(smp, flags, 1, ctx);
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (fsids)
		FREE(fsids, M_TEMP);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_dropcrossref</span>(mount_t mp, vnode_t dp, <span class="enscript-type">int</span> need_put)
{
	vnode_lock(dp);
	mp-&gt;mnt_crossref--;

	<span class="enscript-keyword">if</span> (mp-&gt;mnt_crossref &lt; 0)
		panic(<span class="enscript-string">&quot;mount cross refs -ve&quot;</span>);

	<span class="enscript-keyword">if</span> ((mp != dp-&gt;v_mountedhere) &amp;&amp; (mp-&gt;mnt_crossref == 0)) {
			
		<span class="enscript-keyword">if</span> (need_put)
			vnode_put_locked(dp);
		vnode_unlock(dp);

		mount_lock_destroy(mp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_mount_label_destroy(mp);
#<span class="enscript-reference">endif</span>
		FREE_ZONE((caddr_t)mp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mount), M_MOUNT);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (need_put)
		vnode_put_locked(dp);
	vnode_unlock(dp);
}


<span class="enscript-comment">/*
 * Sync each mounted filesystem.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
<span class="enscript-type">int</span> syncprt = 0;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span> print_vmpage_stat=0;
<span class="enscript-type">int</span> sync_timeout = 60;  <span class="enscript-comment">// Sync time limit (sec)
</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">sync_callback</span>(mount_t mp, __unused <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-keyword">if</span> ((mp-&gt;mnt_flag &amp; MNT_RDONLY) == 0) {
		<span class="enscript-type">int</span> asyncflag = mp-&gt;mnt_flag &amp; MNT_ASYNC;

		mp-&gt;mnt_flag &amp;= ~MNT_ASYNC;
		VFS_SYNC(mp, arg ? MNT_WAIT : MNT_NOWAIT, vfs_context_kernel());
		<span class="enscript-keyword">if</span> (asyncflag)
			mp-&gt;mnt_flag |= MNT_ASYNC;
	}

	<span class="enscript-keyword">return</span> (VFS_RETURNED);
}

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sync</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> sync_args *uap, __unused int32_t *retval)
{
	vfs_iterate(LK_NOWAIT, sync_callback, NULL);

	<span class="enscript-keyword">if</span> (print_vmpage_stat) {
		vm_countdirtypages();
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (syncprt)
		vfs_bufstats();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAGNOSTIC */</span>
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sync_thread</span>(<span class="enscript-type">void</span> *arg, __unused wait_result_t wr)
{
	<span class="enscript-type">int</span> *timeout = (<span class="enscript-type">int</span> *) arg;

	vfs_iterate(LK_NOWAIT, sync_callback, NULL);

	<span class="enscript-keyword">if</span> (timeout)
		wakeup((caddr_t) timeout);
	<span class="enscript-keyword">if</span> (print_vmpage_stat) {
		vm_countdirtypages();
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (syncprt)
		vfs_bufstats();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAGNOSTIC */</span>
}

<span class="enscript-comment">/*
 * Sync in a separate thread so we can time out if it blocks.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sync_async</span>(<span class="enscript-type">int</span> timeout)
{
	thread_t thd;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> timespec ts = {timeout, 0};

	lck_mtx_lock(sync_mtx_lck);
	<span class="enscript-keyword">if</span> (kernel_thread_start(sync_thread, &amp;timeout, &amp;thd) != KERN_SUCCESS) {
		printf(<span class="enscript-string">&quot;sync_thread failed\n&quot;</span>);
		lck_mtx_unlock(sync_mtx_lck);
		<span class="enscript-keyword">return</span> (0);
	}

	error = msleep((caddr_t) &amp;timeout, sync_mtx_lck, (PVFS | PDROP | PCATCH), <span class="enscript-string">&quot;sync_thread&quot;</span>, &amp;ts);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;sync timed out: %d sec\n&quot;</span>, timeout);
	}
	thread_deallocate(thd);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * An in-kernel sync for power management to call.
 */</span>
__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sync_internal</span>(<span class="enscript-type">void</span>)
{
	(<span class="enscript-type">void</span>) sync_async(sync_timeout);

	<span class="enscript-keyword">return</span> 0;
} <span class="enscript-comment">/* end of sync_internal call */</span>

<span class="enscript-comment">/*
 * Change filesystem quotas.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">quotactl</span>(proc_t p, <span class="enscript-type">struct</span> quotactl_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> mount *mp;
	<span class="enscript-type">int</span> error, quota_cmd, quota_status;
	caddr_t datap;
	size_t fnamelen;
	<span class="enscript-type">struct</span> nameidata nd;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">struct</span> dqblk my_dqblk;

	AUDIT_ARG(uid, uap-&gt;uid);
	AUDIT_ARG(cmd, uap-&gt;cmd);
	NDINIT(&amp;nd, LOOKUP, OP_LOOKUP, FOLLOW | AUDITVNPATH1, UIO_USERSPACE,
	       uap-&gt;path, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	mp = nd.ni_vp-&gt;v_mount;
	vnode_put(nd.ni_vp);
	nameidone(&amp;nd);

	<span class="enscript-comment">/* copyin any data we will need for downstream code */</span>
	quota_cmd = uap-&gt;cmd &gt;&gt; SUBCMDSHIFT;

	<span class="enscript-keyword">switch</span> (quota_cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_QUOTAON</span>:
		<span class="enscript-comment">/* uap-&gt;arg specifies a file from which to take the quotas */</span>
		fnamelen = MAXPATHLEN;
		datap = kalloc(MAXPATHLEN);
		error = copyinstr(uap-&gt;arg, datap, MAXPATHLEN, &amp;fnamelen);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_GETQUOTA</span>:
		<span class="enscript-comment">/* uap-&gt;arg is a pointer to a dqblk structure. */</span>
		datap = (caddr_t) &amp;my_dqblk;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_SETQUOTA</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_SETUSE</span>:
		<span class="enscript-comment">/* uap-&gt;arg is a pointer to a dqblk structure. */</span>
		datap = (caddr_t) &amp;my_dqblk;
		<span class="enscript-keyword">if</span> (proc_is64bit(p)) {
			<span class="enscript-type">struct</span> user_dqblk	my_dqblk64;
			error = copyin(uap-&gt;arg, (caddr_t)&amp;my_dqblk64, <span class="enscript-keyword">sizeof</span> (my_dqblk64));
			<span class="enscript-keyword">if</span> (error == 0) {
				munge_dqblk(&amp;my_dqblk, &amp;my_dqblk64, FALSE);
			}
		}
		<span class="enscript-keyword">else</span> {
			error = copyin(uap-&gt;arg, (caddr_t)&amp;my_dqblk, <span class="enscript-keyword">sizeof</span> (my_dqblk));
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_QUOTASTAT</span>:
		<span class="enscript-comment">/* uap-&gt;arg is a pointer to an integer */</span>
		datap = (caddr_t) &amp;quota_status;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		datap = NULL;
		<span class="enscript-keyword">break</span>;
	} <span class="enscript-comment">/* switch */</span>

	<span class="enscript-keyword">if</span> (error == 0) {
		error = VFS_QUOTACTL(mp, uap-&gt;cmd, uap-&gt;uid, datap, ctx);
	}

	<span class="enscript-keyword">switch</span> (quota_cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_QUOTAON</span>:
		<span class="enscript-keyword">if</span> (datap != NULL)
			kfree(datap, MAXPATHLEN);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_GETQUOTA</span>:
		<span class="enscript-comment">/* uap-&gt;arg is a pointer to a dqblk structure we need to copy out to */</span>
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-keyword">if</span> (proc_is64bit(p)) {
				<span class="enscript-type">struct</span> user_dqblk	my_dqblk64 = {.dqb_bhardlimit = 0};
				munge_dqblk(&amp;my_dqblk, &amp;my_dqblk64, TRUE);
				error = copyout((caddr_t)&amp;my_dqblk64, uap-&gt;arg, <span class="enscript-keyword">sizeof</span> (my_dqblk64));
			}
			<span class="enscript-keyword">else</span> {
				error = copyout(datap, uap-&gt;arg, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> dqblk));
			}
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_QUOTASTAT</span>:
		<span class="enscript-comment">/* uap-&gt;arg is a pointer to an integer */</span>
		<span class="enscript-keyword">if</span> (error == 0) {
			error = copyout(datap, uap-&gt;arg, <span class="enscript-keyword">sizeof</span>(quota_status));
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	} <span class="enscript-comment">/* switch */</span>

	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">quotactl</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> quotactl_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (EOPNOTSUPP);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

<span class="enscript-comment">/*
 * Get filesystem statistics.
 *
 * Returns:	0			Success
 *	namei:???
 *	vfs_update_vfsstat:???
 *	munge_statfs:EFAULT
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">statfs</span>(__unused proc_t p, <span class="enscript-type">struct</span> statfs_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> mount *mp;
	<span class="enscript-type">struct</span> vfsstatfs *sp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	vfs_context_t ctx = vfs_context_current();
	vnode_t vp;

	NDINIT(&amp;nd, LOOKUP, OP_STATFS, FOLLOW | AUDITVNPATH1, 
		UIO_USERSPACE, uap-&gt;path, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	vp = nd.ni_vp;
	mp = vp-&gt;v_mount;
	sp = &amp;mp-&gt;mnt_vfsstat;
	nameidone(&amp;nd);

	error = vfs_update_vfsstat(mp, ctx, VFS_USER_EVENT);
	<span class="enscript-keyword">if</span> (error != 0) { 
		vnode_put(vp);
		<span class="enscript-keyword">return</span> (error);
	}

	error = munge_statfs(mp, sp, uap-&gt;buf, NULL, IS_64BIT_PROCESS(p), TRUE);
	vnode_put(vp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Get filesystem statistics.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fstatfs</span>(__unused proc_t p, <span class="enscript-type">struct</span> fstatfs_args *uap, __unused int32_t *retval)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> mount *mp;
	<span class="enscript-type">struct</span> vfsstatfs *sp;
	<span class="enscript-type">int</span> error;

	AUDIT_ARG(fd, uap-&gt;fd);

	<span class="enscript-keyword">if</span> ( (error = file_vnode(uap-&gt;fd, &amp;vp)) )
		<span class="enscript-keyword">return</span> (error);

	error = vnode_getwithref(vp);
	<span class="enscript-keyword">if</span> (error) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span> (error);
	}

	AUDIT_ARG(vnpath_withref, vp, ARG_VNODE1);

	mp = vp-&gt;v_mount;
	<span class="enscript-keyword">if</span> (!mp) {
		error = EBADF;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	sp = &amp;mp-&gt;mnt_vfsstat;
	<span class="enscript-keyword">if</span> ((error = vfs_update_vfsstat(mp,vfs_context_current(),VFS_USER_EVENT)) != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = munge_statfs(mp, sp, uap-&gt;buf, NULL, IS_64BIT_PROCESS(p), TRUE);

<span class="enscript-reference">out</span>:
	file_drop(uap-&gt;fd);
	vnode_put(vp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* 
 * Common routine to handle copying of statfs64 data to user space 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">statfs64_common</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vfsstatfs *sfsp, user_addr_t bufp)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> statfs64 sfs;
	
	bzero(&amp;sfs, <span class="enscript-keyword">sizeof</span>(sfs));

	sfs.f_bsize = sfsp-&gt;f_bsize;
	sfs.f_iosize = (int32_t)sfsp-&gt;f_iosize;
	sfs.f_blocks = sfsp-&gt;f_blocks;
	sfs.f_bfree = sfsp-&gt;f_bfree;
	sfs.f_bavail = sfsp-&gt;f_bavail;
	sfs.f_files = sfsp-&gt;f_files;
	sfs.f_ffree = sfsp-&gt;f_ffree;
	sfs.f_fsid = sfsp-&gt;f_fsid;
	sfs.f_owner = sfsp-&gt;f_owner;
	sfs.f_type = mp-&gt;mnt_vtable-&gt;vfc_typenum;
	sfs.f_flags = mp-&gt;mnt_flag &amp; MNT_VISFLAGMASK;
	sfs.f_fssubtype = sfsp-&gt;f_fssubtype;
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_kern_flag &amp; MNTK_TYPENAME_OVERRIDE) {
		strlcpy(&amp;sfs.f_fstypename[0], &amp;mp-&gt;fstypename_override[0], MFSTYPENAMELEN);
	} <span class="enscript-keyword">else</span> {
		strlcpy(&amp;sfs.f_fstypename[0], &amp;sfsp-&gt;f_fstypename[0], MFSTYPENAMELEN);
	}
	strlcpy(&amp;sfs.f_mntonname[0], &amp;sfsp-&gt;f_mntonname[0], MAXPATHLEN);
	strlcpy(&amp;sfs.f_mntfromname[0], &amp;sfsp-&gt;f_mntfromname[0], MAXPATHLEN);

	error = copyout((caddr_t)&amp;sfs, bufp, <span class="enscript-keyword">sizeof</span>(sfs));

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/* 
 * Get file system statistics in 64-bit mode 
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">statfs64</span>(__unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> statfs64_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> mount *mp;
	<span class="enscript-type">struct</span> vfsstatfs *sp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	vfs_context_t ctxp = vfs_context_current();
	vnode_t vp;

	NDINIT(&amp;nd, LOOKUP, OP_STATFS, FOLLOW | AUDITVNPATH1, 
		UIO_USERSPACE, uap-&gt;path, ctxp);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	vp = nd.ni_vp;
	mp = vp-&gt;v_mount;
	sp = &amp;mp-&gt;mnt_vfsstat;
	nameidone(&amp;nd);

	error = vfs_update_vfsstat(mp, ctxp, VFS_USER_EVENT);
	<span class="enscript-keyword">if</span> (error != 0) { 
		vnode_put(vp);
		<span class="enscript-keyword">return</span> (error);
	}

	error = statfs64_common(mp, sp, uap-&gt;buf);
	vnode_put(vp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* 
 * Get file system statistics in 64-bit mode 
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fstatfs64</span>(__unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> fstatfs64_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">struct</span> mount *mp;
	<span class="enscript-type">struct</span> vfsstatfs *sp;
	<span class="enscript-type">int</span> error;

	AUDIT_ARG(fd, uap-&gt;fd);

	<span class="enscript-keyword">if</span> ( (error = file_vnode(uap-&gt;fd, &amp;vp)) )
		<span class="enscript-keyword">return</span> (error);

	error = vnode_getwithref(vp);
	<span class="enscript-keyword">if</span> (error) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span> (error);
	}

	AUDIT_ARG(vnpath_withref, vp, ARG_VNODE1);

	mp = vp-&gt;v_mount;
	<span class="enscript-keyword">if</span> (!mp) {
		error = EBADF;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	sp = &amp;mp-&gt;mnt_vfsstat;
	<span class="enscript-keyword">if</span> ((error = vfs_update_vfsstat(mp, vfs_context_current(), VFS_USER_EVENT)) != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = statfs64_common(mp, sp, uap-&gt;buf);

<span class="enscript-reference">out</span>:
	file_drop(uap-&gt;fd);
	vnode_put(vp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">struct</span> getfsstat_struct {
	user_addr_t	sfsp;
	user_addr_t	*mp;
	<span class="enscript-type">int</span>		count;
	<span class="enscript-type">int</span>		maxcount;
	<span class="enscript-type">int</span>		flags;
	<span class="enscript-type">int</span>		error;
};


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getfsstat_callback</span>(mount_t mp, <span class="enscript-type">void</span> * arg)
{
	
	<span class="enscript-type">struct</span> getfsstat_struct *fstp = (<span class="enscript-type">struct</span> getfsstat_struct *)arg;
	<span class="enscript-type">struct</span> vfsstatfs *sp;
	<span class="enscript-type">int</span> error, my_size;
	vfs_context_t ctx = vfs_context_current();

	<span class="enscript-keyword">if</span> (fstp-&gt;sfsp &amp;&amp; fstp-&gt;count &lt; fstp-&gt;maxcount) {
		sp = &amp;mp-&gt;mnt_vfsstat;
		<span class="enscript-comment">/*
		 * If MNT_NOWAIT is specified, do not refresh the
		 * fsstat cache. MNT_WAIT/MNT_DWAIT overrides MNT_NOWAIT.
		 */</span>
		<span class="enscript-keyword">if</span> (((fstp-&gt;flags &amp; MNT_NOWAIT) == 0 || (fstp-&gt;flags &amp; (MNT_WAIT | MNT_DWAIT))) &amp;&amp;
			(error = vfs_update_vfsstat(mp, ctx,
			    VFS_USER_EVENT))) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;vfs_update_vfsstat returned %d&quot;</span>, error);
			<span class="enscript-keyword">return</span>(VFS_RETURNED);
		}

		<span class="enscript-comment">/*
		 * Need to handle LP64 version of struct statfs
		 */</span>
		error = munge_statfs(mp, sp, fstp-&gt;sfsp, &amp;my_size, IS_64BIT_PROCESS(vfs_context_proc(ctx)), FALSE);
		<span class="enscript-keyword">if</span> (error) {
			fstp-&gt;error = error;
			<span class="enscript-keyword">return</span>(VFS_RETURNED_DONE);
		}
		fstp-&gt;sfsp += my_size;

		<span class="enscript-keyword">if</span> (fstp-&gt;mp) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
			error = mac_mount_label_get(mp, *fstp-&gt;mp);
			<span class="enscript-keyword">if</span> (error) {
				fstp-&gt;error = error;
				<span class="enscript-keyword">return</span>(VFS_RETURNED_DONE);
			}
#<span class="enscript-reference">endif</span>
			fstp-&gt;mp++;
		}
	}
	fstp-&gt;count++;
	<span class="enscript-keyword">return</span>(VFS_RETURNED);
}

<span class="enscript-comment">/*
 * Get statistics on all filesystems.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getfsstat</span>(__unused proc_t p, <span class="enscript-type">struct</span> getfsstat_args *uap, <span class="enscript-type">int</span> *retval)
{
	<span class="enscript-type">struct</span> __mac_getfsstat_args muap;

	muap.buf = uap-&gt;buf;
	muap.bufsize = uap-&gt;bufsize;
	muap.mac = USER_ADDR_NULL;
	muap.macsize = 0;
	muap.flags = uap-&gt;flags;

	<span class="enscript-keyword">return</span> (__mac_getfsstat(p, &amp;muap, retval));
}

<span class="enscript-comment">/*
 * __mac_getfsstat: Get MAC-related file system statistics
 *
 * Parameters:    p                        (ignored)
 *                uap                      User argument descriptor (see below)
 *                retval                   Count of file system statistics (N stats)  
 *
 * Indirect:      uap-&gt;bufsize             Buffer size
 *                uap-&gt;macsize             MAC info size
 *                uap-&gt;buf                 Buffer where information will be returned
 *                uap-&gt;mac                 MAC info
 *                uap-&gt;flags               File system flags
 *                
 *
 * Returns:        0                       Success
 *                !0                       Not success
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_getfsstat</span>(__unused proc_t p, <span class="enscript-type">struct</span> __mac_getfsstat_args *uap, <span class="enscript-type">int</span> *retval)
{
	user_addr_t sfsp;
	user_addr_t *mp;
	size_t count, maxcount, bufsize, macsize;
	<span class="enscript-type">struct</span> getfsstat_struct fst;

	bufsize = (size_t) uap-&gt;bufsize;
	macsize = (size_t) uap-&gt;macsize;

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		maxcount = bufsize / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_statfs);
	}
	<span class="enscript-keyword">else</span> {
		maxcount = bufsize / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_statfs);
	}
	sfsp = uap-&gt;buf;
	count = 0;

	mp = NULL;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (uap-&gt;mac != USER_ADDR_NULL) {
		u_int32_t *mp0;
		<span class="enscript-type">int</span> error;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

		count = (macsize / (IS_64BIT_PROCESS(p) ? 8 : 4));
		<span class="enscript-keyword">if</span> (count != maxcount)
			<span class="enscript-keyword">return</span> (EINVAL);

		<span class="enscript-comment">/* Copy in the array */</span>
		MALLOC(mp0, u_int32_t *, macsize, M_MACTEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (mp0 == NULL) {
			<span class="enscript-keyword">return</span> (ENOMEM);
		}

		error = copyin(uap-&gt;mac, mp0, macsize);
		<span class="enscript-keyword">if</span> (error) {
			FREE(mp0, M_MACTEMP);
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-comment">/* Normalize to an array of user_addr_t */</span>
		MALLOC(mp, user_addr_t *, count * <span class="enscript-keyword">sizeof</span>(user_addr_t), M_MACTEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (mp == NULL) {
			FREE(mp0, M_MACTEMP);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}

		<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
			<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p))
				mp[i] = ((user_addr_t *)mp0)[i];
			<span class="enscript-keyword">else</span>
				mp[i] = (user_addr_t)mp0[i];
		}
		FREE(mp0, M_MACTEMP);
	}
#<span class="enscript-reference">endif</span>


	fst.sfsp = sfsp;
	fst.mp = mp;
	fst.flags = uap-&gt;flags;
	fst.count = 0;
	fst.error = 0;
	fst.maxcount = maxcount;

	
	vfs_iterate(0, getfsstat_callback, &amp;fst);

	<span class="enscript-keyword">if</span> (mp)
		FREE(mp, M_MACTEMP);

	<span class="enscript-keyword">if</span> (fst.error ) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;ERROR - %s gets %d&quot;</span>, p-&gt;p_comm, fst.error);
		<span class="enscript-keyword">return</span>(fst.error);
	}

	<span class="enscript-keyword">if</span> (fst.sfsp &amp;&amp; fst.count &gt; fst.maxcount)
		*retval = fst.maxcount;
	<span class="enscript-keyword">else</span>
		*retval = fst.count;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getfsstat64_callback</span>(mount_t mp, <span class="enscript-type">void</span> * arg)
{
	<span class="enscript-type">struct</span> getfsstat_struct *fstp = (<span class="enscript-type">struct</span> getfsstat_struct *)arg;
	<span class="enscript-type">struct</span> vfsstatfs *sp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (fstp-&gt;sfsp &amp;&amp; fstp-&gt;count &lt; fstp-&gt;maxcount) {
		sp = &amp;mp-&gt;mnt_vfsstat;
		<span class="enscript-comment">/*
		 * If MNT_NOWAIT is specified, do not refresh the fsstat
		 * cache. MNT_WAIT overrides MNT_NOWAIT.
		 *
		 * We treat MNT_DWAIT as MNT_WAIT for all instances of
		 * getfsstat, since the constants are out of the same
		 * namespace.
		 */</span>
		<span class="enscript-keyword">if</span> (((fstp-&gt;flags &amp; MNT_NOWAIT) == 0 ||
		     (fstp-&gt;flags &amp; (MNT_WAIT | MNT_DWAIT))) &amp;&amp;
		    (error = vfs_update_vfsstat(mp, vfs_context_current(), VFS_USER_EVENT))) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;vfs_update_vfsstat returned %d&quot;</span>, error);
			<span class="enscript-keyword">return</span>(VFS_RETURNED);
		}

		error = statfs64_common(mp, sp, fstp-&gt;sfsp);
		<span class="enscript-keyword">if</span> (error) {
			fstp-&gt;error = error;
			<span class="enscript-keyword">return</span>(VFS_RETURNED_DONE);
		}
		fstp-&gt;sfsp += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> statfs64);
	}
	fstp-&gt;count++;
	<span class="enscript-keyword">return</span>(VFS_RETURNED);
}

<span class="enscript-comment">/*
 * Get statistics on all file systems in 64 bit mode.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getfsstat64</span>(__unused proc_t p, <span class="enscript-type">struct</span> getfsstat64_args *uap, <span class="enscript-type">int</span> *retval)
{
	user_addr_t sfsp;
	<span class="enscript-type">int</span> count, maxcount;
	<span class="enscript-type">struct</span> getfsstat_struct fst;

	maxcount = uap-&gt;bufsize / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> statfs64);

	sfsp = uap-&gt;buf;
	count = 0;

	fst.sfsp = sfsp;
	fst.flags = uap-&gt;flags;
	fst.count = 0;
	fst.error = 0;
	fst.maxcount = maxcount;

	vfs_iterate(0, getfsstat64_callback, &amp;fst);

	<span class="enscript-keyword">if</span> (fst.error ) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;ERROR - %s gets %d&quot;</span>, p-&gt;p_comm, fst.error);
		<span class="enscript-keyword">return</span>(fst.error);
	}

	<span class="enscript-keyword">if</span> (fst.sfsp &amp;&amp; fst.count &gt; fst.maxcount)
		*retval = fst.maxcount;
	<span class="enscript-keyword">else</span>
		*retval = fst.count;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * gets the associated vnode with the file descriptor passed.
 * as input
 *
 * INPUT
 * ctx - vfs context of caller
 * fd - file descriptor for which vnode is required.
 * vpp - Pointer to pointer to vnode to be returned.
 *
 * The vnode is returned with an iocount so any vnode obtained
 * by this call needs a vnode_put
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_getfromfd</span>(vfs_context_t ctx, <span class="enscript-type">int</span> fd, vnode_t *vpp)
{
	<span class="enscript-type">int</span> error;
	vnode_t vp;
	<span class="enscript-type">struct</span> fileproc *fp;
	proc_t p = vfs_context_proc(ctx);

	*vpp =  NULLVP;

	error = fp_getfvp(p, fd, &amp;fp, &amp;vp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	error = vnode_getwithref(vp);
	<span class="enscript-keyword">if</span> (error) {
		(<span class="enscript-type">void</span>)fp_drop(p, fd, fp, 0);
		<span class="enscript-keyword">return</span> (error);
	}

	(<span class="enscript-type">void</span>)fp_drop(p, fd, fp, 0);
	*vpp = vp;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Wrapper function around namei to start lookup from a directory
 * specified by a file descriptor ni_dirfd.
 *
 * In addition to all the errors returned by namei, this call can
 * return ENOTDIR if the file descriptor does not refer to a directory.
 * and EBADF if the file descriptor is not valid.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nameiat</span>(<span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">int</span> dirfd)
{
	<span class="enscript-keyword">if</span> ((dirfd != AT_FDCWD) &amp;&amp;
	    !(ndp-&gt;ni_flag &amp; NAMEI_CONTLOOKUP) &amp;&amp;
	    !(ndp-&gt;ni_cnd.cn_flags &amp; USEDVP)) {
		<span class="enscript-type">int</span> error = 0;
		<span class="enscript-type">char</span> c;

		<span class="enscript-keyword">if</span> (UIO_SEG_IS_USER_SPACE(ndp-&gt;ni_segflg)) {
			error = copyin(ndp-&gt;ni_dirp, &amp;c, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
		} <span class="enscript-keyword">else</span> {
			c = *((<span class="enscript-type">char</span> *)(ndp-&gt;ni_dirp));
		}

		<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'/'</span>) {
			vnode_t dvp_at;

			error = vnode_getfromfd(ndp-&gt;ni_cnd.cn_context, dirfd,
			    &amp;dvp_at);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);

			<span class="enscript-keyword">if</span> (vnode_vtype(dvp_at) != VDIR) {
				vnode_put(dvp_at);
				<span class="enscript-keyword">return</span> (ENOTDIR);
			}

			ndp-&gt;ni_dvp = dvp_at;
			ndp-&gt;ni_cnd.cn_flags |= USEDVP;
			error = namei(ndp);
			ndp-&gt;ni_cnd.cn_flags &amp;= ~USEDVP;
			vnode_put(dvp_at);
			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-keyword">return</span> (namei(ndp));
}

<span class="enscript-comment">/*
 * Change current working directory to a given file descriptor.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">common_fchdir</span>(proc_t p, <span class="enscript-type">struct</span> fchdir_args *uap, <span class="enscript-type">int</span> per_thread)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	vnode_t vp;
	vnode_t tdp;
	vnode_t tvp;
	<span class="enscript-type">struct</span> mount *mp;
	<span class="enscript-type">int</span> error;
	vfs_context_t ctx = vfs_context_current();

	AUDIT_ARG(fd, uap-&gt;fd);
	<span class="enscript-keyword">if</span> (per_thread &amp;&amp; uap-&gt;fd == -1) {
		<span class="enscript-comment">/*
		 * Switching back from per-thread to per process CWD; verify we
		 * in fact have one before proceeding.  The only success case
		 * for this code path is to return 0 preemptively after zapping
		 * the thread structure contents.
		 */</span>
		thread_t th = vfs_context_thread(ctx);
		<span class="enscript-keyword">if</span> (th) {
			uthread_t uth = get_bsdthread_info(th);
			tvp = uth-&gt;uu_cdir;
			uth-&gt;uu_cdir = NULLVP;
			<span class="enscript-keyword">if</span> (tvp != NULLVP) {
				vnode_rele(tvp);
				<span class="enscript-keyword">return</span> (0);
			}
		}
		<span class="enscript-keyword">return</span> (EBADF);
	}

	<span class="enscript-keyword">if</span> ( (error = file_vnode(uap-&gt;fd, &amp;vp)) )
		<span class="enscript-keyword">return</span>(error);
	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
	        file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(error);
	}

	AUDIT_ARG(vnpath, vp, ARG_VNODE1);

	<span class="enscript-keyword">if</span> (vp-&gt;v_type != VDIR) {
		error = ENOTDIR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_chdir(ctx, vp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	error = vnode_authorize(vp, NULL, KAUTH_VNODE_SEARCH, ctx);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">while</span> (!error &amp;&amp; (mp = vp-&gt;v_mountedhere) != NULL) {
		<span class="enscript-keyword">if</span> (vfs_busy(mp, LK_NOWAIT)) {
			error = EACCES;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		error = VFS_ROOT(mp, &amp;tdp, ctx);
		vfs_unbusy(mp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		vnode_put(vp);
		vp = tdp;
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> ( (error = vnode_ref(vp)) )
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	vnode_put(vp);

	<span class="enscript-keyword">if</span> (per_thread) {
		thread_t th = vfs_context_thread(ctx);
		<span class="enscript-keyword">if</span> (th) {
			uthread_t uth = get_bsdthread_info(th);
			tvp = uth-&gt;uu_cdir;
			uth-&gt;uu_cdir = vp;
			OSBitOrAtomic(P_THCWD, &amp;p-&gt;p_flag);
		} <span class="enscript-keyword">else</span> {
			vnode_rele(vp);
			<span class="enscript-keyword">return</span> (ENOENT);
		}
	} <span class="enscript-keyword">else</span> {
		proc_fdlock(p);
		tvp = fdp-&gt;fd_cdir;
		fdp-&gt;fd_cdir = vp;
		proc_fdunlock(p);
	}

	<span class="enscript-keyword">if</span> (tvp)
	        vnode_rele(tvp);
	file_drop(uap-&gt;fd);

	<span class="enscript-keyword">return</span> (0);
<span class="enscript-reference">out</span>:
	vnode_put(vp);
	file_drop(uap-&gt;fd);

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fchdir</span>(proc_t p, <span class="enscript-type">struct</span> fchdir_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> common_fchdir(p, uap, 0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">__pthread_fchdir</span>(proc_t p, <span class="enscript-type">struct</span> __pthread_fchdir_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> common_fchdir(p, (<span class="enscript-type">void</span> *)uap, 1);
}

<span class="enscript-comment">/*
 * Change current working directory (&quot;.&quot;).
 *
 * Returns:	0			Success
 *	change_dir:ENOTDIR
 *	change_dir:???
 *	vnode_ref:ENOENT		No such file or directory
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">common_chdir</span>(proc_t p, <span class="enscript-type">struct</span> chdir_args *uap, <span class="enscript-type">int</span> per_thread)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	vnode_t tvp;
	vfs_context_t ctx = vfs_context_current();

	NDINIT(&amp;nd, LOOKUP, OP_CHDIR, FOLLOW | AUDITVNPATH1, 
		UIO_USERSPACE, uap-&gt;path, ctx);
	error = change_dir(&amp;nd, ctx);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> ( (error = vnode_ref(nd.ni_vp)) ) {
	        vnode_put(nd.ni_vp);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-comment">/*
	 * drop the iocount we picked up in change_dir
	 */</span>
	vnode_put(nd.ni_vp);

	<span class="enscript-keyword">if</span> (per_thread) {
		thread_t th = vfs_context_thread(ctx);
		<span class="enscript-keyword">if</span> (th) {
			uthread_t uth = get_bsdthread_info(th);
			tvp = uth-&gt;uu_cdir;
			uth-&gt;uu_cdir = nd.ni_vp;
			OSBitOrAtomic(P_THCWD, &amp;p-&gt;p_flag);
		} <span class="enscript-keyword">else</span> {
			vnode_rele(nd.ni_vp);
			<span class="enscript-keyword">return</span> (ENOENT);
		}
	} <span class="enscript-keyword">else</span> {
		proc_fdlock(p);
		tvp = fdp-&gt;fd_cdir;
		fdp-&gt;fd_cdir = nd.ni_vp;
		proc_fdunlock(p);
	}

	<span class="enscript-keyword">if</span> (tvp)
	        vnode_rele(tvp);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * chdir
 *
 * Change current working directory (&quot;.&quot;) for the entire process
 *
 * Parameters:  p       Process requesting the call
 * 		uap     User argument descriptor (see below)
 * 		retval  (ignored)
 *
 * Indirect parameters:	uap-&gt;path	Directory path
 *
 * Returns:	0			Success
 * 		common_chdir: ENOTDIR
 * 		common_chdir: ENOENT	No such file or directory
 * 		common_chdir: ???
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">chdir</span>(proc_t p, <span class="enscript-type">struct</span> chdir_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> common_chdir(p, (<span class="enscript-type">void</span> *)uap, 0);
}

<span class="enscript-comment">/*
 * __pthread_chdir
 *
 * Change current working directory (&quot;.&quot;) for a single thread
 *
 * Parameters:  p       Process requesting the call
 * 		uap     User argument descriptor (see below)
 * 		retval  (ignored)
 *
 * Indirect parameters:	uap-&gt;path	Directory path
 *
 * Returns:	0			Success
 * 		common_chdir: ENOTDIR
 *		common_chdir: ENOENT	No such file or directory
 *		common_chdir: ???
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">__pthread_chdir</span>(proc_t p, <span class="enscript-type">struct</span> __pthread_chdir_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> common_chdir(p, (<span class="enscript-type">void</span> *)uap, 1);
}


<span class="enscript-comment">/*
 * Change notion of root (``/'') directory.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">chroot</span>(proc_t p, <span class="enscript-type">struct</span> chroot_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	vnode_t tvp;
	vfs_context_t ctx = vfs_context_current();

	<span class="enscript-keyword">if</span> ((error = suser(kauth_cred_get(), &amp;p-&gt;p_acflag)))
		<span class="enscript-keyword">return</span> (error);

	NDINIT(&amp;nd, LOOKUP, OP_CHROOT, FOLLOW | AUDITVNPATH1, 
		UIO_USERSPACE, uap-&gt;path, ctx);
	error = change_dir(&amp;nd, ctx);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_chroot(ctx, nd.ni_vp,
	    &amp;nd.ni_cnd);
	<span class="enscript-keyword">if</span> (error) {
		vnode_put(nd.ni_vp);
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> ( (error = vnode_ref(nd.ni_vp)) ) {
	        vnode_put(nd.ni_vp);
		<span class="enscript-keyword">return</span> (error);
	}
	vnode_put(nd.ni_vp);

	proc_fdlock(p);
	tvp = fdp-&gt;fd_rdir;
	fdp-&gt;fd_rdir = nd.ni_vp;
	fdp-&gt;fd_flags |= FD_CHROOT;
	proc_fdunlock(p);

	<span class="enscript-keyword">if</span> (tvp != NULL)
		vnode_rele(tvp);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Common routine for chroot and chdir.
 *
 * Returns:	0			Success
 *		ENOTDIR			Not a directory
 *		namei:???		[anything namei can return]
 *		vnode_authorize:???	[anything vnode_authorize can return]
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">change_dir</span>(<span class="enscript-type">struct</span> nameidata *ndp, vfs_context_t ctx)
{
	vnode_t vp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((error = namei(ndp)))
		<span class="enscript-keyword">return</span> (error);
	nameidone(ndp);
	vp = ndp-&gt;ni_vp;

	<span class="enscript-keyword">if</span> (vp-&gt;v_type != VDIR) {
		vnode_put(vp);
		<span class="enscript-keyword">return</span> (ENOTDIR);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_chdir(ctx, vp);
	<span class="enscript-keyword">if</span> (error) {
		vnode_put(vp);
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>

	error = vnode_authorize(vp, NULL, KAUTH_VNODE_SEARCH, ctx);
	<span class="enscript-keyword">if</span> (error) {
		vnode_put(vp);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Free the vnode data (for directories) associated with the file glob.
 */</span>
<span class="enscript-type">struct</span> fd_vn_data *
<span class="enscript-function-name">fg_vn_data_alloc</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> fd_vn_data *fvdata;

	<span class="enscript-comment">/* Allocate per fd vnode data */</span>
	MALLOC(fvdata, <span class="enscript-type">struct</span> fd_vn_data *, (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> fd_vn_data)),
	       M_FD_VN_DATA, M_WAITOK | M_ZERO);
	lck_mtx_init(&amp;fvdata-&gt;fv_lock, fd_vn_lck_grp, fd_vn_lck_attr);
	<span class="enscript-keyword">return</span> fvdata;
}

<span class="enscript-comment">/*
 * Free the vnode data (for directories) associated with the file glob.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fg_vn_data_free</span>(<span class="enscript-type">void</span> *fgvndata)
{
	<span class="enscript-type">struct</span> fd_vn_data *fvdata = (<span class="enscript-type">struct</span> fd_vn_data *)fgvndata;

	<span class="enscript-keyword">if</span> (fvdata-&gt;fv_buf)
		FREE(fvdata-&gt;fv_buf, M_FD_DIRBUF);
	lck_mtx_destroy(&amp;fvdata-&gt;fv_lock, fd_vn_lck_grp);
	FREE(fvdata, M_FD_VN_DATA);
}

<span class="enscript-comment">/*
 * Check permissions, allocate an open file structure,
 * and call the device open routine if any.
 *
 * Returns:	0			Success
 *		EINVAL
 *		EINTR
 *	falloc:ENFILE
 *	falloc:EMFILE
 *	falloc:ENOMEM
 *	vn_open_auth:???
 *	dupfdopen:???
 *	VNOP_ADVLOCK:???
 *	vnode_setsize:???
 *
 * XXX Need to implement uid, gid
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">open1</span>(vfs_context_t ctx, <span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">int</span> uflags,
    <span class="enscript-type">struct</span> vnode_attr *vap, fp_allocfn_t fp_zalloc, <span class="enscript-type">void</span> *cra,
    int32_t *retval)
{
	proc_t p = vfs_context_proc(ctx);
	uthread_t uu = get_bsdthread_info(vfs_context_thread(ctx));
	<span class="enscript-type">struct</span> fileproc *fp;
	vnode_t vp;
	<span class="enscript-type">int</span> flags, oflags;
	<span class="enscript-type">int</span> type, indx, error;
	<span class="enscript-type">struct</span> flock lf;
	<span class="enscript-type">struct</span> vfs_context context;

	oflags = uflags;

	<span class="enscript-keyword">if</span> ((oflags &amp; O_ACCMODE) == O_ACCMODE)
		<span class="enscript-keyword">return</span>(EINVAL);

	flags = FFLAGS(uflags);
	CLR(flags, FENCRYPTED);
	CLR(flags, FUNENCRYPTED);

	AUDIT_ARG(fflags, oflags);
	AUDIT_ARG(mode, vap-&gt;va_mode);

	<span class="enscript-keyword">if</span> ((error = falloc_withalloc(p,
	    &amp;fp, &amp;indx, ctx, fp_zalloc, cra)) != 0) {
		<span class="enscript-keyword">return</span> (error);
	}
	uu-&gt;uu_dupfd = -indx - 1;

	<span class="enscript-keyword">if</span> ((error = vn_open_auth(ndp, &amp;flags, vap))) {
		<span class="enscript-keyword">if</span> ((error == ENODEV || error == ENXIO) &amp;&amp; (uu-&gt;uu_dupfd &gt;= 0)){	<span class="enscript-comment">/* XXX from fdopen */</span>
			<span class="enscript-keyword">if</span> ((error = dupfdopen(p-&gt;p_fd, indx, uu-&gt;uu_dupfd, flags, error)) == 0) {
				fp_drop(p, indx, NULL, 0);
			        *retval = indx;
				<span class="enscript-keyword">return</span> (0);
			}
		}
		<span class="enscript-keyword">if</span> (error == ERESTART)
		        error = EINTR;
		fp_free(p, indx, fp);
		<span class="enscript-keyword">return</span> (error);
	}
	uu-&gt;uu_dupfd = 0;
	vp = ndp-&gt;ni_vp;

	fp-&gt;f_fglob-&gt;fg_flag = flags &amp; (FMASK | O_EVTONLY | FENCRYPTED | FUNENCRYPTED);
	fp-&gt;f_fglob-&gt;fg_ops = &amp;vnops;
	fp-&gt;f_fglob-&gt;fg_data = (caddr_t)vp;

	<span class="enscript-keyword">if</span> (flags &amp; (O_EXLOCK | O_SHLOCK)) {
		lf.l_whence = SEEK_SET;
		lf.l_start = 0;
		lf.l_len = 0;
		<span class="enscript-keyword">if</span> (flags &amp; O_EXLOCK)
			lf.l_type = F_WRLCK;
		<span class="enscript-keyword">else</span>
			lf.l_type = F_RDLCK;
		type = F_FLOCK;
		<span class="enscript-keyword">if</span> ((flags &amp; FNONBLOCK) == 0)
			type |= F_WAIT;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_file_check_lock(vfs_context_ucred(ctx), fp-&gt;f_fglob,
		    F_SETLK, &amp;lf);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> ((error = VNOP_ADVLOCK(vp, (caddr_t)fp-&gt;f_fglob, F_SETLK, &amp;lf, type, ctx, NULL)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		fp-&gt;f_fglob-&gt;fg_flag |= FHASLOCK;
	}

	<span class="enscript-comment">/* try to truncate by setting the size attribute */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; O_TRUNC) &amp;&amp; ((error = vnode_setsize(vp, (off_t)0, 0, ctx)) != 0))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-comment">/*
	 * For directories we hold some additional information in the fd.
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_vtype(vp) == VDIR) {
		fp-&gt;f_fglob-&gt;fg_vn_data = fg_vn_data_alloc();
	} <span class="enscript-keyword">else</span> {
		fp-&gt;f_fglob-&gt;fg_vn_data = NULL;
	}

	vnode_put(vp);

	<span class="enscript-comment">/*
	 * The first terminal open (without a O_NOCTTY) by a session leader
	 * results in it being set as the controlling terminal.
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_istty(vp) &amp;&amp; !(p-&gt;p_flag &amp; P_CONTROLT) &amp;&amp;
	    !(flags &amp; O_NOCTTY)) {
		<span class="enscript-type">int</span> tmp = 0;

		(<span class="enscript-type">void</span>)(*fp-&gt;f_fglob-&gt;fg_ops-&gt;fo_ioctl)(fp, (<span class="enscript-type">int</span>)TIOCSCTTY,
		    (caddr_t)&amp;tmp, ctx);
	}

	proc_fdlock(p);
	<span class="enscript-keyword">if</span> (flags &amp; O_CLOEXEC)
		*fdflags(p, indx) |= UF_EXCLOSE;
	<span class="enscript-keyword">if</span> (flags &amp; O_CLOFORK)
		*fdflags(p, indx) |= UF_FORKCLOSE;
	procfdtbl_releasefd(p, indx, NULL);
	fp_drop(p, indx, fp, 1);
	proc_fdunlock(p);

	*retval = indx;

	<span class="enscript-keyword">return</span> (0);
<span class="enscript-reference">bad</span>:
	context = *vfs_context_current();
	context.vc_ucred = fp-&gt;f_fglob-&gt;fg_cred;
    
    	<span class="enscript-keyword">if</span> ((fp-&gt;f_fglob-&gt;fg_flag &amp; FHASLOCK) &amp;&amp;
	    (FILEGLOB_DTYPE(fp-&gt;f_fglob) == DTYPE_VNODE)) {
		lf.l_whence = SEEK_SET;
        	lf.l_start = 0;
        	lf.l_len = 0;
        	lf.l_type = F_UNLCK;
        
        	(<span class="enscript-type">void</span>)VNOP_ADVLOCK(
        		vp, (caddr_t)fp-&gt;f_fglob, F_UNLCK, &amp;lf, F_FLOCK, ctx, NULL);
	}

	vn_close(vp, fp-&gt;f_fglob-&gt;fg_flag, &amp;context);
	vnode_put(vp);
	fp_free(p, indx, fp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * While most of the *at syscall handlers can call nameiat() which
 * is a wrapper around namei, the use of namei and initialisation
 * of nameidata are far removed and in different functions  - namei
 * gets called in vn_open_auth for open1. So we'll just do here what
 * nameiat() does.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">open1at</span>(vfs_context_t ctx, <span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">int</span> uflags,
    <span class="enscript-type">struct</span> vnode_attr *vap, fp_allocfn_t fp_zalloc, <span class="enscript-type">void</span> *cra, int32_t *retval,
    <span class="enscript-type">int</span> dirfd)
{
	<span class="enscript-keyword">if</span> ((dirfd != AT_FDCWD) &amp;&amp; !(ndp-&gt;ni_cnd.cn_flags &amp; USEDVP)) {
		<span class="enscript-type">int</span> error;
		<span class="enscript-type">char</span> c;

		<span class="enscript-keyword">if</span> (UIO_SEG_IS_USER_SPACE(ndp-&gt;ni_segflg)) {
			error = copyin(ndp-&gt;ni_dirp, &amp;c, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
		} <span class="enscript-keyword">else</span> {
			c = *((<span class="enscript-type">char</span> *)(ndp-&gt;ni_dirp));
		}

		<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'/'</span>) {
			vnode_t dvp_at;

			error = vnode_getfromfd(ndp-&gt;ni_cnd.cn_context, dirfd,
			    &amp;dvp_at);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);

			<span class="enscript-keyword">if</span> (vnode_vtype(dvp_at) != VDIR) {
				vnode_put(dvp_at);
				<span class="enscript-keyword">return</span> (ENOTDIR);
			}

			ndp-&gt;ni_dvp = dvp_at;
			ndp-&gt;ni_cnd.cn_flags |= USEDVP;
			error = open1(ctx, ndp, uflags, vap, fp_zalloc, cra,
			    retval);
			vnode_put(dvp_at);
			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-keyword">return</span> (open1(ctx, ndp, uflags, vap, fp_zalloc, cra, retval));
}

<span class="enscript-comment">/*
 * open_extended: open a file given a path name; with extended argument list (including extended security (ACL)).
 *
 * Parameters:	p			Process requesting the open
 *		uap			User argument descriptor (see below)
 *		retval			Pointer to an area to receive the
 *					return calue from the system call
 *
 * Indirect:	uap-&gt;path		Path to open (same as 'open')
 *		uap-&gt;flags		Flags to open (same as 'open'
 *		uap-&gt;uid		UID to set, if creating
 *		uap-&gt;gid		GID to set, if creating
 *		uap-&gt;mode		File mode, if creating (same as 'open')
 *		uap-&gt;xsecurity		ACL to set, if creating
 *
 * Returns:	0			Success
 *		!0			errno value
 *
 * Notes:	The kauth_filesec_t in 'va', if any, is in host byte order.
 *
 * XXX:		We should enummerate the possible errno values here, and where
 *		in the code they originated.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">open_extended</span>(proc_t p, <span class="enscript-type">struct</span> open_extended_args *uap, int32_t *retval)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">int</span> ciferror;
	kauth_filesec_t xsecdst;
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">int</span> cmode;

	AUDIT_ARG(owner, uap-&gt;uid, uap-&gt;gid);

	xsecdst = NULL;
	<span class="enscript-keyword">if</span> ((uap-&gt;xsecurity != USER_ADDR_NULL) &amp;&amp;
	    ((ciferror = kauth_copyinfilesec(uap-&gt;xsecurity, &amp;xsecdst)) != 0))
		<span class="enscript-keyword">return</span> ciferror;

	VATTR_INIT(&amp;va);
	cmode = ((uap-&gt;mode &amp;~ fdp-&gt;fd_cmask) &amp; ALLPERMS) &amp; ~S_ISTXT;
	VATTR_SET(&amp;va, va_mode, cmode);
	<span class="enscript-keyword">if</span> (uap-&gt;uid != KAUTH_UID_NONE)
		VATTR_SET(&amp;va, va_uid, uap-&gt;uid);
	<span class="enscript-keyword">if</span> (uap-&gt;gid != KAUTH_GID_NONE)
		VATTR_SET(&amp;va, va_gid, uap-&gt;gid);
	<span class="enscript-keyword">if</span> (xsecdst != NULL)
		VATTR_SET(&amp;va, va_acl, &amp;xsecdst-&gt;fsec_acl);

	NDINIT(&amp;nd, LOOKUP, OP_OPEN, FOLLOW | AUDITVNPATH1, UIO_USERSPACE,
	       uap-&gt;path, vfs_context_current());

	ciferror = open1(vfs_context_current(), &amp;nd, uap-&gt;flags, &amp;va,
			 fileproc_alloc_init, NULL, retval);
	<span class="enscript-keyword">if</span> (xsecdst != NULL)
		kauth_filesec_free(xsecdst);

	<span class="enscript-keyword">return</span> ciferror;
}

<span class="enscript-comment">/* 
 * Go through the data-protected atomically controlled open (2)
 *  
 * int open_dprotected_np(user_addr_t path, int flags, int class, int dpflags, int mode)
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">open_dprotected_np</span> (__unused proc_t p, <span class="enscript-type">struct</span> open_dprotected_np_args *uap, int32_t *retval) {
	<span class="enscript-type">int</span> flags = uap-&gt;flags;
	<span class="enscript-type">int</span> class = uap-&gt;class;
	<span class="enscript-type">int</span> dpflags = uap-&gt;dpflags;

	<span class="enscript-comment">/* 
	 * Follow the same path as normal open(2)
	 * Look up the item if it exists, and acquire the vnode.
	 */</span>
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">int</span> cmode;
	<span class="enscript-type">int</span> error;
	
	VATTR_INIT(&amp;va);
	<span class="enscript-comment">/* Mask off all but regular access permissions */</span>
	cmode = ((uap-&gt;mode &amp;~ fdp-&gt;fd_cmask) &amp; ALLPERMS) &amp; ~S_ISTXT;
	VATTR_SET(&amp;va, va_mode, cmode &amp; ACCESSPERMS);

	NDINIT(&amp;nd, LOOKUP, OP_OPEN, FOLLOW | AUDITVNPATH1, UIO_USERSPACE,
	       uap-&gt;path, vfs_context_current());

	<span class="enscript-comment">/* 
	 * Initialize the extra fields in vnode_attr to pass down our 
	 * extra fields.
	 * 1. target cprotect class.
	 * 2. set a flag to mark it as requiring open-raw-encrypted semantics. 
	 */</span> 
	<span class="enscript-keyword">if</span> (flags &amp; O_CREAT) {	
               <span class="enscript-comment">/* lower level kernel code validates that the class is valid before applying it. */</span>
               <span class="enscript-keyword">if</span> (class != PROTECTION_CLASS_DEFAULT) {
                       <span class="enscript-comment">/*
                        * PROTECTION_CLASS_DEFAULT implies that we make the class for this
                        * file behave the same as open (2)
                        */</span>
                       VATTR_SET(&amp;va, va_dataprotect_class, class);
               }
	}
	
	<span class="enscript-keyword">if</span> (dpflags &amp; (O_DP_GETRAWENCRYPTED|O_DP_GETRAWUNENCRYPTED)) {
		<span class="enscript-keyword">if</span> ( flags &amp; (O_RDWR | O_WRONLY)) {
			<span class="enscript-comment">/* Not allowed to write raw encrypted bytes */</span>
			<span class="enscript-keyword">return</span> EINVAL;		
		}			
		<span class="enscript-keyword">if</span> (uap-&gt;dpflags &amp; O_DP_GETRAWENCRYPTED) {
		    VATTR_SET(&amp;va, va_dataprotect_flags, VA_DP_RAWENCRYPTED);
		}
		<span class="enscript-keyword">if</span> (uap-&gt;dpflags &amp; O_DP_GETRAWUNENCRYPTED) {
		    VATTR_SET(&amp;va, va_dataprotect_flags, VA_DP_RAWUNENCRYPTED);
		}
	}

	error = open1(vfs_context_current(), &amp;nd, uap-&gt;flags, &amp;va,
		      fileproc_alloc_init, NULL, retval);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">openat_internal</span>(vfs_context_t ctx, user_addr_t path, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> mode,
    <span class="enscript-type">int</span> fd, <span class="enscript-type">enum</span> uio_seg segflg, <span class="enscript-type">int</span> *retval)
{
	<span class="enscript-type">struct</span> filedesc *fdp = (vfs_context_proc(ctx))-&gt;p_fd;
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">int</span> cmode;

	VATTR_INIT(&amp;va);
	<span class="enscript-comment">/* Mask off all but regular access permissions */</span>
	cmode = ((mode &amp;~ fdp-&gt;fd_cmask) &amp; ALLPERMS) &amp; ~S_ISTXT;
	VATTR_SET(&amp;va, va_mode, cmode &amp; ACCESSPERMS);

	NDINIT(&amp;nd, LOOKUP, OP_OPEN, FOLLOW | AUDITVNPATH1,
	    segflg, path, ctx);

	<span class="enscript-keyword">return</span> (open1at(ctx, &amp;nd, flags, &amp;va, fileproc_alloc_init, NULL,
	    retval, fd));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">open</span>(proc_t p, <span class="enscript-type">struct</span> open_args *uap, int32_t *retval)
{
	__pthread_testcancel(1);
	<span class="enscript-keyword">return</span>(open_nocancel(p, (<span class="enscript-type">struct</span> open_nocancel_args *)uap, retval));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">open_nocancel</span>(__unused proc_t p, <span class="enscript-type">struct</span> open_nocancel_args *uap,
    int32_t *retval)
{
	<span class="enscript-keyword">return</span> (openat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;flags,
	    uap-&gt;mode, AT_FDCWD, UIO_USERSPACE, retval));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">openat_nocancel</span>(__unused proc_t p, <span class="enscript-type">struct</span> openat_nocancel_args *uap,
                int32_t *retval)
{
	<span class="enscript-keyword">return</span> (openat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;flags,
	    uap-&gt;mode, uap-&gt;fd, UIO_USERSPACE, retval));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">openat</span>(proc_t p, <span class="enscript-type">struct</span> openat_args *uap, int32_t *retval)
{
	__pthread_testcancel(1);
	<span class="enscript-keyword">return</span>(openat_nocancel(p, (<span class="enscript-type">struct</span> openat_nocancel_args *)uap, retval));
}

<span class="enscript-comment">/*
 * openbyid_np: open a file given a file system id and a file system object id
 *	the hfs file system object id is an fsobj_id_t {uint32, uint32}
 *	file systems that don't support object ids it is a node id (uint64_t).
 *
 * Parameters:	p			Process requesting the open
 *		uap			User argument descriptor (see below)
 *		retval			Pointer to an area to receive the
 *					return calue from the system call
 *
 * Indirect:	uap-&gt;path		Path to open (same as 'open')
 *
 *		uap-&gt;fsid		id of target file system
 *		uap-&gt;objid		id of target file system object
 *		uap-&gt;flags		Flags to open (same as 'open')
 *
 * Returns:	0			Success
 *		!0			errno value
 *
 *
 * XXX:		We should enummerate the possible errno values here, and where
 *		in the code they originated.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">openbyid_np</span>(__unused proc_t p, <span class="enscript-type">struct</span> openbyid_np_args *uap, <span class="enscript-type">int</span> *retval)
{
	fsid_t fsid;
	uint64_t objid;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> *buf = NULL;
	<span class="enscript-type">int</span> buflen = MAXPATHLEN;
	<span class="enscript-type">int</span> pathlen = 0;
	vfs_context_t ctx = vfs_context_current();

	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;fsid, (caddr_t)&amp;fsid, <span class="enscript-keyword">sizeof</span>(fsid)))) {
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/*uap-&gt;obj is an fsobj_id_t defined as struct {uint32_t, uint32_t} */</span>
	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;objid, (caddr_t)&amp;objid, <span class="enscript-keyword">sizeof</span>(uint64_t)))) {
		<span class="enscript-keyword">return</span> (error);
	}

	AUDIT_ARG(value32, fsid.val[0]);
	AUDIT_ARG(value64, objid);

	<span class="enscript-comment">/*resolve path from fsis, objid*/</span>
	<span class="enscript-keyword">do</span> {
		MALLOC(buf, <span class="enscript-type">char</span> *, buflen + 1, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (buf == NULL) {
			<span class="enscript-keyword">return</span> (ENOMEM);
		}

		error = fsgetpath_internal(
			ctx, fsid.val[0], objid,
			buflen, buf, &amp;pathlen);

		<span class="enscript-keyword">if</span> (error) {
			FREE(buf, M_TEMP);
			buf = NULL;
		}
	} <span class="enscript-keyword">while</span> (error == ENOSPC &amp;&amp; (buflen += MAXPATHLEN));

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}

	buf[pathlen] = 0;

	error = openat_internal(
		ctx, (user_addr_t)buf, uap-&gt;oflags, 0, AT_FDCWD, UIO_SYSSPACE, retval);

	FREE(buf, M_TEMP);

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * Create a special file.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mkfifo1</span>(vfs_context_t ctx, user_addr_t upath, <span class="enscript-type">struct</span> vnode_attr *vap);

<span class="enscript-type">int</span>
<span class="enscript-function-name">mknod</span>(proc_t p, <span class="enscript-type">struct</span> mknod_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> vnode_attr va;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	vnode_t	vp, dvp;

 	VATTR_INIT(&amp;va);
 	VATTR_SET(&amp;va, va_mode, (uap-&gt;mode &amp; ALLPERMS) &amp; ~p-&gt;p_fd-&gt;fd_cmask);
 	VATTR_SET(&amp;va, va_rdev, uap-&gt;dev);

	<span class="enscript-comment">/* If it's a mknod() of a FIFO, call mkfifo1() instead */</span>
	<span class="enscript-keyword">if</span> ((uap-&gt;mode &amp; S_IFMT) == S_IFIFO)
 		<span class="enscript-keyword">return</span>(mkfifo1(ctx, uap-&gt;path, &amp;va));

	AUDIT_ARG(mode, uap-&gt;mode);
	AUDIT_ARG(value32, uap-&gt;dev);

	<span class="enscript-keyword">if</span> ((error = suser(vfs_context_ucred(ctx), &amp;p-&gt;p_acflag)))
		<span class="enscript-keyword">return</span> (error);
	NDINIT(&amp;nd, CREATE, OP_MKNOD, LOCKPARENT | AUDITVNPATH1, 
		UIO_USERSPACE, uap-&gt;path, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	dvp = nd.ni_dvp;
	vp = nd.ni_vp;

	<span class="enscript-keyword">if</span> (vp != NULL) {
		error = EEXIST;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">switch</span> (uap-&gt;mode &amp; S_IFMT) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">S_IFCHR</span>:
		VATTR_SET(&amp;va, va_type, VCHR);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">S_IFBLK</span>:
		VATTR_SET(&amp;va, va_type, VBLK);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_create(ctx,
	    nd.ni_dvp, &amp;nd.ni_cnd, &amp;va);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

 	<span class="enscript-keyword">if</span> ((error = vnode_authorize(dvp, NULL, KAUTH_VNODE_ADD_FILE, ctx)) != 0)
 		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> ((error = vn_create(dvp, &amp;vp, &amp;nd, &amp;va, 0, 0, NULL, ctx)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (vp) {
		<span class="enscript-type">int</span>	update_flags = 0;

	        <span class="enscript-comment">// Make sure the name &amp; parent pointers are hooked up
</span>	        <span class="enscript-keyword">if</span> (vp-&gt;v_name == NULL)
			update_flags |= VNODE_UPDATE_NAME;
		<span class="enscript-keyword">if</span> (vp-&gt;v_parent == NULLVP)
		        update_flags |= VNODE_UPDATE_PARENT;

		<span class="enscript-keyword">if</span> (update_flags)
		        vnode_update_identity(vp, dvp, nd.ni_cnd.cn_nameptr, nd.ni_cnd.cn_namelen, nd.ni_cnd.cn_hash, update_flags);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
		add_fsevent(FSE_CREATE_FILE, ctx,
		    FSE_ARG_VNODE, vp,
		    FSE_ARG_DONE);
#<span class="enscript-reference">endif</span>
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/*
	 * nameidone has to happen before we vnode_put(dvp)
	 * since it may need to release the fs_nodelock on the dvp
	 */</span>
	nameidone(&amp;nd);

	<span class="enscript-keyword">if</span> (vp)
	        vnode_put(vp);
	vnode_put(dvp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Create a named pipe.
 *
 * Returns:	0			Success
 *		EEXIST
 *	namei:???
 *	vnode_authorize:???
 *	vn_create:???
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mkfifo1</span>(vfs_context_t ctx, user_addr_t upath, <span class="enscript-type">struct</span> vnode_attr *vap)
{
	vnode_t	vp, dvp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;

	NDINIT(&amp;nd, CREATE, OP_MKFIFO, LOCKPARENT | AUDITVNPATH1, 
		UIO_USERSPACE, upath, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	dvp = nd.ni_dvp;
	vp = nd.ni_vp;

   	<span class="enscript-comment">/* check that this is a new file and authorize addition */</span>
   	<span class="enscript-keyword">if</span> (vp != NULL) {
   		error = EEXIST;
   		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
   	}
   	VATTR_SET(vap, va_type, VFIFO);

	<span class="enscript-keyword">if</span> ((error = vn_authorize_create(dvp, &amp;nd.ni_cnd, vap, ctx, NULL)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

  	error = vn_create(dvp, &amp;vp, &amp;nd, vap, 0, 0, NULL, ctx);
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/*
	 * nameidone has to happen before we vnode_put(dvp)
	 * since it may need to release the fs_nodelock on the dvp
	 */</span>
	nameidone(&amp;nd);

	<span class="enscript-keyword">if</span> (vp)
	        vnode_put(vp);
	vnode_put(dvp);

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * mkfifo_extended: Create a named pipe; with extended argument list (including extended security (ACL)).
 *
 * Parameters:	p			Process requesting the open
 *		uap			User argument descriptor (see below)
 *		retval			(Ignored)
 *
 * Indirect:	uap-&gt;path		Path to fifo (same as 'mkfifo')
 *		uap-&gt;uid		UID to set
 *		uap-&gt;gid		GID to set
 *		uap-&gt;mode		File mode to set (same as 'mkfifo')
 *		uap-&gt;xsecurity		ACL to set, if creating
 *
 * Returns:	0			Success
 *		!0			errno value
 *
 * Notes:	The kauth_filesec_t in 'va', if any, is in host byte order.
 *
 * XXX:		We should enummerate the possible errno values here, and where
 *		in the code they originated.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mkfifo_extended</span>(proc_t p, <span class="enscript-type">struct</span> mkfifo_extended_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> ciferror;
	kauth_filesec_t xsecdst;
	<span class="enscript-type">struct</span> vnode_attr va;

	AUDIT_ARG(owner, uap-&gt;uid, uap-&gt;gid);

	xsecdst = KAUTH_FILESEC_NONE;
	<span class="enscript-keyword">if</span> (uap-&gt;xsecurity != USER_ADDR_NULL) {
		<span class="enscript-keyword">if</span> ((ciferror = kauth_copyinfilesec(uap-&gt;xsecurity, &amp;xsecdst)) != 0)
			<span class="enscript-keyword">return</span> ciferror;
	}

	VATTR_INIT(&amp;va);
   	VATTR_SET(&amp;va, va_mode, (uap-&gt;mode &amp; ALLPERMS) &amp; ~p-&gt;p_fd-&gt;fd_cmask);
	<span class="enscript-keyword">if</span> (uap-&gt;uid != KAUTH_UID_NONE)
		VATTR_SET(&amp;va, va_uid, uap-&gt;uid);
	<span class="enscript-keyword">if</span> (uap-&gt;gid != KAUTH_GID_NONE)
		VATTR_SET(&amp;va, va_gid, uap-&gt;gid);
	<span class="enscript-keyword">if</span> (xsecdst != KAUTH_FILESEC_NONE)
		VATTR_SET(&amp;va, va_acl, &amp;xsecdst-&gt;fsec_acl);

	ciferror = mkfifo1(vfs_context_current(), uap-&gt;path, &amp;va);

	<span class="enscript-keyword">if</span> (xsecdst != KAUTH_FILESEC_NONE)
		kauth_filesec_free(xsecdst);
	<span class="enscript-keyword">return</span> ciferror;
}

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mkfifo</span>(proc_t p, <span class="enscript-type">struct</span> mkfifo_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> vnode_attr va;

   	VATTR_INIT(&amp;va);
   	VATTR_SET(&amp;va, va_mode, (uap-&gt;mode &amp; ALLPERMS) &amp; ~p-&gt;p_fd-&gt;fd_cmask);

	<span class="enscript-keyword">return</span>(mkfifo1(vfs_context_current(), uap-&gt;path, &amp;va));
}


<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">my_strrchr</span>(<span class="enscript-type">char</span> *p, <span class="enscript-type">int</span> ch)
{
	<span class="enscript-type">char</span> *save;

	<span class="enscript-keyword">for</span> (save = NULL;; ++p) {
		<span class="enscript-keyword">if</span> (*p == ch)
			save = p;
		<span class="enscript-keyword">if</span> (!*p)
			<span class="enscript-keyword">return</span>(save);
	}
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">safe_getpath</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">char</span> *leafname, <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> _len, <span class="enscript-type">int</span> *truncated_path);

<span class="enscript-type">int</span>
<span class="enscript-function-name">safe_getpath</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">char</span> *leafname, <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> _len, <span class="enscript-type">int</span> *truncated_path)
{
	<span class="enscript-type">int</span> ret, len = _len;

	*truncated_path = 0;
	ret = vn_getpath(dvp, path, &amp;len);
	<span class="enscript-keyword">if</span> (ret == 0 &amp;&amp; len &lt; (MAXPATHLEN - 1)) {
		<span class="enscript-keyword">if</span> (leafname) {
			path[len-1] = <span class="enscript-string">'/'</span>;
			len += strlcpy(&amp;path[len], leafname, MAXPATHLEN-len) + 1;
			<span class="enscript-keyword">if</span> (len &gt; MAXPATHLEN) {
				<span class="enscript-type">char</span> *ptr;
			
				<span class="enscript-comment">// the string got truncated!
</span>				*truncated_path = 1;
				ptr = my_strrchr(path, <span class="enscript-string">'/'</span>);
				<span class="enscript-keyword">if</span> (ptr) {
					*ptr = <span class="enscript-string">'\0'</span>;   <span class="enscript-comment">// chop off the string at the last directory component
</span>				}
				len = strlen(path) + 1;
			}
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ret == 0) {
		*truncated_path = 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ret != 0) {
		<span class="enscript-type">struct</span> vnode *mydvp=dvp;

		<span class="enscript-keyword">if</span> (ret != ENOSPC) {
			printf(<span class="enscript-string">&quot;safe_getpath: failed to get the path for vp %p (%s) : err %d\n&quot;</span>,
			       dvp, dvp-&gt;v_name ? dvp-&gt;v_name : <span class="enscript-string">&quot;no-name&quot;</span>, ret);
		}				
		*truncated_path = 1;
		
		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> (mydvp-&gt;v_parent != NULL) {
				mydvp = mydvp-&gt;v_parent;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mydvp-&gt;v_mount) {
				strlcpy(path, mydvp-&gt;v_mount-&gt;mnt_vfsstat.f_mntonname, _len);
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// no parent and no mount point?  only thing is to punt and say &quot;/&quot; changed
</span>				strlcpy(path, <span class="enscript-string">&quot;/&quot;</span>, _len);
				len = 2;
				mydvp = NULL;
			}
			
			<span class="enscript-keyword">if</span> (mydvp == NULL) {
				<span class="enscript-keyword">break</span>;
			}

			len = _len;
			ret = vn_getpath(mydvp, path, &amp;len);
		} <span class="enscript-keyword">while</span> (ret == ENOSPC);
	}

	<span class="enscript-keyword">return</span> len;
}


<span class="enscript-comment">/*
 * Make a hard file link.
 *
 * Returns:	0			Success
 *		EPERM
 *		EEXIST
 *		EXDEV
 *	namei:???
 *	vnode_authorize:???
 *	VNOP_LINK:???
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">linkat_internal</span>(vfs_context_t ctx, <span class="enscript-type">int</span> fd1, user_addr_t path, <span class="enscript-type">int</span> fd2,
    user_addr_t link, <span class="enscript-type">int</span> flag, <span class="enscript-type">enum</span> uio_seg segflg)
{
	vnode_t	vp, dvp, lvp;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">int</span> follow;
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	fse_info finfo;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> need_event, has_listeners;
	<span class="enscript-type">char</span> *target_path = NULL;
	<span class="enscript-type">int</span> truncated=0;

	vp = dvp = lvp = NULLVP;

	<span class="enscript-comment">/* look up the object we are linking to */</span>
	follow = (flag &amp; AT_SYMLINK_FOLLOW) ? FOLLOW : NOFOLLOW;
	NDINIT(&amp;nd, LOOKUP, OP_LOOKUP, AUDITVNPATH1 | follow,
	    segflg, path, ctx);

	error = nameiat(&amp;nd, fd1);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	vp = nd.ni_vp;

	nameidone(&amp;nd);

	<span class="enscript-comment">/*
	 * Normally, linking to directories is not supported.
	 * However, some file systems may have limited support.
	 */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VDIR) {
		<span class="enscript-keyword">if</span> (!(vp-&gt;v_mount-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSDIRLINKS)) {
			error = EPERM;   <span class="enscript-comment">/* POSIX */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* Linking to a directory requires ownership. */</span>
		<span class="enscript-keyword">if</span> (!kauth_cred_issuser(vfs_context_ucred(ctx))) {
			<span class="enscript-type">struct</span> vnode_attr dva;

			VATTR_INIT(&amp;dva);
			VATTR_WANTED(&amp;dva, va_uid);
			<span class="enscript-keyword">if</span> (vnode_getattr(vp, &amp;dva, ctx) != 0 ||
			    !VATTR_IS_SUPPORTED(&amp;dva, va_uid) ||
			    (dva.va_uid != kauth_cred_getuid(vfs_context_ucred(ctx)))) {
				error = EACCES;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}

	<span class="enscript-comment">/* lookup the target node */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	nd.ni_op = OP_LINK;
#<span class="enscript-reference">endif</span>
	nd.ni_cnd.cn_nameiop = CREATE;
	nd.ni_cnd.cn_flags = LOCKPARENT | AUDITVNPATH2 | CN_NBMOUNTLOOK;
	nd.ni_dirp = link;
	error = nameiat(&amp;nd, fd2);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	dvp = nd.ni_dvp;
	lvp = nd.ni_vp;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> ((error = mac_vnode_check_link(ctx, dvp, vp, &amp;nd.ni_cnd)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
#<span class="enscript-reference">endif</span>

  	<span class="enscript-comment">/* or to anything that kauth doesn't want us to (eg. immutable items) */</span>
  	<span class="enscript-keyword">if</span> ((error = vnode_authorize(vp, NULL, KAUTH_VNODE_LINKTARGET, ctx)) != 0)
 		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;

	<span class="enscript-comment">/* target node must not exist */</span>
	<span class="enscript-keyword">if</span> (lvp != NULLVP) {
		error = EEXIST;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
	}
  	<span class="enscript-comment">/* cannot link across mountpoints */</span>
  	<span class="enscript-keyword">if</span> (vnode_mount(vp) != vnode_mount(dvp)) {
  		error = EXDEV;
  		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
  	}
		
  	<span class="enscript-comment">/* authorize creation of the target note */</span>
  	<span class="enscript-keyword">if</span> ((error = vnode_authorize(dvp, NULL, KAUTH_VNODE_ADD_FILE, ctx)) != 0)
  		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;

	<span class="enscript-comment">/* and finally make the link */</span>
	error = VNOP_LINK(vp, dvp, &amp;nd.ni_cnd, ctx);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	(<span class="enscript-type">void</span>)mac_vnode_notify_link(ctx, vp, dvp, &amp;nd.ni_cnd);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	need_event = need_fsevent(FSE_CREATE_FILE, dvp);
#<span class="enscript-reference">else</span>
	need_event = 0;
#<span class="enscript-reference">endif</span>
	has_listeners = kauth_authorize_fileop_has_listeners();

	<span class="enscript-keyword">if</span> (need_event || has_listeners) {
		<span class="enscript-type">char</span> *link_to_path = NULL;
		<span class="enscript-type">int</span> len, link_name_len;

		<span class="enscript-comment">/* build the path to the new link file */</span>
		GET_PATH(target_path);
		<span class="enscript-keyword">if</span> (target_path == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
		}

		len = safe_getpath(dvp, nd.ni_cnd.cn_nameptr, target_path, MAXPATHLEN, &amp;truncated);

		<span class="enscript-keyword">if</span> (has_listeners) {
		        <span class="enscript-comment">/* build the path to file we are linking to */</span>
			GET_PATH(link_to_path);
			<span class="enscript-keyword">if</span> (link_to_path == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
			}

			link_name_len = MAXPATHLEN;
			<span class="enscript-keyword">if</span> (vn_getpath(vp, link_to_path, &amp;link_name_len) == 0) {
				<span class="enscript-comment">/*
				 * Call out to allow 3rd party notification of rename. 
				 * Ignore result of kauth_authorize_fileop call.
				 */</span>
				kauth_authorize_fileop(vfs_context_ucred(ctx), KAUTH_FILEOP_LINK, 
						       (uintptr_t)link_to_path, 
						       (uintptr_t)target_path);
			}
			<span class="enscript-keyword">if</span> (link_to_path != NULL) {
				RELEASE_PATH(link_to_path);
			}
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
		<span class="enscript-keyword">if</span> (need_event) {
		        <span class="enscript-comment">/* construct fsevent */</span>
		        <span class="enscript-keyword">if</span> (get_fse_info(vp, &amp;finfo, ctx) == 0) {
				<span class="enscript-keyword">if</span> (truncated) {
					finfo.mode |= FSE_TRUNCATED_PATH;
				}

			        <span class="enscript-comment">// build the path to the destination of the link
</span>			        add_fsevent(FSE_CREATE_FILE, ctx,
					    FSE_ARG_STRING, len, target_path,
					    FSE_ARG_FINFO, &amp;finfo,
					    FSE_ARG_DONE);
			}
			<span class="enscript-keyword">if</span> (vp-&gt;v_parent) {
			    add_fsevent(FSE_STAT_CHANGED, ctx,
				FSE_ARG_VNODE, vp-&gt;v_parent,
				FSE_ARG_DONE);
			}
		}
#<span class="enscript-reference">endif</span>
	}
<span class="enscript-reference">out2</span>:
	<span class="enscript-comment">/*
	 * nameidone has to happen before we vnode_put(dvp)
	 * since it may need to release the fs_nodelock on the dvp
	 */</span>
	nameidone(&amp;nd);
	<span class="enscript-keyword">if</span> (target_path != NULL) {
		RELEASE_PATH(target_path);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (lvp)
		vnode_put(lvp);
	<span class="enscript-keyword">if</span> (dvp)
		vnode_put(dvp);
	vnode_put(vp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">link</span>(__unused proc_t p, <span class="enscript-type">struct</span> link_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (linkat_internal(vfs_context_current(), AT_FDCWD, uap-&gt;path,
	    AT_FDCWD, uap-&gt;link, AT_SYMLINK_FOLLOW, UIO_USERSPACE));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">linkat</span>(__unused proc_t p, <span class="enscript-type">struct</span> linkat_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">if</span> (uap-&gt;flag &amp; ~AT_SYMLINK_FOLLOW)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (linkat_internal(vfs_context_current(), uap-&gt;fd1, uap-&gt;path,
	    uap-&gt;fd2, uap-&gt;link, uap-&gt;flag, UIO_USERSPACE));
}

<span class="enscript-comment">/*
 * Make a symbolic link.
 *
 * We could add support for ACLs here too...
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">symlinkat_internal</span>(vfs_context_t ctx, user_addr_t path_data, <span class="enscript-type">int</span> fd,
    user_addr_t link, <span class="enscript-type">enum</span> uio_seg segflg)
{
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">char</span> *path;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	vnode_t	vp, dvp;
	uint32_t dfflags;	<span class="enscript-comment">// Directory file flags
</span>	size_t dummy=0;
	proc_t p;

	error = 0;
	<span class="enscript-keyword">if</span> (UIO_SEG_IS_USER_SPACE(segflg)) {
		MALLOC_ZONE(path, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK);
		error = copyinstr(path_data, path, MAXPATHLEN, &amp;dummy);
	} <span class="enscript-keyword">else</span> {
		path = (<span class="enscript-type">char</span> *)path_data;
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	AUDIT_ARG(text, path);	<span class="enscript-comment">/* This is the link string */</span>

	NDINIT(&amp;nd, CREATE, OP_SYMLINK, LOCKPARENT | AUDITVNPATH1,
            segflg, link, ctx);

	error = nameiat(&amp;nd, fd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	dvp = nd.ni_dvp;
	vp = nd.ni_vp;

	p = vfs_context_proc(ctx);
	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_type, VLNK);
	VATTR_SET(&amp;va, va_mode, ACCESSPERMS &amp; ~p-&gt;p_fd-&gt;fd_cmask);

	<span class="enscript-comment">/*
	 * Handle inheritance of restricted flag
	 */</span>
	error = vnode_flags(dvp, &amp;dfflags, ctx);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">skipit</span>;
	<span class="enscript-keyword">if</span> (dfflags &amp; SF_RESTRICTED)
		VATTR_SET(&amp;va, va_flags, SF_RESTRICTED);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_create(ctx,
			dvp, &amp;nd.ni_cnd, &amp;va);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">skipit</span>;
	}

	<span class="enscript-keyword">if</span> (vp != NULL) {
	    error = EEXIST;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">skipit</span>;
	}

	<span class="enscript-comment">/* authorize */</span>
	<span class="enscript-keyword">if</span> (error == 0)
		error = vnode_authorize(dvp, NULL, KAUTH_VNODE_ADD_FILE, ctx);
	<span class="enscript-comment">/* get default ownership, etc. */</span>
	<span class="enscript-keyword">if</span> (error == 0)
		error = vnode_authattr_new(dvp, &amp;va, 0, ctx);
	<span class="enscript-keyword">if</span> (error == 0)
		error = VNOP_SYMLINK(dvp, &amp;vp, &amp;nd.ni_cnd, &amp;va, path, ctx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; vp)
		error = vnode_label(vnode_mount(vp), dvp, vp, &amp;nd.ni_cnd, VNODE_LABEL_CREATE, ctx);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* do fallback attribute handling */</span>
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; vp)
		error = vnode_setattr_fallback(vp, &amp;va, ctx);

	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-type">int</span>	update_flags = 0;

		<span class="enscript-comment">/*check if a new vnode was created, else try to get one*/</span>
		<span class="enscript-keyword">if</span> (vp == NULL) {
			nd.ni_cnd.cn_nameiop = LOOKUP;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
			nd.ni_op = OP_LOOKUP;
#<span class="enscript-reference">endif</span>
			nd.ni_cnd.cn_flags = 0;
			error = nameiat(&amp;nd, fd);
			vp = nd.ni_vp;

			<span class="enscript-keyword">if</span> (vp == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skipit</span>;
		}

#<span class="enscript-reference">if</span> 0  <span class="enscript-comment">/* XXX - kauth_todo - is KAUTH_FILEOP_SYMLINK needed? */</span>
		<span class="enscript-comment">/* call out to allow 3rd party notification of rename.
		 * Ignore result of kauth_authorize_fileop call.
		 */</span>
		<span class="enscript-keyword">if</span> (kauth_authorize_fileop_has_listeners() &amp;&amp;
		    namei(&amp;nd) == 0) {
			<span class="enscript-type">char</span> *new_link_path = NULL;
			<span class="enscript-type">int</span>		len;

			<span class="enscript-comment">/* build the path to the new link file */</span>
			new_link_path = get_pathbuff();
			len = MAXPATHLEN;
			vn_getpath(dvp, new_link_path, &amp;len);
			<span class="enscript-keyword">if</span> ((len + 1 + nd.ni_cnd.cn_namelen + 1) &lt; MAXPATHLEN) {
				new_link_path[len - 1] = <span class="enscript-string">'/'</span>;
				strlcpy(&amp;new_link_path[len], nd.ni_cnd.cn_nameptr, MAXPATHLEN-len);
			}

			kauth_authorize_fileop(vfs_context_ucred(ctx), KAUTH_FILEOP_SYMLINK,
					   (uintptr_t)path, (uintptr_t)new_link_path);
			<span class="enscript-keyword">if</span> (new_link_path != NULL)
				release_pathbuff(new_link_path);
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">// Make sure the name &amp; parent pointers are hooked up
</span>		<span class="enscript-keyword">if</span> (vp-&gt;v_name == NULL)
			update_flags |= VNODE_UPDATE_NAME;
		<span class="enscript-keyword">if</span> (vp-&gt;v_parent == NULLVP)
			update_flags |= VNODE_UPDATE_PARENT;

		<span class="enscript-keyword">if</span> (update_flags)
			vnode_update_identity(vp, dvp, nd.ni_cnd.cn_nameptr, nd.ni_cnd.cn_namelen, nd.ni_cnd.cn_hash, update_flags);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
		add_fsevent(FSE_CREATE_FILE, ctx,
			    FSE_ARG_VNODE, vp,
			    FSE_ARG_DONE);
#<span class="enscript-reference">endif</span>
	}

<span class="enscript-reference">skipit</span>:
	<span class="enscript-comment">/*
	 * nameidone has to happen before we vnode_put(dvp)
	 * since it may need to release the fs_nodelock on the dvp
	 */</span>
	nameidone(&amp;nd);

	<span class="enscript-keyword">if</span> (vp)
	        vnode_put(vp);
	vnode_put(dvp);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (path &amp;&amp; (path != (<span class="enscript-type">char</span> *)path_data))
		FREE_ZONE(path, MAXPATHLEN, M_NAMEI);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">symlink</span>(__unused proc_t p, <span class="enscript-type">struct</span> symlink_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (symlinkat_internal(vfs_context_current(), uap-&gt;path, AT_FDCWD,
	    uap-&gt;link, UIO_USERSPACE));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">symlinkat</span>(__unused proc_t p, <span class="enscript-type">struct</span> symlinkat_args *uap,
    __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (symlinkat_internal(vfs_context_current(), uap-&gt;path1, uap-&gt;fd,
	    uap-&gt;path2, UIO_USERSPACE));
}

<span class="enscript-comment">/*
 * Delete a whiteout from the filesystem.
 * No longer supported.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">undelete</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> undelete_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-comment">/*
 * Delete a name from the filesystem.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">unlinkat_internal</span>(vfs_context_t ctx, <span class="enscript-type">int</span> fd, vnode_t start_dvp,
    user_addr_t path_arg, <span class="enscript-type">enum</span> uio_seg segflg, <span class="enscript-type">int</span> unlink_flags)
{
	<span class="enscript-type">struct</span> nameidata nd;
	vnode_t	vp, dvp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> componentname *cnp;
	<span class="enscript-type">char</span>  *path = NULL;
	<span class="enscript-type">int</span>  len=0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	fse_info  finfo;
	<span class="enscript-type">struct</span> vnode_attr va;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> flags;
	<span class="enscript-type">int</span> need_event;
	<span class="enscript-type">int</span> has_listeners;
	<span class="enscript-type">int</span> truncated_path;
	<span class="enscript-type">int</span> batched;
	<span class="enscript-type">struct</span> vnode_attr *vap;
	<span class="enscript-type">int</span> do_retry;
	<span class="enscript-type">int</span> retry_count = 0;
	<span class="enscript-type">int</span> cn_flags;

	cn_flags = LOCKPARENT;
	<span class="enscript-keyword">if</span> (!(unlink_flags &amp; VNODE_REMOVE_NO_AUDIT_PATH))
		cn_flags |= AUDITVNPATH1;
	<span class="enscript-comment">/* If a starting dvp is passed, it trumps any fd passed. */</span>
	<span class="enscript-keyword">if</span> (start_dvp)
		cn_flags |= USEDVP;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-comment">/* unlink or delete is allowed on rsrc forks and named streams */</span>
	cn_flags |= CN_ALLOWRSRCFORK;
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">retry</span>:
	do_retry = 0;
	flags = 0;
	need_event = 0;
	has_listeners = 0;
	truncated_path = 0;
	vap = NULL;

	NDINIT(&amp;nd, DELETE, OP_UNLINK, cn_flags, segflg, path_arg, ctx);

	nd.ni_dvp = start_dvp;
	nd.ni_flag |= NAMEI_COMPOUNDREMOVE;
	cnp = &amp;nd.ni_cnd;

<span class="enscript-reference">lookup_continue</span>:
	error = nameiat(&amp;nd, fd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	dvp = nd.ni_dvp;
	vp = nd.ni_vp;


	<span class="enscript-comment">/* With Carbon delete semantics, busy files cannot be deleted */</span>
	<span class="enscript-keyword">if</span> (unlink_flags &amp; VNODE_REMOVE_NODELETEBUSY) {
		flags |= VNODE_REMOVE_NODELETEBUSY;
	}
	
	<span class="enscript-comment">/* Skip any potential upcalls if told to. */</span>
	<span class="enscript-keyword">if</span> (unlink_flags &amp; VNODE_REMOVE_SKIP_NAMESPACE_EVENT) {
		flags |= VNODE_REMOVE_SKIP_NAMESPACE_EVENT;
	}

	<span class="enscript-keyword">if</span> (vp) {
		batched = vnode_compound_remove_available(vp);
		<span class="enscript-comment">/*
		 * The root of a mounted filesystem cannot be deleted.
		 */</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VROOT) {
			error = EBUSY;
		}

		<span class="enscript-keyword">if</span> (!batched) {
			error = vn_authorize_unlink(dvp, vp, cnp, ctx, NULL);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">if</span> (error == ENOENT) {
					assert(retry_count &lt; MAX_AUTHORIZE_ENOENT_RETRIES);
					<span class="enscript-keyword">if</span> (retry_count &lt; MAX_AUTHORIZE_ENOENT_RETRIES) {
						do_retry = 1;
						retry_count++;
					}
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	} <span class="enscript-keyword">else</span> {
		batched = 1;

		<span class="enscript-keyword">if</span> (!vnode_compound_remove_available(dvp)) {
			panic(<span class="enscript-string">&quot;No vp, but no compound remove?&quot;</span>);
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	need_event = need_fsevent(FSE_DELETE, dvp);
	<span class="enscript-keyword">if</span> (need_event) {
		<span class="enscript-keyword">if</span> (!batched) {
			<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VISHARDLINK) == 0) {
				<span class="enscript-comment">/* XXX need to get these data in batched VNOP */</span>
				get_fse_info(vp, &amp;finfo, ctx);
			}
		} <span class="enscript-keyword">else</span> {
			error = vfs_get_notify_attributes(&amp;va);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			vap = &amp;va;
		}
	}
#<span class="enscript-reference">endif</span>
	has_listeners = kauth_authorize_fileop_has_listeners();
	<span class="enscript-keyword">if</span> (need_event || has_listeners) {
		<span class="enscript-keyword">if</span> (path == NULL) {
			GET_PATH(path);
			<span class="enscript-keyword">if</span> (path == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
		len = safe_getpath(dvp, nd.ni_cnd.cn_nameptr, path, MAXPATHLEN, &amp;truncated_path);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-keyword">if</span> (nd.ni_cnd.cn_flags &amp; CN_WANTSRSRCFORK)
		error = vnode_removenamedstream(dvp, vp, XATTR_RESOURCEFORK_NAME, 0, ctx);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
	{
		error = vn_remove(dvp, &amp;nd.ni_vp, &amp;nd, flags, vap, ctx);
		vp = nd.ni_vp;
		<span class="enscript-keyword">if</span> (error == EKEEPLOOKING) {
			<span class="enscript-keyword">if</span> (!batched) {
				panic(<span class="enscript-string">&quot;EKEEPLOOKING, but not a filesystem that supports compound VNOPs?&quot;</span>);
			}

			<span class="enscript-keyword">if</span> ((nd.ni_flag &amp; NAMEI_CONTLOOKUP) == 0) {
				panic(<span class="enscript-string">&quot;EKEEPLOOKING, but continue flag not set?&quot;</span>);
			}

			<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
				error = EISDIR;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">lookup_continue</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == ENOENT &amp;&amp; batched) {
			assert(retry_count &lt; MAX_AUTHORIZE_ENOENT_RETRIES);
			<span class="enscript-keyword">if</span> (retry_count &lt; MAX_AUTHORIZE_ENOENT_RETRIES) {
				<span class="enscript-comment">/*
				 * For compound VNOPs, the authorization callback may
				 * return ENOENT in case of racing hardlink lookups
				 * hitting the name  cache, redrive the lookup.
				 */</span>
				do_retry = 1;
				retry_count += 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}

	<span class="enscript-comment">/*
	 * Call out to allow 3rd party notification of delete. 
	 * Ignore result of kauth_authorize_fileop call.
	 */</span>
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-keyword">if</span> (has_listeners) {
			kauth_authorize_fileop(vfs_context_ucred(ctx), 
				KAUTH_FILEOP_DELETE, 
				(uintptr_t)vp,
				(uintptr_t)path);
		}

		<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISHARDLINK) {
		    <span class="enscript-comment">//
</span>		    <span class="enscript-comment">// if a hardlink gets deleted we want to blow away the
</span>		    <span class="enscript-comment">// v_parent link because the path that got us to this
</span>		    <span class="enscript-comment">// instance of the link is no longer valid.  this will
</span>		    <span class="enscript-comment">// force the next call to get the path to ask the file
</span>		    <span class="enscript-comment">// system instead of just following the v_parent link.
</span>		    <span class="enscript-comment">//
</span>		    vnode_update_identity(vp, NULL, NULL, 0, 0, VNODE_UPDATE_PARENT);
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
		<span class="enscript-keyword">if</span> (need_event) {
			<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISHARDLINK) {
				get_fse_info(vp, &amp;finfo, ctx);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vap) {
				vnode_get_fse_info_from_vap(vp, &amp;finfo, vap);
			}
			<span class="enscript-keyword">if</span> (truncated_path) {
				finfo.mode |= FSE_TRUNCATED_PATH;
			}
			add_fsevent(FSE_DELETE, ctx,
						FSE_ARG_STRING, len, path,
						FSE_ARG_FINFO, &amp;finfo,
						FSE_ARG_DONE);
		}
#<span class="enscript-reference">endif</span>
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (path != NULL)
		RELEASE_PATH(path);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-comment">/* recycle the deleted rsrc fork vnode to force a reclaim, which 
	 * will cause its shadow file to go away if necessary.
	 */</span>
	 <span class="enscript-keyword">if</span> (vp &amp;&amp; (vnode_isnamedstream(vp)) &amp;&amp;
		(vp-&gt;v_parent != NULLVP) &amp;&amp;
		vnode_isshadow(vp)) {
   			vnode_recycle(vp);
	 }	
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * nameidone has to happen before we vnode_put(dvp)
	 * since it may need to release the fs_nodelock on the dvp
	 */</span>
	nameidone(&amp;nd);
	vnode_put(dvp);
	<span class="enscript-keyword">if</span> (vp) {
		vnode_put(vp);
	}

	<span class="enscript-keyword">if</span> (do_retry) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">unlink1</span>(vfs_context_t ctx, vnode_t start_dvp, user_addr_t path_arg,
    <span class="enscript-type">enum</span> uio_seg segflg, <span class="enscript-type">int</span> unlink_flags)
{
	<span class="enscript-keyword">return</span> (unlinkat_internal(ctx, AT_FDCWD, start_dvp, path_arg, segflg,
	    unlink_flags));
}

<span class="enscript-comment">/*
 * Delete a name from the filesystem using Carbon semantics.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">delete</span>(__unused proc_t p, <span class="enscript-type">struct</span> delete_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (unlinkat_internal(vfs_context_current(), AT_FDCWD, NULLVP,
	    uap-&gt;path, UIO_USERSPACE, VNODE_REMOVE_NODELETEBUSY));
}

<span class="enscript-comment">/*
 * Delete a name from the filesystem using POSIX semantics.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">unlink</span>(__unused proc_t p, <span class="enscript-type">struct</span> unlink_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (unlinkat_internal(vfs_context_current(), AT_FDCWD, NULLVP,
	    uap-&gt;path, UIO_USERSPACE, 0));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">unlinkat</span>(__unused proc_t p, <span class="enscript-type">struct</span> unlinkat_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">if</span> (uap-&gt;flag &amp; ~AT_REMOVEDIR)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (uap-&gt;flag &amp; AT_REMOVEDIR)
		<span class="enscript-keyword">return</span> (rmdirat_internal(vfs_context_current(), uap-&gt;fd,
		    uap-&gt;path, UIO_USERSPACE));
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (unlinkat_internal(vfs_context_current(), uap-&gt;fd,
		    NULLVP, uap-&gt;path, UIO_USERSPACE, 0));
}

<span class="enscript-comment">/*
 * Reposition read/write file offset.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">lseek</span>(proc_t p, <span class="enscript-type">struct</span> lseek_args *uap, off_t *retval)
{
	<span class="enscript-type">struct</span> fileproc *fp;
	vnode_t vp;
	<span class="enscript-type">struct</span> vfs_context *ctx;
	off_t offset = uap-&gt;offset, file_size;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ( (error = fp_getfvp(p,uap-&gt;fd, &amp;fp, &amp;vp)) ) {
	        <span class="enscript-keyword">if</span> (error == ENOTSUP)
		        <span class="enscript-keyword">return</span> (ESPIPE);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (vnode_isfifo(vp)) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(ESPIPE);
	}


	ctx = vfs_context_current();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (uap-&gt;whence == L_INCR &amp;&amp; uap-&gt;offset == 0)
		error = mac_file_check_get_offset(vfs_context_ucred(ctx),
		    fp-&gt;f_fglob);
	<span class="enscript-keyword">else</span>
		error = mac_file_check_change_offset(vfs_context_ucred(ctx),
		    fp-&gt;f_fglob);
	<span class="enscript-keyword">if</span> (error) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(error);
	}

	<span class="enscript-keyword">switch</span> (uap-&gt;whence) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">L_INCR</span>:
		offset += fp-&gt;f_fglob-&gt;fg_offset;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">L_XTND</span>:
		<span class="enscript-keyword">if</span> ((error = vnode_size(vp, &amp;file_size, ctx)) != 0)
			<span class="enscript-keyword">break</span>;
		offset += file_size;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">L_SET</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
	}
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-keyword">if</span> (uap-&gt;offset &gt; 0 &amp;&amp; offset &lt; 0) {
			<span class="enscript-comment">/* Incremented/relative move past max size */</span>
			error = EOVERFLOW;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Allow negative offsets on character devices, per
			 * POSIX 1003.1-2001.  Most likely for writing disk
			 * labels.
			 */</span>
			<span class="enscript-keyword">if</span> (offset &lt; 0 &amp;&amp; vp-&gt;v_type != VCHR) {
				<span class="enscript-comment">/* Decremented/relative move before start */</span>
				error = EINVAL;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Success */</span>
				fp-&gt;f_fglob-&gt;fg_offset = offset;
				*retval = fp-&gt;f_fglob-&gt;fg_offset;
			}
		}
	}

	<span class="enscript-comment">/* 
	 * An lseek can affect whether data is &quot;available to read.&quot;  Use
	 * hint of NOTE_NONE so no EVFILT_VNODE events fire
	 */</span>
	post_event_if_success(vp, error, NOTE_NONE);
	(<span class="enscript-type">void</span>)vnode_put(vp);
	file_drop(uap-&gt;fd);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Check access permissions.
 *
 * Returns:	0			Success
 *		vnode_authorize:???
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">access1</span>(vnode_t vp, vnode_t dvp, <span class="enscript-type">int</span> uflags, vfs_context_t ctx)
{
 	kauth_action_t action;
	<span class="enscript-type">int</span> error;

 	<span class="enscript-comment">/*
 	 * If just the regular access bits, convert them to something
	 * that vnode_authorize will understand.
 	 */</span>
 	<span class="enscript-keyword">if</span> (!(uflags &amp; _ACCESS_EXTENDED_MASK)) {
 		action = 0;
  		<span class="enscript-keyword">if</span> (uflags &amp; R_OK)
			action |= KAUTH_VNODE_READ_DATA;	<span class="enscript-comment">/* aka KAUTH_VNODE_LIST_DIRECTORY */</span>
  		<span class="enscript-keyword">if</span> (uflags &amp; W_OK) {
			<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
				action |= KAUTH_VNODE_ADD_FILE |
				    KAUTH_VNODE_ADD_SUBDIRECTORY;
				<span class="enscript-comment">/* might want delete rights here too */</span>
			} <span class="enscript-keyword">else</span> {
				action |= KAUTH_VNODE_WRITE_DATA;
			}
		}
  		<span class="enscript-keyword">if</span> (uflags &amp; X_OK) {
			<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
				action |= KAUTH_VNODE_SEARCH;
			} <span class="enscript-keyword">else</span> {
				action |= KAUTH_VNODE_EXECUTE;
			}
		}
  	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* take advantage of definition of uflags */</span>
		action = uflags &gt;&gt; 8;
	}
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_access(ctx, vp, uflags);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>

 	<span class="enscript-comment">/* action == 0 means only check for existence */</span>
 	<span class="enscript-keyword">if</span> (action != 0) {
 		error = vnode_authorize(vp, dvp, action | KAUTH_VNODE_ACCESS, ctx);
	} <span class="enscript-keyword">else</span> {
		error = 0;
	}

	<span class="enscript-keyword">return</span>(error);
}



<span class="enscript-comment">/*
 * access_extended: Check access permissions in bulk.
 *
 * Description:	uap-&gt;entries		Pointer to an array of accessx
 * 					descriptor structs, plus one or 
 * 					more NULL terminated strings (see 
 * 					&quot;Notes&quot; section below).
 *		uap-&gt;size		Size of the area pointed to by
 *					uap-&gt;entries.
 *		uap-&gt;results		Pointer to the results array.
 *
 * Returns:	0			Success
 *		ENOMEM			Insufficient memory
 *		EINVAL			Invalid arguments
 *		namei:EFAULT		Bad address
 *		namei:ENAMETOOLONG	Filename too long
 *		namei:ENOENT		No such file or directory
 *		namei:ELOOP		Too many levels of symbolic links
 *		namei:EBADF		Bad file descriptor
 *		namei:ENOTDIR		Not a directory
 *		namei:???
 *		access1:
 *
 * Implicit returns:
 *		uap-&gt;results		Array contents modified
 *
 * Notes:	The uap-&gt;entries are structured as an arbitrary length array
 *		of accessx descriptors, followed by one or more NULL terminated
 *		strings
 *
 *			struct accessx_descriptor[0]
 *			...
 *			struct accessx_descriptor[n]
 *			char name_data[0];
 *
 *		We determine the entry count by walking the buffer containing
 *		the uap-&gt;entries argument descriptor.  For each descriptor we
 *		see, the valid values for the offset ad_name_offset will be
 *		in the byte range:
 *
 *			[ uap-&gt;entries + sizeof(struct accessx_descriptor) ]
 *						to
 *				[ uap-&gt;entries + uap-&gt;size - 2 ]
 *
 *		since we must have at least one string, and the string must
 *		be at least one character plus the NULL terminator in length.
 *		
 * XXX:		Need to support the check-as uid argument
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">access_extended</span>(__unused proc_t p, <span class="enscript-type">struct</span> access_extended_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> accessx_descriptor *input = NULL;
	errno_t *result = NULL;
	errno_t error = 0;
	<span class="enscript-type">int</span> wantdelete = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> desc_max, desc_actual, i, j;
	<span class="enscript-type">struct</span> vfs_context context;
	<span class="enscript-type">struct</span> nameidata nd;
 	<span class="enscript-type">int</span> niopts;
	vnode_t vp = NULL;
	vnode_t dvp = NULL;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ACCESSX_MAX_DESCR_ON_STACK</span> 10
	<span class="enscript-type">struct</span> accessx_descriptor stack_input[ACCESSX_MAX_DESCR_ON_STACK];

	context.vc_ucred = NULL;

	<span class="enscript-comment">/*
	 * Validate parameters; if valid, copy the descriptor array and string
	 * arguments into local memory.  Before proceeding, the following
	 * conditions must have been met:
	 *
	 * o	The total size is not permitted to exceed ACCESSX_MAX_TABLESIZE
	 * o	There must be sufficient room in the request for at least one
	 *	descriptor and a one yte NUL terminated string.
	 * o	The allocation of local storage must not fail.
	 */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;size &gt; ACCESSX_MAX_TABLESIZE)
		<span class="enscript-keyword">return</span>(ENOMEM);
	<span class="enscript-keyword">if</span> (uap-&gt;size &lt; (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> accessx_descriptor) + 2))
		<span class="enscript-keyword">return</span>(EINVAL);
	<span class="enscript-keyword">if</span> (uap-&gt;size &lt;= <span class="enscript-keyword">sizeof</span> (stack_input)) {
		input = stack_input;
	} <span class="enscript-keyword">else</span> {
	MALLOC(input, <span class="enscript-type">struct</span> accessx_descriptor *, uap-&gt;size, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (input == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	}
	error = copyin(uap-&gt;entries, input, uap-&gt;size);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	AUDIT_ARG(opaque, input, uap-&gt;size);

	<span class="enscript-comment">/*
	 * Force NUL termination of the copyin buffer to avoid nami() running
	 * off the end.  If the caller passes us bogus data, they may get a
	 * bogus result.
	 */</span>
	((<span class="enscript-type">char</span> *)input)[uap-&gt;size - 1] = 0;

	<span class="enscript-comment">/*
	 * Access is defined as checking against the process' real identity,
 	 * even if operations are checking the effective identity.  This
	 * requires that we use a local vfs context.
 	 */</span>
	context.vc_ucred = kauth_cred_copy_real(kauth_cred_get());
	context.vc_thread = current_thread();

	<span class="enscript-comment">/*
	 * Find out how many entries we have, so we can allocate the result
	 * array by walking the list and adjusting the count downward by the
	 * earliest string offset we see.
	 */</span>
	desc_max = (uap-&gt;size - 2) / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> accessx_descriptor);
	desc_actual = desc_max;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; desc_actual; i++) {
		<span class="enscript-comment">/*
		 * Take the offset to the name string for this entry and
		 * convert to an input array index, which would be one off
		 * the end of the array if this entry was the lowest-addressed
		 * name string.
		 */</span>
		j = input[i].ad_name_offset / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> accessx_descriptor);

		<span class="enscript-comment">/*
		 * An offset greater than the max allowable offset is an error.
		 * It is also an error for any valid entry to point
		 * to a location prior to the end of the current entry, if
		 * it's not a reference to the string of the previous entry.
		 */</span>
		<span class="enscript-keyword">if</span> (j &gt; desc_max || (j != 0 &amp;&amp; j &lt;= i)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/*
		 * An offset of 0 means use the previous descriptor's offset;
		 * this is used to chain multiple requests for the same file
		 * to avoid multiple lookups.
		 */</span>
		<span class="enscript-keyword">if</span> (j == 0) {
			<span class="enscript-comment">/* This is not valid for the first entry */</span>
			<span class="enscript-keyword">if</span> (i == 0) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * If the offset of the string for this descriptor is before
		 * what we believe is the current actual last descriptor,
		 * then we need to adjust our estimate downward; this permits
		 * the string table following the last descriptor to be out
		 * of order relative to the descriptor list.
		 */</span>
		<span class="enscript-keyword">if</span> (j &lt; desc_actual)
			desc_actual = j;
	}

	<span class="enscript-comment">/*
	 * We limit the actual number of descriptors we are willing to process
	 * to a hard maximum of ACCESSX_MAX_DESCRIPTORS.  If the number being
	 * requested does not exceed this limit,
	 */</span>
	<span class="enscript-keyword">if</span> (desc_actual &gt; ACCESSX_MAX_DESCRIPTORS) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	MALLOC(result, errno_t *, desc_actual * <span class="enscript-keyword">sizeof</span>(errno_t), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (result == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Do the work by iterating over the descriptor entries we know to
	 * at least appear to contain valid data.
	 */</span>
	error = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; desc_actual; i++) {
		<span class="enscript-comment">/*
		 * If the ad_name_offset is 0, then we use the previous
		 * results to make the check; otherwise, we are looking up
		 * a new file name.
		 */</span>
		<span class="enscript-keyword">if</span> (input[i].ad_name_offset != 0) {
			<span class="enscript-comment">/* discard old vnodes */</span>
			<span class="enscript-keyword">if</span> (vp) {
				vnode_put(vp);
				vp = NULL;
			}
			<span class="enscript-keyword">if</span> (dvp) {
				vnode_put(dvp);
				dvp = NULL;
			}
			
			<span class="enscript-comment">/*
			 * Scan forward in the descriptor list to see if we
			 * need the parent vnode.  We will need it if we are
			 * deleting, since we must have rights  to remove
			 * entries in the parent directory, as well as the
			 * rights to delete the object itself.
			 */</span>
			wantdelete = input[i].ad_flags &amp; _DELETE_OK;
			<span class="enscript-keyword">for</span> (j = i + 1; (j &lt; desc_actual) &amp;&amp; (input[j].ad_name_offset == 0); j++)
				<span class="enscript-keyword">if</span> (input[j].ad_flags &amp; _DELETE_OK)
					wantdelete = 1;
			
			niopts = FOLLOW | AUDITVNPATH1;

			<span class="enscript-comment">/* need parent for vnode_authorize for deletion test */</span>
			<span class="enscript-keyword">if</span> (wantdelete)
				niopts |= WANTPARENT;

			<span class="enscript-comment">/* do the lookup */</span>
			NDINIT(&amp;nd, LOOKUP, OP_ACCESS, niopts, UIO_SYSSPACE,
			       CAST_USER_ADDR_T(((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)input) + input[i].ad_name_offset),
			       &amp;context);
			error = namei(&amp;nd);
			<span class="enscript-keyword">if</span> (!error) {
				vp = nd.ni_vp;
				<span class="enscript-keyword">if</span> (wantdelete)
					dvp = nd.ni_dvp;
			}
			nameidone(&amp;nd);
		}

		<span class="enscript-comment">/*
		 * Handle lookup errors.
		 */</span>
		<span class="enscript-keyword">switch</span>(error) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOENT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EACCES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EPERM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOTDIR</span>:
			result[i] = error;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
			<span class="enscript-comment">/* run this access check */</span>
			result[i] = access1(vp, dvp, input[i].ad_flags, &amp;context);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* fatal lookup error */</span>

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	AUDIT_ARG(data, result, <span class="enscript-keyword">sizeof</span>(errno_t), desc_actual);

	<span class="enscript-comment">/* copy out results */</span>
	error = copyout(result, uap-&gt;results, desc_actual * <span class="enscript-keyword">sizeof</span>(errno_t));
	
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (input &amp;&amp; input != stack_input)
		FREE(input, M_TEMP);
	<span class="enscript-keyword">if</span> (result)
		FREE(result, M_TEMP);
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);
	<span class="enscript-keyword">if</span> (dvp)
		vnode_put(dvp);
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(context.vc_ucred))
 		kauth_cred_unref(&amp;context.vc_ucred);
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * Returns:	0			Success
 *		namei:EFAULT		Bad address
 *		namei:ENAMETOOLONG	Filename too long
 *		namei:ENOENT		No such file or directory
 *		namei:ELOOP		Too many levels of symbolic links
 *		namei:EBADF		Bad file descriptor
 *		namei:ENOTDIR		Not a directory
 *		namei:???
 *		access1:
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">faccessat_internal</span>(vfs_context_t ctx, <span class="enscript-type">int</span> fd, user_addr_t path, <span class="enscript-type">int</span> amode,
    <span class="enscript-type">int</span> flag, <span class="enscript-type">enum</span> uio_seg segflg)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
 	<span class="enscript-type">int</span> niopts;
	<span class="enscript-type">struct</span> vfs_context context;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-type">int</span> is_namedstream = 0;
#<span class="enscript-reference">endif</span>

 	<span class="enscript-comment">/*
	 * Unless the AT_EACCESS option is used, Access is defined as checking
	 * against the process' real identity, even if operations are checking
	 * the effective identity.  So we need to tweak the credential
 	 * in the context for that case.
 	 */</span>
	<span class="enscript-keyword">if</span> (!(flag &amp; AT_EACCESS))
		context.vc_ucred = kauth_cred_copy_real(kauth_cred_get());
	<span class="enscript-keyword">else</span>
		context.vc_ucred = ctx-&gt;vc_ucred;
	context.vc_thread = ctx-&gt;vc_thread;


	niopts = FOLLOW | AUDITVNPATH1;
 	<span class="enscript-comment">/* need parent for vnode_authorize for deletion test */</span>
 	<span class="enscript-keyword">if</span> (amode &amp; _DELETE_OK)
 		niopts |= WANTPARENT;
 	NDINIT(&amp;nd, LOOKUP, OP_ACCESS, niopts, segflg,
	       path, &amp;context);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-comment">/* access(F_OK) calls are allowed for resource forks. */</span>
	<span class="enscript-keyword">if</span> (amode == F_OK)
		nd.ni_cnd.cn_flags |= CN_ALLOWRSRCFORK;
#<span class="enscript-reference">endif</span>
 	error = nameiat(&amp;nd, fd);
 	<span class="enscript-keyword">if</span> (error)
 		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-comment">/* Grab reference on the shadow stream file vnode to 
	 * force an inactive on release which will mark it
	 * for recycle.
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isnamedstream(nd.ni_vp) &amp;&amp;
	    (nd.ni_vp-&gt;v_parent != NULLVP) &amp;&amp;
	    vnode_isshadow(nd.ni_vp)) {
		is_namedstream = 1;
		vnode_ref(nd.ni_vp);
	}
#<span class="enscript-reference">endif</span>

	error = access1(nd.ni_vp, nd.ni_dvp, amode, &amp;context);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-keyword">if</span> (is_namedstream) {
		vnode_rele(nd.ni_vp);
	}
#<span class="enscript-reference">endif</span>

 	vnode_put(nd.ni_vp);
	<span class="enscript-keyword">if</span> (amode &amp; _DELETE_OK)
 		vnode_put(nd.ni_dvp);
  	nameidone(&amp;nd);
  
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (!(flag &amp; AT_EACCESS))
		kauth_cred_unref(&amp;context.vc_ucred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">access</span>(__unused proc_t p, <span class="enscript-type">struct</span> access_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (faccessat_internal(vfs_context_current(), AT_FDCWD,
	    uap-&gt;path, uap-&gt;flags, 0, UIO_USERSPACE));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">faccessat</span>(__unused proc_t p, <span class="enscript-type">struct</span> faccessat_args *uap,
          __unused int32_t *retval)
{
	<span class="enscript-keyword">if</span> (uap-&gt;flag &amp; ~AT_EACCESS)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (faccessat_internal(vfs_context_current(), uap-&gt;fd,
	    uap-&gt;path, uap-&gt;amode, uap-&gt;flag, UIO_USERSPACE));
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		EFAULT
 *	copyout:EFAULT
 *	namei:???
 *	vn_stat:???
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fstatat_internal</span>(vfs_context_t ctx, user_addr_t path, user_addr_t ub,
    user_addr_t xsecurity, user_addr_t xsecurity_size, <span class="enscript-type">int</span> isstat64,
    <span class="enscript-type">enum</span> uio_seg segflg, <span class="enscript-type">int</span> fd, <span class="enscript-type">int</span> flag)
{
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">int</span> follow;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> stat sb;
		<span class="enscript-type">struct</span> stat64 sb64;
	} source;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> user64_stat user64_sb;
		<span class="enscript-type">struct</span> user32_stat user32_sb;
		<span class="enscript-type">struct</span> user64_stat64 user64_sb64;
		<span class="enscript-type">struct</span> user32_stat64 user32_sb64;
	} dest;
	caddr_t sbp;
	<span class="enscript-type">int</span> error, my_size;
	kauth_filesec_t fsec;
	size_t xsecurity_bufsize;
	<span class="enscript-type">void</span> * statptr;

	follow = (flag &amp; AT_SYMLINK_NOFOLLOW) ? NOFOLLOW : FOLLOW;
	NDINIT(&amp;nd, LOOKUP, OP_GETATTR, follow | AUDITVNPATH1,
	    segflg, path, ctx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-type">int</span> is_namedstream = 0;
	<span class="enscript-comment">/* stat calls are allowed for resource forks. */</span>
	nd.ni_cnd.cn_flags |= CN_ALLOWRSRCFORK;
#<span class="enscript-reference">endif</span>
	error = nameiat(&amp;nd, fd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	fsec = KAUTH_FILESEC_NONE;

	statptr = (<span class="enscript-type">void</span> *)&amp;source;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-comment">/* Grab reference on the shadow stream file vnode to 
	 * force an inactive on release which will mark it 
	 * for recycle.
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isnamedstream(nd.ni_vp) &amp;&amp;
	    (nd.ni_vp-&gt;v_parent != NULLVP) &amp;&amp;
	    vnode_isshadow(nd.ni_vp)) {
		is_namedstream = 1;
		vnode_ref(nd.ni_vp);
	}
#<span class="enscript-reference">endif</span>

	error = vn_stat(nd.ni_vp, statptr, (xsecurity != USER_ADDR_NULL ? &amp;fsec : NULL), isstat64, ctx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-keyword">if</span> (is_namedstream) {
		vnode_rele(nd.ni_vp);
	}
#<span class="enscript-reference">endif</span>
	vnode_put(nd.ni_vp);
	nameidone(&amp;nd);

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-comment">/* Zap spare fields */</span>
	<span class="enscript-keyword">if</span> (isstat64 != 0) {
		source.sb64.st_lspare = 0;
		source.sb64.st_qspare[0] = 0LL;
		source.sb64.st_qspare[1] = 0LL;
		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(vfs_context_proc(ctx))) {
			munge_user64_stat64(&amp;source.sb64, &amp;dest.user64_sb64); 
			my_size = <span class="enscript-keyword">sizeof</span>(dest.user64_sb64);
			sbp = (caddr_t)&amp;dest.user64_sb64;
		} <span class="enscript-keyword">else</span> {
			munge_user32_stat64(&amp;source.sb64, &amp;dest.user32_sb64); 
			my_size = <span class="enscript-keyword">sizeof</span>(dest.user32_sb64);
			sbp = (caddr_t)&amp;dest.user32_sb64;
		}
		<span class="enscript-comment">/*
		 * Check if we raced (post lookup) against the last unlink of a file.
		 */</span>
		<span class="enscript-keyword">if</span> ((source.sb64.st_nlink == 0) &amp;&amp; S_ISREG(source.sb64.st_mode)) {
			source.sb64.st_nlink = 1;
		}
	} <span class="enscript-keyword">else</span> {
		source.sb.st_lspare = 0;
		source.sb.st_qspare[0] = 0LL;
		source.sb.st_qspare[1] = 0LL;
		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(vfs_context_proc(ctx))) {
			munge_user64_stat(&amp;source.sb, &amp;dest.user64_sb); 
			my_size = <span class="enscript-keyword">sizeof</span>(dest.user64_sb);
			sbp = (caddr_t)&amp;dest.user64_sb;
		} <span class="enscript-keyword">else</span> {
			munge_user32_stat(&amp;source.sb, &amp;dest.user32_sb); 
			my_size = <span class="enscript-keyword">sizeof</span>(dest.user32_sb);
			sbp = (caddr_t)&amp;dest.user32_sb;
		}

		<span class="enscript-comment">/*
		 * Check if we raced (post lookup) against the last unlink of a file.
		 */</span>
		<span class="enscript-keyword">if</span> ((source.sb.st_nlink == 0) &amp;&amp; S_ISREG(source.sb.st_mode)) {
			source.sb.st_nlink = 1;
		}
	}
	<span class="enscript-keyword">if</span> ((error = copyout(sbp, ub, my_size)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* caller wants extended security information? */</span>
	<span class="enscript-keyword">if</span> (xsecurity != USER_ADDR_NULL) {

		<span class="enscript-comment">/* did we get any? */</span>
		<span class="enscript-keyword">if</span> (fsec == KAUTH_FILESEC_NONE) {
			<span class="enscript-keyword">if</span> (susize(xsecurity_size, 0) != 0) {
				error = EFAULT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* find the user buffer size */</span>
			xsecurity_bufsize = fusize(xsecurity_size);

			<span class="enscript-comment">/* copy out the actual data size */</span>
			<span class="enscript-keyword">if</span> (susize(xsecurity_size, KAUTH_FILESEC_COPYSIZE(fsec)) != 0) {
				error = EFAULT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-comment">/* if the caller supplied enough room, copy out to it */</span>
			<span class="enscript-keyword">if</span> (xsecurity_bufsize &gt;= KAUTH_FILESEC_COPYSIZE(fsec))
				error = copyout(fsec, xsecurity, KAUTH_FILESEC_COPYSIZE(fsec));
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (fsec != KAUTH_FILESEC_NONE)
		kauth_filesec_free(fsec);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * stat_extended: Get file status; with extended security (ACL).
 *
 * Parameters:    p                       (ignored)
 *                uap                     User argument descriptor (see below)
 *                retval                  (ignored) 
 *
 * Indirect:      uap-&gt;path               Path of file to get status from
 *                uap-&gt;ub                 User buffer (holds file status info)
 *                uap-&gt;xsecurity          ACL to get (extended security)
 *                uap-&gt;xsecurity_size     Size of ACL
 *                
 * Returns:        0                      Success
 *                !0                      errno value
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">stat_extended</span>(__unused proc_t p, <span class="enscript-type">struct</span> stat_extended_args *uap,
    __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (fstatat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;ub,
	    uap-&gt;xsecurity, uap-&gt;xsecurity_size, 0, UIO_USERSPACE, AT_FDCWD,
	    0));
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *	fstatat_internal:???		[see fstatat_internal() in this file]
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">stat</span>(__unused proc_t p, <span class="enscript-type">struct</span> stat_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (fstatat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;ub,
	    0, 0, 0, UIO_USERSPACE, AT_FDCWD, 0));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">stat64</span>(__unused proc_t p, <span class="enscript-type">struct</span> stat64_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (fstatat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;ub,
	    0, 0, 1, UIO_USERSPACE, AT_FDCWD, 0));
}

<span class="enscript-comment">/*
 * stat64_extended: Get file status; can handle large inode numbers; with extended security (ACL).
 *
 * Parameters:    p                       (ignored)
 *                uap                     User argument descriptor (see below)
 *                retval                  (ignored) 
 *
 * Indirect:      uap-&gt;path               Path of file to get status from
 *                uap-&gt;ub                 User buffer (holds file status info)
 *                uap-&gt;xsecurity          ACL to get (extended security)
 *                uap-&gt;xsecurity_size     Size of ACL
 *                
 * Returns:        0                      Success
 *                !0                      errno value
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">stat64_extended</span>(__unused proc_t p, <span class="enscript-type">struct</span> stat64_extended_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (fstatat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;ub,
	    uap-&gt;xsecurity, uap-&gt;xsecurity_size, 1, UIO_USERSPACE, AT_FDCWD,
	    0));
}

<span class="enscript-comment">/*
 * lstat_extended: Get file status; does not follow links; with extended security (ACL).
 *
 * Parameters:    p                       (ignored)
 *                uap                     User argument descriptor (see below)
 *                retval                  (ignored) 
 *
 * Indirect:      uap-&gt;path               Path of file to get status from
 *                uap-&gt;ub                 User buffer (holds file status info)
 *                uap-&gt;xsecurity          ACL to get (extended security)
 *                uap-&gt;xsecurity_size     Size of ACL
 *                
 * Returns:        0                      Success
 *                !0                      errno value
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">lstat_extended</span>(__unused proc_t p, <span class="enscript-type">struct</span> lstat_extended_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (fstatat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;ub,
	    uap-&gt;xsecurity, uap-&gt;xsecurity_size, 0, UIO_USERSPACE, AT_FDCWD,
	    AT_SYMLINK_NOFOLLOW));
}

<span class="enscript-comment">/*
 * Get file status; this version does not follow links.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">lstat</span>(__unused proc_t p, <span class="enscript-type">struct</span> lstat_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (fstatat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;ub,
	    0, 0, 0, UIO_USERSPACE, AT_FDCWD, AT_SYMLINK_NOFOLLOW));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">lstat64</span>(__unused proc_t p, <span class="enscript-type">struct</span> lstat64_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (fstatat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;ub,
	    0, 0, 1, UIO_USERSPACE, AT_FDCWD, AT_SYMLINK_NOFOLLOW));
}

<span class="enscript-comment">/*
 * lstat64_extended: Get file status; can handle large inode numbers; does not
 * follow links; with extended security (ACL).
 *
 * Parameters:    p                       (ignored)
 *                uap                     User argument descriptor (see below)
 *                retval                  (ignored) 
 *
 * Indirect:      uap-&gt;path               Path of file to get status from
 *                uap-&gt;ub                 User buffer (holds file status info)
 *                uap-&gt;xsecurity          ACL to get (extended security)
 *                uap-&gt;xsecurity_size     Size of ACL
 *                
 * Returns:        0                      Success
 *                !0                      errno value
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">lstat64_extended</span>(__unused proc_t p, <span class="enscript-type">struct</span> lstat64_extended_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (fstatat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;ub,
	    uap-&gt;xsecurity, uap-&gt;xsecurity_size, 1, UIO_USERSPACE, AT_FDCWD,
	    AT_SYMLINK_NOFOLLOW));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fstatat</span>(__unused proc_t p, <span class="enscript-type">struct</span> fstatat_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">if</span> (uap-&gt;flag &amp; ~AT_SYMLINK_NOFOLLOW)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (fstatat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;ub,
	    0, 0, 0, UIO_USERSPACE, uap-&gt;fd, uap-&gt;flag));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fstatat64</span>(__unused proc_t p, <span class="enscript-type">struct</span> fstatat64_args *uap,
    __unused int32_t *retval)
{
	<span class="enscript-keyword">if</span> (uap-&gt;flag &amp; ~AT_SYMLINK_NOFOLLOW)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (fstatat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;ub,
	    0, 0, 1, UIO_USERSPACE, uap-&gt;fd, uap-&gt;flag));
}

<span class="enscript-comment">/*
 * Get configurable pathname variables.
 *
 * Returns:	0			Success
 *	namei:???
 *	vn_pathconf:???
 *
 * Notes:	Global implementation  constants are intended to be
 *		implemented in this function directly; all other constants
 *		are per-FS implementation, and therefore must be handled in
 *		each respective FS, instead.
 *
 * XXX We implement some things globally right now that should actually be
 * XXX per-FS; we will need to deal with this at some point.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">pathconf</span>(__unused proc_t p, <span class="enscript-type">struct</span> pathconf_args *uap, int32_t *retval)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	vfs_context_t ctx = vfs_context_current();

	NDINIT(&amp;nd, LOOKUP, OP_PATHCONF, FOLLOW | AUDITVNPATH1, 
		UIO_USERSPACE, uap-&gt;path, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	error = vn_pathconf(nd.ni_vp, uap-&gt;name, retval, ctx);

	vnode_put(nd.ni_vp);
	nameidone(&amp;nd);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Return target name of a symbolic link.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">readlinkat_internal</span>(vfs_context_t ctx, <span class="enscript-type">int</span> fd, user_addr_t path,
    <span class="enscript-type">enum</span> uio_seg seg, user_addr_t buf, size_t bufsize, <span class="enscript-type">enum</span> uio_seg bufseg,
    <span class="enscript-type">int</span> *retval)
{
	vnode_t vp;
	uio_t auio;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];

	NDINIT(&amp;nd, LOOKUP, OP_READLINK, NOFOLLOW | AUDITVNPATH1,
	    seg, path, ctx);

	error = nameiat(&amp;nd, fd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	vp = nd.ni_vp;

	nameidone(&amp;nd);

	auio = uio_createwithbuffer(1, 0, bufseg, UIO_READ,
                                    &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, buf, bufsize);
	<span class="enscript-keyword">if</span> (vp-&gt;v_type != VLNK) {
		error = EINVAL;
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_vnode_check_readlink(ctx, vp);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (error == 0)
			error = vnode_authorize(vp, NULL, KAUTH_VNODE_READ_DATA,
			                        ctx);
		<span class="enscript-keyword">if</span> (error == 0)
			error = VNOP_READLINK(vp, auio, ctx);
	}
	vnode_put(vp);

	*retval = bufsize - (<span class="enscript-type">int</span>)uio_resid(auio);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">readlink</span>(proc_t p, <span class="enscript-type">struct</span> readlink_args *uap, int32_t *retval)
{
	<span class="enscript-type">enum</span> uio_seg procseg;

	procseg = IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	<span class="enscript-keyword">return</span> (readlinkat_internal(vfs_context_current(), AT_FDCWD,
	    CAST_USER_ADDR_T(uap-&gt;path), procseg, CAST_USER_ADDR_T(uap-&gt;buf),
	    uap-&gt;count, procseg, retval));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">readlinkat</span>(proc_t p, <span class="enscript-type">struct</span> readlinkat_args *uap, int32_t *retval)
{
	<span class="enscript-type">enum</span> uio_seg procseg;

	procseg = IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	<span class="enscript-keyword">return</span> (readlinkat_internal(vfs_context_current(), uap-&gt;fd, uap-&gt;path,
	    procseg, uap-&gt;buf, uap-&gt;bufsize, procseg, retval));
}

<span class="enscript-comment">/*
 * Change file flags.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">chflags1</span>(vnode_t vp, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnode_attr va;
 	kauth_action_t action;
	<span class="enscript-type">int</span> error;

	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_flags, flags);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_setflags(ctx, vp, flags);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* request authorisation, disregard immutability */</span>
 	<span class="enscript-keyword">if</span> ((error = vnode_authattr(vp, &amp;va, &amp;action, ctx)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-comment">/*
	 * Request that the auth layer disregard those file flags it's allowed to when
	 * authorizing this operation; we need to do this in order to be able to
	 * clear immutable flags.
	 */</span>
	<span class="enscript-keyword">if</span> (action &amp;&amp; ((error = vnode_authorize(vp, NULL, action | KAUTH_VNODE_NOIMMUTABLE, ctx)) != 0))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	error = vnode_setattr(vp, &amp;va, ctx);

	<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; !VATTR_IS_SUPPORTED(&amp;va, va_flags)) {
		error = ENOTSUP;
	}
<span class="enscript-reference">out</span>:
	vnode_put(vp);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Change flags of a file given a path name.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">chflags</span>(__unused proc_t p, <span class="enscript-type">struct</span> chflags_args *uap, __unused int32_t *retval)
{
	vnode_t vp;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;

	AUDIT_ARG(fflags, uap-&gt;flags);
	NDINIT(&amp;nd, LOOKUP, OP_SETATTR, FOLLOW | AUDITVNPATH1, 
		UIO_USERSPACE, uap-&gt;path, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	vp = nd.ni_vp;
	nameidone(&amp;nd);

	error = chflags1(vp, uap-&gt;flags, ctx);

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Change flags of a file given a file descriptor.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fchflags</span>(__unused proc_t p, <span class="enscript-type">struct</span> fchflags_args *uap, __unused int32_t *retval)
{
	vnode_t vp;
	<span class="enscript-type">int</span> error;

	AUDIT_ARG(fd, uap-&gt;fd);
	AUDIT_ARG(fflags, uap-&gt;flags);
	<span class="enscript-keyword">if</span> ( (error = file_vnode(uap-&gt;fd, &amp;vp)) )
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = vnode_getwithref(vp))) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(error);
	}

	AUDIT_ARG(vnpath, vp, ARG_VNODE1);

	error = chflags1(vp, uap-&gt;flags, vfs_context_current());

	file_drop(uap-&gt;fd);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Change security information on a filesystem object.
 *
 * Returns:	0			Success
 *		EPERM			Operation not permitted
 *		vnode_authattr:???	[anything vnode_authattr can return]
 *		vnode_authorize:???	[anything vnode_authorize can return]
 *		vnode_setattr:???	[anything vnode_setattr can return]
 *
 * Notes:	If vnode_authattr or vnode_authorize return EACCES, it will be
 *		translated to EPERM before being returned.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">chmod_vnode</span>(vfs_context_t ctx, vnode_t vp, <span class="enscript-type">struct</span> vnode_attr *vap)
{
	kauth_action_t action;
	<span class="enscript-type">int</span> error;
	
	AUDIT_ARG(mode, vap-&gt;va_mode);
	<span class="enscript-comment">/* XXX audit new args */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-comment">/* chmod calls are not allowed for resource forks. */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISNAMEDSTREAM) {
		<span class="enscript-keyword">return</span> (EPERM);
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_mode) &amp;&amp;
	    (error = mac_vnode_check_setmode(ctx, vp, (mode_t)vap-&gt;va_mode)) != 0)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span>

 	<span class="enscript-comment">/* make sure that the caller is allowed to set this security information */</span>
	<span class="enscript-keyword">if</span> (((error = vnode_authattr(vp, vap, &amp;action, ctx)) != 0) ||
	    ((error = vnode_authorize(vp, NULL, action, ctx)) != 0)) {
		<span class="enscript-keyword">if</span> (error == EACCES)
			error = EPERM;
		<span class="enscript-keyword">return</span>(error);
	}
	
	error = vnode_setattr(vp, vap, ctx);

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Change mode of a file given a path name.
 *
 * Returns:	0			Success
 *		namei:???		[anything namei can return]
 *		chmod_vnode:???		[anything chmod_vnode can return]
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">chmodat</span>(vfs_context_t ctx, user_addr_t path, <span class="enscript-type">struct</span> vnode_attr *vap,
    <span class="enscript-type">int</span> fd, <span class="enscript-type">int</span> flag, <span class="enscript-type">enum</span> uio_seg segflg)
{
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">int</span> follow, error;

	follow = (flag &amp; AT_SYMLINK_NOFOLLOW) ? NOFOLLOW : FOLLOW;
	NDINIT(&amp;nd, LOOKUP, OP_SETATTR, follow | AUDITVNPATH1,
	    segflg, path, ctx);
	<span class="enscript-keyword">if</span> ((error = nameiat(&amp;nd, fd)))
		<span class="enscript-keyword">return</span> (error);
	error = chmod_vnode(ctx, nd.ni_vp, vap);
	vnode_put(nd.ni_vp);
	nameidone(&amp;nd);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * chmod_extended: Change the mode of a file given a path name; with extended 
 * argument list (including extended security (ACL)).
 *
 * Parameters:	p			Process requesting the open
 *		uap			User argument descriptor (see below)
 *		retval			(ignored)
 *
 * Indirect:	uap-&gt;path		Path to object (same as 'chmod')
 *		uap-&gt;uid		UID to set
 *		uap-&gt;gid		GID to set
 *		uap-&gt;mode		File mode to set (same as 'chmod')
 *		uap-&gt;xsecurity		ACL to set (or delete)
 *
 * Returns:	0			Success
 *		!0			errno value
 *
 * Notes:	The kauth_filesec_t in 'va', if any, is in host byte order.
 *
 * XXX:		We should enummerate the possible errno values here, and where
 *		in the code they originated.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">chmod_extended</span>(__unused proc_t p, <span class="enscript-type">struct</span> chmod_extended_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> vnode_attr va;
	kauth_filesec_t xsecdst;

	AUDIT_ARG(owner, uap-&gt;uid, uap-&gt;gid);

	VATTR_INIT(&amp;va);
	<span class="enscript-keyword">if</span> (uap-&gt;mode != -1)
		VATTR_SET(&amp;va, va_mode, uap-&gt;mode &amp; ALLPERMS);
	<span class="enscript-keyword">if</span> (uap-&gt;uid != KAUTH_UID_NONE)
		VATTR_SET(&amp;va, va_uid, uap-&gt;uid);
	<span class="enscript-keyword">if</span> (uap-&gt;gid != KAUTH_GID_NONE)
		VATTR_SET(&amp;va, va_gid, uap-&gt;gid);

	xsecdst = NULL;
	<span class="enscript-keyword">switch</span>(uap-&gt;xsecurity) {
		<span class="enscript-comment">/* explicit remove request */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">CAST_USER_ADDR_T</span>((<span class="enscript-type">void</span> *)1):	<span class="enscript-comment">/* _FILESEC_REMOVE_ACL */</span>
		VATTR_SET(&amp;va, va_acl, NULL);
		<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* not being set */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">USER_ADDR_NULL</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">if</span> ((error = kauth_copyinfilesec(uap-&gt;xsecurity, &amp;xsecdst)) != 0)
			<span class="enscript-keyword">return</span>(error);
		VATTR_SET(&amp;va, va_acl, &amp;xsecdst-&gt;fsec_acl);
		KAUTH_DEBUG(<span class="enscript-string">&quot;CHMOD - setting ACL with %d entries&quot;</span>, va.va_acl-&gt;acl_entrycount);
	}

	error = chmodat(vfs_context_current(), uap-&gt;path, &amp;va, AT_FDCWD, 0,
	    UIO_USERSPACE);

	<span class="enscript-keyword">if</span> (xsecdst != NULL)
		kauth_filesec_free(xsecdst);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		chmodat:???		[anything chmodat can return]
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fchmodat_internal</span>(vfs_context_t ctx, user_addr_t path, <span class="enscript-type">int</span> mode, <span class="enscript-type">int</span> fd,
    <span class="enscript-type">int</span> flag, <span class="enscript-type">enum</span> uio_seg segflg)
{
	<span class="enscript-type">struct</span> vnode_attr va;

	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_mode, mode &amp; ALLPERMS);

	<span class="enscript-keyword">return</span> (chmodat(ctx, path, &amp;va, fd, flag, segflg));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">chmod</span>(__unused proc_t p, <span class="enscript-type">struct</span> chmod_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (fchmodat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;mode,
	    AT_FDCWD, 0, UIO_USERSPACE));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fchmodat</span>(__unused proc_t p, <span class="enscript-type">struct</span> fchmodat_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">if</span> (uap-&gt;flag &amp; ~AT_SYMLINK_NOFOLLOW)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (fchmodat_internal(vfs_context_current(), uap-&gt;path, uap-&gt;mode,
	    uap-&gt;fd, uap-&gt;flag, UIO_USERSPACE));
}

<span class="enscript-comment">/*
 * Change mode of a file given a file descriptor.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fchmod1</span>(__unused proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> vnode_attr *vap)
{
	vnode_t vp;
	<span class="enscript-type">int</span> error;

	AUDIT_ARG(fd, fd);

	<span class="enscript-keyword">if</span> ((error = file_vnode(fd, &amp;vp)) != 0)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> ((error = vnode_getwithref(vp)) != 0) {
		file_drop(fd);
		<span class="enscript-keyword">return</span>(error);
	}
	AUDIT_ARG(vnpath, vp, ARG_VNODE1);

	error = chmod_vnode(vfs_context_current(), vp, vap);
	(<span class="enscript-type">void</span>)vnode_put(vp);
	file_drop(fd);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * fchmod_extended: Change mode of a file given a file descriptor; with
 * extended argument list (including extended security (ACL)).
 *
 * Parameters:    p                       Process requesting to change file mode
 *                uap                     User argument descriptor (see below)
 *                retval                  (ignored) 
 *
 * Indirect:      uap-&gt;mode               File mode to set (same as 'chmod')
 *                uap-&gt;uid                UID to set
 *                uap-&gt;gid                GID to set
 *                uap-&gt;xsecurity          ACL to set (or delete)
 *                uap-&gt;fd                 File descriptor of file to change mode
 *            
 * Returns:        0                      Success
 *                !0                      errno value
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fchmod_extended</span>(proc_t p, <span class="enscript-type">struct</span> fchmod_extended_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> vnode_attr va;
	kauth_filesec_t xsecdst;

	AUDIT_ARG(owner, uap-&gt;uid, uap-&gt;gid);

	VATTR_INIT(&amp;va);
	<span class="enscript-keyword">if</span> (uap-&gt;mode != -1)
		VATTR_SET(&amp;va, va_mode, uap-&gt;mode &amp; ALLPERMS);
	<span class="enscript-keyword">if</span> (uap-&gt;uid != KAUTH_UID_NONE)
		VATTR_SET(&amp;va, va_uid, uap-&gt;uid);
	<span class="enscript-keyword">if</span> (uap-&gt;gid != KAUTH_GID_NONE)
		VATTR_SET(&amp;va, va_gid, uap-&gt;gid);

	xsecdst = NULL;
	<span class="enscript-keyword">switch</span>(uap-&gt;xsecurity) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">USER_ADDR_NULL</span>:
		VATTR_SET(&amp;va, va_acl, NULL);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">CAST_USER_ADDR_T</span>((<span class="enscript-type">void</span> *)1):	<span class="enscript-comment">/* _FILESEC_REMOVE_ACL */</span>
		VATTR_SET(&amp;va, va_acl, NULL);
		<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* not being set */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">CAST_USER_ADDR_T</span>(-1):
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">if</span> ((error = kauth_copyinfilesec(uap-&gt;xsecurity, &amp;xsecdst)) != 0)
			<span class="enscript-keyword">return</span>(error);
		VATTR_SET(&amp;va, va_acl, &amp;xsecdst-&gt;fsec_acl);
	}

	error = fchmod1(p, uap-&gt;fd, &amp;va);

	
	<span class="enscript-keyword">switch</span>(uap-&gt;xsecurity) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">USER_ADDR_NULL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">CAST_USER_ADDR_T</span>(-1):
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">if</span> (xsecdst != NULL)
			kauth_filesec_free(xsecdst);
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fchmod</span>(proc_t p, <span class="enscript-type">struct</span> fchmod_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> vnode_attr va;

	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_mode, uap-&gt;mode &amp; ALLPERMS);

	<span class="enscript-keyword">return</span>(fchmod1(p, uap-&gt;fd, &amp;va));
}


<span class="enscript-comment">/*
 * Set ownership given a path name.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fchownat_internal</span>(vfs_context_t ctx, <span class="enscript-type">int</span> fd, user_addr_t path, uid_t uid,
   gid_t gid, <span class="enscript-type">int</span> flag, <span class="enscript-type">enum</span> uio_seg segflg)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">int</span> follow;
	kauth_action_t action;

	AUDIT_ARG(owner, uid, gid);

	follow = (flag &amp; AT_SYMLINK_NOFOLLOW) ? NOFOLLOW : FOLLOW;
	NDINIT(&amp;nd, LOOKUP, OP_SETATTR, follow | AUDITVNPATH1, segflg,
	    path, ctx);
	error = nameiat(&amp;nd, fd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	vp = nd.ni_vp;

	nameidone(&amp;nd);

	VATTR_INIT(&amp;va);
	<span class="enscript-keyword">if</span> (uid != (uid_t)VNOVAL)
		VATTR_SET(&amp;va, va_uid, uid);
	<span class="enscript-keyword">if</span> (gid != (gid_t)VNOVAL)
		VATTR_SET(&amp;va, va_gid, gid);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_setowner(ctx, vp, uid, gid);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* preflight and authorize attribute changes */</span>
	<span class="enscript-keyword">if</span> ((error = vnode_authattr(vp, &amp;va, &amp;action, ctx)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> (action &amp;&amp; ((error = vnode_authorize(vp, NULL, action, ctx)) != 0))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	error = vnode_setattr(vp, &amp;va, ctx);
 
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/*
	 * EACCES is only allowed from namei(); permissions failure should
	 * return EPERM, so we need to translate the error code.
	 */</span>
	<span class="enscript-keyword">if</span> (error == EACCES)
		error = EPERM;

	vnode_put(vp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">chown</span>(__unused proc_t p, <span class="enscript-type">struct</span> chown_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (fchownat_internal(vfs_context_current(), AT_FDCWD, uap-&gt;path,
	    uap-&gt;uid, uap-&gt;gid, 0, UIO_USERSPACE));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">lchown</span>(__unused proc_t p, <span class="enscript-type">struct</span> lchown_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (fchownat_internal(vfs_context_current(), AT_FDCWD, uap-&gt;path,
	    uap-&gt;owner, uap-&gt;group, AT_SYMLINK_NOFOLLOW, UIO_USERSPACE));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fchownat</span>(__unused proc_t p, <span class="enscript-type">struct</span> fchownat_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">if</span> (uap-&gt;flag &amp; ~AT_SYMLINK_NOFOLLOW)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (fchownat_internal(vfs_context_current(), uap-&gt;fd, uap-&gt;path,
	    uap-&gt;uid, uap-&gt;gid, uap-&gt;flag, UIO_USERSPACE));
}

<span class="enscript-comment">/*
 * Set ownership given a file descriptor.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fchown</span>(__unused proc_t p, <span class="enscript-type">struct</span> fchown_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> vnode_attr va;
	vfs_context_t ctx = vfs_context_current();
	vnode_t vp;
	<span class="enscript-type">int</span> error;
	kauth_action_t action;

	AUDIT_ARG(owner, uap-&gt;uid, uap-&gt;gid);
	AUDIT_ARG(fd, uap-&gt;fd);

	<span class="enscript-keyword">if</span> ( (error = file_vnode(uap-&gt;fd, &amp;vp)) )
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(error);
	}
	AUDIT_ARG(vnpath, vp, ARG_VNODE1);

	VATTR_INIT(&amp;va);
	<span class="enscript-keyword">if</span> (uap-&gt;uid != VNOVAL)
		VATTR_SET(&amp;va, va_uid, uap-&gt;uid);
	<span class="enscript-keyword">if</span> (uap-&gt;gid != VNOVAL)
		VATTR_SET(&amp;va, va_gid, uap-&gt;gid);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-comment">/* chown calls are not allowed for resource forks. */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISNAMEDSTREAM) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_setowner(ctx, vp, uap-&gt;uid, uap-&gt;gid);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

 	<span class="enscript-comment">/* preflight and authorize attribute changes */</span>
	<span class="enscript-keyword">if</span> ((error = vnode_authattr(vp, &amp;va, &amp;action, ctx)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> (action &amp;&amp; ((error = vnode_authorize(vp, NULL, action, ctx)) != 0)) {
		<span class="enscript-keyword">if</span> (error == EACCES)
			error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	error = vnode_setattr(vp, &amp;va, ctx);

<span class="enscript-reference">out</span>:
	(<span class="enscript-type">void</span>)vnode_put(vp);
	file_drop(uap-&gt;fd);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getutimes</span>(user_addr_t usrtvp, <span class="enscript-type">struct</span> timespec *tsp)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (usrtvp == USER_ADDR_NULL) {
		<span class="enscript-type">struct</span> timeval old_tv;
		<span class="enscript-comment">/* XXX Y2038 bug because of microtime argument */</span>
		microtime(&amp;old_tv);
		TIMEVAL_TO_TIMESPEC(&amp;old_tv, &amp;tsp[0]);
		tsp[1] = tsp[0];
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(current_proc())) {
			<span class="enscript-type">struct</span> user64_timeval tv[2];
			error = copyin(usrtvp, (<span class="enscript-type">void</span> *)tv, <span class="enscript-keyword">sizeof</span>(tv));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
			TIMEVAL_TO_TIMESPEC(&amp;tv[0], &amp;tsp[0]);
			TIMEVAL_TO_TIMESPEC(&amp;tv[1], &amp;tsp[1]);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_timeval tv[2];
			error = copyin(usrtvp, (<span class="enscript-type">void</span> *)tv, <span class="enscript-keyword">sizeof</span>(tv));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
			TIMEVAL_TO_TIMESPEC(&amp;tv[0], &amp;tsp[0]);
			TIMEVAL_TO_TIMESPEC(&amp;tv[1], &amp;tsp[1]);
		}
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">setutimes</span>(vfs_context_t ctx, vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> timespec *ts,
	<span class="enscript-type">int</span> nullflag)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> vnode_attr va;
	kauth_action_t action;

	AUDIT_ARG(vnpath, vp, ARG_VNODE1);

	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_access_time, ts[0]);
	VATTR_SET(&amp;va, va_modify_time, ts[1]);
	<span class="enscript-keyword">if</span> (nullflag)
		va.va_vaflags |= VA_UTIMES_NULL;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-comment">/* utimes calls are not allowed for resource forks. */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISNAMEDSTREAM) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_setutimes(ctx, vp, ts[0], ts[1]);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((error = vnode_authattr(vp, &amp;va, &amp;action, ctx)) != 0) {
		<span class="enscript-keyword">if</span> (!nullflag &amp;&amp; error == EACCES)
			error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* since we may not need to auth anything, check here */</span>
	<span class="enscript-keyword">if</span> ((action != 0) &amp;&amp; ((error = vnode_authorize(vp, NULL, action, ctx)) != 0)) {
		<span class="enscript-keyword">if</span> (!nullflag &amp;&amp; error == EACCES)
			error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	error = vnode_setattr(vp, &amp;va, ctx);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Set the access and modification times of a file.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">utimes</span>(__unused proc_t p, <span class="enscript-type">struct</span> utimes_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> timespec ts[2];
	user_addr_t usrtvp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	vfs_context_t ctx = vfs_context_current();

	<span class="enscript-comment">/*
	 * AUDIT: Needed to change the order of operations to do the 
	 * name lookup first because auditing wants the path.
	 */</span>
	NDINIT(&amp;nd, LOOKUP, OP_SETATTR, FOLLOW | AUDITVNPATH1, 
		UIO_USERSPACE, uap-&gt;path, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	nameidone(&amp;nd);

	<span class="enscript-comment">/*
	 * Fetch the user-supplied time.  If usrtvp is USER_ADDR_NULL, we fetch
	 * the current time instead.
	 */</span>
	usrtvp = uap-&gt;tptr;
	<span class="enscript-keyword">if</span> ((error = getutimes(usrtvp, ts)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	error = setutimes(ctx, nd.ni_vp, ts, usrtvp == USER_ADDR_NULL);

<span class="enscript-reference">out</span>:
	vnode_put(nd.ni_vp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Set the access and modification times of a file.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">futimes</span>(__unused proc_t p, <span class="enscript-type">struct</span> futimes_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> timespec ts[2];
	vnode_t vp;
	user_addr_t usrtvp;
	<span class="enscript-type">int</span> error;

	AUDIT_ARG(fd, uap-&gt;fd);
	usrtvp = uap-&gt;tptr;
	<span class="enscript-keyword">if</span> ((error = getutimes(usrtvp, ts)) != 0)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> ((error = file_vnode(uap-&gt;fd, &amp;vp)) != 0)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span>((error = vnode_getwithref(vp))) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(error);
	}

	error =  setutimes(vfs_context_current(), vp, ts, usrtvp == 0);
	vnode_put(vp);
	file_drop(uap-&gt;fd);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Truncate a file given its path name.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">truncate</span>(__unused proc_t p, <span class="enscript-type">struct</span> truncate_args *uap, __unused int32_t *retval)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> vnode_attr va;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	kauth_action_t action;

	<span class="enscript-keyword">if</span> (uap-&gt;length &lt; 0)
		<span class="enscript-keyword">return</span>(EINVAL);
	NDINIT(&amp;nd, LOOKUP, OP_TRUNCATE, FOLLOW | AUDITVNPATH1, 
		UIO_USERSPACE, uap-&gt;path, ctx);
	<span class="enscript-keyword">if</span> ((error = namei(&amp;nd)))
		<span class="enscript-keyword">return</span> (error);
	vp = nd.ni_vp;

	nameidone(&amp;nd);

	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_data_size, uap-&gt;length);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_truncate(ctx, NOCRED, vp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> ((error = vnode_authattr(vp, &amp;va, &amp;action, ctx)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> ((action != 0) &amp;&amp; ((error = vnode_authorize(vp, NULL, action, ctx)) != 0))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	error = vnode_setattr(vp, &amp;va, ctx);
<span class="enscript-reference">out</span>:
	vnode_put(vp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Truncate a file given a file descriptor.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ftruncate</span>(proc_t p, <span class="enscript-type">struct</span> ftruncate_args *uap, int32_t *retval)
{
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">struct</span> vnode_attr va;
	vnode_t vp;
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> error ;
	<span class="enscript-type">int</span> fd = uap-&gt;fd;

	AUDIT_ARG(fd, uap-&gt;fd);
	<span class="enscript-keyword">if</span> (uap-&gt;length &lt; 0)
		<span class="enscript-keyword">return</span>(EINVAL);
        
	<span class="enscript-keyword">if</span> ( (error = fp_lookup(p,fd,&amp;fp,0)) ) {
		<span class="enscript-keyword">return</span>(error);
	}

	<span class="enscript-keyword">switch</span> (FILEGLOB_DTYPE(fp-&gt;f_fglob)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PSXSHM</span>:
		error = pshm_truncate(p, fp, uap-&gt;fd, uap-&gt;length, retval);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_VNODE</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	vp = (vnode_t)fp-&gt;f_fglob-&gt;fg_data;

	<span class="enscript-keyword">if</span> ((fp-&gt;f_fglob-&gt;fg_flag &amp; FWRITE) == 0) {
		AUDIT_ARG(vnpath_withref, vp, ARG_VNODE1);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> ((error = vnode_getwithref(vp)) != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	AUDIT_ARG(vnpath, vp, ARG_VNODE1);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_truncate(ctx,
	    fp-&gt;f_fglob-&gt;fg_cred, vp);
	<span class="enscript-keyword">if</span> (error) {
		(<span class="enscript-type">void</span>)vnode_put(vp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span>
	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_data_size, uap-&gt;length);
	error = vnode_setattr(vp, &amp;va, ctx);
	(<span class="enscript-type">void</span>)vnode_put(vp);
<span class="enscript-reference">out</span>:
	file_drop(fd);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Sync an open file with synchronized I/O _file_ integrity completion
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fsync</span>(proc_t p, <span class="enscript-type">struct</span> fsync_args *uap, __unused int32_t *retval)
{
	__pthread_testcancel(1);
	<span class="enscript-keyword">return</span>(fsync_common(p, uap, MNT_WAIT));
}


<span class="enscript-comment">/*
 * Sync an open file with synchronized I/O _file_ integrity completion
 *
 * Notes:	This is a legacy support function that does not test for
 *		thread cancellation points.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">fsync_nocancel</span>(proc_t p, <span class="enscript-type">struct</span> fsync_nocancel_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span>(fsync_common(p, (<span class="enscript-type">struct</span> fsync_args *)uap, MNT_WAIT));
}


<span class="enscript-comment">/*
 * Sync an open file with synchronized I/O _data_ integrity completion
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fdatasync</span>(proc_t p, <span class="enscript-type">struct</span> fdatasync_args *uap, __unused int32_t *retval)
{
	__pthread_testcancel(1);
	<span class="enscript-keyword">return</span>(fsync_common(p, (<span class="enscript-type">struct</span> fsync_args *)uap, MNT_DWAIT));
}


<span class="enscript-comment">/*
 * fsync_common
 *
 * Common fsync code to support both synchronized I/O file integrity completion
 * (normal fsync) and synchronized I/O data integrity completion (fdatasync).
 *
 * If 'flags' is MNT_DWAIT, the caller is requesting data integrity, which
 * will only guarantee that the file data contents are retrievable.  If
 * 'flags' is MNT_WAIT, the caller is rewuesting file integrity, which also
 * includes additional metadata unnecessary for retrieving the file data
 * contents, such as atime, mtime, ctime, etc., also be committed to stable
 * storage.
 *
 * Parameters:	p				The process
 *		uap-&gt;fd				The descriptor to synchronize
 *		flags				The data integrity flags
 *
 * Returns:	int				Success
 *	fp_getfvp:EBADF				Bad file descriptor
 *	fp_getfvp:ENOTSUP			fd does not refer to a vnode
 *	VNOP_FSYNC:???				unspecified
 *
 * Notes:	We use struct fsync_args because it is a short name, and all
 *		caller argument structures are otherwise identical.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fsync_common</span>(proc_t p, <span class="enscript-type">struct</span> fsync_args *uap, <span class="enscript-type">int</span> flags)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> fileproc *fp;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">int</span> error;

	AUDIT_ARG(fd, uap-&gt;fd);

	<span class="enscript-keyword">if</span> ( (error = fp_getfvp(p, uap-&gt;fd, &amp;fp, &amp;vp)) )
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(error);
	}

	AUDIT_ARG(vnpath, vp, ARG_VNODE1);

	error = VNOP_FSYNC(vp, flags, ctx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-comment">/* Sync resource fork shadow file if necessary. */</span>
	<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp;
	    (vp-&gt;v_flag &amp; VISNAMEDSTREAM) &amp;&amp; 
	    (vp-&gt;v_parent != NULLVP) &amp;&amp;
	    vnode_isshadow(vp) &amp;&amp;
	    (fp-&gt;f_flags &amp; FP_WRITTEN)) {
		(<span class="enscript-type">void</span>) vnode_flushnamedstream(vp-&gt;v_parent, vp, ctx);
	}
#<span class="enscript-reference">endif</span>

	(<span class="enscript-type">void</span>)vnode_put(vp);
	file_drop(uap-&gt;fd);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Duplicate files.  Source must be a file, target must be a file or 
 * must not exist.
 *
 * XXX Copyfile authorisation checking is woefully inadequate, and will not
 *     perform inheritance correctly.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">copyfile</span>(__unused proc_t p, <span class="enscript-type">struct</span> copyfile_args *uap, __unused int32_t *retval)
{
	vnode_t tvp, fvp, tdvp, sdvp;
	<span class="enscript-type">struct</span> nameidata fromnd, tond;
	<span class="enscript-type">int</span> error;
	vfs_context_t ctx = vfs_context_current();

	<span class="enscript-comment">/* Check that the flags are valid. */</span>

	<span class="enscript-keyword">if</span> (uap-&gt;flags &amp; ~CPF_MASK) {
		<span class="enscript-keyword">return</span>(EINVAL);
	}

	NDINIT(&amp;fromnd, LOOKUP, OP_COPYFILE, SAVESTART | AUDITVNPATH1,
		UIO_USERSPACE, uap-&gt;from, ctx);
	<span class="enscript-keyword">if</span> ((error = namei(&amp;fromnd)))
		<span class="enscript-keyword">return</span> (error);
	fvp = fromnd.ni_vp;

	NDINIT(&amp;tond, CREATE, OP_LINK,
	       LOCKPARENT | LOCKLEAF | NOCACHE | SAVESTART | AUDITVNPATH2 | CN_NBMOUNTLOOK,
	       UIO_USERSPACE, uap-&gt;to, ctx);
	<span class="enscript-keyword">if</span> ((error = namei(&amp;tond))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}
	tdvp = tond.ni_dvp;
	tvp = tond.ni_vp;

	<span class="enscript-keyword">if</span> (tvp != NULL) {
		<span class="enscript-keyword">if</span> (!(uap-&gt;flags &amp; CPF_OVERWRITE)) {
			error = EEXIST;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	<span class="enscript-keyword">if</span> (fvp-&gt;v_type == VDIR || (tvp &amp;&amp; tvp-&gt;v_type == VDIR)) {
		error = EISDIR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> ((error = vnode_authorize(tdvp, NULL, KAUTH_VNODE_ADD_FILE, ctx)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (fvp == tdvp)
		error = EINVAL;
	<span class="enscript-comment">/*
	 * If source is the same as the destination (that is the
	 * same inode number) then there is nothing to do.
	 * (fixed to have POSIX semantics - CSM 3/2/98)
	 */</span>
	<span class="enscript-keyword">if</span> (fvp == tvp)
		error = -1;
	<span class="enscript-keyword">if</span> (!error)
	        error = VNOP_COPYFILE(fvp, tdvp, tvp, &amp;tond.ni_cnd, uap-&gt;mode, uap-&gt;flags, ctx);
<span class="enscript-reference">out</span>:
	sdvp = tond.ni_startdir;
	<span class="enscript-comment">/*
	 * nameidone has to happen before we vnode_put(tdvp)
	 * since it may need to release the fs_nodelock on the tdvp
	 */</span>
	nameidone(&amp;tond);

	<span class="enscript-keyword">if</span> (tvp)
		vnode_put(tvp);
	vnode_put(tdvp);
	vnode_put(sdvp);
<span class="enscript-reference">out1</span>:
	vnode_put(fvp);

	<span class="enscript-keyword">if</span> (fromnd.ni_startdir)
	        vnode_put(fromnd.ni_startdir);
	nameidone(&amp;fromnd);

	<span class="enscript-keyword">if</span> (error == -1)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Rename files.  Source and destination must either both be directories,
 * or both not be directories.  If target is a directory, it must be empty.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">renameat_internal</span>(vfs_context_t ctx, <span class="enscript-type">int</span> fromfd, user_addr_t from,
    <span class="enscript-type">int</span> tofd, user_addr_t to, <span class="enscript-type">int</span> segflg, vfs_rename_flags_t flags)
{
	vnode_t tvp, tdvp;
	vnode_t fvp, fdvp;
	<span class="enscript-type">struct</span> nameidata *fromnd, *tond;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> do_retry;
	<span class="enscript-type">int</span> retry_count;
	<span class="enscript-type">int</span> mntrename;
	<span class="enscript-type">int</span> need_event;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *oname = NULL;
	<span class="enscript-type">char</span> *from_name = NULL, *to_name = NULL;
	<span class="enscript-type">int</span> from_len=0, to_len=0;
	<span class="enscript-type">int</span> holding_mntlock;
	mount_t locked_mp = NULL;
	vnode_t oparent = NULLVP;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	fse_info from_finfo, to_finfo;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> from_truncated=0, to_truncated;
	<span class="enscript-type">int</span> batched = 0;
	<span class="enscript-type">struct</span> vnode_attr *fvap, *tvap;
	<span class="enscript-type">int</span> continuing = 0;
	<span class="enscript-comment">/* carving out a chunk for structs that are too big to be on stack. */</span>
	<span class="enscript-type">struct</span> {
		<span class="enscript-type">struct</span> nameidata from_node, to_node;
		<span class="enscript-type">struct</span> vnode_attr fv_attr, tv_attr;
	} * __rename_data;
	MALLOC(__rename_data, <span class="enscript-type">void</span> *, <span class="enscript-keyword">sizeof</span>(*__rename_data), M_TEMP, M_WAITOK);
	fromnd = &amp;__rename_data-&gt;from_node;
	tond = &amp;__rename_data-&gt;to_node;

	holding_mntlock = 0;
	do_retry = 0;
	retry_count = 0;
<span class="enscript-reference">retry</span>:
	fvp = tvp = NULL;
	fdvp = tdvp = NULL;
	fvap = tvap = NULL;
	mntrename = FALSE;

	NDINIT(fromnd, DELETE, OP_UNLINK, WANTPARENT | AUDITVNPATH1,
	    segflg, from, ctx);
	fromnd-&gt;ni_flag = NAMEI_COMPOUNDRENAME;

	NDINIT(tond, RENAME, OP_RENAME, WANTPARENT | AUDITVNPATH2 | CN_NBMOUNTLOOK,
	    segflg, to, ctx);
	tond-&gt;ni_flag = NAMEI_COMPOUNDRENAME;

<span class="enscript-reference">continue_lookup</span>:
	<span class="enscript-keyword">if</span> ((fromnd-&gt;ni_flag &amp; NAMEI_CONTLOOKUP) != 0 || !continuing) {
		<span class="enscript-keyword">if</span> ( (error = nameiat(fromnd, fromfd)) )
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		fdvp = fromnd-&gt;ni_dvp;
		fvp  = fromnd-&gt;ni_vp;

		<span class="enscript-keyword">if</span> (fvp &amp;&amp; fvp-&gt;v_type == VDIR)
			tond-&gt;ni_cnd.cn_flags |= WILLBEDIR;
	}

	<span class="enscript-keyword">if</span> ((tond-&gt;ni_flag &amp; NAMEI_CONTLOOKUP) != 0 || !continuing) {
		<span class="enscript-keyword">if</span> ( (error = nameiat(tond, tofd)) ) {
			<span class="enscript-comment">/*
			 * Translate error code for rename(&quot;dir1&quot;, &quot;dir2/.&quot;).
			 */</span>
			<span class="enscript-keyword">if</span> (error == EISDIR &amp;&amp; fvp-&gt;v_type == VDIR)
				error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
		tdvp = tond-&gt;ni_dvp;
		tvp  = tond-&gt;ni_vp;
	}

	batched = vnode_compound_rename_available(fdvp);
	<span class="enscript-keyword">if</span> (!fvp) {
		<span class="enscript-comment">/*
		 * Claim: this check will never reject a valid rename.
		 * For success, either fvp must be on the same mount as tdvp, or fvp must sit atop a vnode on the same mount as tdvp.
		 * Suppose fdvp and tdvp are not on the same mount.
		 * If fvp is on the same mount as tdvp, then fvp is not on the same mount as fdvp, so fvp is the root of its filesystem.  If fvp is the root,
		 * 	then you can't move it to within another dir on the same mountpoint.
		 * If fvp sits atop a vnode on the same mount as fdvp, then that vnode must be part of the same mount as fdvp, which is a contradiction.
		 *
		 * If this check passes, then we are safe to pass these vnodes to the same FS.
		 */</span>
		<span class="enscript-keyword">if</span> (fdvp-&gt;v_mount != tdvp-&gt;v_mount) {
			error = EXDEV;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">skipped_lookup</span>;
	}

	<span class="enscript-keyword">if</span> (!batched) {
		error = vn_authorize_rename(fdvp, fvp, &amp;fromnd-&gt;ni_cnd, tdvp, tvp, &amp;tond-&gt;ni_cnd, ctx, NULL);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == ENOENT) {
				assert(retry_count &lt; MAX_AUTHORIZE_ENOENT_RETRIES);
				<span class="enscript-keyword">if</span> (retry_count &lt; MAX_AUTHORIZE_ENOENT_RETRIES) {
					<span class="enscript-comment">/*
					 * We encountered a race where after doing the namei, tvp stops
					 * being valid. If so, simply re-drive the rename call from the
					 * top.
					 */</span>
					do_retry = 1;
					retry_count += 1;
				}
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
	}

        <span class="enscript-comment">/*
         * If the source and destination are the same (i.e. they're
         * links to the same vnode) and the target file system is
         * case sensitive, then there is nothing to do.
	 *
	 * XXX Come back to this.
         */</span>
	<span class="enscript-keyword">if</span> (fvp == tvp) {
		<span class="enscript-type">int</span> pathconf_val;

		<span class="enscript-comment">/*
		 * Note: if _PC_CASE_SENSITIVE selector isn't supported,
		 * then assume that this file system is case sensitive.
		 */</span>
		<span class="enscript-keyword">if</span> (VNOP_PATHCONF(fvp, _PC_CASE_SENSITIVE, &amp;pathconf_val, ctx) != 0 ||
		    pathconf_val != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Allow the renaming of mount points.
	 * - target must not exist
	 * - target must reside in the same directory as source
	 * - union mounts cannot be renamed
	 * - &quot;/&quot; cannot be renamed
	 *
	 * XXX Handle this in VFS after a continued lookup (if we missed
	 * in the cache to start off)
	 */</span>
	<span class="enscript-keyword">if</span> ((fvp-&gt;v_flag &amp; VROOT) &amp;&amp;
	    (fvp-&gt;v_type == VDIR) &amp;&amp;
	    (tvp == NULL)  &amp;&amp;
	    (fvp-&gt;v_mountedhere == NULL)  &amp;&amp;
	    (fdvp == tdvp)  &amp;&amp;
	    ((fvp-&gt;v_mount-&gt;mnt_flag &amp; (MNT_UNION | MNT_ROOTFS)) == 0)  &amp;&amp;
	    (fvp-&gt;v_mount-&gt;mnt_vnodecovered != NULLVP)) {
		vnode_t coveredvp;

		<span class="enscript-comment">/* switch fvp to the covered vnode */</span>
		coveredvp = fvp-&gt;v_mount-&gt;mnt_vnodecovered;
		<span class="enscript-keyword">if</span> ( (vnode_getwithref(coveredvp)) ) {
		        error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
		vnode_put(fvp);

		fvp = coveredvp;
		mntrename = TRUE;
	}
	<span class="enscript-comment">/*
	 * Check for cross-device rename.
	 */</span>
	<span class="enscript-keyword">if</span> ((fvp-&gt;v_mount != tdvp-&gt;v_mount) ||
	    (tvp &amp;&amp; (fvp-&gt;v_mount != tvp-&gt;v_mount))) {
		error = EXDEV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}

	<span class="enscript-comment">/*
	 * If source is the same as the destination (that is the
	 * same inode number) then there is nothing to do...
	 * EXCEPT if the underlying file system supports case
	 * insensitivity and is case preserving.  In this case
	 * the file system needs to handle the special case of
	 * getting the same vnode as target (fvp) and source (tvp).
	 *
	 * Only file systems that support pathconf selectors _PC_CASE_SENSITIVE
	 * and _PC_CASE_PRESERVING can have this exception, and they need to
	 * handle the special case of getting the same vnode as target and
	 * source.  NOTE: Then the target is unlocked going into vnop_rename,
	 * so not to cause locking problems. There is a single reference on tvp.
	 *
	 * NOTE - that fvp == tvp also occurs if they are hard linked and
	 * that correct behaviour then is just to return success without doing
	 * anything.
	 *
	 * XXX filesystem should take care of this itself, perhaps...
	 */</span>
	<span class="enscript-keyword">if</span> (fvp == tvp &amp;&amp; fdvp == tdvp) {
		<span class="enscript-keyword">if</span> (fromnd-&gt;ni_cnd.cn_namelen == tond-&gt;ni_cnd.cn_namelen &amp;&amp;
	       	    !bcmp(fromnd-&gt;ni_cnd.cn_nameptr, tond-&gt;ni_cnd.cn_nameptr,
			  fromnd-&gt;ni_cnd.cn_namelen)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
	}

	<span class="enscript-keyword">if</span> (holding_mntlock &amp;&amp; fvp-&gt;v_mount != locked_mp) {
	        <span class="enscript-comment">/*
		 * we're holding a reference and lock
		 * on locked_mp, but it no longer matches
		 * what we want to do... so drop our hold
		 */</span>
		mount_unlock_renames(locked_mp);
		mount_drop(locked_mp, 0);
	        holding_mntlock = 0;
	}
	<span class="enscript-keyword">if</span> (tdvp != fdvp &amp;&amp; fvp-&gt;v_type == VDIR) {
	        <span class="enscript-comment">/*
		 * serialize renames that re-shape
		 * the tree... if holding_mntlock is
		 * set, then we're ready to go...
		 * otherwise we
		 * first need to drop the iocounts
		 * we picked up, second take the
		 * lock to serialize the access,
		 * then finally start the lookup
		 * process over with the lock held
		 */</span>
	        <span class="enscript-keyword">if</span> (!holding_mntlock) {
		        <span class="enscript-comment">/*
			 * need to grab a reference on
			 * the mount point before we
			 * drop all the iocounts... once
			 * the iocounts are gone, the mount
			 * could follow
			 */</span>
			locked_mp = fvp-&gt;v_mount;
			mount_ref(locked_mp, 0);

			<span class="enscript-comment">/*
			 * nameidone has to happen before we vnode_put(tvp)
			 * since it may need to release the fs_nodelock on the tvp
			 */</span>
			nameidone(tond);

			<span class="enscript-keyword">if</span> (tvp)
			        vnode_put(tvp);
			vnode_put(tdvp);

			<span class="enscript-comment">/*
			 * nameidone has to happen before we vnode_put(fdvp)
			 * since it may need to release the fs_nodelock on the fvp
			 */</span>
			nameidone(fromnd);

			vnode_put(fvp);
			vnode_put(fdvp);

			mount_lock_renames(locked_mp);
			holding_mntlock = 1;

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-comment">/*
		 * when we dropped the iocounts to take
		 * the lock, we allowed the identity of
		 * the various vnodes to change... if they did,
		 * we may no longer be dealing with a rename
		 * that reshapes the tree... once we're holding
		 * the iocounts, the vnodes can't change type
		 * so we're free to drop the lock at this point
		 * and continue on
		 */</span>
	        <span class="enscript-keyword">if</span> (holding_mntlock) {
			mount_unlock_renames(locked_mp);
			mount_drop(locked_mp, 0);
		        holding_mntlock = 0;
		}
	}

	<span class="enscript-comment">// save these off so we can later verify that fvp is the same
</span>	oname   = fvp-&gt;v_name;
	oparent = fvp-&gt;v_parent;

<span class="enscript-reference">skipped_lookup</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	need_event = need_fsevent(FSE_RENAME, fdvp);
	<span class="enscript-keyword">if</span> (need_event) {
		<span class="enscript-keyword">if</span> (fvp) {
			get_fse_info(fvp, &amp;from_finfo, ctx);
		} <span class="enscript-keyword">else</span> {
			error = vfs_get_notify_attributes(&amp;__rename_data-&gt;fv_attr);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}

			fvap = &amp;__rename_data-&gt;fv_attr;
		}

		<span class="enscript-keyword">if</span> (tvp) {
		        get_fse_info(tvp, &amp;to_finfo, ctx);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (batched) {
			error = vfs_get_notify_attributes(&amp;__rename_data-&gt;tv_attr);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}

			tvap = &amp;__rename_data-&gt;tv_attr;
		}
	}
#<span class="enscript-reference">else</span>
	need_event = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FSE */</span>

	<span class="enscript-keyword">if</span> (need_event || kauth_authorize_fileop_has_listeners()) {
		<span class="enscript-keyword">if</span> (from_name == NULL) {
			GET_PATH(from_name);
			<span class="enscript-keyword">if</span> (from_name == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}
		}

		from_len = safe_getpath(fdvp, fromnd-&gt;ni_cnd.cn_nameptr, from_name, MAXPATHLEN, &amp;from_truncated);

		<span class="enscript-keyword">if</span> (to_name == NULL) {
			GET_PATH(to_name);
			<span class="enscript-keyword">if</span> (to_name == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}
		}

		to_len = safe_getpath(tdvp, tond-&gt;ni_cnd.cn_nameptr, to_name, MAXPATHLEN, &amp;to_truncated);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SECLUDED_RENAME</span>
	<span class="enscript-keyword">if</span> (flags &amp; VFS_SECLUDE_RENAME) {
		fromnd-&gt;ni_cnd.cn_flags |=  CN_SECLUDE_RENAME;
	}
#<span class="enscript-reference">else</span>
	#pragma unused(flags)
#<span class="enscript-reference">endif</span>
	error = vn_rename(fdvp, &amp;fvp, &amp;fromnd-&gt;ni_cnd, fvap,
			    tdvp, &amp;tvp, &amp;tond-&gt;ni_cnd, tvap,
			    0, ctx);

	<span class="enscript-keyword">if</span> (holding_mntlock) {
		<span class="enscript-comment">/*
		 * we can drop our serialization
		 * lock now
		 */</span>
		mount_unlock_renames(locked_mp);
		mount_drop(locked_mp, 0);
		holding_mntlock = 0;
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (error == EKEEPLOOKING) {
			<span class="enscript-keyword">if</span> ((fromnd-&gt;ni_flag &amp; NAMEI_CONTLOOKUP) == 0) {
				<span class="enscript-keyword">if</span> ((tond-&gt;ni_flag &amp; NAMEI_CONTLOOKUP) == 0) {
					panic(<span class="enscript-string">&quot;EKEEPLOOKING without NAMEI_CONTLOOKUP on either ndp?&quot;</span>);
				}
			}

			fromnd-&gt;ni_vp = fvp;
			tond-&gt;ni_vp = tvp;

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">continue_lookup</span>;
		}

		<span class="enscript-comment">/*
		 * We may encounter a race in the VNOP where the destination didn't
		 * exist when we did the namei, but it does by the time we go and
		 * try to create the entry. In this case, we should re-drive this rename
		 * call from the top again.  Currently, only HFS bubbles out ERECYCLE,
		 * but other filesystems susceptible to this race could return it, too.
		 */</span>
		<span class="enscript-keyword">if</span> (error == ERECYCLE) {
			do_retry = 1;
		}

		<span class="enscript-comment">/*
		 * For compound VNOPs, the authorization callback may return
		 * ENOENT in case of racing hardlink lookups hitting the name
		 * cache, redrive the lookup.
		 */</span>
		<span class="enscript-keyword">if</span> (batched &amp;&amp; error == ENOENT) {
			assert(retry_count &lt; MAX_AUTHORIZE_ENOENT_RETRIES);
			<span class="enscript-keyword">if</span> (retry_count &lt; MAX_AUTHORIZE_ENOENT_RETRIES) {
				do_retry = 1;
				retry_count += 1;
			}
		}

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}

	<span class="enscript-comment">/* call out to allow 3rd party notification of rename.
	 * Ignore result of kauth_authorize_fileop call.
	 */</span>
	kauth_authorize_fileop(vfs_context_ucred(ctx),
			KAUTH_FILEOP_RENAME,
			(uintptr_t)from_name, (uintptr_t)to_name);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (from_name != NULL &amp;&amp; to_name != NULL) {
		<span class="enscript-keyword">if</span> (from_truncated || to_truncated) {
			<span class="enscript-comment">// set it here since only the from_finfo gets reported up to user space
</span>			from_finfo.mode |= FSE_TRUNCATED_PATH;
		}

		<span class="enscript-keyword">if</span> (tvap &amp;&amp; tvp) {
			vnode_get_fse_info_from_vap(tvp, &amp;to_finfo, tvap);
		}
		<span class="enscript-keyword">if</span> (fvap) {
			vnode_get_fse_info_from_vap(fvp, &amp;from_finfo, fvap);
		}

	        <span class="enscript-keyword">if</span> (tvp) {
		        add_fsevent(FSE_RENAME, ctx,
				    FSE_ARG_STRING, from_len, from_name,
				    FSE_ARG_FINFO, &amp;from_finfo,
				    FSE_ARG_STRING, to_len, to_name,
				    FSE_ARG_FINFO, &amp;to_finfo,
				    FSE_ARG_DONE);
		} <span class="enscript-keyword">else</span> {
		        add_fsevent(FSE_RENAME, ctx,
				    FSE_ARG_STRING, from_len, from_name,
				    FSE_ARG_FINFO, &amp;from_finfo,
				    FSE_ARG_STRING, to_len, to_name,
				    FSE_ARG_DONE);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FSE */</span>

	<span class="enscript-comment">/*
	 * update filesystem's mount point data
	 */</span>
	<span class="enscript-keyword">if</span> (mntrename) {
	        <span class="enscript-type">char</span> *cp, *pathend, *mpname;
		<span class="enscript-type">char</span> * tobuf;
		<span class="enscript-type">struct</span> mount *mp;
		<span class="enscript-type">int</span> maxlen;
		size_t len = 0;

		mp = fvp-&gt;v_mountedhere;

		<span class="enscript-keyword">if</span> (vfs_busy(mp, LK_NOWAIT)) {
		        error = EBUSY;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
		MALLOC_ZONE(tobuf, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK);

		<span class="enscript-keyword">if</span> (UIO_SEG_IS_USER_SPACE(segflg))
			error = copyinstr(to, tobuf, MAXPATHLEN, &amp;len);
		<span class="enscript-keyword">else</span>
			error = copystr((<span class="enscript-type">void</span> *)to, tobuf, MAXPATHLEN, &amp;len);
		<span class="enscript-keyword">if</span> (!error) {
		        <span class="enscript-comment">/* find current mount point prefix */</span>
		        pathend = &amp;mp-&gt;mnt_vfsstat.f_mntonname[0];
			<span class="enscript-keyword">for</span> (cp = pathend; *cp != <span class="enscript-string">'\0'</span>; ++cp) {
			        <span class="enscript-keyword">if</span> (*cp == <span class="enscript-string">'/'</span>)
				        pathend = cp + 1;
			}
			<span class="enscript-comment">/* find last component of target name */</span>
			<span class="enscript-keyword">for</span> (mpname = cp = tobuf; *cp != <span class="enscript-string">'\0'</span>; ++cp) {
			        <span class="enscript-keyword">if</span> (*cp == <span class="enscript-string">'/'</span>)
				        mpname = cp + 1;
			}
			<span class="enscript-comment">/* append name to prefix */</span>
			maxlen = MAXPATHLEN - (pathend - mp-&gt;mnt_vfsstat.f_mntonname);
			bzero(pathend, maxlen);
			strlcpy(pathend, mpname, maxlen);
		}
		FREE_ZONE(tobuf, MAXPATHLEN, M_NAMEI);

		vfs_unbusy(mp);
	}
	<span class="enscript-comment">/*
	 * fix up name &amp; parent pointers.  note that we first
	 * check that fvp has the same name/parent pointers it
	 * had before the rename call... this is a 'weak' check
	 * at best...
	 *
	 * XXX oparent and oname may not be set in the compound vnop case
	 */</span>
	<span class="enscript-keyword">if</span> (batched || (oname == fvp-&gt;v_name &amp;&amp; oparent == fvp-&gt;v_parent)) {
	        <span class="enscript-type">int</span> update_flags;

	        update_flags = VNODE_UPDATE_NAME;

		<span class="enscript-keyword">if</span> (fdvp != tdvp)
		        update_flags |= VNODE_UPDATE_PARENT;

	        vnode_update_identity(fvp, tdvp, tond-&gt;ni_cnd.cn_nameptr, tond-&gt;ni_cnd.cn_namelen, tond-&gt;ni_cnd.cn_hash, update_flags);
	}
<span class="enscript-reference">out1</span>:
	<span class="enscript-keyword">if</span> (to_name != NULL) {
		RELEASE_PATH(to_name);
		to_name = NULL;
	}
	<span class="enscript-keyword">if</span> (from_name != NULL) {
		RELEASE_PATH(from_name);
		from_name = NULL;
	}
	<span class="enscript-keyword">if</span> (holding_mntlock) {
	        mount_unlock_renames(locked_mp);
		mount_drop(locked_mp, 0);
		holding_mntlock = 0;
	}
	<span class="enscript-keyword">if</span> (tdvp) {
		<span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(tdvp)
		 * since it may need to release the fs_nodelock on the tdvp
		 */</span>
		nameidone(tond);

		<span class="enscript-keyword">if</span> (tvp)
		        vnode_put(tvp);
	        vnode_put(tdvp);
	}
	<span class="enscript-keyword">if</span> (fdvp) {
		<span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(fdvp)
		 * since it may need to release the fs_nodelock on the fdvp
		 */</span>
		nameidone(fromnd);

		<span class="enscript-keyword">if</span> (fvp)
		        vnode_put(fvp);
	        vnode_put(fdvp);
	}

	<span class="enscript-comment">/*
	 * If things changed after we did the namei, then we will re-drive
	 * this rename call from the top.
	 */</span>
	<span class="enscript-keyword">if</span> (do_retry) {
		do_retry = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
	}

	FREE(__rename_data, M_TEMP);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">rename</span>(__unused proc_t p, <span class="enscript-type">struct</span> rename_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (renameat_internal(vfs_context_current(), AT_FDCWD, uap-&gt;from,
	    AT_FDCWD, uap-&gt;to, UIO_USERSPACE, 0));
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SECLUDED_RENAME</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">rename_ext</span>(__unused proc_t p, <span class="enscript-type">struct</span> rename_ext_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> renameat_internal(
		vfs_context_current(), 
		AT_FDCWD, uap-&gt;from,
		AT_FDCWD, uap-&gt;to, 
		UIO_USERSPACE, uap-&gt;flags);
}
#<span class="enscript-reference">endif</span>
 
<span class="enscript-type">int</span>
<span class="enscript-function-name">renameat</span>(__unused proc_t p, <span class="enscript-type">struct</span> renameat_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (renameat_internal(vfs_context_current(), uap-&gt;fromfd, uap-&gt;from,
	    uap-&gt;tofd, uap-&gt;to, UIO_USERSPACE, 0));
}

<span class="enscript-comment">/*
 * Make a directory file.
 *
 * Returns:	0			Success
 *		EEXIST
 *	namei:???
 *	vnode_authorize:???
 *	vn_create:???
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mkdir1at</span>(vfs_context_t ctx, user_addr_t path, <span class="enscript-type">struct</span> vnode_attr *vap, <span class="enscript-type">int</span> fd,
    <span class="enscript-type">enum</span> uio_seg segflg)
{
	vnode_t	vp, dvp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> update_flags = 0;
	<span class="enscript-type">int</span> batched;
	<span class="enscript-type">struct</span> nameidata nd;

	AUDIT_ARG(mode, vap-&gt;va_mode);
	NDINIT(&amp;nd, CREATE, OP_MKDIR, LOCKPARENT | AUDITVNPATH1, segflg,
	       path, ctx);
	nd.ni_cnd.cn_flags |= WILLBEDIR;
	nd.ni_flag = NAMEI_COMPOUNDMKDIR;

<span class="enscript-reference">continue_lookup</span>:
	error = nameiat(&amp;nd, fd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	dvp = nd.ni_dvp;
	vp = nd.ni_vp;

	<span class="enscript-keyword">if</span> (vp != NULL) {
		error = EEXIST;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	batched = vnode_compound_mkdir_available(dvp);

	VATTR_SET(vap, va_type, VDIR);

	<span class="enscript-comment">/*
	 * XXX
	 * Don't authorize in VFS for compound VNOP.... mkdir -p today assumes that it will
	 * only get EXISTS or EISDIR for existing path components, and not that it could see
	 * EACCESS/EPERM--so if we authorize for mkdir on &quot;/&quot; for &quot;mkdir -p /tmp/foo/bar/baz&quot;
	 * it will fail in a spurious  manner.  Need to figure out if this is valid behavior.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = vn_authorize_mkdir(dvp, &amp;nd.ni_cnd, vap, ctx, NULL)) != 0) {
		<span class="enscript-keyword">if</span> (error == EACCES || error == EPERM) {
			<span class="enscript-type">int</span> error2;

			nameidone(&amp;nd);
			vnode_put(dvp);
			dvp = NULLVP;

			<span class="enscript-comment">/*
			 * Try a lookup without &quot;NAMEI_COMPOUNDVNOP&quot; to make sure we return EEXIST
			 * rather than EACCESS if the target exists.
			 */</span>
			NDINIT(&amp;nd, LOOKUP, OP_MKDIR, AUDITVNPATH1, segflg,
				       	path, ctx);
			error2 = nameiat(&amp;nd, fd);
			<span class="enscript-keyword">if</span> (error2) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			} <span class="enscript-keyword">else</span> {
				vp = nd.ni_vp;
				error = EEXIST;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * make the directory
	 */</span>
	<span class="enscript-keyword">if</span> ((error = vn_create(dvp, &amp;vp, &amp;nd, vap, 0, 0, NULL, ctx)) != 0) {
		<span class="enscript-keyword">if</span> (error == EKEEPLOOKING) {
			nd.ni_vp = vp;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">continue_lookup</span>;
		}

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">// Make sure the name &amp; parent pointers are hooked up
</span>	<span class="enscript-keyword">if</span> (vp-&gt;v_name == NULL)
	        update_flags |= VNODE_UPDATE_NAME;
	<span class="enscript-keyword">if</span> (vp-&gt;v_parent == NULLVP)
	        update_flags |= VNODE_UPDATE_PARENT;

	<span class="enscript-keyword">if</span> (update_flags)
	        vnode_update_identity(vp, dvp, nd.ni_cnd.cn_nameptr, nd.ni_cnd.cn_namelen, nd.ni_cnd.cn_hash, update_flags);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	add_fsevent(FSE_CREATE_DIR, ctx, FSE_ARG_VNODE, vp, FSE_ARG_DONE);
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/*
	 * nameidone has to happen before we vnode_put(dvp)
	 * since it may need to release the fs_nodelock on the dvp
	 */</span>
	nameidone(&amp;nd);

	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);
	<span class="enscript-keyword">if</span> (dvp)
		vnode_put(dvp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * mkdir_extended: Create a directory; with extended security (ACL).
 *
 * Parameters:    p                       Process requesting to create the directory
 *                uap                     User argument descriptor (see below)
 *                retval                  (ignored)
 *
 * Indirect:      uap-&gt;path               Path of directory to create
 *                uap-&gt;mode               Access permissions to set
 *                uap-&gt;xsecurity          ACL to set
 *
 * Returns:        0                      Success
 *                !0                      Not success
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mkdir_extended</span>(proc_t p, <span class="enscript-type">struct</span> mkdir_extended_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> ciferror;
	kauth_filesec_t xsecdst;
	<span class="enscript-type">struct</span> vnode_attr va;

	AUDIT_ARG(owner, uap-&gt;uid, uap-&gt;gid);

	xsecdst = NULL;
	<span class="enscript-keyword">if</span> ((uap-&gt;xsecurity != USER_ADDR_NULL) &amp;&amp;
	    ((ciferror = kauth_copyinfilesec(uap-&gt;xsecurity, &amp;xsecdst)) != 0))
		<span class="enscript-keyword">return</span> ciferror;

	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_mode, (uap-&gt;mode &amp; ACCESSPERMS) &amp; ~p-&gt;p_fd-&gt;fd_cmask);
	<span class="enscript-keyword">if</span> (xsecdst != NULL)
		VATTR_SET(&amp;va, va_acl, &amp;xsecdst-&gt;fsec_acl);

	ciferror = mkdir1at(vfs_context_current(), uap-&gt;path, &amp;va, AT_FDCWD,
	    UIO_USERSPACE);
	<span class="enscript-keyword">if</span> (xsecdst != NULL)
		kauth_filesec_free(xsecdst);
	<span class="enscript-keyword">return</span> ciferror;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mkdir</span>(proc_t p, <span class="enscript-type">struct</span> mkdir_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> vnode_attr va;

	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_mode, (uap-&gt;mode &amp; ACCESSPERMS) &amp; ~p-&gt;p_fd-&gt;fd_cmask);

	<span class="enscript-keyword">return</span> (mkdir1at(vfs_context_current(), uap-&gt;path, &amp;va, AT_FDCWD,
	    UIO_USERSPACE));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mkdirat</span>(proc_t p, <span class="enscript-type">struct</span> mkdirat_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> vnode_attr va;

	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_mode, (uap-&gt;mode &amp; ACCESSPERMS) &amp; ~p-&gt;p_fd-&gt;fd_cmask);

	<span class="enscript-keyword">return</span>(mkdir1at(vfs_context_current(), uap-&gt;path, &amp;va, uap-&gt;fd,
	    UIO_USERSPACE));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rmdirat_internal</span>(vfs_context_t ctx, <span class="enscript-type">int</span> fd, user_addr_t dirpath,
    <span class="enscript-type">enum</span> uio_seg segflg)
{
	vnode_t vp, dvp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">char</span>     *path = NULL;
	<span class="enscript-type">int</span>       len=0;
	<span class="enscript-type">int</span> has_listeners = 0;
	<span class="enscript-type">int</span> need_event = 0;
	<span class="enscript-type">int</span> truncated = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-type">struct</span> vnode_attr va;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FSE */</span>
	<span class="enscript-type">struct</span> vnode_attr *vap = NULL;
	<span class="enscript-type">int</span> restart_count = 0;
	<span class="enscript-type">int</span> batched;

	<span class="enscript-type">int</span> restart_flag;

	<span class="enscript-comment">/*
	 * This loop exists to restart rmdir in the unlikely case that two
	 * processes are simultaneously trying to remove the same directory
	 * containing orphaned appleDouble files.
	 */</span>
	<span class="enscript-keyword">do</span> {
		NDINIT(&amp;nd, DELETE, OP_RMDIR, LOCKPARENT | AUDITVNPATH1,
		    segflg, dirpath, ctx);
		nd.ni_flag = NAMEI_COMPOUNDRMDIR;
<span class="enscript-reference">continue_lookup</span>:
		restart_flag = 0;
		vap = NULL;

		error = nameiat(&amp;nd, fd);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);

		dvp = nd.ni_dvp;
		vp = nd.ni_vp;

		<span class="enscript-keyword">if</span> (vp) {
			batched = vnode_compound_rmdir_available(vp);

			<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VROOT) {
				<span class="enscript-comment">/*
				 * The root of a mounted filesystem cannot be deleted.
				 */</span>
				error = EBUSY;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-comment">/*
			 * Removed a check here; we used to abort if vp's vid
			 * was not the same as what we'd seen the last time around.
			 * I do not think that check was valid, because if we retry
			 * and all dirents are gone, the directory could legitimately
			 * be recycled but still be present in a situation where we would
			 * have had permission to delete.  Therefore, we won't make
			 * an effort to preserve that check now that we may not have a
			 * vp here.
			 */</span>

			<span class="enscript-keyword">if</span> (!batched) {
				error = vn_authorize_rmdir(dvp, vp, &amp;nd.ni_cnd, ctx, NULL);
				<span class="enscript-keyword">if</span> (error) {
					<span class="enscript-keyword">if</span> (error == ENOENT) {
						assert(restart_count &lt; MAX_AUTHORIZE_ENOENT_RETRIES);
						<span class="enscript-keyword">if</span> (restart_count &lt; MAX_AUTHORIZE_ENOENT_RETRIES) {
							restart_flag = 1;
							restart_count += 1;
						}
					}
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}
		} <span class="enscript-keyword">else</span> {
			batched = 1;

			<span class="enscript-keyword">if</span> (!vnode_compound_rmdir_available(dvp)) {
				panic(<span class="enscript-string">&quot;No error, but no compound rmdir?&quot;</span>);
			}
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
		fse_info  finfo;

		need_event = need_fsevent(FSE_DELETE, dvp);
		<span class="enscript-keyword">if</span> (need_event) {
			<span class="enscript-keyword">if</span> (!batched) {
				get_fse_info(vp, &amp;finfo, ctx);
			} <span class="enscript-keyword">else</span> {
				error = vfs_get_notify_attributes(&amp;va);
				<span class="enscript-keyword">if</span> (error) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}

				vap = &amp;va;
			}
		}
#<span class="enscript-reference">endif</span>
		has_listeners = kauth_authorize_fileop_has_listeners();
		<span class="enscript-keyword">if</span> (need_event || has_listeners) {
			<span class="enscript-keyword">if</span> (path == NULL) {
				GET_PATH(path);
				<span class="enscript-keyword">if</span> (path == NULL) {
					error = ENOMEM;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}

			len = safe_getpath(dvp, nd.ni_cnd.cn_nameptr, path, MAXPATHLEN, &amp;truncated);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
			<span class="enscript-keyword">if</span> (truncated) {
				finfo.mode |= FSE_TRUNCATED_PATH;
			}
#<span class="enscript-reference">endif</span>
		}

		error = vn_rmdir(dvp, &amp;vp, &amp;nd, vap, ctx);
		nd.ni_vp = vp;
		<span class="enscript-keyword">if</span> (vp == NULLVP) {
			<span class="enscript-comment">/* Couldn't find a vnode */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-keyword">if</span> (error == EKEEPLOOKING) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">continue_lookup</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (batched &amp;&amp; error == ENOENT) {
			assert(restart_count &lt; MAX_AUTHORIZE_ENOENT_RETRIES);
			<span class="enscript-keyword">if</span> (restart_count &lt; MAX_AUTHORIZE_ENOENT_RETRIES) {
				<span class="enscript-comment">/*
				 * For compound VNOPs, the authorization callback
				 * may return ENOENT in case of racing hard link lookups
				 * redrive the lookup.
				 */</span>
				restart_flag = 1;
				restart_count += 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
		<span class="enscript-comment">/*
		 * Special case to remove orphaned AppleDouble
		 * files. I don't like putting this in the kernel,
		 * but carbon does not like putting this in carbon either,
		 * so here we are.
		 */</span>
		<span class="enscript-keyword">if</span> (error == ENOTEMPTY) {
			error = rmdir_remove_orphaned_appleDouble(vp, ctx, &amp;restart_flag);
			<span class="enscript-keyword">if</span> (error == EBUSY) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}


			<span class="enscript-comment">/*
			 * Assuming everything went well, we will try the RMDIR again
			 */</span>
			<span class="enscript-keyword">if</span> (!error)
				error = vn_rmdir(dvp, &amp;vp, &amp;nd, vap, ctx);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>
		<span class="enscript-comment">/*
		 * Call out to allow 3rd party notification of delete.
		 * Ignore result of kauth_authorize_fileop call.
		 */</span>
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-keyword">if</span> (has_listeners) {
				kauth_authorize_fileop(vfs_context_ucred(ctx),
						KAUTH_FILEOP_DELETE,
						(uintptr_t)vp,
						(uintptr_t)path);
			}

			<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISHARDLINK) {
				<span class="enscript-comment">// see the comment in unlink1() about why we update
</span>				<span class="enscript-comment">// the parent of a hard link when it is removed
</span>				vnode_update_identity(vp, NULL, NULL, 0, 0, VNODE_UPDATE_PARENT);
			}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
			<span class="enscript-keyword">if</span> (need_event) {
				<span class="enscript-keyword">if</span> (vap) {
					vnode_get_fse_info_from_vap(vp, &amp;finfo, vap);
				}
				add_fsevent(FSE_DELETE, ctx,
						FSE_ARG_STRING, len, path,
						FSE_ARG_FINFO, &amp;finfo,
						FSE_ARG_DONE);
			}
#<span class="enscript-reference">endif</span>
		}

<span class="enscript-reference">out</span>:
		<span class="enscript-keyword">if</span> (path != NULL) {
			RELEASE_PATH(path);
			path = NULL;
		}
		<span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(dvp)
		 * since it may need to release the fs_nodelock on the dvp
		 */</span>
		nameidone(&amp;nd);
		vnode_put(dvp);

		<span class="enscript-keyword">if</span> (vp)
			vnode_put(vp);

		<span class="enscript-keyword">if</span> (restart_flag == 0) {
			wakeup_one((caddr_t)vp);
			<span class="enscript-keyword">return</span> (error);
		}
		tsleep(vp, PVFS, <span class="enscript-string">&quot;rm AD&quot;</span>, 1);

	} <span class="enscript-keyword">while</span> (restart_flag != 0);

	<span class="enscript-keyword">return</span> (error);

}

<span class="enscript-comment">/*
 * Remove a directory file.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">rmdir</span>(__unused proc_t p, <span class="enscript-type">struct</span> rmdir_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (rmdirat_internal(vfs_context_current(), AT_FDCWD,
	    CAST_USER_ADDR_T(uap-&gt;path), UIO_USERSPACE));
}

<span class="enscript-comment">/* Get direntry length padded to 8 byte alignment */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DIRENT64_LEN</span>(namlen) \
	((<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> direntry) + (namlen) - (MAXPATHLEN-1) + 7) &amp; ~7)

errno_t
<span class="enscript-function-name">vnode_readdir64</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> *eofflag,
                <span class="enscript-type">int</span> *numdirent, vfs_context_t ctxp)
{
	<span class="enscript-comment">/* Check if fs natively supports VNODE_READDIR_EXTENDED */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_mount-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSREADDIR_EXTENDED) &amp;&amp; 
		   ((vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_DENY_READDIREXT) == 0))	{
		<span class="enscript-keyword">return</span> VNOP_READDIR(vp, uio, flags, eofflag, numdirent, ctxp);
	} <span class="enscript-keyword">else</span> {
		size_t bufsize;
		<span class="enscript-type">void</span> * bufptr;
		uio_t auio;
		<span class="enscript-type">struct</span> direntry *entry64;
		<span class="enscript-type">struct</span> dirent *dep;
		<span class="enscript-type">int</span> bytesread;
		<span class="enscript-type">int</span> error;

		<span class="enscript-comment">/*
		 * Our kernel buffer needs to be smaller since re-packing
		 * will expand each dirent.  The worse case (when the name
		 * length is 3) corresponds to a struct direntry size of 32
		 * bytes (8-byte aligned) and a struct dirent size of 12 bytes
		 * (4-byte aligned).  So having a buffer that is 3/8 the size
		 * will prevent us from reading more than we can pack.
                 *
		 * Since this buffer is wired memory, we will limit the
		 * buffer size to a maximum of 32K. We would really like to 
		 * use 32K in the MIN(), but we use magic number 87371 to
		 * prevent uio_resid() * 3 / 8 from overflowing. 
		 */</span>
		bufsize = 3 * MIN((user_size_t)uio_resid(uio), 87371u) / 8;
		MALLOC(bufptr, <span class="enscript-type">void</span> *, bufsize, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (bufptr == NULL) {
			<span class="enscript-keyword">return</span> ENOMEM;
		}

		auio = uio_create(1, 0, UIO_SYSSPACE, UIO_READ);
		uio_addiov(auio, (uintptr_t)bufptr, bufsize);
		auio-&gt;uio_offset = uio-&gt;uio_offset;

		error = VNOP_READDIR(vp, auio, 0, eofflag, numdirent, ctxp);

		dep = (<span class="enscript-type">struct</span> dirent *)bufptr;
		bytesread = bufsize - uio_resid(auio);

		MALLOC(entry64, <span class="enscript-type">struct</span> direntry *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> direntry),
		       M_TEMP, M_WAITOK);
		<span class="enscript-comment">/*
		 * Convert all the entries and copy them out to user's buffer.
		 */</span>
		<span class="enscript-keyword">while</span> (error == 0 &amp;&amp; (<span class="enscript-type">char</span> *)dep &lt; ((<span class="enscript-type">char</span> *)bufptr + bytesread)) {
			size_t	enbufsize = DIRENT64_LEN(dep-&gt;d_namlen);

			bzero(entry64, enbufsize);
			<span class="enscript-comment">/* Convert a dirent to a dirent64. */</span>
			entry64-&gt;d_ino = dep-&gt;d_ino;
			entry64-&gt;d_seekoff = 0;
			entry64-&gt;d_reclen = enbufsize;
			entry64-&gt;d_namlen = dep-&gt;d_namlen;
			entry64-&gt;d_type = dep-&gt;d_type;
			bcopy(dep-&gt;d_name, entry64-&gt;d_name, dep-&gt;d_namlen + 1);

			<span class="enscript-comment">/* Move to next entry. */</span>
			dep = (<span class="enscript-type">struct</span> dirent *)((<span class="enscript-type">char</span> *)dep + dep-&gt;d_reclen);

			<span class="enscript-comment">/* Copy entry64 to user's buffer. */</span>
			error = uiomove((caddr_t)entry64, entry64-&gt;d_reclen, uio);
		}

		<span class="enscript-comment">/* Update the real offset using the offset we got from VNOP_READDIR. */</span>
		<span class="enscript-keyword">if</span> (error == 0) {
			uio-&gt;uio_offset = auio-&gt;uio_offset;
		}
		uio_free(auio);
		FREE(bufptr, M_TEMP);
		FREE(entry64, M_TEMP);
		<span class="enscript-keyword">return</span> (error);
	}
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GETDIRENTRIES_MAXBUFSIZE</span>	(128 * 1024 * 1024U)

<span class="enscript-comment">/*
 * Read a block of directory entries in a file system independent format.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getdirentries_common</span>(<span class="enscript-type">int</span> fd, user_addr_t bufp, user_size_t bufsize, ssize_t *bytesread,
                     off_t *offset, <span class="enscript-type">int</span> flags)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> vfs_context context = *vfs_context_current();	<span class="enscript-comment">/* local copy */</span>
	<span class="enscript-type">struct</span> fileproc *fp;
	uio_t auio;
	<span class="enscript-type">int</span> spacetype = proc_is64bit(vfs_context_proc(&amp;context)) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	off_t loff;
	<span class="enscript-type">int</span> error, eofflag, numdirent;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];

	error = fp_getfvp(vfs_context_proc(&amp;context), fd, &amp;fp, &amp;vp);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ((fp-&gt;f_fglob-&gt;fg_flag &amp; FREAD) == 0) {
		AUDIT_ARG(vnpath_withref, vp, ARG_VNODE1);
		error = EBADF;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (bufsize &gt; GETDIRENTRIES_MAXBUFSIZE)
		bufsize = GETDIRENTRIES_MAXBUFSIZE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_file_check_change_offset(vfs_context_ucred(&amp;context), fp-&gt;f_fglob);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	AUDIT_ARG(vnpath, vp, ARG_VNODE1);

<span class="enscript-reference">unionread</span>:
	<span class="enscript-keyword">if</span> (vp-&gt;v_type != VDIR) {
		(<span class="enscript-type">void</span>)vnode_put(vp);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_readdir(&amp;context, vp);
	<span class="enscript-keyword">if</span> (error != 0) {
		(<span class="enscript-type">void</span>)vnode_put(vp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>

	loff = fp-&gt;f_fglob-&gt;fg_offset;
	auio = uio_createwithbuffer(1, loff, spacetype, UIO_READ, &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, bufp, bufsize);

	<span class="enscript-keyword">if</span> (flags &amp; VNODE_READDIR_EXTENDED) {
		error = vnode_readdir64(vp, auio, flags, &amp;eofflag, &amp;numdirent, &amp;context);
		fp-&gt;f_fglob-&gt;fg_offset = uio_offset(auio);
	} <span class="enscript-keyword">else</span> {
		error = VNOP_READDIR(vp, auio, 0, &amp;eofflag, &amp;numdirent, &amp;context);
		fp-&gt;f_fglob-&gt;fg_offset = uio_offset(auio);
	}
	<span class="enscript-keyword">if</span> (error) {
		(<span class="enscript-type">void</span>)vnode_put(vp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> ((user_ssize_t)bufsize == uio_resid(auio)){
		<span class="enscript-keyword">if</span> (union_dircheckp) {
			error = union_dircheckp(&amp;vp, fp, &amp;context);
			<span class="enscript-keyword">if</span> (error == -1)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">unionread</span>;
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-keyword">if</span> ((vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_UNION)) {
			<span class="enscript-type">struct</span> vnode *tvp = vp;
			<span class="enscript-keyword">if</span> (lookup_traverse_union(tvp, &amp;vp, &amp;context) == 0) {
				vnode_ref(vp);
				fp-&gt;f_fglob-&gt;fg_data = (caddr_t) vp;
				fp-&gt;f_fglob-&gt;fg_offset = 0;
				vnode_rele(tvp);
				vnode_put(tvp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">unionread</span>;
			}
			vp = tvp;
		}
	}

	vnode_put(vp);
	<span class="enscript-keyword">if</span> (offset) {
		*offset = loff;
	}
	
	*bytesread = bufsize - uio_resid(auio);
<span class="enscript-reference">out</span>:
	file_drop(fd);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">getdirentries</span>(__unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> getdirentries_args *uap, int32_t *retval)
{
	off_t offset;
	ssize_t bytesread;
	<span class="enscript-type">int</span> error;

	AUDIT_ARG(fd, uap-&gt;fd);
	error = getdirentries_common(uap-&gt;fd, uap-&gt;buf, uap-&gt;count, &amp;bytesread, &amp;offset, 0);

	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-keyword">if</span> (proc_is64bit(p)) {
			user64_long_t base = (user64_long_t)offset;
			error = copyout((caddr_t)&amp;base, uap-&gt;basep, <span class="enscript-keyword">sizeof</span>(user64_long_t));
		} <span class="enscript-keyword">else</span> {
			user32_long_t base = (user32_long_t)offset;
			error = copyout((caddr_t)&amp;base, uap-&gt;basep, <span class="enscript-keyword">sizeof</span>(user32_long_t));
		}
		*retval = bytesread;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">getdirentries64</span>(__unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> getdirentries64_args *uap, user_ssize_t *retval)
{
	off_t offset;
	ssize_t bytesread;
	<span class="enscript-type">int</span> error;

	AUDIT_ARG(fd, uap-&gt;fd);
	error = getdirentries_common(uap-&gt;fd, uap-&gt;buf, uap-&gt;bufsize, &amp;bytesread, &amp;offset, VNODE_READDIR_EXTENDED);

	<span class="enscript-keyword">if</span> (error == 0) {
		*retval = bytesread;
		error = copyout((caddr_t)&amp;offset, uap-&gt;position, <span class="enscript-keyword">sizeof</span>(off_t));
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Set the mode mask for creation of filesystem nodes.
 * XXX implement xsecurity
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UMASK_NOXSECURITY</span>	 (void *)1	<span class="enscript-comment">/* leave existing xsecurity alone */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">umask1</span>(proc_t p, <span class="enscript-type">int</span> newmask, __unused kauth_filesec_t fsec, int32_t *retval)
{
	<span class="enscript-type">struct</span> filedesc *fdp;

	AUDIT_ARG(mask, newmask);
	proc_fdlock(p);
	fdp = p-&gt;p_fd;
	*retval = fdp-&gt;fd_cmask;
	fdp-&gt;fd_cmask = newmask &amp; ALLPERMS;
	proc_fdunlock(p);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * umask_extended: Set the mode mask for creation of filesystem nodes; with extended security (ACL).
 *
 * Parameters:    p                       Process requesting to set the umask
 *                uap                     User argument descriptor (see below)
 *                retval                  umask of the process (parameter p)
 *
 * Indirect:      uap-&gt;newmask            umask to set
 *                uap-&gt;xsecurity          ACL to set
 *                
 * Returns:        0                      Success
 *                !0                      Not success
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">umask_extended</span>(proc_t p, <span class="enscript-type">struct</span> umask_extended_args *uap, int32_t *retval)
{
	<span class="enscript-type">int</span> ciferror;
	kauth_filesec_t xsecdst;

	xsecdst = KAUTH_FILESEC_NONE;
	<span class="enscript-keyword">if</span> (uap-&gt;xsecurity != USER_ADDR_NULL) {
		<span class="enscript-keyword">if</span> ((ciferror = kauth_copyinfilesec(uap-&gt;xsecurity, &amp;xsecdst)) != 0)
			<span class="enscript-keyword">return</span> ciferror;
	} <span class="enscript-keyword">else</span> {
		xsecdst = KAUTH_FILESEC_NONE;
	}

	ciferror = umask1(p, uap-&gt;newmask, xsecdst, retval);

	<span class="enscript-keyword">if</span> (xsecdst != KAUTH_FILESEC_NONE)
		kauth_filesec_free(xsecdst);
	<span class="enscript-keyword">return</span> ciferror;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">umask</span>(proc_t p, <span class="enscript-type">struct</span> umask_args *uap, int32_t *retval)
{
	<span class="enscript-keyword">return</span>(umask1(p, uap-&gt;newmask, UMASK_NOXSECURITY, retval));
}

<span class="enscript-comment">/*
 * Void all references to file by ripping underlying filesystem
 * away from vnode.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">revoke</span>(proc_t p, <span class="enscript-type">struct</span> revoke_args *uap, __unused int32_t *retval)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> vnode_attr va;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;

	NDINIT(&amp;nd, LOOKUP, OP_REVOKE, FOLLOW | AUDITVNPATH1, UIO_USERSPACE,
	       uap-&gt;path, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	vp = nd.ni_vp;

	nameidone(&amp;nd);

	<span class="enscript-keyword">if</span> (!(vnode_ischr(vp) || vnode_isblk(vp))) {
		error = ENOTSUP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (vnode_isblk(vp) &amp;&amp; vnode_ismountedon(vp)) {
		error = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_revoke(ctx, vp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

	VATTR_INIT(&amp;va);
	VATTR_WANTED(&amp;va, va_uid);
	<span class="enscript-keyword">if</span> ((error = vnode_getattr(vp, &amp;va, ctx)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> (kauth_cred_getuid(vfs_context_ucred(ctx)) != va.va_uid &amp;&amp;
	    (error = suser(vfs_context_ucred(ctx), &amp;p-&gt;p_acflag)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> (vp-&gt;v_usecount &gt; 0 || (vnode_isaliased(vp)))
		VNOP_REVOKE(vp, REVOKEALL, ctx);
<span class="enscript-reference">out</span>:
	vnode_put(vp);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 *  HFS/HFS PlUS SPECIFIC SYSTEM CALLS
 *  The following system calls are designed to support features
 *  which are specific to the HFS &amp; HFS Plus volume formats
 */</span>


<span class="enscript-comment">/*
 * Obtain attribute information on objects in a directory while enumerating
 * the directory.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getdirentriesattr</span> (proc_t p, <span class="enscript-type">struct</span> getdirentriesattr_args *uap, int32_t *retval)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> fileproc *fp;
	uio_t auio = NULL;
	<span class="enscript-type">int</span> spacetype = proc_is64bit(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	uint32_t count, savecount;
	uint32_t newstate;
	<span class="enscript-type">int</span> error, eofflag;
	uint32_t loff;
	<span class="enscript-type">struct</span> attrlist attributelist; 
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">int</span> fd = uap-&gt;fd;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];
	kauth_action_t action;

	AUDIT_ARG(fd, fd);
    
	<span class="enscript-comment">/* Get the attributes into kernel space */</span>
	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;alist, (caddr_t)&amp;attributelist, <span class="enscript-keyword">sizeof</span>(attributelist)))) {
		<span class="enscript-keyword">return</span>(error);
	}
	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;count, (caddr_t)&amp;count, <span class="enscript-keyword">sizeof</span>(count)))) {
		<span class="enscript-keyword">return</span>(error);
	}
	savecount = count;
	<span class="enscript-keyword">if</span> ( (error = fp_getfvp(p, fd, &amp;fp, &amp;vp)) ) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ((fp-&gt;f_fglob-&gt;fg_flag &amp; FREAD) == 0) {
		AUDIT_ARG(vnpath_withref, vp, ARG_VNODE1);
		error = EBADF;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_file_check_change_offset(vfs_context_ucred(ctx),
	    fp-&gt;f_fglob);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>


	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) )
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	AUDIT_ARG(vnpath, vp, ARG_VNODE1);

<span class="enscript-reference">unionread</span>:
	<span class="enscript-keyword">if</span> (vp-&gt;v_type != VDIR) {
		(<span class="enscript-type">void</span>)vnode_put(vp);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_readdir(ctx, vp);
	<span class="enscript-keyword">if</span> (error != 0) {
		(<span class="enscript-type">void</span>)vnode_put(vp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>

	<span class="enscript-comment">/* set up the uio structure which will contain the users return buffer */</span>
	loff = fp-&gt;f_fglob-&gt;fg_offset;
	auio = uio_createwithbuffer(1, loff, spacetype, UIO_READ, &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, uap-&gt;buffer, uap-&gt;buffersize);
       
	<span class="enscript-comment">/*
	 * If the only item requested is file names, we can let that past with
	 * just LIST_DIRECTORY.  If they want any other attributes, that means
	 * they need SEARCH as well.
	 */</span>
	action = KAUTH_VNODE_LIST_DIRECTORY;
	<span class="enscript-keyword">if</span> ((attributelist.commonattr &amp; ~ATTR_CMN_NAME) ||
	    attributelist.fileattr || attributelist.dirattr)
		action |= KAUTH_VNODE_SEARCH;
	
	<span class="enscript-keyword">if</span> ((error = vnode_authorize(vp, NULL, action, ctx)) == 0) {

		<span class="enscript-comment">/* Believe it or not, uap-&gt;options only has 32-bits of valid
		 * info, so truncate before extending again */</span>

		error = VNOP_READDIRATTR(vp, &amp;attributelist, auio, count,
				(u_long)(uint32_t)uap-&gt;options, &amp;newstate, &amp;eofflag, &amp;count, ctx);
	}

	<span class="enscript-keyword">if</span> (error) {
		(<span class="enscript-type">void</span>) vnode_put(vp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * If we've got the last entry of a directory in a union mount
	 * then reset the eofflag and pretend there's still more to come.
	 * The next call will again set eofflag and the buffer will be empty,
	 * so traverse to the underlying directory and do the directory
	 * read there.
	 */</span>
	<span class="enscript-keyword">if</span> (eofflag &amp;&amp; vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_UNION) {
		<span class="enscript-keyword">if</span> (uio_resid(auio) &lt; (user_ssize_t) uap-&gt;buffersize) { <span class="enscript-comment">// Got some entries
</span>			eofflag = 0;
		} <span class="enscript-keyword">else</span> {						<span class="enscript-comment">// Empty buffer
</span>			<span class="enscript-type">struct</span> vnode *tvp = vp;
			<span class="enscript-keyword">if</span> (lookup_traverse_union(tvp, &amp;vp, ctx) == 0) {
				vnode_ref_ext(vp, fp-&gt;f_fglob-&gt;fg_flag &amp; O_EVTONLY, 0);
				fp-&gt;f_fglob-&gt;fg_data = (caddr_t) vp;
				fp-&gt;f_fglob-&gt;fg_offset = 0; <span class="enscript-comment">// reset index for new dir
</span>				count = savecount;
				vnode_rele_internal(tvp, fp-&gt;f_fglob-&gt;fg_flag &amp; O_EVTONLY, 0, 0);
				vnode_put(tvp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">unionread</span>;
			}
			vp = tvp;
		}
	}

	(<span class="enscript-type">void</span>)vnode_put(vp);

	<span class="enscript-keyword">if</span> (error) 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	fp-&gt;f_fglob-&gt;fg_offset = uio_offset(auio); <span class="enscript-comment">/* should be multiple of dirent, not variable */</span>

	<span class="enscript-keyword">if</span> ((error = copyout((caddr_t) &amp;count, uap-&gt;count, <span class="enscript-keyword">sizeof</span>(count))))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> ((error = copyout((caddr_t) &amp;newstate, uap-&gt;newstate, <span class="enscript-keyword">sizeof</span>(newstate))))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> ((error = copyout((caddr_t) &amp;loff, uap-&gt;basep, <span class="enscript-keyword">sizeof</span>(loff))))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	*retval = eofflag;  <span class="enscript-comment">/* similar to getdirentries */</span>
	error = 0;
<span class="enscript-reference">out</span>:
	file_drop(fd);
	<span class="enscript-keyword">return</span> (error); <span class="enscript-comment">/* return error earlier, an retval of 0 or 1 now */</span>

} <span class="enscript-comment">/* end of getdirentriesattr system call */</span>

<span class="enscript-comment">/*
* Exchange data between two files
*/</span>

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">exchangedata</span> (__unused proc_t p, <span class="enscript-type">struct</span> exchangedata_args *uap, __unused int32_t *retval)
{

	<span class="enscript-type">struct</span> nameidata fnd, snd;
	vfs_context_t ctx = vfs_context_current();
	vnode_t fvp;
	vnode_t svp;
	<span class="enscript-type">int</span> error;
	u_int32_t nameiflags;
	<span class="enscript-type">char</span> *fpath = NULL;
	<span class="enscript-type">char</span> *spath = NULL;
	<span class="enscript-type">int</span>   flen=0, slen=0;
	<span class="enscript-type">int</span> from_truncated=0, to_truncated=0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	fse_info f_finfo, s_finfo;
#<span class="enscript-reference">endif</span>
	
	nameiflags = 0;
	<span class="enscript-keyword">if</span> ((uap-&gt;options &amp; FSOPT_NOFOLLOW) == 0) nameiflags |= FOLLOW;

	NDINIT(&amp;fnd, LOOKUP, OP_EXCHANGEDATA, nameiflags | AUDITVNPATH1,
	       UIO_USERSPACE, uap-&gt;path1, ctx);

	error = namei(&amp;fnd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;

	nameidone(&amp;fnd);
	fvp = fnd.ni_vp;

	NDINIT(&amp;snd, LOOKUP, OP_EXCHANGEDATA, CN_NBMOUNTLOOK | nameiflags | AUDITVNPATH2, 
               UIO_USERSPACE, uap-&gt;path2, ctx);

	error = namei(&amp;snd);
	<span class="enscript-keyword">if</span> (error) {
		vnode_put(fvp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
	}
	nameidone(&amp;snd);
	svp = snd.ni_vp;

	<span class="enscript-comment">/*
	 * if the files are the same, return an inval error
	 */</span>
	<span class="enscript-keyword">if</span> (svp == fvp) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	} 

	<span class="enscript-comment">/*
	 * if the files are on different volumes, return an error
	 */</span>
	<span class="enscript-keyword">if</span> (svp-&gt;v_mount != fvp-&gt;v_mount) {
	        error = EXDEV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* If they're not files, return an error */</span>
	<span class="enscript-keyword">if</span> ( (vnode_isreg(fvp) == 0) || (vnode_isreg(svp) == 0)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_exchangedata(ctx,
	    fvp, svp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (((error = vnode_authorize(fvp, NULL, KAUTH_VNODE_READ_DATA | KAUTH_VNODE_WRITE_DATA, ctx)) != 0) ||
	    ((error = vnode_authorize(svp, NULL, KAUTH_VNODE_READ_DATA | KAUTH_VNODE_WRITE_DATA, ctx)) != 0))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	need_fsevent(FSE_EXCHANGE, fvp) || 
#<span class="enscript-reference">endif</span>
	kauth_authorize_fileop_has_listeners()) {
		GET_PATH(fpath);
		GET_PATH(spath);
		<span class="enscript-keyword">if</span> (fpath == NULL || spath == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		flen = safe_getpath(fvp, NULL, fpath, MAXPATHLEN, &amp;from_truncated);
		slen = safe_getpath(svp, NULL, spath, MAXPATHLEN, &amp;to_truncated);
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
		get_fse_info(fvp, &amp;f_finfo, ctx);
		get_fse_info(svp, &amp;s_finfo, ctx);
		<span class="enscript-keyword">if</span> (from_truncated || to_truncated) {
			<span class="enscript-comment">// set it here since only the f_finfo gets reported up to user space
</span>			f_finfo.mode |= FSE_TRUNCATED_PATH;
		}
#<span class="enscript-reference">endif</span>
	}
	<span class="enscript-comment">/* Ok, make the call */</span>
	error = VNOP_EXCHANGE(fvp, svp, 0, ctx);

	<span class="enscript-keyword">if</span> (error == 0) {
	    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *tmpname;

	    <span class="enscript-keyword">if</span> (fpath != NULL &amp;&amp; spath != NULL) {
	            <span class="enscript-comment">/* call out to allow 3rd party notification of exchangedata. 
		     * Ignore result of kauth_authorize_fileop call.
		     */</span>
	            kauth_authorize_fileop(vfs_context_ucred(ctx), KAUTH_FILEOP_EXCHANGE, 
					   (uintptr_t)fpath, (uintptr_t)spath);
	    }
	    name_cache_lock();

	    tmpname     = fvp-&gt;v_name;
	    fvp-&gt;v_name = svp-&gt;v_name;
	    svp-&gt;v_name = tmpname;
	    
	    <span class="enscript-keyword">if</span> (fvp-&gt;v_parent != svp-&gt;v_parent) {
		vnode_t tmp;

		tmp           = fvp-&gt;v_parent;
		fvp-&gt;v_parent = svp-&gt;v_parent;
		svp-&gt;v_parent = tmp;
	    }
	    name_cache_unlock();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	    <span class="enscript-keyword">if</span> (fpath != NULL &amp;&amp; spath != NULL) {
	            add_fsevent(FSE_EXCHANGE, ctx,
				FSE_ARG_STRING, flen, fpath,
				FSE_ARG_FINFO, &amp;f_finfo,
				FSE_ARG_STRING, slen, spath,
				FSE_ARG_FINFO, &amp;s_finfo,
				FSE_ARG_DONE);
	    }
#<span class="enscript-reference">endif</span>
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (fpath != NULL)
	        RELEASE_PATH(fpath);
	<span class="enscript-keyword">if</span> (spath != NULL)
	        RELEASE_PATH(spath);
	vnode_put(svp);
	vnode_put(fvp);
<span class="enscript-reference">out2</span>:
        <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Return (in MB) the amount of freespace on the given vnode's volume.
 */</span>
uint32_t <span class="enscript-function-name">freespace_mb</span>(vnode_t vp);

uint32_t
<span class="enscript-function-name">freespace_mb</span>(vnode_t vp)
{
	vfs_update_vfsstat(vp-&gt;v_mount, vfs_context_current(), VFS_USER_EVENT);	
 	<span class="enscript-keyword">return</span> (((uint64_t)vp-&gt;v_mount-&gt;mnt_vfsstat.f_bavail *
 	        vp-&gt;v_mount-&gt;mnt_vfsstat.f_bsize) &gt;&gt; 20);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SEARCHFS</span>

<span class="enscript-comment">/* ARGSUSED */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">searchfs</span>(proc_t p, <span class="enscript-type">struct</span> searchfs_args *uap, __unused int32_t *retval)
{
	vnode_t vp, tvp;
	<span class="enscript-type">int</span> i, error=0;
	<span class="enscript-type">int</span> fserror = 0;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">struct</span> user64_fssearchblock searchblock;
	<span class="enscript-type">struct</span> searchstate *state;
	<span class="enscript-type">struct</span> attrlist *returnattrs;
	<span class="enscript-type">struct</span> timeval timelimit;
	<span class="enscript-type">void</span> *searchparams1,*searchparams2;
	uio_t auio = NULL;
	<span class="enscript-type">int</span> spacetype = proc_is64bit(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	uint32_t nummatches;
	<span class="enscript-type">int</span> mallocsize;
	uint32_t nameiflags;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];

	<span class="enscript-comment">/* Start by copying in fsearchblock parameter list */</span>
    <span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
        error = copyin(uap-&gt;searchblock, (caddr_t) &amp;searchblock, <span class="enscript-keyword">sizeof</span>(searchblock));
        timelimit.tv_sec = searchblock.timelimit.tv_sec;
        timelimit.tv_usec = searchblock.timelimit.tv_usec;
    }
    <span class="enscript-keyword">else</span> {
        <span class="enscript-type">struct</span> user32_fssearchblock tmp_searchblock;

        error = copyin(uap-&gt;searchblock, (caddr_t) &amp;tmp_searchblock, <span class="enscript-keyword">sizeof</span>(tmp_searchblock));
        <span class="enscript-comment">// munge into 64-bit version
</span>        searchblock.returnattrs = CAST_USER_ADDR_T(tmp_searchblock.returnattrs);
        searchblock.returnbuffer = CAST_USER_ADDR_T(tmp_searchblock.returnbuffer);
        searchblock.returnbuffersize = tmp_searchblock.returnbuffersize;
        searchblock.maxmatches = tmp_searchblock.maxmatches;
		<span class="enscript-comment">/* 
		 * These casts are safe. We will promote the tv_sec into a 64 bit long if necessary
		 * from a 32 bit long, and tv_usec is already a signed 32 bit int.
		 */</span>
        timelimit.tv_sec = (__darwin_time_t) tmp_searchblock.timelimit.tv_sec;
        timelimit.tv_usec = (__darwin_useconds_t) tmp_searchblock.timelimit.tv_usec;
        searchblock.searchparams1 = CAST_USER_ADDR_T(tmp_searchblock.searchparams1);
        searchblock.sizeofsearchparams1 = tmp_searchblock.sizeofsearchparams1;
        searchblock.searchparams2 = CAST_USER_ADDR_T(tmp_searchblock.searchparams2);
        searchblock.sizeofsearchparams2 = tmp_searchblock.sizeofsearchparams2;
        searchblock.searchattrs = tmp_searchblock.searchattrs;
    }
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span>(error);

	<span class="enscript-comment">/* Do a sanity check on sizeofsearchparams1 and sizeofsearchparams2.  
	 */</span>
	<span class="enscript-keyword">if</span> (searchblock.sizeofsearchparams1 &gt; SEARCHFS_MAX_SEARCHPARMS || 
		searchblock.sizeofsearchparams2 &gt; SEARCHFS_MAX_SEARCHPARMS)
		<span class="enscript-keyword">return</span>(EINVAL);
	
	<span class="enscript-comment">/* Now malloc a big bunch of space to hold the search parameters, the attrlists and the search state. */</span>
	<span class="enscript-comment">/* It all has to do into local memory and it's not that big so we might as well  put it all together. */</span>
	<span class="enscript-comment">/* Searchparams1 shall be first so we might as well use that to hold the base address of the allocated*/</span>
	<span class="enscript-comment">/* block.  											      */</span>
	<span class="enscript-comment">/*												      */</span>
	<span class="enscript-comment">/* NOTE: we allocate an extra 8 bytes to account for the difference in size of the searchstate        */</span>
	<span class="enscript-comment">/*       due to the changes in rdar://problem/12438273.  That way if a 3rd party file system          */</span>
	<span class="enscript-comment">/*       assumes the size is still 556 bytes it will continue to work				      */</span>
		 
	mallocsize = searchblock.sizeofsearchparams1 + searchblock.sizeofsearchparams2 +
		<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> attrlist) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> searchstate) + (2*<span class="enscript-keyword">sizeof</span>(uint32_t));

	MALLOC(searchparams1, <span class="enscript-type">void</span> *, mallocsize, M_TEMP, M_WAITOK);

	<span class="enscript-comment">/* Now set up the various pointers to the correct place in our newly allocated memory */</span>

	searchparams2 = (<span class="enscript-type">void</span> *) (((caddr_t) searchparams1) + searchblock.sizeofsearchparams1);
	returnattrs = (<span class="enscript-type">struct</span> attrlist *) (((caddr_t) searchparams2) + searchblock.sizeofsearchparams2);
	state = (<span class="enscript-type">struct</span> searchstate *) (((caddr_t) returnattrs) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> attrlist));

	<span class="enscript-comment">/* Now copy in the stuff given our local variables. */</span>

	<span class="enscript-keyword">if</span> ((error = copyin(searchblock.searchparams1, searchparams1, searchblock.sizeofsearchparams1)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;

	<span class="enscript-keyword">if</span> ((error = copyin(searchblock.searchparams2, searchparams2, searchblock.sizeofsearchparams2)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;

	<span class="enscript-keyword">if</span> ((error = copyin(searchblock.returnattrs, (caddr_t) returnattrs, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> attrlist))))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;
		
	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;state, (caddr_t) state, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> searchstate))))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;

	<span class="enscript-comment">/*
	 * When searching a union mount, need to set the
	 * start flag at the first call on each layer to
	 * reset state for the new volume.
	 */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;options &amp; SRCHFS_START)
		state-&gt;ss_union_layer = 0;
	<span class="enscript-keyword">else</span> 
		uap-&gt;options |= state-&gt;ss_union_flags;
	state-&gt;ss_union_flags = 0;

	<span class="enscript-comment">/*
	 * Because searchparams1 and searchparams2 may contain an ATTR_CMN_NAME search parameter,
	 * which is passed in with an attrreference_t, we need to inspect the buffer manually here.
	 * The KPI does not provide us the ability to pass in the length of the buffers searchparams1 
	 * and searchparams2. To obviate the need for all searchfs-supporting filesystems to 
	 * validate the user-supplied data offset of the attrreference_t, we'll do it here.
	 */</span>

	<span class="enscript-keyword">if</span> (searchblock.searchattrs.commonattr &amp; ATTR_CMN_NAME) {
		attrreference_t* string_ref;
		u_int32_t* start_length;
		user64_size_t param_length;            

		<span class="enscript-comment">/* validate searchparams1 */</span>
		param_length = searchblock.sizeofsearchparams1;                                           
		<span class="enscript-comment">/* skip the word that specifies length of the buffer */</span>
		start_length= (u_int32_t*) searchparams1;
		start_length= start_length+1;
		string_ref= (attrreference_t*) start_length;

		<span class="enscript-comment">/* ensure no negative offsets or too big offsets */</span>
		<span class="enscript-keyword">if</span> (string_ref-&gt;attr_dataoffset &lt; 0 ) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;		
		}
		<span class="enscript-keyword">if</span> (string_ref-&gt;attr_length &gt; MAXPATHLEN) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;
		}
		
		<span class="enscript-comment">/* Check for pointer overflow in the string ref */</span>
		<span class="enscript-keyword">if</span> (((<span class="enscript-type">char</span>*) string_ref + string_ref-&gt;attr_dataoffset) &lt; (<span class="enscript-type">char</span>*) string_ref) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;
		}

		<span class="enscript-keyword">if</span> (((<span class="enscript-type">char</span>*) string_ref + string_ref-&gt;attr_dataoffset) &gt; ((<span class="enscript-type">char</span>*)searchparams1 + param_length)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;
		}
		<span class="enscript-keyword">if</span> (((<span class="enscript-type">char</span>*)string_ref + string_ref-&gt;attr_dataoffset + string_ref-&gt;attr_length) &gt; ((<span class="enscript-type">char</span>*)searchparams1 + param_length)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;
		}
	}

	<span class="enscript-comment">/* set up the uio structure which will contain the users return buffer */</span>
	auio = uio_createwithbuffer(1, 0, spacetype, UIO_READ, &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
 	uio_addiov(auio, searchblock.returnbuffer, searchblock.returnbuffersize);

	nameiflags = 0;
	<span class="enscript-keyword">if</span> ((uap-&gt;options &amp; FSOPT_NOFOLLOW) == 0) nameiflags |= FOLLOW;
	NDINIT(&amp;nd, LOOKUP, OP_SEARCHFS, nameiflags | AUDITVNPATH1,
	       UIO_USERSPACE, uap-&gt;path, ctx);

	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;
	vp = nd.ni_vp;
	nameidone(&amp;nd);

	<span class="enscript-comment">/*
	 * Switch to the root vnode for the volume
	 */</span>
	error = VFS_ROOT(vnode_mount(vp), &amp;tvp, ctx);
	vnode_put(vp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;
	vp = tvp;

	<span class="enscript-comment">/*
	 * If it's a union mount, the path lookup takes
	 * us to the top layer. But we may need to descend
	 * to a lower layer. For non-union mounts the layer
	 * is always zero.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>) state-&gt;ss_union_layer; i++) {
		<span class="enscript-keyword">if</span> ((vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_UNION) == 0)
			<span class="enscript-keyword">break</span>;
		tvp = vp;
		vp = vp-&gt;v_mount-&gt;mnt_vnodecovered;
		<span class="enscript-keyword">if</span> (vp == NULL) {
			vnode_put(tvp);
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;
		}
		vnode_getwithref(vp);
		vnode_put(tvp);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_searchfs(ctx, vp, &amp;searchblock.searchattrs);
	<span class="enscript-keyword">if</span> (error) {
		vnode_put(vp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;
	}
#<span class="enscript-reference">endif</span>

	 
	<span class="enscript-comment">/*
	 * If searchblock.maxmatches == 0, then skip the search. This has happened 
	 * before and sometimes the underlying code doesnt deal with it well.
	 */</span>
	 <span class="enscript-keyword">if</span> (searchblock.maxmatches == 0) {
		nummatches = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">saveandexit</span>;
	 }

	<span class="enscript-comment">/*
	 * Allright, we have everything we need, so lets make that call.
	 * 
	 * We keep special track of the return value from the file system:
	 * EAGAIN is an acceptable error condition that shouldn't keep us
	 * from copying out any results...
	 */</span>

	fserror = VNOP_SEARCHFS(vp,
		searchparams1,
		searchparams2,
		&amp;searchblock.searchattrs,
		(u_long)searchblock.maxmatches,
		&amp;timelimit,
		returnattrs,
		&amp;nummatches,
		(u_long)uap-&gt;scriptcode,
		(u_long)uap-&gt;options,
		auio,
		(<span class="enscript-type">struct</span> searchstate *) &amp;state-&gt;ss_fsstate,
		ctx);
		
	<span class="enscript-comment">/*
	 * If it's a union mount we need to be called again
	 * to search the mounted-on filesystem.
	 */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_UNION) &amp;&amp; fserror == 0) {
		state-&gt;ss_union_flags = SRCHFS_START;
		state-&gt;ss_union_layer++;	<span class="enscript-comment">// search next layer down
</span>		fserror = EAGAIN;
	}

<span class="enscript-reference">saveandexit</span>:

	vnode_put(vp);

	<span class="enscript-comment">/* Now copy out the stuff that needs copying out. That means the number of matches, the
	   search state.  Everything was already put into he return buffer by the vop call. */</span>

	<span class="enscript-keyword">if</span> ((error = copyout((caddr_t) state, uap-&gt;state, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> searchstate))) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;

	<span class="enscript-keyword">if</span> ((error = suulong(uap-&gt;nummatches, (uint64_t)nummatches)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeandexit</span>;
	
	error = fserror;

<span class="enscript-reference">freeandexit</span>:

	FREE(searchparams1,M_TEMP);

	<span class="enscript-keyword">return</span>(error);


} <span class="enscript-comment">/* end of searchfs system call */</span>

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* CONFIG_SEARCHFS */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">searchfs</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> searchfs_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_SEARCHFS */</span>


lck_grp_attr_t *  nspace_group_attr;
lck_attr_t *      nspace_lock_attr;
lck_grp_t *       nspace_mutex_group;

lck_mtx_t         nspace_handler_lock;
lck_mtx_t         nspace_handler_exclusion_lock;

time_t snapshot_timestamp=0;
<span class="enscript-type">int</span> nspace_allow_virtual_devs=0;

<span class="enscript-type">void</span> <span class="enscript-function-name">nspace_handler_init</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> nspace_item_info {
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">void</span>         *arg;
	uint64_t      op;
	uint32_t      vid;
	uint32_t      flags;
	uint32_t      token;
	uint32_t      refcount;
} nspace_item_info;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_NSPACE_ITEMS</span>   128
nspace_item_info nspace_items[MAX_NSPACE_ITEMS];
uint32_t      nspace_item_idx=0;              <span class="enscript-comment">// also used as the sleep/wakeup rendezvous address
</span>uint32_t      nspace_token_id=0;
uint32_t      nspace_handler_timeout = 15;    <span class="enscript-comment">// seconds
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSPACE_ITEM_NEW</span>         0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSPACE_ITEM_PROCESSING</span>  0x0002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSPACE_ITEM_DEAD</span>        0x0004
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSPACE_ITEM_CANCELLED</span>   0x0008
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSPACE_ITEM_DONE</span>        0x0010
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSPACE_ITEM_RESET_TIMER</span> 0x0020

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSPACE_ITEM_NSPACE_EVENT</span>   0x0040
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSPACE_ITEM_SNAPSHOT_EVENT</span> 0x0080

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NSPACE_ITEM_ALL_EVENT_TYPES</span> (NSPACE_ITEM_NSPACE_EVENT | NSPACE_ITEM_SNAPSHOT_EVENT)

<span class="enscript-comment">//#pragma optimization_level 0
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	NSPACE_HANDLER_NSPACE = 0,
	NSPACE_HANDLER_SNAPSHOT = 1,

	NSPACE_HANDLER_COUNT,
} nspace_type_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	uint64_t handler_tid;
	<span class="enscript-type">struct</span> proc *handler_proc;
	<span class="enscript-type">int</span> handler_busy;
} nspace_handler_t;

nspace_handler_t nspace_handlers[NSPACE_HANDLER_COUNT];

<span class="enscript-comment">/* namespace fsctl functions */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">nspace_flags_matches_handler</span>(uint32_t event_flags, nspace_type_t nspace_type);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">nspace_item_flags_for_type</span>(nspace_type_t nspace_type);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">nspace_open_flags_for_type</span>(nspace_type_t nspace_type);
<span class="enscript-type">static</span> nspace_type_t <span class="enscript-function-name">nspace_type_for_op</span>(uint64_t op);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">nspace_is_special_process</span>(<span class="enscript-type">struct</span> proc *proc);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vn_open_with_vp</span>(vnode_t vp, <span class="enscript-type">int</span> fmode, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wait_for_namespace_event</span>(namespace_handler_data *nhd, nspace_type_t nspace_type);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">validate_namespace_args</span> (<span class="enscript-type">int</span> is64bit, <span class="enscript-type">int</span> size);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">process_namespace_fsctl</span>(nspace_type_t nspace_type, <span class="enscript-type">int</span> is64bit, u_int size, caddr_t data);


<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">nspace_flags_matches_handler</span>(uint32_t event_flags, nspace_type_t nspace_type)
{
	<span class="enscript-keyword">switch</span>(nspace_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NSPACE_HANDLER_NSPACE</span>:
			<span class="enscript-keyword">return</span> (event_flags &amp; NSPACE_ITEM_ALL_EVENT_TYPES) == NSPACE_ITEM_NSPACE_EVENT;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NSPACE_HANDLER_SNAPSHOT</span>:
			<span class="enscript-keyword">return</span> (event_flags &amp; NSPACE_ITEM_ALL_EVENT_TYPES) == NSPACE_ITEM_SNAPSHOT_EVENT;
		<span class="enscript-reference">default</span>:
			printf(<span class="enscript-string">&quot;nspace_flags_matches_handler: invalid type %u\n&quot;</span>, (<span class="enscript-type">int</span>)nspace_type);
			<span class="enscript-keyword">return</span> 0;
	}
}

<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">nspace_item_flags_for_type</span>(nspace_type_t nspace_type)
{
	<span class="enscript-keyword">switch</span>(nspace_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NSPACE_HANDLER_NSPACE</span>:
			<span class="enscript-keyword">return</span> NSPACE_ITEM_NSPACE_EVENT;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NSPACE_HANDLER_SNAPSHOT</span>:
			<span class="enscript-keyword">return</span> NSPACE_ITEM_SNAPSHOT_EVENT;
		<span class="enscript-reference">default</span>:
			printf(<span class="enscript-string">&quot;nspace_item_flags_for_type: invalid type %u\n&quot;</span>, (<span class="enscript-type">int</span>)nspace_type);
			<span class="enscript-keyword">return</span> 0;
	}
}

<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">nspace_open_flags_for_type</span>(nspace_type_t nspace_type)
{
	<span class="enscript-keyword">switch</span>(nspace_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NSPACE_HANDLER_NSPACE</span>:
			<span class="enscript-keyword">return</span> FREAD | FWRITE | O_EVTONLY;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NSPACE_HANDLER_SNAPSHOT</span>:
			<span class="enscript-keyword">return</span> FREAD | O_EVTONLY;
		<span class="enscript-reference">default</span>:
			printf(<span class="enscript-string">&quot;nspace_open_flags_for_type: invalid type %u\n&quot;</span>, (<span class="enscript-type">int</span>)nspace_type);
			<span class="enscript-keyword">return</span> 0;
	}
}

<span class="enscript-type">static</span> inline nspace_type_t <span class="enscript-function-name">nspace_type_for_op</span>(uint64_t op)
{
	<span class="enscript-keyword">switch</span>(op &amp; NAMESPACE_HANDLER_EVENT_TYPE_MASK) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NAMESPACE_HANDLER_NSPACE_EVENT</span>:
			<span class="enscript-keyword">return</span> NSPACE_HANDLER_NSPACE;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NAMESPACE_HANDLER_SNAPSHOT_EVENT</span>:
			<span class="enscript-keyword">return</span> NSPACE_HANDLER_SNAPSHOT;
		<span class="enscript-reference">default</span>:
			printf(<span class="enscript-string">&quot;nspace_type_for_op: invalid op mask %llx\n&quot;</span>, op &amp; NAMESPACE_HANDLER_EVENT_TYPE_MASK);
			<span class="enscript-keyword">return</span> NSPACE_HANDLER_NSPACE;
	}
}

<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">nspace_is_special_process</span>(<span class="enscript-type">struct</span> proc *proc)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; NSPACE_HANDLER_COUNT; i++) {
		<span class="enscript-keyword">if</span> (proc == nspace_handlers[i].handler_proc)
			<span class="enscript-keyword">return</span> 1;
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nspace_handler_init</span>(<span class="enscript-type">void</span>)
{
	nspace_lock_attr    = lck_attr_alloc_init();
	nspace_group_attr   = lck_grp_attr_alloc_init();
	nspace_mutex_group  = lck_grp_alloc_init(<span class="enscript-string">&quot;nspace-mutex&quot;</span>, nspace_group_attr);
	lck_mtx_init(&amp;nspace_handler_lock, nspace_mutex_group, nspace_lock_attr);
	lck_mtx_init(&amp;nspace_handler_exclusion_lock, nspace_mutex_group, nspace_lock_attr);
	memset(&amp;nspace_items[0], 0, <span class="enscript-keyword">sizeof</span>(nspace_items));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nspace_proc_exit</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> i, event_mask = 0;
	
	<span class="enscript-keyword">for</span> (i = 0; i &lt; NSPACE_HANDLER_COUNT; i++) {
		<span class="enscript-keyword">if</span> (p == nspace_handlers[i].handler_proc) {
			event_mask |= nspace_item_flags_for_type(i);
			nspace_handlers[i].handler_tid = 0;
			nspace_handlers[i].handler_proc = NULL;
		}
	}

	<span class="enscript-keyword">if</span> (event_mask == 0) {
		<span class="enscript-keyword">return</span>;
	}
	
	<span class="enscript-keyword">if</span> (event_mask &amp; NSPACE_ITEM_SNAPSHOT_EVENT) {
		<span class="enscript-comment">// if this process was the snapshot handler, zero snapshot_timeout
</span>		snapshot_timestamp = 0;
	}
	
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// unblock anyone that's waiting for the handler that died
</span>	<span class="enscript-comment">//
</span>	lck_mtx_lock(&amp;nspace_handler_lock);
	<span class="enscript-keyword">for</span>(i=0; i &lt; MAX_NSPACE_ITEMS; i++) {
		<span class="enscript-keyword">if</span> (nspace_items[i].flags &amp; (NSPACE_ITEM_NEW | NSPACE_ITEM_PROCESSING)) {

			<span class="enscript-keyword">if</span> ( nspace_items[i].flags &amp; event_mask ) {

				<span class="enscript-keyword">if</span> (nspace_items[i].vp &amp;&amp; (nspace_items[i].vp-&gt;v_flag &amp; VNEEDSSNAPSHOT)) {
					vnode_lock_spin(nspace_items[i].vp);
					nspace_items[i].vp-&gt;v_flag &amp;= ~VNEEDSSNAPSHOT;
					vnode_unlock(nspace_items[i].vp);
				}
				nspace_items[i].vp = NULL;
				nspace_items[i].vid = 0;
				nspace_items[i].flags = NSPACE_ITEM_DONE;
				nspace_items[i].token = 0;
				
				wakeup((caddr_t)&amp;(nspace_items[i].vp));
			}
		}
	}
	
	wakeup((caddr_t)&amp;nspace_item_idx);
	lck_mtx_unlock(&amp;nspace_handler_lock);
}


<span class="enscript-type">int</span> 
<span class="enscript-function-name">resolve_nspace_item</span>(<span class="enscript-type">struct</span> vnode *vp, uint64_t op)
{
	<span class="enscript-keyword">return</span> resolve_nspace_item_ext(vp, op, NULL);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">resolve_nspace_item_ext</span>(<span class="enscript-type">struct</span> vnode *vp, uint64_t op, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">int</span> i, error, keep_waiting;
	<span class="enscript-type">struct</span> timespec ts;
	nspace_type_t nspace_type = nspace_type_for_op(op);

	<span class="enscript-comment">// only allow namespace events on regular files, directories and symlinks.
</span>	<span class="enscript-keyword">if</span> (vp-&gt;v_type != VREG &amp;&amp; vp-&gt;v_type != VDIR &amp;&amp; vp-&gt;v_type != VLNK) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if this is a snapshot event and the vnode is on a
</span>	<span class="enscript-comment">// disk image just pretend nothing happened since any
</span>	<span class="enscript-comment">// change to the disk image will cause the disk image
</span>	<span class="enscript-comment">// itself to get backed up and this avoids multi-way
</span>	<span class="enscript-comment">// deadlocks between the snapshot handler and the ever
</span>	<span class="enscript-comment">// popular diskimages-helper process.  the variable
</span>	<span class="enscript-comment">// nspace_allow_virtual_devs allows this behavior to
</span>	<span class="enscript-comment">// be overridden (for use by the Mobile TimeMachine
</span>	<span class="enscript-comment">// testing infrastructure which uses disk images)
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (   (op &amp; NAMESPACE_HANDLER_SNAPSHOT_EVENT)
	    &amp;&amp; (vp-&gt;v_mount != NULL)
	    &amp;&amp; (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_VIRTUALDEV)
	    &amp;&amp; !nspace_allow_virtual_devs) {

		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">// if (thread_tid(current_thread()) == namespace_handler_tid) {
</span>	<span class="enscript-keyword">if</span> (nspace_handlers[nspace_type].handler_proc == NULL) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (nspace_is_special_process(current_proc())) {
		<span class="enscript-keyword">return</span> EDEADLK;
	}

	lck_mtx_lock(&amp;nspace_handler_lock);

<span class="enscript-reference">retry</span>:
	<span class="enscript-keyword">for</span>(i=0; i &lt; MAX_NSPACE_ITEMS; i++) {
		<span class="enscript-keyword">if</span> (vp == nspace_items[i].vp &amp;&amp; op == nspace_items[i].op) {
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (i &gt;= MAX_NSPACE_ITEMS) {
		<span class="enscript-keyword">for</span>(i=0; i &lt; MAX_NSPACE_ITEMS; i++) {
			<span class="enscript-keyword">if</span> (nspace_items[i].flags == 0) {
				<span class="enscript-keyword">break</span>;
			}
		}
	} <span class="enscript-keyword">else</span> {
		nspace_items[i].refcount++;
	}
	
	<span class="enscript-keyword">if</span> (i &gt;= MAX_NSPACE_ITEMS) {
		ts.tv_sec = nspace_handler_timeout;
		ts.tv_nsec = 0;

		error = msleep((caddr_t)&amp;nspace_token_id, &amp;nspace_handler_lock, PVFS|PCATCH, <span class="enscript-string">&quot;nspace-no-space&quot;</span>, &amp;ts);
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-comment">// an entry got free'd up, go see if we can get a slot
</span>			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		} <span class="enscript-keyword">else</span> {
			lck_mtx_unlock(&amp;nspace_handler_lock);
			<span class="enscript-keyword">return</span> error;
		}
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if it didn't already exist, add it.  if it did exist
</span>	<span class="enscript-comment">// we'll get woken up when someone does a wakeup() on
</span>	<span class="enscript-comment">// the slot in the nspace_items table.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (vp != nspace_items[i].vp) {
		nspace_items[i].vp = vp;
		nspace_items[i].arg = (arg == NSPACE_REARM_NO_ARG) ? NULL : arg;  <span class="enscript-comment">// arg is {NULL, true, uio *} - only pass uio thru to the user
</span>		nspace_items[i].op = op;
		nspace_items[i].vid = vnode_vid(vp);
		nspace_items[i].flags = NSPACE_ITEM_NEW;
		nspace_items[i].flags |= nspace_item_flags_for_type(nspace_type);
		<span class="enscript-keyword">if</span> (nspace_items[i].flags &amp; NSPACE_ITEM_SNAPSHOT_EVENT) {
			<span class="enscript-keyword">if</span> (arg) {
				vnode_lock_spin(vp);
				vp-&gt;v_flag |= VNEEDSSNAPSHOT;
				vnode_unlock(vp);
			}
		}

		nspace_items[i].token = 0;
		nspace_items[i].refcount = 1;
		
		wakeup((caddr_t)&amp;nspace_item_idx);
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// Now go to sleep until the handler does a wakeup on this
</span>	<span class="enscript-comment">// slot in the nspace_items table (or we timeout).
</span>	<span class="enscript-comment">//
</span>	keep_waiting = 1;
	<span class="enscript-keyword">while</span>(keep_waiting) {
		ts.tv_sec = nspace_handler_timeout;
		ts.tv_nsec = 0;
		error = msleep((caddr_t)&amp;(nspace_items[i].vp), &amp;nspace_handler_lock, PVFS|PCATCH, <span class="enscript-string">&quot;namespace-done&quot;</span>, &amp;ts);

		<span class="enscript-keyword">if</span> (nspace_items[i].flags &amp; NSPACE_ITEM_DONE) {
			error = 0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nspace_items[i].flags &amp; NSPACE_ITEM_CANCELLED) {
			error = nspace_items[i].token;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == EWOULDBLOCK || error == ETIMEDOUT) {
			<span class="enscript-keyword">if</span> (nspace_items[i].flags &amp; NSPACE_ITEM_RESET_TIMER) {
				nspace_items[i].flags &amp;= ~NSPACE_ITEM_RESET_TIMER;
				<span class="enscript-keyword">continue</span>;
			} <span class="enscript-keyword">else</span> {
				error = ETIMEDOUT;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-comment">// hmmm, why did we get woken up?
</span>			printf(<span class="enscript-string">&quot;woken up for token %d but it's not done, cancelled or timedout and error == 0.\n&quot;</span>,
			       nspace_items[i].token);
		} 

		<span class="enscript-keyword">if</span> (--nspace_items[i].refcount == 0) {
			nspace_items[i].vp = NULL;     <span class="enscript-comment">// clear this so that no one will match on it again
</span>			nspace_items[i].arg = NULL;
			nspace_items[i].token = 0;     <span class="enscript-comment">// clear this so that the handler will not find it anymore
</span>			nspace_items[i].flags = 0;     <span class="enscript-comment">// this clears it for re-use
</span>		}
		wakeup(&amp;nspace_token_id);
		keep_waiting = 0;
	}

	lck_mtx_unlock(&amp;nspace_handler_lock);

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">get_nspace_item_status</span>(<span class="enscript-type">struct</span> vnode *vp, int32_t *status)
{
	<span class="enscript-type">int</span> i;

	lck_mtx_lock(&amp;nspace_handler_lock);
	<span class="enscript-keyword">for</span>(i=0; i &lt; MAX_NSPACE_ITEMS; i++) {
		<span class="enscript-keyword">if</span> (nspace_items[i].vp == vp) {
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (i &gt;= MAX_NSPACE_ITEMS) {
		lck_mtx_unlock(&amp;nspace_handler_lock);
		<span class="enscript-keyword">return</span> ENOENT;
	}

	*status = nspace_items[i].flags;
	lck_mtx_unlock(&amp;nspace_handler_lock);
	<span class="enscript-keyword">return</span> 0;
}
	

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">build_volfs_path</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> *len)
{
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">int</span> ret;

	VATTR_INIT(&amp;va);
	VATTR_WANTED(&amp;va, va_fsid);
	VATTR_WANTED(&amp;va, va_fileid);

	<span class="enscript-keyword">if</span> (vnode_getattr(vp, &amp;va, vfs_context_kernel()) != 0) {
		*len = snprintf(path, *len, <span class="enscript-string">&quot;/non/existent/path/because/vnode_getattr/failed&quot;</span>) + 1;
		ret = -1;
	} <span class="enscript-keyword">else</span> {
		*len = snprintf(path, *len, <span class="enscript-string">&quot;/.vol/%d/%lld&quot;</span>, (dev_t)va.va_fsid, va.va_fileid) + 1;
		ret = 0;
	}

	<span class="enscript-keyword">return</span> ret;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">//
</span><span class="enscript-comment">// Note: this function does NOT check permissions on all of the
</span><span class="enscript-comment">// parent directories leading to this vnode.  It should only be
</span><span class="enscript-comment">// called on behalf of a root process.  Otherwise a process may
</span><span class="enscript-comment">// get access to a file because the file itself is readable even
</span><span class="enscript-comment">// though its parent directories would prevent access.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vn_open_with_vp</span>(vnode_t vp, <span class="enscript-type">int</span> fmode, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error, action;

	<span class="enscript-keyword">if</span> ((error = suser(kauth_cred_get(), &amp;(current_proc()-&gt;p_acflag)))) {
		<span class="enscript-keyword">return</span> error;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_open(ctx, vp, fmode);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* compute action to be authorized */</span>
	action = 0;
	<span class="enscript-keyword">if</span> (fmode &amp; FREAD) {
		action |= KAUTH_VNODE_READ_DATA;
	}
	<span class="enscript-keyword">if</span> (fmode &amp; (FWRITE | O_TRUNC)) {
		<span class="enscript-comment">/*
		 * If we are writing, appending, and not truncating,
		 * indicate that we are appending so that if the
		 * UF_APPEND or SF_APPEND bits are set, we do not deny
		 * the open.
		 */</span>
		<span class="enscript-keyword">if</span> ((fmode &amp; O_APPEND) &amp;&amp; !(fmode &amp; O_TRUNC)) {
			action |= KAUTH_VNODE_APPEND_DATA;
		} <span class="enscript-keyword">else</span> {
			action |= KAUTH_VNODE_WRITE_DATA;
		}
	}

	<span class="enscript-keyword">if</span> ((error = vnode_authorize(vp, NULL, action, ctx)) != 0)
		<span class="enscript-keyword">return</span> error;
		

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if the vnode is tagged VOPENEVT and the current process
</span>	<span class="enscript-comment">// has the P_CHECKOPENEVT flag set, then we or in the O_EVTONLY
</span>	<span class="enscript-comment">// flag to the open mode so that this open won't count against
</span>	<span class="enscript-comment">// the vnode when carbon delete() does a vnode_isinuse() to see
</span>	<span class="enscript-comment">// if a file is currently in use.  this allows spotlight
</span>	<span class="enscript-comment">// importers to not interfere with carbon apps that depend on
</span>	<span class="enscript-comment">// the no-delete-if-busy semantics of carbon delete().
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VOPENEVT) &amp;&amp; (current_proc()-&gt;p_flag &amp; P_CHECKOPENEVT)) {
		fmode |= O_EVTONLY;
	}

	<span class="enscript-keyword">if</span> ( (error = VNOP_OPEN(vp, fmode, ctx)) ) {
		<span class="enscript-keyword">return</span> error;
	}
	<span class="enscript-keyword">if</span> ( (error = vnode_ref_ext(vp, fmode, 0)) ) {
		VNOP_CLOSE(vp, fmode, ctx);
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-comment">/* Call out to allow 3rd party notification of open. 
	 * Ignore result of kauth_authorize_fileop call.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_vnode_notify_open(ctx, vp, fmode);
#<span class="enscript-reference">endif</span>
	kauth_authorize_fileop(vfs_context_ucred(ctx), KAUTH_FILEOP_OPEN, 
			       (uintptr_t)vp, 0);


	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">wait_for_namespace_event</span>(namespace_handler_data *nhd, nspace_type_t nspace_type)
{
	<span class="enscript-type">int</span> i, error=0, unblock=0;
	task_t curtask;
	
	lck_mtx_lock(&amp;nspace_handler_exclusion_lock);
	<span class="enscript-keyword">if</span> (nspace_handlers[nspace_type].handler_busy) {
		lck_mtx_unlock(&amp;nspace_handler_exclusion_lock);
		<span class="enscript-keyword">return</span> EBUSY;
	}
	nspace_handlers[nspace_type].handler_busy = 1;
	lck_mtx_unlock(&amp;nspace_handler_exclusion_lock);
	
	<span class="enscript-comment">/* 
	 * Any process that gets here will be one of the namespace handlers.
	 * As such, they should be prevented from acquiring DMG vnodes during vnode reclamation
	 * as we can cause deadlocks to occur, because the namespace handler may prevent
	 * VNOP_INACTIVE from proceeding.  Mark the current task as a P_DEPENDENCY_CAPABLE 
	 * process.
	 */</span>
	curtask = current_task();
	bsd_set_dependency_capable (curtask);	
	
	lck_mtx_lock(&amp;nspace_handler_lock);
	<span class="enscript-keyword">if</span> (nspace_handlers[nspace_type].handler_proc == NULL) {
		nspace_handlers[nspace_type].handler_tid = thread_tid(current_thread());
		nspace_handlers[nspace_type].handler_proc = current_proc();
	}
	
	<span class="enscript-keyword">while</span> (error == 0) {
		
		<span class="enscript-keyword">for</span>(i=0; i &lt; MAX_NSPACE_ITEMS; i++) {
			<span class="enscript-keyword">if</span> (nspace_items[i].flags &amp; NSPACE_ITEM_NEW) {
				<span class="enscript-keyword">if</span> (!nspace_flags_matches_handler(nspace_items[i].flags, nspace_type)) {
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">break</span>;
			}
		}
		
		<span class="enscript-keyword">if</span> (i &lt; MAX_NSPACE_ITEMS) {
			nspace_items[i].flags  &amp;= ~NSPACE_ITEM_NEW;
			nspace_items[i].flags  |= NSPACE_ITEM_PROCESSING;
			nspace_items[i].token  = ++nspace_token_id;
			
			<span class="enscript-keyword">if</span> (nspace_items[i].vp) {
				<span class="enscript-type">struct</span> fileproc *fp;
				int32_t indx, fmode;
				<span class="enscript-type">struct</span> proc *p = current_proc();
				vfs_context_t ctx = vfs_context_current();
				<span class="enscript-type">struct</span> vnode_attr va;


				<span class="enscript-comment">/* 
				 * Use vnode pointer to acquire a file descriptor for
				 * hand-off to userland
				 */</span>
				fmode = nspace_open_flags_for_type(nspace_type);
				error = vnode_getwithvid(nspace_items[i].vp, nspace_items[i].vid);
				<span class="enscript-keyword">if</span> (error) {
					unblock = 1;
					<span class="enscript-keyword">break</span>;
				}
				error = vn_open_with_vp(nspace_items[i].vp, fmode, ctx);
				<span class="enscript-keyword">if</span> (error) {
					unblock = 1;
					vnode_put(nspace_items[i].vp);
					<span class="enscript-keyword">break</span>;
				}
				
				<span class="enscript-keyword">if</span> ((error = falloc(p, &amp;fp, &amp;indx, ctx))) {
					vn_close(nspace_items[i].vp, fmode, ctx);
					vnode_put(nspace_items[i].vp);
					unblock = 1;
					<span class="enscript-keyword">break</span>;
				}
				
				fp-&gt;f_fglob-&gt;fg_flag = fmode;
				fp-&gt;f_fglob-&gt;fg_ops = &amp;vnops;
				fp-&gt;f_fglob-&gt;fg_data = (caddr_t)nspace_items[i].vp;
				
				proc_fdlock(p);
				procfdtbl_releasefd(p, indx, NULL);
				fp_drop(p, indx, fp, 1);
				proc_fdunlock(p);	

				<span class="enscript-comment">/* 
				 * All variants of the namespace handler struct support these three fields:
				 * token, flags, and the FD pointer
				 */</span>
				error = copyout(&amp;nspace_items[i].token, nhd-&gt;token, <span class="enscript-keyword">sizeof</span>(uint32_t));
				error = copyout(&amp;nspace_items[i].op, nhd-&gt;flags, <span class="enscript-keyword">sizeof</span>(uint64_t));
				error = copyout(&amp;indx, nhd-&gt;fdptr, <span class="enscript-keyword">sizeof</span>(uint32_t));

				<span class="enscript-comment">/* 
				 * Handle optional fields:
				 * extended version support an info ptr (offset, length), and the
				 * 
				 * namedata version supports a unique per-link object ID
				 *
				 */</span>
				<span class="enscript-keyword">if</span> (nhd-&gt;infoptr) {
					uio_t uio = (uio_t)nspace_items[i].arg;
					uint64_t u_offset, u_length;
					
					<span class="enscript-keyword">if</span> (uio) {
						u_offset = uio_offset(uio);
						u_length = uio_resid(uio);
					} <span class="enscript-keyword">else</span> {
						u_offset = 0;
						u_length = 0;
					}						
					error = copyout(&amp;u_offset, nhd-&gt;infoptr, <span class="enscript-keyword">sizeof</span>(uint64_t));
					error = copyout(&amp;u_length, nhd-&gt;infoptr+<span class="enscript-keyword">sizeof</span>(uint64_t), <span class="enscript-keyword">sizeof</span>(uint64_t));
				}

				<span class="enscript-keyword">if</span> (nhd-&gt;objid) {	
					VATTR_INIT(&amp;va);
					VATTR_WANTED(&amp;va, va_linkid);
					error = vnode_getattr(nspace_items[i].vp, &amp;va, ctx);
					<span class="enscript-keyword">if</span> (error == 0 ) {
						uint64_t linkid = 0;
						<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED (&amp;va, va_linkid)) {
							linkid = (uint64_t)va.va_linkid;
						}
						error = copyout (&amp;linkid, nhd-&gt;objid, <span class="enscript-keyword">sizeof</span>(uint64_t));
					}
				}

				<span class="enscript-keyword">if</span> (error) {
					vn_close(nspace_items[i].vp, fmode, ctx);
					fp_free(p, indx, fp);
					unblock = 1;
				}
				
				vnode_put(nspace_items[i].vp);
				
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> {
				printf(<span class="enscript-string">&quot;wait_for_nspace_event: failed (nspace_items[%d] == %p error %d, name %s)\n&quot;</span>,
				       i, nspace_items[i].vp, error, nspace_items[i].vp-&gt;v_name);
			}
			
		} <span class="enscript-keyword">else</span> {
			error = msleep((caddr_t)&amp;nspace_item_idx, &amp;nspace_handler_lock, PVFS|PCATCH, <span class="enscript-string">&quot;namespace-items&quot;</span>, 0);
			<span class="enscript-keyword">if</span> ((nspace_type == NSPACE_HANDLER_SNAPSHOT) &amp;&amp; (snapshot_timestamp == 0 || snapshot_timestamp == ~0)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			
		}
	}
	
	<span class="enscript-keyword">if</span> (unblock) {
		<span class="enscript-keyword">if</span> (nspace_items[i].vp &amp;&amp; (nspace_items[i].vp-&gt;v_flag &amp; VNEEDSSNAPSHOT)) {
			vnode_lock_spin(nspace_items[i].vp);
			nspace_items[i].vp-&gt;v_flag &amp;= ~VNEEDSSNAPSHOT;
			vnode_unlock(nspace_items[i].vp);
		}
		nspace_items[i].vp = NULL;
		nspace_items[i].vid = 0;
		nspace_items[i].flags = NSPACE_ITEM_DONE;
		nspace_items[i].token = 0;
		
		wakeup((caddr_t)&amp;(nspace_items[i].vp));
	}
	
	<span class="enscript-keyword">if</span> (nspace_type == NSPACE_HANDLER_SNAPSHOT) {
		<span class="enscript-comment">// just go through every snapshot event and unblock it immediately.
</span>		<span class="enscript-keyword">if</span> (error &amp;&amp; (snapshot_timestamp == 0 || snapshot_timestamp == ~0)) {
			<span class="enscript-keyword">for</span>(i=0; i &lt; MAX_NSPACE_ITEMS; i++) {
				<span class="enscript-keyword">if</span> (nspace_items[i].flags &amp; NSPACE_ITEM_NEW) {
					<span class="enscript-keyword">if</span> (nspace_flags_matches_handler(nspace_items[i].flags, nspace_type)) {
						nspace_items[i].vp = NULL;
						nspace_items[i].vid = 0;
						nspace_items[i].flags = NSPACE_ITEM_DONE;
						nspace_items[i].token = 0;
						
						wakeup((caddr_t)&amp;(nspace_items[i].vp));					
					}
				}
			}
		}
	}
	
	lck_mtx_unlock(&amp;nspace_handler_lock);
	
	lck_mtx_lock(&amp;nspace_handler_exclusion_lock);
	nspace_handlers[nspace_type].handler_busy = 0;
	lck_mtx_unlock(&amp;nspace_handler_exclusion_lock);
	
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">validate_namespace_args</span> (<span class="enscript-type">int</span> is64bit, <span class="enscript-type">int</span> size) {

	<span class="enscript-keyword">if</span> (is64bit) {
		<span class="enscript-comment">/* Must be one of these */</span>
		<span class="enscript-keyword">if</span> (size == <span class="enscript-keyword">sizeof</span>(user64_namespace_handler_info)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">sizeok</span>;
		}
		<span class="enscript-keyword">if</span> (size == <span class="enscript-keyword">sizeof</span>(user64_namespace_handler_info_ext)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">sizeok</span>;
		}
		<span class="enscript-keyword">if</span> (size == <span class="enscript-keyword">sizeof</span>(user64_namespace_handler_data)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">sizeok</span>;
		}
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* 32 bit -- must be one of these */</span>
		<span class="enscript-keyword">if</span> (size == <span class="enscript-keyword">sizeof</span>(user32_namespace_handler_info)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">sizeok</span>;
		}
		<span class="enscript-keyword">if</span> (size == <span class="enscript-keyword">sizeof</span>(user32_namespace_handler_info_ext)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">sizeok</span>;
		}
		<span class="enscript-keyword">if</span> (size == <span class="enscript-keyword">sizeof</span>(user32_namespace_handler_data)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">sizeok</span>;
		}
		<span class="enscript-keyword">return</span> EINVAL;
	}

<span class="enscript-reference">sizeok</span>:

	<span class="enscript-keyword">return</span> 0;

}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">process_namespace_fsctl</span>(nspace_type_t nspace_type, <span class="enscript-type">int</span> is64bit, u_int size, caddr_t data)
{
	<span class="enscript-type">int</span> error = 0;
	namespace_handler_data nhd;
	
	bzero (&amp;nhd, <span class="enscript-keyword">sizeof</span>(namespace_handler_data));

	<span class="enscript-keyword">if</span> (nspace_type == NSPACE_HANDLER_SNAPSHOT &amp;&amp; 
			(snapshot_timestamp == 0 || snapshot_timestamp == ~0)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	<span class="enscript-keyword">if</span> ((error = suser(kauth_cred_get(), &amp;(current_proc()-&gt;p_acflag)))) {
		<span class="enscript-keyword">return</span> error;
	}
	
	error = validate_namespace_args (is64bit, size);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}
	
	<span class="enscript-comment">/* Copy in the userland pointers into our kernel-only struct */</span>

	<span class="enscript-keyword">if</span> (is64bit) {
		<span class="enscript-comment">/* 64 bit userland structures */</span>
		nhd.token = (user_addr_t)((user64_namespace_handler_info *)data)-&gt;token;
		nhd.flags = (user_addr_t)((user64_namespace_handler_info *)data)-&gt;flags;
		nhd.fdptr = (user_addr_t)((user64_namespace_handler_info *)data)-&gt;fdptr;

		<span class="enscript-comment">/* If the size is greater than the standard info struct, add in extra fields */</span>
		<span class="enscript-keyword">if</span> (size &gt; (<span class="enscript-keyword">sizeof</span>(user64_namespace_handler_info))) {
			<span class="enscript-keyword">if</span> (size &gt;= (<span class="enscript-keyword">sizeof</span>(user64_namespace_handler_info_ext))) {
				nhd.infoptr = (user_addr_t)((user64_namespace_handler_info_ext *)data)-&gt;infoptr;
			}
			<span class="enscript-keyword">if</span> (size == (<span class="enscript-keyword">sizeof</span>(user64_namespace_handler_data))) {
				nhd.objid = (user_addr_t)((user64_namespace_handler_data*)data)-&gt;objid;
			}
			<span class="enscript-comment">/* Otherwise the fields were pre-zeroed when we did the bzero above. */</span>
		}
	} 
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* 32 bit userland structures */</span>
		nhd.token = CAST_USER_ADDR_T(((user32_namespace_handler_info *)data)-&gt;token);
		nhd.flags = CAST_USER_ADDR_T(((user32_namespace_handler_info *)data)-&gt;flags);
		nhd.fdptr = CAST_USER_ADDR_T(((user32_namespace_handler_info *)data)-&gt;fdptr);
		
		<span class="enscript-keyword">if</span> (size &gt; (<span class="enscript-keyword">sizeof</span>(user32_namespace_handler_info))) {
			<span class="enscript-keyword">if</span> (size &gt;= (<span class="enscript-keyword">sizeof</span>(user32_namespace_handler_info_ext))) {
				nhd.infoptr = CAST_USER_ADDR_T(((user32_namespace_handler_info_ext *)data)-&gt;infoptr);
			}
			<span class="enscript-keyword">if</span> (size == (<span class="enscript-keyword">sizeof</span>(user32_namespace_handler_data))) {
				nhd.objid = (user_addr_t)((user32_namespace_handler_data*)data)-&gt;objid;
			}
			<span class="enscript-comment">/* Otherwise the fields were pre-zeroed when we did the bzero above. */</span>
		}
	}
	
	<span class="enscript-keyword">return</span> wait_for_namespace_event(&amp;nhd, nspace_type);
}

<span class="enscript-comment">/*
 * Make a filesystem-specific control call:
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fsctl_internal</span>(proc_t p, vnode_t *arg_vp, u_long cmd, user_addr_t udata, u_long options, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error=0;
	boolean_t is64bit;
	u_int size;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">STK_PARAMS</span> 128
	<span class="enscript-type">char</span> stkbuf[STK_PARAMS];
	caddr_t data, memp;
	vnode_t vp = *arg_vp;

	size = IOCPARM_LEN(cmd);
	<span class="enscript-keyword">if</span> (size &gt; IOCPARM_MAX) <span class="enscript-keyword">return</span> (EINVAL);

	is64bit = proc_is64bit(p);

	memp = NULL;


	<span class="enscript-comment">/*
	 * ensure the buffer is large enough for underlying calls
	 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HFSIOC_GETPATH</span>
	<span class="enscript-type">typedef</span> <span class="enscript-type">char</span> pn_t[MAXPATHLEN];
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFSIOC_GETPATH</span>  _IOWR(<span class="enscript-string">'h'</span>, 13, pn_t)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HFS_GETPATH</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_GETPATH</span>  IOCBASECMD(HFSIOC_GETPATH)
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (IOCBASECMD(cmd) == HFS_GETPATH) {
		<span class="enscript-comment">/* Round up to MAXPATHLEN regardless of user input */</span>
		size = MAXPATHLEN;
	}

	<span class="enscript-keyword">if</span> (size &gt; <span class="enscript-keyword">sizeof</span> (stkbuf)) {
		<span class="enscript-keyword">if</span> ((memp = (caddr_t)kalloc(size)) == 0) <span class="enscript-keyword">return</span> ENOMEM;
		data = memp;
	} <span class="enscript-keyword">else</span> {
		data = &amp;stkbuf[0];
	};
	
	<span class="enscript-keyword">if</span> (cmd &amp; IOC_IN) {
		<span class="enscript-keyword">if</span> (size) {
			error = copyin(udata, data, size);
			<span class="enscript-keyword">if</span> (error) { 
				<span class="enscript-keyword">if</span> (memp) {
					kfree (memp, size);	
				}
				<span class="enscript-keyword">return</span> error;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (is64bit) {
				*(user_addr_t *)data = udata;
			}
			<span class="enscript-keyword">else</span> {
				*(uint32_t *)data = (uint32_t)udata;
			}
		};
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((cmd &amp; IOC_OUT) &amp;&amp; size) {
		<span class="enscript-comment">/*
		 * Zero the buffer so the user always
		 * gets back something deterministic.
		 */</span>
		bzero(data, size);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd &amp; IOC_VOID) {
		<span class="enscript-keyword">if</span> (is64bit) {
			*(user_addr_t *)data = udata;
		}
		<span class="enscript-keyword">else</span> {
			*(uint32_t *)data = (uint32_t)udata;
		}
	}

	<span class="enscript-comment">/* Check to see if it's a generic command */</span>
	<span class="enscript-keyword">switch</span> (IOCBASECMD(cmd)) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSCTL_SYNC_VOLUME</span>: {
			mount_t mp = vp-&gt;v_mount;
			<span class="enscript-type">int</span> arg = *(uint32_t*)data;

			<span class="enscript-comment">/* record vid of vp so we can drop it below. */</span>
			uint32_t vvid = vp-&gt;v_id;

			<span class="enscript-comment">/*
			 * Then grab mount_iterref so that we can release the vnode.
			 * Without this, a thread may call vnode_iterate_prepare then
			 * get into a deadlock because we've never released the root vp
			 */</span>
			error = mount_iterref (mp, 0);
			<span class="enscript-keyword">if</span> (error)  {
				<span class="enscript-keyword">break</span>;
			}
			vnode_put(vp);

			<span class="enscript-comment">/* issue the sync for this volume */</span>
			(<span class="enscript-type">void</span>)sync_callback(mp, (arg &amp; FSCTL_SYNC_WAIT) ? &amp;arg : NULL);

			<span class="enscript-comment">/* 
			 * Then release the mount_iterref once we're done syncing; it's not
			 * needed for the VNOP_IOCTL below
			 */</span>
			mount_iterdrop(mp);

			<span class="enscript-keyword">if</span> (arg &amp; FSCTL_SYNC_FULLSYNC) {
				<span class="enscript-comment">/* re-obtain vnode iocount on the root vp, if possible */</span>
				error = vnode_getwithvid (vp, vvid);
				<span class="enscript-keyword">if</span> (error == 0) {
					error = VNOP_IOCTL(vp, F_FULLFSYNC, (caddr_t)NULL, 0, ctx);
					vnode_put (vp);
				}
			}
			<span class="enscript-comment">/* mark the argument VP as having been released */</span>
			*arg_vp = NULL;
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSCTL_SET_PACKAGE_EXTS</span>: {
			user_addr_t ext_strings;
			uint32_t    num_entries;
			uint32_t    max_width;

			<span class="enscript-keyword">if</span> (   (is64bit &amp;&amp; size != <span class="enscript-keyword">sizeof</span>(user64_package_ext_info))
					|| (is64bit == 0 &amp;&amp; size != <span class="enscript-keyword">sizeof</span>(user32_package_ext_info))) {

				<span class="enscript-comment">// either you're 64-bit and passed a 64-bit struct or
</span>				<span class="enscript-comment">// you're 32-bit and passed a 32-bit struct.  otherwise
</span>				<span class="enscript-comment">// it's not ok.
</span>				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (is64bit) {
				ext_strings = ((user64_package_ext_info *)data)-&gt;strings;
				num_entries = ((user64_package_ext_info *)data)-&gt;num_entries;
				max_width   = ((user64_package_ext_info *)data)-&gt;max_width;
			} <span class="enscript-keyword">else</span> {
				ext_strings = CAST_USER_ADDR_T(((user32_package_ext_info *)data)-&gt;strings);
				num_entries = ((user32_package_ext_info *)data)-&gt;num_entries;
				max_width   = ((user32_package_ext_info *)data)-&gt;max_width;
			}
			error = set_package_extensions_table(ext_strings, num_entries, max_width);
		}
		<span class="enscript-keyword">break</span>;

   		<span class="enscript-comment">/* namespace handlers */</span>	
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSCTL_NAMESPACE_HANDLER_GET</span>: {
			error = process_namespace_fsctl(NSPACE_HANDLER_NSPACE, is64bit, size, data);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* Snapshot handlers */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSCTL_OLD_SNAPSHOT_HANDLER_GET</span>: {
			error = process_namespace_fsctl(NSPACE_HANDLER_SNAPSHOT, is64bit, size, data);
		} 
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSCTL_SNAPSHOT_HANDLER_GET_EXT</span>: {
			error = process_namespace_fsctl(NSPACE_HANDLER_SNAPSHOT, is64bit, size, data);
		}
		<span class="enscript-keyword">break</span>;	

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSCTL_NAMESPACE_HANDLER_UPDATE</span>: {
			uint32_t token, val;
			<span class="enscript-type">int</span> i;

			<span class="enscript-keyword">if</span> ((error = suser(kauth_cred_get(), &amp;(p-&gt;p_acflag)))) {
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (!nspace_is_special_process(p)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			token = ((uint32_t *)data)[0];
			val   = ((uint32_t *)data)[1];

			lck_mtx_lock(&amp;nspace_handler_lock);

			<span class="enscript-keyword">for</span>(i=0; i &lt; MAX_NSPACE_ITEMS; i++) {
				<span class="enscript-keyword">if</span> (nspace_items[i].token == token) {
					<span class="enscript-keyword">break</span>;  <span class="enscript-comment">/* exit for loop, not case stmt */</span>
				}
			}

			<span class="enscript-keyword">if</span> (i &gt;= MAX_NSPACE_ITEMS) {
				error = ENOENT;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">//
</span>				<span class="enscript-comment">// if this bit is set, when resolve_nspace_item() times out
</span>				<span class="enscript-comment">// it will loop and go back to sleep.
</span>				<span class="enscript-comment">//
</span>				nspace_items[i].flags |= NSPACE_ITEM_RESET_TIMER;
			}

			lck_mtx_unlock(&amp;nspace_handler_lock);

			<span class="enscript-keyword">if</span> (error) {
				printf(<span class="enscript-string">&quot;nspace-handler-update: did not find token %u\n&quot;</span>, token);
			}
		} 
		<span class="enscript-keyword">break</span>;
	
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSCTL_NAMESPACE_HANDLER_UNBLOCK</span>: {	
			uint32_t token, val;
			<span class="enscript-type">int</span> i;

			<span class="enscript-keyword">if</span> ((error = suser(kauth_cred_get(), &amp;(p-&gt;p_acflag)))) {
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (!nspace_is_special_process(p)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			token = ((uint32_t *)data)[0];
			val   = ((uint32_t *)data)[1];

			lck_mtx_lock(&amp;nspace_handler_lock);

			<span class="enscript-keyword">for</span>(i=0; i &lt; MAX_NSPACE_ITEMS; i++) {
				<span class="enscript-keyword">if</span> (nspace_items[i].token == token) {
					<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* exit for loop, not case statement */</span>
				}
			}

			<span class="enscript-keyword">if</span> (i &gt;= MAX_NSPACE_ITEMS) {
				printf(<span class="enscript-string">&quot;nspace-handler-unblock: did not find token %u\n&quot;</span>, token);
				error = ENOENT;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (val == 0 &amp;&amp; nspace_items[i].vp) {
					vnode_lock_spin(nspace_items[i].vp);
					nspace_items[i].vp-&gt;v_flag &amp;= ~VNEEDSSNAPSHOT;
					vnode_unlock(nspace_items[i].vp);
				}

				nspace_items[i].vp = NULL;
				nspace_items[i].arg = NULL;
				nspace_items[i].op = 0;
				nspace_items[i].vid = 0;
				nspace_items[i].flags = NSPACE_ITEM_DONE;
				nspace_items[i].token = 0;

				wakeup((caddr_t)&amp;(nspace_items[i].vp));
			}

			lck_mtx_unlock(&amp;nspace_handler_lock);
		} 
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSCTL_NAMESPACE_HANDLER_CANCEL</span>: {
			uint32_t token, val;
			<span class="enscript-type">int</span> i;

			<span class="enscript-keyword">if</span> ((error = suser(kauth_cred_get(), &amp;(p-&gt;p_acflag)))) {
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (!nspace_is_special_process(p)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			token = ((uint32_t *)data)[0];
			val   = ((uint32_t *)data)[1];

			lck_mtx_lock(&amp;nspace_handler_lock);

			<span class="enscript-keyword">for</span>(i=0; i &lt; MAX_NSPACE_ITEMS; i++) {
				<span class="enscript-keyword">if</span> (nspace_items[i].token == token) {
					<span class="enscript-keyword">break</span>;  <span class="enscript-comment">/* exit for loop, not case stmt */</span>
				}
			}

			<span class="enscript-keyword">if</span> (i &gt;= MAX_NSPACE_ITEMS) {
				printf(<span class="enscript-string">&quot;nspace-handler-cancel: did not find token %u\n&quot;</span>, token);
				error = ENOENT;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (nspace_items[i].vp) {
					vnode_lock_spin(nspace_items[i].vp);
					nspace_items[i].vp-&gt;v_flag &amp;= ~VNEEDSSNAPSHOT;
					vnode_unlock(nspace_items[i].vp);
				}

				nspace_items[i].vp = NULL;			
				nspace_items[i].arg = NULL;			
				nspace_items[i].vid = 0;
				nspace_items[i].token = val;
				nspace_items[i].flags &amp;= ~NSPACE_ITEM_PROCESSING;
				nspace_items[i].flags |= NSPACE_ITEM_CANCELLED;			

				wakeup((caddr_t)&amp;(nspace_items[i].vp));
			}

			lck_mtx_unlock(&amp;nspace_handler_lock);
		} 
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSCTL_NAMESPACE_HANDLER_SET_SNAPSHOT_TIME</span>: {
			<span class="enscript-keyword">if</span> ((error = suser(kauth_cred_get(), &amp;(current_proc()-&gt;p_acflag)))) {
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">// we explicitly do not do the namespace_handler_proc check here
</span>
			lck_mtx_lock(&amp;nspace_handler_lock);
			snapshot_timestamp = ((uint32_t *)data)[0];
			wakeup(&amp;nspace_item_idx);
			lck_mtx_unlock(&amp;nspace_handler_lock);
			printf(<span class="enscript-string">&quot;nspace-handler-set-snapshot-time: %d\n&quot;</span>, (<span class="enscript-type">int</span>)snapshot_timestamp);

		} 
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSCTL_NAMESPACE_ALLOW_DMG_SNAPSHOT_EVENTS</span>:
		{
			<span class="enscript-keyword">if</span> ((error = suser(kauth_cred_get(), &amp;(current_proc()-&gt;p_acflag)))) {
				<span class="enscript-keyword">break</span>;
			}

			lck_mtx_lock(&amp;nspace_handler_lock);
			nspace_allow_virtual_devs = ((uint32_t *)data)[0];
			lck_mtx_unlock(&amp;nspace_handler_lock);
			printf(<span class="enscript-string">&quot;nspace-snapshot-handler will%s allow events on disk-images\n&quot;</span>,
					nspace_allow_virtual_devs ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot; NOT&quot;</span>);
			error = 0;

		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSCTL_SET_FSTYPENAME_OVERRIDE</span>: 
		{	
			<span class="enscript-keyword">if</span> ((error = suser(kauth_cred_get(), &amp;(current_proc()-&gt;p_acflag)))) {
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (vp-&gt;v_mount) {
				mount_lock(vp-&gt;v_mount);
				<span class="enscript-keyword">if</span> (data[0] != 0) {
					strlcpy(&amp;vp-&gt;v_mount-&gt;fstypename_override[0], data, MFSTYPENAMELEN);
					vp-&gt;v_mount-&gt;mnt_kern_flag |= MNTK_TYPENAME_OVERRIDE;
					<span class="enscript-keyword">if</span> (vfs_isrdonly(vp-&gt;v_mount) &amp;&amp; strcmp(vp-&gt;v_mount-&gt;fstypename_override, <span class="enscript-string">&quot;mtmfs&quot;</span>) == 0) {
						vp-&gt;v_mount-&gt;mnt_kern_flag |= MNTK_EXTENDED_SECURITY;
						vp-&gt;v_mount-&gt;mnt_kern_flag &amp;= ~MNTK_AUTH_OPAQUE;
					}
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (strcmp(vp-&gt;v_mount-&gt;fstypename_override, <span class="enscript-string">&quot;mtmfs&quot;</span>) == 0) {
						vp-&gt;v_mount-&gt;mnt_kern_flag &amp;= ~MNTK_EXTENDED_SECURITY;
					}
					vp-&gt;v_mount-&gt;mnt_kern_flag &amp;= ~MNTK_TYPENAME_OVERRIDE;
					vp-&gt;v_mount-&gt;fstypename_override[0] = <span class="enscript-string">'\0'</span>;
				}
				mount_unlock(vp-&gt;v_mount);
			}
		}
		<span class="enscript-keyword">break</span>;
	   	
		<span class="enscript-reference">default</span>: {
			<span class="enscript-comment">/* Invoke the filesystem-specific code */</span>
			error = VNOP_IOCTL(vp, IOCBASECMD(cmd), data, options, ctx);
		}

	} <span class="enscript-comment">/* end switch stmt */</span>

	<span class="enscript-comment">/*
	 * if no errors, copy any data to user. Size was
	 * already set and checked above.
	 */</span>
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; (cmd &amp; IOC_OUT) &amp;&amp; size) 
		error = copyout(data, udata, size);
	
	<span class="enscript-keyword">if</span> (memp) {
		kfree(memp, size);
	}
	
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fsctl</span> (proc_t p, <span class="enscript-type">struct</span> fsctl_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nameidata nd;	
	u_long nameiflags;
	vnode_t vp = NULL;
	vfs_context_t ctx = vfs_context_current();

	AUDIT_ARG(cmd, uap-&gt;cmd);
	AUDIT_ARG(value32, uap-&gt;options);
	<span class="enscript-comment">/* Get the vnode for the file we are getting info on:  */</span>
	nameiflags = 0;
	<span class="enscript-keyword">if</span> ((uap-&gt;options &amp; FSOPT_NOFOLLOW) == 0) nameiflags |= FOLLOW;
	NDINIT(&amp;nd, LOOKUP, OP_FSCTL, nameiflags | AUDITVNPATH1,
	       UIO_USERSPACE, uap-&gt;path, ctx);
	<span class="enscript-keyword">if</span> ((error = namei(&amp;nd))) <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	vp = nd.ni_vp;
	nameidone(&amp;nd);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_mount_check_fsctl(ctx, vnode_mount(vp), uap-&gt;cmd);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
#<span class="enscript-reference">endif</span>

	error = fsctl_internal(p, &amp;vp, uap-&gt;cmd, (user_addr_t)uap-&gt;data, uap-&gt;options, ctx);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);
	<span class="enscript-keyword">return</span> error;
}
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ffsctl</span> (proc_t p, <span class="enscript-type">struct</span> ffsctl_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> error;
	vnode_t vp = NULL;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">int</span> fd = -1;

	AUDIT_ARG(fd, uap-&gt;fd);
	AUDIT_ARG(cmd, uap-&gt;cmd);
	AUDIT_ARG(value32, uap-&gt;options);
	
	<span class="enscript-comment">/* Get the vnode for the file we are getting info on:  */</span>
	<span class="enscript-keyword">if</span> ((error = file_vnode(uap-&gt;fd, &amp;vp)))
		<span class="enscript-keyword">return</span> error;
	fd = uap-&gt;fd;
	<span class="enscript-keyword">if</span> ((error = vnode_getwithref(vp))) {
		file_drop(fd);
		<span class="enscript-keyword">return</span> error;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> ((error = mac_mount_check_fsctl(ctx, vnode_mount(vp), uap-&gt;cmd))) {
		file_drop(fd);
		vnode_put(vp);
		<span class="enscript-keyword">return</span> error;
	}
#<span class="enscript-reference">endif</span>

	error = fsctl_internal(p, &amp;vp, uap-&gt;cmd, (user_addr_t)uap-&gt;data, uap-&gt;options, ctx);

	file_drop(fd);

	<span class="enscript-comment">/*validate vp; fsctl_internal() can drop iocount and reset vp to NULL*/</span>
	<span class="enscript-keyword">if</span> (vp) {
		vnode_put(vp);
	}

	<span class="enscript-keyword">return</span> error;
}
<span class="enscript-comment">/* end of fsctl system call */</span>

<span class="enscript-comment">/*
 *  Retrieve the data of an extended attribute.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getxattr</span>(proc_t p, <span class="enscript-type">struct</span> getxattr_args *uap, user_ssize_t *retval)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">char</span> attrname[XATTR_MAXNAMELEN+1];
	vfs_context_t ctx = vfs_context_current();
	uio_t auio = NULL;
	<span class="enscript-type">int</span> spacetype = IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	size_t attrsize = 0;
	size_t namelen;
	u_int32_t nameiflags;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];

	<span class="enscript-keyword">if</span> (uap-&gt;options &amp; (XATTR_NOSECURITY | XATTR_NODEFAULT))
		<span class="enscript-keyword">return</span> (EINVAL);

	nameiflags = (uap-&gt;options &amp; XATTR_NOFOLLOW) ? 0 : FOLLOW;
	NDINIT(&amp;nd, LOOKUP, OP_GETXATTR, nameiflags, spacetype, uap-&gt;path, ctx);
	<span class="enscript-keyword">if</span> ((error = namei(&amp;nd))) {
		<span class="enscript-keyword">return</span> (error);
	}
	vp = nd.ni_vp;
	nameidone(&amp;nd);

	<span class="enscript-keyword">if</span> ((error = copyinstr(uap-&gt;attrname, attrname, <span class="enscript-keyword">sizeof</span>(attrname), &amp;namelen) != 0)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (xattr_protected(attrname)) {
		<span class="enscript-keyword">if</span> (!vfs_context_issuser(ctx) || strcmp(attrname, <span class="enscript-string">&quot;com.apple.system.Security&quot;</span>) != 0) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	<span class="enscript-comment">/*
	 * the specific check for 0xffffffff is a hack to preserve
	 * binaray compatibilty in K64 with applications that discovered
	 * that passing in a buf pointer and a size of -1 resulted in 
	 * just the size of the indicated extended attribute being returned.
	 * this isn't part of the documented behavior, but because of the
	 * original implemtation's check for &quot;uap-&gt;size &gt; 0&quot;, this behavior
	 * was allowed. In K32 that check turned into a signed comparison
	 * even though uap-&gt;size is unsigned...  in K64, we blow by that
	 * check because uap-&gt;size is unsigned and doesn't get sign smeared
	 * in the munger for a 32 bit user app.  we also need to add a 
	 * check to limit the maximum size of the buffer being passed in...
	 * unfortunately, the underlying fileystems seem to just malloc
	 * the requested size even if the actual extended attribute is tiny.
	 * because that malloc is for kernel wired memory, we have to put a
	 * sane limit on it.
	 *
	 * U32 running on K64 will yield 0x00000000ffffffff for uap-&gt;size
	 * U64 running on K64 will yield -1 (64 bits wide)
	 * U32/U64 running on K32 will yield -1 (32 bits wide)
	 */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;size == 0xffffffff || uap-&gt;size == (size_t)-1)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_uio</span>;

	<span class="enscript-keyword">if</span> (uap-&gt;value) {
		<span class="enscript-keyword">if</span> (uap-&gt;size &gt; (size_t)XATTR_MAXSIZE)
			uap-&gt;size = XATTR_MAXSIZE;
		
		auio = uio_createwithbuffer(1, uap-&gt;position, spacetype, UIO_READ,
		                            &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
		uio_addiov(auio, uap-&gt;value, uap-&gt;size);
	}
<span class="enscript-reference">no_uio</span>:
	error = vn_getxattr(vp, attrname, auio, &amp;attrsize, uap-&gt;options, ctx);
<span class="enscript-reference">out</span>:
	vnode_put(vp);

	<span class="enscript-keyword">if</span> (auio) {
		*retval = uap-&gt;size - uio_resid(auio);
	} <span class="enscript-keyword">else</span> {
		*retval = (user_ssize_t)attrsize;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Retrieve the data of an extended attribute.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fgetxattr</span>(proc_t p, <span class="enscript-type">struct</span> fgetxattr_args *uap, user_ssize_t *retval)
{
	vnode_t vp;
	<span class="enscript-type">char</span> attrname[XATTR_MAXNAMELEN+1];
	uio_t auio = NULL;
	<span class="enscript-type">int</span> spacetype = IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	size_t attrsize = 0;
	size_t namelen;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];

	<span class="enscript-keyword">if</span> (uap-&gt;options &amp; (XATTR_NOFOLLOW | XATTR_NOSECURITY | XATTR_NODEFAULT))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> ( (error = file_vnode(uap-&gt;fd, &amp;vp)) ) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(error);
	}
	<span class="enscript-keyword">if</span> ((error = copyinstr(uap-&gt;attrname, attrname, <span class="enscript-keyword">sizeof</span>(attrname), &amp;namelen) != 0)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (xattr_protected(attrname)) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (uap-&gt;value &amp;&amp; uap-&gt;size &gt; 0) {
		auio = uio_createwithbuffer(1, uap-&gt;position, spacetype, UIO_READ,
		                            &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
		uio_addiov(auio, uap-&gt;value, uap-&gt;size);
	}

	error = vn_getxattr(vp, attrname, auio, &amp;attrsize, uap-&gt;options, vfs_context_current());
<span class="enscript-reference">out</span>:
	(<span class="enscript-type">void</span>)vnode_put(vp);
	file_drop(uap-&gt;fd);

	<span class="enscript-keyword">if</span> (auio) {
		*retval = uap-&gt;size - uio_resid(auio);
	} <span class="enscript-keyword">else</span> {
		*retval = (user_ssize_t)attrsize;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Set the data of an extended attribute.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setxattr</span>(proc_t p, <span class="enscript-type">struct</span> setxattr_args *uap, <span class="enscript-type">int</span> *retval)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">char</span> attrname[XATTR_MAXNAMELEN+1];
	vfs_context_t ctx = vfs_context_current();
	uio_t auio = NULL;
	<span class="enscript-type">int</span> spacetype = IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	size_t namelen;
	u_int32_t nameiflags;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];

	<span class="enscript-keyword">if</span> (uap-&gt;options &amp; (XATTR_NOSECURITY | XATTR_NODEFAULT))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> ((error = copyinstr(uap-&gt;attrname, attrname, <span class="enscript-keyword">sizeof</span>(attrname), &amp;namelen) != 0)) {
		<span class="enscript-keyword">if</span> (error == EPERM) {
			<span class="enscript-comment">/* if the string won't fit in attrname, copyinstr emits EPERM */</span>
			<span class="enscript-keyword">return</span> (ENAMETOOLONG);
		}
		<span class="enscript-comment">/* Otherwise return the default error from copyinstr to detect ERANGE, etc */</span>
		<span class="enscript-keyword">return</span> error;
	}
	<span class="enscript-keyword">if</span> (xattr_protected(attrname))
		<span class="enscript-keyword">return</span>(EPERM);
	<span class="enscript-keyword">if</span> (uap-&gt;size != 0 &amp;&amp; uap-&gt;value == 0) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	nameiflags = (uap-&gt;options &amp; XATTR_NOFOLLOW) ? 0 : FOLLOW;
	NDINIT(&amp;nd, LOOKUP, OP_SETXATTR, nameiflags, spacetype, uap-&gt;path, ctx);
	<span class="enscript-keyword">if</span> ((error = namei(&amp;nd))) {
		<span class="enscript-keyword">return</span> (error);
	}
	vp = nd.ni_vp;
	nameidone(&amp;nd);

	auio = uio_createwithbuffer(1, uap-&gt;position, spacetype, UIO_WRITE,
	                            &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, uap-&gt;value, uap-&gt;size);

	error = vn_setxattr(vp, attrname, auio, uap-&gt;options, ctx);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		add_fsevent(FSE_XATTR_MODIFIED, ctx,
		    FSE_ARG_VNODE, vp,
		    FSE_ARG_DONE);
	}
#<span class="enscript-reference">endif</span>
	vnode_put(vp);
	*retval = 0;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Set the data of an extended attribute.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fsetxattr</span>(proc_t p, <span class="enscript-type">struct</span> fsetxattr_args *uap, <span class="enscript-type">int</span> *retval)
{
	vnode_t vp;
	<span class="enscript-type">char</span> attrname[XATTR_MAXNAMELEN+1];
	uio_t auio = NULL;
	<span class="enscript-type">int</span> spacetype = IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	size_t namelen;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	vfs_context_t ctx = vfs_context_current();
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (uap-&gt;options &amp; (XATTR_NOFOLLOW | XATTR_NOSECURITY | XATTR_NODEFAULT))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> ((error = copyinstr(uap-&gt;attrname, attrname, <span class="enscript-keyword">sizeof</span>(attrname), &amp;namelen) != 0)) {
		<span class="enscript-keyword">if</span> (error == EPERM) {
			<span class="enscript-comment">/* if the string won't fit in attrname, copyinstr emits EPERM */</span>
			<span class="enscript-keyword">return</span> (ENAMETOOLONG);
		}
		<span class="enscript-comment">/* Otherwise return the default error from copyinstr to detect ERANGE, etc */</span>
		<span class="enscript-keyword">return</span> error;
	}
	<span class="enscript-keyword">if</span> (xattr_protected(attrname))
		<span class="enscript-keyword">return</span>(EPERM);
	<span class="enscript-keyword">if</span> (uap-&gt;size != 0 &amp;&amp; uap-&gt;value == 0) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> ( (error = file_vnode(uap-&gt;fd, &amp;vp)) ) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(error);
	}
	auio = uio_createwithbuffer(1, uap-&gt;position, spacetype, UIO_WRITE,
	                            &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, uap-&gt;value, uap-&gt;size);

	error = vn_setxattr(vp, attrname, auio, uap-&gt;options, vfs_context_current());
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		add_fsevent(FSE_XATTR_MODIFIED, ctx,
		    FSE_ARG_VNODE, vp,
		    FSE_ARG_DONE);
	}
#<span class="enscript-reference">endif</span>
	vnode_put(vp);
	file_drop(uap-&gt;fd);
	*retval = 0;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Remove an extended attribute.
 * XXX Code duplication here.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">removexattr</span>(proc_t p, <span class="enscript-type">struct</span> removexattr_args *uap, <span class="enscript-type">int</span> *retval)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">char</span> attrname[XATTR_MAXNAMELEN+1];
	<span class="enscript-type">int</span> spacetype = IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	vfs_context_t ctx = vfs_context_current();
	size_t namelen;
	u_int32_t nameiflags;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (uap-&gt;options &amp; (XATTR_NOSECURITY | XATTR_NODEFAULT))
		<span class="enscript-keyword">return</span> (EINVAL);

	error = copyinstr(uap-&gt;attrname, attrname, <span class="enscript-keyword">sizeof</span>(attrname), &amp;namelen);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (xattr_protected(attrname))
		<span class="enscript-keyword">return</span>(EPERM);
	nameiflags = (uap-&gt;options &amp; XATTR_NOFOLLOW) ? 0 : FOLLOW;
	NDINIT(&amp;nd, LOOKUP, OP_REMOVEXATTR, nameiflags, spacetype, uap-&gt;path, ctx);
	<span class="enscript-keyword">if</span> ((error = namei(&amp;nd))) {
		<span class="enscript-keyword">return</span> (error);
	}
	vp = nd.ni_vp;
	nameidone(&amp;nd);

	error = vn_removexattr(vp, attrname, uap-&gt;options, ctx);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		add_fsevent(FSE_XATTR_REMOVED, ctx,
		    FSE_ARG_VNODE, vp,
		    FSE_ARG_DONE);
	}
#<span class="enscript-reference">endif</span>
	vnode_put(vp);
	*retval = 0;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Remove an extended attribute.
 * XXX Code duplication here.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fremovexattr</span>(__unused proc_t p, <span class="enscript-type">struct</span> fremovexattr_args *uap, <span class="enscript-type">int</span> *retval)
{
	vnode_t vp;
	<span class="enscript-type">char</span> attrname[XATTR_MAXNAMELEN+1];
	size_t namelen;
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	vfs_context_t ctx = vfs_context_current();
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (uap-&gt;options &amp; (XATTR_NOFOLLOW | XATTR_NOSECURITY | XATTR_NODEFAULT))
		<span class="enscript-keyword">return</span> (EINVAL);

	error = copyinstr(uap-&gt;attrname, attrname, <span class="enscript-keyword">sizeof</span>(attrname), &amp;namelen);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (xattr_protected(attrname))
		<span class="enscript-keyword">return</span>(EPERM);
	<span class="enscript-keyword">if</span> ( (error = file_vnode(uap-&gt;fd, &amp;vp)) ) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(error);
	}

	error = vn_removexattr(vp, attrname, uap-&gt;options, vfs_context_current());
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		add_fsevent(FSE_XATTR_REMOVED, ctx,
		    FSE_ARG_VNODE, vp,
		    FSE_ARG_DONE);
	}
#<span class="enscript-reference">endif</span>
	vnode_put(vp);
	file_drop(uap-&gt;fd);
	*retval = 0;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Retrieve the list of extended attribute names.
 * XXX Code duplication here.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">listxattr</span>(proc_t p, <span class="enscript-type">struct</span> listxattr_args *uap, user_ssize_t *retval)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> nameidata nd;
	vfs_context_t ctx = vfs_context_current();
	uio_t auio = NULL;
	<span class="enscript-type">int</span> spacetype = IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	size_t attrsize = 0;
	u_int32_t nameiflags;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];

	<span class="enscript-keyword">if</span> (uap-&gt;options &amp; (XATTR_NOSECURITY | XATTR_NODEFAULT))
		<span class="enscript-keyword">return</span> (EINVAL);

	nameiflags = (uap-&gt;options &amp; XATTR_NOFOLLOW) ? 0 : FOLLOW;
	NDINIT(&amp;nd, LOOKUP, OP_LISTXATTR, nameiflags, spacetype, uap-&gt;path, ctx);
	<span class="enscript-keyword">if</span> ((error = namei(&amp;nd))) {
		<span class="enscript-keyword">return</span> (error);
	}
	vp = nd.ni_vp;
	nameidone(&amp;nd);
	<span class="enscript-keyword">if</span> (uap-&gt;namebuf != 0 &amp;&amp; uap-&gt;bufsize &gt; 0) {
		auio = uio_createwithbuffer(1, 0, spacetype, UIO_READ,
		                            &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
		uio_addiov(auio, uap-&gt;namebuf, uap-&gt;bufsize);
	}

	error = vn_listxattr(vp, auio, &amp;attrsize, uap-&gt;options, ctx);

	vnode_put(vp);
	<span class="enscript-keyword">if</span> (auio) {
		*retval = (user_ssize_t)uap-&gt;bufsize - uio_resid(auio);
	} <span class="enscript-keyword">else</span> {
		*retval = (user_ssize_t)attrsize;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Retrieve the list of extended attribute names.
 * XXX Code duplication here.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">flistxattr</span>(proc_t p, <span class="enscript-type">struct</span> flistxattr_args *uap, user_ssize_t *retval)
{
	vnode_t vp;
	uio_t auio = NULL;
	<span class="enscript-type">int</span> spacetype = proc_is64bit(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	size_t attrsize = 0;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];

	<span class="enscript-keyword">if</span> (uap-&gt;options &amp; (XATTR_NOFOLLOW | XATTR_NOSECURITY | XATTR_NODEFAULT))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> ( (error = file_vnode(uap-&gt;fd, &amp;vp)) ) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(error);
	}
	<span class="enscript-keyword">if</span> (uap-&gt;namebuf != 0 &amp;&amp; uap-&gt;bufsize &gt; 0) {
		auio = uio_createwithbuffer(1, 0, spacetype, 
								  	  UIO_READ, &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
		uio_addiov(auio, uap-&gt;namebuf, uap-&gt;bufsize);
	}

	error = vn_listxattr(vp, auio, &amp;attrsize, uap-&gt;options, vfs_context_current());

	vnode_put(vp);
	file_drop(uap-&gt;fd);
	<span class="enscript-keyword">if</span> (auio) {
		*retval = (user_ssize_t)uap-&gt;bufsize - uio_resid(auio);
	} <span class="enscript-keyword">else</span> {
		*retval = (user_ssize_t)attrsize;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">fsgetpath_internal</span>(
	vfs_context_t ctx, <span class="enscript-type">int</span> volfs_id, uint64_t objid,
	vm_size_t bufsize, caddr_t buf, <span class="enscript-type">int</span> *pathlen)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> mount *mp = NULL;
	vnode_t vp;
	<span class="enscript-type">int</span> length;
	<span class="enscript-type">int</span> bpflags;

	<span class="enscript-keyword">if</span> (bufsize &gt; PAGE_SIZE) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (buf == NULL) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	<span class="enscript-keyword">if</span> ((mp = mount_lookupby_volfsid(volfs_id, 1)) == NULL) {
		error = ENOTSUP;  <span class="enscript-comment">/* unexpected failure */</span>
		<span class="enscript-keyword">return</span> ENOTSUP;
	}

<span class="enscript-reference">unionget</span>:
	<span class="enscript-keyword">if</span> (objid == 2) {
		error = VFS_ROOT(mp, &amp;vp, ctx);
	} <span class="enscript-keyword">else</span> {
		error = VFS_VGET(mp, (ino64_t)objid, &amp;vp, ctx);
	}

	<span class="enscript-keyword">if</span> (error == ENOENT &amp;&amp; (mp-&gt;mnt_flag &amp; MNT_UNION)) {
		<span class="enscript-comment">/*
		 * If the fileid isn't found and we're in a union
		 * mount volume, then see if the fileid is in the
		 * mounted-on volume.
		 */</span>
		<span class="enscript-type">struct</span> mount *tmp = mp;
		mp = vnode_mount(tmp-&gt;mnt_vnodecovered);
		vfs_unbusy(tmp);
		<span class="enscript-keyword">if</span> (vfs_busy(mp, LK_NOWAIT) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unionget</span>;
	} <span class="enscript-keyword">else</span> {
		vfs_unbusy(mp);
	}

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_fsgetpath(ctx, vp);
	<span class="enscript-keyword">if</span> (error) {
		vnode_put(vp);
		<span class="enscript-keyword">return</span> error;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Obtain the absolute path to this vnode. */</span>
	bpflags = vfs_context_suser(ctx) ? BUILDPATH_CHECKACCESS : 0;
	bpflags |= BUILDPATH_CHECK_MOVED;
	error = build_path(vp, buf, bufsize, &amp;length, bpflags, ctx);
	vnode_put(vp);

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	AUDIT_ARG(text, buf);

	<span class="enscript-keyword">if</span> (kdebug_enable) {
		<span class="enscript-type">long</span> dbg_parms[NUMPARMS];
                <span class="enscript-type">int</span>  dbg_namelen;

                dbg_namelen = (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(dbg_parms);

        <span class="enscript-keyword">if</span> (length &lt; dbg_namelen) {
			memcpy((<span class="enscript-type">char</span> *)dbg_parms, buf, length);
			memset((<span class="enscript-type">char</span> *)dbg_parms + length, 0, dbg_namelen - length);

			dbg_namelen = length;
		} <span class="enscript-keyword">else</span> {
			memcpy((<span class="enscript-type">char</span> *)dbg_parms, buf + (length - dbg_namelen), dbg_namelen);
		}

		kdebug_lookup_gen_events(dbg_parms, dbg_namelen, (<span class="enscript-type">void</span> *)vp, TRUE);
	}

	*pathlen = (user_ssize_t)length; <span class="enscript-comment">/* may be superseded by error */</span>

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Obtain the full pathname of a file system object by id.
 *
 * This is a private SPI used by the File Manager.
 */</span>
__private_extern__
<span class="enscript-type">int</span>
<span class="enscript-function-name">fsgetpath</span>(__unused proc_t p, <span class="enscript-type">struct</span> fsgetpath_args *uap, user_ssize_t *retval)
{
	vfs_context_t ctx = vfs_context_current();
	fsid_t fsid;
	<span class="enscript-type">char</span> *realpath;
	<span class="enscript-type">int</span> length;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;fsid, (caddr_t)&amp;fsid, <span class="enscript-keyword">sizeof</span>(fsid)))) {
		<span class="enscript-keyword">return</span> (error);
	}
	AUDIT_ARG(value32, fsid.val[0]);
	AUDIT_ARG(value64, uap-&gt;objid);
	<span class="enscript-comment">/* Restrict output buffer size for now. */</span>
	
	<span class="enscript-keyword">if</span> (uap-&gt;bufsize &gt; PAGE_SIZE) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}	
	MALLOC(realpath, <span class="enscript-type">char</span> *, uap-&gt;bufsize, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (realpath == NULL) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	error = fsgetpath_internal(
		ctx, fsid.val[0], uap-&gt;objid, 
		uap-&gt;bufsize, realpath, &amp;length);

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	error = copyout((caddr_t)realpath, uap-&gt;buf, length);

	*retval = (user_ssize_t)length; <span class="enscript-comment">/* may be superseded by error */</span>
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (realpath) {
		FREE(realpath, M_TEMP);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Common routine to handle various flavors of statfs data heading out
 *	to user space.
 *
 * Returns:	0			Success
 *		EFAULT
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">munge_statfs</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vfsstatfs *sfsp, 
    user_addr_t bufp, <span class="enscript-type">int</span> *sizep, boolean_t is_64_bit, 
    boolean_t partial_copy)
{
	<span class="enscript-type">int</span>		error;
	<span class="enscript-type">int</span>		my_size, copy_size;

	<span class="enscript-keyword">if</span> (is_64_bit) {
		<span class="enscript-type">struct</span> user64_statfs sfs;
		my_size = copy_size = <span class="enscript-keyword">sizeof</span>(sfs);
		bzero(&amp;sfs, my_size);
		sfs.f_flags = mp-&gt;mnt_flag &amp; MNT_VISFLAGMASK;
		sfs.f_type = mp-&gt;mnt_vtable-&gt;vfc_typenum;
		sfs.f_reserved1 = (<span class="enscript-type">short</span>)sfsp-&gt;f_fssubtype;
		sfs.f_bsize = (user64_long_t)sfsp-&gt;f_bsize;
		sfs.f_iosize = (user64_long_t)sfsp-&gt;f_iosize;
		sfs.f_blocks = (user64_long_t)sfsp-&gt;f_blocks;
		sfs.f_bfree = (user64_long_t)sfsp-&gt;f_bfree;
		sfs.f_bavail = (user64_long_t)sfsp-&gt;f_bavail;
		sfs.f_files = (user64_long_t)sfsp-&gt;f_files;
		sfs.f_ffree = (user64_long_t)sfsp-&gt;f_ffree;
		sfs.f_fsid = sfsp-&gt;f_fsid;
		sfs.f_owner = sfsp-&gt;f_owner;
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_kern_flag &amp; MNTK_TYPENAME_OVERRIDE) {
			strlcpy(&amp;sfs.f_fstypename[0], &amp;mp-&gt;fstypename_override[0], MFSNAMELEN);
		} <span class="enscript-keyword">else</span> {
			strlcpy(&amp;sfs.f_fstypename[0], &amp;sfsp-&gt;f_fstypename[0], MFSNAMELEN);
		}
		strlcpy(&amp;sfs.f_mntonname[0], &amp;sfsp-&gt;f_mntonname[0], MNAMELEN);
		strlcpy(&amp;sfs.f_mntfromname[0], &amp;sfsp-&gt;f_mntfromname[0], MNAMELEN);

		<span class="enscript-keyword">if</span> (partial_copy) {
			copy_size -= (<span class="enscript-keyword">sizeof</span>(sfs.f_reserved3) + <span class="enscript-keyword">sizeof</span>(sfs.f_reserved4));
		}
		error = copyout((caddr_t)&amp;sfs, bufp, copy_size);
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_statfs sfs;

		my_size = copy_size = <span class="enscript-keyword">sizeof</span>(sfs);
		bzero(&amp;sfs, my_size);
		
		sfs.f_flags = mp-&gt;mnt_flag &amp; MNT_VISFLAGMASK;
		sfs.f_type = mp-&gt;mnt_vtable-&gt;vfc_typenum;
		sfs.f_reserved1 = (<span class="enscript-type">short</span>)sfsp-&gt;f_fssubtype;
		
		<span class="enscript-comment">/*
		 * It's possible for there to be more than 2^^31 blocks in the filesystem, so we
		 * have to fudge the numbers here in that case.   We inflate the blocksize in order
		 * to reflect the filesystem size as best we can.
		 */</span>
		<span class="enscript-keyword">if</span> ((sfsp-&gt;f_blocks &gt; INT_MAX) 
			<span class="enscript-comment">/* Hack for 4061702 . I think the real fix is for Carbon to 
			 * look for some volume capability and not depend on hidden
			 * semantics agreed between a FS and carbon. 
			 * f_blocks, f_bfree, and f_bavail set to -1 is the trigger
			 * for Carbon to set bNoVolumeSizes volume attribute.
			 * Without this the webdavfs files cannot be copied onto 
			 * disk as they look huge. This change should not affect
			 * XSAN as they should not setting these to -1..
			 */</span>
			 &amp;&amp; (sfsp-&gt;f_blocks != 0xffffffffffffffffULL)
			 &amp;&amp; (sfsp-&gt;f_bfree != 0xffffffffffffffffULL)
			 &amp;&amp; (sfsp-&gt;f_bavail != 0xffffffffffffffffULL)) {
			<span class="enscript-type">int</span>		shift;

			<span class="enscript-comment">/*
			 * Work out how far we have to shift the block count down to make it fit.
			 * Note that it's possible to have to shift so far that the resulting
			 * blocksize would be unreportably large.  At that point, we will clip
			 * any values that don't fit.
			 *
			 * For safety's sake, we also ensure that f_iosize is never reported as
			 * being smaller than f_bsize.
			 */</span>
			<span class="enscript-keyword">for</span> (shift = 0; shift &lt; 32; shift++) {
				<span class="enscript-keyword">if</span> ((sfsp-&gt;f_blocks &gt;&gt; shift) &lt;= INT_MAX)
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">if</span> ((sfsp-&gt;f_bsize &lt;&lt; (shift + 1)) &gt; INT_MAX)
					<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">define</span> <span class="enscript-function-name">__SHIFT_OR_CLIP</span>(x, s)	((((x) &gt;&gt; (s)) &gt; INT_MAX) ? INT_MAX : ((x) &gt;&gt; (s)))
			sfs.f_blocks = (user32_long_t)__SHIFT_OR_CLIP(sfsp-&gt;f_blocks, shift);
			sfs.f_bfree = (user32_long_t)__SHIFT_OR_CLIP(sfsp-&gt;f_bfree, shift);
			sfs.f_bavail = (user32_long_t)__SHIFT_OR_CLIP(sfsp-&gt;f_bavail, shift);
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">__SHIFT_OR_CLIP</span>
			sfs.f_bsize = (user32_long_t)(sfsp-&gt;f_bsize &lt;&lt; shift);
			sfs.f_iosize = lmax(sfsp-&gt;f_iosize, sfsp-&gt;f_bsize);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* filesystem is small enough to be reported honestly */</span>
			sfs.f_bsize = (user32_long_t)sfsp-&gt;f_bsize;
			sfs.f_iosize = (user32_long_t)sfsp-&gt;f_iosize;
			sfs.f_blocks = (user32_long_t)sfsp-&gt;f_blocks;
			sfs.f_bfree = (user32_long_t)sfsp-&gt;f_bfree;
			sfs.f_bavail = (user32_long_t)sfsp-&gt;f_bavail;
		}
		sfs.f_files = (user32_long_t)sfsp-&gt;f_files;
		sfs.f_ffree = (user32_long_t)sfsp-&gt;f_ffree;
		sfs.f_fsid = sfsp-&gt;f_fsid;
		sfs.f_owner = sfsp-&gt;f_owner;
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_kern_flag &amp; MNTK_TYPENAME_OVERRIDE) {
			strlcpy(&amp;sfs.f_fstypename[0], &amp;mp-&gt;fstypename_override[0], MFSNAMELEN);
		} <span class="enscript-keyword">else</span> {
			strlcpy(&amp;sfs.f_fstypename[0], &amp;sfsp-&gt;f_fstypename[0], MFSNAMELEN);
		}
		strlcpy(&amp;sfs.f_mntonname[0], &amp;sfsp-&gt;f_mntonname[0], MNAMELEN);
		strlcpy(&amp;sfs.f_mntfromname[0], &amp;sfsp-&gt;f_mntfromname[0], MNAMELEN);

		<span class="enscript-keyword">if</span> (partial_copy) {
			copy_size -= (<span class="enscript-keyword">sizeof</span>(sfs.f_reserved3) + <span class="enscript-keyword">sizeof</span>(sfs.f_reserved4));
		}
		error = copyout((caddr_t)&amp;sfs, bufp, copy_size);
	}
	
	<span class="enscript-keyword">if</span> (sizep != NULL) {
		*sizep = my_size;
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * copy stat structure into user_stat structure.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">munge_user64_stat</span>(<span class="enscript-type">struct</span> stat *sbp, <span class="enscript-type">struct</span> user64_stat *usbp)
{
	bzero(usbp, <span class="enscript-keyword">sizeof</span>(*usbp));

	usbp-&gt;st_dev = sbp-&gt;st_dev;
	usbp-&gt;st_ino = sbp-&gt;st_ino;
	usbp-&gt;st_mode = sbp-&gt;st_mode;
	usbp-&gt;st_nlink = sbp-&gt;st_nlink;
	usbp-&gt;st_uid = sbp-&gt;st_uid;
	usbp-&gt;st_gid = sbp-&gt;st_gid;
	usbp-&gt;st_rdev = sbp-&gt;st_rdev;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_POSIX_C_SOURCE</span>
	usbp-&gt;st_atimespec.tv_sec = sbp-&gt;st_atimespec.tv_sec;
	usbp-&gt;st_atimespec.tv_nsec = sbp-&gt;st_atimespec.tv_nsec;
	usbp-&gt;st_mtimespec.tv_sec = sbp-&gt;st_mtimespec.tv_sec;
	usbp-&gt;st_mtimespec.tv_nsec = sbp-&gt;st_mtimespec.tv_nsec;
	usbp-&gt;st_ctimespec.tv_sec = sbp-&gt;st_ctimespec.tv_sec;
	usbp-&gt;st_ctimespec.tv_nsec = sbp-&gt;st_ctimespec.tv_nsec;
#<span class="enscript-reference">else</span>
	usbp-&gt;st_atime = sbp-&gt;st_atime;
	usbp-&gt;st_atimensec = sbp-&gt;st_atimensec;
	usbp-&gt;st_mtime = sbp-&gt;st_mtime;
	usbp-&gt;st_mtimensec = sbp-&gt;st_mtimensec;
	usbp-&gt;st_ctime = sbp-&gt;st_ctime;
	usbp-&gt;st_ctimensec = sbp-&gt;st_ctimensec;
#<span class="enscript-reference">endif</span>
	usbp-&gt;st_size = sbp-&gt;st_size;
	usbp-&gt;st_blocks = sbp-&gt;st_blocks;
	usbp-&gt;st_blksize = sbp-&gt;st_blksize;
	usbp-&gt;st_flags = sbp-&gt;st_flags;
	usbp-&gt;st_gen = sbp-&gt;st_gen;
	usbp-&gt;st_lspare = sbp-&gt;st_lspare;
	usbp-&gt;st_qspare[0] = sbp-&gt;st_qspare[0];
	usbp-&gt;st_qspare[1] = sbp-&gt;st_qspare[1];
}

<span class="enscript-type">void</span> <span class="enscript-function-name">munge_user32_stat</span>(<span class="enscript-type">struct</span> stat *sbp, <span class="enscript-type">struct</span> user32_stat *usbp)
{
	bzero(usbp, <span class="enscript-keyword">sizeof</span>(*usbp));

	usbp-&gt;st_dev = sbp-&gt;st_dev;
	usbp-&gt;st_ino = sbp-&gt;st_ino;
	usbp-&gt;st_mode = sbp-&gt;st_mode;
	usbp-&gt;st_nlink = sbp-&gt;st_nlink;
	usbp-&gt;st_uid = sbp-&gt;st_uid;
	usbp-&gt;st_gid = sbp-&gt;st_gid;
	usbp-&gt;st_rdev = sbp-&gt;st_rdev;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_POSIX_C_SOURCE</span>
	usbp-&gt;st_atimespec.tv_sec = sbp-&gt;st_atimespec.tv_sec;
	usbp-&gt;st_atimespec.tv_nsec = sbp-&gt;st_atimespec.tv_nsec;
	usbp-&gt;st_mtimespec.tv_sec = sbp-&gt;st_mtimespec.tv_sec;
	usbp-&gt;st_mtimespec.tv_nsec = sbp-&gt;st_mtimespec.tv_nsec;
	usbp-&gt;st_ctimespec.tv_sec = sbp-&gt;st_ctimespec.tv_sec;
	usbp-&gt;st_ctimespec.tv_nsec = sbp-&gt;st_ctimespec.tv_nsec;
#<span class="enscript-reference">else</span>
	usbp-&gt;st_atime = sbp-&gt;st_atime;
	usbp-&gt;st_atimensec = sbp-&gt;st_atimensec;
	usbp-&gt;st_mtime = sbp-&gt;st_mtime;
	usbp-&gt;st_mtimensec = sbp-&gt;st_mtimensec;
	usbp-&gt;st_ctime = sbp-&gt;st_ctime;
	usbp-&gt;st_ctimensec = sbp-&gt;st_ctimensec;
#<span class="enscript-reference">endif</span>
	usbp-&gt;st_size = sbp-&gt;st_size;
	usbp-&gt;st_blocks = sbp-&gt;st_blocks;
	usbp-&gt;st_blksize = sbp-&gt;st_blksize;
	usbp-&gt;st_flags = sbp-&gt;st_flags;
	usbp-&gt;st_gen = sbp-&gt;st_gen;
	usbp-&gt;st_lspare = sbp-&gt;st_lspare;
	usbp-&gt;st_qspare[0] = sbp-&gt;st_qspare[0];
	usbp-&gt;st_qspare[1] = sbp-&gt;st_qspare[1];
}

<span class="enscript-comment">/*
 * copy stat64 structure into user_stat64 structure.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">munge_user64_stat64</span>(<span class="enscript-type">struct</span> stat64 *sbp, <span class="enscript-type">struct</span> user64_stat64 *usbp)
{
	bzero(usbp, <span class="enscript-keyword">sizeof</span>(*usbp));

	usbp-&gt;st_dev = sbp-&gt;st_dev;
	usbp-&gt;st_ino = sbp-&gt;st_ino;
	usbp-&gt;st_mode = sbp-&gt;st_mode;
	usbp-&gt;st_nlink = sbp-&gt;st_nlink;
	usbp-&gt;st_uid = sbp-&gt;st_uid;
	usbp-&gt;st_gid = sbp-&gt;st_gid;
	usbp-&gt;st_rdev = sbp-&gt;st_rdev;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_POSIX_C_SOURCE</span>
	usbp-&gt;st_atimespec.tv_sec = sbp-&gt;st_atimespec.tv_sec;
	usbp-&gt;st_atimespec.tv_nsec = sbp-&gt;st_atimespec.tv_nsec;
	usbp-&gt;st_mtimespec.tv_sec = sbp-&gt;st_mtimespec.tv_sec;
	usbp-&gt;st_mtimespec.tv_nsec = sbp-&gt;st_mtimespec.tv_nsec;
	usbp-&gt;st_ctimespec.tv_sec = sbp-&gt;st_ctimespec.tv_sec;
	usbp-&gt;st_ctimespec.tv_nsec = sbp-&gt;st_ctimespec.tv_nsec;
	usbp-&gt;st_birthtimespec.tv_sec = sbp-&gt;st_birthtimespec.tv_sec;
	usbp-&gt;st_birthtimespec.tv_nsec = sbp-&gt;st_birthtimespec.tv_nsec;
#<span class="enscript-reference">else</span>
	usbp-&gt;st_atime = sbp-&gt;st_atime;
	usbp-&gt;st_atimensec = sbp-&gt;st_atimensec;
	usbp-&gt;st_mtime = sbp-&gt;st_mtime;
	usbp-&gt;st_mtimensec = sbp-&gt;st_mtimensec;
	usbp-&gt;st_ctime = sbp-&gt;st_ctime;
	usbp-&gt;st_ctimensec = sbp-&gt;st_ctimensec;
	usbp-&gt;st_birthtime = sbp-&gt;st_birthtime;
	usbp-&gt;st_birthtimensec = sbp-&gt;st_birthtimensec;
#<span class="enscript-reference">endif</span>
	usbp-&gt;st_size = sbp-&gt;st_size;
	usbp-&gt;st_blocks = sbp-&gt;st_blocks;
	usbp-&gt;st_blksize = sbp-&gt;st_blksize;
	usbp-&gt;st_flags = sbp-&gt;st_flags;
	usbp-&gt;st_gen = sbp-&gt;st_gen;
	usbp-&gt;st_lspare = sbp-&gt;st_lspare;
	usbp-&gt;st_qspare[0] = sbp-&gt;st_qspare[0];
	usbp-&gt;st_qspare[1] = sbp-&gt;st_qspare[1];
}

<span class="enscript-type">void</span> <span class="enscript-function-name">munge_user32_stat64</span>(<span class="enscript-type">struct</span> stat64 *sbp, <span class="enscript-type">struct</span> user32_stat64 *usbp)
{
	bzero(usbp, <span class="enscript-keyword">sizeof</span>(*usbp));

	usbp-&gt;st_dev = sbp-&gt;st_dev;
	usbp-&gt;st_ino = sbp-&gt;st_ino;
	usbp-&gt;st_mode = sbp-&gt;st_mode;
	usbp-&gt;st_nlink = sbp-&gt;st_nlink;
	usbp-&gt;st_uid = sbp-&gt;st_uid;
	usbp-&gt;st_gid = sbp-&gt;st_gid;
	usbp-&gt;st_rdev = sbp-&gt;st_rdev;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_POSIX_C_SOURCE</span>
	usbp-&gt;st_atimespec.tv_sec = sbp-&gt;st_atimespec.tv_sec;
	usbp-&gt;st_atimespec.tv_nsec = sbp-&gt;st_atimespec.tv_nsec;
	usbp-&gt;st_mtimespec.tv_sec = sbp-&gt;st_mtimespec.tv_sec;
	usbp-&gt;st_mtimespec.tv_nsec = sbp-&gt;st_mtimespec.tv_nsec;
	usbp-&gt;st_ctimespec.tv_sec = sbp-&gt;st_ctimespec.tv_sec;
	usbp-&gt;st_ctimespec.tv_nsec = sbp-&gt;st_ctimespec.tv_nsec;
	usbp-&gt;st_birthtimespec.tv_sec = sbp-&gt;st_birthtimespec.tv_sec;
	usbp-&gt;st_birthtimespec.tv_nsec = sbp-&gt;st_birthtimespec.tv_nsec;
#<span class="enscript-reference">else</span>
	usbp-&gt;st_atime = sbp-&gt;st_atime;
	usbp-&gt;st_atimensec = sbp-&gt;st_atimensec;
	usbp-&gt;st_mtime = sbp-&gt;st_mtime;
	usbp-&gt;st_mtimensec = sbp-&gt;st_mtimensec;
	usbp-&gt;st_ctime = sbp-&gt;st_ctime;
	usbp-&gt;st_ctimensec = sbp-&gt;st_ctimensec;
	usbp-&gt;st_birthtime = sbp-&gt;st_birthtime;
	usbp-&gt;st_birthtimensec = sbp-&gt;st_birthtimensec;
#<span class="enscript-reference">endif</span>
	usbp-&gt;st_size = sbp-&gt;st_size;
	usbp-&gt;st_blocks = sbp-&gt;st_blocks;
	usbp-&gt;st_blksize = sbp-&gt;st_blksize;
	usbp-&gt;st_flags = sbp-&gt;st_flags;
	usbp-&gt;st_gen = sbp-&gt;st_gen;
	usbp-&gt;st_lspare = sbp-&gt;st_lspare;
	usbp-&gt;st_qspare[0] = sbp-&gt;st_qspare[0];
	usbp-&gt;st_qspare[1] = sbp-&gt;st_qspare[1];
}

<span class="enscript-comment">/*
 * Purge buffer cache for simulating cold starts
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vnode_purge_callback</span>(<span class="enscript-type">struct</span> vnode *vp, __unused <span class="enscript-type">void</span> *cargs)
{
	ubc_msync(vp, (off_t)0, ubc_getsize(vp), NULL <span class="enscript-comment">/* off_t *resid_off */</span>, UBC_PUSHALL | UBC_INVALIDATE);

	<span class="enscript-keyword">return</span> VNODE_RETURNED;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vfs_purge_callback</span>(mount_t mp, __unused <span class="enscript-type">void</span> * arg)
{
	vnode_iterate(mp, VNODE_WAIT | VNODE_ITERATE_ALL, vnode_purge_callback, NULL);

	<span class="enscript-keyword">return</span> VFS_RETURNED;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_purge</span>(__unused <span class="enscript-type">struct</span> proc *p, __unused <span class="enscript-type">struct</span> vfs_purge_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get()))
		<span class="enscript-keyword">return</span> EPERM;

	vfs_iterate(0<span class="enscript-comment">/* flags */</span>, vfs_purge_callback, NULL);

	<span class="enscript-keyword">return</span> 0;
}

</pre>
<hr />
</body></html>