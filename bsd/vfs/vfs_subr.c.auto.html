<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_subr.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_subr.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)vfs_subr.c	8.31 (Berkeley) 5/26/95
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

<span class="enscript-comment">/*
 * External virtual filesystem routines
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_memorystatus.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lockf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/fifofs/fifo.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/spl.h&gt;</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_control.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>	<span class="enscript-comment">/* kalloc()/kfree() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>		<span class="enscript-comment">/* delay_for_interval() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>	<span class="enscript-comment">/* OSAddAtomic() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;console/video_console.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>	<span class="enscript-comment">/* vnode_pager_vrele() */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> lck_grp_t *vnode_lck_grp;
<span class="enscript-type">extern</span> lck_attr_t *vnode_lck_attr;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
<span class="enscript-type">extern</span> lck_grp_t *trigger_vnode_lck_grp;
<span class="enscript-type">extern</span> lck_attr_t *trigger_vnode_lck_attr;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> lck_mtx_t * mnt_list_mtx_lock;

<span class="enscript-type">enum</span> vtype iftovt_tab[16] = {
	VNON, VFIFO, VCHR, VNON, VDIR, VNON, VBLK, VNON,
	VREG, VNON, VLNK, VNON, VSOCK, VNON, VNON, VBAD,
};
<span class="enscript-type">int</span>	vttoif_tab[9] = {
	0, S_IFREG, S_IFDIR, S_IFBLK, S_IFCHR, S_IFLNK,
	S_IFSOCK, S_IFIFO, S_IFMT,
};


<span class="enscript-comment">/* XXX These should be in a BSD accessible Mach header, but aren't. */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>             <span class="enscript-function-name">memory_object_mark_used</span>(
	memory_object_control_t         control);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>             <span class="enscript-function-name">memory_object_mark_unused</span>(
	memory_object_control_t         control,
	boolean_t                       rage);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> 		memory_object_mark_io_tracking(
	memory_object_control_t         control);

<span class="enscript-comment">/* XXX next protptype should be from &lt;nfs/nfs.h&gt; */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>       <span class="enscript-function-name">nfs_vinvalbuf</span>(vnode_t, <span class="enscript-type">int</span>, vfs_context_t, <span class="enscript-type">int</span>);

<span class="enscript-comment">/* XXX next prototytype should be from libsa/stdlib.h&gt; but conflicts libkern */</span>
__private_extern__ <span class="enscript-type">void</span> qsort(
    <span class="enscript-type">void</span> * array,
    size_t nmembers,
    size_t member_size,
    <span class="enscript-type">int</span> (*)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *));

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">adjust_vm_object_cache</span>(vm_size_t oval, vm_size_t nval);
__private_extern__ <span class="enscript-type">void</span> vntblinit(<span class="enscript-type">void</span>);
__private_extern__ kern_return_t reset_vmobjectcache(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> val1,
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> val2);
__private_extern__ <span class="enscript-type">int</span> unlink1(vfs_context_t, vnode_t, user_addr_t,
    <span class="enscript-type">enum</span> uio_seg, <span class="enscript-type">int</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> system_inshutdown;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vnode_list_add</span>(vnode_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vnode_async_list_add</span>(vnode_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vnode_list_remove</span>(vnode_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vnode_list_remove_locked</span>(vnode_t);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vnode_abort_advlocks</span>(vnode_t);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">vnode_drain</span>(vnode_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vgone</span>(vnode_t, <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vclean</span>(vnode_t vp, <span class="enscript-type">int</span> flag);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vnode_reclaim_internal</span>(vnode_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vnode_dropiocount</span> (vnode_t);

<span class="enscript-type">static</span> vnode_t <span class="enscript-function-name">checkalias</span>(vnode_t vp, dev_t nvp_rdev);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">vnode_reload</span>(vnode_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">vnode_isinuse_locked</span>(vnode_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">unmount_callback</span>(mount_t, __unused <span class="enscript-type">void</span> *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">insmntque</span>(vnode_t vp, mount_t mp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mount_getvfscnt</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mount_fillfsids</span>(fsid_t *, <span class="enscript-type">int</span> );
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vnode_iterate_setup</span>(mount_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">vnode_umount_preflight</span>(mount_t, vnode_t, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vnode_iterate_prepare</span>(mount_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vnode_iterate_reloadq</span>(mount_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vnode_iterate_clear</span>(mount_t);
<span class="enscript-type">static</span> mount_t <span class="enscript-function-name">vfs_getvfs_locked</span>(fsid_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vn_create_reg</span>(vnode_t dvp, vnode_t *vpp, <span class="enscript-type">struct</span> nameidata *ndp,
		<span class="enscript-type">struct</span> vnode_attr *vap, uint32_t flags, <span class="enscript-type">int</span> fmode, uint32_t *statusp, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vnode_authattr_new_internal</span>(vnode_t dvp, <span class="enscript-type">struct</span> vnode_attr *vap, <span class="enscript-type">int</span> noauth, uint32_t *defaulted_fieldsp, vfs_context_t ctx);

errno_t <span class="enscript-function-name">rmdir_remove_orphaned_appleDouble</span>(vnode_t, vfs_context_t, <span class="enscript-type">int</span> *); 

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">record_vp</span>(vnode_t vp, <span class="enscript-type">int</span> count);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span> &amp;&amp; (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> bootarg_no_vnode_jetsam;    <span class="enscript-comment">/* from bsd_init.c default value is 0 */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM &amp;&amp; (DEVELOPMENT || DEBUG) */</span>

boolean_t root_is_CF_drive = FALSE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vnode_resolver_create</span>(mount_t, vnode_t, <span class="enscript-type">struct</span> vnode_trigger_param *, boolean_t external);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vnode_resolver_detach</span>(vnode_t);
#<span class="enscript-reference">endif</span>

<span class="enscript-function-name">TAILQ_HEAD</span>(freelst, vnode) vnode_free_list;	<span class="enscript-comment">/* vnode free list */</span>
<span class="enscript-function-name">TAILQ_HEAD</span>(deadlst, vnode) vnode_dead_list;	<span class="enscript-comment">/* vnode dead list */</span>
<span class="enscript-function-name">TAILQ_HEAD</span>(async_work_lst, vnode) vnode_async_work_list;


<span class="enscript-function-name">TAILQ_HEAD</span>(ragelst, vnode) vnode_rage_list;	<span class="enscript-comment">/* vnode rapid age list */</span>
<span class="enscript-type">struct</span> timeval rage_tv;
<span class="enscript-type">int</span>	rage_limit = 0;
<span class="enscript-type">int</span>	ragevnodes = 0;			   

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RAGE_LIMIT_MIN</span>	100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RAGE_TIME_LIMIT</span>	5

<span class="enscript-type">struct</span> mntlist mountlist;			<span class="enscript-comment">/* mounted filesystem list */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> nummounts = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VLISTCHECK</span>(fun, vp, list)	\
	<span class="enscript-keyword">if</span> ((vp)-&gt;v_freelist.tqe_prev == (<span class="enscript-type">struct</span> vnode **)0xdeadb) \
		panic(<span class="enscript-string">&quot;%s: %s vnode not on %slist&quot;</span>, (fun), (list), (list));
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VLISTCHECK</span>(fun, vp, list)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAGNOSTIC */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VLISTNONE</span>(vp)	\
	<span class="enscript-keyword">do</span> {	\
		(vp)-&gt;v_freelist.tqe_next = (<span class="enscript-type">struct</span> vnode *)0;	\
		(vp)-&gt;v_freelist.tqe_prev = (<span class="enscript-type">struct</span> vnode **)0xdeadb;	\
	} <span class="enscript-keyword">while</span>(0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VONLIST</span>(vp)	\
	((vp)-&gt;v_freelist.tqe_prev != (<span class="enscript-type">struct</span> vnode **)0xdeadb)

<span class="enscript-comment">/* remove a vnode from free vnode list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VREMFREE</span>(fun, vp)	\
	<span class="enscript-keyword">do</span> {	\
		VLISTCHECK((fun), (vp), <span class="enscript-string">&quot;free&quot;</span>);	\
		TAILQ_REMOVE(&amp;vnode_free_list, (vp), v_freelist);	\
		VLISTNONE((vp));	\
		freevnodes--;	\
	} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/* remove a vnode from dead vnode list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VREMDEAD</span>(fun, vp)	\
	<span class="enscript-keyword">do</span> {	\
		VLISTCHECK((fun), (vp), <span class="enscript-string">&quot;dead&quot;</span>);	\
		TAILQ_REMOVE(&amp;vnode_dead_list, (vp), v_freelist);	\
		VLISTNONE((vp));	\
		vp-&gt;v_listflag &amp;= ~VLIST_DEAD;	\
		deadvnodes--;	\
	} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/* remove a vnode from async work vnode list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VREMASYNC_WORK</span>(fun, vp)	\
	<span class="enscript-keyword">do</span> {	\
		VLISTCHECK((fun), (vp), <span class="enscript-string">&quot;async_work&quot;</span>);	\
		TAILQ_REMOVE(&amp;vnode_async_work_list, (vp), v_freelist);	\
		VLISTNONE((vp));	\
		vp-&gt;v_listflag &amp;= ~VLIST_ASYNC_WORK;	\
		async_work_vnodes--;	\
	} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/* remove a vnode from rage vnode list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VREMRAGE</span>(fun, vp)	\
	<span class="enscript-keyword">do</span> {	\
	        <span class="enscript-keyword">if</span> ( !(vp-&gt;v_listflag &amp; VLIST_RAGE))			\
		        panic(<span class="enscript-string">&quot;VREMRAGE: vp not on rage list&quot;</span>);		\
		VLISTCHECK((fun), (vp), <span class="enscript-string">&quot;rage&quot;</span>);			\
		TAILQ_REMOVE(&amp;vnode_rage_list, (vp), v_freelist);	\
		VLISTNONE((vp));		\
		vp-&gt;v_listflag &amp;= ~VLIST_RAGE;	\
		ragevnodes--;			\
	} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/*
 * vnodetarget hasn't been used in a long time, but
 * it was exported for some reason... I'm leaving in
 * place for now...  it should be deprecated out of the
 * exports and removed eventually.
 */</span>
u_int32_t vnodetarget;		<span class="enscript-comment">/* target for vnreclaim() */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_FREE_TARGET</span>	20	<span class="enscript-comment">/* Default value for vnodetarget */</span>

<span class="enscript-comment">/*
 * We need quite a few vnodes on the free list to sustain the
 * rapid stat() the compilation process does, and still benefit from the name
 * cache. Having too few vnodes on the free list causes serious disk
 * thrashing as we cycle through them.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_FREE_MIN</span>		CONFIG_VNODE_FREE_MIN	<span class="enscript-comment">/* freelist should have at least this many */</span>


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">async_work_continue</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 * Initialize the vnode management data structures.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vntblinit</span>(<span class="enscript-type">void</span>)
{
	thread_t	thread = THREAD_NULL;

	TAILQ_INIT(&amp;vnode_free_list);
	TAILQ_INIT(&amp;vnode_rage_list);
	TAILQ_INIT(&amp;vnode_dead_list);
	TAILQ_INIT(&amp;vnode_async_work_list);
	TAILQ_INIT(&amp;mountlist);

	<span class="enscript-keyword">if</span> (!vnodetarget)
		vnodetarget = VNODE_FREE_TARGET;

	microuptime(&amp;rage_tv);
	rage_limit = desiredvnodes / 100;

	<span class="enscript-keyword">if</span> (rage_limit &lt; RAGE_LIMIT_MIN)
	        rage_limit = RAGE_LIMIT_MIN;
	
	<span class="enscript-comment">/*
	 * Scale the vm_object_cache to accomodate the vnodes 
	 * we want to cache
	 */</span>
	(<span class="enscript-type">void</span>) adjust_vm_object_cache(0, desiredvnodes - VNODE_FREE_MIN);

	<span class="enscript-comment">/*
	 * create worker threads
	 */</span>
	kernel_thread_start((thread_continue_t)async_work_continue, NULL, &amp;thread);
	thread_deallocate(thread);
}

<span class="enscript-comment">/* Reset the VM Object Cache with the values passed in */</span>
__private_extern__ kern_return_t
<span class="enscript-function-name">reset_vmobjectcache</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> val1, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> val2)
{
	vm_size_t oval = val1 - VNODE_FREE_MIN;
	vm_size_t nval;
	
	<span class="enscript-keyword">if</span> (val1 == val2) {
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	<span class="enscript-keyword">if</span>(val2 &lt; VNODE_FREE_MIN)
		nval = 0;
	<span class="enscript-keyword">else</span>
		nval = val2 - VNODE_FREE_MIN;

	<span class="enscript-keyword">return</span>(adjust_vm_object_cache(oval, nval));
}


<span class="enscript-comment">/* the timeout is in 10 msecs */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_waitforwrites</span>(vnode_t vp, <span class="enscript-type">int</span> output_target, <span class="enscript-type">int</span> slpflag, <span class="enscript-type">int</span> slptimeout, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg) {
        <span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> timespec ts;

	KERNEL_DEBUG(0x3010280 | DBG_FUNC_START, (<span class="enscript-type">int</span>)vp, output_target, vp-&gt;v_numoutput, 0, 0);

	<span class="enscript-keyword">if</span> (vp-&gt;v_numoutput &gt; output_target) {

	        slpflag |= PDROP;

	        vnode_lock_spin(vp);

		<span class="enscript-keyword">while</span> ((vp-&gt;v_numoutput &gt; output_target) &amp;&amp; error == 0) {
		        <span class="enscript-keyword">if</span> (output_target)
			        vp-&gt;v_flag |= VTHROTTLED;
			<span class="enscript-keyword">else</span>
			        vp-&gt;v_flag |= VBWAIT;

			ts.tv_sec = (slptimeout/100);
			ts.tv_nsec = (slptimeout % 1000)  * 10 * NSEC_PER_USEC * 1000 ;
			error = msleep((caddr_t)&amp;vp-&gt;v_numoutput, &amp;vp-&gt;v_lock, (slpflag | (PRIBIO + 1)), msg, &amp;ts);

			vnode_lock_spin(vp);
		}
		vnode_unlock(vp);
	}
	KERNEL_DEBUG(0x3010280 | DBG_FUNC_END, (<span class="enscript-type">int</span>)vp, output_target, vp-&gt;v_numoutput, error, 0);

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_startwrite</span>(vnode_t vp) {

        OSAddAtomic(1, &amp;vp-&gt;v_numoutput);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_writedone</span>(vnode_t vp)
{
	<span class="enscript-keyword">if</span> (vp) {
		<span class="enscript-type">int</span> need_wakeup = 0;

	        OSAddAtomic(-1, &amp;vp-&gt;v_numoutput);

		vnode_lock_spin(vp);

		<span class="enscript-keyword">if</span> (vp-&gt;v_numoutput &lt; 0)
			panic(<span class="enscript-string">&quot;vnode_writedone: numoutput &lt; 0&quot;</span>);

		<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VTHROTTLED)) {
			vp-&gt;v_flag &amp;= ~VTHROTTLED;
			need_wakeup = 1;
		}
		<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VBWAIT) &amp;&amp; (vp-&gt;v_numoutput == 0)) {
			vp-&gt;v_flag &amp;= ~VBWAIT;
			need_wakeup = 1;
		}
		vnode_unlock(vp);
		
		<span class="enscript-keyword">if</span> (need_wakeup)
			wakeup((caddr_t)&amp;vp-&gt;v_numoutput);
	}
}



<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_hasdirtyblks</span>(vnode_t vp)
{
        <span class="enscript-type">struct</span> cl_writebehind *wbp;

	<span class="enscript-comment">/*
	 * Not taking the buf_mtxp as there is little
	 * point doing it. Even if the lock is taken the
	 * state can change right after that. If their 
	 * needs to be a synchronization, it must be driven
	 * by the caller
	 */</span> 
        <span class="enscript-keyword">if</span> (vp-&gt;v_dirtyblkhd.lh_first)
	        <span class="enscript-keyword">return</span> (1);
	
	<span class="enscript-keyword">if</span> (!UBCINFOEXISTS(vp))
	        <span class="enscript-keyword">return</span> (0);

	wbp = vp-&gt;v_ubcinfo-&gt;cl_wbehind;

	<span class="enscript-keyword">if</span> (wbp &amp;&amp; (wbp-&gt;cl_number || wbp-&gt;cl_scmap))
	        <span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_hascleanblks</span>(vnode_t vp)
{
	<span class="enscript-comment">/*
	 * Not taking the buf_mtxp as there is little
	 * point doing it. Even if the lock is taken the
	 * state can change right after that. If their 
	 * needs to be a synchronization, it must be driven
	 * by the caller
	 */</span> 
        <span class="enscript-keyword">if</span> (vp-&gt;v_cleanblkhd.lh_first)
	        <span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_iterate_setup</span>(mount_t mp)
{
	<span class="enscript-keyword">while</span> (mp-&gt;mnt_lflag &amp; MNT_LITER) {
		mp-&gt;mnt_lflag |= MNT_LITERWAIT;
		msleep((caddr_t)mp, &amp;mp-&gt;mnt_mlock, PVFS, <span class="enscript-string">&quot;vnode_iterate_setup&quot;</span>, NULL);	
	}

	mp-&gt;mnt_lflag |= MNT_LITER;

}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_umount_preflight</span>(mount_t mp, vnode_t skipvp, <span class="enscript-type">int</span> flags)
{
	vnode_t vp;

	TAILQ_FOREACH(vp, &amp;mp-&gt;mnt_vnodelist, v_mntvnodes) {
		<span class="enscript-keyword">if</span> (vp-&gt;v_type == VDIR)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (vp == skipvp)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((flags &amp; SKIPSYSTEM) &amp;&amp; ((vp-&gt;v_flag &amp; VSYSTEM) || (vp-&gt;v_flag &amp; VNOFLUSH)))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((flags &amp; SKIPSWAP) &amp;&amp; (vp-&gt;v_flag &amp; VSWAP))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((flags &amp; WRITECLOSE) &amp;&amp; (vp-&gt;v_writecount == 0 || vp-&gt;v_type != VREG)) 
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* Look for busy vnode */</span>
		<span class="enscript-keyword">if</span> ((vp-&gt;v_usecount != 0) &amp;&amp; ((vp-&gt;v_usecount - vp-&gt;v_kusecount) != 0)) {
			<span class="enscript-keyword">return</span> 1;

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vp-&gt;v_iocount &gt; 0) {
			 <span class="enscript-comment">/* Busy if iocount is &gt; 0 for more than 3 seconds */</span>
			tsleep(&amp;vp-&gt;v_iocount, PVFS, <span class="enscript-string">&quot;vnode_drain_network&quot;</span>, 3 * hz);
			<span class="enscript-keyword">if</span> (vp-&gt;v_iocount &gt; 0)
				<span class="enscript-keyword">return</span> 1;
			<span class="enscript-keyword">continue</span>;
		}
	}
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/* 
 * This routine prepares iteration by moving all the vnodes to worker queue
 * called with mount lock held
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_iterate_prepare</span>(mount_t mp)
{
	vnode_t vp;

	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;mp-&gt;mnt_vnodelist)) {
		<span class="enscript-comment">/* nothing to do */</span>
		<span class="enscript-keyword">return</span> (0);
	} 

	vp = TAILQ_FIRST(&amp;mp-&gt;mnt_vnodelist);
	vp-&gt;v_mntvnodes.tqe_prev = &amp;(mp-&gt;mnt_workerqueue.tqh_first);
	mp-&gt;mnt_workerqueue.tqh_first = mp-&gt;mnt_vnodelist.tqh_first;
	mp-&gt;mnt_workerqueue.tqh_last = mp-&gt;mnt_vnodelist.tqh_last;

	TAILQ_INIT(&amp;mp-&gt;mnt_vnodelist);
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_newvnodes.tqh_first != NULL)
		panic(<span class="enscript-string">&quot;vnode_iterate_prepare: newvnode when entering vnode&quot;</span>);
	TAILQ_INIT(&amp;mp-&gt;mnt_newvnodes);

	<span class="enscript-keyword">return</span> (1);
}


<span class="enscript-comment">/* called with mount lock held */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_iterate_reloadq</span>(mount_t mp)
{
	<span class="enscript-type">int</span> moved = 0;

	<span class="enscript-comment">/* add the remaining entries in workerq to the end of mount vnode list */</span>
	<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;mp-&gt;mnt_workerqueue)) {
		<span class="enscript-type">struct</span> vnode * mvp;
		mvp = TAILQ_LAST(&amp;mp-&gt;mnt_vnodelist, vnodelst);
		
		<span class="enscript-comment">/* Joining the workerque entities to mount vnode list */</span>
		<span class="enscript-keyword">if</span> (mvp)
			mvp-&gt;v_mntvnodes.tqe_next = mp-&gt;mnt_workerqueue.tqh_first;
		<span class="enscript-keyword">else</span>
			mp-&gt;mnt_vnodelist.tqh_first = mp-&gt;mnt_workerqueue.tqh_first;
		mp-&gt;mnt_workerqueue.tqh_first-&gt;v_mntvnodes.tqe_prev = mp-&gt;mnt_vnodelist.tqh_last;
		mp-&gt;mnt_vnodelist.tqh_last = mp-&gt;mnt_workerqueue.tqh_last;
		TAILQ_INIT(&amp;mp-&gt;mnt_workerqueue);
	}

	<span class="enscript-comment">/* add the newvnodes to the head of mount vnode list */</span>
	<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;mp-&gt;mnt_newvnodes)) {
		<span class="enscript-type">struct</span> vnode * nlvp;
		nlvp = TAILQ_LAST(&amp;mp-&gt;mnt_newvnodes, vnodelst);
		
		mp-&gt;mnt_newvnodes.tqh_first-&gt;v_mntvnodes.tqe_prev = &amp;mp-&gt;mnt_vnodelist.tqh_first;
		nlvp-&gt;v_mntvnodes.tqe_next = mp-&gt;mnt_vnodelist.tqh_first;
		<span class="enscript-keyword">if</span>(mp-&gt;mnt_vnodelist.tqh_first) 
			mp-&gt;mnt_vnodelist.tqh_first-&gt;v_mntvnodes.tqe_prev = &amp;nlvp-&gt;v_mntvnodes.tqe_next;
		<span class="enscript-keyword">else</span>
			mp-&gt;mnt_vnodelist.tqh_last = mp-&gt;mnt_newvnodes.tqh_last;
		mp-&gt;mnt_vnodelist.tqh_first = mp-&gt;mnt_newvnodes.tqh_first;
		TAILQ_INIT(&amp;mp-&gt;mnt_newvnodes);
		moved = 1;
	}

	<span class="enscript-keyword">return</span>(moved);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_iterate_clear</span>(mount_t mp)
{
	mp-&gt;mnt_lflag &amp;= ~MNT_LITER;
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; MNT_LITERWAIT) {
		mp-&gt;mnt_lflag &amp;= ~MNT_LITERWAIT;
		wakeup(mp);
	}
}


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/panic_hooks.h&gt;</span>

<span class="enscript-type">struct</span> vnode_iterate_panic_hook {
	panic_hook_t hook;
	mount_t mp;
	<span class="enscript-type">struct</span> vnode *vp;
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vnode_iterate_panic_hook</span>(panic_hook_t *hook_)
{
	<span class="enscript-type">extern</span> <span class="enscript-type">int</span> kdb_log(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...);
	<span class="enscript-type">struct</span> vnode_iterate_panic_hook *hook = (<span class="enscript-type">struct</span> vnode_iterate_panic_hook *)hook_;
	panic_phys_range_t range;
	uint64_t phys;
	
	<span class="enscript-keyword">if</span> (panic_phys_range_before(hook-&gt;mp, &amp;phys, &amp;range)) {
		kdb_log(<span class="enscript-string">&quot;mp = %p, phys = %p, prev (%p: %p-%p)\n&quot;</span>, 
				hook-&gt;mp, phys, range.type, range.phys_start,
				range.phys_start + range.len);
	} <span class="enscript-keyword">else</span> {
		kdb_log(<span class="enscript-string">&quot;mp = %p, phys = %p, prev (!)\n&quot;</span>, hook-&gt;mp, phys);
	}

	<span class="enscript-keyword">if</span> (panic_phys_range_before(hook-&gt;vp, &amp;phys, &amp;range)) {
		kdb_log(<span class="enscript-string">&quot;vp = %p, phys = %p, prev (%p: %p-%p)\n&quot;</span>, 
				hook-&gt;vp, phys, range.type, range.phys_start,
				range.phys_start + range.len);
	} <span class="enscript-keyword">else</span> {
		kdb_log(<span class="enscript-string">&quot;vp = %p, phys = %p, prev (!)\n&quot;</span>, hook-&gt;vp, phys);
	}
	panic_dump_mem((<span class="enscript-type">void</span> *)(((vm_offset_t)hook-&gt;mp -4096) &amp; ~4095), 12288);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_iterate</span>(mount_t mp, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callout)(<span class="enscript-type">struct</span> vnode *, <span class="enscript-type">void</span> *),
	      <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">int</span> vid, retval;
	<span class="enscript-type">int</span> ret = 0;

	mount_lock(mp);

	vnode_iterate_setup(mp);

	<span class="enscript-comment">/* it is returns 0 then there is nothing to do */</span>
	retval = vnode_iterate_prepare(mp);

	<span class="enscript-keyword">if</span> (retval == 0)  {
		vnode_iterate_clear(mp);
		mount_unlock(mp);
		<span class="enscript-keyword">return</span>(ret);
	}

	<span class="enscript-type">struct</span> vnode_iterate_panic_hook hook;
	hook.mp = mp;
	hook.vp = NULL;
	panic_hook(&amp;hook.hook, vnode_iterate_panic_hook);
	<span class="enscript-comment">/* iterate over all the vnodes */</span>
	<span class="enscript-keyword">while</span> (!TAILQ_EMPTY(&amp;mp-&gt;mnt_workerqueue)) {
		vp = TAILQ_FIRST(&amp;mp-&gt;mnt_workerqueue);
		hook.vp = vp;
		TAILQ_REMOVE(&amp;mp-&gt;mnt_workerqueue, vp, v_mntvnodes);
		TAILQ_INSERT_TAIL(&amp;mp-&gt;mnt_vnodelist, vp, v_mntvnodes);
		vid = vp-&gt;v_id;
		<span class="enscript-keyword">if</span> ((vp-&gt;v_data == NULL) || (vp-&gt;v_type == VNON) || (vp-&gt;v_mount != mp)) {
			<span class="enscript-keyword">continue</span>;
		}
		mount_unlock(mp);

		<span class="enscript-keyword">if</span> ( vget_internal(vp, vid, (flags | VNODE_NODEAD| VNODE_WITHID | VNODE_NOSUSPEND))) {
			mount_lock(mp);
			<span class="enscript-keyword">continue</span>;	
		}
		<span class="enscript-keyword">if</span> (flags &amp; VNODE_RELOAD) {
		        <span class="enscript-comment">/*
			 * we're reloading the filesystem
			 * cast out any inactive vnodes...
			 */</span>
		        <span class="enscript-keyword">if</span> (vnode_reload(vp)) {
			        <span class="enscript-comment">/* vnode will be recycled on the refcount drop */</span>
			        vnode_put(vp);
				mount_lock(mp);
			    	<span class="enscript-keyword">continue</span>;
			}
		}

		retval = callout(vp, arg);

		<span class="enscript-keyword">switch</span> (retval) {
		  <span class="enscript-keyword">case</span> <span class="enscript-reference">VNODE_RETURNED</span>:
		  <span class="enscript-keyword">case</span> <span class="enscript-reference">VNODE_RETURNED_DONE</span>:
			  vnode_put(vp);
			  <span class="enscript-keyword">if</span> (retval == VNODE_RETURNED_DONE) {
				mount_lock(mp);
				ret = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			  }
			  <span class="enscript-keyword">break</span>;

		  <span class="enscript-keyword">case</span> <span class="enscript-reference">VNODE_CLAIMED_DONE</span>:
				mount_lock(mp);
				ret = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		  <span class="enscript-keyword">case</span> <span class="enscript-reference">VNODE_CLAIMED</span>:
		  <span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
		}
		mount_lock(mp);
	}

<span class="enscript-reference">out</span>:
	panic_unhook(&amp;hook.hook);
	(<span class="enscript-type">void</span>)vnode_iterate_reloadq(mp);
	vnode_iterate_clear(mp);
	mount_unlock(mp);
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_lock_renames</span>(mount_t mp)
{
	lck_mtx_lock(&amp;mp-&gt;mnt_renamelock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_unlock_renames</span>(mount_t mp)
{
	lck_mtx_unlock(&amp;mp-&gt;mnt_renamelock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_lock</span>(mount_t mp)
{
	lck_mtx_lock(&amp;mp-&gt;mnt_mlock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_lock_spin</span>(mount_t mp)
{
	lck_mtx_lock_spin(&amp;mp-&gt;mnt_mlock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_unlock</span>(mount_t mp)
{
	lck_mtx_unlock(&amp;mp-&gt;mnt_mlock);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_ref</span>(mount_t mp, <span class="enscript-type">int</span> locked)
{
        <span class="enscript-keyword">if</span> ( !locked)
	        mount_lock_spin(mp);
	
	mp-&gt;mnt_count++;

        <span class="enscript-keyword">if</span> ( !locked)
	        mount_unlock(mp);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_drop</span>(mount_t mp, <span class="enscript-type">int</span> locked)
{
        <span class="enscript-keyword">if</span> ( !locked)
	        mount_lock_spin(mp);
	
	mp-&gt;mnt_count--;

	<span class="enscript-keyword">if</span> (mp-&gt;mnt_count == 0 &amp;&amp; (mp-&gt;mnt_lflag &amp; MNT_LDRAIN))
	        wakeup(&amp;mp-&gt;mnt_lflag);

        <span class="enscript-keyword">if</span> ( !locked)
	        mount_unlock(mp);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">mount_iterref</span>(mount_t mp, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-type">int</span> retval = 0;

	<span class="enscript-keyword">if</span> (!locked)
		mount_list_lock();
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_iterref &lt; 0) {
		retval = 1;
	} <span class="enscript-keyword">else</span> {
		mp-&gt;mnt_iterref++;
	}
	<span class="enscript-keyword">if</span> (!locked)
		mount_list_unlock();
	<span class="enscript-keyword">return</span>(retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mount_isdrained</span>(mount_t mp, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-type">int</span> retval;

	<span class="enscript-keyword">if</span> (!locked)
		mount_list_lock();
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_iterref &lt; 0)
		retval = 1;
	<span class="enscript-keyword">else</span>
		retval = 0;	
	<span class="enscript-keyword">if</span> (!locked)
		mount_list_unlock();
	<span class="enscript-keyword">return</span>(retval);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_iterdrop</span>(mount_t mp)
{
	mount_list_lock();
	mp-&gt;mnt_iterref--;
	wakeup(&amp;mp-&gt;mnt_iterref);
	mount_list_unlock();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_iterdrain</span>(mount_t mp)
{
	mount_list_lock();
	<span class="enscript-keyword">while</span> (mp-&gt;mnt_iterref)
		msleep((caddr_t)&amp;mp-&gt;mnt_iterref, mnt_list_mtx_lock, PVFS, <span class="enscript-string">&quot;mount_iterdrain&quot;</span>, NULL);
	<span class="enscript-comment">/* mount iterations drained */</span>
	mp-&gt;mnt_iterref = -1;
	mount_list_unlock();
}
<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_iterreset</span>(mount_t mp)
{
	mount_list_lock();
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_iterref == -1)
		mp-&gt;mnt_iterref = 0;
	mount_list_unlock();
}

<span class="enscript-comment">/* always called with  mount lock held */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">mount_refdrain</span>(mount_t mp)
{
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; MNT_LDRAIN)
		panic(<span class="enscript-string">&quot;already in drain&quot;</span>);
	mp-&gt;mnt_lflag |= MNT_LDRAIN;

	<span class="enscript-keyword">while</span> (mp-&gt;mnt_count)
		msleep((caddr_t)&amp;mp-&gt;mnt_lflag, &amp;mp-&gt;mnt_mlock, PVFS, <span class="enscript-string">&quot;mount_drain&quot;</span>, NULL);

	<span class="enscript-keyword">if</span> (mp-&gt;mnt_vnodelist.tqh_first != NULL)
		 panic(<span class="enscript-string">&quot;mount_refdrain: dangling vnode&quot;</span>); 

	mp-&gt;mnt_lflag &amp;= ~MNT_LDRAIN;

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/* Tags the mount point as not supportine extended readdir for NFS exports */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">mount_set_noreaddirext</span>(mount_t mp) {
	mount_lock (mp);
	mp-&gt;mnt_kern_flag |= MNTK_DENY_READDIREXT;
	mount_unlock (mp);
}

<span class="enscript-comment">/*
 * Mark a mount point as busy. Used to synchronize access and to delay
 * unmounting.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_busy</span>(mount_t mp, <span class="enscript-type">int</span> flags)
{

<span class="enscript-reference">restart</span>:
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; MNT_LDEAD)
		<span class="enscript-keyword">return</span> (ENOENT);

	mount_lock(mp);

	<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; MNT_LUNMOUNT) {
		<span class="enscript-keyword">if</span> (flags &amp; LK_NOWAIT || mp-&gt;mnt_lflag &amp; MNT_LDEAD) {
		        mount_unlock(mp);
			<span class="enscript-keyword">return</span> (ENOENT);
		}

		<span class="enscript-comment">/*
		 * Since all busy locks are shared except the exclusive
		 * lock granted when unmounting, the only place that a
		 * wakeup needs to be done is at the release of the
		 * exclusive lock at the end of dounmount.
		 */</span>
		mp-&gt;mnt_lflag |= MNT_LWAIT;
		msleep((caddr_t)mp, &amp;mp-&gt;mnt_mlock, (PVFS | PDROP), <span class="enscript-string">&quot;vfsbusy&quot;</span>, NULL);
		<span class="enscript-keyword">return</span> (ENOENT);
	}

	mount_unlock(mp);

	lck_rw_lock_shared(&amp;mp-&gt;mnt_rwlock);

	<span class="enscript-comment">/* 
	 * Until we are granted the rwlock, it's possible for the mount point to
	 * change state, so re-evaluate before granting the vfs_busy.
	 */</span>
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; (MNT_LDEAD | MNT_LUNMOUNT)) {
		lck_rw_done(&amp;mp-&gt;mnt_rwlock);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Free a busy filesystem.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_unbusy</span>(mount_t mp)
{
	lck_rw_done(&amp;mp-&gt;mnt_rwlock);
}



<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_rootmountfailed</span>(mount_t mp) {

	mount_list_lock();
	mp-&gt;mnt_vtable-&gt;vfc_refcount--;
	mount_list_unlock();

	vfs_unbusy(mp);

	mount_lock_destroy(mp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_mount_label_destroy(mp);
#<span class="enscript-reference">endif</span>

	FREE_ZONE(mp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount), M_MOUNT);
}

<span class="enscript-comment">/*
 * Lookup a filesystem type, and if found allocate and initialize
 * a mount structure for it.
 *
 * Devname is usually updated by mount(8) after booting.
 */</span>
<span class="enscript-type">static</span> mount_t
<span class="enscript-function-name">vfs_rootmountalloc_internal</span>(<span class="enscript-type">struct</span> vfstable *vfsp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *devname)
{
	mount_t	mp;

	mp = _MALLOC_ZONE(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount), M_MOUNT, M_WAITOK);
	bzero((<span class="enscript-type">char</span> *)mp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount));

	<span class="enscript-comment">/* Initialize the default IO constraints */</span>
	mp-&gt;mnt_maxreadcnt = mp-&gt;mnt_maxwritecnt = MAXPHYS;
	mp-&gt;mnt_segreadcnt = mp-&gt;mnt_segwritecnt = 32;
	mp-&gt;mnt_maxsegreadsize = mp-&gt;mnt_maxreadcnt;
	mp-&gt;mnt_maxsegwritesize = mp-&gt;mnt_maxwritecnt;
	mp-&gt;mnt_devblocksize = DEV_BSIZE;
	mp-&gt;mnt_alignmentmask = PAGE_MASK;
	mp-&gt;mnt_ioqueue_depth = MNT_DEFAULT_IOQUEUE_DEPTH;
	mp-&gt;mnt_ioscale = 1;
	mp-&gt;mnt_ioflags = 0;
	mp-&gt;mnt_realrootvp = NULLVP;
	mp-&gt;mnt_authcache_ttl = CACHED_LOOKUP_RIGHT_TTL;
	mp-&gt;mnt_throttle_mask = LOWPRI_MAX_NUM_DEV - 1;
	mp-&gt;mnt_devbsdunit = 0;

	mount_lock_init(mp);
	(<span class="enscript-type">void</span>)vfs_busy(mp, LK_NOWAIT);

	TAILQ_INIT(&amp;mp-&gt;mnt_vnodelist);
	TAILQ_INIT(&amp;mp-&gt;mnt_workerqueue);
	TAILQ_INIT(&amp;mp-&gt;mnt_newvnodes);

	mp-&gt;mnt_vtable = vfsp;
	mp-&gt;mnt_op = vfsp-&gt;vfc_vfsops;
	mp-&gt;mnt_flag = MNT_RDONLY | MNT_ROOTFS;
	mp-&gt;mnt_vnodecovered = NULLVP;
	<span class="enscript-comment">//mp-&gt;mnt_stat.f_type = vfsp-&gt;vfc_typenum;
</span>	mp-&gt;mnt_flag |= vfsp-&gt;vfc_flags &amp; MNT_VISFLAGMASK;

	mount_list_lock();
	vfsp-&gt;vfc_refcount++;
	mount_list_unlock();

	strlcpy(mp-&gt;mnt_vfsstat.f_fstypename, vfsp-&gt;vfc_name, MFSTYPENAMELEN);
	mp-&gt;mnt_vfsstat.f_mntonname[0] = <span class="enscript-string">'/'</span>;
	<span class="enscript-comment">/* XXX const poisoning layering violation */</span>
	(<span class="enscript-type">void</span>) copystr((<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)devname, mp-&gt;mnt_vfsstat.f_mntfromname, MAXPATHLEN - 1, NULL);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_mount_label_init(mp);
	mac_mount_label_associate(vfs_context_kernel(), mp);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (mp);
}

errno_t
<span class="enscript-function-name">vfs_rootmountalloc</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fstypename, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *devname, mount_t *mpp)
{
        <span class="enscript-type">struct</span> vfstable *vfsp;

	<span class="enscript-keyword">for</span> (vfsp = vfsconf; vfsp; vfsp = vfsp-&gt;vfc_next)
	        <span class="enscript-keyword">if</span> (!strncmp(vfsp-&gt;vfc_name, fstypename,
			     <span class="enscript-keyword">sizeof</span>(vfsp-&gt;vfc_name)))
		        <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">if</span> (vfsp == NULL)
	        <span class="enscript-keyword">return</span> (ENODEV);

	*mpp = vfs_rootmountalloc_internal(vfsp, devname);

	<span class="enscript-keyword">if</span> (*mpp)
	        <span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span> (ENOMEM);
}


<span class="enscript-comment">/*
 * Find an appropriate filesystem to use for the root. If a filesystem
 * has not been preselected, walk through the list of known filesystems
 * trying those that have mountroot routines, and try them until one
 * works or we have tried them all.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (*mountroot)(<span class="enscript-type">void</span>);

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_mountroot</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">struct</span> vnode *vp;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> vfstable *vfsp;
	vfs_context_t ctx = vfs_context_kernel();
	<span class="enscript-type">struct</span> vfs_attr	vfsattr;
	<span class="enscript-type">int</span>	error;
	mount_t mp;
	vnode_t	bdevvp_rootvp;

	<span class="enscript-keyword">if</span> (mountroot != NULL) {
		<span class="enscript-comment">/*
		 * used for netboot which follows a different set of rules
		 */</span>
		error = (*mountroot)();
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ((error = bdevvp(rootdev, &amp;rootvp))) {
		printf(<span class="enscript-string">&quot;vfs_mountroot: can't setup bdevvp\n&quot;</span>);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-comment">/*
	 * 4951998 - code we call in vfc_mountroot may replace rootvp 
	 * so keep a local copy for some house keeping.
	 */</span>
	bdevvp_rootvp = rootvp;

	<span class="enscript-keyword">for</span> (vfsp = vfsconf; vfsp; vfsp = vfsp-&gt;vfc_next) {
		<span class="enscript-keyword">if</span> (vfsp-&gt;vfc_mountroot == NULL)
			<span class="enscript-keyword">continue</span>;

		mp = vfs_rootmountalloc_internal(vfsp, <span class="enscript-string">&quot;root_device&quot;</span>);
		mp-&gt;mnt_devvp = rootvp;

		<span class="enscript-keyword">if</span> ((error = (*vfsp-&gt;vfc_mountroot)(mp, rootvp, ctx)) == 0) {
			<span class="enscript-keyword">if</span> ( bdevvp_rootvp != rootvp ) {
				<span class="enscript-comment">/*
				 * rootvp changed...
				 *   bump the iocount and fix up mnt_devvp for the
				 *   new rootvp (it will already have a usecount taken)...
				 *   drop the iocount and the usecount on the orignal
				 *   since we are no longer going to use it...
				 */</span>
				vnode_getwithref(rootvp);
				mp-&gt;mnt_devvp = rootvp;

			        vnode_rele(bdevvp_rootvp);
			        vnode_put(bdevvp_rootvp);
			}
			mp-&gt;mnt_devvp-&gt;v_specflags |= SI_MOUNTEDON;

			vfs_unbusy(mp);

			mount_list_add(mp);

			<span class="enscript-comment">/*
			 *   cache the IO attributes for the underlying physical media...
			 *   an error return indicates the underlying driver doesn't
			 *   support all the queries necessary... however, reasonable
			 *   defaults will have been set, so no reason to bail or care
			 */</span>
			vfs_init_io_attributes(rootvp, mp);

			<span class="enscript-keyword">if</span> ((mp-&gt;mnt_ioflags &amp; MNT_IOFLAGS_FUSION_DRIVE) &amp;&amp; 
			    (mp-&gt;mnt_ioflags &amp; MNT_IOFLAGS_IOSCHED_SUPPORTED)) {
				<span class="enscript-comment">/*
				 * only for CF
				 */</span>
				root_is_CF_drive = TRUE;
			}
			<span class="enscript-comment">/*
			 * Shadow the VFC_VFSNATIVEXATTR flag to MNTK_EXTENDED_ATTRS.
			 */</span>
			<span class="enscript-keyword">if</span> (mp-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSNATIVEXATTR) {
				mp-&gt;mnt_kern_flag |= MNTK_EXTENDED_ATTRS;
			}
			<span class="enscript-keyword">if</span> (mp-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSPREFLIGHT) {
				mp-&gt;mnt_kern_flag |= MNTK_UNMOUNT_PREFLIGHT;
			}

			uint32_t speed;

			<span class="enscript-keyword">if</span> (MNTK_VIRTUALDEV &amp; mp-&gt;mnt_kern_flag) speed = 128;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (MNTK_SSD &amp; mp-&gt;mnt_kern_flag)   speed = 7*256;
			<span class="enscript-keyword">else</span>                                     speed = 256;
			vc_progress_setdiskspeed(speed);
			<span class="enscript-comment">/*
			 * Probe root file system for additional features.
			 */</span>
			(<span class="enscript-type">void</span>)VFS_START(mp, 0, ctx);

			VFSATTR_INIT(&amp;vfsattr);
			VFSATTR_WANTED(&amp;vfsattr, f_capabilities);
			<span class="enscript-keyword">if</span> (vfs_getattr(mp, &amp;vfsattr, ctx) == 0 &amp;&amp; 
			    VFSATTR_IS_SUPPORTED(&amp;vfsattr, f_capabilities)) {
				<span class="enscript-keyword">if</span> ((vfsattr.f_capabilities.capabilities[VOL_CAPABILITIES_INTERFACES] &amp; VOL_CAP_INT_EXTENDED_ATTR) &amp;&amp;
				    (vfsattr.f_capabilities.valid[VOL_CAPABILITIES_INTERFACES] &amp; VOL_CAP_INT_EXTENDED_ATTR)) {
					mp-&gt;mnt_kern_flag |= MNTK_EXTENDED_ATTRS;
				}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
				<span class="enscript-keyword">if</span> ((vfsattr.f_capabilities.capabilities[VOL_CAPABILITIES_INTERFACES] &amp; VOL_CAP_INT_NAMEDSTREAMS) &amp;&amp;
				    (vfsattr.f_capabilities.valid[VOL_CAPABILITIES_INTERFACES] &amp; VOL_CAP_INT_NAMEDSTREAMS)) {
					mp-&gt;mnt_kern_flag |= MNTK_NAMED_STREAMS;
				}
#<span class="enscript-reference">endif</span>
				<span class="enscript-keyword">if</span> ((vfsattr.f_capabilities.capabilities[VOL_CAPABILITIES_FORMAT] &amp; VOL_CAP_FMT_PATH_FROM_ID) &amp;&amp;
				    (vfsattr.f_capabilities.valid[VOL_CAPABILITIES_FORMAT] &amp; VOL_CAP_FMT_PATH_FROM_ID)) {
					mp-&gt;mnt_kern_flag |= MNTK_PATH_FROM_ID;
				}
			}

			<span class="enscript-comment">/*
			 * get rid of iocount reference returned
			 * by bdevvp (or picked up by us on the substitued
			 * rootvp)... it (or we) will have also taken
			 * a usecount reference which we want to keep
			 */</span>
			vnode_put(rootvp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
			<span class="enscript-keyword">if</span> ((vfs_flags(mp) &amp; MNT_MULTILABEL) == 0)
				<span class="enscript-keyword">return</span> (0);

			error = VFS_ROOT(mp, &amp;vp, ctx);
			<span class="enscript-keyword">if</span> (error) {
				printf(<span class="enscript-string">&quot;%s() VFS_ROOT() returned %d\n&quot;</span>,
				    __func__, error);
				dounmount(mp, MNT_FORCE, 0, ctx);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			error = vnode_label(mp, NULL, vp, NULL, 0, ctx);
			<span class="enscript-comment">/*
			 * get rid of reference provided by VFS_ROOT
			 */</span>
			vnode_put(vp);

			<span class="enscript-keyword">if</span> (error) {
				printf(<span class="enscript-string">&quot;%s() vnode_label() returned %d\n&quot;</span>,
				    __func__, error);
				dounmount(mp, MNT_FORCE, 0, ctx);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">return</span> (0);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
<span class="enscript-reference">fail</span>:
#<span class="enscript-reference">endif</span>
		vfs_rootmountfailed(mp);
		
		<span class="enscript-keyword">if</span> (error != EINVAL)
			printf(<span class="enscript-string">&quot;%s_mountroot failed: %d\n&quot;</span>, vfsp-&gt;vfc_name, error);
	}
	<span class="enscript-keyword">return</span> (ENODEV);
}

<span class="enscript-comment">/*
 * Lookup a mount point by filesystem identifier.
 */</span>

<span class="enscript-type">struct</span> mount *
<span class="enscript-function-name">vfs_getvfs</span>(fsid_t *fsid)
{
	<span class="enscript-keyword">return</span> (mount_list_lookupby_fsid(fsid, 0, 0));
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mount *
<span class="enscript-function-name">vfs_getvfs_locked</span>(fsid_t *fsid)
{
	<span class="enscript-keyword">return</span>(mount_list_lookupby_fsid(fsid, 1, 0));
}

<span class="enscript-type">struct</span> mount *
<span class="enscript-function-name">vfs_getvfs_by_mntonname</span>(<span class="enscript-type">char</span> *path)
{
	mount_t retmp = (mount_t)0;
	mount_t mp;

	mount_list_lock();
	TAILQ_FOREACH(mp, &amp;mountlist, mnt_list) {
		<span class="enscript-keyword">if</span> (!strncmp(mp-&gt;mnt_vfsstat.f_mntonname, path,
					<span class="enscript-keyword">sizeof</span>(mp-&gt;mnt_vfsstat.f_mntonname))) {
			retmp = mp;
			<span class="enscript-keyword">if</span> (mount_iterref(retmp, 1))
				retmp = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
<span class="enscript-reference">out</span>:
	mount_list_unlock();
	<span class="enscript-keyword">return</span> (retmp);
}

<span class="enscript-comment">/* generation number for creation of new fsids */</span>
u_short mntid_gen = 0;
<span class="enscript-comment">/*
 * Get a new unique fsid
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_getnewfsid</span>(<span class="enscript-type">struct</span> mount *mp)
{

	fsid_t tfsid;
	<span class="enscript-type">int</span> mtype;
	mount_t nmp;

	mount_list_lock();

	<span class="enscript-comment">/* generate a new fsid */</span>
	mtype = mp-&gt;mnt_vtable-&gt;vfc_typenum;
	<span class="enscript-keyword">if</span> (++mntid_gen == 0)
		mntid_gen++;
	tfsid.val[0] = makedev(nblkdev + mtype, mntid_gen);
	tfsid.val[1] = mtype;

	TAILQ_FOREACH(nmp, &amp;mountlist, mnt_list) {
		<span class="enscript-keyword">while</span> (vfs_getvfs_locked(&amp;tfsid)) {
			<span class="enscript-keyword">if</span> (++mntid_gen == 0)
				mntid_gen++;
			tfsid.val[0] = makedev(nblkdev + mtype, mntid_gen);
		}
	}
	mp-&gt;mnt_vfsstat.f_fsid.val[0] = tfsid.val[0];
	mp-&gt;mnt_vfsstat.f_fsid.val[1] = tfsid.val[1];
	mount_list_unlock();
}

<span class="enscript-comment">/*
 * Routines having to do with the management of the vnode table.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (**dead_vnodeop_p)(<span class="enscript-type">void</span> *);
<span class="enscript-type">long</span> numvnodes, freevnodes, deadvnodes, async_work_vnodes;


<span class="enscript-type">int</span> async_work_timed_out = 0;
<span class="enscript-type">int</span> async_work_handled = 0;
<span class="enscript-type">int</span> dead_vnode_wanted = 0;
<span class="enscript-type">int</span> dead_vnode_waited = 0;

<span class="enscript-comment">/*
 * Move a vnode from one mount queue to another.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">insmntque</span>(vnode_t vp, mount_t mp)
{
	mount_t lmp;
	<span class="enscript-comment">/*
	 * Delete from old mount point vnode list, if on one.
	 */</span>
	<span class="enscript-keyword">if</span> ( (lmp = vp-&gt;v_mount) != NULL &amp;&amp; lmp != dead_mountp) {
		<span class="enscript-keyword">if</span> ((vp-&gt;v_lflag &amp; VNAMED_MOUNT) == 0)
			panic(<span class="enscript-string">&quot;insmntque: vp not in mount vnode list&quot;</span>);
		vp-&gt;v_lflag &amp;= ~VNAMED_MOUNT;

		mount_lock_spin(lmp);

		mount_drop(lmp, 1);

		<span class="enscript-keyword">if</span> (vp-&gt;v_mntvnodes.tqe_next == NULL) {
			<span class="enscript-keyword">if</span> (TAILQ_LAST(&amp;lmp-&gt;mnt_vnodelist, vnodelst) == vp)
				TAILQ_REMOVE(&amp;lmp-&gt;mnt_vnodelist, vp, v_mntvnodes);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (TAILQ_LAST(&amp;lmp-&gt;mnt_newvnodes, vnodelst) == vp)
				TAILQ_REMOVE(&amp;lmp-&gt;mnt_newvnodes, vp, v_mntvnodes);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (TAILQ_LAST(&amp;lmp-&gt;mnt_workerqueue, vnodelst) == vp)
				TAILQ_REMOVE(&amp;lmp-&gt;mnt_workerqueue, vp, v_mntvnodes);
		 } <span class="enscript-keyword">else</span> {
			vp-&gt;v_mntvnodes.tqe_next-&gt;v_mntvnodes.tqe_prev = vp-&gt;v_mntvnodes.tqe_prev;
			*vp-&gt;v_mntvnodes.tqe_prev = vp-&gt;v_mntvnodes.tqe_next;
		}	
		vp-&gt;v_mntvnodes.tqe_next = NULL;
		vp-&gt;v_mntvnodes.tqe_prev = NULL;
		mount_unlock(lmp);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * Insert into list of vnodes for the new mount point, if available.
	 */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_mount = mp) != NULL) {
		mount_lock_spin(mp);
		<span class="enscript-keyword">if</span> ((vp-&gt;v_mntvnodes.tqe_next != 0) &amp;&amp; (vp-&gt;v_mntvnodes.tqe_prev != 0))
			panic(<span class="enscript-string">&quot;vp already in mount list&quot;</span>);
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; MNT_LITER)
			TAILQ_INSERT_HEAD(&amp;mp-&gt;mnt_newvnodes, vp, v_mntvnodes);
		<span class="enscript-keyword">else</span>
			TAILQ_INSERT_HEAD(&amp;mp-&gt;mnt_vnodelist, vp, v_mntvnodes);
		<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VNAMED_MOUNT)
			panic(<span class="enscript-string">&quot;insmntque: vp already in mount vnode list&quot;</span>);
		vp-&gt;v_lflag |= VNAMED_MOUNT;
		mount_ref(mp, 1);
		mount_unlock(mp);
	}
}


<span class="enscript-comment">/*
 * Create a vnode for a block device.
 * Used for root filesystem, argdev, and swap areas.
 * Also used for memory file system special devices.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">bdevvp</span>(dev_t dev, vnode_t *vpp)
{
	vnode_t	nvp;
	<span class="enscript-type">int</span>	error;
	<span class="enscript-type">struct</span> vnode_fsparam vfsp;
	<span class="enscript-type">struct</span> vfs_context context;

	<span class="enscript-keyword">if</span> (dev == NODEV) {
		*vpp = NULLVP;
		<span class="enscript-keyword">return</span> (ENODEV);
	}

	context.vc_thread = current_thread();
	context.vc_ucred = FSCRED;

	vfsp.vnfs_mp = (<span class="enscript-type">struct</span> mount *)0;
	vfsp.vnfs_vtype = VBLK;
	vfsp.vnfs_str = <span class="enscript-string">&quot;bdevvp&quot;</span>;
	vfsp.vnfs_dvp = NULL;
	vfsp.vnfs_fsnode = NULL;
	vfsp.vnfs_cnp = NULL;
	vfsp.vnfs_vops = spec_vnodeop_p;
	vfsp.vnfs_rdev = dev;
	vfsp.vnfs_filesize = 0;

	vfsp.vnfs_flags = VNFS_NOCACHE | VNFS_CANTCACHE;

	vfsp.vnfs_marksystem = 0;
	vfsp.vnfs_markroot = 0;

	<span class="enscript-keyword">if</span> ( (error = vnode_create(VNCREATE_FLAVOR, VCREATESIZE, &amp;vfsp, &amp;nvp)) ) {
		*vpp = NULLVP;
		<span class="enscript-keyword">return</span> (error);
	}
	vnode_lock_spin(nvp);
	nvp-&gt;v_flag |= VBDEVVP;
	nvp-&gt;v_tag = VT_NON;	<span class="enscript-comment">/* set this to VT_NON so during aliasing it can be replaced */</span>
	vnode_unlock(nvp);
	<span class="enscript-keyword">if</span> ( (error = vnode_ref(nvp)) ) {
		panic(<span class="enscript-string">&quot;bdevvp failed: vnode_ref&quot;</span>);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ( (error = VNOP_FSYNC(nvp, MNT_WAIT, &amp;context)) ) {
		panic(<span class="enscript-string">&quot;bdevvp failed: fsync&quot;</span>);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ( (error = buf_invalidateblks(nvp, BUF_WRITE_DATA, 0, 0)) ) {
		panic(<span class="enscript-string">&quot;bdevvp failed: invalidateblks&quot;</span>);
		<span class="enscript-keyword">return</span> (error);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/* 
	 * XXXMAC: We can't put a MAC check here, the system will
	 * panic without this vnode.
	 */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>	

	<span class="enscript-keyword">if</span> ( (error = VNOP_OPEN(nvp, FREAD, &amp;context)) ) {
		panic(<span class="enscript-string">&quot;bdevvp failed: open&quot;</span>);
		<span class="enscript-keyword">return</span> (error);
	}
	*vpp = nvp;

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Check to see if the new vnode represents a special device
 * for which we already have a vnode (either because of
 * bdevvp() or because of a different vnode representing
 * the same block device). If such an alias exists, deallocate
 * the existing contents and return the aliased vnode. The
 * caller is responsible for filling it with its new contents.
 */</span>
<span class="enscript-type">static</span> vnode_t
<span class="enscript-function-name">checkalias</span>(<span class="enscript-type">struct</span> vnode *nvp, dev_t nvp_rdev)
{
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">struct</span> vnode **vpp;
	<span class="enscript-type">struct</span> specinfo *sin = NULL;
	<span class="enscript-type">int</span> vid = 0;

	vpp = &amp;speclisth[SPECHASH(nvp_rdev)];
<span class="enscript-reference">loop</span>:
	SPECHASH_LOCK();

	<span class="enscript-keyword">for</span> (vp = *vpp; vp; vp = vp-&gt;v_specnext) {
		<span class="enscript-keyword">if</span> (nvp_rdev == vp-&gt;v_rdev &amp;&amp; nvp-&gt;v_type == vp-&gt;v_type) {
		        vid = vp-&gt;v_id;
			<span class="enscript-keyword">break</span>;
		}
	}
	SPECHASH_UNLOCK();

	<span class="enscript-keyword">if</span> (vp) {
<span class="enscript-reference">found_alias</span>:
	        <span class="enscript-keyword">if</span> (vnode_getwithvid(vp,vid)) {
		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
		}
		<span class="enscript-comment">/*
		 * Termination state is checked in vnode_getwithvid
		 */</span>
		vnode_lock(vp);

		<span class="enscript-comment">/*
		 * Alias, but not in use, so flush it out.
		 */</span>
		<span class="enscript-keyword">if</span> ((vp-&gt;v_iocount == 1) &amp;&amp; (vp-&gt;v_usecount == 0)) {
		        vnode_reclaim_internal(vp, 1, 1, 0);
			vnode_put_locked(vp);
			vnode_unlock(vp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
		}
		
	}
	<span class="enscript-keyword">if</span> (vp == NULL || vp-&gt;v_tag != VT_NON) {
		<span class="enscript-keyword">if</span> (sin == NULL) {
			MALLOC_ZONE(sin, <span class="enscript-type">struct</span> specinfo *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> specinfo),
					M_SPECINFO, M_WAITOK);
		}

		nvp-&gt;v_specinfo = sin;
		bzero(nvp-&gt;v_specinfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> specinfo));
		nvp-&gt;v_rdev = nvp_rdev;
		nvp-&gt;v_specflags = 0;
		nvp-&gt;v_speclastr = -1;
		nvp-&gt;v_specinfo-&gt;si_opencount = 0;
		nvp-&gt;v_specinfo-&gt;si_initted = 0;
		nvp-&gt;v_specinfo-&gt;si_throttleable = 0;

		SPECHASH_LOCK();
		
		<span class="enscript-comment">/* We dropped the lock, someone could have added */</span>
		<span class="enscript-keyword">if</span> (vp == NULLVP) {
			<span class="enscript-keyword">for</span> (vp = *vpp; vp; vp = vp-&gt;v_specnext) {
				<span class="enscript-keyword">if</span> (nvp_rdev == vp-&gt;v_rdev &amp;&amp; nvp-&gt;v_type == vp-&gt;v_type) {
					vid = vp-&gt;v_id;
					SPECHASH_UNLOCK();
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">found_alias</span>;
				}
			}
		} 

		nvp-&gt;v_hashchain = vpp;
		nvp-&gt;v_specnext = *vpp;
		*vpp = nvp;

		<span class="enscript-keyword">if</span> (vp != NULLVP) {
			nvp-&gt;v_specflags |= SI_ALIASED;
			vp-&gt;v_specflags |= SI_ALIASED;
			SPECHASH_UNLOCK();
			vnode_put_locked(vp);
			vnode_unlock(vp);
		} <span class="enscript-keyword">else</span> {
			SPECHASH_UNLOCK();
		}

		<span class="enscript-keyword">return</span> (NULLVP);
	}

	<span class="enscript-keyword">if</span> (sin) {
		FREE_ZONE(sin, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> specinfo), M_SPECINFO);
	}

	<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; (VBDEVVP | VDEVFLUSH)) != 0)
		<span class="enscript-keyword">return</span>(vp);

	panic(<span class="enscript-string">&quot;checkalias with VT_NON vp that shouldn't: %p&quot;</span>, vp);

	<span class="enscript-keyword">return</span> (vp);
}


<span class="enscript-comment">/*
 * Get a reference on a particular vnode and lock it if requested.
 * If the vnode was on the inactive list, remove it from the list.
 * If the vnode was on the free list, remove it from the list and
 * move it to inactive list as needed.
 * The vnode lock bit is set if the vnode is being eliminated in
 * vgone. The process is awakened when the transition is completed,
 * and an error returned to indicate that the vnode is no longer
 * usable (possibly having been changed to a new file system type).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vget_internal</span>(vnode_t vp, <span class="enscript-type">int</span> vid, <span class="enscript-type">int</span> vflags)
{
	<span class="enscript-type">int</span> error = 0;

	vnode_lock_spin(vp);

	<span class="enscript-keyword">if</span> ((vflags &amp; VNODE_WRITEABLE) &amp;&amp; (vp-&gt;v_writecount == 0))
	        <span class="enscript-comment">/*
		 * vnode to be returned only if it has writers opened 
		 */</span>
	        error = EINVAL;
	<span class="enscript-keyword">else</span>
	        error = vnode_getiocount(vp, vid, vflags);

	vnode_unlock(vp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		ENOENT			No such file or directory [terminating]
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_ref</span>(vnode_t vp)
{

        <span class="enscript-keyword">return</span> (vnode_ref_ext(vp, 0, 0));
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		ENOENT			No such file or directory [terminating]
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_ref_ext</span>(vnode_t vp, <span class="enscript-type">int</span> fmode, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">int</span>	error = 0;

	vnode_lock_spin(vp);

	<span class="enscript-comment">/*
	 * once all the current call sites have been fixed to insure they have
	 * taken an iocount, we can toughen this assert up and insist that the
	 * iocount is non-zero... a non-zero usecount doesn't insure correctness
	 */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_iocount &lt;= 0 &amp;&amp; vp-&gt;v_usecount &lt;= 0) 
		panic(<span class="enscript-string">&quot;vnode_ref_ext: vp %p has no valid reference %d, %d&quot;</span>, vp, vp-&gt;v_iocount, vp-&gt;v_usecount);

	<span class="enscript-comment">/*
	 * if you are the owner of drain/termination, can acquire usecount
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; VNODE_REF_FORCE) == 0) {
		<span class="enscript-keyword">if</span> ((vp-&gt;v_lflag &amp; (VL_DRAIN | VL_TERMINATE | VL_DEAD))) {
			<span class="enscript-keyword">if</span> (vp-&gt;v_owner != current_thread()) {
				error = ENOENT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}
	vp-&gt;v_usecount++;

	<span class="enscript-keyword">if</span> (fmode &amp; FWRITE) {
	        <span class="enscript-keyword">if</span> (++vp-&gt;v_writecount &lt;= 0)
		        panic(<span class="enscript-string">&quot;vnode_ref_ext: v_writecount&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (fmode &amp; O_EVTONLY) {
	        <span class="enscript-keyword">if</span> (++vp-&gt;v_kusecount &lt;= 0)
		        panic(<span class="enscript-string">&quot;vnode_ref_ext: v_kusecount&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VRAGE) {
	        <span class="enscript-type">struct</span>  uthread *ut;

	        ut = get_bsdthread_info(current_thread());
		
	        <span class="enscript-keyword">if</span> ( !(current_proc()-&gt;p_lflag &amp; P_LRAGE_VNODES) &amp;&amp;
		     !(ut-&gt;uu_flag &amp; UT_RAGE_VNODES)) {
		        <span class="enscript-comment">/*
			 * a 'normal' process accessed this vnode
			 * so make sure its no longer marked
			 * for rapid aging...  also, make sure
			 * it gets removed from the rage list...
			 * when v_usecount drops back to 0, it
			 * will be put back on the real free list
			 */</span>
			vp-&gt;v_flag &amp;= ~VRAGE;
			vp-&gt;v_references = 0;
			vnode_list_remove(vp);
		}
	}
	<span class="enscript-keyword">if</span> (vp-&gt;v_usecount == 1 &amp;&amp; vp-&gt;v_type == VREG &amp;&amp; !(vp-&gt;v_flag &amp; VSYSTEM)) {

		<span class="enscript-keyword">if</span> (vp-&gt;v_ubcinfo) {
			vnode_lock_convert(vp);
			memory_object_mark_used(vp-&gt;v_ubcinfo-&gt;ui_control);
		}
	}
<span class="enscript-reference">out</span>:
	vnode_unlock(vp);

	<span class="enscript-keyword">return</span> (error);
}


boolean_t
<span class="enscript-function-name">vnode_on_reliable_media</span>(vnode_t vp)
{
	<span class="enscript-keyword">if</span> ( !(vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_VIRTUALDEV) &amp;&amp; (vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_LOCAL) )
		<span class="enscript-keyword">return</span> (TRUE);
	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_async_list_add</span>(vnode_t vp)
{
	vnode_list_lock();

	<span class="enscript-keyword">if</span> (VONLIST(vp) || (vp-&gt;v_lflag &amp; (VL_TERMINATE|VL_DEAD)))
		panic(<span class="enscript-string">&quot;vnode_async_list_add: %p is in wrong state&quot;</span>, vp);

	TAILQ_INSERT_HEAD(&amp;vnode_async_work_list, vp, v_freelist);
	vp-&gt;v_listflag |= VLIST_ASYNC_WORK;

	async_work_vnodes++;

	vnode_list_unlock();

	wakeup(&amp;vnode_async_work_list);

}


<span class="enscript-comment">/*
 * put the vnode on appropriate free list.
 * called with vnode LOCKED
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_list_add</span>(vnode_t vp)
{
	boolean_t need_dead_wakeup = FALSE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	lck_mtx_assert(&amp;vp-&gt;v_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">again</span>:

	<span class="enscript-comment">/*
	 * if it is already on a list or non zero references return 
	 */</span>
	<span class="enscript-keyword">if</span> (VONLIST(vp) || (vp-&gt;v_usecount != 0) || (vp-&gt;v_iocount != 0) || (vp-&gt;v_lflag &amp; VL_TERMINATE))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * In vclean, we might have deferred ditching locked buffers
	 * because something was still referencing them (indicated by
	 * usecount).  We can ditch them now.
	 */</span>
	<span class="enscript-keyword">if</span> (ISSET(vp-&gt;v_lflag, VL_DEAD)
		&amp;&amp; (!LIST_EMPTY(&amp;vp-&gt;v_cleanblkhd) || !LIST_EMPTY(&amp;vp-&gt;v_dirtyblkhd))) {
		++vp-&gt;v_iocount;	<span class="enscript-comment">// Probably not necessary, but harmless
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
		record_vp(vp, 1);
#<span class="enscript-reference">endif</span>
		vnode_unlock(vp);
		buf_invalidateblks(vp, BUF_INVALIDATE_LOCKED, 0, 0);
		vnode_lock(vp);
		vnode_dropiocount(vp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}

	vnode_list_lock();

	<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VRAGE) &amp;&amp; !(vp-&gt;v_lflag &amp; VL_DEAD)) {
		<span class="enscript-comment">/*
		 * add the new guy to the appropriate end of the RAGE list
		 */</span>
		<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VAGE))
		        TAILQ_INSERT_HEAD(&amp;vnode_rage_list, vp, v_freelist);
		<span class="enscript-keyword">else</span>
		        TAILQ_INSERT_TAIL(&amp;vnode_rage_list, vp, v_freelist);

		vp-&gt;v_listflag |= VLIST_RAGE;
		ragevnodes++;

		<span class="enscript-comment">/*
		 * reset the timestamp for the last inserted vp on the RAGE
		 * queue to let new_vnode know that its not ok to start stealing
		 * from this list... as long as we're actively adding to this list
		 * we'll push out the vnodes we want to donate to the real free list
		 * once we stop pushing, we'll let some time elapse before we start
		 * stealing them in the new_vnode routine
		 */</span>
		microuptime(&amp;rage_tv);
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-comment">/*
		 * if VL_DEAD, insert it at head of the dead list
		 * else insert at tail of LRU list or at head if VAGE is set
		 */</span>
	        <span class="enscript-keyword">if</span> ( (vp-&gt;v_lflag &amp; VL_DEAD)) {
		        TAILQ_INSERT_HEAD(&amp;vnode_dead_list, vp, v_freelist);
			vp-&gt;v_listflag |= VLIST_DEAD;
			deadvnodes++;

			<span class="enscript-keyword">if</span> (dead_vnode_wanted) {
				dead_vnode_wanted--;
				need_dead_wakeup = TRUE;
			}

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( (vp-&gt;v_flag &amp; VAGE) ) {
		        TAILQ_INSERT_HEAD(&amp;vnode_free_list, vp, v_freelist);
			vp-&gt;v_flag &amp;= ~VAGE;
			freevnodes++;
		} <span class="enscript-keyword">else</span> {
		        TAILQ_INSERT_TAIL(&amp;vnode_free_list, vp, v_freelist);
			freevnodes++;
		}
	}
	vnode_list_unlock();

	<span class="enscript-keyword">if</span> (need_dead_wakeup == TRUE)
		wakeup_one((caddr_t)&amp;dead_vnode_wanted);
}


<span class="enscript-comment">/*
 * remove the vnode from appropriate free list.
 * called with vnode LOCKED and
 * the list lock held
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_list_remove_locked</span>(vnode_t vp)
{
	<span class="enscript-keyword">if</span> (VONLIST(vp)) {
		<span class="enscript-comment">/*
		 * the v_listflag field is
		 * protected by the vnode_list_lock
		 */</span>
	        <span class="enscript-keyword">if</span> (vp-&gt;v_listflag &amp; VLIST_RAGE)
		        VREMRAGE(<span class="enscript-string">&quot;vnode_list_remove&quot;</span>, vp);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vp-&gt;v_listflag &amp; VLIST_DEAD)
		        VREMDEAD(<span class="enscript-string">&quot;vnode_list_remove&quot;</span>, vp);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vp-&gt;v_listflag &amp; VLIST_ASYNC_WORK)
		        VREMASYNC_WORK(<span class="enscript-string">&quot;vnode_list_remove&quot;</span>, vp);
		<span class="enscript-keyword">else</span>
		        VREMFREE(<span class="enscript-string">&quot;vnode_list_remove&quot;</span>, vp);
	}
}


<span class="enscript-comment">/*
 * remove the vnode from appropriate free list.
 * called with vnode LOCKED
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_list_remove</span>(vnode_t vp)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	lck_mtx_assert(&amp;vp-&gt;v_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
        <span class="enscript-comment">/*
	 * we want to avoid taking the list lock
	 * in the case where we're not on the free
	 * list... this will be true for most
	 * directories and any currently in use files
	 *
	 * we're guaranteed that we can't go from
	 * the not-on-list state to the on-list 
	 * state since we hold the vnode lock...
	 * all calls to vnode_list_add are done
	 * under the vnode lock... so we can
	 * check for that condition (the prevelant one)
	 * without taking the list lock
	 */</span>
	<span class="enscript-keyword">if</span> (VONLIST(vp)) {
	        vnode_list_lock();
		<span class="enscript-comment">/*
		 * however, we're not guaranteed that
		 * we won't go from the on-list state
		 * to the not-on-list state until we
		 * hold the vnode_list_lock... this 
		 * is due to &quot;new_vnode&quot; removing vnodes
		 * from the free list uder the list_lock
		 * w/o the vnode lock... so we need to
		 * check again whether we're currently
		 * on the free list
		 */</span>
		vnode_list_remove_locked(vp);

		vnode_list_unlock();
	}
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_rele</span>(vnode_t vp)
{
        vnode_rele_internal(vp, 0, 0, 0);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_rele_ext</span>(vnode_t vp, <span class="enscript-type">int</span> fmode, <span class="enscript-type">int</span> dont_reenter)
{
        vnode_rele_internal(vp, fmode, dont_reenter, 0);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_rele_internal</span>(vnode_t vp, <span class="enscript-type">int</span> fmode, <span class="enscript-type">int</span> dont_reenter, <span class="enscript-type">int</span> locked)
{

	<span class="enscript-keyword">if</span> ( !locked)
	        vnode_lock_spin(vp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">else</span>
		lck_mtx_assert(&amp;vp-&gt;v_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (--vp-&gt;v_usecount &lt; 0)
		panic(<span class="enscript-string">&quot;vnode_rele_ext: vp %p usecount -ve : %d.  v_tag = %d, v_type = %d, v_flag = %x.&quot;</span>, vp,  vp-&gt;v_usecount, vp-&gt;v_tag, vp-&gt;v_type, vp-&gt;v_flag);

	<span class="enscript-keyword">if</span> (fmode &amp; FWRITE) {
		<span class="enscript-keyword">if</span> (--vp-&gt;v_writecount &lt; 0)
			panic(<span class="enscript-string">&quot;vnode_rele_ext: vp %p writecount -ve : %d.  v_tag = %d, v_type = %d, v_flag = %x.&quot;</span>, vp,  vp-&gt;v_writecount, vp-&gt;v_tag, vp-&gt;v_type, vp-&gt;v_flag);
	}
	<span class="enscript-keyword">if</span> (fmode &amp; O_EVTONLY) {
	        <span class="enscript-keyword">if</span> (--vp-&gt;v_kusecount &lt; 0)
		        panic(<span class="enscript-string">&quot;vnode_rele_ext: vp %p kusecount -ve : %d.  v_tag = %d, v_type = %d, v_flag = %x.&quot;</span>, vp,  vp-&gt;v_kusecount, vp-&gt;v_tag, vp-&gt;v_type, vp-&gt;v_flag);
	}
	<span class="enscript-keyword">if</span> (vp-&gt;v_kusecount &gt; vp-&gt;v_usecount)
		panic(<span class="enscript-string">&quot;vnode_rele_ext: vp %p kusecount(%d) out of balance with usecount(%d).  v_tag = %d, v_type = %d, v_flag = %x.&quot;</span>,vp, vp-&gt;v_kusecount, vp-&gt;v_usecount, vp-&gt;v_tag, vp-&gt;v_type, vp-&gt;v_flag);

	<span class="enscript-keyword">if</span> ((vp-&gt;v_iocount &gt; 0) || (vp-&gt;v_usecount &gt; 0)) {
		<span class="enscript-comment">/*
		 * vnode is still busy... if we're the last
		 * usecount, mark for a future call to VNOP_INACTIVE
		 * when the iocount finally drops to 0
		 */</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_usecount == 0) {
			vp-&gt;v_lflag |= VL_NEEDINACTIVE;
			vp-&gt;v_flag  &amp;= ~(VNOCACHE_DATA | VRAOFF | VOPENEVT);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	vp-&gt;v_flag  &amp;= ~(VNOCACHE_DATA | VRAOFF | VOPENEVT);

	<span class="enscript-keyword">if</span> (ISSET(vp-&gt;v_lflag, VL_TERMINATE | VL_DEAD) || dont_reenter) {
		<span class="enscript-comment">/*
		 * vnode is being cleaned, or
		 * we've requested that we don't reenter
		 * the filesystem on this release...in
		 * the latter case, we'll mark the vnode aged
		 */</span>
		<span class="enscript-keyword">if</span> (dont_reenter) {
			<span class="enscript-keyword">if</span> ( !(vp-&gt;v_lflag &amp; (VL_TERMINATE | VL_DEAD | VL_MARKTERM)) ) {
				vp-&gt;v_lflag |= VL_NEEDINACTIVE;
				
				<span class="enscript-keyword">if</span> (vnode_on_reliable_media(vp) == FALSE || vp-&gt;v_flag &amp; VISDIRTY) {
					vnode_async_list_add(vp);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
			}
			vp-&gt;v_flag |= VAGE;
		}
		vnode_list_add(vp);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * at this point both the iocount and usecount
	 * are zero
	 * pick up an iocount so that we can call
	 * VNOP_INACTIVE with the vnode lock unheld
	 */</span>
	vp-&gt;v_iocount++;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	record_vp(vp, 1);
#<span class="enscript-reference">endif</span>
        vp-&gt;v_lflag &amp;= ~VL_NEEDINACTIVE;
	vnode_unlock(vp);

	VNOP_INACTIVE(vp, vfs_context_current());

	vnode_lock_spin(vp);
	<span class="enscript-comment">/*
	 * because we dropped the vnode lock to call VNOP_INACTIVE
	 * the state of the vnode may have changed... we may have
	 * picked up an iocount, usecount or the MARKTERM may have
	 * been set... we need to reevaluate the reference counts
	 * to determine if we can call vnode_reclaim_internal at
	 * this point... if the reference counts are up, we'll pick
	 * up the MARKTERM state when they get subsequently dropped
	 */</span>
	<span class="enscript-keyword">if</span> ( (vp-&gt;v_iocount == 1) &amp;&amp; (vp-&gt;v_usecount == 0) &amp;&amp;
	     ((vp-&gt;v_lflag &amp; (VL_MARKTERM | VL_TERMINATE | VL_DEAD)) == VL_MARKTERM)) {
	        <span class="enscript-type">struct</span>  uthread *ut;

	        ut = get_bsdthread_info(current_thread());
		
		<span class="enscript-keyword">if</span> (ut-&gt;uu_defer_reclaims) {
		        vp-&gt;v_defer_reclaimlist = ut-&gt;uu_vreclaims;
			ut-&gt;uu_vreclaims = vp;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		vnode_lock_convert(vp);
	        vnode_reclaim_internal(vp, 1, 1, 0);
	}
	vnode_dropiocount(vp);
	vnode_list_add(vp);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (vp-&gt;v_usecount == 0 &amp;&amp; vp-&gt;v_type == VREG &amp;&amp; !(vp-&gt;v_flag &amp; VSYSTEM)) {

		<span class="enscript-keyword">if</span> (vp-&gt;v_ubcinfo) {
			vnode_lock_convert(vp);
			memory_object_mark_unused(vp-&gt;v_ubcinfo-&gt;ui_control, (vp-&gt;v_flag &amp; VRAGE) == VRAGE);
		}
	}
	<span class="enscript-keyword">if</span> ( !locked)
	        vnode_unlock(vp);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Remove any vnodes in the vnode table belonging to mount point mp.
 *
 * If MNT_NOFORCE is specified, there should not be any active ones,
 * return error if any are found (nb: this is a user error, not a
 * system error). If MNT_FORCE is specified, detach any active vnodes
 * that are found.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
<span class="enscript-type">int</span> busyprt = 0;	<span class="enscript-comment">/* print out busy vnodes */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">vflush</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vnode *skipvp, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">int</span> busy = 0;
	<span class="enscript-type">int</span> reclaimed = 0;
	<span class="enscript-type">int</span> retval;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vid;

	mount_lock(mp);
	vnode_iterate_setup(mp);
	<span class="enscript-comment">/*
	 * On regular unmounts(not forced) do a
	 * quick check for vnodes to be in use. This
	 * preserves the caching of vnodes. automounter
	 * tries unmounting every so often to see whether
	 * it is still busy or not.
	 */</span>
	<span class="enscript-keyword">if</span> (((flags &amp; FORCECLOSE)==0)  &amp;&amp; ((mp-&gt;mnt_kern_flag &amp; MNTK_UNMOUNT_PREFLIGHT) != 0)) {
		<span class="enscript-keyword">if</span> (vnode_umount_preflight(mp, skipvp, flags)) {
			vnode_iterate_clear(mp);
			mount_unlock(mp);
			<span class="enscript-keyword">return</span>(EBUSY);
		}
	}
<span class="enscript-reference">loop</span>:
	<span class="enscript-comment">/* it is returns 0 then there is nothing to do */</span>
	retval = vnode_iterate_prepare(mp);

	<span class="enscript-keyword">if</span> (retval == 0)  {
		vnode_iterate_clear(mp);
		mount_unlock(mp);
		<span class="enscript-keyword">return</span>(retval);
	}

	<span class="enscript-comment">/* iterate over all the vnodes */</span>
	<span class="enscript-keyword">while</span> (!TAILQ_EMPTY(&amp;mp-&gt;mnt_workerqueue)) {

		vp = TAILQ_FIRST(&amp;mp-&gt;mnt_workerqueue);
		TAILQ_REMOVE(&amp;mp-&gt;mnt_workerqueue, vp, v_mntvnodes);
		TAILQ_INSERT_TAIL(&amp;mp-&gt;mnt_vnodelist, vp, v_mntvnodes);

		<span class="enscript-keyword">if</span> ( (vp-&gt;v_mount != mp) || (vp == skipvp)) {
			<span class="enscript-keyword">continue</span>;
		}
		vid = vp-&gt;v_id;
		mount_unlock(mp);

		vnode_lock_spin(vp);

		<span class="enscript-comment">// If vnode is already terminating, wait for it...
</span>		<span class="enscript-keyword">while</span> (vp-&gt;v_id == vid &amp;&amp; ISSET(vp-&gt;v_lflag, VL_TERMINATE)) {
			vp-&gt;v_lflag |= VL_TERMWANT;
			msleep(&amp;vp-&gt;v_lflag, &amp;vp-&gt;v_lock, PVFS, <span class="enscript-string">&quot;vflush&quot;</span>, NULL);
		}

		<span class="enscript-keyword">if</span> ((vp-&gt;v_id != vid) || ISSET(vp-&gt;v_lflag, VL_DEAD)) {
				vnode_unlock(vp);
				mount_lock(mp);
				<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * If requested, skip over vnodes marked VSYSTEM.
		 * Skip over all vnodes marked VNOFLUSH.
                 */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; SKIPSYSTEM) &amp;&amp; ((vp-&gt;v_flag &amp; VSYSTEM) ||
		    (vp-&gt;v_flag &amp; VNOFLUSH))) {
			vnode_unlock(vp);
			mount_lock(mp);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * If requested, skip over vnodes marked VSWAP.
		 */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; SKIPSWAP) &amp;&amp; (vp-&gt;v_flag &amp; VSWAP)) {
			vnode_unlock(vp);
			mount_lock(mp);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * If requested, skip over vnodes marked VROOT.
		 */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; SKIPROOT) &amp;&amp; (vp-&gt;v_flag &amp; VROOT)) {
			vnode_unlock(vp);
			mount_lock(mp);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * If WRITECLOSE is set, only flush out regular file
		 * vnodes open for writing.
		 */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; WRITECLOSE) &amp;&amp;
		    (vp-&gt;v_writecount == 0 || vp-&gt;v_type != VREG)) {
			vnode_unlock(vp);
			mount_lock(mp);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * If the real usecount is 0, all we need to do is clear
		 * out the vnode data structures and we are done.
		 */</span>
		<span class="enscript-keyword">if</span> (((vp-&gt;v_usecount == 0) ||
		    ((vp-&gt;v_usecount - vp-&gt;v_kusecount) == 0))) {

			vnode_lock_convert(vp);
		        vp-&gt;v_iocount++;	<span class="enscript-comment">/* so that drain waits for * other iocounts */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
			record_vp(vp, 1);
#<span class="enscript-reference">endif</span>
			vnode_reclaim_internal(vp, 1, 1, 0);
			vnode_dropiocount(vp);
			vnode_list_add(vp);
			vnode_unlock(vp);

			reclaimed++;
			mount_lock(mp);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * If FORCECLOSE is set, forcibly close the vnode.
		 * For block or character devices, revert to an
		 * anonymous device. For all other files, just kill them.
		 */</span>
		<span class="enscript-keyword">if</span> (flags &amp; FORCECLOSE) {
			vnode_lock_convert(vp);

			<span class="enscript-keyword">if</span> (vp-&gt;v_type != VBLK &amp;&amp; vp-&gt;v_type != VCHR) {
				vp-&gt;v_iocount++;	<span class="enscript-comment">/* so that drain waits * for other iocounts */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
				record_vp(vp, 1);
#<span class="enscript-reference">endif</span>
				vnode_abort_advlocks(vp);
				vnode_reclaim_internal(vp, 1, 1, 0);
				vnode_dropiocount(vp);
				vnode_list_add(vp);
				vnode_unlock(vp);
			} <span class="enscript-keyword">else</span> {
				vclean(vp, 0);
				vp-&gt;v_lflag &amp;= ~VL_DEAD;
				vp-&gt;v_op = spec_vnodeop_p;
				vp-&gt;v_flag |= VDEVFLUSH;
				vnode_unlock(vp);
			}
			mount_lock(mp);
			<span class="enscript-keyword">continue</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (busyprt)
			vprint(<span class="enscript-string">&quot;vflush: busy vnode&quot;</span>, vp);
#<span class="enscript-reference">endif</span>
		vnode_unlock(vp);
		mount_lock(mp);
		busy++;
	}

	<span class="enscript-comment">/* At this point the worker queue is completed */</span>
	<span class="enscript-keyword">if</span> (busy &amp;&amp; ((flags &amp; FORCECLOSE)==0) &amp;&amp; reclaimed) {
		busy = 0;
		reclaimed = 0;
		(<span class="enscript-type">void</span>)vnode_iterate_reloadq(mp);
		<span class="enscript-comment">/* returned with mount lock held */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
	}

	<span class="enscript-comment">/* if new vnodes were created in between retry the reclaim */</span>
 	<span class="enscript-keyword">if</span> ( vnode_iterate_reloadq(mp) != 0) {
		<span class="enscript-keyword">if</span> (!(busy &amp;&amp; ((flags &amp; FORCECLOSE)==0)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
	}
	vnode_iterate_clear(mp);
	mount_unlock(mp);

	<span class="enscript-keyword">if</span> (busy &amp;&amp; ((flags &amp; FORCECLOSE)==0))
		<span class="enscript-keyword">return</span> (EBUSY);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">long</span> num_recycledvnodes = 0;
<span class="enscript-comment">/*
 * Disassociate the underlying file system from a vnode.
 * The vnode lock is held on entry.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vclean</span>(vnode_t vp, <span class="enscript-type">int</span> flags)
{
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">int</span> active;
	<span class="enscript-type">int</span> need_inactive;
	<span class="enscript-type">int</span> already_terminating;
	<span class="enscript-type">int</span> clflags = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-type">int</span> is_namedstream;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Check to see if the vnode is in use.
	 * If so we have to reference it before we clean it out
	 * so that its count cannot fall to zero and generate a
	 * race against ourselves to recycle it.
	 */</span>
	active = vp-&gt;v_usecount;

	<span class="enscript-comment">/*
	 * just in case we missed sending a needed
	 * VNOP_INACTIVE, we'll do it now
	 */</span>
	need_inactive = (vp-&gt;v_lflag &amp; VL_NEEDINACTIVE);

	vp-&gt;v_lflag &amp;= ~VL_NEEDINACTIVE;

	<span class="enscript-comment">/*
	 * Prevent the vnode from being recycled or
	 * brought into use while we clean it out.
	 */</span>
	already_terminating = (vp-&gt;v_lflag &amp; VL_TERMINATE);

	vp-&gt;v_lflag |= VL_TERMINATE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	is_namedstream = vnode_isnamedstream(vp);
#<span class="enscript-reference">endif</span>

	vnode_unlock(vp);

	OSAddAtomicLong(1, &amp;num_recycledvnodes);

	<span class="enscript-keyword">if</span> (flags &amp; DOCLOSE)
		clflags |= IO_NDELAY;
	<span class="enscript-keyword">if</span> (flags &amp; REVOKEALL)
		clflags |= IO_REVOKE;
	
	<span class="enscript-keyword">if</span> (active &amp;&amp; (flags &amp; DOCLOSE))
		VNOP_CLOSE(vp, clflags, ctx);

	<span class="enscript-comment">/*
	 * Clean out any buffers associated with the vnode.
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; DOCLOSE) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_tag == VT_NFS)
			nfs_vinvalbuf(vp, V_SAVE, ctx, 0);
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
		{
			VNOP_FSYNC(vp, MNT_WAIT, ctx);

			<span class="enscript-comment">/*
			 * If the vnode is still in use (by the journal for
			 * example) we don't want to invalidate locked buffers
			 * here.  In that case, either the journal will tidy them
			 * up, or we will deal with it when the usecount is
			 * finally released in vnode_rele_internal.
			 */</span>
			buf_invalidateblks(vp, BUF_WRITE_DATA | (active ? 0 : BUF_INVALIDATE_LOCKED), 0, 0);
		}
		<span class="enscript-keyword">if</span> (UBCINFOEXISTS(vp))
		        <span class="enscript-comment">/*
			 * Clean the pages in VM.
			 */</span>
		        (<span class="enscript-type">void</span>)ubc_msync(vp, (off_t)0, ubc_getsize(vp), NULL, UBC_PUSHALL | UBC_INVALIDATE | UBC_SYNC);
	}
	<span class="enscript-keyword">if</span> (active || need_inactive) 
		VNOP_INACTIVE(vp, ctx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-keyword">if</span> ((is_namedstream != 0) &amp;&amp; (vp-&gt;v_parent != NULLVP)) {
		vnode_t pvp = vp-&gt;v_parent;
	    
		<span class="enscript-comment">/* Delete the shadow stream file before we reclaim its vnode */</span>
		<span class="enscript-keyword">if</span> (vnode_isshadow(vp)) {
			vnode_relenamedstream(pvp, vp);
		}
		
		<span class="enscript-comment">/* 
		 * No more streams associated with the parent.  We
		 * have a ref on it, so its identity is stable.
		 * If the parent is on an opaque volume, then we need to know
		 * whether it has associated named streams.
		 */</span>
		<span class="enscript-keyword">if</span> (vfs_authopaque(pvp-&gt;v_mount)) {
			vnode_lock_spin(pvp);
			pvp-&gt;v_lflag &amp;= ~VL_HASSTREAMS;
			vnode_unlock(pvp);
		}
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Destroy ubc named reference
	 * cluster_release is done on this path
	 * along with dropping the reference on the ucred
	 * (and in the case of forced unmount of an mmap-ed file,
	 * the ubc reference on the vnode is dropped here too).
	 */</span>
	ubc_destroy_named(vp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	<span class="enscript-comment">/*
	 * cleanup trigger info from vnode (if any)
	 */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_resolve)
		vnode_resolver_detach(vp);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Reclaim the vnode.
	 */</span>
	<span class="enscript-keyword">if</span> (VNOP_RECLAIM(vp, ctx))
		panic(<span class="enscript-string">&quot;vclean: cannot reclaim&quot;</span>);
	
	<span class="enscript-comment">// make sure the name &amp; parent ptrs get cleaned out!
</span>	vnode_update_identity(vp, NULLVP, NULL, 0, 0, VNODE_UPDATE_PARENT | VNODE_UPDATE_NAME | VNODE_UPDATE_PURGE);

	vnode_lock(vp);

	<span class="enscript-comment">/*
	 * Remove the vnode from any mount list it might be on.  It is not
	 * safe to do this any earlier because unmount needs to wait for
	 * any vnodes to terminate and it cannot do that if it cannot find
	 * them.
	 */</span>
	insmntque(vp, (<span class="enscript-type">struct</span> mount *)0);

	vp-&gt;v_mount = dead_mountp;
	vp-&gt;v_op = dead_vnodeop_p;
	vp-&gt;v_tag = VT_NON;
	vp-&gt;v_data = NULL;

	vp-&gt;v_lflag |= VL_DEAD;
	vp-&gt;v_flag &amp;= ~VISDIRTY;

	<span class="enscript-keyword">if</span> (already_terminating == 0) {
	        vp-&gt;v_lflag &amp;= ~VL_TERMINATE;
		<span class="enscript-comment">/*
		 * Done with purge, notify sleepers of the grim news.
		 */</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VL_TERMWANT) {
		        vp-&gt;v_lflag &amp;= ~VL_TERMWANT;
			wakeup(&amp;vp-&gt;v_lflag);
		}
	}
}

<span class="enscript-comment">/*
 * Eliminate all activity associated with  the requested vnode
 * and with all vnodes aliased to the requested vnode.
 */</span>
<span class="enscript-type">int</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
<span class="enscript-function-name">vn_revoke</span>(vnode_t vp, <span class="enscript-type">int</span> flags, __unused vfs_context_t a_context)
#<span class="enscript-reference">else</span>
<span class="enscript-function-name">vn_revoke</span>(vnode_t vp, __unused <span class="enscript-type">int</span> flags, __unused vfs_context_t a_context)
#<span class="enscript-reference">endif</span>
{
	<span class="enscript-type">struct</span> vnode *vq;
	<span class="enscript-type">int</span> vid;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> ((flags &amp; REVOKEALL) == 0)
		panic(<span class="enscript-string">&quot;vnop_revoke&quot;</span>);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (vnode_isaliased(vp)) {
		<span class="enscript-comment">/*
		 * If a vgone (or vclean) is already in progress,
		 * return an immediate error
		 */</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VL_TERMINATE)
			<span class="enscript-keyword">return</span>(ENOENT);

		<span class="enscript-comment">/*
		 * Ensure that vp will not be vgone'd while we
		 * are eliminating its aliases.
		 */</span>
		SPECHASH_LOCK();
		<span class="enscript-keyword">while</span> ((vp-&gt;v_specflags &amp; SI_ALIASED)) {
			<span class="enscript-keyword">for</span> (vq = *vp-&gt;v_hashchain; vq; vq = vq-&gt;v_specnext) {
				<span class="enscript-keyword">if</span> (vq-&gt;v_rdev != vp-&gt;v_rdev ||
				    vq-&gt;v_type != vp-&gt;v_type || vp == vq)
					<span class="enscript-keyword">continue</span>;
				vid = vq-&gt;v_id;
				SPECHASH_UNLOCK();
				<span class="enscript-keyword">if</span> (vnode_getwithvid(vq,vid)){
					SPECHASH_LOCK();	
					<span class="enscript-keyword">break</span>;
				}
				vnode_lock(vq);
				<span class="enscript-keyword">if</span> (!(vq-&gt;v_lflag &amp; VL_TERMINATE)) {
					vnode_reclaim_internal(vq, 1, 1, 0);
				}
				vnode_put_locked(vq);
				vnode_unlock(vq);
				SPECHASH_LOCK();
				<span class="enscript-keyword">break</span>;
			}
		}
		SPECHASH_UNLOCK();
	}
	vnode_lock(vp);
	<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VL_TERMINATE) {
		vnode_unlock(vp);
		<span class="enscript-keyword">return</span> (ENOENT);
	}
	vnode_reclaim_internal(vp, 1, 0, REVOKEALL);
	vnode_unlock(vp);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Recycle an unused vnode to the front of the free list.
 * Release the passed interlock if the vnode will be recycled.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_recycle</span>(<span class="enscript-type">struct</span> vnode *vp)
{
	vnode_lock_spin(vp);

	<span class="enscript-keyword">if</span> (vp-&gt;v_iocount || vp-&gt;v_usecount) {
		vp-&gt;v_lflag |= VL_MARKTERM;
		vnode_unlock(vp);
		<span class="enscript-keyword">return</span>(0);
	} 
	vnode_lock_convert(vp);
	vnode_reclaim_internal(vp, 1, 0, 0);

	vnode_unlock(vp);

	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_reload</span>(vnode_t vp)
{
	vnode_lock_spin(vp);

	<span class="enscript-keyword">if</span> ((vp-&gt;v_iocount &gt; 1) || vp-&gt;v_usecount) {
		vnode_unlock(vp);
		<span class="enscript-keyword">return</span>(0);
	} 
	<span class="enscript-keyword">if</span> (vp-&gt;v_iocount &lt;= 0)
		panic(<span class="enscript-string">&quot;vnode_reload with no iocount %d&quot;</span>, vp-&gt;v_iocount);

	<span class="enscript-comment">/* mark for release when iocount is dopped */</span>
	vp-&gt;v_lflag |= VL_MARKTERM;
	vnode_unlock(vp);

	<span class="enscript-keyword">return</span> (1);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vgone</span>(vnode_t vp, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> vnode *vq;
	<span class="enscript-type">struct</span> vnode *vx;

	<span class="enscript-comment">/*
	 * Clean out the filesystem specific data.
	 * vclean also takes care of removing the
	 * vnode from any mount list it might be on
	 */</span>
	vclean(vp, flags | DOCLOSE);

	<span class="enscript-comment">/*
	 * If special device, remove it from special device alias list
	 * if it is on one.
	 */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_type == VBLK || vp-&gt;v_type == VCHR) &amp;&amp; vp-&gt;v_specinfo != 0) {
			SPECHASH_LOCK();
			<span class="enscript-keyword">if</span> (*vp-&gt;v_hashchain == vp) {
				*vp-&gt;v_hashchain = vp-&gt;v_specnext;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">for</span> (vq = *vp-&gt;v_hashchain; vq; vq = vq-&gt;v_specnext) {
					<span class="enscript-keyword">if</span> (vq-&gt;v_specnext != vp)
						<span class="enscript-keyword">continue</span>;
					vq-&gt;v_specnext = vp-&gt;v_specnext;
					<span class="enscript-keyword">break</span>;
				}
			<span class="enscript-keyword">if</span> (vq == NULL)
				panic(<span class="enscript-string">&quot;missing bdev&quot;</span>);
			}
			<span class="enscript-keyword">if</span> (vp-&gt;v_specflags &amp; SI_ALIASED) {
				vx = NULL;
				<span class="enscript-keyword">for</span> (vq = *vp-&gt;v_hashchain; vq; vq = vq-&gt;v_specnext) {
					<span class="enscript-keyword">if</span> (vq-&gt;v_rdev != vp-&gt;v_rdev ||
				    	vq-&gt;v_type != vp-&gt;v_type)
						<span class="enscript-keyword">continue</span>;
					<span class="enscript-keyword">if</span> (vx)
						<span class="enscript-keyword">break</span>;
					vx = vq;
				}
				<span class="enscript-keyword">if</span> (vx == NULL)
					panic(<span class="enscript-string">&quot;missing alias&quot;</span>);
				<span class="enscript-keyword">if</span> (vq == NULL)
					vx-&gt;v_specflags &amp;= ~SI_ALIASED;
				vp-&gt;v_specflags &amp;= ~SI_ALIASED;
			}
			SPECHASH_UNLOCK();
			{
			<span class="enscript-type">struct</span> specinfo *tmp = vp-&gt;v_specinfo;
			vp-&gt;v_specinfo = NULL;
			FREE_ZONE((<span class="enscript-type">void</span> *)tmp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> specinfo), M_SPECINFO);
			}
	}
}

<span class="enscript-comment">/*
 * Lookup a vnode by device number.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">check_mountedon</span>(dev_t dev, <span class="enscript-type">enum</span> vtype type, <span class="enscript-type">int</span>  *errorp)
{
	vnode_t	vp;
	<span class="enscript-type">int</span> rc = 0;
	<span class="enscript-type">int</span> vid;

<span class="enscript-reference">loop</span>:
	SPECHASH_LOCK();
	<span class="enscript-keyword">for</span> (vp = speclisth[SPECHASH(dev)]; vp; vp = vp-&gt;v_specnext) {
		<span class="enscript-keyword">if</span> (dev != vp-&gt;v_rdev || type != vp-&gt;v_type)
			<span class="enscript-keyword">continue</span>;
		vid = vp-&gt;v_id;
		SPECHASH_UNLOCK();
		<span class="enscript-keyword">if</span> (vnode_getwithvid(vp,vid))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
		vnode_lock_spin(vp);
		<span class="enscript-keyword">if</span> ((vp-&gt;v_usecount &gt; 0) || (vp-&gt;v_iocount &gt; 1)) {
			vnode_unlock(vp);
			<span class="enscript-keyword">if</span> ((*errorp = vfs_mountedon(vp)) != 0)
				rc = 1;
		} <span class="enscript-keyword">else</span>
			vnode_unlock(vp);
		vnode_put(vp);
		<span class="enscript-keyword">return</span>(rc);
	}
	SPECHASH_UNLOCK();
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Calculate the total number of references to a special device.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vcount</span>(vnode_t vp)
{
	vnode_t vq, vnext;
	<span class="enscript-type">int</span> count;
	<span class="enscript-type">int</span> vid;

<span class="enscript-reference">loop</span>:
	<span class="enscript-keyword">if</span> (!vnode_isaliased(vp))
	        <span class="enscript-keyword">return</span> (vp-&gt;v_specinfo-&gt;si_opencount);
	count = 0;

	SPECHASH_LOCK();
	<span class="enscript-comment">/*
	 * Grab first vnode and its vid.
	 */</span>
	vq = *vp-&gt;v_hashchain;
	vid = vq ? vq-&gt;v_id : 0;

	SPECHASH_UNLOCK();

	<span class="enscript-keyword">while</span> (vq) {
		<span class="enscript-comment">/*
		 * Attempt to get the vnode outside the SPECHASH lock.
		 */</span>
		<span class="enscript-keyword">if</span> (vnode_getwithvid(vq, vid)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
		}
		vnode_lock(vq);

		<span class="enscript-keyword">if</span> (vq-&gt;v_rdev == vp-&gt;v_rdev &amp;&amp; vq-&gt;v_type == vp-&gt;v_type) {
			<span class="enscript-keyword">if</span> ((vq-&gt;v_usecount == 0) &amp;&amp; (vq-&gt;v_iocount == 1)  &amp;&amp; vq != vp) {
				<span class="enscript-comment">/*
				 * Alias, but not in use, so flush it out.
				 */</span>
				vnode_reclaim_internal(vq, 1, 1, 0);
				vnode_put_locked(vq);
				vnode_unlock(vq);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
			}
			count += vq-&gt;v_specinfo-&gt;si_opencount;
		}
		vnode_unlock(vq);

		SPECHASH_LOCK();
		<span class="enscript-comment">/*
		 * must do this with the reference still held on 'vq'
		 * so that it can't be destroyed while we're poking
		 * through v_specnext
		 */</span>
		vnext = vq-&gt;v_specnext;
		vid = vnext ? vnext-&gt;v_id : 0;

		SPECHASH_UNLOCK();

		vnode_put(vq);

		vq = vnext;
	}

	<span class="enscript-keyword">return</span> (count);
}

<span class="enscript-type">int</span>	prtactive = 0;		<span class="enscript-comment">/* 1 =&gt; print out reclaim of active vnodes */</span>

<span class="enscript-comment">/*
 * Print out a description of a vnode.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *typename[] =
   { <span class="enscript-string">&quot;VNON&quot;</span>, <span class="enscript-string">&quot;VREG&quot;</span>, <span class="enscript-string">&quot;VDIR&quot;</span>, <span class="enscript-string">&quot;VBLK&quot;</span>, <span class="enscript-string">&quot;VCHR&quot;</span>, <span class="enscript-string">&quot;VLNK&quot;</span>, <span class="enscript-string">&quot;VSOCK&quot;</span>, <span class="enscript-string">&quot;VFIFO&quot;</span>, <span class="enscript-string">&quot;VBAD&quot;</span> };

<span class="enscript-type">void</span>
<span class="enscript-function-name">vprint</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *label, <span class="enscript-type">struct</span> vnode *vp)
{
	<span class="enscript-type">char</span> sbuf[64];

	<span class="enscript-keyword">if</span> (label != NULL)
		printf(<span class="enscript-string">&quot;%s: &quot;</span>, label);
	printf(<span class="enscript-string">&quot;type %s, usecount %d, writecount %d&quot;</span>,
	       typename[vp-&gt;v_type], vp-&gt;v_usecount, vp-&gt;v_writecount);
	sbuf[0] = <span class="enscript-string">'\0'</span>;
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VROOT)
		strlcat(sbuf, <span class="enscript-string">&quot;|VROOT&quot;</span>, <span class="enscript-keyword">sizeof</span>(sbuf));
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VTEXT)
		strlcat(sbuf, <span class="enscript-string">&quot;|VTEXT&quot;</span>, <span class="enscript-keyword">sizeof</span>(sbuf));
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VSYSTEM)
		strlcat(sbuf, <span class="enscript-string">&quot;|VSYSTEM&quot;</span>, <span class="enscript-keyword">sizeof</span>(sbuf));
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VNOFLUSH)
		strlcat(sbuf, <span class="enscript-string">&quot;|VNOFLUSH&quot;</span>, <span class="enscript-keyword">sizeof</span>(sbuf));
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VBWAIT)
		strlcat(sbuf, <span class="enscript-string">&quot;|VBWAIT&quot;</span>, <span class="enscript-keyword">sizeof</span>(sbuf));
	<span class="enscript-keyword">if</span> (vnode_isaliased(vp))
		strlcat(sbuf, <span class="enscript-string">&quot;|VALIASED&quot;</span>, <span class="enscript-keyword">sizeof</span>(sbuf));
	<span class="enscript-keyword">if</span> (sbuf[0] != <span class="enscript-string">'\0'</span>)
		printf(<span class="enscript-string">&quot; flags (%s)&quot;</span>, &amp;sbuf[1]);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_getpath</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">char</span> *pathbuf, <span class="enscript-type">int</span> *len)
{
	<span class="enscript-keyword">return</span> build_path(vp, pathbuf, *len, len, BUILDPATH_NO_FS_ENTER, vfs_context_current());
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_getpath_fsenter</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">char</span> *pathbuf, <span class="enscript-type">int</span> *len)
{
	<span class="enscript-keyword">return</span> build_path(vp, pathbuf, *len, len, 0, vfs_context_current());
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_getcdhash</span>(<span class="enscript-type">struct</span> vnode *vp, off_t offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *cdhash)
{
	<span class="enscript-keyword">return</span> ubc_cs_getcdhash(vp, offset, cdhash);
}


<span class="enscript-type">static</span> <span class="enscript-type">char</span> *extension_table=NULL;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>   nexts;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>   max_ext_width;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">extension_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *b)
{
    <span class="enscript-keyword">return</span> (strlen((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)a) - strlen((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)b));
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// This is the api LaunchServices uses to inform the kernel
</span><span class="enscript-comment">// the list of package extensions to ignore.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Internally we keep the list sorted by the length of the
</span><span class="enscript-comment">// the extension (from longest to shortest).  We sort the
</span><span class="enscript-comment">// list of extensions so that we can speed up our searches
</span><span class="enscript-comment">// when comparing file names -- we only compare extensions
</span><span class="enscript-comment">// that could possibly fit into the file name, not all of
</span><span class="enscript-comment">// them (i.e. a short 8 character name can't have an 8
</span><span class="enscript-comment">// character extension).
</span><span class="enscript-comment">//
</span><span class="enscript-type">extern</span> lck_mtx_t *pkg_extensions_lck;

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">set_package_extensions_table</span>(user_addr_t data, <span class="enscript-type">int</span> nentries, <span class="enscript-type">int</span> maxwidth)
{
    <span class="enscript-type">char</span> *new_exts, *old_exts;
    <span class="enscript-type">int</span> error;
    
    <span class="enscript-keyword">if</span> (nentries &lt;= 0 || nentries &gt; 1024 || maxwidth &lt;= 0 || maxwidth &gt; 255) {
	<span class="enscript-keyword">return</span> EINVAL;
    }


    <span class="enscript-comment">// allocate one byte extra so we can guarantee null termination
</span>    MALLOC(new_exts, <span class="enscript-type">char</span> *, (nentries * maxwidth) + 1, M_TEMP, M_WAITOK);
    <span class="enscript-keyword">if</span> (new_exts == NULL) {
    	<span class="enscript-keyword">return</span> ENOMEM;
    }
    
    error = copyin(data, new_exts, nentries * maxwidth);
    <span class="enscript-keyword">if</span> (error) {
	FREE(new_exts, M_TEMP);
	<span class="enscript-keyword">return</span> error;
    }

    new_exts[(nentries * maxwidth)] = <span class="enscript-string">'\0'</span>;   <span class="enscript-comment">// guarantee null termination of the block
</span>
    qsort(new_exts, nentries, maxwidth, extension_cmp);

    lck_mtx_lock(pkg_extensions_lck);

    old_exts        = extension_table;
    extension_table = new_exts;
    nexts           = nentries;
    max_ext_width   = maxwidth;

    lck_mtx_unlock(pkg_extensions_lck);

    <span class="enscript-keyword">if</span> (old_exts) {
	FREE(old_exts, M_TEMP);
    }

    <span class="enscript-keyword">return</span> 0;
}


__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">is_package_name</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> len)
{
    <span class="enscript-type">int</span> i, extlen;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ptr, *name_ext;
    
    <span class="enscript-keyword">if</span> (len &lt;= 3) {
	<span class="enscript-keyword">return</span> 0;
    }

    name_ext = NULL;
    <span class="enscript-keyword">for</span>(ptr=name; *ptr != <span class="enscript-string">'\0'</span>; ptr++) {
	<span class="enscript-keyword">if</span> (*ptr == <span class="enscript-string">'.'</span>) {
	    name_ext = ptr;
	}
    }

    <span class="enscript-comment">// if there is no &quot;.&quot; extension, it can't match
</span>    <span class="enscript-keyword">if</span> (name_ext == NULL) {
	<span class="enscript-keyword">return</span> 0;
    }

    <span class="enscript-comment">// advance over the &quot;.&quot;
</span>    name_ext++;

    lck_mtx_lock(pkg_extensions_lck);

    <span class="enscript-comment">// now iterate over all the extensions to see if any match
</span>    ptr = &amp;extension_table[0];
    <span class="enscript-keyword">for</span>(i=0; i &lt; nexts; i++, ptr+=max_ext_width) {
	extlen = strlen(ptr);
	<span class="enscript-keyword">if</span> (strncasecmp(name_ext, ptr, extlen) == 0 &amp;&amp; name_ext[extlen] == <span class="enscript-string">'\0'</span>) {
	    <span class="enscript-comment">// aha, a match!
</span>	    lck_mtx_unlock(pkg_extensions_lck);
	    <span class="enscript-keyword">return</span> 1;
	}
    }

    lck_mtx_unlock(pkg_extensions_lck);

    <span class="enscript-comment">// if we get here, no extension matched
</span>    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_path_package_check</span>(__unused vnode_t vp, <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> pathlen, <span class="enscript-type">int</span> *component)
{
    <span class="enscript-type">char</span> *ptr, *end;
    <span class="enscript-type">int</span> comp=0;
    
    *component = -1;
    <span class="enscript-keyword">if</span> (*path != <span class="enscript-string">'/'</span>) {
	<span class="enscript-keyword">return</span> EINVAL;
    }

    end = path + 1;
    <span class="enscript-keyword">while</span>(end &lt; path + pathlen &amp;&amp; *end != <span class="enscript-string">'\0'</span>) {
	<span class="enscript-keyword">while</span>(end &lt; path + pathlen &amp;&amp; *end == <span class="enscript-string">'/'</span> &amp;&amp; *end != <span class="enscript-string">'\0'</span>) {
	    end++;
	}

	ptr = end;

	<span class="enscript-keyword">while</span>(end &lt; path + pathlen &amp;&amp; *end != <span class="enscript-string">'/'</span> &amp;&amp; *end != <span class="enscript-string">'\0'</span>) {
	    end++;
	}

	<span class="enscript-keyword">if</span> (end &gt; path + pathlen) {
	    <span class="enscript-comment">// hmm, string wasn't null terminated 
</span>	    <span class="enscript-keyword">return</span> EINVAL;
	}

	*end = <span class="enscript-string">'\0'</span>;
	<span class="enscript-keyword">if</span> (is_package_name(ptr, end - ptr)) {
	    *component = comp;
	    <span class="enscript-keyword">break</span>;
	}

	end++;
	comp++;
    }

    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/* 
 * Determine if a name is inappropriate for a searchfs query.
 * This list consists of /System currently.
 */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">vn_searchfs_inappropriate_name</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> len) {
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *bad_names[] = { <span class="enscript-string">&quot;System&quot;</span> };
	<span class="enscript-type">int</span>   bad_len[]   = { 6 };
	<span class="enscript-type">int</span>  i;

	<span class="enscript-keyword">for</span>(i=0; i &lt; (<span class="enscript-type">int</span>) (<span class="enscript-keyword">sizeof</span>(bad_names) / <span class="enscript-keyword">sizeof</span>(bad_names[0])); i++) {
		<span class="enscript-keyword">if</span> (len == bad_len[i] &amp;&amp; strncmp(name, bad_names[i], strlen(bad_names[i]) + 1) == 0) {
			<span class="enscript-keyword">return</span> 1;
		}
	}

	<span class="enscript-comment">// if we get here, no name matched
</span>	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Top level filesystem related information gathering.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vfs_nummntops;

<span class="enscript-comment">/*
 * The VFS_NUMMNTOPS shouldn't be at name[1] since
 * is a VFS generic variable. Since we no longer support
 * VT_UFS, we reserve its value to support this sysctl node.
 *
 * It should have been:
 *    name[0]:  VFS_GENERIC
 *    name[1]:  VFS_NUMMNTOPS
 */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs, VFS_NUMMNTOPS, nummntops,
		   CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED,
		   &amp;vfs_nummntops, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_sysctl</span>(<span class="enscript-type">int</span> *name __unused, u_int namelen __unused,
		   user_addr_t oldp __unused, size_t *oldlenp __unused,
           user_addr_t newp __unused, size_t newlen __unused, proc_t p __unused);

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_sysctl</span>(<span class="enscript-type">int</span> *name __unused, u_int namelen __unused,
		   user_addr_t oldp __unused, size_t *oldlenp __unused,
           user_addr_t newp __unused, size_t newlen __unused, proc_t p __unused)
{
	<span class="enscript-keyword">return</span> (EINVAL);
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// The following code disallows specific sysctl's that came through
</span><span class="enscript-comment">// the direct sysctl interface (vfs_sysctl_node) instead of the newer
</span><span class="enscript-comment">// sysctl_vfs_ctlbyfsid() interface.  We can not allow these selectors
</span><span class="enscript-comment">// through vfs_sysctl_node() because it passes the user's oldp pointer
</span><span class="enscript-comment">// directly to the file system which (for these selectors) casts it
</span><span class="enscript-comment">// back to a struct sysctl_req and then proceed to use SYSCTL_IN()
</span><span class="enscript-comment">// which jumps through an arbitrary function pointer.  When called
</span><span class="enscript-comment">// through the sysctl_vfs_ctlbyfsid() interface this does not happen
</span><span class="enscript-comment">// and so it's safe.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Unfortunately we have to pull in definitions from AFP and SMB and
</span><span class="enscript-comment">// perform explicit name checks on the file system to determine if
</span><span class="enscript-comment">// these selectors are being used.
</span><span class="enscript-comment">//
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AFPFS_VFS_CTL_GETID</span>            0x00020001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AFPFS_VFS_CTL_NETCHANGE</span>        0x00020002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AFPFS_VFS_CTL_VOLCHANGE</span>        0x00020003

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SMBFS_SYSCTL_REMOUNT</span>           1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SMBFS_SYSCTL_REMOUNT_INFO</span>      2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SMBFS_SYSCTL_GET_SERVER_SHARE</span>  3


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">is_bad_sysctl_name</span>(<span class="enscript-type">struct</span> vfstable *vfsp, <span class="enscript-type">int</span> selector_name)
{
	<span class="enscript-keyword">switch</span>(selector_name) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_QUERY</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_TIMEO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_NOLOCKS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_NSTATUS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_SADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_DISC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_SERVERINFO</span>:
			<span class="enscript-keyword">return</span> 1;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">// the more complicated check for some of SMB's special values
</span>	<span class="enscript-keyword">if</span> (strcmp(vfsp-&gt;vfc_name, <span class="enscript-string">&quot;smbfs&quot;</span>) == 0) {
		<span class="enscript-keyword">switch</span>(selector_name) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SMBFS_SYSCTL_REMOUNT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SMBFS_SYSCTL_REMOUNT_INFO</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SMBFS_SYSCTL_GET_SERVER_SHARE</span>:
				<span class="enscript-keyword">return</span> 1;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(vfsp-&gt;vfc_name, <span class="enscript-string">&quot;afpfs&quot;</span>) == 0) {
		<span class="enscript-keyword">switch</span>(selector_name) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AFPFS_VFS_CTL_GETID</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AFPFS_VFS_CTL_NETCHANGE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AFPFS_VFS_CTL_VOLCHANGE</span>:
				<span class="enscript-keyword">return</span> 1;
				<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// If we get here we passed all the checks so the selector is ok
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">int</span> vfs_sysctl_node SYSCTL_HANDLER_ARGS
{
	<span class="enscript-type">int</span> *name, namelen;
	<span class="enscript-type">struct</span> vfstable *vfsp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> fstypenum;
	
	fstypenum = oidp-&gt;oid_number;
	name = arg1;
	namelen = arg2;

	<span class="enscript-comment">/* all sysctl names at this level should have at least one name slot for the FS */</span>
	<span class="enscript-keyword">if</span> (namelen &lt; 1)
		<span class="enscript-keyword">return</span> (EISDIR); <span class="enscript-comment">/* overloaded */</span>
	
	mount_list_lock();
	<span class="enscript-keyword">for</span> (vfsp = vfsconf; vfsp; vfsp = vfsp-&gt;vfc_next)
		<span class="enscript-keyword">if</span> (vfsp-&gt;vfc_typenum == fstypenum) {
			vfsp-&gt;vfc_refcount++;
			<span class="enscript-keyword">break</span>;
		}
	mount_list_unlock();
	
	<span class="enscript-keyword">if</span> (vfsp == NULL) {
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}

	<span class="enscript-keyword">if</span> (is_bad_sysctl_name(vfsp, name[0])) {
		printf(<span class="enscript-string">&quot;vfs: bad selector 0x%.8x for old-style sysctl().  use the sysctl-by-fsid interface instead\n&quot;</span>, name[0]);
		<span class="enscript-keyword">return</span> EPERM;
	}

	error = (vfsp-&gt;vfc_vfsops-&gt;vfs_sysctl)(name, namelen, req-&gt;oldptr, &amp;req-&gt;oldlen, req-&gt;newptr, req-&gt;newlen, vfs_context_current());

	mount_list_lock();
	vfsp-&gt;vfc_refcount--;
	mount_list_unlock();

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Check to see if a filesystem is mounted on a block device.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_mountedon</span>(<span class="enscript-type">struct</span> vnode *vp)
{
	<span class="enscript-type">struct</span> vnode *vq;
	<span class="enscript-type">int</span> error = 0;

	SPECHASH_LOCK();
	<span class="enscript-keyword">if</span> (vp-&gt;v_specflags &amp; SI_MOUNTEDON) {
		error = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (vp-&gt;v_specflags &amp; SI_ALIASED) {
		<span class="enscript-keyword">for</span> (vq = *vp-&gt;v_hashchain; vq; vq = vq-&gt;v_specnext) {
			<span class="enscript-keyword">if</span> (vq-&gt;v_rdev != vp-&gt;v_rdev ||
			    vq-&gt;v_type != vp-&gt;v_type)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (vq-&gt;v_specflags &amp; SI_MOUNTEDON) {
				error = EBUSY;
				<span class="enscript-keyword">break</span>;
			}
		}
	}
<span class="enscript-reference">out</span>:
	SPECHASH_UNLOCK();
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">struct</span> unmount_info {
	<span class="enscript-type">int</span>	u_errs;	<span class="enscript-comment">// Total failed unmounts
</span>	<span class="enscript-type">int</span>	u_busy;	<span class="enscript-comment">// EBUSY failed unmounts
</span>};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">unmount_callback</span>(mount_t mp, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> *mntname;
	<span class="enscript-type">struct</span> unmount_info *uip = arg;

	mount_ref(mp, 0);
	mount_iterdrop(mp);	<span class="enscript-comment">// avoid vfs_iterate deadlock in dounmount()
</span>
	MALLOC_ZONE(mntname, <span class="enscript-type">void</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK);
	<span class="enscript-keyword">if</span> (mntname)
		strlcpy(mntname, mp-&gt;mnt_vfsstat.f_mntonname, MAXPATHLEN);

	error = dounmount(mp, MNT_FORCE, 1, vfs_context_current());
	<span class="enscript-keyword">if</span> (error) {
		uip-&gt;u_errs++;
		printf(<span class="enscript-string">&quot;Unmount of %s failed (%d)\n&quot;</span>, mntname ? mntname:<span class="enscript-string">&quot;?&quot;</span>, error);
		<span class="enscript-keyword">if</span> (error == EBUSY)
			uip-&gt;u_busy++;
	}
	<span class="enscript-keyword">if</span> (mntname)
		FREE_ZONE(mntname, MAXPATHLEN, M_NAMEI);

	<span class="enscript-keyword">return</span> (VFS_RETURNED);
}

<span class="enscript-comment">/*
 * Unmount all filesystems. The list is traversed in reverse order
 * of mounting to avoid dependencies.
 * Busy mounts are retried.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_unmountall</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> mounts, sec = 1;
	<span class="enscript-type">struct</span> unmount_info ui;

<span class="enscript-reference">retry</span>:
	ui.u_errs = ui.u_busy = 0;
	vfs_iterate(VFS_ITERATE_CB_DROPREF | VFS_ITERATE_TAIL_FIRST, unmount_callback, &amp;ui);
	mounts = mount_getvfscnt();
	<span class="enscript-keyword">if</span> (mounts == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (ui.u_busy &gt; 0) {		<span class="enscript-comment">// Busy mounts - wait &amp; retry
</span>		tsleep(&amp;nummounts, PVFS, <span class="enscript-string">&quot;busy mount&quot;</span>, sec * hz);
		sec *= 2;
		<span class="enscript-keyword">if</span> (sec &lt;= 32)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		printf(<span class="enscript-string">&quot;Unmounting timed out\n&quot;</span>);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ui.u_errs &lt; mounts)	{
		<span class="enscript-comment">// If the vfs_iterate missed mounts in progress - wait a bit
</span>		tsleep(&amp;nummounts, PVFS, <span class="enscript-string">&quot;missed mount&quot;</span>, 2 * hz);
	}
}

<span class="enscript-comment">/*  
 * This routine is called from vnode_pager_deallocate out of the VM
 * The path to vnode_pager_deallocate can only be initiated by ubc_destroy_named
 * on a vnode that has a UBCINFO
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_pager_vrele</span>(vnode_t vp)
{
        <span class="enscript-type">struct</span> ubc_info *uip;

	vnode_lock_spin(vp);

	vp-&gt;v_lflag &amp;= ~VNAMED_UBC;
	<span class="enscript-keyword">if</span> (vp-&gt;v_usecount != 0) {
		<span class="enscript-comment">/*
		 * At the eleventh hour, just before the ubcinfo is
		 * destroyed, ensure the ubc-specific v_usecount
		 * reference has gone.  We use v_usecount != 0 as a hint;
		 * ubc_unmap() does nothing if there's no mapping.
		 *
		 * This case is caused by coming here via forced unmount,
		 * versus the usual vm_object_deallocate() path.
		 * In the forced unmount case, ubc_destroy_named()
		 * releases the pager before memory_object_last_unmap()
		 * can be called.
		 */</span>
		vnode_unlock(vp);
		ubc_unmap(vp);
		vnode_lock_spin(vp);
	}

	uip = vp-&gt;v_ubcinfo;
	vp-&gt;v_ubcinfo = UBC_INFO_NULL;

	vnode_unlock(vp);

	ubc_info_deallocate(uip);
}


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>

u_int32_t rootunit = (u_int32_t)-1;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> lowpri_throttle_enabled;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> iosched_enabled;
#<span class="enscript-reference">endif</span>

errno_t
<span class="enscript-function-name">vfs_init_io_attributes</span>(vnode_t devvp, mount_t mp)
{
	<span class="enscript-type">int</span>	error;
	off_t	readblockcnt = 0;
	off_t	writeblockcnt = 0;
	off_t	readmaxcnt = 0;
	off_t	writemaxcnt = 0;
	off_t	readsegcnt = 0;
	off_t	writesegcnt = 0;
	off_t	readsegsize = 0;
	off_t	writesegsize = 0;
	off_t	alignment = 0;
	u_int32_t ioqueue_depth = 0;
	u_int32_t blksize;
	u_int64_t temp;
	u_int32_t features;
	vfs_context_t ctx = vfs_context_current();
	dk_corestorage_info_t cs_info;
	boolean_t cs_present = FALSE;;
	<span class="enscript-type">int</span> isssd = 0;
	<span class="enscript-type">int</span> isvirtual = 0;


	VNOP_IOCTL(devvp, DKIOCGETTHROTTLEMASK, (caddr_t)&amp;mp-&gt;mnt_throttle_mask, 0, NULL);
	<span class="enscript-comment">/*
	 * as a reasonable approximation, only use the lowest bit of the mask
	 * to generate a disk unit number
	 */</span>
	mp-&gt;mnt_devbsdunit = num_trailing_0(mp-&gt;mnt_throttle_mask);

	<span class="enscript-keyword">if</span> (devvp == rootvp)
		rootunit = mp-&gt;mnt_devbsdunit;

	<span class="enscript-keyword">if</span> (mp-&gt;mnt_devbsdunit == rootunit) {
		<span class="enscript-comment">/*
		 * this mount point exists on the same device as the root
		 * partition, so it comes under the hard throttle control...
		 * this is true even for the root mount point itself
		 */</span>
		mp-&gt;mnt_kern_flag |= MNTK_ROOTDEV;
	}
	<span class="enscript-comment">/*
	 * force the spec device to re-cache
	 * the underlying block size in case
	 * the filesystem overrode the initial value
	 */</span>
	set_fsblocksize(devvp);


	<span class="enscript-keyword">if</span> ((error = VNOP_IOCTL(devvp, DKIOCGETBLOCKSIZE,
				(caddr_t)&amp;blksize, 0, ctx)))
		<span class="enscript-keyword">return</span> (error);

	mp-&gt;mnt_devblocksize = blksize;

	<span class="enscript-comment">/*
	 * set the maximum possible I/O size
	 * this may get clipped to a smaller value
	 * based on which constraints are being advertised
	 * and if those advertised constraints result in a smaller
	 * limit for a given I/O
	 */</span>
	mp-&gt;mnt_maxreadcnt = MAX_UPL_SIZE_BYTES;
	mp-&gt;mnt_maxwritecnt = MAX_UPL_SIZE_BYTES;

	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCISVIRTUAL, (caddr_t)&amp;isvirtual, 0, ctx) == 0) {
	        <span class="enscript-keyword">if</span> (isvirtual)
		        mp-&gt;mnt_kern_flag |= MNTK_VIRTUALDEV;
	}
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCISSOLIDSTATE, (caddr_t)&amp;isssd, 0, ctx) == 0) {
	        <span class="enscript-keyword">if</span> (isssd)
		        mp-&gt;mnt_kern_flag |= MNTK_SSD;
	}
	<span class="enscript-keyword">if</span> ((error = VNOP_IOCTL(devvp, DKIOCGETFEATURES,
				(caddr_t)&amp;features, 0, ctx)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = VNOP_IOCTL(devvp, DKIOCGETMAXBLOCKCOUNTREAD,
				(caddr_t)&amp;readblockcnt, 0, ctx)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = VNOP_IOCTL(devvp, DKIOCGETMAXBLOCKCOUNTWRITE,
				(caddr_t)&amp;writeblockcnt, 0, ctx)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = VNOP_IOCTL(devvp, DKIOCGETMAXBYTECOUNTREAD,
				(caddr_t)&amp;readmaxcnt, 0, ctx)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = VNOP_IOCTL(devvp, DKIOCGETMAXBYTECOUNTWRITE,
				(caddr_t)&amp;writemaxcnt, 0, ctx)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = VNOP_IOCTL(devvp, DKIOCGETMAXSEGMENTCOUNTREAD,
				(caddr_t)&amp;readsegcnt, 0, ctx)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = VNOP_IOCTL(devvp, DKIOCGETMAXSEGMENTCOUNTWRITE,
				(caddr_t)&amp;writesegcnt, 0, ctx)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = VNOP_IOCTL(devvp, DKIOCGETMAXSEGMENTBYTECOUNTREAD,
				(caddr_t)&amp;readsegsize, 0, ctx)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = VNOP_IOCTL(devvp, DKIOCGETMAXSEGMENTBYTECOUNTWRITE,
				(caddr_t)&amp;writesegsize, 0, ctx)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = VNOP_IOCTL(devvp, DKIOCGETMINSEGMENTALIGNMENTBYTECOUNT,
				(caddr_t)&amp;alignment, 0, ctx)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = VNOP_IOCTL(devvp, DKIOCGETCOMMANDPOOLSIZE,
				(caddr_t)&amp;ioqueue_depth, 0, ctx)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (readmaxcnt)
		mp-&gt;mnt_maxreadcnt = (readmaxcnt &gt; UINT32_MAX) ? UINT32_MAX : readmaxcnt;

	<span class="enscript-keyword">if</span> (readblockcnt) {
		temp = readblockcnt * blksize;
		temp = (temp &gt; UINT32_MAX) ? UINT32_MAX : temp;

		<span class="enscript-keyword">if</span> (temp &lt; mp-&gt;mnt_maxreadcnt)
			mp-&gt;mnt_maxreadcnt = (u_int32_t)temp;
	}

	<span class="enscript-keyword">if</span> (writemaxcnt)
		mp-&gt;mnt_maxwritecnt = (writemaxcnt &gt; UINT32_MAX) ? UINT32_MAX : writemaxcnt;

	<span class="enscript-keyword">if</span> (writeblockcnt) {
		temp = writeblockcnt * blksize;
		temp = (temp &gt; UINT32_MAX) ? UINT32_MAX : temp;

		<span class="enscript-keyword">if</span> (temp &lt; mp-&gt;mnt_maxwritecnt)
			mp-&gt;mnt_maxwritecnt = (u_int32_t)temp;
	}

	<span class="enscript-keyword">if</span> (readsegcnt) {
	        temp = (readsegcnt &gt; UINT16_MAX) ? UINT16_MAX : readsegcnt;
	} <span class="enscript-keyword">else</span> {
		temp = mp-&gt;mnt_maxreadcnt / PAGE_SIZE;

		<span class="enscript-keyword">if</span> (temp &gt; UINT16_MAX)
			temp = UINT16_MAX;
	}
	mp-&gt;mnt_segreadcnt = (u_int16_t)temp;

	<span class="enscript-keyword">if</span> (writesegcnt) {
	        temp = (writesegcnt &gt; UINT16_MAX) ? UINT16_MAX : writesegcnt;
	} <span class="enscript-keyword">else</span> {
		temp = mp-&gt;mnt_maxwritecnt / PAGE_SIZE;

		<span class="enscript-keyword">if</span> (temp &gt; UINT16_MAX)
			temp = UINT16_MAX;
	}
	mp-&gt;mnt_segwritecnt = (u_int16_t)temp;

	<span class="enscript-keyword">if</span> (readsegsize)
	        temp = (readsegsize &gt; UINT32_MAX) ? UINT32_MAX : readsegsize;
	<span class="enscript-keyword">else</span>
	        temp = mp-&gt;mnt_maxreadcnt;
	mp-&gt;mnt_maxsegreadsize = (u_int32_t)temp;

	<span class="enscript-keyword">if</span> (writesegsize)
	        temp = (writesegsize &gt; UINT32_MAX) ? UINT32_MAX : writesegsize;
	<span class="enscript-keyword">else</span>
	        temp = mp-&gt;mnt_maxwritecnt;
	mp-&gt;mnt_maxsegwritesize = (u_int32_t)temp;

	<span class="enscript-keyword">if</span> (alignment)
	        temp = (alignment &gt; PAGE_SIZE) ? PAGE_MASK : alignment - 1;
	<span class="enscript-keyword">else</span>
	        temp = 0;
	mp-&gt;mnt_alignmentmask = temp;


	<span class="enscript-keyword">if</span> (ioqueue_depth &gt; MNT_DEFAULT_IOQUEUE_DEPTH)
		temp = ioqueue_depth;
	<span class="enscript-keyword">else</span>
		temp = MNT_DEFAULT_IOQUEUE_DEPTH;

	mp-&gt;mnt_ioqueue_depth = temp;
	mp-&gt;mnt_ioscale = (mp-&gt;mnt_ioqueue_depth + (MNT_DEFAULT_IOQUEUE_DEPTH - 1)) / MNT_DEFAULT_IOQUEUE_DEPTH;

	<span class="enscript-keyword">if</span> (mp-&gt;mnt_ioscale &gt; 1)
		printf(<span class="enscript-string">&quot;ioqueue_depth = %d,   ioscale = %d\n&quot;</span>, (<span class="enscript-type">int</span>)mp-&gt;mnt_ioqueue_depth, (<span class="enscript-type">int</span>)mp-&gt;mnt_ioscale);

	<span class="enscript-keyword">if</span> (features &amp; DK_FEATURE_FORCE_UNIT_ACCESS)
	        mp-&gt;mnt_ioflags |= MNT_IOFLAGS_FUA_SUPPORTED;

	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCCORESTORAGE, (caddr_t)&amp;cs_info, 0, ctx) == 0)
		cs_present = TRUE;

	<span class="enscript-keyword">if</span> (features &amp; DK_FEATURE_UNMAP) {
		mp-&gt;mnt_ioflags |= MNT_IOFLAGS_UNMAP_SUPPORTED;

		<span class="enscript-keyword">if</span> (cs_present == TRUE)
			mp-&gt;mnt_ioflags |= MNT_IOFLAGS_CSUNMAP_SUPPORTED;
	}
	<span class="enscript-keyword">if</span> (cs_present == TRUE) {
		<span class="enscript-comment">/*
		 * for now we'll use the following test as a proxy for
		 * the underlying drive being FUSION in nature
		 */</span>
		<span class="enscript-keyword">if</span> ((cs_info.flags &amp; DK_CORESTORAGE_PIN_YOUR_METADATA))
			mp-&gt;mnt_ioflags |= MNT_IOFLAGS_FUSION_DRIVE;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
        <span class="enscript-keyword">if</span> (iosched_enabled &amp;&amp; (features &amp; DK_FEATURE_PRIORITY)) {
                mp-&gt;mnt_ioflags |= MNT_IOFLAGS_IOSCHED_SUPPORTED;
		throttle_info_disable_throttle(mp-&gt;mnt_devbsdunit, (mp-&gt;mnt_ioflags &amp; MNT_IOFLAGS_FUSION_DRIVE) != 0);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IOSCHED */</span>
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> klist fs_klist;
lck_grp_t *fs_klist_lck_grp;
lck_mtx_t *fs_klist_lock;

<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_event_init</span>(<span class="enscript-type">void</span>)
{

	klist_init(&amp;fs_klist);
	fs_klist_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;fs_klist&quot;</span>, NULL);
	fs_klist_lock = lck_mtx_alloc_init(fs_klist_lck_grp, NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_event_signal</span>(fsid_t *fsid, u_int32_t event, intptr_t data)
{
	<span class="enscript-keyword">if</span> (event == VQ_DEAD || event == VQ_NOTRESP) {
		<span class="enscript-type">struct</span> mount *mp = vfs_getvfs(fsid);
		<span class="enscript-keyword">if</span> (mp) {
			mount_lock_spin(mp);
			<span class="enscript-keyword">if</span> (data)
				mp-&gt;mnt_kern_flag &amp;= ~MNT_LNOTRESP;	<span class="enscript-comment">// Now responding
</span>			<span class="enscript-keyword">else</span>
				mp-&gt;mnt_kern_flag |= MNT_LNOTRESP;	<span class="enscript-comment">// Not responding
</span>			mount_unlock(mp);
		}
	}

	lck_mtx_lock(fs_klist_lock);
	KNOTE(&amp;fs_klist, event);
	lck_mtx_unlock(fs_klist_lock);
}

<span class="enscript-comment">/*
 * return the number of mounted filesystems.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_vfs_getvfscnt</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>(mount_getvfscnt());
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mount_getvfscnt</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> ret;

	mount_list_lock();
	ret = nummounts;
	mount_list_unlock();
	<span class="enscript-keyword">return</span> (ret);

}



<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mount_fillfsids</span>(fsid_t *fsidlst, <span class="enscript-type">int</span> count)
{
	<span class="enscript-type">struct</span> mount *mp;
	<span class="enscript-type">int</span> actual=0;

	actual = 0;
	mount_list_lock();
	TAILQ_FOREACH(mp, &amp;mountlist, mnt_list) {
		<span class="enscript-keyword">if</span> (actual &lt;= count) {
			fsidlst[actual] = mp-&gt;mnt_vfsstat.f_fsid;
			actual++;
		}
	}
	mount_list_unlock();
	<span class="enscript-keyword">return</span> (actual);

}

<span class="enscript-comment">/*
 * fill in the array of fsid_t's up to a max of 'count', the actual
 * number filled in will be set in '*actual'.  If there are more fsid_t's
 * than room in fsidlst then ENOMEM will be returned and '*actual' will
 * have the actual count.
 * having *actual filled out even in the error case is depended upon.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_vfs_getvfslist</span>(fsid_t *fsidlst, <span class="enscript-type">int</span> count, <span class="enscript-type">int</span> *actual)
{
	<span class="enscript-type">struct</span> mount *mp;

	*actual = 0;
	mount_list_lock();
	TAILQ_FOREACH(mp, &amp;mountlist, mnt_list) {
		(*actual)++;
		<span class="enscript-keyword">if</span> (*actual &lt;= count)
			fsidlst[(*actual) - 1] = mp-&gt;mnt_vfsstat.f_fsid;
	}
	mount_list_unlock();
	<span class="enscript-keyword">return</span> (*actual &lt;= count ? 0 : ENOMEM);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_vfs_vfslist</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1,
		__unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> actual, error;
	size_t space;
	fsid_t *fsidlst;

	<span class="enscript-comment">/* This is a readonly node. */</span>
	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-comment">/* they are querying us so just return the space required. */</span>
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		req-&gt;oldidx = sysctl_vfs_getvfscnt() * <span class="enscript-keyword">sizeof</span>(fsid_t);
		<span class="enscript-keyword">return</span> 0;
	}
<span class="enscript-reference">again</span>:
	<span class="enscript-comment">/*
	 * Retrieve an accurate count of the amount of space required to copy
	 * out all the fsids in the system.
	 */</span>
	space = req-&gt;oldlen;
	req-&gt;oldlen = sysctl_vfs_getvfscnt() * <span class="enscript-keyword">sizeof</span>(fsid_t);

	<span class="enscript-comment">/* they didn't give us enough space. */</span>
	<span class="enscript-keyword">if</span> (space &lt; req-&gt;oldlen)
		<span class="enscript-keyword">return</span> (ENOMEM);

	MALLOC(fsidlst, fsid_t *, req-&gt;oldlen, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (fsidlst == NULL) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	error = sysctl_vfs_getvfslist(fsidlst, req-&gt;oldlen / <span class="enscript-keyword">sizeof</span>(fsid_t),
	    &amp;actual);
	<span class="enscript-comment">/*
	 * If we get back ENOMEM, then another mount has been added while we
	 * slept in malloc above.  If this is the case then try again.
	 */</span>
	<span class="enscript-keyword">if</span> (error == ENOMEM) {
		FREE(fsidlst, M_TEMP);
		req-&gt;oldlen = space;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}
	<span class="enscript-keyword">if</span> (error == 0) {
		error = SYSCTL_OUT(req, fsidlst, actual * <span class="enscript-keyword">sizeof</span>(fsid_t));
	}
	FREE(fsidlst, M_TEMP);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Do a sysctl by fsid.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_vfs_ctlbyfsid</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2,
		<span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">union</span> union_vfsidctl vc;
	<span class="enscript-type">struct</span> mount *mp;
	<span class="enscript-type">struct</span> vfsstatfs *sp;
	<span class="enscript-type">int</span> *name, flags, namelen;
	<span class="enscript-type">int</span> error=0, gotref=0;
	vfs_context_t ctx = vfs_context_current();
	proc_t p = req-&gt;p;	<span class="enscript-comment">/* XXX req-&gt;p != current_proc()? */</span>
	boolean_t is_64_bit;

	name = arg1;
	namelen = arg2;
	is_64_bit = proc_is64bit(p);

	error = SYSCTL_IN(req, &amp;vc, is_64_bit? <span class="enscript-keyword">sizeof</span>(vc.vc64):<span class="enscript-keyword">sizeof</span>(vc.vc32));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> (vc.vc32.vc_vers != VFS_CTL_VERS1) { <span class="enscript-comment">/* works for 32 and 64 */</span>
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	mp = mount_list_lookupby_fsid(&amp;vc.vc32.vc_fsid, 0, 1); <span class="enscript-comment">/* works for 32 and 64 */</span>
	<span class="enscript-keyword">if</span> (mp == NULL) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	gotref = 1;
	<span class="enscript-comment">/* reset so that the fs specific code can fetch it. */</span>
	req-&gt;newidx = 0;
	<span class="enscript-comment">/*
	 * Note if this is a VFS_CTL then we pass the actual sysctl req
	 * in for &quot;oldp&quot; so that the lower layer can DTRT and use the
	 * SYSCTL_IN/OUT routines.
	 */</span>
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_op-&gt;vfs_sysctl != NULL) {
		<span class="enscript-keyword">if</span> (is_64_bit) {
			<span class="enscript-keyword">if</span> (vfs_64bitready(mp)) {
				error = mp-&gt;mnt_op-&gt;vfs_sysctl(name, namelen,
				    CAST_USER_ADDR_T(req),
				    NULL, USER_ADDR_NULL, 0, 
				    ctx);
			}
			<span class="enscript-keyword">else</span> {
				error = ENOTSUP;
			}
		}
		<span class="enscript-keyword">else</span> {
			error = mp-&gt;mnt_op-&gt;vfs_sysctl(name, namelen,
			    CAST_USER_ADDR_T(req),
			    NULL, USER_ADDR_NULL, 0, 
			    ctx);
		}
		<span class="enscript-keyword">if</span> (error != ENOTSUP) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	<span class="enscript-keyword">switch</span> (name[0]) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_UMOUNT</span>:
		req-&gt;newidx = 0;
		<span class="enscript-keyword">if</span> (is_64_bit) {
			req-&gt;newptr = vc.vc64.vc_ptr;
			req-&gt;newlen = (size_t)vc.vc64.vc_len;
		}
		<span class="enscript-keyword">else</span> {
			req-&gt;newptr = CAST_USER_ADDR_T(vc.vc32.vc_ptr);
			req-&gt;newlen = vc.vc32.vc_len;
		}
		error = SYSCTL_IN(req, &amp;flags, <span class="enscript-keyword">sizeof</span>(flags));
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;

		mount_ref(mp, 0);
		mount_iterdrop(mp);
		gotref = 0;
		<span class="enscript-comment">/* safedounmount consumes a ref */</span>
		error = safedounmount(mp, flags, ctx);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_STATFS</span>:
		req-&gt;newidx = 0;
		<span class="enscript-keyword">if</span> (is_64_bit) {
			req-&gt;newptr = vc.vc64.vc_ptr;
			req-&gt;newlen = (size_t)vc.vc64.vc_len;
		}
		<span class="enscript-keyword">else</span> {
			req-&gt;newptr = CAST_USER_ADDR_T(vc.vc32.vc_ptr);
			req-&gt;newlen = vc.vc32.vc_len;
		}
		error = SYSCTL_IN(req, &amp;flags, <span class="enscript-keyword">sizeof</span>(flags));
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		sp = &amp;mp-&gt;mnt_vfsstat;
		<span class="enscript-keyword">if</span> (((flags &amp; MNT_NOWAIT) == 0 || (flags &amp; (MNT_WAIT | MNT_DWAIT))) &amp;&amp;
		    (error = vfs_update_vfsstat(mp, ctx, VFS_USER_EVENT)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-keyword">if</span> (is_64_bit) {
			<span class="enscript-type">struct</span> user64_statfs sfs;
			bzero(&amp;sfs, <span class="enscript-keyword">sizeof</span>(sfs));
			sfs.f_flags = mp-&gt;mnt_flag &amp; MNT_VISFLAGMASK;
			sfs.f_type = mp-&gt;mnt_vtable-&gt;vfc_typenum;
			sfs.f_bsize = (user64_long_t)sp-&gt;f_bsize;
			sfs.f_iosize = (user64_long_t)sp-&gt;f_iosize;
			sfs.f_blocks = (user64_long_t)sp-&gt;f_blocks;
			sfs.f_bfree = (user64_long_t)sp-&gt;f_bfree;
			sfs.f_bavail = (user64_long_t)sp-&gt;f_bavail;
			sfs.f_files = (user64_long_t)sp-&gt;f_files;
			sfs.f_ffree = (user64_long_t)sp-&gt;f_ffree;
			sfs.f_fsid = sp-&gt;f_fsid;
			sfs.f_owner = sp-&gt;f_owner;
    
			<span class="enscript-keyword">if</span> (mp-&gt;mnt_kern_flag &amp; MNTK_TYPENAME_OVERRIDE) {
				strlcpy(&amp;sfs.f_fstypename[0], &amp;mp-&gt;fstypename_override[0], MFSTYPENAMELEN);
			} <span class="enscript-keyword">else</span> {
				strlcpy(sfs.f_fstypename, sp-&gt;f_fstypename, MFSNAMELEN);
			}
			strlcpy(sfs.f_mntonname, sp-&gt;f_mntonname, MNAMELEN);
			strlcpy(sfs.f_mntfromname, sp-&gt;f_mntfromname, MNAMELEN);
            
			error = SYSCTL_OUT(req, &amp;sfs, <span class="enscript-keyword">sizeof</span>(sfs));
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_statfs sfs;
			bzero(&amp;sfs, <span class="enscript-keyword">sizeof</span>(sfs));
			sfs.f_flags = mp-&gt;mnt_flag &amp; MNT_VISFLAGMASK;
			sfs.f_type = mp-&gt;mnt_vtable-&gt;vfc_typenum;

			<span class="enscript-comment">/*
			 * It's possible for there to be more than 2^^31 blocks in the filesystem, so we
			 * have to fudge the numbers here in that case.   We inflate the blocksize in order
			 * to reflect the filesystem size as best we can.
			 */</span>
			<span class="enscript-keyword">if</span> (sp-&gt;f_blocks &gt; INT_MAX) {
				<span class="enscript-type">int</span>		shift;

				<span class="enscript-comment">/*
				 * Work out how far we have to shift the block count down to make it fit.
				 * Note that it's possible to have to shift so far that the resulting
				 * blocksize would be unreportably large.  At that point, we will clip
				 * any values that don't fit.
				 *
				 * For safety's sake, we also ensure that f_iosize is never reported as
				 * being smaller than f_bsize.
				 */</span>
				<span class="enscript-keyword">for</span> (shift = 0; shift &lt; 32; shift++) {
					<span class="enscript-keyword">if</span> ((sp-&gt;f_blocks &gt;&gt; shift) &lt;= INT_MAX)
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">if</span> ((((<span class="enscript-type">long</span> <span class="enscript-type">long</span>)sp-&gt;f_bsize) &lt;&lt; (shift + 1)) &gt; INT_MAX)
						<span class="enscript-keyword">break</span>;
				}
#<span class="enscript-reference">define</span> <span class="enscript-function-name">__SHIFT_OR_CLIP</span>(x, s)	((((x) &gt;&gt; (s)) &gt; INT_MAX) ? INT_MAX : ((x) &gt;&gt; (s)))
				sfs.f_blocks = (user32_long_t)__SHIFT_OR_CLIP(sp-&gt;f_blocks, shift);
				sfs.f_bfree = (user32_long_t)__SHIFT_OR_CLIP(sp-&gt;f_bfree, shift);
				sfs.f_bavail = (user32_long_t)__SHIFT_OR_CLIP(sp-&gt;f_bavail, shift);
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">__SHIFT_OR_CLIP</span>
				sfs.f_bsize = (user32_long_t)(sp-&gt;f_bsize &lt;&lt; shift);
				sfs.f_iosize = lmax(sp-&gt;f_iosize, sp-&gt;f_bsize);
			} <span class="enscript-keyword">else</span> {
				sfs.f_bsize = (user32_long_t)sp-&gt;f_bsize;
				sfs.f_iosize = (user32_long_t)sp-&gt;f_iosize;
				sfs.f_blocks = (user32_long_t)sp-&gt;f_blocks;
				sfs.f_bfree = (user32_long_t)sp-&gt;f_bfree;
				sfs.f_bavail = (user32_long_t)sp-&gt;f_bavail;
			}
			sfs.f_files = (user32_long_t)sp-&gt;f_files;
			sfs.f_ffree = (user32_long_t)sp-&gt;f_ffree;
			sfs.f_fsid = sp-&gt;f_fsid;
			sfs.f_owner = sp-&gt;f_owner;
    
			<span class="enscript-keyword">if</span> (mp-&gt;mnt_kern_flag &amp; MNTK_TYPENAME_OVERRIDE) {
				strlcpy(&amp;sfs.f_fstypename[0], &amp;mp-&gt;fstypename_override[0], MFSTYPENAMELEN);
			} <span class="enscript-keyword">else</span> {
				strlcpy(sfs.f_fstypename, sp-&gt;f_fstypename, MFSNAMELEN);
			}
			strlcpy(sfs.f_mntonname, sp-&gt;f_mntonname, MNAMELEN);
			strlcpy(sfs.f_mntfromname, sp-&gt;f_mntfromname, MNAMELEN);
            
			error = SYSCTL_OUT(req, &amp;sfs, <span class="enscript-keyword">sizeof</span>(sfs));
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = ENOTSUP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span>(gotref != 0)
		mount_iterdrop(mp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	filt_fsattach(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	filt_fsdetach(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	filt_fsevent(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);
<span class="enscript-type">struct</span> filterops fs_filtops = {
        .f_attach = filt_fsattach,
        .f_detach = filt_fsdetach,
        .f_event = filt_fsevent,
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_fsattach</span>(<span class="enscript-type">struct</span> knote *kn)
{

	lck_mtx_lock(fs_klist_lock);
	kn-&gt;kn_flags |= EV_CLEAR;
	KNOTE_ATTACH(&amp;fs_klist, kn);
	lck_mtx_unlock(fs_klist_lock);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_fsdetach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	lck_mtx_lock(fs_klist_lock);
	KNOTE_DETACH(&amp;fs_klist, kn);
	lck_mtx_unlock(fs_klist_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_fsevent</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-comment">/*
	 * Backwards compatibility:
	 * Other filters would do nothing if kn-&gt;kn_sfflags == 0
	 */</span>

	<span class="enscript-keyword">if</span> ((kn-&gt;kn_sfflags == 0) || (kn-&gt;kn_sfflags &amp; hint)) {
		kn-&gt;kn_fflags |= hint;
	}

	<span class="enscript-keyword">return</span> (kn-&gt;kn_fflags != 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_vfs_noremotehang</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp,
		__unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> out, error;
	pid_t pid;
	proc_t p;

	<span class="enscript-comment">/* We need a pid. */</span>
	<span class="enscript-keyword">if</span> (req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	error = SYSCTL_IN(req, &amp;pid, <span class="enscript-keyword">sizeof</span>(pid));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	p = proc_find(pid &lt; 0 ? -pid : pid);
	<span class="enscript-keyword">if</span> (p == NULL)
		<span class="enscript-keyword">return</span> (ESRCH);

	<span class="enscript-comment">/*
	 * Fetching the value is ok, but we only fetch if the old
	 * pointer is given.
	 */</span>
	<span class="enscript-keyword">if</span> (req-&gt;oldptr != USER_ADDR_NULL) {
		out = !((p-&gt;p_flag &amp; P_NOREMOTEHANG) == 0);
		proc_rele(p);
		error = SYSCTL_OUT(req, &amp;out, <span class="enscript-keyword">sizeof</span>(out));
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* cansignal offers us enough security. */</span>
	<span class="enscript-keyword">if</span> (p != req-&gt;p &amp;&amp; proc_suser(req-&gt;p) != 0) {
		proc_rele(p);
		<span class="enscript-keyword">return</span> (EPERM);
	}

	<span class="enscript-keyword">if</span> (pid &lt; 0)
		OSBitAndAtomic(~((uint32_t)P_NOREMOTEHANG), &amp;p-&gt;p_flag);
	<span class="enscript-keyword">else</span>
		OSBitOrAtomic(P_NOREMOTEHANG, &amp;p-&gt;p_flag);
	proc_rele(p);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_vfs_generic_conf SYSCTL_HANDLER_ARGS
{
	<span class="enscript-type">int</span> *name, namelen;
	<span class="enscript-type">struct</span> vfstable *vfsp;
	<span class="enscript-type">struct</span> vfsconf vfsc;
	
	(<span class="enscript-type">void</span>)oidp;
	name = arg1;
	namelen = arg2;
	
	<span class="enscript-keyword">if</span> (namelen &lt; 1) {
		<span class="enscript-keyword">return</span> (EISDIR);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (namelen &gt; 1) {
		<span class="enscript-keyword">return</span> (ENOTDIR);
	}
			
	mount_list_lock();
	<span class="enscript-keyword">for</span> (vfsp = vfsconf; vfsp; vfsp = vfsp-&gt;vfc_next)
		<span class="enscript-keyword">if</span> (vfsp-&gt;vfc_typenum == name[0])
			<span class="enscript-keyword">break</span>;
	
	<span class="enscript-keyword">if</span> (vfsp == NULL) {
		mount_list_unlock();
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}
			
	vfsc.vfc_reserved1 = 0;
	bcopy(vfsp-&gt;vfc_name, vfsc.vfc_name, <span class="enscript-keyword">sizeof</span>(vfsc.vfc_name));
	vfsc.vfc_typenum = vfsp-&gt;vfc_typenum;
	vfsc.vfc_refcount = vfsp-&gt;vfc_refcount;
	vfsc.vfc_flags = vfsp-&gt;vfc_flags;
	vfsc.vfc_reserved2 = 0;
	vfsc.vfc_reserved3 = 0;
			
	mount_list_unlock();
	<span class="enscript-keyword">return</span> (SYSCTL_OUT(req, &amp;vfsc, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vfsconf)));
}

<span class="enscript-comment">/* the vfs.generic. branch. */</span>
<span class="enscript-function-name">SYSCTL_NODE</span>(_vfs, VFS_GENERIC, generic, CTLFLAG_RW | CTLFLAG_LOCKED, NULL, <span class="enscript-string">&quot;vfs generic hinge&quot;</span>);
<span class="enscript-comment">/* retreive a list of mounted filesystem fsid_t */</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_vfs_generic, OID_AUTO, vfsidlist,
    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
    NULL, 0, sysctl_vfs_vfslist, <span class="enscript-string">&quot;S,fsid&quot;</span>, <span class="enscript-string">&quot;List of mounted filesystem ids&quot;</span>);
<span class="enscript-comment">/* perform operations on filesystem via fsid_t */</span>
<span class="enscript-function-name">SYSCTL_NODE</span>(_vfs_generic, OID_AUTO, ctlbyfsid, CTLFLAG_RW | CTLFLAG_LOCKED,
    sysctl_vfs_ctlbyfsid, <span class="enscript-string">&quot;ctlbyfsid&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_vfs_generic, OID_AUTO, noremotehang, CTLFLAG_RW | CTLFLAG_ANYBODY,
    NULL, 0, sysctl_vfs_noremotehang, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;noremotehang&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic, VFS_MAXTYPENUM, maxtypenum,
		   CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED,
		   &amp;maxvfstypenum, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic, OID_AUTO, sync_timeout, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;sync_timeout, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_NODE</span>(_vfs_generic, VFS_CONF, conf,
		   CTLFLAG_RD | CTLFLAG_LOCKED,
		   sysctl_vfs_generic_conf, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/*
 * Print vnode state.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vn_print_state</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...)
{
	va_list ap;
	<span class="enscript-type">char</span> perm_str[] = <span class="enscript-string">&quot;(VM_KERNEL_ADDRPERM pointer)&quot;</span>;
	<span class="enscript-type">char</span> fs_name[MFSNAMELEN];

	va_start(ap, fmt);
	vprintf(fmt, ap);
	va_end(ap);
	printf(<span class="enscript-string">&quot;vp 0x%0llx %s: &quot;</span>, (uint64_t)VM_KERNEL_ADDRPERM(vp), perm_str);
	printf(<span class="enscript-string">&quot;tag %d, type %d\n&quot;</span>, vp-&gt;v_tag, vp-&gt;v_type);
	<span class="enscript-comment">/* Counts .. */</span>
	printf(<span class="enscript-string">&quot;    iocount %d, usecount %d, kusecount %d references %d\n&quot;</span>,
	    vp-&gt;v_iocount, vp-&gt;v_usecount, vp-&gt;v_kusecount, vp-&gt;v_references);
	printf(<span class="enscript-string">&quot;    writecount %d, numoutput %d\n&quot;</span>, vp-&gt;v_writecount,
	    vp-&gt;v_numoutput);
	<span class="enscript-comment">/* Flags */</span>
	printf(<span class="enscript-string">&quot;    flag 0x%x, lflag 0x%x, listflag 0x%x\n&quot;</span>, vp-&gt;v_flag,
	    vp-&gt;v_lflag, vp-&gt;v_listflag);

	<span class="enscript-keyword">if</span> (vp-&gt;v_mount == NULL || vp-&gt;v_mount == dead_mountp) {
		strlcpy(fs_name, <span class="enscript-string">&quot;deadfs&quot;</span>, MFSNAMELEN);
	} <span class="enscript-keyword">else</span> {
		vfs_name(vp-&gt;v_mount, fs_name);
	}

	printf(<span class="enscript-string">&quot;    v_data 0x%0llx %s\n&quot;</span>,
	    (vp-&gt;v_data ? (uint64_t)VM_KERNEL_ADDRPERM(vp-&gt;v_data) : 0),
	    perm_str);
	printf(<span class="enscript-string">&quot;    v_mount 0x%0llx %s vfs_name %s\n&quot;</span>,
	    (vp-&gt;v_mount ? (uint64_t)VM_KERNEL_ADDRPERM(vp-&gt;v_mount) : 0),
	    perm_str, fs_name);
}

<span class="enscript-type">long</span> num_reusedvnodes = 0;


<span class="enscript-type">static</span> vnode_t
<span class="enscript-function-name">process_vp</span>(vnode_t vp, <span class="enscript-type">int</span> want_vp, <span class="enscript-type">int</span> *deferred)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>  vpid;

	*deferred = 0;

	vpid = vp-&gt;v_id;

	vnode_list_remove_locked(vp);

	vnode_list_unlock();

	vnode_lock_spin(vp);

	<span class="enscript-comment">/* 
	 * We could wait for the vnode_lock after removing the vp from the freelist
	 * and the vid is bumped only at the very end of reclaim. So it is  possible
	 * that we are looking at a vnode that is being terminated. If so skip it.
	 */</span> 
	<span class="enscript-keyword">if</span> ((vpid != vp-&gt;v_id) || (vp-&gt;v_usecount != 0) || (vp-&gt;v_iocount != 0) || 
	    VONLIST(vp) || (vp-&gt;v_lflag &amp; VL_TERMINATE)) {
		<span class="enscript-comment">/*
		 * we lost the race between dropping the list lock
		 * and picking up the vnode_lock... someone else
		 * used this vnode and it is now in a new state
		 */</span>
		vnode_unlock(vp);
		
		<span class="enscript-keyword">return</span> (NULLVP);
	}
	<span class="enscript-keyword">if</span> ( (vp-&gt;v_lflag &amp; (VL_NEEDINACTIVE | VL_MARKTERM)) == VL_NEEDINACTIVE ) {
	        <span class="enscript-comment">/*
		 * we did a vnode_rele_ext that asked for
		 * us not to reenter the filesystem during
		 * the release even though VL_NEEDINACTIVE was
		 * set... we'll do it here by doing a
		 * vnode_get/vnode_put
		 *
		 * pick up an iocount so that we can call
		 * vnode_put and drive the VNOP_INACTIVE...
		 * vnode_put will either leave us off 
		 * the freelist if a new ref comes in,
		 * or put us back on the end of the freelist
		 * or recycle us if we were marked for termination...
		 * so we'll just go grab a new candidate
		 */</span>
	        vp-&gt;v_iocount++;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
		record_vp(vp, 1);
#<span class="enscript-reference">endif</span>
		vnode_put_locked(vp);
		vnode_unlock(vp);

		<span class="enscript-keyword">return</span> (NULLVP);
	}
	<span class="enscript-comment">/*
	 * Checks for anyone racing us for recycle
	 */</span> 
	<span class="enscript-keyword">if</span> (vp-&gt;v_type != VBAD) {
		<span class="enscript-keyword">if</span> (want_vp &amp;&amp; (vnode_on_reliable_media(vp) == FALSE || (vp-&gt;v_flag &amp; VISDIRTY))) {
			vnode_async_list_add(vp);
			vnode_unlock(vp);
			
			*deferred = 1;

			<span class="enscript-keyword">return</span> (NULLVP);
		}
		<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VL_DEAD)
			panic(<span class="enscript-string">&quot;new_vnode(%p): the vnode is VL_DEAD but not VBAD&quot;</span>, vp);

		vnode_lock_convert(vp);
		(<span class="enscript-type">void</span>)vnode_reclaim_internal(vp, 1, want_vp, 0);

		<span class="enscript-keyword">if</span> (want_vp) {
			<span class="enscript-keyword">if</span> ((VONLIST(vp)))
				panic(<span class="enscript-string">&quot;new_vnode(%p): vp on list&quot;</span>, vp);
			<span class="enscript-keyword">if</span> (vp-&gt;v_usecount || vp-&gt;v_iocount || vp-&gt;v_kusecount ||
			    (vp-&gt;v_lflag &amp; (VNAMED_UBC | VNAMED_MOUNT | VNAMED_FSHASH)))
				panic(<span class="enscript-string">&quot;new_vnode(%p): free vnode still referenced&quot;</span>, vp);
			<span class="enscript-keyword">if</span> ((vp-&gt;v_mntvnodes.tqe_prev != 0) &amp;&amp; (vp-&gt;v_mntvnodes.tqe_next != 0))
				panic(<span class="enscript-string">&quot;new_vnode(%p): vnode seems to be on mount list&quot;</span>, vp);
			<span class="enscript-keyword">if</span> ( !LIST_EMPTY(&amp;vp-&gt;v_nclinks) || !LIST_EMPTY(&amp;vp-&gt;v_ncchildren))
				panic(<span class="enscript-string">&quot;new_vnode(%p): vnode still hooked into the name cache&quot;</span>, vp);
		} <span class="enscript-keyword">else</span> {
			vnode_unlock(vp);
			vp = NULLVP;
		}
	}
	<span class="enscript-keyword">return</span> (vp);
}



<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">async_work_continue</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> async_work_lst *q;
	<span class="enscript-type">int</span>	deferred;
	vnode_t	vp;

	q = &amp;vnode_async_work_list;

	<span class="enscript-keyword">for</span> (;;) {

		vnode_list_lock();

		<span class="enscript-keyword">if</span> ( TAILQ_EMPTY(q) ) {
			assert_wait(q, (THREAD_UNINT));
	
			vnode_list_unlock();
			
			thread_block((thread_continue_t)async_work_continue);

			<span class="enscript-keyword">continue</span>;
		}
		async_work_handled++;

		vp = TAILQ_FIRST(q);

		vp = process_vp(vp, 0, &amp;deferred);

		<span class="enscript-keyword">if</span> (vp != NULLVP)
			panic(<span class="enscript-string">&quot;found VBAD vp (%p) on async queue&quot;</span>, vp);
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">new_vnode</span>(vnode_t *vpp)
{
	vnode_t	vp;
	uint32_t retries = 0, max_retries = 100;		<span class="enscript-comment">/* retry incase of tablefull */</span>
	<span class="enscript-type">int</span> force_alloc = 0, walk_count = 0;
	boolean_t need_reliable_vp = FALSE;
	<span class="enscript-type">int</span> deferred;
        <span class="enscript-type">struct</span> timeval initial_tv;
        <span class="enscript-type">struct</span> timeval current_tv;
	proc_t  curproc = current_proc();

	initial_tv.tv_sec = 0;
<span class="enscript-reference">retry</span>:
	vp = NULLVP;

	vnode_list_lock();

	<span class="enscript-keyword">if</span> (need_reliable_vp == TRUE)
		async_work_timed_out++;

	<span class="enscript-keyword">if</span> ((numvnodes - deadvnodes) &lt; desiredvnodes || force_alloc) {
		<span class="enscript-type">struct</span> timespec ts;

		<span class="enscript-keyword">if</span> ( !TAILQ_EMPTY(&amp;vnode_dead_list)) {
			<span class="enscript-comment">/*
			 * Can always reuse a dead one
			 */</span>
			vp = TAILQ_FIRST(&amp;vnode_dead_list);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">steal_this_vp</span>;
		}
		<span class="enscript-comment">/*
		 * no dead vnodes available... if we're under
		 * the limit, we'll create a new vnode
		 */</span>
		numvnodes++;
		vnode_list_unlock();

		MALLOC_ZONE(vp, <span class="enscript-type">struct</span> vnode *, <span class="enscript-keyword">sizeof</span>(*vp), M_VNODE, M_WAITOK);
		bzero((<span class="enscript-type">char</span> *)vp, <span class="enscript-keyword">sizeof</span>(*vp));
		VLISTNONE(vp);		<span class="enscript-comment">/* avoid double queue removal */</span>
		lck_mtx_init(&amp;vp-&gt;v_lock, vnode_lck_grp, vnode_lck_attr);

		klist_init(&amp;vp-&gt;v_knotes);
		nanouptime(&amp;ts);
		vp-&gt;v_id = ts.tv_nsec;
		vp-&gt;v_flag = VSTANDARD;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-keyword">if</span> (mac_vnode_label_init_needed(vp))
			mac_vnode_label_init(vp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>

		vp-&gt;v_iocount = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	microuptime(&amp;current_tv);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_WALK_COUNT</span> 1000

	<span class="enscript-keyword">if</span> ( !TAILQ_EMPTY(&amp;vnode_rage_list) &amp;&amp;
	     (ragevnodes &gt;= rage_limit ||
	      (current_tv.tv_sec - rage_tv.tv_sec) &gt;= RAGE_TIME_LIMIT)) {

		TAILQ_FOREACH(vp, &amp;vnode_rage_list, v_freelist) {
			<span class="enscript-keyword">if</span> ( !(vp-&gt;v_listflag &amp; VLIST_RAGE))
				panic(<span class="enscript-string">&quot;new_vnode: vp (%p) on RAGE list not marked VLIST_RAGE&quot;</span>, vp);

			<span class="enscript-comment">// if we're a dependency-capable process, skip vnodes that can
</span>			<span class="enscript-comment">// cause recycling deadlocks. (i.e. this process is diskimages
</span>			<span class="enscript-comment">// helper and the vnode is in a disk image).  Querying the
</span>			<span class="enscript-comment">// mnt_kern_flag for the mount's virtual device status
</span>			<span class="enscript-comment">// is safer than checking the mnt_dependent_process, which
</span>			<span class="enscript-comment">// may not be updated if there are multiple devnode layers 
</span>			<span class="enscript-comment">// in between the disk image and the final consumer.
</span>
			<span class="enscript-keyword">if</span> ((curproc-&gt;p_flag &amp; P_DEPENDENCY_CAPABLE) == 0 || vp-&gt;v_mount == NULL || 
			    (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_VIRTUALDEV) == 0) {
				<span class="enscript-comment">/*
				 * if need_reliable_vp == TRUE, then we've already sent one or more
				 * non-reliable vnodes to the async thread for processing and timed
				 * out waiting for a dead vnode to show up.  Use the MAX_WALK_COUNT
				 * mechanism to first scan for a reliable vnode before forcing 
				 * a new vnode to be created
				 */</span>
				<span class="enscript-keyword">if</span> (need_reliable_vp == FALSE || vnode_on_reliable_media(vp) == TRUE)
					<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">// don't iterate more than MAX_WALK_COUNT vnodes to
</span>			<span class="enscript-comment">// avoid keeping the vnode list lock held for too long.
</span>
			<span class="enscript-keyword">if</span> (walk_count++ &gt; MAX_WALK_COUNT) {
				vp = NULL;
				<span class="enscript-keyword">break</span>;
			}
		}
	}

	<span class="enscript-keyword">if</span> (vp == NULL &amp;&amp; !TAILQ_EMPTY(&amp;vnode_free_list)) {
	        <span class="enscript-comment">/*
		 * Pick the first vp for possible reuse
		 */</span>
		walk_count = 0;
		TAILQ_FOREACH(vp, &amp;vnode_free_list, v_freelist) {

			<span class="enscript-comment">// if we're a dependency-capable process, skip vnodes that can
</span>			<span class="enscript-comment">// cause recycling deadlocks. (i.e. this process is diskimages
</span>			<span class="enscript-comment">// helper and the vnode is in a disk image).  Querying the
</span>			<span class="enscript-comment">// mnt_kern_flag for the mount's virtual device status
</span>			<span class="enscript-comment">// is safer than checking the mnt_dependent_process, which
</span>			<span class="enscript-comment">// may not be updated if there are multiple devnode layers 
</span>			<span class="enscript-comment">// in between the disk image and the final consumer.
</span>
			<span class="enscript-keyword">if</span> ((curproc-&gt;p_flag &amp; P_DEPENDENCY_CAPABLE) == 0 || vp-&gt;v_mount == NULL || 
			    (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_VIRTUALDEV) == 0) {
				<span class="enscript-comment">/*
				 * if need_reliable_vp == TRUE, then we've already sent one or more
				 * non-reliable vnodes to the async thread for processing and timed
				 * out waiting for a dead vnode to show up.  Use the MAX_WALK_COUNT
				 * mechanism to first scan for a reliable vnode before forcing 
				 * a new vnode to be created
				 */</span>
				<span class="enscript-keyword">if</span> (need_reliable_vp == FALSE || vnode_on_reliable_media(vp) == TRUE)
					<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">// don't iterate more than MAX_WALK_COUNT vnodes to
</span>			<span class="enscript-comment">// avoid keeping the vnode list lock held for too long.
</span>
			<span class="enscript-keyword">if</span> (walk_count++ &gt; MAX_WALK_COUNT) {
				vp = NULL;
				<span class="enscript-keyword">break</span>;
			}
		}
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if we don't have a vnode and the walk_count is &gt;= MAX_WALK_COUNT
</span>	<span class="enscript-comment">// then we're trying to create a vnode on behalf of a
</span>	<span class="enscript-comment">// process like diskimages-helper that has file systems
</span>	<span class="enscript-comment">// mounted on top of itself (and thus we can't reclaim
</span>	<span class="enscript-comment">// vnodes in the file systems on top of us).  if we can't
</span>	<span class="enscript-comment">// find a vnode to reclaim then we'll just have to force
</span>	<span class="enscript-comment">// the allocation.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (vp == NULL &amp;&amp; walk_count &gt;= MAX_WALK_COUNT) {
		force_alloc = 1;
		vnode_list_unlock();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
	}

	<span class="enscript-keyword">if</span> (vp == NULL) {
		<span class="enscript-comment">/*
		 * we've reached the system imposed maximum number of vnodes
		 * but there isn't a single one available
		 * wait a bit and then retry... if we can't get a vnode
		 * after our target number of retries, than log a complaint
		 */</span>
		<span class="enscript-keyword">if</span> (++retries &lt;= max_retries) {
			vnode_list_unlock();
			delay_for_interval(1, 1000 * 1000);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}
			
		vnode_list_unlock();
		tablefull(<span class="enscript-string">&quot;vnode&quot;</span>);
		log(LOG_EMERG, <span class="enscript-string">&quot;%d desired, %d numvnodes, &quot;</span>
			<span class="enscript-string">&quot;%d free, %d dead, %d async, %d rage\n&quot;</span>,
		        desiredvnodes, numvnodes, freevnodes, deadvnodes, async_work_vnodes, ragevnodes);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">if</span> (bootarg_no_vnode_jetsam)
			panic(<span class="enscript-string">&quot;vnode table is full\n&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

		<span class="enscript-comment">/*
		 * Running out of vnodes tends to make a system unusable. Start killing
		 * processes that jetsam knows are killable.
		 */</span>
		<span class="enscript-keyword">if</span> (memorystatus_kill_on_vnode_limit() == FALSE) {
			<span class="enscript-comment">/*
			 * If jetsam can't find any more processes to kill and there
			 * still aren't any free vnodes, panic. Hopefully we'll get a
			 * panic log to tell us why we ran out.
			 */</span>
			panic(<span class="enscript-string">&quot;vnode table is full\n&quot;</span>);
		}

		<span class="enscript-comment">/* 
		 * Now that we've killed someone, wait a bit and continue looking 
		 * (with fewer retries before trying another kill).
		 */</span>
		delay_for_interval(3, 1000 * 1000);
		retries = 0;	
		max_retries = 10;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
#<span class="enscript-reference">endif</span>

		*vpp = NULL;
		<span class="enscript-keyword">return</span> (ENFILE);
	}
<span class="enscript-reference">steal_this_vp</span>:
	<span class="enscript-keyword">if</span> ((vp = process_vp(vp, 1, &amp;deferred)) == NULLVP) {
		<span class="enscript-keyword">if</span> (deferred) {
			<span class="enscript-type">int</span>	elapsed_msecs;
			<span class="enscript-type">struct</span> timeval elapsed_tv;

			<span class="enscript-keyword">if</span> (initial_tv.tv_sec == 0)
				microuptime(&amp;initial_tv);

			vnode_list_lock();

			dead_vnode_waited++;
			dead_vnode_wanted++;

			<span class="enscript-comment">/*
			 * note that we're only going to explicitly wait 10ms
			 * for a dead vnode to become available, since even if one
			 * isn't available, a reliable vnode might now be available
			 * at the head of the VRAGE or free lists... if so, we
			 * can satisfy the new_vnode request with less latency then waiting
			 * for the full 100ms duration we're ultimately willing to tolerate
			 */</span>
			assert_wait_timeout((caddr_t)&amp;dead_vnode_wanted, (THREAD_INTERRUPTIBLE), 10000, NSEC_PER_USEC);

			vnode_list_unlock();

			thread_block(THREAD_CONTINUE_NULL);

			microuptime(&amp;elapsed_tv);
			
			timevalsub(&amp;elapsed_tv, &amp;initial_tv);
			elapsed_msecs = elapsed_tv.tv_sec * 1000 + elapsed_tv.tv_usec / 1000;

			<span class="enscript-keyword">if</span> (elapsed_msecs &gt;= 100) {
				<span class="enscript-comment">/*
				 * we've waited long enough... 100ms is 
				 * somewhat arbitrary for this case, but the
				 * normal worst case latency used for UI
				 * interaction is 100ms, so I've chosen to
				 * go with that.
				 *
				 * setting need_reliable_vp to TRUE
				 * forces us to find a reliable vnode
				 * that we can process synchronously, or
				 * to create a new one if the scan for
				 * a reliable one hits the scan limit
				 */</span>
				need_reliable_vp = TRUE;
			}
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
	}
	OSAddAtomicLong(1, &amp;num_reusedvnodes);


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * We should never see VL_LABELWAIT or VL_LABEL here.
	 * as those operations hold a reference.
	 */</span>
	assert ((vp-&gt;v_lflag &amp; VL_LABELWAIT) != VL_LABELWAIT);
	assert ((vp-&gt;v_lflag &amp; VL_LABEL) != VL_LABEL);
	<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VL_LABELED) {
	        vnode_lock_convert(vp);
		mac_vnode_label_recycle(vp);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mac_vnode_label_init_needed(vp)) {
	        vnode_lock_convert(vp);
		mac_vnode_label_init(vp);
	}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>

	vp-&gt;v_iocount = 1;
	vp-&gt;v_lflag = 0;
	vp-&gt;v_writecount = 0;
        vp-&gt;v_references = 0;
	vp-&gt;v_iterblkflags = 0;
	vp-&gt;v_flag = VSTANDARD;
	<span class="enscript-comment">/* vbad vnodes can point to dead_mountp */</span>
	vp-&gt;v_mount = NULL;
	vp-&gt;v_defer_reclaimlist = (vnode_t)0;

	vnode_unlock(vp);

<span class="enscript-reference">done</span>:
	*vpp = vp;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_lock</span>(vnode_t vp)
{
	lck_mtx_lock(&amp;vp-&gt;v_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_lock_spin</span>(vnode_t vp)
{
	lck_mtx_lock_spin(&amp;vp-&gt;v_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_unlock</span>(vnode_t vp)
{
	lck_mtx_unlock(&amp;vp-&gt;v_lock);
}



<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_get</span>(<span class="enscript-type">struct</span> vnode *vp)
{
        <span class="enscript-type">int</span> retval;

        vnode_lock_spin(vp);
	retval = vnode_get_locked(vp);
	vnode_unlock(vp);

	<span class="enscript-keyword">return</span>(retval);	
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_get_locked</span>(<span class="enscript-type">struct</span> vnode *vp)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	lck_mtx_assert(&amp;vp-&gt;v_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_iocount == 0) &amp;&amp; (vp-&gt;v_lflag &amp; (VL_TERMINATE | VL_DEAD))) {
		<span class="enscript-keyword">return</span>(ENOENT);	
	}
	vp-&gt;v_iocount++;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	record_vp(vp, 1);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * vnode_getwithvid() cuts in line in front of a vnode drain (that is,
 * while the vnode is draining, but at no point after that) to prevent
 * deadlocks when getting vnodes from filesystem hashes while holding
 * resources that may prevent other iocounts from being released.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_getwithvid</span>(vnode_t vp, uint32_t vid)
{
        <span class="enscript-keyword">return</span>(vget_internal(vp, vid, ( VNODE_NODEAD | VNODE_WITHID | VNODE_DRAINO )));
}

<span class="enscript-comment">/*
 * vnode_getwithvid_drainok() is like vnode_getwithvid(), but *does* block behind a vnode
 * drain; it exists for use in the VFS name cache, where we really do want to block behind
 * vnode drain to prevent holding off an unmount.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_getwithvid_drainok</span>(vnode_t vp, uint32_t vid)
{
        <span class="enscript-keyword">return</span>(vget_internal(vp, vid, ( VNODE_NODEAD | VNODE_WITHID )));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_getwithref</span>(vnode_t vp)
{
        <span class="enscript-keyword">return</span>(vget_internal(vp, 0, 0));
}


__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_getalways</span>(vnode_t vp)
{
        <span class="enscript-keyword">return</span>(vget_internal(vp, 0, VNODE_ALWAYS));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_put</span>(vnode_t vp)
{
        <span class="enscript-type">int</span> retval;

	vnode_lock_spin(vp);
	retval = vnode_put_locked(vp);
	vnode_unlock(vp);

	<span class="enscript-keyword">return</span>(retval);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">vn_set_dead</span>(vnode_t vp)
{
	vp-&gt;v_mount = NULL;
	vp-&gt;v_op = dead_vnodeop_p;
	vp-&gt;v_tag = VT_NON;
	vp-&gt;v_data = NULL;
	vp-&gt;v_type = VBAD;
	vp-&gt;v_lflag |= VL_DEAD;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_put_locked</span>(vnode_t vp)
{
	vfs_context_t ctx = vfs_context_current();	<span class="enscript-comment">/* hoist outside loop */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	lck_mtx_assert(&amp;vp-&gt;v_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
<span class="enscript-reference">retry</span>:
	<span class="enscript-keyword">if</span> (vp-&gt;v_iocount &lt; 1) 
		panic(<span class="enscript-string">&quot;vnode_put(%p): iocount &lt; 1&quot;</span>, vp);

	<span class="enscript-keyword">if</span> ((vp-&gt;v_usecount &gt; 0) || (vp-&gt;v_iocount &gt; 1))  {
		vnode_dropiocount(vp);
		<span class="enscript-keyword">return</span>(0);
	}
	<span class="enscript-keyword">if</span> ((vp-&gt;v_lflag &amp; (VL_DEAD | VL_NEEDINACTIVE)) == VL_NEEDINACTIVE) {

	        vp-&gt;v_lflag &amp;= ~VL_NEEDINACTIVE;
	        vnode_unlock(vp);

		VNOP_INACTIVE(vp, ctx);

		vnode_lock_spin(vp);
		<span class="enscript-comment">/*
		 * because we had to drop the vnode lock before calling
		 * VNOP_INACTIVE, the state of this vnode may have changed...
		 * we may pick up both VL_MARTERM and either
		 * an iocount or a usecount while in the VNOP_INACTIVE call
		 * we don't want to call vnode_reclaim_internal on a vnode
		 * that has active references on it... so loop back around
		 * and reevaluate the state
		 */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
	}
        vp-&gt;v_lflag &amp;= ~VL_NEEDINACTIVE;

	<span class="enscript-keyword">if</span> ((vp-&gt;v_lflag &amp; (VL_MARKTERM | VL_TERMINATE | VL_DEAD)) == VL_MARKTERM) {
	        vnode_lock_convert(vp);
	        vnode_reclaim_internal(vp, 1, 1, 0);
	}
	vnode_dropiocount(vp);
	vnode_list_add(vp);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/* is vnode_t in use by others?  */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isinuse</span>(vnode_t vp, <span class="enscript-type">int</span> refcnt)
{
	<span class="enscript-keyword">return</span>(vnode_isinuse_locked(vp, refcnt, 0));
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isinuse_locked</span>(vnode_t vp, <span class="enscript-type">int</span> refcnt, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-type">int</span> retval = 0;

	<span class="enscript-keyword">if</span> (!locked)
		vnode_lock_spin(vp);
	<span class="enscript-keyword">if</span> ((vp-&gt;v_type != VREG) &amp;&amp; ((vp-&gt;v_usecount - vp-&gt;v_kusecount) &gt;  refcnt)) {
		retval = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VREG)  {
		retval = ubc_isinuse_locked(vp, refcnt, 1);
	}
		
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (!locked)
		vnode_unlock(vp);
	<span class="enscript-keyword">return</span>(retval);
}


<span class="enscript-comment">/* resume vnode_t */</span>
errno_t 
<span class="enscript-function-name">vnode_resume</span>(vnode_t vp)
{
	<span class="enscript-keyword">if</span> ((vp-&gt;v_lflag &amp; VL_SUSPENDED) &amp;&amp; vp-&gt;v_owner == current_thread()) {

		vnode_lock_spin(vp);
	        vp-&gt;v_lflag &amp;= ~VL_SUSPENDED;
		vp-&gt;v_owner = NULL;
		vnode_unlock(vp);

		wakeup(&amp;vp-&gt;v_iocount);
	}
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/* suspend vnode_t
 * Please do not use on more than one vnode at a time as it may
 * cause deadlocks.
 * xxx should we explicity prevent this from happening?
 */</span>

errno_t
<span class="enscript-function-name">vnode_suspend</span>(vnode_t vp)
{
	<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VL_SUSPENDED) {
		<span class="enscript-keyword">return</span>(EBUSY);
	}

	vnode_lock_spin(vp);

	<span class="enscript-comment">/* 
	 * xxx is this sufficient to check if a vnode_drain is 
	 * progress?
	 */</span>

	<span class="enscript-keyword">if</span> (vp-&gt;v_owner == NULL) {
		vp-&gt;v_lflag |= VL_SUSPENDED;
		vp-&gt;v_owner = current_thread();
	}
	vnode_unlock(vp);

	<span class="enscript-keyword">return</span>(0);
}
					
<span class="enscript-comment">/*
 * Release any blocked locking requests on the vnode.
 * Used for forced-unmounts.
 *
 * XXX	What about network filesystems?
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_abort_advlocks</span>(vnode_t vp)
{
	<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VLOCKLOCAL)
		lf_abort_advlocks(vp);
}
					

<span class="enscript-type">static</span> errno_t 
<span class="enscript-function-name">vnode_drain</span>(vnode_t vp)
{
	
	<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VL_DRAIN) {
		panic(<span class="enscript-string">&quot;vnode_drain: recursive drain&quot;</span>);
		<span class="enscript-keyword">return</span>(ENOENT);
	}
	vp-&gt;v_lflag |= VL_DRAIN;
	vp-&gt;v_owner = current_thread();

	<span class="enscript-keyword">while</span> (vp-&gt;v_iocount &gt; 1)
		msleep(&amp;vp-&gt;v_iocount, &amp;vp-&gt;v_lock, PVFS, <span class="enscript-string">&quot;vnode_drain&quot;</span>, NULL);

	vp-&gt;v_lflag &amp;= ~VL_DRAIN;

	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * if the number of recent references via vnode_getwithvid or vnode_getwithref
 * exceeds this threshold, than 'UN-AGE' the vnode by removing it from
 * the LRU list if it's currently on it... once the iocount and usecount both drop
 * to 0, it will get put back on the end of the list, effectively making it younger
 * this allows us to keep actively referenced vnodes in the list without having
 * to constantly remove and add to the list each time a vnode w/o a usecount is
 * referenced which costs us taking and dropping a global lock twice.
 * However, if the vnode is marked DIRTY, we want to pull it out much earlier
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UNAGE_THRESHHOLD</span>        25
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UNAGE_DIRTYTHRESHHOLD</span>    6    

errno_t
<span class="enscript-function-name">vnode_getiocount</span>(vnode_t vp, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vid, <span class="enscript-type">int</span> vflags)
{
	<span class="enscript-type">int</span> nodead = vflags &amp; VNODE_NODEAD;
	<span class="enscript-type">int</span> nosusp = vflags &amp; VNODE_NOSUSPEND;
	<span class="enscript-type">int</span> always = vflags &amp; VNODE_ALWAYS;
	<span class="enscript-type">int</span> beatdrain = vflags &amp; VNODE_DRAINO;
	<span class="enscript-type">int</span> withvid = vflags &amp; VNODE_WITHID;

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-type">int</span> sleepflg = 0;

		<span class="enscript-comment">/*
		 * if it is a dead vnode with deadfs
		 */</span>
	        <span class="enscript-keyword">if</span> (nodead &amp;&amp; (vp-&gt;v_lflag &amp; VL_DEAD) &amp;&amp; ((vp-&gt;v_type == VBAD) || (vp-&gt;v_data == 0))) {
			<span class="enscript-keyword">return</span>(ENOENT);
		}
		<span class="enscript-comment">/*
		 * will return VL_DEAD ones
		 */</span>
		<span class="enscript-keyword">if</span> ((vp-&gt;v_lflag &amp; (VL_SUSPENDED | VL_DRAIN | VL_TERMINATE)) == 0 ) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * if suspended vnodes are to be failed
		 */</span>
		<span class="enscript-keyword">if</span> (nosusp &amp;&amp; (vp-&gt;v_lflag &amp; VL_SUSPENDED)) {
			<span class="enscript-keyword">return</span>(ENOENT);
		}
		<span class="enscript-comment">/*
		 * if you are the owner of drain/suspend/termination , can acquire iocount
		 * check for VL_TERMINATE; it does not set owner
		 */</span>
		<span class="enscript-keyword">if</span> ((vp-&gt;v_lflag &amp; (VL_DRAIN | VL_SUSPENDED | VL_TERMINATE)) &amp;&amp;
		    (vp-&gt;v_owner == current_thread())) {
		        <span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">if</span> (always != 0) 
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * If this vnode is getting drained, there are some cases where
		 * we can't block or, in case of tty vnodes, want to be
		 * interruptible.
		 */</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VL_DRAIN) {
			<span class="enscript-comment">/*
			 * In some situations, we want to get an iocount
			 * even if the vnode is draining to prevent deadlock,
			 * e.g. if we're in the filesystem, potentially holding
			 * resources that could prevent other iocounts from
			 * being released.
			 */</span>
			<span class="enscript-keyword">if</span> (beatdrain)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-comment">/*
			 * Don't block if the vnode's mount point is unmounting as
			 * we may be the thread the unmount is itself waiting on
			 * Only callers who pass in vids (at this point, we've already
			 * handled nosusp and nodead) are expecting error returns
			 * from this function, so only we can only return errors for
			 * those. ENODEV is intended to inform callers that the call
			 * failed because an unmount is in progress.
			 */</span>
			<span class="enscript-keyword">if</span> (withvid &amp;&amp; (vp-&gt;v_mount) &amp;&amp; vfs_isunmount(vp-&gt;v_mount))
				<span class="enscript-keyword">return</span> (ENODEV);

			<span class="enscript-keyword">if</span> (vnode_istty(vp)) {
				sleepflg = PCATCH;
			}
		}

		vnode_lock_convert(vp);

		<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VL_TERMINATE) {
			<span class="enscript-type">int</span> error;

			vp-&gt;v_lflag |= VL_TERMWANT;

			error = msleep(&amp;vp-&gt;v_lflag,   &amp;vp-&gt;v_lock,
			   (PVFS | sleepflg), <span class="enscript-string">&quot;vnode getiocount&quot;</span>, NULL);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
		} <span class="enscript-keyword">else</span>
			msleep(&amp;vp-&gt;v_iocount, &amp;vp-&gt;v_lock, PVFS, <span class="enscript-string">&quot;vnode_getiocount&quot;</span>, NULL);
	}
	<span class="enscript-keyword">if</span> (withvid &amp;&amp; vid != vp-&gt;v_id) {
		<span class="enscript-keyword">return</span>(ENOENT);
	}
	<span class="enscript-keyword">if</span> (++vp-&gt;v_references &gt;= UNAGE_THRESHHOLD ||
	    (vp-&gt;v_flag &amp; VISDIRTY &amp;&amp; vp-&gt;v_references &gt;= UNAGE_DIRTYTHRESHHOLD)) {
	        vp-&gt;v_references = 0;
		vnode_list_remove(vp);
	}
	vp-&gt;v_iocount++;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	record_vp(vp, 1);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span>(0);	
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_dropiocount</span> (vnode_t vp)
{
	<span class="enscript-keyword">if</span> (vp-&gt;v_iocount &lt; 1)
		panic(<span class="enscript-string">&quot;vnode_dropiocount(%p): v_iocount &lt; 1&quot;</span>, vp);

	vp-&gt;v_iocount--;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	record_vp(vp, -1);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_lflag &amp; (VL_DRAIN | VL_SUSPENDED)) &amp;&amp; (vp-&gt;v_iocount &lt;= 1))
		wakeup(&amp;vp-&gt;v_iocount);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_reclaim</span>(<span class="enscript-type">struct</span> vnode * vp)
{
	vnode_reclaim_internal(vp, 0, 0, 0);
}

__private_extern__
<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_reclaim_internal</span>(<span class="enscript-type">struct</span> vnode * vp, <span class="enscript-type">int</span> locked, <span class="enscript-type">int</span> reuse, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">int</span> isfifo = 0;

	<span class="enscript-keyword">if</span> (!locked)
		vnode_lock(vp);

	<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VL_TERMINATE) {
		panic(<span class="enscript-string">&quot;vnode reclaim in progress&quot;</span>);
	}
	vp-&gt;v_lflag |= VL_TERMINATE;

	vn_clearunionwait(vp, 1);

	vnode_drain(vp);

	isfifo = (vp-&gt;v_type == VFIFO);

	<span class="enscript-keyword">if</span> (vp-&gt;v_type != VBAD)
		vgone(vp, flags);		<span class="enscript-comment">/* clean and reclaim the vnode */</span>

	<span class="enscript-comment">/*
	 * give the vnode a new identity so that vnode_getwithvid will fail
	 * on any stale cache accesses...
	 * grab the list_lock so that if we're in &quot;new_vnode&quot;
	 * behind the list_lock trying to steal this vnode, the v_id is stable...
	 * once new_vnode drops the list_lock, it will block trying to take
	 * the vnode lock until we release it... at that point it will evaluate
	 * whether the v_vid has changed
	 * also need to make sure that the vnode isn't on a list where &quot;new_vnode&quot;
	 * can find it after the v_id has been bumped until we are completely done
	 * with the vnode (i.e. putting it back on a list has to be the very last
	 * thing we do to this vnode... many of the callers of vnode_reclaim_internal
	 * are holding an io_count on the vnode... they need to drop the io_count
	 * BEFORE doing a vnode_list_add or make sure to hold the vnode lock until
	 * they are completely done with the vnode
	 */</span>
	vnode_list_lock();

	vnode_list_remove_locked(vp);
	vp-&gt;v_id++;

	vnode_list_unlock();

	<span class="enscript-keyword">if</span> (isfifo) {
		<span class="enscript-type">struct</span> fifoinfo * fip;

		fip = vp-&gt;v_fifoinfo;
		vp-&gt;v_fifoinfo = NULL;
		FREE(fip, M_TEMP);
	}
	vp-&gt;v_type = VBAD;

	<span class="enscript-keyword">if</span> (vp-&gt;v_data)
		panic(<span class="enscript-string">&quot;vnode_reclaim_internal: cleaned vnode isn't&quot;</span>);
	<span class="enscript-keyword">if</span> (vp-&gt;v_numoutput)
		panic(<span class="enscript-string">&quot;vnode_reclaim_internal: clean vnode has pending I/O's&quot;</span>);
	<span class="enscript-keyword">if</span> (UBCINFOEXISTS(vp))
		panic(<span class="enscript-string">&quot;vnode_reclaim_internal: ubcinfo not cleaned&quot;</span>);
	<span class="enscript-keyword">if</span> (vp-&gt;v_parent)
	        panic(<span class="enscript-string">&quot;vnode_reclaim_internal: vparent not removed&quot;</span>);
	<span class="enscript-keyword">if</span> (vp-&gt;v_name)
	        panic(<span class="enscript-string">&quot;vnode_reclaim_internal: vname not removed&quot;</span>);

	vp-&gt;v_socket = NULL;

	vp-&gt;v_lflag &amp;= ~VL_TERMINATE;
	vp-&gt;v_owner = NULL;

	KNOTE(&amp;vp-&gt;v_knotes, NOTE_REVOKE);

	<span class="enscript-comment">/* Make sure that when we reuse the vnode, no knotes left over */</span>
	klist_init(&amp;vp-&gt;v_knotes);

	<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VL_TERMWANT) {
		vp-&gt;v_lflag &amp;= ~VL_TERMWANT;
		wakeup(&amp;vp-&gt;v_lflag);
	}
	<span class="enscript-keyword">if</span> (!reuse) {
	        <span class="enscript-comment">/*
		 * make sure we get on the
		 * dead list if appropriate
		 */</span>
	        vnode_list_add(vp);
	}
	<span class="enscript-keyword">if</span> (!locked)
	        vnode_unlock(vp);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_create_internal</span>(uint32_t flavor, uint32_t size, <span class="enscript-type">void</span> *data, vnode_t *vpp,
    <span class="enscript-type">int</span> init_vnode)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> insert = 1;
	<span class="enscript-type">int</span> existing_vnode;
	vnode_t vp;
	vnode_t nvp;
	vnode_t dvp;
        <span class="enscript-type">struct</span>  uthread *ut;
	<span class="enscript-type">struct</span> componentname *cnp;
	<span class="enscript-type">struct</span> vnode_fsparam *param = (<span class="enscript-type">struct</span> vnode_fsparam *)data;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	<span class="enscript-type">struct</span> vnode_trigger_param *tinfo = NULL;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (*vpp) {
		vp = *vpp;
		*vpp = NULLVP;
		existing_vnode = 1;
	} <span class="enscript-keyword">else</span> {
		existing_vnode = 0;
	}

	<span class="enscript-keyword">if</span> (init_vnode) {
		<span class="enscript-comment">/* Do quick sanity check on the parameters. */</span>
		<span class="enscript-keyword">if</span> ((param == NULL) || (param-&gt;vnfs_vtype == VBAD)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_out</span>;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
		<span class="enscript-keyword">if</span> ((flavor == VNCREATE_TRIGGER) &amp;&amp; (size == VNCREATE_TRIGGER_SIZE)) {
			tinfo = (<span class="enscript-type">struct</span> vnode_trigger_param *)data;

			<span class="enscript-comment">/* Validate trigger vnode input */</span>
			<span class="enscript-keyword">if</span> ((param-&gt;vnfs_vtype != VDIR) ||
			    (tinfo-&gt;vnt_resolve_func == NULL) ||
			    (tinfo-&gt;vnt_flags &amp; ~VNT_VALID_MASK)) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_out</span>;
			}
			<span class="enscript-comment">/* Fall through a normal create (params will be the same) */</span>
			flavor = VNCREATE_FLAVOR;
			size = VCREATESIZE;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> ((flavor != VNCREATE_FLAVOR) || (size != VCREATESIZE)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_out</span>;
		}
	}

	<span class="enscript-keyword">if</span> (!existing_vnode) {
		<span class="enscript-keyword">if</span> ((error = new_vnode(&amp;vp)) ) {
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> (!init_vnode) {
			<span class="enscript-comment">/* Make it so that it can be released by a vnode_put) */</span>
			vn_set_dead(vp);
			*vpp = vp;
			<span class="enscript-keyword">return</span> (0);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * A vnode obtained by vnode_create_empty has been passed to
		 * vnode_initialize - Unset VL_DEAD set by vn_set_dead. After
		 * this point, it is set back on any error.
		 *
		 * N.B. vnode locking - We make the same assumptions as the
		 * &quot;unsplit&quot; vnode_create did - i.e. it is safe to update the
		 * vnode's fields without the vnode lock. This vnode has been
		 * out and about with the filesystem and hopefully nothing
		 * was done to the vnode between the vnode_create_empty and
		 * now when it has come in through vnode_initialize.
		 */</span>
		vp-&gt;v_lflag &amp;= ~VL_DEAD;
	}

	dvp = param-&gt;vnfs_dvp;
	cnp = param-&gt;vnfs_cnp;

	vp-&gt;v_op = param-&gt;vnfs_vops;
	vp-&gt;v_type = param-&gt;vnfs_vtype;
	vp-&gt;v_data = param-&gt;vnfs_fsnode;

	<span class="enscript-keyword">if</span> (param-&gt;vnfs_markroot)
		vp-&gt;v_flag |= VROOT;
	<span class="enscript-keyword">if</span> (param-&gt;vnfs_marksystem)
		vp-&gt;v_flag |= VSYSTEM;
	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VREG) {
		error = ubc_info_init_withsize(vp, param-&gt;vnfs_filesize);
		<span class="enscript-keyword">if</span> (error) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
			record_vp(vp, 1);
#<span class="enscript-reference">endif</span>
			vn_set_dead(vp);

			vnode_put(vp);
			<span class="enscript-keyword">return</span>(error);
		}
		<span class="enscript-keyword">if</span> (param-&gt;vnfs_mp-&gt;mnt_ioflags &amp; MNT_IOFLAGS_IOSCHED_SUPPORTED)
			memory_object_mark_io_tracking(vp-&gt;v_ubcinfo-&gt;ui_control);
	}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	record_vp(vp, 1);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	<span class="enscript-comment">/*
	 * For trigger vnodes, attach trigger info to vnode
	 */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_type == VDIR) &amp;&amp; (tinfo != NULL)) {
		<span class="enscript-comment">/* 
		 * Note: has a side effect of incrementing trigger count on the
		 * mount if successful, which we would need to undo on a 
		 * subsequent failure.
		 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
		record_vp(vp, -1);
#<span class="enscript-reference">endif</span>
		error = vnode_resolver_create(param-&gt;vnfs_mp, vp, tinfo, FALSE);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;vnode_create: vnode_resolver_create() err %d\n&quot;</span>, error);
			vn_set_dead(vp);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
			record_vp(vp, 1);
#<span class="enscript-reference">endif</span>
			vnode_put(vp);
			<span class="enscript-keyword">return</span> (error);
		}
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VCHR || vp-&gt;v_type == VBLK) {

		vp-&gt;v_tag = VT_DEVFS;		<span class="enscript-comment">/* callers will reset if needed (bdevvp) */</span>

		<span class="enscript-keyword">if</span> ( (nvp = checkalias(vp, param-&gt;vnfs_rdev)) ) {
			<span class="enscript-comment">/*
			 * if checkalias returns a vnode, it will be locked
			 *
			 * first get rid of the unneeded vnode we acquired
			 */</span>
			vp-&gt;v_data = NULL;
			vp-&gt;v_op = spec_vnodeop_p;
			vp-&gt;v_type = VBAD;
			vp-&gt;v_lflag = VL_DEAD;
			vp-&gt;v_data = NULL; 
			vp-&gt;v_tag = VT_NON;
			vnode_put(vp);

			<span class="enscript-comment">/*
			 * switch to aliased vnode and finish
			 * preparing it
			 */</span>
			vp = nvp;

			vclean(vp, 0);
			vp-&gt;v_op = param-&gt;vnfs_vops;
			vp-&gt;v_type = param-&gt;vnfs_vtype;
			vp-&gt;v_data = param-&gt;vnfs_fsnode;
			vp-&gt;v_lflag = 0;
			vp-&gt;v_mount = NULL;
			insmntque(vp, param-&gt;vnfs_mp);
			insert = 0;
			vnode_unlock(vp);
		}

		<span class="enscript-keyword">if</span> (VCHR == vp-&gt;v_type) {
			u_int maj = major(vp-&gt;v_rdev);

			<span class="enscript-keyword">if</span> (maj &lt; (u_int)nchrdev &amp;&amp; cdevsw[maj].d_type == D_TTY)
				vp-&gt;v_flag |= VISTTY;
		}
	}

	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VFIFO) {
		<span class="enscript-type">struct</span> fifoinfo *fip;

		MALLOC(fip, <span class="enscript-type">struct</span> fifoinfo *,
			<span class="enscript-keyword">sizeof</span>(*fip), M_TEMP, M_WAITOK);
		bzero(fip, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> fifoinfo ));
		vp-&gt;v_fifoinfo = fip;
	}
	<span class="enscript-comment">/* The file systems must pass the address of the location where
	 * they store the vnode pointer. When we add the vnode into the mount
	 * list and name cache they become discoverable. So the file system node
	 * must have the connection to vnode setup by then
	 */</span>
	*vpp = vp;

	<span class="enscript-comment">/* Add fs named reference. */</span>
	<span class="enscript-keyword">if</span> (param-&gt;vnfs_flags &amp; VNFS_ADDFSREF) {
		vp-&gt;v_lflag |= VNAMED_FSHASH;
	}
	<span class="enscript-keyword">if</span> (param-&gt;vnfs_mp) {
			<span class="enscript-keyword">if</span> (param-&gt;vnfs_mp-&gt;mnt_kern_flag &amp; MNTK_LOCK_LOCAL)
				vp-&gt;v_flag |= VLOCKLOCAL;
		<span class="enscript-keyword">if</span> (insert) {
			<span class="enscript-keyword">if</span> ((vp-&gt;v_freelist.tqe_prev != (<span class="enscript-type">struct</span> vnode **)0xdeadb))
				panic(<span class="enscript-string">&quot;insmntque: vp on the free list\n&quot;</span>);

			<span class="enscript-comment">/*
			 * enter in mount vnode list
			 */</span>
			insmntque(vp, param-&gt;vnfs_mp);
		}
	}
	<span class="enscript-keyword">if</span> (dvp &amp;&amp; vnode_ref(dvp) == 0) {
		vp-&gt;v_parent = dvp;
	}
	<span class="enscript-keyword">if</span> (cnp) {
		<span class="enscript-keyword">if</span> (dvp &amp;&amp; ((param-&gt;vnfs_flags &amp; (VNFS_NOCACHE | VNFS_CANTCACHE)) == 0)) {
			<span class="enscript-comment">/*
			 * enter into name cache
			 * we've got the info to enter it into the name cache now
			 * cache_enter_create will pick up an extra reference on
			 * the name entered into the string cache
			 */</span>
			vp-&gt;v_name = cache_enter_create(dvp, vp, cnp);
		} <span class="enscript-keyword">else</span>
			vp-&gt;v_name = vfs_addname(cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, cnp-&gt;cn_hash, 0);

		<span class="enscript-keyword">if</span> ((cnp-&gt;cn_flags &amp; UNIONCREATED) == UNIONCREATED)
			vp-&gt;v_flag |= VISUNION;
	}
	<span class="enscript-keyword">if</span> ((param-&gt;vnfs_flags &amp; VNFS_CANTCACHE) == 0) {
		<span class="enscript-comment">/*
		 * this vnode is being created as cacheable in the name cache
		 * this allows us to re-enter it in the cache
		 */</span>
		vp-&gt;v_flag |= VNCACHEABLE;
	}
	ut = get_bsdthread_info(current_thread());

	<span class="enscript-keyword">if</span> ((current_proc()-&gt;p_lflag &amp; P_LRAGE_VNODES) ||
	    (ut-&gt;uu_flag &amp; UT_RAGE_VNODES)) {
		<span class="enscript-comment">/*
		 * process has indicated that it wants any
		 * vnodes created on its behalf to be rapidly
		 * aged to reduce the impact on the cached set
		 * of vnodes
		 */</span>
		vp-&gt;v_flag |= VRAGE;
	}
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">error_out</span>:
	<span class="enscript-keyword">if</span> (existing_vnode) {
		vnode_put(vp);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* USAGE:
 * The following api creates a vnode and associates all the parameter specified in vnode_fsparam
 * structure and returns a vnode handle with a reference. device aliasing is handled here so checkalias
 * is obsoleted by this.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_create</span>(uint32_t flavor, uint32_t size, <span class="enscript-type">void</span> *data, vnode_t *vpp)
{
	*vpp = NULLVP;
	<span class="enscript-keyword">return</span> (vnode_create_internal(flavor, size, data, vpp, 1));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_create_empty</span>(vnode_t *vpp)
{
	*vpp = NULLVP;
	<span class="enscript-keyword">return</span> (vnode_create_internal(VNCREATE_FLAVOR, VCREATESIZE, NULL,
	    vpp, 0));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_initialize</span>(uint32_t flavor, uint32_t size, <span class="enscript-type">void</span> *data, vnode_t *vpp)
{
	<span class="enscript-keyword">if</span> (*vpp == NULLVP) {
		panic(<span class="enscript-string">&quot;NULL vnode passed to vnode_initialize&quot;</span>);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-comment">/*
	 * We lock to check that vnode is fit for unlocked use in
	 * vnode_create_internal.
	 */</span>
	vnode_lock_spin(*vpp);
	VNASSERT(((*vpp)-&gt;v_iocount == 1), *vpp,
	    (<span class="enscript-string">&quot;vnode_initialize : iocount not 1, is %d&quot;</span>, (*vpp)-&gt;v_iocount));
	VNASSERT(((*vpp)-&gt;v_usecount == 0), *vpp,
	    (<span class="enscript-string">&quot;vnode_initialize : usecount not 0, is %d&quot;</span>, (*vpp)-&gt;v_usecount));
	VNASSERT(((*vpp)-&gt;v_lflag &amp; VL_DEAD), *vpp,
	    (<span class="enscript-string">&quot;vnode_initialize : v_lflag does not have VL_DEAD, is 0x%x&quot;</span>,
	    (*vpp)-&gt;v_lflag));
	VNASSERT(((*vpp)-&gt;v_data == NULL), *vpp,
	    (<span class="enscript-string">&quot;vnode_initialize : v_data not NULL&quot;</span>));
	vnode_unlock(*vpp);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (vnode_create_internal(flavor, size, data, vpp, 1));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_addfsref</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	<span class="enscript-keyword">if</span> (vp-&gt;v_lflag &amp; VNAMED_FSHASH)
		panic(<span class="enscript-string">&quot;add_fsref: vp already has named reference&quot;</span>);
	<span class="enscript-keyword">if</span> ((vp-&gt;v_freelist.tqe_prev != (<span class="enscript-type">struct</span> vnode **)0xdeadb))
	        panic(<span class="enscript-string">&quot;addfsref: vp on the free list\n&quot;</span>);
	vp-&gt;v_lflag |= VNAMED_FSHASH;
	vnode_unlock(vp);
	<span class="enscript-keyword">return</span>(0);

}
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_removefsref</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	<span class="enscript-keyword">if</span> ((vp-&gt;v_lflag &amp; VNAMED_FSHASH) == 0)
		panic(<span class="enscript-string">&quot;remove_fsref: no named reference&quot;</span>);
	vp-&gt;v_lflag &amp;= ~VNAMED_FSHASH;
	vnode_unlock(vp);
	<span class="enscript-keyword">return</span>(0);

}


<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_iterate</span>(<span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> (*callout)(mount_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *arg)
{
	mount_t	mp;
	<span class="enscript-type">int</span> ret = 0;
	fsid_t * fsid_list;
	<span class="enscript-type">int</span> count, actualcount,  i;
	<span class="enscript-type">void</span> * allocmem;
	<span class="enscript-type">int</span> indx_start, indx_stop, indx_incr;
	<span class="enscript-type">int</span> cb_dropref = (flags &amp; VFS_ITERATE_CB_DROPREF);

	count = mount_getvfscnt();
	count += 10;

	fsid_list = (fsid_t *)kalloc(count * <span class="enscript-keyword">sizeof</span>(fsid_t));
	allocmem = (<span class="enscript-type">void</span> *)fsid_list;

	actualcount = mount_fillfsids(fsid_list, count);

	<span class="enscript-comment">/*
	 * Establish the iteration direction
	 * VFS_ITERATE_TAIL_FIRST overrides default head first order (oldest first)
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; VFS_ITERATE_TAIL_FIRST) {
		indx_start = actualcount - 1;
		indx_stop = -1;
		indx_incr = -1;
	} <span class="enscript-keyword">else</span> <span class="enscript-comment">/* Head first by default */</span> {
		indx_start = 0;
		indx_stop = actualcount;
		indx_incr = 1;
	}

	<span class="enscript-keyword">for</span> (i=indx_start; i != indx_stop; i += indx_incr) {

		<span class="enscript-comment">/* obtain the mount point with iteration reference */</span>
		mp = mount_list_lookupby_fsid(&amp;fsid_list[i], 0, 1);

		<span class="enscript-keyword">if</span>(mp == (<span class="enscript-type">struct</span> mount *)0)
			<span class="enscript-keyword">continue</span>;
		mount_lock(mp);
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; (MNT_LDEAD | MNT_LUNMOUNT)) {
			mount_unlock(mp);
			mount_iterdrop(mp);
			<span class="enscript-keyword">continue</span>;
		
		}
		mount_unlock(mp);

		<span class="enscript-comment">/* iterate over all the vnodes */</span>
		ret = callout(mp, arg);

		<span class="enscript-comment">/*
		 * Drop the iterref here if the callback didn't do it.
		 * Note: If cb_dropref is set the mp may no longer exist.
		 */</span>
		<span class="enscript-keyword">if</span> (!cb_dropref)
			mount_iterdrop(mp);

		<span class="enscript-keyword">switch</span> (ret) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_RETURNED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_RETURNED_DONE</span>:
			<span class="enscript-keyword">if</span> (ret == VFS_RETURNED_DONE) {
				ret = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CLAIMED_DONE</span>:
			ret = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CLAIMED</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
		ret = 0;
	}

<span class="enscript-reference">out</span>:
	kfree(allocmem, (count * <span class="enscript-keyword">sizeof</span>(fsid_t)));
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/*
 * Update the vfsstatfs structure in the mountpoint.
 * MAC: Parameter eventtype added, indicating whether the event that
 * triggered this update came from user space, via a system call
 * (VFS_USER_EVENT) or an internal kernel call (VFS_KERNEL_EVENT).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_update_vfsstat</span>(mount_t mp, vfs_context_t ctx, __unused <span class="enscript-type">int</span> eventtype)
{
	<span class="enscript-type">struct</span> vfs_attr	va;
	<span class="enscript-type">int</span>		error;

	<span class="enscript-comment">/*
	 * Request the attributes we want to propagate into
	 * the per-mount vfsstat structure.
	 */</span>
	VFSATTR_INIT(&amp;va);
	VFSATTR_WANTED(&amp;va, f_iosize);
	VFSATTR_WANTED(&amp;va, f_blocks);
	VFSATTR_WANTED(&amp;va, f_bfree);
	VFSATTR_WANTED(&amp;va, f_bavail);
	VFSATTR_WANTED(&amp;va, f_bused);
	VFSATTR_WANTED(&amp;va, f_files);
	VFSATTR_WANTED(&amp;va, f_ffree);
	VFSATTR_WANTED(&amp;va, f_bsize);
	VFSATTR_WANTED(&amp;va, f_fssubtype);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (eventtype == VFS_USER_EVENT) {
		error = mac_mount_check_getattr(ctx, mp, &amp;va);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> ((error = vfs_getattr(mp, &amp;va, ctx)) != 0) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;STAT - filesystem returned error %d&quot;</span>, error);
		<span class="enscript-keyword">return</span>(error);
	}

	<span class="enscript-comment">/*
	 * Unpack into the per-mount structure.
	 *
	 * We only overwrite these fields, which are likely to change:
	 *	f_blocks
	 *	f_bfree
	 *	f_bavail
	 *	f_bused
	 *	f_files
	 *	f_ffree
	 *
	 * And these which are not, but which the FS has no other way
	 * of providing to us:
	 *	f_bsize
	 *	f_iosize
	 *	f_fssubtype
	 *
	 */</span>
	<span class="enscript-keyword">if</span> (VFSATTR_IS_SUPPORTED(&amp;va, f_bsize)) {
		<span class="enscript-comment">/* 4822056 - protect against malformed server mount */</span>
		mp-&gt;mnt_vfsstat.f_bsize = (va.f_bsize &gt; 0 ? va.f_bsize : 512);
	} <span class="enscript-keyword">else</span> {
		mp-&gt;mnt_vfsstat.f_bsize = mp-&gt;mnt_devblocksize;	<span class="enscript-comment">/* default from the device block size */</span>
	}
	<span class="enscript-keyword">if</span> (VFSATTR_IS_SUPPORTED(&amp;va, f_iosize)) {
		mp-&gt;mnt_vfsstat.f_iosize = va.f_iosize;
	} <span class="enscript-keyword">else</span> {
		mp-&gt;mnt_vfsstat.f_iosize = 1024 * 1024;		<span class="enscript-comment">/* 1MB sensible I/O size */</span>
	}
	<span class="enscript-keyword">if</span> (VFSATTR_IS_SUPPORTED(&amp;va, f_blocks))
		mp-&gt;mnt_vfsstat.f_blocks = va.f_blocks;
	<span class="enscript-keyword">if</span> (VFSATTR_IS_SUPPORTED(&amp;va, f_bfree))
		mp-&gt;mnt_vfsstat.f_bfree = va.f_bfree;
	<span class="enscript-keyword">if</span> (VFSATTR_IS_SUPPORTED(&amp;va, f_bavail))
		mp-&gt;mnt_vfsstat.f_bavail = va.f_bavail;
	<span class="enscript-keyword">if</span> (VFSATTR_IS_SUPPORTED(&amp;va, f_bused))
		mp-&gt;mnt_vfsstat.f_bused = va.f_bused;
	<span class="enscript-keyword">if</span> (VFSATTR_IS_SUPPORTED(&amp;va, f_files))
		mp-&gt;mnt_vfsstat.f_files = va.f_files;
	<span class="enscript-keyword">if</span> (VFSATTR_IS_SUPPORTED(&amp;va, f_ffree))
		mp-&gt;mnt_vfsstat.f_ffree = va.f_ffree;

	<span class="enscript-comment">/* this is unlikely to change, but has to be queried for */</span>
	<span class="enscript-keyword">if</span> (VFSATTR_IS_SUPPORTED(&amp;va, f_fssubtype))
		mp-&gt;mnt_vfsstat.f_fssubtype = va.f_fssubtype;

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mount_list_add</span>(mount_t mp)
{
	<span class="enscript-type">int</span> res;

	mount_list_lock();
	<span class="enscript-keyword">if</span> (system_inshutdown != 0) {
		res = -1;
	} <span class="enscript-keyword">else</span> {
		TAILQ_INSERT_TAIL(&amp;mountlist, mp, mnt_list);	
		nummounts++;
		res = 0;
	}
	mount_list_unlock();

	<span class="enscript-keyword">return</span> res;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_list_remove</span>(mount_t mp)
{
	mount_list_lock();
	TAILQ_REMOVE(&amp;mountlist, mp, mnt_list);
	nummounts--;
	mp-&gt;mnt_list.tqe_next = NULL;
	mp-&gt;mnt_list.tqe_prev = NULL;
	mount_list_unlock();
}

mount_t
<span class="enscript-function-name">mount_lookupby_volfsid</span>(<span class="enscript-type">int</span> volfs_id, <span class="enscript-type">int</span> withref)
{
	mount_t cur_mount = (mount_t)0;
	mount_t mp;

	mount_list_lock();
	TAILQ_FOREACH(mp, &amp;mountlist, mnt_list) {
		<span class="enscript-keyword">if</span> (!(mp-&gt;mnt_kern_flag &amp; MNTK_UNMOUNT) &amp;&amp;
		    (mp-&gt;mnt_kern_flag &amp; MNTK_PATH_FROM_ID) &amp;&amp;
		    (mp-&gt;mnt_vfsstat.f_fsid.val[0] == volfs_id)) {
			cur_mount = mp;
			<span class="enscript-keyword">if</span> (withref) {
				<span class="enscript-keyword">if</span> (mount_iterref(cur_mount, 1))  {
					cur_mount = (mount_t)0;
					mount_list_unlock();
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}
			<span class="enscript-keyword">break</span>;
		}
	}
	mount_list_unlock();
	<span class="enscript-keyword">if</span> (withref &amp;&amp; (cur_mount != (mount_t)0)) {
		mp = cur_mount;
		<span class="enscript-keyword">if</span> (vfs_busy(mp, LK_NOWAIT) != 0) {
			cur_mount = (mount_t)0;
		}
		mount_iterdrop(mp);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span>(cur_mount);
}

mount_t 
<span class="enscript-function-name">mount_list_lookupby_fsid</span>(fsid_t *fsid, <span class="enscript-type">int</span> locked, <span class="enscript-type">int</span> withref)
{
	mount_t retmp = (mount_t)0;
	mount_t mp;

	<span class="enscript-keyword">if</span> (!locked)
		mount_list_lock();
	TAILQ_FOREACH(mp, &amp;mountlist, mnt_list) 
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_vfsstat.f_fsid.val[0] == fsid-&gt;val[0] &amp;&amp;
		    mp-&gt;mnt_vfsstat.f_fsid.val[1] == fsid-&gt;val[1]) {
			retmp = mp;
			<span class="enscript-keyword">if</span> (withref) {
				<span class="enscript-keyword">if</span> (mount_iterref(retmp, 1)) 
					retmp = (mount_t)0;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (!locked)
		mount_list_unlock();
	<span class="enscript-keyword">return</span> (retmp);
}

errno_t
<span class="enscript-function-name">vnode_lookup</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> flags, vnode_t *vpp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">int</span> error;
	u_int32_t ndflags = 0;

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (flags &amp; VNODE_LOOKUP_NOFOLLOW)
		ndflags = NOFOLLOW;
	<span class="enscript-keyword">else</span>
		ndflags = FOLLOW;

	<span class="enscript-keyword">if</span> (flags &amp; VNODE_LOOKUP_NOCROSSMOUNT)
		ndflags |= NOCROSSMOUNT;

	<span class="enscript-keyword">if</span> (flags &amp; VNODE_LOOKUP_CROSSMOUNTNOWAIT)
		ndflags |= CN_NBMOUNTLOOK;

	<span class="enscript-comment">/* XXX AUDITVNPATH1 needed ? */</span>
	NDINIT(&amp;nd, LOOKUP, OP_LOOKUP, ndflags, UIO_SYSSPACE,
	       CAST_USER_ADDR_T(path), ctx);

	<span class="enscript-keyword">if</span> ((error = namei(&amp;nd)))
		<span class="enscript-keyword">return</span> (error);
	*vpp = nd.ni_vp;
	nameidone(&amp;nd);
	
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">vnode_open</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> fmode, <span class="enscript-type">int</span> cmode, <span class="enscript-type">int</span> flags, vnode_t *vpp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">int</span> error;
	u_int32_t ndflags = 0;
	<span class="enscript-type">int</span> lflags = flags;

	<span class="enscript-keyword">if</span> (ctx == NULL) {		<span class="enscript-comment">/* XXX technically an error */</span>
		ctx = vfs_context_current();
	}

	<span class="enscript-keyword">if</span> (fmode &amp; O_NOFOLLOW)
		lflags |= VNODE_LOOKUP_NOFOLLOW;

	<span class="enscript-keyword">if</span> (lflags &amp; VNODE_LOOKUP_NOFOLLOW)
		ndflags = NOFOLLOW;
	<span class="enscript-keyword">else</span>
		ndflags = FOLLOW;

	<span class="enscript-keyword">if</span> (lflags &amp; VNODE_LOOKUP_NOCROSSMOUNT)
		ndflags |= NOCROSSMOUNT;
	
	<span class="enscript-keyword">if</span> (lflags &amp; VNODE_LOOKUP_CROSSMOUNTNOWAIT)
		ndflags |= CN_NBMOUNTLOOK;

	<span class="enscript-comment">/* XXX AUDITVNPATH1 needed ? */</span>
	NDINIT(&amp;nd, LOOKUP, OP_OPEN, ndflags, UIO_SYSSPACE,
	       CAST_USER_ADDR_T(path), ctx);

	<span class="enscript-keyword">if</span> ((error = vn_open(&amp;nd, fmode, cmode)))
		*vpp = NULL;
	<span class="enscript-keyword">else</span>
		*vpp = nd.ni_vp;
	
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">vnode_close</span>(vnode_t vp, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}
	
	error = vn_close(vp, flags, ctx);
	vnode_put(vp);
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">vnode_mtime</span>(vnode_t vp, <span class="enscript-type">struct</span> timespec *mtime, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnode_attr	va;
	<span class="enscript-type">int</span>			error;

	VATTR_INIT(&amp;va);
	VATTR_WANTED(&amp;va, va_modify_time);
	error = vnode_getattr(vp, &amp;va, ctx);
	<span class="enscript-keyword">if</span> (!error)
		*mtime = va.va_modify_time;
	<span class="enscript-keyword">return</span> error;
}

errno_t
<span class="enscript-function-name">vnode_flags</span>(vnode_t vp, uint32_t *flags, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnode_attr	va;
	<span class="enscript-type">int</span>			error;

	VATTR_INIT(&amp;va);
	VATTR_WANTED(&amp;va, va_flags);
	error = vnode_getattr(vp, &amp;va, ctx);
	<span class="enscript-keyword">if</span> (!error)
		*flags = va.va_flags;
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *	vnode_getattr:???
 */</span>
errno_t
<span class="enscript-function-name">vnode_size</span>(vnode_t vp, off_t *sizep, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnode_attr	va;
	<span class="enscript-type">int</span>			error;

	VATTR_INIT(&amp;va);
	VATTR_WANTED(&amp;va, va_data_size);
	error = vnode_getattr(vp, &amp;va, ctx);
	<span class="enscript-keyword">if</span> (!error)
		*sizep = va.va_data_size;
	<span class="enscript-keyword">return</span>(error);
}

errno_t
<span class="enscript-function-name">vnode_setsize</span>(vnode_t vp, off_t size, <span class="enscript-type">int</span> ioflag, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnode_attr	va;

	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_data_size, size);
	va.va_vaflags = ioflag &amp; 0xffff;
	<span class="enscript-keyword">return</span>(vnode_setattr(vp, &amp;va, ctx));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_setdirty</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag |= VISDIRTY;
	vnode_unlock(vp);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_cleardirty</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag &amp;= ~VISDIRTY;
	vnode_unlock(vp);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isdirty</span>(vnode_t vp)
{
	<span class="enscript-type">int</span> dirty;

	vnode_lock_spin(vp);
	dirty = (vp-&gt;v_flag &amp; VISDIRTY) ? 1 : 0;
	vnode_unlock(vp);

	<span class="enscript-keyword">return</span> dirty;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vn_create_reg</span>(vnode_t dvp, vnode_t *vpp, <span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">struct</span> vnode_attr *vap, uint32_t flags, <span class="enscript-type">int</span> fmode, uint32_t *statusp, vfs_context_t ctx)
{
	<span class="enscript-comment">/* Only use compound VNOP for compound operation */</span>
	<span class="enscript-keyword">if</span> (vnode_compound_open_available(dvp) &amp;&amp; ((flags &amp; VN_CREATE_DOOPEN) != 0)) {
		*vpp = NULLVP;
		<span class="enscript-keyword">return</span> VNOP_COMPOUND_OPEN(dvp, vpp, ndp, O_CREAT, fmode, statusp, vap, ctx);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> VNOP_CREATE(dvp, vpp, &amp;ndp-&gt;ni_cnd, vap, ctx);
	}
}

<span class="enscript-comment">/*
 * Create a filesystem object of arbitrary type with arbitrary attributes in
 * the spevied directory with the specified name.
 *
 * Parameters:	dvp			Pointer to the vnode of the directory
 *					in which to create the object.
 *		vpp			Pointer to the area into which to
 *					return the vnode of the created object.
 *		cnp			Component name pointer from the namei
 *					data structure, containing the name to
 *					use for the create object.
 *		vap			Pointer to the vnode_attr structure
 *					describing the object to be created,
 *					including the type of object.
 *		flags			VN_* flags controlling ACL inheritance
 *					and whether or not authorization is to
 *					be required for the operation.
 *		
 * Returns:	0			Success
 *		!0			errno value
 *
 * Implicit:	*vpp			Contains the vnode of the object that
 *					was created, if successful.
 *		*cnp			May be modified by the underlying VFS.
 *		*vap			May be modified by the underlying VFS.
 *					modified by either ACL inheritance or
 *		
 *		
 *					be modified, even if the operation is
 *					
 *
 * Notes:	The kauth_filesec_t in 'vap', if any, is in host byte order.
 *
 *		Modification of '*cnp' and '*vap' by the underlying VFS is
 *		strongly discouraged.
 *
 * XXX:		This function is a 'vn_*' function; it belongs in vfs_vnops.c
 *
 * XXX:		We should enummerate the possible errno values here, and where
 *		in the code they originated.
 */</span>
errno_t
<span class="enscript-function-name">vn_create</span>(vnode_t dvp, vnode_t *vpp, <span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">struct</span> vnode_attr *vap, uint32_t flags, <span class="enscript-type">int</span> fmode, uint32_t *statusp, vfs_context_t ctx)
{
	errno_t	error, old_error;
	vnode_t vp = (vnode_t)0;
	boolean_t batched;
	<span class="enscript-type">struct</span> componentname *cnp;
	uint32_t defaulted;
	uint32_t dfflags;	<span class="enscript-comment">// Directory file flags
</span>
	cnp = &amp;ndp-&gt;ni_cnd;
	error = 0;
	batched = namei_compound_available(dvp, ndp) ? TRUE : FALSE;

	KAUTH_DEBUG(<span class="enscript-string">&quot;%p    CREATE - '%s'&quot;</span>, dvp, cnp-&gt;cn_nameptr);

	<span class="enscript-keyword">if</span> (flags &amp; VN_CREATE_NOINHERIT) 
		vap-&gt;va_vaflags |= VA_NOINHERIT;
	<span class="enscript-keyword">if</span> (flags &amp; VN_CREATE_NOAUTH) 
		vap-&gt;va_vaflags |= VA_NOAUTH;
	<span class="enscript-comment">/*
	 * Handle ACL inheritance, initialize vap.
	 */</span>
	error = vn_attribute_prepare(dvp, vap, &amp;defaulted, ctx);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">if</span> (vap-&gt;va_type != VREG &amp;&amp; (fmode != 0 || (flags &amp; VN_CREATE_DOOPEN) || statusp)) {
		panic(<span class="enscript-string">&quot;Open parameters, but not a regular file.&quot;</span>);
	}
	<span class="enscript-keyword">if</span> ((fmode != 0) &amp;&amp; ((flags &amp; VN_CREATE_DOOPEN) == 0)) {
		panic(<span class="enscript-string">&quot;Mode for open, but not trying to open...&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * Handle inheritance of restricted flag
	 */</span>
	error = vnode_flags(dvp, &amp;dfflags, ctx);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
	<span class="enscript-keyword">if</span> (dfflags &amp; SF_RESTRICTED)
		VATTR_SET(vap, va_flags, SF_RESTRICTED);

	<span class="enscript-comment">/*
	 * Create the requested node.
	 */</span>
	<span class="enscript-keyword">switch</span>(vap-&gt;va_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VREG</span>:
		error = vn_create_reg(dvp, vpp, ndp, vap, flags, fmode, statusp, ctx);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VDIR</span>:
		error = vn_mkdir(dvp, vpp, ndp, vap, ctx);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VSOCK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFIFO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
		error = VNOP_MKNOD(dvp, vpp, cnp, vap, ctx);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;vnode_create: unknown vtype %d&quot;</span>, vap-&gt;va_type);
	}
	<span class="enscript-keyword">if</span> (error != 0) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    CREATE - error %d returned by filesystem&quot;</span>, dvp, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	vp = *vpp;
	old_error = error;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (!(flags &amp; VN_CREATE_NOLABEL)) {
		error = vnode_label(vnode_mount(vp), dvp, vp, cnp, VNODE_LABEL_CREATE, ctx);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * If some of the requested attributes weren't handled by the VNOP,
	 * use our fallback code.
	 */</span>
	<span class="enscript-keyword">if</span> (!VATTR_ALL_SUPPORTED(vap) &amp;&amp; *vpp) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;     CREATE - doing fallback with ACL %p&quot;</span>, vap-&gt;va_acl);
		error = vnode_setattr_fallback(*vpp, vap, ctx);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
<span class="enscript-reference">error</span>:
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((error != 0) &amp;&amp; (vp != (vnode_t)0)) {

		<span class="enscript-comment">/* If we've done a compound open, close */</span>
		<span class="enscript-keyword">if</span> (batched &amp;&amp; (old_error == 0) &amp;&amp; (vap-&gt;va_type == VREG)) {
			VNOP_CLOSE(vp, fmode, ctx);
		}

		<span class="enscript-comment">/* Need to provide notifications if a create succeeded */</span>
		<span class="enscript-keyword">if</span> (!batched) {
			*vpp = (vnode_t) 0;
			vnode_put(vp);
		}
	}

<span class="enscript-reference">out</span>:
	vn_attribute_cleanup(vap, defaulted);

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">static</span> kauth_scope_t	vnode_scope;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	vnode_authorize_callback(kauth_cred_t credential, <span class="enscript-type">void</span> *idata, kauth_action_t action,
    uintptr_t arg0, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	vnode_authorize_callback_int(__unused kauth_cred_t credential, __unused <span class="enscript-type">void</span> *idata, kauth_action_t action,
    uintptr_t arg0, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3);

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _vnode_authorize_context {
	vnode_t		vp;
	<span class="enscript-type">struct</span> vnode_attr *vap;
	vnode_t		dvp;
	<span class="enscript-type">struct</span> vnode_attr *dvap;
	vfs_context_t	ctx;
	<span class="enscript-type">int</span>		flags;
	<span class="enscript-type">int</span>		flags_valid;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_VAC_IS_OWNER</span>		(1&lt;&lt;0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_VAC_IN_GROUP</span>		(1&lt;&lt;1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_VAC_IS_DIR_OWNER</span>	(1&lt;&lt;2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_VAC_IN_DIR_GROUP</span>	(1&lt;&lt;3)
} *vauth_ctx;

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_authorize_init</span>(<span class="enscript-type">void</span>)
{
	vnode_scope = kauth_register_scope(KAUTH_SCOPE_VNODE, vnode_authorize_callback, NULL);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VATTR_PREPARE_DEFAULTED_UID</span>		0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VATTR_PREPARE_DEFAULTED_GID</span>		0x2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VATTR_PREPARE_DEFAULTED_MODE</span>		0x4

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_attribute_prepare</span>(vnode_t dvp, <span class="enscript-type">struct</span> vnode_attr *vap, uint32_t *defaulted_fieldsp, vfs_context_t ctx)
{
	kauth_acl_t nacl = NULL, oacl = NULL;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * Handle ACL inheritance.
	 */</span>
	<span class="enscript-keyword">if</span> (!(vap-&gt;va_vaflags &amp; VA_NOINHERIT) &amp;&amp; vfs_extendedsecurity(dvp-&gt;v_mount)) {
		<span class="enscript-comment">/* save the original filesec */</span>
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_acl)) {
			oacl = vap-&gt;va_acl;
		}

		vap-&gt;va_acl = NULL;
		<span class="enscript-keyword">if</span> ((error = kauth_acl_inherit(dvp,
			 oacl,
			 &amp;nacl,
			 vap-&gt;va_type == VDIR,
			 ctx)) != 0) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    CREATE - error %d processing inheritance&quot;</span>, dvp, error);
			<span class="enscript-keyword">return</span>(error);
		}

		<span class="enscript-comment">/*
		 * If the generated ACL is NULL, then we can save ourselves some effort
		 * by clearing the active bit.
		 */</span>
		<span class="enscript-keyword">if</span> (nacl == NULL) {
			VATTR_CLEAR_ACTIVE(vap, va_acl);
		} <span class="enscript-keyword">else</span> {
			vap-&gt;va_base_acl = oacl;
			VATTR_SET(vap, va_acl, nacl);
		}
	}
	
	error = vnode_authattr_new_internal(dvp, vap, (vap-&gt;va_vaflags &amp; VA_NOAUTH), defaulted_fieldsp, ctx);
	<span class="enscript-keyword">if</span> (error) {
		vn_attribute_cleanup(vap, *defaulted_fieldsp);
	} 

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vn_attribute_cleanup</span>(<span class="enscript-type">struct</span> vnode_attr *vap, uint32_t defaulted_fields)
{
	<span class="enscript-comment">/*
	 * If the caller supplied a filesec in vap, it has been replaced
	 * now by the post-inheritance copy.  We need to put the original back
	 * and free the inherited product.
	 */</span>
	kauth_acl_t nacl, oacl;

	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_acl)) {
		nacl = vap-&gt;va_acl;
		oacl = vap-&gt;va_base_acl;

		<span class="enscript-keyword">if</span> (oacl)  {
			VATTR_SET(vap, va_acl, oacl);
			vap-&gt;va_base_acl = NULL;
		} <span class="enscript-keyword">else</span> {
			VATTR_CLEAR_ACTIVE(vap, va_acl);
		}

		<span class="enscript-keyword">if</span> (nacl != NULL) {
			kauth_acl_free(nacl);
		}
	}

	<span class="enscript-keyword">if</span> ((defaulted_fields &amp; VATTR_PREPARE_DEFAULTED_MODE) != 0) {
		VATTR_CLEAR_ACTIVE(vap, va_mode);
	}
	<span class="enscript-keyword">if</span> ((defaulted_fields &amp; VATTR_PREPARE_DEFAULTED_GID) != 0) {
		VATTR_CLEAR_ACTIVE(vap, va_gid);
	}
	<span class="enscript-keyword">if</span> ((defaulted_fields &amp; VATTR_PREPARE_DEFAULTED_UID) != 0) {
		VATTR_CLEAR_ACTIVE(vap, va_uid);
	}

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_authorize_unlink</span>(vnode_t dvp, vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp, vfs_context_t ctx, __unused <span class="enscript-type">void</span> *reserved)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cnp</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/*
	 * Normally, unlinking of directories is not supported. 
	 * However, some file systems may have limited support.
	 */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_type == VDIR) &amp;&amp;
			!(vp-&gt;v_mount-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSDIRLINKS)) {
		<span class="enscript-keyword">return</span> (EPERM);	<span class="enscript-comment">/* POSIX */</span>
	}

	<span class="enscript-comment">/* authorize the delete operation */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (!error)
		error = mac_vnode_check_unlink(ctx, dvp, vp, cnp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>
	<span class="enscript-keyword">if</span> (!error)
		error = vnode_authorize(vp, dvp, KAUTH_VNODE_DELETE, ctx);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_authorize_open_existing</span>(vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">int</span> fmode, vfs_context_t ctx, <span class="enscript-type">void</span> *reserved)
{
	<span class="enscript-comment">/* Open of existing case */</span>
	kauth_action_t action;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-keyword">if</span> (cnp-&gt;cn_ndp == NULL) {
		panic(<span class="enscript-string">&quot;NULL ndp&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (reserved != NULL) {
		panic(<span class="enscript-string">&quot;reserved not NULL.&quot;</span>);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/* XXX may do duplicate work here, but ignore that for now (idempotent) */</span>
	<span class="enscript-keyword">if</span> (vfs_flags(vnode_mount(vp)) &amp; MNT_MULTILABEL) {
		error = vnode_label(vnode_mount(vp), NULL, vp, NULL, 0, ctx);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> ( (fmode &amp; O_DIRECTORY) &amp;&amp; vp-&gt;v_type != VDIR ) {
		<span class="enscript-keyword">return</span> (ENOTDIR);
	}

	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VSOCK &amp;&amp; vp-&gt;v_tag != VT_FDESC) {
		<span class="enscript-keyword">return</span> (EOPNOTSUPP);	<span class="enscript-comment">/* Operation not supported on socket */</span>
	}

	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VLNK &amp;&amp; (fmode &amp; O_NOFOLLOW) != 0) {
		<span class="enscript-keyword">return</span> (ELOOP);		<span class="enscript-comment">/* O_NOFOLLOW was specified and the target is a symbolic link */</span>
	}

	<span class="enscript-comment">/* disallow write operations on directories */</span>
	<span class="enscript-keyword">if</span> (vnode_isdir(vp) &amp;&amp; (fmode &amp; (FWRITE | O_TRUNC))) {
		<span class="enscript-keyword">return</span> (EISDIR);
	}

	<span class="enscript-keyword">if</span> ((cnp-&gt;cn_ndp-&gt;ni_flag &amp; NAMEI_TRAILINGSLASH)) {
		<span class="enscript-keyword">if</span> (vp-&gt;v_type != VDIR) {
			<span class="enscript-keyword">return</span> (ENOTDIR);
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/* If a file being opened is a shadow file containing 
	 * namedstream data, ignore the macf checks because it 
	 * is a kernel internal file and access should always 
	 * be allowed.
	 */</span>
	<span class="enscript-keyword">if</span> (!(vnode_isshadow(vp) &amp;&amp; vnode_isnamedstream(vp))) {
		error = mac_vnode_check_open(ctx, vp, fmode);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">return</span> (error);
		}
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* compute action to be authorized */</span>
	action = 0;
	<span class="enscript-keyword">if</span> (fmode &amp; FREAD) {
		action |= KAUTH_VNODE_READ_DATA;
	}
	<span class="enscript-keyword">if</span> (fmode &amp; (FWRITE | O_TRUNC)) {
		<span class="enscript-comment">/*
		 * If we are writing, appending, and not truncating,
		 * indicate that we are appending so that if the
		 * UF_APPEND or SF_APPEND bits are set, we do not deny
		 * the open.
		 */</span>
		<span class="enscript-keyword">if</span> ((fmode &amp; O_APPEND) &amp;&amp; !(fmode &amp; O_TRUNC)) {
			action |= KAUTH_VNODE_APPEND_DATA;
		} <span class="enscript-keyword">else</span> {
			action |= KAUTH_VNODE_WRITE_DATA;
		}
	}
	error = vnode_authorize(vp, NULL, action, ctx);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-keyword">if</span> (error == EACCES) {
		<span class="enscript-comment">/*
		 * Shadow files may exist on-disk with a different UID/GID
		 * than that of the current context.  Verify that this file
		 * is really a shadow file.  If it was created successfully
		 * then it should be authorized.
		 */</span>
		<span class="enscript-keyword">if</span> (vnode_isshadow(vp) &amp;&amp; vnode_isnamedstream (vp)) {
			error = vnode_verifynamedstream(vp);
		}
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_authorize_create</span>(vnode_t dvp, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx, <span class="enscript-type">void</span> *reserved)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">vap</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* Creation case */</span>
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (cnp-&gt;cn_ndp == NULL) {
		panic(<span class="enscript-string">&quot;NULL cn_ndp&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (reserved != NULL) {
		panic(<span class="enscript-string">&quot;reserved not NULL.&quot;</span>);
	}

	<span class="enscript-comment">/* Only validate path for creation if we didn't do a complete lookup */</span>
	<span class="enscript-keyword">if</span> (cnp-&gt;cn_ndp-&gt;ni_flag &amp; NAMEI_UNFINISHED) {
		error = lookup_validate_creation_path(cnp-&gt;cn_ndp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_create(ctx, dvp, cnp, vap);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF */</span>

	<span class="enscript-keyword">return</span> (vnode_authorize(dvp, NULL, KAUTH_VNODE_ADD_FILE, ctx));
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">vn_authorize_rename</span>(<span class="enscript-type">struct</span> vnode *fdvp,  <span class="enscript-type">struct</span> vnode *fvp,  <span class="enscript-type">struct</span> componentname *fcnp,
             <span class="enscript-type">struct</span> vnode *tdvp,  <span class="enscript-type">struct</span> vnode *tvp,  <span class="enscript-type">struct</span> componentname *tcnp,
             vfs_context_t ctx, <span class="enscript-type">void</span> *reserved)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> moving = 0;

	<span class="enscript-keyword">if</span> (reserved != NULL) {
		panic(<span class="enscript-string">&quot;Passed something other than NULL as reserved field!&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * Avoid renaming &quot;.&quot; and &quot;..&quot;.
	 *
	 * XXX No need to check for this in the FS.  We should always have the leaves
	 * in VFS in this case.
	 */</span>
	<span class="enscript-keyword">if</span> (fvp-&gt;v_type == VDIR &amp;&amp;
	    ((fdvp == fvp) ||
	     (fcnp-&gt;cn_namelen == 1 &amp;&amp; fcnp-&gt;cn_nameptr[0] == <span class="enscript-string">'.'</span>) ||
	     ((fcnp-&gt;cn_flags | tcnp-&gt;cn_flags) &amp; ISDOTDOT)) ) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (tvp == NULLVP &amp;&amp; vnode_compound_rename_available(tdvp)) {
		error = lookup_validate_creation_path(tcnp-&gt;cn_ndp);
		<span class="enscript-keyword">if</span> (error) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/***** &lt;MACF&gt; *****/</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_rename(ctx, fdvp, fvp, fcnp, tdvp, tvp, tcnp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/***** &lt;/MACF&gt; *****/</span>

	<span class="enscript-comment">/***** &lt;MiscChecks&gt; *****/</span>
	<span class="enscript-keyword">if</span> (tvp != NULL) {
		<span class="enscript-keyword">if</span> (fvp-&gt;v_type == VDIR &amp;&amp; tvp-&gt;v_type != VDIR) {
			error = ENOTDIR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fvp-&gt;v_type != VDIR &amp;&amp; tvp-&gt;v_type == VDIR) {
			error = EISDIR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-keyword">if</span> (fvp == tdvp) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * The following edge case is caught here:
	 * (to cannot be a descendent of from)
	 *
	 *       o fdvp
	 *      /
	 *     /
	 *    o fvp
	 *     \
	 *      \
	 *       o tdvp
	 *      /
	 *     /
	 *    o tvp
	 */</span>
	<span class="enscript-keyword">if</span> (tdvp-&gt;v_parent == fvp) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/***** &lt;/MiscChecks&gt; *****/</span>

	<span class="enscript-comment">/***** &lt;Kauth&gt; *****/</span>

	error = 0;
	<span class="enscript-keyword">if</span> ((tvp != NULL) &amp;&amp; vnode_isdir(tvp)) {
		<span class="enscript-keyword">if</span> (tvp != fdvp)
			moving = 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tdvp != fdvp) {
		moving = 1;
	}


	<span class="enscript-comment">/*
	 * must have delete rights to remove the old name even in
	 * the simple case of fdvp == tdvp.
	 *
	 * If fvp is a directory, and we are changing it's parent,
	 * then we also need rights to rewrite its &quot;..&quot; entry as well.
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isdir(fvp)) {
		<span class="enscript-keyword">if</span> ((error = vnode_authorize(fvp, fdvp, KAUTH_VNODE_DELETE | KAUTH_VNODE_ADD_SUBDIRECTORY, ctx)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((error = vnode_authorize(fvp, fdvp, KAUTH_VNODE_DELETE, ctx)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (moving) {
		<span class="enscript-comment">/* moving into tdvp or tvp, must have rights to add */</span>
		<span class="enscript-keyword">if</span> ((error = vnode_authorize(((tvp != NULL) &amp;&amp; vnode_isdir(tvp)) ? tvp : tdvp,
						NULL, 
						vnode_isdir(fvp) ? KAUTH_VNODE_ADD_SUBDIRECTORY : KAUTH_VNODE_ADD_FILE,
						ctx)) != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* node staying in same directory, must be allowed to add new name */</span>
		<span class="enscript-keyword">if</span> ((error = vnode_authorize(fdvp, NULL,
						vnode_isdir(fvp) ? KAUTH_VNODE_ADD_SUBDIRECTORY : KAUTH_VNODE_ADD_FILE, ctx)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/* overwriting tvp */</span>
	<span class="enscript-keyword">if</span> ((tvp != NULL) &amp;&amp; !vnode_isdir(tvp) &amp;&amp;
			((error = vnode_authorize(tvp, tdvp, KAUTH_VNODE_DELETE, ctx)) != 0)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/***** &lt;/Kauth&gt; *****/</span>

	<span class="enscript-comment">/* XXX more checks? */</span>
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_authorize_mkdir</span>(vnode_t dvp, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx, <span class="enscript-type">void</span> *reserved)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">vap</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (reserved != NULL) {
		panic(<span class="enscript-string">&quot;reserved not NULL in vn_authorize_mkdir()&quot;</span>);	
	}

	<span class="enscript-comment">/* XXX A hack for now, to make shadow files work */</span>
	<span class="enscript-keyword">if</span> (cnp-&gt;cn_ndp == NULL) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (vnode_compound_mkdir_available(dvp)) {
		error = lookup_validate_creation_path(cnp-&gt;cn_ndp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_create(ctx,
	    dvp, cnp, vap);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

  	<span class="enscript-comment">/* authorize addition of a directory to the parent */</span>
  	<span class="enscript-keyword">if</span> ((error = vnode_authorize(dvp, NULL, KAUTH_VNODE_ADD_SUBDIRECTORY, ctx)) != 0)
  		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
 	
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_authorize_rmdir</span>(vnode_t dvp, vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp, vfs_context_t ctx, <span class="enscript-type">void</span> *reserved)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cnp</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (reserved != NULL) {
		panic(<span class="enscript-string">&quot;Non-NULL reserved argument to vn_authorize_rmdir()&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (vp-&gt;v_type != VDIR) {
		<span class="enscript-comment">/*
		 * rmdir only deals with directories
		 */</span>
		<span class="enscript-keyword">return</span> ENOTDIR;
	} 
	
	<span class="enscript-keyword">if</span> (dvp == vp) {
		<span class="enscript-comment">/*
		 * No rmdir &quot;.&quot; please.
		 */</span>
		<span class="enscript-keyword">return</span> EINVAL;
	} 
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_unlink(ctx, dvp,
			vp, cnp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> vnode_authorize(vp, dvp, KAUTH_VNODE_DELETE, ctx);
}

<span class="enscript-comment">/*
 * Authorize an operation on a vnode.
 *
 * This is KPI, but here because it needs vnode_scope.
 *
 * Returns:	0			Success
 *	kauth_authorize_action:EPERM	...
 *	xlate =&gt; EACCES			Permission denied
 *	kauth_authorize_action:0	Success
 *	kauth_authorize_action:		Depends on callback return; this is
 *					usually only vnode_authorize_callback(),
 *					but may include other listerners, if any
 *					exist.
 *		EROFS
 *		EACCES
 *		EPERM
 *		???
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_authorize</span>(vnode_t vp, vnode_t dvp, kauth_action_t action, vfs_context_t ctx)
{
	<span class="enscript-type">int</span>	error, result;

	<span class="enscript-comment">/*
	 * We can't authorize against a dead vnode; allow all operations through so that
	 * the correct error can be returned.
	 */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VBAD)
		<span class="enscript-keyword">return</span>(0);
	
	error = 0;
	result = kauth_authorize_action(vnode_scope, vfs_context_ucred(ctx), action,
		   (uintptr_t)ctx, (uintptr_t)vp, (uintptr_t)dvp, (uintptr_t)&amp;error);
	<span class="enscript-keyword">if</span> (result == EPERM)		<span class="enscript-comment">/* traditional behaviour */</span>
		result = EACCES;
	<span class="enscript-comment">/* did the lower layers give a better error return? */</span>
	<span class="enscript-keyword">if</span> ((result != 0) &amp;&amp; (error != 0))
	        <span class="enscript-keyword">return</span>(error);
	<span class="enscript-keyword">return</span>(result);
}

<span class="enscript-comment">/*
 * Test for vnode immutability.
 *
 * The 'append' flag is set when the authorization request is constrained
 * to operations which only request the right to append to a file.
 *
 * The 'ignore' flag is set when an operation modifying the immutability flags
 * is being authorized.  We check the system securelevel to determine which
 * immutability flags we can ignore.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_immutable</span>(<span class="enscript-type">struct</span> vnode_attr *vap, <span class="enscript-type">int</span> append, <span class="enscript-type">int</span> ignore)
{
	<span class="enscript-type">int</span>	mask;

	<span class="enscript-comment">/* start with all bits precluding the operation */</span>
	mask = IMMUTABLE | APPEND;

	<span class="enscript-comment">/* if appending only, remove the append-only bits */</span>
	<span class="enscript-keyword">if</span> (append)
		mask &amp;= ~APPEND;

	<span class="enscript-comment">/* ignore only set when authorizing flags changes */</span>
	<span class="enscript-keyword">if</span> (ignore) {
		<span class="enscript-keyword">if</span> (securelevel &lt;= 0) {
			<span class="enscript-comment">/* in insecure state, flags do not inhibit changes */</span>
			mask = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* in secure state, user flags don't inhibit */</span>
			mask &amp;= ~(UF_IMMUTABLE | UF_APPEND);
		}
	}
	KAUTH_DEBUG(<span class="enscript-string">&quot;IMMUTABLE - file flags 0x%x mask 0x%x append = %d ignore = %d&quot;</span>, vap-&gt;va_flags, mask, append, ignore);
	<span class="enscript-keyword">if</span> ((vap-&gt;va_flags &amp; mask) != 0)
		<span class="enscript-keyword">return</span>(EPERM);
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vauth_node_owner</span>(<span class="enscript-type">struct</span> vnode_attr *vap, kauth_cred_t cred)
{
	<span class="enscript-type">int</span> result;

	<span class="enscript-comment">/* default assumption is not-owner */</span>
	result = 0;

	<span class="enscript-comment">/*
	 * If the filesystem has given us a UID, we treat this as authoritative.
	 */</span>
	<span class="enscript-keyword">if</span> (vap &amp;&amp; VATTR_IS_SUPPORTED(vap, va_uid)) {
		result = (vap-&gt;va_uid == kauth_cred_getuid(cred)) ? 1 : 0;
	}
	<span class="enscript-comment">/* we could test the owner UUID here if we had a policy for it */</span>
	
	<span class="enscript-keyword">return</span>(result);
}

<span class="enscript-comment">/*
 * vauth_node_group
 *
 * Description:	Ask if a cred is a member of the group owning the vnode object
 *
 * Parameters:		vap		vnode attribute
 *				vap-&gt;va_gid	group owner of vnode object
 *			cred		credential to check
 *			ismember	pointer to where to put the answer
 *			idontknow	Return this if we can't get an answer
 *
 * Returns:		0		Success
 *			idontknow	Can't get information
 *	kauth_cred_ismember_gid:?	Error from kauth subsystem
 *	kauth_cred_ismember_gid:?	Error from kauth subsystem
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vauth_node_group</span>(<span class="enscript-type">struct</span> vnode_attr *vap, kauth_cred_t cred, <span class="enscript-type">int</span> *ismember, <span class="enscript-type">int</span> idontknow)
{
	<span class="enscript-type">int</span>	error;
	<span class="enscript-type">int</span>	result;

	error = 0;
	result = 0;

	<span class="enscript-comment">/*
	 * The caller is expected to have asked the filesystem for a group
	 * at some point prior to calling this function.  The answer may
	 * have been that there is no group ownership supported for the
	 * vnode object, in which case we return
	 */</span>
	<span class="enscript-keyword">if</span> (vap &amp;&amp; VATTR_IS_SUPPORTED(vap, va_gid)) {
		error = kauth_cred_ismember_gid(cred, vap-&gt;va_gid, &amp;result);
		<span class="enscript-comment">/*
		 * Credentials which are opted into external group membership
		 * resolution which are not known to the external resolver
		 * will result in an ENOENT error.  We translate this into
		 * the appropriate 'idontknow' response for our caller.
		 *
		 * XXX We do not make a distinction here between an ENOENT
		 * XXX arising from a response from the external resolver,
		 * XXX and an ENOENT which is internally generated.  This is
		 * XXX a deficiency of the published kauth_cred_ismember_gid()
		 * XXX KPI which can not be overcome without new KPI.  For
		 * XXX all currently known cases, however, this wil result
		 * XXX in correct behaviour.
		 */</span>
		<span class="enscript-keyword">if</span> (error == ENOENT)
			error = idontknow;
	}
	<span class="enscript-comment">/*
	 * XXX We could test the group UUID here if we had a policy for it,
	 * XXX but this is problematic from the perspective of synchronizing
	 * XXX group UUID and POSIX GID ownership of a file and keeping the
	 * XXX values coherent over time.  The problem is that the local
	 * XXX system will vend transient group UUIDs for unknown POSIX GID
	 * XXX values, and these are not persistent, whereas storage of values
	 * XXX is persistent.  One potential solution to this is a local
	 * XXX (persistent) replica of remote directory entries and vended
	 * XXX local ids in a local directory server (think in terms of a
	 * XXX caching DNS server).
	 */</span>

	<span class="enscript-keyword">if</span> (!error)
		*ismember = result;
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vauth_file_owner</span>(vauth_ctx vcp)
{
	<span class="enscript-type">int</span> result;

	<span class="enscript-keyword">if</span> (vcp-&gt;flags_valid &amp; _VAC_IS_OWNER) {
		result = (vcp-&gt;flags &amp; _VAC_IS_OWNER) ? 1 : 0;
	} <span class="enscript-keyword">else</span> {
		result = vauth_node_owner(vcp-&gt;vap, vcp-&gt;ctx-&gt;vc_ucred);

		<span class="enscript-comment">/* cache our result */</span>
		vcp-&gt;flags_valid |= _VAC_IS_OWNER;
		<span class="enscript-keyword">if</span> (result) {
			vcp-&gt;flags |= _VAC_IS_OWNER;
		} <span class="enscript-keyword">else</span> {
			vcp-&gt;flags &amp;= ~_VAC_IS_OWNER;
		}
	}
	<span class="enscript-keyword">return</span>(result);
}


<span class="enscript-comment">/*
 * vauth_file_ingroup
 *
 * Description:	Ask if a user is a member of the group owning the directory
 *
 * Parameters:		vcp		The vnode authorization context that
 *					contains the user and directory info
 *				vcp-&gt;flags_valid	Valid flags
 *				vcp-&gt;flags		Flags values
 *				vcp-&gt;vap		File vnode attributes
 *				vcp-&gt;ctx		VFS Context (for user)
 *			ismember	pointer to where to put the answer
 *			idontknow	Return this if we can't get an answer
 *
 * Returns:		0		Success
 *		vauth_node_group:?	Error from vauth_node_group()
 *
 * Implicit returns:	*ismember	0	The user is not a group member
 *					1	The user is a group member
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vauth_file_ingroup</span>(vauth_ctx vcp, <span class="enscript-type">int</span> *ismember, <span class="enscript-type">int</span> idontknow)
{
	<span class="enscript-type">int</span>	error;

	<span class="enscript-comment">/* Check for a cached answer first, to avoid the check if possible */</span>
	<span class="enscript-keyword">if</span> (vcp-&gt;flags_valid &amp; _VAC_IN_GROUP) {
		*ismember = (vcp-&gt;flags &amp; _VAC_IN_GROUP) ? 1 : 0;
		error = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Otherwise, go look for it */</span>
		error = vauth_node_group(vcp-&gt;vap, vcp-&gt;ctx-&gt;vc_ucred, ismember, idontknow);

		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/* cache our result */</span>
			vcp-&gt;flags_valid |= _VAC_IN_GROUP;
			<span class="enscript-keyword">if</span> (*ismember) {
				vcp-&gt;flags |= _VAC_IN_GROUP;
			} <span class="enscript-keyword">else</span> {
				vcp-&gt;flags &amp;= ~_VAC_IN_GROUP;
			}
		}
		
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vauth_dir_owner</span>(vauth_ctx vcp)
{
	<span class="enscript-type">int</span> result;

	<span class="enscript-keyword">if</span> (vcp-&gt;flags_valid &amp; _VAC_IS_DIR_OWNER) {
		result = (vcp-&gt;flags &amp; _VAC_IS_DIR_OWNER) ? 1 : 0;
	} <span class="enscript-keyword">else</span> {
		result = vauth_node_owner(vcp-&gt;dvap, vcp-&gt;ctx-&gt;vc_ucred);

		<span class="enscript-comment">/* cache our result */</span>
		vcp-&gt;flags_valid |= _VAC_IS_DIR_OWNER;
		<span class="enscript-keyword">if</span> (result) {
			vcp-&gt;flags |= _VAC_IS_DIR_OWNER;
		} <span class="enscript-keyword">else</span> {
			vcp-&gt;flags &amp;= ~_VAC_IS_DIR_OWNER;
		}
	}
	<span class="enscript-keyword">return</span>(result);
}

<span class="enscript-comment">/*
 * vauth_dir_ingroup
 *
 * Description:	Ask if a user is a member of the group owning the directory
 *
 * Parameters:		vcp		The vnode authorization context that
 *					contains the user and directory info
 *				vcp-&gt;flags_valid	Valid flags
 *				vcp-&gt;flags		Flags values
 *				vcp-&gt;dvap		Dir vnode attributes
 *				vcp-&gt;ctx		VFS Context (for user)
 *			ismember	pointer to where to put the answer
 *			idontknow	Return this if we can't get an answer
 *
 * Returns:		0		Success
 *		vauth_node_group:?	Error from vauth_node_group()
 *
 * Implicit returns:	*ismember	0	The user is not a group member
 *					1	The user is a group member
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vauth_dir_ingroup</span>(vauth_ctx vcp, <span class="enscript-type">int</span> *ismember, <span class="enscript-type">int</span> idontknow)
{
	<span class="enscript-type">int</span>	error;

	<span class="enscript-comment">/* Check for a cached answer first, to avoid the check if possible */</span>
	<span class="enscript-keyword">if</span> (vcp-&gt;flags_valid &amp; _VAC_IN_DIR_GROUP) {
		*ismember = (vcp-&gt;flags &amp; _VAC_IN_DIR_GROUP) ? 1 : 0;
		error = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Otherwise, go look for it */</span>
		error = vauth_node_group(vcp-&gt;dvap, vcp-&gt;ctx-&gt;vc_ucred, ismember, idontknow);

		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/* cache our result */</span>
			vcp-&gt;flags_valid |= _VAC_IN_DIR_GROUP;
			<span class="enscript-keyword">if</span> (*ismember) {
				vcp-&gt;flags |= _VAC_IN_DIR_GROUP;
			} <span class="enscript-keyword">else</span> {
				vcp-&gt;flags &amp;= ~_VAC_IN_DIR_GROUP;
			}
		}
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Test the posix permissions in (vap) to determine whether (credential)
 * may perform (action)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_authorize_posix</span>(vauth_ctx vcp, <span class="enscript-type">int</span> action, <span class="enscript-type">int</span> on_dir)
{
	<span class="enscript-type">struct</span> vnode_attr *vap;
	<span class="enscript-type">int</span> needed, error, owner_ok, group_ok, world_ok, ismember;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KAUTH_DEBUG_ENABLE</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *where = <span class="enscript-string">&quot;uninitialized&quot;</span>;
# <span class="enscript-reference">define</span> <span class="enscript-function-name">_SETWHERE</span>(c)	where = c;
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">_SETWHERE</span>(c)
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* checking file or directory? */</span>
	<span class="enscript-keyword">if</span> (on_dir) {
		vap = vcp-&gt;dvap;
	} <span class="enscript-keyword">else</span> {
		vap = vcp-&gt;vap;
	}
	
	error = 0;
	
	<span class="enscript-comment">/*
	 * We want to do as little work here as possible.  So first we check
	 * which sets of permissions grant us the access we need, and avoid checking
	 * whether specific permissions grant access when more generic ones would.
	 */</span>

	<span class="enscript-comment">/* owner permissions */</span>
	needed = 0;
	<span class="enscript-keyword">if</span> (action &amp; VREAD)
		needed |= S_IRUSR;
	<span class="enscript-keyword">if</span> (action &amp; VWRITE)
		needed |= S_IWUSR;
	<span class="enscript-keyword">if</span> (action &amp; VEXEC)
		needed |= S_IXUSR;
	owner_ok = (needed &amp; vap-&gt;va_mode) == needed;

	<span class="enscript-comment">/* group permissions */</span>
	needed = 0;
	<span class="enscript-keyword">if</span> (action &amp; VREAD)
		needed |= S_IRGRP;
	<span class="enscript-keyword">if</span> (action &amp; VWRITE)
		needed |= S_IWGRP;
	<span class="enscript-keyword">if</span> (action &amp; VEXEC)
		needed |= S_IXGRP;
	group_ok = (needed &amp; vap-&gt;va_mode) == needed;

	<span class="enscript-comment">/* world permissions */</span>
	needed = 0;
	<span class="enscript-keyword">if</span> (action &amp; VREAD)
		needed |= S_IROTH;
	<span class="enscript-keyword">if</span> (action &amp; VWRITE)
		needed |= S_IWOTH;
	<span class="enscript-keyword">if</span> (action &amp; VEXEC)
		needed |= S_IXOTH;
	world_ok = (needed &amp; vap-&gt;va_mode) == needed;

	<span class="enscript-comment">/* If granted/denied by all three, we're done */</span>
	<span class="enscript-keyword">if</span> (owner_ok &amp;&amp; group_ok &amp;&amp; world_ok) {
		_SETWHERE(<span class="enscript-string">&quot;all&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (!owner_ok &amp;&amp; !group_ok &amp;&amp; !world_ok) {
		_SETWHERE(<span class="enscript-string">&quot;all&quot;</span>);
		error = EACCES;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Check ownership (relatively cheap) */</span>
	<span class="enscript-keyword">if</span> ((on_dir &amp;&amp; vauth_dir_owner(vcp)) ||
	    (!on_dir &amp;&amp; vauth_file_owner(vcp))) {
		_SETWHERE(<span class="enscript-string">&quot;user&quot;</span>);
		<span class="enscript-keyword">if</span> (!owner_ok)
			error = EACCES;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Not owner; if group and world both grant it we're done */</span>
	<span class="enscript-keyword">if</span> (group_ok &amp;&amp; world_ok) {
		_SETWHERE(<span class="enscript-string">&quot;group/world&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (!group_ok &amp;&amp; !world_ok) {
		_SETWHERE(<span class="enscript-string">&quot;group/world&quot;</span>);
		error = EACCES;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Check group membership (most expensive) */</span>
	ismember = 0;	<span class="enscript-comment">/* Default to allow, if the target has no group owner */</span>

	<span class="enscript-comment">/*
	 * In the case we can't get an answer about the user from the call to
	 * vauth_dir_ingroup() or vauth_file_ingroup(), we want to fail on
	 * the side of caution, rather than simply granting access, or we will
	 * fail to correctly implement exclusion groups, so we set the third
	 * parameter on the basis of the state of 'group_ok'.
	 */</span>
	<span class="enscript-keyword">if</span> (on_dir) {
		error = vauth_dir_ingroup(vcp, &amp;ismember, (!group_ok ? EACCES : 0));
	} <span class="enscript-keyword">else</span> {
		error = vauth_file_ingroup(vcp, &amp;ismember, (!group_ok ? EACCES : 0));
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (!group_ok)
			ismember = 1;
		error = 0;
	}
	<span class="enscript-keyword">if</span> (ismember) {
		_SETWHERE(<span class="enscript-string">&quot;group&quot;</span>);
		<span class="enscript-keyword">if</span> (!group_ok)
			error = EACCES;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Not owner, not in group, use world result */</span>
	_SETWHERE(<span class="enscript-string">&quot;world&quot;</span>);
	<span class="enscript-keyword">if</span> (!world_ok)
		error = EACCES;

	<span class="enscript-comment">/* FALLTHROUGH */</span>

<span class="enscript-reference">out</span>:
	KAUTH_DEBUG(<span class="enscript-string">&quot;%p    %s - posix %s permissions : need %s%s%s %x have %s%s%s%s%s%s%s%s%s UID = %d file = %d,%d&quot;</span>,
	    vcp-&gt;vp, (error == 0) ? <span class="enscript-string">&quot;ALLOWED&quot;</span> : <span class="enscript-string">&quot;DENIED&quot;</span>, where,
	    (action &amp; VREAD)  ? <span class="enscript-string">&quot;r&quot;</span> : <span class="enscript-string">&quot;-&quot;</span>,
	    (action &amp; VWRITE) ? <span class="enscript-string">&quot;w&quot;</span> : <span class="enscript-string">&quot;-&quot;</span>,
	    (action &amp; VEXEC)  ? <span class="enscript-string">&quot;x&quot;</span> : <span class="enscript-string">&quot;-&quot;</span>,
	    needed,
	    (vap-&gt;va_mode &amp; S_IRUSR) ? <span class="enscript-string">&quot;r&quot;</span> : <span class="enscript-string">&quot;-&quot;</span>,
	    (vap-&gt;va_mode &amp; S_IWUSR) ? <span class="enscript-string">&quot;w&quot;</span> : <span class="enscript-string">&quot;-&quot;</span>,
	    (vap-&gt;va_mode &amp; S_IXUSR) ? <span class="enscript-string">&quot;x&quot;</span> : <span class="enscript-string">&quot;-&quot;</span>,
	    (vap-&gt;va_mode &amp; S_IRGRP) ? <span class="enscript-string">&quot;r&quot;</span> : <span class="enscript-string">&quot;-&quot;</span>,
	    (vap-&gt;va_mode &amp; S_IWGRP) ? <span class="enscript-string">&quot;w&quot;</span> : <span class="enscript-string">&quot;-&quot;</span>,
	    (vap-&gt;va_mode &amp; S_IXGRP) ? <span class="enscript-string">&quot;x&quot;</span> : <span class="enscript-string">&quot;-&quot;</span>,
	    (vap-&gt;va_mode &amp; S_IROTH) ? <span class="enscript-string">&quot;r&quot;</span> : <span class="enscript-string">&quot;-&quot;</span>,
	    (vap-&gt;va_mode &amp; S_IWOTH) ? <span class="enscript-string">&quot;w&quot;</span> : <span class="enscript-string">&quot;-&quot;</span>,
	    (vap-&gt;va_mode &amp; S_IXOTH) ? <span class="enscript-string">&quot;x&quot;</span> : <span class="enscript-string">&quot;-&quot;</span>,
	    kauth_cred_getuid(vcp-&gt;ctx-&gt;vc_ucred),
	    on_dir ? vcp-&gt;dvap-&gt;va_uid : vcp-&gt;vap-&gt;va_uid,
	    on_dir ? vcp-&gt;dvap-&gt;va_gid : vcp-&gt;vap-&gt;va_gid);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Authorize the deletion of the node vp from the directory dvp.
 *
 * We assume that:
 * - Neither the node nor the directory are immutable.
 * - The user is not the superuser.
 *
 * Deletion is not permitted if the directory is sticky and the caller is
 * not owner of the node or directory.
 *
 * If either the node grants DELETE, or the directory grants DELETE_CHILD,
 * the node may be deleted.  If neither denies the permission, and the
 * caller has Posix write access to the directory, then the node may be
 * deleted.
 *
 * As an optimization, we cache whether or not delete child is permitted
 * on directories without the sticky bit set.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_authorize_delete</span>(vauth_ctx vcp, boolean_t cached_delete_child);
<span class="enscript-comment">/*static*/</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_authorize_delete</span>(vauth_ctx vcp, boolean_t cached_delete_child)
{
	<span class="enscript-type">struct</span> vnode_attr	*vap = vcp-&gt;vap;
	<span class="enscript-type">struct</span> vnode_attr	*dvap = vcp-&gt;dvap;
	kauth_cred_t		cred = vcp-&gt;ctx-&gt;vc_ucred;
	<span class="enscript-type">struct</span> kauth_acl_eval	eval;
	<span class="enscript-type">int</span>			error, delete_denied, delete_child_denied, ismember;

	<span class="enscript-comment">/* check the ACL on the directory */</span>
	delete_child_denied = 0;
	<span class="enscript-keyword">if</span> (!cached_delete_child &amp;&amp; VATTR_IS_NOT(dvap, va_acl, NULL)) {
		eval.ae_requested = KAUTH_VNODE_DELETE_CHILD;
		eval.ae_acl = &amp;dvap-&gt;va_acl-&gt;acl_ace[0];
		eval.ae_count = dvap-&gt;va_acl-&gt;acl_entrycount;
		eval.ae_options = 0;
		<span class="enscript-keyword">if</span> (vauth_dir_owner(vcp))
			eval.ae_options |= KAUTH_AEVAL_IS_OWNER;
		<span class="enscript-comment">/*
		 * We use ENOENT as a marker to indicate we could not get
		 * information in order to delay evaluation until after we
		 * have the ACL evaluation answer.  Previously, we would
		 * always deny the operation at this point.
		 */</span>
		<span class="enscript-keyword">if</span> ((error = vauth_dir_ingroup(vcp, &amp;ismember, ENOENT)) != 0 &amp;&amp; error != ENOENT)
			<span class="enscript-keyword">return</span>(error);
		<span class="enscript-keyword">if</span> (error == ENOENT)
			eval.ae_options |= KAUTH_AEVAL_IN_GROUP_UNKNOWN;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ismember)
			eval.ae_options |= KAUTH_AEVAL_IN_GROUP;
		eval.ae_exp_gall = KAUTH_VNODE_GENERIC_ALL_BITS;
		eval.ae_exp_gread = KAUTH_VNODE_GENERIC_READ_BITS;
		eval.ae_exp_gwrite = KAUTH_VNODE_GENERIC_WRITE_BITS;
		eval.ae_exp_gexec = KAUTH_VNODE_GENERIC_EXECUTE_BITS;

		<span class="enscript-comment">/*
		 * If there is no entry, we are going to defer to other
		 * authorization mechanisms.
		 */</span>
		error = kauth_acl_evaluate(cred, &amp;eval);

		<span class="enscript-keyword">if</span> (error != 0) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ERROR during ACL processing - %d&quot;</span>, vcp-&gt;vp, error);
			<span class="enscript-keyword">return</span>(error);
		}
		<span class="enscript-keyword">switch</span>(eval.ae_result) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_RESULT_DENY</span>:
			delete_child_denied = 1;
			<span class="enscript-keyword">break</span>;
			<span class="enscript-comment">/* FALLSTHROUGH */</span>
                <span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_RESULT_ALLOW</span>:
                        KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ALLOWED - granted by directory ACL&quot;</span>, vcp-&gt;vp);
                        <span class="enscript-keyword">return</span>(0);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_RESULT_DEFER</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* Effectively the same as !delete_child_denied */</span>
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DEFERRED - directory ACL&quot;</span>, vcp-&gt;vp);
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">/* check the ACL on the node */</span>
	delete_denied = 0;
	<span class="enscript-keyword">if</span> (VATTR_IS_NOT(vap, va_acl, NULL)) {
		eval.ae_requested = KAUTH_VNODE_DELETE;
		eval.ae_acl = &amp;vap-&gt;va_acl-&gt;acl_ace[0];
		eval.ae_count = vap-&gt;va_acl-&gt;acl_entrycount;
		eval.ae_options = 0;
		<span class="enscript-keyword">if</span> (vauth_file_owner(vcp))
			eval.ae_options |= KAUTH_AEVAL_IS_OWNER;
		<span class="enscript-comment">/*
		 * We use ENOENT as a marker to indicate we could not get
		 * information in order to delay evaluation until after we
		 * have the ACL evaluation answer.  Previously, we would
		 * always deny the operation at this point.
		 */</span>
		<span class="enscript-keyword">if</span> ((error = vauth_file_ingroup(vcp, &amp;ismember, ENOENT)) != 0 &amp;&amp; error != ENOENT)
			<span class="enscript-keyword">return</span>(error);
		<span class="enscript-keyword">if</span> (error == ENOENT)
			eval.ae_options |= KAUTH_AEVAL_IN_GROUP_UNKNOWN;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ismember)
			eval.ae_options |= KAUTH_AEVAL_IN_GROUP;
		eval.ae_exp_gall = KAUTH_VNODE_GENERIC_ALL_BITS;
		eval.ae_exp_gread = KAUTH_VNODE_GENERIC_READ_BITS;
		eval.ae_exp_gwrite = KAUTH_VNODE_GENERIC_WRITE_BITS;
		eval.ae_exp_gexec = KAUTH_VNODE_GENERIC_EXECUTE_BITS;

		<span class="enscript-keyword">if</span> ((error = kauth_acl_evaluate(cred, &amp;eval)) != 0) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ERROR during ACL processing - %d&quot;</span>, vcp-&gt;vp, error);
			<span class="enscript-keyword">return</span>(error);
		}

		<span class="enscript-keyword">switch</span>(eval.ae_result) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_RESULT_DENY</span>:
			delete_denied = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_RESULT_ALLOW</span>:
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ALLOWED - granted by file ACL&quot;</span>, vcp-&gt;vp);
			<span class="enscript-keyword">return</span>(0);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_RESULT_DEFER</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* Effectively the same as !delete_child_denied */</span>
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DEFERRED%s - by file ACL&quot;</span>, vcp-&gt;vp, delete_denied ? <span class="enscript-string">&quot;(DENY)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">/* if denied by ACL on directory or node, return denial */</span>
	<span class="enscript-keyword">if</span> (delete_denied || delete_child_denied) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DENIED - denied by ACL&quot;</span>, vcp-&gt;vp);
		<span class="enscript-keyword">return</span>(EACCES);
	}

	<span class="enscript-comment">/* enforce sticky bit behaviour */</span>
	<span class="enscript-keyword">if</span> ((dvap-&gt;va_mode &amp; S_ISTXT) &amp;&amp; !vauth_file_owner(vcp) &amp;&amp; !vauth_dir_owner(vcp)) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DENIED - sticky bit rules (user %d  file %d  dir %d)&quot;</span>,
		    vcp-&gt;vp, cred-&gt;cr_posix.cr_uid, vap-&gt;va_uid, dvap-&gt;va_uid);
		<span class="enscript-keyword">return</span>(EACCES);
	}

	<span class="enscript-comment">/* check the directory */</span>
	<span class="enscript-keyword">if</span> (!cached_delete_child &amp;&amp; (error = vnode_authorize_posix(vcp, VWRITE, 1 <span class="enscript-comment">/* on_dir */</span>)) != 0) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DENIED - denied by posix permisssions&quot;</span>, vcp-&gt;vp);
		<span class="enscript-keyword">return</span>(error);
	}

	<span class="enscript-comment">/* not denied, must be OK */</span>
	<span class="enscript-keyword">return</span>(0);
}
	

<span class="enscript-comment">/*
 * Authorize an operation based on the node's attributes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_authorize_simple</span>(vauth_ctx vcp, kauth_ace_rights_t acl_rights, kauth_ace_rights_t preauth_rights, boolean_t *found_deny)
{
	<span class="enscript-type">struct</span> vnode_attr	*vap = vcp-&gt;vap;
	kauth_cred_t		cred = vcp-&gt;ctx-&gt;vc_ucred;
	<span class="enscript-type">struct</span> kauth_acl_eval	eval;
	<span class="enscript-type">int</span>			error, ismember;
	mode_t			posix_action;

	<span class="enscript-comment">/*
	 * If we are the file owner, we automatically have some rights.
	 *
	 * Do we need to expand this to support group ownership?
	 */</span>
	<span class="enscript-keyword">if</span> (vauth_file_owner(vcp))
		acl_rights &amp;= ~(KAUTH_VNODE_WRITE_SECURITY);

	<span class="enscript-comment">/*
	 * If we are checking both TAKE_OWNERSHIP and WRITE_SECURITY, we can
	 * mask the latter.  If TAKE_OWNERSHIP is requested the caller is about to
	 * change ownership to themselves, and WRITE_SECURITY is implicitly
	 * granted to the owner.  We need to do this because at this point
	 * WRITE_SECURITY may not be granted as the caller is not currently
	 * the owner.
	 */</span>
	<span class="enscript-keyword">if</span> ((acl_rights &amp; KAUTH_VNODE_TAKE_OWNERSHIP) &amp;&amp;
	    (acl_rights &amp; KAUTH_VNODE_WRITE_SECURITY))
		acl_rights &amp;= ~KAUTH_VNODE_WRITE_SECURITY;
	
	<span class="enscript-keyword">if</span> (acl_rights == 0) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ALLOWED - implicit or no rights required&quot;</span>, vcp-&gt;vp);
		<span class="enscript-keyword">return</span>(0);
	}

	<span class="enscript-comment">/* if we have an ACL, evaluate it */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_NOT(vap, va_acl, NULL)) {
		eval.ae_requested = acl_rights;
		eval.ae_acl = &amp;vap-&gt;va_acl-&gt;acl_ace[0];
		eval.ae_count = vap-&gt;va_acl-&gt;acl_entrycount;
		eval.ae_options = 0;
		<span class="enscript-keyword">if</span> (vauth_file_owner(vcp))
			eval.ae_options |= KAUTH_AEVAL_IS_OWNER;
		<span class="enscript-comment">/*
		 * We use ENOENT as a marker to indicate we could not get
		 * information in order to delay evaluation until after we
		 * have the ACL evaluation answer.  Previously, we would
		 * always deny the operation at this point.
		 */</span>
		<span class="enscript-keyword">if</span> ((error = vauth_file_ingroup(vcp, &amp;ismember, ENOENT)) != 0 &amp;&amp; error != ENOENT)
			<span class="enscript-keyword">return</span>(error);
		<span class="enscript-keyword">if</span> (error == ENOENT)
			eval.ae_options |= KAUTH_AEVAL_IN_GROUP_UNKNOWN;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ismember)
			eval.ae_options |= KAUTH_AEVAL_IN_GROUP;
		eval.ae_exp_gall = KAUTH_VNODE_GENERIC_ALL_BITS;
		eval.ae_exp_gread = KAUTH_VNODE_GENERIC_READ_BITS;
		eval.ae_exp_gwrite = KAUTH_VNODE_GENERIC_WRITE_BITS;
		eval.ae_exp_gexec = KAUTH_VNODE_GENERIC_EXECUTE_BITS;
		
		<span class="enscript-keyword">if</span> ((error = kauth_acl_evaluate(cred, &amp;eval)) != 0) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ERROR during ACL processing - %d&quot;</span>, vcp-&gt;vp, error);
			<span class="enscript-keyword">return</span>(error);
		}
		
		<span class="enscript-keyword">switch</span>(eval.ae_result) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_RESULT_DENY</span>:
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DENIED - by ACL&quot;</span>, vcp-&gt;vp);
			<span class="enscript-keyword">return</span>(EACCES);		<span class="enscript-comment">/* deny, deny, counter-allege */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_RESULT_ALLOW</span>:
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ALLOWED - all rights granted by ACL&quot;</span>, vcp-&gt;vp);
			<span class="enscript-keyword">return</span>(0);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_RESULT_DEFER</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* Effectively the same as !delete_child_denied */</span>
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DEFERRED - directory ACL&quot;</span>, vcp-&gt;vp);
			<span class="enscript-keyword">break</span>;
		}

		*found_deny = eval.ae_found_deny;

		<span class="enscript-comment">/* fall through and evaluate residual rights */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* no ACL, everything is residual */</span>
		eval.ae_residual = acl_rights;
	}

	<span class="enscript-comment">/*
	 * Grant residual rights that have been pre-authorized.
	 */</span>
	eval.ae_residual &amp;= ~preauth_rights;

	<span class="enscript-comment">/*
	 * We grant WRITE_ATTRIBUTES to the owner if it hasn't been denied.
	 */</span>
	<span class="enscript-keyword">if</span> (vauth_file_owner(vcp))
		eval.ae_residual &amp;= ~KAUTH_VNODE_WRITE_ATTRIBUTES;
	
	<span class="enscript-keyword">if</span> (eval.ae_residual == 0) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ALLOWED - rights already authorized&quot;</span>, vcp-&gt;vp);
		<span class="enscript-keyword">return</span>(0);
	}		
	
	<span class="enscript-comment">/*
	 * Bail if we have residual rights that can't be granted by posix permissions,
	 * or aren't presumed granted at this point.
	 *
	 * XXX these can be collapsed for performance
	 */</span>
	<span class="enscript-keyword">if</span> (eval.ae_residual &amp; KAUTH_VNODE_CHANGE_OWNER) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DENIED - CHANGE_OWNER not permitted&quot;</span>, vcp-&gt;vp);
		<span class="enscript-keyword">return</span>(EACCES);
	}
	<span class="enscript-keyword">if</span> (eval.ae_residual &amp; KAUTH_VNODE_WRITE_SECURITY) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DENIED - WRITE_SECURITY not permitted&quot;</span>, vcp-&gt;vp);
		<span class="enscript-keyword">return</span>(EACCES);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (eval.ae_residual &amp; KAUTH_VNODE_DELETE)
		panic(<span class="enscript-string">&quot;vnode_authorize: can't be checking delete permission here&quot;</span>);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Compute the fallback posix permissions that will satisfy the remaining
	 * rights.
	 */</span>
	posix_action = 0;
	<span class="enscript-keyword">if</span> (eval.ae_residual &amp; (KAUTH_VNODE_READ_DATA |
		KAUTH_VNODE_LIST_DIRECTORY |
		KAUTH_VNODE_READ_EXTATTRIBUTES))
		posix_action |= VREAD;
	<span class="enscript-keyword">if</span> (eval.ae_residual &amp; (KAUTH_VNODE_WRITE_DATA |
		KAUTH_VNODE_ADD_FILE |
		KAUTH_VNODE_ADD_SUBDIRECTORY |
		KAUTH_VNODE_DELETE_CHILD |
		KAUTH_VNODE_WRITE_ATTRIBUTES |
		KAUTH_VNODE_WRITE_EXTATTRIBUTES))
		posix_action |= VWRITE;
	<span class="enscript-keyword">if</span> (eval.ae_residual &amp; (KAUTH_VNODE_EXECUTE |
		KAUTH_VNODE_SEARCH))
		posix_action |= VEXEC;
	
	<span class="enscript-keyword">if</span> (posix_action != 0) {
		<span class="enscript-keyword">return</span>(vnode_authorize_posix(vcp, posix_action, 0 <span class="enscript-comment">/* !on_dir */</span>));
	} <span class="enscript-keyword">else</span> {
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ALLOWED - residual rights %s%s%s%s%s%s%s%s%s%s%s%s%s%s granted due to no posix mapping&quot;</span>,
		    vcp-&gt;vp,
		    (eval.ae_residual &amp; KAUTH_VNODE_READ_DATA)
		    ? vnode_isdir(vcp-&gt;vp) ? <span class="enscript-string">&quot; LIST_DIRECTORY&quot;</span> : <span class="enscript-string">&quot; READ_DATA&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_WRITE_DATA)
		    ? vnode_isdir(vcp-&gt;vp) ? <span class="enscript-string">&quot; ADD_FILE&quot;</span> : <span class="enscript-string">&quot; WRITE_DATA&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_EXECUTE)
		    ? vnode_isdir(vcp-&gt;vp) ? <span class="enscript-string">&quot; SEARCH&quot;</span> : <span class="enscript-string">&quot; EXECUTE&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_DELETE)
		    ? <span class="enscript-string">&quot; DELETE&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_APPEND_DATA)
		    ? vnode_isdir(vcp-&gt;vp) ? <span class="enscript-string">&quot; ADD_SUBDIRECTORY&quot;</span> : <span class="enscript-string">&quot; APPEND_DATA&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_DELETE_CHILD)
		    ? <span class="enscript-string">&quot; DELETE_CHILD&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_READ_ATTRIBUTES)
		    ? <span class="enscript-string">&quot; READ_ATTRIBUTES&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_WRITE_ATTRIBUTES)
		    ? <span class="enscript-string">&quot; WRITE_ATTRIBUTES&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_READ_EXTATTRIBUTES)
		    ? <span class="enscript-string">&quot; READ_EXTATTRIBUTES&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_WRITE_EXTATTRIBUTES)
		    ? <span class="enscript-string">&quot; WRITE_EXTATTRIBUTES&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_READ_SECURITY)
		    ? <span class="enscript-string">&quot; READ_SECURITY&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_WRITE_SECURITY)
		    ? <span class="enscript-string">&quot; WRITE_SECURITY&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_CHECKIMMUTABLE)
		    ? <span class="enscript-string">&quot; CHECKIMMUTABLE&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    (eval.ae_residual &amp; KAUTH_VNODE_CHANGE_OWNER)
		    ? <span class="enscript-string">&quot; CHANGE_OWNER&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * Lack of required Posix permissions implies no reason to deny access.
	 */</span>
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Check for file immutability.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_authorize_checkimmutable</span>(vnode_t vp, <span class="enscript-type">struct</span> vnode_attr *vap, <span class="enscript-type">int</span> rights, <span class="enscript-type">int</span> ignore)
{
	mount_t mp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> append;

	<span class="enscript-comment">/*
	 * Perform immutability checks for operations that change data.
	 *
	 * Sockets, fifos and devices require special handling.
	 */</span>
	<span class="enscript-keyword">switch</span>(vp-&gt;v_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VSOCK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFIFO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
		<span class="enscript-comment">/*
		 * Writing to these nodes does not change the filesystem data,
		 * so forget that it's being tried.
		 */</span>
		rights &amp;= ~KAUTH_VNODE_WRITE_DATA;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	error = 0;
	<span class="enscript-keyword">if</span> (rights &amp; KAUTH_VNODE_WRITE_RIGHTS) {
		
		<span class="enscript-comment">/* check per-filesystem options if possible */</span>
		mp = vp-&gt;v_mount;
		<span class="enscript-keyword">if</span> (mp != NULL) {
	
			<span class="enscript-comment">/* check for no-EA filesystems */</span>
			<span class="enscript-keyword">if</span> ((rights &amp; KAUTH_VNODE_WRITE_EXTATTRIBUTES) &amp;&amp;
			    (vfs_flags(mp) &amp; MNT_NOUSERXATTR)) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DENIED - filesystem disallowed extended attributes&quot;</span>, vp);
				error = EACCES;  <span class="enscript-comment">/* User attributes disabled */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}

		<span class="enscript-comment">/* 
		 * check for file immutability. first, check if the requested rights are 
		 * allowable for a UF_APPEND file.
		 */</span>
		append = 0;
		<span class="enscript-keyword">if</span> (vp-&gt;v_type == VDIR) {
			<span class="enscript-keyword">if</span> ((rights &amp; (KAUTH_VNODE_ADD_FILE | KAUTH_VNODE_ADD_SUBDIRECTORY | KAUTH_VNODE_WRITE_EXTATTRIBUTES)) == rights)
				append = 1;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> ((rights &amp; (KAUTH_VNODE_APPEND_DATA | KAUTH_VNODE_WRITE_EXTATTRIBUTES)) == rights)
				append = 1;
		}
		<span class="enscript-keyword">if</span> ((error = vnode_immutable(vap, append, ignore)) != 0) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DENIED - file is immutable&quot;</span>, vp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Handle authorization actions for filesystems that advertise that the
 * server will be enforcing.
 *
 * Returns:	0			Authorization should be handled locally
 *		1			Authorization was handled by the FS
 *
 * Note:	Imputed returns will only occur if the authorization request
 *		was handled by the FS.
 *
 * Imputed:	*resultp, modified	Return code from FS when the request is
 *					handled by the FS.
 *		VNOP_ACCESS:???
 *		VNOP_OPEN:???
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_authorize_opaque</span>(vnode_t vp, <span class="enscript-type">int</span> *resultp, kauth_action_t action, vfs_context_t ctx)
{
	<span class="enscript-type">int</span>	error;

	<span class="enscript-comment">/*
	 * If the vp is a device node, socket or FIFO it actually represents a local
	 * endpoint, so we need to handle it locally.
	 */</span>
	<span class="enscript-keyword">switch</span>(vp-&gt;v_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VSOCK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFIFO</span>:
		<span class="enscript-keyword">return</span>(0);
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * In the advisory request case, if the filesystem doesn't think it's reliable
	 * we will attempt to formulate a result ourselves based on VNOP_GETATTR data.
	 */</span>
	<span class="enscript-keyword">if</span> ((action &amp; KAUTH_VNODE_ACCESS) &amp;&amp; !vfs_authopaqueaccess(vp-&gt;v_mount))
		<span class="enscript-keyword">return</span>(0);

	<span class="enscript-comment">/*
	 * Let the filesystem have a say in the matter.  It's OK for it to not implemnent
	 * VNOP_ACCESS, as most will authorise inline with the actual request.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = VNOP_ACCESS(vp, action, ctx)) != ENOTSUP) {
		*resultp = error;
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DENIED - opaque filesystem VNOP_ACCESS denied access&quot;</span>, vp);
		<span class="enscript-keyword">return</span>(1);
	}
	
	<span class="enscript-comment">/*
	 * Typically opaque filesystems do authorisation in-line, but exec is a special case.  In
	 * order to be reasonably sure that exec will be permitted, we try a bit harder here.
	 */</span>
	<span class="enscript-keyword">if</span> ((action &amp; KAUTH_VNODE_EXECUTE) &amp;&amp; (vp-&gt;v_type == VREG)) {
		<span class="enscript-comment">/* try a VNOP_OPEN for readonly access */</span>
		<span class="enscript-keyword">if</span> ((error = VNOP_OPEN(vp, FREAD, ctx)) != 0) {
			*resultp = error;
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DENIED - EXECUTE denied because file could not be opened readonly&quot;</span>, vp);
			<span class="enscript-keyword">return</span>(1);
		}
		VNOP_CLOSE(vp, FREAD, ctx);
	}

	<span class="enscript-comment">/*
	 * We don't have any reason to believe that the request has to be denied at this point,
	 * so go ahead and allow it.
	 */</span>
	*resultp = 0;
	KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ALLOWED - bypassing access check for non-local filesystem&quot;</span>, vp);
	<span class="enscript-keyword">return</span>(1);
}




<span class="enscript-comment">/*
 * Returns:	KAUTH_RESULT_ALLOW
 *		KAUTH_RESULT_DENY
 *
 * Imputed:	*arg3, modified		Error code in the deny case
 *		EROFS			Read-only file system
 *		EACCES			Permission denied
 *		EPERM			Operation not permitted [no execute]
 *	vnode_getattr:ENOMEM		Not enough space [only if has filesec]
 *	vnode_getattr:???
 *	vnode_authorize_opaque:*arg2	???
 *	vnode_authorize_checkimmutable:???
 *	vnode_authorize_delete:???
 *	vnode_authorize_simple:???
 */</span>


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_authorize_callback</span>(kauth_cred_t cred, <span class="enscript-type">void</span> *idata, kauth_action_t action,
			 uintptr_t arg0, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3)
{
	vfs_context_t	ctx;
	vnode_t		cvp = NULLVP;
	vnode_t		vp, dvp;
	<span class="enscript-type">int</span>		result = KAUTH_RESULT_DENY;
	<span class="enscript-type">int</span>		parent_iocount = 0;
	<span class="enscript-type">int</span>		parent_action; <span class="enscript-comment">/* In case we need to use namedstream's data fork for cached rights*/</span>

	ctx = (vfs_context_t)arg0;
	vp = (vnode_t)arg1;
	dvp = (vnode_t)arg2;

	<span class="enscript-comment">/*
	 * if there are 2 vnodes passed in, we don't know at
	 * this point which rights to look at based on the 
	 * combined action being passed in... defer until later...
	 * otherwise check the kauth 'rights' cache hung
	 * off of the vnode we're interested in... if we've already
	 * been granted the right we're currently interested in,
	 * we can just return success... otherwise we'll go through
	 * the process of authorizing the requested right(s)... if that
	 * succeeds, we'll add the right(s) to the cache.
	 * VNOP_SETATTR and VNOP_SETXATTR will invalidate this cache
	 */</span>
        <span class="enscript-keyword">if</span> (dvp &amp;&amp; vp)
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">defer</span>;
	<span class="enscript-keyword">if</span> (dvp) {
	        cvp = dvp;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* 
		 * For named streams on local-authorization volumes, rights are cached on the parent;
		 * authorization is determined by looking at the parent's properties anyway, so storing
		 * on the parent means that we don't recompute for the named stream and that if 
		 * we need to flush rights (e.g. on VNOP_SETATTR()) we don't need to track down the
		 * stream to flush its cache separately.  If we miss in the cache, then we authorize
		 * as if there were no cached rights (passing the named stream vnode and desired rights to 
		 * vnode_authorize_callback_int()).
		 *
		 * On an opaquely authorized volume, we don't know the relationship between the 
		 * data fork's properties and the rights granted on a stream.  Thus, named stream vnodes
		 * on such a volume are authorized directly (rather than using the parent) and have their
		 * own caches.  When a named stream vnode is created, we mark the parent as having a named
		 * stream. On a VNOP_SETATTR() for the parent that may invalidate cached authorization, we 
		 * find the stream and flush its cache.
		 */</span>
		<span class="enscript-keyword">if</span> (vnode_isnamedstream(vp) &amp;&amp; (!vfs_authopaque(vp-&gt;v_mount))) {
			cvp = vnode_getparent(vp);
			<span class="enscript-keyword">if</span> (cvp != NULLVP) {
				parent_iocount = 1;
			} <span class="enscript-keyword">else</span> {
				cvp = NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">defer</span>; <span class="enscript-comment">/* If we can't use the parent, take the slow path */</span>
			}

			<span class="enscript-comment">/* Have to translate some actions */</span>
			parent_action = action;
			<span class="enscript-keyword">if</span> (parent_action &amp; KAUTH_VNODE_READ_DATA) {
				parent_action &amp;= ~KAUTH_VNODE_READ_DATA;
				parent_action |= KAUTH_VNODE_READ_EXTATTRIBUTES;
			}
			<span class="enscript-keyword">if</span> (parent_action &amp; KAUTH_VNODE_WRITE_DATA) {
				parent_action &amp;= ~KAUTH_VNODE_WRITE_DATA;
				parent_action |= KAUTH_VNODE_WRITE_EXTATTRIBUTES;
			}

		} <span class="enscript-keyword">else</span> {
			cvp = vp;
		}
	}

	<span class="enscript-keyword">if</span> (vnode_cache_is_authorized(cvp, ctx, parent_iocount ? parent_action : action) == TRUE) {
	 	result = KAUTH_RESULT_ALLOW;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
<span class="enscript-reference">defer</span>:
        result = vnode_authorize_callback_int(cred, idata, action, arg0, arg1, arg2, arg3);

	<span class="enscript-keyword">if</span> (result == KAUTH_RESULT_ALLOW &amp;&amp; cvp != NULLVP) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p - caching action = %x&quot;</span>, cvp, action);
	        vnode_cache_authorized_action(cvp, ctx, action);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (parent_iocount) {
		vnode_put(cvp);
	}

	<span class="enscript-keyword">return</span> result;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_authorize_callback_int</span>(__unused kauth_cred_t unused_cred, __unused <span class="enscript-type">void</span> *idata, kauth_action_t action,
    uintptr_t arg0, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3)
{
	<span class="enscript-type">struct</span> _vnode_authorize_context auth_context;
	vauth_ctx		vcp;
	vfs_context_t		ctx;
	vnode_t			vp, dvp;
	kauth_cred_t		cred;
	kauth_ace_rights_t	rights;
	<span class="enscript-type">struct</span> vnode_attr	va, dva;
	<span class="enscript-type">int</span>			result;
	<span class="enscript-type">int</span>			*errorp;
	<span class="enscript-type">int</span>			noimmutable;
	boolean_t		parent_authorized_for_delete_child = FALSE;
	boolean_t		found_deny = FALSE;
	boolean_t		parent_ref= FALSE;

	vcp = &amp;auth_context;
	ctx = vcp-&gt;ctx = (vfs_context_t)arg0;
	vp = vcp-&gt;vp = (vnode_t)arg1;
	dvp = vcp-&gt;dvp = (vnode_t)arg2;
	errorp = (<span class="enscript-type">int</span> *)arg3;
	<span class="enscript-comment">/*
	 * Note that we authorize against the context, not the passed cred
	 * (the same thing anyway)
	 */</span>
	cred = ctx-&gt;vc_ucred;

	VATTR_INIT(&amp;va);
	vcp-&gt;vap = &amp;va;
	VATTR_INIT(&amp;dva);
	vcp-&gt;dvap = &amp;dva;

	vcp-&gt;flags = vcp-&gt;flags_valid = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> ((ctx == NULL) || (vp == NULL) || (cred == NULL))
		panic(<span class="enscript-string">&quot;vnode_authorize: bad arguments (context %p  vp %p  cred %p)&quot;</span>, ctx, vp, cred);
#<span class="enscript-reference">endif</span>

	KAUTH_DEBUG(<span class="enscript-string">&quot;%p  AUTH - %s %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s on %s '%s' (0x%x:%p/%p)&quot;</span>,
	    vp, vfs_context_proc(ctx)-&gt;p_comm,
	    (action &amp; KAUTH_VNODE_ACCESS)		? <span class="enscript-string">&quot;access&quot;</span> : <span class="enscript-string">&quot;auth&quot;</span>,
	    (action &amp; KAUTH_VNODE_READ_DATA)		? vnode_isdir(vp) ? <span class="enscript-string">&quot; LIST_DIRECTORY&quot;</span> : <span class="enscript-string">&quot; READ_DATA&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_WRITE_DATA)		? vnode_isdir(vp) ? <span class="enscript-string">&quot; ADD_FILE&quot;</span> : <span class="enscript-string">&quot; WRITE_DATA&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_EXECUTE)		? vnode_isdir(vp) ? <span class="enscript-string">&quot; SEARCH&quot;</span> : <span class="enscript-string">&quot; EXECUTE&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_DELETE)		? <span class="enscript-string">&quot; DELETE&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_APPEND_DATA)		? vnode_isdir(vp) ? <span class="enscript-string">&quot; ADD_SUBDIRECTORY&quot;</span> : <span class="enscript-string">&quot; APPEND_DATA&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_DELETE_CHILD)		? <span class="enscript-string">&quot; DELETE_CHILD&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_READ_ATTRIBUTES)	? <span class="enscript-string">&quot; READ_ATTRIBUTES&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_WRITE_ATTRIBUTES)	? <span class="enscript-string">&quot; WRITE_ATTRIBUTES&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_READ_EXTATTRIBUTES)	? <span class="enscript-string">&quot; READ_EXTATTRIBUTES&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_WRITE_EXTATTRIBUTES)	? <span class="enscript-string">&quot; WRITE_EXTATTRIBUTES&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_READ_SECURITY)	? <span class="enscript-string">&quot; READ_SECURITY&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_WRITE_SECURITY)	? <span class="enscript-string">&quot; WRITE_SECURITY&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_CHANGE_OWNER)		? <span class="enscript-string">&quot; CHANGE_OWNER&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    (action &amp; KAUTH_VNODE_NOIMMUTABLE)		? <span class="enscript-string">&quot; (noimmutable)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    vnode_isdir(vp) ? <span class="enscript-string">&quot;directory&quot;</span> : <span class="enscript-string">&quot;file&quot;</span>,
	    vp-&gt;v_name ? vp-&gt;v_name : <span class="enscript-string">&quot;&lt;NULL&gt;&quot;</span>, action, vp, dvp);

	<span class="enscript-comment">/*
	 * Extract the control bits from the action, everything else is
	 * requested rights.
	 */</span>
	noimmutable = (action &amp; KAUTH_VNODE_NOIMMUTABLE) ? 1 : 0;
	rights = action &amp; ~(KAUTH_VNODE_ACCESS | KAUTH_VNODE_NOIMMUTABLE);
 
	<span class="enscript-keyword">if</span> (rights &amp; KAUTH_VNODE_DELETE) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (dvp == NULL)
			panic(<span class="enscript-string">&quot;vnode_authorize: KAUTH_VNODE_DELETE test requires a directory&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/*
		 * check to see if we've already authorized the parent
		 * directory for deletion of its children... if so, we
		 * can skip a whole bunch of work... we will still have to
		 * authorize that this specific child can be removed
		 */</span>
		<span class="enscript-keyword">if</span> (vnode_cache_is_authorized(dvp, ctx, KAUTH_VNODE_DELETE_CHILD) == TRUE)
		        parent_authorized_for_delete_child = TRUE;
	} <span class="enscript-keyword">else</span> {
		dvp = NULL;
	}
	
	<span class="enscript-comment">/*
	 * Check for read-only filesystems.
	 */</span>
	<span class="enscript-keyword">if</span> ((rights &amp; KAUTH_VNODE_WRITE_RIGHTS) &amp;&amp;
	    (vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_RDONLY) &amp;&amp;
	    ((vp-&gt;v_type == VREG) || (vp-&gt;v_type == VDIR) || 
	     (vp-&gt;v_type == VLNK) || (vp-&gt;v_type == VCPLX) || 
	     (rights &amp; KAUTH_VNODE_DELETE) || (rights &amp; KAUTH_VNODE_DELETE_CHILD))) {
		result = EROFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Check for noexec filesystems.
	 */</span>
	<span class="enscript-keyword">if</span> ((rights &amp; KAUTH_VNODE_EXECUTE) &amp;&amp; (vp-&gt;v_type == VREG) &amp;&amp; (vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_NOEXEC)) {
		result = EACCES;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Handle cases related to filesystems with non-local enforcement.
	 * This call can return 0, in which case we will fall through to perform a
	 * check based on VNOP_GETATTR data.  Otherwise it returns 1 and sets
	 * an appropriate result, at which point we can return immediately.
	 */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_AUTH_OPAQUE) &amp;&amp; vnode_authorize_opaque(vp, &amp;result, action, ctx))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * Get vnode attributes and extended security information for the vnode
	 * and directory if required.
	 */</span>
	VATTR_WANTED(&amp;va, va_mode);
	VATTR_WANTED(&amp;va, va_uid);
	VATTR_WANTED(&amp;va, va_gid);
	VATTR_WANTED(&amp;va, va_flags);
	VATTR_WANTED(&amp;va, va_acl);
	<span class="enscript-keyword">if</span> ((result = vnode_getattr(vp, &amp;va, ctx)) != 0) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ERROR - failed to get vnode attributes - %d&quot;</span>, vp, result);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (dvp) {
		VATTR_WANTED(&amp;dva, va_mode);
		VATTR_WANTED(&amp;dva, va_uid);
		VATTR_WANTED(&amp;dva, va_gid);
		VATTR_WANTED(&amp;dva, va_flags);
		VATTR_WANTED(&amp;dva, va_acl);
		<span class="enscript-keyword">if</span> ((result = vnode_getattr(dvp, &amp;dva, ctx)) != 0) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ERROR - failed to get directory vnode attributes - %d&quot;</span>, vp, result);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/*
	 * If the vnode is an extended attribute data vnode (eg. a resource fork), *_DATA becomes
	 * *_EXTATTRIBUTES.
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isnamedstream(vp)) {
		<span class="enscript-keyword">if</span> (rights &amp; KAUTH_VNODE_READ_DATA) {
			rights &amp;= ~KAUTH_VNODE_READ_DATA;
			rights |= KAUTH_VNODE_READ_EXTATTRIBUTES;
		}
		<span class="enscript-keyword">if</span> (rights &amp; KAUTH_VNODE_WRITE_DATA) {
			rights &amp;= ~KAUTH_VNODE_WRITE_DATA;
			rights |= KAUTH_VNODE_WRITE_EXTATTRIBUTES;
		}
	}

	<span class="enscript-comment">/*
	 * Point 'vp' to the resource fork's parent for ACL checking
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isnamedstream(vp) &amp;&amp;
	    (vp-&gt;v_parent != NULL) &amp;&amp;
	    (vget_internal(vp-&gt;v_parent, 0, VNODE_NODEAD | VNODE_DRAINO) == 0)) {
		parent_ref = TRUE;
		vcp-&gt;vp = vp = vp-&gt;v_parent;
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;va, va_acl) &amp;&amp; (va.va_acl != NULL))
			kauth_acl_free(va.va_acl);
		VATTR_INIT(&amp;va);
		VATTR_WANTED(&amp;va, va_mode);
		VATTR_WANTED(&amp;va, va_uid);
		VATTR_WANTED(&amp;va, va_gid);
		VATTR_WANTED(&amp;va, va_flags);
		VATTR_WANTED(&amp;va, va_acl);
		<span class="enscript-keyword">if</span> ((result = vnode_getattr(vp, &amp;va, ctx)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Check for immutability.
	 *
	 * In the deletion case, parent directory immutability vetoes specific
	 * file rights.
	 */</span>
	<span class="enscript-keyword">if</span> ((result = vnode_authorize_checkimmutable(vp, &amp;va, rights, noimmutable)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> ((rights &amp; KAUTH_VNODE_DELETE) &amp;&amp;
	    parent_authorized_for_delete_child == FALSE &amp;&amp;
	    ((result = vnode_authorize_checkimmutable(dvp, &amp;dva, KAUTH_VNODE_DELETE_CHILD, 0)) != 0))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * Clear rights that have been authorized by reaching this point, bail if nothing left to
	 * check.
	 */</span>
	rights &amp;= ~(KAUTH_VNODE_LINKTARGET | KAUTH_VNODE_CHECKIMMUTABLE);
	<span class="enscript-keyword">if</span> (rights == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * If we're not the superuser, authorize based on file properties;
	 * note that even if parent_authorized_for_delete_child is TRUE, we
	 * need to check on the node itself.
	 */</span>
	<span class="enscript-keyword">if</span> (!vfs_context_issuser(ctx)) {
		<span class="enscript-comment">/* process delete rights */</span>
		<span class="enscript-keyword">if</span> ((rights &amp; KAUTH_VNODE_DELETE) &amp;&amp;
		    ((result = vnode_authorize_delete(vcp, parent_authorized_for_delete_child)) != 0))
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		<span class="enscript-comment">/* process remaining rights */</span>
		<span class="enscript-keyword">if</span> ((rights &amp; ~KAUTH_VNODE_DELETE) &amp;&amp;
		    (result = vnode_authorize_simple(vcp, rights, rights &amp; KAUTH_VNODE_DELETE, &amp;found_deny)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	} <span class="enscript-keyword">else</span> {

		<span class="enscript-comment">/*
		 * Execute is only granted to root if one of the x bits is set.  This check only
		 * makes sense if the posix mode bits are actually supported.
		 */</span>
		<span class="enscript-keyword">if</span> ((rights &amp; KAUTH_VNODE_EXECUTE) &amp;&amp;
		    (vp-&gt;v_type == VREG) &amp;&amp;
		    VATTR_IS_SUPPORTED(&amp;va, va_mode) &amp;&amp;
		    !(va.va_mode &amp; (S_IXUSR | S_IXGRP | S_IXOTH))) {
			result = EPERM;
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DENIED - root execute requires at least one x bit in 0x%x&quot;</span>, vp, va.va_mode);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ALLOWED - caller is superuser&quot;</span>, vp);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;va, va_acl) &amp;&amp; (va.va_acl != NULL))
		kauth_acl_free(va.va_acl);
	<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;dva, va_acl) &amp;&amp; (dva.va_acl != NULL))
		kauth_acl_free(dva.va_acl);

	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">if</span> (parent_ref)
			vnode_put(vp);
		*errorp = result;
		KAUTH_DEBUG(<span class="enscript-string">&quot;%p    DENIED - auth denied&quot;</span>, vp);
		<span class="enscript-keyword">return</span>(KAUTH_RESULT_DENY);
	}
	<span class="enscript-keyword">if</span> ((rights &amp; KAUTH_VNODE_SEARCH) &amp;&amp; found_deny == FALSE &amp;&amp; vp-&gt;v_type == VDIR) {
	        <span class="enscript-comment">/*
		 * if we were successfully granted the right to search this directory
		 * and there were NO ACL DENYs for search and the posix permissions also don't
		 * deny execute, we can synthesize a global right that allows anyone to 
		 * traverse this directory during a pathname lookup without having to
		 * match the credential associated with this cache of rights.
		 */</span>
	        <span class="enscript-keyword">if</span> (!VATTR_IS_SUPPORTED(&amp;va, va_mode) ||
		    ((va.va_mode &amp; (S_IXUSR | S_IXGRP | S_IXOTH)) ==
		     (S_IXUSR | S_IXGRP | S_IXOTH))) {
		        vnode_cache_authorized_action(vp, ctx, KAUTH_VNODE_SEARCHBYANYONE);
		}
	}
	<span class="enscript-keyword">if</span> ((rights &amp; KAUTH_VNODE_DELETE) &amp;&amp; parent_authorized_for_delete_child == FALSE) {
	        <span class="enscript-comment">/*
		 * parent was successfully and newly authorized for content deletions
		 * add it to the cache, but only if it doesn't have the sticky
		 * bit set on it.  This same  check is done earlier guarding
		 * fetching of dva, and if we jumped to out without having done
		 * this, we will have returned already because of a non-zero
		 * 'result' value.
		 */</span>
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;dva, va_mode) &amp;&amp;
		    !(dva.va_mode &amp; (S_ISVTX))) {
		    	<span class="enscript-comment">/* OK to cache delete rights */</span>
			KAUTH_DEBUG(<span class="enscript-string">&quot;%p - caching DELETE_CHILD rights&quot;</span>, dvp);
			vnode_cache_authorized_action(dvp, ctx, KAUTH_VNODE_DELETE_CHILD);
		}
	}
	<span class="enscript-keyword">if</span> (parent_ref)
		vnode_put(vp);
	<span class="enscript-comment">/*
	 * Note that this implies that we will allow requests for no rights, as well as
	 * for rights that we do not recognise.  There should be none of these.
	 */</span>
	KAUTH_DEBUG(<span class="enscript-string">&quot;%p    ALLOWED - auth granted&quot;</span>, vp);
	<span class="enscript-keyword">return</span>(KAUTH_RESULT_ALLOW);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_authattr_new</span>(vnode_t dvp, <span class="enscript-type">struct</span> vnode_attr *vap, <span class="enscript-type">int</span> noauth, vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span> vnode_authattr_new_internal(dvp, vap, noauth, NULL, ctx);
}

<span class="enscript-comment">/*
 * Check that the attribute information in vattr can be legally applied to
 * a new file by the context.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_authattr_new_internal</span>(vnode_t dvp, <span class="enscript-type">struct</span> vnode_attr *vap, <span class="enscript-type">int</span> noauth, uint32_t *defaulted_fieldsp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span>		error;
	<span class="enscript-type">int</span>		has_priv_suser, ismember, defaulted_owner, defaulted_group, defaulted_mode;
	kauth_cred_t	cred;
	guid_t		changer;
	mount_t		dmp;

	error = 0;

	<span class="enscript-keyword">if</span> (defaulted_fieldsp) {
		*defaulted_fieldsp = 0;
	}

	defaulted_owner = defaulted_group = defaulted_mode = 0;

	<span class="enscript-comment">/*
	 * Require that the filesystem support extended security to apply any.
	 */</span>
	<span class="enscript-keyword">if</span> (!vfs_extendedsecurity(dvp-&gt;v_mount) &amp;&amp;
	    (VATTR_IS_ACTIVE(vap, va_acl) || VATTR_IS_ACTIVE(vap, va_uuuid) || VATTR_IS_ACTIVE(vap, va_guuid))) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	<span class="enscript-comment">/*
	 * Default some fields.
	 */</span>
	dmp = dvp-&gt;v_mount;

	<span class="enscript-comment">/*
	 * If the filesystem is mounted IGNORE_OWNERSHIP and an explicit owner is set, that
	 * owner takes ownership of all new files.
	 */</span>
	<span class="enscript-keyword">if</span> ((dmp-&gt;mnt_flag &amp; MNT_IGNORE_OWNERSHIP) &amp;&amp; (dmp-&gt;mnt_fsowner != KAUTH_UID_NONE)) {
		VATTR_SET(vap, va_uid, dmp-&gt;mnt_fsowner);
		defaulted_owner = 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_uid)) {
			<span class="enscript-comment">/* default owner is current user */</span>
			VATTR_SET(vap, va_uid, kauth_cred_getuid(vfs_context_ucred(ctx)));
			defaulted_owner = 1;
		}
	}

	<span class="enscript-comment">/*
	 * If the filesystem is mounted IGNORE_OWNERSHIP and an explicit grouo is set, that
	 * group takes ownership of all new files.
	 */</span>
	<span class="enscript-keyword">if</span> ((dmp-&gt;mnt_flag &amp; MNT_IGNORE_OWNERSHIP) &amp;&amp; (dmp-&gt;mnt_fsgroup != KAUTH_GID_NONE)) {
		VATTR_SET(vap, va_gid, dmp-&gt;mnt_fsgroup);
		defaulted_group = 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_gid)) {
			<span class="enscript-comment">/* default group comes from parent object, fallback to current user */</span>
			<span class="enscript-type">struct</span> vnode_attr dva;
			VATTR_INIT(&amp;dva);
			VATTR_WANTED(&amp;dva, va_gid);
			<span class="enscript-keyword">if</span> ((error = vnode_getattr(dvp, &amp;dva, ctx)) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;dva, va_gid)) {
				VATTR_SET(vap, va_gid, dva.va_gid);
			} <span class="enscript-keyword">else</span> {
				VATTR_SET(vap, va_gid, kauth_cred_getgid(vfs_context_ucred(ctx)));
			}
			defaulted_group = 1;
		}
	}

	<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_flags))
		VATTR_SET(vap, va_flags, 0);
	
	<span class="enscript-comment">/* default mode is everything, masked with current umask */</span>
	<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_mode)) {
		VATTR_SET(vap, va_mode, ACCESSPERMS &amp; ~vfs_context_proc(ctx)-&gt;p_fd-&gt;fd_cmask);
		KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - defaulting new file mode to %o from umask %o&quot;</span>, vap-&gt;va_mode, vfs_context_proc(ctx)-&gt;p_fd-&gt;fd_cmask);
		defaulted_mode = 1;
	}
	<span class="enscript-comment">/* set timestamps to now */</span>
	<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_create_time)) {
		nanotime(&amp;vap-&gt;va_create_time);
		VATTR_SET_ACTIVE(vap, va_create_time);
	}
	
	<span class="enscript-comment">/*
	 * Check for attempts to set nonsensical fields.
	 */</span>
	<span class="enscript-keyword">if</span> (vap-&gt;va_active &amp; ~VNODE_ATTR_NEWOBJ) {
		error = EINVAL;
		KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - ERROR - attempt to set unsupported new-file attributes %llx&quot;</span>,
		    vap-&gt;va_active &amp; ~VNODE_ATTR_NEWOBJ);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Quickly check for the applicability of any enforcement here.
	 * Tests below maintain the integrity of the local security model.
	 */</span>
	<span class="enscript-keyword">if</span> (vfs_authopaque(dvp-&gt;v_mount))
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * We need to know if the caller is the superuser, or if the work is
	 * otherwise already authorised.
	 */</span>
	cred = vfs_context_ucred(ctx);
	<span class="enscript-keyword">if</span> (noauth) {
		<span class="enscript-comment">/* doing work for the kernel */</span>
		has_priv_suser = 1;
	} <span class="enscript-keyword">else</span> {
		has_priv_suser = vfs_context_issuser(ctx);
	}


	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_flags)) {
		<span class="enscript-keyword">if</span> (has_priv_suser) {
			<span class="enscript-keyword">if</span> ((vap-&gt;va_flags &amp; (UF_SETTABLE | SF_SETTABLE)) != vap-&gt;va_flags) {
				error = EPERM;
				KAUTH_DEBUG(<span class="enscript-string">&quot;  DENIED - superuser attempt to set illegal flag(s)&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> ((vap-&gt;va_flags &amp; UF_SETTABLE) != vap-&gt;va_flags) {
				error = EPERM;
				KAUTH_DEBUG(<span class="enscript-string">&quot;  DENIED - user attempt to set illegal flag(s)&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}

	<span class="enscript-comment">/* if not superuser, validate legality of new-item attributes */</span>
	<span class="enscript-keyword">if</span> (!has_priv_suser) {
		<span class="enscript-keyword">if</span> (!defaulted_mode &amp;&amp; VATTR_IS_ACTIVE(vap, va_mode)) {
			<span class="enscript-comment">/* setgid? */</span>
			<span class="enscript-keyword">if</span> (vap-&gt;va_mode &amp; S_ISGID) {
				<span class="enscript-keyword">if</span> ((error = kauth_cred_ismember_gid(cred, vap-&gt;va_gid, &amp;ismember)) != 0) {
					KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - ERROR: got %d checking for membership in %d&quot;</span>, error, vap-&gt;va_gid);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				<span class="enscript-keyword">if</span> (!ismember) {
					KAUTH_DEBUG(<span class="enscript-string">&quot;  DENIED - can't set SGID bit, not a member of %d&quot;</span>, vap-&gt;va_gid);
					error = EPERM;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}

			<span class="enscript-comment">/* setuid? */</span>
			<span class="enscript-keyword">if</span> ((vap-&gt;va_mode &amp; S_ISUID) &amp;&amp; (vap-&gt;va_uid != kauth_cred_getuid(cred))) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - ERROR: illegal attempt to set the setuid bit&quot;</span>);
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
		<span class="enscript-keyword">if</span> (!defaulted_owner &amp;&amp; (vap-&gt;va_uid != kauth_cred_getuid(cred))) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;  DENIED - cannot create new item owned by %d&quot;</span>, vap-&gt;va_uid);
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (!defaulted_group) {
			<span class="enscript-keyword">if</span> ((error = kauth_cred_ismember_gid(cred, vap-&gt;va_gid, &amp;ismember)) != 0) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;  ERROR - got %d checking for membership in %d&quot;</span>, error, vap-&gt;va_gid);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> (!ismember) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;  DENIED - cannot create new item with group %d - not a member&quot;</span>, vap-&gt;va_gid);
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}

		<span class="enscript-comment">/* initialising owner/group UUID */</span>
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uuuid)) {
			<span class="enscript-keyword">if</span> ((error = kauth_cred_getguid(cred, &amp;changer)) != 0) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;  ERROR - got %d trying to get caller UUID&quot;</span>, error);
				<span class="enscript-comment">/* XXX ENOENT here - no GUID - should perhaps become EPERM */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> (!kauth_guid_equal(&amp;vap-&gt;va_uuuid, &amp;changer)) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;  ERROR - cannot create item with supplied owner UUID - not us&quot;</span>);
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_guuid)) {
			<span class="enscript-keyword">if</span> ((error = kauth_cred_ismember_guid(cred, &amp;vap-&gt;va_guuid, &amp;ismember)) != 0) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;  ERROR - got %d trying to check group membership&quot;</span>, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> (!ismember) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;  ERROR - cannot create item with supplied group UUID - not a member&quot;</span>);
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}
<span class="enscript-reference">out</span>:	
	<span class="enscript-keyword">if</span> (defaulted_fieldsp) {
		<span class="enscript-keyword">if</span> (defaulted_mode) {
			*defaulted_fieldsp |= VATTR_PREPARE_DEFAULTED_MODE;
		}
		<span class="enscript-keyword">if</span> (defaulted_group) {
			*defaulted_fieldsp |= VATTR_PREPARE_DEFAULTED_GID;
		}
		<span class="enscript-keyword">if</span> (defaulted_owner) {
			*defaulted_fieldsp |= VATTR_PREPARE_DEFAULTED_UID;
		}
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Check that the attribute information in vap can be legally written by the
 * context.
 *
 * Call this when you're not sure about the vnode_attr; either its contents
 * have come from an unknown source, or when they are variable.
 *
 * Returns errno, or zero and sets *actionp to the KAUTH_VNODE_* actions that
 * must be authorized to be permitted to write the vattr.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_authattr</span>(vnode_t vp, <span class="enscript-type">struct</span> vnode_attr *vap, kauth_action_t *actionp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnode_attr ova;
	kauth_action_t	required_action;
	<span class="enscript-type">int</span>		error, has_priv_suser, ismember, chowner, chgroup, clear_suid, clear_sgid;
	guid_t		changer;
	gid_t		group;
	uid_t		owner;
	mode_t		newmode;
	kauth_cred_t	cred;
	uint32_t	fdelta;

	VATTR_INIT(&amp;ova);
	required_action = 0;
	error = 0;

	<span class="enscript-comment">/*
	 * Quickly check for enforcement applicability.
	 */</span>
	<span class="enscript-keyword">if</span> (vfs_authopaque(vp-&gt;v_mount))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	
	<span class="enscript-comment">/*
	 * Check for attempts to set nonsensical fields.
	 */</span>
	<span class="enscript-keyword">if</span> (vap-&gt;va_active &amp; VNODE_ATTR_RDONLY) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - ERROR: attempt to set readonly attribute(s)&quot;</span>);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * We need to know if the caller is the superuser.
	 */</span>
	cred = vfs_context_ucred(ctx);
	has_priv_suser = kauth_cred_issuser(cred);
	
	<span class="enscript-comment">/*
	 * If any of the following are changing, we need information from the old file:
	 * va_uid
	 * va_gid
	 * va_mode
	 * va_uuuid
	 * va_guuid
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uid) ||
	    VATTR_IS_ACTIVE(vap, va_gid) ||
	    VATTR_IS_ACTIVE(vap, va_mode) ||
	    VATTR_IS_ACTIVE(vap, va_uuuid) ||
	    VATTR_IS_ACTIVE(vap, va_guuid)) {
		VATTR_WANTED(&amp;ova, va_mode);
		VATTR_WANTED(&amp;ova, va_uid);
		VATTR_WANTED(&amp;ova, va_gid);
		VATTR_WANTED(&amp;ova, va_uuuid);
		VATTR_WANTED(&amp;ova, va_guuid);
		KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - security information changing, fetching existing attributes&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * If timestamps are being changed, we need to know who the file is owned
	 * by.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_create_time) ||
	    VATTR_IS_ACTIVE(vap, va_change_time) ||
	    VATTR_IS_ACTIVE(vap, va_modify_time) ||
	    VATTR_IS_ACTIVE(vap, va_access_time) ||
	    VATTR_IS_ACTIVE(vap, va_backup_time)) {

		VATTR_WANTED(&amp;ova, va_uid);
#<span class="enscript-reference">if</span> 0	<span class="enscript-comment">/* enable this when we support UUIDs as official owners */</span>
		VATTR_WANTED(&amp;ova, va_uuuid);
#<span class="enscript-reference">endif</span>
		KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - timestamps changing, fetching uid and GUID&quot;</span>);
	}
		
	<span class="enscript-comment">/*
	 * If flags are being changed, we need the old flags.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_flags)) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - flags changing, fetching old flags&quot;</span>);
		VATTR_WANTED(&amp;ova, va_flags);
	}

	<span class="enscript-comment">/*
	 * If ACLs are being changed, we need the old ACLs.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_acl)) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - acl changing, fetching old flags&quot;</span>);
		VATTR_WANTED(&amp;ova, va_acl);
	}

	<span class="enscript-comment">/*
	 * If the size is being set, make sure it's not a directory.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size)) {
		<span class="enscript-comment">/* size is meaningless on a directory, don't permit this */</span>
		<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - ERROR: size change requested on a directory&quot;</span>);
			error = EISDIR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Get old data.
	 */</span>
	KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - fetching old attributes %016llx&quot;</span>, ova.va_active);
	<span class="enscript-keyword">if</span> ((error = vnode_getattr(vp, &amp;ova, ctx)) != 0) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;  ERROR - got %d trying to get attributes&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Size changes require write access to the file data.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size)) {
		<span class="enscript-comment">/* if we can't get the size, or it's different, we need write access */</span>
			KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - size change, requiring WRITE_DATA&quot;</span>);
			required_action |= KAUTH_VNODE_WRITE_DATA;
	}

	<span class="enscript-comment">/*
	 * Changing timestamps?
	 *
	 * Note that we are only called to authorize user-requested time changes;
	 * side-effect time changes are not authorized.  Authorisation is only
	 * required for existing files.
	 *
	 * Non-owners are not permitted to change the time on an existing
	 * file to anything other than the current time.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_create_time) ||
	    VATTR_IS_ACTIVE(vap, va_change_time) ||
	    VATTR_IS_ACTIVE(vap, va_modify_time) ||
	    VATTR_IS_ACTIVE(vap, va_access_time) ||
	    VATTR_IS_ACTIVE(vap, va_backup_time)) {
		<span class="enscript-comment">/*
		 * The owner and root may set any timestamps they like,
		 * provided that the file is not immutable.  The owner still needs
		 * WRITE_ATTRIBUTES (implied by ownership but still deniable).
		 */</span>
		<span class="enscript-keyword">if</span> (has_priv_suser || vauth_node_owner(&amp;ova, cred)) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - root or owner changing timestamps&quot;</span>);
			required_action |= KAUTH_VNODE_CHECKIMMUTABLE | KAUTH_VNODE_WRITE_ATTRIBUTES;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* just setting the current time? */</span>
			<span class="enscript-keyword">if</span> (vap-&gt;va_vaflags &amp; VA_UTIMES_NULL) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - non-root/owner changing timestamps, requiring WRITE_ATTRIBUTES&quot;</span>);
				required_action |= KAUTH_VNODE_WRITE_ATTRIBUTES;
			} <span class="enscript-keyword">else</span> {
				KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - ERROR: illegal timestamp modification attempted&quot;</span>);
				error = EACCES;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}

	<span class="enscript-comment">/*
	 * Changing file mode?
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_mode) &amp;&amp; VATTR_IS_SUPPORTED(&amp;ova, va_mode) &amp;&amp; (ova.va_mode != vap-&gt;va_mode)) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - mode change from %06o to %06o&quot;</span>, ova.va_mode, vap-&gt;va_mode);

		<span class="enscript-comment">/*
		 * Mode changes always have the same basic auth requirements.
		 */</span>
		<span class="enscript-keyword">if</span> (has_priv_suser) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - superuser mode change, requiring immutability check&quot;</span>);
			required_action |= KAUTH_VNODE_CHECKIMMUTABLE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* need WRITE_SECURITY */</span>
			KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - non-superuser mode change, requiring WRITE_SECURITY&quot;</span>);
			required_action |= KAUTH_VNODE_WRITE_SECURITY;
		}

		<span class="enscript-comment">/*
		 * Can't set the setgid bit if you're not in the group and not root.  Have to have
		 * existing group information in the case we're not setting it right now.
		 */</span>
		<span class="enscript-keyword">if</span> (vap-&gt;va_mode &amp; S_ISGID) {
			required_action |= KAUTH_VNODE_CHECKIMMUTABLE;	<span class="enscript-comment">/* always required */</span>
			<span class="enscript-keyword">if</span> (!has_priv_suser) {
				<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_gid)) {
					group = vap-&gt;va_gid;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;ova, va_gid)) {
					group = ova.va_gid;
				} <span class="enscript-keyword">else</span> {
					KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - ERROR: setgid but no gid available&quot;</span>);
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				<span class="enscript-comment">/*
				 * This might be too restrictive; WRITE_SECURITY might be implied by
				 * membership in this case, rather than being an additional requirement.
				 */</span>
				<span class="enscript-keyword">if</span> ((error = kauth_cred_ismember_gid(cred, group, &amp;ismember)) != 0) {
					KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - ERROR: got %d checking for membership in %d&quot;</span>, error, vap-&gt;va_gid);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				<span class="enscript-keyword">if</span> (!ismember) {
					KAUTH_DEBUG(<span class="enscript-string">&quot;  DENIED - can't set SGID bit, not a member of %d&quot;</span>, group);
					error = EPERM;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}
		}

		<span class="enscript-comment">/*
		 * Can't set the setuid bit unless you're root or the file's owner.
		 */</span>
		<span class="enscript-keyword">if</span> (vap-&gt;va_mode &amp; S_ISUID) {
			required_action |= KAUTH_VNODE_CHECKIMMUTABLE;	<span class="enscript-comment">/* always required */</span>
			<span class="enscript-keyword">if</span> (!has_priv_suser) {
				<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uid)) {
					owner = vap-&gt;va_uid;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;ova, va_uid)) {
					owner = ova.va_uid;
				} <span class="enscript-keyword">else</span> {
					KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - ERROR: setuid but no uid available&quot;</span>);
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				<span class="enscript-keyword">if</span> (owner != kauth_cred_getuid(cred)) {
					<span class="enscript-comment">/*
					 * We could allow this if WRITE_SECURITY is permitted, perhaps.
					 */</span>
					KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - ERROR: illegal attempt to set the setuid bit&quot;</span>);
					error = EPERM;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}
		}
	}
	    
	<span class="enscript-comment">/*
	 * Validate/mask flags changes.  This checks that only the flags in
	 * the UF_SETTABLE mask are being set, and preserves the flags in
	 * the SF_SETTABLE case.
	 *
	 * Since flags changes may be made in conjunction with other changes,
	 * we will ask the auth code to ignore immutability in the case that
	 * the SF_* flags are not set and we are only manipulating the file flags.
	 * 
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_flags)) {
		<span class="enscript-comment">/* compute changing flags bits */</span>
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;ova, va_flags)) {
			fdelta = vap-&gt;va_flags ^ ova.va_flags;
		} <span class="enscript-keyword">else</span> {
			fdelta = vap-&gt;va_flags;
		}

		<span class="enscript-keyword">if</span> (fdelta != 0) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - flags changing, requiring WRITE_SECURITY&quot;</span>);
			required_action |= KAUTH_VNODE_WRITE_SECURITY;

			<span class="enscript-comment">/* check that changing bits are legal */</span>
			<span class="enscript-keyword">if</span> (has_priv_suser) {
				<span class="enscript-comment">/*
				 * The immutability check will prevent us from clearing the SF_*
				 * flags unless the system securelevel permits it, so just check
				 * for legal flags here.
				 */</span>
				<span class="enscript-keyword">if</span> (fdelta &amp; ~(UF_SETTABLE | SF_SETTABLE)) {
					error = EPERM;
					KAUTH_DEBUG(<span class="enscript-string">&quot;  DENIED - superuser attempt to set illegal flag(s)&quot;</span>);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (fdelta &amp; ~UF_SETTABLE) {
					error = EPERM;
					KAUTH_DEBUG(<span class="enscript-string">&quot;  DENIED - user attempt to set illegal flag(s)&quot;</span>);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}
			<span class="enscript-comment">/*
			 * If the caller has the ability to manipulate file flags,
			 * security is not reduced by ignoring them for this operation.
			 *
			 * A more complete test here would consider the 'after' states of the flags
			 * to determine whether it would permit the operation, but this becomes
			 * very complex.
			 *
			 * Ignoring immutability is conditional on securelevel; this does not bypass
			 * the SF_* flags if securelevel &gt; 0.
			 */</span>
			required_action |= KAUTH_VNODE_NOIMMUTABLE;
		}
	}

	<span class="enscript-comment">/*
	 * Validate ownership information.
	 */</span>
	chowner = 0;
	chgroup = 0;
	clear_suid = 0;
	clear_sgid = 0;

	<span class="enscript-comment">/*
	 * uid changing
	 * Note that if the filesystem didn't give us a UID, we expect that it doesn't
	 * support them in general, and will ignore it if/when we try to set it.
	 * We might want to clear the uid out of vap completely here.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uid)) {
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;ova, va_uid) &amp;&amp; (vap-&gt;va_uid != ova.va_uid)) {
		<span class="enscript-keyword">if</span> (!has_priv_suser &amp;&amp; (kauth_cred_getuid(cred) != vap-&gt;va_uid)) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;  DENIED - non-superuser cannot change ownershipt to a third party&quot;</span>);
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		chowner = 1;
	}
		clear_suid = 1;
	}
	
	<span class="enscript-comment">/*
	 * gid changing
	 * Note that if the filesystem didn't give us a GID, we expect that it doesn't
	 * support them in general, and will ignore it if/when we try to set it.
	 * We might want to clear the gid out of vap completely here.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_gid)) {
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;ova, va_gid) &amp;&amp; (vap-&gt;va_gid != ova.va_gid)) {
		<span class="enscript-keyword">if</span> (!has_priv_suser) {
			<span class="enscript-keyword">if</span> ((error = kauth_cred_ismember_gid(cred, vap-&gt;va_gid, &amp;ismember)) != 0) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;  ERROR - got %d checking for membership in %d&quot;</span>, error, vap-&gt;va_gid);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> (!ismember) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;  DENIED - group change from %d to %d but not a member of target group&quot;</span>,
				    ova.va_gid, vap-&gt;va_gid);
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
		chgroup = 1;
	}
		clear_sgid = 1;
	}

	<span class="enscript-comment">/*
	 * Owner UUID being set or changed.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uuuid)) {
		<span class="enscript-comment">/* if the owner UUID is not actually changing ... */</span>
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;ova, va_uuuid)) {
			<span class="enscript-keyword">if</span> (kauth_guid_equal(&amp;vap-&gt;va_uuuid, &amp;ova.va_uuuid))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_uuuid_change</span>;
			
			<span class="enscript-comment">/*
			 * If the current owner UUID is a null GUID, check
			 * it against the UUID corresponding to the owner UID.
			 */</span>
			<span class="enscript-keyword">if</span> (kauth_guid_equal(&amp;ova.va_uuuid, &amp;kauth_null_guid) &amp;&amp;
			    VATTR_IS_SUPPORTED(&amp;ova, va_uid)) {
				guid_t uid_guid;

				<span class="enscript-keyword">if</span> (kauth_cred_uid2guid(ova.va_uid, &amp;uid_guid) == 0 &amp;&amp;
				    kauth_guid_equal(&amp;vap-&gt;va_uuuid, &amp;uid_guid))
				    	<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_uuuid_change</span>;
			}
		}
		
		<span class="enscript-comment">/*
		 * The owner UUID cannot be set by a non-superuser to anything other than
		 * their own or a null GUID (to &quot;unset&quot; the owner UUID).
		 * Note that file systems must be prepared to handle the
		 * null UUID case in a manner appropriate for that file
		 * system.
		 */</span>
		<span class="enscript-keyword">if</span> (!has_priv_suser) {
			<span class="enscript-keyword">if</span> ((error = kauth_cred_getguid(cred, &amp;changer)) != 0) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;  ERROR - got %d trying to get caller UUID&quot;</span>, error);
				<span class="enscript-comment">/* XXX ENOENT here - no UUID - should perhaps become EPERM */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> (!kauth_guid_equal(&amp;vap-&gt;va_uuuid, &amp;changer) &amp;&amp;
			    !kauth_guid_equal(&amp;vap-&gt;va_uuuid, &amp;kauth_null_guid)) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;  ERROR - cannot set supplied owner UUID - not us / null&quot;</span>);
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
		chowner = 1;
		clear_suid = 1;
	}
<span class="enscript-reference">no_uuuid_change</span>:
	<span class="enscript-comment">/*
	 * Group UUID being set or changed.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_guuid)) {
		<span class="enscript-comment">/* if the group UUID is not actually changing ... */</span>
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;ova, va_guuid)) {
			<span class="enscript-keyword">if</span> (kauth_guid_equal(&amp;vap-&gt;va_guuid, &amp;ova.va_guuid))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_guuid_change</span>;

			<span class="enscript-comment">/*
			 * If the current group UUID is a null UUID, check
			 * it against the UUID corresponding to the group GID.
			 */</span>
			<span class="enscript-keyword">if</span> (kauth_guid_equal(&amp;ova.va_guuid, &amp;kauth_null_guid) &amp;&amp;
			    VATTR_IS_SUPPORTED(&amp;ova, va_gid)) {
				guid_t gid_guid;

				<span class="enscript-keyword">if</span> (kauth_cred_gid2guid(ova.va_gid, &amp;gid_guid) == 0 &amp;&amp;
				    kauth_guid_equal(&amp;vap-&gt;va_guuid, &amp;gid_guid))
				    	<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_guuid_change</span>;
			}
		}

		<span class="enscript-comment">/*
		 * The group UUID cannot be set by a non-superuser to anything other than
		 * one of which they are a member or a null GUID (to &quot;unset&quot;
		 * the group UUID).
		 * Note that file systems must be prepared to handle the
		 * null UUID case in a manner appropriate for that file
		 * system.
		 */</span>
		<span class="enscript-keyword">if</span> (!has_priv_suser) {
			<span class="enscript-keyword">if</span> (kauth_guid_equal(&amp;vap-&gt;va_guuid, &amp;kauth_null_guid))
				ismember = 1;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((error = kauth_cred_ismember_guid(cred, &amp;vap-&gt;va_guuid, &amp;ismember)) != 0) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;  ERROR - got %d trying to check group membership&quot;</span>, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> (!ismember) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;  ERROR - cannot set supplied group UUID - not a member / null&quot;</span>);
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
		chgroup = 1;
	}
<span class="enscript-reference">no_guuid_change</span>:

	<span class="enscript-comment">/*
	 * Compute authorisation for group/ownership changes.
	 */</span>
	<span class="enscript-keyword">if</span> (chowner || chgroup || clear_suid || clear_sgid) {
		<span class="enscript-keyword">if</span> (has_priv_suser) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - superuser changing file owner/group, requiring immutability check&quot;</span>);
			required_action |= KAUTH_VNODE_CHECKIMMUTABLE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (chowner) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - ownership change, requiring TAKE_OWNERSHIP&quot;</span>);
				required_action |= KAUTH_VNODE_TAKE_OWNERSHIP;
			}
			<span class="enscript-keyword">if</span> (chgroup &amp;&amp; !chowner) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;ATTR - group change, requiring WRITE_SECURITY&quot;</span>);
				required_action |= KAUTH_VNODE_WRITE_SECURITY;
			}
			
			<span class="enscript-comment">/* clear set-uid and set-gid bits as required by Posix */</span>
			<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_mode)) {
				newmode = vap-&gt;va_mode;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;ova, va_mode)) {
				newmode = ova.va_mode;
			} <span class="enscript-keyword">else</span> {
				KAUTH_DEBUG(<span class="enscript-string">&quot;CHOWN - trying to change owner but cannot get mode from filesystem to mask setugid bits&quot;</span>);
				newmode = 0;
			}
			<span class="enscript-keyword">if</span> (newmode &amp; (S_ISUID | S_ISGID)) {
				VATTR_SET(vap, va_mode, newmode &amp; ~(S_ISUID | S_ISGID));
				KAUTH_DEBUG(<span class="enscript-string">&quot;CHOWN - masking setugid bits from mode %o to %o&quot;</span>, newmode, vap-&gt;va_mode);
			}
		}
	}

	<span class="enscript-comment">/*
	 * Authorise changes in the ACL.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_acl)) {

		<span class="enscript-comment">/* no existing ACL */</span>
		<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(&amp;ova, va_acl) || (ova.va_acl == NULL)) {

			<span class="enscript-comment">/* adding an ACL */</span>
			<span class="enscript-keyword">if</span> (vap-&gt;va_acl != NULL) {
				required_action |= KAUTH_VNODE_WRITE_SECURITY;
				KAUTH_DEBUG(<span class="enscript-string">&quot;CHMOD - adding ACL&quot;</span>);
			}

			<span class="enscript-comment">/* removing an existing ACL */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vap-&gt;va_acl == NULL) {
			required_action |= KAUTH_VNODE_WRITE_SECURITY;
			KAUTH_DEBUG(<span class="enscript-string">&quot;CHMOD - removing ACL&quot;</span>);

			<span class="enscript-comment">/* updating an existing ACL */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (vap-&gt;va_acl-&gt;acl_entrycount != ova.va_acl-&gt;acl_entrycount) {
				<span class="enscript-comment">/* entry count changed, must be different */</span>
				required_action |= KAUTH_VNODE_WRITE_SECURITY;
				KAUTH_DEBUG(<span class="enscript-string">&quot;CHMOD - adding/removing ACL entries&quot;</span>);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vap-&gt;va_acl-&gt;acl_entrycount &gt; 0) {
				<span class="enscript-comment">/* both ACLs have the same ACE count, said count is 1 or more, bitwise compare ACLs */</span>
				<span class="enscript-keyword">if</span> (memcmp(&amp;vap-&gt;va_acl-&gt;acl_ace[0], &amp;ova.va_acl-&gt;acl_ace[0],
					<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kauth_ace) * vap-&gt;va_acl-&gt;acl_entrycount)) {
					required_action |= KAUTH_VNODE_WRITE_SECURITY;
					KAUTH_DEBUG(<span class="enscript-string">&quot;CHMOD - changing ACL entries&quot;</span>);
				}
			}
		}
	}

	<span class="enscript-comment">/*
	 * Other attributes that require authorisation.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_encoding))
		required_action |= KAUTH_VNODE_WRITE_ATTRIBUTES;
	
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;ova, va_acl) &amp;&amp; (ova.va_acl != NULL))
		kauth_acl_free(ova.va_acl);
	<span class="enscript-keyword">if</span> (error == 0)
		*actionp = required_action;
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">setlocklocal_callback</span>(<span class="enscript-type">struct</span> vnode *vp, __unused <span class="enscript-type">void</span> *cargs)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag |= VLOCKLOCAL;
	vnode_unlock(vp);

	<span class="enscript-keyword">return</span> (VNODE_RETURNED);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_setlocklocal</span>(mount_t mp)
{
	mount_lock_spin(mp);
	mp-&gt;mnt_kern_flag |= MNTK_LOCK_LOCAL;
	mount_unlock(mp);

	<span class="enscript-comment">/*
	 * The number of active vnodes is expected to be
	 * very small when vfs_setlocklocal is invoked.
	 */</span>
	vnode_iterate(mp, 0, setlocklocal_callback, NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_setcompoundopen</span>(mount_t mp)
{
	mount_lock_spin(mp);
	mp-&gt;mnt_compound_ops |= COMPOUND_VNOP_OPEN;
	mount_unlock(mp);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_setswapmount</span>(vnode_t vp)
{
	mount_lock(vp-&gt;v_mount);
	vp-&gt;v_mount-&gt;mnt_kern_flag |= MNTK_SWAP_MOUNT;
	mount_unlock(vp-&gt;v_mount);
}


int64_t
<span class="enscript-function-name">vnode_getswappin_avail</span>(vnode_t vp)
{
	int64_t	max_swappin_avail = 0;

	mount_lock(vp-&gt;v_mount);
	<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_ioflags &amp; MNT_IOFLAGS_SWAPPIN_SUPPORTED)
		max_swappin_avail = vp-&gt;v_mount-&gt;mnt_max_swappin_available;
	mount_unlock(vp-&gt;v_mount);

	<span class="enscript-keyword">return</span> (max_swappin_avail);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vn_setunionwait</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag |= VISUNION;
	vnode_unlock(vp);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vn_checkunionwait</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	<span class="enscript-keyword">while</span> ((vp-&gt;v_flag &amp; VISUNION) == VISUNION)
		msleep((caddr_t)&amp;vp-&gt;v_flag, &amp;vp-&gt;v_lock, 0, 0, 0);
	vnode_unlock(vp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vn_clearunionwait</span>(vnode_t vp, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (!locked)
		vnode_lock_spin(vp);
	<span class="enscript-keyword">if</span>((vp-&gt;v_flag &amp; VISUNION) == VISUNION) {
		vp-&gt;v_flag &amp;= ~VISUNION;
		wakeup((caddr_t)&amp;vp-&gt;v_flag);
	}
	<span class="enscript-keyword">if</span> (!locked)
		vnode_unlock(vp);
}

<span class="enscript-comment">/* 
 * Removes orphaned apple double files during a rmdir
 * Works by:
 * 1. vnode_suspend().
 * 2. Call VNOP_READDIR() till the end of directory is reached.  
 * 3. Check if the directory entries returned are regular files with name starting with &quot;._&quot;.  If not, return ENOTEMPTY.  
 * 4. Continue (2) and (3) till end of directory is reached.
 * 5. If all the entries in the directory were files with &quot;._&quot; name, delete all the files.
 * 6. vnode_resume()
 * 7. If deletion of all files succeeded, call VNOP_RMDIR() again.
 */</span>

errno_t <span class="enscript-function-name">rmdir_remove_orphaned_appleDouble</span>(vnode_t vp , vfs_context_t ctx, <span class="enscript-type">int</span> * restart_flag) 
{

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UIO_BUFF_SIZE</span> 2048
	uio_t auio = NULL;
	<span class="enscript-type">int</span> eofflag, siz = UIO_BUFF_SIZE, nentries = 0;
	<span class="enscript-type">int</span> open_flag = 0, full_erase_flag = 0;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];
	<span class="enscript-type">char</span> *rbuf = NULL;
   	<span class="enscript-type">void</span> *dir_pos;
	<span class="enscript-type">void</span> *dir_end;
	<span class="enscript-type">struct</span> dirent *dp;
	errno_t error;

	error = vnode_suspend(vp);

	<span class="enscript-comment">/*
	 * restart_flag is set so that the calling rmdir sleeps and resets
	 */</span>
	<span class="enscript-keyword">if</span> (error == EBUSY)
		*restart_flag = 1;
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * set up UIO
	 */</span>
	MALLOC(rbuf, caddr_t, siz, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (rbuf)
		auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_READ,
				&amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	<span class="enscript-keyword">if</span> (!rbuf || !auio) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outsc</span>;
	}

	uio_setoffset(auio,0);

	eofflag = 0;

	<span class="enscript-keyword">if</span> ((error = VNOP_OPEN(vp, FREAD, ctx))) 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">outsc</span>; 	
	<span class="enscript-keyword">else</span>
		open_flag = 1;

	<span class="enscript-comment">/*
	 * First pass checks if all files are appleDouble files.
	 */</span>

	<span class="enscript-keyword">do</span> {
		siz = UIO_BUFF_SIZE;
		uio_reset(auio, uio_offset(auio), UIO_SYSSPACE, UIO_READ);
		uio_addiov(auio, CAST_USER_ADDR_T(rbuf), UIO_BUFF_SIZE);

		<span class="enscript-keyword">if</span>((error = VNOP_READDIR(vp, auio, 0, &amp;eofflag, &amp;nentries, ctx)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outsc</span>;

		<span class="enscript-keyword">if</span> (uio_resid(auio) != 0) 
			siz -= uio_resid(auio);

		<span class="enscript-comment">/*
		 * Iterate through directory
		 */</span>
		dir_pos = (<span class="enscript-type">void</span>*) rbuf;
		dir_end = (<span class="enscript-type">void</span>*) (rbuf + siz);
		dp = (<span class="enscript-type">struct</span> dirent*) (dir_pos);

		<span class="enscript-keyword">if</span> (dir_pos == dir_end)
			eofflag = 1;

		<span class="enscript-keyword">while</span> (dir_pos &lt; dir_end) {
			<span class="enscript-comment">/*
			 * Check for . and .. as well as directories
			 */</span>
			<span class="enscript-keyword">if</span> (dp-&gt;d_ino != 0 &amp;&amp; 
					!((dp-&gt;d_namlen == 1 &amp;&amp; dp-&gt;d_name[0] == <span class="enscript-string">'.'</span>) ||
					    (dp-&gt;d_namlen == 2 &amp;&amp; dp-&gt;d_name[0] == <span class="enscript-string">'.'</span> &amp;&amp; dp-&gt;d_name[1] == <span class="enscript-string">'.'</span>))) {
				<span class="enscript-comment">/*
				 * Check for irregular files and ._ files
				 * If there is a ._._ file abort the op
				 */</span>
				<span class="enscript-keyword">if</span> ( dp-&gt;d_namlen &lt; 2 ||
						strncmp(dp-&gt;d_name,<span class="enscript-string">&quot;._&quot;</span>,2) ||
						(dp-&gt;d_namlen &gt;= 4 &amp;&amp; !strncmp(&amp;(dp-&gt;d_name[2]), <span class="enscript-string">&quot;._&quot;</span>,2))) {
					error = ENOTEMPTY;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">outsc</span>;
				}
			}
			dir_pos = (<span class="enscript-type">void</span>*) ((uint8_t*)dir_pos + dp-&gt;d_reclen);
			dp = (<span class="enscript-type">struct</span> dirent*)dir_pos;
		}
		
		<span class="enscript-comment">/*
		 * workaround for HFS/NFS setting eofflag before end of file 
		 */</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_tag == VT_HFS &amp;&amp; nentries &gt; 2)
			eofflag=0;

		<span class="enscript-keyword">if</span> (vp-&gt;v_tag == VT_NFS) {
			<span class="enscript-keyword">if</span> (eofflag &amp;&amp; !full_erase_flag) {
				full_erase_flag = 1;
				eofflag = 0;
				uio_reset(auio, 0, UIO_SYSSPACE, UIO_READ);
			}
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!eofflag &amp;&amp; full_erase_flag)
				full_erase_flag = 0;
		}

	} <span class="enscript-keyword">while</span> (!eofflag);
	<span class="enscript-comment">/*
	 * If we've made it here all the files in the dir are ._ files.
	 * We can delete the files even though the node is suspended
	 * because we are the owner of the file.
	 */</span>

	uio_reset(auio, 0, UIO_SYSSPACE, UIO_READ);
	eofflag = 0;
	full_erase_flag = 0;

	<span class="enscript-keyword">do</span> {
		siz = UIO_BUFF_SIZE;
		uio_reset(auio, uio_offset(auio), UIO_SYSSPACE, UIO_READ);
		uio_addiov(auio, CAST_USER_ADDR_T(rbuf), UIO_BUFF_SIZE);

		error = VNOP_READDIR(vp, auio, 0, &amp;eofflag, &amp;nentries, ctx);

		<span class="enscript-keyword">if</span> (error != 0) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">outsc</span>;

		<span class="enscript-keyword">if</span> (uio_resid(auio) != 0) 
			siz -= uio_resid(auio);

		<span class="enscript-comment">/*
		 * Iterate through directory
		 */</span>
		dir_pos = (<span class="enscript-type">void</span>*) rbuf;
		dir_end = (<span class="enscript-type">void</span>*) (rbuf + siz);
		dp = (<span class="enscript-type">struct</span> dirent*) dir_pos;
		
		<span class="enscript-keyword">if</span> (dir_pos == dir_end)
			eofflag = 1;
	
		<span class="enscript-keyword">while</span> (dir_pos &lt; dir_end) {
			<span class="enscript-comment">/*
			 * Check for . and .. as well as directories
			 */</span>
			<span class="enscript-keyword">if</span> (dp-&gt;d_ino != 0 &amp;&amp; 
					!((dp-&gt;d_namlen == 1 &amp;&amp; dp-&gt;d_name[0] == <span class="enscript-string">'.'</span>) ||
					    (dp-&gt;d_namlen == 2 &amp;&amp; dp-&gt;d_name[0] == <span class="enscript-string">'.'</span> &amp;&amp; dp-&gt;d_name[1] == <span class="enscript-string">'.'</span>))
					  ) {
	
				error = unlink1(ctx, vp,
				    CAST_USER_ADDR_T(dp-&gt;d_name), UIO_SYSSPACE,
				    VNODE_REMOVE_SKIP_NAMESPACE_EVENT |
				    VNODE_REMOVE_NO_AUDIT_PATH);

				<span class="enscript-keyword">if</span> (error &amp;&amp;  error != ENOENT) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">outsc</span>;
				}

			}
			dir_pos = (<span class="enscript-type">void</span>*) ((uint8_t*)dir_pos + dp-&gt;d_reclen);
			dp = (<span class="enscript-type">struct</span> dirent*)dir_pos;
		}
		
		<span class="enscript-comment">/*
		 * workaround for HFS/NFS setting eofflag before end of file 
		 */</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_tag == VT_HFS &amp;&amp; nentries &gt; 2)
			eofflag=0;

		<span class="enscript-keyword">if</span> (vp-&gt;v_tag == VT_NFS) {
			<span class="enscript-keyword">if</span> (eofflag &amp;&amp; !full_erase_flag) {
				full_erase_flag = 1;
				eofflag = 0;
				uio_reset(auio, 0, UIO_SYSSPACE, UIO_READ);
			}
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!eofflag &amp;&amp; full_erase_flag)
				full_erase_flag = 0;
		}

	} <span class="enscript-keyword">while</span> (!eofflag);


	error = 0;

<span class="enscript-reference">outsc</span>:
	<span class="enscript-keyword">if</span> (open_flag)
		VNOP_CLOSE(vp, FREAD, ctx);

	<span class="enscript-keyword">if</span> (auio)
		uio_free(auio);
	FREE(rbuf, M_TEMP);

	vnode_resume(vp);


	<span class="enscript-keyword">return</span>(error);

}


<span class="enscript-type">void</span> 
<span class="enscript-function-name">lock_vnode_and_post</span>(vnode_t vp, <span class="enscript-type">int</span> kevent_num) 
{
	<span class="enscript-comment">/* Only take the lock if there's something there! */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_knotes.slh_first != NULL) {
		vnode_lock(vp);
		KNOTE(&amp;vp-&gt;v_knotes, kevent_num);
		vnode_unlock(vp);
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">panic_print_vnodes</span>(<span class="enscript-type">void</span>);
<span class="enscript-comment">/* define PANIC_PRINTS_VNODES only if investigation is required. */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PANIC_PRINTS_VNODES</span>

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">__vtype</span>(uint16_t vtype)
{
	<span class="enscript-keyword">switch</span> (vtype) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VREG</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;R&quot;</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VDIR</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;D&quot;</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;B&quot;</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;C&quot;</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VLNK</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;L&quot;</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VSOCK</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;S&quot;</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFIFO</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;F&quot;</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VBAD</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;x&quot;</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VSTR</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;T&quot;</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VCPLX</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;X&quot;</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;?&quot;</span>;
	}
}

<span class="enscript-comment">/*
 * build a path from the bottom up
 * NOTE: called from the panic path - no alloc'ing of memory and no locks!
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">__vpath</span>(vnode_t vp, <span class="enscript-type">char</span> *str, <span class="enscript-type">int</span> len, <span class="enscript-type">int</span> depth)
{
	<span class="enscript-type">int</span> vnm_len;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *src;
	<span class="enscript-type">char</span> *dst;

	<span class="enscript-keyword">if</span> (len &lt;= 0)
		<span class="enscript-keyword">return</span> str;
	<span class="enscript-comment">/* str + len is the start of the string we created */</span>
	<span class="enscript-keyword">if</span> (!vp-&gt;v_name)
		<span class="enscript-keyword">return</span> str + len;

	<span class="enscript-comment">/* follow mount vnodes to get the full path */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VROOT)) {
		<span class="enscript-keyword">if</span> (vp-&gt;v_mount != NULL &amp;&amp; vp-&gt;v_mount-&gt;mnt_vnodecovered) {
			<span class="enscript-keyword">return</span> __vpath(vp-&gt;v_mount-&gt;mnt_vnodecovered,
				       str, len, depth+1);
		}
		<span class="enscript-keyword">return</span> str + len;
	}

	src = vp-&gt;v_name;
	vnm_len = strlen(src);
	<span class="enscript-keyword">if</span> (vnm_len &gt; len) {
		<span class="enscript-comment">/* truncate the name to fit in the string */</span>
		src += (vnm_len - len);
		vnm_len = len;
	}

	<span class="enscript-comment">/* start from the back and copy just characters (no NULLs) */</span>

	<span class="enscript-comment">/* this will chop off leaf path (file) names */</span>
	<span class="enscript-keyword">if</span> (depth &gt; 0) {
		dst = str + len - vnm_len;
		memcpy(dst, src, vnm_len);
		len -= vnm_len;
	} <span class="enscript-keyword">else</span> {
		dst = str + len;
	}

	<span class="enscript-keyword">if</span> (vp-&gt;v_parent &amp;&amp; len &gt; 1) {
		<span class="enscript-comment">/* follow parents up the chain */</span>
		len--;
		*(dst-1) = <span class="enscript-string">'/'</span>;
		<span class="enscript-keyword">return</span> __vpath(vp-&gt;v_parent, str, len, depth + 1);
	}

	<span class="enscript-keyword">return</span> dst;
}

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kdb_printf</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *format, ...) __printflike(1,2);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SANE_VNODE_PRINT_LIMIT</span> 5000
<span class="enscript-type">void</span> <span class="enscript-function-name">panic_print_vnodes</span>(<span class="enscript-type">void</span>)
{
	mount_t mnt;
	vnode_t vp;
	<span class="enscript-type">int</span> nvnodes = 0;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *type;
	<span class="enscript-type">char</span> *nm;
	<span class="enscript-type">char</span> vname[257];

	kdb_printf(<span class="enscript-string">&quot;\n***** VNODES *****\n&quot;</span>
		   <span class="enscript-string">&quot;TYPE UREF ICNT PATH\n&quot;</span>);

	<span class="enscript-comment">/* NULL-terminate the path name */</span>
	vname[<span class="enscript-keyword">sizeof</span>(vname)-1] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-comment">/*
	 * iterate all vnodelist items in all mounts (mntlist) -&gt; mnt_vnodelist
	 */</span>
	TAILQ_FOREACH(mnt, &amp;mountlist, mnt_list) {
		TAILQ_FOREACH(vp, &amp;mnt-&gt;mnt_vnodelist, v_mntvnodes) {
			<span class="enscript-keyword">if</span> (++nvnodes &gt; SANE_VNODE_PRINT_LIMIT)
				<span class="enscript-keyword">return</span>;
			type = __vtype(vp-&gt;v_type);
			nm = __vpath(vp, vname, <span class="enscript-keyword">sizeof</span>(vname)-1, 0);
			kdb_printf(<span class="enscript-string">&quot;%s %0d %0d %s\n&quot;</span>,
				   type, vp-&gt;v_usecount, vp-&gt;v_iocount, nm);
		}
	}
}

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !PANIC_PRINTS_VNODES */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">panic_print_vnodes</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>;
}
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">record_vp</span>(vnode_t vp, <span class="enscript-type">int</span> count) {
        <span class="enscript-type">struct</span> uthread *ut;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_resolve)
		<span class="enscript-keyword">return</span>;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VSYSTEM))
	        <span class="enscript-keyword">return</span>;

	ut = get_bsdthread_info(current_thread());
        ut-&gt;uu_iocount += count;

	<span class="enscript-keyword">if</span> (count == 1) {
		<span class="enscript-keyword">if</span> (ut-&gt;uu_vpindex &lt; 32) {
			OSBacktrace((<span class="enscript-type">void</span> **)&amp;ut-&gt;uu_pcs[ut-&gt;uu_vpindex][0], 10);

			ut-&gt;uu_vps[ut-&gt;uu_vpindex] = vp;
			ut-&gt;uu_vpindex++;
		}
	}
}
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TRIG_DEBUG</span> 0

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRIG_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TRIG_LOG</span>(...) do { printf(<span class="enscript-string">&quot;%s: &quot;</span>, __FUNCTION__); printf(__VA_ARGS__); } while (0)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TRIG_LOG</span>(...)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Resolver result functions
 */</span>

resolver_result_t
<span class="enscript-function-name">vfs_resolver_result</span>(uint32_t seq, <span class="enscript-type">enum</span> resolver_status stat, <span class="enscript-type">int</span> aux)
{
	<span class="enscript-comment">/*
	 * |&lt;---   32   ---&gt;|&lt;---  28  ---&gt;|&lt;- 4 -&gt;|
	 *      sequence        auxiliary    status
	 */</span>
	<span class="enscript-keyword">return</span> (((uint64_t)seq) &lt;&lt; 32) |		
	       (((uint64_t)(aux &amp; 0x0fffffff)) &lt;&lt; 4) |	
	       (uint64_t)(stat &amp; 0x0000000F);	
}

<span class="enscript-type">enum</span> resolver_status
<span class="enscript-function-name">vfs_resolver_status</span>(resolver_result_t result)
{
	<span class="enscript-comment">/* lower 4 bits is status */</span>
	<span class="enscript-keyword">return</span> (result &amp; 0x0000000F);
}

uint32_t
<span class="enscript-function-name">vfs_resolver_sequence</span>(resolver_result_t result)
{
	<span class="enscript-comment">/* upper 32 bits is sequence */</span>
	<span class="enscript-keyword">return</span> (uint32_t)(result &gt;&gt; 32);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_resolver_auxiliary</span>(resolver_result_t result)
{
	<span class="enscript-comment">/* 28 bits of auxiliary */</span>
	<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)(((uint32_t)(result &amp; 0xFFFFFFF0)) &gt;&gt; 4);
}

<span class="enscript-comment">/*
 * SPI
 * Call in for resolvers to update vnode trigger state
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_trigger_update</span>(vnode_t vp, resolver_result_t result)
{
	vnode_resolve_t rp;
	uint32_t seq;
	<span class="enscript-type">enum</span> resolver_status stat;

	<span class="enscript-keyword">if</span> (vp-&gt;v_resolve == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	stat = vfs_resolver_status(result);
	seq = vfs_resolver_sequence(result);

	<span class="enscript-keyword">if</span> ((stat != RESOLVER_RESOLVED) &amp;&amp; (stat != RESOLVER_UNRESOLVED)) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	rp = vp-&gt;v_resolve;
	lck_mtx_lock(&amp;rp-&gt;vr_lock);

	<span class="enscript-keyword">if</span> (seq &gt; rp-&gt;vr_lastseq) {
		<span class="enscript-keyword">if</span> (stat == RESOLVER_RESOLVED)
			rp-&gt;vr_flags |= VNT_RESOLVED;
		<span class="enscript-keyword">else</span>
			rp-&gt;vr_flags &amp;= ~VNT_RESOLVED;

		rp-&gt;vr_lastseq = seq;
	}

	lck_mtx_unlock(&amp;rp-&gt;vr_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_resolver_attach</span>(vnode_t vp, vnode_resolve_t rp, boolean_t ref)
{
	<span class="enscript-type">int</span> error;

	vnode_lock_spin(vp);
	<span class="enscript-keyword">if</span> (vp-&gt;v_resolve != NULL) {
		vnode_unlock(vp);
		<span class="enscript-keyword">return</span> EINVAL;
	} <span class="enscript-keyword">else</span> {
		vp-&gt;v_resolve = rp;
	}
	vnode_unlock(vp);
	
	<span class="enscript-keyword">if</span> (ref) {
		error = vnode_ref_ext(vp, O_EVTONLY, VNODE_REF_FORCE);
		<span class="enscript-keyword">if</span> (error != 0) {
			panic(<span class="enscript-string">&quot;VNODE_REF_FORCE didn't help...&quot;</span>);
		}
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * VFS internal interfaces for vnode triggers
 *
 * vnode must already have an io count on entry
 * v_resolve is stable when io count is non-zero
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_resolver_create</span>(mount_t mp, vnode_t vp, <span class="enscript-type">struct</span> vnode_trigger_param *tinfo, boolean_t external)
{
	vnode_resolve_t rp;
	<span class="enscript-type">int</span> result;
	<span class="enscript-type">char</span> byte;

#<span class="enscript-reference">if</span> 1
	<span class="enscript-comment">/* minimum pointer test (debugging) */</span>
	<span class="enscript-keyword">if</span> (tinfo-&gt;vnt_data)
		byte = *((<span class="enscript-type">char</span> *)tinfo-&gt;vnt_data);
#<span class="enscript-reference">endif</span>
	MALLOC(rp, vnode_resolve_t, <span class="enscript-keyword">sizeof</span>(*rp), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (rp == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	lck_mtx_init(&amp;rp-&gt;vr_lock, trigger_vnode_lck_grp, trigger_vnode_lck_attr);

	rp-&gt;vr_resolve_func = tinfo-&gt;vnt_resolve_func;
	rp-&gt;vr_unresolve_func = tinfo-&gt;vnt_unresolve_func;
	rp-&gt;vr_rearm_func = tinfo-&gt;vnt_rearm_func;
	rp-&gt;vr_reclaim_func = tinfo-&gt;vnt_reclaim_func;
	rp-&gt;vr_data = tinfo-&gt;vnt_data;
	rp-&gt;vr_lastseq = 0;
	rp-&gt;vr_flags = tinfo-&gt;vnt_flags &amp; VNT_VALID_MASK;
	<span class="enscript-keyword">if</span> (external) {
		rp-&gt;vr_flags |= VNT_EXTERNAL;
	}

	result = vnode_resolver_attach(vp, rp, external);
	<span class="enscript-keyword">if</span> (result != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (mp) {
		OSAddAtomic(1, &amp;mp-&gt;mnt_numtriggers);
	}

	<span class="enscript-keyword">return</span> (result);

<span class="enscript-reference">out</span>:
	FREE(rp, M_TEMP);
	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_resolver_release</span>(vnode_resolve_t rp)
{
	<span class="enscript-comment">/*
	 * Give them a chance to free any private data
	 */</span>
	<span class="enscript-keyword">if</span> (rp-&gt;vr_data &amp;&amp; rp-&gt;vr_reclaim_func) {
		rp-&gt;vr_reclaim_func(NULLVP, rp-&gt;vr_data);
	}

	lck_mtx_destroy(&amp;rp-&gt;vr_lock, trigger_vnode_lck_grp);
	FREE(rp, M_TEMP);

}

<span class="enscript-comment">/* Called after the vnode has been drained */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_resolver_detach</span>(vnode_t vp)
{
	vnode_resolve_t rp;
	mount_t	mp;

	mp = vnode_mount(vp);

	vnode_lock(vp);
	rp = vp-&gt;v_resolve;
	vp-&gt;v_resolve = NULL;
	vnode_unlock(vp);

	<span class="enscript-keyword">if</span> ((rp-&gt;vr_flags &amp; VNT_EXTERNAL) != 0) {
		vnode_rele_ext(vp, O_EVTONLY, 1);
	} 

	vnode_resolver_release(rp);
	
	<span class="enscript-comment">/* Keep count of active trigger vnodes per mount */</span>
	OSAddAtomic(-1, &amp;mp-&gt;mnt_numtriggers);	
}

__private_extern__
<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_trigger_rearm</span>(vnode_t vp, vfs_context_t ctx)
{
	vnode_resolve_t rp;
	resolver_result_t result;
	<span class="enscript-type">enum</span> resolver_status status;
	uint32_t seq;

	<span class="enscript-keyword">if</span> ((vp-&gt;v_resolve == NULL) ||
	    (vp-&gt;v_resolve-&gt;vr_rearm_func == NULL) ||
	    (vp-&gt;v_resolve-&gt;vr_flags &amp; VNT_AUTO_REARM) == 0) {
		<span class="enscript-keyword">return</span>;
	}

	rp = vp-&gt;v_resolve;
	lck_mtx_lock(&amp;rp-&gt;vr_lock);

	<span class="enscript-comment">/*
	 * Check if VFS initiated this unmount. If so, we'll catch it after the unresolve completes.
	 */</span>
	<span class="enscript-keyword">if</span> (rp-&gt;vr_flags &amp; VNT_VFS_UNMOUNTED) {
		lck_mtx_unlock(&amp;rp-&gt;vr_lock);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Check if this vnode is already armed */</span>
	<span class="enscript-keyword">if</span> ((rp-&gt;vr_flags &amp; VNT_RESOLVED) == 0) {
		lck_mtx_unlock(&amp;rp-&gt;vr_lock);
		<span class="enscript-keyword">return</span>;
	}

	lck_mtx_unlock(&amp;rp-&gt;vr_lock);

	result = rp-&gt;vr_rearm_func(vp, 0, rp-&gt;vr_data, ctx);
	status = vfs_resolver_status(result);
	seq = vfs_resolver_sequence(result);

	lck_mtx_lock(&amp;rp-&gt;vr_lock);
	<span class="enscript-keyword">if</span> (seq &gt; rp-&gt;vr_lastseq) {
		<span class="enscript-keyword">if</span> (status == RESOLVER_UNRESOLVED)
			rp-&gt;vr_flags &amp;= ~VNT_RESOLVED;
		rp-&gt;vr_lastseq = seq;
	}
	lck_mtx_unlock(&amp;rp-&gt;vr_lock);
}

__private_extern__
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_trigger_resolve</span>(vnode_t vp, <span class="enscript-type">struct</span> nameidata *ndp, vfs_context_t ctx)
{
	vnode_resolve_t rp;
	<span class="enscript-type">enum</span> path_operation op;
	resolver_result_t result;
	<span class="enscript-type">enum</span> resolver_status status;
	uint32_t seq;

	<span class="enscript-comment">/* Only trigger on topmost vnodes */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_resolve == NULL) ||
	    (vp-&gt;v_resolve-&gt;vr_resolve_func == NULL) ||
	    (vp-&gt;v_mountedhere != NULL)) {
		<span class="enscript-keyword">return</span> (0);
	}

	rp = vp-&gt;v_resolve;
	lck_mtx_lock(&amp;rp-&gt;vr_lock);

	<span class="enscript-comment">/* Check if this vnode is already resolved */</span>
	<span class="enscript-keyword">if</span> (rp-&gt;vr_flags &amp; VNT_RESOLVED) {
		lck_mtx_unlock(&amp;rp-&gt;vr_lock);
		<span class="enscript-keyword">return</span> (0);
	}

	lck_mtx_unlock(&amp;rp-&gt;vr_lock);

	<span class="enscript-comment">/*
	 * XXX
	 * assumes that resolver will not access this trigger vnode (otherwise the kernel will deadlock)
	 * is there anyway to know this???
	 * there can also be other legitimate lookups in parallel
	 *
	 * XXX - should we call this on a separate thread with a timeout?
	 * 
	 * XXX - should we use ISLASTCN to pick the op value???  Perhaps only leafs should
	 * get the richer set and non-leafs should get generic OP_LOOKUP?  TBD
	 */</span>
	op = (ndp-&gt;ni_op &lt; OP_MAXOP) ? ndp-&gt;ni_op: OP_LOOKUP;

	result = rp-&gt;vr_resolve_func(vp, &amp;ndp-&gt;ni_cnd, op, 0, rp-&gt;vr_data, ctx);
	status = vfs_resolver_status(result);
	seq = vfs_resolver_sequence(result);

	lck_mtx_lock(&amp;rp-&gt;vr_lock);
	<span class="enscript-keyword">if</span> (seq &gt; rp-&gt;vr_lastseq) {
		<span class="enscript-keyword">if</span> (status == RESOLVER_RESOLVED)
			rp-&gt;vr_flags |= VNT_RESOLVED;
		rp-&gt;vr_lastseq = seq;
	}
	lck_mtx_unlock(&amp;rp-&gt;vr_lock);

	<span class="enscript-comment">/* On resolver errors, propagate the error back up */</span>
	<span class="enscript-keyword">return</span> (status == RESOLVER_ERROR ? vfs_resolver_auxiliary(result) : 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_trigger_unresolve</span>(vnode_t vp, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	vnode_resolve_t rp;
	resolver_result_t result;
	<span class="enscript-type">enum</span> resolver_status status;
	uint32_t seq;

	<span class="enscript-keyword">if</span> ((vp-&gt;v_resolve == NULL) || (vp-&gt;v_resolve-&gt;vr_unresolve_func == NULL)) {
		<span class="enscript-keyword">return</span> (0);
	}

	rp = vp-&gt;v_resolve;
	lck_mtx_lock(&amp;rp-&gt;vr_lock);

	<span class="enscript-comment">/* Check if this vnode is already resolved */</span>
	<span class="enscript-keyword">if</span> ((rp-&gt;vr_flags &amp; VNT_RESOLVED) == 0) {
		printf(<span class="enscript-string">&quot;vnode_trigger_unresolve: not currently resolved\n&quot;</span>);
		lck_mtx_unlock(&amp;rp-&gt;vr_lock);
		<span class="enscript-keyword">return</span> (0);
	}

	rp-&gt;vr_flags |= VNT_VFS_UNMOUNTED;

	lck_mtx_unlock(&amp;rp-&gt;vr_lock);

	<span class="enscript-comment">/*
	 * XXX
	 * assumes that resolver will not access this trigger vnode (otherwise the kernel will deadlock)
	 * there can also be other legitimate lookups in parallel
	 *
	 * XXX - should we call this on a separate thread with a timeout?
	 */</span>

	result = rp-&gt;vr_unresolve_func(vp, flags, rp-&gt;vr_data, ctx);
	status = vfs_resolver_status(result);
	seq = vfs_resolver_sequence(result);

	lck_mtx_lock(&amp;rp-&gt;vr_lock);
	<span class="enscript-keyword">if</span> (seq &gt; rp-&gt;vr_lastseq) {
		<span class="enscript-keyword">if</span> (status == RESOLVER_UNRESOLVED)
			rp-&gt;vr_flags &amp;= ~VNT_RESOLVED;
		rp-&gt;vr_lastseq = seq;
	}
	rp-&gt;vr_flags &amp;= ~VNT_VFS_UNMOUNTED;
	lck_mtx_unlock(&amp;rp-&gt;vr_lock);

	<span class="enscript-comment">/* On resolver errors, propagate the error back up */</span>
	<span class="enscript-keyword">return</span> (status == RESOLVER_ERROR ? vfs_resolver_auxiliary(result) : 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">triggerisdescendant</span>(mount_t mp, mount_t rmp)
{
	<span class="enscript-type">int</span> match = FALSE;

	<span class="enscript-comment">/*
	 * walk up vnode covered chain looking for a match
	 */</span>
	name_cache_lock_shared();

	<span class="enscript-keyword">while</span> (1) {
		vnode_t vp;

		<span class="enscript-comment">/* did we encounter &quot;/&quot; ? */</span>
		<span class="enscript-keyword">if</span> (mp-&gt;mnt_flag &amp; MNT_ROOTFS)
			<span class="enscript-keyword">break</span>;

		vp = mp-&gt;mnt_vnodecovered;
		<span class="enscript-keyword">if</span> (vp == NULLVP)
			<span class="enscript-keyword">break</span>;

		mp = vp-&gt;v_mount;
		<span class="enscript-keyword">if</span> (mp == rmp) {
			match = TRUE;
			<span class="enscript-keyword">break</span>;
		}
	}

	name_cache_unlock();

	<span class="enscript-keyword">return</span> (match);
}

<span class="enscript-type">struct</span> trigger_unmount_info {
	vfs_context_t	ctx;
	mount_t		top_mp;
	vnode_t		trigger_vp;
	mount_t		trigger_mp;
	uint32_t	trigger_vid;
	<span class="enscript-type">int</span>		flags;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">trigger_unmount_callback</span>(mount_t mp, <span class="enscript-type">void</span> * arg)
{
	<span class="enscript-type">struct</span> trigger_unmount_info * infop = (<span class="enscript-type">struct</span> trigger_unmount_info *)arg;
	boolean_t mountedtrigger = FALSE;

	<span class="enscript-comment">/*
	 * When we encounter the top level mount we're done
	 */</span>
	<span class="enscript-keyword">if</span> (mp == infop-&gt;top_mp)
		<span class="enscript-keyword">return</span> (VFS_RETURNED_DONE);

	<span class="enscript-keyword">if</span> ((mp-&gt;mnt_vnodecovered == NULL) ||
	    (vnode_getwithref(mp-&gt;mnt_vnodecovered) != 0)) {
		<span class="enscript-keyword">return</span> (VFS_RETURNED);
	}

	<span class="enscript-keyword">if</span> ((mp-&gt;mnt_vnodecovered-&gt;v_mountedhere == mp) &amp;&amp;
	    (mp-&gt;mnt_vnodecovered-&gt;v_resolve != NULL) &amp;&amp;
	    (mp-&gt;mnt_vnodecovered-&gt;v_resolve-&gt;vr_flags &amp; VNT_RESOLVED)) {
		mountedtrigger = TRUE;
	}
	vnode_put(mp-&gt;mnt_vnodecovered);

	<span class="enscript-comment">/*
	 * When we encounter a mounted trigger, check if its under the top level mount
	 */</span>
	<span class="enscript-keyword">if</span> ( !mountedtrigger || !triggerisdescendant(mp, infop-&gt;top_mp) )
		<span class="enscript-keyword">return</span> (VFS_RETURNED);

	<span class="enscript-comment">/*
	 * Process any pending nested mount (now that its not referenced)
	 */</span>
	<span class="enscript-keyword">if</span> ((infop-&gt;trigger_vp != NULLVP) &amp;&amp;
	    (vnode_getwithvid(infop-&gt;trigger_vp, infop-&gt;trigger_vid) == 0)) {
		vnode_t vp = infop-&gt;trigger_vp;
		<span class="enscript-type">int</span> error;

		infop-&gt;trigger_vp = NULLVP;
		
		<span class="enscript-keyword">if</span> (mp == vp-&gt;v_mountedhere) {
			vnode_put(vp);
			printf(<span class="enscript-string">&quot;trigger_unmount_callback: unexpected match '%s'\n&quot;</span>,
				mp-&gt;mnt_vfsstat.f_mntonname);
			<span class="enscript-keyword">return</span> (VFS_RETURNED);
		}
		<span class="enscript-keyword">if</span> (infop-&gt;trigger_mp != vp-&gt;v_mountedhere) {
			vnode_put(vp);
			printf(<span class="enscript-string">&quot;trigger_unmount_callback: trigger mnt changed! (%p != %p)\n&quot;</span>,
				infop-&gt;trigger_mp, vp-&gt;v_mountedhere);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">savenext</span>;
		}

		error = vnode_trigger_unresolve(vp, infop-&gt;flags, infop-&gt;ctx);
		vnode_put(vp);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;unresolving: '%s', err %d\n&quot;</span>,
				vp-&gt;v_mountedhere ? vp-&gt;v_mountedhere-&gt;mnt_vfsstat.f_mntonname :
				<span class="enscript-string">&quot;???&quot;</span>, error);
			<span class="enscript-keyword">return</span> (VFS_RETURNED_DONE); <span class="enscript-comment">/* stop iteration on errors */</span>
		}
	}
<span class="enscript-reference">savenext</span>:
	<span class="enscript-comment">/*
	 * We can't call resolver here since we hold a mount iter
	 * ref on mp so save its covered vp for later processing
	 */</span>
	infop-&gt;trigger_vp = mp-&gt;mnt_vnodecovered;
	<span class="enscript-keyword">if</span> ((infop-&gt;trigger_vp != NULLVP) &amp;&amp;
	    (vnode_getwithref(infop-&gt;trigger_vp) == 0)) {
		<span class="enscript-keyword">if</span> (infop-&gt;trigger_vp-&gt;v_mountedhere == mp) {
			infop-&gt;trigger_vid = infop-&gt;trigger_vp-&gt;v_id;
			infop-&gt;trigger_mp = mp;
		}
		vnode_put(infop-&gt;trigger_vp);
	}

	<span class="enscript-keyword">return</span> (VFS_RETURNED);
}

<span class="enscript-comment">/*
 * Attempt to unmount any trigger mounts nested underneath a mount.
 * This is a best effort attempt and no retries are performed here.
 *
 * Note: mp-&gt;mnt_rwlock is held exclusively on entry (so be carefull)
 */</span>
__private_extern__
<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_nested_trigger_unmounts</span>(mount_t mp, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> trigger_unmount_info info;

	<span class="enscript-comment">/* Must have trigger vnodes */</span>
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_numtriggers == 0) {
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/* Avoid recursive requests (by checking covered vnode) */</span>
	<span class="enscript-keyword">if</span> ((mp-&gt;mnt_vnodecovered != NULL) &amp;&amp;
	    (vnode_getwithref(mp-&gt;mnt_vnodecovered) == 0)) {
		boolean_t recursive = FALSE;

		<span class="enscript-keyword">if</span> ((mp-&gt;mnt_vnodecovered-&gt;v_mountedhere == mp) &amp;&amp;
		    (mp-&gt;mnt_vnodecovered-&gt;v_resolve != NULL) &amp;&amp;
		    (mp-&gt;mnt_vnodecovered-&gt;v_resolve-&gt;vr_flags &amp; VNT_VFS_UNMOUNTED)) {
			recursive = TRUE;
		}
		vnode_put(mp-&gt;mnt_vnodecovered);
		<span class="enscript-keyword">if</span> (recursive)
			<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * Attempt to unmount any nested trigger mounts (best effort)
	 */</span>
	info.ctx = ctx;
	info.top_mp = mp;
	info.trigger_vp = NULLVP;
	info.trigger_vid = 0;
	info.trigger_mp = NULL;
	info.flags = flags;

	(<span class="enscript-type">void</span>) vfs_iterate(VFS_ITERATE_TAIL_FIRST, trigger_unmount_callback, &amp;info);

	<span class="enscript-comment">/*
	 * Process remaining nested mount (now that its not referenced)
	 */</span>
	<span class="enscript-keyword">if</span> ((info.trigger_vp != NULLVP) &amp;&amp;
	    (vnode_getwithvid(info.trigger_vp, info.trigger_vid) == 0)) {
		vnode_t vp = info.trigger_vp;

		<span class="enscript-keyword">if</span> (info.trigger_mp == vp-&gt;v_mountedhere) {
			(<span class="enscript-type">void</span>) vnode_trigger_unresolve(vp, flags, ctx);
		}
		vnode_put(vp);
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_addtrigger</span>(mount_t mp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *relpath, <span class="enscript-type">struct</span> vnode_trigger_info *vtip, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">int</span> res;
	vnode_t rvp, vp;
	<span class="enscript-type">struct</span> vnode_trigger_param vtp;
	
	<span class="enscript-comment">/* 
	 * Must be called for trigger callback, wherein rwlock is held 
	 */</span>
	lck_rw_assert(&amp;mp-&gt;mnt_rwlock, LCK_RW_ASSERT_HELD);

	TRIG_LOG(<span class="enscript-string">&quot;Adding trigger at %s\n&quot;</span>, relpath);
	TRIG_LOG(<span class="enscript-string">&quot;Trying VFS_ROOT\n&quot;</span>);

	<span class="enscript-comment">/* 
	 * We do a lookup starting at the root of the mountpoint, unwilling
	 * to cross into other mountpoints.
	 */</span>
	res = VFS_ROOT(mp, &amp;rvp, ctx);
	<span class="enscript-keyword">if</span> (res != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	TRIG_LOG(<span class="enscript-string">&quot;Trying namei\n&quot;</span>);

	NDINIT(&amp;nd, LOOKUP, OP_LOOKUP, USEDVP | NOCROSSMOUNT | FOLLOW, UIO_SYSSPACE,
		CAST_USER_ADDR_T(relpath), ctx);
	nd.ni_dvp = rvp;
	res = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (res != 0) {
		vnode_put(rvp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	vp = nd.ni_vp;
	nameidone(&amp;nd);
	vnode_put(rvp);

	TRIG_LOG(<span class="enscript-string">&quot;Trying vnode_resolver_create()\n&quot;</span>);

	<span class="enscript-comment">/* 
	 * Set up blob.  vnode_create() takes a larger structure
	 * with creation info, and we needed something different
	 * for this case.  One needs to win, or we need to munge both;
	 * vnode_create() wins.
	 */</span>
	bzero(&amp;vtp, <span class="enscript-keyword">sizeof</span>(vtp));
	vtp.vnt_resolve_func = vtip-&gt;vti_resolve_func;
	vtp.vnt_unresolve_func = vtip-&gt;vti_unresolve_func;
	vtp.vnt_rearm_func = vtip-&gt;vti_rearm_func;
	vtp.vnt_reclaim_func = vtip-&gt;vti_reclaim_func;
	vtp.vnt_reclaim_func = vtip-&gt;vti_reclaim_func;
	vtp.vnt_data = vtip-&gt;vti_data;
	vtp.vnt_flags = vtip-&gt;vti_flags;

	res = vnode_resolver_create(mp, vp, &amp;vtp, TRUE);
	vnode_put(vp);
<span class="enscript-reference">out</span>:
	TRIG_LOG(<span class="enscript-string">&quot;Returning %d\n&quot;</span>, res);
	<span class="enscript-keyword">return</span> res;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_TRIGGERS */</span>
</pre>
<hr />
</body></html>