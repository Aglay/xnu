<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_init.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_init.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed
 * to Berkeley by John Heidemann of the UCLA Ficus project.
 *
 * Source: * @(#)i405_init.c 2.10 92/04/27 UCLA Ficus project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)vfs_init.c	8.5 (Berkeley) 5/11/95
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vfs/vfs_journal.h&gt;</span>	<span class="enscript-comment">/* journal_init() */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/quota.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Sigh, such primitive tools are these...
 */</span>
#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DODEBUG</span>(A) A
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DODEBUG</span>(A)
#<span class="enscript-reference">endif</span>

__private_extern__ <span class="enscript-type">void</span> vntblinit(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> vnodeopv_desc *vfs_opv_descs[];
				<span class="enscript-comment">/* a list of lists of vnodeops defns */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> vnodeop_desc *vfs_op_descs[];
				<span class="enscript-comment">/* and the operations they perform */</span>
<span class="enscript-comment">/*
 * This code doesn't work if the defn is **vnodop_defns with cc.
 * The problem is because of the compiler sometimes putting in an
 * extra level of indirection for arrays.  It's an interesting
 * &quot;feature&quot; of C.
 */</span>
<span class="enscript-type">int</span> vfs_opv_numops;

<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*PFIvp)(<span class="enscript-type">void</span> *); 

<span class="enscript-comment">/*
 * A miscellaneous routine.
 * A generic &quot;default&quot; routine that just returns an error.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_default_error</span>(<span class="enscript-type">void</span>)
{

	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-comment">/*
 * vfs_init.c
 *
 * Allocate and fill in operations vectors.
 *
 * An undocumented feature of this approach to defining operations is that
 * there can be multiple entries in vfs_opv_descs for the same operations
 * vector. This allows third parties to extend the set of operations
 * supported by another layer in a binary compatibile way. For example,
 * assume that NFS needed to be modified to support Ficus. NFS has an entry
 * (probably nfs_vnopdeop_decls) declaring all the operations NFS supports by
 * default. Ficus could add another entry (ficus_nfs_vnodeop_decl_entensions)
 * listing those new operations Ficus adds to NFS, all without modifying the
 * NFS code. (Of couse, the OTW NFS protocol still needs to be munged, but
 * that is a(whole)nother story.) This is a feature.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_opv_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i, j, k;
	<span class="enscript-type">int</span> (***opv_desc_vector_p)(<span class="enscript-type">void</span> *);
	<span class="enscript-type">int</span> (**opv_desc_vector)(<span class="enscript-type">void</span> *);
	<span class="enscript-type">struct</span> vnodeopv_entry_desc *opve_descp;

	<span class="enscript-comment">/*
	 * Allocate the dynamic vectors and fill them in.
	 */</span>
	<span class="enscript-keyword">for</span> (i=0; vfs_opv_descs[i]; i++) {
		opv_desc_vector_p = vfs_opv_descs[i]-&gt;opv_desc_vector_p;
		<span class="enscript-comment">/*
		 * Allocate and init the vector, if it needs it.
		 * Also handle backwards compatibility.
		 */</span>
		<span class="enscript-keyword">if</span> (*opv_desc_vector_p == NULL) {
			MALLOC(*opv_desc_vector_p, PFIvp*,
			       vfs_opv_numops*<span class="enscript-keyword">sizeof</span>(PFIvp), M_TEMP, M_WAITOK);
			bzero (*opv_desc_vector_p, vfs_opv_numops*<span class="enscript-keyword">sizeof</span>(PFIvp));
			DODEBUG(printf(<span class="enscript-string">&quot;vector at %x allocated\n&quot;</span>,
			    opv_desc_vector_p));
		}
		opv_desc_vector = *opv_desc_vector_p;
		<span class="enscript-keyword">for</span> (j=0; vfs_opv_descs[i]-&gt;opv_desc_ops[j].opve_op; j++) {
			opve_descp = &amp;(vfs_opv_descs[i]-&gt;opv_desc_ops[j]);

			<span class="enscript-comment">/*
			 * Sanity check:  is this operation listed
			 * in the list of operations?  We check this
			 * by seeing if its offest is zero.  Since
			 * the default routine should always be listed
			 * first, it should be the only one with a zero
			 * offset.  Any other operation with a zero
			 * offset is probably not listed in
			 * vfs_op_descs, and so is probably an error.
			 *
			 * A panic here means the layer programmer
			 * has committed the all-too common bug
			 * of adding a new operation to the layer's
			 * list of vnode operations but
			 * not adding the operation to the system-wide
			 * list of supported operations.
			 */</span>
			<span class="enscript-keyword">if</span> (opve_descp-&gt;opve_op-&gt;vdesc_offset == 0 &amp;&amp;
				    opve_descp-&gt;opve_op-&gt;vdesc_offset !=
				    	VOFFSET(vnop_default)) {
				printf(<span class="enscript-string">&quot;operation %s not listed in %s.\n&quot;</span>,
				    opve_descp-&gt;opve_op-&gt;vdesc_name,
				    <span class="enscript-string">&quot;vfs_op_descs&quot;</span>);
				panic (<span class="enscript-string">&quot;vfs_opv_init: bad operation&quot;</span>);
			}
			<span class="enscript-comment">/*
			 * Fill in this entry.
			 */</span>
			opv_desc_vector[opve_descp-&gt;opve_op-&gt;vdesc_offset] =
					opve_descp-&gt;opve_impl;
		}
	}
	<span class="enscript-comment">/*
	 * Finally, go back and replace unfilled routines
	 * with their default.  (Sigh, an O(n^3) algorithm.  I
	 * could make it better, but that'd be work, and n is small.)
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; vfs_opv_descs[i]; i++) {
		opv_desc_vector = *(vfs_opv_descs[i]-&gt;opv_desc_vector_p);
		<span class="enscript-comment">/*
		 * Force every operations vector to have a default routine.
		 */</span>
		<span class="enscript-keyword">if</span> (opv_desc_vector[VOFFSET(vnop_default)]==NULL) {
			panic(<span class="enscript-string">&quot;vfs_opv_init: operation vector without default routine.&quot;</span>);
		}
		<span class="enscript-keyword">for</span> (k = 0; k&lt;vfs_opv_numops; k++)
			<span class="enscript-keyword">if</span> (opv_desc_vector[k] == NULL)
				opv_desc_vector[k] = 
					opv_desc_vector[VOFFSET(vnop_default)];
	}
}

<span class="enscript-comment">/*
 * Initialize known vnode operations vectors.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_op_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;

	DODEBUG(printf(<span class="enscript-string">&quot;Vnode_interface_init.\n&quot;</span>));
	<span class="enscript-comment">/*
	 * Set all vnode vectors to a well known value.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; vfs_opv_descs[i]; i++)
		*(vfs_opv_descs[i]-&gt;opv_desc_vector_p) = NULL;
	<span class="enscript-comment">/*
	 * Figure out how many ops there are by counting the table,
	 * and assign each its offset.
	 */</span>
	<span class="enscript-keyword">for</span> (vfs_opv_numops = 0, i = 0; vfs_op_descs[i]; i++) {
		vfs_op_descs[i]-&gt;vdesc_offset = vfs_opv_numops;
		vfs_opv_numops++;
	}
	DODEBUG(printf (<span class="enscript-string">&quot;vfs_opv_numops=%d\n&quot;</span>, vfs_opv_numops));
}

<span class="enscript-comment">/*
 * Routines having to do with the management of the vnode table.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> vnodeops dead_vnodeops;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> vnodeops spec_vnodeops;

<span class="enscript-comment">/* vars for vnode lock */</span>
lck_grp_t * vnode_lck_grp;
lck_grp_attr_t * vnode_lck_grp_attr;
lck_attr_t * vnode_lck_attr;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
<span class="enscript-comment">/* vars for vnode trigger resolver */</span>
lck_grp_t * trigger_vnode_lck_grp;
lck_grp_attr_t * trigger_vnode_lck_grp_attr;
lck_attr_t * trigger_vnode_lck_attr;
#<span class="enscript-reference">endif</span>

lck_grp_t * fd_vn_lck_grp;
lck_grp_attr_t * fd_vn_lck_grp_attr;
lck_attr_t * fd_vn_lck_attr;

<span class="enscript-comment">/* vars for vnode list lock */</span>
lck_grp_t * vnode_list_lck_grp;
lck_grp_attr_t * vnode_list_lck_grp_attr;
lck_attr_t * vnode_list_lck_attr;
lck_spin_t * vnode_list_spin_lock;
lck_mtx_t * spechash_mtx_lock;

<span class="enscript-comment">/* vars for vfsconf lock */</span>
lck_grp_t * fsconf_lck_grp;
lck_grp_attr_t * fsconf_lck_grp_attr;
lck_attr_t * fsconf_lck_attr;


<span class="enscript-comment">/* vars for mount lock */</span>
lck_grp_t * mnt_lck_grp;
lck_grp_attr_t * mnt_lck_grp_attr;
lck_attr_t * mnt_lck_attr;

<span class="enscript-comment">/* vars for mount list lock */</span>
lck_grp_t * mnt_list_lck_grp;
lck_grp_attr_t * mnt_list_lck_grp_attr;
lck_attr_t * mnt_list_lck_attr;
lck_mtx_t * mnt_list_mtx_lock;

<span class="enscript-comment">/* vars for sync mutex */</span>
lck_grp_t * sync_mtx_lck_grp;
lck_grp_attr_t * sync_mtx_lck_grp_attr;
lck_attr_t * sync_mtx_lck_attr;
lck_mtx_t * sync_mtx_lck;

lck_mtx_t *pkg_extensions_lck;

<span class="enscript-type">struct</span> mount * dead_mountp;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nspace_handler_init</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 * Initialize the vnode structures and initialize each file system type.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vfsinit</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> vfstable *vfsp;
	<span class="enscript-type">int</span> i, maxtypenum;
	<span class="enscript-type">struct</span> mount * mp;
	
	<span class="enscript-comment">/* Allocate vnode list lock group attribute and group */</span>
	vnode_list_lck_grp_attr = lck_grp_attr_alloc_init();

	vnode_list_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;vnode list&quot;</span>,  vnode_list_lck_grp_attr);
	
	<span class="enscript-comment">/* Allocate vnode list lock attribute */</span>
	vnode_list_lck_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/* Allocate vnode list lock */</span>
	vnode_list_spin_lock = lck_spin_alloc_init(vnode_list_lck_grp, vnode_list_lck_attr);

	<span class="enscript-comment">/* Allocate spec hash list lock */</span>
	spechash_mtx_lock = lck_mtx_alloc_init(vnode_list_lck_grp, vnode_list_lck_attr);

	<span class="enscript-comment">/* Allocate the package extensions table lock */</span>
	pkg_extensions_lck = lck_mtx_alloc_init(vnode_list_lck_grp, vnode_list_lck_attr);

	<span class="enscript-comment">/* allocate vnode lock group attribute and group */</span>
	vnode_lck_grp_attr= lck_grp_attr_alloc_init();

	vnode_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;vnode&quot;</span>,  vnode_lck_grp_attr);

	<span class="enscript-comment">/* Allocate vnode lock attribute */</span>
	vnode_lck_attr = lck_attr_alloc_init();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	trigger_vnode_lck_grp_attr = lck_grp_attr_alloc_init();
	trigger_vnode_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;trigger_vnode&quot;</span>, trigger_vnode_lck_grp_attr);
	trigger_vnode_lck_attr = lck_attr_alloc_init();
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* Allocate per fd vnode data lock attribute and group */</span>
	fd_vn_lck_grp_attr = lck_grp_attr_alloc_init();
	fd_vn_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;fd_vnode_data&quot;</span>, fd_vn_lck_grp_attr);
	fd_vn_lck_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/* Allocate fs config lock group attribute and group */</span>
	fsconf_lck_grp_attr= lck_grp_attr_alloc_init();

	fsconf_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;fs conf&quot;</span>,  fsconf_lck_grp_attr);
	
	<span class="enscript-comment">/* Allocate fs config lock attribute */</span>
	fsconf_lck_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/* Allocate mount point related lock structures  */</span>

	<span class="enscript-comment">/* Allocate mount list lock group attribute and group */</span>
	mnt_list_lck_grp_attr= lck_grp_attr_alloc_init();

	mnt_list_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;mount list&quot;</span>,  mnt_list_lck_grp_attr);
	
	<span class="enscript-comment">/* Allocate mount list lock attribute */</span>
	mnt_list_lck_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/* Allocate mount list lock */</span>
	mnt_list_mtx_lock = lck_mtx_alloc_init(mnt_list_lck_grp, mnt_list_lck_attr);


	<span class="enscript-comment">/* allocate mount lock group attribute and group */</span>
	mnt_lck_grp_attr= lck_grp_attr_alloc_init();

	mnt_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;mount&quot;</span>,  mnt_lck_grp_attr);

	<span class="enscript-comment">/* Allocate mount lock attribute */</span>
	mnt_lck_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/* Allocate sync lock */</span>
	sync_mtx_lck_grp_attr =	 lck_grp_attr_alloc_init();
	sync_mtx_lck_grp =	 lck_grp_alloc_init(<span class="enscript-string">&quot;sync thread&quot;</span>,  sync_mtx_lck_grp_attr);
	sync_mtx_lck_attr =	 lck_attr_alloc_init();
	sync_mtx_lck =		 lck_mtx_alloc_init(sync_mtx_lck_grp, sync_mtx_lck_attr);

	<span class="enscript-comment">/*
	 * Initialize the vnode table
	 */</span>
	vntblinit();
	<span class="enscript-comment">/*
	 * Initialize the filesystem event mechanism.
	 */</span>
	vfs_event_init();
	<span class="enscript-comment">/*
	 * Initialize the vnode name cache
	 */</span>
	nchinit();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">JOURNALING</span>
	<span class="enscript-comment">/*
	 * Initialize the journaling locks
	 */</span>
	journal_init();
#<span class="enscript-reference">endif</span> 
	nspace_handler_init();

	<span class="enscript-comment">/*
	 * Build vnode operation vectors.
	 */</span>
	vfs_op_init();
	vfs_opv_init();   <span class="enscript-comment">/* finish the job */</span>
	<span class="enscript-comment">/*
	 * Initialize each file system type in the static list,
	 * until the first NULL -&gt;vfs_vfsops is encountered.
	 */</span>
	maxtypenum = VT_NON;
	<span class="enscript-keyword">for</span> (vfsp = vfsconf, i = 0; i &lt; maxvfsslots; i++, vfsp++) {
		<span class="enscript-type">struct</span> vfsconf vfsc;
		<span class="enscript-keyword">if</span> (vfsp-&gt;vfc_vfsops == (<span class="enscript-type">struct</span>	vfsops *)0)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (i) vfsconf[i-1].vfc_next = vfsp;
		<span class="enscript-keyword">if</span> (maxtypenum &lt;= vfsp-&gt;vfc_typenum)
			maxtypenum = vfsp-&gt;vfc_typenum + 1;
		
		bzero(&amp;vfsc, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vfsconf));
		vfsc.vfc_reserved1 = 0;
		bcopy(vfsp-&gt;vfc_name, vfsc.vfc_name, <span class="enscript-keyword">sizeof</span>(vfsc.vfc_name));
		vfsc.vfc_typenum = vfsp-&gt;vfc_typenum;
		vfsc.vfc_refcount = vfsp-&gt;vfc_refcount;
		vfsc.vfc_flags = vfsp-&gt;vfc_flags;
		vfsc.vfc_reserved2 = 0;
		vfsc.vfc_reserved3 = 0;

		<span class="enscript-keyword">if</span> (vfsp-&gt;vfc_vfsops-&gt;vfs_sysctl) {
			<span class="enscript-type">struct</span> sysctl_oid *oidp = NULL;
			<span class="enscript-type">struct</span> sysctl_oid oid = SYSCTL_STRUCT_INIT(_vfs, vfsp-&gt;vfc_typenum, , CTLTYPE_NODE | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED, NULL, 0, vfs_sysctl_node, <span class="enscript-string">&quot;-&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
			
			MALLOC(oidp, <span class="enscript-type">struct</span> sysctl_oid *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sysctl_oid), M_TEMP, M_WAITOK);
			*oidp = oid;
			
			<span class="enscript-comment">/* Memory for VFS oid held by vfsentry forever */</span>
			vfsp-&gt;vfc_sysctl = oidp;
			oidp-&gt;oid_name = vfsp-&gt;vfc_name;
			sysctl_register_oid(vfsp-&gt;vfc_sysctl);
		}
		
		(*vfsp-&gt;vfc_vfsops-&gt;vfs_init)(&amp;vfsc);

		numused_vfsslots++;
		numregistered_fses++;
	}
	<span class="enscript-comment">/* next vfc_typenum to be used */</span>
	maxvfstypenum = maxtypenum;

	<span class="enscript-comment">/*
	 * Initialize the vnop authorization scope.
	 */</span>
	vnode_authorize_init();

	<span class="enscript-comment">/*
	 * Initialiize the quota system.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	dqinit();
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-comment">/* 
	 * create a mount point for dead vnodes
	 */</span>
	MALLOC_ZONE(mp, <span class="enscript-type">struct</span> mount *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount),
		M_MOUNT, M_WAITOK);
	bzero((<span class="enscript-type">char</span> *)mp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount));
	<span class="enscript-comment">/* Initialize the default IO constraints */</span>
	mp-&gt;mnt_maxreadcnt = mp-&gt;mnt_maxwritecnt = MAXPHYS;
	mp-&gt;mnt_segreadcnt = mp-&gt;mnt_segwritecnt = 32;
	mp-&gt;mnt_maxsegreadsize = mp-&gt;mnt_maxreadcnt;
	mp-&gt;mnt_maxsegwritesize = mp-&gt;mnt_maxwritecnt;
	mp-&gt;mnt_devblocksize = DEV_BSIZE;
	mp-&gt;mnt_alignmentmask = PAGE_MASK;
	mp-&gt;mnt_ioqueue_depth = MNT_DEFAULT_IOQUEUE_DEPTH;
	mp-&gt;mnt_ioscale = 1;
	mp-&gt;mnt_ioflags = 0;
	mp-&gt;mnt_realrootvp = NULLVP;
	mp-&gt;mnt_authcache_ttl = CACHED_LOOKUP_RIGHT_TTL;
    
	TAILQ_INIT(&amp;mp-&gt;mnt_vnodelist);
	TAILQ_INIT(&amp;mp-&gt;mnt_workerqueue);
	TAILQ_INIT(&amp;mp-&gt;mnt_newvnodes);
	mp-&gt;mnt_flag = MNT_LOCAL;
	mp-&gt;mnt_lflag = MNT_LDEAD;
	mount_lock_init(mp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_mount_label_init(mp);
	mac_mount_label_associate(vfs_context_kernel(), mp);
#<span class="enscript-reference">endif</span>
	dead_mountp = mp;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_list_lock</span>(<span class="enscript-type">void</span>)
{
	lck_spin_lock(vnode_list_spin_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_list_unlock</span>(<span class="enscript-type">void</span>)
{
	lck_spin_unlock(vnode_list_spin_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_list_lock</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock(mnt_list_mtx_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_list_unlock</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_unlock(mnt_list_mtx_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_lock_init</span>(mount_t mp)
{
	lck_mtx_init(&amp;mp-&gt;mnt_mlock, mnt_lck_grp, mnt_lck_attr);
	lck_mtx_init(&amp;mp-&gt;mnt_renamelock, mnt_lck_grp, mnt_lck_attr);
	lck_rw_init(&amp;mp-&gt;mnt_rwlock, mnt_lck_grp, mnt_lck_attr);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mount_lock_destroy</span>(mount_t mp)
{
	lck_mtx_destroy(&amp;mp-&gt;mnt_mlock, mnt_lck_grp);
	lck_mtx_destroy(&amp;mp-&gt;mnt_renamelock, mnt_lck_grp);
	lck_rw_destroy(&amp;mp-&gt;mnt_rwlock, mnt_lck_grp);
}


<span class="enscript-comment">/*
 * Name:	vfstable_add
 *
 * Description:	Add a filesystem to the vfsconf list at the first
 *		unused slot.  If no slots are available, return an
 *		error.
 *
 * Parameter:	nvfsp		vfsconf for VFS to add
 *
 * Returns:	0		Success
 *		-1		Failure
 *
 * Notes:	The vfsconf should be treated as a linked list by
 *		all external references, as the implementation is
 *		expected to change in the future.  The linkage is
 *		through -&gt;vfc_next, and the list is NULL terminated.
 *
 * Warning:	This code assumes that vfsconf[0] is non-empty.
 */</span>
<span class="enscript-type">struct</span> vfstable *
<span class="enscript-function-name">vfstable_add</span>(<span class="enscript-type">struct</span> vfstable  *nvfsp)
{
	<span class="enscript-type">int</span> slot;
	<span class="enscript-type">struct</span> vfstable *slotp, *allocated = NULL;
	<span class="enscript-type">struct</span> sysctl_oid *oidp = NULL;

	
	<span class="enscript-keyword">if</span> (nvfsp-&gt;vfc_vfsops-&gt;vfs_sysctl) {
		<span class="enscript-type">struct</span> sysctl_oid oid = SYSCTL_STRUCT_INIT(_vfs, nvfsp-&gt;vfc_typenum, , CTLTYPE_NODE | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED, NULL, 0, vfs_sysctl_node, <span class="enscript-string">&quot;-&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
		
		MALLOC(oidp, <span class="enscript-type">struct</span> sysctl_oid *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sysctl_oid), M_TEMP, M_WAITOK);
		*oidp = oid;
	}
	
	<span class="enscript-comment">/*
	 * Find the next empty slot; we recognize an empty slot by a
	 * NULL-valued -&gt;vfc_vfsops, so if we delete a VFS, we must
	 * ensure we set the entry back to NULL.
	 */</span>
<span class="enscript-reference">findslot</span>:
	mount_list_lock();
	<span class="enscript-keyword">for</span> (slot = 0; slot &lt; maxvfsslots; slot++) {
		<span class="enscript-keyword">if</span> (vfsconf[slot].vfc_vfsops == NULL)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (slot == maxvfsslots) {
		<span class="enscript-keyword">if</span> (allocated == NULL) {
			mount_list_unlock();
			<span class="enscript-comment">/* out of static slots; allocate one instead */</span>
			MALLOC(allocated, <span class="enscript-type">struct</span> vfstable *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vfstable),
					M_TEMP, M_WAITOK);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">findslot</span>;
		} <span class="enscript-keyword">else</span> {
			slotp = allocated;
		}
	} <span class="enscript-keyword">else</span> {
		slotp = &amp;vfsconf[slot];
	}

	<span class="enscript-comment">/*
	 * Replace the contents of the next empty slot with the contents
	 * of the provided nvfsp.
	 *
	 * Note; Takes advantage of the fact that 'slot' was left
	 * with the value of 'maxvfslots' in the allocation case.
	 */</span>
	bcopy(nvfsp, slotp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vfstable));
	<span class="enscript-keyword">if</span> (slot != 0) {
		slotp-&gt;vfc_next = vfsconf[slot - 1].vfc_next;
		vfsconf[slot - 1].vfc_next = slotp;
	} <span class="enscript-keyword">else</span> {
		slotp-&gt;vfc_next = NULL;
	}

	<span class="enscript-keyword">if</span> (slotp != allocated) {
		<span class="enscript-comment">/* used a statically allocated slot */</span>
		numused_vfsslots++;
	}
	numregistered_fses++;

	<span class="enscript-keyword">if</span> (oidp) {
		<span class="enscript-comment">/* Memory freed in vfstable_del after unregistration */</span>
		slotp-&gt;vfc_sysctl = oidp;
		oidp-&gt;oid_name = slotp-&gt;vfc_name;
		sysctl_register_oid(slotp-&gt;vfc_sysctl);
	}

	mount_list_unlock();
	
	<span class="enscript-keyword">if</span> (allocated &amp;&amp; allocated != slotp) {
		<span class="enscript-comment">/* did allocation, but ended up using static slot */</span>
		FREE(allocated, M_TEMP);
	}

	<span class="enscript-keyword">return</span>(slotp);
}

<span class="enscript-comment">/*
 * Name:	vfstable_del
 *
 * Description:	Remove a filesystem from the vfsconf list by name.
 *		If no such filesystem exists, return an error.
 *
 * Parameter:	fs_name		name of VFS to remove
 *
 * Returns:	0		Success
 *		-1		Failure
 *
 * Notes:	Hopefully all filesystems have unique names.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vfstable_del</span>(<span class="enscript-type">struct</span> vfstable  * vtbl)
{
	<span class="enscript-type">struct</span> vfstable **vcpp;
	<span class="enscript-type">struct</span> vfstable *vcdelp;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(mnt_list_mtx_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	<span class="enscript-comment">/*
	 * Traverse the list looking for vtbl; if found, *vcpp
	 * will contain the address of the pointer to the entry to
	 * be removed.
	 */</span>
	<span class="enscript-keyword">for</span>( vcpp = &amp;vfsconf; *vcpp; vcpp = &amp;(*vcpp)-&gt;vfc_next) {
		<span class="enscript-keyword">if</span> (*vcpp == vtbl)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (*vcpp == NULL)
	   <span class="enscript-keyword">return</span>(ESRCH);	<span class="enscript-comment">/* vtbl not on vfsconf list */</span>

	<span class="enscript-keyword">if</span> ((*vcpp)-&gt;vfc_sysctl) {
		sysctl_unregister_oid((*vcpp)-&gt;vfc_sysctl);
		(*vcpp)-&gt;vfc_sysctl-&gt;oid_name = NULL;
		FREE((*vcpp)-&gt;vfc_sysctl, M_TEMP);
		(*vcpp)-&gt;vfc_sysctl = NULL;
	}

	<span class="enscript-comment">/* Unlink entry */</span>
	vcdelp = *vcpp;
	*vcpp = (*vcpp)-&gt;vfc_next;

	<span class="enscript-comment">/*
	 * Is this an entry from our static table?  We find out by
	 * seeing if the pointer to the object to be deleted places
	 * the object in the address space containing the table (or not).
	 */</span>
	<span class="enscript-keyword">if</span> (vcdelp &gt;= vfsconf &amp;&amp; vcdelp &lt; (vfsconf + maxvfsslots)) {	<span class="enscript-comment">/* Y */</span>
		<span class="enscript-comment">/* Mark as empty for vfscon_add() */</span>
		bzero(vcdelp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vfstable));
		numregistered_fses--;
		numused_vfsslots--;
	} <span class="enscript-keyword">else</span> {							<span class="enscript-comment">/* N */</span>
		<span class="enscript-comment">/*
		 * This entry was dynamically allocated; we must free it;
		 * we would prefer to have just linked the caller's
		 * vfsconf onto our list, but it may not be persistent
		 * because of the previous (copying) implementation.
		 */</span>
		numregistered_fses--;
		mount_list_unlock();
		FREE(vcdelp, M_TEMP);
		mount_list_lock();
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(mnt_list_mtx_lock, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">SPECHASH_LOCK</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock(spechash_mtx_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">SPECHASH_UNLOCK</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_unlock(spechash_mtx_lock);
}

</pre>
<hr />
</body></html>