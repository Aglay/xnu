<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_vnops.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_vnops.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)vfs_vnops.c	8.14 (Berkeley) 6/15/95
 *
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tty.h&gt;</span>
<span class="enscript-comment">/* Temporary workaround for ubc.h until &lt;rdar://4714366 is resolved */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ubc_setcred</span> ubc_setcred_deprecated
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ubc_setcred</span>
<span class="enscript-type">int</span>	ubc_setcred(<span class="enscript-type">struct</span> vnode *, <span class="enscript-type">struct</span> proc *);
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsevents.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/xattr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/fifofs/fifo.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cprotect.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOBSD.h&gt;</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vn_closefile</span>(<span class="enscript-type">struct</span> fileglob *fp, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vn_ioctl</span>(<span class="enscript-type">struct</span> fileproc *fp, u_long com, caddr_t data,
			vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vn_read</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> flags,
			vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vn_write</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> flags,
			vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vn_select</span>( <span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">int</span> which, <span class="enscript-type">void</span> * wql,
			vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vn_kqfilt_add</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> knote *kn,
			vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_vndetach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_vnode</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vn_open_auth_finish</span>(vnode_t vp, <span class="enscript-type">int</span> fmode, vfs_context_t ctx);
#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vn_kqfilt_remove</span>(<span class="enscript-type">struct</span> vnode *vp, uintptr_t ident,
			vfs_context_t ctx);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">const</span> <span class="enscript-type">struct</span> fileops vnops = {
	DTYPE_VNODE,
	vn_read,
	vn_write,
	vn_ioctl,
	vn_select,
	vn_closefile,
	vn_kqfilt_add,
	NULL
};

<span class="enscript-type">struct</span>  filterops vnode_filtops = { 
	.f_isfd = 1, 
	.f_attach = NULL, 
	.f_detach = filt_vndetach, 
	.f_event = filt_vnode
};

<span class="enscript-comment">/*
 * Common code for vnode open operations.
 * Check permissions, and call the VNOP_OPEN or VNOP_CREATE routine.
 *
 * XXX the profusion of interfaces here is probably a bad thing.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_open</span>(<span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">int</span> fmode, <span class="enscript-type">int</span> cmode)
{
	<span class="enscript-keyword">return</span>(vn_open_modflags(ndp, &amp;fmode, cmode));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_open_modflags</span>(<span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">int</span> *fmodep, <span class="enscript-type">int</span> cmode)
{
	<span class="enscript-type">struct</span> vnode_attr va;

	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_mode, cmode);
	
	<span class="enscript-keyword">return</span>(vn_open_auth(ndp, fmodep, &amp;va));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vn_open_auth_finish</span>(vnode_t vp, <span class="enscript-type">int</span> fmode, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((error = vnode_ref_ext(vp, fmode, 0)) != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* Call out to allow 3rd party notification of open. 
	 * Ignore result of kauth_authorize_fileop call.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_vnode_notify_open(ctx, vp, fmode);
#<span class="enscript-reference">endif</span>
	kauth_authorize_fileop(vfs_context_ucred(ctx), KAUTH_FILEOP_OPEN, 
						   (uintptr_t)vp, 0);

	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">return</span> error;

}

<span class="enscript-comment">/*
 * May do nameidone() to allow safely adding an FSEvent.  Cue off of ni_dvp to
 * determine whether that has happened.  
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vn_open_auth_do_create</span>(<span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">struct</span> vnode_attr *vap, <span class="enscript-type">int</span> fmode, boolean_t *did_create, boolean_t *did_open, vfs_context_t ctx)
{
	uint32_t status = 0;
	vnode_t dvp = ndp-&gt;ni_dvp;
	<span class="enscript-type">int</span> batched;
	<span class="enscript-type">int</span> error;
	vnode_t vp;

	batched = vnode_compound_open_available(ndp-&gt;ni_dvp);
	*did_open = FALSE;

	VATTR_SET(vap, va_type, VREG);
	<span class="enscript-keyword">if</span> (fmode &amp; O_EXCL)
		vap-&gt;va_vaflags |= VA_EXCLUSIVE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-keyword">if</span> (ndp-&gt;ni_cnd.cn_flags &amp; CN_WANTSRSRCFORK) {
		<span class="enscript-keyword">if</span> ((error = vn_authorize_create(dvp, &amp;ndp-&gt;ni_cnd, vap, ctx, NULL)) != 0) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-keyword">if</span> ((error = vnode_makenamedstream(dvp, &amp;ndp-&gt;ni_vp, XATTR_RESOURCEFORK_NAME, 0, ctx)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		*did_create = TRUE;
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (!batched) {
			<span class="enscript-keyword">if</span> ((error = vn_authorize_create(dvp, &amp;ndp-&gt;ni_cnd, vap, ctx, NULL)) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		error = vn_create(dvp, &amp;ndp-&gt;ni_vp, ndp, vap, VN_CREATE_DOOPEN, fmode, &amp;status, ctx);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">if</span> (batched) {
				*did_create = (status &amp; COMPOUND_OPEN_STATUS_DID_CREATE) ? TRUE : FALSE;
			} <span class="enscript-keyword">else</span> {
				*did_create = FALSE;
			}

			<span class="enscript-keyword">if</span> (error == EKEEPLOOKING) {
				<span class="enscript-keyword">if</span> (*did_create) {
					panic(<span class="enscript-string">&quot;EKEEPLOOKING, but we did a create?&quot;</span>);
				}
				<span class="enscript-keyword">if</span> (!batched) {
					panic(<span class="enscript-string">&quot;EKEEPLOOKING from filesystem that doesn't support compound vnops?&quot;</span>);
				}
				<span class="enscript-keyword">if</span> ((ndp-&gt;ni_flag &amp; NAMEI_CONTLOOKUP) == 0) {
					panic(<span class="enscript-string">&quot;EKEEPLOOKING, but continue flag not set?&quot;</span>);
				}

				<span class="enscript-comment">/* 
				 * Do NOT drop the dvp: we need everything to continue the lookup.
				 */</span>
				<span class="enscript-keyword">return</span> error;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (batched) {
				*did_create = (status &amp; COMPOUND_OPEN_STATUS_DID_CREATE) ? 1 : 0;
				*did_open = TRUE;
			} <span class="enscript-keyword">else</span> {
				*did_create = TRUE;
			}
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	}
#<span class="enscript-reference">endif</span>

	vp = ndp-&gt;ni_vp;

	<span class="enscript-keyword">if</span> (*did_create) {
		<span class="enscript-type">int</span>	update_flags = 0;

		<span class="enscript-comment">// Make sure the name &amp; parent pointers are hooked up
</span>		<span class="enscript-keyword">if</span> (vp-&gt;v_name == NULL)
			update_flags |= VNODE_UPDATE_NAME;
		<span class="enscript-keyword">if</span> (vp-&gt;v_parent == NULLVP)
			update_flags |= VNODE_UPDATE_PARENT;

		<span class="enscript-keyword">if</span> (update_flags)
			vnode_update_identity(vp, dvp, ndp-&gt;ni_cnd.cn_nameptr, ndp-&gt;ni_cnd.cn_namelen, ndp-&gt;ni_cnd.cn_hash, update_flags);

		vnode_put(dvp);
		ndp-&gt;ni_dvp = NULLVP;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
		<span class="enscript-keyword">if</span> (need_fsevent(FSE_CREATE_FILE, vp)) {
			add_fsevent(FSE_CREATE_FILE, ctx,
					FSE_ARG_VNODE, vp,
					FSE_ARG_DONE);
		}
#<span class="enscript-reference">endif</span>
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (ndp-&gt;ni_dvp != NULLVP) {
		vnode_put(dvp);
		ndp-&gt;ni_dvp = NULLVP;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * This is the number of times we'll loop in vn_open_auth without explicitly
 * yielding the CPU when we determine we have to retry.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RETRY_NO_YIELD_COUNT</span>	5

<span class="enscript-comment">/*
 * Open a file with authorization, updating the contents of the structures
 * pointed to by ndp, fmodep, and vap as necessary to perform the requested
 * operation.  This function is used for both opens of existing files, and
 * creation of new files.
 *
 * Parameters:	ndp			The nami data pointer describing the
 *					file
 *		fmodep			A pointer to an int containg the mode
 *					information to be used for the open
 *		vap			A pointer to the vnode attribute
 *					descriptor to be used for the open
 *
 * Indirect:	*			Contents of the data structures pointed
 *					to by the parameters are modified as
 *					necessary to the requested operation.
 *
 * Returns:	0			Success
 *		!0			errno value
 *
 * Notes:	The kauth_filesec_t in 'vap', if any, is in host byte order.
 *
 *		The contents of '*ndp' will be modified, based on the other
 *		arguments to this function, and to return file and directory
 *		data necessary to satisfy the requested operation.
 *
 *		If the file does not exist and we are creating it, then the
 *		O_TRUNC flag will be cleared in '*fmodep' to indicate to the
 *		caller that the file was not truncated.
 *
 *		If the file exists and the O_EXCL flag was not specified, then
 *		the O_CREAT flag will be cleared in '*fmodep' to indicate to
 *		the caller that the existing file was merely opened rather
 *		than created.
 *
 *		The contents of '*vap' will be modified as necessary to
 *		complete the operation, including setting of supported
 *		attribute, clearing of fields containing unsupported attributes
 *		in the request, if the request proceeds without them, etc..
 *
 * XXX:		This function is too complicated in actings on its arguments
 *
 * XXX:		We should enummerate the possible errno values here, and where
 *		in the code they originated.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_open_auth</span>(<span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">int</span> *fmodep, <span class="enscript-type">struct</span> vnode_attr *vap)
{
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">struct</span> vnode *dvp;
	vfs_context_t ctx = ndp-&gt;ni_cnd.cn_context;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> fmode;
	uint32_t origcnflags;
	boolean_t did_create;
	boolean_t did_open;
	boolean_t need_vnop_open;
	boolean_t batched;
	boolean_t ref_failed;
	<span class="enscript-type">int</span> nretries = 0;

<span class="enscript-reference">again</span>:
	vp = NULL;
	dvp = NULL;
	batched = FALSE;
	did_create = FALSE;
	need_vnop_open = TRUE;
	ref_failed = FALSE;
	fmode = *fmodep;
	origcnflags = ndp-&gt;ni_cnd.cn_flags;

	<span class="enscript-comment">/*
	 * O_CREAT
	 */</span>
	<span class="enscript-keyword">if</span> (fmode &amp; O_CREAT) {
	        <span class="enscript-keyword">if</span> ( (fmode &amp; O_DIRECTORY) ) {
		        error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		ndp-&gt;ni_cnd.cn_nameiop = CREATE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
		ndp-&gt;ni_op = OP_LINK;
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/* Inherit USEDVP, vnode_open() supported flags only */</span>
		ndp-&gt;ni_cnd.cn_flags &amp;= (USEDVP | NOCROSSMOUNT);
		ndp-&gt;ni_cnd.cn_flags |= LOCKPARENT | LOCKLEAF | AUDITVNPATH1;
		ndp-&gt;ni_flag = NAMEI_COMPOUNDOPEN;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
		<span class="enscript-comment">/* open calls are allowed for resource forks. */</span>
		ndp-&gt;ni_cnd.cn_flags |= CN_ALLOWRSRCFORK;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> ((fmode &amp; O_EXCL) == 0 &amp;&amp; (fmode &amp; O_NOFOLLOW) == 0 &amp;&amp; (origcnflags &amp; FOLLOW) != 0)
			ndp-&gt;ni_cnd.cn_flags |= FOLLOW;

<span class="enscript-reference">continue_create_lookup</span>:
		<span class="enscript-keyword">if</span> ( (error = namei(ndp)) )
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		dvp = ndp-&gt;ni_dvp;
		vp = ndp-&gt;ni_vp;

		batched = vnode_compound_open_available(dvp);

		<span class="enscript-comment">/* not found, create */</span>
		<span class="enscript-keyword">if</span> (vp == NULL) {
			<span class="enscript-comment">/* must have attributes for a new file */</span>
			<span class="enscript-keyword">if</span> (vap == NULL) {
				vnode_put(dvp);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-comment">/*
			 * Attempt a create.   For a system supporting compound VNOPs, we may
			 * find an existing file or create one; in either case, we will already
			 * have the file open and no VNOP_OPEN() will be needed.
			 */</span>
			error = vn_open_auth_do_create(ndp, vap, fmode, &amp;did_create, &amp;did_open, ctx);

			dvp = ndp-&gt;ni_dvp;
			vp = ndp-&gt;ni_vp;

			<span class="enscript-comment">/* 
			 * Detected a node that the filesystem couldn't handle.  Don't call
			 * nameidone() yet, because we need that path buffer.
			 */</span>
			<span class="enscript-keyword">if</span> (error == EKEEPLOOKING) {
				<span class="enscript-keyword">if</span> (!batched) {
					panic(<span class="enscript-string">&quot;EKEEPLOOKING from a filesystem that doesn't support compound VNOPs?&quot;</span>);
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">continue_create_lookup</span>;
			}

			nameidone(ndp);
			<span class="enscript-keyword">if</span> (dvp) {
				panic(<span class="enscript-string">&quot;Shouldn't have a dvp here.&quot;</span>);
			}

			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-comment">/*
				 * Check for a create race.
				 */</span>
				<span class="enscript-keyword">if</span> ((error == EEXIST) &amp;&amp; !(fmode &amp; O_EXCL)){
					<span class="enscript-keyword">if</span> (vp) 
						vnode_put(vp);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}

			need_vnop_open = !did_open;
		} 
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (fmode &amp; O_EXCL)
				error = EEXIST;

			<span class="enscript-comment">/* 
			 * We have a vnode.  Use compound open if available 
			 * or else fall through to &quot;traditional&quot; path.  Note: can't
			 * do a compound open for root, because the parent belongs
			 * to a different FS.
			 */</span>
			<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; batched &amp;&amp; (vnode_mount(dvp) == vnode_mount(vp))) {
				error = VNOP_COMPOUND_OPEN(dvp, &amp;ndp-&gt;ni_vp, ndp, 0, fmode, NULL, NULL, ctx);

				<span class="enscript-keyword">if</span> (error == 0) {
					vp = ndp-&gt;ni_vp;
					need_vnop_open = FALSE;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == EKEEPLOOKING) {
					<span class="enscript-keyword">if</span> ((ndp-&gt;ni_flag &amp; NAMEI_CONTLOOKUP) == 0) {
						panic(<span class="enscript-string">&quot;EKEEPLOOKING, but continue flag not set?&quot;</span>);
					}
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">continue_create_lookup</span>;
				} 
			}
			nameidone(ndp);
			vnode_put(dvp);
			ndp-&gt;ni_dvp = NULLVP;

			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}

			fmode &amp;= ~O_CREAT;

			<span class="enscript-comment">/* Fall through */</span>
		}
	}
    <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Not O_CREAT
		 */</span>
		ndp-&gt;ni_cnd.cn_nameiop = LOOKUP;
		<span class="enscript-comment">/* Inherit USEDVP, vnode_open() supported flags only */</span>
		ndp-&gt;ni_cnd.cn_flags &amp;= (USEDVP | NOCROSSMOUNT);
		ndp-&gt;ni_cnd.cn_flags |= FOLLOW | LOCKLEAF | AUDITVNPATH1 | WANTPARENT;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
		<span class="enscript-comment">/* open calls are allowed for resource forks. */</span>
		ndp-&gt;ni_cnd.cn_flags |= CN_ALLOWRSRCFORK;
#<span class="enscript-reference">endif</span>
		ndp-&gt;ni_flag = NAMEI_COMPOUNDOPEN;

		<span class="enscript-comment">/* preserve NOFOLLOW from vnode_open() */</span>
		<span class="enscript-keyword">if</span> (fmode &amp; O_NOFOLLOW || fmode &amp; O_SYMLINK || (origcnflags &amp; FOLLOW) == 0) {
			ndp-&gt;ni_cnd.cn_flags &amp;= ~FOLLOW;
		}

		<span class="enscript-comment">/* Do a lookup, possibly going directly to filesystem for compound operation */</span>
		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> ( (error = namei(ndp)) )
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			vp = ndp-&gt;ni_vp;
			dvp = ndp-&gt;ni_dvp;

			<span class="enscript-comment">/* Check for batched lookup-open */</span>
			batched = vnode_compound_open_available(dvp);
			<span class="enscript-keyword">if</span> (batched &amp;&amp; ((vp == NULLVP) || (vnode_mount(dvp) == vnode_mount(vp)))) {
				error = VNOP_COMPOUND_OPEN(dvp, &amp;ndp-&gt;ni_vp, ndp, 0, fmode, NULL, NULL, ctx);
				vp = ndp-&gt;ni_vp;
				<span class="enscript-keyword">if</span> (error == 0) {
					need_vnop_open = FALSE;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == EKEEPLOOKING) {
					<span class="enscript-keyword">if</span> ((ndp-&gt;ni_flag &amp; NAMEI_CONTLOOKUP) == 0) {
						panic(<span class="enscript-string">&quot;EKEEPLOOKING, but continue flag not set?&quot;</span>);
					}
				}
			}
		} <span class="enscript-keyword">while</span> (error == EKEEPLOOKING);

		nameidone(ndp);
		vnode_put(dvp);
		ndp-&gt;ni_dvp = NULLVP;

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	<span class="enscript-comment">/* 
	 * By this point, nameidone() is called, dvp iocount is dropped,
	 * and dvp pointer is cleared.
	 */</span>
	<span class="enscript-keyword">if</span> (ndp-&gt;ni_dvp != NULLVP) {
		panic(<span class="enscript-string">&quot;Haven't cleaned up adequately in vn_open_auth()&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * Expect to use this code for filesystems without compound VNOPs, for the root 
	 * of a filesystem, which can't be &quot;looked up&quot; in the sense of VNOP_LOOKUP(),
	 * and for shadow files, which do not live on the same filesystems as their &quot;parents.&quot;
	 */</span>
	<span class="enscript-keyword">if</span> (need_vnop_open) {
		<span class="enscript-keyword">if</span> (batched &amp;&amp; !vnode_isvroot(vp) &amp;&amp; !vnode_isnamedstream(vp)) {
			panic(<span class="enscript-string">&quot;Why am I trying to use VNOP_OPEN() on anything other than the root or a named stream?&quot;</span>);
		}

		<span class="enscript-keyword">if</span> (!did_create) {
			error = vn_authorize_open_existing(vp, &amp;ndp-&gt;ni_cnd, fmode, ctx, NULL);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
		<span class="enscript-comment">// If raw encrypted mode is requested, handle that here
</span>		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE (vap, va_dataprotect_flags)
			&amp;&amp; ISSET(vap-&gt;va_dataprotect_flags, VA_DP_RAWENCRYPTED)) {
			fmode |= FENCRYPTED;
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE (vap, va_dataprotect_flags)
			&amp;&amp; ISSET(vap-&gt;va_dataprotect_flags, VA_DP_RAWUNENCRYPTED)) {
			<span class="enscript-comment">/* Don't allow unencrypted io request from user space unless entitled */</span>
			boolean_t entitled = FALSE;
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">SECURE_KERNEL</span>
			entitled = IOTaskHasEntitlement(current_task(), <span class="enscript-string">&quot;com.apple.private.security.file-unencrypt-access&quot;</span>);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (!entitled) {
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			fmode |= FUNENCRYPTED;
		}

		<span class="enscript-comment">/*
		 * Perform any content protection access checks prior to calling 
		 * into the filesystem.
		 */</span>
		error = cp_handle_open (vp, fmode);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
#<span class="enscript-reference">endif</span>

		error = VNOP_OPEN(vp, fmode, ctx);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		need_vnop_open = FALSE;
	}

	<span class="enscript-comment">// if the vnode is tagged VOPENEVT and the current process
</span>	<span class="enscript-comment">// has the P_CHECKOPENEVT flag set, then we or in the O_EVTONLY
</span>	<span class="enscript-comment">// flag to the open mode so that this open won't count against
</span>	<span class="enscript-comment">// the vnode when carbon delete() does a vnode_isinuse() to see
</span>	<span class="enscript-comment">// if a file is currently in use.  this allows spotlight
</span>	<span class="enscript-comment">// importers to not interfere with carbon apps that depend on
</span>	<span class="enscript-comment">// the no-delete-if-busy semantics of carbon delete().
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (!did_create &amp;&amp; (vp-&gt;v_flag &amp; VOPENEVT) &amp;&amp; (current_proc()-&gt;p_flag &amp; P_CHECKOPENEVT)) {
		fmode |= O_EVTONLY;
	}

	<span class="enscript-comment">/*
	 * Grab reference, etc.
	 */</span>
	error = vn_open_auth_finish(vp, fmode, ctx);
	<span class="enscript-keyword">if</span> (error) {
		ref_failed = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* Compound VNOP open is responsible for doing the truncate */</span>
	<span class="enscript-keyword">if</span> (batched || did_create) 
		fmode &amp;= ~O_TRUNC;

	*fmodep = fmode;
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">bad</span>:
	<span class="enscript-comment">/* Opened either explicitly or by a batched create */</span>
	<span class="enscript-keyword">if</span> (!need_vnop_open) {
		VNOP_CLOSE(vp, fmode, ctx);
	}

	ndp-&gt;ni_vp = NULL;
	<span class="enscript-keyword">if</span> (vp) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
		<span class="enscript-comment">/* Aggressively recycle shadow files if we error'd out during open() */</span>
		<span class="enscript-keyword">if</span> ((vnode_isnamedstream(vp)) &amp;&amp;
			(vp-&gt;v_parent != NULLVP) &amp;&amp; 
			(vnode_isshadow(vp))) {
				vnode_recycle(vp);
		}
#<span class="enscript-reference">endif</span>
		vnode_put(vp);
		<span class="enscript-comment">/*
		 * Check for a race against unlink.  We had a vnode
		 * but according to vnode_authorize or VNOP_OPEN it
		 * no longer exists.
		 *
		 * EREDRIVEOPEN: means that we were hit by the tty allocation race.
		 */</span>
		<span class="enscript-keyword">if</span> (((error == ENOENT) &amp;&amp; (*fmodep &amp; O_CREAT)) || (error == EREDRIVEOPEN) || ref_failed) {
			<span class="enscript-comment">/*
			 * We'll retry here but it may be possible that we get
			 * into a retry &quot;spin&quot; inside the kernel and not allow
			 * threads, which need to run in order for the retry
			 * loop to end, to run. An example is an open of a
			 * terminal which is getting revoked and we spin here
			 * without yielding becasue namei and VNOP_OPEN are
			 * successful but vnode_ref fails. The revoke needs
			 * threads with an iocount to run but if spin here we
			 * may possibly be blcoking other threads from running.
			 *
			 * We start yielding the CPU after some number of
			 * retries for increasing durations. Note that this is
			 * still a loop without an exit condition.
			 */</span>
			nretries += 1;
			<span class="enscript-keyword">if</span> (nretries &gt; RETRY_NO_YIELD_COUNT) {
				<span class="enscript-comment">/* Every hz/100 secs is 10 msecs ... */</span>
				tsleep(&amp;nretries, PVFS, <span class="enscript-string">&quot;vn_open_auth_retry&quot;</span>,
				    MIN((nretries * (hz/100)), hz));
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		}
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">vn_access_DEPRECATED</span>
<span class="enscript-comment">/*
 * Authorize an action against a vnode.  This has been the canonical way to
 * ensure that the credential/process/etc. referenced by a vfs_context
 * is granted the rights called out in 'mode' against the vnode 'vp'.
 *
 * Unfortunately, the use of VREAD/VWRITE/VEXEC makes it very difficult
 * to add support for more rights.  As such, this interface will be deprecated
 * and callers will use vnode_authorize instead.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_access</span>(vnode_t vp, <span class="enscript-type">int</span> mode, vfs_context_t context)
{
 	kauth_action_t	action;
  
  	action = 0;
 	<span class="enscript-keyword">if</span> (mode &amp; VREAD)
 		action |= KAUTH_VNODE_READ_DATA;
 	<span class="enscript-keyword">if</span> (mode &amp; VWRITE)
		action |= KAUTH_VNODE_WRITE_DATA;
  	<span class="enscript-keyword">if</span> (mode &amp; VEXEC)
  		action |= KAUTH_VNODE_EXECUTE;
  
 	<span class="enscript-keyword">return</span>(vnode_authorize(vp, NULL, action, context));
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* vn_access_DEPRECATED */</span>

<span class="enscript-comment">/*
 * Vnode close call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_close</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> flusherror = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDRSRCFORK</span>
	<span class="enscript-comment">/* Sync data from resource fork shadow file if needed. */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VISNAMEDSTREAM) &amp;&amp; 
	    (vp-&gt;v_parent != NULLVP) &amp;&amp;
	    vnode_isshadow(vp)) {
		<span class="enscript-keyword">if</span> (flags &amp; FWASWRITTEN) {
			flusherror = vnode_flushnamedstream(vp-&gt;v_parent, vp, ctx);
		}
	}
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-comment">/* work around for foxhound */</span>
	<span class="enscript-keyword">if</span> (vnode_isspec(vp))
		(<span class="enscript-type">void</span>)vnode_rele_ext(vp, flags, 0);

	<span class="enscript-comment">/*
	 * On HFS, we flush when the last writer closes.  We do this
	 * because resource fork vnodes hold a reference on data fork
	 * vnodes and that will prevent them from getting VNOP_INACTIVE
	 * which will delay when we flush cached data.  In future, we
	 * might find it beneficial to do this for all file systems.
	 * Note that it's OK to access v_writecount without the lock
	 * in this context.
	 */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_tag == VT_HFS &amp;&amp; (flags &amp; FWRITE) &amp;&amp; vp-&gt;v_writecount == 1)
		VNOP_FSYNC(vp, MNT_NOWAIT, ctx);

	error = VNOP_CLOSE(vp, flags, ctx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (flags &amp; FWASWRITTEN) {
	        <span class="enscript-keyword">if</span> (need_fsevent(FSE_CONTENT_MODIFIED, vp)) {
		        add_fsevent(FSE_CONTENT_MODIFIED, ctx,
				    FSE_ARG_VNODE, vp,
				    FSE_ARG_DONE);
		}
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (!vnode_isspec(vp))
		(<span class="enscript-type">void</span>)vnode_rele_ext(vp, flags, 0);
	
	<span class="enscript-keyword">if</span> (flusherror) {
		error = flusherror;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vn_read_swapfile</span>(
	<span class="enscript-type">struct</span> vnode	*vp,
	uio_t		uio)
{
	<span class="enscript-type">int</span>	error;
	off_t	swap_count, this_count;
	off_t	file_end, read_end;
	off_t	prev_resid;
	<span class="enscript-type">char</span> 	*my_swap_page;

	<span class="enscript-comment">/*
	 * Reading from a swap file will get you zeroes.
	 */</span>

	my_swap_page = NULL;
	error = 0;
	swap_count = uio_resid(uio);

	file_end = ubc_getsize(vp);
	read_end = uio-&gt;uio_offset + uio_resid(uio);
	<span class="enscript-keyword">if</span> (uio-&gt;uio_offset &gt;= file_end) {
		<span class="enscript-comment">/* uio starts after end of file: nothing to read */</span>
		swap_count = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (read_end &gt; file_end) {
		<span class="enscript-comment">/* uio extends beyond end of file: stop before that */</span>
		swap_count -= (read_end - file_end);
	}

	<span class="enscript-keyword">while</span> (swap_count &gt; 0) {
		<span class="enscript-keyword">if</span> (my_swap_page == NULL) {
			MALLOC(my_swap_page, <span class="enscript-type">char</span> *, PAGE_SIZE,
			       M_TEMP, M_WAITOK);
			memset(my_swap_page, <span class="enscript-string">'\0'</span>, PAGE_SIZE);
			<span class="enscript-comment">/* add an end-of-line to keep line counters happy */</span>
			my_swap_page[PAGE_SIZE-1] = <span class="enscript-string">'\n'</span>;
		}
		this_count = swap_count;
		<span class="enscript-keyword">if</span> (this_count &gt; PAGE_SIZE) {
			this_count = PAGE_SIZE;
		}

		prev_resid = uio_resid(uio);
		error = uiomove((caddr_t) my_swap_page,
				this_count,
				uio);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">break</span>;
		}
		swap_count -= (prev_resid - uio_resid(uio));
	}
	<span class="enscript-keyword">if</span> (my_swap_page != NULL) {
		FREE(my_swap_page, M_TEMP);
		my_swap_page = NULL;
	}

	<span class="enscript-keyword">return</span> error;
}
<span class="enscript-comment">/*
 * Package up an I/O request on a vnode into a uio and do it.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_rdwr</span>(
	<span class="enscript-type">enum</span> uio_rw rw,
	<span class="enscript-type">struct</span> vnode *vp,
	caddr_t base,
	<span class="enscript-type">int</span> len,
	off_t offset,
	<span class="enscript-type">enum</span> uio_seg segflg,
	<span class="enscript-type">int</span> ioflg,
	kauth_cred_t cred,
	<span class="enscript-type">int</span> *aresid,
	proc_t p)
{
	int64_t resid;
	<span class="enscript-type">int</span> result;
	
	result = vn_rdwr_64(rw,
			vp,
			(uint64_t)(uintptr_t)base,
			(int64_t)len,
			offset,
			segflg,
			ioflg,
			cred,
			&amp;resid,
			p);

	<span class="enscript-comment">/* &quot;resid&quot; should be bounded above by &quot;len,&quot; which is an int */</span>
	<span class="enscript-keyword">if</span> (aresid != NULL) {
		*aresid = resid;
	}

	<span class="enscript-keyword">return</span> result;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_rdwr_64</span>(
	<span class="enscript-type">enum</span> uio_rw rw,
	<span class="enscript-type">struct</span> vnode *vp,
	uint64_t base,
	int64_t len,
	off_t offset,
	<span class="enscript-type">enum</span> uio_seg segflg,
	<span class="enscript-type">int</span> ioflg,
	kauth_cred_t cred,
	int64_t *aresid,
	proc_t p)
{
	uio_t auio;
	<span class="enscript-type">int</span> spacetype;
	<span class="enscript-type">struct</span> vfs_context context;
	<span class="enscript-type">int</span> error=0;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];

	context.vc_thread = current_thread();
	context.vc_ucred = cred;

	<span class="enscript-keyword">if</span> (UIO_SEG_IS_USER_SPACE(segflg)) {
		spacetype = proc_is64bit(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;
	}
	<span class="enscript-keyword">else</span> {
		spacetype = UIO_SYSSPACE;
	}
	auio = uio_createwithbuffer(1, offset, spacetype, rw, 
								  &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, base, len);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/* XXXMAC
	 * 	IO_NOAUTH should be re-examined.
 	 *	Likely that mediation should be performed in caller.
	 */</span>
	<span class="enscript-keyword">if</span> ((ioflg &amp; IO_NOAUTH) == 0) {
	<span class="enscript-comment">/* passed cred is fp-&gt;f_cred */</span>
		<span class="enscript-keyword">if</span> (rw == UIO_READ)
			error = mac_vnode_check_read(&amp;context, cred, vp);
		<span class="enscript-keyword">else</span>
			error = mac_vnode_check_write(&amp;context, cred, vp);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-keyword">if</span> (rw == UIO_READ) {
			<span class="enscript-keyword">if</span> (vnode_isswap(vp) &amp;&amp; ((ioflg &amp; IO_SWAP_DISPATCH) == 0)) {
				error = vn_read_swapfile(vp, auio);
			} <span class="enscript-keyword">else</span> {
				error = VNOP_READ(vp, auio, ioflg, &amp;context);
			}
		} <span class="enscript-keyword">else</span> {
			error = VNOP_WRITE(vp, auio, ioflg, &amp;context);
		}
	}

	<span class="enscript-keyword">if</span> (aresid)
		*aresid = uio_resid(auio);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">if</span> (uio_resid(auio) &amp;&amp; error == 0)
			error = EIO;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">vn_offset_lock</span>(<span class="enscript-type">struct</span> fileglob *fg)
{
	lck_mtx_lock_spin(&amp;fg-&gt;fg_lock);
	<span class="enscript-keyword">while</span> (fg-&gt;fg_lflags &amp; FG_OFF_LOCKED) {
		fg-&gt;fg_lflags |= FG_OFF_LOCKWANT;
		msleep(&amp;fg-&gt;fg_lflags, &amp;fg-&gt;fg_lock, PVFS | PSPIN,
		    <span class="enscript-string">&quot;fg_offset_lock_wait&quot;</span>, 0);
	}
	fg-&gt;fg_lflags |= FG_OFF_LOCKED;
	lck_mtx_unlock(&amp;fg-&gt;fg_lock);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">vn_offset_unlock</span>(<span class="enscript-type">struct</span> fileglob *fg)
{
	<span class="enscript-type">int</span> lock_wanted = 0;

	lck_mtx_lock_spin(&amp;fg-&gt;fg_lock);
	<span class="enscript-keyword">if</span> (fg-&gt;fg_lflags &amp; FG_OFF_LOCKWANT) {
		lock_wanted = 1;
	}
	fg-&gt;fg_lflags &amp;= ~(FG_OFF_LOCKED | FG_OFF_LOCKWANT);
	lck_mtx_unlock(&amp;fg-&gt;fg_lock);
	<span class="enscript-keyword">if</span> (lock_wanted) {
		wakeup(&amp;fg-&gt;fg_lflags);
	}
}

<span class="enscript-comment">/*
 * File table vnode read routine.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vn_read</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> ioflag;
	off_t count;
	<span class="enscript-type">int</span> offset_locked = 0;

	vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_fglob-&gt;fg_data;
	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		<span class="enscript-keyword">return</span>(error);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_read(ctx, vfs_context_ucred(ctx), vp);
	<span class="enscript-keyword">if</span> (error) {
		(<span class="enscript-type">void</span>)vnode_put(vp);
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* This signals to VNOP handlers that this read came from a file table read */</span>
	ioflag = IO_SYSCALL_DISPATCH;

	<span class="enscript-keyword">if</span> (fp-&gt;f_fglob-&gt;fg_flag &amp; FNONBLOCK)
		ioflag |= IO_NDELAY;
	<span class="enscript-keyword">if</span> ((fp-&gt;f_fglob-&gt;fg_flag &amp; FNOCACHE) || vnode_isnocache(vp))
	    ioflag |= IO_NOCACHE;
	<span class="enscript-keyword">if</span> (fp-&gt;f_fglob-&gt;fg_flag &amp; FENCRYPTED) {
		ioflag |= IO_ENCRYPTED;
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_fglob-&gt;fg_flag &amp; FUNENCRYPTED) {
		ioflag |= IO_SKIP_ENCRYPTION;
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_fglob-&gt;fg_flag &amp; O_EVTONLY) {
		ioflag |= IO_EVTONLY;
	}
	<span class="enscript-keyword">if</span> (fp-&gt;f_fglob-&gt;fg_flag &amp; FNORDAHEAD)
	    ioflag |= IO_RAOFF;

	<span class="enscript-keyword">if</span> ((flags &amp; FOF_OFFSET) == 0) {
		<span class="enscript-keyword">if</span> ((vnode_vtype(vp) == VREG) &amp;&amp; !vnode_isswap(vp)) {
			vn_offset_lock(fp-&gt;f_fglob);
			offset_locked = 1;
		}
		uio-&gt;uio_offset = fp-&gt;f_fglob-&gt;fg_offset;
	}
	count = uio_resid(uio);

	<span class="enscript-keyword">if</span> (vnode_isswap(vp) &amp;&amp; !(IO_SKIP_ENCRYPTION &amp; ioflag)) {
		<span class="enscript-comment">/* special case for swap files */</span>
		error = vn_read_swapfile(vp, uio);
	} <span class="enscript-keyword">else</span> {
		error = VNOP_READ(vp, uio, ioflag, ctx);
	}
	<span class="enscript-keyword">if</span> ((flags &amp; FOF_OFFSET) == 0) {
		fp-&gt;f_fglob-&gt;fg_offset += count - uio_resid(uio);
		<span class="enscript-keyword">if</span> (offset_locked) {
			vn_offset_unlock(fp-&gt;f_fglob);
			offset_locked = 0;
		}
	}

	(<span class="enscript-type">void</span>)vnode_put(vp);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * File table vnode write routine.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vn_write</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">int</span> error, ioflag;
	off_t count;
	<span class="enscript-type">int</span> clippedsize = 0;
	<span class="enscript-type">int</span> partialwrite=0;
	<span class="enscript-type">int</span> residcount, oldcount;
	<span class="enscript-type">int</span> offset_locked = 0;
	proc_t p = vfs_context_proc(ctx);

	count = 0;
	vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_fglob-&gt;fg_data;
	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		<span class="enscript-keyword">return</span>(error);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_write(ctx, vfs_context_ucred(ctx), vp);
	<span class="enscript-keyword">if</span> (error) {
		(<span class="enscript-type">void</span>)vnode_put(vp);
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * IO_SYSCALL_DISPATCH signals to VNOP handlers that this write came from
	 * a file table write
	 */</span>
	ioflag = (IO_UNIT | IO_SYSCALL_DISPATCH);

	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VREG &amp;&amp; (fp-&gt;f_fglob-&gt;fg_flag &amp; O_APPEND))
		ioflag |= IO_APPEND;
	<span class="enscript-keyword">if</span> (fp-&gt;f_fglob-&gt;fg_flag &amp; FNONBLOCK)
		ioflag |= IO_NDELAY;
	<span class="enscript-keyword">if</span> ((fp-&gt;f_fglob-&gt;fg_flag &amp; FNOCACHE) || vnode_isnocache(vp))
	        ioflag |= IO_NOCACHE;
	<span class="enscript-keyword">if</span> (fp-&gt;f_fglob-&gt;fg_flag &amp; FNODIRECT)
		ioflag |= IO_NODIRECT;
	<span class="enscript-keyword">if</span> (fp-&gt;f_fglob-&gt;fg_flag &amp; FSINGLE_WRITER)
		ioflag |= IO_SINGLE_WRITER;
	<span class="enscript-keyword">if</span> (fp-&gt;f_fglob-&gt;fg_flag &amp; O_EVTONLY)
		ioflag |= IO_EVTONLY;

	<span class="enscript-comment">/*
	 * Treat synchronous mounts and O_FSYNC on the fd as equivalent.
	 *
	 * XXX We treat O_DSYNC as O_FSYNC for now, since we can not delay
	 * XXX the non-essential metadata without some additional VFS work;
	 * XXX the intent at this point is to plumb the interface for it.
	 */</span>
	<span class="enscript-keyword">if</span> ((fp-&gt;f_fglob-&gt;fg_flag &amp; (O_FSYNC|O_DSYNC)) ||
		(vp-&gt;v_mount &amp;&amp; (vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_SYNCHRONOUS))) {
		ioflag |= IO_SYNC;
	}

	<span class="enscript-keyword">if</span> ((flags &amp; FOF_OFFSET) == 0) {
		<span class="enscript-keyword">if</span> ((vnode_vtype(vp) == VREG) &amp;&amp; !vnode_isswap(vp)) {
			vn_offset_lock(fp-&gt;f_fglob);
			offset_locked = 1;
		}
		uio-&gt;uio_offset = fp-&gt;f_fglob-&gt;fg_offset;
		count = uio_resid(uio);
	}
	<span class="enscript-keyword">if</span> (((flags &amp; FOF_OFFSET) == 0) &amp;&amp;
	 	vfs_context_proc(ctx) &amp;&amp; (vp-&gt;v_type == VREG) &amp;&amp;
            (((rlim_t)(uio-&gt;uio_offset + uio_resid(uio)) &gt; p-&gt;p_rlimit[RLIMIT_FSIZE].rlim_cur) ||
             ((rlim_t)uio_resid(uio) &gt; (p-&gt;p_rlimit[RLIMIT_FSIZE].rlim_cur - uio-&gt;uio_offset)))) {
	     	<span class="enscript-comment">/*
		 * If the requested residual would cause us to go past the
		 * administrative limit, then we need to adjust the residual
		 * down to cause fewer bytes than requested to be written.  If
		 * we can't do that (e.g. the residual is already 1 byte),
		 * then we fail the write with EFBIG.
		 */</span>
		residcount = uio_resid(uio);
            	<span class="enscript-keyword">if</span> ((rlim_t)(uio-&gt;uio_offset + uio_resid(uio)) &gt; p-&gt;p_rlimit[RLIMIT_FSIZE].rlim_cur) {
			clippedsize =  (uio-&gt;uio_offset + uio_resid(uio)) - p-&gt;p_rlimit[RLIMIT_FSIZE].rlim_cur;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((rlim_t)uio_resid(uio) &gt; (p-&gt;p_rlimit[RLIMIT_FSIZE].rlim_cur - uio-&gt;uio_offset)) {
			clippedsize = (p-&gt;p_rlimit[RLIMIT_FSIZE].rlim_cur - uio-&gt;uio_offset);
		}
		<span class="enscript-keyword">if</span> (clippedsize &gt;= residcount) {
			psignal(p, SIGXFSZ);
			error = EFBIG;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_out</span>;
		}
		partialwrite = 1;
		uio_setresid(uio, residcount-clippedsize);
	}
	<span class="enscript-keyword">if</span> ((flags &amp; FOF_OFFSET) != 0) {
		<span class="enscript-comment">/* for pwrite, append should  be ignored */</span>
		ioflag &amp;= ~IO_APPEND;
		<span class="enscript-keyword">if</span> (p &amp;&amp; (vp-&gt;v_type == VREG) &amp;&amp;
            	((rlim_t)uio-&gt;uio_offset  &gt;= p-&gt;p_rlimit[RLIMIT_FSIZE].rlim_cur)) {
		psignal(p, SIGXFSZ);
		error = EFBIG;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_out</span>;
	}
		<span class="enscript-keyword">if</span> (p &amp;&amp; (vp-&gt;v_type == VREG) &amp;&amp;
			((rlim_t)(uio-&gt;uio_offset + uio_resid(uio)) &gt; p-&gt;p_rlimit[RLIMIT_FSIZE].rlim_cur)) {
			<span class="enscript-comment">//Debugger(&quot;vn_bwrite:overstepping the bounds&quot;);
</span>			residcount = uio_resid(uio);
			clippedsize =  (uio-&gt;uio_offset + uio_resid(uio)) - p-&gt;p_rlimit[RLIMIT_FSIZE].rlim_cur;
			partialwrite = 1;
			uio_setresid(uio, residcount-clippedsize);
		}
	}

	error = VNOP_WRITE(vp, uio, ioflag, ctx);

	<span class="enscript-keyword">if</span> (partialwrite) {
		oldcount = uio_resid(uio);
		uio_setresid(uio, oldcount + clippedsize);
	}

	<span class="enscript-keyword">if</span> ((flags &amp; FOF_OFFSET) == 0) {
		<span class="enscript-keyword">if</span> (ioflag &amp; IO_APPEND)
			fp-&gt;f_fglob-&gt;fg_offset = uio-&gt;uio_offset;
		<span class="enscript-keyword">else</span>
			fp-&gt;f_fglob-&gt;fg_offset += count - uio_resid(uio);
		<span class="enscript-keyword">if</span> (offset_locked) {
			vn_offset_unlock(fp-&gt;f_fglob);
			offset_locked = 0;
		}
	}

	<span class="enscript-comment">/*
	 * Set the credentials on successful writes
	 */</span>
	<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; (vp-&gt;v_tag == VT_NFS) &amp;&amp; (UBCINFOEXISTS(vp))) {
		<span class="enscript-comment">/* 
		 * When called from aio subsystem, we only have the proc from
		 * which to get the credential, at this point, so use that
		 * instead.  This means aio functions are incompatible with
		 * per-thread credentials (aio operations are proxied).  We
		 * can't easily correct the aio vs. settid race in this case
		 * anyway, so we disallow it.
		 */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; FOF_PCRED) == 0) {
			ubc_setthreadcred(vp, p, current_thread());
		} <span class="enscript-keyword">else</span> {
			ubc_setcred(vp, p);
		}
	}
	(<span class="enscript-type">void</span>)vnode_put(vp);
	<span class="enscript-keyword">return</span> (error);

<span class="enscript-reference">error_out</span>:
	<span class="enscript-keyword">if</span> (offset_locked) {
		vn_offset_unlock(fp-&gt;f_fglob);
	}
	(<span class="enscript-type">void</span>)vnode_put(vp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * File table vnode stat routine.
 *
 * Returns:	0			Success
 *		EBADF
 *		ENOMEM
 *	vnode_getattr:???
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_stat_noauth</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">void</span> *sbptr, kauth_filesec_t *xsec, <span class="enscript-type">int</span> isstat64, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">int</span> error;
	u_short mode;
	kauth_filesec_t fsec;
	<span class="enscript-type">struct</span> stat *sb = (<span class="enscript-type">struct</span> stat *)0;	<span class="enscript-comment">/* warning avoidance ; protected by isstat64 */</span>
	<span class="enscript-type">struct</span> stat64 * sb64 = (<span class="enscript-type">struct</span> stat64 *)0;  <span class="enscript-comment">/* warning avoidance ; protected by isstat64 */</span>

	<span class="enscript-keyword">if</span> (isstat64 != 0)
		sb64 = (<span class="enscript-type">struct</span> stat64 *)sbptr;
	<span class="enscript-keyword">else</span>
		sb = (<span class="enscript-type">struct</span> stat *)sbptr;
	memset(&amp;va, 0, <span class="enscript-keyword">sizeof</span>(va));
	VATTR_INIT(&amp;va);
	VATTR_WANTED(&amp;va, va_fsid);
	VATTR_WANTED(&amp;va, va_fileid);
	VATTR_WANTED(&amp;va, va_mode);
	VATTR_WANTED(&amp;va, va_type);
	VATTR_WANTED(&amp;va, va_nlink);
	VATTR_WANTED(&amp;va, va_uid);
	VATTR_WANTED(&amp;va, va_gid);
	VATTR_WANTED(&amp;va, va_rdev);
	VATTR_WANTED(&amp;va, va_data_size);
	VATTR_WANTED(&amp;va, va_access_time);
	VATTR_WANTED(&amp;va, va_modify_time);
	VATTR_WANTED(&amp;va, va_change_time);
	VATTR_WANTED(&amp;va, va_create_time);
	VATTR_WANTED(&amp;va, va_flags);
	VATTR_WANTED(&amp;va, va_gen);
	VATTR_WANTED(&amp;va, va_iosize);
	<span class="enscript-comment">/* lower layers will synthesise va_total_alloc from va_data_size if required */</span>
	VATTR_WANTED(&amp;va, va_total_alloc);
	<span class="enscript-keyword">if</span> (xsec != NULL) {
		VATTR_WANTED(&amp;va, va_uuuid);
		VATTR_WANTED(&amp;va, va_guuid);
		VATTR_WANTED(&amp;va, va_acl);
	}
	error = vnode_getattr(vp, &amp;va, ctx);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-comment">/*
	 * Copy from vattr table
	 */</span>
	<span class="enscript-keyword">if</span> (isstat64 != 0) {
		sb64-&gt;st_dev = va.va_fsid;
		sb64-&gt;st_ino = (ino64_t)va.va_fileid;

	} <span class="enscript-keyword">else</span> {
		sb-&gt;st_dev = va.va_fsid;
		sb-&gt;st_ino = (ino_t)va.va_fileid;
	}
	mode = va.va_mode;
	<span class="enscript-keyword">switch</span> (vp-&gt;v_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VREG</span>:
		mode |= S_IFREG;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VDIR</span>:
		mode |= S_IFDIR;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:
		mode |= S_IFBLK;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
		mode |= S_IFCHR;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VLNK</span>:
		mode |= S_IFLNK;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VSOCK</span>:
		mode |= S_IFSOCK;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFIFO</span>:
		mode |= S_IFIFO;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EBADF;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	};
	<span class="enscript-keyword">if</span> (isstat64 != 0) {
		sb64-&gt;st_mode = mode;
		sb64-&gt;st_nlink = VATTR_IS_SUPPORTED(&amp;va, va_nlink) ? (u_int16_t)va.va_nlink : 1;
		sb64-&gt;st_uid = va.va_uid;
		sb64-&gt;st_gid = va.va_gid;
		sb64-&gt;st_rdev = va.va_rdev;
		sb64-&gt;st_size = va.va_data_size;
		sb64-&gt;st_atimespec = va.va_access_time;
		sb64-&gt;st_mtimespec = va.va_modify_time;
		sb64-&gt;st_ctimespec = va.va_change_time;
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;va, va_create_time)) {
			sb64-&gt;st_birthtimespec =  va.va_create_time;
		} <span class="enscript-keyword">else</span> {
			sb64-&gt;st_birthtimespec.tv_sec = sb64-&gt;st_birthtimespec.tv_nsec = 0;
		}
		sb64-&gt;st_blksize = va.va_iosize;
		sb64-&gt;st_flags = va.va_flags;
		sb64-&gt;st_blocks = roundup(va.va_total_alloc, 512) / 512;
	} <span class="enscript-keyword">else</span> {
		sb-&gt;st_mode = mode;
		sb-&gt;st_nlink = VATTR_IS_SUPPORTED(&amp;va, va_nlink) ? (u_int16_t)va.va_nlink : 1;
		sb-&gt;st_uid = va.va_uid;
		sb-&gt;st_gid = va.va_gid;
		sb-&gt;st_rdev = va.va_rdev;
		sb-&gt;st_size = va.va_data_size;
		sb-&gt;st_atimespec = va.va_access_time;
		sb-&gt;st_mtimespec = va.va_modify_time;
		sb-&gt;st_ctimespec = va.va_change_time;
		sb-&gt;st_blksize = va.va_iosize;
		sb-&gt;st_flags = va.va_flags;
		sb-&gt;st_blocks = roundup(va.va_total_alloc, 512) / 512;
	}

	<span class="enscript-comment">/* if we're interested in extended security data and we got an ACL */</span>
	<span class="enscript-keyword">if</span> (xsec != NULL) {
		<span class="enscript-keyword">if</span> (!VATTR_IS_SUPPORTED(&amp;va, va_acl) &amp;&amp;
		    !VATTR_IS_SUPPORTED(&amp;va, va_uuuid) &amp;&amp;
		    !VATTR_IS_SUPPORTED(&amp;va, va_guuid)) {
			*xsec = KAUTH_FILESEC_NONE;
		} <span class="enscript-keyword">else</span> {
		
			<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;va, va_acl) &amp;&amp; (va.va_acl != NULL)) {
				fsec = kauth_filesec_alloc(va.va_acl-&gt;acl_entrycount);
			} <span class="enscript-keyword">else</span> {
				fsec = kauth_filesec_alloc(0);
			}
			<span class="enscript-keyword">if</span> (fsec == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			fsec-&gt;fsec_magic = KAUTH_FILESEC_MAGIC;
			<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;va, va_uuuid)) {
				fsec-&gt;fsec_owner = va.va_uuuid;
			} <span class="enscript-keyword">else</span> {
				fsec-&gt;fsec_owner = kauth_null_guid;
			}
			<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;va, va_guuid)) {
				fsec-&gt;fsec_group = va.va_guuid;
			} <span class="enscript-keyword">else</span> {
				fsec-&gt;fsec_group = kauth_null_guid;
			}
			<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;va, va_acl) &amp;&amp; (va.va_acl != NULL)) {
				bcopy(va.va_acl, &amp;(fsec-&gt;fsec_acl), KAUTH_ACL_COPYSIZE(va.va_acl));
			} <span class="enscript-keyword">else</span> {
				fsec-&gt;fsec_acl.acl_entrycount = KAUTH_FILESEC_NOACL;
			}
			*xsec = fsec;
		}
	}
	
	<span class="enscript-comment">/* Do not give the generation number out to unpriviledged users */</span>
	<span class="enscript-keyword">if</span> (va.va_gen &amp;&amp; !vfs_context_issuser(ctx)) {
		<span class="enscript-keyword">if</span> (isstat64 != 0)
			sb64-&gt;st_gen = 0; 
		<span class="enscript-keyword">else</span>
			sb-&gt;st_gen = 0; 
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (isstat64 != 0)
			sb64-&gt;st_gen = va.va_gen; 
		<span class="enscript-keyword">else</span>
			sb-&gt;st_gen = va.va_gen;
	}

	error = 0;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;va, va_acl) &amp;&amp; va.va_acl != NULL)
		kauth_acl_free(va.va_acl);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_stat</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">void</span> *sb, kauth_filesec_t *xsec, <span class="enscript-type">int</span> isstat64, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_stat(ctx, NOCRED, vp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* authorize */</span>
	<span class="enscript-keyword">if</span> ((error = vnode_authorize(vp, NULL, KAUTH_VNODE_READ_ATTRIBUTES | KAUTH_VNODE_READ_SECURITY, ctx)) != 0)
		<span class="enscript-keyword">return</span>(error);

	<span class="enscript-comment">/* actual stat */</span>
	<span class="enscript-keyword">return</span>(vn_stat_noauth(vp, sb, xsec, isstat64, ctx));
}


<span class="enscript-comment">/*
 * File table vnode ioctl routine.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vn_ioctl</span>(<span class="enscript-type">struct</span> fileproc *fp, u_long com, caddr_t data, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnode *vp = ((<span class="enscript-type">struct</span> vnode *)fp-&gt;f_fglob-&gt;fg_data);
	off_t file_size;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> vnode *ttyvp;
	<span class="enscript-type">struct</span> session * sessp;
	
	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) ) {
		<span class="enscript-keyword">return</span>(error);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_ioctl(ctx, vp, com);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">switch</span> (vp-&gt;v_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VREG</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VDIR</span>:
		<span class="enscript-keyword">if</span> (com == FIONREAD) {
			<span class="enscript-keyword">if</span> ((error = vnode_size(vp, &amp;file_size, ctx)) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			*(<span class="enscript-type">int</span> *)data = file_size - fp-&gt;f_fglob-&gt;fg_offset;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (com == FIONBIO || com == FIOASYNC) {	<span class="enscript-comment">/* XXX */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* fall into ... */</span>

	<span class="enscript-reference">default</span>:
		error = ENOTTY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFIFO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:

		<span class="enscript-comment">/* Should not be able to set block size from user space */</span>
		<span class="enscript-keyword">if</span> (com == DKIOCSETBLOCKSIZE) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-keyword">if</span> (com == FIODTYPE) {
			<span class="enscript-keyword">if</span> (vp-&gt;v_type == VBLK) {
				<span class="enscript-keyword">if</span> (major(vp-&gt;v_rdev) &gt;= nblkdev) {
					error = ENXIO;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				*(<span class="enscript-type">int</span> *)data = bdevsw[major(vp-&gt;v_rdev)].d_type;

			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vp-&gt;v_type == VCHR) {
				<span class="enscript-keyword">if</span> (major(vp-&gt;v_rdev) &gt;= nchrdev) {
					error = ENXIO;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				*(<span class="enscript-type">int</span> *)data = cdevsw[major(vp-&gt;v_rdev)].d_type;
			} <span class="enscript-keyword">else</span> {
				error = ENOTTY;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		error = VNOP_IOCTL(vp, com, data, fp-&gt;f_fglob-&gt;fg_flag, ctx);

		<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; com == TIOCSCTTY) {
			sessp = proc_session(vfs_context_proc(ctx));

			session_lock(sessp);
			ttyvp = sessp-&gt;s_ttyvp;
			sessp-&gt;s_ttyvp = vp;
			sessp-&gt;s_ttyvid = vnode_vid(vp);
			session_unlock(sessp);
			session_rele(sessp);
		}
	}
<span class="enscript-reference">out</span>:
	(<span class="enscript-type">void</span>)vnode_put(vp);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * File table vnode select routine.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vn_select</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">int</span> which, <span class="enscript-type">void</span> *wql, __unused vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> vnode * vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_fglob-&gt;fg_data;
	<span class="enscript-type">struct</span> vfs_context context;

	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {
		context.vc_thread = current_thread();
		context.vc_ucred = fp-&gt;f_fglob-&gt;fg_cred;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-comment">/*
		 * XXX We should use a per thread credential here; minimally,
		 * XXX the process credential should have a persistent
		 * XXX reference on it before being passed in here.
		 */</span>
		error = mac_vnode_check_select(ctx, vp, which);
		<span class="enscript-keyword">if</span> (error == 0)
#<span class="enscript-reference">endif</span>
	        error = VNOP_SELECT(vp, which, fp-&gt;f_fglob-&gt;fg_flag, wql, ctx);

		(<span class="enscript-type">void</span>)vnode_put(vp);
	}
	<span class="enscript-keyword">return</span>(error);
	
}

<span class="enscript-comment">/*
 * File table vnode close routine.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vn_closefile</span>(<span class="enscript-type">struct</span> fileglob *fg, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnode *vp = fg-&gt;fg_data;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(vp)) == 0 ) {
		<span class="enscript-keyword">if</span> (FILEGLOB_DTYPE(fg) == DTYPE_VNODE &amp;&amp;
		    ((fg-&gt;fg_flag &amp; FHASLOCK) != 0 || 
		    (fg-&gt;fg_lflags &amp; FG_HAS_OFDLOCK) != 0)) {
			<span class="enscript-type">struct</span> flock lf = {
				.l_whence = SEEK_SET,
				.l_start = 0,
				.l_len = 0,
				.l_type = F_UNLCK
			};

			<span class="enscript-keyword">if</span> ((fg-&gt;fg_flag &amp; FHASLOCK) != 0)
				(<span class="enscript-type">void</span>) VNOP_ADVLOCK(vp, (caddr_t)fg,
				    F_UNLCK, &amp;lf, F_FLOCK, ctx, NULL);

			<span class="enscript-keyword">if</span> ((fg-&gt;fg_lflags &amp; FG_HAS_OFDLOCK) != 0)
				(<span class="enscript-type">void</span>) VNOP_ADVLOCK(vp, (caddr_t)fg,
				    F_UNLCK, &amp;lf, F_OFD_LOCK, ctx, NULL);
		}
	        error = vn_close(vp, fg-&gt;fg_flag, ctx);
		(<span class="enscript-type">void</span>) vnode_put(vp);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *	VNOP_PATHCONF:???
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_pathconf</span>(vnode_t vp, <span class="enscript-type">int</span> name, int32_t *retval, vfs_context_t ctx)
{
	<span class="enscript-type">int</span>	error = 0;
	<span class="enscript-type">struct</span> vfs_attr vfa;

	<span class="enscript-keyword">switch</span>(name) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_EXTENDED_SECURITY_NP</span>:
		*retval = vfs_extendedsecurity(vnode_mount(vp)) ? 1 : 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_AUTH_OPAQUE_NP</span>:
		*retval = vfs_authopaque(vnode_mount(vp));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_2_SYMLINKS</span>:
		*retval = 1;	<span class="enscript-comment">/* XXX NOTSUP on MSDOS, etc. */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_ALLOC_SIZE_MIN</span>:
		*retval = 1;	<span class="enscript-comment">/* XXX lie: 1 byte */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_ASYNC_IO</span>:	<span class="enscript-comment">/* unistd.h: _POSIX_ASYNCHRONUS_IO */</span>
		*retval = 1;	<span class="enscript-comment">/* [AIO] option is supported */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_PRIO_IO</span>:	<span class="enscript-comment">/* unistd.h: _POSIX_PRIORITIZED_IO */</span>
		*retval = 0;	<span class="enscript-comment">/* [PIO] option is not supported */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_REC_INCR_XFER_SIZE</span>:
		*retval = 4096;	<span class="enscript-comment">/* XXX go from MIN to MAX 4K at a time */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_REC_MIN_XFER_SIZE</span>:
		*retval = 4096;	<span class="enscript-comment">/* XXX recommend 4K minimum reads/writes */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_REC_MAX_XFER_SIZE</span>:
		*retval = 65536; <span class="enscript-comment">/* XXX recommend 64K maximum reads/writes */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_REC_XFER_ALIGN</span>:
		*retval = 4096;	<span class="enscript-comment">/* XXX recommend page aligned buffers */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_SYMLINK_MAX</span>:
		*retval = 255;	<span class="enscript-comment">/* Minimum acceptable POSIX value */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_SYNC_IO</span>:	<span class="enscript-comment">/* unistd.h: _POSIX_SYNCHRONIZED_IO */</span>
		*retval = 0;	<span class="enscript-comment">/* [SIO] option is not supported */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_XATTR_SIZE_BITS</span>:
		<span class="enscript-comment">/* The number of bits used to store maximum extended 
		 * attribute size in bytes.  For example, if the maximum 
		 * attribute size supported by a file system is 128K, the 
		 * value returned will be 18.  However a value 18 can mean 
		 * that the maximum attribute size can be anywhere from 
		 * (256KB - 1) to 128KB.  As a special case, the resource 
		 * fork can have much larger size, and some file system 
		 * specific extended attributes can have smaller and preset 
		 * size; for example, Finder Info is always 32 bytes.
		 */</span>
		memset(&amp;vfa, 0, <span class="enscript-keyword">sizeof</span>(vfa));
		VFSATTR_INIT(&amp;vfa);
		VFSATTR_WANTED(&amp;vfa, f_capabilities);
		<span class="enscript-keyword">if</span> (vfs_getattr(vnode_mount(vp), &amp;vfa, ctx) == 0 &amp;&amp;
		    (VFSATTR_IS_SUPPORTED(&amp;vfa, f_capabilities)) &amp;&amp; 
		    (vfa.f_capabilities.capabilities[VOL_CAPABILITIES_INTERFACES] &amp; VOL_CAP_INT_EXTENDED_ATTR) &amp;&amp; 
		    (vfa.f_capabilities.valid[VOL_CAPABILITIES_INTERFACES] &amp; VOL_CAP_INT_EXTENDED_ATTR)) {
			<span class="enscript-comment">/* Supports native extended attributes */</span>
			error = VNOP_PATHCONF(vp, name, retval, ctx);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Number of bits used to represent the maximum size of 
			 * extended attribute stored in an Apple Double file.
			 */</span>
			*retval = AD_XATTR_SIZE_BITS;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = VNOP_PATHCONF(vp, name, retval, ctx);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vn_kqfilt_add</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> knote *kn, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> vnode *vp;
	
	vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_fglob-&gt;fg_data;

	<span class="enscript-comment">/*
	 * Don't attach a knote to a dead vnode.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = vget_internal(vp, 0, VNODE_NODEAD)) == 0) {
		<span class="enscript-keyword">switch</span> (kn-&gt;kn_filter) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_READ</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_WRITE</span>:
				<span class="enscript-keyword">if</span> (vnode_isfifo(vp)) {
					<span class="enscript-comment">/* We'll only watch FIFOs that use our fifofs */</span>
					<span class="enscript-keyword">if</span> (!(vp-&gt;v_fifoinfo &amp;&amp; vp-&gt;v_fifoinfo-&gt;fi_readsock)) {
						error = ENOTSUP;
					}

				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!vnode_isreg(vp)) {
					<span class="enscript-keyword">if</span> (vnode_ischr(vp) &amp;&amp; 
							(error = spec_kqfilter(vp, kn)) == 0) {
						<span class="enscript-comment">/* claimed by a special device */</span>
						vnode_put(vp);
						<span class="enscript-keyword">return</span> 0;
					}

					error = EINVAL;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_VNODE</span>:
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				error = EINVAL;
		}

		<span class="enscript-keyword">if</span> (error) {
			vnode_put(vp);
			<span class="enscript-keyword">return</span> error;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_vnode_check_kqfilter(ctx, fp-&gt;f_fglob-&gt;fg_cred, kn, vp);
		<span class="enscript-keyword">if</span> (error) {
			vnode_put(vp);
			<span class="enscript-keyword">return</span> error;
		}
#<span class="enscript-reference">endif</span>

		kn-&gt;kn_hook = (<span class="enscript-type">void</span>*)vp;
		kn-&gt;kn_hookid = vnode_vid(vp);
		kn-&gt;kn_fop = &amp;vnode_filtops;

		vnode_lock(vp);
		KNOTE_ATTACH(&amp;vp-&gt;v_knotes, kn);
		vnode_unlock(vp);

		<span class="enscript-comment">/* Ask the filesystem to provide remove notifications, but ignore failure */</span>
		VNOP_MONITOR(vp, 0, VNODE_MONITOR_BEGIN, (<span class="enscript-type">void</span>*) kn,  ctx);

		vnode_put(vp);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_vndetach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">struct</span> vnode *vp; 
	vp = (<span class="enscript-type">struct</span> vnode *)kn-&gt;kn_hook;
	<span class="enscript-keyword">if</span> (vnode_getwithvid(vp, kn-&gt;kn_hookid))
		<span class="enscript-keyword">return</span>;

	vnode_lock(vp);
	KNOTE_DETACH(&amp;vp-&gt;v_knotes, kn);
	vnode_unlock(vp);
	
	<span class="enscript-comment">/* 
	 * Tell a (generally networked) filesystem that we're no longer watching 
	 * If the FS wants to track contexts, it should still be using the one from
	 * the VNODE_MONITOR_BEGIN.
	 */</span>
	VNOP_MONITOR(vp, 0, VNODE_MONITOR_END, (<span class="enscript-type">void</span>*)kn, ctx);
	vnode_put(vp);
}


<span class="enscript-comment">/*
 * Used for EVFILT_READ
 *
 * Takes only VFIFO or VREG. vnode is locked.  We handle the &quot;poll&quot; case
 * differently than the regular case for VREG files.  If not in poll(),
 * then we need to know current fileproc offset for VREG.
 */</span>
<span class="enscript-type">static</span> intptr_t
<span class="enscript-function-name">vnode_readable_data_count</span>(vnode_t vp, off_t current_offset, <span class="enscript-type">int</span> ispoll)
{
	<span class="enscript-keyword">if</span> (vnode_isfifo(vp)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FIFO</span>
		<span class="enscript-type">int</span> cnt;
		<span class="enscript-type">int</span> err = fifo_charcount(vp, &amp;cnt);
		<span class="enscript-keyword">if</span> (err == 0) {
			<span class="enscript-keyword">return</span> (intptr_t)cnt;
		} <span class="enscript-keyword">else</span> 
#<span class="enscript-reference">endif</span>
		{
			<span class="enscript-keyword">return</span> (intptr_t)0;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vnode_isreg(vp)) {
		<span class="enscript-keyword">if</span> (ispoll) {
			<span class="enscript-keyword">return</span> (intptr_t)1;
		}

		off_t amount;
		amount = vp-&gt;v_un.vu_ubcinfo-&gt;ui_size - current_offset;
		<span class="enscript-keyword">if</span> (amount &gt; (off_t)INTPTR_MAX) {
			<span class="enscript-keyword">return</span> INTPTR_MAX;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (amount &lt; (off_t)INTPTR_MIN) {
			<span class="enscript-keyword">return</span> INTPTR_MIN;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span> (intptr_t)amount;
		} 
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;Should never have an EVFILT_READ except for reg or fifo.&quot;</span>);
		<span class="enscript-keyword">return</span> 0;
	}
}

<span class="enscript-comment">/*
 * Used for EVFILT_WRITE.  
 *
 * For regular vnodes, we can always write (1).  For named pipes,
 * see how much space there is in the buffer.  Nothing else is covered.
 */</span>
<span class="enscript-type">static</span> intptr_t
<span class="enscript-function-name">vnode_writable_space_count</span>(vnode_t vp) 
{
	<span class="enscript-keyword">if</span> (vnode_isfifo(vp)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FIFO</span>
		<span class="enscript-type">long</span> spc;
		<span class="enscript-type">int</span> err = fifo_freespace(vp, &amp;spc);
		<span class="enscript-keyword">if</span> (err == 0) {
			<span class="enscript-keyword">return</span> (intptr_t)spc;
		} <span class="enscript-keyword">else</span> 
#<span class="enscript-reference">endif</span>
		{
			<span class="enscript-keyword">return</span> (intptr_t)0;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vnode_isreg(vp)) {
		<span class="enscript-keyword">return</span> (intptr_t)1;
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;Should never have an EVFILT_READ except for reg or fifo.&quot;</span>);
		<span class="enscript-keyword">return</span> 0;
	}
}

<span class="enscript-comment">/* 
 * Determine whether this knote should be active
 * 
 * This is kind of subtle.  
 * 	--First, notice if the vnode has been revoked: in so, override hint
 * 	--EVFILT_READ knotes are checked no matter what the hint is
 * 	--Other knotes activate based on hint.  
 * 	--If hint is revoke, set special flags and activate
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_vnode</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	vnode_t vp = (<span class="enscript-type">struct</span> vnode *)kn-&gt;kn_hook;
	<span class="enscript-type">int</span> activate = 0;
	<span class="enscript-type">long</span> orig_hint = hint;

	<span class="enscript-keyword">if</span> (0 == hint) {
		vnode_lock(vp);

		<span class="enscript-keyword">if</span> (vnode_getiocount(vp, kn-&gt;kn_hookid, VNODE_NODEAD | VNODE_WITHID) != 0) {
			<span class="enscript-comment">/* Is recycled */</span>
			hint = NOTE_REVOKE;
		} 
	} <span class="enscript-keyword">else</span> {
		lck_mtx_assert(&amp;vp-&gt;v_lock, LCK_MTX_ASSERT_OWNED);
	}

	<span class="enscript-comment">/* Special handling for vnodes that are in recycle or already gone */</span>
	<span class="enscript-keyword">if</span> (NOTE_REVOKE == hint) {
		kn-&gt;kn_flags |= (EV_EOF | EV_ONESHOT);
		activate = 1;

		<span class="enscript-keyword">if</span> ((kn-&gt;kn_filter == EVFILT_VNODE) &amp;&amp; (kn-&gt;kn_sfflags &amp; NOTE_REVOKE)) {
			kn-&gt;kn_fflags |= NOTE_REVOKE;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">switch</span>(kn-&gt;kn_filter) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_READ</span>:
				kn-&gt;kn_data = vnode_readable_data_count(vp, kn-&gt;kn_fp-&gt;f_fglob-&gt;fg_offset, (kn-&gt;kn_flags &amp; EV_POLL));

				<span class="enscript-keyword">if</span> (kn-&gt;kn_data != 0) {
					activate = 1;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_WRITE</span>: 
				kn-&gt;kn_data = vnode_writable_space_count(vp);

				<span class="enscript-keyword">if</span> (kn-&gt;kn_data != 0) {
					activate = 1;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_VNODE</span>:
				<span class="enscript-comment">/* Check events this note matches against the hint */</span>
				<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; hint) {
					kn-&gt;kn_fflags |= hint; <span class="enscript-comment">/* Set which event occurred */</span>
				}
				<span class="enscript-keyword">if</span> (kn-&gt;kn_fflags != 0) {
					activate = 1;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				panic(<span class="enscript-string">&quot;Invalid knote filter on a vnode!\n&quot;</span>);
		}
	}

	<span class="enscript-keyword">if</span> (orig_hint == 0) {
		<span class="enscript-comment">/*
		 * Definitely need to unlock, may need to put 
		 */</span>
		<span class="enscript-keyword">if</span> (hint == 0) {
			vnode_put_locked(vp);
		}
		vnode_unlock(vp);
	}

	<span class="enscript-keyword">return</span> (activate);
}
</pre>
<hr />
</body></html>