<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_journal.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_journal.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2002-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">//
</span><span class="enscript-comment">// This file implements a simple write-ahead journaling layer.  
</span><span class="enscript-comment">// In theory any file system can make use of it by calling these 
</span><span class="enscript-comment">// functions when the fs wants to modify meta-data blocks.  See
</span><span class="enscript-comment">// vfs_journal.h for a more detailed description of the api and
</span><span class="enscript-comment">// data structures.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Dominic Giampaolo (<a href="mailto:dbg@apple.com">dbg@apple.com</a>)
</span><span class="enscript-comment">//
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tty.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>	<span class="enscript-comment">/* OSAddAtomic */</span>

kern_return_t	thread_terminate(thread_t);

<span class="enscript-comment">/*
 * Set sysctl vfs.generic.jnl.kdebug.trim=1 to enable KERNEL_DEBUG_CONSTANT
 * logging of trim-related calls within the journal.  (They're
 * disabled by default because there can be a lot of these events,
 * and we don't want to overwhelm the kernel debug buffer.  If you
 * want to watch these events in particular, just set the sysctl.)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> jnl_kdebug = 0;
<span class="enscript-function-name">SYSCTL_DECL</span>(_vfs_generic);
<span class="enscript-function-name">SYSCTL_NODE</span>(_vfs_generic, OID_AUTO, jnl, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;Journal&quot;</span>);
<span class="enscript-function-name">SYSCTL_NODE</span>(_vfs_generic_jnl, OID_AUTO, kdebug, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;Journal kdebug&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_jnl_kdebug, OID_AUTO, trim, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;jnl_kdebug, 0, <span class="enscript-string">&quot;Enable kdebug logging for journal TRIM&quot;</span>);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_JOURNAL_FLUSH</span>			FSDBG_CODE(DBG_JOURNAL, 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_JOURNAL_TRIM_ADD</span>		FSDBG_CODE(DBG_JOURNAL, 2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_JOURNAL_TRIM_REMOVE</span>		FSDBG_CODE(DBG_JOURNAL, 3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_JOURNAL_TRIM_REMOVE_PENDING</span>	FSDBG_CODE(DBG_JOURNAL, 4)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_JOURNAL_TRIM_REALLOC</span>	FSDBG_CODE(DBG_JOURNAL, 5)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_JOURNAL_TRIM_FLUSH</span>		FSDBG_CODE(DBG_JOURNAL, 6)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_JOURNAL_TRIM_UNMAP</span>		FSDBG_CODE(DBG_JOURNAL, 7)

<span class="enscript-comment">/* 
 * Cap the journal max size to 2GB.  On HFS, it will attempt to occupy
 * a full allocation block if the current size is smaller than the allocation
 * block on which it resides.  Once we hit the exabyte filesystem range, then
 * it will use 2GB allocation blocks.  As a result, make the cap 2GB.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_JOURNAL_SIZE</span> 0x80000000U

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sdt.h&gt;</span> <span class="enscript-comment">/* DTRACE_IO1 */</span>
#<span class="enscript-reference">else</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;limits.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;compat.h&quot;</span>

#<span class="enscript-reference">endif</span>   <span class="enscript-comment">/* KERNEL */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;vfs_journal.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">KERNEL_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERNEL_DEBUG</span> KERNEL_DEBUG_CONSTANT
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">CONFIG_HFS_TRIM</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CONFIG_HFS_TRIM</span> 0
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">JOURNALING</span>

<span class="enscript-comment">//
</span><span class="enscript-comment">// By default, we grow the list of extents to trim by 4K at a time.
</span><span class="enscript-comment">// We'll opt to flush a transaction if it contains at least
</span><span class="enscript-comment">// JOURNAL_FLUSH_TRIM_EXTENTS extents to be trimmed (even if the number
</span><span class="enscript-comment">// of modified blocks is small).
</span><span class="enscript-comment">//
</span><span class="enscript-type">enum</span> {
    JOURNAL_DEFAULT_TRIM_BYTES = 4096,
    JOURNAL_DEFAULT_TRIM_EXTENTS = JOURNAL_DEFAULT_TRIM_BYTES / <span class="enscript-keyword">sizeof</span>(dk_extent_t),
    JOURNAL_FLUSH_TRIM_EXTENTS = JOURNAL_DEFAULT_TRIM_EXTENTS * 15 / 16
};

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> jnl_trim_flush_limit = JOURNAL_FLUSH_TRIM_EXTENTS;
<span class="enscript-function-name">SYSCTL_UINT</span> (_kern, OID_AUTO, jnl_trim_flush, CTLFLAG_RW, &amp;jnl_trim_flush_limit, 0, <span class="enscript-string">&quot;number of trimmed extents to cause a journal flush&quot;</span>);

<span class="enscript-comment">/* XXX next prototype should be from libsa/stdlib.h&gt; but conflicts libkern */</span>
__private_extern__ <span class="enscript-type">void</span> qsort(
	<span class="enscript-type">void</span> * array,
	size_t nmembers,
	size_t member_size,
	<span class="enscript-type">int</span> (*)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *));



<span class="enscript-comment">// number of bytes to checksum in a block_list_header
</span><span class="enscript-comment">// NOTE: this should be enough to clear out the header
</span><span class="enscript-comment">//       fields as well as the first entry of binfo[]
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BLHDR_CHECKSUM_SIZE</span> 32

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">lock_condition</span>(journal *jnl, boolean_t *condition, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *condition_name);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wait_condition</span>(journal *jnl, boolean_t *condition, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *condition_name);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">unlock_condition</span>(journal *jnl, boolean_t *condition);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">finish_end_thread</span>(transaction *tr);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">write_header_thread</span>(journal *jnl);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">finish_end_transaction</span>(transaction *tr, errno_t (*callback)(<span class="enscript-type">void</span>*), <span class="enscript-type">void</span> *callback_arg);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">end_transaction</span>(transaction *tr, <span class="enscript-type">int</span> force_it, errno_t (*callback)(<span class="enscript-type">void</span>*), <span class="enscript-type">void</span> *callback_arg, boolean_t drop_lock, boolean_t must_wait);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">abort_transaction</span>(journal *jnl, transaction *tr);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dump_journal</span>(journal *jnl);

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>  <span class="enscript-function-name">lock_oldstart</span>(journal *jnl);
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>  <span class="enscript-function-name">unlock_oldstart</span>(journal *jnl);
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>  <span class="enscript-function-name">lock_flush</span>(journal *jnl);
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>  <span class="enscript-function-name">unlock_flush</span>(journal *jnl);


<span class="enscript-comment">//
</span><span class="enscript-comment">// 3105942 - Coalesce writes to the same block on journal replay
</span><span class="enscript-comment">//
</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> bucket {
	off_t     block_num;
	uint32_t  jnl_offset;
	uint32_t  block_size;
	int32_t   cksum;
} bucket;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">STARTING_BUCKETS</span> 256

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">add_block</span>(journal *jnl, <span class="enscript-type">struct</span> bucket **buf_ptr, off_t block_num, size_t size, size_t offset, int32_t cksum, <span class="enscript-type">int</span> *num_buckets_ptr, <span class="enscript-type">int</span> *num_full_ptr);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">grow_table</span>(<span class="enscript-type">struct</span> bucket **buf_ptr, <span class="enscript-type">int</span> num_buckets, <span class="enscript-type">int</span> new_size);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">lookup_bucket</span>(<span class="enscript-type">struct</span> bucket **buf_ptr, off_t block_num, <span class="enscript-type">int</span> num_full);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">do_overlap</span>(journal *jnl, <span class="enscript-type">struct</span> bucket **buf_ptr, <span class="enscript-type">int</span> blk_index, off_t block_num, size_t size, size_t offset, int32_t cksum, <span class="enscript-type">int</span> *num_buckets_ptr, <span class="enscript-type">int</span> *num_full_ptr);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">insert_block</span>(journal *jnl, <span class="enscript-type">struct</span> bucket **buf_ptr, <span class="enscript-type">int</span> blk_index, off_t num, size_t size, size_t offset, int32_t cksum, <span class="enscript-type">int</span> *num_buckets_ptr, <span class="enscript-type">int</span> *num_full_ptr, <span class="enscript-type">int</span> overwriting);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CHECK_JOURNAL</span>(jnl) \
	<span class="enscript-keyword">do</span> {		   \
	<span class="enscript-keyword">if</span> (jnl == NULL) {					\
		panic(<span class="enscript-string">&quot;%s:%d: null journal ptr?\n&quot;</span>, __FILE__, __LINE__); \
	}								\
	<span class="enscript-keyword">if</span> (jnl-&gt;jdev == NULL) {				\
		panic(<span class="enscript-string">&quot;%s:%d: jdev is null!\n&quot;</span>, __FILE__, __LINE__); \
	}							\
	<span class="enscript-keyword">if</span> (jnl-&gt;fsdev == NULL) {				\
		panic(<span class="enscript-string">&quot;%s:%d: fsdev is null!\n&quot;</span>, __FILE__, __LINE__);	\
	}								\
	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;magic != JOURNAL_HEADER_MAGIC) {			\
		panic(<span class="enscript-string">&quot;%s:%d: jhdr magic corrupted (0x%x != 0x%x)\n&quot;</span>,	\
		      __FILE__, __LINE__, jnl-&gt;jhdr-&gt;magic, JOURNAL_HEADER_MAGIC); \
	}								\
	<span class="enscript-keyword">if</span> (   jnl-&gt;jhdr-&gt;start &lt;= 0					\
	       || jnl-&gt;jhdr-&gt;start &gt; jnl-&gt;jhdr-&gt;size) {			\
		panic(<span class="enscript-string">&quot;%s:%d: jhdr start looks bad (0x%llx max size 0x%llx)\n&quot;</span>, \
		      __FILE__, __LINE__, jnl-&gt;jhdr-&gt;start, jnl-&gt;jhdr-&gt;size); \
	}								\
	<span class="enscript-keyword">if</span> (   jnl-&gt;jhdr-&gt;end &lt;= 0					\
	       || jnl-&gt;jhdr-&gt;end &gt; jnl-&gt;jhdr-&gt;size) {			\
		panic(<span class="enscript-string">&quot;%s:%d: jhdr end looks bad (0x%llx max size 0x%llx)\n&quot;</span>, \
		      __FILE__, __LINE__, jnl-&gt;jhdr-&gt;end, jnl-&gt;jhdr-&gt;size); \
	}								\
	} <span class="enscript-keyword">while</span>(0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CHECK_TRANSACTION</span>(tr) \
	<span class="enscript-keyword">do</span> {		      \
	<span class="enscript-keyword">if</span> (tr == NULL) {					\
		panic(<span class="enscript-string">&quot;%s:%d: null transaction ptr?\n&quot;</span>, __FILE__, __LINE__); \
	}								\
	<span class="enscript-keyword">if</span> (tr-&gt;jnl == NULL) {						\
		panic(<span class="enscript-string">&quot;%s:%d: null tr-&gt;jnl ptr?\n&quot;</span>, __FILE__, __LINE__); \
	}								\
	<span class="enscript-keyword">if</span> (tr-&gt;blhdr != (block_list_header *)tr-&gt;tbuffer) {		\
		panic(<span class="enscript-string">&quot;%s:%d: blhdr (%p) != tbuffer (%p)\n&quot;</span>, __FILE__, __LINE__, tr-&gt;blhdr, tr-&gt;tbuffer); \
	}								\
	<span class="enscript-keyword">if</span> (tr-&gt;total_bytes &lt; 0) {					\
		panic(<span class="enscript-string">&quot;%s:%d: tr total_bytes looks bad: %d\n&quot;</span>, __FILE__, __LINE__, tr-&gt;total_bytes); \
	}								\
	<span class="enscript-keyword">if</span> (tr-&gt;journal_start &lt; 0) {					\
		panic(<span class="enscript-string">&quot;%s:%d: tr journal start looks bad: 0x%llx\n&quot;</span>, __FILE__, __LINE__, tr-&gt;journal_start); \
	}								\
	<span class="enscript-keyword">if</span> (tr-&gt;journal_end &lt; 0) {					\
		panic(<span class="enscript-string">&quot;%s:%d: tr journal end looks bad: 0x%llx\n&quot;</span>, __FILE__, __LINE__, tr-&gt;journal_end); \
	}								\
	<span class="enscript-keyword">if</span> (tr-&gt;blhdr &amp;&amp; (tr-&gt;blhdr-&gt;max_blocks &lt;= 0 || tr-&gt;blhdr-&gt;max_blocks &gt; (tr-&gt;jnl-&gt;jhdr-&gt;size/tr-&gt;jnl-&gt;jhdr-&gt;jhdr_size))) { \
		panic(<span class="enscript-string">&quot;%s:%d: tr blhdr max_blocks looks bad: %d\n&quot;</span>, __FILE__, __LINE__, tr-&gt;blhdr-&gt;max_blocks);	\
	}								\
	} <span class="enscript-keyword">while</span>(0)



<span class="enscript-comment">//
</span><span class="enscript-comment">// this isn't a great checksum routine but it will do for now.
</span><span class="enscript-comment">// we use it to checksum the journal header and the block list
</span><span class="enscript-comment">// headers that are at the start of each transaction.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">calc_checksum</span>(<span class="enscript-type">char</span> *ptr, <span class="enscript-type">int</span> len)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> cksum=0;

	<span class="enscript-comment">// this is a lame checksum but for now it'll do
</span>	<span class="enscript-keyword">for</span>(i = 0; i &lt; len; i++, ptr++) {
		cksum = (cksum &lt;&lt; 8) ^ (cksum + *(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)ptr);
	}

	<span class="enscript-keyword">return</span> (~cksum);
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// Journal Locking
</span><span class="enscript-comment">//
</span>lck_grp_attr_t *  jnl_group_attr;
lck_attr_t *      jnl_lock_attr;
lck_grp_t *       jnl_mutex_group;

<span class="enscript-type">void</span>
<span class="enscript-function-name">journal_init</span>(<span class="enscript-type">void</span>)
{
	jnl_lock_attr    = lck_attr_alloc_init();
	jnl_group_attr   = lck_grp_attr_alloc_init();
	jnl_mutex_group  = lck_grp_alloc_init(<span class="enscript-string">&quot;jnl-mutex&quot;</span>, jnl_group_attr);
}

__inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">journal_lock</span>(journal *jnl)
{
	lck_mtx_lock(&amp;jnl-&gt;jlock);
	<span class="enscript-keyword">if</span> (jnl-&gt;owner) {
		panic (<span class="enscript-string">&quot;jnl: owner is %p, expected NULL\n&quot;</span>, jnl-&gt;owner);
	}
	jnl-&gt;owner = current_thread();
}

__inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">journal_unlock</span>(journal *jnl)
{
	jnl-&gt;owner = NULL;
	lck_mtx_unlock(&amp;jnl-&gt;jlock);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">lock_flush</span>(journal *jnl)
{
	lck_mtx_lock(&amp;jnl-&gt;flock);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">unlock_flush</span>(journal *jnl)
{
	lck_mtx_unlock(&amp;jnl-&gt;flock);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">lock_oldstart</span>(journal *jnl)
{
	lck_mtx_lock(&amp;jnl-&gt;old_start_lock);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">unlock_oldstart</span>(journal *jnl)
{
	lck_mtx_unlock(&amp;jnl-&gt;old_start_lock);
}



#<span class="enscript-reference">define</span> <span class="enscript-variable-name">JNL_WRITE</span>    0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">JNL_READ</span>     0x0002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">JNL_HEADER</span>   0x8000

<span class="enscript-comment">//
</span><span class="enscript-comment">// This function sets up a fake buf and passes it directly to the
</span><span class="enscript-comment">// journal device strategy routine (so that it won't get cached in
</span><span class="enscript-comment">// the block cache.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// It also handles range checking the i/o so that we don't write
</span><span class="enscript-comment">// outside the journal boundaries and it will wrap the i/o back
</span><span class="enscript-comment">// to the beginning if necessary (skipping over the journal header)
</span><span class="enscript-comment">// 
</span><span class="enscript-type">static</span> size_t
<span class="enscript-function-name">do_journal_io</span>(journal *jnl, off_t *offset, <span class="enscript-type">void</span> *data, size_t len, <span class="enscript-type">int</span> direction)
{
	<span class="enscript-type">int</span>	err, curlen=len;
	size_t	io_sz = 0;
	buf_t	bp;
	off_t 	max_iosize;
	<span class="enscript-type">struct</span> bufattr *bap;
	boolean_t was_vm_privileged = FALSE;
	boolean_t need_vm_privilege = FALSE;

	<span class="enscript-keyword">if</span> (jnl-&gt;fsmount) {
		<span class="enscript-keyword">if</span> (jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT)
			need_vm_privilege = TRUE;
	}

	<span class="enscript-keyword">if</span> (*offset &lt; 0 || *offset &gt; jnl-&gt;jhdr-&gt;size) {
		panic(<span class="enscript-string">&quot;jnl: do_jnl_io: bad offset 0x%llx (max 0x%llx)\n&quot;</span>, *offset, jnl-&gt;jhdr-&gt;size);
	}
	
	<span class="enscript-keyword">if</span> (direction &amp; JNL_WRITE)
		max_iosize = jnl-&gt;max_write_size;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (direction &amp; JNL_READ)
		max_iosize = jnl-&gt;max_read_size;
	<span class="enscript-keyword">else</span>
		max_iosize = 128 * 1024;

<span class="enscript-reference">again</span>:
	bp = alloc_io_buf(jnl-&gt;jdev, 1);

	<span class="enscript-keyword">if</span> (*offset + (off_t)curlen &gt; jnl-&gt;jhdr-&gt;size &amp;&amp; *offset != 0 &amp;&amp; jnl-&gt;jhdr-&gt;size != 0) {
		<span class="enscript-keyword">if</span> (*offset == jnl-&gt;jhdr-&gt;size) {
			*offset = jnl-&gt;jhdr-&gt;jhdr_size;
		} <span class="enscript-keyword">else</span> {
			curlen = (off_t)jnl-&gt;jhdr-&gt;size - *offset;
		}
	}

	<span class="enscript-keyword">if</span> (curlen &gt; max_iosize) {
		curlen = max_iosize;
	}

	<span class="enscript-keyword">if</span> (curlen &lt;= 0) {
		panic(<span class="enscript-string">&quot;jnl: do_jnl_io: curlen == %d, offset 0x%llx len %zd\n&quot;</span>, curlen, *offset, len);
	}

	<span class="enscript-keyword">if</span> (*offset == 0 &amp;&amp; (direction &amp; JNL_HEADER) == 0) {
		panic(<span class="enscript-string">&quot;jnl: request for i/o to jnl-header without JNL_HEADER flag set! (len %d, data %p)\n&quot;</span>, curlen, data);
	}

	<span class="enscript-comment">/*
	 * As alluded to in the block comment at the top of the function, we use a &quot;fake&quot; iobuf
	 * here and issue directly to the disk device that the journal protects since we don't
	 * want this to enter the block cache.  As a result, we lose the ability to mark it
	 * as a metadata buf_t for the layers below us that may care. If we were to
	 * simply attach the B_META flag into the b_flags this may confuse things further
	 * since this is an iobuf, not a metadata buffer. 
	 *
	 * To address this, we use the extended bufattr struct embedded in the bp. 
	 * Explicitly mark the buf here as a metadata buffer in its bufattr flags.
	 */</span>
	bap = &amp;bp-&gt;b_attr;
	bap-&gt;ba_flags |= BA_META;
	
	<span class="enscript-keyword">if</span> (direction &amp; JNL_READ)
		buf_setflags(bp, B_READ);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * don't have to set any flags
		 */</span>
		vnode_startwrite(jnl-&gt;jdev);
	}
	buf_setsize(bp, curlen);
	buf_setcount(bp, curlen);
	buf_setdataptr(bp, (uintptr_t)data);
	buf_setblkno(bp, (daddr64_t) ((jnl-&gt;jdev_offset + *offset) / (off_t)jnl-&gt;jhdr-&gt;jhdr_size));
	buf_setlblkno(bp, (daddr64_t) ((jnl-&gt;jdev_offset + *offset) / (off_t)jnl-&gt;jhdr-&gt;jhdr_size));

	<span class="enscript-keyword">if</span> ((direction &amp; JNL_WRITE) &amp;&amp; (jnl-&gt;flags &amp; JOURNAL_DO_FUA_WRITES)) {
		buf_markfua(bp);
	}

	<span class="enscript-keyword">if</span> (need_vm_privilege == TRUE) {
		<span class="enscript-comment">/*
		 * if we block waiting for memory, and there is enough pressure to
		 * cause us to try and create a new swap file, we may end up deadlocking
		 * due to waiting for the journal on the swap file creation path...
		 * by making ourselves vm_privileged, we give ourselves the best chance
		 * of not blocking
		 */</span>
		was_vm_privileged = set_vm_privilege(TRUE);
	}
	DTRACE_IO1(journal__start, buf_t, bp);
	err = VNOP_STRATEGY(bp);
	<span class="enscript-keyword">if</span> (!err) {
		err = (<span class="enscript-type">int</span>)buf_biowait(bp);
	}
	DTRACE_IO1(journal__done, buf_t, bp);

	<span class="enscript-keyword">if</span> (need_vm_privilege == TRUE &amp;&amp; was_vm_privileged == FALSE)
		set_vm_privilege(FALSE);

	free_io_buf(bp);

	<span class="enscript-keyword">if</span> (err) {
		printf(<span class="enscript-string">&quot;jnl: %s: do_jnl_io: strategy err 0x%x\n&quot;</span>, jnl-&gt;jdev_name, err);
		<span class="enscript-keyword">return</span> 0;
	}

	*offset += curlen;
	io_sz   += curlen;

	<span class="enscript-keyword">if</span> (io_sz != len) {
		<span class="enscript-comment">// handle wrap-around
</span>		data    = (<span class="enscript-type">char</span> *)data + curlen;
		curlen  = len - io_sz;
		<span class="enscript-keyword">if</span> (*offset &gt;= jnl-&gt;jhdr-&gt;size) {
			*offset = jnl-&gt;jhdr-&gt;jhdr_size;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}

	<span class="enscript-keyword">return</span> io_sz;
}

<span class="enscript-type">static</span> size_t
<span class="enscript-function-name">read_journal_data</span>(journal *jnl, off_t *offset, <span class="enscript-type">void</span> *data, size_t len)
{
	<span class="enscript-keyword">return</span> do_journal_io(jnl, offset, data, len, JNL_READ);
}

<span class="enscript-type">static</span> size_t
<span class="enscript-function-name">write_journal_data</span>(journal *jnl, off_t *offset, <span class="enscript-type">void</span> *data, size_t len)
{
	<span class="enscript-keyword">return</span> do_journal_io(jnl, offset, data, len, JNL_WRITE);
}


<span class="enscript-type">static</span> size_t
<span class="enscript-function-name">read_journal_header</span>(journal *jnl, <span class="enscript-type">void</span> *data, size_t len)
{
	off_t hdr_offset = 0;
	
	<span class="enscript-keyword">return</span> do_journal_io(jnl, &amp;hdr_offset, data, len, JNL_READ|JNL_HEADER);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">write_journal_header</span>(journal *jnl, <span class="enscript-type">int</span> updating_start, uint32_t sequence_num)
{
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> num_err_prints = 0;
	<span class="enscript-type">int</span> ret=0;
	off_t jhdr_offset = 0;
	<span class="enscript-type">struct</span> vfs_context context;

	context.vc_thread = current_thread();
	context.vc_ucred = NOCRED;
	<span class="enscript-comment">// 
</span>	<span class="enscript-comment">// Flush the track cache if we're not doing force-unit-access
</span>	<span class="enscript-comment">// writes.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (!updating_start &amp;&amp; (jnl-&gt;flags &amp; JOURNAL_DO_FUA_WRITES) == 0) {

		dk_synchronize_t sync_request = {
			.options			= DK_SYNCHRONIZE_OPTION_BARRIER,
		};

		<span class="enscript-comment">/*
		 * If device doesn't support barrier-only flush, or
		 * the journal is on a different device, use full flush.
		 */</span>
		<span class="enscript-keyword">if</span> (!(jnl-&gt;flags &amp; JOURNAL_FEATURE_BARRIER) || (jnl-&gt;jdev != jnl-&gt;fsdev)) {
			sync_request.options = 0;
			jnl-&gt;flush_counter++;
		}

		ret = VNOP_IOCTL(jnl-&gt;jdev, DKIOCSYNCHRONIZE, (caddr_t)&amp;sync_request, FWRITE, &amp;context);
	}
	<span class="enscript-keyword">if</span> (ret != 0) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// Only print this error if it's a different error than the
</span>		<span class="enscript-comment">// previous one, or if it's the first time for this device
</span>		<span class="enscript-comment">// or if the total number of printfs is less than 25.  We
</span>		<span class="enscript-comment">// allow for up to 25 printfs to insure that some make it
</span>		<span class="enscript-comment">// into the on-disk syslog.  Otherwise if we only printed
</span>		<span class="enscript-comment">// one, it's possible it would never make it to the syslog
</span>		<span class="enscript-comment">// for the root volume and that makes debugging hard.
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> (   ret != jnl-&gt;last_flush_err
		       || (jnl-&gt;flags &amp; JOURNAL_FLUSHCACHE_ERR) == 0
		       || num_err_prints++ &lt; 25) {
	    
			printf(<span class="enscript-string">&quot;jnl: %s: flushing fs disk buffer returned 0x%x\n&quot;</span>, jnl-&gt;jdev_name, ret);
	    
			jnl-&gt;flags |= JOURNAL_FLUSHCACHE_ERR;
			jnl-&gt;last_flush_err = ret;
		}
	}

	jnl-&gt;jhdr-&gt;sequence_num = sequence_num;
	jnl-&gt;jhdr-&gt;checksum = 0;
	jnl-&gt;jhdr-&gt;checksum = calc_checksum((<span class="enscript-type">char</span> *)jnl-&gt;jhdr, JOURNAL_HEADER_CKSUM_SIZE);

	<span class="enscript-keyword">if</span> (do_journal_io(jnl, &amp;jhdr_offset, jnl-&gt;header_buf, jnl-&gt;jhdr-&gt;jhdr_size, JNL_WRITE|JNL_HEADER) != (size_t)jnl-&gt;jhdr-&gt;jhdr_size) {
		printf(<span class="enscript-string">&quot;jnl: %s: write_journal_header: error writing the journal header!\n&quot;</span>, jnl-&gt;jdev_name);
		jnl-&gt;flags |= JOURNAL_INVALID;
		<span class="enscript-keyword">return</span> -1;
	}	

	<span class="enscript-comment">// If we're not doing force-unit-access writes, then we
</span>	<span class="enscript-comment">// have to flush after writing the journal header so that
</span>	<span class="enscript-comment">// a future transaction doesn't sneak out to disk before
</span>	<span class="enscript-comment">// the header does and thus overwrite data that the old
</span>	<span class="enscript-comment">// journal header refers to.  Saw this exact case happen
</span>	<span class="enscript-comment">// on an IDE bus analyzer with Larry Barras so while it
</span>	<span class="enscript-comment">// may seem obscure, it's not.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (updating_start &amp;&amp; (jnl-&gt;flags &amp; JOURNAL_DO_FUA_WRITES) == 0) {

		dk_synchronize_t sync_request = {
			.options			= DK_SYNCHRONIZE_OPTION_BARRIER,
		};

		<span class="enscript-comment">/*
		 * If device doesn't support barrier-only flush, or
		 * the journal is on a different device, use full flush.
		 */</span>
		<span class="enscript-keyword">if</span> (!(jnl-&gt;flags &amp; JOURNAL_FEATURE_BARRIER) || (jnl-&gt;jdev != jnl-&gt;fsdev)) {
			sync_request.options = 0;
			jnl-&gt;flush_counter++;
		}

		VNOP_IOCTL(jnl-&gt;jdev, DKIOCSYNCHRONIZE, (caddr_t)&amp;sync_request, FWRITE, &amp;context);
	}

	<span class="enscript-keyword">return</span> 0;
}



<span class="enscript-comment">//
</span><span class="enscript-comment">// this is a work function used to free up transactions that
</span><span class="enscript-comment">// completed. they can't be free'd from buffer_flushed_callback
</span><span class="enscript-comment">// because it is called from deep with the disk driver stack
</span><span class="enscript-comment">// and thus can't do something that would potentially cause
</span><span class="enscript-comment">// paging.  it gets called by each of the journal api entry
</span><span class="enscript-comment">// points so stuff shouldn't hang around for too long.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">free_old_stuff</span>(journal *jnl)
{
	transaction *tr, *next;
	block_list_header  *blhdr=NULL, *next_blhdr=NULL;

	<span class="enscript-keyword">if</span> (jnl-&gt;tr_freeme == NULL)
		<span class="enscript-keyword">return</span>;

	lock_oldstart(jnl);
	tr = jnl-&gt;tr_freeme;
	jnl-&gt;tr_freeme = NULL;
	unlock_oldstart(jnl);

	<span class="enscript-keyword">for</span>(; tr; tr=next) {
		<span class="enscript-keyword">for</span> (blhdr = tr-&gt;blhdr; blhdr; blhdr = next_blhdr) {
			next_blhdr = (block_list_header *)((<span class="enscript-type">long</span>)blhdr-&gt;binfo[0].bnum);
			blhdr-&gt;binfo[0].bnum = 0xdeadc0de;
		    
			kmem_free(kernel_map, (vm_offset_t)blhdr, tr-&gt;tbuffer_size);

			KERNEL_DEBUG(0xbbbbc01c, jnl, tr, tr-&gt;tbuffer_size, 0, 0);
		}
		next = tr-&gt;next;
		FREE_ZONE(tr, <span class="enscript-keyword">sizeof</span>(transaction), M_JNL_TR);
	}
}



<span class="enscript-comment">//
</span><span class="enscript-comment">// This is our callback that lets us know when a buffer has been
</span><span class="enscript-comment">// flushed to disk.  It's called from deep within the driver stack
</span><span class="enscript-comment">// and thus is quite limited in what it can do.  Notably, it can
</span><span class="enscript-comment">// not initiate any new i/o's or allocate/free memory.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">buffer_flushed_callback</span>(<span class="enscript-type">struct</span> buf *bp, <span class="enscript-type">void</span> *arg)
{
	transaction  *tr;
	journal      *jnl;
	transaction  *ctr, *prev=NULL, *next;
	size_t        i;
	<span class="enscript-type">int</span>           bufsize, amt_flushed, total_bytes;


	<span class="enscript-comment">//printf(&quot;jnl: buf flush: bp @ 0x%x l/blkno %qd/%qd vp 0x%x tr @ 0x%x\n&quot;,
</span>	<span class="enscript-comment">//	   bp, buf_lblkno(bp), buf_blkno(bp), buf_vnode(bp), arg);
</span>
	<span class="enscript-comment">// snarf out the bits we want
</span>	bufsize = buf_size(bp);
	tr      = (transaction *)arg;

	<span class="enscript-comment">// then we've already seen it
</span>	<span class="enscript-keyword">if</span> (tr == NULL) {
		<span class="enscript-keyword">return</span>;
	}

	CHECK_TRANSACTION(tr);

	jnl = tr-&gt;jnl;

	CHECK_JOURNAL(jnl);

	amt_flushed = tr-&gt;num_killed;
	total_bytes = tr-&gt;total_bytes;
    
	<span class="enscript-comment">// update the number of blocks that have been flushed.
</span>	<span class="enscript-comment">// this buf may represent more than one block so take
</span>	<span class="enscript-comment">// that into account.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// OSAddAtomic() returns the value of tr-&gt;num_flushed before the add
</span>	<span class="enscript-comment">//
</span>	amt_flushed += OSAddAtomic(bufsize, &amp;tr-&gt;num_flushed);


	<span class="enscript-comment">// if this transaction isn't done yet, just return as
</span>	<span class="enscript-comment">// there is nothing to do.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// NOTE: we are careful to not reference anything through
</span>	<span class="enscript-comment">//       the tr pointer after doing the OSAddAtomic().  if
</span>	<span class="enscript-comment">//       this if statement fails then we are the last one
</span>	<span class="enscript-comment">//       and then it's ok to dereference &quot;tr&quot;.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> ((amt_flushed + bufsize) &lt; total_bytes) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">// this will single thread checking the transaction
</span>	lock_oldstart(jnl);

	<span class="enscript-keyword">if</span> (tr-&gt;total_bytes == (<span class="enscript-type">int</span>)0xfbadc0de) {
		<span class="enscript-comment">// then someone beat us to it...
</span>		unlock_oldstart(jnl);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">// mark this so that we're the owner of dealing with the
</span>	<span class="enscript-comment">// cleanup for this transaction
</span>	tr-&gt;total_bytes = 0xfbadc0de;

	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_INVALID)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">transaction_done</span>;

	<span class="enscript-comment">//printf(&quot;jnl: tr 0x%x (0x%llx 0x%llx) in jnl 0x%x completed.\n&quot;,
</span>	<span class="enscript-comment">//   tr, tr-&gt;journal_start, tr-&gt;journal_end, jnl);
</span>
	<span class="enscript-comment">// find this entry in the old_start[] index and mark it completed
</span>	<span class="enscript-keyword">for</span>(i = 0; i &lt; <span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start)/<span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start[0]); i++) {
	
		<span class="enscript-keyword">if</span> ((off_t)(jnl-&gt;old_start[i] &amp; ~(0x8000000000000000ULL)) == tr-&gt;journal_start) {
			jnl-&gt;old_start[i] &amp;= ~(0x8000000000000000ULL);
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (i &gt;= <span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start)/<span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start[0])) {
		panic(<span class="enscript-string">&quot;jnl: buffer_flushed: did not find tr w/start @ %lld (tr %p, jnl %p)\n&quot;</span>,
		      tr-&gt;journal_start, tr, jnl);
	}


	<span class="enscript-comment">// if we are here then we need to update the journal header
</span>	<span class="enscript-comment">// to reflect that this transaction is complete
</span>	<span class="enscript-keyword">if</span> (tr-&gt;journal_start == jnl-&gt;active_start) {
		jnl-&gt;active_start = tr-&gt;journal_end;
		tr-&gt;journal_start = tr-&gt;journal_end = (off_t)0;
	}

	<span class="enscript-comment">// go through the completed_trs list and try to coalesce
</span>	<span class="enscript-comment">// entries, restarting back at the beginning if we have to.
</span>	<span class="enscript-keyword">for</span> (ctr = jnl-&gt;completed_trs; ctr; prev=ctr, ctr=next) {
		<span class="enscript-keyword">if</span> (ctr-&gt;journal_start == jnl-&gt;active_start) {
			jnl-&gt;active_start = ctr-&gt;journal_end;
			<span class="enscript-keyword">if</span> (prev) {
				prev-&gt;next = ctr-&gt;next;
			}
			<span class="enscript-keyword">if</span> (ctr == jnl-&gt;completed_trs) {
				jnl-&gt;completed_trs = ctr-&gt;next;
			}
	    
			next           = jnl-&gt;completed_trs;   <span class="enscript-comment">// this starts us over again
</span>			ctr-&gt;next      = jnl-&gt;tr_freeme;
			jnl-&gt;tr_freeme = ctr;
			ctr            = NULL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tr-&gt;journal_end == ctr-&gt;journal_start) {
			ctr-&gt;journal_start = tr-&gt;journal_start;
			next               = jnl-&gt;completed_trs;  <span class="enscript-comment">// this starts us over again
</span>			ctr                = NULL;
			tr-&gt;journal_start  = tr-&gt;journal_end = (off_t)0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tr-&gt;journal_start == ctr-&gt;journal_end) {
			ctr-&gt;journal_end  = tr-&gt;journal_end;
			next              = ctr-&gt;next;
			tr-&gt;journal_start = tr-&gt;journal_end = (off_t)0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ctr-&gt;next &amp;&amp; ctr-&gt;journal_end == ctr-&gt;next-&gt;journal_start) {
			<span class="enscript-comment">// coalesce the next entry with this one and link the next
</span>			<span class="enscript-comment">// entry in at the head of the tr_freeme list
</span>			next              = ctr-&gt;next;           <span class="enscript-comment">// temporarily use the &quot;next&quot; variable
</span>			ctr-&gt;journal_end  = next-&gt;journal_end;
			ctr-&gt;next         = next-&gt;next;
			next-&gt;next        = jnl-&gt;tr_freeme;      <span class="enscript-comment">// link in the next guy at the head of the tr_freeme list
</span>			jnl-&gt;tr_freeme    = next;

			next              = jnl-&gt;completed_trs;  <span class="enscript-comment">// this starts us over again
</span>			ctr               = NULL;
		} <span class="enscript-keyword">else</span> {
			next = ctr-&gt;next;
		}
	}
    
	<span class="enscript-comment">// if this is true then we didn't merge with anyone
</span>	<span class="enscript-comment">// so link ourselves in at the head of the completed
</span>	<span class="enscript-comment">// transaction list.
</span>	<span class="enscript-keyword">if</span> (tr-&gt;journal_start != 0) {
		<span class="enscript-comment">// put this entry into the correct sorted place
</span>		<span class="enscript-comment">// in the list instead of just at the head.
</span>		<span class="enscript-comment">//
</span>	
		prev = NULL;
		<span class="enscript-keyword">for</span> (ctr = jnl-&gt;completed_trs; ctr &amp;&amp; tr-&gt;journal_start &gt; ctr-&gt;journal_start; prev=ctr, ctr=ctr-&gt;next) {
			<span class="enscript-comment">// just keep looping
</span>		}

		<span class="enscript-keyword">if</span> (ctr == NULL &amp;&amp; prev == NULL) {
			jnl-&gt;completed_trs = tr;
			tr-&gt;next = NULL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ctr == jnl-&gt;completed_trs) {
			tr-&gt;next = jnl-&gt;completed_trs;
			jnl-&gt;completed_trs = tr;
		} <span class="enscript-keyword">else</span> {
			tr-&gt;next = prev-&gt;next;
			prev-&gt;next = tr;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// if we're here this tr got merged with someone else so
</span>		<span class="enscript-comment">// put it on the list to be free'd
</span>		tr-&gt;next       = jnl-&gt;tr_freeme;
		jnl-&gt;tr_freeme = tr;
	}
<span class="enscript-reference">transaction_done</span>:
	unlock_oldstart(jnl);

	unlock_condition(jnl, &amp;jnl-&gt;asyncIO);
}


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSByteOrder.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SWAP16</span>(x) OSSwapInt16(x)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SWAP32</span>(x) OSSwapInt32(x)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SWAP64</span>(x) OSSwapInt64(x)


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">swap_journal_header</span>(journal *jnl)
{
	jnl-&gt;jhdr-&gt;magic      = SWAP32(jnl-&gt;jhdr-&gt;magic);
	jnl-&gt;jhdr-&gt;endian     = SWAP32(jnl-&gt;jhdr-&gt;endian);
	jnl-&gt;jhdr-&gt;start      = SWAP64(jnl-&gt;jhdr-&gt;start);
	jnl-&gt;jhdr-&gt;end        = SWAP64(jnl-&gt;jhdr-&gt;end);
	jnl-&gt;jhdr-&gt;size       = SWAP64(jnl-&gt;jhdr-&gt;size);
	jnl-&gt;jhdr-&gt;blhdr_size = SWAP32(jnl-&gt;jhdr-&gt;blhdr_size);
	jnl-&gt;jhdr-&gt;checksum   = SWAP32(jnl-&gt;jhdr-&gt;checksum);
	jnl-&gt;jhdr-&gt;jhdr_size  = SWAP32(jnl-&gt;jhdr-&gt;jhdr_size);
	jnl-&gt;jhdr-&gt;sequence_num  = SWAP32(jnl-&gt;jhdr-&gt;sequence_num);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">swap_block_list_header</span>(journal *jnl, block_list_header *blhdr)
{
	<span class="enscript-type">int</span> i;
    
	blhdr-&gt;max_blocks = SWAP16(blhdr-&gt;max_blocks);
	blhdr-&gt;num_blocks = SWAP16(blhdr-&gt;num_blocks);
	blhdr-&gt;bytes_used = SWAP32(blhdr-&gt;bytes_used);
	blhdr-&gt;checksum   = SWAP32(blhdr-&gt;checksum);
	blhdr-&gt;flags      = SWAP32(blhdr-&gt;flags);

	<span class="enscript-keyword">if</span> (blhdr-&gt;num_blocks &gt;= ((jnl-&gt;jhdr-&gt;blhdr_size / <span class="enscript-keyword">sizeof</span>(block_info)) - 1)) {
		printf(<span class="enscript-string">&quot;jnl: %s: blhdr num blocks looks suspicious (%d / blhdr size %d).  not swapping.\n&quot;</span>, jnl-&gt;jdev_name, blhdr-&gt;num_blocks, jnl-&gt;jhdr-&gt;blhdr_size);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">for</span>(i = 0; i &lt; blhdr-&gt;num_blocks; i++) {
		blhdr-&gt;binfo[i].bnum    = SWAP64(blhdr-&gt;binfo[i].bnum);
		blhdr-&gt;binfo[i].u.bi.bsize   = SWAP32(blhdr-&gt;binfo[i].u.bi.bsize);
		blhdr-&gt;binfo[i].u.bi.b.cksum = SWAP32(blhdr-&gt;binfo[i].u.bi.b.cksum);
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">update_fs_block</span>(journal *jnl, <span class="enscript-type">void</span> *block_ptr, off_t fs_block, size_t bsize)
{
	<span class="enscript-type">int</span>		ret;
	<span class="enscript-type">struct</span> buf *oblock_bp=NULL;
	boolean_t was_vm_privileged = FALSE;

    
	<span class="enscript-comment">// first read the block we want.
</span>	ret = buf_meta_bread(jnl-&gt;fsdev, (daddr64_t)fs_block, bsize, NOCRED, &amp;oblock_bp);
	<span class="enscript-keyword">if</span> (ret != 0) {
		printf(<span class="enscript-string">&quot;jnl: %s: update_fs_block: error reading fs block # %lld! (ret %d)\n&quot;</span>, jnl-&gt;jdev_name, fs_block, ret);

		<span class="enscript-keyword">if</span> (oblock_bp) {
			buf_brelse(oblock_bp);
			oblock_bp = NULL;
		}

		<span class="enscript-comment">// let's try to be aggressive here and just re-write the block
</span>		oblock_bp = buf_getblk(jnl-&gt;fsdev, (daddr64_t)fs_block, bsize, 0, 0, BLK_META);
		<span class="enscript-keyword">if</span> (oblock_bp == NULL) {
			printf(<span class="enscript-string">&quot;jnl: %s: update_fs_block: buf_getblk() for %lld failed! failing update.\n&quot;</span>, jnl-&gt;jdev_name, fs_block);
			<span class="enscript-keyword">return</span> -1;
		}
	}
	    
	<span class="enscript-comment">// make sure it's the correct size.
</span>	<span class="enscript-keyword">if</span> (buf_size(oblock_bp) != bsize) {
		buf_brelse(oblock_bp);
		<span class="enscript-keyword">return</span> -1;
	}

	<span class="enscript-comment">// copy the journal data over top of it
</span>	memcpy((<span class="enscript-type">char</span> *)buf_dataptr(oblock_bp), block_ptr, bsize);

	<span class="enscript-keyword">if</span> (jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) {
		<span class="enscript-comment">/*
		 * if we block waiting for memory, and there is enough pressure to
		 * cause us to try and create a new swap file, we may end up deadlocking
		 * due to waiting for the journal on the swap file creation path...
		 * by making ourselves vm_privileged, we give ourselves the best chance
		 * of not blocking
		 */</span>
		was_vm_privileged = set_vm_privilege(TRUE);
	}
	ret = VNOP_BWRITE(oblock_bp);

	<span class="enscript-keyword">if</span> ((jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) &amp;&amp; (was_vm_privileged == FALSE))
		set_vm_privilege(FALSE);

	<span class="enscript-keyword">if</span> (ret != 0) {
		printf(<span class="enscript-string">&quot;jnl: %s: update_fs_block: failed to update block %lld (ret %d)\n&quot;</span>, jnl-&gt;jdev_name, fs_block,ret);
		<span class="enscript-keyword">return</span> ret;
	}
	<span class="enscript-comment">// and now invalidate it so that if someone else wants to read
</span>	<span class="enscript-comment">// it in a different size they'll be able to do it.
</span>	ret = buf_meta_bread(jnl-&gt;fsdev, (daddr64_t)fs_block, bsize, NOCRED, &amp;oblock_bp);
	<span class="enscript-keyword">if</span> (oblock_bp) {
                buf_markinvalid(oblock_bp);
		buf_brelse(oblock_bp);
	}
	    
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">grow_table</span>(<span class="enscript-type">struct</span> bucket **buf_ptr, <span class="enscript-type">int</span> num_buckets, <span class="enscript-type">int</span> new_size)
{
	<span class="enscript-type">struct</span> bucket *newBuf;
	<span class="enscript-type">int</span> current_size = num_buckets, i;
    
	<span class="enscript-comment">// return if newsize is less than the current size
</span>	<span class="enscript-keyword">if</span> (new_size &lt; num_buckets) {
		<span class="enscript-keyword">return</span> current_size;
	}
    
	<span class="enscript-keyword">if</span> ((MALLOC(newBuf, <span class="enscript-type">struct</span> bucket *, new_size*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bucket), M_TEMP, M_WAITOK)) == NULL) {
		printf(<span class="enscript-string">&quot;jnl: grow_table: no memory to expand coalesce buffer!\n&quot;</span>);
		<span class="enscript-keyword">return</span> -1;
	}
    
	<span class="enscript-comment">//  printf(&quot;jnl: lookup_bucket: expanded co_buf to %d elems\n&quot;, new_size);
</span>    
	<span class="enscript-comment">// copy existing elements 
</span>	bcopy(*buf_ptr, newBuf, num_buckets*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bucket));
    
	<span class="enscript-comment">// initialize the new ones
</span>	<span class="enscript-keyword">for</span>(i = num_buckets; i &lt; new_size; i++) {
		newBuf[i].block_num = (off_t)-1;
	}
    
	<span class="enscript-comment">// free the old container
</span>	FREE(*buf_ptr, M_TEMP);
    
	<span class="enscript-comment">// reset the buf_ptr
</span>	*buf_ptr = newBuf;
    
	<span class="enscript-keyword">return</span> new_size;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">lookup_bucket</span>(<span class="enscript-type">struct</span> bucket **buf_ptr, off_t block_num, <span class="enscript-type">int</span> num_full)
{
	<span class="enscript-type">int</span> lo, hi, index, matches, i;
    
	<span class="enscript-keyword">if</span> (num_full == 0) {
		<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">// table is empty, so insert at index=0
</span>	}
    
	lo = 0;
	hi = num_full - 1;
	index = -1;
    
	<span class="enscript-comment">// perform binary search for block_num
</span>	<span class="enscript-keyword">do</span> {
		<span class="enscript-type">int</span> mid = (hi - lo)/2 + lo;
		off_t this_num = (*buf_ptr)[mid].block_num;
	
		<span class="enscript-keyword">if</span> (block_num == this_num) {
			index = mid;
			<span class="enscript-keyword">break</span>;
		}
	
		<span class="enscript-keyword">if</span> (block_num &lt; this_num) {
			hi = mid;
			<span class="enscript-keyword">continue</span>;
		}
	
		<span class="enscript-keyword">if</span> (block_num &gt; this_num) {
			lo = mid + 1;
			<span class="enscript-keyword">continue</span>;
		}
	} <span class="enscript-keyword">while</span> (lo &lt; hi);
    
	<span class="enscript-comment">// check if lo and hi converged on the match
</span>	<span class="enscript-keyword">if</span> (block_num == (*buf_ptr)[hi].block_num) {
		index = hi;
	}
    
	<span class="enscript-comment">// if no existing entry found, find index for new one
</span>	<span class="enscript-keyword">if</span> (index == -1) {
		index = (block_num &lt; (*buf_ptr)[hi].block_num) ? hi : hi + 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// make sure that we return the right-most index in the case of multiple matches
</span>		matches = 0;
		i = index + 1;
		<span class="enscript-keyword">while</span> (i &lt; num_full &amp;&amp; block_num == (*buf_ptr)[i].block_num) {
			matches++;
			i++;
		}

		index += matches;
	}
    
	<span class="enscript-keyword">return</span> index;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">insert_block</span>(journal *jnl, <span class="enscript-type">struct</span> bucket **buf_ptr, <span class="enscript-type">int</span> blk_index, off_t num, size_t size, size_t offset, int32_t cksum, <span class="enscript-type">int</span> *num_buckets_ptr, <span class="enscript-type">int</span> *num_full_ptr, <span class="enscript-type">int</span> overwriting)
{
	<span class="enscript-keyword">if</span> (!overwriting) {
		<span class="enscript-comment">// grow the table if we're out of space
</span>		<span class="enscript-keyword">if</span> (*num_full_ptr &gt;= *num_buckets_ptr) {
			<span class="enscript-type">int</span> new_size = *num_buckets_ptr * 2;
			<span class="enscript-type">int</span> grow_size = grow_table(buf_ptr, *num_buckets_ptr, new_size);
	    
			<span class="enscript-keyword">if</span> (grow_size &lt; new_size) {
				printf(<span class="enscript-string">&quot;jnl: %s: add_block: grow_table returned an error!\n&quot;</span>, jnl-&gt;jdev_name);
				<span class="enscript-keyword">return</span> -1;
			}
	    
			*num_buckets_ptr = grow_size; <span class="enscript-comment">//update num_buckets to reflect the new size
</span>		}
	
		<span class="enscript-comment">// if we're not inserting at the end, we need to bcopy
</span>		<span class="enscript-keyword">if</span> (blk_index != *num_full_ptr) {
			bcopy( (*buf_ptr)+(blk_index), (*buf_ptr)+(blk_index+1), (*num_full_ptr-blk_index)*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bucket) );
		}
	
		(*num_full_ptr)++; <span class="enscript-comment">// increment only if we're not overwriting
</span>	}

	<span class="enscript-comment">// sanity check the values we're about to add
</span>	<span class="enscript-keyword">if</span> ((off_t)offset &gt;= jnl-&gt;jhdr-&gt;size) {
		offset = jnl-&gt;jhdr-&gt;jhdr_size + (offset - jnl-&gt;jhdr-&gt;size);
	}
	<span class="enscript-keyword">if</span> (size &lt;= 0) {
		panic(<span class="enscript-string">&quot;jnl: insert_block: bad size in insert_block (%zd)\n&quot;</span>, size);
	}	 

	(*buf_ptr)[blk_index].block_num = num;
	(*buf_ptr)[blk_index].block_size = size;
	(*buf_ptr)[blk_index].jnl_offset = offset;
	(*buf_ptr)[blk_index].cksum = cksum;
    
	<span class="enscript-keyword">return</span> blk_index;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">do_overlap</span>(journal *jnl, <span class="enscript-type">struct</span> bucket **buf_ptr, <span class="enscript-type">int</span> blk_index, off_t block_num, size_t size, __unused size_t offset, int32_t cksum, <span class="enscript-type">int</span> *num_buckets_ptr, <span class="enscript-type">int</span> *num_full_ptr)
{
	<span class="enscript-type">int</span>	num_to_remove, index, i, overwrite, err;
	size_t	jhdr_size = jnl-&gt;jhdr-&gt;jhdr_size, new_offset;
	off_t	overlap, block_start, block_end;

	block_start = block_num*jhdr_size;
	block_end = block_start + size;
	overwrite = (block_num == (*buf_ptr)[blk_index].block_num &amp;&amp; size &gt;= (*buf_ptr)[blk_index].block_size);

	<span class="enscript-comment">// first, eliminate any overlap with the previous entry
</span>	<span class="enscript-keyword">if</span> (blk_index != 0 &amp;&amp; !overwrite) {
		off_t prev_block_start = (*buf_ptr)[blk_index-1].block_num*jhdr_size;
		off_t prev_block_end = prev_block_start + (*buf_ptr)[blk_index-1].block_size;
		overlap = prev_block_end - block_start;
		<span class="enscript-keyword">if</span> (overlap &gt; 0) {
			<span class="enscript-keyword">if</span> (overlap % jhdr_size != 0) {
				panic(<span class="enscript-string">&quot;jnl: do_overlap: overlap with previous entry not a multiple of %zd\n&quot;</span>, jhdr_size);
			}

			<span class="enscript-comment">// if the previous entry completely overlaps this one, we need to break it into two pieces.
</span>			<span class="enscript-keyword">if</span> (prev_block_end &gt; block_end) {
				off_t new_num = block_end / jhdr_size;
				size_t new_size = prev_block_end - block_end;

				new_offset = (*buf_ptr)[blk_index-1].jnl_offset + (block_end - prev_block_start);
		
				err = insert_block(jnl, buf_ptr, blk_index, new_num, new_size, new_offset, cksum, num_buckets_ptr, num_full_ptr, 0);
				<span class="enscript-keyword">if</span> (err &lt; 0) {
					panic(<span class="enscript-string">&quot;jnl: do_overlap: error inserting during pre-overlap\n&quot;</span>);
				}
			}
	    
			<span class="enscript-comment">// Regardless, we need to truncate the previous entry to the beginning of the overlap
</span>			(*buf_ptr)[blk_index-1].block_size = block_start - prev_block_start;
			(*buf_ptr)[blk_index-1].cksum = 0;   <span class="enscript-comment">// have to blow it away because there's no way to check it
</span>		}
	}

	<span class="enscript-comment">// then, bail out fast if there's no overlap with the entries that follow
</span>	<span class="enscript-keyword">if</span> (!overwrite &amp;&amp; block_end &lt;= (off_t)((*buf_ptr)[blk_index].block_num*jhdr_size)) {
		<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">// no overlap, no overwrite
</span>	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (overwrite &amp;&amp; (blk_index + 1 &gt;= *num_full_ptr || block_end &lt;= (off_t)((*buf_ptr)[blk_index+1].block_num*jhdr_size))) {

		(*buf_ptr)[blk_index].cksum = cksum;   <span class="enscript-comment">// update this
</span>		<span class="enscript-keyword">return</span> 1; <span class="enscript-comment">// simple overwrite
</span>	}
    
	<span class="enscript-comment">// Otherwise, find all cases of total and partial overlap. We use the special
</span>	<span class="enscript-comment">// block_num of -2 to designate entries that are completely overlapped and must
</span>	<span class="enscript-comment">// be eliminated. The block_num, size, and jnl_offset of partially overlapped
</span>	<span class="enscript-comment">// entries must be adjusted to keep the array consistent.
</span>	index = blk_index;
	num_to_remove = 0;
	<span class="enscript-keyword">while</span> (index &lt; *num_full_ptr &amp;&amp; block_end &gt; (off_t)((*buf_ptr)[index].block_num*jhdr_size)) {
		<span class="enscript-keyword">if</span> (block_end &gt;= (off_t)(((*buf_ptr)[index].block_num*jhdr_size + (*buf_ptr)[index].block_size))) {
			(*buf_ptr)[index].block_num = -2; <span class="enscript-comment">// mark this for deletion
</span>			num_to_remove++;
		} <span class="enscript-keyword">else</span> {
			overlap = block_end - (*buf_ptr)[index].block_num*jhdr_size;
			<span class="enscript-keyword">if</span> (overlap &gt; 0) {
				<span class="enscript-keyword">if</span> (overlap % jhdr_size != 0) {
					panic(<span class="enscript-string">&quot;jnl: do_overlap: overlap of %lld is not multiple of %zd\n&quot;</span>, overlap, jhdr_size);
				}
				
				<span class="enscript-comment">// if we partially overlap this entry, adjust its block number, jnl offset, and size
</span>				(*buf_ptr)[index].block_num += (overlap / jhdr_size); <span class="enscript-comment">// make sure overlap is multiple of jhdr_size, or round up
</span>				(*buf_ptr)[index].cksum = 0;
		
				new_offset = (*buf_ptr)[index].jnl_offset + overlap; <span class="enscript-comment">// check for wrap-around
</span>				<span class="enscript-keyword">if</span> ((off_t)new_offset &gt;= jnl-&gt;jhdr-&gt;size) {
					new_offset = jhdr_size + (new_offset - jnl-&gt;jhdr-&gt;size);
				}
				(*buf_ptr)[index].jnl_offset = new_offset;
		
				(*buf_ptr)[index].block_size -= overlap; <span class="enscript-comment">// sanity check for negative value
</span>				<span class="enscript-keyword">if</span> ((*buf_ptr)[index].block_size &lt;= 0) {
					panic(<span class="enscript-string">&quot;jnl: do_overlap: after overlap, new block size is invalid (%u)\n&quot;</span>, (*buf_ptr)[index].block_size);
					<span class="enscript-comment">// return -1; // if above panic is removed, return -1 for error
</span>				}
			}
			
		}

		index++;
	}

	<span class="enscript-comment">// bcopy over any completely overlapped entries, starting at the right (where the above loop broke out)
</span>	index--; <span class="enscript-comment">// start with the last index used within the above loop
</span>	<span class="enscript-keyword">while</span> (index &gt;= blk_index) {
		<span class="enscript-keyword">if</span> ((*buf_ptr)[index].block_num == -2) {
			<span class="enscript-keyword">if</span> (index == *num_full_ptr-1) {
				(*buf_ptr)[index].block_num = -1; <span class="enscript-comment">// it's the last item in the table... just mark as free
</span>			} <span class="enscript-keyword">else</span> {
				bcopy( (*buf_ptr)+(index+1), (*buf_ptr)+(index), (*num_full_ptr - (index + 1)) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bucket) );
			}
			(*num_full_ptr)--;
		}
		index--;
	}

	<span class="enscript-comment">// eliminate any stale entries at the end of the table
</span>	<span class="enscript-keyword">for</span>(i = *num_full_ptr; i &lt; (*num_full_ptr + num_to_remove); i++) {
		(*buf_ptr)[i].block_num = -1;
	}
    
	<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">// if we got this far, we need to insert the entry into the table (rather than overwrite) 
</span>}

<span class="enscript-comment">// PR-3105942: Coalesce writes to the same block in journal replay
</span><span class="enscript-comment">// We coalesce writes by maintaining a dynamic sorted array of physical disk blocks
</span><span class="enscript-comment">// to be replayed and the corresponding location in the journal which contains
</span><span class="enscript-comment">// the most recent data for those blocks. The array is &quot;played&quot; once the all the
</span><span class="enscript-comment">// blocks in the journal have been coalesced. The code for the case of conflicting/
</span><span class="enscript-comment">// overlapping writes to a single block is the most dense. Because coalescing can
</span><span class="enscript-comment">// disrupt the existing time-ordering of blocks in the journal playback, care
</span><span class="enscript-comment">// is taken to catch any overlaps and keep the array consistent. 
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">add_block</span>(journal *jnl, <span class="enscript-type">struct</span> bucket **buf_ptr, off_t block_num, size_t size, __unused size_t offset, int32_t cksum, <span class="enscript-type">int</span> *num_buckets_ptr, <span class="enscript-type">int</span> *num_full_ptr)
{
	<span class="enscript-type">int</span>	blk_index, overwriting;
    
	<span class="enscript-comment">// on return from lookup_bucket(), blk_index is the index into the table where block_num should be
</span>	<span class="enscript-comment">// inserted (or the index of the elem to overwrite). 
</span>	blk_index = lookup_bucket( buf_ptr, block_num, *num_full_ptr);
    
	<span class="enscript-comment">// check if the index is within bounds (if we're adding this block to the end of
</span>	<span class="enscript-comment">// the table, blk_index will be equal to num_full)
</span>	<span class="enscript-keyword">if</span> (blk_index &lt; 0 || blk_index &gt; *num_full_ptr) {
		<span class="enscript-comment">//printf(&quot;jnl: add_block: trouble adding block to co_buf\n&quot;);
</span>		<span class="enscript-keyword">return</span> -1;
	} <span class="enscript-comment">// else printf(&quot;jnl: add_block: adding block 0x%llx at i=%d\n&quot;, block_num, blk_index);
</span>    
	<span class="enscript-comment">// Determine whether we're overwriting an existing entry by checking for overlap
</span>	overwriting = do_overlap(jnl, buf_ptr, blk_index, block_num, size, offset, cksum, num_buckets_ptr, num_full_ptr);
	<span class="enscript-keyword">if</span> (overwriting &lt; 0) {
		<span class="enscript-keyword">return</span> -1; <span class="enscript-comment">// if we got an error, pass it along
</span>	}
        
	<span class="enscript-comment">// returns the index, or -1 on error
</span>	blk_index = insert_block(jnl, buf_ptr, blk_index, block_num, size, offset, cksum, num_buckets_ptr, num_full_ptr, overwriting);
    
	<span class="enscript-keyword">return</span> blk_index;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">replay_journal</span>(journal *jnl)
{
	<span class="enscript-type">int</span>		i, bad_blocks=0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	orig_checksum, checksum, check_block_checksums = 0;
	size_t		ret;
	size_t		max_bsize = 0;		<span class="enscript-comment">/* protected by block_ptr */</span>
	block_list_header *blhdr;
	off_t		offset, txn_start_offset=0, blhdr_offset, orig_jnl_start;
	<span class="enscript-type">char</span>		*buff, *block_ptr=NULL;
	<span class="enscript-type">struct</span> bucket	*co_buf;
	<span class="enscript-type">int</span>		num_buckets = STARTING_BUCKETS, num_full, check_past_jnl_end = 1, in_uncharted_territory=0;
	uint32_t	last_sequence_num = 0;
	<span class="enscript-type">int</span> 		replay_retry_count = 0;
    
	<span class="enscript-comment">// wrap the start ptr if it points to the very end of the journal
</span>	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;start == jnl-&gt;jhdr-&gt;size) {
		jnl-&gt;jhdr-&gt;start = jnl-&gt;jhdr-&gt;jhdr_size;
	}
	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;end == jnl-&gt;jhdr-&gt;size) {
		jnl-&gt;jhdr-&gt;end = jnl-&gt;jhdr-&gt;jhdr_size;
	}

	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;start == jnl-&gt;jhdr-&gt;end) {
		<span class="enscript-keyword">return</span> 0;
	}

	orig_jnl_start = jnl-&gt;jhdr-&gt;start;

	<span class="enscript-comment">// allocate memory for the header_block.  we'll read each blhdr into this
</span>	<span class="enscript-keyword">if</span> (kmem_alloc_kobject(kernel_map, (vm_offset_t *)&amp;buff, jnl-&gt;jhdr-&gt;blhdr_size, VM_KERN_MEMORY_FILE)) {
		printf(<span class="enscript-string">&quot;jnl: %s: replay_journal: no memory for block buffer! (%d bytes)\n&quot;</span>,
		       jnl-&gt;jdev_name, jnl-&gt;jhdr-&gt;blhdr_size);
		<span class="enscript-keyword">return</span> -1;
	}

	<span class="enscript-comment">// allocate memory for the coalesce buffer
</span>	<span class="enscript-keyword">if</span> ((MALLOC(co_buf, <span class="enscript-type">struct</span> bucket *, num_buckets*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bucket), M_TEMP, M_WAITOK)) == NULL) {
		printf(<span class="enscript-string">&quot;jnl: %s: replay_journal: no memory for coalesce buffer!\n&quot;</span>, jnl-&gt;jdev_name);
		<span class="enscript-keyword">return</span> -1;
	}

<span class="enscript-reference">restart_replay</span>:

	<span class="enscript-comment">// initialize entries
</span>	<span class="enscript-keyword">for</span>(i = 0; i &lt; num_buckets; i++) {
		co_buf[i].block_num = -1;
	}
	num_full = 0; <span class="enscript-comment">// empty at first
</span>

	printf(<span class="enscript-string">&quot;jnl: %s: replay_journal: from: %lld to: %lld (joffset 0x%llx)\n&quot;</span>,
	       jnl-&gt;jdev_name, jnl-&gt;jhdr-&gt;start, jnl-&gt;jhdr-&gt;end, jnl-&gt;jdev_offset);

	<span class="enscript-keyword">while</span> (check_past_jnl_end || jnl-&gt;jhdr-&gt;start != jnl-&gt;jhdr-&gt;end) {
		offset = blhdr_offset = jnl-&gt;jhdr-&gt;start;
		ret = read_journal_data(jnl, &amp;offset, buff, jnl-&gt;jhdr-&gt;blhdr_size);
		<span class="enscript-keyword">if</span> (ret != (size_t)jnl-&gt;jhdr-&gt;blhdr_size) {
			printf(<span class="enscript-string">&quot;jnl: %s: replay_journal: Could not read block list header block @ 0x%llx!\n&quot;</span>, jnl-&gt;jdev_name, offset);
			bad_blocks = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_txn_handling</span>;
		}

		blhdr = (block_list_header *)buff;
		
		orig_checksum = blhdr-&gt;checksum;
		blhdr-&gt;checksum = 0;
		<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_NEED_SWAP) {
			<span class="enscript-comment">// calculate the checksum based on the unswapped data
</span>			<span class="enscript-comment">// because it is done byte-at-a-time.
</span>			orig_checksum = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)SWAP32(orig_checksum);
			checksum = calc_checksum((<span class="enscript-type">char</span> *)blhdr, BLHDR_CHECKSUM_SIZE);
			swap_block_list_header(jnl, blhdr);
		} <span class="enscript-keyword">else</span> {
			checksum = calc_checksum((<span class="enscript-type">char</span> *)blhdr, BLHDR_CHECKSUM_SIZE);
		}


		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// XXXdbg - if these checks fail, we should replay as much
</span>		<span class="enscript-comment">//          we can in the hopes that it will still leave the
</span>		<span class="enscript-comment">//          drive in a better state than if we didn't replay
</span>		<span class="enscript-comment">//          anything
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> (checksum != orig_checksum) {
			<span class="enscript-keyword">if</span> (check_past_jnl_end &amp;&amp; in_uncharted_territory) {

				<span class="enscript-keyword">if</span> (blhdr_offset != jnl-&gt;jhdr-&gt;end) {
					printf(<span class="enscript-string">&quot;jnl: %s: Extra txn replay stopped @ %lld / 0x%llx\n&quot;</span>, jnl-&gt;jdev_name, blhdr_offset, blhdr_offset);
				}

				check_past_jnl_end = 0;
				jnl-&gt;jhdr-&gt;end = blhdr_offset;
				<span class="enscript-keyword">continue</span>;
			}

			printf(<span class="enscript-string">&quot;jnl: %s: replay_journal: bad block list header @ 0x%llx (checksum 0x%x != 0x%x)\n&quot;</span>,
			jnl-&gt;jdev_name, blhdr_offset, orig_checksum, checksum);

			<span class="enscript-keyword">if</span> (blhdr_offset == orig_jnl_start) {
				<span class="enscript-comment">// if there's nothing in the journal at all, just bail out altogether.
</span>				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_replay</span>;
			}

			bad_blocks = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_txn_handling</span>;
		}

		<span class="enscript-keyword">if</span> (   (last_sequence_num != 0)
		       &amp;&amp; (blhdr-&gt;binfo[0].u.bi.b.sequence_num != 0)
		       &amp;&amp; (blhdr-&gt;binfo[0].u.bi.b.sequence_num != last_sequence_num)
		       &amp;&amp; (blhdr-&gt;binfo[0].u.bi.b.sequence_num != last_sequence_num+1)) {

			txn_start_offset = jnl-&gt;jhdr-&gt;end = blhdr_offset;

			<span class="enscript-keyword">if</span> (check_past_jnl_end) {
				check_past_jnl_end = 0;
				printf(<span class="enscript-string">&quot;jnl: %s: 2: extra replay stopped @ %lld / 0x%llx (seq %d &lt; %d)\n&quot;</span>,
				       jnl-&gt;jdev_name, blhdr_offset, blhdr_offset, blhdr-&gt;binfo[0].u.bi.b.sequence_num, last_sequence_num);
				<span class="enscript-keyword">continue</span>;
			}

			printf(<span class="enscript-string">&quot;jnl: %s: txn sequence numbers out of order in txn @ %lld / %llx! (%d &lt; %d)\n&quot;</span>,
			       jnl-&gt;jdev_name, blhdr_offset, blhdr_offset, blhdr-&gt;binfo[0].u.bi.b.sequence_num, last_sequence_num);
			bad_blocks = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_txn_handling</span>;
		}
		last_sequence_num = blhdr-&gt;binfo[0].u.bi.b.sequence_num;

		<span class="enscript-keyword">if</span> (blhdr_offset &gt;= jnl-&gt;jhdr-&gt;end &amp;&amp; jnl-&gt;jhdr-&gt;start &lt;= jnl-&gt;jhdr-&gt;end) {
			<span class="enscript-keyword">if</span> (last_sequence_num == 0) {
				check_past_jnl_end = 0;
				printf(<span class="enscript-string">&quot;jnl: %s: pre-sequence-num-enabled txn's - can not go further than end (%lld %lld).\n&quot;</span>,
				       jnl-&gt;jdev_name, jnl-&gt;jhdr-&gt;start, jnl-&gt;jhdr-&gt;end);
				<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;start != jnl-&gt;jhdr-&gt;end) {
					jnl-&gt;jhdr-&gt;start = jnl-&gt;jhdr-&gt;end;
				}
				<span class="enscript-keyword">continue</span>;
			}
			printf(<span class="enscript-string">&quot;jnl: %s: examining extra transactions starting @ %lld / 0x%llx\n&quot;</span>, jnl-&gt;jdev_name, blhdr_offset, blhdr_offset);
		}

		<span class="enscript-keyword">if</span> (   blhdr-&gt;max_blocks &lt;= 0 || blhdr-&gt;max_blocks &gt; (jnl-&gt;jhdr-&gt;size/jnl-&gt;jhdr-&gt;jhdr_size)
		       || blhdr-&gt;num_blocks &lt;= 0 || blhdr-&gt;num_blocks &gt; blhdr-&gt;max_blocks) {
			printf(<span class="enscript-string">&quot;jnl: %s: replay_journal: bad looking journal entry: max: %d num: %d\n&quot;</span>,
			       jnl-&gt;jdev_name, blhdr-&gt;max_blocks, blhdr-&gt;num_blocks);
			bad_blocks = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_txn_handling</span>;
		}
	
		max_bsize = 0;
		<span class="enscript-keyword">for</span> (i = 1; i &lt; blhdr-&gt;num_blocks; i++) {
			<span class="enscript-keyword">if</span> (blhdr-&gt;binfo[i].bnum &lt; 0 &amp;&amp; blhdr-&gt;binfo[i].bnum != (off_t)-1) {
				printf(<span class="enscript-string">&quot;jnl: %s: replay_journal: bogus block number 0x%llx\n&quot;</span>, jnl-&gt;jdev_name, blhdr-&gt;binfo[i].bnum);
				bad_blocks = 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_txn_handling</span>;
			}
			
			<span class="enscript-keyword">if</span> ((size_t)blhdr-&gt;binfo[i].u.bi.bsize &gt; max_bsize) {
				max_bsize = blhdr-&gt;binfo[i].u.bi.bsize;
			}
		}

		<span class="enscript-keyword">if</span> (blhdr-&gt;flags &amp; BLHDR_CHECK_CHECKSUMS) {
			check_block_checksums = 1;
			<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;block_ptr, max_bsize, VM_KERN_MEMORY_FILE)) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_replay</span>;
			}
		} <span class="enscript-keyword">else</span> {
			block_ptr = NULL;
		}

		<span class="enscript-keyword">if</span> (blhdr-&gt;flags &amp; BLHDR_FIRST_HEADER) {
			txn_start_offset = blhdr_offset;
		}

		<span class="enscript-comment">//printf(&quot;jnl: replay_journal: adding %d blocks in journal entry @ 0x%llx to co_buf\n&quot;, 
</span>		<span class="enscript-comment">//       blhdr-&gt;num_blocks-1, jnl-&gt;jhdr-&gt;start);
</span>		bad_blocks = 0;
		<span class="enscript-keyword">for</span> (i = 1; i &lt; blhdr-&gt;num_blocks; i++) {
			<span class="enscript-type">int</span> size, ret_val;
			off_t number;

			size = blhdr-&gt;binfo[i].u.bi.bsize;
			number = blhdr-&gt;binfo[i].bnum;
			
			<span class="enscript-comment">// don't add &quot;killed&quot; blocks
</span>			<span class="enscript-keyword">if</span> (number == (off_t)-1) {
				<span class="enscript-comment">//printf(&quot;jnl: replay_journal: skipping killed fs block (index %d)\n&quot;, i);
</span>			} <span class="enscript-keyword">else</span> {

				<span class="enscript-keyword">if</span> (check_block_checksums) {
					int32_t disk_cksum;
					off_t block_offset;

					block_offset = offset;

					<span class="enscript-comment">// read the block so we can check the checksum
</span>					ret = read_journal_data(jnl, &amp;block_offset, block_ptr, size);
					<span class="enscript-keyword">if</span> (ret != (size_t)size) {
						printf(<span class="enscript-string">&quot;jnl: %s: replay_journal: Could not read journal entry data @ offset 0x%llx!\n&quot;</span>, jnl-&gt;jdev_name, offset);
						bad_blocks = 1;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_txn_handling</span>;
					}
				
					disk_cksum = calc_checksum(block_ptr, size);

					<span class="enscript-comment">// there is no need to swap the checksum from disk because
</span>					<span class="enscript-comment">// it got swapped when the blhdr was read in.
</span>					<span class="enscript-keyword">if</span> (blhdr-&gt;binfo[i].u.bi.b.cksum != 0 &amp;&amp; disk_cksum != blhdr-&gt;binfo[i].u.bi.b.cksum) {
						printf(<span class="enscript-string">&quot;jnl: %s: txn starting at %lld (%lld) @ index %3d bnum %lld (%d) with disk cksum != blhdr cksum (0x%.8x 0x%.8x)\n&quot;</span>,
						       jnl-&gt;jdev_name, txn_start_offset, blhdr_offset, i, number, size, disk_cksum, blhdr-&gt;binfo[i].u.bi.b.cksum);
						printf(<span class="enscript-string">&quot;jnl: 0x%.8x 0x%.8x 0x%.8x 0x%.8x  0x%.8x 0x%.8x 0x%.8x 0x%.8x\n&quot;</span>,
						       *(<span class="enscript-type">int</span> *)&amp;block_ptr[0*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)], *(<span class="enscript-type">int</span> *)&amp;block_ptr[1*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)], *(<span class="enscript-type">int</span> *)&amp;block_ptr[2*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)], *(<span class="enscript-type">int</span> *)&amp;block_ptr[3*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)],
						       *(<span class="enscript-type">int</span> *)&amp;block_ptr[4*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)], *(<span class="enscript-type">int</span> *)&amp;block_ptr[5*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)], *(<span class="enscript-type">int</span> *)&amp;block_ptr[6*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)], *(<span class="enscript-type">int</span> *)&amp;block_ptr[7*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)]);

						bad_blocks = 1;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_txn_handling</span>;
					}
				}


				<span class="enscript-comment">// add this bucket to co_buf, coalescing where possible
</span>				<span class="enscript-comment">// printf(&quot;jnl: replay_journal: adding block 0x%llx\n&quot;, number);
</span>				ret_val = add_block(jnl, &amp;co_buf, number, size, (size_t) offset, blhdr-&gt;binfo[i].u.bi.b.cksum, &amp;num_buckets, &amp;num_full);
			    
				<span class="enscript-keyword">if</span> (ret_val == -1) {
					printf(<span class="enscript-string">&quot;jnl: %s: replay_journal: trouble adding block to co_buf\n&quot;</span>, jnl-&gt;jdev_name);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_replay</span>;
				} <span class="enscript-comment">// else printf(&quot;jnl: replay_journal: added block 0x%llx at i=%d\n&quot;, number);
</span>			}
			
			<span class="enscript-comment">// increment offset
</span>			offset += size;
			
			<span class="enscript-comment">// check if the last block added puts us off the end of the jnl.
</span>			<span class="enscript-comment">// if so, we need to wrap to the beginning and take any remainder
</span>			<span class="enscript-comment">// into account
</span>			<span class="enscript-comment">//
</span>			<span class="enscript-keyword">if</span> (offset &gt;= jnl-&gt;jhdr-&gt;size) {
				offset = jnl-&gt;jhdr-&gt;jhdr_size + (offset - jnl-&gt;jhdr-&gt;size);
			}
		}

		<span class="enscript-keyword">if</span> (block_ptr) {
			kmem_free(kernel_map, (vm_offset_t)block_ptr, max_bsize);
			block_ptr = NULL;
		}
		
<span class="enscript-reference">bad_txn_handling</span>:
		<span class="enscript-keyword">if</span> (bad_blocks) {
			<span class="enscript-comment">/* Journal replay got error before it found any valid 
			 *  transations, abort replay */</span>
			<span class="enscript-keyword">if</span> (txn_start_offset == 0) {
				printf(<span class="enscript-string">&quot;jnl: %s: no known good txn start offset! aborting journal replay.\n&quot;</span>, jnl-&gt;jdev_name);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_replay</span>;
			}

			<span class="enscript-comment">/* Repeated error during journal replay, abort replay */</span>
			<span class="enscript-keyword">if</span> (replay_retry_count == 3) {
				printf(<span class="enscript-string">&quot;jnl: %s: repeated errors replaying journal! aborting journal replay.\n&quot;</span>, jnl-&gt;jdev_name);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_replay</span>;
			}
			replay_retry_count++;

			<span class="enscript-comment">/* There was an error replaying the journal (possibly 
			 * EIO/ENXIO from the device).  So retry replaying all 
			 * the good transactions that we found before getting 
			 * the error.  
			 */</span>
			jnl-&gt;jhdr-&gt;start = orig_jnl_start;
			jnl-&gt;jhdr-&gt;end = txn_start_offset;
			check_past_jnl_end = 0;
			last_sequence_num = 0;
			printf(<span class="enscript-string">&quot;jnl: %s: restarting journal replay (%lld - %lld)!\n&quot;</span>, jnl-&gt;jdev_name, jnl-&gt;jhdr-&gt;start, jnl-&gt;jhdr-&gt;end);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart_replay</span>;
		}

		jnl-&gt;jhdr-&gt;start += blhdr-&gt;bytes_used;
		<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;start &gt;= jnl-&gt;jhdr-&gt;size) {
			<span class="enscript-comment">// wrap around and skip the journal header block
</span>			jnl-&gt;jhdr-&gt;start = (jnl-&gt;jhdr-&gt;start % jnl-&gt;jhdr-&gt;size) + jnl-&gt;jhdr-&gt;jhdr_size;
		}

		<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;start == jnl-&gt;jhdr-&gt;end) {
			in_uncharted_territory = 1;
		}
	}

	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;start != jnl-&gt;jhdr-&gt;end) {
		printf(<span class="enscript-string">&quot;jnl: %s: start %lld != end %lld.  resetting end.\n&quot;</span>, jnl-&gt;jdev_name, jnl-&gt;jhdr-&gt;start, jnl-&gt;jhdr-&gt;end);
		jnl-&gt;jhdr-&gt;end = jnl-&gt;jhdr-&gt;start;
	}

	<span class="enscript-comment">//printf(&quot;jnl: replay_journal: replaying %d blocks\n&quot;, num_full);
</span>    
	<span class="enscript-comment">/*
	 * make sure it's at least one page in size, so
	 * start max_bsize at PAGE_SIZE
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0, max_bsize = PAGE_SIZE; i &lt; num_full; i++) {

		<span class="enscript-keyword">if</span> (co_buf[i].block_num == (off_t)-1)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (co_buf[i].block_size &gt; max_bsize)
			max_bsize = co_buf[i].block_size;
	}
	<span class="enscript-comment">/*
	 * round max_bsize up to the nearest PAGE_SIZE multiple
	 */</span>
	<span class="enscript-keyword">if</span> (max_bsize &amp; (PAGE_SIZE - 1)) {
		max_bsize = (max_bsize + PAGE_SIZE) &amp; ~(PAGE_SIZE - 1);
	}

	<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;block_ptr, max_bsize, VM_KERN_MEMORY_FILE)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_replay</span>;
	}
    
	<span class="enscript-comment">// Replay the coalesced entries in the co-buf
</span>	<span class="enscript-keyword">for</span>(i = 0; i &lt; num_full; i++) {
		size_t size = co_buf[i].block_size;
		off_t jnl_offset = (off_t) co_buf[i].jnl_offset;
		off_t number = co_buf[i].block_num;
	
	
		<span class="enscript-comment">// printf(&quot;replaying co_buf[%d]: block 0x%llx, size 0x%x, jnl_offset 0x%llx\n&quot;, i, co_buf[i].block_num,
</span>		<span class="enscript-comment">//      co_buf[i].block_size, co_buf[i].jnl_offset);
</span>	
		<span class="enscript-keyword">if</span> (number == (off_t)-1) {
			<span class="enscript-comment">// printf(&quot;jnl: replay_journal: skipping killed fs block\n&quot;);
</span>		} <span class="enscript-keyword">else</span> {
	    
			<span class="enscript-comment">// do journal read, and set the phys. block 
</span>			ret = read_journal_data(jnl, &amp;jnl_offset, block_ptr, size);
			<span class="enscript-keyword">if</span> (ret != size) {
				printf(<span class="enscript-string">&quot;jnl: %s: replay_journal: Could not read journal entry data @ offset 0x%llx!\n&quot;</span>, jnl-&gt;jdev_name, offset);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_replay</span>;
			}
	    	    
			<span class="enscript-keyword">if</span> (update_fs_block(jnl, block_ptr, number, size) != 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_replay</span>;
			}
		}
	}
    
	
	<span class="enscript-comment">// done replaying; update jnl header
</span>	<span class="enscript-keyword">if</span> (write_journal_header(jnl, 1, jnl-&gt;jhdr-&gt;sequence_num) != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_replay</span>;
	}

	printf(<span class="enscript-string">&quot;jnl: %s: journal replay done.\n&quot;</span>, jnl-&gt;jdev_name);
    
	<span class="enscript-comment">// free block_ptr
</span>	<span class="enscript-keyword">if</span> (block_ptr) {
		kmem_free(kernel_map, (vm_offset_t)block_ptr, max_bsize);
		block_ptr = NULL;
	}
    
	<span class="enscript-comment">// free the coalesce buffer
</span>	FREE(co_buf, M_TEMP);
	co_buf = NULL;
  
	kmem_free(kernel_map, (vm_offset_t)buff, jnl-&gt;jhdr-&gt;blhdr_size);
	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">bad_replay</span>:
	<span class="enscript-keyword">if</span> (block_ptr) {
		kmem_free(kernel_map, (vm_offset_t)block_ptr, max_bsize);
	}
	<span class="enscript-keyword">if</span> (co_buf) {
		FREE(co_buf, M_TEMP);
	}
	kmem_free(kernel_map, (vm_offset_t)buff, jnl-&gt;jhdr-&gt;blhdr_size);

	<span class="enscript-keyword">return</span> -1;
}


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_TRANSACTION_BUFFER_SIZE</span>  (128*1024)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_TRANSACTION_BUFFER_SIZE</span>      (3072*1024)

<span class="enscript-comment">// XXXdbg - so I can change it in the debugger
</span><span class="enscript-type">int</span> def_tbuffer_size = 0;


<span class="enscript-comment">//
</span><span class="enscript-comment">// This function sets the size of the tbuffer and the
</span><span class="enscript-comment">// size of the blhdr.  It assumes that jnl-&gt;jhdr-&gt;size
</span><span class="enscript-comment">// and jnl-&gt;jhdr-&gt;jhdr_size are already valid.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">size_up_tbuffer</span>(journal *jnl, <span class="enscript-type">int</span> tbuffer_size, <span class="enscript-type">int</span> phys_blksz)
{
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// one-time initialization based on how much memory 
</span>	<span class="enscript-comment">// there is in the machine.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (def_tbuffer_size == 0) {
		<span class="enscript-keyword">if</span> (max_mem &lt; (256*1024*1024)) {
			def_tbuffer_size = DEFAULT_TRANSACTION_BUFFER_SIZE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (max_mem &lt; (512*1024*1024)) {
			def_tbuffer_size = DEFAULT_TRANSACTION_BUFFER_SIZE * 2;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (max_mem &lt; (1024*1024*1024)) {
			def_tbuffer_size = DEFAULT_TRANSACTION_BUFFER_SIZE * 3;
		} <span class="enscript-keyword">else</span> {
			def_tbuffer_size = DEFAULT_TRANSACTION_BUFFER_SIZE * (max_mem / (256*1024*1024));
		}
	}

	<span class="enscript-comment">// size up the transaction buffer... can't be larger than the number
</span>	<span class="enscript-comment">// of blocks that can fit in a block_list_header block.
</span>	<span class="enscript-keyword">if</span> (tbuffer_size == 0) {
		jnl-&gt;tbuffer_size = def_tbuffer_size;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// make sure that the specified tbuffer_size isn't too small
</span>		<span class="enscript-keyword">if</span> (tbuffer_size &lt; jnl-&gt;jhdr-&gt;blhdr_size * 2) {
			tbuffer_size = jnl-&gt;jhdr-&gt;blhdr_size * 2;
		}
		<span class="enscript-comment">// and make sure it's an even multiple of the block size
</span>		<span class="enscript-keyword">if</span> ((tbuffer_size % jnl-&gt;jhdr-&gt;jhdr_size) != 0) {
			tbuffer_size -= (tbuffer_size % jnl-&gt;jhdr-&gt;jhdr_size);
		}

		jnl-&gt;tbuffer_size = tbuffer_size;
	}

	<span class="enscript-keyword">if</span> (jnl-&gt;tbuffer_size &gt; (jnl-&gt;jhdr-&gt;size / 2)) {
		jnl-&gt;tbuffer_size = (jnl-&gt;jhdr-&gt;size / 2);
	}
    
	<span class="enscript-keyword">if</span> (jnl-&gt;tbuffer_size &gt; MAX_TRANSACTION_BUFFER_SIZE) {
		jnl-&gt;tbuffer_size = MAX_TRANSACTION_BUFFER_SIZE;
	}

	jnl-&gt;jhdr-&gt;blhdr_size = (jnl-&gt;tbuffer_size / jnl-&gt;jhdr-&gt;jhdr_size) * <span class="enscript-keyword">sizeof</span>(block_info);
	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;blhdr_size &lt; phys_blksz) {
		jnl-&gt;jhdr-&gt;blhdr_size = phys_blksz;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((jnl-&gt;jhdr-&gt;blhdr_size % phys_blksz) != 0) {
		<span class="enscript-comment">// have to round up so we're an even multiple of the physical block size
</span>		jnl-&gt;jhdr-&gt;blhdr_size = (jnl-&gt;jhdr-&gt;blhdr_size + (phys_blksz - 1)) &amp; ~(phys_blksz - 1);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">get_io_info</span>(<span class="enscript-type">struct</span> vnode *devvp, size_t phys_blksz, journal *jnl, <span class="enscript-type">struct</span> vfs_context *context)
{
	off_t	readblockcnt;
	off_t	writeblockcnt;
	off_t	readmaxcnt=0, tmp_readmaxcnt;
	off_t	writemaxcnt=0, tmp_writemaxcnt;
	off_t	readsegcnt, writesegcnt;
	int32_t	features;

	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETFEATURES, (caddr_t)&amp;features, 0, context) == 0) {
		<span class="enscript-keyword">if</span> (features &amp; DK_FEATURE_FORCE_UNIT_ACCESS) {
			<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = vnode_getname_printable(devvp);
			jnl-&gt;flags |= JOURNAL_DO_FUA_WRITES;
			printf(<span class="enscript-string">&quot;jnl: %s: enabling FUA writes (features 0x%x)\n&quot;</span>, name, features);
			vnode_putname_printable(name);
		}
		<span class="enscript-keyword">if</span> (features &amp; DK_FEATURE_UNMAP) {
			jnl-&gt;flags |= JOURNAL_USE_UNMAP;
		}

		<span class="enscript-keyword">if</span> (features &amp; DK_FEATURE_BARRIER) {
			jnl-&gt;flags |= JOURNAL_FEATURE_BARRIER;
		}
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// First check the max read size via several different mechanisms...
</span>	<span class="enscript-comment">//
</span>	VNOP_IOCTL(devvp, DKIOCGETMAXBYTECOUNTREAD, (caddr_t)&amp;readmaxcnt, 0, context);

	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETMAXBLOCKCOUNTREAD, (caddr_t)&amp;readblockcnt, 0, context) == 0) {
		tmp_readmaxcnt = readblockcnt * phys_blksz;
		<span class="enscript-keyword">if</span> (readmaxcnt == 0 || (readblockcnt &gt; 0 &amp;&amp; tmp_readmaxcnt &lt; readmaxcnt)) {
			readmaxcnt = tmp_readmaxcnt;
		}
	}

	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETMAXSEGMENTCOUNTREAD, (caddr_t)&amp;readsegcnt, 0, context)) {
		readsegcnt = 0;
	}

	<span class="enscript-keyword">if</span> (readsegcnt &gt; 0 &amp;&amp; (readsegcnt * PAGE_SIZE) &lt; readmaxcnt) {
		readmaxcnt = readsegcnt * PAGE_SIZE;
	}
	    
	<span class="enscript-keyword">if</span> (readmaxcnt == 0) {
		readmaxcnt = 128 * 1024;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (readmaxcnt &gt; UINT32_MAX) {
		readmaxcnt = UINT32_MAX;
	}


	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// Now check the max writes size via several different mechanisms...
</span>	<span class="enscript-comment">//
</span>	VNOP_IOCTL(devvp, DKIOCGETMAXBYTECOUNTWRITE, (caddr_t)&amp;writemaxcnt, 0, context);

	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETMAXBLOCKCOUNTWRITE, (caddr_t)&amp;writeblockcnt, 0, context) == 0) {
		tmp_writemaxcnt = writeblockcnt * phys_blksz;
		<span class="enscript-keyword">if</span> (writemaxcnt == 0 || (writeblockcnt &gt; 0 &amp;&amp; tmp_writemaxcnt &lt; writemaxcnt)) {
			writemaxcnt = tmp_writemaxcnt;
		}
	}

	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETMAXSEGMENTCOUNTWRITE,	(caddr_t)&amp;writesegcnt, 0, context)) {
		writesegcnt = 0;
	}

	<span class="enscript-keyword">if</span> (writesegcnt &gt; 0 &amp;&amp; (writesegcnt * PAGE_SIZE) &lt; writemaxcnt) {
		writemaxcnt = writesegcnt * PAGE_SIZE;
	}

	<span class="enscript-keyword">if</span> (writemaxcnt == 0) {
		writemaxcnt = 128 * 1024;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (writemaxcnt &gt; UINT32_MAX) {
		writemaxcnt = UINT32_MAX;
	}

	jnl-&gt;max_read_size  = readmaxcnt;
	jnl-&gt;max_write_size = writemaxcnt;
	<span class="enscript-comment">// printf(&quot;jnl: %s: max read/write: %lld k / %lld k\n&quot;,
</span>	<span class="enscript-comment">//     jnl-&gt;jdev_name ? jnl-&gt;jdev_name : &quot;unknown&quot;,
</span>	<span class="enscript-comment">//     jnl-&gt;max_read_size/1024, jnl-&gt;max_write_size/1024);
</span>}


journal *
<span class="enscript-function-name">journal_create</span>(<span class="enscript-type">struct</span> vnode *jvp,
			   off_t         offset,
			   off_t         journal_size,
			   <span class="enscript-type">struct</span> vnode *fsvp,
			   size_t        min_fs_blksz,
			   int32_t       flags,
			   int32_t       tbuffer_size,
			   <span class="enscript-type">void</span>        (*flush)(<span class="enscript-type">void</span> *arg),
			   <span class="enscript-type">void</span>         *arg,
			   <span class="enscript-type">struct</span> mount *fsmount)
{
	journal		*jnl;
	uint32_t	phys_blksz, new_txn_base;
	u_int32_t	min_size;
	<span class="enscript-type">struct</span> vfs_context context;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*jdev_name;
	<span class="enscript-comment">/* 
	 * Cap the journal max size to 2GB.  On HFS, it will attempt to occupy
	 * a full allocation block if the current size is smaller than the allocation
	 * block on which it resides.  Once we hit the exabyte filesystem range, then
	 * it will use 2GB allocation blocks.  As a result, make the cap 2GB.
	 */</span>
	context.vc_thread = current_thread();
	context.vc_ucred = FSCRED;

	jdev_name = vnode_getname_printable(jvp);

	<span class="enscript-comment">/* Get the real physical block size. */</span>
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(jvp, DKIOCGETBLOCKSIZE, (caddr_t)&amp;phys_blksz, 0, &amp;context)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}

	<span class="enscript-keyword">if</span> (journal_size &lt; (256*1024) || journal_size &gt; (MAX_JOURNAL_SIZE)) {
		printf(<span class="enscript-string">&quot;jnl: %s: create: journal size %lld looks bogus.\n&quot;</span>, jdev_name, journal_size);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}

	min_size = phys_blksz * (phys_blksz / <span class="enscript-keyword">sizeof</span>(block_info));
	<span class="enscript-comment">/* Reject journals that are too small given the sector size of the device */</span>
	<span class="enscript-keyword">if</span> (journal_size &lt; min_size) {
		printf(<span class="enscript-string">&quot;jnl: %s: create: journal size (%lld) too small given sector size of (%u)\n&quot;</span>, 
				jdev_name, journal_size, phys_blksz);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}

	<span class="enscript-keyword">if</span> (phys_blksz &gt; min_fs_blksz) {
		printf(<span class="enscript-string">&quot;jnl: %s: create: error: phys blksize %u bigger than min fs blksize %zd\n&quot;</span>,
		       jdev_name, phys_blksz, min_fs_blksz);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}

	<span class="enscript-keyword">if</span> ((journal_size % phys_blksz) != 0) {
		printf(<span class="enscript-string">&quot;jnl: %s: create: journal size 0x%llx is not an even multiple of block size 0x%ux\n&quot;</span>,
		       jdev_name, journal_size, phys_blksz);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}


	MALLOC_ZONE(jnl, <span class="enscript-type">struct</span> journal *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> journal), M_JNL_JNL, M_WAITOK);
	memset(jnl, 0, <span class="enscript-keyword">sizeof</span>(*jnl));

	jnl-&gt;jdev         = jvp;
	jnl-&gt;jdev_offset  = offset;
	jnl-&gt;fsdev        = fsvp;
	jnl-&gt;flush        = flush;
	jnl-&gt;flush_arg    = arg;
	jnl-&gt;flags        = (flags &amp; JOURNAL_OPTION_FLAGS_MASK);
	jnl-&gt;jdev_name    = jdev_name;
	lck_mtx_init(&amp;jnl-&gt;old_start_lock, jnl_mutex_group, jnl_lock_attr);

	<span class="enscript-comment">// Keep a point to the mount around for use in IO throttling.
</span>	jnl-&gt;fsmount      = fsmount;
	<span class="enscript-comment">// XXX: This lock discipline looks correct based on dounmount(), but it
</span>	<span class="enscript-comment">// doesn't seem to be documented anywhere.
</span>	mount_ref(fsmount, 0);

	get_io_info(jvp, phys_blksz, jnl, &amp;context);
	
	<span class="enscript-keyword">if</span> (kmem_alloc_kobject(kernel_map, (vm_offset_t *)&amp;jnl-&gt;header_buf, phys_blksz, VM_KERN_MEMORY_FILE)) {
		printf(<span class="enscript-string">&quot;jnl: %s: create: could not allocate space for header buffer (%u bytes)\n&quot;</span>, jdev_name, phys_blksz);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_kmem_alloc</span>;
	}
	jnl-&gt;header_buf_size = phys_blksz;

	jnl-&gt;jhdr = (journal_header *)jnl-&gt;header_buf;
	memset(jnl-&gt;jhdr, 0, <span class="enscript-keyword">sizeof</span>(journal_header));

	<span class="enscript-comment">// we have to set this up here so that do_journal_io() will work
</span>	jnl-&gt;jhdr-&gt;jhdr_size = phys_blksz;

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// We try and read the journal header to see if there is already one
</span>	<span class="enscript-comment">// out there.  If there is, it's possible that it has transactions
</span>	<span class="enscript-comment">// in it that we might replay if we happen to pick a sequence number
</span>	<span class="enscript-comment">// that is a little less than the old one, there is a crash and the 
</span>	<span class="enscript-comment">// last txn written ends right at the start of a txn from the previous
</span>	<span class="enscript-comment">// incarnation of this file system.  If all that happens we would
</span>	<span class="enscript-comment">// replay the transactions from the old file system and that would
</span>	<span class="enscript-comment">// destroy your disk.  Although it is extremely unlikely for all those
</span>	<span class="enscript-comment">// conditions to happen, the probability is non-zero and the result is
</span>	<span class="enscript-comment">// severe - you lose your file system.  Therefore if we find a valid
</span>	<span class="enscript-comment">// journal header and the sequence number is non-zero we write junk
</span>	<span class="enscript-comment">// over the entire journal so that there is no way we will encounter
</span>	<span class="enscript-comment">// any old transactions.  This is slow but should be a rare event
</span>	<span class="enscript-comment">// since most tools erase the journal.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (   read_journal_header(jnl, jnl-&gt;jhdr, phys_blksz) == phys_blksz
	       &amp;&amp; jnl-&gt;jhdr-&gt;magic == JOURNAL_HEADER_MAGIC
	       &amp;&amp; jnl-&gt;jhdr-&gt;sequence_num != 0) {

		new_txn_base = (jnl-&gt;jhdr-&gt;sequence_num + (journal_size / phys_blksz) + (random() % 16384)) &amp; 0x00ffffff;
		printf(<span class="enscript-string">&quot;jnl: %s: create: avoiding old sequence number 0x%x (0x%x)\n&quot;</span>, jdev_name, jnl-&gt;jhdr-&gt;sequence_num, new_txn_base);

#<span class="enscript-reference">if</span> 0
		<span class="enscript-type">int</span> i;
		off_t pos=0;

		<span class="enscript-keyword">for</span>(i = 1; i &lt; journal_size / phys_blksz; i++) {
			pos = i*phys_blksz;

			<span class="enscript-comment">// we don't really care what data we write just so long
</span>			<span class="enscript-comment">// as it's not a valid transaction header.  since we have
</span>			<span class="enscript-comment">// the header_buf sitting around we'll use that.
</span>			write_journal_data(jnl, &amp;pos, jnl-&gt;header_buf, phys_blksz);
		}
		printf(<span class="enscript-string">&quot;jnl: create: done clearing journal (i=%d)\n&quot;</span>, i);
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span> {
		new_txn_base = random() &amp; 0x00ffffff;
	}

	memset(jnl-&gt;header_buf, 0, phys_blksz);
    
	jnl-&gt;jhdr-&gt;magic      = JOURNAL_HEADER_MAGIC;
	jnl-&gt;jhdr-&gt;endian     = ENDIAN_MAGIC;
	jnl-&gt;jhdr-&gt;start      = phys_blksz;    <span class="enscript-comment">// start at block #1, block #0 is for the jhdr itself
</span>	jnl-&gt;jhdr-&gt;end        = phys_blksz;
	jnl-&gt;jhdr-&gt;size       = journal_size;
	jnl-&gt;jhdr-&gt;jhdr_size  = phys_blksz;
	size_up_tbuffer(jnl, tbuffer_size, phys_blksz);

	jnl-&gt;active_start     = jnl-&gt;jhdr-&gt;start;

	<span class="enscript-comment">// XXXdbg  - for testing you can force the journal to wrap around
</span>	<span class="enscript-comment">// jnl-&gt;jhdr-&gt;start = jnl-&gt;jhdr-&gt;size - (phys_blksz*3);
</span>	<span class="enscript-comment">// jnl-&gt;jhdr-&gt;end   = jnl-&gt;jhdr-&gt;size - (phys_blksz*3);
</span>    
	jnl-&gt;jhdr-&gt;sequence_num = new_txn_base;

	lck_mtx_init(&amp;jnl-&gt;jlock, jnl_mutex_group, jnl_lock_attr);
	lck_mtx_init(&amp;jnl-&gt;flock, jnl_mutex_group, jnl_lock_attr);
	lck_rw_init(&amp;jnl-&gt;trim_lock, jnl_mutex_group, jnl_lock_attr);


	jnl-&gt;flushing = FALSE;
	jnl-&gt;asyncIO = FALSE;
	jnl-&gt;flush_aborted = FALSE;
	jnl-&gt;writing_header = FALSE;
	jnl-&gt;async_trim = NULL;
	jnl-&gt;sequence_num = jnl-&gt;jhdr-&gt;sequence_num;
	
	<span class="enscript-keyword">if</span> (write_journal_header(jnl, 1, jnl-&gt;jhdr-&gt;sequence_num) != 0) {
		printf(<span class="enscript-string">&quot;jnl: %s: journal_create: failed to write journal header.\n&quot;</span>, jdev_name);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_write</span>;
	}

	<span class="enscript-keyword">goto</span> <span class="enscript-reference">journal_create_complete</span>;


<span class="enscript-reference">bad_write</span>:
	kmem_free(kernel_map, (vm_offset_t)jnl-&gt;header_buf, phys_blksz);
<span class="enscript-reference">bad_kmem_alloc</span>:
	jnl-&gt;jhdr = NULL;
	FREE_ZONE(jnl, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> journal), M_JNL_JNL);
	mount_drop(fsmount, 0);
<span class="enscript-reference">cleanup_jdev_name</span>:
	vnode_putname_printable(jdev_name);
	jnl = NULL;
<span class="enscript-reference">journal_create_complete</span>:
	<span class="enscript-keyword">return</span> jnl;
}


journal *
<span class="enscript-function-name">journal_open</span>(<span class="enscript-type">struct</span> vnode *jvp,
			 off_t         offset,
			 off_t         journal_size,
			 <span class="enscript-type">struct</span> vnode *fsvp,
			 size_t        min_fs_blksz,
			 int32_t       flags,
			 int32_t       tbuffer_size,
			 <span class="enscript-type">void</span>        (*flush)(<span class="enscript-type">void</span> *arg),
			 <span class="enscript-type">void</span>         *arg,
			 <span class="enscript-type">struct</span> mount *fsmount)
{
	journal		*jnl;
	uint32_t	orig_blksz=0;
	uint32_t	phys_blksz;
	u_int32_t	min_size = 0;
	<span class="enscript-type">int</span>		orig_checksum, checksum;
	<span class="enscript-type">struct</span> vfs_context context;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*jdev_name = vnode_getname_printable(jvp);

	context.vc_thread = current_thread();
	context.vc_ucred = FSCRED;

	<span class="enscript-comment">/* Get the real physical block size. */</span>
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(jvp, DKIOCGETBLOCKSIZE, (caddr_t)&amp;phys_blksz, 0, &amp;context)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}

	<span class="enscript-keyword">if</span> (phys_blksz &gt; min_fs_blksz) {
		printf(<span class="enscript-string">&quot;jnl: %s: open: error: phys blksize %u bigger than min fs blksize %zd\n&quot;</span>,
		       jdev_name, phys_blksz, min_fs_blksz);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}

	<span class="enscript-keyword">if</span> (journal_size &lt; (256*1024) || journal_size &gt; (1024*1024*1024)) {
		printf(<span class="enscript-string">&quot;jnl: %s: open: journal size %lld looks bogus.\n&quot;</span>, jdev_name, journal_size);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}

	min_size = phys_blksz * (phys_blksz / <span class="enscript-keyword">sizeof</span>(block_info));
	<span class="enscript-comment">/* Reject journals that are too small given the sector size of the device */</span>
	<span class="enscript-keyword">if</span> (journal_size &lt; min_size) {
		printf(<span class="enscript-string">&quot;jnl: %s: open: journal size (%lld) too small given sector size of (%u)\n&quot;</span>, 
				jdev_name, journal_size, phys_blksz);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}
    
	<span class="enscript-keyword">if</span> ((journal_size % phys_blksz) != 0) {
		printf(<span class="enscript-string">&quot;jnl: %s: open: journal size 0x%llx is not an even multiple of block size 0x%x\n&quot;</span>,
		       jdev_name, journal_size, phys_blksz);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}

	MALLOC_ZONE(jnl, <span class="enscript-type">struct</span> journal *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> journal), M_JNL_JNL, M_WAITOK);
	memset(jnl, 0, <span class="enscript-keyword">sizeof</span>(*jnl));

	jnl-&gt;jdev         = jvp;
	jnl-&gt;jdev_offset  = offset;
	jnl-&gt;fsdev        = fsvp;
	jnl-&gt;flush        = flush;
	jnl-&gt;flush_arg    = arg;
	jnl-&gt;flags        = (flags &amp; JOURNAL_OPTION_FLAGS_MASK);
	jnl-&gt;jdev_name    = jdev_name;
	lck_mtx_init(&amp;jnl-&gt;old_start_lock, jnl_mutex_group, jnl_lock_attr);

	<span class="enscript-comment">/* We need a reference to the mount to later pass to the throttling code for
	 * IO accounting.
	 */</span>
	jnl-&gt;fsmount      = fsmount;
	mount_ref(fsmount, 0);

	get_io_info(jvp, phys_blksz, jnl, &amp;context);

	<span class="enscript-keyword">if</span> (kmem_alloc_kobject(kernel_map, (vm_offset_t *)&amp;jnl-&gt;header_buf, phys_blksz, VM_KERN_MEMORY_FILE)) {
		printf(<span class="enscript-string">&quot;jnl: %s: create: could not allocate space for header buffer (%u bytes)\n&quot;</span>, jdev_name, phys_blksz);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_kmem_alloc</span>;
	}
	jnl-&gt;header_buf_size = phys_blksz;

	jnl-&gt;jhdr = (journal_header *)jnl-&gt;header_buf;
	memset(jnl-&gt;jhdr, 0, <span class="enscript-keyword">sizeof</span>(journal_header));

	<span class="enscript-comment">// we have to set this up here so that do_journal_io() will work
</span>	jnl-&gt;jhdr-&gt;jhdr_size = phys_blksz;

	<span class="enscript-keyword">if</span> (read_journal_header(jnl, jnl-&gt;jhdr, phys_blksz) != phys_blksz) {
		printf(<span class="enscript-string">&quot;jnl: %s: open: could not read %u bytes for the journal header.\n&quot;</span>,
		       jdev_name, phys_blksz);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}

	orig_checksum = jnl-&gt;jhdr-&gt;checksum;
	jnl-&gt;jhdr-&gt;checksum = 0;

	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;magic == SWAP32(JOURNAL_HEADER_MAGIC)) {
		<span class="enscript-comment">// do this before the swap since it's done byte-at-a-time
</span>		orig_checksum = SWAP32(orig_checksum);
		checksum = calc_checksum((<span class="enscript-type">char</span> *)jnl-&gt;jhdr, JOURNAL_HEADER_CKSUM_SIZE);
		swap_journal_header(jnl);
		jnl-&gt;flags |= JOURNAL_NEED_SWAP;
	} <span class="enscript-keyword">else</span> {
		checksum = calc_checksum((<span class="enscript-type">char</span> *)jnl-&gt;jhdr, JOURNAL_HEADER_CKSUM_SIZE);
	}

	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;magic != JOURNAL_HEADER_MAGIC &amp;&amp; jnl-&gt;jhdr-&gt;magic != OLD_JOURNAL_HEADER_MAGIC) {
		printf(<span class="enscript-string">&quot;jnl: %s: open: journal magic is bad (0x%x != 0x%x)\n&quot;</span>,
		       jnl-&gt;jdev_name, jnl-&gt;jhdr-&gt;magic, JOURNAL_HEADER_MAGIC);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}

	<span class="enscript-comment">// only check if we're the current journal header magic value
</span>	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;magic == JOURNAL_HEADER_MAGIC) {

		<span class="enscript-keyword">if</span> (orig_checksum != checksum) {
			printf(<span class="enscript-string">&quot;jnl: %s: open: journal checksum is bad (0x%x != 0x%x)\n&quot;</span>,
			       jdev_name, orig_checksum, checksum);
				   
			<span class="enscript-comment">//goto bad_journal;
</span>		}
	}

	<span class="enscript-comment">// XXXdbg - convert old style magic numbers to the new one
</span>	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;magic == OLD_JOURNAL_HEADER_MAGIC) {
		jnl-&gt;jhdr-&gt;magic = JOURNAL_HEADER_MAGIC;
	}

	<span class="enscript-keyword">if</span> (phys_blksz != (size_t)jnl-&gt;jhdr-&gt;jhdr_size &amp;&amp; jnl-&gt;jhdr-&gt;jhdr_size != 0) {
		<span class="enscript-comment">/*
		 * The volume has probably been resized (such that we had to adjust the
		 * logical sector size), or copied to media with a different logical
		 * sector size.
		 * 
		 * Temporarily change the device's logical block size to match the
		 * journal's header size.  This will allow us to replay the journal
		 * safely.  If the replay succeeds, we will update the journal's header
		 * size (later in this function).
		 */</span>
		orig_blksz = phys_blksz;
		phys_blksz = jnl-&gt;jhdr-&gt;jhdr_size;
		VNOP_IOCTL(jvp, DKIOCSETBLOCKSIZE, (caddr_t)&amp;phys_blksz, FWRITE, &amp;context);
		printf(<span class="enscript-string">&quot;jnl: %s: open: temporarily switched block size from %u to %u\n&quot;</span>,
			   jdev_name, orig_blksz, phys_blksz);
	}

	<span class="enscript-keyword">if</span> (   jnl-&gt;jhdr-&gt;start &lt;= 0
	       || jnl-&gt;jhdr-&gt;start &gt; jnl-&gt;jhdr-&gt;size
	       || jnl-&gt;jhdr-&gt;start &gt; 1024*1024*1024) {
		printf(<span class="enscript-string">&quot;jnl: %s: open: jhdr start looks bad (0x%llx max size 0x%llx)\n&quot;</span>,
		       jdev_name, jnl-&gt;jhdr-&gt;start, jnl-&gt;jhdr-&gt;size);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}

	<span class="enscript-keyword">if</span> (   jnl-&gt;jhdr-&gt;end &lt;= 0
	       || jnl-&gt;jhdr-&gt;end &gt; jnl-&gt;jhdr-&gt;size
	       || jnl-&gt;jhdr-&gt;end &gt; 1024*1024*1024) {
		printf(<span class="enscript-string">&quot;jnl: %s: open: jhdr end looks bad (0x%llx max size 0x%llx)\n&quot;</span>,
		       jdev_name, jnl-&gt;jhdr-&gt;end, jnl-&gt;jhdr-&gt;size);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}

	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;size &lt; (256*1024) || jnl-&gt;jhdr-&gt;size &gt; 1024*1024*1024) {
		printf(<span class="enscript-string">&quot;jnl: %s: open: jhdr size looks bad (0x%llx)\n&quot;</span>, jdev_name, jnl-&gt;jhdr-&gt;size);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}

<span class="enscript-comment">// XXXdbg - can't do these checks because hfs writes all kinds of
</span><span class="enscript-comment">//          non-uniform sized blocks even on devices that have a block size
</span><span class="enscript-comment">//          that is larger than 512 bytes (i.e. optical media w/2k blocks).
</span><span class="enscript-comment">//          therefore these checks will fail and so we just have to punt and
</span><span class="enscript-comment">//          do more relaxed checking...
</span><span class="enscript-comment">// XXXdbg    if ((jnl-&gt;jhdr-&gt;start % jnl-&gt;jhdr-&gt;jhdr_size) != 0) {
</span>	<span class="enscript-keyword">if</span> ((jnl-&gt;jhdr-&gt;start % 512) != 0) {
		printf(<span class="enscript-string">&quot;jnl: %s: open: journal start (0x%llx) not a multiple of 512?\n&quot;</span>,
		       jdev_name, jnl-&gt;jhdr-&gt;start);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}

<span class="enscript-comment">//XXXdbg    if ((jnl-&gt;jhdr-&gt;end % jnl-&gt;jhdr-&gt;jhdr_size) != 0) {
</span>	<span class="enscript-keyword">if</span> ((jnl-&gt;jhdr-&gt;end % 512) != 0) {
		printf(<span class="enscript-string">&quot;jnl: %s: open: journal end (0x%llx) not a multiple of block size (0x%x)?\n&quot;</span>,
		       jdev_name, jnl-&gt;jhdr-&gt;end, jnl-&gt;jhdr-&gt;jhdr_size);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}

	<span class="enscript-comment">// take care of replaying the journal if necessary
</span>	<span class="enscript-keyword">if</span> (flags &amp; JOURNAL_RESET) {
		printf(<span class="enscript-string">&quot;jnl: %s: journal start/end pointers reset! (s 0x%llx e 0x%llx)\n&quot;</span>,
		       jdev_name, jnl-&gt;jhdr-&gt;start, jnl-&gt;jhdr-&gt;end);
		jnl-&gt;jhdr-&gt;start = jnl-&gt;jhdr-&gt;end;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (replay_journal(jnl) != 0) {
		printf(<span class="enscript-string">&quot;jnl: %s: journal_open: Error replaying the journal!\n&quot;</span>, jdev_name);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}
	
	<span class="enscript-comment">/*
	 * When we get here, we know that the journal is empty (jnl-&gt;jhdr-&gt;start ==
	 * jnl-&gt;jhdr-&gt;end).  If the device's logical block size was different from
	 * the journal's header size, then we can now restore the device's logical
	 * block size and update the journal's header size to match.
	 *
	 * Note that we also adjust the journal's start and end so that they will
	 * be aligned on the new block size.  We pick a new sequence number to
	 * avoid any problems if a replay found previous transactions using the old
	 * journal header size.  (See the comments in journal_create(), above.)
	 */</span>
	
	<span class="enscript-keyword">if</span> (orig_blksz != 0) {
		VNOP_IOCTL(jvp, DKIOCSETBLOCKSIZE, (caddr_t)&amp;orig_blksz, FWRITE, &amp;context);
		phys_blksz = orig_blksz;
		
		orig_blksz = 0;
		
		jnl-&gt;jhdr-&gt;jhdr_size = phys_blksz;
		jnl-&gt;jhdr-&gt;start = phys_blksz;
		jnl-&gt;jhdr-&gt;end = phys_blksz;
		jnl-&gt;jhdr-&gt;sequence_num = (jnl-&gt;jhdr-&gt;sequence_num +
								   (journal_size / phys_blksz) +
								   (random() % 16384)) &amp; 0x00ffffff;
		
		<span class="enscript-keyword">if</span> (write_journal_header(jnl, 1, jnl-&gt;jhdr-&gt;sequence_num)) {
			printf(<span class="enscript-string">&quot;jnl: %s: open: failed to update journal header size\n&quot;</span>, jdev_name);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
		}
	}

	<span class="enscript-comment">// make sure this is in sync!
</span>	jnl-&gt;active_start = jnl-&gt;jhdr-&gt;start;
	jnl-&gt;sequence_num = jnl-&gt;jhdr-&gt;sequence_num;

	<span class="enscript-comment">// set this now, after we've replayed the journal
</span>	size_up_tbuffer(jnl, tbuffer_size, phys_blksz);

	<span class="enscript-comment">// TODO: Does this need to change if the device's logical block size changed?
</span>	<span class="enscript-keyword">if</span> ((off_t)(jnl-&gt;jhdr-&gt;blhdr_size/<span class="enscript-keyword">sizeof</span>(block_info)-1) &gt; (jnl-&gt;jhdr-&gt;size/jnl-&gt;jhdr-&gt;jhdr_size)) {
		printf(<span class="enscript-string">&quot;jnl: %s: open: jhdr size and blhdr size are not compatible (0x%llx, %d, %d)\n&quot;</span>, jdev_name, jnl-&gt;jhdr-&gt;size,
		       jnl-&gt;jhdr-&gt;blhdr_size, jnl-&gt;jhdr-&gt;jhdr_size);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}

	lck_mtx_init(&amp;jnl-&gt;jlock, jnl_mutex_group, jnl_lock_attr);
	lck_mtx_init(&amp;jnl-&gt;flock, jnl_mutex_group, jnl_lock_attr);
	lck_rw_init(&amp;jnl-&gt;trim_lock, jnl_mutex_group, jnl_lock_attr);

	<span class="enscript-keyword">goto</span> <span class="enscript-reference">journal_open_complete</span>;

<span class="enscript-reference">bad_journal</span>:
	<span class="enscript-keyword">if</span> (orig_blksz != 0) {
		phys_blksz = orig_blksz;
		VNOP_IOCTL(jvp, DKIOCSETBLOCKSIZE, (caddr_t)&amp;orig_blksz, FWRITE, &amp;context);
		printf(<span class="enscript-string">&quot;jnl: %s: open: restored block size after error\n&quot;</span>, jdev_name);
	}
	kmem_free(kernel_map, (vm_offset_t)jnl-&gt;header_buf, phys_blksz);
<span class="enscript-reference">bad_kmem_alloc</span>:
	FREE_ZONE(jnl, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> journal), M_JNL_JNL);
	mount_drop(fsmount, 0);
<span class="enscript-reference">cleanup_jdev_name</span>:
	vnode_putname_printable(jdev_name);
	jnl = NULL;
<span class="enscript-reference">journal_open_complete</span>:
	<span class="enscript-keyword">return</span> jnl;    
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_is_clean</span>(<span class="enscript-type">struct</span> vnode *jvp,
		 off_t         offset,
		 off_t         journal_size,
		 <span class="enscript-type">struct</span> vnode *fsvp,
                 size_t        min_fs_block_size)
{
	journal		jnl;
	uint32_t	phys_blksz;
	<span class="enscript-type">int</span>		ret;
	<span class="enscript-type">int</span>		orig_checksum, checksum;
	<span class="enscript-type">struct</span> vfs_context context;
	<span class="enscript-type">const</span>		<span class="enscript-type">char</span> *jdev_name = vnode_getname_printable(jvp);

	context.vc_thread = current_thread();
	context.vc_ucred = FSCRED;

	<span class="enscript-comment">/* Get the real physical block size. */</span>
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(jvp, DKIOCGETBLOCKSIZE, (caddr_t)&amp;phys_blksz, 0, &amp;context)) {
		printf(<span class="enscript-string">&quot;jnl: %s: is_clean: failed to get device block size.\n&quot;</span>, jdev_name);
		ret = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}

	<span class="enscript-keyword">if</span> (phys_blksz &gt; (uint32_t)min_fs_block_size) {
		printf(<span class="enscript-string">&quot;jnl: %s: is_clean: error: phys blksize %d bigger than min fs blksize %zd\n&quot;</span>,
		       jdev_name, phys_blksz, min_fs_block_size);
		ret = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}

	<span class="enscript-keyword">if</span> (journal_size &lt; (256*1024) || journal_size &gt; (MAX_JOURNAL_SIZE)) {
		printf(<span class="enscript-string">&quot;jnl: %s: is_clean: journal size %lld looks bogus.\n&quot;</span>, jdev_name, journal_size);
		ret = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}
    
	<span class="enscript-keyword">if</span> ((journal_size % phys_blksz) != 0) {
		printf(<span class="enscript-string">&quot;jnl: %s: is_clean: journal size 0x%llx is not an even multiple of block size 0x%x\n&quot;</span>,
		       jdev_name, journal_size, phys_blksz);
		ret = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}

	memset(&amp;jnl, 0, <span class="enscript-keyword">sizeof</span>(jnl));

	<span class="enscript-keyword">if</span> (kmem_alloc_kobject(kernel_map, (vm_offset_t *)&amp;jnl.header_buf, phys_blksz, VM_KERN_MEMORY_FILE)) {
		printf(<span class="enscript-string">&quot;jnl: %s: is_clean: could not allocate space for header buffer (%d bytes)\n&quot;</span>, jdev_name, phys_blksz);
		ret = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_jdev_name</span>;
	}
	jnl.header_buf_size = phys_blksz;

	get_io_info(jvp, phys_blksz, &amp;jnl, &amp;context);
    
	jnl.jhdr = (journal_header *)jnl.header_buf;
	memset(jnl.jhdr, 0, <span class="enscript-keyword">sizeof</span>(journal_header));

	jnl.jdev        = jvp;
	jnl.jdev_offset = offset;
	jnl.fsdev       = fsvp;

	<span class="enscript-comment">// we have to set this up here so that do_journal_io() will work
</span>	jnl.jhdr-&gt;jhdr_size = phys_blksz;

	<span class="enscript-keyword">if</span> (read_journal_header(&amp;jnl, jnl.jhdr, phys_blksz) != (<span class="enscript-type">unsigned</span>)phys_blksz) {
		printf(<span class="enscript-string">&quot;jnl: %s: is_clean: could not read %d bytes for the journal header.\n&quot;</span>,
		       jdev_name, phys_blksz);
		ret = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}

	orig_checksum = jnl.jhdr-&gt;checksum;
	jnl.jhdr-&gt;checksum = 0;

	<span class="enscript-keyword">if</span> (jnl.jhdr-&gt;magic == SWAP32(JOURNAL_HEADER_MAGIC)) {
		<span class="enscript-comment">// do this before the swap since it's done byte-at-a-time
</span>		orig_checksum = SWAP32(orig_checksum);
		checksum = calc_checksum((<span class="enscript-type">char</span> *)jnl.jhdr, JOURNAL_HEADER_CKSUM_SIZE);
		swap_journal_header(&amp;jnl);
		jnl.flags |= JOURNAL_NEED_SWAP;
	} <span class="enscript-keyword">else</span> {
		checksum = calc_checksum((<span class="enscript-type">char</span> *)jnl.jhdr, JOURNAL_HEADER_CKSUM_SIZE);
	}

	<span class="enscript-keyword">if</span> (jnl.jhdr-&gt;magic != JOURNAL_HEADER_MAGIC &amp;&amp; jnl.jhdr-&gt;magic != OLD_JOURNAL_HEADER_MAGIC) {
		printf(<span class="enscript-string">&quot;jnl: %s: is_clean: journal magic is bad (0x%x != 0x%x)\n&quot;</span>,
		       jdev_name, jnl.jhdr-&gt;magic, JOURNAL_HEADER_MAGIC);
		ret = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}

	<span class="enscript-keyword">if</span> (orig_checksum != checksum) {
		printf(<span class="enscript-string">&quot;jnl: %s: is_clean: journal checksum is bad (0x%x != 0x%x)\n&quot;</span>, jdev_name, orig_checksum, checksum);
		ret = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if the start and end are equal then the journal is clean.
</span>	<span class="enscript-comment">// otherwise it's not clean and therefore an error.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (jnl.jhdr-&gt;start == jnl.jhdr-&gt;end) {
		ret = 0;
	} <span class="enscript-keyword">else</span> {
		ret = EBUSY;    <span class="enscript-comment">// so the caller can differentiate an invalid journal from a &quot;busy&quot; one
</span>	}

<span class="enscript-reference">get_out</span>:
	kmem_free(kernel_map, (vm_offset_t)jnl.header_buf, phys_blksz);
<span class="enscript-reference">cleanup_jdev_name</span>:
	vnode_putname_printable(jdev_name);
	<span class="enscript-keyword">return</span> ret;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">journal_close</span>(journal *jnl)
{
	<span class="enscript-type">volatile</span> off_t *start, *end;
	<span class="enscript-type">int</span>             counter=0;

	CHECK_JOURNAL(jnl);

	<span class="enscript-comment">// set this before doing anything that would block so that
</span>	<span class="enscript-comment">// we start tearing things down properly.
</span>	<span class="enscript-comment">//
</span>	jnl-&gt;flags |= JOURNAL_CLOSE_PENDING;

	<span class="enscript-keyword">if</span> (jnl-&gt;owner != current_thread()) {
		journal_lock(jnl);
	}

	wait_condition(jnl, &amp;jnl-&gt;flushing, <span class="enscript-string">&quot;journal_close&quot;</span>);

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// only write stuff to disk if the journal is still valid
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> ((jnl-&gt;flags &amp; JOURNAL_INVALID) == 0) {

		<span class="enscript-keyword">if</span> (jnl-&gt;active_tr) {
			<span class="enscript-comment">/*
			 * &quot;journal_end_transaction&quot; will fire the flush asynchronously
			 */</span>
			journal_end_transaction(jnl);
		}
		
		<span class="enscript-comment">// flush any buffered transactions
</span>		<span class="enscript-keyword">if</span> (jnl-&gt;cur_tr) {
			transaction *tr = jnl-&gt;cur_tr;

			jnl-&gt;cur_tr = NULL;
			<span class="enscript-comment">/*
			 * &quot;end_transaction&quot; will wait for any in-progress flush to complete
			 * before flushing &quot;cur_tr&quot; synchronously(&quot;must_wait&quot; == TRUE)
			 */</span>
			end_transaction(tr, 1, NULL, NULL, FALSE, TRUE);
		}
		<span class="enscript-comment">/*
		 * if there was an &quot;active_tr&quot;, make sure we wait for
		 * it to flush if there was no &quot;cur_tr&quot; to process
		 */</span>
		wait_condition(jnl, &amp;jnl-&gt;flushing, <span class="enscript-string">&quot;journal_close&quot;</span>);
    
		<span class="enscript-comment">//start = &amp;jnl-&gt;jhdr-&gt;start;
</span>		start = &amp;jnl-&gt;active_start;
		end   = &amp;jnl-&gt;jhdr-&gt;end;
    
		<span class="enscript-keyword">while</span> (*start != *end &amp;&amp; counter++ &lt; 5000) {
			<span class="enscript-comment">//printf(&quot;jnl: close: flushing the buffer cache (start 0x%llx end 0x%llx)\n&quot;, *start, *end);
</span>			<span class="enscript-keyword">if</span> (jnl-&gt;flush) {
				jnl-&gt;flush(jnl-&gt;flush_arg);
			}
			tsleep((caddr_t)jnl, PRIBIO, <span class="enscript-string">&quot;jnl_close&quot;</span>, 2);
		}

		<span class="enscript-keyword">if</span> (*start != *end) {
			printf(<span class="enscript-string">&quot;jnl: %s: close: buffer flushing didn't seem to flush out all the transactions! (0x%llx - 0x%llx)\n&quot;</span>,
			       jnl-&gt;jdev_name, *start, *end);
		}

		<span class="enscript-comment">// make sure this is in sync when we close the journal
</span>		jnl-&gt;jhdr-&gt;start = jnl-&gt;active_start;

		<span class="enscript-comment">// if this fails there's not much we can do at this point...
</span>		write_journal_header(jnl, 1, jnl-&gt;sequence_num);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// if we're here the journal isn't valid any more.
</span>		<span class="enscript-comment">// so make sure we don't leave any locked blocks lying around
</span>		printf(<span class="enscript-string">&quot;jnl: %s: close: journal is invalid.  aborting outstanding transactions\n&quot;</span>, jnl-&gt;jdev_name);
		<span class="enscript-keyword">if</span> (jnl-&gt;active_tr || jnl-&gt;cur_tr) {
			transaction *tr;

			<span class="enscript-keyword">if</span> (jnl-&gt;active_tr) {
				tr = jnl-&gt;active_tr;
				jnl-&gt;active_tr = NULL;
			} <span class="enscript-keyword">else</span> {
				tr = jnl-&gt;cur_tr;
				jnl-&gt;cur_tr = NULL;
			}
			abort_transaction(jnl, tr);

			<span class="enscript-keyword">if</span> (jnl-&gt;active_tr || jnl-&gt;cur_tr) {
				panic(<span class="enscript-string">&quot;jnl: %s: close: jnl @ %p had both an active and cur tr\n&quot;</span>, jnl-&gt;jdev_name, jnl);
			}
		}
	}
	wait_condition(jnl, &amp;jnl-&gt;asyncIO, <span class="enscript-string">&quot;journal_close&quot;</span>);

	free_old_stuff(jnl);

	kmem_free(kernel_map, (vm_offset_t)jnl-&gt;header_buf, jnl-&gt;header_buf_size);
	jnl-&gt;jhdr = (<span class="enscript-type">void</span> *)0xbeefbabe;

	<span class="enscript-comment">// Release reference on the mount
</span>	<span class="enscript-keyword">if</span> (jnl-&gt;fsmount)
		 mount_drop(jnl-&gt;fsmount, 0);

	vnode_putname_printable(jnl-&gt;jdev_name);

	journal_unlock(jnl);
	lck_mtx_destroy(&amp;jnl-&gt;old_start_lock, jnl_mutex_group);
	lck_mtx_destroy(&amp;jnl-&gt;jlock, jnl_mutex_group);
	lck_mtx_destroy(&amp;jnl-&gt;flock, jnl_mutex_group);
	FREE_ZONE(jnl, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> journal), M_JNL_JNL);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dump_journal</span>(journal *jnl)
{
	transaction *ctr;

	printf(<span class="enscript-string">&quot;journal for dev %s:&quot;</span>, jnl-&gt;jdev_name);
	printf(<span class="enscript-string">&quot;  jdev_offset %.8llx\n&quot;</span>, jnl-&gt;jdev_offset);
	printf(<span class="enscript-string">&quot;  magic: 0x%.8x\n&quot;</span>, jnl-&gt;jhdr-&gt;magic);
	printf(<span class="enscript-string">&quot;  start: 0x%.8llx\n&quot;</span>, jnl-&gt;jhdr-&gt;start);
	printf(<span class="enscript-string">&quot;  end:   0x%.8llx\n&quot;</span>, jnl-&gt;jhdr-&gt;end);
	printf(<span class="enscript-string">&quot;  size:  0x%.8llx\n&quot;</span>, jnl-&gt;jhdr-&gt;size);
	printf(<span class="enscript-string">&quot;  blhdr size: %d\n&quot;</span>, jnl-&gt;jhdr-&gt;blhdr_size);
	printf(<span class="enscript-string">&quot;  jhdr size: %d\n&quot;</span>, jnl-&gt;jhdr-&gt;jhdr_size);
	printf(<span class="enscript-string">&quot;  chksum: 0x%.8x\n&quot;</span>, jnl-&gt;jhdr-&gt;checksum);
    
	printf(<span class="enscript-string">&quot;  completed transactions:\n&quot;</span>);
	<span class="enscript-keyword">for</span> (ctr = jnl-&gt;completed_trs; ctr; ctr = ctr-&gt;next) {
		printf(<span class="enscript-string">&quot;    0x%.8llx - 0x%.8llx\n&quot;</span>, ctr-&gt;journal_start, ctr-&gt;journal_end);
	}
}



<span class="enscript-type">static</span> off_t
<span class="enscript-function-name">free_space</span>(journal *jnl)
{
	off_t free_space_offset;
	
	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;start &lt; jnl-&gt;jhdr-&gt;end) {
		free_space_offset = jnl-&gt;jhdr-&gt;size - (jnl-&gt;jhdr-&gt;end - jnl-&gt;jhdr-&gt;start) - jnl-&gt;jhdr-&gt;jhdr_size;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;start &gt; jnl-&gt;jhdr-&gt;end) {
		free_space_offset = jnl-&gt;jhdr-&gt;start - jnl-&gt;jhdr-&gt;end;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// journal is completely empty
</span>		free_space_offset = jnl-&gt;jhdr-&gt;size - jnl-&gt;jhdr-&gt;jhdr_size;
	}

	<span class="enscript-keyword">return</span> free_space_offset;
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// The journal must be locked on entry to this function.
</span><span class="enscript-comment">// The &quot;desired_size&quot; is in bytes.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">check_free_space</span>(journal *jnl, <span class="enscript-type">int</span> desired_size, boolean_t *delayed_header_write, uint32_t sequence_num)
{
	size_t	i;
	<span class="enscript-type">int</span>	counter=0;

	<span class="enscript-comment">//printf(&quot;jnl: check free space (desired 0x%x, avail 0x%Lx)\n&quot;,
</span>        <span class="enscript-comment">//	   desired_size, free_space(jnl));
</span>
	<span class="enscript-keyword">if</span> (delayed_header_write)
		*delayed_header_write = FALSE;
    
	<span class="enscript-keyword">while</span> (1) {
		<span class="enscript-type">int</span> old_start_empty;
		
		<span class="enscript-comment">// make sure there's space in the journal to hold this transaction
</span>		<span class="enscript-keyword">if</span> (free_space(jnl) &gt; desired_size &amp;&amp; jnl-&gt;old_start[0] == 0) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (counter++ == 5000) {
			dump_journal(jnl);
			panic(<span class="enscript-string">&quot;jnl: check_free_space: buffer flushing isn't working &quot;</span>
			      <span class="enscript-string">&quot;(jnl @ %p s %lld e %lld f %lld [active start %lld]).\n&quot;</span>, jnl,
			      jnl-&gt;jhdr-&gt;start, jnl-&gt;jhdr-&gt;end, free_space(jnl), jnl-&gt;active_start);
		}
		<span class="enscript-keyword">if</span> (counter &gt; 7500) {
			printf(<span class="enscript-string">&quot;jnl: %s: check_free_space: giving up waiting for free space.\n&quot;</span>, jnl-&gt;jdev_name);
			<span class="enscript-keyword">return</span> ENOSPC;
		}

		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// here's where we lazily bump up jnl-&gt;jhdr-&gt;start.  we'll consume
</span>		<span class="enscript-comment">// entries until there is enough space for the next transaction.
</span>		<span class="enscript-comment">//
</span>		old_start_empty = 1;
		lock_oldstart(jnl);

		<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start)/<span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start[0]); i++) {
			<span class="enscript-type">int</span>   lcl_counter;

			lcl_counter = 0;
			<span class="enscript-keyword">while</span> (jnl-&gt;old_start[i] &amp; 0x8000000000000000LL) {
				<span class="enscript-keyword">if</span> (lcl_counter++ &gt; 10000) {
					panic(<span class="enscript-string">&quot;jnl: check_free_space: tr starting @ 0x%llx not flushing (jnl %p).\n&quot;</span>,
					      jnl-&gt;old_start[i], jnl);
				}
				
				unlock_oldstart(jnl);
				<span class="enscript-keyword">if</span> (jnl-&gt;flush) {
					jnl-&gt;flush(jnl-&gt;flush_arg);
				}
				tsleep((caddr_t)jnl, PRIBIO, <span class="enscript-string">&quot;check_free_space1&quot;</span>, 1);
				lock_oldstart(jnl);
			}

			<span class="enscript-keyword">if</span> (jnl-&gt;old_start[i] == 0) {
				<span class="enscript-keyword">continue</span>;
			}

			old_start_empty   = 0;
			jnl-&gt;jhdr-&gt;start  = jnl-&gt;old_start[i];
			jnl-&gt;old_start[i] = 0;

			<span class="enscript-keyword">if</span> (free_space(jnl) &gt; desired_size) {
				
				<span class="enscript-keyword">if</span> (delayed_header_write)
					*delayed_header_write = TRUE;
				<span class="enscript-keyword">else</span> {
					unlock_oldstart(jnl);
					write_journal_header(jnl, 1, sequence_num);
					lock_oldstart(jnl);
				}
				<span class="enscript-keyword">break</span>;
			}
		}
		unlock_oldstart(jnl);
		
		<span class="enscript-comment">// if we bumped the start, loop and try again
</span>		<span class="enscript-keyword">if</span> (i &lt; <span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start)/<span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start[0])) {
			<span class="enscript-keyword">continue</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (old_start_empty) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// if there is nothing in old_start anymore then we can
</span>			<span class="enscript-comment">// bump the jhdr-&gt;start to be the same as active_start
</span>			<span class="enscript-comment">// since it is possible there was only one very large
</span>			<span class="enscript-comment">// transaction in the old_start array.  if we didn't do
</span>			<span class="enscript-comment">// this then jhdr-&gt;start would never get updated and we
</span>			<span class="enscript-comment">// would wind up looping until we hit the panic at the
</span>			<span class="enscript-comment">// start of the loop.
</span>			<span class="enscript-comment">//
</span>			jnl-&gt;jhdr-&gt;start = jnl-&gt;active_start;
			
			<span class="enscript-keyword">if</span> (delayed_header_write)
				*delayed_header_write = TRUE;
			<span class="enscript-keyword">else</span>
				write_journal_header(jnl, 1, sequence_num);
			<span class="enscript-keyword">continue</span>;
		}


		<span class="enscript-comment">// if the file system gave us a flush function, call it to so that
</span>		<span class="enscript-comment">// it can flush some blocks which hopefully will cause some transactions
</span>		<span class="enscript-comment">// to complete and thus free up space in the journal.
</span>		<span class="enscript-keyword">if</span> (jnl-&gt;flush) {
			jnl-&gt;flush(jnl-&gt;flush_arg);
		}
	
		<span class="enscript-comment">// wait for a while to avoid being cpu-bound (this will
</span>		<span class="enscript-comment">// put us to sleep for 10 milliseconds)
</span>		tsleep((caddr_t)jnl, PRIBIO, <span class="enscript-string">&quot;check_free_space2&quot;</span>, 1);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Allocate a new active transaction.
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">journal_allocate_transaction</span>(journal *jnl)
{
	transaction *tr;
	boolean_t was_vm_privileged = FALSE;
	kern_return_t retval;
	
	<span class="enscript-keyword">if</span> (jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) {
		<span class="enscript-comment">/*
		 * the disk driver can allocate memory on this path...
		 * if we block waiting for memory, and there is enough pressure to
		 * cause us to try and create a new swap file, we may end up deadlocking
		 * due to waiting for the journal on the swap file creation path...
		 * by making ourselves vm_privileged, we give ourselves the best chance
		 * of not blocking
		 */</span>
		was_vm_privileged = set_vm_privilege(TRUE);
	}
	MALLOC_ZONE(tr, transaction *, <span class="enscript-keyword">sizeof</span>(transaction), M_JNL_TR, M_WAITOK);
	memset(tr, 0, <span class="enscript-keyword">sizeof</span>(transaction));

	tr-&gt;tbuffer_size = jnl-&gt;tbuffer_size;

	retval = kmem_alloc_kobject(kernel_map, (vm_offset_t *)&amp;tr-&gt;tbuffer, tr-&gt;tbuffer_size, VM_KERN_MEMORY_FILE);

	<span class="enscript-keyword">if</span> ((jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) &amp;&amp; (was_vm_privileged == FALSE))
		set_vm_privilege(FALSE);

	<span class="enscript-keyword">if</span> (retval) {
		FREE_ZONE(tr, <span class="enscript-keyword">sizeof</span>(transaction), M_JNL_TR);
		jnl-&gt;active_tr = NULL;
		<span class="enscript-keyword">return</span> ENOMEM;
	}

	<span class="enscript-comment">// journal replay code checksum check depends on this.
</span>	memset(tr-&gt;tbuffer, 0, BLHDR_CHECKSUM_SIZE);
	<span class="enscript-comment">// Fill up the rest of the block with unimportant bytes (0x5a 'Z' chosen for visibility)
</span>	memset(tr-&gt;tbuffer + BLHDR_CHECKSUM_SIZE, 0x5a, jnl-&gt;jhdr-&gt;blhdr_size - BLHDR_CHECKSUM_SIZE);

	tr-&gt;blhdr = (block_list_header *)tr-&gt;tbuffer;
	tr-&gt;blhdr-&gt;max_blocks = (jnl-&gt;jhdr-&gt;blhdr_size / <span class="enscript-keyword">sizeof</span>(block_info)) - 1;
	tr-&gt;blhdr-&gt;num_blocks = 1;      <span class="enscript-comment">// accounts for this header block
</span>	tr-&gt;blhdr-&gt;bytes_used = jnl-&gt;jhdr-&gt;blhdr_size;
	tr-&gt;blhdr-&gt;flags = BLHDR_CHECK_CHECKSUMS | BLHDR_FIRST_HEADER;

	tr-&gt;sequence_num = ++jnl-&gt;sequence_num;
	tr-&gt;num_blhdrs  = 1;
	tr-&gt;total_bytes = jnl-&gt;jhdr-&gt;blhdr_size;
	tr-&gt;jnl         = jnl;

	jnl-&gt;active_tr  = tr;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_start_transaction</span>(journal *jnl)
{
	<span class="enscript-type">int</span> ret;

	CHECK_JOURNAL(jnl);
    
	free_old_stuff(jnl);

	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_INVALID) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> (jnl-&gt;owner == current_thread()) {
		<span class="enscript-keyword">if</span> (jnl-&gt;active_tr == NULL) {
			panic(<span class="enscript-string">&quot;jnl: start_tr: active_tr is NULL (jnl @ %p, owner %p, current_thread %p\n&quot;</span>,
			      jnl, jnl-&gt;owner, current_thread());
		}
		jnl-&gt;nested_count++;
		<span class="enscript-keyword">return</span> 0;
	}

	journal_lock(jnl);

	<span class="enscript-keyword">if</span> (jnl-&gt;nested_count != 0 || jnl-&gt;active_tr != NULL) {
		panic(<span class="enscript-string">&quot;jnl: start_tr: owner %p, nested count %d, active_tr %p jnl @ %p\n&quot;</span>,
		      jnl-&gt;owner, jnl-&gt;nested_count, jnl-&gt;active_tr, jnl);
	}

	jnl-&gt;nested_count = 1;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">JOE</span>
	<span class="enscript-comment">// make sure there's room in the journal
</span>	<span class="enscript-keyword">if</span> (free_space(jnl) &lt; jnl-&gt;tbuffer_size) {

		KERNEL_DEBUG(0xbbbbc030 | DBG_FUNC_START, jnl, 0, 0, 0, 0);

		<span class="enscript-comment">// this is the call that really waits for space to free up
</span>		<span class="enscript-comment">// as well as updating jnl-&gt;jhdr-&gt;start
</span>		<span class="enscript-keyword">if</span> (check_free_space(jnl, jnl-&gt;tbuffer_size, NULL, jnl-&gt;sequence_num) != 0) {
			printf(<span class="enscript-string">&quot;jnl: %s: start transaction failed: no space\n&quot;</span>, jnl-&gt;jdev_name);
			ret = ENOSPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_start</span>;
		}
		KERNEL_DEBUG(0xbbbbc030 | DBG_FUNC_END, jnl, 0, 0, 0, 0);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">// if there's a buffered transaction, use it.
</span>	<span class="enscript-keyword">if</span> (jnl-&gt;cur_tr) {
		jnl-&gt;active_tr = jnl-&gt;cur_tr;
		jnl-&gt;cur_tr    = NULL;

		<span class="enscript-keyword">return</span> 0;
	}

	ret = journal_allocate_transaction(jnl);
	<span class="enscript-keyword">if</span> (ret) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_start</span>;
	}

	<span class="enscript-comment">// printf(&quot;jnl: start_tr: owner 0x%x new tr @ 0x%x\n&quot;, jnl-&gt;owner, jnl-&gt;active_tr);
</span>
	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">bad_start</span>:
	jnl-&gt;nested_count = 0;
	journal_unlock(jnl);

	<span class="enscript-keyword">return</span> ret;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_modify_block_start</span>(journal *jnl, <span class="enscript-type">struct</span> buf *bp)
{
	transaction *tr;
	boolean_t was_vm_privileged = FALSE;
    
	CHECK_JOURNAL(jnl);


	free_old_stuff(jnl);

	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_INVALID) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) {
		<span class="enscript-comment">/*
		 * if we block waiting for memory, and there is enough pressure to
		 * cause us to try and create a new swap file, we may end up deadlocking
		 * due to waiting for the journal on the swap file creation path...
		 * by making ourselves vm_privileged, we give ourselves the best chance
		 * of not blocking
		 */</span>
		was_vm_privileged = set_vm_privilege(TRUE);
	}

	<span class="enscript-comment">// XXXdbg - for debugging I want this to be true.  later it may
</span>	<span class="enscript-comment">//          not be necessary.
</span>	<span class="enscript-keyword">if</span> ((buf_flags(bp) &amp; B_META) == 0) {
		panic(<span class="enscript-string">&quot;jnl: modify_block_start: bp @ %p is not a meta-data block! (jnl %p)\n&quot;</span>, bp, jnl);
	}

	tr = jnl-&gt;active_tr;
	CHECK_TRANSACTION(tr);

	<span class="enscript-keyword">if</span> (jnl-&gt;owner != current_thread()) {
		panic(<span class="enscript-string">&quot;jnl: modify_block_start: called w/out a transaction! jnl %p, owner %p, curact %p\n&quot;</span>,
		      jnl, jnl-&gt;owner, current_thread());
	}

	<span class="enscript-comment">//printf(&quot;jnl: mod block start (bp 0x%x vp 0x%x l/blkno %qd/%qd bsz %d; total bytes %d)\n&quot;,
</span>	<span class="enscript-comment">//   bp, buf_vnode(bp), buf_lblkno(bp), buf_blkno(bp), buf_size(bp), tr-&gt;total_bytes);
</span>
	<span class="enscript-comment">// can't allow blocks that aren't an even multiple of the
</span>	<span class="enscript-comment">// underlying block size.
</span>	<span class="enscript-keyword">if</span> ((buf_size(bp) % jnl-&gt;jhdr-&gt;jhdr_size) != 0) {
		uint32_t phys_blksz, bad=0;
	    
		<span class="enscript-keyword">if</span> (VNOP_IOCTL(jnl-&gt;jdev, DKIOCGETBLOCKSIZE, (caddr_t)&amp;phys_blksz, 0, vfs_context_kernel())) {
			bad = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (phys_blksz != (uint32_t)jnl-&gt;jhdr-&gt;jhdr_size) {
			<span class="enscript-keyword">if</span> (phys_blksz &lt; 512) {
				panic(<span class="enscript-string">&quot;jnl: mod block start: phys blksz %d is too small (%d, %d)\n&quot;</span>,
				      phys_blksz, buf_size(bp), jnl-&gt;jhdr-&gt;jhdr_size);
			}

			<span class="enscript-keyword">if</span> ((buf_size(bp) % phys_blksz) != 0) {
				bad = 1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (phys_blksz &lt; (uint32_t)jnl-&gt;jhdr-&gt;jhdr_size) {
				jnl-&gt;jhdr-&gt;jhdr_size = phys_blksz;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// the phys_blksz is now larger... need to realloc the jhdr
</span>				<span class="enscript-type">char</span> *new_header_buf;

				printf(<span class="enscript-string">&quot;jnl: %s: phys blksz got bigger (was: %d/%d now %d)\n&quot;</span>,
				       jnl-&gt;jdev_name, jnl-&gt;header_buf_size, jnl-&gt;jhdr-&gt;jhdr_size, phys_blksz);
				<span class="enscript-keyword">if</span> (kmem_alloc_kobject(kernel_map, (vm_offset_t *)&amp;new_header_buf, phys_blksz, VM_KERN_MEMORY_FILE)) {
					printf(<span class="enscript-string">&quot;jnl: modify_block_start: %s: create: phys blksz change (was %d, now %d) but could not allocate space for new header\n&quot;</span>,
					       jnl-&gt;jdev_name, jnl-&gt;jhdr-&gt;jhdr_size, phys_blksz);
					bad = 1;
				} <span class="enscript-keyword">else</span> {
					memcpy(new_header_buf, jnl-&gt;header_buf, jnl-&gt;header_buf_size);
					memset(&amp;new_header_buf[jnl-&gt;header_buf_size], 0x18, (phys_blksz - jnl-&gt;header_buf_size));
					kmem_free(kernel_map, (vm_offset_t)jnl-&gt;header_buf, jnl-&gt;header_buf_size);
					jnl-&gt;header_buf = new_header_buf;
					jnl-&gt;header_buf_size = phys_blksz;
					
					jnl-&gt;jhdr = (journal_header *)jnl-&gt;header_buf;
					jnl-&gt;jhdr-&gt;jhdr_size = phys_blksz;
				}
			}
		} <span class="enscript-keyword">else</span> {
			bad = 1;
		}
	    
		<span class="enscript-keyword">if</span> (bad) {
			panic(<span class="enscript-string">&quot;jnl: mod block start: bufsize %d not a multiple of block size %d\n&quot;</span>,
			      buf_size(bp), jnl-&gt;jhdr-&gt;jhdr_size);

			<span class="enscript-keyword">if</span> ((jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) &amp;&amp; (was_vm_privileged == FALSE))
				set_vm_privilege(FALSE);
			<span class="enscript-keyword">return</span> -1;
		}
	}

	<span class="enscript-comment">// make sure that this transaction isn't bigger than the whole journal
</span>	<span class="enscript-keyword">if</span> (tr-&gt;total_bytes+buf_size(bp) &gt;= (jnl-&gt;jhdr-&gt;size - jnl-&gt;jhdr-&gt;jhdr_size)) {
		panic(<span class="enscript-string">&quot;jnl: transaction too big (%d &gt;= %lld bytes, bufsize %d, tr %p bp %p)\n&quot;</span>,
		      tr-&gt;total_bytes, (tr-&gt;jnl-&gt;jhdr-&gt;size - jnl-&gt;jhdr-&gt;jhdr_size), buf_size(bp), tr, bp);

		<span class="enscript-keyword">if</span> ((jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) &amp;&amp; (was_vm_privileged == FALSE))
			set_vm_privilege(FALSE);
		<span class="enscript-keyword">return</span> -1;
	}

	<span class="enscript-comment">// if the block is dirty and not already locked we have to write
</span>	<span class="enscript-comment">// it out before we muck with it because it has data that belongs
</span>	<span class="enscript-comment">// (presumably) to another transaction.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> ((buf_flags(bp) &amp; (B_DELWRI | B_LOCKED)) == B_DELWRI) {

		<span class="enscript-keyword">if</span> (buf_flags(bp) &amp; B_ASYNC) {
			panic(<span class="enscript-string">&quot;modify_block_start: bp @ %p has async flag set!\n&quot;</span>, bp);
		}
		<span class="enscript-keyword">if</span> (bp-&gt;b_shadow_ref)
			panic(<span class="enscript-string">&quot;modify_block_start: dirty bp @ %p has shadows!\n&quot;</span>, bp);

		<span class="enscript-comment">// this will cause it to not be buf_brelse()'d
</span>                buf_setflags(bp, B_NORELSE);
		VNOP_BWRITE(bp);
	}
	buf_setflags(bp, B_LOCKED);

	<span class="enscript-keyword">if</span> ((jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) &amp;&amp; (was_vm_privileged == FALSE))
		set_vm_privilege(FALSE);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_modify_block_abort</span>(journal *jnl, <span class="enscript-type">struct</span> buf *bp)
{
	transaction	*tr;
	block_list_header *blhdr;
	<span class="enscript-type">int</span>		i;
    
	CHECK_JOURNAL(jnl);

	free_old_stuff(jnl);

	tr = jnl-&gt;active_tr;
	
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if there's no active transaction then we just want to
</span>	<span class="enscript-comment">// call buf_brelse() and return since this is just a block
</span>	<span class="enscript-comment">// that happened to be modified as part of another tr.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (tr == NULL) {
		buf_brelse(bp);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_INVALID) {
    	<span class="enscript-comment">/* Still need to buf_brelse(). Callers assume we consume the bp. */</span>
    	buf_brelse(bp);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	CHECK_TRANSACTION(tr);
    
	<span class="enscript-keyword">if</span> (jnl-&gt;owner != current_thread()) {
		panic(<span class="enscript-string">&quot;jnl: modify_block_abort: called w/out a transaction! jnl %p, owner %p, curact %p\n&quot;</span>,
		      jnl, jnl-&gt;owner, current_thread());
	}

	<span class="enscript-comment">// printf(&quot;jnl: modify_block_abort: tr 0x%x bp 0x%x\n&quot;, jnl-&gt;active_tr, bp);
</span>
	<span class="enscript-comment">// first check if it's already part of this transaction
</span>	<span class="enscript-keyword">for</span> (blhdr = tr-&gt;blhdr; blhdr; blhdr = (block_list_header *)((<span class="enscript-type">long</span>)blhdr-&gt;binfo[0].bnum)) {
		<span class="enscript-keyword">for</span> (i = 1; i &lt; blhdr-&gt;num_blocks; i++) {
			<span class="enscript-keyword">if</span> (bp == blhdr-&gt;binfo[i].u.bp) {
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (i &lt; blhdr-&gt;num_blocks) {
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if blhdr is null, then this block has only had modify_block_start
</span>	<span class="enscript-comment">// called on it as part of the current transaction.  that means that
</span>	<span class="enscript-comment">// it is ok to clear the LOCKED bit since it hasn't actually been
</span>	<span class="enscript-comment">// modified.  if blhdr is non-null then modify_block_end was called
</span>	<span class="enscript-comment">// on it and so we need to keep it locked in memory.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (blhdr == NULL) { 
		buf_clearflags(bp, B_LOCKED);
	}

	buf_brelse(bp);
	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_modify_block_end</span>(journal *jnl, <span class="enscript-type">struct</span> buf *bp, <span class="enscript-type">void</span> (*func)(buf_t bp, <span class="enscript-type">void</span> *arg), <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">int</span>		i = 1;
	<span class="enscript-type">int</span>		tbuffer_offset=0;
	block_list_header *blhdr, *prev=NULL;
	transaction	*tr;

	CHECK_JOURNAL(jnl);

	free_old_stuff(jnl);

	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_INVALID) {
    	<span class="enscript-comment">/* Still need to buf_brelse(). Callers assume we consume the bp. */</span>
    	buf_brelse(bp);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	tr = jnl-&gt;active_tr;
	CHECK_TRANSACTION(tr);

	<span class="enscript-keyword">if</span> (jnl-&gt;owner != current_thread()) {
		panic(<span class="enscript-string">&quot;jnl: modify_block_end: called w/out a transaction! jnl %p, owner %p, curact %p\n&quot;</span>,
		      jnl, jnl-&gt;owner, current_thread());
	}

	<span class="enscript-comment">//printf(&quot;jnl: mod block end:  (bp 0x%x vp 0x%x l/blkno %qd/%qd bsz %d, total bytes %d)\n&quot;, 
</span>	<span class="enscript-comment">//   bp, buf_vnode(bp), buf_lblkno(bp), buf_blkno(bp), buf_size(bp), tr-&gt;total_bytes);
</span>
	<span class="enscript-keyword">if</span> ((buf_flags(bp) &amp; B_LOCKED) == 0) {
		panic(<span class="enscript-string">&quot;jnl: modify_block_end: bp %p not locked! jnl @ %p\n&quot;</span>, bp, jnl);
	}
	 
	<span class="enscript-comment">// first check if it's already part of this transaction
</span>	<span class="enscript-keyword">for</span> (blhdr = tr-&gt;blhdr; blhdr; prev = blhdr, blhdr = (block_list_header *)((<span class="enscript-type">long</span>)blhdr-&gt;binfo[0].bnum)) {
		tbuffer_offset = jnl-&gt;jhdr-&gt;blhdr_size;

		<span class="enscript-keyword">for</span> (i = 1; i &lt; blhdr-&gt;num_blocks; i++) {
			<span class="enscript-keyword">if</span> (bp == blhdr-&gt;binfo[i].u.bp) {
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (blhdr-&gt;binfo[i].bnum != (off_t)-1) {
				tbuffer_offset += buf_size(blhdr-&gt;binfo[i].u.bp);
			} <span class="enscript-keyword">else</span> {
				tbuffer_offset += blhdr-&gt;binfo[i].u.bi.bsize;
			}
		}

		<span class="enscript-keyword">if</span> (i &lt; blhdr-&gt;num_blocks) {
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (blhdr == NULL
	    &amp;&amp; prev
	    &amp;&amp; (prev-&gt;num_blocks+1) &lt;= prev-&gt;max_blocks
	    &amp;&amp; (prev-&gt;bytes_used+buf_size(bp)) &lt;= (uint32_t)tr-&gt;tbuffer_size) {
		blhdr = prev;

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (blhdr == NULL) {
		block_list_header *nblhdr;
		<span class="enscript-keyword">if</span> (prev == NULL) {
			panic(<span class="enscript-string">&quot;jnl: modify block end: no way man, prev == NULL?!?, jnl %p, bp %p\n&quot;</span>, jnl, bp);
		}

		<span class="enscript-comment">// we got to the end of the list, didn't find the block and there's
</span>		<span class="enscript-comment">// no room in the block_list_header pointed to by prev
</span>	
		<span class="enscript-comment">// we allocate another tbuffer and link it in at the end of the list
</span>		<span class="enscript-comment">// through prev-&gt;binfo[0].bnum.  that's a skanky way to do things but
</span>		<span class="enscript-comment">// avoids having yet another linked list of small data structures to manage.
</span>
		<span class="enscript-keyword">if</span> (kmem_alloc_kobject(kernel_map, (vm_offset_t *)&amp;nblhdr, tr-&gt;tbuffer_size, VM_KERN_MEMORY_FILE)) {
			panic(<span class="enscript-string">&quot;jnl: end_tr: no space for new block tr @ %p (total bytes: %d)!\n&quot;</span>,
			      tr, tr-&gt;total_bytes);
		}

		<span class="enscript-comment">// journal replay code checksum check depends on this.
</span>		memset(nblhdr, 0, BLHDR_CHECKSUM_SIZE);
		<span class="enscript-comment">// Fill up the rest of the block with unimportant bytes
</span>		memset(nblhdr + BLHDR_CHECKSUM_SIZE, 0x5a, jnl-&gt;jhdr-&gt;blhdr_size - BLHDR_CHECKSUM_SIZE);

		<span class="enscript-comment">// initialize the new guy
</span>		nblhdr-&gt;max_blocks = (jnl-&gt;jhdr-&gt;blhdr_size / <span class="enscript-keyword">sizeof</span>(block_info)) - 1;
		nblhdr-&gt;num_blocks = 1;      <span class="enscript-comment">// accounts for this header block
</span>		nblhdr-&gt;bytes_used = jnl-&gt;jhdr-&gt;blhdr_size;
		nblhdr-&gt;flags = BLHDR_CHECK_CHECKSUMS;
	    
		tr-&gt;num_blhdrs++;
		tr-&gt;total_bytes += jnl-&gt;jhdr-&gt;blhdr_size;

		<span class="enscript-comment">// then link him in at the end
</span>		prev-&gt;binfo[0].bnum = (off_t)((<span class="enscript-type">long</span>)nblhdr);

		<span class="enscript-comment">// and finally switch to using the new guy
</span>		blhdr          = nblhdr;
		tbuffer_offset = jnl-&gt;jhdr-&gt;blhdr_size;
		i              = 1;
	}


	<span class="enscript-keyword">if</span> ((i+1) &gt; blhdr-&gt;max_blocks) {
		panic(<span class="enscript-string">&quot;jnl: modify_block_end: i = %d, max_blocks %d\n&quot;</span>, i, blhdr-&gt;max_blocks);
	}

	<span class="enscript-comment">// if this is true then this is a new block we haven't seen
</span>	<span class="enscript-keyword">if</span> (i &gt;= blhdr-&gt;num_blocks) {
                <span class="enscript-type">int</span>	bsize;
		vnode_t	vp;

		vp = buf_vnode(bp);
		<span class="enscript-keyword">if</span> (vnode_ref(vp)) {
			<span class="enscript-comment">// Nobody checks the return values, so...
</span>			jnl-&gt;flags |= JOURNAL_INVALID;

			buf_brelse(bp);

			<span class="enscript-comment">// We're probably here due to a force unmount, so EIO is appropriate
</span>			<span class="enscript-keyword">return</span> EIO;
		}

		bsize = buf_size(bp);

		blhdr-&gt;binfo[i].bnum = (off_t)(buf_blkno(bp));
		blhdr-&gt;binfo[i].u.bp = bp;

		KERNEL_DEBUG_CONSTANT(0x3018004, VM_KERNEL_ADDRPERM(vp), blhdr-&gt;binfo[i].bnum, bsize, 0, 0);

		<span class="enscript-keyword">if</span> (func) {
			<span class="enscript-type">void</span> (*old_func)(buf_t, <span class="enscript-type">void</span> *)=NULL, *old_arg=NULL;
			
			buf_setfilter(bp, func, arg, &amp;old_func, &amp;old_arg);
			<span class="enscript-keyword">if</span> (old_func != NULL &amp;&amp; old_func != func) {
			    panic(<span class="enscript-string">&quot;jnl: modify_block_end: old func %p / arg %p (func %p)&quot;</span>, old_func, old_arg, func);
			}
		}
		
		blhdr-&gt;bytes_used += bsize;
		tr-&gt;total_bytes   += bsize;

		blhdr-&gt;num_blocks++;
	}
	buf_bdwrite(bp);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_kill_block</span>(journal *jnl, <span class="enscript-type">struct</span> buf *bp)
{
	<span class="enscript-type">int</span>		i;
	<span class="enscript-type">int</span>		bflags;
	block_list_header *blhdr;
	transaction	*tr;

	CHECK_JOURNAL(jnl);

	free_old_stuff(jnl);

	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_INVALID) {
		buf_brelse(bp);
		<span class="enscript-keyword">return</span> 0;
	}

	tr = jnl-&gt;active_tr;
	CHECK_TRANSACTION(tr);

	<span class="enscript-keyword">if</span> (jnl-&gt;owner != current_thread()) {
		panic(<span class="enscript-string">&quot;jnl: modify_block_end: called w/out a transaction! jnl %p, owner %p, curact %p\n&quot;</span>,
		      jnl, jnl-&gt;owner, current_thread());
	}

	bflags = buf_flags(bp);

	<span class="enscript-keyword">if</span> ( !(bflags &amp; B_LOCKED))
		panic(<span class="enscript-string">&quot;jnl: modify_block_end: called with bp not B_LOCKED&quot;</span>);

	<span class="enscript-comment">/*
	 * bp must be BL_BUSY and B_LOCKED
	 * first check if it's already part of this transaction
	 */</span>
	<span class="enscript-keyword">for</span> (blhdr = tr-&gt;blhdr; blhdr; blhdr = (block_list_header *)((<span class="enscript-type">long</span>)blhdr-&gt;binfo[0].bnum)) {

		<span class="enscript-keyword">for</span> (i = 1; i &lt; blhdr-&gt;num_blocks; i++) {
			<span class="enscript-keyword">if</span> (bp == blhdr-&gt;binfo[i].u.bp) {
			        vnode_t vp;

				buf_clearflags(bp, B_LOCKED);

				<span class="enscript-comment">// this undoes the vnode_ref() in journal_modify_block_end()
</span>				vp = buf_vnode(bp);
				vnode_rele_ext(vp, 0, 1);

				<span class="enscript-comment">// if the block has the DELWRI and FILTER bits sets, then
</span>				<span class="enscript-comment">// things are seriously weird.  if it was part of another
</span>				<span class="enscript-comment">// transaction then journal_modify_block_start() should
</span>				<span class="enscript-comment">// have force it to be written.
</span>				<span class="enscript-comment">//
</span>				<span class="enscript-comment">//if ((bflags &amp; B_DELWRI) &amp;&amp; (bflags &amp; B_FILTER)) {
</span>				<span class="enscript-comment">//	panic(&quot;jnl: kill block: this defies all logic! bp 0x%x\n&quot;, bp);
</span>				<span class="enscript-comment">//} else {
</span>					tr-&gt;num_killed += buf_size(bp);
				<span class="enscript-comment">//}
</span>				blhdr-&gt;binfo[i].bnum = (off_t)-1;
				blhdr-&gt;binfo[i].u.bp = NULL;
				blhdr-&gt;binfo[i].u.bi.bsize = buf_size(bp);

				buf_markinvalid(bp);
				buf_brelse(bp);

				<span class="enscript-keyword">return</span> 0;
			}
		}
	}

	<span class="enscript-comment">/*
	 * We did not find the block in any transaction buffer but we still
	 * need to release it or else it will be left locked forever.
	 */</span>
	buf_brelse(bp);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
;________________________________________________________________________________
;
; Routine:		journal_trim_set_callback
;
; Function:		Provide the journal with a routine to be called back when a
;				TRIM has (or would have) been issued to the device.  That
;				is, the transaction has been flushed to the device, and the
;				blocks freed by the transaction are now safe for reuse.
;
;				CAUTION: If the journal becomes invalid (eg., due to an I/O
;				error when trying to write to the journal), this callback
;				will stop getting called, even if extents got freed before
;				the journal became invalid!
;
; Input Arguments:
;	jnl			- The journal structure for the filesystem.
;	callback	- The function to call when the TRIM is complete.
;	arg			- An argument to be passed to callback.
;________________________________________________________________________________
*/</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">journal_trim_set_callback</span>(journal *jnl, jnl_trim_callback_t callback, <span class="enscript-type">void</span> *arg)
{
	jnl-&gt;trim_callback = callback;
	jnl-&gt;trim_callback_arg = arg;
}


<span class="enscript-comment">/*
;________________________________________________________________________________
;
; Routine:		journal_trim_realloc
;
; Function:		Increase the amount of memory allocated for the list of extents
;				to be unmapped (trimmed).  This routine will be called when
;				adding an extent to the list, and the list already occupies
;				all of the space allocated to it.  This routine returns ENOMEM
;				if unable to allocate more space, or 0 if the extent list was
;				grown successfully.
;
; Input Arguments:
;	trim		- The trim list to be resized.
;
; Output:
;	(result)	- ENOMEM or 0.
;
; Side effects:
;	 The allocated_count and extents fields of tr-&gt;trim are updated
;	 if the function returned 0.
;________________________________________________________________________________
*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">trim_realloc</span>(journal *jnl, <span class="enscript-type">struct</span> jnl_trim_list *trim)
{
	<span class="enscript-type">void</span> *new_extents;
	uint32_t new_allocated_count;
	boolean_t was_vm_privileged = FALSE;
	
	<span class="enscript-keyword">if</span> (jnl_kdebug)
		KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_REALLOC | DBG_FUNC_START, VM_KERNEL_ADDRPERM(trim), 0, trim-&gt;allocated_count, trim-&gt;extent_count, 0);
	
	new_allocated_count = trim-&gt;allocated_count + JOURNAL_DEFAULT_TRIM_EXTENTS;

	<span class="enscript-keyword">if</span> (jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) {
		<span class="enscript-comment">/*
		 * if we block waiting for memory, and there is enough pressure to
		 * cause us to try and create a new swap file, we may end up deadlocking
		 * due to waiting for the journal on the swap file creation path...
		 * by making ourselves vm_privileged, we give ourselves the best chance
		 * of not blocking
		 */</span>
		was_vm_privileged = set_vm_privilege(TRUE);
	}
	new_extents = kalloc(new_allocated_count * <span class="enscript-keyword">sizeof</span>(dk_extent_t));
	<span class="enscript-keyword">if</span> ((jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) &amp;&amp; (was_vm_privileged == FALSE))
		set_vm_privilege(FALSE);

	<span class="enscript-keyword">if</span> (new_extents == NULL) {
		printf(<span class="enscript-string">&quot;jnl: trim_realloc: unable to grow extent list!\n&quot;</span>);
		<span class="enscript-comment">/*
		 * Since we could be called when allocating space previously marked
		 * to be trimmed, we need to empty out the list to be safe.
		 */</span>
		trim-&gt;extent_count = 0;
		<span class="enscript-keyword">if</span> (jnl_kdebug)
			KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_REALLOC | DBG_FUNC_END, ENOMEM, 0, trim-&gt;allocated_count, 0, 0);
		<span class="enscript-keyword">return</span> ENOMEM;
	}
	
	<span class="enscript-comment">/* Copy the old extent list to the newly allocated list. */</span>
	<span class="enscript-keyword">if</span> (trim-&gt;extents != NULL) {
		memmove(new_extents,
				trim-&gt;extents,
				trim-&gt;allocated_count * <span class="enscript-keyword">sizeof</span>(dk_extent_t));
		kfree(trim-&gt;extents,
			  trim-&gt;allocated_count * <span class="enscript-keyword">sizeof</span>(dk_extent_t));
	}
	
	trim-&gt;allocated_count = new_allocated_count;
	trim-&gt;extents = new_extents;

	<span class="enscript-keyword">if</span> (jnl_kdebug)
		KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_REALLOC | DBG_FUNC_END, 0, 0, new_allocated_count, trim-&gt;extent_count, 0);
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 ;________________________________________________________________________________
 ;
 ; Routine:		trim_search_extent
 ;
 ; Function:		Search the given extent list to see if any of its extents
 ;				overlap the given extent.
 ;
 ; Input Arguments:
 ;	trim		- The trim list to be searched.
 ;	offset		- The first byte of the range to be searched for.
 ;	length		- The number of bytes of the extent being searched for.
 ;  overlap_start - start of the overlapping extent
 ;  overlap_len   - length of the overlapping extent
 ;
 ; Output:
 ;	(result)	- TRUE if one or more extents overlap, FALSE otherwise.
 ;________________________________________________________________________________
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">trim_search_extent</span>(<span class="enscript-type">struct</span> jnl_trim_list *trim, uint64_t offset,
		uint64_t length, uint64_t *overlap_start, uint64_t *overlap_len)
{
	uint64_t end = offset + length;
	uint32_t lower = 0;						<span class="enscript-comment">/* Lowest index to search */</span>
	uint32_t upper = trim-&gt;extent_count;	<span class="enscript-comment">/* Highest index to search + 1 */</span>
	uint32_t middle;

	<span class="enscript-comment">/* A binary search over the extent list. */</span>
	<span class="enscript-keyword">while</span> (lower &lt; upper) {
		middle = (lower + upper) / 2;

		<span class="enscript-keyword">if</span> (trim-&gt;extents[middle].offset &gt;= end)
			upper = middle;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (trim-&gt;extents[middle].offset + trim-&gt;extents[middle].length &lt;= offset)
			lower = middle + 1;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (overlap_start) {
				*overlap_start = trim-&gt;extents[middle].offset;
			}
			<span class="enscript-keyword">if</span> (overlap_len) {
				*overlap_len = trim-&gt;extents[middle].length;
			}
			<span class="enscript-keyword">return</span> TRUE;
		}
	}

	<span class="enscript-keyword">return</span> FALSE;
}


<span class="enscript-comment">/*
;________________________________________________________________________________
;
; Routine:		journal_trim_add_extent
;
; Function:		Keep track of extents that have been freed as part of this
;				transaction.  If the underlying device supports TRIM (UNMAP),
;				then those extents will be trimmed/unmapped once the
;				transaction has been written to the journal.  (For example,
;				SSDs can support trim/unmap and avoid having to recopy those
;				blocks when doing wear leveling, and may reuse the same
;				phsyical blocks for different logical blocks.)
;
;				HFS also uses this, in combination with journal_trim_set_callback,
;				to add recently freed extents to its free extent cache, but
;				only after the transaction that freed them is committed to
;				disk.  (This reduces the chance of overwriting live data in
;				a way that causes data loss if a transaction never gets
;				written to the journal.)
;
; Input Arguments:
;	jnl			- The journal for the volume containing the byte range.
;	offset		- The first byte of the range to be trimmed.
;	length		- The number of bytes of the extent being trimmed.
;________________________________________________________________________________
*/</span>
__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">journal_trim_add_extent</span>(journal *jnl, uint64_t offset, uint64_t length)
{
	uint64_t end;
	transaction *tr;
	dk_extent_t *extent;
	uint32_t insert_index;
	uint32_t replace_count;
		
	CHECK_JOURNAL(jnl);

	<span class="enscript-comment">/* TODO: Is it OK to manipulate the trim list even if JOURNAL_INVALID is set?  I think so... */</span>
	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_INVALID) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	tr = jnl-&gt;active_tr;
	CHECK_TRANSACTION(tr);

	<span class="enscript-keyword">if</span> (jnl_kdebug)
		KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_ADD | DBG_FUNC_START, VM_KERNEL_ADDRPERM(jnl), offset, length, tr-&gt;trim.extent_count, 0);

	<span class="enscript-keyword">if</span> (jnl-&gt;owner != current_thread()) {
		panic(<span class="enscript-string">&quot;jnl: trim_add_extent: called w/out a transaction! jnl %p, owner %p, curact %p\n&quot;</span>,
			  jnl, jnl-&gt;owner, current_thread());
	}

	free_old_stuff(jnl);
		
	end = offset + length;
		
	<span class="enscript-comment">/*
	 * Find the range of existing extents that can be combined with the
	 * input extent.  We start by counting the number of extents that end
	 * strictly before the input extent, then count the number of extents
	 * that overlap or are contiguous with the input extent.
	 */</span>
	extent = tr-&gt;trim.extents;
	insert_index = 0;
	<span class="enscript-keyword">while</span> (insert_index &lt; tr-&gt;trim.extent_count &amp;&amp; extent-&gt;offset + extent-&gt;length &lt; offset) {
		++insert_index;
		++extent;
	}
	replace_count = 0;
	<span class="enscript-keyword">while</span> (insert_index + replace_count &lt; tr-&gt;trim.extent_count &amp;&amp; extent-&gt;offset &lt;= end) {
		++replace_count;
		++extent;
	}
		
	<span class="enscript-comment">/*
	 * If none of the existing extents can be combined with the input extent,
	 * then just insert it in the list (before item number insert_index).
	 */</span>
	<span class="enscript-keyword">if</span> (replace_count == 0) {
		<span class="enscript-comment">/* If the list was already full, we need to grow it. */</span>
		<span class="enscript-keyword">if</span> (tr-&gt;trim.extent_count == tr-&gt;trim.allocated_count) {
			<span class="enscript-keyword">if</span> (trim_realloc(jnl, &amp;tr-&gt;trim) != 0) {
				printf(<span class="enscript-string">&quot;jnl: trim_add_extent: out of memory!&quot;</span>);
				<span class="enscript-keyword">if</span> (jnl_kdebug)
					KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_ADD | DBG_FUNC_END, ENOMEM, 0, 0, tr-&gt;trim.extent_count, 0);
				<span class="enscript-keyword">return</span> ENOMEM;
			}
		}
		
		<span class="enscript-comment">/* Shift any existing extents with larger offsets. */</span>
		<span class="enscript-keyword">if</span> (insert_index &lt; tr-&gt;trim.extent_count) {
			memmove(&amp;tr-&gt;trim.extents[insert_index+1],
					&amp;tr-&gt;trim.extents[insert_index],
					(tr-&gt;trim.extent_count - insert_index) * <span class="enscript-keyword">sizeof</span>(dk_extent_t));
		}
		tr-&gt;trim.extent_count++;
		
		<span class="enscript-comment">/* Store the new extent in the list. */</span>
		tr-&gt;trim.extents[insert_index].offset = offset;
		tr-&gt;trim.extents[insert_index].length = length;
		
		<span class="enscript-comment">/* We're done. */</span>
		<span class="enscript-keyword">if</span> (jnl_kdebug)
			KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_ADD | DBG_FUNC_END, 0, 0, 0, tr-&gt;trim.extent_count, 0);
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-comment">/*
	 * Update extent number insert_index to be the union of the input extent
	 * and all of the replaced extents.
	 */</span>
	<span class="enscript-keyword">if</span> (tr-&gt;trim.extents[insert_index].offset &lt; offset)
		offset = tr-&gt;trim.extents[insert_index].offset;
	extent = &amp;tr-&gt;trim.extents[insert_index + replace_count - 1];
	<span class="enscript-keyword">if</span> (extent-&gt;offset + extent-&gt;length &gt; end)
		end = extent-&gt;offset + extent-&gt;length;
	tr-&gt;trim.extents[insert_index].offset = offset;
	tr-&gt;trim.extents[insert_index].length = end - offset;
	
	<span class="enscript-comment">/*
	 * If we were replacing more than one existing extent, then shift any
	 * extents with larger offsets, and update the count of extents.
	 *
	 * We're going to leave extent #insert_index alone since it was just updated, above.
	 * We need to move extents from index (insert_index + replace_count) through the end of
	 * the list by (replace_count - 1) positions so that they overwrite extent #(insert_index + 1).
	 */</span>
	<span class="enscript-keyword">if</span> (replace_count &gt; 1 &amp;&amp; (insert_index + replace_count) &lt; tr-&gt;trim.extent_count) {
		memmove(&amp;tr-&gt;trim.extents[insert_index + 1],
				&amp;tr-&gt;trim.extents[insert_index + replace_count],
				(tr-&gt;trim.extent_count - insert_index - replace_count) * <span class="enscript-keyword">sizeof</span>(dk_extent_t));
	}
	tr-&gt;trim.extent_count -= replace_count - 1;

	<span class="enscript-keyword">if</span> (jnl_kdebug)
		KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_ADD | DBG_FUNC_END, 0, 0, 0, tr-&gt;trim.extent_count, 0);
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * journal_trim_extent_overlap
 *
 * Return 1 if there are any pending TRIMs that overlap with the given offset and length
 * Return 0 otherwise.
 */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">journal_trim_extent_overlap</span> (journal *jnl, uint64_t offset, uint64_t length, uint64_t *end) {
	transaction *tr = NULL;
	<span class="enscript-type">int</span> overlap = 0;

	uint64_t overlap_start;
	uint64_t overlap_len;
	tr = jnl-&gt;active_tr;
	CHECK_TRANSACTION(tr);

	<span class="enscript-comment">/*
	 * There are two lists that need to be examined for potential overlaps:
	 *
	 * The first is the current transaction. Since this function requires that
	 * a transaction be active when this is called, this is the &quot;active_tr&quot;
	 * pointer in the journal struct.  This has a trimlist pointer which needs
	 * to be searched.
	 */</span>
	overlap = trim_search_extent (&amp;tr-&gt;trim, offset, length, &amp;overlap_start, &amp;overlap_len);
	<span class="enscript-keyword">if</span> (overlap == 0) {
		<span class="enscript-comment">/*
		 * The second is the async trim list, which is only done if the current
		 * transaction group (active transaction) did not overlap with our target
		 * extent. This async trim list is the set of all previously
		 * committed transaction groups whose I/Os are now in-flight. We need to hold the
		 * trim lock in order to search this list.  If we grab the list before the
		 * TRIM has completed, then we will compare it. If it is grabbed AFTER the
		 * TRIM has completed, then the pointer will be zeroed out and we won't have
		 * to check anything.
		 */</span>
		lck_rw_lock_shared (&amp;jnl-&gt;trim_lock);
		<span class="enscript-keyword">if</span> (jnl-&gt;async_trim != NULL) {
			overlap = trim_search_extent(jnl-&gt;async_trim, offset, length, &amp;overlap_start, &amp;overlap_len);
		}
		lck_rw_unlock_shared (&amp;jnl-&gt;trim_lock);
	}

	<span class="enscript-keyword">if</span> (overlap) {
		<span class="enscript-comment">/* compute the end (min) of the overlapping range */</span>
		<span class="enscript-keyword">if</span> ( (overlap_start + overlap_len) &lt; (offset + length)) {
			*end = (overlap_start + overlap_len);
		}
		<span class="enscript-keyword">else</span> {
			*end = (offset + length);
		}
	}


	<span class="enscript-keyword">return</span> overlap;
}

<span class="enscript-comment">/*
 * journal_request_immediate_flush
 *
 * FS requests that the journal flush immediately upon the
 * active transaction's completion.
 *
 * Returns 0 if operation succeeds
 * Returns EPERM if we failed to leave hint
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_request_immediate_flush</span> (journal *jnl) {

	transaction *tr = NULL;
	<span class="enscript-comment">/*
	 * Is a transaction still in process? You must do
	 * this while there are txns open
	 */</span>
	tr = jnl-&gt;active_tr;
	<span class="enscript-keyword">if</span> (tr != NULL) {
		CHECK_TRANSACTION(tr);
		tr-&gt;flush_on_completion = TRUE;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> EPERM;
	}
	<span class="enscript-keyword">return</span> 0;
}



<span class="enscript-comment">/*
;________________________________________________________________________________
;
; Routine:		trim_remove_extent
;
; Function:		Indicate that a range of bytes, some of which may have previously
;				been passed to journal_trim_add_extent, is now allocated.
;				Any overlapping ranges currently in the journal's trim list will
;				be removed.  If the underlying device supports TRIM (UNMAP), then
;				these extents will not be trimmed/unmapped when the transaction
;				is written to the journal.
;
;				HFS also uses this to prevent newly allocated space from being
;				added to its free extent cache (if some portion of the newly
;				allocated space was recently freed).
;
; Input Arguments:
;	trim		- The trim list to update.
;	offset		- The first byte of the range to be trimmed.
;	length		- The number of bytes of the extent being trimmed.
;________________________________________________________________________________
*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">trim_remove_extent</span>(journal *jnl, <span class="enscript-type">struct</span> jnl_trim_list *trim, uint64_t offset, uint64_t length)
{
	u_int64_t end;
	dk_extent_t *extent;
	u_int32_t keep_before;
	u_int32_t keep_after;
	
	end = offset + length;
	
	<span class="enscript-comment">/*
	 * Find any existing extents that start before or end after the input
	 * extent.  These extents will be modified if they overlap the input
	 * extent.  Other extents between them will be deleted.
	 */</span>
	extent = trim-&gt;extents;
	keep_before = 0;
	<span class="enscript-keyword">while</span> (keep_before &lt; trim-&gt;extent_count &amp;&amp; extent-&gt;offset &lt; offset) {
		++keep_before;
		++extent;
	}
	keep_after = keep_before;
	<span class="enscript-keyword">if</span> (keep_after &gt; 0) {
		<span class="enscript-comment">/* See if previous extent extends beyond both ends of input extent. */</span>
		--keep_after;
		--extent;
	}
	<span class="enscript-keyword">while</span> (keep_after &lt; trim-&gt;extent_count &amp;&amp; (extent-&gt;offset + extent-&gt;length) &lt;= end) {
		++keep_after;
		++extent;
	}
	
	<span class="enscript-comment">/*
	 * When we get here, the first keep_before extents (0 .. keep_before-1)
	 * start before the input extent, and extents (keep_after .. extent_count-1)
	 * end after the input extent.  We'll need to keep, all of those extents,
	 * but possibly modify #(keep_before-1) and #keep_after to remove the portion
	 * that overlaps with the input extent.
	 */</span>
	
	<span class="enscript-comment">/*
	 * Does the input extent start after and end before the same existing
	 * extent?  If so, we have to &quot;punch a hole&quot; in that extent and convert
	 * it to two separate extents.
	 */</span>
	<span class="enscript-keyword">if</span> (keep_before &gt;  keep_after) {
		<span class="enscript-comment">/* If the list was already full, we need to grow it. */</span>
		<span class="enscript-keyword">if</span> (trim-&gt;extent_count == trim-&gt;allocated_count) {
			<span class="enscript-keyword">if</span> (trim_realloc(jnl, trim) != 0) {
				printf(<span class="enscript-string">&quot;jnl: trim_remove_extent: out of memory!&quot;</span>);
				<span class="enscript-keyword">return</span> ENOMEM;
			}
		}
		
		<span class="enscript-comment">/*
		 * Make room for a new extent by shifting extents #keep_after and later
		 * down by one extent.  When we're done, extents #keep_before and
		 * #keep_after will be identical, and we can fall through to removing
		 * the portion that overlaps the input extent.
		 */</span>
		memmove(&amp;trim-&gt;extents[keep_before],
				&amp;trim-&gt;extents[keep_after],
				(trim-&gt;extent_count - keep_after) * <span class="enscript-keyword">sizeof</span>(dk_extent_t));
		++trim-&gt;extent_count;
		++keep_after;
		
		<span class="enscript-comment">/*
		 * Fall through.  We now have the case where the length of extent
		 * #(keep_before - 1) needs to be updated, and the start of extent
		 * #(keep_after) needs to be updated.
		 */</span>
	}
	
	<span class="enscript-comment">/*
	 * May need to truncate the end of extent #(keep_before - 1) if it overlaps
	 * the input extent.
	 */</span>
	<span class="enscript-keyword">if</span> (keep_before &gt; 0) {
		extent = &amp;trim-&gt;extents[keep_before - 1];
		<span class="enscript-keyword">if</span> (extent-&gt;offset + extent-&gt;length &gt; offset) {
			extent-&gt;length = offset - extent-&gt;offset;
		}
	}
	
	<span class="enscript-comment">/*
	 * May need to update the start of extent #(keep_after) if it overlaps the
	 * input extent.
	 */</span>
	<span class="enscript-keyword">if</span> (keep_after &lt; trim-&gt;extent_count) {
		extent = &amp;trim-&gt;extents[keep_after];
		<span class="enscript-keyword">if</span> (extent-&gt;offset &lt; end) {
			extent-&gt;length = extent-&gt;offset + extent-&gt;length - end;
			extent-&gt;offset = end;
		}
	}
	
	<span class="enscript-comment">/*
	 * If there were whole extents that overlapped the input extent, get rid
	 * of them by shifting any following extents, and updating the count.
	 */</span>
	<span class="enscript-keyword">if</span> (keep_after &gt; keep_before &amp;&amp; keep_after &lt; trim-&gt;extent_count) {
		memmove(&amp;trim-&gt;extents[keep_before],
				&amp;trim-&gt;extents[keep_after],
				(trim-&gt;extent_count - keep_after) * <span class="enscript-keyword">sizeof</span>(dk_extent_t));
	}
	trim-&gt;extent_count -= keep_after - keep_before;

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 ;________________________________________________________________________________
 ;
 ; Routine:		journal_trim_remove_extent
 ;
 ; Function:		Make note of a range of bytes, some of which may have previously
 ;				been passed to journal_trim_add_extent, is now in use on the
 ;				volume.  The given bytes will be not be trimmed as part of
 ;				this transaction, or a pending trim of a transaction being
 ;				asynchronously flushed.
 ;
 ; Input Arguments:
 ;	jnl			- The journal for the volume containing the byte range.
 ;	offset		- The first byte of the range to be trimmed.
 ;	length		- The number of bytes of the extent being trimmed.
 ;________________________________________________________________________________
 */</span>
__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">journal_trim_remove_extent</span>(journal *jnl, uint64_t offset, uint64_t length)
{
	<span class="enscript-type">int</span> error = 0;
	transaction *tr;
	
	CHECK_JOURNAL(jnl);

	<span class="enscript-comment">/* TODO: Is it OK to manipulate the trim list even if JOURNAL_INVALID is set?  I think so... */</span>
	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_INVALID) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	tr = jnl-&gt;active_tr;
	CHECK_TRANSACTION(tr);

	<span class="enscript-keyword">if</span> (jnl_kdebug)
		KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_REMOVE | DBG_FUNC_START, VM_KERNEL_ADDRPERM(jnl), offset, length, tr-&gt;trim.extent_count, 0);

	<span class="enscript-keyword">if</span> (jnl-&gt;owner != current_thread()) {
		panic(<span class="enscript-string">&quot;jnl: trim_remove_extent: called w/out a transaction! jnl %p, owner %p, curact %p\n&quot;</span>,
			  jnl, jnl-&gt;owner, current_thread());
	}

	free_old_stuff(jnl);
		
	error = trim_remove_extent(jnl, &amp;tr-&gt;trim, offset, length);
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-type">int</span> found = FALSE;
		
		<span class="enscript-comment">/*
		 * See if a pending trim has any extents that overlap with the
		 * one we were given.
		 */</span>
		lck_rw_lock_shared(&amp;jnl-&gt;trim_lock);
		<span class="enscript-keyword">if</span> (jnl-&gt;async_trim != NULL)
			found = trim_search_extent(jnl-&gt;async_trim, offset, length, NULL, NULL);
		lck_rw_unlock_shared(&amp;jnl-&gt;trim_lock);
		
		<span class="enscript-keyword">if</span> (found) {
			<span class="enscript-comment">/*
			 * There was an overlap, so avoid trimming the extent we
			 * just allocated.  (Otherwise, it might get trimmed after
			 * we've written to it, which will cause that data to be
			 * corrupted.)
			 */</span>
			uint32_t async_extent_count = 0;
			
			<span class="enscript-keyword">if</span> (jnl_kdebug)
				KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_REMOVE_PENDING | DBG_FUNC_START, VM_KERNEL_ADDRPERM(jnl), offset, length, 0, 0);
			lck_rw_lock_exclusive(&amp;jnl-&gt;trim_lock);
			<span class="enscript-keyword">if</span> (jnl-&gt;async_trim != NULL) {
				error = trim_remove_extent(jnl, jnl-&gt;async_trim, offset, length);
				async_extent_count = jnl-&gt;async_trim-&gt;extent_count;
			}
			lck_rw_unlock_exclusive(&amp;jnl-&gt;trim_lock);
			<span class="enscript-keyword">if</span> (jnl_kdebug)
				KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_REMOVE_PENDING | DBG_FUNC_END, error, 0, 0, async_extent_count, 0);
		}
	}

	<span class="enscript-keyword">if</span> (jnl_kdebug)
		KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_REMOVE | DBG_FUNC_END, error, 0, 0, tr-&gt;trim.extent_count, 0);
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">journal_trim_flush</span>(journal *jnl, transaction *tr)
{
	<span class="enscript-type">int</span> errno = 0;
	boolean_t was_vm_privileged = FALSE;
	
	<span class="enscript-keyword">if</span> (jnl_kdebug)
		KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_FLUSH | DBG_FUNC_START, VM_KERNEL_ADDRPERM(jnl), tr, 0, tr-&gt;trim.extent_count, 0);

	<span class="enscript-keyword">if</span> (jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) {
		<span class="enscript-comment">/*
		 * the disk driver can allocate memory on this path...
		 * if we block waiting for memory, and there is enough pressure to
		 * cause us to try and create a new swap file, we may end up deadlocking
		 * due to waiting for the journal on the swap file creation path...
		 * by making ourselves vm_privileged, we give ourselves the best chance
		 * of not blocking
		 */</span>
		was_vm_privileged = set_vm_privilege(TRUE);
	}
	lck_rw_lock_shared(&amp;jnl-&gt;trim_lock);
	<span class="enscript-keyword">if</span> (tr-&gt;trim.extent_count &gt; 0) {
		dk_unmap_t unmap;
				
		bzero(&amp;unmap, <span class="enscript-keyword">sizeof</span>(unmap));
		<span class="enscript-keyword">if</span> (CONFIG_HFS_TRIM &amp;&amp; (jnl-&gt;flags &amp; JOURNAL_USE_UNMAP)) {
			unmap.extents = tr-&gt;trim.extents;
			unmap.extentsCount = tr-&gt;trim.extent_count;
			<span class="enscript-keyword">if</span> (jnl_kdebug)
				KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_UNMAP | DBG_FUNC_START, VM_KERNEL_ADDRPERM(jnl), tr, 0, tr-&gt;trim.extent_count, 0);
			errno = VNOP_IOCTL(jnl-&gt;fsdev, DKIOCUNMAP, (caddr_t)&amp;unmap, FWRITE, vfs_context_kernel());
			<span class="enscript-keyword">if</span> (jnl_kdebug)
				KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_UNMAP | DBG_FUNC_END, errno, 0, 0, 0, 0);
		}
		
		<span class="enscript-comment">/*
		 * Call back into the file system to tell them that we have
		 * trimmed some extents and that they can now be reused.
		 *
		 * CAUTION: If the journal becomes invalid (eg., due to an I/O
		 * error when trying to write to the journal), this callback
		 * will stop getting called, even if extents got freed before
		 * the journal became invalid!
		 */</span>
		<span class="enscript-keyword">if</span> (jnl-&gt;trim_callback)
			jnl-&gt;trim_callback(jnl-&gt;trim_callback_arg, tr-&gt;trim.extent_count, tr-&gt;trim.extents);
	}
	lck_rw_unlock_shared(&amp;jnl-&gt;trim_lock);

	<span class="enscript-keyword">if</span> ((jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) &amp;&amp; (was_vm_privileged == FALSE))
		set_vm_privilege(FALSE);
	<span class="enscript-comment">/*
	 * If the transaction we're flushing was the async transaction, then
	 * tell the current transaction that there is no pending trim
	 * any more.
	 *
	 * NOTE: Since we released the lock, another thread could have
	 * removed one or more extents from our list.  That's not a
	 * problem since any writes to the re-allocated blocks
	 * would get sent to the device after the DKIOCUNMAP.
	 */</span>
	lck_rw_lock_exclusive(&amp;jnl-&gt;trim_lock);
	<span class="enscript-keyword">if</span> (jnl-&gt;async_trim == &amp;tr-&gt;trim)
		jnl-&gt;async_trim = NULL;
	lck_rw_unlock_exclusive(&amp;jnl-&gt;trim_lock);

	<span class="enscript-comment">/*
	 * By the time we get here, no other thread can discover the address
	 * of &quot;tr&quot;, so it is safe for us to manipulate tr-&gt;trim without
	 * holding any locks.
	 */</span>
	<span class="enscript-keyword">if</span> (tr-&gt;trim.extents) {			
		kfree(tr-&gt;trim.extents, tr-&gt;trim.allocated_count * <span class="enscript-keyword">sizeof</span>(dk_extent_t));
		tr-&gt;trim.allocated_count = 0;
		tr-&gt;trim.extent_count = 0;
		tr-&gt;trim.extents = NULL;
	}
	
	<span class="enscript-keyword">if</span> (jnl_kdebug)
		KERNEL_DEBUG_CONSTANT(DBG_JOURNAL_TRIM_FLUSH | DBG_FUNC_END, errno, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span> errno;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">journal_binfo_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *b)
{
	<span class="enscript-type">const</span> block_info *bi_a = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> block_info *)a;
	<span class="enscript-type">const</span> block_info *bi_b = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> block_info *)b;
	daddr64_t res;

	<span class="enscript-keyword">if</span> (bi_a-&gt;bnum == (off_t)-1) {
		<span class="enscript-keyword">return</span> 1;
	}
	<span class="enscript-keyword">if</span> (bi_b-&gt;bnum == (off_t)-1) {
		<span class="enscript-keyword">return</span> -1;
	}

	<span class="enscript-comment">// don't have to worry about negative block
</span>	<span class="enscript-comment">// numbers so this is ok to do.
</span>	<span class="enscript-comment">//
</span>	res = (buf_blkno(bi_a-&gt;u.bp) - buf_blkno(bi_b-&gt;u.bp));

	<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)res;
}


<span class="enscript-comment">/*
 * End a transaction.  If the transaction is small enough, and we're not forcing
 * a write to disk, the &quot;active&quot; transaction becomes the &quot;current&quot; transaction,
 * and will be reused for the next transaction that is started (group commit).
 *
 * If the transaction gets written to disk (because force_it is true, or no
 * group commit, or the transaction is sufficiently full), the blocks get
 * written into the journal first, then the are written asynchronously.  When
 * those async writes complete, the transaction can be freed and removed from
 * the journal.
 *
 * An optional callback can be supplied.  If given, it is called after the
 * the blocks have been written to the journal, but before the async writes
 * of those blocks to their normal on-disk locations.  This is used by
 * journal_relocate so that the location of the journal can be changed and
 * flushed to disk before the blocks get written to their normal locations.
 * Note that the callback is only called if the transaction gets written to
 * the journal during this end_transaction call; you probably want to set the
 * force_it flag.
 *
 * Inputs:
 *	tr			 Transaction to add to the journal
 *	force_it	 If true, force this transaction to the on-disk journal immediately.
 *	callback	 See description above.  Pass NULL for no callback.
 *	callback_arg Argument passed to callback routine.
 *
 * Result
 *		 0		No errors
 *		-1		An error occurred.  The journal is marked invalid.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">end_transaction</span>(transaction *tr, <span class="enscript-type">int</span> force_it, errno_t (*callback)(<span class="enscript-type">void</span>*), <span class="enscript-type">void</span> *callback_arg, boolean_t drop_lock, boolean_t must_wait)
{
	block_list_header  *blhdr=NULL, *next=NULL;
	<span class="enscript-type">int</span>		i, ret_val = 0;
	errno_t		errno;
	journal		*jnl = tr-&gt;jnl;
	<span class="enscript-type">struct</span> buf	*bp;
	size_t		tbuffer_offset;
	boolean_t	drop_lock_early;

	<span class="enscript-keyword">if</span> (jnl-&gt;cur_tr) {
		panic(<span class="enscript-string">&quot;jnl: jnl @ %p already has cur_tr %p, new tr: %p\n&quot;</span>,
			  jnl, jnl-&gt;cur_tr, tr);
	}

	<span class="enscript-comment">// if there weren't any modified blocks in the transaction
</span>	<span class="enscript-comment">// just save off the transaction pointer and return.
</span>	<span class="enscript-keyword">if</span> (tr-&gt;total_bytes == jnl-&gt;jhdr-&gt;blhdr_size) {
		jnl-&gt;cur_tr = tr;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	
    <span class="enscript-comment">// if our transaction buffer isn't very full, just hang
</span>    <span class="enscript-comment">// on to it and don't actually flush anything.  this is
</span>    <span class="enscript-comment">// what is known as &quot;group commit&quot;.  we will flush the
</span>    <span class="enscript-comment">// transaction buffer if it's full or if we have more than
</span>    <span class="enscript-comment">// one of them so we don't start hogging too much memory.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// We also check the device supports UNMAP/TRIM, and if so,
</span>    <span class="enscript-comment">// the number of extents waiting to be trimmed.  If it is
</span>    <span class="enscript-comment">// small enough, then keep accumulating more (so we can
</span>    <span class="enscript-comment">// reduce the overhead of trimming).  If there was a prior
</span>    <span class="enscript-comment">// trim error, then we stop issuing trims for this
</span>    <span class="enscript-comment">// volume, so we can also coalesce transactions.
</span>	<span class="enscript-comment">//
</span>    <span class="enscript-keyword">if</span> (   force_it == 0
		   &amp;&amp; (jnl-&gt;flags &amp; JOURNAL_NO_GROUP_COMMIT) == 0 
		   &amp;&amp; tr-&gt;num_blhdrs &lt; 3
		   &amp;&amp; (tr-&gt;total_bytes &lt;= ((tr-&gt;tbuffer_size*tr-&gt;num_blhdrs) - tr-&gt;tbuffer_size/8))
		   &amp;&amp; (!(jnl-&gt;flags &amp; JOURNAL_USE_UNMAP) || (tr-&gt;trim.extent_count &lt; jnl_trim_flush_limit))) {

		jnl-&gt;cur_tr = tr;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	KERNEL_DEBUG(0xbbbbc018|DBG_FUNC_START, jnl, tr, drop_lock, must_wait, 0);

	lock_condition(jnl, &amp;jnl-&gt;flushing, <span class="enscript-string">&quot;end_transaction&quot;</span>);

	<span class="enscript-comment">/*
	 * if the previous 'finish_end_transaction' was being run
	 * asynchronously, it could have encountered a condition
	 * that caused it to mark the journal invalid... if that
	 * occurred while we were waiting for it to finish, we
	 * need to notice and abort the current transaction
	 */</span>
	<span class="enscript-keyword">if</span> ((jnl-&gt;flags &amp; JOURNAL_INVALID) || jnl-&gt;flush_aborted == TRUE) {
		unlock_condition(jnl, &amp;jnl-&gt;flushing);

		abort_transaction(jnl, tr);
		ret_val = -1;
		KERNEL_DEBUG(0xbbbbc018|DBG_FUNC_END, jnl, tr, ret_val, 0, 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	
	<span class="enscript-comment">/*
	 * Store a pointer to this transaction's trim list so that
	 * future transactions can find it.
	 *
	 * Note: if there are no extents in the trim list, then don't
	 * bother saving the pointer since nothing can add new extents
	 * to the list (and other threads/transactions only care if
	 * there is a trim pending).
	 */</span>
	lck_rw_lock_exclusive(&amp;jnl-&gt;trim_lock);
	<span class="enscript-keyword">if</span> (jnl-&gt;async_trim != NULL)
		panic(<span class="enscript-string">&quot;jnl: end_transaction: async_trim already non-NULL!&quot;</span>);
	<span class="enscript-keyword">if</span> (tr-&gt;trim.extent_count &gt; 0)
		jnl-&gt;async_trim = &amp;tr-&gt;trim;
	lck_rw_unlock_exclusive(&amp;jnl-&gt;trim_lock);

	<span class="enscript-comment">/*
	 * snapshot the transaction sequence number while we are still behind
	 * the journal lock since it will be bumped upon the start of the
	 * next transaction group which may overlap the current journal flush...
	 * we pass the snapshot into write_journal_header during the journal
	 * flush so that it can write the correct version in the header...
	 * because we hold the 'flushing' condition variable for the duration
	 * of the journal flush, 'saved_sequence_num' remains stable
	 */</span>
	jnl-&gt;saved_sequence_num = jnl-&gt;sequence_num;
	
	<span class="enscript-comment">/*
	 * if we're here we're going to flush the transaction buffer to disk.
	 * 'check_free_space' will not return untl there is enough free
	 * space for this transaction in the journal and jnl-&gt;old_start[0]
	 * is avaiable for use
	 */</span>
	KERNEL_DEBUG(0xbbbbc030 | DBG_FUNC_START, jnl, 0, 0, 0, 0);

	check_free_space(jnl, tr-&gt;total_bytes, &amp;tr-&gt;delayed_header_write, jnl-&gt;saved_sequence_num);

	KERNEL_DEBUG(0xbbbbc030 | DBG_FUNC_END, jnl, tr-&gt;delayed_header_write, 0, 0, 0);

	<span class="enscript-comment">// range check the end index
</span>	<span class="enscript-keyword">if</span> (jnl-&gt;jhdr-&gt;end &lt;= 0 || jnl-&gt;jhdr-&gt;end &gt; jnl-&gt;jhdr-&gt;size) {
		panic(<span class="enscript-string">&quot;jnl: end_transaction: end is bogus 0x%llx (sz 0x%llx)\n&quot;</span>,
			  jnl-&gt;jhdr-&gt;end, jnl-&gt;jhdr-&gt;size);
	}
	<span class="enscript-keyword">if</span> (tr-&gt;delayed_header_write == TRUE) {
		thread_t	thread = THREAD_NULL;

		lock_condition(jnl, &amp;jnl-&gt;writing_header, <span class="enscript-string">&quot;end_transaction&quot;</span>);
		<span class="enscript-comment">/*
		 * fire up a thread to write the journal header
		 * asynchronously... when it finishes, it will call
		 * unlock_condition... we can overlap the preparation of
		 * the log and buffers during this time
		 */</span>
		kernel_thread_start((thread_continue_t)write_header_thread, jnl, &amp;thread);
	} <span class="enscript-keyword">else</span>
		jnl-&gt;write_header_failed = FALSE;


	<span class="enscript-comment">// this transaction starts where the current journal ends
</span>	tr-&gt;journal_start = jnl-&gt;jhdr-&gt;end;

	lock_oldstart(jnl);
	<span class="enscript-comment">/*
	 * Because old_start is locked above, we can cast away the volatile qualifier before passing it to memcpy.
	 * slide everyone else down and put our latest guy in the last
	 * entry in the old_start array
	 */</span>
	memcpy(__CAST_AWAY_QUALIFIER(&amp;jnl-&gt;old_start[0], <span class="enscript-type">volatile</span>, <span class="enscript-type">void</span> *), __CAST_AWAY_QUALIFIER(&amp;jnl-&gt;old_start[1], <span class="enscript-type">volatile</span>, <span class="enscript-type">void</span> *), <span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start)-<span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start[0]));
	jnl-&gt;old_start[<span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start)/<span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start[0]) - 1] = tr-&gt;journal_start | 0x8000000000000000LL;

	unlock_oldstart(jnl);


	<span class="enscript-keyword">for</span> (blhdr = tr-&gt;blhdr; blhdr; blhdr = next) {
		<span class="enscript-type">char</span>	*blkptr;
		buf_t	sbp;
		int32_t	bsize;

		tbuffer_offset = jnl-&gt;jhdr-&gt;blhdr_size;

		<span class="enscript-keyword">for</span> (i = 1; i &lt; blhdr-&gt;num_blocks; i++) {

			<span class="enscript-keyword">if</span> (blhdr-&gt;binfo[i].bnum != (off_t)-1) {
				<span class="enscript-type">void</span> (*func)(buf_t, <span class="enscript-type">void</span> *);
				<span class="enscript-type">void</span>  *arg;

				bp = blhdr-&gt;binfo[i].u.bp;

				<span class="enscript-keyword">if</span> (bp == NULL) {
					panic(<span class="enscript-string">&quot;jnl: inconsistent binfo (NULL bp w/bnum %lld; jnl @ %p, tr %p)\n&quot;</span>,
						blhdr-&gt;binfo[i].bnum, jnl, tr);
				}
				<span class="enscript-comment">/*
				 * acquire the bp here so that we can safely
				 * mess around with its data.  buf_acquire()
				 * will return EAGAIN if the buffer was busy,
				 * so loop trying again.
				 */</span>
				<span class="enscript-keyword">do</span> {
					errno = buf_acquire(bp, BAC_REMOVE, 0, 0);
				} <span class="enscript-keyword">while</span> (errno == EAGAIN);
					
				<span class="enscript-keyword">if</span> (errno)
					panic(<span class="enscript-string">&quot;could not acquire bp %p (err %d)\n&quot;</span>, bp, errno);

				<span class="enscript-keyword">if</span> ((buf_flags(bp) &amp; (B_LOCKED|B_DELWRI)) != (B_LOCKED|B_DELWRI)) {
					<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_CLOSE_PENDING) {
						buf_clearflags(bp, B_LOCKED);
						buf_brelse(bp);
						
						<span class="enscript-comment">/*
						 * this is an odd case that appears to happen occasionally
						 * make sure we mark this block as no longer valid
						 * so that we don't process it in &quot;finish_end_transaction&quot; since
						 * the bp that is recorded in our array no longer belongs
						 * to us (normally we substitute a shadow bp to be processed
						 * issuing a 'buf_bawrite' on a stale buf_t pointer leads
						 * to all kinds of problems.
						 */</span>
						blhdr-&gt;binfo[i].bnum = (off_t)-1;
						<span class="enscript-keyword">continue</span>;
					} <span class="enscript-keyword">else</span> {
						panic(<span class="enscript-string">&quot;jnl: end_tr: !!!DANGER!!! bp %p flags (0x%x) not LOCKED &amp; DELWRI\n&quot;</span>, bp, buf_flags(bp));
					}
				}
				bsize = buf_size(bp);

				buf_setfilter(bp, NULL, NULL, &amp;func, &amp;arg);
				
				blkptr = (<span class="enscript-type">char</span> *)&amp;((<span class="enscript-type">char</span> *)blhdr)[tbuffer_offset];

				sbp = buf_create_shadow_priv(bp, FALSE, (uintptr_t)blkptr, 0, 0);

				<span class="enscript-keyword">if</span> (sbp == NULL)
					panic(<span class="enscript-string">&quot;jnl: buf_create_shadow returned NULL&quot;</span>);

				<span class="enscript-comment">/*
				 * copy the data into the transaction buffer...
				 */</span>
				memcpy(blkptr, (<span class="enscript-type">char</span> *)buf_dataptr(bp), bsize);

				buf_clearflags(bp, B_LOCKED);
				buf_markclean(bp);
				buf_drop(bp);

				<span class="enscript-comment">/*
				 * adopt the shadow buffer for this block
				 */</span>
				<span class="enscript-keyword">if</span> (func) {
					<span class="enscript-comment">/*
					 * transfer FS hook function to the
					 * shadow buffer... it will get called
					 * in finish_end_transaction
					 */</span>
					buf_setfilter(sbp, func, arg, NULL, NULL);
				}
				blhdr-&gt;binfo[i].u.bp = sbp;

			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// bnum == -1, only true if a block was &quot;killed&quot; 
</span>				bsize = blhdr-&gt;binfo[i].u.bi.bsize;
			}
			tbuffer_offset += bsize;
		}
		next = (block_list_header *)((<span class="enscript-type">long</span>)blhdr-&gt;binfo[0].bnum);
	}
	<span class="enscript-comment">/*
	 * if callback != NULL, we don't want to drop the journal
	 * lock, or complete end_transaction asynchronously, since
	 * the caller is expecting the callback to run in the calling
	 * context
	 *
	 * if drop_lock == FALSE, we can't complete end_transaction
	 * asynchronously
	 */</span>
	<span class="enscript-keyword">if</span> (callback)
		drop_lock_early = FALSE;
	<span class="enscript-keyword">else</span>
		drop_lock_early = drop_lock;

	<span class="enscript-keyword">if</span> (drop_lock_early == FALSE)
		must_wait = TRUE;

	<span class="enscript-keyword">if</span> (drop_lock_early == TRUE) {
		journal_unlock(jnl);
		drop_lock = FALSE;
	}
	<span class="enscript-keyword">if</span> (must_wait == TRUE)
		ret_val = finish_end_transaction(tr, callback, callback_arg);
	<span class="enscript-keyword">else</span> {
		thread_t	thread = THREAD_NULL;

		<span class="enscript-comment">/*
		 * fire up a thread to complete processing this transaction
		 * asynchronously... when it finishes, it will call
		 * unlock_condition
		 */</span>
		kernel_thread_start((thread_continue_t)finish_end_thread, tr, &amp;thread);
	}
	KERNEL_DEBUG(0xbbbbc018|DBG_FUNC_END, jnl, tr, ret_val, 0, 0);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (drop_lock == TRUE) {
		journal_unlock(jnl);
	}
	<span class="enscript-keyword">return</span> (ret_val);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">finish_end_thread</span>(transaction *tr)
{
	proc_set_task_policy(current_task(), current_thread(),
	                     TASK_POLICY_INTERNAL, TASK_POLICY_IOPOL, IOPOL_PASSIVE);

	finish_end_transaction(tr, NULL, NULL);

	thread_deallocate(current_thread());
	thread_terminate(current_thread());
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">write_header_thread</span>(journal *jnl)
{
	proc_set_task_policy(current_task(), current_thread(),
	                     TASK_POLICY_INTERNAL, TASK_POLICY_IOPOL, IOPOL_PASSIVE);

	<span class="enscript-keyword">if</span> (write_journal_header(jnl, 1, jnl-&gt;saved_sequence_num))
		jnl-&gt;write_header_failed = TRUE;
	<span class="enscript-keyword">else</span>
		jnl-&gt;write_header_failed = FALSE;
	unlock_condition(jnl, &amp;jnl-&gt;writing_header);

	thread_deallocate(current_thread());
	thread_terminate(current_thread());
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">finish_end_transaction</span>(transaction *tr, errno_t (*callback)(<span class="enscript-type">void</span>*), <span class="enscript-type">void</span> *callback_arg)
{
	<span class="enscript-type">int</span>		i, amt;
	<span class="enscript-type">int</span>		ret = 0;
	off_t		end;
	journal		*jnl = tr-&gt;jnl;
	buf_t		bp, *bparray;
	vnode_t		vp;
	block_list_header  *blhdr=NULL, *next=NULL;
	size_t		tbuffer_offset;
	<span class="enscript-type">int</span>		bufs_written = 0;
	<span class="enscript-type">int</span>		ret_val = 0;
	boolean_t	was_vm_privileged = FALSE;

	KERNEL_DEBUG(0xbbbbc028|DBG_FUNC_START, jnl, tr, 0, 0, 0);

	<span class="enscript-keyword">if</span> (jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) {
		<span class="enscript-comment">/*
		 * if we block waiting for memory, and there is enough pressure to
		 * cause us to try and create a new swap file, we may end up deadlocking
		 * due to waiting for the journal on the swap file creation path...
		 * by making ourselves vm_privileged, we give ourselves the best chance
		 * of not blocking
		 */</span>
		was_vm_privileged = set_vm_privilege(TRUE);
	}
	end  = jnl-&gt;jhdr-&gt;end;

	<span class="enscript-keyword">for</span> (blhdr = tr-&gt;blhdr; blhdr; blhdr = (block_list_header *)((<span class="enscript-type">long</span>)blhdr-&gt;binfo[0].bnum)) {

		amt = blhdr-&gt;bytes_used;

		blhdr-&gt;binfo[0].u.bi.b.sequence_num = tr-&gt;sequence_num;

		blhdr-&gt;checksum = 0;
		blhdr-&gt;checksum = calc_checksum((<span class="enscript-type">char</span> *)blhdr, BLHDR_CHECKSUM_SIZE);

		<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;bparray, blhdr-&gt;num_blocks * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> buf *), VM_KERN_MEMORY_FILE)) {
			panic(<span class="enscript-string">&quot;can't allocate %zd bytes for bparray\n&quot;</span>, blhdr-&gt;num_blocks * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> buf *));
		}
		tbuffer_offset = jnl-&gt;jhdr-&gt;blhdr_size;

		<span class="enscript-keyword">for</span> (i = 1; i &lt; blhdr-&gt;num_blocks; i++) {
			<span class="enscript-type">void</span> (*func)(buf_t, <span class="enscript-type">void</span> *);
			<span class="enscript-type">void</span>	*arg;
			int32_t	bsize;
		    
			<span class="enscript-comment">/*
			 * finish preparing the shadow buf_t before 
			 * calculating the individual block checksums
			 */</span>
			<span class="enscript-keyword">if</span> (blhdr-&gt;binfo[i].bnum != (off_t)-1) {
				daddr64_t blkno;
				daddr64_t lblkno;

				bp = blhdr-&gt;binfo[i].u.bp;
				
				vp = buf_vnode(bp);
				blkno = buf_blkno(bp);
				lblkno = buf_lblkno(bp);

				<span class="enscript-keyword">if</span> (vp == NULL &amp;&amp; lblkno == blkno) {
					printf(<span class="enscript-string">&quot;jnl: %s: end_tr: bad news! buffer w/null vp and l/blkno = %qd/%qd.  aborting the transaction.\n&quot;</span>,
					       jnl-&gt;jdev_name, lblkno, blkno);
					ret_val = -1;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
				}
	    
				<span class="enscript-comment">// if the lblkno is the same as blkno and this bp isn't
</span>				<span class="enscript-comment">// associated with the underlying file system device then
</span>				<span class="enscript-comment">// we need to call bmap() to get the actual physical block.
</span>				<span class="enscript-comment">//
</span>				<span class="enscript-keyword">if</span> ((lblkno == blkno) &amp;&amp; (vp != jnl-&gt;fsdev)) {
					off_t	f_offset;
					size_t 	contig_bytes;

					<span class="enscript-keyword">if</span> (VNOP_BLKTOOFF(vp, lblkno, &amp;f_offset)) {
						printf(<span class="enscript-string">&quot;jnl: %s: end_tr: vnop_blktooff failed\n&quot;</span>, jnl-&gt;jdev_name);
						ret_val = -1;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
					}
					<span class="enscript-keyword">if</span> (VNOP_BLOCKMAP(vp, f_offset, buf_count(bp), &amp;blkno, &amp;contig_bytes, NULL, 0, NULL)) {
						printf(<span class="enscript-string">&quot;jnl: %s: end_tr: can't blockmap the buffer&quot;</span>, jnl-&gt;jdev_name);
						ret_val = -1;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
					}
					<span class="enscript-keyword">if</span> ((uint32_t)contig_bytes &lt; buf_count(bp)) {
						printf(<span class="enscript-string">&quot;jnl: %s: end_tr: blk not physically contiguous on disk\n&quot;</span>, jnl-&gt;jdev_name);
						ret_val = -1;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
					}
					buf_setblkno(bp, blkno);
				}
				<span class="enscript-comment">// update this so we write out the correct physical block number!
</span>				blhdr-&gt;binfo[i].bnum = (off_t)(blkno);

				<span class="enscript-comment">/*
				 * pick up the FS hook function (if any) and prepare
				 * to fire this buffer off in the next pass
				 */</span>
				buf_setfilter(bp, buffer_flushed_callback, tr, &amp;func, &amp;arg);

				<span class="enscript-keyword">if</span> (func) {
					<span class="enscript-comment">/*
					 * call the hook function supplied by the filesystem...
					 * this needs to happen BEFORE cacl_checksum in case
					 * the FS morphs the data in the buffer
					 */</span>
					func(bp, arg);
				}
				bparray[i] = bp;
				bsize = buf_size(bp);
				blhdr-&gt;binfo[i].u.bi.bsize = bsize;
				blhdr-&gt;binfo[i].u.bi.b.cksum = calc_checksum(&amp;((<span class="enscript-type">char</span> *)blhdr)[tbuffer_offset], bsize);
			} <span class="enscript-keyword">else</span> {
				bparray[i] = NULL;
				bsize = blhdr-&gt;binfo[i].u.bi.bsize;
				blhdr-&gt;binfo[i].u.bi.b.cksum = 0;
			}
			tbuffer_offset += bsize;
		}
		<span class="enscript-comment">/*
		 * if we fired off the journal_write_header asynchronously in
		 * 'end_transaction', we need to wait for its completion
		 * before writing the actual journal data
		 */</span>
		wait_condition(jnl, &amp;jnl-&gt;writing_header, <span class="enscript-string">&quot;finish_end_transaction&quot;</span>);

		<span class="enscript-keyword">if</span> (jnl-&gt;write_header_failed == FALSE)
			ret = write_journal_data(jnl, &amp;end, blhdr, amt);
		<span class="enscript-keyword">else</span> 
			ret_val = -1;
		<span class="enscript-comment">/*
		 * put the bp pointers back so that we can 
		 * make the final pass on them
		 */</span>
		<span class="enscript-keyword">for</span> (i = 1; i &lt; blhdr-&gt;num_blocks; i++)
			blhdr-&gt;binfo[i].u.bp = bparray[i];

		kmem_free(kernel_map, (vm_offset_t)bparray, blhdr-&gt;num_blocks * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> buf *));

		<span class="enscript-keyword">if</span> (ret_val == -1)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;

		<span class="enscript-keyword">if</span> (ret != amt) {
			printf(<span class="enscript-string">&quot;jnl: %s: end_transaction: only wrote %d of %d bytes to the journal!\n&quot;</span>,
			       jnl-&gt;jdev_name, ret, amt);

			ret_val = -1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
		}
	}
	jnl-&gt;jhdr-&gt;end  = end;    <span class="enscript-comment">// update where the journal now ends
</span>	tr-&gt;journal_end = end;    <span class="enscript-comment">// the transaction ends here too
</span>
	<span class="enscript-keyword">if</span> (tr-&gt;journal_start == 0 || tr-&gt;journal_end == 0) {
		panic(<span class="enscript-string">&quot;jnl: end_transaction: bad tr journal start/end: 0x%llx 0x%llx\n&quot;</span>,
		      tr-&gt;journal_start, tr-&gt;journal_end);
	}

	<span class="enscript-keyword">if</span> (write_journal_header(jnl, 0, jnl-&gt;saved_sequence_num) != 0) {
		ret_val = -1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}
	<span class="enscript-comment">/*
	 * If the caller supplied a callback, call it now that the blocks have been
	 * written to the journal.  This is used by journal_relocate so, for example,
	 * the file system can change its pointer to the new journal.
	 */</span>
	<span class="enscript-keyword">if</span> (callback != NULL &amp;&amp; callback(callback_arg) != 0) {
		ret_val = -1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}
	
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// Send a DKIOCUNMAP for the extents trimmed by this transaction, and
</span>	<span class="enscript-comment">// free up the extent list.
</span>	<span class="enscript-comment">//
</span>	journal_trim_flush(jnl, tr);
	
	<span class="enscript-comment">// the buffer_flushed_callback will only be called for the 
</span>	<span class="enscript-comment">// real blocks that get flushed so we have to account for 
</span>	<span class="enscript-comment">// the block_list_headers here.
</span>	<span class="enscript-comment">//
</span>	tr-&gt;num_flushed = tr-&gt;num_blhdrs * jnl-&gt;jhdr-&gt;blhdr_size;

	lock_condition(jnl, &amp;jnl-&gt;asyncIO, <span class="enscript-string">&quot;finish_end_transaction&quot;</span>);

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// setup for looping through all the blhdr's.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">for</span> (blhdr = tr-&gt;blhdr; blhdr; blhdr = next) {
		uint16_t	num_blocks;

		<span class="enscript-comment">/*
		 * grab this info ahead of issuing the buf_bawrites...
		 * once the last one goes out, its possible for blhdr
		 * to be freed (especially if we get preempted) before
		 * we do the last check of num_blocks or
		 * grab the next blhdr pointer...
		 */</span>
		next = (block_list_header *)((<span class="enscript-type">long</span>)blhdr-&gt;binfo[0].bnum);
		num_blocks = blhdr-&gt;num_blocks;

		<span class="enscript-comment">/*
		 * we can re-order the buf ptrs because everything is written out already
		 */</span>
		qsort(&amp;blhdr-&gt;binfo[1], num_blocks-1, <span class="enscript-keyword">sizeof</span>(block_info), journal_binfo_cmp);

		<span class="enscript-comment">/*
		 * need to make sure that the loop issuing the buf_bawrite's
		 * does not touch blhdr once the last buf_bawrite has been
		 * issued... at that point, we no longer have a legitmate
		 * reference on the associated storage since it will be
		 * released upon the completion of that last buf_bawrite
		 */</span>
		<span class="enscript-keyword">for</span> (i = num_blocks-1; i &gt;= 1; i--) {
			<span class="enscript-keyword">if</span> (blhdr-&gt;binfo[i].bnum != (off_t)-1)
				<span class="enscript-keyword">break</span>;
			num_blocks--;
		}
		<span class="enscript-keyword">for</span> (i = 1; i &lt; num_blocks; i++) {

			<span class="enscript-keyword">if</span> ((bp = blhdr-&gt;binfo[i].u.bp)) {
				vp = buf_vnode(bp);
		    
				buf_bawrite(bp);
				
				<span class="enscript-comment">// this undoes the vnode_ref() in journal_modify_block_end()
</span>				vnode_rele_ext(vp, 0, 1);

				bufs_written++;
			}
		}
	}
	<span class="enscript-keyword">if</span> (bufs_written == 0) {
		<span class="enscript-comment">/*
		 * since we didn't issue any buf_bawrite's, there is no
		 * async trigger to cause the memory associated with this
		 * transaction to be freed... so, move it to the garbage
		 * list now
		 */</span>
		lock_oldstart(jnl);

		tr-&gt;next       = jnl-&gt;tr_freeme;
		jnl-&gt;tr_freeme = tr;

		unlock_oldstart(jnl);

		unlock_condition(jnl, &amp;jnl-&gt;asyncIO);
	}

	<span class="enscript-comment">//printf(&quot;jnl: end_tr: tr @ 0x%x, jnl-blocks: 0x%llx - 0x%llx. exit!\n&quot;,
</span>	<span class="enscript-comment">//   tr, tr-&gt;journal_start, tr-&gt;journal_end);
</span>
<span class="enscript-reference">bad_journal</span>:
	<span class="enscript-keyword">if</span> (ret_val == -1) {
		abort_transaction(jnl, tr);		<span class="enscript-comment">// cleans up list of extents to be trimmed
</span>
		<span class="enscript-comment">/*
		 * 'flush_aborted' is protected by the flushing condition... we need to
		 * set it before dropping the condition so that it will be
		 * noticed in 'end_transaction'... we add this additional
		 * aborted condition so that we can drop the 'flushing' condition
		 * before grabbing the journal lock... this avoids a deadlock
		 * in 'end_transaction' which is holding the journal lock while
		 * waiting for the 'flushing' condition to clear...
		 * everyone else will notice the JOURNAL_INVALID flag
		 */</span>
		jnl-&gt;flush_aborted = TRUE;

		unlock_condition(jnl, &amp;jnl-&gt;flushing);
		journal_lock(jnl);

		jnl-&gt;flags |= JOURNAL_INVALID;
		jnl-&gt;old_start[<span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start)/<span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start[0]) - 1] &amp;= ~0x8000000000000000LL;

		journal_unlock(jnl);
	} <span class="enscript-keyword">else</span>
		unlock_condition(jnl, &amp;jnl-&gt;flushing);

	<span class="enscript-keyword">if</span> ((jnl-&gt;fsmount-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) &amp;&amp; (was_vm_privileged == FALSE))
		set_vm_privilege(FALSE);

	KERNEL_DEBUG(0xbbbbc028|DBG_FUNC_END, jnl, tr, bufs_written, ret_val, 0);

	<span class="enscript-keyword">return</span> (ret_val);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lock_condition</span>(journal *jnl, boolean_t *condition, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *condition_name)
{

	KERNEL_DEBUG(0xbbbbc020|DBG_FUNC_START, jnl, condition, 0, 0, 0);

	lock_flush(jnl);

	<span class="enscript-keyword">while</span> (*condition == TRUE)
		msleep(condition, &amp;jnl-&gt;flock, PRIBIO, condition_name, NULL);

	*condition = TRUE;
	unlock_flush(jnl);

	KERNEL_DEBUG(0xbbbbc020|DBG_FUNC_END, jnl, condition, 0, 0, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">wait_condition</span>(journal *jnl, boolean_t *condition, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *condition_name)
{

	<span class="enscript-keyword">if</span> (*condition == FALSE)
		<span class="enscript-keyword">return</span>;

	KERNEL_DEBUG(0xbbbbc02c|DBG_FUNC_START, jnl, condition, 0, 0, 0);

	lock_flush(jnl);

	<span class="enscript-keyword">while</span> (*condition == TRUE)
		msleep(condition, &amp;jnl-&gt;flock, PRIBIO, condition_name, NULL);

	unlock_flush(jnl);

	KERNEL_DEBUG(0xbbbbc02c|DBG_FUNC_END, jnl, condition, 0, 0, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">unlock_condition</span>(journal *jnl, boolean_t *condition)
{
	lock_flush(jnl);

	*condition = FALSE;
	wakeup(condition);

	unlock_flush(jnl);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">abort_transaction</span>(journal *jnl, transaction *tr)
{
	block_list_header *blhdr, *next;

	<span class="enscript-comment">// for each block list header, iterate over the blocks then
</span>	<span class="enscript-comment">// free up the memory associated with the block list.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// find each of the primary blocks (i.e. the list could
</span>	<span class="enscript-comment">// contain a mix of shadowed and real buf_t's depending
</span>	<span class="enscript-comment">// on when the abort condition was detected) and mark them
</span>	<span class="enscript-comment">// clean and locked in the cache... this at least allows 
</span>	<span class="enscript-comment">// the FS a consistent view between it's incore data structures
</span>	<span class="enscript-comment">// and the meta-data held in the cache
</span>	<span class="enscript-comment">//
</span>	KERNEL_DEBUG(0xbbbbc034|DBG_FUNC_START, jnl, tr, 0, 0, 0);

	<span class="enscript-keyword">for</span> (blhdr = tr-&gt;blhdr; blhdr; blhdr = next) {
		<span class="enscript-type">int</span>	i;
		
		<span class="enscript-keyword">for</span> (i = 1; i &lt; blhdr-&gt;num_blocks; i++) {
			buf_t		bp, tbp, sbp;
			vnode_t		bp_vp;
			errno_t		errno;

			<span class="enscript-keyword">if</span> (blhdr-&gt;binfo[i].bnum == (off_t)-1)
				<span class="enscript-keyword">continue</span>;

			tbp = blhdr-&gt;binfo[i].u.bp;

			bp_vp = buf_vnode(tbp);

			<span class="enscript-keyword">if</span> (buf_shadow(tbp)) {
				sbp = tbp;
				buf_setfilter(tbp, NULL, NULL, NULL, NULL);
			} <span class="enscript-keyword">else</span> {
				assert(ISSET(buf_flags(tbp), B_LOCKED));

				sbp = NULL;

				<span class="enscript-keyword">do</span> {
					errno = buf_acquire(tbp, BAC_REMOVE, 0, 0);
				} <span class="enscript-keyword">while</span> (errno == EAGAIN);

				<span class="enscript-keyword">if</span> (!errno) {
					buf_setfilter(tbp, NULL, NULL, NULL, NULL);
					buf_brelse(tbp);
				}
			}

			<span class="enscript-keyword">if</span> (bp_vp) {
				errno = buf_meta_bread(bp_vp,
						       buf_lblkno(tbp),
						       buf_size(tbp),
						       NOCRED,
						       &amp;bp);
				<span class="enscript-keyword">if</span> (errno == 0) {
					<span class="enscript-keyword">if</span> (sbp == NULL &amp;&amp; bp != tbp &amp;&amp; (buf_flags(tbp) &amp; B_LOCKED)) {
						panic(<span class="enscript-string">&quot;jnl: abort_tr: got back a different bp! (bp %p should be %p, jnl %p\n&quot;</span>,
						      bp, tbp, jnl);
					}
					<span class="enscript-comment">/*
					 * once the journal has been marked INVALID and aborted,
					 * NO meta data can be written back to the disk, so 
					 * mark the buf_t clean and make sure it's locked in the cache
					 * note: if we found a shadow, the real buf_t needs to be relocked
					 */</span>
					buf_setflags(bp, B_LOCKED);
					buf_markclean(bp);
					buf_brelse(bp);

					KERNEL_DEBUG(0xbbbbc034|DBG_FUNC_NONE, jnl, tr, bp, 0, 0);

					<span class="enscript-comment">/*
					 * this undoes the vnode_ref() in journal_modify_block_end()
					 */</span>
					vnode_rele_ext(bp_vp, 0, 1);
				} <span class="enscript-keyword">else</span> {
					printf(<span class="enscript-string">&quot;jnl: %s: abort_tr: could not find block %lld for vnode!\n&quot;</span>,
					       jnl-&gt;jdev_name, blhdr-&gt;binfo[i].bnum);
					<span class="enscript-keyword">if</span> (bp) {
						buf_brelse(bp);
					}
				}
			}
			<span class="enscript-keyword">if</span> (sbp)
				buf_brelse(sbp);
		}
		next = (block_list_header *)((<span class="enscript-type">long</span>)blhdr-&gt;binfo[0].bnum);

		<span class="enscript-comment">// we can free blhdr here since we won't need it any more
</span>		blhdr-&gt;binfo[0].bnum = 0xdeadc0de;
		kmem_free(kernel_map, (vm_offset_t)blhdr, tr-&gt;tbuffer_size);
	}

	<span class="enscript-comment">/*
	 * If the transaction we're aborting was the async transaction, then
	 * tell the current transaction that there is no pending trim
	 * any more.
	 */</span>
	lck_rw_lock_exclusive(&amp;jnl-&gt;trim_lock);
	<span class="enscript-keyword">if</span> (jnl-&gt;async_trim == &amp;tr-&gt;trim)
		jnl-&gt;async_trim = NULL;
	lck_rw_unlock_exclusive(&amp;jnl-&gt;trim_lock);
	
	
	<span class="enscript-keyword">if</span> (tr-&gt;trim.extents) {
		kfree(tr-&gt;trim.extents, tr-&gt;trim.allocated_count * <span class="enscript-keyword">sizeof</span>(dk_extent_t));
	}
	tr-&gt;trim.allocated_count = 0;
	tr-&gt;trim.extent_count = 0;
	tr-&gt;trim.extents = NULL;
	tr-&gt;tbuffer     = NULL;
	tr-&gt;blhdr       = NULL;
	tr-&gt;total_bytes = 0xdbadc0de;
	FREE_ZONE(tr, <span class="enscript-keyword">sizeof</span>(transaction), M_JNL_TR);

	KERNEL_DEBUG(0xbbbbc034|DBG_FUNC_END, jnl, tr, 0, 0, 0);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_end_transaction</span>(journal *jnl)
{
	<span class="enscript-type">int</span> ret;
	transaction *tr;
    
	CHECK_JOURNAL(jnl);

	free_old_stuff(jnl);

	<span class="enscript-keyword">if</span> ((jnl-&gt;flags &amp; JOURNAL_INVALID) &amp;&amp; jnl-&gt;owner == NULL) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (jnl-&gt;owner != current_thread()) {
		panic(<span class="enscript-string">&quot;jnl: end_tr: I'm not the owner! jnl %p, owner %p, curact %p\n&quot;</span>,
		      jnl, jnl-&gt;owner, current_thread());
	}
	jnl-&gt;nested_count--;

	<span class="enscript-keyword">if</span> (jnl-&gt;nested_count &gt; 0) {
		<span class="enscript-keyword">return</span> 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (jnl-&gt;nested_count &lt; 0) {
		panic(<span class="enscript-string">&quot;jnl: jnl @ %p has negative nested count (%d). bad boy.\n&quot;</span>, jnl, jnl-&gt;nested_count);
	}
    
	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_INVALID) {
		<span class="enscript-keyword">if</span> (jnl-&gt;active_tr) {
			<span class="enscript-keyword">if</span> (jnl-&gt;cur_tr != NULL) {
				panic(<span class="enscript-string">&quot;jnl: journal @ %p has active tr (%p) and cur tr (%p)\n&quot;</span>,
				      jnl, jnl-&gt;active_tr, jnl-&gt;cur_tr);
			}
			tr             = jnl-&gt;active_tr;
			jnl-&gt;active_tr = NULL;

			abort_transaction(jnl, tr);
		}
		journal_unlock(jnl);

		<span class="enscript-keyword">return</span> EINVAL;
	}

	tr = jnl-&gt;active_tr;
	CHECK_TRANSACTION(tr);

	<span class="enscript-comment">// clear this out here so that when check_free_space() calls
</span>	<span class="enscript-comment">// the FS flush function, we don't panic in journal_flush()
</span>	<span class="enscript-comment">// if the FS were to call that.  note: check_free_space() is
</span>	<span class="enscript-comment">// called from end_transaction().
</span>	<span class="enscript-comment">// 
</span>	jnl-&gt;active_tr = NULL;
	
	<span class="enscript-comment">/* Examine the force-journal-flush state in the active txn */</span>
	<span class="enscript-keyword">if</span> (tr-&gt;flush_on_completion == TRUE) {
		<span class="enscript-comment">/*
		 * If the FS requested it, disallow group commit and force the
		 * transaction out to disk immediately.
		 */</span>
		ret = end_transaction(tr, 1, NULL, NULL, TRUE, TRUE);
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* in the common path we can simply use the double-buffered journal */</span>
		ret = end_transaction(tr, 0, NULL, NULL, TRUE, FALSE);
	}

	<span class="enscript-keyword">return</span> ret;
}


<span class="enscript-comment">/* 
 * Flush the contents of the journal to the disk. 
 *
 *  Input: 
 *  	wait_for_IO - 
 *  	If TRUE, wait to write in-memory journal to the disk 
 *  	consistently, and also wait to write all asynchronous 
 *  	metadata blocks to its corresponding locations
 *  	consistently on the disk.  This means that the journal 
 *  	is empty at this point and does not contain any 
 *  	transactions.  This is overkill in normal scenarios  
 *  	but is useful whenever the metadata blocks are required 
 *  	to be consistent on-disk instead of just the journal 
 *  	being consistent; like before live verification 
 *  	and live volume resizing.  
 *
 *  	If FALSE, only wait to write in-memory journal to the 
 *  	disk consistently.  This means that the journal still 
 *  	contains uncommitted transactions and the file system 
 *  	metadata blocks in the journal transactions might be 
 *  	written asynchronously to the disk.  But there is no 
 *  	guarantee that they are written to the disk before 
 *  	returning to the caller.  Note that this option is 
 *  	sufficient for file system data integrity as it 
 *  	guarantees consistent journal content on the disk.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_flush</span>(journal *jnl, journal_flush_options_t options)
{
	boolean_t drop_lock = FALSE;
	errno_t error = 0;
	uint32_t flush_count;
    
	CHECK_JOURNAL(jnl);
    
	free_old_stuff(jnl);

	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_INVALID) {
		<span class="enscript-keyword">return</span> -1;
	}

	KERNEL_DEBUG(DBG_JOURNAL_FLUSH | DBG_FUNC_START, jnl, 0, 0, 0, 0);

	<span class="enscript-keyword">if</span> (jnl-&gt;owner != current_thread()) {
		journal_lock(jnl);
		drop_lock = TRUE;
	}

	<span class="enscript-keyword">if</span> (ISSET(options, JOURNAL_FLUSH_FULL))
		flush_count = jnl-&gt;flush_counter;

	<span class="enscript-comment">// if we're not active, flush any buffered transactions
</span>	<span class="enscript-keyword">if</span> (jnl-&gt;active_tr == NULL &amp;&amp; jnl-&gt;cur_tr) {
		transaction *tr = jnl-&gt;cur_tr;

		jnl-&gt;cur_tr = NULL;

		<span class="enscript-keyword">if</span> (ISSET(options, JOURNAL_WAIT_FOR_IO)) {
			wait_condition(jnl, &amp;jnl-&gt;flushing, <span class="enscript-string">&quot;journal_flush&quot;</span>);
			wait_condition(jnl, &amp;jnl-&gt;asyncIO, <span class="enscript-string">&quot;journal_flush&quot;</span>);
		}
		<span class="enscript-comment">/*
		 * &quot;end_transction&quot; will wait for any current async flush
		 * to complete, before flushing &quot;cur_tr&quot;... because we've
		 * specified the 'must_wait' arg as TRUE, it will then
		 * synchronously flush the &quot;cur_tr&quot;
		 */</span>
		end_transaction(tr, 1, NULL, NULL, drop_lock, TRUE);   <span class="enscript-comment">// force it to get flushed
</span>
	} <span class="enscript-keyword">else</span>  { 
		<span class="enscript-keyword">if</span> (drop_lock == TRUE) {
			journal_unlock(jnl);
		}

		<span class="enscript-comment">/* Because of pipelined journal, the journal transactions 
		 * might be in process of being flushed on another thread.  
		 * If there is nothing to flush currently, we should 
		 * synchronize ourselves with the pipelined journal thread 
		 * to ensure that all inflight transactions, if any, are 
		 * flushed before we return success to caller.
		 */</span>
		wait_condition(jnl, &amp;jnl-&gt;flushing, <span class="enscript-string">&quot;journal_flush&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (ISSET(options, JOURNAL_WAIT_FOR_IO)) {
		wait_condition(jnl, &amp;jnl-&gt;asyncIO, <span class="enscript-string">&quot;journal_flush&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (ISSET(options, JOURNAL_FLUSH_FULL)) {

		dk_synchronize_t sync_request = {
			.options                        = 0,
		};

		<span class="enscript-comment">// We need a full cache flush. If it has not been done, do it here.
</span>		<span class="enscript-keyword">if</span> (flush_count == jnl-&gt;flush_counter)
			error = VNOP_IOCTL(jnl-&gt;jdev, DKIOCSYNCHRONIZE, (caddr_t)&amp;sync_request, FWRITE, vfs_context_kernel());

		<span class="enscript-comment">// If external journal partition is enabled, flush filesystem data partition.
</span>		<span class="enscript-keyword">if</span> (jnl-&gt;jdev != jnl-&gt;fsdev)
			error = VNOP_IOCTL(jnl-&gt;fsdev, DKIOCSYNCHRONIZE, (caddr_t)&amp;sync_request, FWRITE, vfs_context_kernel());

	}

	KERNEL_DEBUG(DBG_JOURNAL_FLUSH | DBG_FUNC_END, jnl, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_active</span>(journal *jnl)
{
	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_INVALID) {
		<span class="enscript-keyword">return</span> -1;
	}
    
	<span class="enscript-keyword">return</span> (jnl-&gt;active_tr == NULL) ? 0 : 1;
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">journal_owner</span>(journal *jnl)
{
	<span class="enscript-keyword">return</span> jnl-&gt;owner;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">journal_uses_fua</span>(journal *jnl)
{
	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_DO_FUA_WRITES)
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Relocate the journal.
 * 
 * You provide the new starting offset and size for the journal. You may
 * optionally provide a new tbuffer_size; passing zero defaults to not
 * changing the tbuffer size except as needed to fit within the new journal
 * size.
 * 
 * You must have already started a transaction. The transaction may contain
 * modified blocks (such as those needed to deallocate the old journal,
 * allocate the new journal, and update the location and size of the journal
 * in filesystem-private structures). Any transactions prior to the active
 * transaction will be flushed to the old journal. The new journal will be
 * initialized, and the blocks from the active transaction will be written to
 * the new journal.
 *
 * The caller will need to update the structures that identify the location
 * and size of the journal.  These updates should be made in the supplied
 * callback routine.  These updates must NOT go into a transaction.  You should
 * force these updates to the media before returning from the callback.  In the
 * even of a crash, either the old journal will be found, with an empty journal,
 * or the new journal will be found with the contents of the active transaction.
 *
 * Upon return from the callback, the blocks from the active transaction are
 * written to their normal locations on disk.
 *
 * (Remember that we have to ensure that blocks get committed to the journal
 * before being committed to their normal locations.  But the blocks don't count
 * as committed until the new journal is pointed at.)
 *
 * Upon return, there is still an active transaction: newly allocated, and
 * with no modified blocks.  Call journal_end_transaction as normal.  You may
 * modifiy additional blocks before calling journal_end_transaction, and those
 * blocks will (eventually) go to the relocated journal.
 *
 * Inputs:
 *	jnl				The (opened) journal to relocate.
 *	offset			The new journal byte offset (from start of the journal device).
 *	journal_size	The size, in bytes, of the new journal.
 *	tbuffer_size	The new desired transaction buffer size.  Pass zero to keep
 *					the same size as the current journal.  The size will be
 *					modified as needed to fit the new journal.
 *	callback		Routine called after the new journal has been initialized,
 *					and the active transaction written to the new journal, but
 *					before the blocks are written to their normal locations.
 *					Pass NULL for no callback.
 *	callback_arg	An argument passed to the callback routine.
 *
 * Result:
 *	0				No errors
 *	EINVAL			The offset is not block aligned
 *	EINVAL			The journal_size is not a multiple of the block size
 *	EINVAL			The journal is invalid
 *	(any)			An error returned by journal_flush.
 *
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">journal_relocate</span>(journal *jnl, off_t offset, off_t journal_size, int32_t tbuffer_size,
	errno_t (*callback)(<span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *callback_arg)
{
	<span class="enscript-type">int</span>		ret;
	transaction	*tr;
	size_t i = 0;

	<span class="enscript-comment">/*
	 * Sanity check inputs, and adjust the size of the transaction buffer.
	 */</span>
	<span class="enscript-keyword">if</span> ((offset % jnl-&gt;jhdr-&gt;jhdr_size) != 0) {
		printf(<span class="enscript-string">&quot;jnl: %s: relocate: offset 0x%llx is not an even multiple of block size 0x%x\n&quot;</span>,
		       jnl-&gt;jdev_name, offset, jnl-&gt;jhdr-&gt;jhdr_size);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> ((journal_size % jnl-&gt;jhdr-&gt;jhdr_size) != 0) {
		printf(<span class="enscript-string">&quot;jnl: %s: relocate: journal size 0x%llx is not an even multiple of block size 0x%x\n&quot;</span>,
		       jnl-&gt;jdev_name, journal_size, jnl-&gt;jhdr-&gt;jhdr_size);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	CHECK_JOURNAL(jnl);

	<span class="enscript-comment">/* Guarantee we own the active transaction. */</span>
	<span class="enscript-keyword">if</span> (jnl-&gt;flags &amp; JOURNAL_INVALID) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> (jnl-&gt;owner != current_thread()) {
		panic(<span class="enscript-string">&quot;jnl: relocate: Not the owner! jnl %p, owner %p, curact %p\n&quot;</span>,
		      jnl, jnl-&gt;owner, current_thread());
	}
	
	<span class="enscript-keyword">if</span> (tbuffer_size == 0)
		tbuffer_size = jnl-&gt;tbuffer_size;
	size_up_tbuffer(jnl, tbuffer_size, jnl-&gt;jhdr-&gt;jhdr_size);
	
	<span class="enscript-comment">/*
	 * Flush any non-active transactions.  We have to temporarily hide the
	 * active transaction to make journal_flush flush out non-active but
	 * current (unwritten) transactions.
	 */</span>
	tr = jnl-&gt;active_tr;
	CHECK_TRANSACTION(tr);
	jnl-&gt;active_tr = NULL;
	ret = journal_flush(jnl, JOURNAL_WAIT_FOR_IO);
	jnl-&gt;active_tr = tr;

	<span class="enscript-keyword">if</span> (ret) {
		<span class="enscript-keyword">return</span> ret;
	}
	wait_condition(jnl, &amp;jnl-&gt;flushing, <span class="enscript-string">&quot;end_transaction&quot;</span>);

	<span class="enscript-comment">/*
	 * At this point, we have completely flushed the contents of the current
	 * journal to disk (and have asynchronously written all of the txns to 
	 * their actual desired locations).  As a result, we can (and must) clear 
	 * out the old_start array.  If we do not, then if the last written transaction
	 * started at the beginning of the journal (starting 1 block into the 
	 * journal file) it could confuse the buffer_flushed callback. This is
	 * because we're about to reset the start/end pointers of the journal header
	 * below. 
	 */</span>
	lock_oldstart(jnl); 
	<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span> (jnl-&gt;old_start) / <span class="enscript-keyword">sizeof</span>(jnl-&gt;old_start[0]); i++) { 
		jnl-&gt;old_start[i] = 0; 
	}
	unlock_oldstart(jnl);

	<span class="enscript-comment">/* Update the journal's offset and size in memory. */</span>
	jnl-&gt;jdev_offset = offset;
	jnl-&gt;jhdr-&gt;start = jnl-&gt;jhdr-&gt;end = jnl-&gt;jhdr-&gt;jhdr_size;
	jnl-&gt;jhdr-&gt;size = journal_size;
	jnl-&gt;active_start = jnl-&gt;jhdr-&gt;start;
	
	<span class="enscript-comment">/*
	 * Force the active transaction to be written to the new journal.  Call the
	 * supplied callback after the blocks have been written to the journal, but
	 * before they get written to their normal on-disk locations.
	 */</span>
	jnl-&gt;active_tr = NULL;
	ret = end_transaction(tr, 1, callback, callback_arg, FALSE, TRUE);
	<span class="enscript-keyword">if</span> (ret) {
		printf(<span class="enscript-string">&quot;jnl: %s: relocate: end_transaction failed (%d)\n&quot;</span>, jnl-&gt;jdev_name, ret);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}
	
	<span class="enscript-comment">/*
	 * Create a new, empty transaction to be the active transaction.  This way
	 * our caller can use journal_end_transaction as usual.
	 */</span>
	ret = journal_allocate_transaction(jnl);
	<span class="enscript-keyword">if</span> (ret) {
		printf(<span class="enscript-string">&quot;jnl: %s: relocate: could not allocate new transaction (%d)\n&quot;</span>, jnl-&gt;jdev_name, ret);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_journal</span>;
	}
	
	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">bad_journal</span>:
	jnl-&gt;flags |= JOURNAL_INVALID;
	abort_transaction(jnl, tr);
	<span class="enscript-keyword">return</span> ret;
}

uint32_t <span class="enscript-function-name">journal_current_txn</span>(journal *jnl)
{
	<span class="enscript-keyword">return</span> jnl-&gt;sequence_num + (jnl-&gt;active_tr || jnl-&gt;cur_tr ? 0 : 1);
}

#<span class="enscript-reference">else</span>   // !<span class="enscript-variable-name">JOURNALING</span> - <span class="enscript-variable-name">so</span> <span class="enscript-variable-name">provide</span> <span class="enscript-variable-name">stub</span> <span class="enscript-variable-name">functions</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">journal_uses_fua</span>(__unused journal *jnl)
{
	<span class="enscript-keyword">return</span> 0;
}

journal *
<span class="enscript-function-name">journal_create</span>(__unused <span class="enscript-type">struct</span> vnode *jvp,
	       __unused off_t         offset,
	       __unused off_t         journal_size,
	       __unused <span class="enscript-type">struct</span> vnode *fsvp,
	       __unused size_t        min_fs_blksz,
	       __unused int32_t       flags,
	       __unused int32_t       tbuffer_size,
	       __unused <span class="enscript-type">void</span>        (*flush)(<span class="enscript-type">void</span> *arg),
	       __unused <span class="enscript-type">void</span>         *arg,
	       __unused <span class="enscript-type">struct</span> mount *fsmount)
{
    <span class="enscript-keyword">return</span> NULL;
}

journal *
<span class="enscript-function-name">journal_open</span>(__unused <span class="enscript-type">struct</span> vnode *jvp,
	     __unused off_t         offset,
	     __unused off_t         journal_size,
	     __unused <span class="enscript-type">struct</span> vnode *fsvp,
	     __unused size_t        min_fs_blksz,
	     __unused int32_t       flags,
	     __unused int32_t       tbuffer_size,
	     __unused <span class="enscript-type">void</span>        (*flush)(<span class="enscript-type">void</span> *arg),
	     __unused <span class="enscript-type">void</span>         *arg,
	     __unused <span class="enscript-type">struct</span> mount *fsmount)
{
	<span class="enscript-keyword">return</span> NULL;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_modify_block_start</span>(__unused journal *jnl, __unused <span class="enscript-type">struct</span> buf *bp)
{
	<span class="enscript-keyword">return</span> EINVAL;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_modify_block_end</span>(__unused journal *jnl,
			 __unused <span class="enscript-type">struct</span> buf *bp,
			 __unused <span class="enscript-type">void</span> (*func)(<span class="enscript-type">struct</span> buf *bp, <span class="enscript-type">void</span> *arg),
			 __unused <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-keyword">return</span> EINVAL;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_kill_block</span>(__unused journal *jnl, __unused <span class="enscript-type">struct</span> buf *bp)
{
	<span class="enscript-keyword">return</span> EINVAL;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">journal_relocate</span>(__unused journal *jnl,
		     __unused off_t offset,
		     __unused off_t journal_size,
		     __unused int32_t tbuffer_size,
		     __unused errno_t (*callback)(<span class="enscript-type">void</span> *),
		     __unused <span class="enscript-type">void</span> *callback_arg)
{
	<span class="enscript-keyword">return</span> EINVAL;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">journal_close</span>(__unused journal *jnl)
{
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_start_transaction</span>(__unused journal *jnl)
{
	<span class="enscript-keyword">return</span> EINVAL;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_end_transaction</span>(__unused journal *jnl)
{
	<span class="enscript-keyword">return</span> EINVAL;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_flush</span>(__unused journal *jnl, __unused journal_flush_options_t options)
{
	<span class="enscript-keyword">return</span> EINVAL;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_is_clean</span>(__unused <span class="enscript-type">struct</span> vnode *jvp,
		 __unused off_t         offset,
		 __unused off_t         journal_size,
		 __unused <span class="enscript-type">struct</span> vnode *fsvp,
                 __unused size_t        min_fs_block_size)
{
	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">void</span> *
<span class="enscript-function-name">journal_owner</span>(__unused journal *jnl)
{
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">journal_lock</span>(__unused journal *jnl) 
{
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">journal_unlock</span>(__unused journal *jnl)
{
	<span class="enscript-keyword">return</span>;
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">journal_trim_add_extent</span>(__unused journal *jnl, 
			__unused uint64_t offset, 
			__unused uint64_t length)
{
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">journal_request_immediate_flush</span>(__unused journal *jnl) 
{
	<span class="enscript-keyword">return</span> 0;
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">journal_trim_remove_extent</span>(__unused journal *jnl, 
			   __unused uint64_t offset, 
			   __unused uint64_t length)
{
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">journal_trim_extent_overlap</span>(__unused journal *jnl, 
				__unused uint64_t offset, 
				__unused uint64_t length, 
				__unused uint64_t *end) 
{
	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">endif</span>  // !<span class="enscript-variable-name">JOURNALING</span>
</pre>
<hr />
</body></html>