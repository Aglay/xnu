<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_fsevents.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_fsevents.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/event.h&gt;</span>         // for kqueue related stuff
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsevents.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dirent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/attr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/cons.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit_kevents.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> kfs_event {
    LIST_ENTRY(kfs_event) kevent_list;
    int16_t        type;           <span class="enscript-comment">// type code of this event
</span>    u_int16_t      flags,          <span class="enscript-comment">// per-event flags
</span>                   len;            <span class="enscript-comment">// the length of the path in &quot;str&quot;
</span>    int32_t        refcount;       <span class="enscript-comment">// number of clients referencing this
</span>    pid_t          pid;            <span class="enscript-comment">// pid of the process that did the op
</span>
    uint64_t       abstime;        <span class="enscript-comment">// when this event happened (mach_absolute_time())
</span>    ino64_t        ino;
    dev_t          dev;
    int32_t        mode;
    uid_t          uid;
    gid_t          gid;

    <span class="enscript-type">const</span> <span class="enscript-type">char</span>    *str;

    <span class="enscript-type">struct</span> kfs_event *dest;    <span class="enscript-comment">// if this is a two-file op
</span>} kfs_event;

<span class="enscript-comment">// flags for the flags field
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KFSE_COMBINED_EVENTS</span>          0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KFSE_CONTAINS_DROPPED_EVENTS</span>  0x0002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KFSE_RECYCLED_EVENT</span>           0x0004
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KFSE_BEING_CREATED</span>            0x0008

<span class="enscript-function-name">LIST_HEAD</span>(kfse_list, kfs_event) kfse_list_head = LIST_HEAD_INITIALIZER(x);
<span class="enscript-type">int</span> num_events_outstanding = 0;
<span class="enscript-type">int</span> num_pending_rename = 0;


<span class="enscript-type">struct</span> fsevent_handle;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> fs_event_watcher {
    int8_t      *event_list;             <span class="enscript-comment">// the events we're interested in
</span>    int32_t      num_events;
    dev_t       *devices_not_to_watch;   <span class="enscript-comment">// report events from devices not in this list
</span>    uint32_t     num_devices;
    int32_t      flags;
    kfs_event  **event_queue;
    int32_t      eventq_size;            <span class="enscript-comment">// number of event pointers in queue
</span>    int32_t      num_readers;
    int32_t      rd;                     <span class="enscript-comment">// read index into the event_queue
</span>    int32_t      wr;                     <span class="enscript-comment">// write index into the event_queue
</span>    int32_t      blockers;
    int32_t      my_id;
    uint32_t     num_dropped;
    uint64_t     max_event_id;
    <span class="enscript-type">struct</span> fsevent_handle *fseh;
    pid_t        pid;
    <span class="enscript-type">char</span>         proc_name[(2 * MAXCOMLEN) + 1];
} fs_event_watcher;

<span class="enscript-comment">// fs_event_watcher flags
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WATCHER_DROPPED_EVENTS</span>         0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WATCHER_CLOSING</span>                0x0002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WATCHER_WANTS_COMPACT_EVENTS</span>   0x0004
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WATCHER_WANTS_EXTENDED_INFO</span>    0x0008
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WATCHER_APPLE_SYSTEM_SERVICE</span>   0x0010   // fseventsd, coreservicesd, mds

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_WATCHERS</span>  8
<span class="enscript-type">static</span> fs_event_watcher *watcher_table[MAX_WATCHERS];

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_MAX_KFS_EVENTS</span>   4096
<span class="enscript-type">static</span> <span class="enscript-type">int</span> max_kfs_events = DEFAULT_MAX_KFS_EVENTS;

<span class="enscript-comment">// we allocate kfs_event structures out of this zone
</span><span class="enscript-type">static</span> zone_t     event_zone;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>        fs_event_init = 0;

<span class="enscript-comment">//
</span><span class="enscript-comment">// this array records whether anyone is interested in a
</span><span class="enscript-comment">// particular type of event.  if no one is, we bail out
</span><span class="enscript-comment">// early from the event delivery
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> int16_t     fs_event_type_watchers[FSE_MAX_EVENTS];

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">watcher_add_event</span>(fs_event_watcher *watcher, kfs_event *kfse);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">fsevents_wakeup</span>(fs_event_watcher *watcher);

<span class="enscript-comment">//
</span><span class="enscript-comment">// Locks
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> lck_grp_attr_t *  fsevent_group_attr;
<span class="enscript-type">static</span> lck_attr_t *      fsevent_lock_attr;
<span class="enscript-type">static</span> lck_grp_t *       fsevent_mutex_group;

<span class="enscript-type">static</span> lck_grp_t *       fsevent_rw_group;

<span class="enscript-type">static</span> lck_rw_t  event_handling_lock; <span class="enscript-comment">// handles locking for event manipulation and recycling
</span><span class="enscript-type">static</span> lck_mtx_t watch_table_lock;
<span class="enscript-type">static</span> lck_mtx_t event_buf_lock;
<span class="enscript-type">static</span> lck_mtx_t event_writer_lock;


<span class="enscript-comment">/* Explicitly declare qsort so compiler doesn't complain */</span>
__private_extern__ <span class="enscript-type">void</span> qsort(
    <span class="enscript-type">void</span> * array,
    size_t nmembers,
    size_t member_size,
    <span class="enscript-type">int</span> (*)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *));

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">is_ignored_directory</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path) {

    <span class="enscript-keyword">if</span> (!path) {
      <span class="enscript-keyword">return</span> 0;
    }

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_TLD</span>(x) strnstr(__DECONST(char *, path), x, MAXPATHLEN)
    <span class="enscript-keyword">if</span> (IS_TLD(<span class="enscript-string">&quot;/.Spotlight-V100/&quot;</span>) ||
        IS_TLD(<span class="enscript-string">&quot;/.MobileBackups/&quot;</span>) || 
        IS_TLD(<span class="enscript-string">&quot;/Backups.backupdb/&quot;</span>)) {
        <span class="enscript-keyword">return</span> 1;
    }
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">IS_TLD</span>
	
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">fsevents_internal_init</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> i;
    
    <span class="enscript-keyword">if</span> (fs_event_init++ != 0) {
	<span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">for</span>(i=0; i &lt; FSE_MAX_EVENTS; i++) {
	fs_event_type_watchers[i] = 0;
    }

    memset(watcher_table, 0, <span class="enscript-keyword">sizeof</span>(watcher_table));

    fsevent_lock_attr    = lck_attr_alloc_init();
    fsevent_group_attr   = lck_grp_attr_alloc_init();
    fsevent_mutex_group  = lck_grp_alloc_init(<span class="enscript-string">&quot;fsevent-mutex&quot;</span>, fsevent_group_attr);
    fsevent_rw_group     = lck_grp_alloc_init(<span class="enscript-string">&quot;fsevent-rw&quot;</span>, fsevent_group_attr);

    lck_mtx_init(&amp;watch_table_lock, fsevent_mutex_group, fsevent_lock_attr);
    lck_mtx_init(&amp;event_buf_lock, fsevent_mutex_group, fsevent_lock_attr);
    lck_mtx_init(&amp;event_writer_lock, fsevent_mutex_group, fsevent_lock_attr);

    lck_rw_init(&amp;event_handling_lock, fsevent_rw_group, fsevent_lock_attr);

    PE_get_default(<span class="enscript-string">&quot;kern.maxkfsevents&quot;</span>, &amp;max_kfs_events, <span class="enscript-keyword">sizeof</span>(max_kfs_events));

    event_zone = zinit(<span class="enscript-keyword">sizeof</span>(kfs_event),
	               max_kfs_events * <span class="enscript-keyword">sizeof</span>(kfs_event),
	               max_kfs_events * <span class="enscript-keyword">sizeof</span>(kfs_event),
	               <span class="enscript-string">&quot;fs-event-buf&quot;</span>);
    <span class="enscript-keyword">if</span> (event_zone == NULL) {
	printf(<span class="enscript-string">&quot;fsevents: failed to initialize the event zone.\n&quot;</span>);
    }

    <span class="enscript-comment">// mark the zone as exhaustible so that it will not
</span>    <span class="enscript-comment">// ever grow beyond what we initially filled it with
</span>    zone_change(event_zone, Z_EXHAUST, TRUE);
    zone_change(event_zone, Z_COLLECT, FALSE);
    zone_change(event_zone, Z_CALLERACCT, FALSE);

    <span class="enscript-keyword">if</span> (zfill(event_zone, max_kfs_events) &lt; max_kfs_events) {
	printf(<span class="enscript-string">&quot;fsevents: failed to pre-fill the event zone.\n&quot;</span>);	
    }
    
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lock_watch_table</span>(<span class="enscript-type">void</span>)
{
    lck_mtx_lock(&amp;watch_table_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">unlock_watch_table</span>(<span class="enscript-type">void</span>)
{
    lck_mtx_unlock(&amp;watch_table_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lock_fs_event_list</span>(<span class="enscript-type">void</span>)
{
    lck_mtx_lock(&amp;event_buf_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">unlock_fs_event_list</span>(<span class="enscript-type">void</span>)
{
    lck_mtx_unlock(&amp;event_buf_lock);
}

<span class="enscript-comment">// forward prototype
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">release_event_ref</span>(kfs_event *kfse);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">watcher_cares_about_dev</span>(fs_event_watcher *watcher, dev_t dev)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
    
    <span class="enscript-comment">// if devices_not_to_watch is NULL then we care about all
</span>    <span class="enscript-comment">// events from all devices
</span>    <span class="enscript-keyword">if</span> (watcher-&gt;devices_not_to_watch == NULL) {
	<span class="enscript-keyword">return</span> 1;
    }

    <span class="enscript-keyword">for</span>(i=0; i &lt; watcher-&gt;num_devices; i++) {
	<span class="enscript-keyword">if</span> (dev == watcher-&gt;devices_not_to_watch[i]) {
	    <span class="enscript-comment">// found a match! that means we do not 
</span>	    <span class="enscript-comment">// want events from this device.
</span>	    <span class="enscript-keyword">return</span> 0;
	}
    }

    <span class="enscript-comment">// if we're here it's not in the devices_not_to_watch[] 
</span>    <span class="enscript-comment">// list so that means we do care about it
</span>    <span class="enscript-keyword">return</span> 1;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">need_fsevent</span>(<span class="enscript-type">int</span> type, vnode_t vp)
{
    <span class="enscript-keyword">if</span> (type &gt;= 0 &amp;&amp; type &lt; FSE_MAX_EVENTS &amp;&amp; fs_event_type_watchers[type] == 0)
	<span class="enscript-keyword">return</span> (0);

    <span class="enscript-comment">// events in /dev aren't really interesting...
</span>    <span class="enscript-keyword">if</span> (vp-&gt;v_tag == VT_DEVFS) {
	<span class="enscript-keyword">return</span> (0);
    }

    <span class="enscript-keyword">return</span> 1;
}


#<span class="enscript-reference">define</span> <span class="enscript-function-name">is_throw_away</span>(x)  ((x) == FSE_STAT_CHANGED || (x) == FSE_CONTENT_MODIFIED)


<span class="enscript-comment">// Ways that an event can be reused:
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// &quot;combined&quot; events mean that there were two events for 
</span><span class="enscript-comment">// the same vnode or path and we're combining both events 
</span><span class="enscript-comment">// into a single event.  The primary event gets a bit that
</span><span class="enscript-comment">// marks it as having been combined.  The secondary event 
</span><span class="enscript-comment">// is essentially dropped and the kfse structure reused.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// &quot;collapsed&quot; means that multiple events below a given
</span><span class="enscript-comment">// directory are collapsed into a single event.  in this
</span><span class="enscript-comment">// case, the directory that we collapse into and all of
</span><span class="enscript-comment">// its children must be re-scanned.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// &quot;recycled&quot; means that we're completely blowing away 
</span><span class="enscript-comment">// the event since there are other events that have info 
</span><span class="enscript-comment">// about the same vnode or path (and one of those other 
</span><span class="enscript-comment">// events will be marked as combined or collapsed as
</span><span class="enscript-comment">// appropriate).
</span><span class="enscript-comment">//
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KFSE_COMBINED</span>   0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KFSE_COLLAPSED</span>  0x0002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KFSE_RECYCLED</span>   0x0004

<span class="enscript-type">int</span> num_dropped         = 0;
<span class="enscript-type">int</span> num_parent_switch   = 0;
<span class="enscript-type">int</span> num_recycled_rename = 0;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> timeval last_print;

<span class="enscript-comment">//
</span><span class="enscript-comment">// These variables are used to track coalescing multiple identical
</span><span class="enscript-comment">// events for the same vnode/pathname.  If we get the same event
</span><span class="enscript-comment">// type and same vnode/pathname as the previous event, we just drop
</span><span class="enscript-comment">// the event since it's superfluous.  This improves some micro-
</span><span class="enscript-comment">// benchmarks considerably and actually has a real-world impact on
</span><span class="enscript-comment">// tests like a Finder copy where multiple stat-changed events can
</span><span class="enscript-comment">// get coalesced.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>     last_event_type=-1;
<span class="enscript-type">static</span> <span class="enscript-type">void</span>   *last_ptr=NULL;
<span class="enscript-type">static</span> <span class="enscript-type">char</span>    last_str[MAXPATHLEN];
<span class="enscript-type">static</span> <span class="enscript-type">int</span>     last_nlen=0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>     last_vid=-1;
<span class="enscript-type">static</span> uint64_t last_coalesced_time=0;
<span class="enscript-type">static</span> <span class="enscript-type">void</span>   *last_event_ptr=NULL;
<span class="enscript-type">int</span>            last_coalesced = 0;
<span class="enscript-type">static</span> mach_timebase_info_data_t    sTimebaseInfo = { 0, 0 };


<span class="enscript-type">int</span>
<span class="enscript-function-name">add_fsevent</span>(<span class="enscript-type">int</span> type, vfs_context_t ctx, ...) 
{
    <span class="enscript-type">struct</span> proc	     *p = vfs_context_proc(ctx);
    <span class="enscript-type">int</span>               i, arg_type, ret;
    kfs_event        *kfse, *kfse_dest=NULL, *cur;
    fs_event_watcher *watcher;
    va_list           ap;
    <span class="enscript-type">int</span> 	      error = 0, did_alloc=0;
    dev_t             dev = 0;
    uint64_t          now, elapsed;
    <span class="enscript-type">char</span>             *pathbuff=NULL;
    <span class="enscript-type">int</span>               pathbuff_len;



    va_start(ap, ctx);

    <span class="enscript-comment">// ignore bogus event types..
</span>    <span class="enscript-keyword">if</span> (type &lt; 0 || type &gt;= FSE_MAX_EVENTS) {
	<span class="enscript-keyword">return</span> EINVAL;
    }

    <span class="enscript-comment">// if no one cares about this type of event, bail out
</span>    <span class="enscript-keyword">if</span> (fs_event_type_watchers[type] == 0) {
	va_end(ap);

	<span class="enscript-keyword">return</span> 0;
    }

    now = mach_absolute_time();

    <span class="enscript-comment">// find a free event and snag it for our use
</span>    <span class="enscript-comment">// NOTE: do not do anything that would block until
</span>    <span class="enscript-comment">//       the lock is dropped.
</span>    lock_fs_event_list();
    
    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// check if this event is identical to the previous one...
</span>    <span class="enscript-comment">// (as long as it's not an event type that can never be the
</span>    <span class="enscript-comment">// same as a previous event)
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-keyword">if</span> (type != FSE_CREATE_FILE &amp;&amp; type != FSE_DELETE &amp;&amp; type != FSE_RENAME &amp;&amp; type != FSE_EXCHANGE &amp;&amp; type != FSE_CHOWN &amp;&amp; type != FSE_DOCID_CHANGED &amp;&amp; type != FSE_DOCID_CREATED) {
	<span class="enscript-type">void</span> *ptr=NULL;
	<span class="enscript-type">int</span>   vid=0, was_str=0, nlen=0;

	<span class="enscript-keyword">for</span>(arg_type=va_arg(ap, int32_t); arg_type != FSE_ARG_DONE; arg_type=va_arg(ap, int32_t)) {
	    <span class="enscript-keyword">switch</span>(arg_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSE_ARG_VNODE</span>: {
		    ptr = va_arg(ap, <span class="enscript-type">void</span> *);
		    vid = vnode_vid((<span class="enscript-type">struct</span> vnode *)ptr);
		    last_str[0] = <span class="enscript-string">'\0'</span>;
		    <span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FSE_ARG_STRING</span>: {
		    nlen = va_arg(ap, int32_t);
		    ptr = va_arg(ap, <span class="enscript-type">void</span> *);
		    was_str = 1;
		    <span class="enscript-keyword">break</span>;
		}
	    }
	    <span class="enscript-keyword">if</span> (ptr != NULL) {
		<span class="enscript-keyword">break</span>;
	    }
	}

	<span class="enscript-keyword">if</span> ( sTimebaseInfo.denom == 0 ) {
	    (<span class="enscript-type">void</span>) clock_timebase_info(&amp;sTimebaseInfo);
	}
	
	elapsed = (now - last_coalesced_time);
	<span class="enscript-keyword">if</span> (sTimebaseInfo.denom != sTimebaseInfo.numer) {
	    <span class="enscript-keyword">if</span> (sTimebaseInfo.denom == 1) {
		elapsed *= sTimebaseInfo.numer;
	    } <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// this could overflow... the worst that will happen is that we'll
</span>		<span class="enscript-comment">// send (or not send) an extra event so I'm not going to worry about
</span>		<span class="enscript-comment">// doing the math right like dtrace_abs_to_nano() does.
</span>		elapsed = (elapsed * sTimebaseInfo.numer) / (uint64_t)sTimebaseInfo.denom;
	    }
	}
	
	<span class="enscript-keyword">if</span> (type == last_event_type
            &amp;&amp; (elapsed &lt; 1000000000)
	    &amp;&amp; 
	    ((vid &amp;&amp; vid == last_vid &amp;&amp; last_ptr == ptr)
	      ||
	     (last_str[0] &amp;&amp; last_nlen == nlen &amp;&amp; ptr &amp;&amp; strcmp(last_str, ptr) == 0))
	   ) {
	    
	    last_coalesced++;
	    unlock_fs_event_list();
	    va_end(ap);

	    <span class="enscript-keyword">return</span> 0;
	} <span class="enscript-keyword">else</span> {
	    last_ptr = ptr;
	    <span class="enscript-keyword">if</span> (was_str) {
		strlcpy(last_str, ptr, <span class="enscript-keyword">sizeof</span>(last_str));
	    }
	    last_nlen = nlen;
	    last_vid = vid;
	    last_event_type = type;
	    last_coalesced_time = now;
	}
    }
    va_start(ap, ctx);


    kfse = zalloc_noblock(event_zone);
    <span class="enscript-keyword">if</span> (kfse &amp;&amp; (type == FSE_RENAME || type == FSE_EXCHANGE)) {
	kfse_dest = zalloc_noblock(event_zone);
	<span class="enscript-keyword">if</span> (kfse_dest == NULL) {
	    did_alloc = 1;
	    zfree(event_zone, kfse);
	    kfse = NULL;
	}
    }


    <span class="enscript-keyword">if</span> (kfse == NULL) {        <span class="enscript-comment">// yikes! no free events
</span>	    unlock_fs_event_list();
	    lock_watch_table();

	    <span class="enscript-keyword">for</span>(i=0; i &lt; MAX_WATCHERS; i++) {
		watcher = watcher_table[i];
		<span class="enscript-keyword">if</span> (watcher == NULL) {
		    <span class="enscript-keyword">continue</span>;
		}

		watcher-&gt;flags |= WATCHER_DROPPED_EVENTS;
		fsevents_wakeup(watcher);
	    }
	    unlock_watch_table();

	    {	    
		<span class="enscript-type">struct</span> timeval current_tv;

		num_dropped++;

		<span class="enscript-comment">// only print a message at most once every 5 seconds
</span>		microuptime(&amp;current_tv);
		<span class="enscript-keyword">if</span> ((current_tv.tv_sec - last_print.tv_sec) &gt; 10) {
		    <span class="enscript-type">int</span> ii;
		    <span class="enscript-type">void</span> *junkptr=zalloc_noblock(event_zone), *listhead=kfse_list_head.lh_first;
		    
		    printf(<span class="enscript-string">&quot;add_fsevent: event queue is full! dropping events (num dropped events: %d; num events outstanding: %d).\n&quot;</span>, num_dropped, num_events_outstanding);
		    printf(<span class="enscript-string">&quot;add_fsevent: kfse_list head %p ; num_pending_rename %d\n&quot;</span>, listhead, num_pending_rename);
		    printf(<span class="enscript-string">&quot;add_fsevent: zalloc sez: %p\n&quot;</span>, junkptr);
		    printf(<span class="enscript-string">&quot;add_fsevent: event_zone info: %d 0x%x\n&quot;</span>, ((<span class="enscript-type">int</span> *)event_zone)[0], ((<span class="enscript-type">int</span> *)event_zone)[1]);
		    lock_watch_table();
		    <span class="enscript-keyword">for</span>(ii=0; ii &lt; MAX_WATCHERS; ii++) {
			<span class="enscript-keyword">if</span> (watcher_table[ii] == NULL) {
			    <span class="enscript-keyword">continue</span>;
			}
			
			printf(<span class="enscript-string">&quot;add_fsevent: watcher %s %p: rd %4d wr %4d q_size %4d flags 0x%x\n&quot;</span>,
			       watcher_table[ii]-&gt;proc_name,
			       watcher_table[ii],
			       watcher_table[ii]-&gt;rd, watcher_table[ii]-&gt;wr,
			       watcher_table[ii]-&gt;eventq_size, watcher_table[ii]-&gt;flags);
		    }
		    unlock_watch_table();

		    last_print = current_tv;
		    <span class="enscript-keyword">if</span> (junkptr) {
			zfree(event_zone, junkptr);
		    }
		}
	    }

	    <span class="enscript-keyword">if</span> (pathbuff) {
		release_pathbuff(pathbuff);
		pathbuff = NULL;
	    }
	    <span class="enscript-keyword">return</span> ENOSPC;
	}

    memset(kfse, 0, <span class="enscript-keyword">sizeof</span>(kfs_event));
    kfse-&gt;refcount = 1;
    OSBitOrAtomic16(KFSE_BEING_CREATED, &amp;kfse-&gt;flags);

    last_event_ptr = kfse;
    kfse-&gt;type     = type;
    kfse-&gt;abstime  = now;
    kfse-&gt;pid      = p-&gt;p_pid;
    <span class="enscript-keyword">if</span> (type == FSE_RENAME || type == FSE_EXCHANGE) {
	memset(kfse_dest, 0, <span class="enscript-keyword">sizeof</span>(kfs_event));
	kfse_dest-&gt;refcount = 1;
	OSBitOrAtomic16(KFSE_BEING_CREATED, &amp;kfse_dest-&gt;flags);
	kfse_dest-&gt;type     = type;
	kfse_dest-&gt;pid      = p-&gt;p_pid;
	kfse_dest-&gt;abstime  = now;
	
	kfse-&gt;dest = kfse_dest;
    }
    
    num_events_outstanding++;
    <span class="enscript-keyword">if</span> (kfse-&gt;type == FSE_RENAME) {
	num_pending_rename++;
    }
    LIST_INSERT_HEAD(&amp;kfse_list_head, kfse, kevent_list);

    <span class="enscript-keyword">if</span> (kfse-&gt;refcount &lt; 1) {
	panic(<span class="enscript-string">&quot;add_fsevent: line %d: kfse recount %d but should be at least 1\n&quot;</span>, __LINE__, kfse-&gt;refcount);
    }

    unlock_fs_event_list();  <span class="enscript-comment">// at this point it's safe to unlock
</span>
    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// now process the arguments passed in and copy them into
</span>    <span class="enscript-comment">// the kfse
</span>    <span class="enscript-comment">//
</span>    
    cur = kfse;

    <span class="enscript-keyword">if</span> (type == FSE_DOCID_CREATED || type == FSE_DOCID_CHANGED) {
	    uint64_t val;

	    <span class="enscript-comment">//
</span>	    <span class="enscript-comment">// These events are special and not like the other events.  They only
</span>	    <span class="enscript-comment">// have a dev_t, src inode #, dest inode #, and a doc-id.  We use the
</span>	    <span class="enscript-comment">// fields that we can in the kfse but have to overlay the dest inode
</span>	    <span class="enscript-comment">// number and the doc-id on the other fields.
</span>	    <span class="enscript-comment">//
</span>
	    <span class="enscript-comment">// First the dev_t
</span>	    arg_type = va_arg(ap, int32_t);
	    <span class="enscript-keyword">if</span> (arg_type == FSE_ARG_DEV) {
		    cur-&gt;dev = (dev_t)(va_arg(ap, dev_t));
	    } <span class="enscript-keyword">else</span> {
		    cur-&gt;dev = (dev_t)0xbadc0de1;
	    }

	    <span class="enscript-comment">// next the source inode #
</span>	    arg_type = va_arg(ap, int32_t);
	    <span class="enscript-keyword">if</span> (arg_type == FSE_ARG_INO) {
		    cur-&gt;ino = (ino64_t)(va_arg(ap, ino64_t));
	    } <span class="enscript-keyword">else</span> {
		    cur-&gt;ino = 0xbadc0de2;
	    }

	    <span class="enscript-comment">// now the dest inode #
</span>	    arg_type = va_arg(ap, int32_t);
	    <span class="enscript-keyword">if</span> (arg_type == FSE_ARG_INO) {
		    val = (ino64_t)(va_arg(ap, ino64_t));
	    } <span class="enscript-keyword">else</span> {
		    val = 0xbadc0de2;
	    }
	    <span class="enscript-comment">// overlay the dest inode number on the str/dest pointer fields
</span>	    memcpy(&amp;cur-&gt;str, &amp;val, <span class="enscript-keyword">sizeof</span>(ino64_t));


	    <span class="enscript-comment">// and last the document-id
</span>	    arg_type = va_arg(ap, int32_t);
	    <span class="enscript-keyword">if</span> (arg_type == FSE_ARG_INT32) {
		    val = (uint64_t)va_arg(ap, uint32_t);
	    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (arg_type == FSE_ARG_INT64) {
		    val = (uint64_t)va_arg(ap, uint64_t);
	    } <span class="enscript-keyword">else</span> {
		    val = 0xbadc0de3;
	    }
	    
	    <span class="enscript-comment">// the docid is 64-bit and overlays the uid/gid fields
</span>	    memcpy(&amp;cur-&gt;uid, &amp;val, <span class="enscript-keyword">sizeof</span>(uint64_t));

	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">done_with_args</span>;
    }

    <span class="enscript-keyword">for</span>(arg_type=va_arg(ap, int32_t); arg_type != FSE_ARG_DONE; arg_type=va_arg(ap, int32_t))

	<span class="enscript-keyword">switch</span>(arg_type) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">FSE_ARG_VNODE</span>: {
		<span class="enscript-comment">// this expands out into multiple arguments to the client
</span>		<span class="enscript-type">struct</span> vnode *vp;
		<span class="enscript-type">struct</span> vnode_attr va;

		<span class="enscript-keyword">if</span> (kfse-&gt;str != NULL) {
		    cur = kfse_dest;
		}

		vp = va_arg(ap, <span class="enscript-type">struct</span> vnode *);
		<span class="enscript-keyword">if</span> (vp == NULL) {
		    panic(<span class="enscript-string">&quot;add_fsevent: you can't pass me a NULL vnode ptr (type %d)!\n&quot;</span>,
			  cur-&gt;type);
		}

		VATTR_INIT(&amp;va);
		VATTR_WANTED(&amp;va, va_fsid);
		VATTR_WANTED(&amp;va, va_fileid);
		VATTR_WANTED(&amp;va, va_mode);
		VATTR_WANTED(&amp;va, va_uid);
		VATTR_WANTED(&amp;va, va_gid);
		VATTR_WANTED(&amp;va, va_nlink);
		<span class="enscript-keyword">if</span> ((ret = vnode_getattr(vp, &amp;va, vfs_context_kernel())) != 0) {
		    <span class="enscript-comment">// printf(&quot;add_fsevent: failed to getattr on vp %p (%d)\n&quot;, cur-&gt;fref.vp, ret);
</span>		    cur-&gt;str = NULL;
		    error = EINVAL;
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">clean_up</span>;
		}

		cur-&gt;dev  = dev = (dev_t)va.va_fsid;
		cur-&gt;ino  = (ino64_t)va.va_fileid;
		cur-&gt;mode = (int32_t)vnode_vttoif(vnode_vtype(vp)) | va.va_mode;
		cur-&gt;uid  = va.va_uid;
		cur-&gt;gid  = va.va_gid;
		<span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISHARDLINK) {
			cur-&gt;mode |= FSE_MODE_HLINK;
			<span class="enscript-keyword">if</span> ((vp-&gt;v_type == VDIR &amp;&amp; va.va_dirlinkcount == 0) || (vp-&gt;v_type == VREG &amp;&amp; va.va_nlink == 0)) {
				cur-&gt;mode |= FSE_MODE_LAST_HLINK;
			}
		}

		<span class="enscript-comment">// if we haven't gotten the path yet, get it.
</span>		<span class="enscript-keyword">if</span> (pathbuff == NULL) {
		    pathbuff = get_pathbuff();
		    pathbuff_len = MAXPATHLEN;
		    
		    pathbuff[0] = <span class="enscript-string">'\0'</span>;
		    <span class="enscript-keyword">if</span> ((ret = vn_getpath(vp, pathbuff, &amp;pathbuff_len)) != 0 || pathbuff[0] == <span class="enscript-string">'\0'</span>) {
			
			cur-&gt;flags |= KFSE_CONTAINS_DROPPED_EVENTS;
			
			<span class="enscript-keyword">do</span> {
				<span class="enscript-keyword">if</span> (vp-&gt;v_parent != NULL) {
					vp = vp-&gt;v_parent;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vp-&gt;v_mount) {
					strlcpy(pathbuff, vp-&gt;v_mount-&gt;mnt_vfsstat.f_mntonname, MAXPATHLEN);
					<span class="enscript-keyword">break</span>;
				} <span class="enscript-keyword">else</span> {
					vp = NULL;
				}

				<span class="enscript-keyword">if</span> (vp == NULL) {
					<span class="enscript-keyword">break</span>;
				}

				pathbuff_len = MAXPATHLEN;
				ret = vn_getpath(vp, pathbuff, &amp;pathbuff_len);
			} <span class="enscript-keyword">while</span> (ret == ENOSPC);
				
			<span class="enscript-keyword">if</span> (ret != 0 || vp == NULL) {
				error = ENOENT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">clean_up</span>;
			}
		    }
		}

		<span class="enscript-comment">// store the path by adding it to the global string table
</span>		cur-&gt;len = pathbuff_len;
		cur-&gt;str = vfs_addname(pathbuff, pathbuff_len, 0, 0);
		<span class="enscript-keyword">if</span> (cur-&gt;str == NULL || cur-&gt;str[0] == <span class="enscript-string">'\0'</span>) {
		    panic(<span class="enscript-string">&quot;add_fsevent: was not able to add path %s to event %p.\n&quot;</span>, pathbuff, cur);
		}
		
		release_pathbuff(pathbuff);
		pathbuff = NULL;

		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">FSE_ARG_FINFO</span>: {
		fse_info *fse;
		
		fse = va_arg(ap, fse_info *);
		
		cur-&gt;dev  = dev = (dev_t)fse-&gt;dev;
		cur-&gt;ino  = (ino64_t)fse-&gt;ino;
		cur-&gt;mode = (int32_t)fse-&gt;mode;
		cur-&gt;uid  = (uid_t)fse-&gt;uid;
		cur-&gt;gid  = (uid_t)fse-&gt;gid;
		<span class="enscript-comment">// if it's a hard-link and this is the last link, flag it
</span>		<span class="enscript-keyword">if</span> ((fse-&gt;mode &amp; FSE_MODE_HLINK) &amp;&amp; fse-&gt;nlink == 0) {
		    cur-&gt;mode |= FSE_MODE_LAST_HLINK;
		}
		<span class="enscript-keyword">if</span> (cur-&gt;mode &amp; FSE_TRUNCATED_PATH) {
			cur-&gt;flags |= KFSE_CONTAINS_DROPPED_EVENTS;
			cur-&gt;mode &amp;= ~FSE_TRUNCATED_PATH;
		}
		<span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">FSE_ARG_STRING</span>:
		<span class="enscript-keyword">if</span> (kfse-&gt;str != NULL) {
		    cur = kfse_dest;
		}

		cur-&gt;len = (int16_t)(va_arg(ap, int32_t) &amp; 0x7fff);
		<span class="enscript-keyword">if</span> (cur-&gt;len &gt;= 1) {
		    cur-&gt;str = vfs_addname(va_arg(ap, <span class="enscript-type">char</span> *), cur-&gt;len, 0, 0);
		} <span class="enscript-keyword">else</span> {
		    printf(<span class="enscript-string">&quot;add_fsevent: funny looking string length: %d\n&quot;</span>, (<span class="enscript-type">int</span>)cur-&gt;len);
		    cur-&gt;len = 2;
		    cur-&gt;str = vfs_addname(<span class="enscript-string">&quot;/&quot;</span>, cur-&gt;len, 0, 0);
		}
		<span class="enscript-keyword">if</span> (cur-&gt;str[0] == 0) {
		    printf(<span class="enscript-string">&quot;add_fsevent: bogus looking string (len %d)\n&quot;</span>, cur-&gt;len);
		}
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">FSE_ARG_INT32</span>: {
		    uint32_t ival = (uint32_t)va_arg(ap, int32_t);
		    kfse-&gt;uid = (ino64_t)ival;
		<span class="enscript-keyword">break</span>;
	    }
		    
	    <span class="enscript-reference">default</span>:
		printf(<span class="enscript-string">&quot;add_fsevent: unknown type %d\n&quot;</span>, arg_type);
		<span class="enscript-comment">// just skip one 32-bit word and hope we sync up...
</span>		(<span class="enscript-type">void</span>)va_arg(ap, int32_t);
	}

<span class="enscript-reference">done_with_args</span>:
    va_end(ap);

    OSBitAndAtomic16(~KFSE_BEING_CREATED, &amp;kfse-&gt;flags);
    <span class="enscript-keyword">if</span> (kfse_dest) {
	OSBitAndAtomic16(~KFSE_BEING_CREATED, &amp;kfse_dest-&gt;flags);
    }

    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// now we have to go and let everyone know that
</span>    <span class="enscript-comment">// is interested in this type of event
</span>    <span class="enscript-comment">//
</span>    lock_watch_table();
    
    <span class="enscript-keyword">for</span>(i=0; i &lt; MAX_WATCHERS; i++) {
	watcher = watcher_table[i];
	<span class="enscript-keyword">if</span> (watcher == NULL) {
	    <span class="enscript-keyword">continue</span>;
	}
	
	<span class="enscript-keyword">if</span> (   type &lt; watcher-&gt;num_events
	    &amp;&amp; watcher-&gt;event_list[type] == FSE_REPORT
	    &amp;&amp; watcher_cares_about_dev(watcher, dev)) {
	    
	    <span class="enscript-keyword">if</span> (watcher_add_event(watcher, kfse) != 0) {
		watcher-&gt;num_dropped++;
		<span class="enscript-keyword">continue</span>;
	    }
	}

	<span class="enscript-comment">// if (kfse-&gt;refcount &lt; 1) {
</span>	<span class="enscript-comment">//    panic(&quot;add_fsevent: line %d: kfse recount %d but should be at least 1\n&quot;, __LINE__, kfse-&gt;refcount);
</span>	<span class="enscript-comment">// }
</span>    }

    unlock_watch_table();

  <span class="enscript-reference">clean_up</span>:

    <span class="enscript-keyword">if</span> (pathbuff) {
	release_pathbuff(pathbuff);
	pathbuff = NULL;
    }

    release_event_ref(kfse);

    <span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">release_event_ref</span>(kfs_event *kfse)
{
    <span class="enscript-type">int</span> old_refcount;
    kfs_event copy, dest_copy;
    
    
    old_refcount = OSAddAtomic(-1, &amp;kfse-&gt;refcount);
    <span class="enscript-keyword">if</span> (old_refcount &gt; 1) {
	<span class="enscript-keyword">return</span>;
    }

    lock_fs_event_list();
    <span class="enscript-keyword">if</span> (last_event_ptr == kfse) {
	    last_event_ptr = NULL;
	    last_event_type = -1;
	    last_coalesced_time = 0;
    }

    <span class="enscript-keyword">if</span> (kfse-&gt;refcount &lt; 0) {
	panic(<span class="enscript-string">&quot;release_event_ref: bogus kfse refcount %d\n&quot;</span>, kfse-&gt;refcount);
    }

    <span class="enscript-keyword">if</span> (kfse-&gt;refcount &gt; 0 || kfse-&gt;type == FSE_INVALID) {
	<span class="enscript-comment">// This is very subtle.  Either of these conditions can
</span>	<span class="enscript-comment">// be true if an event got recycled while we were waiting
</span>	<span class="enscript-comment">// on the fs_event_list lock or the event got recycled,
</span>	<span class="enscript-comment">// delivered, _and_ free'd by someone else while we were
</span>	<span class="enscript-comment">// waiting on the fs event list lock.  In either case
</span>	<span class="enscript-comment">// we need to just unlock the list and return without
</span>	<span class="enscript-comment">// doing anything because if the refcount is &gt; 0 then
</span>	<span class="enscript-comment">// someone else will take care of free'ing it and when
</span>	<span class="enscript-comment">// the kfse-&gt;type is invalid then someone else already
</span>	<span class="enscript-comment">// has handled free'ing the event (while we were blocked
</span>	<span class="enscript-comment">// on the event list lock).
</span>	<span class="enscript-comment">//
</span>	unlock_fs_event_list();
	<span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// make a copy of this so we can free things without
</span>    <span class="enscript-comment">// holding the fs_event_buf lock
</span>    <span class="enscript-comment">//
</span>    copy = *kfse;
    <span class="enscript-keyword">if</span> (kfse-&gt;dest &amp;&amp; OSAddAtomic(-1, &amp;kfse-&gt;dest-&gt;refcount) == 1) {
	dest_copy = *kfse-&gt;dest;
    } <span class="enscript-keyword">else</span> {
	dest_copy.str  = NULL;
	dest_copy.len  = 0;
	dest_copy.type = FSE_INVALID;
    }

    kfse-&gt;pid = kfse-&gt;type;             <span class="enscript-comment">// save this off for debugging...
</span>    kfse-&gt;uid = (uid_t)(<span class="enscript-type">long</span>)kfse-&gt;str;       <span class="enscript-comment">// save this off for debugging... 
</span>    kfse-&gt;gid = (gid_t)(<span class="enscript-type">long</span>)current_thread();

    kfse-&gt;str = (<span class="enscript-type">char</span> *)0xdeadbeef;             <span class="enscript-comment">// XXXdbg - catch any cheaters...
</span>
    <span class="enscript-keyword">if</span> (dest_copy.type != FSE_INVALID) {
	kfse-&gt;dest-&gt;str = (<span class="enscript-type">char</span> *)0xbadc0de;   <span class="enscript-comment">// XXXdbg - catch any cheaters...
</span>	kfse-&gt;dest-&gt;type = FSE_INVALID;

	<span class="enscript-keyword">if</span> (kfse-&gt;dest-&gt;kevent_list.le_prev != NULL) {
	    num_events_outstanding--;
	    LIST_REMOVE(kfse-&gt;dest, kevent_list);
	    memset(&amp;kfse-&gt;dest-&gt;kevent_list, 0xa5, <span class="enscript-keyword">sizeof</span>(kfse-&gt;dest-&gt;kevent_list));
	}

	zfree(event_zone, kfse-&gt;dest);
    }

    <span class="enscript-comment">// mark this fsevent as invalid
</span>    {
	<span class="enscript-type">int</span> otype;
	
	otype = kfse-&gt;type;
    kfse-&gt;type = FSE_INVALID;

    <span class="enscript-keyword">if</span> (kfse-&gt;kevent_list.le_prev != NULL) {
	num_events_outstanding--;
	<span class="enscript-keyword">if</span> (otype == FSE_RENAME) {
	    num_pending_rename--;
	}
	LIST_REMOVE(kfse, kevent_list);
	memset(&amp;kfse-&gt;kevent_list, 0, <span class="enscript-keyword">sizeof</span>(kfse-&gt;kevent_list));
    }
    }
    
    zfree(event_zone, kfse);
    
    unlock_fs_event_list();
    
    <span class="enscript-comment">// if we have a pointer in the union
</span>    <span class="enscript-keyword">if</span> (copy.str &amp;&amp; copy.type != FSE_DOCID_CHANGED) {
	<span class="enscript-keyword">if</span> (copy.len == 0) {    <span class="enscript-comment">// and it's not a string
</span>	    panic(<span class="enscript-string">&quot;%s:%d: no more fref.vp!\n&quot;</span>, __FILE__, __LINE__);
	    <span class="enscript-comment">// vnode_rele_ext(copy.fref.vp, O_EVTONLY, 0);
</span>	} <span class="enscript-keyword">else</span> {                <span class="enscript-comment">// else it's a string
</span>	    vfs_removename(copy.str);
	}
    }

    <span class="enscript-keyword">if</span> (dest_copy.type != FSE_INVALID &amp;&amp; dest_copy.str) {
	<span class="enscript-keyword">if</span> (dest_copy.len == 0) {
	    panic(<span class="enscript-string">&quot;%s:%d: no more fref.vp!\n&quot;</span>, __FILE__, __LINE__);
	    <span class="enscript-comment">// vnode_rele_ext(dest_copy.fref.vp, O_EVTONLY, 0);
</span>	} <span class="enscript-keyword">else</span> {
	    vfs_removename(dest_copy.str);
	}
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">add_watcher</span>(int8_t *event_list, int32_t num_events, int32_t eventq_size, fs_event_watcher **watcher_out, <span class="enscript-type">void</span> *fseh)
{
    <span class="enscript-type">int</span>               i;
    fs_event_watcher *watcher;

    <span class="enscript-keyword">if</span> (eventq_size &lt;= 0 || eventq_size &gt; 100*max_kfs_events) {
	eventq_size = max_kfs_events;
    }

    <span class="enscript-comment">// Note: the event_queue follows the fs_event_watcher struct
</span>    <span class="enscript-comment">//       in memory so we only have to do one allocation
</span>    MALLOC(watcher,
	   fs_event_watcher *,
	   <span class="enscript-keyword">sizeof</span>(fs_event_watcher) + eventq_size * <span class="enscript-keyword">sizeof</span>(kfs_event *),
	   M_TEMP, M_WAITOK);
    <span class="enscript-keyword">if</span> (watcher == NULL) {
	<span class="enscript-keyword">return</span> ENOMEM;
    }

    watcher-&gt;event_list   = event_list;
    watcher-&gt;num_events   = num_events;
    watcher-&gt;devices_not_to_watch = NULL;
    watcher-&gt;num_devices  = 0;
    watcher-&gt;flags        = 0;
    watcher-&gt;event_queue  = (kfs_event **)&amp;watcher[1];
    watcher-&gt;eventq_size  = eventq_size;
    watcher-&gt;rd           = 0;
    watcher-&gt;wr           = 0;
    watcher-&gt;blockers     = 0;
    watcher-&gt;num_readers  = 0;
    watcher-&gt;max_event_id = 0;
    watcher-&gt;fseh         = fseh;
    watcher-&gt;pid          = proc_selfpid();
    proc_selfname(watcher-&gt;proc_name, <span class="enscript-keyword">sizeof</span>(watcher-&gt;proc_name));

    watcher-&gt;num_dropped  = 0;      <span class="enscript-comment">// XXXdbg - debugging
</span>
    <span class="enscript-keyword">if</span> (!strncmp(watcher-&gt;proc_name, <span class="enscript-string">&quot;fseventsd&quot;</span>, <span class="enscript-keyword">sizeof</span>(watcher-&gt;proc_name)) ||
	!strncmp(watcher-&gt;proc_name, <span class="enscript-string">&quot;coreservicesd&quot;</span>, <span class="enscript-keyword">sizeof</span>(watcher-&gt;proc_name)) ||
	!strncmp(watcher-&gt;proc_name, <span class="enscript-string">&quot;mds&quot;</span>, <span class="enscript-keyword">sizeof</span>(watcher-&gt;proc_name))) {
	watcher-&gt;flags |= WATCHER_APPLE_SYSTEM_SERVICE;
    } <span class="enscript-keyword">else</span> {
      printf(<span class="enscript-string">&quot;fsevents: watcher %s (pid: %d) - Using /dev/fsevents directly is unsupported.  Migrate to FSEventsFramework\n&quot;</span>,
	     watcher-&gt;proc_name, watcher-&gt;pid);
    }

    lock_watch_table();

    <span class="enscript-comment">// find a slot for the new watcher
</span>    <span class="enscript-keyword">for</span>(i=0; i &lt; MAX_WATCHERS; i++) {
	<span class="enscript-keyword">if</span> (watcher_table[i] == NULL) {
	    watcher-&gt;my_id   = i;
	    watcher_table[i] = watcher;
	    <span class="enscript-keyword">break</span>;
	}
    }

    <span class="enscript-keyword">if</span> (i &gt;= MAX_WATCHERS) {
	printf(<span class="enscript-string">&quot;fsevents: too many watchers!\n&quot;</span>);
	unlock_watch_table();
	FREE(watcher, M_TEMP);
	<span class="enscript-keyword">return</span> ENOSPC;
    }

    <span class="enscript-comment">// now update the global list of who's interested in
</span>    <span class="enscript-comment">// events of a particular type...
</span>    <span class="enscript-keyword">for</span>(i=0; i &lt; num_events; i++) {
	<span class="enscript-keyword">if</span> (event_list[i] != FSE_IGNORE &amp;&amp; i &lt; FSE_MAX_EVENTS) {
	    fs_event_type_watchers[i]++;
	}
    }

    unlock_watch_table();

    *watcher_out = watcher;

    <span class="enscript-keyword">return</span> 0;
}



<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">remove_watcher</span>(fs_event_watcher *target)
{
    <span class="enscript-type">int</span> i, j, counter=0;
    fs_event_watcher *watcher;
    kfs_event *kfse;
    
    lock_watch_table();
    
    <span class="enscript-keyword">for</span>(j=0; j &lt; MAX_WATCHERS; j++) {
	watcher = watcher_table[j];
	<span class="enscript-keyword">if</span> (watcher != target) {
	    <span class="enscript-keyword">continue</span>;
	}

	watcher_table[j] = NULL;

	<span class="enscript-keyword">for</span>(i=0; i &lt; watcher-&gt;num_events; i++) {
	    <span class="enscript-keyword">if</span> (watcher-&gt;event_list[i] != FSE_IGNORE &amp;&amp; i &lt; FSE_MAX_EVENTS) {
		fs_event_type_watchers[i]--;
	    }
	}

	<span class="enscript-keyword">if</span> (watcher-&gt;flags &amp; WATCHER_CLOSING) {
	    unlock_watch_table();
	    <span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">// printf(&quot;fsevents: removing watcher %p (rd %d wr %d num_readers %d flags 0x%x)\n&quot;, watcher, watcher-&gt;rd, watcher-&gt;wr, watcher-&gt;num_readers, watcher-&gt;flags);
</span>	watcher-&gt;flags |= WATCHER_CLOSING;
	OSAddAtomic(1, &amp;watcher-&gt;num_readers);
	
	unlock_watch_table();
	    
	<span class="enscript-keyword">while</span> (watcher-&gt;num_readers &gt; 1 &amp;&amp; counter++ &lt; 5000) {
	    lock_watch_table();
	    fsevents_wakeup(watcher);      <span class="enscript-comment">// in case they're asleep
</span>	    unlock_watch_table();
	    
	    tsleep(watcher, PRIBIO, <span class="enscript-string">&quot;fsevents-close&quot;</span>, 1);
	}
	<span class="enscript-keyword">if</span> (counter++ &gt;= 5000) {
	    <span class="enscript-comment">// printf(&quot;fsevents: close: still have readers! (%d)\n&quot;, watcher-&gt;num_readers);
</span>	    panic(<span class="enscript-string">&quot;fsevents: close: still have readers! (%d)\n&quot;</span>, watcher-&gt;num_readers);
	}

	<span class="enscript-comment">// drain the event_queue 
</span>
	lck_rw_lock_exclusive(&amp;event_handling_lock);
	<span class="enscript-keyword">while</span>(watcher-&gt;rd != watcher-&gt;wr) {
	    kfse = watcher-&gt;event_queue[watcher-&gt;rd];
	    watcher-&gt;event_queue[watcher-&gt;rd] = NULL;
	    watcher-&gt;rd = (watcher-&gt;rd+1) % watcher-&gt;eventq_size;
	    OSSynchronizeIO();
	    <span class="enscript-keyword">if</span> (kfse != NULL &amp;&amp; kfse-&gt;type != FSE_INVALID &amp;&amp; kfse-&gt;refcount &gt;= 1) {
		release_event_ref(kfse);
	    }
	}
	lck_rw_unlock_exclusive(&amp;event_handling_lock);
	    
	<span class="enscript-keyword">if</span> (watcher-&gt;event_list) {
	    FREE(watcher-&gt;event_list, M_TEMP);
	    watcher-&gt;event_list = NULL;
	}
	<span class="enscript-keyword">if</span> (watcher-&gt;devices_not_to_watch) {
	    FREE(watcher-&gt;devices_not_to_watch, M_TEMP);
	    watcher-&gt;devices_not_to_watch = NULL;
	}
	FREE(watcher, M_TEMP);

	<span class="enscript-keyword">return</span>;
    }

    unlock_watch_table();
}


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EVENT_DELAY_IN_MS</span>   10
<span class="enscript-type">static</span> thread_call_t event_delivery_timer = NULL;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> timer_set = 0;


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">delayed_event_delivery</span>(__unused <span class="enscript-type">void</span> *param0, __unused <span class="enscript-type">void</span> *param1)
{
    <span class="enscript-type">int</span> i;
    
    lock_watch_table();

    <span class="enscript-keyword">for</span>(i=0; i &lt; MAX_WATCHERS; i++) {
	<span class="enscript-keyword">if</span> (watcher_table[i] != NULL &amp;&amp; watcher_table[i]-&gt;rd != watcher_table[i]-&gt;wr) {
	    fsevents_wakeup(watcher_table[i]);
	}
    }

    timer_set = 0;

    unlock_watch_table();
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// The watch table must be locked before calling this function.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">schedule_event_wakeup</span>(<span class="enscript-type">void</span>)
{
    uint64_t deadline;
    
    <span class="enscript-keyword">if</span> (event_delivery_timer == NULL) {
	event_delivery_timer = thread_call_allocate((thread_call_func_t)delayed_event_delivery, NULL);
    }

    clock_interval_to_deadline(EVENT_DELAY_IN_MS, 1000 * 1000, &amp;deadline);
    
    thread_call_enter_delayed(event_delivery_timer, deadline);
    timer_set = 1;
}



#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_NUM_PENDING</span>  16

<span class="enscript-comment">//
</span><span class="enscript-comment">// NOTE: the watch table must be locked before calling
</span><span class="enscript-comment">//       this routine.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">watcher_add_event</span>(fs_event_watcher *watcher, kfs_event *kfse)
{
    <span class="enscript-keyword">if</span> (kfse-&gt;abstime &gt; watcher-&gt;max_event_id) {
	watcher-&gt;max_event_id = kfse-&gt;abstime;
    }

    <span class="enscript-keyword">if</span> (((watcher-&gt;wr + 1) % watcher-&gt;eventq_size) == watcher-&gt;rd) {
	watcher-&gt;flags |= WATCHER_DROPPED_EVENTS;
	fsevents_wakeup(watcher);
	<span class="enscript-keyword">return</span> ENOSPC;
    }

    OSAddAtomic(1, &amp;kfse-&gt;refcount);
    watcher-&gt;event_queue[watcher-&gt;wr] = kfse;
    OSSynchronizeIO();
    watcher-&gt;wr = (watcher-&gt;wr + 1) % watcher-&gt;eventq_size;

    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// wake up the watcher if there are more than MAX_NUM_PENDING events.
</span>    <span class="enscript-comment">// otherwise schedule a timer (if one isn't already set) which will 
</span>    <span class="enscript-comment">// send any pending events if no more are received in the next 
</span>    <span class="enscript-comment">// EVENT_DELAY_IN_MS milli-seconds.
</span>    <span class="enscript-comment">//
</span>    int32_t num_pending = 0;
    <span class="enscript-keyword">if</span> (watcher-&gt;rd &lt; watcher-&gt;wr) {
      num_pending = watcher-&gt;wr - watcher-&gt;rd;
    }
    
    <span class="enscript-keyword">if</span> (watcher-&gt;rd &gt; watcher-&gt;wr) {
      num_pending = watcher-&gt;wr + watcher-&gt;eventq_size - watcher-&gt;rd;
    }
    
    <span class="enscript-keyword">if</span> (num_pending &gt; (watcher-&gt;eventq_size*3/4) &amp;&amp; !(watcher-&gt;flags &amp; WATCHER_APPLE_SYSTEM_SERVICE)) {
      <span class="enscript-comment">/* Non-Apple Service is falling behind, start dropping events for this process */</span>
      lck_rw_lock_exclusive(&amp;event_handling_lock);	        
      <span class="enscript-keyword">while</span> (watcher-&gt;rd != watcher-&gt;wr) {
	kfse = watcher-&gt;event_queue[watcher-&gt;rd];
	watcher-&gt;event_queue[watcher-&gt;rd] = NULL;		
	watcher-&gt;rd = (watcher-&gt;rd+1) % watcher-&gt;eventq_size;
	OSSynchronizeIO();
	<span class="enscript-keyword">if</span> (kfse != NULL &amp;&amp; kfse-&gt;type != FSE_INVALID &amp;&amp; kfse-&gt;refcount &gt;= 1) {
	  release_event_ref(kfse);
	}
      }
      watcher-&gt;flags |= WATCHER_DROPPED_EVENTS;
      lck_rw_unlock_exclusive(&amp;event_handling_lock);

      printf(<span class="enscript-string">&quot;fsevents: watcher falling behind: %s (pid: %d) rd: %4d wr: %4d q_size: %4d flags: 0x%x\n&quot;</span>,
	     watcher-&gt;proc_name, watcher-&gt;pid, watcher-&gt;rd, watcher-&gt;wr,
	     watcher-&gt;eventq_size, watcher-&gt;flags);

      fsevents_wakeup(watcher);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (num_pending &gt; MAX_NUM_PENDING) {
      fsevents_wakeup(watcher);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (timer_set == 0) {
      schedule_event_wakeup();
    } 

    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fill_buff</span>(uint16_t type, int32_t size, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data,
          <span class="enscript-type">char</span> *buff, int32_t *_buff_idx, int32_t buff_sz,
          <span class="enscript-type">struct</span> uio *uio)
{
    int32_t amt, error = 0, buff_idx = *_buff_idx;
    uint16_t tmp;
    
    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// the +1 on the size is to guarantee that the main data
</span>    <span class="enscript-comment">// copy loop will always copy at least 1 byte
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-keyword">if</span> ((buff_sz - buff_idx) &lt;= (<span class="enscript-type">int</span>)(2*<span class="enscript-keyword">sizeof</span>(uint16_t) + 1)) {
	<span class="enscript-keyword">if</span> (buff_idx &gt; uio_resid(uio)) {
	    error = ENOSPC;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}

	error = uiomove(buff, buff_idx, uio);
	<span class="enscript-keyword">if</span> (error) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}
	buff_idx = 0;
    }

    <span class="enscript-comment">// copy out the header (type &amp; size)
</span>    memcpy(&amp;buff[buff_idx], &amp;type, <span class="enscript-keyword">sizeof</span>(uint16_t));
    buff_idx += <span class="enscript-keyword">sizeof</span>(uint16_t);
    
    tmp = size &amp; 0xffff;
    memcpy(&amp;buff[buff_idx], &amp;tmp, <span class="enscript-keyword">sizeof</span>(uint16_t));
    buff_idx += <span class="enscript-keyword">sizeof</span>(uint16_t);
    
    <span class="enscript-comment">// now copy the body of the data, flushing along the way 
</span>    <span class="enscript-comment">// if the buffer fills up.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-keyword">while</span>(size &gt; 0) {
	amt = (size &lt; (buff_sz - buff_idx)) ? size : (buff_sz - buff_idx);
	memcpy(&amp;buff[buff_idx], data, amt);

	size -= amt;
	buff_idx += amt;
	data = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)data + amt;
	<span class="enscript-keyword">if</span> (size &gt; (buff_sz - buff_idx)) {
	    <span class="enscript-keyword">if</span> (buff_idx &gt; uio_resid(uio)) {
		error = ENOSPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	    }
	    error = uiomove(buff, buff_idx, uio);
	    <span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	    }
	    buff_idx = 0;
	}

	<span class="enscript-keyword">if</span> (amt == 0) {   <span class="enscript-comment">// just in case...
</span>	    <span class="enscript-keyword">break</span>;
	}
    }

  <span class="enscript-reference">get_out</span>:
    *_buff_idx = buff_idx;
    
    <span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">copy_out_kfse</span>(fs_event_watcher *watcher, kfs_event *kfse, <span class="enscript-type">struct</span> uio *uio)  __attribute__((noinline));

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">copy_out_kfse</span>(fs_event_watcher *watcher, kfs_event *kfse, <span class="enscript-type">struct</span> uio *uio)
{
    <span class="enscript-type">int</span>      error;
    uint16_t tmp16;
    int32_t  type;
    kfs_event *cur;
    <span class="enscript-type">char</span>     evbuff[512];
    <span class="enscript-type">int</span>      evbuff_idx = 0;

    <span class="enscript-keyword">if</span> (kfse-&gt;type == FSE_INVALID) {
	panic(<span class="enscript-string">&quot;fsevents: copy_out_kfse: asked to copy out an invalid event (kfse %p, refcount %d fref ptr %p)\n&quot;</span>, kfse, kfse-&gt;refcount, kfse-&gt;str);
    }

    <span class="enscript-keyword">if</span> (kfse-&gt;flags &amp; KFSE_BEING_CREATED) {
	<span class="enscript-keyword">return</span> 0;
    }

    <span class="enscript-keyword">if</span> (kfse-&gt;type == FSE_RENAME &amp;&amp; kfse-&gt;dest == NULL) {
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// This can happen if an event gets recycled but we had a
</span>	<span class="enscript-comment">// pointer to it in our event queue.  The event is the
</span>	<span class="enscript-comment">// destination of a rename which we'll process separately
</span>	<span class="enscript-comment">// (that is, another kfse points to this one so it's ok
</span>	<span class="enscript-comment">// to skip this guy because we'll process it when we process
</span>	<span class="enscript-comment">// the other one)
</span>	error = 0;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
    }

    <span class="enscript-keyword">if</span> (watcher-&gt;flags &amp; WATCHER_WANTS_EXTENDED_INFO) {

	type = (kfse-&gt;type &amp; 0xfff);

	<span class="enscript-keyword">if</span> (kfse-&gt;flags &amp; KFSE_CONTAINS_DROPPED_EVENTS) {
	    type |= (FSE_CONTAINS_DROPPED_EVENTS &lt;&lt; FSE_FLAG_SHIFT);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kfse-&gt;flags &amp; KFSE_COMBINED_EVENTS) {
	    type |= (FSE_COMBINED_EVENTS &lt;&lt; FSE_FLAG_SHIFT);
	}

    } <span class="enscript-keyword">else</span> {
	type = (int32_t)kfse-&gt;type;
    }

    <span class="enscript-comment">// copy out the type of the event
</span>    memcpy(evbuff, &amp;type, <span class="enscript-keyword">sizeof</span>(int32_t));
    evbuff_idx += <span class="enscript-keyword">sizeof</span>(int32_t);

    <span class="enscript-comment">// copy out the pid of the person that generated the event
</span>    memcpy(&amp;evbuff[evbuff_idx], &amp;kfse-&gt;pid, <span class="enscript-keyword">sizeof</span>(pid_t));
    evbuff_idx += <span class="enscript-keyword">sizeof</span>(pid_t);

    cur = kfse;

  <span class="enscript-reference">copy_again</span>:

    <span class="enscript-keyword">if</span> (kfse-&gt;type == FSE_DOCID_CHANGED || kfse-&gt;type == FSE_DOCID_CREATED) {
	dev_t    dev  = cur-&gt;dev;
	ino_t    ino  = cur-&gt;ino;
	uint64_t ival;

	error = fill_buff(FSE_ARG_DEV, <span class="enscript-keyword">sizeof</span>(dev_t), &amp;dev, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}

	error = fill_buff(FSE_ARG_INO, <span class="enscript-keyword">sizeof</span>(ino_t), &amp;ino, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}

	memcpy(&amp;ino, &amp;cur-&gt;str, <span class="enscript-keyword">sizeof</span>(ino_t));
	error = fill_buff(FSE_ARG_INO, <span class="enscript-keyword">sizeof</span>(ino_t), &amp;ino, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}

	memcpy(&amp;ival, &amp;cur-&gt;uid, <span class="enscript-keyword">sizeof</span>(uint64_t));   <span class="enscript-comment">// the docid gets stuffed into the ino field
</span>	error = fill_buff(FSE_ARG_INT64, <span class="enscript-keyword">sizeof</span>(uint64_t), &amp;ival, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}

	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    <span class="enscript-keyword">if</span> (cur-&gt;str == NULL || cur-&gt;str[0] == <span class="enscript-string">'\0'</span>) {
	printf(<span class="enscript-string">&quot;copy_out_kfse:2: empty/short path (%s)\n&quot;</span>, cur-&gt;str);
	error = fill_buff(FSE_ARG_STRING, 2, <span class="enscript-string">&quot;/&quot;</span>, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
    } <span class="enscript-keyword">else</span> {
	error = fill_buff(FSE_ARG_STRING, cur-&gt;len, cur-&gt;str, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
    }
    <span class="enscript-keyword">if</span> (error != 0) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
    }

    <span class="enscript-keyword">if</span> (cur-&gt;dev == 0 &amp;&amp; cur-&gt;ino == 0) {
	<span class="enscript-comment">// this happens when a rename event happens and the
</span>	<span class="enscript-comment">// destination of the rename did not previously exist.
</span>	<span class="enscript-comment">// it thus has no other file info so skip copying out
</span>	<span class="enscript-comment">// the stuff below since it isn't initialized
</span>	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    
    <span class="enscript-keyword">if</span> (watcher-&gt;flags &amp; WATCHER_WANTS_COMPACT_EVENTS) {
	int32_t finfo_size;
	
	finfo_size = <span class="enscript-keyword">sizeof</span>(dev_t) + <span class="enscript-keyword">sizeof</span>(ino64_t) + <span class="enscript-keyword">sizeof</span>(int32_t) + <span class="enscript-keyword">sizeof</span>(uid_t) + <span class="enscript-keyword">sizeof</span>(gid_t);
	error = fill_buff(FSE_ARG_FINFO, finfo_size, &amp;cur-&gt;ino, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}
    } <span class="enscript-keyword">else</span> {
	ino_t ino;
	
	error = fill_buff(FSE_ARG_DEV, <span class="enscript-keyword">sizeof</span>(dev_t), &amp;cur-&gt;dev, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}

	ino = (ino_t)cur-&gt;ino;
	error = fill_buff(FSE_ARG_INO, <span class="enscript-keyword">sizeof</span>(ino_t), &amp;ino, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}

	error = fill_buff(FSE_ARG_MODE, <span class="enscript-keyword">sizeof</span>(int32_t), &amp;cur-&gt;mode, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}

	error = fill_buff(FSE_ARG_UID, <span class="enscript-keyword">sizeof</span>(uid_t), &amp;cur-&gt;uid, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}

	error = fill_buff(FSE_ARG_GID, <span class="enscript-keyword">sizeof</span>(gid_t), &amp;cur-&gt;gid, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
	<span class="enscript-keyword">if</span> (error != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}
    }


    <span class="enscript-keyword">if</span> (cur-&gt;dest) {
	cur = cur-&gt;dest;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">copy_again</span>;
    }

  <span class="enscript-reference">done</span>:
    <span class="enscript-comment">// very last thing: the time stamp
</span>    error = fill_buff(FSE_ARG_INT64, <span class="enscript-keyword">sizeof</span>(uint64_t), &amp;cur-&gt;abstime, evbuff, &amp;evbuff_idx, <span class="enscript-keyword">sizeof</span>(evbuff), uio);
    <span class="enscript-keyword">if</span> (error != 0) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
    }

    <span class="enscript-comment">// check if the FSE_ARG_DONE will fit
</span>    <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(uint16_t) &gt; <span class="enscript-keyword">sizeof</span>(evbuff) - evbuff_idx) {
	<span class="enscript-keyword">if</span> (evbuff_idx &gt; uio_resid(uio)) {
	    error = ENOSPC;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}
	error = uiomove(evbuff, evbuff_idx, uio);
	<span class="enscript-keyword">if</span> (error) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
	}
	evbuff_idx = 0;
    }

    tmp16 = FSE_ARG_DONE;
    memcpy(&amp;evbuff[evbuff_idx], &amp;tmp16, <span class="enscript-keyword">sizeof</span>(uint16_t));
    evbuff_idx += <span class="enscript-keyword">sizeof</span>(uint16_t);

    <span class="enscript-comment">// flush any remaining data in the buffer (and hopefully
</span>    <span class="enscript-comment">// in most cases this is the only uiomove we'll do)
</span>    <span class="enscript-keyword">if</span> (evbuff_idx &gt; uio_resid(uio)) {
	error = ENOSPC;
    } <span class="enscript-keyword">else</span> {
	error = uiomove(evbuff, evbuff_idx, uio);
    }

  <span class="enscript-reference">get_out</span>:

    <span class="enscript-keyword">return</span> error;
}



<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fmod_watch</span>(fs_event_watcher *watcher, <span class="enscript-type">struct</span> uio *uio)
{
    <span class="enscript-type">int</span>               error=0; 
    user_ssize_t      last_full_event_resid;
    kfs_event        *kfse;
    uint16_t          tmp16;
    <span class="enscript-type">int</span>               skipped;

    last_full_event_resid = uio_resid(uio);

    <span class="enscript-comment">// need at least 2048 bytes of space (maxpathlen + 1 event buf)
</span>    <span class="enscript-keyword">if</span>  (uio_resid(uio) &lt; 2048 || watcher == NULL) {
	<span class="enscript-keyword">return</span> EINVAL;
    }

    <span class="enscript-keyword">if</span> (watcher-&gt;flags &amp; WATCHER_CLOSING) {
	<span class="enscript-keyword">return</span> 0;
    }

    <span class="enscript-keyword">if</span> (OSAddAtomic(1, &amp;watcher-&gt;num_readers) != 0) {
	<span class="enscript-comment">// don't allow multiple threads to read from the fd at the same time
</span>	OSAddAtomic(-1, &amp;watcher-&gt;num_readers);
	<span class="enscript-keyword">return</span> EAGAIN;
    }

 <span class="enscript-reference">restart_watch</span>:
    <span class="enscript-keyword">if</span> (watcher-&gt;rd == watcher-&gt;wr) {
	<span class="enscript-keyword">if</span> (watcher-&gt;flags &amp; WATCHER_CLOSING) {
	    OSAddAtomic(-1, &amp;watcher-&gt;num_readers);
	    <span class="enscript-keyword">return</span> 0;
	}
	OSAddAtomic(1, &amp;watcher-&gt;blockers);
    
	<span class="enscript-comment">// there's nothing to do, go to sleep
</span>	error = tsleep((caddr_t)watcher, PUSER|PCATCH, <span class="enscript-string">&quot;fsevents_empty&quot;</span>, 0);

	OSAddAtomic(-1, &amp;watcher-&gt;blockers);

	<span class="enscript-keyword">if</span> (error != 0 || (watcher-&gt;flags &amp; WATCHER_CLOSING)) {
	    OSAddAtomic(-1, &amp;watcher-&gt;num_readers);
	    <span class="enscript-keyword">return</span> error;
	}
    }

    <span class="enscript-comment">// if we dropped events, return that as an event first
</span>    <span class="enscript-keyword">if</span> (watcher-&gt;flags &amp; WATCHER_DROPPED_EVENTS) {
	int32_t val = FSE_EVENTS_DROPPED;

	error = uiomove((caddr_t)&amp;val, <span class="enscript-keyword">sizeof</span>(int32_t), uio);
	<span class="enscript-keyword">if</span> (error == 0) {
	    val = 0;             <span class="enscript-comment">// a fake pid
</span>	    error = uiomove((caddr_t)&amp;val, <span class="enscript-keyword">sizeof</span>(int32_t), uio);
	    
	    tmp16 = FSE_ARG_DONE;  <span class="enscript-comment">// makes it a consistent msg
</span>	    error = uiomove((caddr_t)&amp;tmp16, <span class="enscript-keyword">sizeof</span>(int16_t), uio);

	    last_full_event_resid = uio_resid(uio);
	} 

	<span class="enscript-keyword">if</span> (error) {
	    OSAddAtomic(-1, &amp;watcher-&gt;num_readers);
	    <span class="enscript-keyword">return</span> error;
	}
	
	watcher-&gt;flags &amp;= ~WATCHER_DROPPED_EVENTS;
    }

    skipped = 0;

    lck_rw_lock_shared(&amp;event_handling_lock);
    <span class="enscript-keyword">while</span> (uio_resid(uio) &gt; 0 &amp;&amp; watcher-&gt;rd != watcher-&gt;wr) {
	<span class="enscript-keyword">if</span> (watcher-&gt;flags &amp; WATCHER_CLOSING) {
	    <span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// check if the event is something of interest to us
</span>	<span class="enscript-comment">// (since it may have been recycled/reused and changed
</span>	<span class="enscript-comment">// its type or which device it is for)
</span>	<span class="enscript-comment">//
</span>	kfse = watcher-&gt;event_queue[watcher-&gt;rd];
	<span class="enscript-keyword">if</span> (!kfse || kfse-&gt;type == FSE_INVALID || kfse-&gt;type &gt;= watcher-&gt;num_events || kfse-&gt;refcount &lt; 1) {
	  <span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (watcher-&gt;event_list[kfse-&gt;type] == FSE_REPORT &amp;&amp; watcher_cares_about_dev(watcher, kfse-&gt;dev)) {

	  <span class="enscript-keyword">if</span> (!(watcher-&gt;flags &amp; WATCHER_APPLE_SYSTEM_SERVICE) &amp;&amp; kfse-&gt;type != FSE_DOCID_CHANGED &amp;&amp; is_ignored_directory(kfse-&gt;str)) {
	    <span class="enscript-comment">// If this is not an Apple System Service, skip specified directories
</span>	    <span class="enscript-comment">// radar://12034844
</span>	    error = 0;
	    skipped = 1;
	  } <span class="enscript-keyword">else</span> {

	    skipped = 0;
	    <span class="enscript-keyword">if</span> (last_event_ptr == kfse) {
		last_event_ptr = NULL;
		last_event_type = -1;
		last_coalesced_time = 0;
	    }
	    error = copy_out_kfse(watcher, kfse, uio);
	    <span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-comment">// if an event won't fit or encountered an error while
</span>		<span class="enscript-comment">// we were copying it out, then backup to the last full
</span>		<span class="enscript-comment">// event and just bail out.  if the error was ENOENT
</span>		<span class="enscript-comment">// then we can continue regular processing, otherwise
</span>		<span class="enscript-comment">// we should unlock things and return.
</span>		uio_setresid(uio, last_full_event_resid);
		<span class="enscript-keyword">if</span> (error != ENOENT) {
		    lck_rw_unlock_shared(&amp;event_handling_lock);
		    error = 0;
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">get_out</span>;
		}
	    }

	    last_full_event_resid = uio_resid(uio);
	  }
	}

	watcher-&gt;event_queue[watcher-&gt;rd] = NULL;
	watcher-&gt;rd = (watcher-&gt;rd + 1) % watcher-&gt;eventq_size;
	OSSynchronizeIO();
	release_event_ref(kfse);
    }
    lck_rw_unlock_shared(&amp;event_handling_lock);

    <span class="enscript-keyword">if</span> (skipped &amp;&amp; error == 0) {
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">restart_watch</span>;
    }

  <span class="enscript-reference">get_out</span>:
    OSAddAtomic(-1, &amp;watcher-&gt;num_readers);

    <span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">// release any references we might have on vnodes which are 
</span><span class="enscript-comment">// the mount point passed to us (so that it can be cleanly
</span><span class="enscript-comment">// unmounted).
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// since we don't want to lose the events we'll convert the
</span><span class="enscript-comment">// vnode refs to full paths.
</span><span class="enscript-comment">//
</span><span class="enscript-type">void</span>
<span class="enscript-function-name">fsevent_unmount</span>(__unused <span class="enscript-type">struct</span> mount *mp)
{
    <span class="enscript-comment">// we no longer maintain pointers to vnodes so
</span>    <span class="enscript-comment">// there is nothing to do... 
</span>}


<span class="enscript-comment">//
</span><span class="enscript-comment">// /dev/fsevents device code
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span> fsevents_installed = 0;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> fsevent_handle {
    UInt32            flags;
    SInt32            active;
    fs_event_watcher *watcher;
    <span class="enscript-type">struct</span> klist      knotes;
    <span class="enscript-type">struct</span> selinfo    si;
} fsevent_handle;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FSEH_CLOSING</span>   0x0001

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventsf_read</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio,
	       __unused <span class="enscript-type">int</span> flags, __unused vfs_context_t ctx)
{
    fsevent_handle *fseh = (<span class="enscript-type">struct</span> fsevent_handle *)fp-&gt;f_fglob-&gt;fg_data;
    <span class="enscript-type">int</span> error;

    error = fmod_watch(fseh-&gt;watcher, uio);

    <span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventsf_write</span>(__unused <span class="enscript-type">struct</span> fileproc *fp, __unused <span class="enscript-type">struct</span> uio *uio,
		__unused <span class="enscript-type">int</span> flags, __unused vfs_context_t ctx)
{
    <span class="enscript-keyword">return</span> EIO;
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>(<span class="enscript-variable-name">push</span>, 4)
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> fsevent_dev_filter_args32 {
    uint32_t            num_devices;
    user32_addr_t       devices;
} fsevent_dev_filter_args32;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> fsevent_dev_filter_args64 {
    uint32_t            num_devices;
    user64_addr_t       devices;
} fsevent_dev_filter_args64;
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>(<span class="enscript-variable-name">pop</span>)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FSEVENTS_DEVICE_FILTER_32</span>	_IOW(<span class="enscript-string">'s'</span>, 100, fsevent_dev_filter_args32)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FSEVENTS_DEVICE_FILTER_64</span>	_IOW(<span class="enscript-string">'s'</span>, 100, fsevent_dev_filter_args64)

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventsf_ioctl</span>(<span class="enscript-type">struct</span> fileproc *fp, u_long cmd, caddr_t data, vfs_context_t ctx)
{
    fsevent_handle *fseh = (<span class="enscript-type">struct</span> fsevent_handle *)fp-&gt;f_fglob-&gt;fg_data;
    <span class="enscript-type">int</span> ret = 0;
    fsevent_dev_filter_args64 *devfilt_args, _devfilt_args;

    OSAddAtomic(1, &amp;fseh-&gt;active);
    <span class="enscript-keyword">if</span> (fseh-&gt;flags &amp; FSEH_CLOSING) {
	OSAddAtomic(-1, &amp;fseh-&gt;active);
	<span class="enscript-keyword">return</span> 0;
    }

    <span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIONBIO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIOASYNC</span>:
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FSEVENTS_WANT_COMPACT_EVENTS</span>: {
	    fseh-&gt;watcher-&gt;flags |= WATCHER_WANTS_COMPACT_EVENTS;
	    <span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FSEVENTS_WANT_EXTENDED_INFO</span>: {
	    fseh-&gt;watcher-&gt;flags |= WATCHER_WANTS_EXTENDED_INFO;
	    <span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FSEVENTS_GET_CURRENT_ID</span>: {
		*(uint64_t *)data = fseh-&gt;watcher-&gt;max_event_id;
		ret = 0;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FSEVENTS_DEVICE_FILTER_32</span>: {
	    <span class="enscript-keyword">if</span> (proc_is64bit(vfs_context_proc(ctx))) {
		    ret = EINVAL;
		    <span class="enscript-keyword">break</span>;
	    }
	    fsevent_dev_filter_args32 *devfilt_args32 = (fsevent_dev_filter_args32 *)data;

	    devfilt_args = &amp;_devfilt_args;
	    memset(devfilt_args, 0, <span class="enscript-keyword">sizeof</span>(fsevent_dev_filter_args64));
	    devfilt_args-&gt;num_devices = devfilt_args32-&gt;num_devices;
	    devfilt_args-&gt;devices     = CAST_USER_ADDR_T(devfilt_args32-&gt;devices);
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_dev_filter</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FSEVENTS_DEVICE_FILTER_64</span>:
	    <span class="enscript-keyword">if</span> (!proc_is64bit(vfs_context_proc(ctx))) {
		    ret = EINVAL;
		    <span class="enscript-keyword">break</span>;
	    }
	    devfilt_args = (fsevent_dev_filter_args64 *)data;

	<span class="enscript-reference">handle_dev_filter</span>:
	{
	    <span class="enscript-type">int</span> new_num_devices;
	    dev_t *devices_not_to_watch, *tmp=NULL;
	    
	    <span class="enscript-keyword">if</span> (devfilt_args-&gt;num_devices &gt; 256) {
		ret = EINVAL;
		<span class="enscript-keyword">break</span>;
	    }
	    
	    new_num_devices = devfilt_args-&gt;num_devices;
	    <span class="enscript-keyword">if</span> (new_num_devices == 0) {
		tmp = fseh-&gt;watcher-&gt;devices_not_to_watch;

		lock_watch_table();
		fseh-&gt;watcher-&gt;devices_not_to_watch = NULL;
		fseh-&gt;watcher-&gt;num_devices = new_num_devices;
		unlock_watch_table();

		<span class="enscript-keyword">if</span> (tmp) {
		    FREE(tmp, M_TEMP);
		}
		<span class="enscript-keyword">break</span>;
	    }

	    MALLOC(devices_not_to_watch, dev_t *,
		   new_num_devices * <span class="enscript-keyword">sizeof</span>(dev_t),
		   M_TEMP, M_WAITOK);
	    <span class="enscript-keyword">if</span> (devices_not_to_watch == NULL) {
		ret = ENOMEM;
		<span class="enscript-keyword">break</span>;
	    }
    
	    ret = copyin(devfilt_args-&gt;devices,
			 (<span class="enscript-type">void</span> *)devices_not_to_watch,
			 new_num_devices * <span class="enscript-keyword">sizeof</span>(dev_t));
	    <span class="enscript-keyword">if</span> (ret) {
		FREE(devices_not_to_watch, M_TEMP);
		<span class="enscript-keyword">break</span>;
	    }

	    lock_watch_table();
	    fseh-&gt;watcher-&gt;num_devices = new_num_devices;
	    tmp = fseh-&gt;watcher-&gt;devices_not_to_watch;
	    fseh-&gt;watcher-&gt;devices_not_to_watch = devices_not_to_watch;
	    unlock_watch_table();

	    <span class="enscript-keyword">if</span> (tmp) {
		FREE(tmp, M_TEMP);
	    }
	    
	    <span class="enscript-keyword">break</span>;
	}	    

	<span class="enscript-reference">default</span>:
	    ret = EINVAL;
	    <span class="enscript-keyword">break</span>;
    }

    OSAddAtomic(-1, &amp;fseh-&gt;active);
    <span class="enscript-keyword">return</span> (ret);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventsf_select</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">int</span> which, __unused <span class="enscript-type">void</span> *wql, vfs_context_t ctx)
{
    fsevent_handle *fseh = (<span class="enscript-type">struct</span> fsevent_handle *)fp-&gt;f_fglob-&gt;fg_data;
    <span class="enscript-type">int</span> ready = 0;

    <span class="enscript-keyword">if</span> ((which != FREAD) || (fseh-&gt;watcher-&gt;flags &amp; WATCHER_CLOSING)) {
	<span class="enscript-keyword">return</span> 0;
    }


    <span class="enscript-comment">// if there's nothing in the queue, we're not ready
</span>    <span class="enscript-keyword">if</span> (fseh-&gt;watcher-&gt;rd != fseh-&gt;watcher-&gt;wr) {
	ready = 1;
    }

    <span class="enscript-keyword">if</span> (!ready) {
	selrecord(vfs_context_proc(ctx), &amp;fseh-&gt;si, wql);
    }

    <span class="enscript-keyword">return</span> ready;
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NOTUSED</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventsf_stat</span>(__unused <span class="enscript-type">struct</span> fileproc *fp, __unused <span class="enscript-type">struct</span> stat *sb, __unused vfs_context_t ctx)
{
    <span class="enscript-keyword">return</span> ENOTSUP;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventsf_close</span>(<span class="enscript-type">struct</span> fileglob *fg, __unused vfs_context_t ctx)
{
    fsevent_handle *fseh = (<span class="enscript-type">struct</span> fsevent_handle *)fg-&gt;fg_data;
    fs_event_watcher *watcher;

    OSBitOrAtomic(FSEH_CLOSING, &amp;fseh-&gt;flags);
    <span class="enscript-keyword">while</span> (OSAddAtomic(0, &amp;fseh-&gt;active) &gt; 0) {
	tsleep((caddr_t)fseh-&gt;watcher, PRIBIO, <span class="enscript-string">&quot;fsevents-close&quot;</span>, 1);
    }

    watcher = fseh-&gt;watcher;
    fg-&gt;fg_data = NULL;
    fseh-&gt;watcher = NULL;

    remove_watcher(watcher);
    FREE(fseh, M_TEMP);

    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_fsevent_detach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	fsevent_handle *fseh = (<span class="enscript-type">struct</span> fsevent_handle *)kn-&gt;kn_hook;

	lock_watch_table();

	KNOTE_DETACH(&amp;fseh-&gt;knotes, kn);
	
	unlock_watch_table();
}

<span class="enscript-comment">/* 
 * Determine whether this knote should be active
 * 
 * This is kind of subtle.  
 * 	--First, notice if the vnode has been revoked: in so, override hint
 * 	--EVFILT_READ knotes are checked no matter what the hint is
 * 	--Other knotes activate based on hint.  
 * 	--If hint is revoke, set special flags and activate
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_fsevent</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	fsevent_handle *fseh = (<span class="enscript-type">struct</span> fsevent_handle *)kn-&gt;kn_hook;
	<span class="enscript-type">int</span> activate = 0;
	int32_t rd, wr, amt;

	<span class="enscript-keyword">if</span> (NOTE_REVOKE == hint) {
		kn-&gt;kn_flags |= (EV_EOF | EV_ONESHOT);
		activate = 1;
	}

	rd = fseh-&gt;watcher-&gt;rd;
	wr = fseh-&gt;watcher-&gt;wr;
	<span class="enscript-keyword">if</span> (rd &lt;= wr) {
	    amt = wr - rd;
	} <span class="enscript-keyword">else</span> {
	    amt = fseh-&gt;watcher-&gt;eventq_size - (rd - wr);
	}

	<span class="enscript-keyword">switch</span>(kn-&gt;kn_filter) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_READ</span>:
			kn-&gt;kn_data = amt;
			
			<span class="enscript-keyword">if</span> (kn-&gt;kn_data != 0) {
				activate = 1;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_VNODE</span>:
			<span class="enscript-comment">/* Check events this note matches against the hint */</span>
			<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; hint) {
				kn-&gt;kn_fflags |= hint; <span class="enscript-comment">/* Set which event occurred */</span>
			}
			<span class="enscript-keyword">if</span> (kn-&gt;kn_fflags != 0) {
				activate = 1;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>: {
			<span class="enscript-comment">// nothing to do...
</span>			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (activate);
}


<span class="enscript-type">struct</span>  filterops fsevent_filtops = { 
	.f_isfd = 1, 
	.f_attach = NULL, 
	.f_detach = filt_fsevent_detach, 
	.f_event = filt_fsevent
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventsf_kqfilter</span>(__unused <span class="enscript-type">struct</span> fileproc *fp, __unused <span class="enscript-type">struct</span> knote *kn, __unused vfs_context_t ctx)
{
    fsevent_handle *fseh = (<span class="enscript-type">struct</span> fsevent_handle *)fp-&gt;f_fglob-&gt;fg_data;

    kn-&gt;kn_hook = (<span class="enscript-type">void</span>*)fseh;
    kn-&gt;kn_hookid = 1;
    kn-&gt;kn_fop = &amp;fsevent_filtops;
    
    lock_watch_table();

    KNOTE_ATTACH(&amp;fseh-&gt;knotes, kn);

    unlock_watch_table();
    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventsf_drain</span>(<span class="enscript-type">struct</span> fileproc *fp, __unused vfs_context_t ctx)
{
    <span class="enscript-type">int</span> counter = 0;
    fsevent_handle *fseh = (<span class="enscript-type">struct</span> fsevent_handle *)fp-&gt;f_fglob-&gt;fg_data;

    fseh-&gt;watcher-&gt;flags |= WATCHER_CLOSING;

    <span class="enscript-comment">// if there are people still waiting, sleep for 10ms to
</span>    <span class="enscript-comment">// let them clean up and get out of there.  however we
</span>    <span class="enscript-comment">// also don't want to get stuck forever so if they don't
</span>    <span class="enscript-comment">// exit after 5 seconds we're tearing things down anyway.
</span>    <span class="enscript-keyword">while</span>(fseh-&gt;watcher-&gt;blockers &amp;&amp; counter++ &lt; 500) {
        <span class="enscript-comment">// issue wakeup in case anyone is blocked waiting for an event
</span>        <span class="enscript-comment">// do this each time we wakeup in case the blocker missed
</span>        <span class="enscript-comment">// the wakeup due to the unprotected test of WATCHER_CLOSING
</span>        <span class="enscript-comment">// and decision to tsleep in fmod_watch... this bit of 
</span>        <span class="enscript-comment">// latency is a decent tradeoff against not having to
</span>        <span class="enscript-comment">// take and drop a lock in fmod_watch
</span>	lock_watch_table();
	fsevents_wakeup(fseh-&gt;watcher);
	unlock_watch_table();

	tsleep((caddr_t)fseh-&gt;watcher, PRIBIO, <span class="enscript-string">&quot;watcher-close&quot;</span>, 1);
    }

    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventsopen</span>(__unused dev_t dev, __unused <span class="enscript-type">int</span> flag, __unused <span class="enscript-type">int</span> mode, __unused <span class="enscript-type">struct</span> proc *p)
{
    <span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get())) {
	<span class="enscript-keyword">return</span> EPERM;
    }
    
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventsclose</span>(__unused dev_t dev, __unused <span class="enscript-type">int</span> flag, __unused <span class="enscript-type">int</span> mode, __unused <span class="enscript-type">struct</span> proc *p)
{
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventsread</span>(__unused dev_t dev, __unused <span class="enscript-type">struct</span> uio *uio, __unused <span class="enscript-type">int</span> ioflag)
{
    <span class="enscript-keyword">return</span> EIO;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">parse_buffer_and_add_events</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *buffer, <span class="enscript-type">int</span> bufsize, vfs_context_t ctx, <span class="enscript-type">long</span> *remainder)
{
    <span class="enscript-type">const</span> fse_info *finfo, *dest_finfo;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *path, *ptr, *dest_path, *event_start=buffer;
    <span class="enscript-type">int</span> path_len, type, dest_path_len, err = 0;


    ptr = buffer;
    <span class="enscript-keyword">while</span> ((ptr+<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)+<span class="enscript-keyword">sizeof</span>(fse_info)+1) &lt; buffer+bufsize) {
	type = *(<span class="enscript-type">const</span> <span class="enscript-type">int</span> *)ptr;
	<span class="enscript-keyword">if</span> (type &lt; 0 || type &gt;= FSE_MAX_EVENTS) {
	    err = EINVAL;
	    <span class="enscript-keyword">break</span>;
	}

	ptr += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>);
	
	finfo = (<span class="enscript-type">const</span> fse_info *)ptr;
	ptr += <span class="enscript-keyword">sizeof</span>(fse_info);

	path = ptr;
	<span class="enscript-keyword">while</span>(ptr &lt; buffer+bufsize &amp;&amp; *ptr != <span class="enscript-string">'\0'</span>) {
	    ptr++;
	}

	<span class="enscript-keyword">if</span> (ptr &gt;= buffer+bufsize) {
	    <span class="enscript-keyword">break</span>;
	}

	ptr++;   <span class="enscript-comment">// advance over the trailing '\0'
</span>
	path_len = ptr - path;

	<span class="enscript-keyword">if</span> (type != FSE_RENAME &amp;&amp; type != FSE_EXCHANGE) {
	    event_start = ptr;   <span class="enscript-comment">// record where the next event starts
</span>
	    err = add_fsevent(type, ctx, FSE_ARG_STRING, path_len, path, FSE_ARG_FINFO, finfo, FSE_ARG_DONE);
	    <span class="enscript-keyword">if</span> (err) {
		<span class="enscript-keyword">break</span>;
	    }
	    <span class="enscript-keyword">continue</span>;
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if we're here we have to slurp up the destination finfo
</span>	<span class="enscript-comment">// and path so that we can pass them to the add_fsevent()
</span>	<span class="enscript-comment">// call.  basically it's a copy of the above code.
</span>	<span class="enscript-comment">//
</span>	dest_finfo = (<span class="enscript-type">const</span> fse_info *)ptr;
	ptr += <span class="enscript-keyword">sizeof</span>(fse_info);

	dest_path = ptr;
	<span class="enscript-keyword">while</span>(ptr &lt; buffer+bufsize &amp;&amp; *ptr != <span class="enscript-string">'\0'</span>) {
	    ptr++;
	}

	<span class="enscript-keyword">if</span> (ptr &gt;= buffer+bufsize) {
	    <span class="enscript-keyword">break</span>;
	}

	ptr++;               <span class="enscript-comment">// advance over the trailing '\0'
</span>	event_start = ptr;   <span class="enscript-comment">// record where the next event starts
</span>
	dest_path_len = ptr - dest_path;
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// If the destination inode number is non-zero, generate a rename
</span>	<span class="enscript-comment">// with both source and destination FSE_ARG_FINFO. Otherwise generate
</span>	<span class="enscript-comment">// a rename with only one FSE_ARG_FINFO. If you need to inject an
</span>	<span class="enscript-comment">// exchange with an inode of zero, just make that inode (and its path)
</span>	<span class="enscript-comment">// come in as the first one, not the second.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (dest_finfo-&gt;ino) {
	        err = add_fsevent(type, ctx,
		                  FSE_ARG_STRING, path_len,      path,      FSE_ARG_FINFO, finfo,
		                  FSE_ARG_STRING, dest_path_len, dest_path, FSE_ARG_FINFO, dest_finfo,
		                  FSE_ARG_DONE);
	} <span class="enscript-keyword">else</span> {
		err = add_fsevent(type, ctx,
		                  FSE_ARG_STRING, path_len,      path,      FSE_ARG_FINFO, finfo,
		                  FSE_ARG_STRING, dest_path_len, dest_path,
		                  FSE_ARG_DONE);
	}

	<span class="enscript-keyword">if</span> (err) {
	    <span class="enscript-keyword">break</span>;
	}

    }

    <span class="enscript-comment">// if the last event wasn't complete, set the remainder
</span>    <span class="enscript-comment">// to be the last event start boundary.
</span>    <span class="enscript-comment">//
</span>    *remainder = (<span class="enscript-type">long</span>)((buffer+bufsize) - event_start);

    <span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// Note: this buffer size can not ever be less than
</span><span class="enscript-comment">//       2*MAXPATHLEN + 2*sizeof(fse_info) + sizeof(int)
</span><span class="enscript-comment">//       because that is the max size for a single event.
</span><span class="enscript-comment">//       I made it 4k to be a &quot;nice&quot; size.  making it
</span><span class="enscript-comment">//       smaller is not a good idea.
</span><span class="enscript-comment">//
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WRITE_BUFFER_SIZE</span>  4096
<span class="enscript-type">char</span> *write_buffer=NULL;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventswrite</span>(__unused dev_t dev, <span class="enscript-type">struct</span> uio *uio, __unused <span class="enscript-type">int</span> ioflag)
{
    <span class="enscript-type">int</span> error=0, count;
    vfs_context_t ctx = vfs_context_current();
    <span class="enscript-type">long</span> offset=0, remainder;

    lck_mtx_lock(&amp;event_writer_lock);

    <span class="enscript-keyword">if</span> (write_buffer == NULL) {
	<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;write_buffer, WRITE_BUFFER_SIZE, VM_KERN_MEMORY_FILE)) {
	    lck_mtx_unlock(&amp;event_writer_lock);
	    <span class="enscript-keyword">return</span> ENOMEM;
	}
    }

    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// this loop copies in and processes the events written.
</span>    <span class="enscript-comment">// it takes care to copy in reasonable size chunks and
</span>    <span class="enscript-comment">// process them.  if there is an event that spans a chunk
</span>    <span class="enscript-comment">// boundary we're careful to copy those bytes down to the
</span>    <span class="enscript-comment">// beginning of the buffer and read the next chunk in just
</span>    <span class="enscript-comment">// after it.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-keyword">while</span>(uio_resid(uio)) {
	<span class="enscript-keyword">if</span> (uio_resid(uio) &gt; (WRITE_BUFFER_SIZE-offset)) {
	    count = WRITE_BUFFER_SIZE - offset;
	} <span class="enscript-keyword">else</span> {
	    count = uio_resid(uio);
	}

	error = uiomove(write_buffer+offset, count, uio);
	<span class="enscript-keyword">if</span> (error) {
	    <span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">// printf(&quot;fsevents: write: copied in %d bytes (offset: %ld)\n&quot;, count, offset);
</span>	error = parse_buffer_and_add_events(write_buffer, offset+count, ctx, &amp;remainder);
	<span class="enscript-keyword">if</span> (error) {
	    <span class="enscript-keyword">break</span>;
	}	    

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if there's any remainder, copy it down to the beginning
</span>	<span class="enscript-comment">// of the buffer so that it will get processed the next time
</span>	<span class="enscript-comment">// through the loop.  note that the remainder always starts
</span>	<span class="enscript-comment">// at an event boundary.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (remainder != 0) {
	    <span class="enscript-comment">// printf(&quot;fsevents: write: an event spanned a %d byte boundary.  remainder: %ld\n&quot;,
</span>	    <span class="enscript-comment">//	WRITE_BUFFER_SIZE, remainder);
</span>	    memmove(write_buffer, (write_buffer+count+offset) - remainder, remainder);
	    offset = remainder;
	} <span class="enscript-keyword">else</span> {
	    offset = 0;
	}
    }

    lck_mtx_unlock(&amp;event_writer_lock);

    <span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> fileops fsevents_fops = {
    DTYPE_FSEVENTS,
    fseventsf_read,
    fseventsf_write,
    fseventsf_ioctl,
    fseventsf_select,
    fseventsf_close,
    fseventsf_kqfilter,
    fseventsf_drain
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> fsevent_clone_args32 {
    user32_addr_t       event_list;
    int32_t             num_events;
    int32_t             event_queue_depth;
    user32_addr_t       fd;
} fsevent_clone_args32;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> fsevent_clone_args64 {
    user64_addr_t       event_list;
    int32_t             num_events;
    int32_t             event_queue_depth;
    user64_addr_t       fd;
} fsevent_clone_args64;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FSEVENTS_CLONE_32</span>	_IOW(<span class="enscript-string">'s'</span>, 1, fsevent_clone_args32)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FSEVENTS_CLONE_64</span>	_IOW(<span class="enscript-string">'s'</span>, 1, fsevent_clone_args64)

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fseventsioctl</span>(__unused dev_t dev, u_long cmd, caddr_t data, __unused <span class="enscript-type">int</span> flag, <span class="enscript-type">struct</span> proc *p)
{
    <span class="enscript-type">struct</span> fileproc *f;
    <span class="enscript-type">int</span> fd, error;
    fsevent_handle *fseh = NULL;
    fsevent_clone_args64 *fse_clone_args, _fse_clone;
    int8_t *event_list;
    <span class="enscript-type">int</span> is64bit = proc_is64bit(p);

    <span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FSEVENTS_CLONE_32</span>: {
	    <span class="enscript-keyword">if</span> (is64bit) {
		    <span class="enscript-keyword">return</span> EINVAL;
	    }
	    fsevent_clone_args32 *args32 = (fsevent_clone_args32 *)data;

	    fse_clone_args = &amp;_fse_clone;
	    memset(fse_clone_args, 0, <span class="enscript-keyword">sizeof</span>(fsevent_clone_args64));

	    fse_clone_args-&gt;event_list        = CAST_USER_ADDR_T(args32-&gt;event_list);
	    fse_clone_args-&gt;num_events        = args32-&gt;num_events;
	    fse_clone_args-&gt;event_queue_depth = args32-&gt;event_queue_depth;
	    fse_clone_args-&gt;fd                = CAST_USER_ADDR_T(args32-&gt;fd);
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_clone</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FSEVENTS_CLONE_64</span>:
	    <span class="enscript-keyword">if</span> (!is64bit) {
		    <span class="enscript-keyword">return</span> EINVAL;
	    }
	    fse_clone_args = (fsevent_clone_args64 *)data;

	<span class="enscript-reference">handle_clone</span>:
	    <span class="enscript-keyword">if</span> (fse_clone_args-&gt;num_events &lt; 0 || fse_clone_args-&gt;num_events &gt; 4096) {
		<span class="enscript-keyword">return</span> EINVAL;
	    }

	    MALLOC(fseh, fsevent_handle *, <span class="enscript-keyword">sizeof</span>(fsevent_handle),
		   M_TEMP, M_WAITOK);
	    <span class="enscript-keyword">if</span> (fseh == NULL) {
		<span class="enscript-keyword">return</span> ENOMEM;
	    }
	    memset(fseh, 0, <span class="enscript-keyword">sizeof</span>(fsevent_handle));
	    
	    klist_init(&amp;fseh-&gt;knotes);

	    MALLOC(event_list, int8_t *,
		   fse_clone_args-&gt;num_events * <span class="enscript-keyword">sizeof</span>(int8_t),
		   M_TEMP, M_WAITOK);
	    <span class="enscript-keyword">if</span> (event_list == NULL) {
		FREE(fseh, M_TEMP);
		<span class="enscript-keyword">return</span> ENOMEM;
	    }
    
	    error = copyin(fse_clone_args-&gt;event_list,
			   (<span class="enscript-type">void</span> *)event_list,
			   fse_clone_args-&gt;num_events * <span class="enscript-keyword">sizeof</span>(int8_t));
	    <span class="enscript-keyword">if</span> (error) {
		FREE(event_list, M_TEMP);
		FREE(fseh, M_TEMP);
		<span class="enscript-keyword">return</span> error;
	    }
    
	    error = add_watcher(event_list,
				fse_clone_args-&gt;num_events,
				fse_clone_args-&gt;event_queue_depth,
			        &amp;fseh-&gt;watcher,
			        fseh);
	    <span class="enscript-keyword">if</span> (error) {
		FREE(event_list, M_TEMP);
		FREE(fseh, M_TEMP);
		<span class="enscript-keyword">return</span> error;
	    }

	    fseh-&gt;watcher-&gt;fseh = fseh;

	    error = falloc(p, &amp;f, &amp;fd, vfs_context_current());
	    <span class="enscript-keyword">if</span> (error) {
		remove_watcher(fseh-&gt;watcher);
		FREE(event_list, M_TEMP);
		FREE(fseh, M_TEMP);
		<span class="enscript-keyword">return</span> (error);
	    }
	    proc_fdlock(p);
	    f-&gt;f_fglob-&gt;fg_flag = FREAD | FWRITE;
	    f-&gt;f_fglob-&gt;fg_ops = &amp;fsevents_fops;
	    f-&gt;f_fglob-&gt;fg_data = (caddr_t) fseh;
	    proc_fdunlock(p);
	    error = copyout((<span class="enscript-type">void</span> *)&amp;fd, fse_clone_args-&gt;fd, <span class="enscript-keyword">sizeof</span>(int32_t));
	    <span class="enscript-keyword">if</span> (error != 0) {
		fp_free(p, fd, f);
	    } <span class="enscript-keyword">else</span> {
		proc_fdlock(p);
		procfdtbl_releasefd(p, fd, NULL);
		fp_drop(p, fd, f, 1);
		proc_fdunlock(p);
	    }
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
	    error = EINVAL;
	    <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">fsevents_wakeup</span>(fs_event_watcher *watcher)
{
    selwakeup(&amp;watcher-&gt;fseh-&gt;si);
    KNOTE(&amp;watcher-&gt;fseh-&gt;knotes, NOTE_WRITE|NOTE_NONE);
    wakeup((caddr_t)watcher);
}


<span class="enscript-comment">/*
 * A struct describing which functions will get invoked for certain
 * actions.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cdevsw fsevents_cdevsw =
{
    fseventsopen,		<span class="enscript-comment">/* open */</span>
    fseventsclose,		<span class="enscript-comment">/* close */</span>
    fseventsread,		<span class="enscript-comment">/* read */</span>
    fseventswrite,		<span class="enscript-comment">/* write */</span>
    fseventsioctl,		<span class="enscript-comment">/* ioctl */</span>
    (stop_fcn_t *)&amp;nulldev,	<span class="enscript-comment">/* stop */</span>
    (reset_fcn_t *)&amp;nulldev,	<span class="enscript-comment">/* reset */</span>
    NULL,			<span class="enscript-comment">/* tty's */</span>
    eno_select,			<span class="enscript-comment">/* select */</span>
    eno_mmap,			<span class="enscript-comment">/* mmap */</span>
    eno_strat,			<span class="enscript-comment">/* strategy */</span>
    eno_getc,			<span class="enscript-comment">/* getc */</span>
    eno_putc,			<span class="enscript-comment">/* putc */</span>
    0				<span class="enscript-comment">/* type */</span>
};


<span class="enscript-comment">/*
 * Called to initialize our device,
 * and to register ourselves with devfs
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">fsevents_init</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> ret;

    <span class="enscript-keyword">if</span> (fsevents_installed) {
	<span class="enscript-keyword">return</span>;
    } 

    fsevents_installed = 1;

    ret = cdevsw_add(-1, &amp;fsevents_cdevsw);
    <span class="enscript-keyword">if</span> (ret &lt; 0) {
	fsevents_installed = 0;
	<span class="enscript-keyword">return</span>;
    }

    devfs_make_node(makedev (ret, 0), DEVFS_CHAR,
		    UID_ROOT, GID_WHEEL, 0644, <span class="enscript-string">&quot;fsevents&quot;</span>, 0);

    fsevents_internal_init();
}


<span class="enscript-type">char</span> *
<span class="enscript-function-name">get_pathbuff</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">char</span> *path;

    MALLOC_ZONE(path, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK);
    <span class="enscript-keyword">return</span> path;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">release_pathbuff</span>(<span class="enscript-type">char</span> *path)
{

    <span class="enscript-keyword">if</span> (path == NULL) {
	<span class="enscript-keyword">return</span>;
    }
    FREE_ZONE(path, MAXPATHLEN, M_NAMEI);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">get_fse_info</span>(<span class="enscript-type">struct</span> vnode *vp, fse_info *fse, __unused vfs_context_t ctx)
{
    <span class="enscript-type">struct</span> vnode_attr va;

    VATTR_INIT(&amp;va);
    VATTR_WANTED(&amp;va, va_fsid);
    VATTR_WANTED(&amp;va, va_fileid);
    VATTR_WANTED(&amp;va, va_mode);
    VATTR_WANTED(&amp;va, va_uid);
    VATTR_WANTED(&amp;va, va_gid);
    <span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISHARDLINK) {
	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VDIR) {
	    VATTR_WANTED(&amp;va, va_dirlinkcount);
	} <span class="enscript-keyword">else</span> {
	    VATTR_WANTED(&amp;va, va_nlink);
	}
    }
    
    <span class="enscript-keyword">if</span> (vnode_getattr(vp, &amp;va, vfs_context_kernel()) != 0) {
	memset(fse, 0, <span class="enscript-keyword">sizeof</span>(fse_info));
	<span class="enscript-keyword">return</span> -1;
    }

    <span class="enscript-keyword">return</span> vnode_get_fse_info_from_vap(vp, fse, &amp;va);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_get_fse_info_from_vap</span>(vnode_t vp, fse_info *fse, <span class="enscript-type">struct</span> vnode_attr *vap) 
{
    fse-&gt;ino  = (ino64_t)vap-&gt;va_fileid;
    fse-&gt;dev  = (dev_t)vap-&gt;va_fsid;
    fse-&gt;mode = (int32_t)vnode_vttoif(vnode_vtype(vp)) | vap-&gt;va_mode;
    fse-&gt;uid  = (uid_t)vap-&gt;va_uid;
    fse-&gt;gid  = (gid_t)vap-&gt;va_gid;
    <span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISHARDLINK) {
	fse-&gt;mode |= FSE_MODE_HLINK;
	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VDIR) {
	    fse-&gt;nlink = (uint64_t)vap-&gt;va_dirlinkcount;
	} <span class="enscript-keyword">else</span> {
	    fse-&gt;nlink = (uint64_t)vap-&gt;va_nlink;
	}
    }    

    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">create_fsevent_from_kevent</span>(vnode_t vp, uint32_t kevents, <span class="enscript-type">struct</span> vnode_attr *vap)
{
    <span class="enscript-type">int</span> fsevent_type=FSE_CONTENT_MODIFIED, len;   <span class="enscript-comment">// the default is the most pessimistic
</span>    <span class="enscript-type">char</span> pathbuf[MAXPATHLEN];
    fse_info fse;

    
    <span class="enscript-keyword">if</span> (kevents &amp; VNODE_EVENT_DELETE) {
        fsevent_type = FSE_DELETE;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kevents &amp; (VNODE_EVENT_EXTEND|VNODE_EVENT_WRITE)) {
	fsevent_type = FSE_CONTENT_MODIFIED;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kevents &amp; VNODE_EVENT_LINK) {
	fsevent_type = FSE_CREATE_FILE;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kevents &amp; VNODE_EVENT_RENAME) {
	fsevent_type = FSE_CREATE_FILE;    <span class="enscript-comment">// XXXdbg - should use FSE_RENAME but we don't have the destination info;
</span>    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kevents &amp; (VNODE_EVENT_FILE_CREATED|VNODE_EVENT_FILE_REMOVED|VNODE_EVENT_DIR_CREATED|VNODE_EVENT_DIR_REMOVED)) {
	fsevent_type = FSE_STAT_CHANGED;  <span class="enscript-comment">// XXXdbg - because vp is a dir and the thing created/removed lived inside it
</span>    } <span class="enscript-keyword">else</span> {   <span class="enscript-comment">// a catch all for VNODE_EVENT_PERMS, VNODE_EVENT_ATTRIB and anything else
</span>        fsevent_type = FSE_STAT_CHANGED;
    }

    <span class="enscript-comment">// printf(&quot;convert_kevent: kevents 0x%x fsevent type 0x%x (for %s)\n&quot;, kevents, fsevent_type, vp-&gt;v_name ? vp-&gt;v_name : &quot;(no-name)&quot;);
</span>
    fse.dev = vap-&gt;va_fsid;
    fse.ino = vap-&gt;va_fileid;
    fse.mode = vnode_vttoif(vnode_vtype(vp)) | (uint32_t)vap-&gt;va_mode;
    <span class="enscript-keyword">if</span> (vp-&gt;v_flag &amp; VISHARDLINK) {
	fse.mode |= FSE_MODE_HLINK;
	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VDIR) {
	    fse.nlink = vap-&gt;va_dirlinkcount;
	} <span class="enscript-keyword">else</span> {
	    fse.nlink = vap-&gt;va_nlink;
	}
    }

    <span class="enscript-keyword">if</span> (vp-&gt;v_type == VDIR) {
	fse.mode |= FSE_REMOTE_DIR_EVENT;	
    }
    

    fse.uid = vap-&gt;va_uid;
    fse.gid = vap-&gt;va_gid;

    len = <span class="enscript-keyword">sizeof</span>(pathbuf);
    <span class="enscript-keyword">if</span> (vn_getpath(vp, pathbuf, &amp;len) == 0) {
	add_fsevent(fsevent_type, vfs_context_current(), FSE_ARG_STRING, len, pathbuf, FSE_ARG_FINFO, &amp;fse, FSE_ARG_DONE);
    }
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* CONFIG_FSE */</span>
<span class="enscript-comment">/*
 * The get_pathbuff and release_pathbuff routines are used in places not
 * related to fsevents, and it's a handy abstraction, so define trivial
 * versions that don't cache a pool of buffers.  This way, we don't have
 * to conditionalize the callers, and they still get the advantage of the
 * pool of buffers if CONFIG_FSE is turned on.
 */</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">get_pathbuff</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">char</span> *path;
	MALLOC_ZONE(path, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK);
	<span class="enscript-keyword">return</span> path;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">release_pathbuff</span>(<span class="enscript-type">char</span> *path)
{
	FREE_ZONE(path, MAXPATHLEN, M_NAMEI);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FSE */</span>
</pre>
<hr />
</body></html>