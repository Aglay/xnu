<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_attrlist.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_attrlist.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1995-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/attr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/xattr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsevents.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_TIME_SIZE</span>	-1

<span class="enscript-comment">/*
 * Structure describing the state of an in-progress attrlist operation.
 */</span>
<span class="enscript-type">struct</span> _attrlist_buf {
	<span class="enscript-type">char</span>	*base;
	<span class="enscript-type">char</span>	*fixedcursor;
	<span class="enscript-type">char</span>	*varcursor;
	ssize_t	allocated;
	ssize_t needed;
	attribute_set_t	actual;
	attribute_set_t valid;
};


<span class="enscript-comment">/*
 * Attempt to pack a fixed width attribute of size (count) bytes from
 * source to our attrlist buffer.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">attrlist_pack_fixed</span>(<span class="enscript-type">struct</span> _attrlist_buf *ab, <span class="enscript-type">void</span> *source, ssize_t count)
{
	<span class="enscript-comment">/* 
	 * Use ssize_t for pointer math purposes,
	 * since a ssize_t is a signed long
	 */</span>
	ssize_t	fit;

	<span class="enscript-comment">/*
	 * Compute the amount of remaining space in the attrlist buffer
	 * based on how much we've used for fixed width fields vs. the
	 * start of the attributes.  
	 * 
	 * If we've still got room, then 'fit' will contain the amount of 
	 * remaining space.  
	 * 
	 * Note that this math is safe because, in the event that the 
	 * fixed-width cursor has moved beyond the end of the buffer,
	 * then, the second input into lmin() below will be negative, and 
	 * we will fail the (fit &gt; 0) check below. 
	 */</span> 
	fit = lmin(count, ab-&gt;allocated - (ab-&gt;fixedcursor - ab-&gt;base));
	<span class="enscript-keyword">if</span> (fit &gt; 0) {
		<span class="enscript-comment">/* Copy in as much as we can */</span>
		bcopy(source, ab-&gt;fixedcursor, fit);
	}

	<span class="enscript-comment">/* always move in increments of 4, even if we didn't pack an attribute. */</span>
	ab-&gt;fixedcursor += roundup(count, 4);
}

<span class="enscript-comment">/*
 * Attempt to pack one (or two) variable width attributes into the attrlist
 * buffer.  If we are trying to pack two variable width attributes, they are treated
 * as a single variable-width attribute from the POV of the system call caller.
 * 
 * Recall that a variable-width attribute has two components: the fixed-width 
 * attribute that tells the caller where to look, and the actual variable width data.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">attrlist_pack_variable2</span>(<span class="enscript-type">struct</span> _attrlist_buf *ab, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *source, ssize_t count, 
		<span class="enscript-type">const</span> <span class="enscript-type">void</span> *ext, ssize_t extcount) 
{
	<span class="enscript-comment">/* Use ssize_t's for pointer math ease */</span>
	<span class="enscript-type">struct</span> attrreference ar;
	ssize_t fit;

	<span class="enscript-comment">/*
	 * Pack the fixed-width component to the variable object. 
	 * Note that we may be able to pack the fixed width attref, but not
	 * the variable (if there's no room).
	 */</span>
	ar.attr_dataoffset = ab-&gt;varcursor - ab-&gt;fixedcursor;
	ar.attr_length = count + extcount;
	attrlist_pack_fixed(ab, &amp;ar, <span class="enscript-keyword">sizeof</span>(ar));

	<span class="enscript-comment">/* 
	 * Use an lmin() to do a signed comparison. We use a signed comparison
	 * to detect the 'out of memory' conditions as described above in the
	 * fixed width check above.
	 *
	 * Then pack the first variable attribute as space allows.  Note that we advance
	 * the variable cursor only if we we had some available space. 
	 */</span>
	fit = lmin(count, ab-&gt;allocated - (ab-&gt;varcursor - ab-&gt;base));
	<span class="enscript-keyword">if</span> (fit &gt; 0) {
		<span class="enscript-keyword">if</span> (source != NULL) {
			bcopy(source, ab-&gt;varcursor, fit);
		}
		ab-&gt;varcursor += fit;
	}

	<span class="enscript-comment">/* Compute the available space for the second attribute */</span>
	fit = lmin(extcount, ab-&gt;allocated - (ab-&gt;varcursor - ab-&gt;base));
	<span class="enscript-keyword">if</span> (fit &gt; 0) {
		<span class="enscript-comment">/* Copy in data for the second attribute (if needed) if there is room */</span>
		<span class="enscript-keyword">if</span> (ext != NULL) {
			bcopy(ext, ab-&gt;varcursor, fit);
		}
		ab-&gt;varcursor += fit;
	}
	<span class="enscript-comment">/* always move in increments of 4 */</span>
	ab-&gt;varcursor = (<span class="enscript-type">char</span> *)roundup((uintptr_t)ab-&gt;varcursor, 4);
}

<span class="enscript-comment">/* 
 * Packing a single variable-width attribute is the same as calling the two, but with
 * an invalid 2nd attribute.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">attrlist_pack_variable</span>(<span class="enscript-type">struct</span> _attrlist_buf *ab, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *source, ssize_t count)
{
	attrlist_pack_variable2(ab, source, count, NULL, 0);
}

<span class="enscript-comment">/*
 * Attempt to pack a string. This is a special case of a variable width attribute.
 *
 * If &quot;source&quot; is NULL, then an empty string (&quot;&quot;) will be packed.  If &quot;source&quot; is
 * not NULL, but &quot;count&quot; is zero, then &quot;source&quot; is assumed to be a NUL-terminated
 * C-string.  If &quot;source&quot; is not NULL and &quot;count&quot; is not zero, then only the first
 * &quot;count&quot; bytes of &quot;source&quot; will be copied, and a NUL terminator will be added.
 *
 * If the attrlist buffer doesn't have enough room to hold the entire string (including
 * NUL terminator), then copy as much as will fit.  The attrlist buffer's &quot;varcursor&quot;
 * will always be updated based on the entire length of the string (including NUL
 * terminator); this means &quot;varcursor&quot; may end up pointing beyond the end of the
 * allocated buffer space.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">attrlist_pack_string</span>(<span class="enscript-type">struct</span> _attrlist_buf *ab, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *source, ssize_t count)
{
	<span class="enscript-type">struct</span> attrreference ar;
	ssize_t fit, space;

	<span class="enscript-comment">/*
	 * Supplied count is character count of string text, excluding trailing nul
	 * which we always supply here.
	 */</span>
	<span class="enscript-keyword">if</span> (source == NULL) {
		count = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (count == 0) {
		count = strlen(source);
	}

	<span class="enscript-comment">/*
	 * Construct the fixed-width attribute that refers to this string. 
	 */</span>
	ar.attr_dataoffset = ab-&gt;varcursor - ab-&gt;fixedcursor;
	ar.attr_length = count + 1;
	attrlist_pack_fixed(ab, &amp;ar, <span class="enscript-keyword">sizeof</span>(ar));

	<span class="enscript-comment">/*
	 * Now compute how much available memory we have to copy the string text.
	 *
	 * space = the number of bytes available in the attribute buffer to hold the
	 *         string's value.
	 *
	 * fit = the number of bytes to copy from the start of the string into the
	 *       attribute buffer, NOT including the NUL terminator.  If the attribute
	 *       buffer is large enough, this will be the string's length; otherwise, it
	 *       will be equal to &quot;space&quot;.
	 */</span>
	space = ab-&gt;allocated - (ab-&gt;varcursor - ab-&gt;base);
	fit = lmin(count, space);
	<span class="enscript-keyword">if</span> (space &gt; 0) {
		<span class="enscript-type">int</span> bytes_to_zero;

		<span class="enscript-comment">/* 
		 * If there is space remaining, copy data in, and 
		 * accommodate the trailing NUL terminator.
		 *
		 * NOTE: if &quot;space&quot; is too small to hold the string and its NUL
		 * terminator (space &lt; fit + 1), then the string value in the attribute
		 * buffer will NOT be NUL terminated!
		 *
		 * NOTE 2: bcopy() will do nothing if the length (&quot;fit&quot;) is zero.
		 * Therefore, we don't bother checking for that here.
		 */</span>
		bcopy(source, ab-&gt;varcursor, fit);
		<span class="enscript-comment">/* is there room for our trailing nul? */</span>
		<span class="enscript-keyword">if</span> (space &gt; fit) {
			ab-&gt;varcursor[fit++] = <span class="enscript-string">'\0'</span>;
			<span class="enscript-comment">/* 'fit' now the number of bytes AFTER adding in the NUL */</span>
			<span class="enscript-comment">/*
			 * Zero out any additional bytes we might have as a
			 * result of rounding up.
			 */</span>
			bytes_to_zero = min((roundup(fit, 4) - fit),
			    space - fit);
			<span class="enscript-keyword">if</span> (bytes_to_zero)
				bzero(&amp;(ab-&gt;varcursor[fit]), bytes_to_zero);
		}
	}
	<span class="enscript-comment">/* 
	 * always move in increments of 4 (including the trailing NUL)
	 */</span>
	ab-&gt;varcursor += roundup((count+1), 4);

}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ATTR_PACK4</span>(AB, V)                                                 \
	<span class="enscript-keyword">do</span> {                                                              \
		<span class="enscript-keyword">if</span> ((AB.allocated - (AB.fixedcursor - AB.base)) &gt;= 4) {   \
			*(uint32_t *)AB.fixedcursor = V;                  \
			AB.fixedcursor += 4;                              \
		}                                                         \
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ATTR_PACK8</span>(AB, V)                                                 \
	<span class="enscript-keyword">do</span> {                                                              \
		<span class="enscript-keyword">if</span> ((AB.allocated - (AB.fixedcursor - AB.base)) &gt;= 8) {   \
			*(uint64_t *)AB.fixedcursor = *(uint64_t *)&amp;V;    \
			AB.fixedcursor += 8;                              \
		}                                                         \
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ATTR_PACK</span>(b, v)	attrlist_pack_fixed(b, &amp;v, sizeof(v))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ATTR_PACK_CAST</span>(b, t, v)						\
	<span class="enscript-keyword">do</span> {								\
		t _f = (t)v;						\
		ATTR_PACK(b, _f);					\
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ATTR_PACK_TIME</span>(b, v, is64)					       		\
	<span class="enscript-keyword">do</span> {										\
		<span class="enscript-keyword">if</span> (is64) {								\
			<span class="enscript-type">struct</span> user64_timespec us = {v.tv_sec, v.tv_nsec};		\
			ATTR_PACK(&amp;b, us);						\
		} <span class="enscript-keyword">else</span> {								\
			<span class="enscript-type">struct</span> user32_timespec us = {v.tv_sec, v.tv_nsec};		\
			ATTR_PACK(&amp;b, us);						\
		}									\
	} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/*
 * Table-driven setup for all valid common/volume attributes.
 */</span>
<span class="enscript-type">struct</span> getvolattrlist_attrtab {
	attrgroup_t	attr;
	uint64_t	bits;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VFSATTR_BIT</span>(b)	(VFSATTR_ ## b)
	ssize_t		size;
};
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> getvolattrlist_attrtab getvolattrlist_common_tab[] = {
	{ATTR_CMN_NAME,		0,				<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> attrreference)},
	{ATTR_CMN_DEVID,	0,				<span class="enscript-keyword">sizeof</span>(dev_t)},
	{ATTR_CMN_FSID,		0,				<span class="enscript-keyword">sizeof</span>(fsid_t)},
	{ATTR_CMN_OBJTYPE,	0,				<span class="enscript-keyword">sizeof</span>(fsobj_type_t)},
	{ATTR_CMN_OBJTAG,	0,				<span class="enscript-keyword">sizeof</span>(fsobj_tag_t)},
	{ATTR_CMN_OBJID,	0,				<span class="enscript-keyword">sizeof</span>(fsobj_id_t)},
	{ATTR_CMN_OBJPERMANENTID, 0,				<span class="enscript-keyword">sizeof</span>(fsobj_id_t)},
	{ATTR_CMN_PAROBJID,	0,				<span class="enscript-keyword">sizeof</span>(fsobj_id_t)},
	{ATTR_CMN_SCRIPT,	0,				<span class="enscript-keyword">sizeof</span>(text_encoding_t)},
	{ATTR_CMN_CRTIME,	VFSATTR_BIT(f_create_time),	ATTR_TIME_SIZE},
	{ATTR_CMN_MODTIME,	VFSATTR_BIT(f_modify_time),	ATTR_TIME_SIZE},
	{ATTR_CMN_CHGTIME,	VFSATTR_BIT(f_modify_time),	ATTR_TIME_SIZE},
	{ATTR_CMN_ACCTIME,	VFSATTR_BIT(f_access_time),	ATTR_TIME_SIZE},
	{ATTR_CMN_BKUPTIME,	VFSATTR_BIT(f_backup_time),	ATTR_TIME_SIZE},
	{ATTR_CMN_FNDRINFO,	0,				32},
	{ATTR_CMN_OWNERID,	0,				<span class="enscript-keyword">sizeof</span>(uid_t)},
	{ATTR_CMN_GRPID,	0,				<span class="enscript-keyword">sizeof</span>(gid_t)},
	{ATTR_CMN_ACCESSMASK,	0,				<span class="enscript-keyword">sizeof</span>(uint32_t)},
	{ATTR_CMN_FLAGS,	0,				<span class="enscript-keyword">sizeof</span>(uint32_t)},
	{ATTR_CMN_USERACCESS,	0,				<span class="enscript-keyword">sizeof</span>(uint32_t)},
	{ATTR_CMN_EXTENDED_SECURITY, 0,				<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> attrreference)},
	{ATTR_CMN_UUID,		0,				<span class="enscript-keyword">sizeof</span>(guid_t)},
	{ATTR_CMN_GRPUUID,	0,				<span class="enscript-keyword">sizeof</span>(guid_t)},
	{ATTR_CMN_FILEID,	0, 				<span class="enscript-keyword">sizeof</span>(uint64_t)},
	{ATTR_CMN_PARENTID,	0,				<span class="enscript-keyword">sizeof</span>(uint64_t)},
	{ATTR_CMN_RETURNED_ATTRS, 0,				<span class="enscript-keyword">sizeof</span>(attribute_set_t)},
	{ATTR_CMN_ERROR,	0,				<span class="enscript-keyword">sizeof</span>(uint32_t)},
	{0, 0, 0}
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATTR_CMN_VOL_INVALID</span> \
	(ATTR_CMN_EXTENDED_SECURITY | ATTR_CMN_UUID | ATTR_CMN_GRPUUID | \
	 ATTR_CMN_FILEID | ATTR_CMN_PARENTID)

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> getvolattrlist_attrtab getvolattrlist_vol_tab[] = {
	{ATTR_VOL_FSTYPE,		0,						<span class="enscript-keyword">sizeof</span>(uint32_t)},
	{ATTR_VOL_SIGNATURE,		VFSATTR_BIT(f_signature),			<span class="enscript-keyword">sizeof</span>(uint32_t)},
	{ATTR_VOL_SIZE,			VFSATTR_BIT(f_blocks),				<span class="enscript-keyword">sizeof</span>(off_t)},
	{ATTR_VOL_SPACEFREE,		VFSATTR_BIT(f_bfree) | VFSATTR_BIT(f_bsize),	<span class="enscript-keyword">sizeof</span>(off_t)},
	{ATTR_VOL_SPACEAVAIL,		VFSATTR_BIT(f_bavail) | VFSATTR_BIT(f_bsize),	<span class="enscript-keyword">sizeof</span>(off_t)},
	{ATTR_VOL_MINALLOCATION,	VFSATTR_BIT(f_bsize),				<span class="enscript-keyword">sizeof</span>(off_t)},
	{ATTR_VOL_ALLOCATIONCLUMP,	VFSATTR_BIT(f_bsize),				<span class="enscript-keyword">sizeof</span>(off_t)},
	{ATTR_VOL_IOBLOCKSIZE,		VFSATTR_BIT(f_iosize),				<span class="enscript-keyword">sizeof</span>(uint32_t)},
	{ATTR_VOL_OBJCOUNT,		VFSATTR_BIT(f_objcount),			<span class="enscript-keyword">sizeof</span>(uint32_t)},
	{ATTR_VOL_FILECOUNT,		VFSATTR_BIT(f_filecount),			<span class="enscript-keyword">sizeof</span>(uint32_t)},
	{ATTR_VOL_DIRCOUNT,		VFSATTR_BIT(f_dircount),			<span class="enscript-keyword">sizeof</span>(uint32_t)},
	{ATTR_VOL_MAXOBJCOUNT,		VFSATTR_BIT(f_maxobjcount),			<span class="enscript-keyword">sizeof</span>(uint32_t)},
	{ATTR_VOL_MOUNTPOINT,		0,						<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> attrreference)},
	{ATTR_VOL_NAME,			VFSATTR_BIT(f_vol_name),			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> attrreference)},
	{ATTR_VOL_MOUNTFLAGS,		0,						<span class="enscript-keyword">sizeof</span>(uint32_t)},
	{ATTR_VOL_MOUNTEDDEVICE,	0,						<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> attrreference)},
	{ATTR_VOL_ENCODINGSUSED,	0,						<span class="enscript-keyword">sizeof</span>(uint64_t)},
	{ATTR_VOL_CAPABILITIES,		VFSATTR_BIT(f_capabilities),			<span class="enscript-keyword">sizeof</span>(vol_capabilities_attr_t)},
	{ATTR_VOL_UUID,			VFSATTR_BIT(f_uuid),				<span class="enscript-keyword">sizeof</span>(uuid_t)},
	{ATTR_VOL_ATTRIBUTES,		VFSATTR_BIT(f_attributes),			<span class="enscript-keyword">sizeof</span>(vol_attributes_attr_t)},
	{ATTR_VOL_INFO, 0, 0},
	{0, 0, 0}
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getvolattrlist_parsetab</span>(<span class="enscript-type">struct</span> getvolattrlist_attrtab *tab, attrgroup_t attrs, <span class="enscript-type">struct</span> vfs_attr *vsp,
    ssize_t *sizep, <span class="enscript-type">int</span> is_64bit)
{
	attrgroup_t	recognised;

	recognised = 0;
	<span class="enscript-keyword">do</span> {
		<span class="enscript-comment">/* is this attribute set? */</span>
		<span class="enscript-keyword">if</span> (tab-&gt;attr &amp; attrs) {
			recognised |= tab-&gt;attr;
			vsp-&gt;f_active |= tab-&gt;bits;
			<span class="enscript-keyword">if</span> (tab-&gt;size == ATTR_TIME_SIZE) {
				<span class="enscript-keyword">if</span> (is_64bit) {
					*sizep += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_timespec);
				} <span class="enscript-keyword">else</span> {
					*sizep += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_timespec);
				}
			} <span class="enscript-keyword">else</span> {
				*sizep += tab-&gt;size;
			}
		}
	} <span class="enscript-keyword">while</span> ((++tab)-&gt;attr != 0);
	
	<span class="enscript-comment">/* check to make sure that we recognised all of the passed-in attributes */</span>
	<span class="enscript-keyword">if</span> (attrs &amp; ~recognised)
		<span class="enscript-keyword">return</span>(EINVAL);
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Given the attributes listed in alp, configure vap to request
 * the data from a filesystem.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getvolattrlist_setupvfsattr</span>(<span class="enscript-type">struct</span> attrlist *alp, <span class="enscript-type">struct</span> vfs_attr *vsp, ssize_t *sizep, <span class="enscript-type">int</span> is_64bit)
{
	<span class="enscript-type">int</span>	error;

	<span class="enscript-comment">/*
	 * Parse the above tables.
	 */</span>
	*sizep = <span class="enscript-keyword">sizeof</span>(uint32_t);	<span class="enscript-comment">/* length count */</span>
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr) {
		<span class="enscript-keyword">if</span> ((alp-&gt;commonattr &amp; ATTR_CMN_VOL_INVALID) &amp;&amp;
		    (alp-&gt;commonattr &amp; ATTR_CMN_RETURNED_ATTRS) == 0) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-keyword">if</span> ((error = getvolattrlist_parsetab(getvolattrlist_common_tab,
		                                    alp-&gt;commonattr, vsp, sizep,
		                                    is_64bit)) != 0) {
			<span class="enscript-keyword">return</span>(error);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp;&amp;
	    (error = getvolattrlist_parsetab(getvolattrlist_vol_tab, alp-&gt;volattr, vsp, sizep, is_64bit)) != 0)
		<span class="enscript-keyword">return</span>(error);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Given the attributes listed in asp and those supported
 * in the vsp, fixup the asp attributes to reflect any
 * missing attributes from the file system
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">getvolattrlist_fixupattrs</span>(attribute_set_t *asp, <span class="enscript-type">struct</span> vfs_attr *vsp)
{
	<span class="enscript-type">struct</span> getvolattrlist_attrtab *tab;

	<span class="enscript-keyword">if</span> (asp-&gt;commonattr) {
		tab = getvolattrlist_common_tab;
		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> ((tab-&gt;attr &amp; asp-&gt;commonattr) &amp;&amp;
			    (tab-&gt;bits != 0) &amp;&amp;
			    ((tab-&gt;bits &amp; vsp-&gt;f_supported) == 0)) {
				asp-&gt;commonattr &amp;= ~tab-&gt;attr;
			}
		} <span class="enscript-keyword">while</span> ((++tab)-&gt;attr != 0);
	}
	<span class="enscript-keyword">if</span> (asp-&gt;volattr) {
		tab = getvolattrlist_vol_tab;
		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> ((tab-&gt;attr &amp; asp-&gt;volattr) &amp;&amp;
			    (tab-&gt;bits != 0) &amp;&amp;
			    ((tab-&gt;bits &amp; vsp-&gt;f_supported) == 0)) {
				asp-&gt;volattr &amp;= ~tab-&gt;attr;
			}
		} <span class="enscript-keyword">while</span> ((++tab)-&gt;attr != 0);
	}
}

<span class="enscript-comment">/*
 * Table-driven setup for all valid common/dir/file/fork attributes against files.
 */</span>
<span class="enscript-type">struct</span> getattrlist_attrtab {
	attrgroup_t	attr;
	uint64_t	bits;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VATTR_BIT</span>(b)	(VNODE_ATTR_ ## b)
	ssize_t		size;
	kauth_action_t	action;
};

<span class="enscript-comment">/* 
 * A zero after the ATTR_ bit indicates that we don't expect the underlying FS to report back with this 
 * information, and we will synthesize it at the VFS level.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> getattrlist_attrtab getattrlist_common_tab[] = {
	{ATTR_CMN_NAME,		VATTR_BIT(va_name),		<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> attrreference),	KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_DEVID,	0,				<span class="enscript-keyword">sizeof</span>(dev_t),			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_FSID,		0,				<span class="enscript-keyword">sizeof</span>(fsid_t),			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_OBJTYPE,	0,				<span class="enscript-keyword">sizeof</span>(fsobj_type_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_OBJTAG,	0,				<span class="enscript-keyword">sizeof</span>(fsobj_tag_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_OBJID,	VATTR_BIT(va_fileid) | VATTR_BIT(va_linkid), <span class="enscript-keyword">sizeof</span>(fsobj_id_t), KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_OBJPERMANENTID, VATTR_BIT(va_fileid) | VATTR_BIT(va_linkid), <span class="enscript-keyword">sizeof</span>(fsobj_id_t), KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_PAROBJID,	VATTR_BIT(va_parentid),		<span class="enscript-keyword">sizeof</span>(fsobj_id_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_SCRIPT,	VATTR_BIT(va_encoding),		<span class="enscript-keyword">sizeof</span>(text_encoding_t),	KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_CRTIME,	VATTR_BIT(va_create_time),	ATTR_TIME_SIZE,			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_MODTIME,	VATTR_BIT(va_modify_time),	ATTR_TIME_SIZE,			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_CHGTIME,	VATTR_BIT(va_change_time),	ATTR_TIME_SIZE,			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_ACCTIME,	VATTR_BIT(va_access_time),	ATTR_TIME_SIZE,			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_BKUPTIME,	VATTR_BIT(va_backup_time),	ATTR_TIME_SIZE,			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_FNDRINFO,	0,				32,				KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_OWNERID,	VATTR_BIT(va_uid),		<span class="enscript-keyword">sizeof</span>(uid_t),			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_GRPID,	VATTR_BIT(va_gid),		<span class="enscript-keyword">sizeof</span>(gid_t),			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_ACCESSMASK,	VATTR_BIT(va_mode),		<span class="enscript-keyword">sizeof</span>(uint32_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_FLAGS,	VATTR_BIT(va_flags),		<span class="enscript-keyword">sizeof</span>(uint32_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_GEN_COUNT,	VATTR_BIT(va_write_gencount),	<span class="enscript-keyword">sizeof</span>(uint32_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_DOCUMENT_ID,	VATTR_BIT(va_document_id),	<span class="enscript-keyword">sizeof</span>(uint32_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_USERACCESS,	0,				<span class="enscript-keyword">sizeof</span>(uint32_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_EXTENDED_SECURITY, VATTR_BIT(va_acl),		<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> attrreference),	KAUTH_VNODE_READ_SECURITY},
	{ATTR_CMN_UUID,		VATTR_BIT(va_uuuid),		<span class="enscript-keyword">sizeof</span>(guid_t),			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_GRPUUID,	VATTR_BIT(va_guuid),		<span class="enscript-keyword">sizeof</span>(guid_t),			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_FILEID,	VATTR_BIT(va_fileid), 		<span class="enscript-keyword">sizeof</span>(uint64_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_PARENTID,	VATTR_BIT(va_parentid),		<span class="enscript-keyword">sizeof</span>(uint64_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_FULLPATH, 	0, 				<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> attrreference),	KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_ADDEDTIME, 	VATTR_BIT(va_addedtime), 	ATTR_TIME_SIZE,			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_RETURNED_ATTRS, 0,				<span class="enscript-keyword">sizeof</span>(attribute_set_t),	0},
	{ATTR_CMN_ERROR, 	0,				<span class="enscript-keyword">sizeof</span>(uint32_t),		0},
	{ATTR_CMN_DATA_PROTECT_FLAGS, VATTR_BIT(va_dataprotect_class), <span class="enscript-keyword">sizeof</span>(uint32_t),	KAUTH_VNODE_READ_ATTRIBUTES},
	{0, 0, 0, 0}
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> getattrlist_attrtab getattrlist_dir_tab[] = {
	{ATTR_DIR_LINKCOUNT,	VATTR_BIT(va_dirlinkcount),	<span class="enscript-keyword">sizeof</span>(uint32_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_DIR_ENTRYCOUNT,	VATTR_BIT(va_nchildren),	<span class="enscript-keyword">sizeof</span>(uint32_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_DIR_MOUNTSTATUS,	0,				<span class="enscript-keyword">sizeof</span>(uint32_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{0, 0, 0, 0}
};
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> getattrlist_attrtab getattrlist_file_tab[] = {
	{ATTR_FILE_LINKCOUNT,	VATTR_BIT(va_nlink),		<span class="enscript-keyword">sizeof</span>(uint32_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_FILE_TOTALSIZE,	VATTR_BIT(va_total_size),	<span class="enscript-keyword">sizeof</span>(off_t),			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_FILE_ALLOCSIZE,	VATTR_BIT(va_total_alloc) | VATTR_BIT(va_total_size), <span class="enscript-keyword">sizeof</span>(off_t), KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_FILE_IOBLOCKSIZE,	VATTR_BIT(va_iosize),		<span class="enscript-keyword">sizeof</span>(uint32_t),		KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_FILE_DEVTYPE,	VATTR_BIT(va_rdev),		<span class="enscript-keyword">sizeof</span>(dev_t),			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_FILE_DATALENGTH,	VATTR_BIT(va_total_size) | VATTR_BIT(va_data_size), <span class="enscript-keyword">sizeof</span>(off_t), KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_FILE_DATAALLOCSIZE, VATTR_BIT(va_total_alloc)| VATTR_BIT(va_data_alloc), <span class="enscript-keyword">sizeof</span>(off_t), KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_FILE_RSRCLENGTH,	0,				<span class="enscript-keyword">sizeof</span>(off_t),			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_FILE_RSRCALLOCSIZE, 0,				<span class="enscript-keyword">sizeof</span>(off_t),			KAUTH_VNODE_READ_ATTRIBUTES},
	{0, 0, 0, 0}
};	

<span class="enscript-comment">/*
 * This table is for attributes which are only set from the getattrlistbulk(2)
 * call. These attributes have already been set from the common, file and
 * directory tables but the vattr bits have not been recorded. Since these
 * vattr bits are only used from the bulk call, we have a seperate table for
 * these.
 * The sizes are not returned from here since the sizes have already been
 * accounted from the common, file and directory tables.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> getattrlist_attrtab getattrlistbulk_common_tab[] = {
	{ATTR_CMN_DEVID,	VATTR_BIT(va_devid),		0,			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_FSID,		VATTR_BIT(va_fsid64),		0,			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_OBJTYPE,	VATTR_BIT(va_objtype),		0,			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_OBJTAG,	VATTR_BIT(va_objtag),		0,			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_USERACCESS,	VATTR_BIT(va_user_access),	0,			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_CMN_FNDRINFO,	VATTR_BIT(va_finderinfo),	0,			KAUTH_VNODE_READ_ATTRIBUTES},
	{0, 0, 0, 0}
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> getattrlist_attrtab getattrlistbulk_file_tab[] = {
	{ATTR_FILE_RSRCLENGTH,	VATTR_BIT(va_rsrc_length),	0,			KAUTH_VNODE_READ_ATTRIBUTES},
	{ATTR_FILE_RSRCALLOCSIZE, VATTR_BIT(va_rsrc_alloc),	0,			KAUTH_VNODE_READ_ATTRIBUTES},
	{0, 0, 0, 0}
};

<span class="enscript-comment">/*
 * The following are attributes that VFS can derive.
 *
 * A majority of them are the same attributes that are required for stat(2) and statfs(2).
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_DFLT_ATTR_VOL</span>	(ATTR_VOL_FSTYPE | ATTR_VOL_SIGNATURE |  \
				 ATTR_VOL_SIZE | ATTR_VOL_SPACEFREE |  \
				 ATTR_VOL_SPACEAVAIL | ATTR_VOL_MINALLOCATION |  \
				 ATTR_VOL_ALLOCATIONCLUMP |  ATTR_VOL_IOBLOCKSIZE |  \
				 ATTR_VOL_MOUNTPOINT | ATTR_VOL_MOUNTFLAGS |  \
				 ATTR_VOL_MOUNTEDDEVICE | ATTR_VOL_CAPABILITIES |  \
				 ATTR_VOL_ATTRIBUTES | ATTR_VOL_ENCODINGSUSED)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_DFLT_ATTR_CMN</span>	(ATTR_CMN_NAME | ATTR_CMN_DEVID |  \
				 ATTR_CMN_FSID | ATTR_CMN_OBJTYPE |  \
				 ATTR_CMN_OBJTAG | ATTR_CMN_OBJID |  \
				 ATTR_CMN_PAROBJID | ATTR_CMN_SCRIPT |  \
				 ATTR_CMN_MODTIME | ATTR_CMN_CHGTIME |  \
				 ATTR_CMN_FNDRINFO |  \
				 ATTR_CMN_OWNERID  | ATTR_CMN_GRPID |  \
				 ATTR_CMN_ACCESSMASK | ATTR_CMN_FLAGS |  \
				 ATTR_CMN_USERACCESS | ATTR_CMN_FILEID | \
				 ATTR_CMN_PARENTID | ATTR_CMN_RETURNED_ATTRS | \
				 ATTR_CMN_DOCUMENT_ID | ATTR_CMN_GEN_COUNT | \
				 ATTR_CMN_DATA_PROTECT_FLAGS)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_DFLT_ATT_CMN_EXT</span>	(ATTR_CMN_EXT_GEN_COUNT | ATTR_CMN_EXT_DOCUMENT_ID |\
				 ATTR_CMN_EXT_DATA_PROTECT_FLAGS)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_DFLT_ATTR_DIR</span>	(ATTR_DIR_LINKCOUNT | ATTR_DIR_MOUNTSTATUS)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VFS_DFLT_ATTR_FILE</span>	(ATTR_FILE_LINKCOUNT | ATTR_FILE_TOTALSIZE |  \
				 ATTR_FILE_ALLOCSIZE  | ATTR_FILE_IOBLOCKSIZE |  \
				 ATTR_FILE_DEVTYPE | ATTR_FILE_DATALENGTH |  \
				 ATTR_FILE_DATAALLOCSIZE | ATTR_FILE_RSRCLENGTH |  \
				 ATTR_FILE_RSRCALLOCSIZE)

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getattrlist_parsetab</span>(<span class="enscript-type">struct</span> getattrlist_attrtab *tab, attrgroup_t attrs,
    <span class="enscript-type">struct</span> vnode_attr *vap, ssize_t *sizep, kauth_action_t *actionp,
    <span class="enscript-type">int</span> is_64bit)
{
	attrgroup_t	recognised;

	recognised = 0;
	<span class="enscript-keyword">do</span> {
		<span class="enscript-comment">/* is this attribute set? */</span>
		<span class="enscript-keyword">if</span> (tab-&gt;attr &amp; attrs) {
			recognised |= tab-&gt;attr;
			<span class="enscript-keyword">if</span> (vap)
				vap-&gt;va_active |= tab-&gt;bits;
			<span class="enscript-keyword">if</span> (sizep) {
				<span class="enscript-keyword">if</span> (tab-&gt;size == ATTR_TIME_SIZE) {
					<span class="enscript-keyword">if</span> (is_64bit) {
						*sizep += <span class="enscript-keyword">sizeof</span>(
						    <span class="enscript-type">struct</span> user64_timespec);
					} <span class="enscript-keyword">else</span> {
						*sizep += <span class="enscript-keyword">sizeof</span>(
						    <span class="enscript-type">struct</span> user32_timespec);
					}
				} <span class="enscript-keyword">else</span> {
					*sizep += tab-&gt;size;
				}
			}
			<span class="enscript-keyword">if</span> (actionp)
				*actionp |= tab-&gt;action;
			<span class="enscript-keyword">if</span> (attrs == recognised)
				<span class="enscript-keyword">break</span>;  <span class="enscript-comment">/* all done, get out */</span>
		}
	} <span class="enscript-keyword">while</span> ((++tab)-&gt;attr != 0);
	
	<span class="enscript-comment">/* check to make sure that we recognised all of the passed-in attributes */</span>
	<span class="enscript-keyword">if</span> (attrs &amp; ~recognised)
		<span class="enscript-keyword">return</span>(EINVAL);
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Given the attributes listed in alp, configure vap to request
 * the data from a filesystem.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getattrlist_setupvattr</span>(<span class="enscript-type">struct</span> attrlist *alp, <span class="enscript-type">struct</span> vnode_attr *vap, ssize_t *sizep, kauth_action_t *actionp, <span class="enscript-type">int</span> is_64bit, <span class="enscript-type">int</span> isdir)
{
	<span class="enscript-type">int</span>	error;

	<span class="enscript-comment">/*
	 * Parse the above tables.
	 */</span>
	*sizep = <span class="enscript-keyword">sizeof</span>(uint32_t);	<span class="enscript-comment">/* length count */</span>
	*actionp = 0;
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp;&amp;
	    (error = getattrlist_parsetab(getattrlist_common_tab, alp-&gt;commonattr, vap, sizep, actionp, is_64bit)) != 0)
		<span class="enscript-keyword">return</span>(error);
	<span class="enscript-keyword">if</span> (isdir &amp;&amp; alp-&gt;dirattr &amp;&amp;
	    (error = getattrlist_parsetab(getattrlist_dir_tab, alp-&gt;dirattr, vap, sizep, actionp, is_64bit)) != 0)
		<span class="enscript-keyword">return</span>(error);
	<span class="enscript-keyword">if</span> (!isdir &amp;&amp; alp-&gt;fileattr &amp;&amp;
	    (error = getattrlist_parsetab(getattrlist_file_tab, alp-&gt;fileattr, vap, sizep, actionp, is_64bit)) != 0)
		<span class="enscript-keyword">return</span>(error);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Given the attributes listed in alp, configure vap to request
 * the data from a filesystem.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getattrlist_setupvattr_all</span>(<span class="enscript-type">struct</span> attrlist *alp, <span class="enscript-type">struct</span> vnode_attr *vap,
    <span class="enscript-type">enum</span> vtype obj_type, ssize_t *fixedsize, <span class="enscript-type">int</span> is_64bit)
{
	<span class="enscript-type">int</span>	error = 0;

	<span class="enscript-comment">/*
	 * Parse the above tables.
	 */</span>
	<span class="enscript-keyword">if</span> (fixedsize) {
		*fixedsize = <span class="enscript-keyword">sizeof</span>(uint32_t);
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr) {
		error = getattrlist_parsetab(getattrlist_common_tab,
		    alp-&gt;commonattr, vap, fixedsize, NULL, is_64bit);

		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/* Ignore any errrors from the bulk table */</span>
			(<span class="enscript-type">void</span>)getattrlist_parsetab(getattrlistbulk_common_tab,
			    alp-&gt;commonattr, vap, fixedsize, NULL, is_64bit);
			<span class="enscript-comment">/*
			 * turn off va_fsid since we will be using only
			 * va_fsid64 for ATTR_CMN_FSID.
			 */</span>
			VATTR_CLEAR_ACTIVE(vap, va_fsid);
		}
	}

	<span class="enscript-keyword">if</span> (!error &amp;&amp; (obj_type == VNON || obj_type == VDIR) &amp;&amp; alp-&gt;dirattr) {
		error = getattrlist_parsetab(getattrlist_dir_tab, alp-&gt;dirattr,
	            vap, fixedsize, NULL, is_64bit);
	}

	<span class="enscript-keyword">if</span> (!error &amp;&amp; (obj_type != VDIR) &amp;&amp; alp-&gt;fileattr) {
		error = getattrlist_parsetab(getattrlist_file_tab,
		    alp-&gt;fileattr, vap, fixedsize, NULL, is_64bit);

		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/*Ignore any errors from the bulk table */</span>
			(<span class="enscript-type">void</span>)getattrlist_parsetab(getattrlistbulk_file_tab,
			    alp-&gt;fileattr, vap, fixedsize, NULL, is_64bit);
		}
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_setup_vattr_from_attrlist</span>(<span class="enscript-type">struct</span> attrlist *alp, <span class="enscript-type">struct</span> vnode_attr *vap,
    <span class="enscript-type">enum</span> vtype obj_vtype, ssize_t *attrs_fixed_sizep, vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span> (getattrlist_setupvattr_all(alp, vap, obj_vtype,
	    attrs_fixed_sizep, IS_64BIT_PROCESS(vfs_context_proc(ctx))));
}




<span class="enscript-comment">/*
 * Given the attributes listed in asp and those supported
 * in the vap, fixup the asp attributes to reflect any
 * missing attributes from the file system
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">getattrlist_fixupattrs</span>(attribute_set_t *asp, <span class="enscript-type">struct</span> vnode_attr *vap)
{
	<span class="enscript-type">struct</span> getattrlist_attrtab *tab;

	<span class="enscript-keyword">if</span> (asp-&gt;commonattr) {
		tab = getattrlist_common_tab;
		<span class="enscript-keyword">do</span> {
            <span class="enscript-comment">/* 
			 * This if() statement is slightly confusing. We're trying to
			 * iterate through all of the bits listed in the array 
			 * getattr_common_tab, and see if the filesystem was expected
			 * to support it, and whether or not we need to do anything about this.
			 * 
			 * This array is full of structs that have 4 fields (attr, bits, size, action).
			 * The first is used to store the ATTR_CMN_* bit that was being requested 
			 * from userland.  The second stores the VATTR_BIT corresponding to the field
			 * filled in vnode_attr struct.  If it is 0, then we don't typically expect
			 * the filesystem to fill in this field.  The third is the size of the field,
			 * and the fourth is the type of kauth actions needed.
			 *
			 * So, for all of the ATTR_CMN bits listed in this array, we iterate through 
			 * them, and check to see if it was both passed down to the filesystem via the
			 * va_active bitfield, and whether or not we expect it to be emitted from
			 * the filesystem.  If it wasn't supported, then we un-twiddle the bit and move
			 * on.  This is done so that we can uncheck those bits and re-request
			 * a vnode_getattr from the filesystem again.
			 */</span>
			<span class="enscript-keyword">if</span> ((tab-&gt;attr &amp; asp-&gt;commonattr) &amp;&amp;
			    (tab-&gt;bits &amp; vap-&gt;va_active) &amp;&amp;
			    (tab-&gt;bits &amp; vap-&gt;va_supported) == 0) {
				asp-&gt;commonattr &amp;= ~tab-&gt;attr;
			}
		} <span class="enscript-keyword">while</span> ((++tab)-&gt;attr != 0);
	}
	<span class="enscript-keyword">if</span> (asp-&gt;dirattr) {
		tab = getattrlist_dir_tab;
		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> ((tab-&gt;attr &amp; asp-&gt;dirattr) &amp;&amp;
			    (tab-&gt;bits &amp; vap-&gt;va_active) &amp;&amp;
			    (vap-&gt;va_supported &amp; tab-&gt;bits) == 0) {
				asp-&gt;dirattr &amp;= ~tab-&gt;attr;
			}
		} <span class="enscript-keyword">while</span> ((++tab)-&gt;attr != 0);
	}
	<span class="enscript-keyword">if</span> (asp-&gt;fileattr) {
		tab = getattrlist_file_tab;
		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> ((tab-&gt;attr &amp; asp-&gt;fileattr) &amp;&amp;
			    (tab-&gt;bits &amp; vap-&gt;va_active) &amp;&amp;
			    (vap-&gt;va_supported &amp; tab-&gt;bits) == 0) {
				asp-&gt;fileattr &amp;= ~tab-&gt;attr;
			}
		} <span class="enscript-keyword">while</span> ((++tab)-&gt;attr != 0);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">setattrlist_setfinderinfo</span>(vnode_t vp, <span class="enscript-type">char</span> *fndrinfo, <span class="enscript-type">struct</span> vfs_context *ctx)
{
	uio_t	auio;
	<span class="enscript-type">char</span>	uio_buf[UIO_SIZEOF(1)];
	<span class="enscript-type">int</span>	error;

	<span class="enscript-keyword">if</span> ((auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_WRITE, uio_buf, <span class="enscript-keyword">sizeof</span>(uio_buf))) == NULL) {
		error = ENOMEM;
	} <span class="enscript-keyword">else</span> {
		uio_addiov(auio, CAST_USER_ADDR_T(fndrinfo), 32);
		error = vn_setxattr(vp, XATTR_FINDERINFO_NAME, auio, XATTR_NOSECURITY, ctx);
		uio_free(auio);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; need_fsevent(FSE_FINDER_INFO_CHANGED, vp)) {
	    add_fsevent(FSE_FINDER_INFO_CHANGED, ctx, FSE_ARG_VNODE, vp, FSE_ARG_DONE);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Find something resembling a terminal component name in the mountedonname for vp
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">getattrlist_findnamecomp</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *mn, <span class="enscript-type">const</span> <span class="enscript-type">char</span> **np, ssize_t *nl)
{
	<span class="enscript-type">int</span>		counting;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*cp;

	<span class="enscript-comment">/*
	 * We're looking for the last sequence of non / characters, but
	 * not including any trailing / characters.
	 */</span>
	*np = NULL;
	*nl = 0;
	counting = 0;
	<span class="enscript-keyword">for</span> (cp = mn; *cp != 0; cp++) {
		<span class="enscript-keyword">if</span> (!counting) {
			<span class="enscript-comment">/* start of run of chars */</span>
			<span class="enscript-keyword">if</span> (*cp != <span class="enscript-string">'/'</span>) {
				*np = cp;
				counting = 1;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* end of run of chars */</span>
			<span class="enscript-keyword">if</span> (*cp == <span class="enscript-string">'/'</span>) {
				*nl = cp - *np;
				counting = 0;
			}
		}
	}
	<span class="enscript-comment">/* need to close run? */</span>
	<span class="enscript-keyword">if</span> (counting)
		*nl = cp - *np;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getvolattrlist</span>(vfs_context_t ctx, vnode_t vp, <span class="enscript-type">struct</span> attrlist *alp,
               user_addr_t attributeBuffer, size_t bufferSize, uint64_t options,
               <span class="enscript-type">enum</span> uio_seg segflg, <span class="enscript-type">int</span> is_64bit)
{
	<span class="enscript-type">struct</span> vfs_attr vs;
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">struct</span> _attrlist_buf ab;
	<span class="enscript-type">int</span>		error;
	ssize_t		fixedsize, varsize;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*cnp = NULL;	<span class="enscript-comment">/* protected by ATTR_CMN_NAME */</span>
	ssize_t		cnl = 0;	<span class="enscript-comment">/* protected by ATTR_CMN_NAME */</span>
	<span class="enscript-type">int</span>		release_str = 0;
	mount_t		mnt;
	<span class="enscript-type">int</span>		return_valid;
	<span class="enscript-type">int</span>		pack_invalid;

	ab.base = NULL;
	VATTR_INIT(&amp;va);
	VFSATTR_INIT(&amp;vs);
	vs.f_vol_name = NULL;
	mnt = vp-&gt;v_mount;

		
	<span class="enscript-comment">/* Check for special packing semantics */</span>
	return_valid = (alp-&gt;commonattr &amp; ATTR_CMN_RETURNED_ATTRS);
	pack_invalid = (options &amp; FSOPT_PACK_INVAL_ATTRS);
	<span class="enscript-keyword">if</span> (pack_invalid) {
		<span class="enscript-comment">/* FSOPT_PACK_INVAL_ATTRS requires ATTR_CMN_RETURNED_ATTRS */</span>
		<span class="enscript-keyword">if</span> (!return_valid) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* Keep invalid attrs from being uninitialized */</span>
		bzero(&amp;vs, <span class="enscript-keyword">sizeof</span> (vs));
		<span class="enscript-comment">/* Generate a valid mask for post processing */</span>
		bcopy(&amp;alp-&gt;commonattr, &amp;ab.valid, <span class="enscript-keyword">sizeof</span> (attribute_set_t));
	}

	<span class="enscript-comment">/*
	 * For now, the vnode must be the root of its filesystem.
	 * To relax this, we need to be able to find the root vnode of a filesystem
	 * from any vnode in the filesystem.
	 */</span>
	<span class="enscript-keyword">if</span> (!vnode_isvroot(vp)) {
		error = EINVAL;
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: volume attributes requested but not the root of a filesystem&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Set up the vfs_attr structure and call the filesystem.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = getvolattrlist_setupvfsattr(alp, &amp;vs, &amp;fixedsize, is_64bit)) != 0) {
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: setup for request failed&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (vs.f_active != 0) {
		<span class="enscript-comment">/* If we're going to ask for f_vol_name, allocate a buffer to point it at */</span>
		<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(&amp;vs, f_vol_name)) {
			vs.f_vol_name = (<span class="enscript-type">char</span> *) kalloc(MAXPATHLEN);
			<span class="enscript-keyword">if</span> (vs.f_vol_name == NULL) {
				error = ENOMEM;
				VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: could not allocate f_vol_name buffer&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_mount_check_getattr(ctx, mnt, &amp;vs);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST -       calling to get %016llx with supported %016llx&quot;</span>, vs.f_active, vs.f_supported);
		<span class="enscript-keyword">if</span> ((error = vfs_getattr(mnt, &amp;vs, ctx)) != 0) {
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: filesystem returned %d&quot;</span>, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/*
		 * Did we ask for something the filesystem doesn't support?
		 */</span>
		<span class="enscript-keyword">if</span> (!VFSATTR_ALL_SUPPORTED(&amp;vs)) {
			<span class="enscript-comment">/* default value for volume subtype */</span>
			<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(&amp;vs, f_fssubtype)
			    &amp;&amp; !VFSATTR_IS_SUPPORTED(&amp;vs, f_fssubtype))
				VFSATTR_RETURN(&amp;vs, f_fssubtype, 0);

			<span class="enscript-comment">/*
			 * If the file system didn't supply f_signature, then
			 * default it to 'BD', which is the generic signature
			 * that most Carbon file systems should return.
			 */</span>
			<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(&amp;vs, f_signature)
			    &amp;&amp; !VFSATTR_IS_SUPPORTED(&amp;vs, f_signature))
				VFSATTR_RETURN(&amp;vs, f_signature, 0x4244);

			<span class="enscript-comment">/* default for block size */</span>
			<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(&amp;vs, f_bsize)
			    &amp;&amp; !VFSATTR_IS_SUPPORTED(&amp;vs, f_bsize))
				VFSATTR_RETURN(&amp;vs, f_bsize, mnt-&gt;mnt_devblocksize);

			<span class="enscript-comment">/* default value for volume f_attributes */</span>
			<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(&amp;vs, f_attributes)
			    &amp;&amp; !VFSATTR_IS_SUPPORTED(&amp;vs, f_attributes)) {
				vol_attributes_attr_t *attrp = &amp;vs.f_attributes;
		
				attrp-&gt;validattr.commonattr = VFS_DFLT_ATTR_CMN;
				attrp-&gt;validattr.volattr = VFS_DFLT_ATTR_VOL;
				attrp-&gt;validattr.dirattr = VFS_DFLT_ATTR_DIR;
				attrp-&gt;validattr.fileattr = VFS_DFLT_ATTR_FILE;
				attrp-&gt;validattr.forkattr = 0;
		
				attrp-&gt;nativeattr.commonattr =  0;
				attrp-&gt;nativeattr.volattr = 0;
				attrp-&gt;nativeattr.dirattr = 0;
				attrp-&gt;nativeattr.fileattr = 0;
				attrp-&gt;nativeattr.forkattr = 0;
				VFSATTR_SET_SUPPORTED(&amp;vs, f_attributes);
			}

			<span class="enscript-comment">/* default value for volume f_capabilities */</span>
			<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(&amp;vs, f_capabilities)) {
				<span class="enscript-comment">/* getattrlist is always supported now. */</span>
				<span class="enscript-keyword">if</span> (!VFSATTR_IS_SUPPORTED(&amp;vs, f_capabilities)) {
					vs.f_capabilities.capabilities[VOL_CAPABILITIES_FORMAT] = 0;
					vs.f_capabilities.capabilities[VOL_CAPABILITIES_INTERFACES] = VOL_CAP_INT_ATTRLIST;
					vs.f_capabilities.capabilities[VOL_CAPABILITIES_RESERVED1] = 0;
					vs.f_capabilities.capabilities[VOL_CAPABILITIES_RESERVED2] = 0;
	
					vs.f_capabilities.valid[VOL_CAPABILITIES_FORMAT] = 0;
					vs.f_capabilities.valid[VOL_CAPABILITIES_INTERFACES] = VOL_CAP_INT_ATTRLIST;
					vs.f_capabilities.valid[VOL_CAPABILITIES_RESERVED1] = 0;
					vs.f_capabilities.valid[VOL_CAPABILITIES_RESERVED2] = 0;
					VFSATTR_SET_SUPPORTED(&amp;vs, f_capabilities);
				}
				<span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* OR in VOL_CAP_INT_ATTRLIST if f_capabilities is supported */</span>
					vs.f_capabilities.capabilities[VOL_CAPABILITIES_INTERFACES] |= VOL_CAP_INT_ATTRLIST;
					vs.f_capabilities.valid[VOL_CAPABILITIES_INTERFACES] |= VOL_CAP_INT_ATTRLIST;
				}
			}

			<span class="enscript-comment">/* check to see if our fixups were enough */</span>
			<span class="enscript-keyword">if</span> (!VFSATTR_ALL_SUPPORTED(&amp;vs)) {
				<span class="enscript-keyword">if</span> (return_valid) {
					<span class="enscript-keyword">if</span> (pack_invalid) {
						<span class="enscript-comment">/* Fix up valid mask for post processing */</span>
						getvolattrlist_fixupattrs(&amp;ab.valid, &amp;vs);
						
						<span class="enscript-comment">/* Force packing of everything asked for */</span>
						vs.f_supported = vs.f_active;
					} <span class="enscript-keyword">else</span> {
						<span class="enscript-comment">/* Adjust the requested attributes */</span>
						getvolattrlist_fixupattrs((attribute_set_t *)&amp;alp-&gt;commonattr, &amp;vs);
					}
				} <span class="enscript-keyword">else</span> {
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}
		}
	}

	<span class="enscript-comment">/*
	 * Some fields require data from the root vp
	 */</span>
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; (ATTR_CMN_OWNERID | ATTR_CMN_GRPID | ATTR_CMN_ACCESSMASK | ATTR_CMN_FLAGS | ATTR_CMN_SCRIPT)) {
		VATTR_WANTED(&amp;va, va_uid);
		VATTR_WANTED(&amp;va, va_gid);
		VATTR_WANTED(&amp;va, va_mode);
		VATTR_WANTED(&amp;va, va_flags);
		VATTR_WANTED(&amp;va, va_encoding);

		<span class="enscript-keyword">if</span> ((error = vnode_getattr(vp, &amp;va, ctx)) != 0) {
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: could not fetch attributes from root vnode&quot;</span>, vp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(&amp;va, va_encoding) &amp;&amp;
		    !VATTR_IS_SUPPORTED(&amp;va, va_encoding)) {
			<span class="enscript-keyword">if</span> (!return_valid || pack_invalid)
				<span class="enscript-comment">/* use kTextEncodingMacUnicode */</span>
				VATTR_RETURN(&amp;va, va_encoding, 0x7e);
			<span class="enscript-keyword">else</span>
				<span class="enscript-comment">/* don't use a default */</span>
				alp-&gt;commonattr &amp;= ~ATTR_CMN_SCRIPT;
		}
	}

	<span class="enscript-comment">/*
	 * Compute variable-size buffer requirements.
	 */</span>
	varsize = 0;
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_NAME) {
		<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_vfsstat.f_mntonname[1] == 0x00 &amp;&amp;
			vp-&gt;v_mount-&gt;mnt_vfsstat.f_mntonname[0] == <span class="enscript-string">'/'</span>) {
			<span class="enscript-comment">/* special case for boot volume.  Use root name when it's
			 * available (which is the volume name) or just the mount on
			 * name of &quot;/&quot;.  we must do this for binary compatibility with
			 * pre Tiger code.  returning nothing for the boot volume name
			 * breaks installers - 3961058
			 */</span>
			cnp = vnode_getname(vp);
			<span class="enscript-keyword">if</span> (cnp == NULL) {
				<span class="enscript-comment">/* just use &quot;/&quot; as name */</span>
				cnp = &amp;vp-&gt;v_mount-&gt;mnt_vfsstat.f_mntonname[0];
			}
			<span class="enscript-keyword">else</span> {
				release_str = 1;
			}
			cnl = strlen(cnp);
		}
		<span class="enscript-keyword">else</span> {
			getattrlist_findnamecomp(vp-&gt;v_mount-&gt;mnt_vfsstat.f_mntonname, &amp;cnp, &amp;cnl);
		}
		<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_NAME)
			varsize += roundup(cnl + 1, 4);
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_MOUNTPOINT)
		varsize += roundup(strlen(mnt-&gt;mnt_vfsstat.f_mntonname) + 1, 4);
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_NAME) {
		vs.f_vol_name[MAXPATHLEN-1] = <span class="enscript-string">'\0'</span>; <span class="enscript-comment">/* Ensure nul-termination */</span>
		varsize += roundup(strlen(vs.f_vol_name) + 1, 4);
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_MOUNTEDDEVICE)
		varsize += roundup(strlen(mnt-&gt;mnt_vfsstat.f_mntfromname) + 1, 4);

	<span class="enscript-comment">/*
	 * Allocate a target buffer for attribute results.
	 * Note that since we won't ever copy out more than the caller requested,
	 * we never need to allocate more than they offer.
	 */</span>
	ab.allocated = ulmin(bufferSize, fixedsize + varsize);
	<span class="enscript-keyword">if</span> (ab.allocated &gt; ATTR_MAX_BUFFER) {
		error = ENOMEM;
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: buffer size too large (%d limit %d)&quot;</span>, ab.allocated, ATTR_MAX_BUFFER);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	MALLOC(ab.base, <span class="enscript-type">char</span> *, ab.allocated, M_TEMP, M_ZERO | M_WAITOK);
	<span class="enscript-keyword">if</span> (ab.base == NULL) {
		error = ENOMEM;
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: could not allocate %d for copy buffer&quot;</span>, ab.allocated);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Pack results into the destination buffer.
	 */</span>
	ab.fixedcursor = ab.base + <span class="enscript-keyword">sizeof</span>(uint32_t);
	<span class="enscript-keyword">if</span> (return_valid) {
		ab.fixedcursor += <span class="enscript-keyword">sizeof</span> (attribute_set_t);
		bzero(&amp;ab.actual, <span class="enscript-keyword">sizeof</span> (ab.actual));
	}
	ab.varcursor = ab.base + fixedsize;
	ab.needed = fixedsize + varsize;

	<span class="enscript-comment">/* common attributes **************************************************/</span>
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_NAME) {
		attrlist_pack_string(&amp;ab, cnp, cnl);
		ab.actual.commonattr |= ATTR_CMN_NAME;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_DEVID) {
		ATTR_PACK4(ab, mnt-&gt;mnt_vfsstat.f_fsid.val[0]);
		ab.actual.commonattr |= ATTR_CMN_DEVID;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_FSID) {
		ATTR_PACK8(ab, mnt-&gt;mnt_vfsstat.f_fsid);
		ab.actual.commonattr |= ATTR_CMN_FSID;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_OBJTYPE) {
		<span class="enscript-keyword">if</span> (!return_valid || pack_invalid)
			ATTR_PACK4(ab, 0);
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_OBJTAG) {
		ATTR_PACK4(ab, vp-&gt;v_tag);
		ab.actual.commonattr |= ATTR_CMN_OBJTAG;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_OBJID) {
		<span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			fsobj_id_t f = {0, 0};
			ATTR_PACK8(ab, f);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_OBJPERMANENTID) {
		<span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			fsobj_id_t f = {0, 0};
			ATTR_PACK8(ab, f);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_PAROBJID) {
		<span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			fsobj_id_t f = {0, 0};
			ATTR_PACK8(ab, f);
		}
	}
	<span class="enscript-comment">/* note that this returns the encoding for the volume name, not the node name */</span>
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_SCRIPT) {
		ATTR_PACK4(ab, va.va_encoding);
		ab.actual.commonattr |= ATTR_CMN_SCRIPT;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_CRTIME) {
		ATTR_PACK_TIME(ab, vs.f_create_time, is_64bit);
		ab.actual.commonattr |= ATTR_CMN_CRTIME;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_MODTIME) {
		ATTR_PACK_TIME(ab, vs.f_modify_time, is_64bit);
		ab.actual.commonattr |= ATTR_CMN_MODTIME;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_CHGTIME) {
		<span class="enscript-keyword">if</span> (!return_valid || pack_invalid)
			ATTR_PACK_TIME(ab, vs.f_modify_time, is_64bit);
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_ACCTIME) {
		ATTR_PACK_TIME(ab, vs.f_access_time, is_64bit);
		ab.actual.commonattr |= ATTR_CMN_ACCTIME;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_BKUPTIME) {
		ATTR_PACK_TIME(ab, vs.f_backup_time, is_64bit);
		ab.actual.commonattr |= ATTR_CMN_BKUPTIME;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_FNDRINFO) {
		<span class="enscript-type">char</span> f[32];
		<span class="enscript-comment">/*
		 * This attribute isn't really Finder Info, at least for HFS.
		 */</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_tag == VT_HFS) {
			error = VNOP_IOCTL(vp, HFS_GET_BOOT_INFO, (caddr_t)&amp;f, 0, ctx);
			<span class="enscript-keyword">if</span> (error == 0) {
				attrlist_pack_fixed(&amp;ab, f, <span class="enscript-keyword">sizeof</span>(f));
				ab.actual.commonattr |= ATTR_CMN_FNDRINFO;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			<span class="enscript-comment">/* XXX we could at least pass out the volume UUID here */</span>
			bzero(&amp;f, <span class="enscript-keyword">sizeof</span>(f));
			attrlist_pack_fixed(&amp;ab, f, <span class="enscript-keyword">sizeof</span>(f));
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_OWNERID) {
		ATTR_PACK4(ab, va.va_uid);
		ab.actual.commonattr |= ATTR_CMN_OWNERID;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_GRPID) {
		ATTR_PACK4(ab, va.va_gid);
		ab.actual.commonattr |= ATTR_CMN_GRPID;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_ACCESSMASK) {
		ATTR_PACK_CAST(&amp;ab, uint32_t, va.va_mode);
		ab.actual.commonattr |= ATTR_CMN_ACCESSMASK;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_FLAGS) {
		ATTR_PACK4(ab, va.va_flags);
		ab.actual.commonattr |= ATTR_CMN_FLAGS;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_USERACCESS) {	<span class="enscript-comment">/* XXX this is expensive and also duplicate work */</span>
		uint32_t	perms = 0;
		<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
			<span class="enscript-keyword">if</span> (vnode_authorize(vp, NULL,
				KAUTH_VNODE_ACCESS | KAUTH_VNODE_ADD_FILE | KAUTH_VNODE_ADD_SUBDIRECTORY | KAUTH_VNODE_DELETE_CHILD, ctx) == 0)
				perms |= W_OK;
			<span class="enscript-keyword">if</span> (vnode_authorize(vp, NULL, KAUTH_VNODE_ACCESS | KAUTH_VNODE_LIST_DIRECTORY, ctx) == 0)
				perms |= R_OK;
			<span class="enscript-keyword">if</span> (vnode_authorize(vp, NULL, KAUTH_VNODE_ACCESS | KAUTH_VNODE_SEARCH, ctx) == 0)
				perms |= X_OK;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (vnode_authorize(vp, NULL, KAUTH_VNODE_ACCESS | KAUTH_VNODE_WRITE_DATA, ctx) == 0)
				perms |= W_OK;
			<span class="enscript-keyword">if</span> (vnode_authorize(vp, NULL, KAUTH_VNODE_ACCESS | KAUTH_VNODE_READ_DATA, ctx) == 0)
				perms |= R_OK;
			<span class="enscript-keyword">if</span> (vnode_authorize(vp, NULL, KAUTH_VNODE_ACCESS | KAUTH_VNODE_EXECUTE, ctx) == 0)
				perms |= X_OK;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-comment">/* 
		 * Rather than MAC preceding DAC, in this case we want
		 * the smallest set of permissions granted by both MAC &amp; DAC
		 * checks.  We won't add back any permissions.
		 */</span>
		<span class="enscript-keyword">if</span> (perms &amp; W_OK)
			<span class="enscript-keyword">if</span> (mac_vnode_check_access(ctx, vp, W_OK) != 0)
				perms &amp;= ~W_OK;
		<span class="enscript-keyword">if</span> (perms &amp; R_OK)
			<span class="enscript-keyword">if</span> (mac_vnode_check_access(ctx, vp, R_OK) != 0)
				perms &amp;= ~R_OK;
		<span class="enscript-keyword">if</span> (perms &amp; X_OK)
			<span class="enscript-keyword">if</span> (mac_vnode_check_access(ctx, vp, X_OK) != 0)
				perms &amp;= ~X_OK;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>
		KAUTH_DEBUG(<span class="enscript-string">&quot;ATTRLIST - returning user access %x&quot;</span>, perms);
		ATTR_PACK4(ab, perms);
		ab.actual.commonattr |= ATTR_CMN_USERACCESS;
	}
	<span class="enscript-comment">/*
	 * The following common volume attributes are only
	 * packed when the pack_invalid mode is enabled.
	 */</span>
	<span class="enscript-keyword">if</span> (pack_invalid) {
		uint64_t fid = 0;

		<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_EXTENDED_SECURITY)
			attrlist_pack_variable(&amp;ab, NULL, 0);
		<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_UUID)
			ATTR_PACK(&amp;ab, kauth_null_guid);
		<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_GRPUUID)
			ATTR_PACK(&amp;ab, kauth_null_guid);
		<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_FILEID)
			ATTR_PACK8(ab, fid);
		<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_PARENTID)
			ATTR_PACK8(ab, fid);
	}

	<span class="enscript-comment">/* volume attributes **************************************************/</span>

	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_FSTYPE) {
		ATTR_PACK_CAST(&amp;ab, uint32_t, vfs_typenum(mnt));
		ab.actual.volattr |= ATTR_VOL_FSTYPE;
	}
 	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_SIGNATURE) {
 		ATTR_PACK_CAST(&amp;ab, uint32_t, vs.f_signature);
		ab.actual.volattr |= ATTR_VOL_SIGNATURE;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_SIZE) {
		ATTR_PACK_CAST(&amp;ab, off_t, vs.f_bsize * vs.f_blocks);
		ab.actual.volattr |= ATTR_VOL_SIZE;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_SPACEFREE) {
		ATTR_PACK_CAST(&amp;ab, off_t, vs.f_bsize * vs.f_bfree);
		ab.actual.volattr |= ATTR_VOL_SPACEFREE;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_SPACEAVAIL) {
		ATTR_PACK_CAST(&amp;ab, off_t, vs.f_bsize * vs.f_bavail);
		ab.actual.volattr |= ATTR_VOL_SPACEAVAIL;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_MINALLOCATION) {
		ATTR_PACK_CAST(&amp;ab, off_t, vs.f_bsize);
		ab.actual.volattr |= ATTR_VOL_MINALLOCATION;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_ALLOCATIONCLUMP) {
		ATTR_PACK_CAST(&amp;ab, off_t, vs.f_bsize);			<span class="enscript-comment">/* not strictly true */</span>
		ab.actual.volattr |= ATTR_VOL_ALLOCATIONCLUMP;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_IOBLOCKSIZE) {
		ATTR_PACK_CAST(&amp;ab, uint32_t, vs.f_iosize);
		ab.actual.volattr |= ATTR_VOL_IOBLOCKSIZE;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_OBJCOUNT) {
		ATTR_PACK_CAST(&amp;ab, uint32_t, vs.f_objcount);
		ab.actual.volattr |= ATTR_VOL_OBJCOUNT;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_FILECOUNT) {
		ATTR_PACK_CAST(&amp;ab, uint32_t, vs.f_filecount);
		ab.actual.volattr |= ATTR_VOL_FILECOUNT;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_DIRCOUNT) {
		ATTR_PACK_CAST(&amp;ab, uint32_t, vs.f_dircount);
		ab.actual.volattr |= ATTR_VOL_DIRCOUNT;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_MAXOBJCOUNT) {
		ATTR_PACK_CAST(&amp;ab, uint32_t, vs.f_maxobjcount);
		ab.actual.volattr |= ATTR_VOL_MAXOBJCOUNT;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_MOUNTPOINT) {
		attrlist_pack_string(&amp;ab, mnt-&gt;mnt_vfsstat.f_mntonname, 0);
		ab.actual.volattr |= ATTR_VOL_MOUNTPOINT;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_NAME) {
		attrlist_pack_string(&amp;ab, vs.f_vol_name, 0);
		ab.actual.volattr |= ATTR_VOL_NAME;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_MOUNTFLAGS) {
		ATTR_PACK_CAST(&amp;ab, uint32_t, mnt-&gt;mnt_flag);
		ab.actual.volattr |= ATTR_VOL_MOUNTFLAGS;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_MOUNTEDDEVICE) {
		attrlist_pack_string(&amp;ab, mnt-&gt;mnt_vfsstat.f_mntfromname, 0);
		ab.actual.volattr |= ATTR_VOL_MOUNTEDDEVICE;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_ENCODINGSUSED) {
		<span class="enscript-keyword">if</span> (!return_valid || pack_invalid)
			ATTR_PACK_CAST(&amp;ab, uint64_t, ~0LL);  <span class="enscript-comment">/* return all encodings */</span>
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_CAPABILITIES) {
		<span class="enscript-comment">/* fix up volume capabilities */</span>
		<span class="enscript-keyword">if</span> (vfs_extendedsecurity(mnt)) {
			vs.f_capabilities.capabilities[VOL_CAPABILITIES_INTERFACES] |= VOL_CAP_INT_EXTENDED_SECURITY;
		} <span class="enscript-keyword">else</span> {
			vs.f_capabilities.capabilities[VOL_CAPABILITIES_INTERFACES] &amp;= ~VOL_CAP_INT_EXTENDED_SECURITY;
		}
		vs.f_capabilities.valid[VOL_CAPABILITIES_INTERFACES] |= VOL_CAP_INT_EXTENDED_SECURITY;
		ATTR_PACK(&amp;ab, vs.f_capabilities);
		ab.actual.volattr |= ATTR_VOL_CAPABILITIES;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_UUID) {
		ATTR_PACK(&amp;ab, vs.f_uuid);
		ab.actual.volattr |= ATTR_VOL_UUID;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;volattr &amp; ATTR_VOL_ATTRIBUTES) {
		<span class="enscript-comment">/* fix up volume attribute information */</span>

		vs.f_attributes.validattr.commonattr |= VFS_DFLT_ATTR_CMN;
		vs.f_attributes.validattr.volattr |= VFS_DFLT_ATTR_VOL;
		vs.f_attributes.validattr.dirattr |= VFS_DFLT_ATTR_DIR;
		vs.f_attributes.validattr.fileattr |= VFS_DFLT_ATTR_FILE;

		<span class="enscript-keyword">if</span> (vfs_extendedsecurity(mnt)) {
			vs.f_attributes.validattr.commonattr |= (ATTR_CMN_EXTENDED_SECURITY | ATTR_CMN_UUID | ATTR_CMN_GRPUUID);
		} <span class="enscript-keyword">else</span> {
			vs.f_attributes.validattr.commonattr &amp;= ~(ATTR_CMN_EXTENDED_SECURITY | ATTR_CMN_UUID | ATTR_CMN_GRPUUID);
			vs.f_attributes.nativeattr.commonattr &amp;= ~(ATTR_CMN_EXTENDED_SECURITY | ATTR_CMN_UUID | ATTR_CMN_GRPUUID);
		}
		ATTR_PACK(&amp;ab, vs.f_attributes);
		ab.actual.volattr |= ATTR_VOL_ATTRIBUTES;
	}
	
	<span class="enscript-comment">/* diagnostic */</span>
	<span class="enscript-keyword">if</span> (!return_valid &amp;&amp; (ab.fixedcursor - ab.base) != fixedsize)
		panic(<span class="enscript-string">&quot;packed field size mismatch; allocated %ld but packed %ld for common %08x vol %08x&quot;</span>,
		    fixedsize, (<span class="enscript-type">long</span>) (ab.fixedcursor - ab.base), alp-&gt;commonattr, alp-&gt;volattr);
	<span class="enscript-keyword">if</span> (!return_valid &amp;&amp; ab.varcursor != (ab.base + ab.needed))
		panic(<span class="enscript-string">&quot;packed variable field size mismatch; used %ld but expected %ld&quot;</span>, (<span class="enscript-type">long</span>) (ab.varcursor - ab.base), ab.needed);

	<span class="enscript-comment">/*
	 * In the compatible case, we report the smaller of the required and returned sizes.
	 * If the FSOPT_REPORT_FULLSIZE option is supplied, we report the full (required) size
	 * of the result buffer, even if we copied less out.  The caller knows how big a buffer
	 * they gave us, so they can always check for truncation themselves.
	 */</span>
	*(uint32_t *)ab.base = (options &amp; FSOPT_REPORT_FULLSIZE) ? ab.needed : imin(ab.allocated, ab.needed);
	
	<span class="enscript-comment">/* Return attribute set output if requested. */</span>
	<span class="enscript-keyword">if</span> (return_valid) {
		ab.actual.commonattr |= ATTR_CMN_RETURNED_ATTRS;
		<span class="enscript-keyword">if</span> (pack_invalid) {
			<span class="enscript-comment">/* Only report the attributes that are valid */</span>
			ab.actual.commonattr &amp;= ab.valid.commonattr;
			ab.actual.volattr &amp;= ab.valid.volattr;
		}
		bcopy(&amp;ab.actual, ab.base + <span class="enscript-keyword">sizeof</span>(uint32_t), <span class="enscript-keyword">sizeof</span> (ab.actual));
	}

	<span class="enscript-keyword">if</span> (UIO_SEG_IS_USER_SPACE(segflg))
		error = copyout(ab.base, CAST_USER_ADDR_T(attributeBuffer),
		                ab.allocated);
	<span class="enscript-keyword">else</span>
		bcopy(ab.base, (<span class="enscript-type">void</span> *)attributeBuffer, (size_t)ab.allocated);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (vs.f_vol_name != NULL)
		kfree(vs.f_vol_name, MAXPATHLEN);
	<span class="enscript-keyword">if</span> (release_str) {
		vnode_putname(cnp);
	}
	<span class="enscript-keyword">if</span> (ab.base != NULL)
		FREE(ab.base, M_TEMP);
	VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - returning %d&quot;</span>, error);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Pack ATTR_COMMON attributes into a user buffer.
 * alp is a pointer to the bitmap of attributes required.
 * abp is the state of the attribute filling operation.
 * The attribute data (along with some other fields that are required
 * are in ad.
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">attr_pack_common</span>(vfs_context_t ctx, <span class="enscript-type">struct</span> vnode *vp,  <span class="enscript-type">struct</span> attrlist *alp,
    <span class="enscript-type">struct</span> _attrlist_buf *abp, <span class="enscript-type">struct</span> vnode_attr *vap, <span class="enscript-type">int</span> proc_is64,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *cnp, ssize_t cnl, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fullpathptr,
    ssize_t fullpathlen, <span class="enscript-type">int</span> return_valid, <span class="enscript-type">int</span> pack_invalid, <span class="enscript-type">int</span> vtype,
    <span class="enscript-type">int</span> is_bulk)
{
	uint32_t	perms = 0;
	<span class="enscript-type">int</span>		error = 0;

	<span class="enscript-keyword">if</span> ((alp-&gt;commonattr &amp; ATTR_CMN_ERROR) &amp;&amp;
	    (!return_valid || pack_invalid)) {
		ATTR_PACK4((*abp), 0);
		abp-&gt;actual.commonattr |= ATTR_CMN_ERROR;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_NAME) {
		attrlist_pack_string(abp, cnp, cnl);
		abp-&gt;actual.commonattr |= ATTR_CMN_NAME;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_DEVID) {
		<span class="enscript-keyword">if</span> (vp) {
			ATTR_PACK4((*abp),
			    vp-&gt;v_mount-&gt;mnt_vfsstat.f_fsid.val[0]);
			abp-&gt;actual.commonattr |= ATTR_CMN_DEVID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_devid)) {
			ATTR_PACK4((*abp), vap-&gt;va_devid);
			abp-&gt;actual.commonattr |= ATTR_CMN_DEVID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			ATTR_PACK4((*abp), 0);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_FSID) {
		<span class="enscript-keyword">if</span> (vp) {
			ATTR_PACK8((*abp),
			    vp-&gt;v_mount-&gt;mnt_vfsstat.f_fsid);
			abp-&gt;actual.commonattr |= ATTR_CMN_FSID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_fsid64)) {
			ATTR_PACK8((*abp), vap-&gt;va_fsid64);
			abp-&gt;actual.commonattr |= ATTR_CMN_FSID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			fsid_t fsid = {{0}};

			ATTR_PACK8((*abp), fsid);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_OBJTYPE) {
		<span class="enscript-keyword">if</span> (vp) {
			ATTR_PACK4((*abp), vtype);
			abp-&gt;actual.commonattr |= ATTR_CMN_OBJTYPE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_objtype)) {
			ATTR_PACK4((*abp), vap-&gt;va_objtype);
			abp-&gt;actual.commonattr |= ATTR_CMN_OBJTYPE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			ATTR_PACK4((*abp), 0);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_OBJTAG) {
		<span class="enscript-keyword">if</span> (vp) {
			ATTR_PACK4((*abp), vp-&gt;v_tag);
			abp-&gt;actual.commonattr |= ATTR_CMN_OBJTAG;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_objtag)) {
			ATTR_PACK4((*abp), vap-&gt;va_objtag);
			abp-&gt;actual.commonattr |= ATTR_CMN_OBJTAG;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			ATTR_PACK4((*abp), 0);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_OBJID) {
		fsobj_id_t f;
		<span class="enscript-comment">/*
		 * Carbon can't deal with us reporting the target ID
		 * for links.  So we ask the filesystem to give us the
		 * source ID as well, and if it gives us one, we use
		 * it instead.
		 */</span>
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_linkid)) {
			f.fid_objno = vap-&gt;va_linkid;
		} <span class="enscript-keyword">else</span> {
			f.fid_objno = vap-&gt;va_fileid;
		}
		f.fid_generation = 0;
		ATTR_PACK8((*abp), f);
		abp-&gt;actual.commonattr |= ATTR_CMN_OBJID;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_OBJPERMANENTID) {
		fsobj_id_t f;
		<span class="enscript-comment">/*
		 * Carbon can't deal with us reporting the target ID
		 * for links.  So we ask the filesystem to give us the
		 * source ID as well, and if it gives us one, we use
		 * it instead.
		 */</span>
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_linkid)) {
			f.fid_objno = vap-&gt;va_linkid;
		} <span class="enscript-keyword">else</span> {
			f.fid_objno = vap-&gt;va_fileid;
		}
		f.fid_generation = 0;
		ATTR_PACK8((*abp), f);
		abp-&gt;actual.commonattr |= ATTR_CMN_OBJPERMANENTID;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_PAROBJID) {
		fsobj_id_t f;

		f.fid_objno = vap-&gt;va_parentid;  <span class="enscript-comment">/* could be lossy here! */</span>
		f.fid_generation = 0;
		ATTR_PACK8((*abp), f);
		abp-&gt;actual.commonattr |= ATTR_CMN_PAROBJID;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_SCRIPT) {
 		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_encoding)) {
			ATTR_PACK4((*abp), vap-&gt;va_encoding);
			abp-&gt;actual.commonattr |= ATTR_CMN_SCRIPT;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			ATTR_PACK4((*abp), 0x7e);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_CRTIME) {
		ATTR_PACK_TIME((*abp), vap-&gt;va_create_time, proc_is64);
		abp-&gt;actual.commonattr |= ATTR_CMN_CRTIME;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_MODTIME) {
		ATTR_PACK_TIME((*abp), vap-&gt;va_modify_time, proc_is64);
		abp-&gt;actual.commonattr |= ATTR_CMN_MODTIME;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_CHGTIME) {
		ATTR_PACK_TIME((*abp), vap-&gt;va_change_time, proc_is64);
		abp-&gt;actual.commonattr |= ATTR_CMN_CHGTIME;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_ACCTIME) {
		ATTR_PACK_TIME((*abp), vap-&gt;va_access_time, proc_is64);
		abp-&gt;actual.commonattr |= ATTR_CMN_ACCTIME;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_BKUPTIME) {
		ATTR_PACK_TIME((*abp), vap-&gt;va_backup_time, proc_is64);
		abp-&gt;actual.commonattr |= ATTR_CMN_BKUPTIME;
	}
	<span class="enscript-comment">/*
	 * They are requesting user access, we should obtain this before getting 
	 * the finder info. For some network file systems this is a performance
	 * improvement.
	 */</span>
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_USERACCESS) {	<span class="enscript-comment">/* this is expensive */</span>
		<span class="enscript-keyword">if</span> (vp &amp;&amp; !is_bulk) {
			<span class="enscript-keyword">if</span> (vtype == VDIR) {
				<span class="enscript-keyword">if</span> (vnode_authorize(vp, NULL,
				    KAUTH_VNODE_ACCESS | KAUTH_VNODE_ADD_FILE |
				    KAUTH_VNODE_ADD_SUBDIRECTORY |
				    KAUTH_VNODE_DELETE_CHILD, ctx) == 0)
					perms |= W_OK;

				<span class="enscript-keyword">if</span> (vnode_authorize(vp, NULL,
				    KAUTH_VNODE_ACCESS |
				    KAUTH_VNODE_LIST_DIRECTORY, ctx) == 0)
					perms |= R_OK;

				<span class="enscript-keyword">if</span> (vnode_authorize(vp, NULL, KAUTH_VNODE_ACCESS |
				    KAUTH_VNODE_SEARCH, ctx) == 0)
					perms |= X_OK;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (vnode_authorize(vp, NULL, KAUTH_VNODE_ACCESS |
				    KAUTH_VNODE_WRITE_DATA, ctx) == 0)
					perms |= W_OK;

				<span class="enscript-keyword">if</span> (vnode_authorize(vp, NULL, KAUTH_VNODE_ACCESS | KAUTH_VNODE_READ_DATA, ctx) == 0)
					perms |= R_OK;
				<span class="enscript-keyword">if</span> (vnode_authorize(vp, NULL, KAUTH_VNODE_ACCESS | KAUTH_VNODE_EXECUTE, ctx) == 0)
					perms |= X_OK;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (is_bulk &amp;&amp;
		    VATTR_IS_SUPPORTED(vap, va_user_access)) {
			perms = vap-&gt;va_user_access;
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_FNDRINFO) {
		size_t	fisize = 32;

		error = 0; 
		<span class="enscript-keyword">if</span> (vp &amp;&amp; !is_bulk) {
			uio_t	auio;
			<span class="enscript-type">char</span>	uio_buf[UIO_SIZEOF(1)];

			<span class="enscript-keyword">if</span> ((auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE,
			    UIO_READ, uio_buf, <span class="enscript-keyword">sizeof</span>(uio_buf))) == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			uio_addiov(auio, CAST_USER_ADDR_T(abp-&gt;fixedcursor),
			    fisize);
			<span class="enscript-comment">/* fisize may be reset to 0 after this call */</span>
			error = vn_getxattr(vp, XATTR_FINDERINFO_NAME, auio,
					    &amp;fisize, XATTR_NOSECURITY, ctx);
			uio_free(auio);

			<span class="enscript-comment">/*
			 * Default to zeros if its not available,
			 * unless ATTR_CMN_RETURNED_ATTRS was requested.
			 */</span>
			<span class="enscript-keyword">if</span> (error &amp;&amp;
			    (!return_valid || pack_invalid) &amp;&amp;
			    ((error == ENOATTR) || (error == ENOENT) ||
			    (error == ENOTSUP) || (error == EPERM))) {
				VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - No system.finderinfo attribute, returning zeroes&quot;</span>);
				bzero(abp-&gt;fixedcursor, 32);
				error = 0;
			}

			<span class="enscript-keyword">if</span> (error == 0) {
				abp-&gt;fixedcursor += 32;
				abp-&gt;actual.commonattr |= ATTR_CMN_FNDRINFO;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * If we can inform the caller that we can't
				 * return this attribute, reset error and
				 * continue with the rest of the attributes.
				 */</span>
				error = 0;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_finderinfo)) {
			bcopy(&amp;vap-&gt;va_finderinfo[0], abp-&gt;fixedcursor, fisize);
			abp-&gt;fixedcursor += fisize;
			abp-&gt;actual.commonattr |= ATTR_CMN_FNDRINFO;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			bzero(abp-&gt;fixedcursor, fisize);
			abp-&gt;fixedcursor += fisize;
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_OWNERID) {
		ATTR_PACK4((*abp), vap-&gt;va_uid);
		abp-&gt;actual.commonattr |= ATTR_CMN_OWNERID;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_GRPID) {
		ATTR_PACK4((*abp), vap-&gt;va_gid);
		abp-&gt;actual.commonattr |= ATTR_CMN_GRPID;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_ACCESSMASK) {
		ATTR_PACK4((*abp), vap-&gt;va_mode);
		abp-&gt;actual.commonattr |= ATTR_CMN_ACCESSMASK;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_FLAGS) {
		ATTR_PACK4((*abp), vap-&gt;va_flags);
		abp-&gt;actual.commonattr |= ATTR_CMN_FLAGS;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_GEN_COUNT) {
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_write_gencount)) {
			ATTR_PACK4((*abp), vap-&gt;va_write_gencount);
			abp-&gt;actual.commonattr |= ATTR_CMN_GEN_COUNT;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			ATTR_PACK4((*abp), 0);
		}
	}

	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_DOCUMENT_ID) {
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_document_id)) {
			ATTR_PACK4((*abp), vap-&gt;va_document_id);
			abp-&gt;actual.commonattr |= ATTR_CMN_DOCUMENT_ID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			ATTR_PACK4((*abp), 0);
		}	
	}
	<span class="enscript-comment">/* We already obtain the user access, so just fill in the buffer here */</span>
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_USERACCESS) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-keyword">if</span> (!is_bulk &amp;&amp; vp) {
			<span class="enscript-comment">/*
			 * Rather than MAC preceding DAC, in this case we want
			 * the smallest set of permissions granted by both MAC &amp;
			 * DAC checks.  We won't add back any permissions.
			 */</span>
			<span class="enscript-keyword">if</span> (perms &amp; W_OK)
				<span class="enscript-keyword">if</span> (mac_vnode_check_access(ctx, vp, W_OK) != 0)
					perms &amp;= ~W_OK;
			<span class="enscript-keyword">if</span> (perms &amp; R_OK)
				<span class="enscript-keyword">if</span> (mac_vnode_check_access(ctx, vp, R_OK) != 0)
					perms &amp;= ~R_OK;
			<span class="enscript-keyword">if</span> (perms &amp; X_OK)
				<span class="enscript-keyword">if</span> (mac_vnode_check_access(ctx, vp, X_OK) != 0)
					perms &amp;= ~X_OK;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - granting perms %d&quot;</span>, perms);
		<span class="enscript-keyword">if</span> (!is_bulk &amp;&amp; vp) {
			ATTR_PACK4((*abp), perms);
			abp-&gt;actual.commonattr |= ATTR_CMN_USERACCESS;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (is_bulk &amp;&amp; VATTR_IS_SUPPORTED(vap, va_user_access)) {
			ATTR_PACK4((*abp), perms);
			abp-&gt;actual.commonattr |= ATTR_CMN_USERACCESS;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			ATTR_PACK4((*abp), 0);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_EXTENDED_SECURITY) {
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_acl) &amp;&amp; (vap-&gt;va_acl != NULL)) {
			<span class="enscript-type">struct</span> kauth_filesec fsec;
			<span class="enscript-comment">/*
			 * We want to return a kauth_filesec (for now), but all we have is a kauth_acl.
			 */</span>
			fsec.fsec_magic = KAUTH_FILESEC_MAGIC;
			fsec.fsec_owner = kauth_null_guid;
			fsec.fsec_group = kauth_null_guid;
			attrlist_pack_variable2(abp, &amp;fsec, __offsetof(<span class="enscript-type">struct</span> kauth_filesec, fsec_acl), vap-&gt;va_acl, KAUTH_ACL_COPYSIZE(vap-&gt;va_acl));
			abp-&gt;actual.commonattr |= ATTR_CMN_EXTENDED_SECURITY;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			attrlist_pack_variable(abp, NULL, 0);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_UUID) {
 		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_uuuid)) {
			ATTR_PACK(abp, vap-&gt;va_uuuid);
			abp-&gt;actual.commonattr |= ATTR_CMN_UUID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			ATTR_PACK(abp, kauth_null_guid);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_GRPUUID) {
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_guuid)) {
			ATTR_PACK(abp, vap-&gt;va_guuid);
			abp-&gt;actual.commonattr |= ATTR_CMN_GRPUUID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			ATTR_PACK(abp, kauth_null_guid);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_FILEID) {
		ATTR_PACK8((*abp), vap-&gt;va_fileid);
		abp-&gt;actual.commonattr |= ATTR_CMN_FILEID;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_PARENTID) {
		ATTR_PACK8((*abp), vap-&gt;va_parentid);
		abp-&gt;actual.commonattr |= ATTR_CMN_PARENTID;
	}
	
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_FULLPATH) {
		attrlist_pack_string (abp, fullpathptr, fullpathlen);
		abp-&gt;actual.commonattr |= ATTR_CMN_FULLPATH;
	}
    
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_ADDEDTIME) {
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_addedtime)) {
			ATTR_PACK_TIME((*abp), vap-&gt;va_addedtime, proc_is64);
			abp-&gt;actual.commonattr |= ATTR_CMN_ADDEDTIME;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			<span class="enscript-type">struct</span> timespec zerotime = {0, 0};

			ATTR_PACK_TIME((*abp), zerotime, proc_is64);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_DATA_PROTECT_FLAGS) {
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_dataprotect_class)) {
			ATTR_PACK4((*abp), vap-&gt;va_dataprotect_class);
			abp-&gt;actual.commonattr |= ATTR_CMN_DATA_PROTECT_FLAGS;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			ATTR_PACK4((*abp), 0);
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">attr_pack_dir</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> attrlist *alp, <span class="enscript-type">struct</span> _attrlist_buf *abp,
    <span class="enscript-type">struct</span> vnode_attr *vap)
{
	<span class="enscript-keyword">if</span> (alp-&gt;dirattr &amp; ATTR_DIR_LINKCOUNT) {  <span class="enscript-comment">/* full count of entries */</span>
		ATTR_PACK4((*abp), (uint32_t)vap-&gt;va_dirlinkcount);
		abp-&gt;actual.dirattr |= ATTR_DIR_LINKCOUNT;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;dirattr &amp; ATTR_DIR_ENTRYCOUNT) {
		ATTR_PACK4((*abp), (uint32_t)vap-&gt;va_nchildren);
		abp-&gt;actual.dirattr |= ATTR_DIR_ENTRYCOUNT;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;dirattr &amp; ATTR_DIR_MOUNTSTATUS) {
		uint32_t mntstat;

		<span class="enscript-keyword">if</span> (vp) {
			<span class="enscript-comment">/*
			 * The vnode that is passed down may either be a
			 * top level vnode of a mount stack or a mounted
			 * on vnode. In either case, the directory should
			 * be reported as a mount point.
			 */</span>
			<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VROOT) ||  vnode_mountedhere(vp)) {
				mntstat = DIR_MNTSTATUS_MNTPOINT;
			} <span class="enscript-keyword">else</span> {
				mntstat = 0;
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
			<span class="enscript-comment">/*
			 * Report back on active vnode triggers
			 * that can directly trigger a mount
			 */</span>
			<span class="enscript-keyword">if</span> (vp-&gt;v_resolve &amp;&amp;
			    !(vp-&gt;v_resolve-&gt;vr_flags &amp; VNT_NO_DIRECT_MOUNT)) {
				mntstat |= DIR_MNTSTATUS_TRIGGER;
			}
#<span class="enscript-reference">endif</span>
		} <span class="enscript-keyword">else</span> {
			mntstat = 0;
		}

		ATTR_PACK4((*abp), mntstat);
		abp-&gt;actual.dirattr |= ATTR_DIR_MOUNTSTATUS;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * The is_bulk parameter differentiates whether the function is called from
 * getattrlist or getattrlistbulk. When coming in from getattrlistbulk,
 * the corresponding va_* values are expected to be the values filled and no
 * attempt is made to retrieve them by calling back into the filesystem.
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">attr_pack_file</span>(vfs_context_t ctx, <span class="enscript-type">struct</span> vnode *vp,  <span class="enscript-type">struct</span> attrlist *alp,
    <span class="enscript-type">struct</span> _attrlist_buf *abp, <span class="enscript-type">struct</span> vnode_attr *vap, <span class="enscript-type">int</span> return_valid,
    <span class="enscript-type">int</span> pack_invalid, <span class="enscript-type">int</span> is_bulk)
{
	size_t	rsize = 0;
	uint64_t rlength = 0;
	uint64_t ralloc = 0;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/*
	 * Pre-fetch the rsrc attributes now so we only get them once.
	 * Fetch the resource fork size/allocation via xattr interface
	 */</span>
	<span class="enscript-keyword">if</span> (vp &amp;&amp; !is_bulk &amp;&amp;
	    (alp-&gt;fileattr &amp; (ATTR_FILE_TOTALSIZE | ATTR_FILE_ALLOCSIZE |
	    ATTR_FILE_RSRCLENGTH | ATTR_FILE_RSRCALLOCSIZE))) {

		error = vn_getxattr(vp, XATTR_RESOURCEFORK_NAME, NULL,
		    &amp;rsize, XATTR_NOSECURITY, ctx);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> ((error == ENOENT) || (error == ENOATTR) ||
			    (error == ENOTSUP) || (error == EPERM) ||
			    (error == EACCES)) {
				rsize = 0;
				error = 0;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
		rlength = rsize;

		<span class="enscript-keyword">if</span> (alp-&gt;fileattr &amp; (ATTR_FILE_RSRCALLOCSIZE |
		    ATTR_FILE_ALLOCSIZE)) {
			uint32_t  blksize;

			blksize = vp-&gt;v_mount-&gt;mnt_vfsstat.f_bsize;

			<span class="enscript-keyword">if</span> (blksize == 0) {
				blksize = 512;
			}
			ralloc = roundup(rsize, blksize);
		}
	}

	<span class="enscript-keyword">if</span> (alp-&gt;fileattr &amp; ATTR_FILE_LINKCOUNT) {
		ATTR_PACK4((*abp), (uint32_t)vap-&gt;va_nlink);
		abp-&gt;actual.fileattr |= ATTR_FILE_LINKCOUNT;
	}
	<span class="enscript-comment">/*
	 * Note the following caveats for the TOTALSIZE and ALLOCSIZE attributes:
	 * We infer that if the filesystem does not support va_data_size or va_data_alloc
	 * it must not know about alternate forks.  So when we need to gather
	 * the total size or total alloc, it's OK to substitute the total size for
	 * the data size below.  This is because it is likely a flat filesystem and we must
	 * be using AD files to store the rsrc fork and EAs.
	 *
	 * Additionally, note that getattrlist is barred from being called on
	 * resource fork paths. (Search for CN_ALLOWRSRCFORK).  So if the filesystem does
	 * support va_data_size, it is guaranteed to represent the data fork's size.  This
	 * is an important distinction to make because when we call vnode_getattr on
	 * an HFS resource fork vnode, to get the size, it will vend out the resource
	 * fork's size (it only gets the size of the passed-in vnode).
	 */</span>
	<span class="enscript-keyword">if</span> (alp-&gt;fileattr &amp; ATTR_FILE_TOTALSIZE) {
		<span class="enscript-keyword">if</span> (!is_bulk) {
			uint64_t totalsize = rlength;

			<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_data_size)) {
				totalsize += vap-&gt;va_data_size;
			} <span class="enscript-keyword">else</span> {
				totalsize += vap-&gt;va_total_size;
			}

			ATTR_PACK8((*abp), totalsize);
			abp-&gt;actual.fileattr |= ATTR_FILE_TOTALSIZE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_total_size)) {
			ATTR_PACK8((*abp), vap-&gt;va_total_size);
			abp-&gt;actual.fileattr |= ATTR_FILE_TOTALSIZE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			uint64_t zero_val = 0;

			ATTR_PACK8((*abp), zero_val);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;fileattr &amp; ATTR_FILE_ALLOCSIZE) {
		<span class="enscript-keyword">if</span> (!is_bulk) {
			uint64_t totalalloc = ralloc;

			<span class="enscript-comment">/*
			 * If data_alloc is supported, then it must represent the
			 * data fork size.
			 */</span>
			<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_data_alloc)) {
				totalalloc += vap-&gt;va_data_alloc;
			} <span class="enscript-keyword">else</span> {
				totalalloc += vap-&gt;va_total_alloc;
			}

			ATTR_PACK8((*abp), totalalloc);
			abp-&gt;actual.fileattr |= ATTR_FILE_ALLOCSIZE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_total_alloc)) {
			ATTR_PACK8((*abp), vap-&gt;va_total_alloc);
			abp-&gt;actual.fileattr |= ATTR_FILE_ALLOCSIZE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			uint64_t zero_val = 0;

			ATTR_PACK8((*abp), zero_val);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;fileattr &amp; ATTR_FILE_IOBLOCKSIZE) {
		ATTR_PACK4((*abp), vap-&gt;va_iosize);
		abp-&gt;actual.fileattr |= ATTR_FILE_IOBLOCKSIZE;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;fileattr &amp; ATTR_FILE_CLUMPSIZE) {
		<span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			ATTR_PACK4((*abp), 0);     <span class="enscript-comment">/* this value is deprecated */</span>
			abp-&gt;actual.fileattr |= ATTR_FILE_CLUMPSIZE;
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;fileattr &amp; ATTR_FILE_DEVTYPE) {
		<span class="enscript-keyword">if</span> (vp &amp;&amp; (vp-&gt;v_type == VCHR || vp-&gt;v_type == VBLK)) {
			uint32_t dev;

			<span class="enscript-keyword">if</span> (vp-&gt;v_specinfo != NULL) {
				dev = vp-&gt;v_specinfo-&gt;si_rdev;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_rdev)) {
				dev = vap-&gt;va_rdev;
			} <span class="enscript-keyword">else</span> {
				dev = 0;
			}
			ATTR_PACK4((*abp), dev);
			abp-&gt;actual.fileattr |= ATTR_FILE_DEVTYPE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vp) {
			ATTR_PACK4((*abp), 0);
			abp-&gt;actual.fileattr |= ATTR_FILE_DEVTYPE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_rdev)) {
			ATTR_PACK4((*abp), vap-&gt;va_rdev);
			abp-&gt;actual.fileattr |= ATTR_FILE_DEVTYPE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			ATTR_PACK4((*abp), 0);
		}
	}
	<span class="enscript-comment">/*
	 * If the filesystem does not support datalength
	 * or dataallocsize, then we infer that totalsize and
	 * totalalloc are substitutes.
	 */</span>
	<span class="enscript-keyword">if</span> (alp-&gt;fileattr &amp; ATTR_FILE_DATALENGTH) {
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_data_size)) {
			ATTR_PACK8((*abp), vap-&gt;va_data_size);
		} <span class="enscript-keyword">else</span> {
			ATTR_PACK8((*abp), vap-&gt;va_total_size);
		}
		abp-&gt;actual.fileattr |= ATTR_FILE_DATALENGTH;
	}
	<span class="enscript-keyword">if</span> (alp-&gt;fileattr &amp; ATTR_FILE_DATAALLOCSIZE) {
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_data_alloc)) {
			ATTR_PACK8((*abp), vap-&gt;va_data_alloc);
		} <span class="enscript-keyword">else</span> {
			ATTR_PACK8((*abp), vap-&gt;va_total_alloc);
		}
		abp-&gt;actual.fileattr |= ATTR_FILE_DATAALLOCSIZE;
	}
	<span class="enscript-comment">/* already got the resource fork size/allocation above */</span>
	<span class="enscript-keyword">if</span> (alp-&gt;fileattr &amp; ATTR_FILE_RSRCLENGTH) {
		<span class="enscript-keyword">if</span> (!is_bulk) {
			ATTR_PACK8((*abp), rlength);
			abp-&gt;actual.fileattr |= ATTR_FILE_RSRCLENGTH;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_rsrc_length)) {
			ATTR_PACK8((*abp), vap-&gt;va_rsrc_length);
			abp-&gt;actual.fileattr |= ATTR_FILE_RSRCLENGTH;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			uint64_t zero_val = 0;

			ATTR_PACK8((*abp), zero_val);
		}
	}
	<span class="enscript-keyword">if</span> (alp-&gt;fileattr &amp; ATTR_FILE_RSRCALLOCSIZE) {
		<span class="enscript-keyword">if</span> (!is_bulk) {
			ATTR_PACK8((*abp), ralloc);
			abp-&gt;actual.fileattr |= ATTR_FILE_RSRCALLOCSIZE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_rsrc_alloc)) {
			ATTR_PACK8((*abp), vap-&gt;va_rsrc_alloc);
			abp-&gt;actual.fileattr |= ATTR_FILE_RSRCALLOCSIZE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!return_valid || pack_invalid) {
			uint64_t zero_val = 0;

			ATTR_PACK8((*abp), zero_val);
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vattr_get_alt_data</span>(vnode_t vp, <span class="enscript-type">struct</span> attrlist *alp, <span class="enscript-type">struct</span> vnode_attr *vap,
    <span class="enscript-type">int</span> return_valid, <span class="enscript-type">int</span> is_bulk, vfs_context_t ctx)
{
	<span class="enscript-comment">/*
	 * There are a couple of special cases.
	 * If we are after object IDs, we can make do with va_fileid.
	 */</span>
	<span class="enscript-keyword">if</span> ((alp-&gt;commonattr &amp;
	    (ATTR_CMN_OBJID | ATTR_CMN_OBJPERMANENTID | ATTR_CMN_FILEID)) &amp;&amp;
	    !VATTR_IS_SUPPORTED(vap, va_linkid)) {
		<span class="enscript-comment">/* forget we wanted this */</span>
		VATTR_CLEAR_ACTIVE(vap, va_linkid);
	}
	
	<span class="enscript-comment">/*
	 * Many filesystems don't know their parent object id.
	 * If necessary, attempt to derive it from the vnode.
	 */</span>
	<span class="enscript-keyword">if</span> ((alp-&gt;commonattr &amp; (ATTR_CMN_PAROBJID | ATTR_CMN_PARENTID)) &amp;&amp;
	    !VATTR_IS_SUPPORTED(vap, va_parentid) &amp;&amp; vp &amp;&amp; !is_bulk) {
		vnode_t	dvp;

		<span class="enscript-keyword">if</span> ((dvp = vnode_getparent(vp)) != NULLVP) {
			<span class="enscript-type">struct</span> vnode_attr lva;

			VATTR_INIT(&amp;lva);
			VATTR_WANTED(&amp;lva, va_fileid);
			<span class="enscript-keyword">if</span> (vnode_getattr(dvp, &amp;lva, ctx) == 0 &amp;&amp;
			    VATTR_IS_SUPPORTED(vap, va_fileid)) {
				vap-&gt;va_parentid = lva.va_fileid;
				VATTR_SET_SUPPORTED(vap, va_parentid);
			}
			vnode_put(dvp);
		}
	}
	<span class="enscript-comment">/*
	 * And we can report datasize/alloc from total.
	 */</span>
	<span class="enscript-keyword">if</span> ((alp-&gt;fileattr &amp; ATTR_FILE_DATALENGTH) &amp;&amp;
	    !VATTR_IS_SUPPORTED(vap, va_data_size)) {
		VATTR_CLEAR_ACTIVE(vap, va_data_size);
	}

	<span class="enscript-keyword">if</span> ((alp-&gt;fileattr &amp; ATTR_FILE_DATAALLOCSIZE) &amp;&amp;
	    !VATTR_IS_SUPPORTED(vap, va_data_alloc)) {
		VATTR_CLEAR_ACTIVE(vap, va_data_alloc);
	}

	<span class="enscript-comment">/*
	 * If we don't have an encoding, go with UTF-8
	 */</span>
	<span class="enscript-keyword">if</span> ((alp-&gt;commonattr &amp; ATTR_CMN_SCRIPT) &amp;&amp;
	    !VATTR_IS_SUPPORTED(vap, va_encoding) &amp;&amp; !return_valid) {
		VATTR_RETURN(vap, va_encoding,
		    0x7e <span class="enscript-comment">/* kTextEncodingMacUnicode */</span>);
	}

	<span class="enscript-comment">/*
	 * If we don't have a name, we'll get one from the vnode or
	 * mount point.
	 */</span>
	<span class="enscript-keyword">if</span> ((alp-&gt;commonattr &amp; ATTR_CMN_NAME) &amp;&amp;
	    !VATTR_IS_SUPPORTED(vap, va_name)) {
		VATTR_CLEAR_ACTIVE(vap, va_name);
	}

	<span class="enscript-comment">/* If va_dirlinkcount isn't supported use a default of 1. */</span>
	<span class="enscript-keyword">if</span> ((alp-&gt;dirattr &amp; ATTR_DIR_LINKCOUNT) &amp;&amp;
	    !VATTR_IS_SUPPORTED(vap, va_dirlinkcount)) {
		VATTR_RETURN(vap, va_dirlinkcount, 1);
	}
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">calc_varsize</span>(vnode_t vp, <span class="enscript-type">struct</span> attrlist *alp, <span class="enscript-type">struct</span> vnode_attr *vap,
   ssize_t *varsizep, <span class="enscript-type">char</span> *fullpathptr, ssize_t *fullpathlenp,
   <span class="enscript-type">const</span> <span class="enscript-type">char</span> **vnamep, <span class="enscript-type">const</span> <span class="enscript-type">char</span> **cnpp, ssize_t *cnlp)  
{
	<span class="enscript-type">int</span> error = 0;

	*varsizep = 0; <span class="enscript-comment">/* length count */</span>
	<span class="enscript-comment">/* We may need to fix up the name attribute if requested */</span>
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_NAME) {
		<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_name)) {
			vap-&gt;va_name[MAXPATHLEN-1] = <span class="enscript-string">'\0'</span>;	<span class="enscript-comment">/* Ensure nul-termination */</span>
			*cnpp = vap-&gt;va_name;
			*cnlp = strlen(*cnpp);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vp) {
			<span class="enscript-comment">/* Filesystem did not support getting the name */</span>
			<span class="enscript-keyword">if</span> (vnode_isvroot(vp)) {
				<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_vfsstat.f_mntonname[1] == 0x00 &amp;&amp;
						vp-&gt;v_mount-&gt;mnt_vfsstat.f_mntonname[0] == <span class="enscript-string">'/'</span>) {
					<span class="enscript-comment">/* special case for boot volume.  Use root name when it's
					 * available (which is the volume name) or just the mount on
					 * name of &quot;/&quot;.  we must do this for binary compatibility with
					 * pre Tiger code.  returning nothing for the boot volume name
					 * breaks installers - 3961058
					 */</span>
					*cnpp = *vnamep = vnode_getname(vp);
					<span class="enscript-keyword">if</span> (*cnpp == NULL) {
						<span class="enscript-comment">/* just use &quot;/&quot; as name */</span>
						*cnpp = &amp;vp-&gt;v_mount-&gt;mnt_vfsstat.f_mntonname[0];
					}
					*cnlp = strlen(*cnpp);
				}
				<span class="enscript-keyword">else</span> {
					getattrlist_findnamecomp(vp-&gt;v_mount-&gt;mnt_vfsstat.f_mntonname, cnpp, cnlp);
				}
			} 
			<span class="enscript-keyword">else</span> {
				*cnpp = *vnamep = vnode_getname(vp);
				*cnlp = 0;
				<span class="enscript-keyword">if</span> (*cnpp != NULL) {
					*cnlp = strlen(*cnpp);
				}
			}
		} <span class="enscript-keyword">else</span> {
			*cnlp = 0;
		}
		*varsizep += roundup(*cnlp + 1, 4);
	}

	<span class="enscript-comment">/* 
	 * Compute the full path to this vnode, if necessary. This attribute is almost certainly
	 * not supported by any filesystem, so build the path to this vnode at this time.
	 */</span>
	<span class="enscript-keyword">if</span> (vp &amp;&amp; (alp-&gt;commonattr &amp; ATTR_CMN_FULLPATH)) {
		<span class="enscript-type">int</span> len = MAXPATHLEN;
		<span class="enscript-type">int</span> err;

		<span class="enscript-comment">/* call build_path making sure NOT to use the cache-only behavior */</span>
		err = build_path(vp, fullpathptr, len, &amp;len, 0, vfs_context_current());
		<span class="enscript-keyword">if</span> (err) {
			error = err;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		*fullpathlenp = 0;
		<span class="enscript-keyword">if</span> (fullpathptr){
			*fullpathlenp = strlen(fullpathptr);
		}
		*varsizep += roundup(((*fullpathlenp) + 1), 4);
	}

	<span class="enscript-comment">/*
	 * We have a kauth_acl_t but we will be returning a kauth_filesec_t.
	 *
	 * XXX This needs to change at some point; since the blob is opaque in
	 * user-space this is OK.
	 */</span>
	<span class="enscript-keyword">if</span> ((alp-&gt;commonattr &amp; ATTR_CMN_EXTENDED_SECURITY) &amp;&amp;
			VATTR_IS_SUPPORTED(vap, va_acl) &amp;&amp;
			(vap-&gt;va_acl != NULL)) {

		<span class="enscript-comment">/* 
		 * Since we have a kauth_acl_t (not a kauth_filesec_t), we have to check against
		 * KAUTH_FILESEC_NOACL ourselves
		 */</span> 
		<span class="enscript-keyword">if</span> (vap-&gt;va_acl-&gt;acl_entrycount == KAUTH_FILESEC_NOACL) {
			*varsizep += roundup((KAUTH_FILESEC_SIZE(0)), 4);
		}
		<span class="enscript-keyword">else</span> {
			*varsizep += roundup ((KAUTH_FILESEC_SIZE(vap-&gt;va_acl-&gt;acl_entrycount)), 4);
		}
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">vfs_attr_pack_internal</span>(vnode_t vp, uio_t auio, <span class="enscript-type">struct</span> attrlist *alp,
    uint64_t options, <span class="enscript-type">struct</span> vnode_attr *vap, __unused <span class="enscript-type">void</span> *fndesc,
    vfs_context_t ctx, <span class="enscript-type">int</span> is_bulk, <span class="enscript-type">enum</span> vtype vtype, ssize_t fixedsize)
{
	<span class="enscript-type">struct</span> _attrlist_buf ab;
	ssize_t buf_size;
	size_t copy_size;
	ssize_t	varsize;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *vname = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *cnp;
	ssize_t cnl;
	<span class="enscript-type">char</span> *fullpathptr;
	ssize_t	fullpathlen;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> proc_is64;
	<span class="enscript-type">int</span> return_valid;
	<span class="enscript-type">int</span> pack_invalid;
	<span class="enscript-type">int</span> alloc_local_buf;

	proc_is64 = proc_is64bit(vfs_context_proc(ctx));
	ab.base = NULL;
	cnp = <span class="enscript-string">&quot;unknown&quot;</span>;
	cnl = 0;
	fullpathptr = NULL;
	fullpathlen = 0;
	error = 0;
	alloc_local_buf = 0;

	buf_size = (ssize_t)uio_resid(auio);
	<span class="enscript-keyword">if</span> ((buf_size &lt;= 0) || (uio_iovcnt(auio) &gt; 1))
		<span class="enscript-keyword">return</span> (EINVAL);

	copy_size = 0;
	<span class="enscript-comment">/* Check for special packing semantics */</span>
	return_valid = (alp-&gt;commonattr &amp; ATTR_CMN_RETURNED_ATTRS) ? 1 : 0;
	pack_invalid = (options &amp; FSOPT_PACK_INVAL_ATTRS) ? 1 : 0;

	<span class="enscript-keyword">if</span> (pack_invalid) {
		<span class="enscript-comment">/* Generate a valid mask for post processing */</span>
		bcopy(&amp;(alp-&gt;commonattr), &amp;ab.valid, <span class="enscript-keyword">sizeof</span> (attribute_set_t));
	}

	<span class="enscript-comment">/* did we ask for something the filesystem doesn't support? */</span>
	<span class="enscript-keyword">if</span> (vap-&gt;va_active &amp;&amp; !VATTR_ALL_SUPPORTED(vap)) {
		vattr_get_alt_data(vp, alp, vap, return_valid, is_bulk,
		    ctx);

		<span class="enscript-comment">/* check again */</span>
		<span class="enscript-keyword">if</span> (!VATTR_ALL_SUPPORTED(vap)) {
			<span class="enscript-keyword">if</span> (return_valid &amp;&amp; pack_invalid) {
				<span class="enscript-comment">/* Fix up valid mask for post processing */</span>
				getattrlist_fixupattrs(&amp;ab.valid, vap);
					
				<span class="enscript-comment">/* Force packing of everything asked for */</span>
				vap-&gt;va_supported = vap-&gt;va_active;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (return_valid) {
				<span class="enscript-comment">/* Adjust the requested attributes */</span>
				getattrlist_fixupattrs(
				    (attribute_set_t *)&amp;(alp-&gt;commonattr), vap);
			} <span class="enscript-keyword">else</span> {
				error = EINVAL;
			}
		}

		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; (ATTR_CMN_FULLPATH)) {
		fullpathptr = (<span class="enscript-type">char</span>*) kalloc(MAXPATHLEN);
		<span class="enscript-keyword">if</span> (fullpathptr == NULL) {
			error = ENOMEM;
			VFS_DEBUG(ctx,vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: cannot allocate fullpath buffer&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Compute variable-space requirements.
	 */</span>
	error = calc_varsize(vp, alp, vap, &amp;varsize, fullpathptr, &amp;fullpathlen,
	    &amp;vname, &amp;cnp, &amp;cnl);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * Allocate a target buffer for attribute results.
	 *
	 * Note that we won't ever copy out more than the caller requested, even though
	 * we might have to allocate more than they offer so that the diagnostic checks
	 * don't result in a panic if the caller's buffer is too small..
	 */</span>
	ab.allocated = fixedsize + varsize;
	<span class="enscript-comment">/* Cast 'allocated' to an unsigned to verify allocation size */</span>
	<span class="enscript-keyword">if</span> ( ((size_t)ab.allocated) &gt; ATTR_MAX_BUFFER) {
		error = ENOMEM;
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: buffer size too large (%d limit %d)&quot;</span>, ab.allocated, ATTR_MAX_BUFFER);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Special handling for bulk calls, align to 8 (and only if enough
	 * space left.
	 */</span>
	<span class="enscript-keyword">if</span> (is_bulk) {
		<span class="enscript-keyword">if</span> (buf_size &lt; ab.allocated) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> {
			uint32_t newlen;

			newlen = (ab.allocated + 7) &amp; ~0x07;
			<span class="enscript-comment">/* Align only if enough space for alignment */</span>
			<span class="enscript-keyword">if</span> (newlen &lt;= (uint32_t)buf_size)
				ab.allocated = newlen;
		}
	}

	<span class="enscript-comment">/*
	 * See if we can reuse buffer passed in i.e. it is a kernel buffer
	 * and big enough.
	 */</span>
	<span class="enscript-keyword">if</span> (uio_isuserspace(auio) || (buf_size &lt; ab.allocated)) {
		MALLOC(ab.base, <span class="enscript-type">char</span> *, ab.allocated, M_TEMP,
		       M_ZERO | M_WAITOK);
		alloc_local_buf = 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * In case this is a kernel buffer and sufficiently
		 * big, this function will try to use that buffer
		 * instead of allocating another buffer and bcopy'ing
		 * into it.
		 *
		 * The calculation below figures out where to start
		 * writing in the buffer and once all the data has been
		 * filled in, uio_resid is updated to reflect the usage
		 * of the buffer.
		 *
		 * uio_offset cannot be used here to determine the
		 * starting location as uio_offset could be set to a
		 * value which has nothing to do the location
		 * in the buffer.
		 */</span>
		ab.base = (<span class="enscript-type">char</span> *)uio_curriovbase(auio) +
		    ((ssize_t)uio_curriovlen(auio) - buf_size);
		bzero(ab.base, ab.allocated);
	}

	<span class="enscript-keyword">if</span> (ab.base == NULL) {
		error = ENOMEM;
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: could not allocate %d for copy buffer&quot;</span>, ab.allocated);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}


	<span class="enscript-comment">/* set the S_IFMT bits for the mode */</span>
	<span class="enscript-keyword">if</span> (alp-&gt;commonattr &amp; ATTR_CMN_ACCESSMASK) {
		<span class="enscript-keyword">if</span> (vp) {
			<span class="enscript-keyword">switch</span> (vp-&gt;v_type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">VREG</span>:
				vap-&gt;va_mode |= S_IFREG;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">VDIR</span>:
				vap-&gt;va_mode |= S_IFDIR;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:
				vap-&gt;va_mode |= S_IFBLK;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
				vap-&gt;va_mode |= S_IFCHR;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">VLNK</span>:
				vap-&gt;va_mode |= S_IFLNK;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">VSOCK</span>:
				vap-&gt;va_mode |= S_IFSOCK;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">VFIFO</span>:
				vap-&gt;va_mode |= S_IFIFO;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				error = EBADF;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}

	<span class="enscript-comment">/*
	 * Pack results into the destination buffer.
	 */</span>
	ab.fixedcursor = ab.base + <span class="enscript-keyword">sizeof</span>(uint32_t);
	<span class="enscript-keyword">if</span> (return_valid) {
		ab.fixedcursor += <span class="enscript-keyword">sizeof</span> (attribute_set_t);
		bzero(&amp;ab.actual, <span class="enscript-keyword">sizeof</span> (ab.actual));
	}
	ab.varcursor = ab.base + fixedsize;
	ab.needed = ab.allocated;

	<span class="enscript-comment">/* common attributes ************************************************/</span>
	error = attr_pack_common(ctx, vp, alp, &amp;ab, vap, proc_is64, cnp, cnl,
	    fullpathptr, fullpathlen, return_valid, pack_invalid, vtype, is_bulk); 

	<span class="enscript-comment">/* directory attributes *********************************************/</span>
	<span class="enscript-keyword">if</span> (!error &amp;&amp; alp-&gt;dirattr &amp;&amp; (vtype == VDIR)) {
		error = attr_pack_dir(vp, alp, &amp;ab, vap);
	}

	<span class="enscript-comment">/* file attributes **************************************************/</span>
	<span class="enscript-keyword">if</span> (!error &amp;&amp; alp-&gt;fileattr &amp;&amp; (vtype != VDIR)) {
		error = attr_pack_file(ctx, vp, alp, &amp;ab, vap, return_valid,
		    pack_invalid, is_bulk);
	}

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	
	<span class="enscript-comment">/* diagnostic */</span>
	<span class="enscript-keyword">if</span> (!return_valid &amp;&amp; (ab.fixedcursor - ab.base) != fixedsize)
		panic(<span class="enscript-string">&quot;packed field size mismatch; allocated %ld but packed %ld for common %08x vol %08x&quot;</span>,
		    fixedsize, (<span class="enscript-type">long</span>) (ab.fixedcursor - ab.base), alp-&gt;commonattr, alp-&gt;volattr);
	<span class="enscript-keyword">if</span> (!return_valid &amp;&amp; ab.varcursor != (ab.base + ab.needed))
		panic(<span class="enscript-string">&quot;packed variable field size mismatch; used %ld but expected %ld&quot;</span>, (<span class="enscript-type">long</span>) (ab.varcursor - ab.base), ab.needed);

	<span class="enscript-comment">/*
	 * In the compatible case, we report the smaller of the required and returned sizes.
	 * If the FSOPT_REPORT_FULLSIZE option is supplied, we report the full (required) size
	 * of the result buffer, even if we copied less out.  The caller knows how big a buffer
	 * they gave us, so they can always check for truncation themselves.
	 */</span>
	*(uint32_t *)ab.base = (options &amp; FSOPT_REPORT_FULLSIZE) ? ab.needed : imin(ab.allocated, ab.needed);

	<span class="enscript-comment">/* Return attribute set output if requested. */</span>
	<span class="enscript-keyword">if</span> (return_valid) {
		ab.actual.commonattr |= ATTR_CMN_RETURNED_ATTRS;
		<span class="enscript-keyword">if</span> (pack_invalid) {
			<span class="enscript-comment">/* Only report the attributes that are valid */</span>
			ab.actual.commonattr &amp;= ab.valid.commonattr;
			ab.actual.dirattr &amp;= ab.valid.dirattr;
			ab.actual.fileattr &amp;= ab.valid.fileattr;
		}
		bcopy(&amp;ab.actual, ab.base + <span class="enscript-keyword">sizeof</span>(uint32_t), <span class="enscript-keyword">sizeof</span> (ab.actual));
	}

	copy_size = imin(buf_size, ab.allocated);

	<span class="enscript-comment">/* Only actually copyout as much out as the user buffer can hold */</span>
	<span class="enscript-keyword">if</span> (alloc_local_buf) {
		error = uiomove(ab.base, copy_size, auio);
	} <span class="enscript-keyword">else</span> {
		off_t orig_offset = uio_offset(auio);

		<span class="enscript-comment">/*
		 * The buffer in the uio struct was used directly
		 * (i.e. it was a kernel buffer and big enough
		 * to hold the data required) in order to avoid
		 * un-needed allocation and copies.
		 *
		 * At this point, update the resid value to what it
		 * would be if this was the result of a uiomove. The
		 * offset is also incremented, though it may not
		 * mean anything to the caller but that is what
		 * uiomove does as well.
		 */</span>
		uio_setresid(auio, buf_size - copy_size);
		uio_setoffset(auio, orig_offset + (off_t)copy_size);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (vname)
		vnode_putname(vname);
	<span class="enscript-keyword">if</span> (fullpathptr)
		kfree(fullpathptr, MAXPATHLEN);
	<span class="enscript-keyword">if</span> (ab.base != NULL &amp;&amp; alloc_local_buf)
		FREE(ab.base, M_TEMP);
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">vfs_attr_pack</span>(vnode_t vp, uio_t uio, <span class="enscript-type">struct</span> attrlist *alp, uint64_t options,
    <span class="enscript-type">struct</span> vnode_attr *vap, __unused <span class="enscript-type">void</span> *fndesc, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;
	ssize_t fixedsize;
	uint64_t orig_active;
	<span class="enscript-type">struct</span> attrlist orig_al;
	<span class="enscript-type">enum</span> vtype v_type;

	<span class="enscript-keyword">if</span> (vp)
		v_type = vnode_vtype(vp);
	<span class="enscript-keyword">else</span>
		v_type = vap-&gt;va_objtype;

	orig_al = *alp;
	orig_active = vap-&gt;va_active;
	vap-&gt;va_active = 0;

	error = getattrlist_setupvattr_all(alp, vap, v_type, &amp;fixedsize,
	    proc_is64bit(vfs_context_proc(ctx)));

	<span class="enscript-keyword">if</span> (error) {
		VFS_DEBUG(ctx, vp,
		    <span class="enscript-string">&quot;ATTRLIST - ERROR: setup for request failed&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = vfs_attr_pack_internal(vp, uio, alp, 
	    options|FSOPT_REPORT_FULLSIZE, vap, NULL, ctx, 1, v_type,
	    fixedsize);

	VATTR_CLEAR_SUPPORTED_ALL(vap);
	vap-&gt;va_active = orig_active;
	*alp = orig_al;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Obtain attribute information about a filesystem object.
 *
 * Note: The alt_name parameter can be used by the caller to pass in the vnode
 * name obtained from some authoritative source (eg. readdir vnop); where
 * filesystems' getattr vnops do not support ATTR_CMN_NAME, the alt_name will be
 * used as the ATTR_CMN_NAME attribute returned in vnode_attr.va_name.
 * 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getattrlist_internal</span>(vfs_context_t ctx, vnode_t vp, <span class="enscript-type">struct</span> attrlist  *alp,
    user_addr_t attributeBuffer, size_t bufferSize, uint64_t options,
    <span class="enscript-type">enum</span> uio_seg segflg, <span class="enscript-type">char</span>* alt_name)
{
	<span class="enscript-type">struct</span> vnode_attr va;
	kauth_action_t	action;
	ssize_t		fixedsize;
	<span class="enscript-type">char</span>		*va_name;
	<span class="enscript-type">int</span>		proc_is64;
	<span class="enscript-type">int</span>		error;
	<span class="enscript-type">int</span>		return_valid;
	<span class="enscript-type">int</span>		pack_invalid;
	<span class="enscript-type">int</span>		vtype = 0;
	uio_t		auio;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1)];

	proc_is64 = proc_is64bit(vfs_context_proc(ctx));

	<span class="enscript-keyword">if</span> (segflg == UIO_USERSPACE) {
		<span class="enscript-keyword">if</span> (proc_is64)
			segflg = UIO_USERSPACE64;
		<span class="enscript-keyword">else</span>
			segflg = UIO_USERSPACE32;
	}
	auio = uio_createwithbuffer(1, 0, segflg, UIO_READ,
		    &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, attributeBuffer, bufferSize);

	VATTR_INIT(&amp;va);
	va_name = NULL;

	<span class="enscript-keyword">if</span> (alp-&gt;bitmapcount != ATTR_BIT_MAP_COUNT) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;%p  ATTRLIST - %s request common %08x vol %08x file %08x dir %08x fork %08x %sfollow on '%s'&quot;</span>,
	    vp, p-&gt;p_comm, alp-&gt;commonattr, alp-&gt;volattr, alp-&gt;fileattr, alp-&gt;dirattr, alp-&gt;forkattr,
	    (options &amp; FSOPT_NOFOLLOW) ? <span class="enscript-string">&quot;no&quot;</span>:<span class="enscript-string">&quot;&quot;</span>, vp-&gt;v_name);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_getattrlist(ctx, vp, alp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>

	<span class="enscript-comment">/*
	 * It is legal to request volume or file attributes,
	 * but not both.
	 */</span>
	<span class="enscript-keyword">if</span> (alp-&gt;volattr) {
		<span class="enscript-keyword">if</span> (alp-&gt;fileattr || alp-&gt;dirattr || alp-&gt;forkattr) {
			error = EINVAL;
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: mixed volume/file/directory/fork attributes&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* handle volume attribute request */</span>
		error = getvolattrlist(ctx, vp, alp, attributeBuffer,
		                       bufferSize, options, segflg, proc_is64);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * ATTR_CMN_GEN_COUNT and ATTR_CMN_DOCUMENT_ID reuse the bits
	 * originally allocated to ATTR_CMN_NAMEDATTRCOUNT and
	 * ATTR_CMN_NAMEDATTRLIST.
	 */</span>
	<span class="enscript-keyword">if</span> ((alp-&gt;commonattr &amp; (ATTR_CMN_GEN_COUNT | ATTR_CMN_DOCUMENT_ID)) &amp;&amp;
	    !(options &amp; FSOPT_ATTR_CMN_EXTENDED)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Check for special packing semantics */</span>
	return_valid = (alp-&gt;commonattr &amp; ATTR_CMN_RETURNED_ATTRS) ? 1 : 0;
	pack_invalid = (options &amp; FSOPT_PACK_INVAL_ATTRS) ? 1 : 0;
	<span class="enscript-keyword">if</span> (pack_invalid) {
		<span class="enscript-comment">/* FSOPT_PACK_INVAL_ATTRS requires ATTR_CMN_RETURNED_ATTRS */</span>
		<span class="enscript-keyword">if</span> (!return_valid || alp-&gt;forkattr) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* Keep invalid attrs from being uninitialized */</span>
		bzero(&amp;va, <span class="enscript-keyword">sizeof</span> (va));
	}

	<span class="enscript-comment">/* Pick up the vnode type.  If the FS is bad and changes vnode types on us, we
	 * will have a valid snapshot that we can work from here.
	 */</span>
	vtype = vp-&gt;v_type;

	<span class="enscript-comment">/*
	 * Set up the vnode_attr structure and authorise.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = getattrlist_setupvattr(alp, &amp;va, &amp;fixedsize, &amp;action, proc_is64, (vtype == VDIR))) != 0) {
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: setup for request failed&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> ((error = vnode_authorize(vp, NULL, action, ctx)) != 0) {
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: authorisation failed/denied&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}



	<span class="enscript-keyword">if</span> (va.va_active != 0) {
		uint64_t va_active = va.va_active;

		<span class="enscript-comment">/*
		 * If we're going to ask for va_name, allocate a buffer to point it at
		 */</span>
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(&amp;va, va_name)) {
			MALLOC_ZONE(va_name, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI,
			    M_WAITOK);
			<span class="enscript-keyword">if</span> (va_name == NULL) {
				error = ENOMEM;
				VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: cannot allocate va_name buffer&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}

		va.va_name = va_name;

		<span class="enscript-comment">/*
		 * Call the filesystem.
		 */</span>
		<span class="enscript-keyword">if</span> ((error = vnode_getattr(vp, &amp;va, ctx)) != 0) {
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: filesystem returned %d&quot;</span>, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}


		<span class="enscript-comment">/* 
		 * If ATTR_CMN_NAME is not supported by filesystem and the
		 * caller has provided a name, use that.
		 * A (buggy) filesystem may change fields which belong
		 * to us. We try to deal with that here as well.
		 */</span>
		va.va_active = va_active;
		<span class="enscript-keyword">if</span> (alt_name  &amp;&amp; va_name &amp;&amp;
		    !(VATTR_IS_SUPPORTED(&amp;va, va_name))) {
			strlcpy(va_name, alt_name, MAXPATHLEN);
			VATTR_SET_SUPPORTED(&amp;va, va_name);
		}
		va.va_name = va_name;
	}
	
	error = vfs_attr_pack_internal(vp, auio, alp, options, &amp;va, NULL, ctx,
	    0, vtype, fixedsize);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (va_name)
		FREE_ZONE(va_name, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(&amp;va, va_acl) &amp;&amp; (va.va_acl != NULL))
		kauth_acl_free(va.va_acl);

	VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - returning %d&quot;</span>, error);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fgetattrlist</span>(proc_t p, <span class="enscript-type">struct</span> fgetattrlist_args *uap, __unused int32_t *retval)
{
	vfs_context_t ctx;
	vnode_t vp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> attrlist al;

	ctx = vfs_context_current();
	error = 0;

	<span class="enscript-keyword">if</span> ((error = file_vnode(uap-&gt;fd, &amp;vp)) != 0)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = vnode_getwithref(vp)) != 0) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(error);
	}

	<span class="enscript-comment">/*
	 * Fetch the attribute request.
	 */</span>
	error = copyin(uap-&gt;alist, &amp;al, <span class="enscript-keyword">sizeof</span>(al));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* Default to using the vnode's name. */</span>
	error = getattrlist_internal(ctx, vp, &amp;al, uap-&gt;attributeBuffer,
	                             uap-&gt;bufferSize, uap-&gt;options,
				     (IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : \
	                             UIO_USERSPACE32), NULL);

<span class="enscript-reference">out</span>:
	file_drop(uap-&gt;fd);
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getattrlistat_internal</span>(vfs_context_t ctx, user_addr_t path,
    <span class="enscript-type">struct</span> attrlist *alp, user_addr_t attributeBuffer, size_t bufferSize,
    uint64_t options, <span class="enscript-type">enum</span> uio_seg segflg, <span class="enscript-type">enum</span> uio_seg pathsegflg, <span class="enscript-type">int</span> fd)
{
	<span class="enscript-type">struct</span> nameidata nd;
	vnode_t vp;
	int32_t nameiflags;
	<span class="enscript-type">int</span> error;

	nameiflags = 0;
	<span class="enscript-comment">/*
	 * Look up the file.
	 */</span>
	<span class="enscript-keyword">if</span> (!(options &amp; FSOPT_NOFOLLOW))
		nameiflags |= FOLLOW;

	nameiflags |= AUDITVNPATH1;
	NDINIT(&amp;nd, LOOKUP, OP_GETATTR, nameiflags, pathsegflg,
	    path, ctx);

	error = nameiat(&amp;nd, fd);

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	vp = nd.ni_vp;

	error = getattrlist_internal(ctx, vp, alp, attributeBuffer,
	    bufferSize, options, segflg, NULL);
	
	<span class="enscript-comment">/* Retain the namei reference until the getattrlist completes. */</span>
	nameidone(&amp;nd);
	vnode_put(vp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">getattrlist</span>(proc_t p, <span class="enscript-type">struct</span> getattrlist_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">enum</span> uio_seg segflg;
	<span class="enscript-type">struct</span> attrlist al;
	<span class="enscript-type">int</span> error;

	segflg = IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;

	<span class="enscript-comment">/*
	 * Fetch the attribute request.
	 */</span>
	error = copyin(uap-&gt;alist, &amp;al, <span class="enscript-keyword">sizeof</span>(al));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-keyword">return</span> (getattrlistat_internal(vfs_context_current(),
	    CAST_USER_ADDR_T(uap-&gt;path), &amp;al,
	    CAST_USER_ADDR_T(uap-&gt;attributeBuffer), uap-&gt;bufferSize,
	    (uint64_t)uap-&gt;options, segflg, segflg, AT_FDCWD));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">getattrlistat</span>(proc_t p, <span class="enscript-type">struct</span> getattrlistat_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">enum</span> uio_seg segflg;
	<span class="enscript-type">struct</span> attrlist al;
	<span class="enscript-type">int</span> error;

	segflg = IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;

	<span class="enscript-comment">/*
	 * Fetch the attribute request.
	 */</span>
	error = copyin(uap-&gt;alist, &amp;al, <span class="enscript-keyword">sizeof</span>(al));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-keyword">return</span> (getattrlistat_internal(vfs_context_current(),
	    CAST_USER_ADDR_T(uap-&gt;path), &amp;al,
	    CAST_USER_ADDR_T(uap-&gt;attributeBuffer), uap-&gt;bufferSize,
	    (uint64_t)uap-&gt;options, segflg, segflg, uap-&gt;fd));
}

<span class="enscript-comment">/*
 * This refills the per-fd direntries cache by issuing a VNOP_READDIR.
 * It attempts to try and find a size the filesystem responds to, so
 * it first tries 1 direntry sized buffer and going from 1 to 2 to 4
 * direntry sized buffers to readdir. If the filesystem does not respond
 * to 4 * direntry it returns the error by the filesystem (if any) and sets
 * EOF.
 *
 * This function also tries again if the last &quot;refill&quot; returned an EOF
 * to try and get any additional entries if they were added after the last
 * refill.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">refill_fd_direntries</span>(vfs_context_t ctx, vnode_t dvp, <span class="enscript-type">struct</span> fd_vn_data *fvd,
    <span class="enscript-type">int</span> *eofflagp)
{
	uio_t rdir_uio;
	<span class="enscript-type">char</span> uio_buf[UIO_SIZEOF(1)];
	size_t rdirbufsiz;
	size_t rdirbufused;
	<span class="enscript-type">int</span> eofflag;
	<span class="enscript-type">int</span> nentries;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * If the last readdir returned EOF, don't try again.
	 */</span>
	<span class="enscript-keyword">if</span> (fvd-&gt;fv_eofflag) {
		*eofflagp = 1;
		<span class="enscript-keyword">if</span> (fvd-&gt;fv_buf) {
			FREE(fvd-&gt;fv_buf, M_FD_DIRBUF);
			fvd-&gt;fv_buf = NULL;
		}
		<span class="enscript-keyword">return</span> 0;
	}

	error = 0;

	<span class="enscript-comment">/*
	 * If there is a cached allocation size of the dirbuf that should be
	 * allocated, use that. Otherwise start with a allocation size of
	 * FV_DIRBUF_START_SIZ. This start size may need to be increased if the
	 * filesystem doesn't respond to the initial size.
	 */</span>

	<span class="enscript-keyword">if</span> (fvd-&gt;fv_offset &amp;&amp; fvd-&gt;fv_bufallocsiz) {
		rdirbufsiz = fvd-&gt;fv_bufallocsiz;
	} <span class="enscript-keyword">else</span> {
		rdirbufsiz = FV_DIRBUF_START_SIZ;
	}

	*eofflagp = 0;

	rdir_uio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_READ,
	    &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));

<span class="enscript-reference">retry_alloc</span>:
	<span class="enscript-comment">/*
	 * Don't explicitly zero out this buffer since this is
	 * not copied out to user space.
	 */</span>
	<span class="enscript-keyword">if</span> (!fvd-&gt;fv_buf) {
		MALLOC(fvd-&gt;fv_buf, caddr_t, rdirbufsiz, M_FD_DIRBUF, M_WAITOK);
		fvd-&gt;fv_bufdone = 0;
	}

	uio_reset(rdir_uio, fvd-&gt;fv_eoff, UIO_SYSSPACE, UIO_READ);
	uio_addiov(rdir_uio, CAST_USER_ADDR_T(fvd-&gt;fv_buf), rdirbufsiz);

	<span class="enscript-comment">/*
	 * Some filesystems do not set nentries or eofflag...
	 */</span>
	eofflag = 0;
	nentries = 0;
	error = vnode_readdir64(dvp, rdir_uio, VNODE_READDIR_EXTENDED,
	    &amp;eofflag, &amp;nentries, ctx);

	rdirbufused = rdirbufsiz - (size_t)uio_resid(rdir_uio);

	<span class="enscript-keyword">if</span> (!error &amp;&amp; (rdirbufused &gt; 0) &amp;&amp; (rdirbufused &lt;= rdirbufsiz)) {
		<span class="enscript-comment">/* Save offsets */</span>
		fvd-&gt;fv_soff = fvd-&gt;fv_eoff;
		fvd-&gt;fv_eoff = uio_offset(rdir_uio);
		 <span class="enscript-comment">/* Save eofflag state but don't return EOF for this time.*/</span>
		fvd-&gt;fv_eofflag = eofflag;
		eofflag = 0;
		 <span class="enscript-comment">/* Reset buffer parameters */</span>
		fvd-&gt;fv_bufsiz = rdirbufused;
		fvd-&gt;fv_bufdone = 0;
		bzero(fvd-&gt;fv_buf + rdirbufused, rdirbufsiz - rdirbufused);
		<span class="enscript-comment">/* Cache allocation size the Filesystem responded to */</span>
		fvd-&gt;fv_bufallocsiz = rdirbufsiz;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!eofflag &amp;&amp; (rdirbufsiz &lt; FV_DIRBUF_MAX_SIZ)) {
		<span class="enscript-comment">/*
		 * Some Filesystems have higher requirements for the
		 * smallest buffer size they will respond to for a
		 * directory listing. Start (relatively) small but increase
		 * it upto FV_DIRBUF_MAX_SIZ. Most should be good with
		 * 1*direntry. Cache the size found so that this does not need
		 * need to be done every time. This also means that an error
		 * from VNOP_READDIR is ignored until at least FV_DIRBUF_MAX_SIZ
		 * has been attempted.
		 */</span>
		FREE(fvd-&gt;fv_buf, M_FD_DIRBUF);
		fvd-&gt;fv_buf = NULL;
		rdirbufsiz = 2 * rdirbufsiz;
		fvd-&gt;fv_bufallocsiz = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry_alloc</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">/*
		 * The Filesystem did not set eofflag but also did not
		 * return any entries (or an error). It is presumed that
		 * EOF has been reached.
		 */</span>
		fvd-&gt;fv_eofflag = eofflag = 1;
	}

	<span class="enscript-comment">/*
	 * If the filesystem returned an error and it had previously returned
	 * EOF, ignore the error and set EOF.
	 */</span>
	<span class="enscript-keyword">if</span> (error &amp;&amp; fvd-&gt;fv_eofflag) {
		eofflag = 1;
		error = 0;
	}

	<span class="enscript-comment">/*
	 * If either the directory has either hit EOF or an error, now is a good
	 * time to free up directory entry buffer.
	 */</span>
	<span class="enscript-keyword">if</span> ((error || eofflag) &amp;&amp; fvd-&gt;fv_buf) {
		FREE(fvd-&gt;fv_buf, M_FD_DIRBUF);
		fvd-&gt;fv_buf = NULL;
	}

	*eofflagp = eofflag;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * gets the current direntry. To advance to the next direntry this has to be
 * paired with a direntry_done.
 *
 * Since directories have restrictions on where directory enumeration
 * can restart from, entries are first read into* a per fd diectory entry
 * &quot;cache&quot; and entries provided from that cache.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">get_direntry</span>(vfs_context_t ctx, vnode_t dvp, <span class="enscript-type">struct</span> fd_vn_data *fvd,
    <span class="enscript-type">int</span> *eofflagp, <span class="enscript-type">struct</span> direntry **dpp)
{
	<span class="enscript-type">int</span> eofflag;
	<span class="enscript-type">int</span> error;

	*eofflagp = 0;
	*dpp = NULL;
	error = 0;
	<span class="enscript-keyword">if</span> (!fvd-&gt;fv_bufsiz) {
		error = refill_fd_direntries(ctx, dvp, fvd, &amp;eofflag);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> (eofflag) {
			*eofflagp = eofflag;
			<span class="enscript-keyword">return</span> (error);
		}
	}

	*dpp = (<span class="enscript-type">struct</span> direntry *)(fvd-&gt;fv_buf + fvd-&gt;fv_bufdone);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Advances to the next direntry.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">direntry_done</span>(<span class="enscript-type">struct</span> fd_vn_data *fvd)
{
	<span class="enscript-type">struct</span> direntry *dp;

	dp = (<span class="enscript-type">struct</span> direntry *)(fvd-&gt;fv_buf + fvd-&gt;fv_bufdone);
	<span class="enscript-keyword">if</span> (dp-&gt;d_reclen) {
		fvd-&gt;fv_bufdone += dp-&gt;d_reclen;
		<span class="enscript-keyword">if</span> (fvd-&gt;fv_bufdone &gt; fvd-&gt;fv_bufsiz) {
			fvd-&gt;fv_bufdone = fvd-&gt;fv_bufsiz;
		}
	} <span class="enscript-keyword">else</span> {
		fvd-&gt;fv_bufdone = fvd-&gt;fv_bufsiz;
	}

	<span class="enscript-comment">/*
	 * If we're at the end the fd direntries cache, reset the
	 * cache trackers.
	 */</span>
	<span class="enscript-keyword">if</span> (fvd-&gt;fv_bufdone == fvd-&gt;fv_bufsiz) {
		fvd-&gt;fv_bufdone = 0;
		fvd-&gt;fv_bufsiz = 0;
	}
}

<span class="enscript-comment">/*
 *  A stripped down version of getattrlist_internal to fill in only select
 *  attributes in case of an error from getattrlist_internal.
 *
 *  It always returns at least ATTR_BULK_REQUIRED i.e. the name (but may also
 *  return some other attributes which can be obtained from the vnode).
 *
 *  It does not change the value of the passed in attrlist.
 *
 *  The objective of this function is to fill in an &quot;error entry&quot;, i.e.
 *  an entry with ATTR_CMN_RETURNED_ATTRS &amp; ATTR_CMN_NAME. If the caller
 *  has also asked for ATTR_CMN_ERROR, it is filled in as well.
 *
 *  Input
 *       vp - vnode pointer
 *       alp - pointer to attrlist struct.
 *       options - options passed to getattrlistbulk(2)
 *       kern_attr_buf - Kernel buffer to fill data (assumes offset 0 in
 *           buffer)
 *       kern_attr_buf_siz - Size of buffer.
 *       needs_error_attr - Whether the caller asked for ATTR_CMN_ERROR
 *       error_attr - This value is used to fill ATTR_CMN_ERROR (if the user
 *                  has requested it in the attribute list.
 *       namebuf - This is used to fill in the name.
 *       ctx - vfs context of caller.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">get_error_attributes</span>(vnode_t vp, <span class="enscript-type">struct</span> attrlist *alp, uint64_t options,
    user_addr_t kern_attr_buf, size_t kern_attr_buf_siz, <span class="enscript-type">int</span> error_attr,
    caddr_t namebuf, vfs_context_t ctx)
{
	size_t fsiz, vsiz;
	<span class="enscript-type">struct</span> _attrlist_buf ab;
	<span class="enscript-type">int</span> namelen;
	kauth_action_t action;
	<span class="enscript-type">struct</span> attrlist al;
	<span class="enscript-type">int</span> needs_error_attr = (alp-&gt;commonattr &amp; ATTR_CMN_ERROR);

	<span class="enscript-comment">/*
	 * To calculate fixed size required, in the FSOPT_PACK_INVAL_ATTRS case,
	 * the fixedsize should include space for all the attributes asked by
	 * the user. Only ATTR_BULK_REQUIRED (and ATTR_CMN_ERROR) will be filled
	 * and will be valid. All other attributes are zeroed out later.
	 *
	 * ATTR_CMN_RETURNED_ATTRS, ATTR_CMN_ERROR and ATTR_CMN_NAME
	 * (the only valid ones being returned from here) happen to be
	 * the first three attributes by order as well.
	 */</span>
	al = *alp;
	<span class="enscript-keyword">if</span> (!(options &amp; FSOPT_PACK_INVAL_ATTRS)) {
		<span class="enscript-comment">/*
		 * In this case the fixedsize only needs to be only for the
		 * attributes being actually returned.
		 */</span>
		al.commonattr = ATTR_BULK_REQUIRED;
		<span class="enscript-keyword">if</span> (needs_error_attr) {
			al.commonattr |= ATTR_CMN_ERROR;
		}
		al.fileattr = 0;
		al.dirattr = 0;
	}

	<span class="enscript-comment">/*
	 * Passing NULL for the vnode_attr pointer is valid for
	 * getattrlist_setupvattr. All that is required is the size.
	 */</span>
	fsiz = 0;
	(<span class="enscript-type">void</span>)getattrlist_setupvattr(&amp;al, NULL, (ssize_t *)&amp;fsiz,
	    &amp;action, proc_is64bit(vfs_context_proc(ctx)),
	    (vnode_vtype(vp) == VDIR));

	namelen = strlen(namebuf);
	vsiz = namelen + 1;
	vsiz = ((vsiz + 3) &amp; ~0x03);

	bzero(&amp;ab, <span class="enscript-keyword">sizeof</span>(ab));
	ab.base = (<span class="enscript-type">char</span> *)kern_attr_buf;
	ab.needed = fsiz + vsiz;

	<span class="enscript-comment">/* Fill in the size needed */</span>
	*((uint32_t *)ab.base) = ab.needed;
	<span class="enscript-keyword">if</span> (ab.needed &gt; (ssize_t)kern_attr_buf_siz) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Setup to pack results into the destination buffer.
	 */</span>
	ab.fixedcursor = ab.base + <span class="enscript-keyword">sizeof</span>(uint32_t);
	<span class="enscript-comment">/*
	 * Zero out buffer, ab.fixedbuffer starts after the first uint32_t
	 * which gives the length. This ensures everything that we don't
	 * fill in explicitly later is zeroed out correctly.
	 */</span>
	bzero(ab.fixedcursor, fsiz);
	<span class="enscript-comment">/*
	 * variable size data should start after all the fixed
	 * size data.
	 */</span>
	ab.varcursor = ab.base + fsiz;
	<span class="enscript-comment">/*
	 * Initialise the value for ATTR_CMN_RETURNED_ATTRS and leave space
	 * Leave space for filling in its value here at the end.
	 */</span>
	bzero(&amp;ab.actual, <span class="enscript-keyword">sizeof</span> (ab.actual));
	ab.fixedcursor += <span class="enscript-keyword">sizeof</span> (attribute_set_t);

	ab.allocated = ab.needed;

	<span class="enscript-comment">/* Fill ATTR_CMN_ERROR (if asked for) */</span>
	<span class="enscript-keyword">if</span> (needs_error_attr) {
		ATTR_PACK4(ab, error_attr);
		ab.actual.commonattr |= ATTR_CMN_ERROR;
	}

	<span class="enscript-comment">/*
	 * Fill ATTR_CMN_NAME, The attrrefrence is packed at this location
	 * but the actual string itself is packed after fixedsize which set
	 * to different lengths based on whether FSOPT_PACK_INVAL_ATTRS
	 * was passed.
	 */</span>
	attrlist_pack_string(&amp;ab, namebuf, namelen);

	<span class="enscript-comment">/*
	 * Now Fill in ATTR_CMN_RETURNED_ATTR. This copies to a
	 * location after the count i.e. before ATTR_CMN_ERROR and
	 * ATTR_CMN_NAME.
	 */</span>
	ab.actual.commonattr |= ATTR_CMN_NAME | ATTR_CMN_RETURNED_ATTRS;
	bcopy(&amp;ab.actual, ab.base + <span class="enscript-keyword">sizeof</span>(uint32_t), <span class="enscript-keyword">sizeof</span> (ab.actual));
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * This is the buffer size required to return at least 1 entry. We need space
 * for the length, for ATTR_CMN_RETURNED_ATTRS and ATTR_CMN_NAME. Assuming the
 * smallest filename of a single byte we get
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MIN_BUF_SIZE_REQUIRED</span>  (sizeof(uint32_t) + sizeof(attribute_set_t) +\
    <span class="enscript-keyword">sizeof</span>(attrreference_t))

<span class="enscript-comment">/*
 * Read directory entries and get attributes filled in for each directory
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">readdirattr</span>(vnode_t dvp, <span class="enscript-type">struct</span> fd_vn_data *fvd, uio_t auio,
    <span class="enscript-type">struct</span> attrlist *alp, uint64_t options, <span class="enscript-type">int</span> *count, <span class="enscript-type">int</span> *eofflagp,
    vfs_context_t ctx)
{
	caddr_t kern_attr_buf;
	size_t kern_attr_buf_siz;
	caddr_t max_path_name_buf = NULL;
	<span class="enscript-type">int</span> error = 0;

	*count = 0;
	*eofflagp = 0;

	<span class="enscript-keyword">if</span> (uio_iovcnt(auio) &gt; 1) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/*
	 * We fill in a kernel buffer for the attributes and uiomove each
	 * entry's attributes (as returned by getattrlist_internal)
	 */</span>
	kern_attr_buf_siz = uio_resid(auio);
	<span class="enscript-keyword">if</span> (kern_attr_buf_siz &gt; ATTR_MAX_BUFFER) {
		kern_attr_buf_siz = ATTR_MAX_BUFFER;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kern_attr_buf_siz == 0) {
		<span class="enscript-comment">/* Nothing to do */</span>
		<span class="enscript-keyword">return</span> (error);
	}

	MALLOC(kern_attr_buf, caddr_t, kern_attr_buf_siz, M_TEMP, M_WAITOK);

	<span class="enscript-keyword">while</span> (uio_resid(auio) &gt; (user_ssize_t)MIN_BUF_SIZE_REQUIRED) {
		<span class="enscript-type">struct</span> direntry *dp;
		user_addr_t name_buffer;
		<span class="enscript-type">struct</span> nameidata nd;
		vnode_t vp;
		<span class="enscript-type">struct</span> attrlist al;
		size_t entlen;
		size_t bytes_left;
		size_t pad_bytes;
		ssize_t new_resid;

		<span class="enscript-comment">/*
		 * get_direntry returns the current direntry and does not
		 * advance. A move to the next direntry only happens if
		 * direntry_done is called.
		 */</span>
		error = get_direntry(ctx, dvp, fvd, eofflagp, &amp;dp);
		<span class="enscript-keyword">if</span> (error || (*eofflagp) || !dp) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * skip &quot;.&quot; and &quot;..&quot; (and a bunch of other invalid conditions.)
		 */</span>
		<span class="enscript-keyword">if</span> (!dp-&gt;d_reclen || dp-&gt;d_ino == 0 || dp-&gt;d_namlen == 0 ||
		    (dp-&gt;d_namlen == 1 &amp;&amp; dp-&gt;d_name[0] == <span class="enscript-string">'.'</span>) ||
		    (dp-&gt;d_namlen == 2 &amp;&amp; dp-&gt;d_name[0] == <span class="enscript-string">'.'</span> &amp;&amp;
		    dp-&gt;d_name[1] == <span class="enscript-string">'.'</span>)) {
			direntry_done(fvd);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * try to deal with not-null terminated filenames.
		 */</span>
		<span class="enscript-keyword">if</span> (dp-&gt;d_name[dp-&gt;d_namlen] != <span class="enscript-string">'\0'</span>) {
			<span class="enscript-keyword">if</span> (!max_path_name_buf) {
				MALLOC(max_path_name_buf, caddr_t, MAXPATHLEN,
				    M_TEMP, M_WAITOK);
			}
			bcopy(dp-&gt;d_name, max_path_name_buf, dp-&gt;d_namlen);
			max_path_name_buf[dp-&gt;d_namlen] = <span class="enscript-string">'\0'</span>;
			name_buffer = CAST_USER_ADDR_T(max_path_name_buf);
		} <span class="enscript-keyword">else</span> {
			name_buffer = CAST_USER_ADDR_T(&amp;(dp-&gt;d_name));
		}

		<span class="enscript-comment">/*
		 * We have an iocount on the directory already.
		 * 
		 * Note that we supply NOCROSSMOUNT to the namei call as we attempt to acquire
		 * a vnode for this particular entry.  This is because the native call will
		 * (likely) attempt to emit attributes based on its own metadata in order to avoid
		 * creating vnodes where posssible.  If the native call is not going to  walk
		 * up the vnode mounted-on chain in order to find the top-most mount point, then we
		 * should not either in this emulated readdir+getattrlist() approach.  We  
		 * will be responsible for setting DIR_MNTSTATUS_MNTPOINT on that directory that
		 * contains a mount point.  
		 */</span>
		NDINIT(&amp;nd, LOOKUP, OP_GETATTR, (AUDITVNPATH1 | USEDVP | NOCROSSMOUNT), 
		    UIO_SYSSPACE, CAST_USER_ADDR_T(name_buffer), ctx);

		nd.ni_dvp = dvp;
		error = namei(&amp;nd);

		<span class="enscript-keyword">if</span> (error) {
			direntry_done(fvd);
			error = 0;
			<span class="enscript-keyword">continue</span>;
		}

		vp = nd.ni_vp;

		<span class="enscript-comment">/*
		 * getattrlist_internal can change the values of the
		 * the required attribute list. Copy the current values
		 * and use that one instead.
		 */</span>
		al = *alp;

		error = getattrlist_internal(ctx, vp, &amp;al,
		    CAST_USER_ADDR_T(kern_attr_buf), kern_attr_buf_siz,
		    options | FSOPT_REPORT_FULLSIZE, UIO_SYSSPACE, 
		    CAST_DOWN_EXPLICIT(<span class="enscript-type">char</span> *, name_buffer));

		nameidone(&amp;nd);

		<span class="enscript-keyword">if</span> (error) {
			get_error_attributes(vp, alp, options,
			    CAST_USER_ADDR_T(kern_attr_buf),
			    kern_attr_buf_siz, error, (caddr_t)name_buffer,
			    ctx);
			error = 0;
		}

		<span class="enscript-comment">/* Done with vnode now */</span>
		vnode_put(vp);

		<span class="enscript-comment">/*
		 * Because FSOPT_REPORT_FULLSIZE was set, the first 4 bytes
		 * of the buffer returned by getattrlist contains the size
		 * (even if the provided buffer isn't sufficiently big). Use
		 * that to check if we've run out of buffer space.
		 *
		 * resid is a signed type, and the size of the buffer etc
		 * are unsigned types. It is theoretically possible for
		 * resid to be &lt; 0 and in which case we would be assigning
		 * an out of bounds value to bytes_left (which is unsigned)
		 * uiomove takes care to not ever set resid to &lt; 0, so it
		 * is safe to do this here.
		 */</span>
		bytes_left = (size_t)((user_size_t)uio_resid(auio));
		entlen = (size_t)(*((uint32_t *)(kern_attr_buf)));
		<span class="enscript-keyword">if</span> (!entlen || (entlen &gt; bytes_left)) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * Will the pad bytes fit as well  ? If they can't be, still use
		 * this entry but this will be the last entry returned.
		 */</span>
		pad_bytes = ((entlen + 7) &amp; ~0x07) - entlen;
		new_resid = 0;
		<span class="enscript-keyword">if</span> (pad_bytes &amp;&amp; (entlen + pad_bytes &lt;= bytes_left)) {
			<span class="enscript-comment">/*
			 * While entlen can never be &gt; ATTR_MAX_BUFFER,
			 * (entlen + pad_bytes) can be, handle that and
			 * zero out the pad bytes. N.B. - Only zero
			 * out information in the kernel buffer that is
			 * going to be uiomove'ed out.
			 */</span>
			<span class="enscript-keyword">if</span> (entlen + pad_bytes &lt;= kern_attr_buf_siz) {
				<span class="enscript-comment">/* This is the normal case. */</span>
				bzero(kern_attr_buf + entlen, pad_bytes);
			} <span class="enscript-keyword">else</span> {
				bzero(kern_attr_buf + entlen,
				    kern_attr_buf_siz - entlen);
				<span class="enscript-comment">/*
				 * Pad bytes left over, change the resid value
				 * manually. We only got in here because
				 * bytes_left &gt;= entlen + pad_bytes so
				 * new_resid (which is a signed type) is
				 * always positive.
				 */</span>
				new_resid = (ssize_t)(bytes_left -
				    (entlen + pad_bytes));
			}
			entlen += pad_bytes;
		}
		*((uint32_t *)kern_attr_buf) = (uint32_t)entlen;
		error = uiomove(kern_attr_buf, min(entlen, kern_attr_buf_siz),
		    auio);

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (new_resid) {
			uio_setresid(auio, (user_ssize_t)new_resid);
		}

		<span class="enscript-comment">/*
		 * At this point, the directory entry has been consumed, proceed
		 * to the next one.
		 */</span>
		(*count)++;
		direntry_done(fvd);
	}

	<span class="enscript-keyword">if</span> (max_path_name_buf) {
		FREE(max_path_name_buf, M_TEMP);
	}

	<span class="enscript-comment">/*
	 * At this point, kern_attr_buf is always allocated
	 */</span>
	FREE(kern_attr_buf, M_TEMP);

	<span class="enscript-comment">/*
	 * Always set the offset to the last succesful offset
	 * returned by VNOP_READDIR.
	 */</span>
	uio_setoffset(auio, fvd-&gt;fv_eoff);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 *int getattrlistbulk(int dirfd, struct attrlist *alist, void *attributeBuffer,
 *    size_t bufferSize, uint64_t options)
 *
 * Gets directory entries alongwith their attributes in the same way
 * getattrlist does for a single file system object.
 *
 * On non error returns, retval will hold the count of entries returned.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getattrlistbulk</span>(proc_t p, <span class="enscript-type">struct</span> getattrlistbulk_args *uap, int32_t *retval)
{
	<span class="enscript-type">struct</span> attrlist al;
	vnode_t dvp;
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> fd_vn_data *fvdata;
	vfs_context_t ctx;
	<span class="enscript-type">enum</span> uio_seg segflg;
	<span class="enscript-type">int</span> count;
	uio_t auio = NULL;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];
	kauth_action_t action;
	<span class="enscript-type">int</span> eofflag;
	uint64_t options;
	<span class="enscript-type">int</span> error;

	*retval = 0;

	error = fp_getfvp(p, uap-&gt;dirfd, &amp;fp, &amp;dvp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	count = 0;
	fvdata = NULL;
	eofflag = 0;
	ctx = vfs_context_current();
	segflg = IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32;

	<span class="enscript-keyword">if</span> ((fp-&gt;f_fglob-&gt;fg_flag &amp; FREAD) == 0) {
		<span class="enscript-comment">/*
		AUDIT_ARG(vnpath_withref, dvp, ARG_VNODE1);
		*/</span>
		error = EBADF;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> ((error = vnode_getwithref(dvp))) {
		dvp = NULLVP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (dvp-&gt;v_type != VDIR) {
		error = ENOTDIR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_file_check_change_offset(vfs_context_ucred(ctx),
	                                     fp-&gt;f_fglob);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * XXX : Audit Support
	 *AUDIT_ARG(vnpath, dvp, ARG_VNODE1);
	 */</span>

	options = uap-&gt;options | FSOPT_ATTR_CMN_EXTENDED;

	<span class="enscript-keyword">if</span> ((error = copyin(CAST_USER_ADDR_T(uap-&gt;alist), &amp;al,
	    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> attrlist)))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (al.volattr ||
	    ((al.commonattr &amp; ATTR_BULK_REQUIRED) != ATTR_BULK_REQUIRED)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_readdir(ctx, dvp);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>

	<span class="enscript-comment">/*
	 * If the only item requested is file names, we can let that past with
	 * just LIST_DIRECTORY.  If they want any other attributes, that means
	 * they need SEARCH as well.
	 */</span>
	action = KAUTH_VNODE_LIST_DIRECTORY;
	<span class="enscript-keyword">if</span> ((al.commonattr &amp; ~ATTR_CMN_NAME) || al.fileattr || al.dirattr)
		action |= KAUTH_VNODE_SEARCH;
	
	error = vnode_authorize(dvp, NULL, action, ctx);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	fvdata = (<span class="enscript-type">struct</span> fd_vn_data *)fp-&gt;f_fglob-&gt;fg_vn_data;
	<span class="enscript-keyword">if</span> (!fvdata) {
		panic(<span class="enscript-string">&quot;Directory expected to have fg_vn_data&quot;</span>);
	}

	FV_LOCK(fvdata);

	<span class="enscript-comment">/*
	 * getattrlistbulk(2) maintains its offset in fv_offset. However
	 * if the offset in the file glob is set (or reset) to 0, the directory
	 * traversal needs to be restarted (Any existing state in the
	 * directory buffer is removed as well).
	 */</span>
	<span class="enscript-keyword">if</span> (!fp-&gt;f_fglob-&gt;fg_offset) {
		fvdata-&gt;fv_offset = 0;
		<span class="enscript-keyword">if</span> (fvdata-&gt;fv_buf)
			FREE(fvdata-&gt;fv_buf, M_FD_DIRBUF);
		fvdata-&gt;fv_buf = NULL;
		fvdata-&gt;fv_bufsiz = 0;
		fvdata-&gt;fv_bufdone = 0;
		fvdata-&gt;fv_soff = 0;
		fvdata-&gt;fv_eoff = 0;
		fvdata-&gt;fv_eofflag = 0;
	}

	auio = uio_createwithbuffer(1, fvdata-&gt;fv_offset, segflg, UIO_READ,
	    &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, uap-&gt;attributeBuffer, (user_size_t)uap-&gt;bufferSize);

	<span class="enscript-comment">/*
	 * For &quot;expensive&quot; operations in which the native VNOP implementations
	 * end up having to do just as much (if not more) work than the default
	 * implementation, fall back to the default implementation.
	 * The VNOP helper functions depend on the filesystem providing the
	 * object type, if the caller has not requested ATTR_CMN_OBJTYPE, fall
	 * back to the default implementation.
	 */</span>
	<span class="enscript-keyword">if</span> ((al.commonattr &amp;
	    (ATTR_CMN_UUID | ATTR_CMN_GRPUUID | ATTR_CMN_EXTENDED_SECURITY)) ||
	    !(al.commonattr &amp; ATTR_CMN_OBJTYPE)) {
		error = ENOTSUP;
	 } <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> vnode_attr va;
		<span class="enscript-type">char</span> *va_name;

		<span class="enscript-keyword">if</span> (fvdata-&gt;fv_eofflag &amp;&amp; !fvdata-&gt;fv_buf) {
			<span class="enscript-comment">/*
			 * If the last successful VNOP_GETATTRLISTBULK or
			 * VNOP_READDIR returned EOF, don't try again.
			 */</span>
			eofflag = 1;
			count = 0;
			error = 0;
		} <span class="enscript-keyword">else</span> {
			eofflag = 0;
			count = 0;

			VATTR_INIT(&amp;va);
			MALLOC(va_name, <span class="enscript-type">char</span> *, MAXPATHLEN, M_TEMP,
			    M_WAITOK | M_ZERO);
			va.va_name = va_name;

			(<span class="enscript-type">void</span>)getattrlist_setupvattr_all(&amp;al, &amp;va, VNON, NULL,
			    IS_64BIT_PROCESS(p));

			error = VNOP_GETATTRLISTBULK(dvp, &amp;al, &amp;va, auio, NULL,
			    options, &amp;eofflag, &amp;count, ctx);

			FREE(va_name, M_TEMP);

			<span class="enscript-comment">/*
			 * cache state of eofflag.
			 */</span>
			<span class="enscript-keyword">if</span> (!error) {
				fvdata-&gt;fv_eofflag = eofflag;
			}
		}
	}

	<span class="enscript-comment">/*
	 * If the Filessytem does not natively support getattrlistbulk,
	 * do the default implementation.
	 */</span>
	<span class="enscript-keyword">if</span> (error == ENOTSUP) {
		eofflag = 0;
		count = 0;

		error = readdirattr(dvp, fvdata, auio, &amp;al, options,
		    &amp;count, &amp;eofflag, ctx);
	}

	<span class="enscript-keyword">if</span> (count) {
		fvdata-&gt;fv_offset = uio_offset(auio);
		fp-&gt;f_fglob-&gt;fg_offset = fvdata-&gt;fv_offset;
		*retval = count;
		error = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!error &amp;&amp; !eofflag) {
		<span class="enscript-comment">/*
		 * This just means the buffer was too small to fit even a
		 * single entry.
		 */</span>
		error = ERANGE;
	}

	FV_UNLOCK(fvdata);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (dvp) {
		vnode_put(dvp);
	}

	file_drop(uap-&gt;dirfd);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">attrlist_unpack_fixed</span>(<span class="enscript-type">char</span> **cursor, <span class="enscript-type">char</span> *end, <span class="enscript-type">void</span> *buf, ssize_t size)
{
	<span class="enscript-comment">/* make sure we have enough source data */</span>
	<span class="enscript-keyword">if</span> ((*cursor) + size &gt; end)
		<span class="enscript-keyword">return</span>(EINVAL);

	bcopy(*cursor, buf, size);
	*cursor += size;
	<span class="enscript-keyword">return</span>(0);
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ATTR_UNPACK</span>(v)		do {if ((error = attrlist_unpack_fixed(&amp;cursor, bufend, &amp;v, sizeof(v))) != 0) goto out;} while(0);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ATTR_UNPACK_CAST</span>(t, v)	do { t _f; ATTR_UNPACK(_f); v = _f;} while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ATTR_UNPACK_TIME</span>(v, is64)				\
	<span class="enscript-keyword">do</span> {							\
		<span class="enscript-keyword">if</span> (is64) {					\
			<span class="enscript-type">struct</span> user64_timespec us;		\
			ATTR_UNPACK(us);			\
			v.tv_sec = us.tv_sec;			\
			v.tv_nsec = us.tv_nsec;			\
		} <span class="enscript-keyword">else</span> {					\
			<span class="enscript-type">struct</span> user32_timespec us;		\
			ATTR_UNPACK(us);			\
			v.tv_sec = us.tv_sec;			\
			v.tv_nsec = us.tv_nsec;			\
		}						\
	} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/*
 * Write attributes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">setattrlist_internal</span>(vnode_t vp, <span class="enscript-type">struct</span> setattrlist_args *uap, proc_t p, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> attrlist al;
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">struct</span> attrreference ar;
	kauth_action_t	action;
	<span class="enscript-type">char</span>		*user_buf, *cursor, *bufend, *fndrinfo, *cp, *volname;
	<span class="enscript-type">int</span>		proc_is64, error;
	uint32_t	nace;
	kauth_filesec_t rfsec;

	user_buf = NULL;
	fndrinfo = NULL;
	volname = NULL;
	error = 0;
	proc_is64 = proc_is64bit(p);
	VATTR_INIT(&amp;va);
	
	<span class="enscript-comment">/*
	 * Fetch the attribute set and validate.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;alist, (caddr_t) &amp;al, <span class="enscript-keyword">sizeof</span> (al))))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> (al.bitmapcount != ATTR_BIT_MAP_COUNT) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;%p  ATTRLIST - %s set common %08x vol %08x file %08x dir %08x fork %08x %sfollow on '%s'&quot;</span>,
	    vp, p-&gt;p_comm, al.commonattr, al.volattr, al.fileattr, al.dirattr, al.forkattr,
	    (uap-&gt;options &amp; FSOPT_NOFOLLOW) ? <span class="enscript-string">&quot;no&quot;</span>:<span class="enscript-string">&quot;&quot;</span>, vp-&gt;v_name);

	<span class="enscript-keyword">if</span> (al.volattr) {
		<span class="enscript-keyword">if</span> ((al.volattr &amp; ~ATTR_VOL_SETMASK) ||
		    (al.commonattr &amp; ~ATTR_CMN_VOLSETMASK) ||
		    al.fileattr ||
		    al.forkattr) {
			error = EINVAL;
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: attempt to set invalid volume attributes&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((al.commonattr &amp; ~ATTR_CMN_SETMASK) ||
		    (al.fileattr &amp; ~ATTR_FILE_SETMASK) ||
		    (al.dirattr &amp; ~ATTR_DIR_SETMASK) ||
		    (al.forkattr &amp; ~ATTR_FORK_SETMASK)) {
			error = EINVAL;
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: attempt to set invalid file/folder attributes&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/*
	 * If the caller's bitmaps indicate that there are no attributes to set,
	 * then exit early.  In particular, we want to avoid the MALLOC below
	 * since the caller's bufferSize could be zero, and MALLOC of zero bytes
	 * returns a NULL pointer, which would cause setattrlist to return ENOMEM.
	 */</span>
	<span class="enscript-keyword">if</span> (al.commonattr == 0 &amp;&amp;
		(al.volattr &amp; ~ATTR_VOL_INFO) == 0 &amp;&amp;
		al.dirattr == 0 &amp;&amp;
		al.fileattr == 0 &amp;&amp;
		al.forkattr == 0) {
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
		
	<span class="enscript-comment">/*
	 * Make the naive assumption that the caller has supplied a reasonable buffer
	 * size.  We could be more careful by pulling in the fixed-size region, checking
	 * the attrref structures, then pulling in the variable section.
	 * We need to reconsider this for handling large ACLs, as they should probably be
	 * brought directly into a buffer.  Multiple copyins will make this slower though.
	 *
	 * We could also map the user buffer if it is larger than some sensible mimimum.
	 */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;bufferSize &gt; ATTR_MAX_BUFFER) {
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: buffer size %d too large&quot;</span>, uap-&gt;bufferSize);
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	MALLOC(user_buf, <span class="enscript-type">char</span> *, uap-&gt;bufferSize, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (user_buf == NULL) {
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: could not allocate %d bytes for buffer&quot;</span>, uap-&gt;bufferSize);
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;attributeBuffer, user_buf, uap-&gt;bufferSize)) != 0) {
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: buffer copyin failed&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - copied in %d bytes of user attributes to %p&quot;</span>, uap-&gt;bufferSize, user_buf);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_setattrlist(ctx, vp, &amp;al);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>

	<span class="enscript-comment">/*
	 * Unpack the argument buffer.
	 */</span>
	cursor = user_buf;
	bufend = cursor + uap-&gt;bufferSize;

	<span class="enscript-comment">/* common */</span>
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_SCRIPT) {
		ATTR_UNPACK(va.va_encoding);
		VATTR_SET_ACTIVE(&amp;va, va_encoding);
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_CRTIME) {
		ATTR_UNPACK_TIME(va.va_create_time, proc_is64);
		VATTR_SET_ACTIVE(&amp;va, va_create_time);
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_MODTIME) {
		ATTR_UNPACK_TIME(va.va_modify_time, proc_is64);
		VATTR_SET_ACTIVE(&amp;va, va_modify_time);
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_CHGTIME) {
		ATTR_UNPACK_TIME(va.va_change_time, proc_is64);
		al.commonattr &amp;= ~ATTR_CMN_CHGTIME;
		<span class="enscript-comment">/*quietly ignore change time; advisory in man page*/</span>
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_ACCTIME) {
		ATTR_UNPACK_TIME(va.va_access_time, proc_is64);
		VATTR_SET_ACTIVE(&amp;va, va_access_time);
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_BKUPTIME) {
		ATTR_UNPACK_TIME(va.va_backup_time, proc_is64);
		VATTR_SET_ACTIVE(&amp;va, va_backup_time);
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_FNDRINFO) {
		<span class="enscript-keyword">if</span> ((cursor + 32) &gt; bufend) {
			error = EINVAL;
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - not enough data supplied for FINDERINFO&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		fndrinfo = cursor;
		cursor += 32;
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_OWNERID) {
		ATTR_UNPACK(va.va_uid);
		VATTR_SET_ACTIVE(&amp;va, va_uid);
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_GRPID) {
		ATTR_UNPACK(va.va_gid);
		VATTR_SET_ACTIVE(&amp;va, va_gid);
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_ACCESSMASK) {
		ATTR_UNPACK_CAST(uint32_t, va.va_mode);
		VATTR_SET_ACTIVE(&amp;va, va_mode);
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_FLAGS) {
		ATTR_UNPACK(va.va_flags);
		VATTR_SET_ACTIVE(&amp;va, va_flags);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-keyword">if</span> ((error = mac_vnode_check_setflags(ctx, vp, va.va_flags)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_EXTENDED_SECURITY) {

		<span class="enscript-comment">/*
		 * We are (for now) passed a kauth_filesec_t, but all we want from
		 * it is the ACL.
		 */</span>
		cp = cursor;
		ATTR_UNPACK(ar);
		<span class="enscript-keyword">if</span> (ar.attr_dataoffset &lt; 0) {
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: bad offset supplied&quot;</span>, ar.attr_dataoffset);
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		cp += ar.attr_dataoffset;
		rfsec = (kauth_filesec_t)cp;
		<span class="enscript-keyword">if</span> (((((<span class="enscript-type">char</span> *)rfsec) + KAUTH_FILESEC_SIZE(0)) &gt; bufend) ||			<span class="enscript-comment">/* no space for acl */</span>
		    (rfsec-&gt;fsec_magic != KAUTH_FILESEC_MAGIC) ||       <span class="enscript-comment">/* bad magic */</span>
		    (KAUTH_FILESEC_COPYSIZE(rfsec) != ar.attr_length) || <span class="enscript-comment">/* size does not match */</span>
		    ((cp + KAUTH_FILESEC_COPYSIZE(rfsec)) &gt; bufend)) {	<span class="enscript-comment">/* ACEs overrun buffer */</span>
			error = EINVAL;
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: bad ACL supplied&quot;</span>, ar.attr_length);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		nace = rfsec-&gt;fsec_entrycount;
		<span class="enscript-keyword">if</span> (nace == KAUTH_FILESEC_NOACL)
			nace = 0;
		<span class="enscript-keyword">if</span> (nace &gt; KAUTH_ACL_MAX_ENTRIES) {			<span class="enscript-comment">/* ACL size invalid */</span>
			error = EINVAL;
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: bad ACL supplied&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		nace = rfsec-&gt;fsec_acl.acl_entrycount;
		<span class="enscript-keyword">if</span> (nace == KAUTH_FILESEC_NOACL) {
			<span class="enscript-comment">/* deleting ACL */</span>
			VATTR_SET(&amp;va, va_acl, NULL);
		} <span class="enscript-keyword">else</span> {
			
			<span class="enscript-keyword">if</span> (nace &gt; KAUTH_ACL_MAX_ENTRIES) {			<span class="enscript-comment">/* ACL size invalid */</span>
				error = EINVAL;
				VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: supplied ACL is too large&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			VATTR_SET(&amp;va, va_acl, &amp;rfsec-&gt;fsec_acl);
		}
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_UUID) {
		ATTR_UNPACK(va.va_uuuid);
		VATTR_SET_ACTIVE(&amp;va, va_uuuid);
	}
	<span class="enscript-keyword">if</span> (al.commonattr &amp; ATTR_CMN_GRPUUID) {
		ATTR_UNPACK(va.va_guuid);
		VATTR_SET_ACTIVE(&amp;va, va_guuid);
	}

	<span class="enscript-comment">/* volume */</span>
	<span class="enscript-keyword">if</span> (al.volattr &amp; ATTR_VOL_INFO) {
		<span class="enscript-keyword">if</span> (al.volattr &amp; ATTR_VOL_NAME) {
			volname = cursor;
			ATTR_UNPACK(ar);	
			<span class="enscript-comment">/* attr_length cannot be 0! */</span>
			<span class="enscript-keyword">if</span> ((ar.attr_dataoffset &lt; 0) || (ar.attr_length == 0) ||
				(ar.attr_length &gt; uap-&gt;bufferSize) ||
				(uap-&gt;bufferSize - ar.attr_length &lt; (<span class="enscript-type">unsigned</span>)ar.attr_dataoffset)) {
				VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: bad offset supplied (2) &quot;</span>, ar.attr_dataoffset);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-keyword">if</span> (volname &gt;= bufend - ar.attr_dataoffset - ar.attr_length) {
				error = EINVAL;
				VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: volume name too big for caller buffer&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			volname += ar.attr_dataoffset;
			<span class="enscript-comment">/* guarantee NUL termination */</span>
			volname[ar.attr_length - 1] = 0;
		}
	}

	<span class="enscript-comment">/* file */</span>
	<span class="enscript-keyword">if</span> (al.fileattr &amp; ATTR_FILE_DEVTYPE) {
		<span class="enscript-comment">/* XXX does it actually make any sense to change this? */</span>
		error = EINVAL;
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - XXX device type change not implemented&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Validate and authorize.
	 */</span>
	action = 0;
	<span class="enscript-keyword">if</span> ((va.va_active != 0LL) &amp;&amp; ((error = vnode_authattr(vp, &amp;va, &amp;action, ctx)) != 0)) {
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: attribute changes refused: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * We can auth file Finder Info here.  HFS volume FinderInfo is really boot data,
	 * and will be auth'ed by the FS.
	 */</span>
	<span class="enscript-keyword">if</span> (fndrinfo != NULL) {
		<span class="enscript-keyword">if</span> (al.volattr &amp; ATTR_VOL_INFO) {
			<span class="enscript-keyword">if</span> (vp-&gt;v_tag != VT_HFS) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		} <span class="enscript-keyword">else</span> {
			action |= KAUTH_VNODE_WRITE_EXTATTRIBUTES;
		}
	}

	<span class="enscript-keyword">if</span> ((action != 0) &amp;&amp; ((error = vnode_authorize(vp, NULL, action, ctx)) != 0)) {
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: authorization failed&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * When we're setting both the access mask and the finder info, then
	 * check if were about to remove write access for the owner.  Since
	 * vnode_setattr and vn_setxattr invoke two separate vnops, we need
	 * to consider their ordering.
	 *
	 * If were about to remove write access for the owner we'll set the
	 * Finder Info here before vnode_setattr.  Otherwise we'll set it
	 * after vnode_setattr since it may be adding owner write access.
	 */</span>
	<span class="enscript-keyword">if</span> ((fndrinfo != NULL) &amp;&amp; !(al.volattr &amp; ATTR_VOL_INFO) &amp;&amp;
	    (al.commonattr &amp; ATTR_CMN_ACCESSMASK) &amp;&amp; !(va.va_mode &amp; S_IWUSR)) {
		<span class="enscript-keyword">if</span> ((error = setattrlist_setfinderinfo(vp, fndrinfo, ctx)) != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		fndrinfo = NULL;  <span class="enscript-comment">/* it was set here so skip setting below */</span>
	}

	<span class="enscript-comment">/*
	 * Write the attributes if we have any.
	 */</span>
	<span class="enscript-keyword">if</span> ((va.va_active != 0LL) &amp;&amp; ((error = vnode_setattr(vp, &amp;va, ctx)) != 0)) {
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: filesystem returned %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Write the Finder Info if we have any.
	 */</span>
	<span class="enscript-keyword">if</span> (fndrinfo != NULL) {
		<span class="enscript-keyword">if</span> (al.volattr &amp; ATTR_VOL_INFO) {
			<span class="enscript-keyword">if</span> (vp-&gt;v_tag == VT_HFS) {
				error = VNOP_IOCTL(vp, HFS_SET_BOOT_INFO, (caddr_t)fndrinfo, 0, ctx);
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* XXX should never get here */</span>
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((error = setattrlist_setfinderinfo(vp, fndrinfo, ctx)) != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/* 
	 * Set the volume name, if we have one
	 */</span>
	<span class="enscript-keyword">if</span> (volname != NULL)
	{
		<span class="enscript-type">struct</span> vfs_attr vs;
		
		VFSATTR_INIT(&amp;vs);
		
		vs.f_vol_name = volname;	<span class="enscript-comment">/* References the setattrlist buffer directly */</span>
		VFSATTR_WANTED(&amp;vs, f_vol_name);
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_mount_check_setattr(ctx, vp-&gt;v_mount, &amp;vs);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">if</span> ((error = vfs_setattr(vp-&gt;v_mount, &amp;vs, ctx)) != 0) {
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: setting volume name failed&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		<span class="enscript-keyword">if</span> (!VFSATTR_ALL_SUPPORTED(&amp;vs)) {
			error = EINVAL;
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - ERROR: could not set volume name&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/* all done and successful */</span>
	
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (user_buf != NULL)
		FREE(user_buf, M_TEMP);
	VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;ATTRLIST - set returning %d&quot;</span>, error);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">setattrlist</span>(proc_t p, <span class="enscript-type">struct</span> setattrlist_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> vfs_context *ctx;
	<span class="enscript-type">struct</span> nameidata nd;
	vnode_t		vp = NULL;
	u_long		nameiflags;
	<span class="enscript-type">int</span> error = 0;

	ctx = vfs_context_current();

	<span class="enscript-comment">/*
	 * Look up the file.
	 */</span>
	nameiflags = AUDITVNPATH1;
	<span class="enscript-keyword">if</span> ((uap-&gt;options &amp; FSOPT_NOFOLLOW) == 0)
		nameiflags |= FOLLOW;
	NDINIT(&amp;nd, LOOKUP, OP_SETATTR, nameiflags, UIO_USERSPACE, uap-&gt;path, ctx);
	<span class="enscript-keyword">if</span> ((error = namei(&amp;nd)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	vp = nd.ni_vp;
	nameidone(&amp;nd);

	error = setattrlist_internal(vp, uap, p, ctx);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (vp != NULL)
		vnode_put(vp);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fsetattrlist</span>(proc_t p, <span class="enscript-type">struct</span> fsetattrlist_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> vfs_context *ctx;
	vnode_t		vp = NULL;
	<span class="enscript-type">int</span>		error;
	<span class="enscript-type">struct</span> setattrlist_args ap;

	ctx = vfs_context_current();

	<span class="enscript-keyword">if</span> ((error = file_vnode(uap-&gt;fd, &amp;vp)) != 0)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((error = vnode_getwithref(vp)) != 0) {
		file_drop(uap-&gt;fd);
		<span class="enscript-keyword">return</span>(error);
	}

	ap.path = 0;
	ap.alist = uap-&gt;alist;
	ap.attributeBuffer = uap-&gt;attributeBuffer;
	ap.bufferSize = uap-&gt;bufferSize;
	ap.options = uap-&gt;options;

	error = setattrlist_internal(vp, &amp;ap, p, ctx);
	file_drop(uap-&gt;fd);
	<span class="enscript-keyword">if</span> (vp != NULL)
		vnode_put(vp);

	<span class="enscript-keyword">return</span> error;
}

</pre>
<hr />
</body></html>