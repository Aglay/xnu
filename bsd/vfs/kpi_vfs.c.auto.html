<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kpi_vfs.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kpi_vfs.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)kpi_vfs.c
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

<span class="enscript-comment">/*
 * External virtual filesystem routines
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsevents.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lockf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/xattr.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSByteOrder.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sdt.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ESUCCESS</span> 0
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">mount_t</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">vnode_t</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COMPAT_ONLY</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NATIVE_XATTR</span>(VP)  \
	((VP)-&gt;v_mount ? (VP)-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_EXTENDED_ATTRS : 0)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">xattrfile_remove</span>(vnode_t dvp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *basename,
				vfs_context_t ctx, <span class="enscript-type">int</span> force);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">xattrfile_setattr</span>(vnode_t dvp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * basename,
				<span class="enscript-type">struct</span> vnode_attr * vap, vfs_context_t ctx);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>

<span class="enscript-comment">/*
 * vnode_setneedinactive
 *
 * Description: Indicate that when the last iocount on this vnode goes away,
 * 		and the usecount is also zero, we should inform the filesystem
 * 		via VNOP_INACTIVE.
 *
 * Parameters:  vnode_t		vnode to mark
 *
 * Returns:     Nothing
 *
 * Notes:       Notably used when we're deleting a file--we need not have a 
 * 		usecount, so VNOP_INACTIVE may not get called by anyone.  We
 * 		want it called when we drop our iocount.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_setneedinactive</span>(vnode_t vp)
{
        cache_purge(vp);

        vnode_lock_spin(vp);
	vp-&gt;v_lflag |= VL_NEEDINACTIVE;
	vnode_unlock(vp);
}


<span class="enscript-comment">/* ====================================================================== */</span>
<span class="enscript-comment">/* ************  EXTERNAL KERNEL APIS  ********************************** */</span>
<span class="enscript-comment">/* ====================================================================== */</span>

<span class="enscript-comment">/*
 * implementations of exported VFS operations
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">VFS_MOUNT</span>(mount_t mp, vnode_t devvp, user_addr_t data, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((mp == dead_mountp) || (mp-&gt;mnt_op-&gt;vfs_mount == 0))
		<span class="enscript-keyword">return</span>(ENOTSUP);

	<span class="enscript-keyword">if</span> (vfs_context_is64bit(ctx)) {
		<span class="enscript-keyword">if</span> (vfs_64bitready(mp)) {
			error = (*mp-&gt;mnt_op-&gt;vfs_mount)(mp, devvp, data, ctx);
		}
		<span class="enscript-keyword">else</span> {
			error = ENOTSUP;
		}
	}
	<span class="enscript-keyword">else</span> {
		error = (*mp-&gt;mnt_op-&gt;vfs_mount)(mp, devvp, data, ctx);
	}
	
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">VFS_START</span>(mount_t mp, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((mp == dead_mountp) || (mp-&gt;mnt_op-&gt;vfs_start == 0))
		<span class="enscript-keyword">return</span>(ENOTSUP);

	error = (*mp-&gt;mnt_op-&gt;vfs_start)(mp, flags, ctx);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">VFS_UNMOUNT</span>(mount_t mp, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((mp == dead_mountp) || (mp-&gt;mnt_op-&gt;vfs_unmount == 0))
		<span class="enscript-keyword">return</span>(ENOTSUP);

	error = (*mp-&gt;mnt_op-&gt;vfs_unmount)(mp, flags, ctx);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		ENOTSUP			Not supported
 *		&lt;vfs_root&gt;:ENOENT
 *		&lt;vfs_root&gt;:???
 *
 * Note:	The return codes from the underlying VFS's root routine can't
 *		be fully enumerated here, since third party VFS authors may not
 *		limit their error returns to the ones documented here, even
 *		though this may result in some programs functioning incorrectly.
 *
 *		The return codes documented above are those which may currently
 *		be returned by HFS from hfs_vfs_root, which is a simple wrapper
 *		for a call to hfs_vget on the volume mount poit, not including
 *		additional error codes which may be propagated from underlying
 *		routines called by hfs_vget.
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">VFS_ROOT</span>(mount_t mp, <span class="enscript-type">struct</span> vnode  ** vpp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((mp == dead_mountp) || (mp-&gt;mnt_op-&gt;vfs_root == 0))
		<span class="enscript-keyword">return</span>(ENOTSUP);

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}

	error = (*mp-&gt;mnt_op-&gt;vfs_root)(mp, vpp, ctx);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">VFS_QUOTACTL</span>(mount_t mp, <span class="enscript-type">int</span> cmd, uid_t uid, caddr_t datap, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((mp == dead_mountp) || (mp-&gt;mnt_op-&gt;vfs_quotactl == 0))
		<span class="enscript-keyword">return</span>(ENOTSUP);

	error = (*mp-&gt;mnt_op-&gt;vfs_quotactl)(mp, cmd, uid, datap, ctx);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">VFS_GETATTR</span>(mount_t mp, <span class="enscript-type">struct</span> vfs_attr *vfa, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((mp == dead_mountp) || (mp-&gt;mnt_op-&gt;vfs_getattr == 0))
		<span class="enscript-keyword">return</span>(ENOTSUP);

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}

	error = (*mp-&gt;mnt_op-&gt;vfs_getattr)(mp, vfa, ctx);
	
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">VFS_SETATTR</span>(mount_t mp, <span class="enscript-type">struct</span> vfs_attr *vfa, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((mp == dead_mountp) || (mp-&gt;mnt_op-&gt;vfs_setattr == 0))
		<span class="enscript-keyword">return</span>(ENOTSUP);

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}

	error = (*mp-&gt;mnt_op-&gt;vfs_setattr)(mp, vfa, ctx);

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">VFS_SYNC</span>(mount_t mp, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((mp == dead_mountp) || (mp-&gt;mnt_op-&gt;vfs_sync == 0))
		<span class="enscript-keyword">return</span>(ENOTSUP);

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}

	error = (*mp-&gt;mnt_op-&gt;vfs_sync)(mp, flags, ctx);

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">VFS_VGET</span>(mount_t mp, ino64_t ino, <span class="enscript-type">struct</span> vnode **vpp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((mp == dead_mountp) || (mp-&gt;mnt_op-&gt;vfs_vget == 0))
		<span class="enscript-keyword">return</span>(ENOTSUP);

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}

	error = (*mp-&gt;mnt_op-&gt;vfs_vget)(mp, ino, vpp, ctx);

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">VFS_FHTOVP</span>(mount_t mp, <span class="enscript-type">int</span> fhlen, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * fhp, vnode_t * vpp, vfs_context_t ctx) 
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((mp == dead_mountp) || (mp-&gt;mnt_op-&gt;vfs_fhtovp == 0))
		<span class="enscript-keyword">return</span>(ENOTSUP);

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}

	error = (*mp-&gt;mnt_op-&gt;vfs_fhtovp)(mp, fhlen, fhp, vpp, ctx);

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">VFS_VPTOFH</span>(<span class="enscript-type">struct</span> vnode * vp, <span class="enscript-type">int</span> *fhlenp, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * fhp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((vp-&gt;v_mount == dead_mountp) || (vp-&gt;v_mount-&gt;mnt_op-&gt;vfs_vptofh == 0))
		<span class="enscript-keyword">return</span>(ENOTSUP);

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}

	error = (*vp-&gt;v_mount-&gt;mnt_op-&gt;vfs_vptofh)(vp, fhlenp, fhp, ctx);

	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/* returns the cached throttle mask for the mount_t */</span>
uint64_t
<span class="enscript-function-name">vfs_throttle_mask</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span>(mp-&gt;mnt_throttle_mask);
}

<span class="enscript-comment">/* returns a  copy of vfs type name for the mount_t */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">vfs_name</span>(mount_t mp, <span class="enscript-type">char</span> * buffer)
{
        strncpy(buffer, mp-&gt;mnt_vtable-&gt;vfc_name, MFSNAMELEN);
}

<span class="enscript-comment">/* returns  vfs type number for the mount_t */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vfs_typenum</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span>(mp-&gt;mnt_vtable-&gt;vfc_typenum);
}

<span class="enscript-comment">/* Safe to cast to &quot;struct label*&quot;; returns &quot;void*&quot; to limit dependence of mount.h on security headers.  */</span>
<span class="enscript-type">void</span>*
<span class="enscript-function-name">vfs_mntlabel</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span> (<span class="enscript-type">void</span>*)mp-&gt;mnt_mntlabel;
}

<span class="enscript-comment">/* returns command modifier flags of mount_t ie. MNT_CMDFLAGS */</span>
uint64_t 
<span class="enscript-function-name">vfs_flags</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span>((uint64_t)(mp-&gt;mnt_flag &amp; (MNT_CMDFLAGS | MNT_VISFLAGMASK)));
}

<span class="enscript-comment">/* set any of the command modifier flags(MNT_CMDFLAGS) in mount_t */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">vfs_setflags</span>(mount_t mp, uint64_t flags)
{
	uint32_t lflags = (uint32_t)(flags &amp; (MNT_CMDFLAGS | MNT_VISFLAGMASK)); 

	mount_lock(mp);
	mp-&gt;mnt_flag |= lflags;
	mount_unlock(mp);
}

<span class="enscript-comment">/* clear any of the command modifier flags(MNT_CMDFLAGS) in mount_t */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">vfs_clearflags</span>(mount_t mp , uint64_t flags)
{
	uint32_t lflags = (uint32_t)(flags &amp; (MNT_CMDFLAGS | MNT_VISFLAGMASK)); 

	mount_lock(mp);
	mp-&gt;mnt_flag &amp;= ~lflags;
	mount_unlock(mp);
}

<span class="enscript-comment">/* Is the mount_t ronly and upgrade read/write requested? */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vfs_iswriteupgrade</span>(mount_t mp) <span class="enscript-comment">/* ronly &amp;&amp;  MNTK_WANTRDWR */</span>
{
	<span class="enscript-keyword">return</span> ((mp-&gt;mnt_flag &amp; MNT_RDONLY) &amp;&amp; (mp-&gt;mnt_kern_flag &amp; MNTK_WANTRDWR));
}


<span class="enscript-comment">/* Is the mount_t mounted ronly */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vfs_isrdonly</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span> (mp-&gt;mnt_flag &amp; MNT_RDONLY);
}

<span class="enscript-comment">/* Is the mount_t mounted for filesystem synchronous writes? */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vfs_issynchronous</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span> (mp-&gt;mnt_flag &amp; MNT_SYNCHRONOUS);
}

<span class="enscript-comment">/* Is the mount_t mounted read/write? */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vfs_isrdwr</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span> ((mp-&gt;mnt_flag &amp; MNT_RDONLY) == 0);
}


<span class="enscript-comment">/* Is mount_t marked for update (ie MNT_UPDATE) */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vfs_isupdate</span>(mount_t mp) 
{
	<span class="enscript-keyword">return</span> (mp-&gt;mnt_flag &amp; MNT_UPDATE);
}


<span class="enscript-comment">/* Is mount_t marked for reload (ie MNT_RELOAD) */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vfs_isreload</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span> ((mp-&gt;mnt_flag &amp; MNT_UPDATE) &amp;&amp; (mp-&gt;mnt_flag &amp; MNT_RELOAD));
}

<span class="enscript-comment">/* Is mount_t marked for forced unmount (ie MNT_FORCE or MNTK_FRCUNMOUNT) */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vfs_isforce</span>(mount_t mp)
{
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_lflag &amp; MNT_LFORCE)
		<span class="enscript-keyword">return</span>(1);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_isunmount</span>(mount_t mp)
{
	<span class="enscript-keyword">if</span> ((mp-&gt;mnt_lflag &amp; MNT_LUNMOUNT)) {
		<span class="enscript-keyword">return</span> 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> 0;
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_64bitready</span>(mount_t mp)
{
	<span class="enscript-keyword">if</span> ((mp-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFS64BITREADY))
		<span class="enscript-keyword">return</span>(1);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_authcache_ttl</span>(mount_t mp)
{
        <span class="enscript-keyword">if</span> ( (mp-&gt;mnt_kern_flag &amp; (MNTK_AUTH_OPAQUE | MNTK_AUTH_CACHE_TTL)) )
	        <span class="enscript-keyword">return</span> (mp-&gt;mnt_authcache_ttl);
	<span class="enscript-keyword">else</span>
	        <span class="enscript-keyword">return</span> (CACHED_RIGHT_INFINITE_TTL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_setauthcache_ttl</span>(mount_t mp, <span class="enscript-type">int</span> ttl)
{
	mount_lock(mp);
	mp-&gt;mnt_kern_flag |= MNTK_AUTH_CACHE_TTL;
	mp-&gt;mnt_authcache_ttl = ttl;
	mount_unlock(mp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_clearauthcache_ttl</span>(mount_t mp)
{
	mount_lock(mp);
	mp-&gt;mnt_kern_flag &amp;= ~MNTK_AUTH_CACHE_TTL;
	<span class="enscript-comment">/*
	 * back to the default TTL value in case
	 * MNTK_AUTH_OPAQUE is set on this mount
	 */</span>
	mp-&gt;mnt_authcache_ttl = CACHED_LOOKUP_RIGHT_TTL;
	mount_unlock(mp);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_authopaque</span>(mount_t mp)
{
	<span class="enscript-keyword">if</span> ((mp-&gt;mnt_kern_flag &amp; MNTK_AUTH_OPAQUE))
		<span class="enscript-keyword">return</span>(1);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">vfs_authopaqueaccess</span>(mount_t mp)
{
	<span class="enscript-keyword">if</span> ((mp-&gt;mnt_kern_flag &amp; MNTK_AUTH_OPAQUE_ACCESS))
		<span class="enscript-keyword">return</span>(1);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_setauthopaque</span>(mount_t mp)
{
	mount_lock(mp);
	mp-&gt;mnt_kern_flag |= MNTK_AUTH_OPAQUE;
	mount_unlock(mp);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">vfs_setauthopaqueaccess</span>(mount_t mp)
{
	mount_lock(mp);
	mp-&gt;mnt_kern_flag |= MNTK_AUTH_OPAQUE_ACCESS;
	mount_unlock(mp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_clearauthopaque</span>(mount_t mp)
{
	mount_lock(mp);
	mp-&gt;mnt_kern_flag &amp;= ~MNTK_AUTH_OPAQUE;
	mount_unlock(mp);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">vfs_clearauthopaqueaccess</span>(mount_t mp)
{
	mount_lock(mp);
	mp-&gt;mnt_kern_flag &amp;= ~MNTK_AUTH_OPAQUE_ACCESS;
	mount_unlock(mp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_setextendedsecurity</span>(mount_t mp)
{
	mount_lock(mp);
	mp-&gt;mnt_kern_flag |= MNTK_EXTENDED_SECURITY;
	mount_unlock(mp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_clearextendedsecurity</span>(mount_t mp)
{
	mount_lock(mp);
	mp-&gt;mnt_kern_flag &amp;= ~MNTK_EXTENDED_SECURITY;
	mount_unlock(mp);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_extendedsecurity</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span>(mp-&gt;mnt_kern_flag &amp; MNTK_EXTENDED_SECURITY);
}

<span class="enscript-comment">/* returns the max size of short symlink in this mount_t */</span>
uint32_t 
<span class="enscript-function-name">vfs_maxsymlen</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span>(mp-&gt;mnt_maxsymlinklen);
}

<span class="enscript-comment">/* set  max size of short symlink on mount_t */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">vfs_setmaxsymlen</span>(mount_t mp, uint32_t symlen)
{
	mp-&gt;mnt_maxsymlinklen = symlen;
}

<span class="enscript-comment">/* return a pointer to the RO vfs_statfs associated with mount_t */</span>
<span class="enscript-type">struct</span> vfsstatfs * 
<span class="enscript-function-name">vfs_statfs</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span>(&amp;mp-&gt;mnt_vfsstat);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_getattr</span>(mount_t mp, <span class="enscript-type">struct</span> vfs_attr *vfa, vfs_context_t ctx)
{
	<span class="enscript-type">int</span>		error;

	<span class="enscript-keyword">if</span> ((error = VFS_GETATTR(mp, vfa, ctx)) != 0)
		<span class="enscript-keyword">return</span>(error);

	<span class="enscript-comment">/*
 	 * If we have a filesystem create time, use it to default some others.
 	 */</span>
 	<span class="enscript-keyword">if</span> (VFSATTR_IS_SUPPORTED(vfa, f_create_time)) {
 		<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(vfa, f_modify_time) &amp;&amp; !VFSATTR_IS_SUPPORTED(vfa, f_modify_time))
 			VFSATTR_RETURN(vfa, f_modify_time, vfa-&gt;f_create_time);
 	}

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_setattr</span>(mount_t mp, <span class="enscript-type">struct</span> vfs_attr *vfa, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;
	
	<span class="enscript-keyword">if</span> (vfs_isrdonly(mp))
		<span class="enscript-keyword">return</span> EROFS;

	error = VFS_SETATTR(mp, vfa, ctx);
	
	<span class="enscript-comment">/*
	 * If we had alternate ways of setting vfs attributes, we'd
	 * fall back here.
	 */</span>

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/* return the private data handle stored in mount_t */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">vfs_fsprivate</span>(mount_t mp)
{
	<span class="enscript-keyword">return</span>(mp-&gt;mnt_data);
}

<span class="enscript-comment">/* set the private data handle in mount_t */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">vfs_setfsprivate</span>(mount_t mp, <span class="enscript-type">void</span> *mntdata)
{
	mount_lock(mp);
	mp-&gt;mnt_data = mntdata;
	mount_unlock(mp);
}

<span class="enscript-comment">/* query whether the mount point supports native EAs */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vfs_nativexattrs</span>(mount_t mp) {
	<span class="enscript-keyword">return</span> (mp-&gt;mnt_kern_flag &amp; MNTK_EXTENDED_ATTRS);
}
	
<span class="enscript-comment">/*
 * return the block size of the underlying
 * device associated with mount_t
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_devblocksize</span>(mount_t mp) {

        <span class="enscript-keyword">return</span>(mp-&gt;mnt_devblocksize);
}

<span class="enscript-comment">/* 
 * Returns vnode with an iocount that must be released with vnode_put() 
 */</span>
vnode_t
<span class="enscript-function-name">vfs_vnodecovered</span>(mount_t mp) 
{
	vnode_t vp = mp-&gt;mnt_vnodecovered;
	<span class="enscript-keyword">if</span> ((vp == NULL) || (vnode_getwithref(vp) != 0)) {
		<span class="enscript-keyword">return</span> NULL;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> vp;
	}
}

<span class="enscript-comment">/*
 * Returns device vnode backing a mountpoint with an iocount (if valid vnode exists).
 * The iocount must be released with vnode_put().  Note that this KPI is subtle
 * with respect to the validity of using this device vnode for anything substantial
 * (which is discouraged).  If commands are sent to the device driver without
 * taking proper steps to ensure that the device is still open, chaos may ensue.  
 * Similarly, this routine should only be called if there is some guarantee that
 * the mount itself is still valid.
 */</span>
vnode_t
<span class="enscript-function-name">vfs_devvp</span>(mount_t mp)
{
	vnode_t vp = mp-&gt;mnt_devvp;

	<span class="enscript-keyword">if</span> ((vp != NULLVP) &amp;&amp; (vnode_get(vp) == 0)) {
		<span class="enscript-keyword">return</span> vp;
	}

	<span class="enscript-keyword">return</span> NULLVP;
}

<span class="enscript-comment">/*
 * return the io attributes associated with mount_t
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_ioattr</span>(mount_t mp, <span class="enscript-type">struct</span> vfsioattr *ioattrp)
{
        <span class="enscript-keyword">if</span> (mp == NULL) {
	        ioattrp-&gt;io_maxreadcnt  = MAXPHYS;
		ioattrp-&gt;io_maxwritecnt = MAXPHYS;
		ioattrp-&gt;io_segreadcnt  = 32;
		ioattrp-&gt;io_segwritecnt = 32;
		ioattrp-&gt;io_maxsegreadsize  = MAXPHYS;
		ioattrp-&gt;io_maxsegwritesize = MAXPHYS;
		ioattrp-&gt;io_devblocksize = DEV_BSIZE;
		ioattrp-&gt;io_flags = 0;
	} <span class="enscript-keyword">else</span> {
	        ioattrp-&gt;io_maxreadcnt  = mp-&gt;mnt_maxreadcnt;
		ioattrp-&gt;io_maxwritecnt = mp-&gt;mnt_maxwritecnt;
		ioattrp-&gt;io_segreadcnt  = mp-&gt;mnt_segreadcnt;
		ioattrp-&gt;io_segwritecnt = mp-&gt;mnt_segwritecnt;
		ioattrp-&gt;io_maxsegreadsize  = mp-&gt;mnt_maxsegreadsize;
		ioattrp-&gt;io_maxsegwritesize = mp-&gt;mnt_maxsegwritesize;
		ioattrp-&gt;io_devblocksize = mp-&gt;mnt_devblocksize;
		ioattrp-&gt;io_flags = mp-&gt;mnt_ioflags;
	}
	ioattrp-&gt;io_reserved[0] = NULL;
	ioattrp-&gt;io_reserved[1] = NULL;
}


<span class="enscript-comment">/*
 * set the IO attributes associated with mount_t
 */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">vfs_setioattr</span>(mount_t mp, <span class="enscript-type">struct</span> vfsioattr * ioattrp)
{
        <span class="enscript-keyword">if</span> (mp == NULL)
	        <span class="enscript-keyword">return</span>;
        mp-&gt;mnt_maxreadcnt  = ioattrp-&gt;io_maxreadcnt;
	mp-&gt;mnt_maxwritecnt = ioattrp-&gt;io_maxwritecnt;
	mp-&gt;mnt_segreadcnt  = ioattrp-&gt;io_segreadcnt;
	mp-&gt;mnt_segwritecnt = ioattrp-&gt;io_segwritecnt;
	mp-&gt;mnt_maxsegreadsize = ioattrp-&gt;io_maxsegreadsize;
	mp-&gt;mnt_maxsegwritesize = ioattrp-&gt;io_maxsegwritesize;
	mp-&gt;mnt_devblocksize = ioattrp-&gt;io_devblocksize;
	mp-&gt;mnt_ioflags = ioattrp-&gt;io_flags;
}
 
<span class="enscript-comment">/*
 * Add a new filesystem into the kernel specified in passed in
 * vfstable structure. It fills in the vnode 
 * dispatch vector that is to be passed to when vnodes are created.
 * It returns a handle which is to be used to when the FS is to be removed
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*PFI)(<span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> vfs_opv_numops;
errno_t
<span class="enscript-function-name">vfs_fsadd</span>(<span class="enscript-type">struct</span> vfs_fsentry *vfe, vfstable_t * handle)
{
	<span class="enscript-type">struct</span> vfstable	*newvfstbl = NULL;
	<span class="enscript-type">int</span>	i,j;
	<span class="enscript-type">int</span>	(***opv_desc_vector_p)(<span class="enscript-type">void</span> *);
	<span class="enscript-type">int</span>	(**opv_desc_vector)(<span class="enscript-type">void</span> *);
	<span class="enscript-type">struct</span> vnodeopv_entry_desc	*opve_descp; 
	<span class="enscript-type">int</span> desccount;
	<span class="enscript-type">int</span> descsize;
	PFI *descptr;

	<span class="enscript-comment">/*
	 * This routine is responsible for all the initialization that would
	 * ordinarily be done as part of the system startup;
	 */</span>

	<span class="enscript-keyword">if</span> (vfe == (<span class="enscript-type">struct</span> vfs_fsentry *)0)
		<span class="enscript-keyword">return</span>(EINVAL);

	desccount = vfe-&gt;vfe_vopcnt;
	<span class="enscript-keyword">if</span> ((desccount &lt;=0) || ((desccount &gt; 8)) || (vfe-&gt;vfe_vfsops == (<span class="enscript-type">struct</span> vfsops *)NULL)
		|| (vfe-&gt;vfe_opvdescs == (<span class="enscript-type">struct</span> vnodeopv_desc **)NULL))
		<span class="enscript-keyword">return</span>(EINVAL);

	<span class="enscript-comment">/* Non-threadsafe filesystems are not supported */</span>
	<span class="enscript-keyword">if</span> ((vfe-&gt;vfe_flags &amp;  (VFS_TBLTHREADSAFE | VFS_TBLFSNODELOCK)) == 0) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	MALLOC(newvfstbl, <span class="enscript-type">void</span> *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vfstable), M_TEMP,
	       M_WAITOK);
	bzero(newvfstbl, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vfstable));
	newvfstbl-&gt;vfc_vfsops = vfe-&gt;vfe_vfsops;
	strncpy(&amp;newvfstbl-&gt;vfc_name[0], vfe-&gt;vfe_fsname, MFSNAMELEN);
	<span class="enscript-keyword">if</span> ((vfe-&gt;vfe_flags &amp; VFS_TBLNOTYPENUM))
		newvfstbl-&gt;vfc_typenum = maxvfstypenum++;
	<span class="enscript-keyword">else</span>
		newvfstbl-&gt;vfc_typenum = vfe-&gt;vfe_fstypenum;
	
	newvfstbl-&gt;vfc_refcount = 0;
	newvfstbl-&gt;vfc_flags = 0;
	newvfstbl-&gt;vfc_mountroot = NULL;
	newvfstbl-&gt;vfc_next = NULL;
	newvfstbl-&gt;vfc_vfsflags = 0;
	<span class="enscript-keyword">if</span> (vfe-&gt;vfe_flags &amp;  VFS_TBL64BITREADY)
		newvfstbl-&gt;vfc_vfsflags |= VFC_VFS64BITREADY;
	<span class="enscript-keyword">if</span> (vfe-&gt;vfe_flags &amp;  VFS_TBLVNOP_PAGEINV2)
		newvfstbl-&gt;vfc_vfsflags |= VFC_VFSVNOP_PAGEINV2;
	<span class="enscript-keyword">if</span> (vfe-&gt;vfe_flags &amp;  VFS_TBLVNOP_PAGEOUTV2)
		newvfstbl-&gt;vfc_vfsflags |= VFC_VFSVNOP_PAGEOUTV2;
	<span class="enscript-keyword">if</span> ((vfe-&gt;vfe_flags &amp; VFS_TBLLOCALVOL) == VFS_TBLLOCALVOL)
		newvfstbl-&gt;vfc_flags |= MNT_LOCAL;
	<span class="enscript-keyword">if</span> ((vfe-&gt;vfe_flags &amp; VFS_TBLLOCALVOL) &amp;&amp; (vfe-&gt;vfe_flags &amp; VFS_TBLGENERICMNTARGS) == 0)
		newvfstbl-&gt;vfc_vfsflags |= VFC_VFSLOCALARGS;
	<span class="enscript-keyword">else</span>
		newvfstbl-&gt;vfc_vfsflags |= VFC_VFSGENERICARGS;

	<span class="enscript-keyword">if</span> (vfe-&gt;vfe_flags &amp;  VFS_TBLNATIVEXATTR)
		newvfstbl-&gt;vfc_vfsflags |= VFC_VFSNATIVEXATTR;
	<span class="enscript-keyword">if</span> (vfe-&gt;vfe_flags &amp;  VFS_TBLUNMOUNT_PREFLIGHT)
		newvfstbl-&gt;vfc_vfsflags |= VFC_VFSPREFLIGHT;
	<span class="enscript-keyword">if</span> (vfe-&gt;vfe_flags &amp;  VFS_TBLREADDIR_EXTENDED)
		newvfstbl-&gt;vfc_vfsflags |= VFC_VFSREADDIR_EXTENDED;
	<span class="enscript-keyword">if</span> (vfe-&gt;vfe_flags &amp; VFS_TBLNOMACLABEL)
		newvfstbl-&gt;vfc_vfsflags |= VFC_VFSNOMACLABEL;
	<span class="enscript-keyword">if</span> (vfe-&gt;vfe_flags &amp; VFS_TBLVNOP_NOUPDATEID_RENAME)
		newvfstbl-&gt;vfc_vfsflags |= VFC_VFSVNOP_NOUPDATEID_RENAME;

	<span class="enscript-comment">/*
	 * Allocate and init the vectors.
	 * Also handle backwards compatibility.
	 *
	 * We allocate one large block to hold all &lt;desccount&gt;
	 * vnode operation vectors stored contiguously.
	 */</span>
	<span class="enscript-comment">/* XXX - shouldn't be M_TEMP */</span>

	descsize = desccount * vfs_opv_numops * <span class="enscript-keyword">sizeof</span>(PFI);
	MALLOC(descptr, PFI *, descsize,
	       M_TEMP, M_WAITOK);
	bzero(descptr, descsize);

	newvfstbl-&gt;vfc_descptr = descptr;
	newvfstbl-&gt;vfc_descsize = descsize;
	
	newvfstbl-&gt;vfc_sysctl = NULL;

	<span class="enscript-keyword">for</span> (i= 0; i&lt; desccount; i++ ) {
	opv_desc_vector_p = vfe-&gt;vfe_opvdescs[i]-&gt;opv_desc_vector_p;
	<span class="enscript-comment">/*
	 * Fill in the caller's pointer to the start of the i'th vector.
	 * They'll need to supply it when calling vnode_create.
	 */</span>
	opv_desc_vector = descptr + i * vfs_opv_numops;
	*opv_desc_vector_p = opv_desc_vector;

	<span class="enscript-keyword">for</span> (j = 0; vfe-&gt;vfe_opvdescs[i]-&gt;opv_desc_ops[j].opve_op; j++) {
		opve_descp = &amp;(vfe-&gt;vfe_opvdescs[i]-&gt;opv_desc_ops[j]);

		<span class="enscript-comment">/*
		 * Sanity check:  is this operation listed
		 * in the list of operations?  We check this
		 * by seeing if its offset is zero.  Since
		 * the default routine should always be listed
		 * first, it should be the only one with a zero
		 * offset.  Any other operation with a zero
		 * offset is probably not listed in
		 * vfs_op_descs, and so is probably an error.
		 *
		 * A panic here means the layer programmer
		 * has committed the all-too common bug
		 * of adding a new operation to the layer's
		 * list of vnode operations but
		 * not adding the operation to the system-wide
		 * list of supported operations.
		 */</span>
		<span class="enscript-keyword">if</span> (opve_descp-&gt;opve_op-&gt;vdesc_offset == 0 &amp;&amp;
		    opve_descp-&gt;opve_op-&gt;vdesc_offset != VOFFSET(vnop_default)) {
			printf(<span class="enscript-string">&quot;vfs_fsadd: operation %s not listed in %s.\n&quot;</span>,
			       opve_descp-&gt;opve_op-&gt;vdesc_name,
			       <span class="enscript-string">&quot;vfs_op_descs&quot;</span>);
			panic(<span class="enscript-string">&quot;vfs_fsadd: bad operation&quot;</span>);
		}
		<span class="enscript-comment">/*
		 * Fill in this entry.
		 */</span>
		opv_desc_vector[opve_descp-&gt;opve_op-&gt;vdesc_offset] =
		    opve_descp-&gt;opve_impl;
	}


	<span class="enscript-comment">/*  
	 * Finally, go back and replace unfilled routines
	 * with their default.  (Sigh, an O(n^3) algorithm.  I
	 * could make it better, but that'd be work, and n is small.)
	 */</span>  
	opv_desc_vector_p = vfe-&gt;vfe_opvdescs[i]-&gt;opv_desc_vector_p;

	<span class="enscript-comment">/*   
	 * Force every operations vector to have a default routine.
	 */</span>  
	opv_desc_vector = *opv_desc_vector_p;
	<span class="enscript-keyword">if</span> (opv_desc_vector[VOFFSET(vnop_default)] == NULL)
	    panic(<span class="enscript-string">&quot;vfs_fsadd: operation vector without default routine.&quot;</span>);
	<span class="enscript-keyword">for</span> (j = 0; j &lt; vfs_opv_numops; j++)  
		<span class="enscript-keyword">if</span> (opv_desc_vector[j] == NULL)
			opv_desc_vector[j] =
			    opv_desc_vector[VOFFSET(vnop_default)];

	} <span class="enscript-comment">/* end of each vnodeopv_desc parsing */</span>


	
	*handle = vfstable_add(newvfstbl);

	<span class="enscript-keyword">if</span> (newvfstbl-&gt;vfc_typenum &lt;= maxvfstypenum )
			maxvfstypenum = newvfstbl-&gt;vfc_typenum + 1;

	<span class="enscript-keyword">if</span> (newvfstbl-&gt;vfc_vfsops-&gt;vfs_init) {
		<span class="enscript-type">struct</span> vfsconf vfsc;
		bzero(&amp;vfsc, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vfsconf));
		vfsc.vfc_reserved1 = 0;
		bcopy((*handle)-&gt;vfc_name, vfsc.vfc_name, <span class="enscript-keyword">sizeof</span>(vfsc.vfc_name));
		vfsc.vfc_typenum = (*handle)-&gt;vfc_typenum;
		vfsc.vfc_refcount = (*handle)-&gt;vfc_refcount;
		vfsc.vfc_flags = (*handle)-&gt;vfc_flags;
		vfsc.vfc_reserved2 = 0;
		vfsc.vfc_reserved3 = 0;

		(*newvfstbl-&gt;vfc_vfsops-&gt;vfs_init)(&amp;vfsc);
	}

	FREE(newvfstbl, M_TEMP);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Removes the filesystem from kernel.
 * The argument passed in is the handle that was given when 
 * file system was added
 */</span>
errno_t  
<span class="enscript-function-name">vfs_fsremove</span>(vfstable_t  handle)
{
	<span class="enscript-type">struct</span> vfstable * vfstbl =  (<span class="enscript-type">struct</span> vfstable *)handle;
	<span class="enscript-type">void</span> *old_desc = NULL;
	errno_t err;
	
	<span class="enscript-comment">/* Preflight check for any mounts */</span>
	mount_list_lock();
	<span class="enscript-keyword">if</span> ( vfstbl-&gt;vfc_refcount != 0 ) {
		mount_list_unlock();
		<span class="enscript-keyword">return</span> EBUSY;
	}
	
	<span class="enscript-comment">/*
	 * save the old descriptor; the free cannot occur unconditionally,
	 * since vfstable_del() may fail.
	 */</span>
	<span class="enscript-keyword">if</span> (vfstbl-&gt;vfc_descptr &amp;&amp; vfstbl-&gt;vfc_descsize) {
		old_desc = vfstbl-&gt;vfc_descptr;
	}
	err = vfstable_del(vfstbl);

	mount_list_unlock();

	<span class="enscript-comment">/* free the descriptor if the delete was successful */</span>
	<span class="enscript-keyword">if</span> (err == 0 &amp;&amp; old_desc) {
		FREE(old_desc, M_TEMP);
	}

	<span class="enscript-keyword">return</span>(err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_context_pid</span>(vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span> (proc_pid(vfs_context_proc(ctx)));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_context_suser</span>(vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span> (suser(ctx-&gt;vc_ucred, NULL));
}

<span class="enscript-comment">/*
 * Return bit field of signals posted to all threads in the context's process.
 *
 * XXX Signals should be tied to threads, not processes, for most uses of this
 * XXX call.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_context_issignal</span>(vfs_context_t ctx, sigset_t mask)
{
	proc_t p = vfs_context_proc(ctx);
	<span class="enscript-keyword">if</span> (p)
		<span class="enscript-keyword">return</span>(proc_pendingsignals(p, mask));
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_context_is64bit</span>(vfs_context_t ctx)
{
	proc_t proc = vfs_context_proc(ctx);

	<span class="enscript-keyword">if</span> (proc)
		<span class="enscript-keyword">return</span>(proc_is64bit(proc));
	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * vfs_context_proc
 *
 * Description:	Given a vfs_context_t, return the proc_t associated with it.
 *
 * Parameters:	vfs_context_t			The context to use
 *
 * Returns:	proc_t				The process for this context
 *
 * Notes:	This function will return the current_proc() if any of the
 *		following conditions are true:
 *
 *		o	The supplied context pointer is NULL
 *		o	There is no Mach thread associated with the context
 *		o	There is no Mach task associated with the Mach thread
 *		o	There is no proc_t associated with the Mach task
 *		o	The proc_t has no per process open file table
 *		o	The proc_t is post-vfork()
 *
 *		This causes this function to return a value matching as
 *		closely as possible the previous behaviour, while at the
 *		same time avoiding the task lending that results from vfork()
 */</span>
proc_t
<span class="enscript-function-name">vfs_context_proc</span>(vfs_context_t ctx)
{
	proc_t	proc = NULL;

	<span class="enscript-keyword">if</span> (ctx != NULL &amp;&amp; ctx-&gt;vc_thread != NULL)
		proc = (proc_t)get_bsdthreadtask_info(ctx-&gt;vc_thread);
	<span class="enscript-keyword">if</span> (proc != NULL &amp;&amp; (proc-&gt;p_fd == NULL || (proc-&gt;p_lflag &amp; P_LVFORK)))
		proc = NULL;

	<span class="enscript-keyword">return</span>(proc == NULL ? current_proc() : proc);
}

<span class="enscript-comment">/*
 * vfs_context_get_special_port
 *
 * Description: Return the requested special port from the task associated
 * 		with the given context.
 *
 * Parameters:	vfs_context_t			The context to use
 * 		int				Index of special port
 * 		ipc_port_t *			Pointer to returned port
 *
 * Returns:	kern_return_t			see task_get_special_port()
 */</span>
kern_return_t
<span class="enscript-function-name">vfs_context_get_special_port</span>(vfs_context_t ctx, <span class="enscript-type">int</span> which, ipc_port_t *portp)
{
	task_t			task = NULL;

	<span class="enscript-keyword">if</span> (ctx != NULL &amp;&amp; ctx-&gt;vc_thread != NULL)
		task = get_threadtask(ctx-&gt;vc_thread);

	<span class="enscript-keyword">return</span> task_get_special_port(task, which, portp);
}

<span class="enscript-comment">/*
 * vfs_context_set_special_port
 *
 * Description: Set the requested special port in the task associated
 * 		with the given context.
 *
 * Parameters:	vfs_context_t			The context to use
 * 		int				Index of special port
 * 		ipc_port_t			New special port
 *
 * Returns:	kern_return_t			see task_set_special_port()
 */</span>
kern_return_t
<span class="enscript-function-name">vfs_context_set_special_port</span>(vfs_context_t ctx, <span class="enscript-type">int</span> which, ipc_port_t port)
{
	task_t			task = NULL;

	<span class="enscript-keyword">if</span> (ctx != NULL &amp;&amp; ctx-&gt;vc_thread != NULL)
		task = get_threadtask(ctx-&gt;vc_thread);

	<span class="enscript-keyword">return</span> task_set_special_port(task, which, port);
}

<span class="enscript-comment">/*
 * vfs_context_thread
 *
 * Description:	Return the Mach thread associated with a vfs_context_t
 *
 * Parameters:	vfs_context_t			The context to use
 *
 * Returns:	thread_t			The thread for this context, or
 *						NULL, if there is not one.
 *
 * Notes:	NULL thread_t's are legal, but discouraged.  They occur only
 *		as a result of a static vfs_context_t declaration in a function
 *		and will result in this function returning NULL.
 *
 *		This is intentional; this function should NOT return the
 *		current_thread() in this case.
 */</span>
thread_t
<span class="enscript-function-name">vfs_context_thread</span>(vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span>(ctx-&gt;vc_thread);
}


<span class="enscript-comment">/*
 * vfs_context_cwd
 *
 * Description:	Returns a reference on the vnode for the current working
 *		directory for the supplied context
 *
 * Parameters:	vfs_context_t			The context to use
 *
 * Returns:	vnode_t				The current working directory
 *						for this context
 *
 * Notes:	The function first attempts to obtain the current directory
 *		from the thread, and if it is not present there, falls back
 *		to obtaining it from the process instead.  If it can't be
 *		obtained from either place, we return NULLVP.
 */</span>
vnode_t
<span class="enscript-function-name">vfs_context_cwd</span>(vfs_context_t ctx)
{
	vnode_t cwd = NULLVP;

	<span class="enscript-keyword">if</span>(ctx != NULL &amp;&amp; ctx-&gt;vc_thread != NULL) {
		uthread_t uth = get_bsdthread_info(ctx-&gt;vc_thread);
		proc_t proc;

		<span class="enscript-comment">/*
		 * Get the cwd from the thread; if there isn't one, get it
		 * from the process, instead.
		 */</span>
		<span class="enscript-keyword">if</span> ((cwd = uth-&gt;uu_cdir) == NULLVP &amp;&amp;
		    (proc = (proc_t)get_bsdthreadtask_info(ctx-&gt;vc_thread)) != NULL &amp;&amp;
		    proc-&gt;p_fd != NULL)
			cwd = proc-&gt;p_fd-&gt;fd_cdir;
	}

	<span class="enscript-keyword">return</span>(cwd);
}

<span class="enscript-comment">/*
 * vfs_context_create
 *
 * Description: Allocate and initialize a new context. 
 *
 * Parameters:  vfs_context_t: 			Context to copy, or NULL for new
 *
 * Returns:     Pointer to new context
 *
 * Notes:       Copy cred and thread from argument, if available; else 
 * 		initialize with current thread and new cred.  Returns 
 * 		with a reference held on the credential.
 */</span>
vfs_context_t
<span class="enscript-function-name">vfs_context_create</span>(vfs_context_t ctx)
{
	vfs_context_t newcontext;

	newcontext = (vfs_context_t)kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vfs_context));

	<span class="enscript-keyword">if</span> (newcontext) {
		kauth_cred_t safecred;
		<span class="enscript-keyword">if</span> (ctx) {
			newcontext-&gt;vc_thread = ctx-&gt;vc_thread;
			safecred = ctx-&gt;vc_ucred;
		} <span class="enscript-keyword">else</span> {
			newcontext-&gt;vc_thread = current_thread();
			safecred = kauth_cred_get();
		}
		<span class="enscript-keyword">if</span> (IS_VALID_CRED(safecred))
			kauth_cred_ref(safecred);
		newcontext-&gt;vc_ucred = safecred;
		<span class="enscript-keyword">return</span>(newcontext);
	}
	<span class="enscript-keyword">return</span>(NULL);	
}


vfs_context_t
<span class="enscript-function-name">vfs_context_current</span>(<span class="enscript-type">void</span>)
{
	vfs_context_t ctx = NULL;
	<span class="enscript-type">volatile</span> uthread_t ut = (uthread_t)get_bsdthread_info(current_thread());

	<span class="enscript-keyword">if</span> (ut != NULL ) {
		<span class="enscript-keyword">if</span> (ut-&gt;uu_context.vc_ucred != NULL) {
			ctx = &amp;ut-&gt;uu_context;
		}
	}

	<span class="enscript-keyword">return</span>(ctx == NULL ? vfs_context_kernel() : ctx);
}


<span class="enscript-comment">/*
 * XXX Do not ask
 *
 * Dangerous hack - adopt the first kernel thread as the current thread, to
 * get to the vfs_context_t in the uthread associated with a kernel thread.
 * This is used by UDF to make the call into IOCDMediaBSDClient,
 * IOBDMediaBSDClient, and IODVDMediaBSDClient to determine whether the
 * ioctl() is being called from kernel or user space (and all this because
 * we do not pass threads into our ioctl()'s, instead of processes).
 *
 * This is also used by imageboot_setup(), called early from bsd_init() after
 * kernproc has been given a credential.
 *
 * Note: The use of proc_thread() here is a convenience to avoid inclusion
 * of many Mach headers to do the reference directly rather than indirectly;
 * we will need to forego this convenience when we reture proc_thread().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vfs_context kerncontext;
vfs_context_t
<span class="enscript-function-name">vfs_context_kernel</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (kerncontext.vc_ucred == NOCRED)
		kerncontext.vc_ucred = kernproc-&gt;p_ucred;
	<span class="enscript-keyword">if</span> (kerncontext.vc_thread == NULL)
		kerncontext.vc_thread = proc_thread(kernproc);

	<span class="enscript-keyword">return</span>(&amp;kerncontext);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_context_rele</span>(vfs_context_t ctx)
{
	<span class="enscript-keyword">if</span> (ctx) {
		<span class="enscript-keyword">if</span> (IS_VALID_CRED(ctx-&gt;vc_ucred))
			kauth_cred_unref(&amp;ctx-&gt;vc_ucred);
		kfree(ctx, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vfs_context));
	}
	<span class="enscript-keyword">return</span>(0);
}


kauth_cred_t
<span class="enscript-function-name">vfs_context_ucred</span>(vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span> (ctx-&gt;vc_ucred);
}

<span class="enscript-comment">/*
 * Return true if the context is owned by the superuser.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_context_issuser</span>(vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span>(kauth_cred_issuser(vfs_context_ucred(ctx)));
}

<span class="enscript-comment">/*
 * Given a context, for all fields of vfs_context_t which
 * are not held with a reference, set those fields to the
 * values for the current execution context.  Currently, this 
 * just means the vc_thread.
 *
 * Returns: 0 for success, nonzero for failure
 *
 * The intended use is:
 * 1. vfs_context_create()	gets the caller a context
 * 2. vfs_context_bind() 	sets the unrefcounted data
 * 3. vfs_context_rele() 	releases the context
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_context_bind</span>(vfs_context_t ctx)
{
	ctx-&gt;vc_thread = current_thread();
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/* XXXXXXXXXXXXXX VNODE KAPIS XXXXXXXXXXXXXXXXXXXXXXXXX */</span>

 
<span class="enscript-comment">/*
 * Convert between vnode types and inode formats (since POSIX.1
 * defines mode word of stat structure in terms of inode formats).
 */</span>
<span class="enscript-type">enum</span> vtype 
<span class="enscript-function-name">vnode_iftovt</span>(<span class="enscript-type">int</span> mode)
{
	<span class="enscript-keyword">return</span>(iftovt_tab[((mode) &amp; S_IFMT) &gt;&gt; 12]);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_vttoif</span>(<span class="enscript-type">enum</span> vtype indx)
{
	<span class="enscript-keyword">return</span>(vttoif_tab[(<span class="enscript-type">int</span>)(indx)]);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_makeimode</span>(<span class="enscript-type">int</span> indx, <span class="enscript-type">int</span> mode)
{
	<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)(VTTOIF(indx) | (mode));
}


<span class="enscript-comment">/*
 * vnode manipulation functions.
 */</span>

<span class="enscript-comment">/* returns system root vnode iocount; It should be released using vnode_put() */</span>
vnode_t  
<span class="enscript-function-name">vfs_rootvnode</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> error;

	error = vnode_get(rootvnode);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> ((vnode_t)0);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> rootvnode;
}	


uint32_t 
<span class="enscript-function-name">vnode_vid</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((uint32_t)(vp-&gt;v_id));
}	

mount_t 
<span class="enscript-function-name">vnode_mount</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> (vp-&gt;v_mount);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
vnode_t
<span class="enscript-function-name">vnode_mountdevvp</span>(vnode_t vp)
{
	<span class="enscript-keyword">if</span> (vp-&gt;v_mount)
		<span class="enscript-keyword">return</span> (vp-&gt;v_mount-&gt;mnt_devvp);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> ((vnode_t)0);
}
#<span class="enscript-reference">endif</span>

mount_t 
<span class="enscript-function-name">vnode_mountedhere</span>(vnode_t vp)
{
	mount_t mp;

	<span class="enscript-keyword">if</span> ((vp-&gt;v_type == VDIR) &amp;&amp; ((mp = vp-&gt;v_mountedhere) != NULL) &amp;&amp;
	    (mp-&gt;mnt_vnodecovered == vp))
		<span class="enscript-keyword">return</span> (mp);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (mount_t)NULL;
}

<span class="enscript-comment">/* returns vnode type of vnode_t */</span>
<span class="enscript-type">enum</span> vtype 
<span class="enscript-function-name">vnode_vtype</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> (vp-&gt;v_type);
}

<span class="enscript-comment">/* returns FS specific node saved in vnode */</span>
<span class="enscript-type">void</span> * 
<span class="enscript-function-name">vnode_fsnode</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> (vp-&gt;v_data);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">vnode_clearfsnode</span>(vnode_t vp)
{
	vp-&gt;v_data = NULL;
}

dev_t 
<span class="enscript-function-name">vnode_specrdev</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span>(vp-&gt;v_rdev);
}


<span class="enscript-comment">/* Accessor functions */</span>
<span class="enscript-comment">/* is vnode_t a root vnode */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isvroot</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VROOT)? 1 : 0);
}

<span class="enscript-comment">/* is vnode_t a system vnode */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_issystem</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VSYSTEM)? 1 : 0);
}

<span class="enscript-comment">/* is vnode_t a swap file vnode */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isswap</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VSWAP)? 1 : 0);
}

<span class="enscript-comment">/* is vnode_t a tty */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_istty</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VISTTY) ? 1 : 0);
}

<span class="enscript-comment">/* if vnode_t mount operation in progress */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_ismount</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VMOUNT)? 1 : 0);
}

<span class="enscript-comment">/* is this vnode under recyle now */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isrecycled</span>(vnode_t vp)
{
	<span class="enscript-type">int</span> ret;

	vnode_lock_spin(vp);
	ret =  (vp-&gt;v_lflag &amp; (VL_TERMINATE|VL_DEAD))? 1 : 0;
	vnode_unlock(vp);
	<span class="enscript-keyword">return</span>(ret);
}

<span class="enscript-comment">/* vnode was created by background task requesting rapid aging
   and has not since been referenced by a normal task */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_israge</span>(vnode_t vp)
{
        <span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VRAGE)? 1 : 0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_needssnapshots</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VNEEDSSNAPSHOT)? 1 : 0);
}


<span class="enscript-comment">/* Check the process/thread to see if we should skip atime updates */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_ctx_skipatime</span> (vfs_context_t ctx) {
	<span class="enscript-type">struct</span> uthread *ut;
	proc_t proc;
	thread_t thr;

	proc = vfs_context_proc(ctx);
	thr = vfs_context_thread (ctx);

	<span class="enscript-comment">/* Validate pointers in case we were invoked via a kernel context */</span>
	<span class="enscript-keyword">if</span> (thr &amp;&amp; proc) {
		ut = get_bsdthread_info (thr);

		<span class="enscript-keyword">if</span> (proc-&gt;p_lflag &amp; P_LRAGE_VNODES) {
			<span class="enscript-keyword">return</span> 1;
		}
		
		<span class="enscript-keyword">if</span> (ut) {
			<span class="enscript-keyword">if</span>  (ut-&gt;uu_flag &amp; UT_RAGE_VNODES) {
				<span class="enscript-keyword">return</span> 1;
			}
		}
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/* is vnode_t marked to not keep data cached once it's been consumed */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isnocache</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VNOCACHE_DATA)? 1 : 0);
}

<span class="enscript-comment">/*
 * has sequential readahead been disabled on this vnode
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_isnoreadahead</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VRAOFF)? 1 : 0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_is_openevt</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VOPENEVT)? 1 : 0);
}

<span class="enscript-comment">/* is vnode_t a standard one? */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isstandard</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VSTANDARD)? 1 : 0);
}

<span class="enscript-comment">/* don't vflush() if SKIPSYSTEM */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isnoflush</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VNOFLUSH)? 1 : 0);
}

<span class="enscript-comment">/* is vnode_t a regular file */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isreg</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_type == VREG)? 1 : 0);
}

<span class="enscript-comment">/* is vnode_t a directory? */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isdir</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_type == VDIR)? 1 : 0);
}

<span class="enscript-comment">/* is vnode_t a symbolic link ? */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_islnk</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_type == VLNK)? 1 : 0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_lookup_continue_needed</span>(vnode_t vp, <span class="enscript-type">struct</span> componentname *cnp)
{
	<span class="enscript-type">struct</span> nameidata *ndp = cnp-&gt;cn_ndp;

	<span class="enscript-keyword">if</span> (ndp == NULL) {
		panic(<span class="enscript-string">&quot;vnode_lookup_continue_needed(): cnp-&gt;cn_ndp is NULL\n&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
		<span class="enscript-keyword">if</span> (vp-&gt;v_mountedhere != NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">yes</span>;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
		<span class="enscript-keyword">if</span> (vp-&gt;v_resolve) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">yes</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_TRIGGERS */</span>

	}


	<span class="enscript-keyword">if</span> (vnode_islnk(vp)) {
		<span class="enscript-comment">/* From lookup():  || *ndp-&gt;ni_next == '/') No need for this, we know we're NULL-terminated here */</span>
		<span class="enscript-keyword">if</span> (cnp-&gt;cn_flags &amp; FOLLOW) { 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">yes</span>;
		}
		<span class="enscript-keyword">if</span> (ndp-&gt;ni_flag &amp; NAMEI_TRAILINGSLASH) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">yes</span>;
		}
	}

	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">yes</span>:
	ndp-&gt;ni_flag |= NAMEI_CONTLOOKUP;
	<span class="enscript-keyword">return</span> EKEEPLOOKING;
}

<span class="enscript-comment">/* is vnode_t a fifo ? */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isfifo</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_type == VFIFO)? 1 : 0);
}

<span class="enscript-comment">/* is vnode_t a block device? */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isblk</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_type == VBLK)? 1 : 0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_isspec</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> (((vp-&gt;v_type == VCHR) || (vp-&gt;v_type == VBLK)) ? 1 : 0);
}

<span class="enscript-comment">/* is vnode_t a char device? */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_ischr</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_type == VCHR)? 1 : 0);
}

<span class="enscript-comment">/* is vnode_t a socket? */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_issock</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_type == VSOCK)? 1 : 0);
}

<span class="enscript-comment">/* is vnode_t a device with multiple active vnodes referring to it? */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_isaliased</span>(vnode_t vp)
{	
	<span class="enscript-type">enum</span> vtype vt = vp-&gt;v_type;
	<span class="enscript-keyword">if</span> (!((vt == VCHR) || (vt == VBLK))) {
		<span class="enscript-keyword">return</span> 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (vp-&gt;v_specflags &amp; SI_ALIASED);
	}
}

<span class="enscript-comment">/* is vnode_t a named stream? */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_isnamedstream</span>(
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
		vnode_t vp
#<span class="enscript-reference">else</span>
		__unused vnode_t vp
#<span class="enscript-reference">endif</span>
		)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VISNAMEDSTREAM) ? 1 : 0);
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">return</span> (0);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">int</span> 	
<span class="enscript-function-name">vnode_isshadow</span>(
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
		vnode_t vp
#<span class="enscript-reference">else</span>
		__unused vnode_t vp
#<span class="enscript-reference">endif</span>
		)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VISSHADOW) ? 1 : 0);
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">return</span> (0);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/* does vnode have associated named stream vnodes ? */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_hasnamedstreams</span>(
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
		vnode_t vp
#<span class="enscript-reference">else</span>
		__unused vnode_t vp
#<span class="enscript-reference">endif</span>
		)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-keyword">return</span> ((vp-&gt;v_lflag &amp; VL_HASSTREAMS) ? 1 : 0);
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">return</span> (0);
#<span class="enscript-reference">endif</span>
}
<span class="enscript-comment">/* TBD:  set vnode_t to not cache data after it is consumed once; used for quota */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">vnode_setnocache</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag |= VNOCACHE_DATA;
	vnode_unlock(vp);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">vnode_clearnocache</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag &amp;= ~VNOCACHE_DATA;
	vnode_unlock(vp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_set_openevt</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag |= VOPENEVT;
	vnode_unlock(vp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_clear_openevt</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag &amp;= ~VOPENEVT;
	vnode_unlock(vp);
}


<span class="enscript-type">void</span> 
<span class="enscript-function-name">vnode_setnoreadahead</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag |= VRAOFF;
	vnode_unlock(vp);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">vnode_clearnoreadahead</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag &amp;= ~VRAOFF;
	vnode_unlock(vp);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_isfastdevicecandidate</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VFASTDEVCANDIDATE)? 1 : 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_setfastdevicecandidate</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag |= VFASTDEVCANDIDATE;
	vnode_unlock(vp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_clearfastdevicecandidate</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag &amp;= ~VFASTDEVCANDIDATE;
	vnode_unlock(vp);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_isautocandidate</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VAUTOCANDIDATE)? 1 : 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_setautocandidate</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag |= VAUTOCANDIDATE;
	vnode_unlock(vp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_clearautocandidate</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag &amp;= ~VAUTOCANDIDATE;
	vnode_unlock(vp);
}




<span class="enscript-comment">/* mark vnode_t to skip vflush() is SKIPSYSTEM */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">vnode_setnoflush</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag |= VNOFLUSH;
	vnode_unlock(vp);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">vnode_clearnoflush</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_flag &amp;= ~VNOFLUSH;
	vnode_unlock(vp);
}


<span class="enscript-comment">/* is vnode_t a blkdevice and has a FS mounted on it */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_ismountedon</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_specflags &amp; SI_MOUNTEDON)? 1 : 0);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">vnode_setmountedon</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_specflags |= SI_MOUNTEDON;
	vnode_unlock(vp);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">vnode_clearmountedon</span>(vnode_t vp)
{
	vnode_lock_spin(vp);
	vp-&gt;v_specflags &amp;= ~SI_MOUNTEDON;
	vnode_unlock(vp);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_settag</span>(vnode_t vp, <span class="enscript-type">int</span> tag)
{
	vp-&gt;v_tag = tag;

}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_tag</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span>(vp-&gt;v_tag);
}

vnode_t 
<span class="enscript-function-name">vnode_parent</span>(vnode_t vp)
{

	<span class="enscript-keyword">return</span>(vp-&gt;v_parent);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_setparent</span>(vnode_t vp, vnode_t dvp)
{
	vp-&gt;v_parent = dvp;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_setname</span>(vnode_t vp, <span class="enscript-type">char</span> * name)
{
	vp-&gt;v_name = name;
}

<span class="enscript-comment">/* return the registered  FS name when adding the FS to kernel */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">vnode_vfsname</span>(vnode_t vp, <span class="enscript-type">char</span> * buf)
{
        strlcpy(buf, vp-&gt;v_mount-&gt;mnt_vtable-&gt;vfc_name, MFSNAMELEN);
}

<span class="enscript-comment">/* return the FS type number */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_vfstypenum</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span>(vp-&gt;v_mount-&gt;mnt_vtable-&gt;vfc_typenum);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_vfs64bitready</span>(vnode_t vp) 
{

	<span class="enscript-comment">/* 
	 * Checking for dead_mountp is a bit of a hack for SnowLeopard: &lt;rdar://problem/6269051&gt;
	 */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_mount != dead_mountp) &amp;&amp; (vp-&gt;v_mount-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFS64BITREADY))
		<span class="enscript-keyword">return</span>(1);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>(0);
}



<span class="enscript-comment">/* return the visible flags on associated mount point of vnode_t */</span>
uint32_t 
<span class="enscript-function-name">vnode_vfsvisflags</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span>(vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_VISFLAGMASK);
}

<span class="enscript-comment">/* return the command modifier flags on associated mount point of vnode_t */</span>
uint32_t 
<span class="enscript-function-name">vnode_vfscmdflags</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span>(vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_CMDFLAGS);
}

<span class="enscript-comment">/* return the max symlink of short links  of vnode_t */</span>
uint32_t 
<span class="enscript-function-name">vnode_vfsmaxsymlen</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span>(vp-&gt;v_mount-&gt;mnt_maxsymlinklen);
}

<span class="enscript-comment">/* return a pointer to the RO vfs_statfs associated with vnode_t's mount point */</span>
<span class="enscript-type">struct</span> vfsstatfs *
<span class="enscript-function-name">vnode_vfsstatfs</span>(vnode_t vp)
{
        <span class="enscript-keyword">return</span>(&amp;vp-&gt;v_mount-&gt;mnt_vfsstat);
}

<span class="enscript-comment">/* return a handle to the FSs specific private handle associated with vnode_t's mount point */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">vnode_vfsfsprivate</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span>(vp-&gt;v_mount-&gt;mnt_data);
}

<span class="enscript-comment">/* is vnode_t in a rdonly mounted  FS */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vnode_vfsisrdonly</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_RDONLY)? 1 : 0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_compound_rename_available</span>(vnode_t vp) 
{
	<span class="enscript-keyword">return</span> vnode_compound_op_available(vp, COMPOUND_VNOP_RENAME);
}
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_compound_rmdir_available</span>(vnode_t vp) 
{
	<span class="enscript-keyword">return</span> vnode_compound_op_available(vp, COMPOUND_VNOP_RMDIR);
}
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_compound_mkdir_available</span>(vnode_t vp) 
{
	<span class="enscript-keyword">return</span> vnode_compound_op_available(vp, COMPOUND_VNOP_MKDIR);
}
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_compound_remove_available</span>(vnode_t vp) 
{
	<span class="enscript-keyword">return</span> vnode_compound_op_available(vp, COMPOUND_VNOP_REMOVE);
}
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_compound_open_available</span>(vnode_t vp) 
{
	<span class="enscript-keyword">return</span> vnode_compound_op_available(vp, COMPOUND_VNOP_OPEN);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_compound_op_available</span>(vnode_t vp, compound_vnop_id_t opid) 
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_mount-&gt;mnt_compound_ops &amp; opid) != 0);
}

<span class="enscript-comment">/*
 * Returns vnode ref to current working directory; if a per-thread current
 * working directory is in effect, return that instead of the per process one.
 *
 * XXX Published, but not used.
 */</span>
vnode_t 
<span class="enscript-function-name">current_workingdir</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> vfs_context_cwd(vfs_context_current());
}

<span class="enscript-comment">/* returns vnode ref to current root(chroot) directory */</span>
vnode_t 
<span class="enscript-function-name">current_rootdir</span>(<span class="enscript-type">void</span>)
{
	proc_t proc = current_proc();
	<span class="enscript-type">struct</span> vnode * vp ;

	<span class="enscript-keyword">if</span> ( (vp = proc-&gt;p_fd-&gt;fd_rdir) ) {
	        <span class="enscript-keyword">if</span> ( (vnode_getwithref(vp)) )
		        <span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-keyword">return</span> vp;
}

<span class="enscript-comment">/*
 * Get a filesec and optional acl contents from an extended attribute.
 * Function will attempt to retrive ACL, UUID, and GUID information using a
 * read of a named extended attribute (KAUTH_FILESEC_XATTR).
 *
 * Parameters:	vp			The vnode on which to operate.
 *		fsecp			The filesec (and ACL, if any) being
 *					retrieved.
 *		ctx			The vnode context in which the
 *					operation is to be attempted.
 *
 * Returns:	0			Success
 *		!0			errno value
 *
 * Notes:	The kauth_filesec_t in '*fsecp', if retrieved, will be in
 *		host byte order, as will be the ACL contents, if any.
 *		Internally, we will cannonize these values from network (PPC)
 *		byte order after we retrieve them so that the on-disk contents
 *		of the extended attribute are identical for both PPC and Intel
 *		(if we were not being required to provide this service via
 *		fallback, this would be the job of the filesystem
 *		'VNOP_GETATTR' call).
 *
 *		We use ntohl() because it has a transitive property on Intel
 *		machines and no effect on PPC mancines.  This guarantees us
 *
 * XXX:		Deleting rather than ignoreing a corrupt security structure is
 *		probably the only way to reset it without assistance from an
 *		file system integrity checking tool.  Right now we ignore it.
 *
 * XXX:		We should enummerate the possible errno values here, and where
 *		in the code they originated.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_get_filesec</span>(vnode_t vp, kauth_filesec_t *fsecp, vfs_context_t ctx)
{
	kauth_filesec_t fsec;
	uio_t	fsec_uio;
	size_t	fsec_size;
	size_t	xsize, rsize;
	<span class="enscript-type">int</span>	error;
	uint32_t	host_fsec_magic;
	uint32_t	host_acl_entrycount;

	fsec = NULL;
	fsec_uio = NULL;
	error = 0;
	
	<span class="enscript-comment">/* find out how big the EA is */</span>
	<span class="enscript-keyword">if</span> (vn_getxattr(vp, KAUTH_FILESEC_XATTR, NULL, &amp;xsize, XATTR_NOSECURITY, ctx) != 0) {
		<span class="enscript-comment">/* no EA, no filesec */</span>
		<span class="enscript-keyword">if</span> ((error == ENOATTR) || (error == ENOENT) || (error == EJUSTRETURN))
			error = 0;
		<span class="enscript-comment">/* either way, we are done */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * To be valid, a kauth_filesec_t must be large enough to hold a zero
	 * ACE entrly ACL, and if it's larger than that, it must have the right
	 * number of bytes such that it contains an atomic number of ACEs,
	 * rather than partial entries.  Otherwise, we ignore it.
	 */</span>
	<span class="enscript-keyword">if</span> (!KAUTH_FILESEC_VALID(xsize)) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;    ERROR - Bogus kauth_fiilesec_t: %ld bytes&quot;</span>, xsize);	
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
				
	<span class="enscript-comment">/* how many entries would fit? */</span>
	fsec_size = KAUTH_FILESEC_COUNT(xsize);

	<span class="enscript-comment">/* get buffer and uio */</span>
	<span class="enscript-keyword">if</span> (((fsec = kauth_filesec_alloc(fsec_size)) == NULL) ||
	    ((fsec_uio = uio_create(1, 0, UIO_SYSSPACE, UIO_READ)) == NULL) ||
	    uio_addiov(fsec_uio, CAST_USER_ADDR_T(fsec), xsize)) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;    ERROR - could not allocate iov to read ACL&quot;</span>);	
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* read security attribute */</span>
	rsize = xsize;
	<span class="enscript-keyword">if</span> ((error = vn_getxattr(vp,
		 KAUTH_FILESEC_XATTR,
		 fsec_uio,
		 &amp;rsize,
		 XATTR_NOSECURITY,
		 ctx)) != 0) {

		<span class="enscript-comment">/* no attribute - no security data */</span>
		<span class="enscript-keyword">if</span> ((error == ENOATTR) || (error == ENOENT) || (error == EJUSTRETURN))
			error = 0;
		<span class="enscript-comment">/* either way, we are done */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Validate security structure; the validation must take place in host
	 * byte order.  If it's corrupt, we will just ignore it.
	 */</span>

	<span class="enscript-comment">/* Validate the size before trying to convert it */</span>
	<span class="enscript-keyword">if</span> (rsize &lt; KAUTH_FILESEC_SIZE(0)) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;ACL - DATA TOO SMALL (%d)&quot;</span>, rsize);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Validate the magic number before trying to convert it */</span>
	host_fsec_magic = ntohl(KAUTH_FILESEC_MAGIC);
	<span class="enscript-keyword">if</span> (fsec-&gt;fsec_magic != host_fsec_magic) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;ACL - BAD MAGIC %x&quot;</span>, host_fsec_magic);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Validate the entry count before trying to convert it. */</span>
	host_acl_entrycount = ntohl(fsec-&gt;fsec_acl.acl_entrycount);
	<span class="enscript-keyword">if</span> (host_acl_entrycount != KAUTH_FILESEC_NOACL) {
		<span class="enscript-keyword">if</span> (host_acl_entrycount &gt; KAUTH_ACL_MAX_ENTRIES) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;ACL - BAD ENTRYCOUNT %x&quot;</span>, host_acl_entrycount);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	    	<span class="enscript-keyword">if</span> (KAUTH_FILESEC_SIZE(host_acl_entrycount) &gt; rsize) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;ACL - BUFFER OVERFLOW (%d entries too big for %d)&quot;</span>, host_acl_entrycount, rsize);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	kauth_filesec_acl_setendian(KAUTH_ENDIAN_HOST, fsec, NULL);

	*fsecp = fsec;
	fsec = NULL;
	error = 0;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (fsec != NULL)
		kauth_filesec_free(fsec);
	<span class="enscript-keyword">if</span> (fsec_uio != NULL)
		uio_free(fsec_uio);
	<span class="enscript-keyword">if</span> (error)
		*fsecp = NULL;
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Set a filesec and optional acl contents into an extended attribute.
 * function will attempt to store ACL, UUID, and GUID information using a
 * write to a named extended attribute (KAUTH_FILESEC_XATTR).  The 'acl'
 * may or may not point to the `fsec-&gt;fsec_acl`, depending on whether the
 * original caller supplied an acl.
 *
 * Parameters:	vp			The vnode on which to operate.
 *		fsec			The filesec being set.
 *		acl			The acl to be associated with 'fsec'.
 *		ctx			The vnode context in which the
 *					operation is to be attempted.
 *
 * Returns:	0			Success
 *		!0			errno value
 *
 * Notes:	Both the fsec and the acl are always valid.
 *
 *		The kauth_filesec_t in 'fsec', if any, is in host byte order,
 *		as are the acl contents, if they are used.  Internally, we will
 *		cannonize these values into network (PPC) byte order before we
 *		attempt to write them so that the on-disk contents of the
 *		extended attribute are identical for both PPC and Intel (if we
 *		were not being required to provide this service via fallback,
 *		this would be the job of the filesystem 'VNOP_SETATTR' call).
 *		We reverse this process on the way out, so we leave with the
 *		same byte order we started with.
 *
 * XXX:		We should enummerate the possible errno values here, and where
 *		in the code they originated.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_set_filesec</span>(vnode_t vp, kauth_filesec_t fsec, kauth_acl_t acl, vfs_context_t ctx)
{
	uio_t		fsec_uio;
	<span class="enscript-type">int</span>		error;
	uint32_t	saved_acl_copysize;

	fsec_uio = NULL;
	
	<span class="enscript-keyword">if</span> ((fsec_uio = uio_create(2, 0, UIO_SYSSPACE, UIO_WRITE)) == NULL) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;    ERROR - could not allocate iov to write ACL&quot;</span>);	
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * Save the pre-converted ACL copysize, because it gets swapped too
	 * if we are running with the wrong endianness.
	 */</span>
	saved_acl_copysize = KAUTH_ACL_COPYSIZE(acl);

	kauth_filesec_acl_setendian(KAUTH_ENDIAN_DISK, fsec, acl);

	uio_addiov(fsec_uio, CAST_USER_ADDR_T(fsec), KAUTH_FILESEC_SIZE(0) - KAUTH_ACL_SIZE(KAUTH_FILESEC_NOACL));
	uio_addiov(fsec_uio, CAST_USER_ADDR_T(acl), saved_acl_copysize);
	error = vn_setxattr(vp,
	    KAUTH_FILESEC_XATTR,
	    fsec_uio,
	    XATTR_NOSECURITY, 		<span class="enscript-comment">/* we have auth'ed already */</span>
	    ctx);
	VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;SETATTR - set ACL returning %d&quot;</span>, error);

	kauth_filesec_acl_setendian(KAUTH_ENDIAN_HOST, fsec, acl);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (fsec_uio != NULL)
		uio_free(fsec_uio);
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * Returns:	0			Success
 *		ENOMEM			Not enough space [only if has filesec]
 *		VNOP_GETATTR:		???
 *		vnode_get_filesec:	???
 *		kauth_cred_guid2uid:	???
 *		kauth_cred_guid2gid:	???
 *		vfs_update_vfsstat:	???
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_getattr</span>(vnode_t vp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
	kauth_filesec_t fsec;
	kauth_acl_t facl;
	<span class="enscript-type">int</span>	error;
	uid_t	nuid;
	gid_t	ngid;

	<span class="enscript-comment">/* don't ask for extended security data if the filesystem doesn't support it */</span>
	<span class="enscript-keyword">if</span> (!vfs_extendedsecurity(vnode_mount(vp))) {
		VATTR_CLEAR_ACTIVE(vap, va_acl);
		VATTR_CLEAR_ACTIVE(vap, va_uuuid);
		VATTR_CLEAR_ACTIVE(vap, va_guuid);
	}

	<span class="enscript-comment">/*
	 * If the caller wants size values we might have to synthesise, give the
	 * filesystem the opportunity to supply better intermediate results.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_alloc) ||
	    VATTR_IS_ACTIVE(vap, va_total_size) ||
	    VATTR_IS_ACTIVE(vap, va_total_alloc)) {
		VATTR_SET_ACTIVE(vap, va_data_size);
		VATTR_SET_ACTIVE(vap, va_data_alloc);
		VATTR_SET_ACTIVE(vap, va_total_size);
		VATTR_SET_ACTIVE(vap, va_total_alloc);
	}
	
	error = VNOP_GETATTR(vp, vap, ctx);
	<span class="enscript-keyword">if</span> (error) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;ERROR - returning %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * If extended security data was requested but not returned, try the fallback
	 * path.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_NOT_RETURNED(vap, va_acl) || VATTR_NOT_RETURNED(vap, va_uuuid) || VATTR_NOT_RETURNED(vap, va_guuid)) {
		fsec = NULL;

		<span class="enscript-keyword">if</span> (XATTR_VNODE_SUPPORTED(vp)) {
			<span class="enscript-comment">/* try to get the filesec */</span>
			<span class="enscript-keyword">if</span> ((error = vnode_get_filesec(vp, &amp;fsec, ctx)) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* if no filesec, no attributes */</span>
		<span class="enscript-keyword">if</span> (fsec == NULL) {
			VATTR_RETURN(vap, va_acl, NULL);
			VATTR_RETURN(vap, va_uuuid, kauth_null_guid);
			VATTR_RETURN(vap, va_guuid, kauth_null_guid);
		} <span class="enscript-keyword">else</span> {

			<span class="enscript-comment">/* looks good, try to return what we were asked for */</span>
			VATTR_RETURN(vap, va_uuuid, fsec-&gt;fsec_owner);
			VATTR_RETURN(vap, va_guuid, fsec-&gt;fsec_group);

			<span class="enscript-comment">/* only return the ACL if we were actually asked for it */</span>
			<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_acl)) {
				<span class="enscript-keyword">if</span> (fsec-&gt;fsec_acl.acl_entrycount == KAUTH_FILESEC_NOACL) {
					VATTR_RETURN(vap, va_acl, NULL);
				} <span class="enscript-keyword">else</span> {
					facl = kauth_acl_alloc(fsec-&gt;fsec_acl.acl_entrycount);
					<span class="enscript-keyword">if</span> (facl == NULL) {
						kauth_filesec_free(fsec);
						error = ENOMEM;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
					}
					bcopy(&amp;fsec-&gt;fsec_acl, facl, KAUTH_ACL_COPYSIZE(&amp;fsec-&gt;fsec_acl));
					VATTR_RETURN(vap, va_acl, facl);
				}
			}
			kauth_filesec_free(fsec);
		}
	}
	<span class="enscript-comment">/*
	 * If someone gave us an unsolicited filesec, toss it.  We promise that
	 * we're OK with a filesystem giving us anything back, but our callers
	 * only expect what they asked for.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_acl) &amp;&amp; !VATTR_IS_ACTIVE(vap, va_acl)) {
		<span class="enscript-keyword">if</span> (vap-&gt;va_acl != NULL)
			kauth_acl_free(vap-&gt;va_acl);
		VATTR_CLEAR_SUPPORTED(vap, va_acl);
	}

#<span class="enscript-reference">if</span> 0	<span class="enscript-comment">/* enable when we have a filesystem only supporting UUIDs */</span>
	<span class="enscript-comment">/*
	 * Handle the case where we need a UID/GID, but only have extended
	 * security information.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_NOT_RETURNED(vap, va_uid) &amp;&amp;
	    VATTR_IS_SUPPORTED(vap, va_uuuid) &amp;&amp;
	    !kauth_guid_equal(&amp;vap-&gt;va_uuuid, &amp;kauth_null_guid)) {
		<span class="enscript-keyword">if</span> ((error = kauth_cred_guid2uid(&amp;vap-&gt;va_uuuid, &amp;nuid)) == 0)
			VATTR_RETURN(vap, va_uid, nuid);
	}
	<span class="enscript-keyword">if</span> (VATTR_NOT_RETURNED(vap, va_gid) &amp;&amp;
	    VATTR_IS_SUPPORTED(vap, va_guuid) &amp;&amp;
	    !kauth_guid_equal(&amp;vap-&gt;va_guuid, &amp;kauth_null_guid)) {
		<span class="enscript-keyword">if</span> ((error = kauth_cred_guid2gid(&amp;vap-&gt;va_guuid, &amp;ngid)) == 0)
			VATTR_RETURN(vap, va_gid, ngid);
	}
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-comment">/*
	 * Handle uid/gid == 99 and MNT_IGNORE_OWNERSHIP here.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uid)) {
		<span class="enscript-keyword">if</span> (vfs_context_issuser(ctx) &amp;&amp; VATTR_IS_SUPPORTED(vap, va_uid)) {
			nuid = vap-&gt;va_uid;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_IGNORE_OWNERSHIP) {
			nuid = vp-&gt;v_mount-&gt;mnt_fsowner;
			<span class="enscript-keyword">if</span> (nuid == KAUTH_UID_NONE)
				nuid = 99;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_uid)) {
			nuid = vap-&gt;va_uid;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* this will always be something sensible */</span>
			nuid = vp-&gt;v_mount-&gt;mnt_fsowner;
		}
		<span class="enscript-keyword">if</span> ((nuid == 99) &amp;&amp; !vfs_context_issuser(ctx))
			nuid = kauth_cred_getuid(vfs_context_ucred(ctx));
		VATTR_RETURN(vap, va_uid, nuid);
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_gid)) {
		<span class="enscript-keyword">if</span> (vfs_context_issuser(ctx) &amp;&amp; VATTR_IS_SUPPORTED(vap, va_gid)) {
			ngid = vap-&gt;va_gid;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_IGNORE_OWNERSHIP) {
			ngid = vp-&gt;v_mount-&gt;mnt_fsgroup;
			<span class="enscript-keyword">if</span> (ngid == KAUTH_GID_NONE)
				ngid = 99;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_SUPPORTED(vap, va_gid)) {
			ngid = vap-&gt;va_gid;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* this will always be something sensible */</span>
			ngid = vp-&gt;v_mount-&gt;mnt_fsgroup;
		}
		<span class="enscript-keyword">if</span> ((ngid == 99) &amp;&amp; !vfs_context_issuser(ctx))
			ngid = kauth_cred_getgid(vfs_context_ucred(ctx));
		VATTR_RETURN(vap, va_gid, ngid);
	}

	<span class="enscript-comment">/*
	 * Synthesise some values that can be reasonably guessed.
	 */</span>
	<span class="enscript-keyword">if</span> (!VATTR_IS_SUPPORTED(vap, va_iosize))
		VATTR_RETURN(vap, va_iosize, vp-&gt;v_mount-&gt;mnt_vfsstat.f_iosize);
	
	<span class="enscript-keyword">if</span> (!VATTR_IS_SUPPORTED(vap, va_flags))
		VATTR_RETURN(vap, va_flags, 0);

	<span class="enscript-keyword">if</span> (!VATTR_IS_SUPPORTED(vap, va_filerev))
		VATTR_RETURN(vap, va_filerev, 0);

	<span class="enscript-keyword">if</span> (!VATTR_IS_SUPPORTED(vap, va_gen))
		VATTR_RETURN(vap, va_gen, 0);

	<span class="enscript-comment">/*
	 * Default sizes.  Ordering here is important, as later defaults build on earlier ones.
	 */</span>
	<span class="enscript-keyword">if</span> (!VATTR_IS_SUPPORTED(vap, va_data_size))
		VATTR_RETURN(vap, va_data_size, 0);

	<span class="enscript-comment">/* do we want any of the possibly-computed values? */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_alloc) ||
	    VATTR_IS_ACTIVE(vap, va_total_size) ||
	    VATTR_IS_ACTIVE(vap, va_total_alloc)) {
                <span class="enscript-comment">/* make sure f_bsize is valid */</span>
                <span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_vfsstat.f_bsize == 0) {
                    <span class="enscript-keyword">if</span> ((error = vfs_update_vfsstat(vp-&gt;v_mount, ctx, VFS_KERNEL_EVENT)) != 0)
                        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
                }

		<span class="enscript-comment">/* default va_data_alloc from va_data_size */</span>
		<span class="enscript-keyword">if</span> (!VATTR_IS_SUPPORTED(vap, va_data_alloc))
			VATTR_RETURN(vap, va_data_alloc, roundup(vap-&gt;va_data_size, vp-&gt;v_mount-&gt;mnt_vfsstat.f_bsize));

		<span class="enscript-comment">/* default va_total_size from va_data_size */</span>
		<span class="enscript-keyword">if</span> (!VATTR_IS_SUPPORTED(vap, va_total_size))
			VATTR_RETURN(vap, va_total_size, vap-&gt;va_data_size);

		<span class="enscript-comment">/* default va_total_alloc from va_total_size which is guaranteed at this point */</span>
		<span class="enscript-keyword">if</span> (!VATTR_IS_SUPPORTED(vap, va_total_alloc))
			VATTR_RETURN(vap, va_total_alloc, roundup(vap-&gt;va_total_size, vp-&gt;v_mount-&gt;mnt_vfsstat.f_bsize));
	}

	<span class="enscript-comment">/*
	 * If we don't have a change time, pull it from the modtime.
	 */</span>
	<span class="enscript-keyword">if</span> (!VATTR_IS_SUPPORTED(vap, va_change_time) &amp;&amp; VATTR_IS_SUPPORTED(vap, va_modify_time))
		VATTR_RETURN(vap, va_change_time, vap-&gt;va_modify_time);

	<span class="enscript-comment">/*
	 * This is really only supported for the creation VNOPs, but since the field is there
	 * we should populate it correctly.
	 */</span>
	VATTR_RETURN(vap, va_type, vp-&gt;v_type);

	<span class="enscript-comment">/*
	 * The fsid can be obtained from the mountpoint directly.
	 */</span>
	VATTR_RETURN(vap, va_fsid, vp-&gt;v_mount-&gt;mnt_vfsstat.f_fsid.val[0]);

<span class="enscript-reference">out</span>:

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Set the attributes on a vnode in a vnode context.
 *
 * Parameters:	vp			The vnode whose attributes to set.
 *		vap			A pointer to the attributes to set.
 *		ctx			The vnode context in which the
 *					operation is to be attempted.
 *
 * Returns:	0			Success
 *		!0			errno value
 *
 * Notes:	The kauth_filesec_t in 'vap', if any, is in host byte order.
 *
 *		The contents of the data area pointed to by 'vap' may be
 *		modified if the vnode is on a filesystem which has been
 *		mounted with ingore ownership flags, or by the underlyng
 *		VFS itself, or by the fallback code, if the underlying VFS
 *		does not support ACL, UUID, or GUUID attributes directly.
 *
 * XXX:		We should enummerate the possible errno values here, and where
 *		in the code they originated.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_setattr</span>(vnode_t vp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
	<span class="enscript-type">int</span>	error, is_perm_change=0;

	<span class="enscript-comment">/*
	 * Make sure the filesystem is mounted R/W.
	 * If not, return an error.
	 */</span>
	<span class="enscript-keyword">if</span> (vfs_isrdonly(vp-&gt;v_mount)) {
		error = EROFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-comment">/* For streams, va_data_size is the only setable attribute. */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VISNAMEDSTREAM) &amp;&amp; (vap-&gt;va_active != VNODE_ATTR_va_data_size)) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-comment">/*
	 * If ownership is being ignored on this volume, we silently discard
	 * ownership changes.
	 */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_IGNORE_OWNERSHIP) {
		VATTR_CLEAR_ACTIVE(vap, va_uid);
		VATTR_CLEAR_ACTIVE(vap, va_gid);
	}

	<span class="enscript-keyword">if</span> (   VATTR_IS_ACTIVE(vap, va_uid)  || VATTR_IS_ACTIVE(vap, va_gid)
	    || VATTR_IS_ACTIVE(vap, va_mode) || VATTR_IS_ACTIVE(vap, va_acl)) {
	    is_perm_change = 1;
	}
	
	<span class="enscript-comment">/*
	 * Make sure that extended security is enabled if we're going to try
	 * to set any.
	 */</span>
	<span class="enscript-keyword">if</span> (!vfs_extendedsecurity(vnode_mount(vp)) &amp;&amp;
	    (VATTR_IS_ACTIVE(vap, va_acl) || VATTR_IS_ACTIVE(vap, va_uuuid) || VATTR_IS_ACTIVE(vap, va_guuid))) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;SETATTR - returning ENOTSUP to request to set extended security&quot;</span>);
		error = ENOTSUP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Never allow the setting of any unsupported superuser flags. */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_flags)) {
	    vap-&gt;va_flags &amp;= (SF_SUPPORTED | UF_SETTABLE);
	}

	error = VNOP_SETATTR(vp, vap, ctx);

	<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; !VATTR_ALL_SUPPORTED(vap))
		error = vnode_setattr_fallback(vp, vap, ctx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-comment">// only send a stat_changed event if this is more than
</span>	<span class="enscript-comment">// just an access or backup time update
</span>	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; (vap-&gt;va_active != VNODE_ATTR_BIT(va_access_time)) &amp;&amp; (vap-&gt;va_active != VNODE_ATTR_BIT(va_backup_time))) {
	    <span class="enscript-keyword">if</span> (is_perm_change) {
		<span class="enscript-keyword">if</span> (need_fsevent(FSE_CHOWN, vp)) {
		    add_fsevent(FSE_CHOWN, ctx, FSE_ARG_VNODE, vp, FSE_ARG_DONE);
		}
	    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(need_fsevent(FSE_STAT_CHANGED, vp)) {
		add_fsevent(FSE_STAT_CHANGED, ctx, FSE_ARG_VNODE, vp, FSE_ARG_DONE);
	    }
	}
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Fallback for setting the attributes on a vnode in a vnode context.  This
 * Function will attempt to store ACL, UUID, and GUID information utilizing
 * a read/modify/write operation against an EA used as a backing store for
 * the object.
 *
 * Parameters:	vp			The vnode whose attributes to set.
 *		vap			A pointer to the attributes to set.
 *		ctx			The vnode context in which the
 *					operation is to be attempted.
 *
 * Returns:	0			Success
 *		!0			errno value
 *
 * Notes:	The kauth_filesec_t in 'vap', if any, is in host byte order,
 *		as are the fsec and lfsec, if they are used.
 *
 *		The contents of the data area pointed to by 'vap' may be
 *		modified to indicate that the attribute is supported for
 *		any given requested attribute.
 *
 * XXX:		We should enummerate the possible errno values here, and where
 *		in the code they originated.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_setattr_fallback</span>(vnode_t vp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
	kauth_filesec_t fsec;
	kauth_acl_t facl;
	<span class="enscript-type">struct</span> kauth_filesec lfsec;
	<span class="enscript-type">int</span>	error;

	error = 0;

	<span class="enscript-comment">/*
	 * Extended security fallback via extended attributes.
	 *
	 * Note that we do not free the filesec; the caller is expected to
	 * do this.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_NOT_RETURNED(vap, va_acl) ||
	    VATTR_NOT_RETURNED(vap, va_uuuid) ||
	    VATTR_NOT_RETURNED(vap, va_guuid)) {
		VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;SETATTR - doing filesec fallback&quot;</span>);

		<span class="enscript-comment">/*
		 * Fail for file types that we don't permit extended security
		 * to be set on.
		 */</span>
		<span class="enscript-keyword">if</span> (!XATTR_VNODE_SUPPORTED(vp)) {
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;SETATTR - Can't write ACL to file type %d&quot;</span>, vnode_vtype(vp));
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/*
		 * If we don't have all the extended security items, we need
		 * to fetch the existing data to perform a read-modify-write
		 * operation.
		 */</span>
		fsec = NULL;
		<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_acl) ||
		    !VATTR_IS_ACTIVE(vap, va_uuuid) ||
		    !VATTR_IS_ACTIVE(vap, va_guuid)) {
			<span class="enscript-keyword">if</span> ((error = vnode_get_filesec(vp, &amp;fsec, ctx)) != 0) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;SETATTR - ERROR %d fetching filesec for update&quot;</span>, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
		<span class="enscript-comment">/* if we didn't get a filesec, use our local one */</span>
		<span class="enscript-keyword">if</span> (fsec == NULL) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;SETATTR - using local filesec for new/full update&quot;</span>);
			fsec = &amp;lfsec;
		} <span class="enscript-keyword">else</span> {
			KAUTH_DEBUG(<span class="enscript-string">&quot;SETATTR - updating existing filesec&quot;</span>);
		}
		<span class="enscript-comment">/* find the ACL */</span>
		facl = &amp;fsec-&gt;fsec_acl;
		
		<span class="enscript-comment">/* if we're using the local filesec, we need to initialise it */</span>
		<span class="enscript-keyword">if</span> (fsec == &amp;lfsec) {
			fsec-&gt;fsec_magic = KAUTH_FILESEC_MAGIC;
			fsec-&gt;fsec_owner = kauth_null_guid;
			fsec-&gt;fsec_group = kauth_null_guid;
			facl-&gt;acl_entrycount = KAUTH_FILESEC_NOACL;
			facl-&gt;acl_flags = 0;
		}

		<span class="enscript-comment">/*
		 * Update with the supplied attributes.
		 */</span>
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uuuid)) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;SETATTR - updating owner UUID&quot;</span>);
			fsec-&gt;fsec_owner = vap-&gt;va_uuuid;
			VATTR_SET_SUPPORTED(vap, va_uuuid);
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_guuid)) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;SETATTR - updating group UUID&quot;</span>);
			fsec-&gt;fsec_group = vap-&gt;va_guuid;
			VATTR_SET_SUPPORTED(vap, va_guuid);
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_acl)) {
			<span class="enscript-keyword">if</span> (vap-&gt;va_acl == NULL) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;SETATTR - removing ACL&quot;</span>);
				facl-&gt;acl_entrycount = KAUTH_FILESEC_NOACL;
			} <span class="enscript-keyword">else</span> {
				KAUTH_DEBUG(<span class="enscript-string">&quot;SETATTR - setting ACL with %d entries&quot;</span>, vap-&gt;va_acl-&gt;acl_entrycount);
				facl = vap-&gt;va_acl;
			}
			VATTR_SET_SUPPORTED(vap, va_acl);
		}
		
		<span class="enscript-comment">/*
		 * If the filesec data is all invalid, we can just remove
		 * the EA completely.
		 */</span>
		<span class="enscript-keyword">if</span> ((facl-&gt;acl_entrycount == KAUTH_FILESEC_NOACL) &amp;&amp;
		    kauth_guid_equal(&amp;fsec-&gt;fsec_owner, &amp;kauth_null_guid) &amp;&amp;
		    kauth_guid_equal(&amp;fsec-&gt;fsec_group, &amp;kauth_null_guid)) {
			error = vn_removexattr(vp, KAUTH_FILESEC_XATTR, XATTR_NOSECURITY, ctx);
			<span class="enscript-comment">/* no attribute is ok, nothing to delete */</span>
			<span class="enscript-keyword">if</span> (error == ENOATTR)
				error = 0;
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;SETATTR - remove filesec returning %d&quot;</span>, error);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* write the EA */</span>
			error = vnode_set_filesec(vp, fsec, facl, ctx);
			VFS_DEBUG(ctx, vp, <span class="enscript-string">&quot;SETATTR - update filesec returning %d&quot;</span>, error);
		}

		<span class="enscript-comment">/* if we fetched a filesec, dispose of the buffer */</span>
		<span class="enscript-keyword">if</span> (fsec != &amp;lfsec)
			kauth_filesec_free(fsec);
	}
<span class="enscript-reference">out</span>:

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Upcall for a filesystem to tell VFS about an EVFILT_VNODE-type
 * event on a vnode.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_notify</span>(vnode_t vp, uint32_t events, <span class="enscript-type">struct</span> vnode_attr *vap) 
{
	<span class="enscript-comment">/* These are the same as the corresponding knotes, at least for now.  Cheating a little. */</span>
	uint32_t knote_mask = (VNODE_EVENT_WRITE | VNODE_EVENT_DELETE | VNODE_EVENT_RENAME 
		| VNODE_EVENT_LINK | VNODE_EVENT_EXTEND | VNODE_EVENT_ATTRIB);
	uint32_t dir_contents_mask = (VNODE_EVENT_DIR_CREATED | VNODE_EVENT_FILE_CREATED 
			| VNODE_EVENT_DIR_REMOVED | VNODE_EVENT_FILE_REMOVED);
	uint32_t knote_events = (events &amp; knote_mask);

	<span class="enscript-comment">/* Permissions are not explicitly part of the kqueue model */</span>
	<span class="enscript-keyword">if</span> (events &amp; VNODE_EVENT_PERMS) {
		knote_events |= NOTE_ATTRIB;
	} 

	<span class="enscript-comment">/* Directory contents information just becomes NOTE_WRITE */</span>
	<span class="enscript-keyword">if</span> ((vnode_isdir(vp)) &amp;&amp; (events &amp; dir_contents_mask)) {
		knote_events |= NOTE_WRITE;
	}
	
	<span class="enscript-keyword">if</span> (knote_events) {
		lock_vnode_and_post(vp, knote_events);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
		<span class="enscript-keyword">if</span> (vap != NULL) {
			create_fsevent_from_kevent(vp, events, vap);
		}
#<span class="enscript-reference">else</span>
		(<span class="enscript-type">void</span>)vap;
#<span class="enscript-reference">endif</span>
	} 

	<span class="enscript-keyword">return</span> 0;
}



<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_isdyldsharedcache</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_flag &amp; VSHARED_DYLD) ? 1 : 0);
}


<span class="enscript-comment">/*
 * For a filesystem that isn't tracking its own vnode watchers:
 * check whether a vnode is being monitored.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vnode_ismonitored</span>(vnode_t vp) {
	<span class="enscript-keyword">return</span> (vp-&gt;v_knotes.slh_first != NULL);
}

<span class="enscript-comment">/*
 * Initialize a struct vnode_attr and activate the attributes required
 * by the vnode_notify() call.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vfs_get_notify_attributes</span>(<span class="enscript-type">struct</span> vnode_attr *vap) 
{
	VATTR_INIT(vap); 
	vap-&gt;va_active = VNODE_NOTIFY_ATTRS;
	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">vfs_settriggercallback</span>(fsid_t *fsid, vfs_trigger_callback_t vtc, <span class="enscript-type">void</span> *data, uint32_t flags __unused, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;
	mount_t mp;

	mp = mount_list_lookupby_fsid(fsid, 0 <span class="enscript-comment">/* locked */</span>, 1 <span class="enscript-comment">/* withref */</span>);
	<span class="enscript-keyword">if</span> (mp == NULL) {
		<span class="enscript-keyword">return</span> ENOENT;
	}

	error = vfs_busy(mp, LK_NOWAIT);
	mount_iterdrop(mp);

	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">return</span> ENOENT;
	}

	mount_lock(mp);
	<span class="enscript-keyword">if</span> (mp-&gt;mnt_triggercallback != NULL) {
		error = EBUSY;
		mount_unlock(mp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	mp-&gt;mnt_triggercallback = vtc;
	mp-&gt;mnt_triggerdata = data;
	mount_unlock(mp);

	mp-&gt;mnt_triggercallback(mp, VTC_REPLACE, data, ctx);

<span class="enscript-reference">out</span>:
	vfs_unbusy(mp);
	<span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_TRIGGERS */</span>

<span class="enscript-comment">/*
 *  Definition of vnode operations.
 */</span>

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *# 
 *#% lookup       dvp     L ? ?
 *#% lookup       vpp     - L -
 */</span>
<span class="enscript-type">struct</span> vnop_lookup_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	<span class="enscript-type">struct</span> componentname *a_cnp;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>

<span class="enscript-comment">/*
 * Returns:	0			Success
 *	lock_fsnode:ENOENT		No such file or directory [only for VFS
 *					 that is not thread safe &amp; vnode is
 *					 currently being/has been terminated]
 *	&lt;vfs_lookup&gt;:ENAMETOOLONG
 *	&lt;vfs_lookup&gt;:ENOENT
 *	&lt;vfs_lookup&gt;:EJUSTRETURN
 *	&lt;vfs_lookup&gt;:EPERM
 *	&lt;vfs_lookup&gt;:EISDIR
 *	&lt;vfs_lookup&gt;:ENOTDIR
 *	&lt;vfs_lookup&gt;:???
 *
 * Note:	The return codes from the underlying VFS's lookup routine can't
 *		be fully enumerated here, since third party VFS authors may not
 *		limit their error returns to the ones documented here, even
 *		though this may result in some programs functioning incorrectly.
 *
 *		The return codes documented above are those which may currently
 *		be returned by HFS from hfs_lookup, not including additional
 *		error code which may be propagated from underlying routines.
 */</span>
errno_t 
<span class="enscript-function-name">VNOP_LOOKUP</span>(vnode_t dvp, vnode_t *vpp, <span class="enscript-type">struct</span> componentname *cnp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_lookup_args a;

	a.a_desc = &amp;vnop_lookup_desc;
	a.a_dvp = dvp;
	a.a_vpp = vpp;
	a.a_cnp = cnp;
	a.a_context = ctx;

	_err = (*dvp-&gt;v_op[vnop_lookup_desc.vdesc_offset])(&amp;a);
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; *vpp) {
		DTRACE_FSINFO(lookup, vnode_t, *vpp);
	}

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">struct</span> vnop_compound_open_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	<span class="enscript-type">struct</span> componentname *a_cnp;
	int32_t a_flags;
	int32_t a_fmode;
	<span class="enscript-type">struct</span> vnode_attr *a_vap;
	vfs_context_t a_context;
	<span class="enscript-type">void</span> *a_reserved;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">VNOP_COMPOUND_OPEN</span>(vnode_t dvp, vnode_t *vpp, <span class="enscript-type">struct</span> nameidata *ndp, int32_t flags, int32_t fmode, uint32_t *statusp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_compound_open_args a;
	<span class="enscript-type">int</span> did_create = 0;
	<span class="enscript-type">int</span> want_create;
	uint32_t tmp_status = 0;
	<span class="enscript-type">struct</span> componentname *cnp = &amp;ndp-&gt;ni_cnd;

	want_create = (flags &amp; O_CREAT);

	a.a_desc = &amp;vnop_compound_open_desc;
	a.a_dvp = dvp;
	a.a_vpp = vpp; <span class="enscript-comment">/* Could be NULL */</span>
	a.a_cnp = cnp;
	a.a_flags = flags;
	a.a_fmode = fmode;
	a.a_status = (statusp != NULL) ? statusp : &amp;tmp_status;
	a.a_vap = vap;
	a.a_context = ctx;
	a.a_open_create_authorizer = vn_authorize_create;
	a.a_open_existing_authorizer = vn_authorize_open_existing;
	a.a_reserved = NULL;

	<span class="enscript-keyword">if</span> (dvp == NULLVP) {
		panic(<span class="enscript-string">&quot;No dvp?&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (want_create &amp;&amp; !vap) {
		panic(<span class="enscript-string">&quot;Want create, but no vap?&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (!want_create &amp;&amp; vap) {
		panic(<span class="enscript-string">&quot;Don't want create, but have a vap?&quot;</span>);
	}

	_err = (*dvp-&gt;v_op[vnop_compound_open_desc.vdesc_offset])(&amp;a);
	<span class="enscript-keyword">if</span> (want_create) {
	       	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; *vpp) {
			DTRACE_FSINFO(compound_open, vnode_t, *vpp);
		} <span class="enscript-keyword">else</span> {
			DTRACE_FSINFO(compound_open, vnode_t, dvp);
		}
	} <span class="enscript-keyword">else</span> {
		DTRACE_FSINFO(compound_open, vnode_t, *vpp);
	}

	did_create = (*a.a_status &amp; COMPOUND_OPEN_STATUS_DID_CREATE);

	<span class="enscript-keyword">if</span> (did_create &amp;&amp; !want_create) {
		panic(<span class="enscript-string">&quot;Filesystem did a create, even though none was requested?&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (did_create) { 
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
		<span class="enscript-keyword">if</span> (!NATIVE_XATTR(dvp)) {
			<span class="enscript-comment">/* 
			 * Remove stale Apple Double file (if any).
			 */</span>
			xattrfile_remove(dvp, cnp-&gt;cn_nameptr, ctx, 0);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>
		<span class="enscript-comment">/* On create, provide kqueue notification */</span>
		post_event_if_success(dvp, _err, NOTE_WRITE);
	}

	lookup_compound_vnop_post_hook(_err, dvp, *vpp, ndp, did_create);
#<span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* FSEvents... */</span>
	<span class="enscript-keyword">if</span> (*vpp &amp;&amp; _err &amp;&amp; _err != EKEEPLOOKING) {
		vnode_put(*vpp);
		*vpp = NULLVP;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0 */</span>

	<span class="enscript-keyword">return</span> (_err);

}

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">struct</span> vnop_create_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t *a_vpp;
	<span class="enscript-type">struct</span> componentname *a_cnp;
	<span class="enscript-type">struct</span> vnode_attr *a_vap;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_CREATE</span>(vnode_t dvp, vnode_t * vpp, <span class="enscript-type">struct</span> componentname * cnp, <span class="enscript-type">struct</span> vnode_attr * vap, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_create_args a;

	a.a_desc = &amp;vnop_create_desc;
	a.a_dvp = dvp;
	a.a_vpp = vpp;
	a.a_cnp = cnp;
	a.a_vap = vap;
	a.a_context = ctx;

	_err = (*dvp-&gt;v_op[vnop_create_desc.vdesc_offset])(&amp;a);
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; *vpp) {
		DTRACE_FSINFO(create, vnode_t, *vpp);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; !NATIVE_XATTR(dvp)) {
		<span class="enscript-comment">/* 
		 * Remove stale Apple Double file (if any).
		 */</span>
		xattrfile_remove(dvp, cnp-&gt;cn_nameptr, ctx, 0);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>

	post_event_if_success(dvp, _err, NOTE_WRITE);

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% whiteout     dvp     L L L
 *#% whiteout     cnp     - - -
 *#% whiteout     flag    - - -
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_whiteout_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_dvp;
	<span class="enscript-type">struct</span> componentname *a_cnp;
	<span class="enscript-type">int</span> a_flags;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_WHITEOUT</span>(__unused vnode_t dvp, __unused <span class="enscript-type">struct</span> componentname *cnp,
	__unused <span class="enscript-type">int</span> flags, __unused vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);	<span class="enscript-comment">// XXX OBSOLETE
</span>}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% mknod        dvp     L U U
 *#% mknod        vpp     - X -
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_mknod_args {
       <span class="enscript-type">struct</span> vnodeop_desc *a_desc;
       vnode_t a_dvp;
       vnode_t *a_vpp;
       <span class="enscript-type">struct</span> componentname *a_cnp;
       <span class="enscript-type">struct</span> vnode_attr *a_vap;
       vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t
<span class="enscript-function-name">VNOP_MKNOD</span>(vnode_t dvp, vnode_t * vpp, <span class="enscript-type">struct</span> componentname * cnp, <span class="enscript-type">struct</span> vnode_attr * vap, vfs_context_t ctx)
{

       <span class="enscript-type">int</span> _err;
       <span class="enscript-type">struct</span> vnop_mknod_args a;

       a.a_desc = &amp;vnop_mknod_desc;
       a.a_dvp = dvp;
       a.a_vpp = vpp;
       a.a_cnp = cnp;
       a.a_vap = vap;
       a.a_context = ctx;

       _err = (*dvp-&gt;v_op[vnop_mknod_desc.vdesc_offset])(&amp;a);
       <span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; *vpp) {
		DTRACE_FSINFO(mknod, vnode_t, *vpp);
       }

       post_event_if_success(dvp, _err, NOTE_WRITE);

       <span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% open         vp      L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_open_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">int</span> a_mode;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_OPEN</span>(vnode_t vp, <span class="enscript-type">int</span> mode, vfs_context_t ctx) 
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_open_args a;

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}    
	a.a_desc = &amp;vnop_open_desc;
	a.a_vp = vp;
	a.a_mode = mode;
	a.a_context = ctx; 

	_err = (*vp-&gt;v_op[vnop_open_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(open, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% close        vp      U U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_close_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">int</span> a_fflag;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_CLOSE</span>(vnode_t vp, <span class="enscript-type">int</span> fflag, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_close_args a;

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}
	a.a_desc = &amp;vnop_close_desc;
	a.a_vp = vp;
	a.a_fflag = fflag;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_close_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(close, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% access       vp      L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_access_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">int</span> a_action;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_ACCESS</span>(vnode_t vp, <span class="enscript-type">int</span> action, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_access_args a;

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}
	a.a_desc = &amp;vnop_access_desc;
	a.a_vp = vp;
	a.a_action = action;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_access_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(access, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% getattr      vp      = = =
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_getattr_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">struct</span> vnode_attr *a_vap;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_GETATTR</span>(vnode_t vp, <span class="enscript-type">struct</span> vnode_attr * vap, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_getattr_args a;

	a.a_desc = &amp;vnop_getattr_desc;
	a.a_vp = vp;
	a.a_vap = vap;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_getattr_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(getattr, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% setattr      vp      L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_setattr_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">struct</span> vnode_attr *a_vap;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_SETATTR</span>(vnode_t vp, <span class="enscript-type">struct</span> vnode_attr * vap, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_setattr_args a;

	a.a_desc = &amp;vnop_setattr_desc;
	a.a_vp = vp;
	a.a_vap = vap;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_setattr_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(setattr, vnode_t, vp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
	<span class="enscript-comment">/* 
	 * Shadow uid/gid/mod change to extended attribute file.
	 */</span>
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; !NATIVE_XATTR(vp)) {
		<span class="enscript-type">struct</span> vnode_attr va;
		<span class="enscript-type">int</span> change = 0;

		VATTR_INIT(&amp;va);
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uid)) {
			VATTR_SET(&amp;va, va_uid, vap-&gt;va_uid);
			change = 1;
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_gid)) {
			VATTR_SET(&amp;va, va_gid, vap-&gt;va_gid);
			change = 1;
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_mode)) {
			VATTR_SET(&amp;va, va_mode, vap-&gt;va_mode);
			change = 1;
		}
		<span class="enscript-keyword">if</span> (change) {
		        vnode_t dvp;
			<span class="enscript-type">const</span> <span class="enscript-type">char</span>   *vname;

			dvp = vnode_getparent(vp);
			vname = vnode_getname(vp);

			xattrfile_setattr(dvp, vname, &amp;va, ctx);
			<span class="enscript-keyword">if</span> (dvp != NULLVP)
			        vnode_put(dvp);
			<span class="enscript-keyword">if</span> (vname != NULL)
			        vnode_putname(vname);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>

	<span class="enscript-comment">/*
	 * If we have changed any of the things about the file that are likely
	 * to result in changes to authorization results, blow the vnode auth
	 * cache
	 */</span>
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; (
			  VATTR_IS_SUPPORTED(vap, va_mode) ||
			  VATTR_IS_SUPPORTED(vap, va_uid) ||
			  VATTR_IS_SUPPORTED(vap, va_gid) ||
			  VATTR_IS_SUPPORTED(vap, va_flags) ||
			  VATTR_IS_SUPPORTED(vap, va_acl) ||
			  VATTR_IS_SUPPORTED(vap, va_uuuid) ||
			  VATTR_IS_SUPPORTED(vap, va_guuid))) {
	        vnode_uncache_authorized_action(vp, KAUTH_INVALIDATE_CACHED_RIGHTS);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
		<span class="enscript-keyword">if</span> (vfs_authopaque(vp-&gt;v_mount) &amp;&amp; vnode_hasnamedstreams(vp)) {
			vnode_t svp;
			<span class="enscript-keyword">if</span> (vnode_getnamedstream(vp, &amp;svp, XATTR_RESOURCEFORK_NAME, NS_OPEN, 0, ctx) == 0) {
				vnode_uncache_authorized_action(svp, KAUTH_INVALIDATE_CACHED_RIGHTS);
				vnode_put(svp);
		 	} 
		} 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NAMEDSTREAMS */</span>
	}


	post_event_if_success(vp, _err, NOTE_ATTRIB);

	<span class="enscript-keyword">return</span> (_err);
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% read         vp      L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_read_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">struct</span> uio *a_uio;
	<span class="enscript-type">int</span> a_ioflag;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_READ</span>(vnode_t vp, <span class="enscript-type">struct</span> uio * uio, <span class="enscript-type">int</span> ioflag, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_read_args a;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	user_ssize_t resid = uio_resid(uio);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	a.a_desc = &amp;vnop_read_desc;
	a.a_vp = vp;
	a.a_uio = uio;
	a.a_ioflag = ioflag;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_read_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO_IO(read,
	    vnode_t, vp, user_ssize_t, (resid - uio_resid(uio)));

	<span class="enscript-keyword">return</span> (_err);
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% write        vp      L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_write_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">struct</span> uio *a_uio;
	<span class="enscript-type">int</span> a_ioflag;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_WRITE</span>(vnode_t vp, <span class="enscript-type">struct</span> uio * uio, <span class="enscript-type">int</span> ioflag, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnop_write_args a;
	<span class="enscript-type">int</span> _err;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	user_ssize_t resid = uio_resid(uio);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	a.a_desc = &amp;vnop_write_desc;
	a.a_vp = vp;
	a.a_uio = uio;
	a.a_ioflag = ioflag;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_write_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO_IO(write,
	    vnode_t, vp, user_ssize_t, (resid - uio_resid(uio)));

	post_event_if_success(vp, _err, NOTE_WRITE);

	<span class="enscript-keyword">return</span> (_err);
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% ioctl        vp      U U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_ioctl_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	u_long a_command;
	caddr_t a_data;
	<span class="enscript-type">int</span> a_fflag;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_IOCTL</span>(vnode_t vp, u_long command, caddr_t data, <span class="enscript-type">int</span> fflag, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_ioctl_args a;

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}

	<span class="enscript-comment">/*
	 * This check should probably have been put in the TTY code instead...
	 *
	 * We have to be careful about what we assume during startup and shutdown.
	 * We have to be able to use the root filesystem's device vnode even when
	 * devfs isn't mounted (yet/anymore), so we can't go looking at its mount
	 * structure.  If there is no data pointer, it doesn't matter whether
	 * the device is 64-bit ready.  Any command (like DKIOCSYNCHRONIZE)
	 * which passes NULL for its data pointer can therefore be used during
	 * mount or unmount of the root filesystem.
	 *
	 * Depending on what root filesystems need to do during mount/unmount, we
	 * may need to loosen this check again in the future.
	 */</span>
	<span class="enscript-keyword">if</span> (vfs_context_is64bit(ctx) &amp;&amp; !(vnode_ischr(vp) || vnode_isblk(vp))) {
		<span class="enscript-keyword">if</span> (data != NULL &amp;&amp; !vnode_vfs64bitready(vp)) {
			<span class="enscript-keyword">return</span>(ENOTTY);
		}
	}

	a.a_desc = &amp;vnop_ioctl_desc;
	a.a_vp = vp;
	a.a_command = command;
	a.a_data = data;
	a.a_fflag = fflag;
	a.a_context= ctx;

	_err = (*vp-&gt;v_op[vnop_ioctl_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(ioctl, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% select       vp      U U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_select_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">int</span> a_which;
	<span class="enscript-type">int</span> a_fflags;
	<span class="enscript-type">void</span> *a_wql;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_SELECT</span>(vnode_t vp, <span class="enscript-type">int</span> which , <span class="enscript-type">int</span> fflags, <span class="enscript-type">void</span> * wql, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_select_args a;

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}
	a.a_desc = &amp;vnop_select_desc;
	a.a_vp = vp;
	a.a_which = which;
	a.a_fflags = fflags;
	a.a_context = ctx;
	a.a_wql = wql;

	_err = (*vp-&gt;v_op[vnop_select_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(select, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% exchange fvp         L L L
 *#% exchange tvp         L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_exchange_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_fvp;
        vnode_t a_tvp;
        <span class="enscript-type">int</span> a_options;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_EXCHANGE</span>(vnode_t fvp, vnode_t tvp, <span class="enscript-type">int</span> options, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_exchange_args a;

	a.a_desc = &amp;vnop_exchange_desc;
	a.a_fvp = fvp;
	a.a_tvp = tvp;
	a.a_options = options;
	a.a_context = ctx;

	_err = (*fvp-&gt;v_op[vnop_exchange_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(exchange, vnode_t, fvp);

	<span class="enscript-comment">/* Don't post NOTE_WRITE because file descriptors follow the data ... */</span>
	post_event_if_success(fvp, _err, NOTE_ATTRIB);
	post_event_if_success(tvp, _err, NOTE_ATTRIB);

	<span class="enscript-keyword">return</span> (_err);
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% revoke       vp      U U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_revoke_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">int</span> a_flags;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_REVOKE</span>(vnode_t vp, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnop_revoke_args a;
	<span class="enscript-type">int</span> _err;

	a.a_desc = &amp;vnop_revoke_desc;
	a.a_vp = vp;
	a.a_flags = flags;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_revoke_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(revoke, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *# mmap - vp U U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_mmap_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">int</span> a_fflags;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_MMAP</span>(vnode_t vp, <span class="enscript-type">int</span> fflags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_mmap_args a;

	a.a_desc = &amp;vnop_mmap_desc;
	a.a_vp = vp;
	a.a_fflags = fflags;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_mmap_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(mmap, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *# mnomap - vp U U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_mnomap_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_MNOMAP</span>(vnode_t vp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_mnomap_args a;

	a.a_desc = &amp;vnop_mnomap_desc;
	a.a_vp = vp;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_mnomap_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(mnomap, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% fsync        vp      L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_fsync_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">int</span> a_waitfor;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_FSYNC</span>(vnode_t vp, <span class="enscript-type">int</span> waitfor, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnop_fsync_args a;
	<span class="enscript-type">int</span> _err;

	a.a_desc = &amp;vnop_fsync_desc;
	a.a_vp = vp;
	a.a_waitfor = waitfor;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_fsync_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(fsync, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% remove       dvp     L U U
 *#% remove       vp      L U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_remove_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t a_vp;
	<span class="enscript-type">struct</span> componentname *a_cnp;
	<span class="enscript-type">int</span> a_flags;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_REMOVE</span>(vnode_t dvp, vnode_t vp, <span class="enscript-type">struct</span> componentname * cnp, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_remove_args a;

	a.a_desc = &amp;vnop_remove_desc;
	a.a_dvp = dvp;
	a.a_vp = vp;
	a.a_cnp = cnp;
	a.a_flags = flags;
	a.a_context = ctx;

	_err = (*dvp-&gt;v_op[vnop_remove_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(remove, vnode_t, vp);

	<span class="enscript-keyword">if</span> (_err == 0) {
	        vnode_setneedinactive(vp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
		<span class="enscript-keyword">if</span> ( !(NATIVE_XATTR(dvp)) ) {
		        <span class="enscript-comment">/* 
			 * Remove any associated extended attribute file (._ AppleDouble file).
			 */</span>
		        xattrfile_remove(dvp, cnp-&gt;cn_nameptr, ctx, 1);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>
	}

	post_event_if_success(vp, _err, NOTE_DELETE | NOTE_LINK);
	post_event_if_success(dvp, _err, NOTE_WRITE);
	
	<span class="enscript-keyword">return</span> (_err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">VNOP_COMPOUND_REMOVE</span>(vnode_t dvp, vnode_t *vpp, <span class="enscript-type">struct</span> nameidata *ndp, int32_t flags, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_compound_remove_args a;
	<span class="enscript-type">int</span> no_vp = (*vpp == NULLVP);

	a.a_desc = &amp;vnop_compound_remove_desc;
	a.a_dvp = dvp;
	a.a_vpp = vpp;
	a.a_cnp = &amp;ndp-&gt;ni_cnd;
	a.a_flags = flags;
	a.a_vap = vap;
	a.a_context = ctx;
	a.a_remove_authorizer = vn_authorize_unlink;

	_err = (*dvp-&gt;v_op[vnop_compound_remove_desc.vdesc_offset])(&amp;a);
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; *vpp) {
		DTRACE_FSINFO(compound_remove, vnode_t, *vpp);
	} <span class="enscript-keyword">else</span> {
		DTRACE_FSINFO(compound_remove, vnode_t, dvp);
	}
	<span class="enscript-keyword">if</span> (_err == 0) {
	        vnode_setneedinactive(*vpp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
		<span class="enscript-keyword">if</span> ( !(NATIVE_XATTR(dvp)) ) {
		        <span class="enscript-comment">/* 
			 * Remove any associated extended attribute file (._ AppleDouble file).
			 */</span>
		        xattrfile_remove(dvp, ndp-&gt;ni_cnd.cn_nameptr, ctx, 1);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>
	}

	post_event_if_success(*vpp, _err, NOTE_DELETE | NOTE_LINK);
	post_event_if_success(dvp, _err, NOTE_WRITE);

	<span class="enscript-keyword">if</span> (no_vp) {
		lookup_compound_vnop_post_hook(_err, dvp, *vpp, ndp, 0);
		<span class="enscript-keyword">if</span> (*vpp &amp;&amp; _err &amp;&amp; _err != EKEEPLOOKING) {
			vnode_put(*vpp);
			*vpp = NULLVP;
		}
	}

	<span class="enscript-comment">//printf(&quot;VNOP_COMPOUND_REMOVE() returning %d\n&quot;, _err);
</span>
	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% link         vp      U U U
 *#% link         tdvp    L U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_link_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	vnode_t a_tdvp;
	<span class="enscript-type">struct</span> componentname *a_cnp;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_LINK</span>(vnode_t vp, vnode_t tdvp, <span class="enscript-type">struct</span> componentname * cnp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_link_args a;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
	<span class="enscript-comment">/*
	 * For file systems with non-native extended attributes,
	 * disallow linking to an existing &quot;._&quot; Apple Double file.
	 */</span>
	<span class="enscript-keyword">if</span> ( !NATIVE_XATTR(tdvp) &amp;&amp; (vp-&gt;v_type == VREG)) {
		<span class="enscript-type">const</span> <span class="enscript-type">char</span>   *vname;

		vname = vnode_getname(vp);
		<span class="enscript-keyword">if</span> (vname != NULL) {
			_err = 0;
			<span class="enscript-keyword">if</span> (vname[0] == <span class="enscript-string">'.'</span> &amp;&amp; vname[1] == <span class="enscript-string">'_'</span> &amp;&amp; vname[2] != <span class="enscript-string">'\0'</span>) {
				_err = EPERM;
			}
			vnode_putname(vname);
			<span class="enscript-keyword">if</span> (_err)
				<span class="enscript-keyword">return</span> (_err);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>

	a.a_desc = &amp;vnop_link_desc;
	a.a_vp = vp;
	a.a_tdvp = tdvp;
	a.a_cnp = cnp;
	a.a_context = ctx;

	_err = (*tdvp-&gt;v_op[vnop_link_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(link, vnode_t, vp);

	post_event_if_success(vp, _err, NOTE_LINK);
	post_event_if_success(tdvp, _err, NOTE_WRITE);

	<span class="enscript-keyword">return</span> (_err);
}

errno_t
<span class="enscript-function-name">vn_rename</span>(<span class="enscript-type">struct</span> vnode *fdvp, <span class="enscript-type">struct</span> vnode **fvpp, <span class="enscript-type">struct</span> componentname *fcnp, <span class="enscript-type">struct</span> vnode_attr *fvap,
            <span class="enscript-type">struct</span> vnode *tdvp, <span class="enscript-type">struct</span> vnode **tvpp, <span class="enscript-type">struct</span> componentname *tcnp, <span class="enscript-type">struct</span> vnode_attr *tvap,
            uint32_t flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> nameidata *fromnd = NULL;
	<span class="enscript-type">struct</span> nameidata *tond = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
	vnode_t src_attr_vp = NULLVP;
	vnode_t dst_attr_vp = NULLVP;
	<span class="enscript-type">char</span> smallname1[48];
	<span class="enscript-type">char</span> smallname2[48];
	<span class="enscript-type">char</span> *xfromname = NULL;
	<span class="enscript-type">char</span> *xtoname = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>
	<span class="enscript-type">int</span> batched;
	uint32_t tdfflags;	<span class="enscript-comment">// Target directory file flags
</span>
	batched = vnode_compound_rename_available(fdvp);

	<span class="enscript-keyword">if</span> (!batched) {
		<span class="enscript-keyword">if</span> (*fvpp == NULLVP) 
			panic(<span class="enscript-string">&quot;Not batched, and no fvp?&quot;</span>);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SECLUDED_RENAME</span>
	<span class="enscript-keyword">if</span> ((fcnp-&gt;cn_flags &amp; CN_SECLUDE_RENAME) &amp;&amp; 
	    (((*fvpp)-&gt;v_mount-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSVNOP_SECLUDE_RENAME) == 0)) {
	    <span class="enscript-keyword">return</span> ENOTSUP;
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
	<span class="enscript-comment">/* 
	 * We need to preflight any potential AppleDouble file for the source file
	 * before doing the rename operation, since we could potentially be doing
	 * this operation on a network filesystem, and would end up duplicating
	 * the work.  Also, save the source and destination names.  Skip it if the
	 * source has a &quot;._&quot; prefix.
	 */</span>
	
	<span class="enscript-keyword">if</span> (!NATIVE_XATTR(fdvp) &amp;&amp;
	    !(fcnp-&gt;cn_nameptr[0] == <span class="enscript-string">'.'</span> &amp;&amp; fcnp-&gt;cn_nameptr[1] == <span class="enscript-string">'_'</span>)) {
		size_t len;
		<span class="enscript-type">int</span> error;

		<span class="enscript-comment">/* Get source attribute file name. */</span>
		len = fcnp-&gt;cn_namelen + 3;
		<span class="enscript-keyword">if</span> (len &gt; <span class="enscript-keyword">sizeof</span>(smallname1)) {
			MALLOC(xfromname, <span class="enscript-type">char</span> *, len, M_TEMP, M_WAITOK);
		} <span class="enscript-keyword">else</span> {
			xfromname = &amp;smallname1[0];
		}
		strlcpy(xfromname, <span class="enscript-string">&quot;._&quot;</span>, min(<span class="enscript-keyword">sizeof</span> smallname1, len));
		strncat(xfromname, fcnp-&gt;cn_nameptr, fcnp-&gt;cn_namelen);
		xfromname[len-1] = <span class="enscript-string">'\0'</span>;

		<span class="enscript-comment">/* Get destination attribute file name. */</span>
		len = tcnp-&gt;cn_namelen + 3;
		<span class="enscript-keyword">if</span> (len &gt; <span class="enscript-keyword">sizeof</span>(smallname2)) {
			MALLOC(xtoname, <span class="enscript-type">char</span> *, len, M_TEMP, M_WAITOK);
		} <span class="enscript-keyword">else</span> {
			xtoname = &amp;smallname2[0];
		}
		strlcpy(xtoname, <span class="enscript-string">&quot;._&quot;</span>, min(<span class="enscript-keyword">sizeof</span> smallname2, len));
		strncat(xtoname, tcnp-&gt;cn_nameptr, tcnp-&gt;cn_namelen);
		xtoname[len-1] = <span class="enscript-string">'\0'</span>;
	
		<span class="enscript-comment">/* 
		 * Look up source attribute file, keep reference on it if exists.
		 * Note that we do the namei with the nameiop of RENAME, which is different than
		 * in the rename syscall. It's OK if the source file does not exist, since this
		 * is only for AppleDouble files.
		 */</span>
		<span class="enscript-keyword">if</span> (xfromname != NULL) {
			MALLOC(fromnd, <span class="enscript-type">struct</span> nameidata *, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nameidata), M_TEMP, M_WAITOK);
			NDINIT(fromnd, RENAME, OP_RENAME, NOFOLLOW | USEDVP | CN_NBMOUNTLOOK,
			       UIO_SYSSPACE, CAST_USER_ADDR_T(xfromname), ctx);
			fromnd-&gt;ni_dvp = fdvp;
			error = namei(fromnd);
		
			<span class="enscript-comment">/* 
			 * If there was an error looking up source attribute file, 
			 * we'll behave as if it didn't exist. 
			 */</span>

			<span class="enscript-keyword">if</span> (error == 0) {
				<span class="enscript-keyword">if</span> (fromnd-&gt;ni_vp) {
					<span class="enscript-comment">/* src_attr_vp indicates need to call vnode_put / nameidone later */</span>
					src_attr_vp = fromnd-&gt;ni_vp;
										
					<span class="enscript-keyword">if</span> (fromnd-&gt;ni_vp-&gt;v_type != VREG) {
						src_attr_vp = NULLVP;
						vnode_put(fromnd-&gt;ni_vp);
					}
				} 
				<span class="enscript-comment">/*
				 * Either we got an invalid vnode type (not a regular file) or the namei lookup 
				 * suppressed ENOENT as a valid error since we're renaming. Either way, we don't 
				 * have a vnode here, so we drop our namei buffer for the source attribute file
				 */</span>
				<span class="enscript-keyword">if</span> (src_attr_vp == NULLVP) {
					nameidone(fromnd);
				}
			}
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>

	<span class="enscript-keyword">if</span> (batched) {
		_err = VNOP_COMPOUND_RENAME(fdvp, fvpp, fcnp, fvap, tdvp, tvpp, tcnp, tvap, flags, ctx);
		<span class="enscript-keyword">if</span> (_err != 0) {
			printf(<span class="enscript-string">&quot;VNOP_COMPOUND_RENAME() returned %d\n&quot;</span>, _err);
		}
	} <span class="enscript-keyword">else</span> {
		_err = VNOP_RENAME(fdvp, *fvpp, fcnp, tdvp, *tvpp, tcnp, ctx);
	}

	<span class="enscript-comment">/*
	 * If moved to a new directory that is restricted,
	 * set the restricted flag on the item moved.
	 */</span>
	<span class="enscript-keyword">if</span> (_err == 0) {
		_err = vnode_flags(tdvp, &amp;tdfflags, ctx);
		<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; (tdfflags &amp; SF_RESTRICTED)) {
			uint32_t fflags;
			_err = vnode_flags(*fvpp, &amp;fflags, ctx);
			<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; !(fflags &amp; SF_RESTRICTED)) {
				<span class="enscript-type">struct</span> vnode_attr va;
				VATTR_INIT(&amp;va);
				VATTR_SET(&amp;va, va_flags, fflags | SF_RESTRICTED);
				_err = vnode_setattr(*fvpp, &amp;va, ctx);
			}
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (_err == 0) {
		mac_vnode_notify_rename(ctx, *fvpp, tdvp, tcnp);
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
	<span class="enscript-comment">/* 
	 * Rename any associated extended attribute file (._ AppleDouble file).
	 */</span>
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; !NATIVE_XATTR(fdvp) &amp;&amp; xfromname != NULL) {
		<span class="enscript-type">int</span> error = 0;
	
		<span class="enscript-comment">/*
		 * Get destination attribute file vnode.
		 * Note that tdvp already has an iocount reference. Make sure to check that we
		 * get a valid vnode from namei.
		 */</span>
		MALLOC(tond, <span class="enscript-type">struct</span> nameidata *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nameidata), M_TEMP, M_WAITOK);
		NDINIT(tond, RENAME, OP_RENAME,
		       NOCACHE | NOFOLLOW | USEDVP | CN_NBMOUNTLOOK, UIO_SYSSPACE,
		       CAST_USER_ADDR_T(xtoname), ctx);
		tond-&gt;ni_dvp = tdvp;
		error = namei(tond);

		<span class="enscript-keyword">if</span> (error) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ad_error</span>;
		
		<span class="enscript-keyword">if</span> (tond-&gt;ni_vp) {
			dst_attr_vp = tond-&gt;ni_vp;
		}
		
		<span class="enscript-keyword">if</span> (src_attr_vp) {
			<span class="enscript-type">const</span> <span class="enscript-type">char</span> *old_name = src_attr_vp-&gt;v_name;
			vnode_t old_parent = src_attr_vp-&gt;v_parent;
	
			<span class="enscript-keyword">if</span> (batched) {
				error = VNOP_COMPOUND_RENAME(fdvp, &amp;src_attr_vp, &amp;fromnd-&gt;ni_cnd, NULL,
						tdvp, &amp;dst_attr_vp, &amp;tond-&gt;ni_cnd, NULL,
						0, ctx);
			} <span class="enscript-keyword">else</span> {
				error = VNOP_RENAME(fdvp, src_attr_vp, &amp;fromnd-&gt;ni_cnd, 
						tdvp, dst_attr_vp, &amp;tond-&gt;ni_cnd, ctx);
			}

			<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; old_name == src_attr_vp-&gt;v_name &amp;&amp;
					old_parent == src_attr_vp-&gt;v_parent) {
				<span class="enscript-type">int</span> update_flags = VNODE_UPDATE_NAME;
				
				<span class="enscript-keyword">if</span> (fdvp != tdvp)
					update_flags |= VNODE_UPDATE_PARENT;
				
				<span class="enscript-keyword">if</span> ((src_attr_vp-&gt;v_mount-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSVNOP_NOUPDATEID_RENAME) == 0) {
					vnode_update_identity(src_attr_vp, tdvp,
						tond-&gt;ni_cnd.cn_nameptr,
						tond-&gt;ni_cnd.cn_namelen,
						tond-&gt;ni_cnd.cn_hash,
						update_flags);
				}
			}
			
			<span class="enscript-comment">/* kevent notifications for moving resource files 
			 * _err is zero if we're here, so no need to notify directories, code
			 * below will do that.  only need to post the rename on the source and
			 * possibly a delete on the dest
			 */</span>
			post_event_if_success(src_attr_vp, error, NOTE_RENAME);
			<span class="enscript-keyword">if</span> (dst_attr_vp) {
				post_event_if_success(dst_attr_vp, error, NOTE_DELETE);	
			}

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dst_attr_vp) {
			<span class="enscript-comment">/*
			 * Just delete destination attribute file vnode if it exists, since
			 * we didn't have a source attribute file.
			 * Note that tdvp already has an iocount reference.
			 */</span>

			<span class="enscript-type">struct</span> vnop_remove_args args;
			
			args.a_desc    = &amp;vnop_remove_desc;
			args.a_dvp     = tdvp;
			args.a_vp      = dst_attr_vp;
			args.a_cnp     = &amp;tond-&gt;ni_cnd;
			args.a_context = ctx;

			<span class="enscript-keyword">if</span> (error == 0) {
				error = (*tdvp-&gt;v_op[vnop_remove_desc.vdesc_offset])(&amp;args);

				<span class="enscript-keyword">if</span> (error == 0)
					vnode_setneedinactive(dst_attr_vp);
			}
			
			<span class="enscript-comment">/* kevent notification for deleting the destination's attribute file
			 * if it existed.  Only need to post the delete on the destination, since
			 * the code below will handle the directories. 
			 */</span>
			post_event_if_success(dst_attr_vp, error, NOTE_DELETE);	
		}
	}
<span class="enscript-reference">ad_error</span>:
	<span class="enscript-keyword">if</span> (src_attr_vp) {
		vnode_put(src_attr_vp);
		nameidone(fromnd);
	}
	<span class="enscript-keyword">if</span> (dst_attr_vp) {
		vnode_put(dst_attr_vp);
		nameidone(tond);
	}
	<span class="enscript-keyword">if</span> (xfromname &amp;&amp; xfromname != &amp;smallname1[0]) {
		FREE(xfromname, M_TEMP);
	}
	<span class="enscript-keyword">if</span> (xtoname &amp;&amp; xtoname != &amp;smallname2[0]) {
		FREE(xtoname, M_TEMP);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>
	<span class="enscript-keyword">if</span> (fromnd) {
		FREE(fromnd, M_TEMP);
	}
	<span class="enscript-keyword">if</span> (tond) {
		FREE(tond, M_TEMP);
	}
	<span class="enscript-keyword">return</span> _err;
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% rename       fdvp    U U U
 *#% rename       fvp     U U U
 *#% rename       tdvp    L U U
 *#% rename       tvp     X U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_rename_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_fdvp;
	vnode_t a_fvp;
	<span class="enscript-type">struct</span> componentname *a_fcnp;
	vnode_t a_tdvp;
	vnode_t a_tvp;
	<span class="enscript-type">struct</span> componentname *a_tcnp;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t
<span class="enscript-function-name">VNOP_RENAME</span>(<span class="enscript-type">struct</span> vnode *fdvp, <span class="enscript-type">struct</span> vnode *fvp, <span class="enscript-type">struct</span> componentname *fcnp,
            <span class="enscript-type">struct</span> vnode *tdvp, <span class="enscript-type">struct</span> vnode *tvp, <span class="enscript-type">struct</span> componentname *tcnp,
            vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err = 0;
	<span class="enscript-type">int</span> events;
	<span class="enscript-type">struct</span> vnop_rename_args a;

	a.a_desc = &amp;vnop_rename_desc;
	a.a_fdvp = fdvp;
	a.a_fvp = fvp;
	a.a_fcnp = fcnp;
	a.a_tdvp = tdvp;
	a.a_tvp = tvp;
	a.a_tcnp = tcnp;
	a.a_context = ctx;

	<span class="enscript-comment">/* do the rename of the main file. */</span>
	_err = (*fdvp-&gt;v_op[vnop_rename_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(rename, vnode_t, fdvp);

	<span class="enscript-keyword">if</span> (_err == 0) {
		<span class="enscript-keyword">if</span> (tvp &amp;&amp; tvp != fvp)
		        vnode_setneedinactive(tvp);
	}

	<span class="enscript-comment">/* Wrote at least one directory.  If transplanted a dir, also changed link counts */</span>
	<span class="enscript-keyword">if</span> (_err == 0) {
		events = NOTE_WRITE;
		<span class="enscript-keyword">if</span> (vnode_isdir(fvp)) {
			<span class="enscript-comment">/* Link count on dir changed only if we are moving a dir and...
			 * 	--Moved to new dir, not overwriting there
			 * 	--Kept in same dir and DID overwrite
			 */</span>
			<span class="enscript-keyword">if</span> (((fdvp != tdvp) &amp;&amp; (!tvp)) || ((fdvp == tdvp) &amp;&amp; (tvp))) {
				events |= NOTE_LINK;
			}
		}

		lock_vnode_and_post(fdvp, events);
		<span class="enscript-keyword">if</span> (fdvp != tdvp) {
			lock_vnode_and_post(tdvp,  events);
		}

		<span class="enscript-comment">/* If you're replacing the target, post a deletion for it */</span>
		<span class="enscript-keyword">if</span> (tvp)
		{
			lock_vnode_and_post(tvp, NOTE_DELETE);
		}

		lock_vnode_and_post(fvp, NOTE_RENAME);
	}

	<span class="enscript-keyword">return</span> (_err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">VNOP_COMPOUND_RENAME</span>( 
		<span class="enscript-type">struct</span> vnode *fdvp,  <span class="enscript-type">struct</span> vnode **fvpp,  <span class="enscript-type">struct</span> componentname *fcnp, <span class="enscript-type">struct</span> vnode_attr *fvap,
             	<span class="enscript-type">struct</span> vnode *tdvp,  <span class="enscript-type">struct</span> vnode **tvpp,  <span class="enscript-type">struct</span> componentname *tcnp, <span class="enscript-type">struct</span> vnode_attr *tvap,  
	     	uint32_t flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err = 0;
	<span class="enscript-type">int</span> events;
	<span class="enscript-type">struct</span> vnop_compound_rename_args a;
	<span class="enscript-type">int</span> no_fvp, no_tvp;

	no_fvp = (*fvpp) == NULLVP;
	no_tvp = (*tvpp) == NULLVP;

	a.a_desc = &amp;vnop_compound_rename_desc;
	
	a.a_fdvp = fdvp;
	a.a_fvpp = fvpp;
	a.a_fcnp = fcnp;
	a.a_fvap = fvap;

	a.a_tdvp = tdvp;
	a.a_tvpp = tvpp;
	a.a_tcnp = tcnp;
	a.a_tvap = tvap;
	
	a.a_flags = flags;
	a.a_context = ctx;
	a.a_rename_authorizer = vn_authorize_rename;
	a.a_reserved = NULL;

	<span class="enscript-comment">/* do the rename of the main file. */</span>
	_err = (*fdvp-&gt;v_op[vnop_compound_rename_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(compound_rename, vnode_t, fdvp);

	<span class="enscript-keyword">if</span> (_err == 0) {
		<span class="enscript-keyword">if</span> (*tvpp &amp;&amp; *tvpp != *fvpp)
		        vnode_setneedinactive(*tvpp);
	}

	<span class="enscript-comment">/* Wrote at least one directory.  If transplanted a dir, also changed link counts */</span>
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; *fvpp != *tvpp) {
		<span class="enscript-keyword">if</span> (!*fvpp) {
			panic(<span class="enscript-string">&quot;No fvpp after compound rename?&quot;</span>);
		}

		events = NOTE_WRITE;
		<span class="enscript-keyword">if</span> (vnode_isdir(*fvpp)) {
			<span class="enscript-comment">/* Link count on dir changed only if we are moving a dir and...
			 * 	--Moved to new dir, not overwriting there
			 * 	--Kept in same dir and DID overwrite
			 */</span>
			<span class="enscript-keyword">if</span> (((fdvp != tdvp) &amp;&amp; (!*tvpp)) || ((fdvp == tdvp) &amp;&amp; (*tvpp))) {
				events |= NOTE_LINK;
			}
		}

		lock_vnode_and_post(fdvp, events);
		<span class="enscript-keyword">if</span> (fdvp != tdvp) {
			lock_vnode_and_post(tdvp,  events);
		}

		<span class="enscript-comment">/* If you're replacing the target, post a deletion for it */</span>
		<span class="enscript-keyword">if</span> (*tvpp)
		{
			lock_vnode_and_post(*tvpp, NOTE_DELETE);
		}

		lock_vnode_and_post(*fvpp, NOTE_RENAME);
	}

	<span class="enscript-keyword">if</span> (no_fvp) {
		lookup_compound_vnop_post_hook(_err, fdvp, *fvpp, fcnp-&gt;cn_ndp, 0); 
	}
	<span class="enscript-keyword">if</span> (no_tvp &amp;&amp; *tvpp != NULLVP) {
		lookup_compound_vnop_post_hook(_err, tdvp, *tvpp, tcnp-&gt;cn_ndp, 0);
	}

	<span class="enscript-keyword">if</span> (_err &amp;&amp; _err != EKEEPLOOKING) {
		<span class="enscript-keyword">if</span> (*fvpp) {
			vnode_put(*fvpp);
			*fvpp = NULLVP;
		}
		<span class="enscript-keyword">if</span> (*tvpp) {
			vnode_put(*tvpp);
			*tvpp = NULLVP;
		}
	}

	<span class="enscript-keyword">return</span> (_err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_mkdir</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">struct</span> nameidata *ndp,
           <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
	<span class="enscript-keyword">if</span> (ndp-&gt;ni_cnd.cn_nameiop != CREATE) {
		panic(<span class="enscript-string">&quot;Non-CREATE nameiop in vn_mkdir()?&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (vnode_compound_mkdir_available(dvp)) {
		<span class="enscript-keyword">return</span> VNOP_COMPOUND_MKDIR(dvp, vpp, ndp, vap, ctx);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> VNOP_MKDIR(dvp, vpp, &amp;ndp-&gt;ni_cnd, vap, ctx);
	}
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% mkdir        dvp     L U U
 *#% mkdir        vpp     - L -
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_mkdir_args {
       <span class="enscript-type">struct</span> vnodeop_desc *a_desc;
       vnode_t a_dvp;
       vnode_t *a_vpp;
       <span class="enscript-type">struct</span> componentname *a_cnp;
       <span class="enscript-type">struct</span> vnode_attr *a_vap;
       vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t
<span class="enscript-function-name">VNOP_MKDIR</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">struct</span> componentname *cnp,
           <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
       <span class="enscript-type">int</span> _err;
       <span class="enscript-type">struct</span> vnop_mkdir_args a;

       a.a_desc = &amp;vnop_mkdir_desc;
       a.a_dvp = dvp;
       a.a_vpp = vpp;
       a.a_cnp = cnp;
       a.a_vap = vap;
       a.a_context = ctx;

       _err = (*dvp-&gt;v_op[vnop_mkdir_desc.vdesc_offset])(&amp;a);
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; *vpp) {
		DTRACE_FSINFO(mkdir, vnode_t, *vpp);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; !NATIVE_XATTR(dvp)) {
		<span class="enscript-comment">/* 
		 * Remove stale Apple Double file (if any).
		 */</span>
		xattrfile_remove(dvp, cnp-&gt;cn_nameptr, ctx, 0);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>

       post_event_if_success(dvp, _err, NOTE_LINK | NOTE_WRITE);

       <span class="enscript-keyword">return</span> (_err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">VNOP_COMPOUND_MKDIR</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">struct</span> nameidata *ndp,
           <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
       <span class="enscript-type">int</span> _err;
       <span class="enscript-type">struct</span> vnop_compound_mkdir_args a;

       a.a_desc = &amp;vnop_compound_mkdir_desc;
       a.a_dvp = dvp;
       a.a_vpp = vpp;
       a.a_cnp = &amp;ndp-&gt;ni_cnd;
       a.a_vap = vap;
       a.a_flags = 0;
       a.a_context = ctx;
#<span class="enscript-reference">if</span> 0
       a.a_mkdir_authorizer = vn_authorize_mkdir;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0 */</span>
       a.a_reserved = NULL;

       _err = (*dvp-&gt;v_op[vnop_compound_mkdir_desc.vdesc_offset])(&amp;a);
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; *vpp) {
		DTRACE_FSINFO(compound_mkdir, vnode_t, *vpp);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; !NATIVE_XATTR(dvp)) {
		<span class="enscript-comment">/* 
		 * Remove stale Apple Double file (if any).
		 */</span>
		xattrfile_remove(dvp, ndp-&gt;ni_cnd.cn_nameptr, ctx, 0);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>

	post_event_if_success(dvp, _err, NOTE_LINK | NOTE_WRITE);

	lookup_compound_vnop_post_hook(_err, dvp, *vpp, ndp, (_err == 0));
	<span class="enscript-keyword">if</span> (*vpp &amp;&amp; _err &amp;&amp; _err != EKEEPLOOKING) {
		vnode_put(*vpp);
		*vpp = NULLVP;
	}

	<span class="enscript-keyword">return</span> (_err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_rmdir</span>(vnode_t dvp, vnode_t *vpp, <span class="enscript-type">struct</span> nameidata *ndp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
	<span class="enscript-keyword">if</span> (vnode_compound_rmdir_available(dvp)) {
		<span class="enscript-keyword">return</span> VNOP_COMPOUND_RMDIR(dvp, vpp, ndp, vap, ctx);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (*vpp == NULLVP) {
			panic(<span class="enscript-string">&quot;NULL vp, but not a compound VNOP?&quot;</span>);
		}
		<span class="enscript-keyword">if</span> (vap != NULL) {
			panic(<span class="enscript-string">&quot;Non-NULL vap, but not a compound VNOP?&quot;</span>);
		}
		<span class="enscript-keyword">return</span> VNOP_RMDIR(dvp, *vpp, &amp;ndp-&gt;ni_cnd, ctx);
	}
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% rmdir        dvp     L U U
 *#% rmdir        vp      L U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_rmdir_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_dvp;
	vnode_t a_vp;
	<span class="enscript-type">struct</span> componentname *a_cnp;
	vfs_context_t a_context;
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t
<span class="enscript-function-name">VNOP_RMDIR</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> componentname *cnp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_rmdir_args a;

	a.a_desc = &amp;vnop_rmdir_desc;
	a.a_dvp = dvp;
	a.a_vp = vp;
	a.a_cnp = cnp;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_rmdir_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(rmdir, vnode_t, vp);

	<span class="enscript-keyword">if</span> (_err == 0) {
	        vnode_setneedinactive(vp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
		<span class="enscript-keyword">if</span> ( !(NATIVE_XATTR(dvp)) ) {
		        <span class="enscript-comment">/* 
			 * Remove any associated extended attribute file (._ AppleDouble file).
			 */</span>
		        xattrfile_remove(dvp, cnp-&gt;cn_nameptr, ctx, 1);
		}
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-comment">/* If you delete a dir, it loses its &quot;.&quot; reference --&gt; NOTE_LINK */</span>
	post_event_if_success(vp, _err, NOTE_DELETE | NOTE_LINK);
	post_event_if_success(dvp, _err, NOTE_LINK | NOTE_WRITE);

	<span class="enscript-keyword">return</span> (_err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">VNOP_COMPOUND_RMDIR</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">struct</span> nameidata *ndp,
           <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
       <span class="enscript-type">int</span> _err;
       <span class="enscript-type">struct</span> vnop_compound_rmdir_args a;
       <span class="enscript-type">int</span> no_vp;

       a.a_desc = &amp;vnop_mkdir_desc;
       a.a_dvp = dvp;
       a.a_vpp = vpp;
       a.a_cnp = &amp;ndp-&gt;ni_cnd;
       a.a_vap = vap;
       a.a_flags = 0;
       a.a_context = ctx;
       a.a_rmdir_authorizer = vn_authorize_rmdir;
       a.a_reserved = NULL;

       no_vp = (*vpp == NULLVP);

       _err = (*dvp-&gt;v_op[vnop_compound_rmdir_desc.vdesc_offset])(&amp;a);
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; *vpp) {
		DTRACE_FSINFO(compound_rmdir, vnode_t, *vpp);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; !NATIVE_XATTR(dvp)) {
		<span class="enscript-comment">/* 
		 * Remove stale Apple Double file (if any).
		 */</span>
		xattrfile_remove(dvp, ndp-&gt;ni_cnd.cn_nameptr, ctx, 0);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (*vpp) {
		post_event_if_success(*vpp, _err, NOTE_DELETE | NOTE_LINK);
	}
	post_event_if_success(dvp, _err, NOTE_LINK | NOTE_WRITE);

       <span class="enscript-keyword">if</span> (no_vp) {
	       lookup_compound_vnop_post_hook(_err, dvp, *vpp, ndp, 0);

#<span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* Removing orphaned ._ files requires a vp.... */</span>
	       <span class="enscript-keyword">if</span> (*vpp &amp;&amp; _err &amp;&amp; _err != EKEEPLOOKING) {
		       vnode_put(*vpp);
		       *vpp = NULLVP;
	       }
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* 0 */</span>
       }

       <span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
<span class="enscript-comment">/*
 * Remove a ._ AppleDouble file
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AD_STALE_SECS</span>  (180)
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">xattrfile_remove</span>(vnode_t dvp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * basename, vfs_context_t ctx, <span class="enscript-type">int</span> force) 
{
	vnode_t xvp;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">char</span> smallname[64];
	<span class="enscript-type">char</span> *filename = NULL;
	size_t len;

	<span class="enscript-keyword">if</span> ((basename == NULL) || (basename[0] == <span class="enscript-string">'\0'</span>) ||
	    (basename[0] == <span class="enscript-string">'.'</span> &amp;&amp; basename[1] == <span class="enscript-string">'_'</span>)) {
		<span class="enscript-keyword">return</span>;
	}
	filename = &amp;smallname[0];
	len = snprintf(filename, <span class="enscript-keyword">sizeof</span>(smallname), <span class="enscript-string">&quot;._%s&quot;</span>, basename);
	<span class="enscript-keyword">if</span> (len &gt;= <span class="enscript-keyword">sizeof</span>(smallname)) {
		len++;  <span class="enscript-comment">/* snprintf result doesn't include '\0' */</span>
		MALLOC(filename, <span class="enscript-type">char</span> *, len, M_TEMP, M_WAITOK);
		len = snprintf(filename, len, <span class="enscript-string">&quot;._%s&quot;</span>, basename);
	}
	NDINIT(&amp;nd, DELETE, OP_UNLINK, WANTPARENT | LOCKLEAF | NOFOLLOW | USEDVP, UIO_SYSSPACE,
	       CAST_USER_ADDR_T(filename), ctx);
	nd.ni_dvp = dvp;
	<span class="enscript-keyword">if</span> (namei(&amp;nd) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;

	xvp = nd.ni_vp;
	nameidone(&amp;nd);
	<span class="enscript-keyword">if</span> (xvp-&gt;v_type != VREG)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;

	<span class="enscript-comment">/*
	 * When creating a new object and a &quot;._&quot; file already
	 * exists, check to see if its a stale &quot;._&quot; file.
	 *
	 */</span>
	<span class="enscript-keyword">if</span> (!force) {
		<span class="enscript-type">struct</span> vnode_attr va;

		VATTR_INIT(&amp;va);
		VATTR_WANTED(&amp;va, va_data_size);
		VATTR_WANTED(&amp;va, va_modify_time);
		<span class="enscript-keyword">if</span> (VNOP_GETATTR(xvp, &amp;va, ctx) == 0  &amp;&amp;
		    VATTR_IS_SUPPORTED(&amp;va, va_data_size)  &amp;&amp;
		    VATTR_IS_SUPPORTED(&amp;va, va_modify_time)  &amp;&amp;
		    va.va_data_size != 0) {
			<span class="enscript-type">struct</span> timeval tv;

			microtime(&amp;tv);
			<span class="enscript-keyword">if</span> ((tv.tv_sec &gt; va.va_modify_time.tv_sec) &amp;&amp;
			    (tv.tv_sec - va.va_modify_time.tv_sec) &gt; AD_STALE_SECS) {
				force = 1;  <span class="enscript-comment">/* must be stale */</span>
			}
		}
	}
	<span class="enscript-keyword">if</span> (force) {
		<span class="enscript-type">int</span>  error;
	
		error = VNOP_REMOVE(dvp, xvp, &amp;nd.ni_cnd, 0, ctx);
		<span class="enscript-keyword">if</span> (error == 0)
			vnode_setneedinactive(xvp);

		post_event_if_success(xvp, error, NOTE_DELETE);
		post_event_if_success(dvp, error, NOTE_WRITE);
	}

<span class="enscript-reference">out1</span>:		
	vnode_put(dvp);
	vnode_put(xvp);
<span class="enscript-reference">out2</span>:
	<span class="enscript-keyword">if</span> (filename &amp;&amp; filename != &amp;smallname[0]) {
		FREE(filename, M_TEMP);
	}
}

<span class="enscript-comment">/*
 * Shadow uid/gid/mod to a ._ AppleDouble file
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">xattrfile_setattr</span>(vnode_t dvp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * basename, <span class="enscript-type">struct</span> vnode_attr * vap,
                  vfs_context_t ctx) 
{
	vnode_t xvp;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">char</span> smallname[64];
	<span class="enscript-type">char</span> *filename = NULL;
	size_t len;

	<span class="enscript-keyword">if</span> ((dvp == NULLVP) ||
	    (basename == NULL) || (basename[0] == <span class="enscript-string">'\0'</span>) ||
	    (basename[0] == <span class="enscript-string">'.'</span> &amp;&amp; basename[1] == <span class="enscript-string">'_'</span>)) {
		<span class="enscript-keyword">return</span>;
	}
	filename = &amp;smallname[0];
	len = snprintf(filename, <span class="enscript-keyword">sizeof</span>(smallname), <span class="enscript-string">&quot;._%s&quot;</span>, basename);
	<span class="enscript-keyword">if</span> (len &gt;= <span class="enscript-keyword">sizeof</span>(smallname)) {
		len++;  <span class="enscript-comment">/* snprintf result doesn't include '\0' */</span>
		MALLOC(filename, <span class="enscript-type">char</span> *, len, M_TEMP, M_WAITOK);
		len = snprintf(filename, len, <span class="enscript-string">&quot;._%s&quot;</span>, basename);
	}
	NDINIT(&amp;nd, LOOKUP, OP_SETATTR, NOFOLLOW | USEDVP, UIO_SYSSPACE,
	       CAST_USER_ADDR_T(filename), ctx);
	nd.ni_dvp = dvp;
	<span class="enscript-keyword">if</span> (namei(&amp;nd) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;

	xvp = nd.ni_vp;
	nameidone(&amp;nd);

	<span class="enscript-keyword">if</span> (xvp-&gt;v_type == VREG) {
		<span class="enscript-type">struct</span> vnop_setattr_args a;

		a.a_desc = &amp;vnop_setattr_desc;
		a.a_vp = xvp;
		a.a_vap = vap;
		a.a_context = ctx;

		(<span class="enscript-type">void</span>) (*xvp-&gt;v_op[vnop_setattr_desc.vdesc_offset])(&amp;a);
	}

	vnode_put(xvp);
<span class="enscript-reference">out2</span>:
	<span class="enscript-keyword">if</span> (filename &amp;&amp; filename != &amp;smallname[0]) {
		FREE(filename, M_TEMP);
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>

 #<span class="enscript-keyword">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% symlink      dvp     L U U
 *#% symlink      vpp     - U -
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_symlink_args {
       <span class="enscript-type">struct</span> vnodeop_desc *a_desc;
       vnode_t a_dvp;
       vnode_t *a_vpp;
       <span class="enscript-type">struct</span> componentname *a_cnp;
       <span class="enscript-type">struct</span> vnode_attr *a_vap;
       <span class="enscript-type">char</span> *a_target;
       vfs_context_t a_context;
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t
<span class="enscript-function-name">VNOP_SYMLINK</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">struct</span> componentname *cnp,
             <span class="enscript-type">struct</span> vnode_attr *vap, <span class="enscript-type">char</span> *target, vfs_context_t ctx)
{
       <span class="enscript-type">int</span> _err;
       <span class="enscript-type">struct</span> vnop_symlink_args a;

       a.a_desc = &amp;vnop_symlink_desc;
       a.a_dvp = dvp;
       a.a_vpp = vpp;
       a.a_cnp = cnp;
       a.a_vap = vap;
       a.a_target = target;
       a.a_context = ctx;

       _err = (*dvp-&gt;v_op[vnop_symlink_desc.vdesc_offset])(&amp;a);   
	DTRACE_FSINFO(symlink, vnode_t, dvp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_APPLEDOUBLE</span>
	<span class="enscript-keyword">if</span> (_err == 0 &amp;&amp; !NATIVE_XATTR(dvp)) {
		<span class="enscript-comment">/* 
		 * Remove stale Apple Double file (if any).  Posts its own knotes
		 */</span>
		xattrfile_remove(dvp, cnp-&gt;cn_nameptr, ctx, 0);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_APPLEDOUBLE */</span>

	post_event_if_success(dvp, _err, NOTE_WRITE);

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% readdir      vp      L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_readdir_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">struct</span> uio *a_uio;
	<span class="enscript-type">int</span> a_flags;
	<span class="enscript-type">int</span> *a_eofflag;
	<span class="enscript-type">int</span> *a_numdirent;
	vfs_context_t a_context;
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_READDIR</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> *eofflag,
             <span class="enscript-type">int</span> *numdirent, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_readdir_args a;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	user_ssize_t resid = uio_resid(uio);
#<span class="enscript-reference">endif</span>

	a.a_desc = &amp;vnop_readdir_desc;
	a.a_vp = vp;
	a.a_uio = uio;
	a.a_flags = flags;
	a.a_eofflag = eofflag;
	a.a_numdirent = numdirent;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_readdir_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO_IO(readdir,
	    vnode_t, vp, user_ssize_t, (resid - uio_resid(uio)));

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% readdirattr  vp      L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_readdirattr_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">struct</span> attrlist *a_alist;
	<span class="enscript-type">struct</span> uio *a_uio;
	uint32_t a_maxcount;
	uint32_t a_options;
	uint32_t *a_newstate;
	<span class="enscript-type">int</span> *a_eofflag;
	uint32_t *a_actualcount;
	vfs_context_t a_context;
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_READDIRATTR</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> attrlist *alist, <span class="enscript-type">struct</span> uio *uio, uint32_t maxcount,
                 uint32_t options, uint32_t *newstate, <span class="enscript-type">int</span> *eofflag, uint32_t *actualcount, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_readdirattr_args a;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	user_ssize_t resid = uio_resid(uio);
#<span class="enscript-reference">endif</span>

	a.a_desc = &amp;vnop_readdirattr_desc;
	a.a_vp = vp;
	a.a_alist = alist;
	a.a_uio = uio;
	a.a_maxcount = maxcount;
	a.a_options = options;
	a.a_newstate = newstate;
	a.a_eofflag = eofflag;
	a.a_actualcount = actualcount;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_readdirattr_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO_IO(readdirattr,
	    vnode_t, vp, user_ssize_t, (resid - uio_resid(uio)));

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">struct</span> vnop_getttrlistbulk_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">struct</span> attrlist *a_alist;
	<span class="enscript-type">struct</span> vnode_attr *a_vap;
	<span class="enscript-type">struct</span> uio *a_uio;
	<span class="enscript-type">void</span> *a_private
	uint64_t a_options;
	<span class="enscript-type">int</span> *a_eofflag;
	uint32_t *a_actualcount;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t
<span class="enscript-function-name">VNOP_GETATTRLISTBULK</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> attrlist *alist,
    <span class="enscript-type">struct</span> vnode_attr *vap, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">void</span> *private, uint64_t options,
    int32_t *eofflag, int32_t *actualcount, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_getattrlistbulk_args a;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	user_ssize_t resid = uio_resid(uio);
#<span class="enscript-reference">endif</span>

	a.a_desc = &amp;vnop_getattrlistbulk_desc;
	a.a_vp = vp;
	a.a_alist = alist;
	a.a_vap = vap;
	a.a_uio = uio;
	a.a_private = private;
	a.a_options = options;
	a.a_eofflag = eofflag;
	a.a_actualcount = actualcount;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_getattrlistbulk_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO_IO(getattrlistbulk,
	    vnode_t, vp, user_ssize_t, (resid - uio_resid(uio)));

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% readlink     vp      L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_readlink_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">struct</span> uio *a_uio;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0 */</span>

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		lock_fsnode:ENOENT	No such file or directory [only for VFS
 *					 that is not thread safe &amp; vnode is
 *					 currently being/has been terminated]
 *		&lt;vfs_readlink&gt;:EINVAL
 *		&lt;vfs_readlink&gt;:???
 *
 * Note:	The return codes from the underlying VFS's readlink routine
 *		can't be fully enumerated here, since third party VFS authors
 *		may not limit their error returns to the ones documented here,
 *		even though this may result in some programs functioning
 *		incorrectly.
 *
 *		The return codes documented above are those which may currently
 *		be returned by HFS from hfs_vnop_readlink, not including
 *		additional error code which may be propagated from underlying
 *		routines.
 */</span>
errno_t 
<span class="enscript-function-name">VNOP_READLINK</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> uio *uio, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_readlink_args a;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	user_ssize_t resid = uio_resid(uio);
#<span class="enscript-reference">endif</span>
	a.a_desc = &amp;vnop_readlink_desc;
	a.a_vp = vp;
	a.a_uio = uio;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_readlink_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO_IO(readlink,
	    vnode_t, vp, user_ssize_t, (resid - uio_resid(uio)));

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% inactive     vp      L U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_inactive_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_INACTIVE</span>(<span class="enscript-type">struct</span> vnode *vp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_inactive_args a;

	a.a_desc = &amp;vnop_inactive_desc;
	a.a_vp = vp;
	a.a_context = ctx;
	
	_err = (*vp-&gt;v_op[vnop_inactive_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(inactive, vnode_t, vp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	<span class="enscript-comment">/* For file systems that do not support namedstream natively, mark 
	 * the shadow stream file vnode to be recycled as soon as the last 
	 * reference goes away.  To avoid re-entering reclaim code, do not 
	 * call recycle on terminating namedstream vnodes.
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isnamedstream(vp) &amp;&amp;
	    (vp-&gt;v_parent != NULLVP) &amp;&amp;
	    vnode_isshadow(vp) &amp;&amp;
	    ((vp-&gt;v_lflag &amp; VL_TERMINATE) == 0)) {
		vnode_recycle(vp);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (_err);
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% reclaim      vp      U U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_reclaim_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t
<span class="enscript-function-name">VNOP_RECLAIM</span>(<span class="enscript-type">struct</span> vnode *vp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_reclaim_args a;

	a.a_desc = &amp;vnop_reclaim_desc;
	a.a_vp = vp;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_reclaim_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(reclaim, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}


<span class="enscript-comment">/*
 * Returns:	0			Success
 *	lock_fsnode:ENOENT		No such file or directory [only for VFS
 *					 that is not thread safe &amp; vnode is
 *					 currently being/has been terminated]
 *	&lt;vnop_pathconf_desc&gt;:???	[per FS implementation specific]
 */</span>
#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% pathconf     vp      L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_pathconf_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">int</span> a_name;
	int32_t *a_retval;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_PATHCONF</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> name, int32_t *retval, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_pathconf_args a;

	a.a_desc = &amp;vnop_pathconf_desc;
	a.a_vp = vp;
	a.a_name = name;
	a.a_retval = retval;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_pathconf_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(pathconf, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *	err_advlock:ENOTSUP
 *	lf_advlock:???
 *	&lt;vnop_advlock_desc&gt;:???
 *
 * Notes:	VFS implementations of advisory locking using calls through
 *		&lt;vnop_advlock_desc&gt; because lock enforcement does not occur
 *		locally should try to limit themselves to the return codes
 *		documented above for lf_advlock and err_advlock.
 */</span>
#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% advlock      vp      U U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_advlock_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	caddr_t a_id;
	<span class="enscript-type">int</span> a_op;
	<span class="enscript-type">struct</span> flock *a_fl;
	<span class="enscript-type">int</span> a_flags;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_ADVLOCK</span>(<span class="enscript-type">struct</span> vnode *vp, caddr_t id, <span class="enscript-type">int</span> op, <span class="enscript-type">struct</span> flock *fl, <span class="enscript-type">int</span> flags, vfs_context_t ctx, <span class="enscript-type">struct</span> timespec *timeout)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_advlock_args a;

	a.a_desc = &amp;vnop_advlock_desc;
	a.a_vp = vp;
	a.a_id = id;
	a.a_op = op;
	a.a_fl = fl;
	a.a_flags = flags;
	a.a_context = ctx;
	a.a_timeout = timeout;

	<span class="enscript-comment">/* Disallow advisory locking on non-seekable vnodes */</span>
	<span class="enscript-keyword">if</span> (vnode_isfifo(vp)) {
		_err = err_advlock(&amp;a);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VLOCKLOCAL)) {
			<span class="enscript-comment">/* Advisory locking done at this layer */</span>
			_err = lf_advlock(&amp;a);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; F_OFD_LOCK) {
			<span class="enscript-comment">/* Non-local locking doesn't work for OFD locks */</span>
			_err = err_advlock(&amp;a);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Advisory locking done by underlying filesystem */</span>
			_err = (*vp-&gt;v_op[vnop_advlock_desc.vdesc_offset])(&amp;a);
		}
		DTRACE_FSINFO(advlock, vnode_t, vp);
	}

	<span class="enscript-keyword">return</span> (_err);
}



#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% allocate     vp      L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_allocate_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	off_t a_length;
	u_int32_t a_flags;
	off_t *a_bytesallocated;
	off_t a_offset;
	vfs_context_t a_context;
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_ALLOCATE</span>(<span class="enscript-type">struct</span> vnode *vp, off_t length, u_int32_t flags, off_t *bytesallocated, off_t offset, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_allocate_args a;

	a.a_desc = &amp;vnop_allocate_desc;
	a.a_vp = vp;
	a.a_length = length;
	a.a_flags = flags;
	a.a_bytesallocated = bytesallocated;
	a.a_offset = offset;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_allocate_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(allocate, vnode_t, vp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (_err == 0) {
		add_fsevent(FSE_STAT_CHANGED, ctx, FSE_ARG_VNODE, vp, FSE_ARG_DONE);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% pagein       vp      = = =
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_pagein_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	upl_t a_pl;
	upl_offset_t a_pl_offset;
	off_t a_f_offset;
	size_t a_size;
	<span class="enscript-type">int</span> a_flags;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_PAGEIN</span>(<span class="enscript-type">struct</span> vnode *vp, upl_t pl, upl_offset_t pl_offset, off_t f_offset, size_t size, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_pagein_args a;

	a.a_desc = &amp;vnop_pagein_desc;
	a.a_vp = vp;
	a.a_pl = pl;
	a.a_pl_offset = pl_offset;
	a.a_f_offset = f_offset;
	a.a_size = size;
	a.a_flags = flags;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_pagein_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(pagein, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% pageout      vp      = = =
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_pageout_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	upl_t a_pl;
	upl_offset_t a_pl_offset;
	off_t a_f_offset;
	size_t a_size;
	<span class="enscript-type">int</span> a_flags;
	vfs_context_t a_context;
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_PAGEOUT</span>(<span class="enscript-type">struct</span> vnode *vp, upl_t pl, upl_offset_t pl_offset, off_t f_offset, size_t size, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_pageout_args a;

	a.a_desc = &amp;vnop_pageout_desc;
	a.a_vp = vp;
	a.a_pl = pl;
	a.a_pl_offset = pl_offset;
	a.a_f_offset = f_offset;
	a.a_size = size;
	a.a_flags = flags;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_pageout_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(pageout, vnode_t, vp);

	post_event_if_success(vp, _err, NOTE_WRITE);

	<span class="enscript-keyword">return</span> (_err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_remove</span>(vnode_t dvp, vnode_t *vpp, <span class="enscript-type">struct</span> nameidata *ndp, int32_t flags, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
	<span class="enscript-keyword">if</span> (vnode_compound_remove_available(dvp)) {
		<span class="enscript-keyword">return</span> VNOP_COMPOUND_REMOVE(dvp, vpp, ndp, flags, vap, ctx);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> VNOP_REMOVE(dvp, *vpp, &amp;ndp-&gt;ni_cnd, flags, ctx);
	}
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SEARCHFS</span>

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% searchfs     vp      L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_searchfs_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	<span class="enscript-type">void</span> *a_searchparams1;
	<span class="enscript-type">void</span> *a_searchparams2;
	<span class="enscript-type">struct</span> attrlist *a_searchattrs;
	uint32_t a_maxmatches;
	<span class="enscript-type">struct</span> timeval *a_timelimit;
	<span class="enscript-type">struct</span> attrlist *a_returnattrs;
	uint32_t *a_nummatches;
	uint32_t a_scriptcode;
	uint32_t a_options;
	<span class="enscript-type">struct</span> uio *a_uio;
	<span class="enscript-type">struct</span> searchstate *a_searchstate;
	vfs_context_t a_context;
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_SEARCHFS</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">void</span> *searchparams1, <span class="enscript-type">void</span> *searchparams2, <span class="enscript-type">struct</span> attrlist *searchattrs, uint32_t maxmatches, <span class="enscript-type">struct</span> timeval *timelimit, <span class="enscript-type">struct</span> attrlist *returnattrs, uint32_t *nummatches, uint32_t scriptcode, uint32_t options, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">struct</span> searchstate *searchstate, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_searchfs_args a;

	a.a_desc = &amp;vnop_searchfs_desc;
	a.a_vp = vp;
	a.a_searchparams1 = searchparams1;
	a.a_searchparams2 = searchparams2;
	a.a_searchattrs = searchattrs;
	a.a_maxmatches = maxmatches;
	a.a_timelimit = timelimit;
	a.a_returnattrs = returnattrs;
	a.a_nummatches = nummatches;
	a.a_scriptcode = scriptcode;
	a.a_options = options;
	a.a_uio = uio;
	a.a_searchstate = searchstate;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_searchfs_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(searchfs, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_SEARCHFS */</span>

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% copyfile fvp U U U
 *#% copyfile tdvp L U U
 *#% copyfile tvp X U U
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_copyfile_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_fvp;
	vnode_t a_tdvp;
	vnode_t a_tvp;
	<span class="enscript-type">struct</span> componentname *a_tcnp;
	<span class="enscript-type">int</span> a_mode;
	<span class="enscript-type">int</span> a_flags;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_COPYFILE</span>(<span class="enscript-type">struct</span> vnode *fvp, <span class="enscript-type">struct</span> vnode *tdvp, <span class="enscript-type">struct</span> vnode *tvp, <span class="enscript-type">struct</span> componentname *tcnp,
              <span class="enscript-type">int</span> mode, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_copyfile_args a;
	a.a_desc = &amp;vnop_copyfile_desc;
	a.a_fvp = fvp;
	a.a_tdvp = tdvp;
	a.a_tvp = tvp;
	a.a_tcnp = tcnp;
	a.a_mode = mode;
	a.a_flags = flags;
	a.a_context = ctx;
	_err = (*fvp-&gt;v_op[vnop_copyfile_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(copyfile, vnode_t, fvp);
	<span class="enscript-keyword">return</span> (_err);
}

errno_t
<span class="enscript-function-name">VNOP_GETXATTR</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, uio_t uio, size_t *size, <span class="enscript-type">int</span> options, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnop_getxattr_args a;
	<span class="enscript-type">int</span> error;

	a.a_desc = &amp;vnop_getxattr_desc;
	a.a_vp = vp;
	a.a_name = name;
	a.a_uio = uio;
	a.a_size = size;
	a.a_options = options;
	a.a_context = ctx;

	error = (*vp-&gt;v_op[vnop_getxattr_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(getxattr, vnode_t, vp);

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">VNOP_SETXATTR</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, uio_t uio, <span class="enscript-type">int</span> options, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnop_setxattr_args a;
	<span class="enscript-type">int</span> error;

	a.a_desc = &amp;vnop_setxattr_desc;
	a.a_vp = vp;
	a.a_name = name;
	a.a_uio = uio;
	a.a_options = options;
	a.a_context = ctx;

	error = (*vp-&gt;v_op[vnop_setxattr_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(setxattr, vnode_t, vp);

	<span class="enscript-keyword">if</span> (error == 0)
	        vnode_uncache_authorized_action(vp, KAUTH_INVALIDATE_CACHED_RIGHTS);

	post_event_if_success(vp, error, NOTE_ATTRIB);

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">VNOP_REMOVEXATTR</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> options, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnop_removexattr_args a;
	<span class="enscript-type">int</span> error;

	a.a_desc = &amp;vnop_removexattr_desc;
	a.a_vp = vp;
	a.a_name = name;
	a.a_options = options;
	a.a_context = ctx;

	error = (*vp-&gt;v_op[vnop_removexattr_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(removexattr, vnode_t, vp);

	post_event_if_success(vp, error, NOTE_ATTRIB);
	
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">VNOP_LISTXATTR</span>(vnode_t vp, uio_t uio, size_t *size, <span class="enscript-type">int</span> options, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> vnop_listxattr_args a;
	<span class="enscript-type">int</span> error;

	a.a_desc = &amp;vnop_listxattr_desc;
	a.a_vp = vp;
	a.a_uio = uio;
	a.a_size = size;
	a.a_options = options;
	a.a_context = ctx;

	error = (*vp-&gt;v_op[vnop_listxattr_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(listxattr, vnode_t, vp);

	<span class="enscript-keyword">return</span> (error);
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% blktooff vp = = =
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_blktooff_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	daddr64_t a_lblkno;
	off_t *a_offset;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_BLKTOOFF</span>(<span class="enscript-type">struct</span> vnode *vp, daddr64_t lblkno, off_t *offset)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_blktooff_args a;

	a.a_desc = &amp;vnop_blktooff_desc;
	a.a_vp = vp;
	a.a_lblkno = lblkno;
	a.a_offset = offset;

	_err = (*vp-&gt;v_op[vnop_blktooff_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(blktooff, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% offtoblk vp = = =
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_offtoblk_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	off_t a_offset;
	daddr64_t *a_lblkno;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_OFFTOBLK</span>(<span class="enscript-type">struct</span> vnode *vp, off_t offset, daddr64_t *lblkno)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_offtoblk_args a;

	a.a_desc = &amp;vnop_offtoblk_desc;
	a.a_vp = vp;
	a.a_offset = offset;
	a.a_lblkno = lblkno;

	_err = (*vp-&gt;v_op[vnop_offtoblk_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(offtoblk, vnode_t, vp);

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 *#
 *#% blockmap vp L L L
 *#
 */</span>
<span class="enscript-type">struct</span> vnop_blockmap_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	vnode_t a_vp;
	off_t a_foffset;
	size_t a_size;
	daddr64_t *a_bpn;
	size_t *a_run;
	<span class="enscript-type">void</span> *a_poff;
	<span class="enscript-type">int</span> a_flags;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_BLOCKMAP</span>(<span class="enscript-type">struct</span> vnode *vp, off_t foffset, size_t size, daddr64_t *bpn, size_t *run, <span class="enscript-type">void</span> *poff, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_blockmap_args a;
	size_t localrun = 0;

	<span class="enscript-keyword">if</span> (ctx == NULL) {
		ctx = vfs_context_current();
	}
	a.a_desc = &amp;vnop_blockmap_desc;
	a.a_vp = vp;
	a.a_foffset = foffset;
	a.a_size = size;
	a.a_bpn = bpn;
	a.a_run = &amp;localrun;
	a.a_poff = poff;
	a.a_flags = flags;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_blockmap_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(blockmap, vnode_t, vp);

	<span class="enscript-comment">/*
	 * We used a local variable to request information from the underlying
	 * filesystem about the length of the I/O run in question.  If
	 * we get malformed output from the filesystem, we cap it to the length
	 * requested, at most.  Update 'run' on the way out.
	 */</span>
	<span class="enscript-keyword">if</span> (_err == 0) {
		<span class="enscript-keyword">if</span> (localrun &gt; size) {
			localrun = size;
		}

		<span class="enscript-keyword">if</span> (run) {
			*run = localrun;
		}
	}

	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">struct</span> vnop_strategy_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	<span class="enscript-type">struct</span> buf *a_bp;
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_STRATEGY</span>(<span class="enscript-type">struct</span> buf *bp)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_strategy_args a;
	vnode_t vp = buf_vnode(bp);
	a.a_desc = &amp;vnop_strategy_desc;
	a.a_bp = bp;
	_err = (*vp-&gt;v_op[vnop_strategy_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(strategy, vnode_t, vp);
	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">struct</span> vnop_bwrite_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	buf_t a_bp;
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0*/</span>
errno_t 
<span class="enscript-function-name">VNOP_BWRITE</span>(<span class="enscript-type">struct</span> buf *bp)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_bwrite_args a;
	vnode_t vp = buf_vnode(bp);
	a.a_desc = &amp;vnop_bwrite_desc;
	a.a_bp = bp;
	_err = (*vp-&gt;v_op[vnop_bwrite_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(bwrite, vnode_t, vp);
	<span class="enscript-keyword">return</span> (_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">struct</span> vnop_kqfilt_add_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	<span class="enscript-type">struct</span> vnode *a_vp;
	<span class="enscript-type">struct</span> knote *a_kn;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span>
errno_t
<span class="enscript-function-name">VNOP_KQFILT_ADD</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> knote *kn, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_kqfilt_add_args a;

	a.a_desc = VDESC(vnop_kqfilt_add);
	a.a_vp = vp;
	a.a_kn = kn;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_kqfilt_add_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(kqfilt_add, vnode_t, vp);
	
	<span class="enscript-keyword">return</span>(_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">struct</span> vnop_kqfilt_remove_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	<span class="enscript-type">struct</span> vnode *a_vp;
	uintptr_t a_ident;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span>
errno_t
<span class="enscript-function-name">VNOP_KQFILT_REMOVE</span>(<span class="enscript-type">struct</span> vnode *vp, uintptr_t ident, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_kqfilt_remove_args a;

	a.a_desc = VDESC(vnop_kqfilt_remove);
	a.a_vp = vp;
	a.a_ident = ident;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_kqfilt_remove_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(kqfilt_remove, vnode_t, vp);

	<span class="enscript-keyword">return</span>(_err);
}

errno_t
<span class="enscript-function-name">VNOP_MONITOR</span>(vnode_t vp, uint32_t events, uint32_t flags, <span class="enscript-type">void</span> *handle, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_monitor_args a;

	a.a_desc = VDESC(vnop_monitor);
	a.a_vp = vp;
	a.a_events = events;
	a.a_flags = flags;
	a.a_handle = handle;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_monitor_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(monitor, vnode_t, vp);

	<span class="enscript-keyword">return</span>(_err);
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">struct</span> vnop_setlabel_args {
	<span class="enscript-type">struct</span> vnodeop_desc *a_desc;
	<span class="enscript-type">struct</span> vnode *a_vp;
	<span class="enscript-type">struct</span> label *a_vl;
	vfs_context_t a_context;
};
#<span class="enscript-reference">endif</span>
errno_t
<span class="enscript-function-name">VNOP_SETLABEL</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> label *label, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_setlabel_args a;

	a.a_desc = VDESC(vnop_setlabel);
	a.a_vp = vp;
	a.a_vl = label;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_setlabel_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(setlabel, vnode_t, vp);

	<span class="enscript-keyword">return</span>(_err);
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
<span class="enscript-comment">/*
 * Get a named streamed
 */</span>
errno_t 
<span class="enscript-function-name">VNOP_GETNAMEDSTREAM</span>(vnode_t vp, vnode_t *svpp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">enum</span> nsoperation operation, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_getnamedstream_args a;

	a.a_desc = &amp;vnop_getnamedstream_desc;
	a.a_vp = vp;
	a.a_svpp = svpp;
	a.a_name = name;
	a.a_operation = operation;
	a.a_flags = flags;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_getnamedstream_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(getnamedstream, vnode_t, vp);
	<span class="enscript-keyword">return</span> (_err);
}

<span class="enscript-comment">/*
 * Create a named streamed
 */</span>
errno_t 
<span class="enscript-function-name">VNOP_MAKENAMEDSTREAM</span>(vnode_t vp, vnode_t *svpp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_makenamedstream_args a;

	a.a_desc = &amp;vnop_makenamedstream_desc;
	a.a_vp = vp;
	a.a_svpp = svpp;
	a.a_name = name;
	a.a_flags = flags;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_makenamedstream_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(makenamedstream, vnode_t, vp);
	<span class="enscript-keyword">return</span> (_err);
}


<span class="enscript-comment">/*
 * Remove a named streamed
 */</span>
errno_t 
<span class="enscript-function-name">VNOP_REMOVENAMEDSTREAM</span>(vnode_t vp, vnode_t svp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> flags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> _err;
	<span class="enscript-type">struct</span> vnop_removenamedstream_args a;

	a.a_desc = &amp;vnop_removenamedstream_desc;
	a.a_vp = vp;
	a.a_svp = svp;
	a.a_name = name;
	a.a_flags = flags;
	a.a_context = ctx;

	_err = (*vp-&gt;v_op[vnop_removenamedstream_desc.vdesc_offset])(&amp;a);
	DTRACE_FSINFO(removenamedstream, vnode_t, vp);
	<span class="enscript-keyword">return</span> (_err);
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>