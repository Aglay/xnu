<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vfs_bio.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vfs_bio.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*-
 * Copyright (c) 1994 Christopher G. Demetriou
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)vfs_bio.c	8.6 (Berkeley) 1/11/94
 */</span>

<span class="enscript-comment">/*
 * Some references:
 *	Bach: The Design of the UNIX Operating System (Prentice Hall, 1986)
 *	Leffler, et al.: The Design and Implementation of the 4.3BSD
 *		UNIX Operating System (Addison Welley, 1989)
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/trace.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAGNOSTIC */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fslog.h&gt;</span>		<span class="enscript-comment">/* fslog_io_error() */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>	<span class="enscript-comment">/* thread_block() */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sdt.h&gt;</span>

<span class="enscript-type">int</span>	bcleanbuf(buf_t bp, boolean_t discard);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	brecover_data(buf_t bp);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">incore</span>(vnode_t vp, daddr64_t blkno);
<span class="enscript-comment">/* timeout is in msecs */</span>
<span class="enscript-type">static</span> buf_t	getnewbuf(<span class="enscript-type">int</span> slpflag, <span class="enscript-type">int</span> slptimeo, <span class="enscript-type">int</span> *queue);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bremfree_locked(buf_t bp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	buf_reassign(buf_t bp, vnode_t newvp);
<span class="enscript-type">static</span> errno_t	buf_acquire_locked(buf_t bp, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> slpflag, <span class="enscript-type">int</span> slptimeo);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	buf_iterprepare(vnode_t vp, <span class="enscript-type">struct</span> buflists *, <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	buf_itercomplete(vnode_t vp, <span class="enscript-type">struct</span> buflists *, <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">buffer_cache_gc</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> buf_t	buf_brelse_shadow(buf_t bp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	buf_free_meta_store(buf_t bp);

<span class="enscript-type">static</span> buf_t	buf_create_shadow_internal(buf_t bp, boolean_t force_copy,
					   uintptr_t external_storage, <span class="enscript-type">void</span> (*iodone)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *arg, <span class="enscript-type">int</span> priv);


__private_extern__ <span class="enscript-type">int</span>  bdwrite_internal(buf_t, <span class="enscript-type">int</span>);

<span class="enscript-comment">/* zone allocated buffer headers */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bufzoneinit(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bcleanbuf_thread_init(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	bcleanbuf_thread(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> zone_t	buf_hdr_zone;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	buf_hdr_count;


<span class="enscript-comment">/*
 * Definitions for the buffer hash lists.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BUFHASH</span>(dvp, lbn)	\
	(&amp;bufhashtbl[((<span class="enscript-type">long</span>)(dvp) / <span class="enscript-keyword">sizeof</span>(*(dvp)) + (<span class="enscript-type">int</span>)(lbn)) &amp; bufhash])
<span class="enscript-function-name">LIST_HEAD</span>(bufhashhdr, buf) *bufhashtbl, invalhash;
u_long	bufhash;

<span class="enscript-type">static</span> buf_t	incore_locked(vnode_t vp, daddr64_t blkno, <span class="enscript-type">struct</span> bufhashhdr *dp);

<span class="enscript-comment">/* Definitions for the buffer stats. */</span>
<span class="enscript-type">struct</span> bufstats bufstats;

<span class="enscript-comment">/* Number of delayed write buffers */</span>
<span class="enscript-type">long</span> nbdwrite = 0;
<span class="enscript-type">int</span> blaundrycnt = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> boot_nbuf_headers = 0;

<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(delayqueue, buf) delaybufqueue;

<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(ioqueue, buf) iobufqueue;
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(bqueues, buf) bufqueues[BQUEUES];
<span class="enscript-type">static</span> <span class="enscript-type">int</span> needbuffer;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> need_iobuffer;

<span class="enscript-type">static</span> lck_grp_t	*buf_mtx_grp;
<span class="enscript-type">static</span> lck_attr_t	*buf_mtx_attr;
<span class="enscript-type">static</span> lck_grp_attr_t   *buf_mtx_grp_attr;
<span class="enscript-type">static</span> lck_mtx_t	*iobuffer_mtxp;
<span class="enscript-type">static</span> lck_mtx_t	*buf_mtxp;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> buf_busycount;

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">buf_timestamp</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span>	timeval		t;
	microuptime(&amp;t);
	<span class="enscript-keyword">return</span> (t.tv_sec);
}

<span class="enscript-comment">/*
 * Insq/Remq for the buffer free lists.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">binsheadfree</span>(bp, dp, whichq)	do { \
				    TAILQ_INSERT_HEAD(dp, bp, b_freelist); \
				} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">binstailfree</span>(bp, dp, whichq)	do { \
				    TAILQ_INSERT_TAIL(dp, bp, b_freelist); \
				} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">BHASHENTCHECK</span>(bp)	\
	<span class="enscript-keyword">if</span> ((bp)-&gt;b_hash.le_prev != (<span class="enscript-type">struct</span> buf **)0xdeadbeef)	\
		panic(<span class="enscript-string">&quot;%p: b_hash.le_prev is not deadbeef&quot;</span>, (bp));

#<span class="enscript-reference">define</span> <span class="enscript-function-name">BLISTNONE</span>(bp)	\
	(bp)-&gt;b_hash.le_next = (<span class="enscript-type">struct</span> buf *)0;	\
	(bp)-&gt;b_hash.le_prev = (<span class="enscript-type">struct</span> buf **)0xdeadbeef;

<span class="enscript-comment">/*
 * Insq/Remq for the vnode usage lists.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">bufinsvn</span>(bp, dp)	LIST_INSERT_HEAD(dp, bp, b_vnbufs)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">bufremvn</span>(bp) {							\
	LIST_REMOVE(bp, b_vnbufs);					\
	(bp)-&gt;b_vnbufs.le_next = NOLIST;				\
}

<span class="enscript-comment">/*
 * Time in seconds before a buffer on a list is 
 * considered as a stale buffer 
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LRU_IS_STALE</span> 120 <span class="enscript-comment">/* default value for the LRU */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AGE_IS_STALE</span> 60  <span class="enscript-comment">/* default value for the AGE */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">META_IS_STALE</span> 180 <span class="enscript-comment">/* default value for the BQ_META */</span>

<span class="enscript-type">int</span> lru_is_stale = LRU_IS_STALE;
<span class="enscript-type">int</span> age_is_stale = AGE_IS_STALE;
<span class="enscript-type">int</span> meta_is_stale = META_IS_STALE;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAXLAUNDRY</span>	10

<span class="enscript-comment">/* LIST_INSERT_HEAD() with assertions */</span>
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">blistenterhead</span>(<span class="enscript-type">struct</span> bufhashhdr * head, buf_t bp)
{
	<span class="enscript-keyword">if</span> ((bp-&gt;b_hash.le_next = (head)-&gt;lh_first) != NULL)
		(head)-&gt;lh_first-&gt;b_hash.le_prev = &amp;(bp)-&gt;b_hash.le_next;
	(head)-&gt;lh_first = bp;
	bp-&gt;b_hash.le_prev = &amp;(head)-&gt;lh_first;
	<span class="enscript-keyword">if</span> (bp-&gt;b_hash.le_prev == (<span class="enscript-type">struct</span> buf **)0xdeadbeef) 
		panic(<span class="enscript-string">&quot;blistenterhead: le_prev is deadbeef&quot;</span>);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> 
<span class="enscript-function-name">binshash</span>(buf_t bp, <span class="enscript-type">struct</span> bufhashhdr *dp)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	buf_t	nbp;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAGNOSTIC */</span>

	BHASHENTCHECK(bp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	nbp = dp-&gt;lh_first;
	<span class="enscript-keyword">for</span>(; nbp != NULL; nbp = nbp-&gt;b_hash.le_next) {
		<span class="enscript-keyword">if</span>(nbp == bp) 
			panic(<span class="enscript-string">&quot;buf already in hashlist&quot;</span>);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAGNOSTIC */</span>

	blistenterhead(dp, bp);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> 
<span class="enscript-function-name">bremhash</span>(buf_t	bp) 
{
	<span class="enscript-keyword">if</span> (bp-&gt;b_hash.le_prev == (<span class="enscript-type">struct</span> buf **)0xdeadbeef) 
		panic(<span class="enscript-string">&quot;bremhash le_prev is deadbeef&quot;</span>);
	<span class="enscript-keyword">if</span> (bp-&gt;b_hash.le_next == bp) 
		panic(<span class="enscript-string">&quot;bremhash: next points to self&quot;</span>);

	<span class="enscript-keyword">if</span> (bp-&gt;b_hash.le_next != NULL)
		bp-&gt;b_hash.le_next-&gt;b_hash.le_prev = bp-&gt;b_hash.le_prev;
	*bp-&gt;b_hash.le_prev = (bp)-&gt;b_hash.le_next;
}

<span class="enscript-comment">/*
 * buf_mtxp held.
 */</span>
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bmovelaundry</span>(buf_t bp)
{
	bp-&gt;b_whichq = BQ_LAUNDRY;
	bp-&gt;b_timestamp = buf_timestamp();
	binstailfree(bp, &amp;bufqueues[BQ_LAUNDRY], BQ_LAUNDRY);
	blaundrycnt++;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">buf_release_credentials</span>(buf_t bp)
{
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(bp-&gt;b_rcred)) {
		kauth_cred_unref(&amp;bp-&gt;b_rcred);
	}
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(bp-&gt;b_wcred)) {
		kauth_cred_unref(&amp;bp-&gt;b_wcred);
	}
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">buf_valid</span>(buf_t bp) {

        <span class="enscript-keyword">if</span> ( (bp-&gt;b_flags &amp; (B_DONE | B_DELWRI)) )
	        <span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">buf_fromcache</span>(buf_t bp) {

        <span class="enscript-keyword">if</span> ( (bp-&gt;b_flags &amp; B_CACHE) )
	        <span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_markinvalid</span>(buf_t bp) {
  
        SET(bp-&gt;b_flags, B_INVAL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_markdelayed</span>(buf_t bp) {
  
	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;b_flags, B_DELWRI)) {
		SET(bp-&gt;b_flags, B_DELWRI);

		OSAddAtomicLong(1, &amp;nbdwrite);
		buf_reassign(bp, bp-&gt;b_vp);
	}
        SET(bp-&gt;b_flags, B_DONE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_markclean</span>(buf_t bp) {

	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_DELWRI)) {
		CLR(bp-&gt;b_flags, B_DELWRI);

		OSAddAtomicLong(-1, &amp;nbdwrite);
		buf_reassign(bp, bp-&gt;b_vp);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_markeintr</span>(buf_t bp) {
  
        SET(bp-&gt;b_flags, B_EINTR);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_markaged</span>(buf_t bp) {
  
        SET(bp-&gt;b_flags, B_AGE);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">buf_fua</span>(buf_t bp) {

        <span class="enscript-keyword">if</span> ((bp-&gt;b_flags &amp; B_FUA) == B_FUA)
	        <span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">buf_markfua</span>(buf_t bp) {

        SET(bp-&gt;b_flags, B_FUA);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
cpx_t <span class="enscript-function-name">bufattr_cpx</span>(bufattr_t bap)
{
	<span class="enscript-keyword">return</span> bap-&gt;ba_cpx;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">bufattr_setcpx</span>(bufattr_t bap, cpx_t cpx)
{
	bap-&gt;ba_cpx = cpx;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setcpoff</span> (buf_t bp, uint64_t foffset) {
	bp-&gt;b_attr.ba_cp_file_off = foffset;
}

uint64_t
<span class="enscript-function-name">bufattr_cpoff</span>(bufattr_t bap) {
	<span class="enscript-keyword">return</span> bap-&gt;ba_cp_file_off;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bufattr_setcpoff</span>(bufattr_t bap, uint64_t foffset) {
	bap-&gt;ba_cp_file_off = foffset;
}

#<span class="enscript-reference">else</span> // !<span class="enscript-variable-name">CONTECT_PROTECT</span>

uint64_t
<span class="enscript-function-name">bufattr_cpoff</span>(bufattr_t bap __unused) {
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bufattr_setcpoff</span>(__unused bufattr_t bap, __unused uint64_t foffset) {
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">struct</span> cpx *<span class="enscript-function-name">bufattr_cpx</span>(__unused bufattr_t bap)
{
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">bufattr_setcpx</span>(__unused bufattr_t bap, __unused <span class="enscript-type">struct</span> cpx *cpx)
{
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !CONFIG_PROTECT */</span>

bufattr_t
<span class="enscript-function-name">bufattr_alloc</span>() {
	bufattr_t bap;
	MALLOC(bap, bufattr_t, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bufattr), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (bap == NULL)
		<span class="enscript-keyword">return</span> NULL;

	bzero(bap, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bufattr));
	<span class="enscript-keyword">return</span> bap;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bufattr_free</span>(bufattr_t bap) {
	<span class="enscript-keyword">if</span> (bap)
		FREE(bap, M_TEMP);
}

bufattr_t
<span class="enscript-function-name">bufattr_dup</span>(bufattr_t bap) {
	bufattr_t new_bufattr;
	MALLOC(new_bufattr, bufattr_t, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bufattr), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_bufattr == NULL)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-comment">/* Copy the provided one into the new copy */</span>
	memcpy (new_bufattr, bap, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bufattr));
	<span class="enscript-keyword">return</span> new_bufattr;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bufattr_rawencrypted</span>(bufattr_t bap) {
	<span class="enscript-keyword">if</span> ( (bap-&gt;ba_flags &amp; BA_RAW_ENCRYPTED_IO) )
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bufattr_throttled</span>(bufattr_t bap) {
	<span class="enscript-keyword">return</span> (GET_BUFATTR_IO_TIER(bap));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bufattr_passive</span>(bufattr_t bap) {
	<span class="enscript-keyword">if</span> ( (bap-&gt;ba_flags &amp; BA_PASSIVE) )
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bufattr_nocache</span>(bufattr_t bap) {
	<span class="enscript-keyword">if</span> ( (bap-&gt;ba_flags &amp; BA_NOCACHE) )
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bufattr_meta</span>(bufattr_t bap) {
	<span class="enscript-keyword">if</span> ( (bap-&gt;ba_flags &amp; BA_META) )
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bufattr_markmeta</span>(bufattr_t bap) {
	SET(bap-&gt;ba_flags,  BA_META);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bufattr_delayidlesleep</span>(bufattr_t bap) 
{
	<span class="enscript-keyword">if</span> ( (bap-&gt;ba_flags &amp; BA_DELAYIDLESLEEP) )
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}

bufattr_t
<span class="enscript-function-name">buf_attr</span>(buf_t bp) {
	<span class="enscript-keyword">return</span> &amp;bp-&gt;b_attr;
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">buf_markstatic</span>(buf_t bp __unused) {
	SET(bp-&gt;b_flags, B_STATICCONTENT);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">buf_static</span>(buf_t bp) {
    <span class="enscript-keyword">if</span> ( (bp-&gt;b_flags &amp; B_STATICCONTENT) )
        <span class="enscript-keyword">return</span> 1;
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">bufattr_markgreedymode</span>(bufattr_t bap) {
	SET(bap-&gt;ba_flags, BA_GREEDY_MODE);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bufattr_greedymode</span>(bufattr_t bap) {
    <span class="enscript-keyword">if</span> ( (bap-&gt;ba_flags &amp; BA_GREEDY_MODE) )
        <span class="enscript-keyword">return</span> 1;
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">bufattr_markisochronous</span>(bufattr_t bap) {
	SET(bap-&gt;ba_flags, BA_ISOCHRONOUS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bufattr_isochronous</span>(bufattr_t bap) {
    <span class="enscript-keyword">if</span> ( (bap-&gt;ba_flags &amp; BA_ISOCHRONOUS) )
        <span class="enscript-keyword">return</span> 1;
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">bufattr_markquickcomplete</span>(bufattr_t bap) {
	SET(bap-&gt;ba_flags, BA_QUICK_COMPLETE);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bufattr_quickcomplete</span>(bufattr_t bap) {
    <span class="enscript-keyword">if</span> ( (bap-&gt;ba_flags &amp; BA_QUICK_COMPLETE) )
        <span class="enscript-keyword">return</span> 1;
    <span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">buf_error</span>(buf_t bp) {
        
        <span class="enscript-keyword">return</span> (bp-&gt;b_error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_seterror</span>(buf_t bp, errno_t error) {

        <span class="enscript-keyword">if</span> ((bp-&gt;b_error = error))
	        SET(bp-&gt;b_flags, B_ERROR);
	<span class="enscript-keyword">else</span>
	        CLR(bp-&gt;b_flags, B_ERROR);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setflags</span>(buf_t bp, int32_t flags) {

        SET(bp-&gt;b_flags, (flags &amp; BUF_X_WRFLAGS));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_clearflags</span>(buf_t bp, int32_t flags) {

        CLR(bp-&gt;b_flags, (flags &amp; BUF_X_WRFLAGS));
}

int32_t
<span class="enscript-function-name">buf_flags</span>(buf_t bp) {
        
        <span class="enscript-keyword">return</span> ((bp-&gt;b_flags &amp; BUF_X_RDFLAGS));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_reset</span>(buf_t bp, int32_t io_flags) {
        
        CLR(bp-&gt;b_flags, (B_READ | B_WRITE | B_ERROR | B_DONE | B_INVAL | B_ASYNC | B_NOCACHE | B_FUA));
	SET(bp-&gt;b_flags, (io_flags &amp; (B_ASYNC | B_READ | B_WRITE | B_NOCACHE)));

	bp-&gt;b_error = 0;
}

uint32_t
<span class="enscript-function-name">buf_count</span>(buf_t bp) {
        
        <span class="enscript-keyword">return</span> (bp-&gt;b_bcount);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setcount</span>(buf_t bp, uint32_t bcount) {
        
        bp-&gt;b_bcount = bcount;
}

uint32_t
<span class="enscript-function-name">buf_size</span>(buf_t bp) {
        
        <span class="enscript-keyword">return</span> (bp-&gt;b_bufsize);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setsize</span>(buf_t bp, uint32_t bufsize) {
        
        bp-&gt;b_bufsize = bufsize;
}

uint32_t
<span class="enscript-function-name">buf_resid</span>(buf_t bp) {
        
        <span class="enscript-keyword">return</span> (bp-&gt;b_resid);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setresid</span>(buf_t bp, uint32_t resid) {
        
        bp-&gt;b_resid = resid;
}

uint32_t
<span class="enscript-function-name">buf_dirtyoff</span>(buf_t bp) {

        <span class="enscript-keyword">return</span> (bp-&gt;b_dirtyoff);
}

uint32_t
<span class="enscript-function-name">buf_dirtyend</span>(buf_t bp) {

        <span class="enscript-keyword">return</span> (bp-&gt;b_dirtyend);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setdirtyoff</span>(buf_t bp, uint32_t dirtyoff) {
        
        bp-&gt;b_dirtyoff = dirtyoff;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setdirtyend</span>(buf_t bp, uint32_t dirtyend) {
        
        bp-&gt;b_dirtyend = dirtyend;
}

uintptr_t
<span class="enscript-function-name">buf_dataptr</span>(buf_t bp) {
        
        <span class="enscript-keyword">return</span> (bp-&gt;b_datap);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setdataptr</span>(buf_t bp, uintptr_t data) {
        
        bp-&gt;b_datap = data;
}

vnode_t
<span class="enscript-function-name">buf_vnode</span>(buf_t bp) {
        
        <span class="enscript-keyword">return</span> (bp-&gt;b_vp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setvnode</span>(buf_t bp, vnode_t vp) {
        
        bp-&gt;b_vp = vp;
}


<span class="enscript-type">void</span> *
<span class="enscript-function-name">buf_callback</span>(buf_t bp)
{
        <span class="enscript-keyword">if</span> ( !(bp-&gt;b_flags &amp; B_CALL) )
	        <span class="enscript-keyword">return</span> ((<span class="enscript-type">void</span> *) NULL);

	<span class="enscript-keyword">return</span> ((<span class="enscript-type">void</span> *)bp-&gt;b_iodone);
}


errno_t
<span class="enscript-function-name">buf_setcallback</span>(buf_t bp, <span class="enscript-type">void</span> (*callback)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *transaction)
{
	assert(!ISSET(bp-&gt;b_flags, B_FILTER) &amp;&amp; ISSET(bp-&gt;b_lflags, BL_BUSY));

	<span class="enscript-keyword">if</span> (callback)
	        bp-&gt;b_flags |= (B_CALL | B_ASYNC);
	<span class="enscript-keyword">else</span>
	        bp-&gt;b_flags &amp;= ~B_CALL;
	bp-&gt;b_transaction = transaction;
	bp-&gt;b_iodone = callback;

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">buf_setupl</span>(buf_t bp, upl_t upl, uint32_t offset)
{

        <span class="enscript-keyword">if</span> ( !(bp-&gt;b_lflags &amp; BL_IOBUF) )
	        <span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (upl)
	        bp-&gt;b_flags |= B_CLUSTER;
	<span class="enscript-keyword">else</span>
	        bp-&gt;b_flags &amp;= ~B_CLUSTER;
	bp-&gt;b_upl = upl;
	bp-&gt;b_uploffset = offset;

	<span class="enscript-keyword">return</span> (0);
}

buf_t
<span class="enscript-function-name">buf_clone</span>(buf_t bp, <span class="enscript-type">int</span> io_offset, <span class="enscript-type">int</span> io_size, <span class="enscript-type">void</span> (*iodone)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *arg)
{
        buf_t	io_bp;

	<span class="enscript-keyword">if</span> (io_offset &lt; 0 || io_size &lt; 0)
	        <span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>)(io_offset + io_size) &gt; (<span class="enscript-type">unsigned</span>)bp-&gt;b_bcount)
	        <span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_CLUSTER) {
	        <span class="enscript-keyword">if</span> (io_offset &amp;&amp; ((bp-&gt;b_uploffset + io_offset) &amp; PAGE_MASK))
		        <span class="enscript-keyword">return</span> (NULL);

	        <span class="enscript-keyword">if</span> (((bp-&gt;b_uploffset + io_offset + io_size) &amp; PAGE_MASK) &amp;&amp; ((io_offset + io_size) &lt; bp-&gt;b_bcount))
		        <span class="enscript-keyword">return</span> (NULL);
	}
	io_bp = alloc_io_buf(bp-&gt;b_vp, 0);

	io_bp-&gt;b_flags = bp-&gt;b_flags &amp; (B_COMMIT_UPL | B_META | B_PAGEIO | B_CLUSTER | B_PHYS | B_RAW | B_ASYNC | B_READ | B_FUA);

	<span class="enscript-keyword">if</span> (iodone) {
	        io_bp-&gt;b_transaction = arg;
		io_bp-&gt;b_iodone = iodone;
		io_bp-&gt;b_flags |= B_CALL;
	}
	<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_CLUSTER) {
	        io_bp-&gt;b_upl = bp-&gt;b_upl;
		io_bp-&gt;b_uploffset = bp-&gt;b_uploffset + io_offset;
	} <span class="enscript-keyword">else</span> {
	        io_bp-&gt;b_datap  = (uintptr_t)(((<span class="enscript-type">char</span> *)bp-&gt;b_datap) + io_offset);
	}
	io_bp-&gt;b_bcount = io_size;

	<span class="enscript-keyword">return</span> (io_bp);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">buf_shadow</span>(buf_t bp)
{
	<span class="enscript-keyword">if</span> (bp-&gt;b_lflags &amp; BL_SHADOW)
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}


buf_t
<span class="enscript-function-name">buf_create_shadow_priv</span>(buf_t bp, boolean_t force_copy, uintptr_t external_storage, <span class="enscript-type">void</span> (*iodone)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-keyword">return</span> (buf_create_shadow_internal(bp, force_copy, external_storage, iodone, arg, 1));
}

buf_t
<span class="enscript-function-name">buf_create_shadow</span>(buf_t bp, boolean_t force_copy, uintptr_t external_storage, <span class="enscript-type">void</span> (*iodone)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-keyword">return</span> (buf_create_shadow_internal(bp, force_copy, external_storage, iodone, arg, 0));
}


<span class="enscript-type">static</span> buf_t
<span class="enscript-function-name">buf_create_shadow_internal</span>(buf_t bp, boolean_t force_copy, uintptr_t external_storage, <span class="enscript-type">void</span> (*iodone)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *arg, <span class="enscript-type">int</span> priv)
{
        buf_t	io_bp;

	KERNEL_DEBUG(0xbbbbc000 | DBG_FUNC_START, bp, 0, 0, 0, 0);

	<span class="enscript-keyword">if</span> ( !(bp-&gt;b_flags &amp; B_META) || (bp-&gt;b_lflags &amp; BL_IOBUF)) {

		KERNEL_DEBUG(0xbbbbc000 | DBG_FUNC_END, bp, 0, 0, 0, 0);
		<span class="enscript-keyword">return</span> (NULL);
	}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BUF_MAKE_PRIVATE</span>
	<span class="enscript-keyword">if</span> (bp-&gt;b_shadow_ref &amp;&amp; bp-&gt;b_data_ref == 0 &amp;&amp; external_storage == 0)
		panic(<span class="enscript-string">&quot;buf_create_shadow: %p is in the private state (%d, %d)&quot;</span>, bp, bp-&gt;b_shadow_ref, bp-&gt;b_data_ref);
#<span class="enscript-reference">endif</span>
	io_bp = alloc_io_buf(bp-&gt;b_vp, priv);

	io_bp-&gt;b_flags = bp-&gt;b_flags &amp; (B_META | B_ZALLOC | B_ASYNC | B_READ | B_FUA);
	io_bp-&gt;b_blkno = bp-&gt;b_blkno;
	io_bp-&gt;b_lblkno = bp-&gt;b_lblkno;

	<span class="enscript-keyword">if</span> (iodone) {
	        io_bp-&gt;b_transaction = arg;
		io_bp-&gt;b_iodone = iodone;
		io_bp-&gt;b_flags |= B_CALL;
	}
	<span class="enscript-keyword">if</span> (force_copy == FALSE) {
		io_bp-&gt;b_bcount = bp-&gt;b_bcount;
		io_bp-&gt;b_bufsize = bp-&gt;b_bufsize;

		<span class="enscript-keyword">if</span> (external_storage) {
			io_bp-&gt;b_datap = external_storage;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BUF_MAKE_PRIVATE</span>
			io_bp-&gt;b_data_store = NULL;
#<span class="enscript-reference">endif</span>
		} <span class="enscript-keyword">else</span> {
			io_bp-&gt;b_datap = bp-&gt;b_datap;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BUF_MAKE_PRIVATE</span>
			io_bp-&gt;b_data_store = bp;
#<span class="enscript-reference">endif</span>
		}
		*(buf_t *)(&amp;io_bp-&gt;b_orig) = bp;

		lck_mtx_lock_spin(buf_mtxp);

		io_bp-&gt;b_lflags |= BL_SHADOW;
		io_bp-&gt;b_shadow = bp-&gt;b_shadow;
		bp-&gt;b_shadow = io_bp;
		bp-&gt;b_shadow_ref++;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BUF_MAKE_PRIVATE</span>
		<span class="enscript-keyword">if</span> (external_storage)
			io_bp-&gt;b_lflags |= BL_EXTERNAL;
		<span class="enscript-keyword">else</span>
			bp-&gt;b_data_ref++;
#<span class="enscript-reference">endif</span>
		lck_mtx_unlock(buf_mtxp);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (external_storage) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BUF_MAKE_PRIVATE</span>
			io_bp-&gt;b_lflags |= BL_EXTERNAL;
#<span class="enscript-reference">endif</span>
			io_bp-&gt;b_bcount = bp-&gt;b_bcount;
			io_bp-&gt;b_bufsize = bp-&gt;b_bufsize;
			io_bp-&gt;b_datap = external_storage;
		} <span class="enscript-keyword">else</span> {
			allocbuf(io_bp, bp-&gt;b_bcount);

			io_bp-&gt;b_lflags |= BL_IOBUF_ALLOC;
		}
		bcopy((caddr_t)bp-&gt;b_datap, (caddr_t)io_bp-&gt;b_datap, bp-&gt;b_bcount);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BUF_MAKE_PRIVATE</span>
		io_bp-&gt;b_data_store = NULL;
#<span class="enscript-reference">endif</span>
	}
	KERNEL_DEBUG(0xbbbbc000 | DBG_FUNC_END, bp, bp-&gt;b_shadow_ref, 0, io_bp, 0);

	<span class="enscript-keyword">return</span> (io_bp);
}


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BUF_MAKE_PRIVATE</span>
errno_t
<span class="enscript-function-name">buf_make_private</span>(buf_t bp)
{
	buf_t	ds_bp;
	buf_t	t_bp;
	<span class="enscript-type">struct</span> buf my_buf;

	KERNEL_DEBUG(0xbbbbc004 | DBG_FUNC_START, bp, bp-&gt;b_shadow_ref, 0, 0, 0);

	<span class="enscript-keyword">if</span> (bp-&gt;b_shadow_ref == 0 || bp-&gt;b_data_ref == 0 || ISSET(bp-&gt;b_lflags, BL_SHADOW)) {

		KERNEL_DEBUG(0xbbbbc004 | DBG_FUNC_END, bp, bp-&gt;b_shadow_ref, 0, EINVAL, 0);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	my_buf.b_flags = B_META;
	my_buf.b_datap = (uintptr_t)NULL;
	allocbuf(&amp;my_buf, bp-&gt;b_bcount);

	bcopy((caddr_t)bp-&gt;b_datap, (caddr_t)my_buf.b_datap, bp-&gt;b_bcount);

	lck_mtx_lock_spin(buf_mtxp);

	<span class="enscript-keyword">for</span> (t_bp = bp-&gt;b_shadow; t_bp; t_bp = t_bp-&gt;b_shadow) {
		<span class="enscript-keyword">if</span> ( !ISSET(bp-&gt;b_lflags, BL_EXTERNAL))
			<span class="enscript-keyword">break</span>;
	}
	ds_bp = t_bp;

	<span class="enscript-keyword">if</span> (ds_bp == NULL &amp;&amp; bp-&gt;b_data_ref)
		panic(<span class="enscript-string">&quot;buf_make_private: b_data_ref != 0 &amp;&amp; ds_bp == NULL&quot;</span>);

	<span class="enscript-keyword">if</span> (ds_bp &amp;&amp; (bp-&gt;b_data_ref == 0 || bp-&gt;b_shadow_ref == 0))
		panic(<span class="enscript-string">&quot;buf_make_private: ref_count == 0 &amp;&amp; ds_bp != NULL&quot;</span>);

	<span class="enscript-keyword">if</span> (ds_bp == NULL) {
		lck_mtx_unlock(buf_mtxp);

		buf_free_meta_store(&amp;my_buf);

		KERNEL_DEBUG(0xbbbbc004 | DBG_FUNC_END, bp, bp-&gt;b_shadow_ref, 0, EINVAL, 0);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">for</span> (t_bp = bp-&gt;b_shadow; t_bp; t_bp = t_bp-&gt;b_shadow) {
		<span class="enscript-keyword">if</span> ( !ISSET(t_bp-&gt;b_lflags, BL_EXTERNAL))
			t_bp-&gt;b_data_store = ds_bp;
	}
	ds_bp-&gt;b_data_ref = bp-&gt;b_data_ref;

	bp-&gt;b_data_ref = 0;
	bp-&gt;b_datap = my_buf.b_datap;

	lck_mtx_unlock(buf_mtxp);

	KERNEL_DEBUG(0xbbbbc004 | DBG_FUNC_END, bp, bp-&gt;b_shadow_ref, 0, 0, 0);
	<span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">endif</span>


<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setfilter</span>(buf_t bp, <span class="enscript-type">void</span> (*filter)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *transaction,
			  <span class="enscript-type">void</span> (**old_iodone)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> **old_transaction)
{
	assert(ISSET(bp-&gt;b_lflags, BL_BUSY));

	<span class="enscript-keyword">if</span> (old_iodone)
		*old_iodone = bp-&gt;b_iodone;
	<span class="enscript-keyword">if</span> (old_transaction)
		*old_transaction = bp-&gt;b_transaction;

	bp-&gt;b_transaction = transaction;
	bp-&gt;b_iodone = filter;
	<span class="enscript-keyword">if</span> (filter)
	        bp-&gt;b_flags |= B_FILTER;
	<span class="enscript-keyword">else</span>
	        bp-&gt;b_flags &amp;= ~B_FILTER;
}


daddr64_t
<span class="enscript-function-name">buf_blkno</span>(buf_t bp) {

        <span class="enscript-keyword">return</span> (bp-&gt;b_blkno);
}

daddr64_t
<span class="enscript-function-name">buf_lblkno</span>(buf_t bp) {

        <span class="enscript-keyword">return</span> (bp-&gt;b_lblkno);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setblkno</span>(buf_t bp, daddr64_t blkno) {

        bp-&gt;b_blkno = blkno;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setlblkno</span>(buf_t bp, daddr64_t lblkno) {

        bp-&gt;b_lblkno = lblkno;
}

dev_t
<span class="enscript-function-name">buf_device</span>(buf_t bp) {
        
        <span class="enscript-keyword">return</span> (bp-&gt;b_dev);
}

errno_t
<span class="enscript-function-name">buf_setdevice</span>(buf_t bp, vnode_t vp) {

        <span class="enscript-keyword">if</span> ((vp-&gt;v_type != VBLK) &amp;&amp; (vp-&gt;v_type != VCHR))
	        <span class="enscript-keyword">return</span> EINVAL;
	bp-&gt;b_dev = vp-&gt;v_rdev;

	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">void</span> *
<span class="enscript-function-name">buf_drvdata</span>(buf_t bp) {

        <span class="enscript-keyword">return</span> (bp-&gt;b_drvdata);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setdrvdata</span>(buf_t bp, <span class="enscript-type">void</span> *drvdata) {

        bp-&gt;b_drvdata = drvdata;
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">buf_fsprivate</span>(buf_t bp) {

        <span class="enscript-keyword">return</span> (bp-&gt;b_fsprivate);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_setfsprivate</span>(buf_t bp, <span class="enscript-type">void</span> *fsprivate) {

        bp-&gt;b_fsprivate = fsprivate;
}

kauth_cred_t
<span class="enscript-function-name">buf_rcred</span>(buf_t bp) {

        <span class="enscript-keyword">return</span> (bp-&gt;b_rcred);
}

kauth_cred_t
<span class="enscript-function-name">buf_wcred</span>(buf_t bp) {

        <span class="enscript-keyword">return</span> (bp-&gt;b_wcred);
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">buf_upl</span>(buf_t bp) {

        <span class="enscript-keyword">return</span> (bp-&gt;b_upl);
}

uint32_t
<span class="enscript-function-name">buf_uploffset</span>(buf_t bp) {

        <span class="enscript-keyword">return</span> ((uint32_t)(bp-&gt;b_uploffset));
}

proc_t
<span class="enscript-function-name">buf_proc</span>(buf_t bp) {

        <span class="enscript-keyword">return</span> (bp-&gt;b_proc);
}


errno_t
<span class="enscript-function-name">buf_map</span>(buf_t bp, caddr_t *io_addr)
{
        buf_t		real_bp;
        vm_offset_t	vaddr;
        kern_return_t	kret;

        <span class="enscript-keyword">if</span> ( !(bp-&gt;b_flags &amp; B_CLUSTER)) {
	        *io_addr = (caddr_t)bp-&gt;b_datap;
		<span class="enscript-keyword">return</span> (0);
	}
	real_bp = (buf_t)(bp-&gt;b_real_bp);

	<span class="enscript-keyword">if</span> (real_bp &amp;&amp; real_bp-&gt;b_datap) {
	        <span class="enscript-comment">/*
		 * b_real_bp is only valid if B_CLUSTER is SET
		 * if it's non-zero, than someone did a cluster_bp call
		 * if the backing physical pages were already mapped
		 * in before the call to cluster_bp (non-zero b_datap),
		 * than we just use that mapping
		 */</span>
	        *io_addr = (caddr_t)real_bp-&gt;b_datap;
		<span class="enscript-keyword">return</span> (0);
	}
	kret = ubc_upl_map(bp-&gt;b_upl, &amp;vaddr);    <span class="enscript-comment">/* Map it in */</span>

	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
	        *io_addr = NULL;

	        <span class="enscript-keyword">return</span>(ENOMEM);
	}
	vaddr += bp-&gt;b_uploffset;                                       

	*io_addr = (caddr_t)vaddr;

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">buf_unmap</span>(buf_t bp)
{
        buf_t		real_bp;
        kern_return_t	kret;

        <span class="enscript-keyword">if</span> ( !(bp-&gt;b_flags &amp; B_CLUSTER))
	        <span class="enscript-keyword">return</span> (0);
	<span class="enscript-comment">/*
	 * see buf_map for the explanation
	 */</span>
	real_bp = (buf_t)(bp-&gt;b_real_bp);

	<span class="enscript-keyword">if</span> (real_bp &amp;&amp; real_bp-&gt;b_datap)
	        <span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> ((bp-&gt;b_lflags &amp; BL_IOBUF) &amp;&amp;
	    ((bp-&gt;b_flags &amp; (B_PAGEIO | B_READ)) != (B_PAGEIO | B_READ))) {
	        <span class="enscript-comment">/*
		 * ignore pageins... the 'right' thing will
		 * happen due to the way we handle speculative
		 * clusters...
		 *
		 * when we commit these pages, we'll hit
		 * it with UPL_COMMIT_INACTIVE which
		 * will clear the reference bit that got
		 * turned on when we touched the mapping
		 */</span>
	        bp-&gt;b_flags |= B_AGE;
	}
	kret = ubc_upl_unmap(bp-&gt;b_upl);

	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
	        <span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_clear</span>(buf_t bp) {
        caddr_t baddr;
  
        <span class="enscript-keyword">if</span> (buf_map(bp, &amp;baddr) == 0) {
	        bzero(baddr, bp-&gt;b_bcount);
		buf_unmap(bp);
	}
	bp-&gt;b_resid = 0;
}

<span class="enscript-comment">/*
 * Read or write a buffer that is not contiguous on disk.
 * buffer is marked done/error at the conclusion
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">buf_strategy_fragmented</span>(vnode_t devvp, buf_t bp, off_t f_offset, size_t contig_bytes)
{
	vnode_t	vp = buf_vnode(bp);
	buf_t	io_bp;			 <span class="enscript-comment">/* For reading or writing a single block */</span>
	<span class="enscript-type">int</span>	io_direction;
	<span class="enscript-type">int</span>	io_resid;
	size_t	io_contig_bytes;
        daddr64_t io_blkno;
	<span class="enscript-type">int</span>	error = 0;
	<span class="enscript-type">int</span>	bmap_flags;

	<span class="enscript-comment">/*
	 * save our starting point... the bp was already mapped
	 * in buf_strategy before we got called
	 * no sense doing it again.
	 */</span>
	io_blkno = bp-&gt;b_blkno;
	<span class="enscript-comment">/*
	 * Make sure we redo this mapping for the next I/O
	 * i.e. this can never be a 'permanent' mapping
	 */</span>
	bp-&gt;b_blkno = bp-&gt;b_lblkno;
	
	<span class="enscript-comment">/*
	 * Get an io buffer to do the deblocking
	 */</span>
	io_bp = alloc_io_buf(devvp, 0);

	io_bp-&gt;b_lblkno = bp-&gt;b_lblkno;
	io_bp-&gt;b_datap  = bp-&gt;b_datap;
	io_resid	= bp-&gt;b_bcount;
        io_direction	= bp-&gt;b_flags &amp; B_READ;
	io_contig_bytes = contig_bytes;
	
	<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_READ)
	        bmap_flags = VNODE_READ;
	<span class="enscript-keyword">else</span>
	        bmap_flags = VNODE_WRITE;

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (io_blkno == -1)
		        <span class="enscript-comment">/*
			 * this is unexepected, but we'll allow for it
			 */</span>
		        bzero((caddr_t)io_bp-&gt;b_datap, (<span class="enscript-type">int</span>)io_contig_bytes);
		<span class="enscript-keyword">else</span> {
		        io_bp-&gt;b_bcount	 = io_contig_bytes;
			io_bp-&gt;b_bufsize = io_contig_bytes;
			io_bp-&gt;b_resid   = io_contig_bytes;
			io_bp-&gt;b_blkno   = io_blkno;

			buf_reset(io_bp, io_direction);

			<span class="enscript-comment">/*
			 * Call the device to do the I/O and wait for it.  Make sure the appropriate party is charged for write
			 */</span>

			<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;b_flags, B_READ))
			        OSAddAtomic(1, &amp;devvp-&gt;v_numoutput);

			<span class="enscript-keyword">if</span> ((error = VNOP_STRATEGY(io_bp)))
			        <span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> ((error = (<span class="enscript-type">int</span>)buf_biowait(io_bp)))
			        <span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (io_bp-&gt;b_resid) {
			        io_resid -= (io_contig_bytes - io_bp-&gt;b_resid);
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> ((io_resid -= io_contig_bytes) == 0)
		        <span class="enscript-keyword">break</span>;
		f_offset       += io_contig_bytes;
		io_bp-&gt;b_datap += io_contig_bytes;

		<span class="enscript-comment">/*
		 * Map the current position to a physical block number
		 */</span>
		<span class="enscript-keyword">if</span> ((error = VNOP_BLOCKMAP(vp, f_offset, io_resid, &amp;io_blkno, &amp;io_contig_bytes, NULL, bmap_flags, NULL)))
		        <span class="enscript-keyword">break</span>;
	}
	buf_free(io_bp);
	
	<span class="enscript-keyword">if</span> (error)
	        buf_seterror(bp, error);
	bp-&gt;b_resid = io_resid;
	<span class="enscript-comment">/*
	 * This I/O is now complete
	 */</span>
	buf_biodone(bp);

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * struct vnop_strategy_args {
 *      struct buf *a_bp;
 * } *ap;
 */</span>
errno_t
<span class="enscript-function-name">buf_strategy</span>(vnode_t devvp, <span class="enscript-type">void</span> *ap)
{
        buf_t	bp = ((<span class="enscript-type">struct</span> vnop_strategy_args *)ap)-&gt;a_bp;
	vnode_t	vp = bp-&gt;b_vp;
	<span class="enscript-type">int</span>	bmap_flags;
        errno_t error;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-type">int</span> dtrace_io_start_flag = 0;	 <span class="enscript-comment">/* We only want to trip the io:::start
					  * probe once, with the true physical
					  * block in place (b_blkno)
					  */</span>

#<span class="enscript-reference">endif</span>	

	<span class="enscript-keyword">if</span> (vp == NULL || vp-&gt;v_type == VCHR || vp-&gt;v_type == VBLK)
	        panic(<span class="enscript-string">&quot;buf_strategy: b_vp == NULL || vtype == VCHR | VBLK\n&quot;</span>);
	<span class="enscript-comment">/*
	 * associate the physical device with
	 * with this buf_t even if we don't
	 * end up issuing the I/O...
	 */</span>
	bp-&gt;b_dev = devvp-&gt;v_rdev;

	<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_READ)
	        bmap_flags = VNODE_READ;
	<span class="enscript-keyword">else</span>
	        bmap_flags = VNODE_WRITE;

        <span class="enscript-keyword">if</span> ( !(bp-&gt;b_flags &amp; B_CLUSTER)) {

	        <span class="enscript-keyword">if</span> ( (bp-&gt;b_upl) ) {
		        <span class="enscript-comment">/*
			 * we have a UPL associated with this bp
			 * go through cluster_bp which knows how
			 * to deal with filesystem block sizes
			 * that aren't equal to the page size
			 */</span>
			DTRACE_IO1(start, buf_t, bp);
		        <span class="enscript-keyword">return</span> (cluster_bp(bp));
		}
		<span class="enscript-keyword">if</span> (bp-&gt;b_blkno == bp-&gt;b_lblkno) {
		    off_t	f_offset;
			size_t 	contig_bytes;
		  
			<span class="enscript-keyword">if</span> ((error = VNOP_BLKTOOFF(vp, bp-&gt;b_lblkno, &amp;f_offset))) {
				DTRACE_IO1(start, buf_t, bp);
			        buf_seterror(bp, error);
				buf_biodone(bp);

			    <span class="enscript-keyword">return</span> (error);
			}

		<span class="enscript-keyword">if</span> ((error = VNOP_BLOCKMAP(vp, f_offset, bp-&gt;b_bcount, &amp;bp-&gt;b_blkno, &amp;contig_bytes, NULL, bmap_flags, NULL))) {
				DTRACE_IO1(start, buf_t, bp);
			        buf_seterror(bp, error);
				buf_biodone(bp);

			        <span class="enscript-keyword">return</span> (error);
			}

			DTRACE_IO1(start, buf_t, bp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
			dtrace_io_start_flag = 1;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>			

			<span class="enscript-keyword">if</span> ((bp-&gt;b_blkno == -1) || (contig_bytes == 0)) {
				<span class="enscript-comment">/* Set block number to force biodone later */</span>
				bp-&gt;b_blkno = -1;
			        buf_clear(bp);
			}
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((<span class="enscript-type">long</span>)contig_bytes &lt; bp-&gt;b_bcount) {
			        <span class="enscript-keyword">return</span> (buf_strategy_fragmented(devvp, bp, f_offset, contig_bytes));
			}
		}
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-keyword">if</span> (dtrace_io_start_flag == 0) {
			DTRACE_IO1(start, buf_t, bp);
			dtrace_io_start_flag = 1;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>
		
		<span class="enscript-keyword">if</span> (bp-&gt;b_blkno == -1) {
		        buf_biodone(bp);
			<span class="enscript-keyword">return</span> (0);
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-keyword">if</span> (dtrace_io_start_flag == 0)
		DTRACE_IO1(start, buf_t, bp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-comment">/* Capture f_offset in the bufattr*/</span>
	cpx_t cpx = bufattr_cpx(buf_attr(bp));
	<span class="enscript-keyword">if</span> (cpx) {
		<span class="enscript-comment">/* No need to go here for older EAs */</span>
		<span class="enscript-keyword">if</span>(cpx_use_offset_for_iv(cpx)) {
			off_t f_offset;
			<span class="enscript-keyword">if</span> ((error = VNOP_BLKTOOFF(bp-&gt;b_vp, bp-&gt;b_lblkno, &amp;f_offset)))
				<span class="enscript-keyword">return</span> error;

			<span class="enscript-comment">/* 
			 * Attach the file offset to this buffer.  The
			 * bufattr attributes will be passed down the stack
			 * until they reach IOFlashStorage.  IOFlashStorage
			 * will retain the offset in a local variable when it
			 * issues its I/Os to the NAND controller.	 
			 * 
			 * Note that LwVM may end up splitting this I/O 
			 * into sub-I/Os if it crosses a chunk boundary.  In this
			 * case, LwVM will update this field when it dispatches
			 * each I/O to IOFlashStorage.  But from our perspective
			 * we have only issued a single I/O.
			 */</span>
			buf_setcpoff(bp, f_offset);
			CP_DEBUG((CPDBG_OFFSET_IO | DBG_FUNC_NONE), (uint32_t) f_offset, (uint32_t) bp-&gt;b_lblkno, (uint32_t) bp-&gt;b_blkno, (uint32_t) bp-&gt;b_bcount, 0);
		}
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * we can issue the I/O because...
	 * either B_CLUSTER is set which
	 * means that the I/O is properly set
	 * up to be a multiple of the page size, or
	 * we were able to successfully set up the
	 * physical block mapping
	 */</span>
	error = VOCALL(devvp-&gt;v_op, VOFFSET(vnop_strategy), ap);
	DTRACE_FSINFO(strategy, vnode_t, vp);
	<span class="enscript-keyword">return</span> (error);
}



buf_t
<span class="enscript-function-name">buf_alloc</span>(vnode_t vp)
{
        <span class="enscript-keyword">return</span>(alloc_io_buf(vp, 0));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_free</span>(buf_t bp) {
        
        free_io_buf(bp);
}


<span class="enscript-comment">/*
 * iterate buffers for the specified vp. 
 *   if BUF_SCAN_DIRTY is set, do the dirty list
 *   if BUF_SCAN_CLEAN is set, do the clean list
 *   if neither flag is set, default to BUF_SCAN_DIRTY
 *   if BUF_NOTIFY_BUSY is set, call the callout function using a NULL bp for busy pages
 */</span>

<span class="enscript-type">struct</span> buf_iterate_info_t {
	<span class="enscript-type">int</span> flag;
	<span class="enscript-type">struct</span> buflists *listhead;
};

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_iterate</span>(vnode_t vp, <span class="enscript-type">int</span> (*callout)(buf_t, <span class="enscript-type">void</span> *), <span class="enscript-type">int</span> flags, <span class="enscript-type">void</span> *arg)
{
	buf_t 	bp;
	<span class="enscript-type">int</span>	retval;
	<span class="enscript-type">struct</span>	buflists local_iterblkhd;
	<span class="enscript-type">int</span>	lock_flags = BAC_NOWAIT | BAC_REMOVE;
	<span class="enscript-type">int</span>	notify_busy = flags &amp; BUF_NOTIFY_BUSY;
	<span class="enscript-type">struct</span> buf_iterate_info_t list[2];
	<span class="enscript-type">int</span>	num_lists, i;

	<span class="enscript-keyword">if</span> (flags &amp; BUF_SKIP_LOCKED)
	        lock_flags |= BAC_SKIP_LOCKED;
	<span class="enscript-keyword">if</span> (flags &amp; BUF_SKIP_NONLOCKED)
	        lock_flags |= BAC_SKIP_NONLOCKED;

	<span class="enscript-keyword">if</span> ( !(flags &amp; (BUF_SCAN_DIRTY | BUF_SCAN_CLEAN)))
	        flags |= BUF_SCAN_DIRTY;

	num_lists = 0;

	<span class="enscript-keyword">if</span> (flags &amp; BUF_SCAN_DIRTY) {
	        list[num_lists].flag = VBI_DIRTY;
		list[num_lists].listhead = &amp;vp-&gt;v_dirtyblkhd;
		num_lists++;
	}
	<span class="enscript-keyword">if</span> (flags &amp; BUF_SCAN_CLEAN) {
		list[num_lists].flag = VBI_CLEAN;
		list[num_lists].listhead = &amp;vp-&gt;v_cleanblkhd;
		num_lists++;
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt; num_lists; i++) {
		lck_mtx_lock(buf_mtxp);
	
		<span class="enscript-keyword">if</span> (buf_iterprepare(vp, &amp;local_iterblkhd, list[i].flag))  {
			lck_mtx_unlock(buf_mtxp);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">while</span> (!LIST_EMPTY(&amp;local_iterblkhd)) {
			bp = LIST_FIRST(&amp;local_iterblkhd);
			LIST_REMOVE(bp, b_vnbufs);
			LIST_INSERT_HEAD(list[i].listhead, bp, b_vnbufs);

			<span class="enscript-keyword">if</span> (buf_acquire_locked(bp, lock_flags, 0, 0)) {
				<span class="enscript-keyword">if</span> (notify_busy) {
					bp = NULL;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">continue</span>;
				}
			}

			lck_mtx_unlock(buf_mtxp);

			retval = callout(bp, arg);

			<span class="enscript-keyword">switch</span> (retval) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">BUF_RETURNED</span>:
				<span class="enscript-keyword">if</span> (bp)
					buf_brelse(bp);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">BUF_CLAIMED</span>:
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">BUF_RETURNED_DONE</span>:
				<span class="enscript-keyword">if</span> (bp)
					buf_brelse(bp);
				lck_mtx_lock(buf_mtxp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">BUF_CLAIMED_DONE</span>:
				lck_mtx_lock(buf_mtxp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			lck_mtx_lock(buf_mtxp);
		} <span class="enscript-comment">/* while list has more nodes */</span>
	  <span class="enscript-reference">out</span>:
		buf_itercomplete(vp, &amp;local_iterblkhd, list[i].flag);
		lck_mtx_unlock(buf_mtxp);
	} <span class="enscript-comment">/* for each list */</span>
} <span class="enscript-comment">/* buf_iterate */</span>


<span class="enscript-comment">/*
 * Flush out and invalidate all buffers associated with a vnode.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">buf_invalidateblks</span>(vnode_t vp, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> slpflag, <span class="enscript-type">int</span> slptimeo)
{
	buf_t	bp;
	<span class="enscript-type">int</span>	aflags;
	<span class="enscript-type">int</span>	error = 0;
	<span class="enscript-type">int</span>	must_rescan = 1;
	<span class="enscript-type">struct</span>	buflists local_iterblkhd;


	<span class="enscript-keyword">if</span> (LIST_EMPTY(&amp;vp-&gt;v_cleanblkhd) &amp;&amp; LIST_EMPTY(&amp;vp-&gt;v_dirtyblkhd))
		<span class="enscript-keyword">return</span> (0);

	lck_mtx_lock(buf_mtxp);

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (must_rescan == 0)
		        <span class="enscript-comment">/*
			 * the lists may not be empty, but all that's left at this
			 * point are metadata or B_LOCKED buffers which are being
			 * skipped... we know this because we made it through both
			 * the clean and dirty lists without dropping buf_mtxp...
			 * each time we drop buf_mtxp we bump &quot;must_rescan&quot;
			 */</span>
		        <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (LIST_EMPTY(&amp;vp-&gt;v_cleanblkhd) &amp;&amp; LIST_EMPTY(&amp;vp-&gt;v_dirtyblkhd))
		        <span class="enscript-keyword">break</span>;
		must_rescan = 0;
		<span class="enscript-comment">/*
		 * iterate the clean list
		 */</span>
		<span class="enscript-keyword">if</span> (buf_iterprepare(vp, &amp;local_iterblkhd, VBI_CLEAN)) {
		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">try_dirty_list</span>;
		}
		<span class="enscript-keyword">while</span> (!LIST_EMPTY(&amp;local_iterblkhd)) {

			bp = LIST_FIRST(&amp;local_iterblkhd);

			LIST_REMOVE(bp, b_vnbufs);
			LIST_INSERT_HEAD(&amp;vp-&gt;v_cleanblkhd, bp, b_vnbufs);

			<span class="enscript-comment">/*
			 * some filesystems distinguish meta data blocks with a negative logical block #
			 */</span>
			<span class="enscript-keyword">if</span> ((flags &amp; BUF_SKIP_META) &amp;&amp; (bp-&gt;b_lblkno &lt; 0 || ISSET(bp-&gt;b_flags, B_META)))
				<span class="enscript-keyword">continue</span>;

			aflags = BAC_REMOVE;

			<span class="enscript-keyword">if</span> ( !(flags &amp; BUF_INVALIDATE_LOCKED) )
				aflags |= BAC_SKIP_LOCKED;

			<span class="enscript-keyword">if</span> ( (error = (<span class="enscript-type">int</span>)buf_acquire_locked(bp, aflags, slpflag, slptimeo)) ) {
			        <span class="enscript-keyword">if</span> (error == EDEADLK)
				        <span class="enscript-comment">/*	
					 * this buffer was marked B_LOCKED... 
					 * we didn't drop buf_mtxp, so we
					 * we don't need to rescan
					 */</span>
				        <span class="enscript-keyword">continue</span>;
			        <span class="enscript-keyword">if</span> (error == EAGAIN) {
				        <span class="enscript-comment">/*
					 * found a busy buffer... we blocked and
					 * dropped buf_mtxp, so we're going to
					 * need to rescan after this pass is completed
					 */</span>
				        must_rescan++;
				        <span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-comment">/*
				 * got some kind of 'real' error out of the msleep
				 * in buf_acquire_locked, terminate the scan and return the error
				 */</span>
				buf_itercomplete(vp, &amp;local_iterblkhd, VBI_CLEAN);

				lck_mtx_unlock(buf_mtxp);
				<span class="enscript-keyword">return</span> (error);
			}
			lck_mtx_unlock(buf_mtxp);

			<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_LOCKED)
				KERNEL_DEBUG(0xbbbbc038, bp, 0, 0, 0, 0);

			CLR(bp-&gt;b_flags, B_LOCKED);
			SET(bp-&gt;b_flags, B_INVAL);
			buf_brelse(bp);

			lck_mtx_lock(buf_mtxp);

			<span class="enscript-comment">/*
			 * by dropping buf_mtxp, we allow new
			 * buffers to be added to the vnode list(s)
			 * we'll have to rescan at least once more
			 * if the queues aren't empty
			 */</span>
			must_rescan++;
		}
		buf_itercomplete(vp, &amp;local_iterblkhd, VBI_CLEAN);

<span class="enscript-reference">try_dirty_list</span>:
		<span class="enscript-comment">/*
		 * Now iterate on dirty blks
		 */</span>
		<span class="enscript-keyword">if</span> (buf_iterprepare(vp, &amp;local_iterblkhd, VBI_DIRTY)) {
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">while</span> (!LIST_EMPTY(&amp;local_iterblkhd)) {
			bp = LIST_FIRST(&amp;local_iterblkhd);

			LIST_REMOVE(bp, b_vnbufs);
			LIST_INSERT_HEAD(&amp;vp-&gt;v_dirtyblkhd, bp, b_vnbufs);

			<span class="enscript-comment">/*
			 * some filesystems distinguish meta data blocks with a negative logical block #
			 */</span>
			<span class="enscript-keyword">if</span> ((flags &amp; BUF_SKIP_META) &amp;&amp; (bp-&gt;b_lblkno &lt; 0 || ISSET(bp-&gt;b_flags, B_META)))
				<span class="enscript-keyword">continue</span>;

			aflags = BAC_REMOVE;

			<span class="enscript-keyword">if</span> ( !(flags &amp; BUF_INVALIDATE_LOCKED) )
				aflags |= BAC_SKIP_LOCKED;

			<span class="enscript-keyword">if</span> ( (error = (<span class="enscript-type">int</span>)buf_acquire_locked(bp, aflags, slpflag, slptimeo)) ) {
			        <span class="enscript-keyword">if</span> (error == EDEADLK)
				        <span class="enscript-comment">/*	
					 * this buffer was marked B_LOCKED... 
					 * we didn't drop buf_mtxp, so we
					 * we don't need to rescan
					 */</span>
				        <span class="enscript-keyword">continue</span>;
			        <span class="enscript-keyword">if</span> (error == EAGAIN) {
				        <span class="enscript-comment">/*
					 * found a busy buffer... we blocked and
					 * dropped buf_mtxp, so we're going to
					 * need to rescan after this pass is completed
					 */</span>
				        must_rescan++;
				        <span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-comment">/*
				 * got some kind of 'real' error out of the msleep
				 * in buf_acquire_locked, terminate the scan and return the error
				 */</span>
				buf_itercomplete(vp, &amp;local_iterblkhd, VBI_DIRTY);

				lck_mtx_unlock(buf_mtxp);
				<span class="enscript-keyword">return</span> (error);
			}
			lck_mtx_unlock(buf_mtxp);

			<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_LOCKED)
				KERNEL_DEBUG(0xbbbbc038, bp, 0, 0, 1, 0);

			CLR(bp-&gt;b_flags, B_LOCKED);
			SET(bp-&gt;b_flags, B_INVAL);

			<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_DELWRI) &amp;&amp; (flags &amp; BUF_WRITE_DATA))
				(<span class="enscript-type">void</span>) VNOP_BWRITE(bp);
			<span class="enscript-keyword">else</span>
				buf_brelse(bp);

			lck_mtx_lock(buf_mtxp);
			<span class="enscript-comment">/*
			 * by dropping buf_mtxp, we allow new
			 * buffers to be added to the vnode list(s)
			 * we'll have to rescan at least once more
			 * if the queues aren't empty
			 */</span>
			must_rescan++;
		}
		buf_itercomplete(vp, &amp;local_iterblkhd, VBI_DIRTY);
	}
	lck_mtx_unlock(buf_mtxp);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_flushdirtyblks</span>(vnode_t vp, <span class="enscript-type">int</span> wait, <span class="enscript-type">int</span> flags, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg) {

	(<span class="enscript-type">void</span>) buf_flushdirtyblks_skipinfo(vp, wait, flags, msg);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">buf_flushdirtyblks_skipinfo</span>(vnode_t vp, <span class="enscript-type">int</span> wait, <span class="enscript-type">int</span> flags, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg) {
	buf_t	bp;
	<span class="enscript-type">int</span>	writes_issued = 0;
	errno_t	error;
	<span class="enscript-type">int</span>	busy = 0;
	<span class="enscript-type">struct</span>	buflists local_iterblkhd;
	<span class="enscript-type">int</span>	lock_flags = BAC_NOWAIT | BAC_REMOVE;
	<span class="enscript-type">int</span> any_locked = 0;

	<span class="enscript-keyword">if</span> (flags &amp; BUF_SKIP_LOCKED)
	        lock_flags |= BAC_SKIP_LOCKED;
	<span class="enscript-keyword">if</span> (flags &amp; BUF_SKIP_NONLOCKED)
	        lock_flags |= BAC_SKIP_NONLOCKED;
<span class="enscript-reference">loop</span>:
	lck_mtx_lock(buf_mtxp);

	<span class="enscript-keyword">if</span> (buf_iterprepare(vp, &amp;local_iterblkhd, VBI_DIRTY) == 0)  {
	        <span class="enscript-keyword">while</span> (!LIST_EMPTY(&amp;local_iterblkhd)) {
			bp = LIST_FIRST(&amp;local_iterblkhd);
			LIST_REMOVE(bp, b_vnbufs);
			LIST_INSERT_HEAD(&amp;vp-&gt;v_dirtyblkhd, bp, b_vnbufs);

			<span class="enscript-keyword">if</span> ((error = buf_acquire_locked(bp, lock_flags, 0, 0)) == EBUSY) {
				busy++;
			}
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-comment">/* 
				 * If we passed in BUF_SKIP_LOCKED or BUF_SKIP_NONLOCKED,
				 * we may want to do somethign differently if a locked or unlocked
				 * buffer was encountered (depending on the arg specified).
				 * In this case, we know that one of those two was set, and the
				 * buf acquisition failed above.  
				 * 
				 * If it failed with EDEADLK, then save state which can be emitted
				 * later on to the caller.  Most callers should not care.
				 */</span>
				<span class="enscript-keyword">if</span> (error == EDEADLK) {
					any_locked++;
				}
				<span class="enscript-keyword">continue</span>;
			}
			lck_mtx_unlock(buf_mtxp);

			bp-&gt;b_flags &amp;= ~B_LOCKED;

			<span class="enscript-comment">/*
			 * Wait for I/O associated with indirect blocks to complete,
			 * since there is no way to quickly wait for them below.
			 */</span>
			<span class="enscript-keyword">if</span> ((bp-&gt;b_vp == vp) || (wait == 0))
			        (<span class="enscript-type">void</span>) buf_bawrite(bp);
			<span class="enscript-keyword">else</span>
			        (<span class="enscript-type">void</span>) VNOP_BWRITE(bp);
			writes_issued++;

			lck_mtx_lock(buf_mtxp);
		}
		buf_itercomplete(vp, &amp;local_iterblkhd, VBI_DIRTY);
	}
	lck_mtx_unlock(buf_mtxp);
	
	<span class="enscript-keyword">if</span> (wait) {
	        (<span class="enscript-type">void</span>)vnode_waitforwrites(vp, 0, 0, 0, msg);

		<span class="enscript-keyword">if</span> (vp-&gt;v_dirtyblkhd.lh_first &amp;&amp; busy) {
		        <span class="enscript-comment">/*
			 * we had one or more BUSY buffers on
			 * the dirtyblock list... most likely
			 * these are due to delayed writes that
			 * were moved to the bclean queue but
			 * have not yet been 'written'.
			 * if we issued some writes on the 
			 * previous pass, we try again immediately
			 * if we didn't, we'll sleep for some time
			 * to allow the state to change...
			 */</span>
		        <span class="enscript-keyword">if</span> (writes_issued == 0) {
			        (<span class="enscript-type">void</span>)tsleep((caddr_t)&amp;vp-&gt;v_numoutput,
					     PRIBIO + 1, <span class="enscript-string">&quot;vnode_flushdirtyblks&quot;</span>, hz/20);
			}
			writes_issued = 0;
			busy = 0;

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
		}
	}

	<span class="enscript-keyword">return</span> any_locked;
}


<span class="enscript-comment">/*
 * called with buf_mtxp held...
 * this lock protects the queue manipulation
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">buf_iterprepare</span>(vnode_t vp, <span class="enscript-type">struct</span> buflists *iterheadp, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> buflists * listheadp;

	<span class="enscript-keyword">if</span> (flags &amp; VBI_DIRTY)
		listheadp = &amp;vp-&gt;v_dirtyblkhd;
	<span class="enscript-keyword">else</span>
		listheadp = &amp;vp-&gt;v_cleanblkhd;
		
	<span class="enscript-keyword">while</span> (vp-&gt;v_iterblkflags &amp; VBI_ITER) 	{
	        vp-&gt;v_iterblkflags |= VBI_ITERWANT;
		msleep(&amp;vp-&gt;v_iterblkflags, buf_mtxp, 0, <span class="enscript-string">&quot;buf_iterprepare&quot;</span>, NULL);	
	}
	<span class="enscript-keyword">if</span> (LIST_EMPTY(listheadp)) {
	        LIST_INIT(iterheadp);
		<span class="enscript-keyword">return</span>(EINVAL);
	}
	vp-&gt;v_iterblkflags |= VBI_ITER;

	iterheadp-&gt;lh_first = listheadp-&gt;lh_first;
	listheadp-&gt;lh_first-&gt;b_vnbufs.le_prev = &amp;iterheadp-&gt;lh_first;	
	LIST_INIT(listheadp);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * called with buf_mtxp held...
 * this lock protects the queue manipulation
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">buf_itercomplete</span>(vnode_t vp, <span class="enscript-type">struct</span> buflists *iterheadp, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> buflists * listheadp;
	buf_t bp;

	<span class="enscript-keyword">if</span> (flags &amp; VBI_DIRTY)
		listheadp = &amp;vp-&gt;v_dirtyblkhd;
	<span class="enscript-keyword">else</span>
		listheadp = &amp;vp-&gt;v_cleanblkhd;

	<span class="enscript-keyword">while</span> (!LIST_EMPTY(iterheadp)) {
		bp = LIST_FIRST(iterheadp);
		LIST_REMOVE(bp, b_vnbufs);
		LIST_INSERT_HEAD(listheadp, bp, b_vnbufs);
	}
	vp-&gt;v_iterblkflags &amp;= ~VBI_ITER;

	<span class="enscript-keyword">if</span>  (vp-&gt;v_iterblkflags &amp; VBI_ITERWANT) 	{
		vp-&gt;v_iterblkflags &amp;= ~VBI_ITERWANT;
		wakeup(&amp;vp-&gt;v_iterblkflags);
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bremfree_locked</span>(buf_t bp)
{
	<span class="enscript-type">struct</span> bqueues *dp = NULL;
	<span class="enscript-type">int</span> whichq;

	whichq = bp-&gt;b_whichq;

	<span class="enscript-keyword">if</span> (whichq == -1) {
		<span class="enscript-keyword">if</span> (bp-&gt;b_shadow_ref == 0)
			panic(<span class="enscript-string">&quot;bremfree_locked: %p not on freelist&quot;</span>, bp);
		<span class="enscript-comment">/*
		 * there are clones pointing to 'bp'...
		 * therefore, it was not put on a freelist
		 * when buf_brelse was last called on 'bp'
		 */</span>
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/*
	 * We only calculate the head of the freelist when removing
	 * the last element of the list as that is the only time that
	 * it is needed (e.g. to reset the tail pointer).
	 *
	 * NB: This makes an assumption about how tailq's are implemented.
	 */</span>
	<span class="enscript-keyword">if</span> (bp-&gt;b_freelist.tqe_next == NULL) {
	        dp = &amp;bufqueues[whichq];

		<span class="enscript-keyword">if</span> (dp-&gt;tqh_last != &amp;bp-&gt;b_freelist.tqe_next)
			panic(<span class="enscript-string">&quot;bremfree: lost tail&quot;</span>);
	}
	TAILQ_REMOVE(dp, bp, b_freelist);

	<span class="enscript-keyword">if</span> (whichq == BQ_LAUNDRY)
	        blaundrycnt--;

	bp-&gt;b_whichq = -1;
	bp-&gt;b_timestamp = 0; 
	bp-&gt;b_shadow = 0;
}

<span class="enscript-comment">/*
 * Associate a buffer with a vnode.
 * buf_mtxp must be locked on entry
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bgetvp_locked</span>(vnode_t vp, buf_t bp)
{

	<span class="enscript-keyword">if</span> (bp-&gt;b_vp != vp)
		panic(<span class="enscript-string">&quot;bgetvp_locked: not free&quot;</span>);

	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VBLK || vp-&gt;v_type == VCHR)
		bp-&gt;b_dev = vp-&gt;v_rdev;
	<span class="enscript-keyword">else</span>
		bp-&gt;b_dev = NODEV;
	<span class="enscript-comment">/*
	 * Insert onto list for new vnode.
	 */</span>
	bufinsvn(bp, &amp;vp-&gt;v_cleanblkhd);
}

<span class="enscript-comment">/*
 * Disassociate a buffer from a vnode.
 * buf_mtxp must be locked on entry
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">brelvp_locked</span>(buf_t bp)
{
	<span class="enscript-comment">/*
	 * Delete from old vnode list, if on one.
	 */</span>
	<span class="enscript-keyword">if</span> (bp-&gt;b_vnbufs.le_next != NOLIST)
		bufremvn(bp);

	bp-&gt;b_vp = (vnode_t)NULL;
}

<span class="enscript-comment">/*
 * Reassign a buffer from one vnode to another.
 * Used to assign file specific control information
 * (indirect blocks) to the vnode to which they belong.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">buf_reassign</span>(buf_t bp, vnode_t newvp)
{
	<span class="enscript-type">struct</span> buflists *listheadp;

	<span class="enscript-keyword">if</span> (newvp == NULL) {
		printf(<span class="enscript-string">&quot;buf_reassign: NULL&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}
	lck_mtx_lock_spin(buf_mtxp);

	<span class="enscript-comment">/*
	 * Delete from old vnode list, if on one.
	 */</span>
	<span class="enscript-keyword">if</span> (bp-&gt;b_vnbufs.le_next != NOLIST)
		bufremvn(bp);
	<span class="enscript-comment">/*
	 * If dirty, put on list of dirty buffers;
	 * otherwise insert onto list of clean buffers.
	 */</span>
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_DELWRI))
		listheadp = &amp;newvp-&gt;v_dirtyblkhd;
	<span class="enscript-keyword">else</span>
		listheadp = &amp;newvp-&gt;v_cleanblkhd;
	bufinsvn(bp, listheadp);

	lck_mtx_unlock(buf_mtxp);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bufhdrinit</span>(buf_t bp)
{
	bzero((<span class="enscript-type">char</span> *)bp, <span class="enscript-keyword">sizeof</span> *bp);
	bp-&gt;b_dev = NODEV;
	bp-&gt;b_rcred = NOCRED;
	bp-&gt;b_wcred = NOCRED;
	bp-&gt;b_vnbufs.le_next = NOLIST;
	bp-&gt;b_flags = B_INVAL;

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Initialize buffers and hash links for buffers.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">bufinit</span>(<span class="enscript-type">void</span>)
{
	buf_t	bp;
	<span class="enscript-type">struct</span> bqueues *dp;
	<span class="enscript-type">int</span>	i;

	nbuf_headers = 0;
	<span class="enscript-comment">/* Initialize the buffer queues ('freelists') and the hash table */</span>
	<span class="enscript-keyword">for</span> (dp = bufqueues; dp &lt; &amp;bufqueues[BQUEUES]; dp++)
		TAILQ_INIT(dp);
	bufhashtbl = hashinit(nbuf_hashelements, M_CACHE, &amp;bufhash);

	buf_busycount = 0;

	<span class="enscript-comment">/* Initialize the buffer headers */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; max_nbuf_headers; i++) {
		nbuf_headers++;
		bp = &amp;buf_headers[i];
		bufhdrinit(bp);

		BLISTNONE(bp);
		dp = &amp;bufqueues[BQ_EMPTY];
		bp-&gt;b_whichq = BQ_EMPTY;
		bp-&gt;b_timestamp = buf_timestamp();
		binsheadfree(bp, dp, BQ_EMPTY);
		binshash(bp, &amp;invalhash);
	}
	boot_nbuf_headers = nbuf_headers;

	TAILQ_INIT(&amp;iobufqueue);
	TAILQ_INIT(&amp;delaybufqueue);

	<span class="enscript-keyword">for</span> (; i &lt; nbuf_headers + niobuf_headers; i++) {
		bp = &amp;buf_headers[i];
		bufhdrinit(bp);
		bp-&gt;b_whichq = -1;
		binsheadfree(bp, &amp;iobufqueue, -1);
	}

	<span class="enscript-comment">/*
	 * allocate lock group attribute and group
	 */</span>
	buf_mtx_grp_attr = lck_grp_attr_alloc_init();
	buf_mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;buffer cache&quot;</span>, buf_mtx_grp_attr);
		
	<span class="enscript-comment">/*
	 * allocate the lock attribute
	 */</span>
	buf_mtx_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/*
	 * allocate and initialize mutex's for the buffer and iobuffer pools
	 */</span>
	buf_mtxp	= lck_mtx_alloc_init(buf_mtx_grp, buf_mtx_attr);
	iobuffer_mtxp	= lck_mtx_alloc_init(buf_mtx_grp, buf_mtx_attr);

	<span class="enscript-keyword">if</span> (iobuffer_mtxp == NULL)
	        panic(<span class="enscript-string">&quot;couldn't create iobuffer mutex&quot;</span>);

	<span class="enscript-keyword">if</span> (buf_mtxp == NULL)
	        panic(<span class="enscript-string">&quot;couldn't create buf mutex&quot;</span>);

	<span class="enscript-comment">/*
	 * allocate and initialize cluster specific global locks...
	 */</span>
	cluster_init();

	printf(<span class="enscript-string">&quot;using %d buffer headers and %d cluster IO buffer headers\n&quot;</span>,
		nbuf_headers, niobuf_headers);

	<span class="enscript-comment">/* Set up zones used by the buffer cache */</span>
	bufzoneinit();

	<span class="enscript-comment">/* start the bcleanbuf() thread */</span>
	bcleanbuf_thread_init();

	<span class="enscript-comment">/* Register a callout for relieving vm pressure */</span>
	<span class="enscript-keyword">if</span> (vm_set_buffer_cleanup_callout(buffer_cache_gc) != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;Couldn't register buffer cache callout for vm pressure!\n&quot;</span>);
	}

}

<span class="enscript-comment">/*
 * Zones for the meta data buffers
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MINMETA</span> 512
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAXMETA</span> 8192

<span class="enscript-type">struct</span> meta_zone_entry {
	zone_t mz_zone;
	vm_size_t mz_size;
	vm_size_t mz_max;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *mz_name;
};

<span class="enscript-type">struct</span> meta_zone_entry meta_zones[] = {
	{NULL, (MINMETA * 1), 128 * (MINMETA * 1), <span class="enscript-string">&quot;buf.512&quot;</span> },
	{NULL, (MINMETA * 2),  64 * (MINMETA * 2), <span class="enscript-string">&quot;buf.1024&quot;</span> },
	{NULL, (MINMETA * 4),  16 * (MINMETA * 4), <span class="enscript-string">&quot;buf.2048&quot;</span> },
	{NULL, (MINMETA * 8), 512 * (MINMETA * 8), <span class="enscript-string">&quot;buf.4096&quot;</span> },
	{NULL, (MINMETA * 16), 512 * (MINMETA * 16), <span class="enscript-string">&quot;buf.8192&quot;</span> },
	{NULL, 0, 0, <span class="enscript-string">&quot;&quot;</span> } <span class="enscript-comment">/* End */</span>
};

<span class="enscript-comment">/*
 * Initialize the meta data zones
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bufzoneinit</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; meta_zones[i].mz_size != 0; i++) {
		meta_zones[i].mz_zone = 
				zinit(meta_zones[i].mz_size,
					meta_zones[i].mz_max,
					PAGE_SIZE,
					meta_zones[i].mz_name);
		zone_change(meta_zones[i].mz_zone, Z_CALLERACCT, FALSE);
	}
	buf_hdr_zone = zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> buf), 32, PAGE_SIZE, <span class="enscript-string">&quot;buf headers&quot;</span>);
	zone_change(buf_hdr_zone, Z_CALLERACCT, FALSE);
}

<span class="enscript-type">static</span> __inline__ zone_t
<span class="enscript-function-name">getbufzone</span>(size_t size)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> ((size % 512) || (size &lt; MINMETA) || (size &gt; MAXMETA))
		panic(<span class="enscript-string">&quot;getbufzone: incorect size = %lu&quot;</span>, size);

	<span class="enscript-keyword">for</span> (i = 0; meta_zones[i].mz_size != 0; i++) {
		<span class="enscript-keyword">if</span> (meta_zones[i].mz_size &gt;= size)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (meta_zones[i].mz_zone);
}



<span class="enscript-type">static</span> <span class="enscript-type">struct</span> buf *
<span class="enscript-function-name">bio_doread</span>(vnode_t vp, daddr64_t blkno, <span class="enscript-type">int</span> size, kauth_cred_t cred, <span class="enscript-type">int</span> async, <span class="enscript-type">int</span> queuetype)
{
	buf_t	bp;

	bp = buf_getblk(vp, blkno, size, 0, 0, queuetype);

	<span class="enscript-comment">/*
	 * If buffer does not have data valid, start a read.
	 * Note that if buffer is B_INVAL, buf_getblk() won't return it.
	 * Therefore, it's valid if it's I/O has completed or been delayed.
	 */</span>
	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;b_flags, (B_DONE | B_DELWRI))) {
		<span class="enscript-type">struct</span> proc *p;

		p = current_proc();

		<span class="enscript-comment">/* Start I/O for the buffer (keeping credentials). */</span>
		SET(bp-&gt;b_flags, B_READ | async);
		<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred) &amp;&amp; !IS_VALID_CRED(bp-&gt;b_rcred)) {
			kauth_cred_ref(cred);
			bp-&gt;b_rcred = cred;
		}

		VNOP_STRATEGY(bp);

		trace(TR_BREADMISS, pack(vp, size), blkno);

		<span class="enscript-comment">/* Pay for the read. */</span>
		<span class="enscript-keyword">if</span> (p &amp;&amp; p-&gt;p_stats) { 
			OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_inblock);		<span class="enscript-comment">/* XXX */</span>
		}

		<span class="enscript-keyword">if</span> (async) {
		        <span class="enscript-comment">/*
			 * since we asked for an ASYNC I/O
			 * the biodone will do the brelse
			 * we don't want to pass back a bp
			 * that we don't 'own'
			 */</span>
		        bp = NULL;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (async) {
		buf_brelse(bp);
		bp = NULL;
	}

	trace(TR_BREADHIT, pack(vp, size), blkno);

	<span class="enscript-keyword">return</span> (bp);
}

<span class="enscript-comment">/*
 * Perform the reads for buf_breadn() and buf_meta_breadn(). 
 * Trivial modification to the breada algorithm presented in Bach (p.55). 
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">do_breadn_for_type</span>(vnode_t vp, daddr64_t blkno, <span class="enscript-type">int</span> size, daddr64_t *rablks, <span class="enscript-type">int</span> *rasizes, 
		   <span class="enscript-type">int</span> nrablks, kauth_cred_t cred, buf_t *bpp, <span class="enscript-type">int</span> queuetype)
{
	buf_t	bp;
	<span class="enscript-type">int</span>	i;

	bp = *bpp = bio_doread(vp, blkno, size, cred, 0, queuetype);

	<span class="enscript-comment">/*
	 * For each of the read-ahead blocks, start a read, if necessary.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; nrablks; i++) {
		<span class="enscript-comment">/* If it's in the cache, just go on to next one. */</span>
		<span class="enscript-keyword">if</span> (incore(vp, rablks[i]))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* Get a buffer for the read-ahead block */</span>
		(<span class="enscript-type">void</span>) bio_doread(vp, rablks[i], rasizes[i], cred, B_ASYNC, queuetype);
	}

	<span class="enscript-comment">/* Otherwise, we had to start a read for it; wait until it's valid. */</span>
	<span class="enscript-keyword">return</span> (buf_biowait(bp));
}


<span class="enscript-comment">/*
 * Read a disk block.
 * This algorithm described in Bach (p.54).
 */</span>
errno_t
<span class="enscript-function-name">buf_bread</span>(vnode_t vp, daddr64_t blkno, <span class="enscript-type">int</span> size, kauth_cred_t cred, buf_t *bpp)
{
	buf_t	bp;

	<span class="enscript-comment">/* Get buffer for block. */</span>
	bp = *bpp = bio_doread(vp, blkno, size, cred, 0, BLK_READ);

	<span class="enscript-comment">/* Wait for the read to complete, and return result. */</span>
	<span class="enscript-keyword">return</span> (buf_biowait(bp));
}

<span class="enscript-comment">/*
 * Read a disk block. [bread() for meta-data]
 * This algorithm described in Bach (p.54).
 */</span>
errno_t
<span class="enscript-function-name">buf_meta_bread</span>(vnode_t vp, daddr64_t blkno, <span class="enscript-type">int</span> size, kauth_cred_t cred, buf_t *bpp)
{
	buf_t	bp;

	<span class="enscript-comment">/* Get buffer for block. */</span>
	bp = *bpp = bio_doread(vp, blkno, size, cred, 0, BLK_META);

	<span class="enscript-comment">/* Wait for the read to complete, and return result. */</span>
	<span class="enscript-keyword">return</span> (buf_biowait(bp));
}

<span class="enscript-comment">/*
 * Read-ahead multiple disk blocks. The first is sync, the rest async.
 */</span>
errno_t
<span class="enscript-function-name">buf_breadn</span>(vnode_t vp, daddr64_t blkno, <span class="enscript-type">int</span> size, daddr64_t *rablks, <span class="enscript-type">int</span> *rasizes, <span class="enscript-type">int</span> nrablks, kauth_cred_t cred, buf_t *bpp)
{
	<span class="enscript-keyword">return</span> (do_breadn_for_type(vp, blkno, size, rablks, rasizes, nrablks, cred, bpp, BLK_READ));
}

<span class="enscript-comment">/*
 * Read-ahead multiple disk blocks. The first is sync, the rest async.
 * [buf_breadn() for meta-data]
 */</span>
errno_t
<span class="enscript-function-name">buf_meta_breadn</span>(vnode_t vp, daddr64_t blkno, <span class="enscript-type">int</span> size, daddr64_t *rablks, <span class="enscript-type">int</span> *rasizes, <span class="enscript-type">int</span> nrablks, kauth_cred_t cred, buf_t *bpp)
{
	<span class="enscript-keyword">return</span> (do_breadn_for_type(vp, blkno, size, rablks, rasizes, nrablks, cred, bpp, BLK_META));
}

<span class="enscript-comment">/*
 * Block write.  Described in Bach (p.56)
 */</span>
errno_t
<span class="enscript-function-name">buf_bwrite</span>(buf_t bp)
{
	<span class="enscript-type">int</span>	sync, wasdelayed;
	errno_t	rv;
	proc_t	p = current_proc();
	vnode_t	vp = bp-&gt;b_vp;

	<span class="enscript-keyword">if</span> (bp-&gt;b_datap == 0) {
	        <span class="enscript-keyword">if</span> (brecover_data(bp) == 0)
		        <span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-comment">/* Remember buffer type, to switch on it later. */</span>
	sync = !ISSET(bp-&gt;b_flags, B_ASYNC);
	wasdelayed = ISSET(bp-&gt;b_flags, B_DELWRI);
	CLR(bp-&gt;b_flags, (B_READ | B_DONE | B_ERROR | B_DELWRI));

	<span class="enscript-keyword">if</span> (wasdelayed)
		OSAddAtomicLong(-1, &amp;nbdwrite);

	<span class="enscript-keyword">if</span> (!sync) {
		<span class="enscript-comment">/*
		 * If not synchronous, pay for the I/O operation and make
		 * sure the buf is on the correct vnode queue.  We have
		 * to do this now, because if we don't, the vnode may not
		 * be properly notified that its I/O has completed.
		 */</span>
		<span class="enscript-keyword">if</span> (wasdelayed)
			buf_reassign(bp, vp);
		<span class="enscript-keyword">else</span> 
			<span class="enscript-keyword">if</span> (p &amp;&amp; p-&gt;p_stats) {
				OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_oublock);	<span class="enscript-comment">/* XXX */</span>
			}
	}
	trace(TR_BUFWRITE, pack(vp, bp-&gt;b_bcount), bp-&gt;b_lblkno);

	<span class="enscript-comment">/* Initiate disk write.  Make sure the appropriate party is charged. */</span>

        OSAddAtomic(1, &amp;vp-&gt;v_numoutput);
	
	VNOP_STRATEGY(bp);

	<span class="enscript-keyword">if</span> (sync) {
		<span class="enscript-comment">/*
		 * If I/O was synchronous, wait for it to complete.
		 */</span>
		rv = buf_biowait(bp);

		<span class="enscript-comment">/*
		 * Pay for the I/O operation, if it's not been paid for, and
		 * make sure it's on the correct vnode queue. (async operatings
		 * were payed for above.)
		 */</span>
		<span class="enscript-keyword">if</span> (wasdelayed)
			buf_reassign(bp, vp);
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">if</span> (p &amp;&amp; p-&gt;p_stats) { 
				OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_oublock);	<span class="enscript-comment">/* XXX */</span>
			}

		<span class="enscript-comment">/* Release the buffer. */</span>
		<span class="enscript-comment">// XXXdbg - only if the unused bit is set
</span>		<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;b_flags, B_NORELSE)) {
		    buf_brelse(bp);
		} <span class="enscript-keyword">else</span> {
		    CLR(bp-&gt;b_flags, B_NORELSE);
		}

		<span class="enscript-keyword">return</span> (rv);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (0);
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vn_bwrite</span>(<span class="enscript-type">struct</span> vnop_bwrite_args *ap)
{
	<span class="enscript-keyword">return</span> (buf_bwrite(ap-&gt;a_bp));
}

<span class="enscript-comment">/*
 * Delayed write.
 *
 * The buffer is marked dirty, but is not queued for I/O.
 * This routine should be used when the buffer is expected
 * to be modified again soon, typically a small write that
 * partially fills a buffer.
 *
 * NB: magnetic tapes cannot be delayed; they must be
 * written in the order that the writes are requested.
 *
 * Described in Leffler, et al. (pp. 208-213).
 *
 * Note: With the ability to allocate additional buffer
 * headers, we can get in to the situation where &quot;too&quot; many 
 * buf_bdwrite()s can create situation where the kernel can create
 * buffers faster than the disks can service. Doing a buf_bawrite() in
 * cases where we have &quot;too many&quot; outstanding buf_bdwrite()s avoids that.
 */</span>
__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">bdwrite_internal</span>(buf_t bp, <span class="enscript-type">int</span> return_error)
{
	proc_t	p  = current_proc();
	vnode_t	vp = bp-&gt;b_vp;

	<span class="enscript-comment">/*
	 * If the block hasn't been seen before:
	 *	(1) Mark it as having been seen,
	 *	(2) Charge for the write.
	 *	(3) Make sure it's on its vnode's correct block list,
	 */</span>
	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;b_flags, B_DELWRI)) {
		SET(bp-&gt;b_flags, B_DELWRI);
		<span class="enscript-keyword">if</span> (p &amp;&amp; p-&gt;p_stats) { 
			OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_oublock);	<span class="enscript-comment">/* XXX */</span>
		}
		OSAddAtomicLong(1, &amp;nbdwrite);
		buf_reassign(bp, vp);
	}

	<span class="enscript-comment">/*
	 * if we're not LOCKED, but the total number of delayed writes
	 * has climbed above 75% of the total buffers in the system
	 * return an error if the caller has indicated that it can 
	 * handle one in this case, otherwise schedule the I/O now
	 * this is done to prevent us from allocating tons of extra
	 * buffers when dealing with virtual disks (i.e. DiskImages),
	 * because additional buffers are dynamically allocated to prevent
	 * deadlocks from occurring
	 *
	 * however, can't do a buf_bawrite() if the LOCKED bit is set because the
	 * buffer is part of a transaction and can't go to disk until
	 * the LOCKED bit is cleared.
	 */</span>
	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;b_flags, B_LOCKED) &amp;&amp; nbdwrite &gt; ((nbuf_headers/4)*3)) {
		<span class="enscript-keyword">if</span> (return_error)
			<span class="enscript-keyword">return</span> (EAGAIN);
		<span class="enscript-comment">/*
		 * If the vnode has &quot;too many&quot; write operations in progress
		 * wait for them to finish the IO
		 */</span>
		(<span class="enscript-type">void</span>)vnode_waitforwrites(vp, VNODE_ASYNC_THROTTLE, 0, 0, <span class="enscript-string">&quot;buf_bdwrite&quot;</span>);

		<span class="enscript-keyword">return</span> (buf_bawrite(bp));
	}
	 
	<span class="enscript-comment">/* Otherwise, the &quot;write&quot; is done, so mark and release the buffer. */</span>
	SET(bp-&gt;b_flags, B_DONE);
	buf_brelse(bp);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">buf_bdwrite</span>(buf_t bp)
{
	<span class="enscript-keyword">return</span> (bdwrite_internal(bp, 0));
}
 

<span class="enscript-comment">/*
 * Asynchronous block write; just an asynchronous buf_bwrite().
 *
 * Note: With the abilitty to allocate additional buffer
 * headers, we can get in to the situation where &quot;too&quot; many 
 * buf_bawrite()s can create situation where the kernel can create
 * buffers faster than the disks can service.
 * We limit the number of &quot;in flight&quot; writes a vnode can have to
 * avoid this.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bawrite_internal</span>(buf_t bp, <span class="enscript-type">int</span> throttle)
{
	vnode_t	vp = bp-&gt;b_vp;

	<span class="enscript-keyword">if</span> (vp) {
	        <span class="enscript-keyword">if</span> (throttle)
		        <span class="enscript-comment">/*
			 * If the vnode has &quot;too many&quot; write operations in progress
			 * wait for them to finish the IO
			 */</span>
		        (<span class="enscript-type">void</span>)vnode_waitforwrites(vp, VNODE_ASYNC_THROTTLE, 0, 0, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)<span class="enscript-string">&quot;buf_bawrite&quot;</span>);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vp-&gt;v_numoutput &gt;= VNODE_ASYNC_THROTTLE)
		        <span class="enscript-comment">/*
			 * return to the caller and 
			 * let him decide what to do
			 */</span>
		        <span class="enscript-keyword">return</span> (EWOULDBLOCK);
	}
	SET(bp-&gt;b_flags, B_ASYNC);

	<span class="enscript-keyword">return</span> (VNOP_BWRITE(bp));
}

errno_t
<span class="enscript-function-name">buf_bawrite</span>(buf_t bp)
{
	<span class="enscript-keyword">return</span> (bawrite_internal(bp, 1));
}



<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">buf_free_meta_store</span>(buf_t bp)
{
	<span class="enscript-keyword">if</span> (bp-&gt;b_bufsize) {
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_ZALLOC)) {
			zone_t z;

			z = getbufzone(bp-&gt;b_bufsize);
			zfree(z, (<span class="enscript-type">void</span> *)bp-&gt;b_datap);
		} <span class="enscript-keyword">else</span>
			kmem_free(kernel_map, bp-&gt;b_datap, bp-&gt;b_bufsize); 

		bp-&gt;b_datap = (uintptr_t)NULL;
		bp-&gt;b_bufsize = 0;
	}
}


<span class="enscript-type">static</span> buf_t
<span class="enscript-function-name">buf_brelse_shadow</span>(buf_t bp)
{
	buf_t	bp_head;
	buf_t	bp_temp;
	buf_t	bp_return = NULL;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BUF_MAKE_PRIVATE</span>
	buf_t	bp_data;
	<span class="enscript-type">int</span>	data_ref = 0;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> need_wakeup = 0;

	lck_mtx_lock_spin(buf_mtxp);

	__IGNORE_WCASTALIGN(bp_head = (buf_t)bp-&gt;b_orig);

	<span class="enscript-keyword">if</span> (bp_head-&gt;b_whichq != -1)
		panic(<span class="enscript-string">&quot;buf_brelse_shadow: bp_head on freelist %d\n&quot;</span>, bp_head-&gt;b_whichq);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BUF_MAKE_PRIVATE</span>
	<span class="enscript-keyword">if</span> (bp_data = bp-&gt;b_data_store) {
		bp_data-&gt;b_data_ref--;
		<span class="enscript-comment">/*
		 * snapshot the ref count so that we can check it 
		 * outside of the lock... we only want the guy going
		 * from 1 -&gt; 0 to try and release the storage
		 */</span>
		data_ref = bp_data-&gt;b_data_ref;
	}
#<span class="enscript-reference">endif</span>
	KERNEL_DEBUG(0xbbbbc008 | DBG_FUNC_START, bp, bp_head, bp_head-&gt;b_shadow_ref, 0, 0);

	bp_head-&gt;b_shadow_ref--;

	<span class="enscript-keyword">for</span> (bp_temp = bp_head; bp_temp &amp;&amp; bp != bp_temp-&gt;b_shadow; bp_temp = bp_temp-&gt;b_shadow);

	<span class="enscript-keyword">if</span> (bp_temp == NULL)
		panic(<span class="enscript-string">&quot;buf_brelse_shadow: bp not on list %p&quot;</span>, bp_head);

	bp_temp-&gt;b_shadow = bp_temp-&gt;b_shadow-&gt;b_shadow;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BUF_MAKE_PRIVATE</span>
	<span class="enscript-comment">/*
	 * we're about to free the current 'owner' of the data buffer and
	 * there is at least one other shadow buf_t still pointing at it
	 * so transfer it to the first shadow buf left in the chain
	 */</span>
	<span class="enscript-keyword">if</span> (bp == bp_data &amp;&amp; data_ref) {
		<span class="enscript-keyword">if</span> ((bp_data = bp_head-&gt;b_shadow) == NULL)
			panic(<span class="enscript-string">&quot;buf_brelse_shadow: data_ref mismatch bp(%p)&quot;</span>, bp);

		<span class="enscript-keyword">for</span> (bp_temp = bp_data; bp_temp; bp_temp = bp_temp-&gt;b_shadow)
			bp_temp-&gt;b_data_store = bp_data;
		bp_data-&gt;b_data_ref = data_ref;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (bp_head-&gt;b_shadow_ref == 0 &amp;&amp; bp_head-&gt;b_shadow)
		panic(<span class="enscript-string">&quot;buf_relse_shadow: b_shadow != NULL &amp;&amp; b_shadow_ref == 0  bp(%p)&quot;</span>, bp); 
	<span class="enscript-keyword">if</span> (bp_head-&gt;b_shadow_ref &amp;&amp; bp_head-&gt;b_shadow == 0)
		panic(<span class="enscript-string">&quot;buf_relse_shadow: b_shadow == NULL &amp;&amp; b_shadow_ref != 0  bp(%p)&quot;</span>, bp); 

	<span class="enscript-keyword">if</span> (bp_head-&gt;b_shadow_ref == 0) {
		<span class="enscript-keyword">if</span> (!ISSET(bp_head-&gt;b_lflags, BL_BUSY)) {

			CLR(bp_head-&gt;b_flags, B_AGE);
			bp_head-&gt;b_timestamp = buf_timestamp();

			<span class="enscript-keyword">if</span> (ISSET(bp_head-&gt;b_flags, B_LOCKED)) {
				bp_head-&gt;b_whichq = BQ_LOCKED;
				binstailfree(bp_head, &amp;bufqueues[BQ_LOCKED], BQ_LOCKED);
			} <span class="enscript-keyword">else</span> {
				bp_head-&gt;b_whichq = BQ_META;
				binstailfree(bp_head, &amp;bufqueues[BQ_META], BQ_META);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(bp_head-&gt;b_lflags, BL_WAITSHADOW)) {
			CLR(bp_head-&gt;b_lflags, BL_WAITSHADOW);

			bp_return = bp_head;
		}
		<span class="enscript-keyword">if</span> (ISSET(bp_head-&gt;b_lflags, BL_WANTED_REF)) {
			CLR(bp_head-&gt;b_lflags, BL_WANTED_REF);
			need_wakeup = 1;
		}
	}
	lck_mtx_unlock(buf_mtxp);

	<span class="enscript-keyword">if</span> (need_wakeup)
		wakeup(bp_head);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BUF_MAKE_PRIVATE</span>	
	<span class="enscript-keyword">if</span> (bp == bp_data &amp;&amp; data_ref == 0)
		buf_free_meta_store(bp);

	bp-&gt;b_data_store = NULL;
#<span class="enscript-reference">endif</span>
	KERNEL_DEBUG(0xbbbbc008 | DBG_FUNC_END, bp, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span> (bp_return);
}


<span class="enscript-comment">/*
 * Release a buffer on to the free lists.
 * Described in Bach (p. 46).
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_brelse</span>(buf_t bp)
{
	<span class="enscript-type">struct</span> bqueues *bufq;
	<span class="enscript-type">long</span>	whichq;
	upl_t	upl;
	<span class="enscript-type">int</span> need_wakeup = 0;
	<span class="enscript-type">int</span> need_bp_wakeup = 0;


	<span class="enscript-keyword">if</span> (bp-&gt;b_whichq != -1 || !(bp-&gt;b_lflags &amp; BL_BUSY))
	        panic(<span class="enscript-string">&quot;buf_brelse: bad buffer = %p\n&quot;</span>, bp);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	(<span class="enscript-type">void</span>) OSBacktrace(&amp;bp-&gt;b_stackbrelse[0], 6);

	bp-&gt;b_lastbrelse = current_thread();
	bp-&gt;b_tag = 0;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (bp-&gt;b_lflags &amp; BL_IOBUF) {
		buf_t	shadow_master_bp = NULL;

		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_lflags, BL_SHADOW))
			shadow_master_bp = buf_brelse_shadow(bp);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_lflags, BL_IOBUF_ALLOC))
			 buf_free_meta_store(bp);
	        free_io_buf(bp);

		<span class="enscript-keyword">if</span> (shadow_master_bp) {
			bp = shadow_master_bp;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish_shadow_master</span>;
		}
		<span class="enscript-keyword">return</span>;
	}

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 388)) | DBG_FUNC_START,
		     bp-&gt;b_lblkno * PAGE_SIZE, bp, bp-&gt;b_datap,
		     bp-&gt;b_flags, 0);

	trace(TR_BRELSE, pack(bp-&gt;b_vp, bp-&gt;b_bufsize), bp-&gt;b_lblkno);

	<span class="enscript-comment">/*
	 * if we're invalidating a buffer that has the B_FILTER bit
	 * set then call the b_iodone function so it gets cleaned
	 * up properly.
	 *
	 * the HFS journal code depends on this
	 */</span>
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_META) &amp;&amp; ISSET(bp-&gt;b_flags, B_INVAL)) {
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_FILTER)) {	<span class="enscript-comment">/* if necessary, call out */</span>
			<span class="enscript-type">void</span>	(*iodone_func)(<span class="enscript-type">struct</span> buf *, <span class="enscript-type">void</span> *) = bp-&gt;b_iodone;
			<span class="enscript-type">void</span> 	*arg = bp-&gt;b_transaction;

			CLR(bp-&gt;b_flags, B_FILTER);	<span class="enscript-comment">/* but note callout done */</span>
			bp-&gt;b_iodone = NULL;
			bp-&gt;b_transaction = NULL;

			<span class="enscript-keyword">if</span> (iodone_func == NULL) {
				panic(<span class="enscript-string">&quot;brelse: bp @ %p has NULL b_iodone!\n&quot;</span>, bp);
			}
			(*iodone_func)(bp, arg);
		}
	}
	<span class="enscript-comment">/*
	 * I/O is done. Cleanup the UPL state
	 */</span>
	upl = bp-&gt;b_upl;

	<span class="enscript-keyword">if</span> ( !ISSET(bp-&gt;b_flags, B_META) &amp;&amp; UBCINFOEXISTS(bp-&gt;b_vp) &amp;&amp; bp-&gt;b_bufsize) {
		kern_return_t kret;
		<span class="enscript-type">int</span>           upl_flags;

		<span class="enscript-keyword">if</span> (upl == NULL) {
		        <span class="enscript-keyword">if</span> ( !ISSET(bp-&gt;b_flags, B_INVAL)) {
				kret = ubc_create_upl(bp-&gt;b_vp, 
						      ubc_blktooff(bp-&gt;b_vp, bp-&gt;b_lblkno),
						      bp-&gt;b_bufsize, 
						      &amp;upl,
						      NULL,
						      UPL_PRECIOUS);

				<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
				        panic(<span class="enscript-string">&quot;brelse: Failed to create UPL&quot;</span>);
#<span class="enscript-reference">if</span>  <span class="enscript-variable-name">UPL_DEBUG</span>
				upl_ubc_alias_set(upl, (uintptr_t) bp, (uintptr_t) 5);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* UPL_DEBUG */</span>
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (bp-&gt;b_datap) {
			        kret = ubc_upl_unmap(upl);

				<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
				        panic(<span class="enscript-string">&quot;ubc_upl_unmap failed&quot;</span>);
				bp-&gt;b_datap = (uintptr_t)NULL;
			}
		}
		<span class="enscript-keyword">if</span> (upl) {
			<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; (B_ERROR | B_INVAL)) {
			        <span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; (B_READ | B_INVAL))
				        upl_flags = UPL_ABORT_DUMP_PAGES;
				<span class="enscript-keyword">else</span>
				        upl_flags = 0;

				ubc_upl_abort(upl, upl_flags);
			} <span class="enscript-keyword">else</span> {
			        <span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_DELWRI | B_WASDIRTY))
				        upl_flags = UPL_COMMIT_SET_DIRTY ;
				<span class="enscript-keyword">else</span>
				        upl_flags = UPL_COMMIT_CLEAR_DIRTY ;

				ubc_upl_commit_range(upl, 0, bp-&gt;b_bufsize, upl_flags |
						     UPL_COMMIT_INACTIVATE | UPL_COMMIT_FREE_ON_EMPTY);
			}
			bp-&gt;b_upl = NULL;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ( (upl) )
			panic(<span class="enscript-string">&quot;brelse: UPL set for non VREG; vp=%p&quot;</span>, bp-&gt;b_vp);
	}	

	<span class="enscript-comment">/*
	 * If it's locked, don't report an error; try again later.
	 */</span>
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, (B_LOCKED|B_ERROR)) == (B_LOCKED|B_ERROR))
		CLR(bp-&gt;b_flags, B_ERROR);
	<span class="enscript-comment">/*
	 * If it's not cacheable, or an error, mark it invalid.
	 */</span>
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, (B_NOCACHE|B_ERROR)))
		SET(bp-&gt;b_flags, B_INVAL);
	
	<span class="enscript-keyword">if</span> ((bp-&gt;b_bufsize &lt;= 0) || 
			ISSET(bp-&gt;b_flags, B_INVAL) || 
			(ISSET(bp-&gt;b_lflags, BL_WANTDEALLOC) &amp;&amp; !ISSET(bp-&gt;b_flags, B_DELWRI))) {

		boolean_t	delayed_buf_free_meta_store = FALSE;

		<span class="enscript-comment">/*
		 * If it's invalid or empty, dissociate it from its vnode,
		 * release its storage if B_META, and
		 * clean it up a bit and put it on the EMPTY queue
		 */</span>
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_DELWRI))
			OSAddAtomicLong(-1, &amp;nbdwrite);

		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_META)) {
			<span class="enscript-keyword">if</span> (bp-&gt;b_shadow_ref)
				delayed_buf_free_meta_store = TRUE;
			<span class="enscript-keyword">else</span>
				buf_free_meta_store(bp);
		}
		<span class="enscript-comment">/*
		 * nuke any credentials we were holding
		 */</span>
		buf_release_credentials(bp);

		lck_mtx_lock_spin(buf_mtxp);

		<span class="enscript-keyword">if</span> (bp-&gt;b_shadow_ref) {
			SET(bp-&gt;b_lflags, BL_WAITSHADOW);
			
			lck_mtx_unlock(buf_mtxp);
			
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">if</span> (delayed_buf_free_meta_store == TRUE) {

			lck_mtx_unlock(buf_mtxp);
<span class="enscript-reference">finish_shadow_master</span>:
			buf_free_meta_store(bp);

			lck_mtx_lock_spin(buf_mtxp);
		}
		CLR(bp-&gt;b_flags, (B_META | B_ZALLOC | B_DELWRI | B_LOCKED | B_AGE | B_ASYNC | B_NOCACHE | B_FUA));

		<span class="enscript-keyword">if</span> (bp-&gt;b_vp)
			brelvp_locked(bp);

		bremhash(bp);
		BLISTNONE(bp);
		binshash(bp, &amp;invalhash);

		bp-&gt;b_whichq = BQ_EMPTY;
		binsheadfree(bp, &amp;bufqueues[BQ_EMPTY], BQ_EMPTY);
	} <span class="enscript-keyword">else</span> {

		<span class="enscript-comment">/*
		 * It has valid data.  Put it on the end of the appropriate
		 * queue, so that it'll stick around for as long as possible.
		 */</span>
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_LOCKED))
			whichq = BQ_LOCKED;		<span class="enscript-comment">/* locked in core */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_META))
			whichq = BQ_META;		<span class="enscript-comment">/* meta-data */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_AGE))
			whichq = BQ_AGE;		<span class="enscript-comment">/* stale but valid data */</span>
		<span class="enscript-keyword">else</span>
			whichq = BQ_LRU;		<span class="enscript-comment">/* valid data */</span>
		bufq = &amp;bufqueues[whichq];

		bp-&gt;b_timestamp = buf_timestamp();

		lck_mtx_lock_spin(buf_mtxp);
		
		<span class="enscript-comment">/*
		 * the buf_brelse_shadow routine doesn't take 'ownership'
		 * of the parent buf_t... it updates state that is protected by
		 * the buf_mtxp, and checks for BL_BUSY to determine whether to
		 * put the buf_t back on a free list.  b_shadow_ref is protected
		 * by the lock, and since we have not yet cleared B_BUSY, we need
		 * to check it while holding the lock to insure that one of us
		 * puts this buf_t back on a free list when it is safe to do so
		 */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;b_shadow_ref == 0) {
			CLR(bp-&gt;b_flags, (B_AGE | B_ASYNC | B_NOCACHE));
			bp-&gt;b_whichq = whichq;
			binstailfree(bp, bufq, whichq);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * there are still cloned buf_t's pointing
			 * at this guy... need to keep it off the
			 * freelists until a buf_brelse is done on 
			 * the last clone
			 */</span>
			CLR(bp-&gt;b_flags, (B_ASYNC | B_NOCACHE));
		}
	}
	<span class="enscript-keyword">if</span> (needbuffer) {
	        <span class="enscript-comment">/*
		 * needbuffer is a global
		 * we're currently using buf_mtxp to protect it
		 * delay doing the actual wakeup until after
		 * we drop buf_mtxp
		 */</span>
		needbuffer = 0;
		need_wakeup = 1;
	}
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_lflags, BL_WANTED)) {
	        <span class="enscript-comment">/*	
		 * delay the actual wakeup until after we
		 * clear BL_BUSY and we've dropped buf_mtxp
		 */</span>
		need_bp_wakeup = 1;
	}
	<span class="enscript-comment">/*
	 * Unlock the buffer.
	 */</span>
	CLR(bp-&gt;b_lflags, (BL_BUSY | BL_WANTED));
	buf_busycount--;

	lck_mtx_unlock(buf_mtxp);

	<span class="enscript-keyword">if</span> (need_wakeup) {
	        <span class="enscript-comment">/*
		 * Wake up any processes waiting for any buffer to become free.
		 */</span>
	        wakeup(&amp;needbuffer);
	}
	<span class="enscript-keyword">if</span> (need_bp_wakeup) {
	        <span class="enscript-comment">/*
		 * Wake up any proceeses waiting for _this_ buffer to become free.
		 */</span>
	        wakeup(bp);
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 388)) | DBG_FUNC_END,
		     bp, bp-&gt;b_datap, bp-&gt;b_flags, 0, 0);
}

<span class="enscript-comment">/*
 * Determine if a block is in the cache.
 * Just look on what would be its hash chain.  If it's there, return
 * a pointer to it, unless it's marked invalid.  If it's marked invalid,
 * we normally don't return the buffer, unless the caller explicitly
 * wants us to.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">incore</span>(vnode_t vp, daddr64_t blkno)
{
        boolean_t retval;
	<span class="enscript-type">struct</span>	bufhashhdr *dp;

	dp = BUFHASH(vp, blkno);

	lck_mtx_lock_spin(buf_mtxp);

	<span class="enscript-keyword">if</span> (incore_locked(vp, blkno, dp))
	        retval = TRUE;
	<span class="enscript-keyword">else</span>
	        retval = FALSE;
	lck_mtx_unlock(buf_mtxp);

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">static</span> buf_t
<span class="enscript-function-name">incore_locked</span>(vnode_t vp, daddr64_t blkno, <span class="enscript-type">struct</span> bufhashhdr *dp)
{
	<span class="enscript-type">struct</span> buf *bp;

	<span class="enscript-comment">/* Search hash chain */</span>
	<span class="enscript-keyword">for</span> (bp = dp-&gt;lh_first; bp != NULL; bp = bp-&gt;b_hash.le_next) {
		<span class="enscript-keyword">if</span> (bp-&gt;b_lblkno == blkno &amp;&amp; bp-&gt;b_vp == vp &amp;&amp;
		    !ISSET(bp-&gt;b_flags, B_INVAL)) {
			<span class="enscript-keyword">return</span> (bp);
		}
	}
	<span class="enscript-keyword">return</span> (NULL);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_wait_for_shadow_io</span>(vnode_t vp, daddr64_t blkno)
{
	buf_t bp;
	<span class="enscript-type">struct</span>	bufhashhdr *dp;

	dp = BUFHASH(vp, blkno);

	lck_mtx_lock_spin(buf_mtxp);

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> ((bp = incore_locked(vp, blkno, dp)) == NULL)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (bp-&gt;b_shadow_ref == 0)
			<span class="enscript-keyword">break</span>;

		SET(bp-&gt;b_lflags, BL_WANTED_REF);

		(<span class="enscript-type">void</span>) msleep(bp, buf_mtxp, PSPIN | (PRIBIO+1), <span class="enscript-string">&quot;buf_wait_for_shadow&quot;</span>, NULL);
	}
	lck_mtx_unlock(buf_mtxp);
}
	
<span class="enscript-comment">/* XXX FIXME -- Update the comment to reflect the UBC changes (please) -- */</span>
<span class="enscript-comment">/*
 * Get a block of requested size that is associated with
 * a given vnode and block offset. If it is found in the
 * block cache, mark it as having been found, make it busy
 * and return it. Otherwise, return an empty block of the
 * correct size. It is up to the caller to insure that the
 * cached blocks be of the correct size.
 */</span>
buf_t
<span class="enscript-function-name">buf_getblk</span>(vnode_t vp, daddr64_t blkno, <span class="enscript-type">int</span> size, <span class="enscript-type">int</span> slpflag, <span class="enscript-type">int</span> slptimeo, <span class="enscript-type">int</span> operation)
{
	buf_t bp;
	<span class="enscript-type">int</span>   err;
	upl_t upl;
	upl_page_info_t *pl;
	kern_return_t kret;
	<span class="enscript-type">int</span> ret_only_valid;
	<span class="enscript-type">struct</span> timespec ts;
	<span class="enscript-type">int</span> upl_flags;
	<span class="enscript-type">struct</span>	bufhashhdr *dp;

	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 386)) | DBG_FUNC_START,
		     (uintptr_t)(blkno * PAGE_SIZE), size, operation, 0, 0);

	ret_only_valid = operation &amp; BLK_ONLYVALID;
	operation &amp;= ~BLK_ONLYVALID;
	dp = BUFHASH(vp, blkno);
<span class="enscript-reference">start</span>:
	lck_mtx_lock_spin(buf_mtxp);

	<span class="enscript-keyword">if</span> ((bp = incore_locked(vp, blkno, dp))) {
		<span class="enscript-comment">/*
		 * Found in the Buffer Cache
		 */</span>
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_lflags, BL_BUSY)) {
			<span class="enscript-comment">/*
			 * but is busy
			 */</span>
			<span class="enscript-keyword">switch</span> (operation) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">BLK_READ</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">BLK_WRITE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">BLK_META</span>:
				SET(bp-&gt;b_lflags, BL_WANTED);
				bufstats.bufs_busyincore++;

				<span class="enscript-comment">/*
				 * don't retake the mutex after being awakened...
				 * the time out is in msecs 
				 */</span>
				ts.tv_sec = (slptimeo/1000);
				ts.tv_nsec = (slptimeo % 1000) * 10  * NSEC_PER_USEC * 1000;

				KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 396)) | DBG_FUNC_NONE,
					     (uintptr_t)blkno, size, operation, 0, 0);

				err = msleep(bp, buf_mtxp, slpflag | PDROP | (PRIBIO + 1), <span class="enscript-string">&quot;buf_getblk&quot;</span>, &amp;ts);

				<span class="enscript-comment">/*
				 * Callers who call with PCATCH or timeout are
				 * willing to deal with the NULL pointer
				 */</span>
				<span class="enscript-keyword">if</span> (err &amp;&amp; ((slpflag &amp; PCATCH) || ((err == EWOULDBLOCK) &amp;&amp; slptimeo)))
					<span class="enscript-keyword">return</span> (NULL);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">start</span>;
				<span class="enscript-comment">/*NOTREACHED*/</span>
				<span class="enscript-keyword">break</span>;

			<span class="enscript-reference">default</span>:
			        <span class="enscript-comment">/*
				 * unknown operation requested
				 */</span>
				panic(<span class="enscript-string">&quot;getblk: paging or unknown operation for incore busy buffer - %x\n&quot;</span>, operation);
				<span class="enscript-comment">/*NOTREACHED*/</span>
				<span class="enscript-keyword">break</span>;
			}		
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * buffer in core and not busy
			 */</span>
			SET(bp-&gt;b_lflags, BL_BUSY);
			SET(bp-&gt;b_flags, B_CACHE);
			buf_busycount++;

			bremfree_locked(bp);
			bufstats.bufs_incore++;
			
			lck_mtx_unlock(buf_mtxp);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
			bp-&gt;b_owner = current_thread();
			bp-&gt;b_tag   = 1;
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> ( (bp-&gt;b_upl) )
			        panic(<span class="enscript-string">&quot;buffer has UPL, but not marked BUSY: %p&quot;</span>, bp);

			<span class="enscript-keyword">if</span> ( !ret_only_valid &amp;&amp; bp-&gt;b_bufsize != size)
			        allocbuf(bp, size);

			upl_flags = 0;
			<span class="enscript-keyword">switch</span> (operation) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">BLK_WRITE</span>:
				<span class="enscript-comment">/*
				 * &quot;write&quot; operation:  let the UPL subsystem
				 * know that we intend to modify the buffer
				 * cache pages we're gathering.
				 */</span>
				upl_flags |= UPL_WILL_MODIFY;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">BLK_READ</span>:
				upl_flags |= UPL_PRECIOUS;
			        <span class="enscript-keyword">if</span> (UBCINFOEXISTS(bp-&gt;b_vp) &amp;&amp; bp-&gt;b_bufsize) {
					kret = ubc_create_upl(vp,
							      ubc_blktooff(vp, bp-&gt;b_lblkno), 
							      bp-&gt;b_bufsize, 
							      &amp;upl, 
							      &amp;pl,
							      upl_flags);
					<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
					        panic(<span class="enscript-string">&quot;Failed to create UPL&quot;</span>);

					bp-&gt;b_upl = upl;

					<span class="enscript-keyword">if</span> (upl_valid_page(pl, 0)) {
					        <span class="enscript-keyword">if</span> (upl_dirty_page(pl, 0))
						        SET(bp-&gt;b_flags, B_WASDIRTY);
						<span class="enscript-keyword">else</span>
						        CLR(bp-&gt;b_flags, B_WASDIRTY);
					} <span class="enscript-keyword">else</span> 
					        CLR(bp-&gt;b_flags, (B_DONE | B_CACHE | B_WASDIRTY | B_DELWRI));

					kret = ubc_upl_map(upl, (vm_offset_t*)&amp;(bp-&gt;b_datap));

					<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
					        panic(<span class="enscript-string">&quot;getblk: ubc_upl_map() failed with (%d)&quot;</span>, kret);
				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">BLK_META</span>:
				<span class="enscript-comment">/*
				 * VM is not involved in IO for the meta data
				 * buffer already has valid data 
				 */</span>
				<span class="enscript-keyword">break</span>;

			<span class="enscript-reference">default</span>:
				panic(<span class="enscript-string">&quot;getblk: paging or unknown operation for incore buffer- %d\n&quot;</span>, operation);
				<span class="enscript-comment">/*NOTREACHED*/</span>
				<span class="enscript-keyword">break</span>;
			}
		}
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* not incore() */</span>
		<span class="enscript-type">int</span> queue = BQ_EMPTY; <span class="enscript-comment">/* Start with no preference */</span>
		
		<span class="enscript-keyword">if</span> (ret_only_valid) {
			lck_mtx_unlock(buf_mtxp);
			<span class="enscript-keyword">return</span> (NULL);
		}
		<span class="enscript-keyword">if</span> ((vnode_isreg(vp) == 0) || (UBCINFOEXISTS(vp) == 0) <span class="enscript-comment">/*|| (vnode_issystem(vp) == 1)*/</span>)
			operation = BLK_META;

		<span class="enscript-keyword">if</span> ((bp = getnewbuf(slpflag, slptimeo, &amp;queue)) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">start</span>;

		<span class="enscript-comment">/*
		 * getnewbuf may block for a number of different reasons...
		 * if it does, it's then possible for someone else to
		 * create a buffer for the same block and insert it into
		 * the hash... if we see it incore at this point we dump
		 * the buffer we were working on and start over
		 */</span>
		<span class="enscript-keyword">if</span> (incore_locked(vp, blkno, dp)) {
			SET(bp-&gt;b_flags, B_INVAL);
			binshash(bp, &amp;invalhash);

			lck_mtx_unlock(buf_mtxp);

			buf_brelse(bp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">start</span>;
		}
		<span class="enscript-comment">/*
		 * NOTE: YOU CAN NOT BLOCK UNTIL binshash() HAS BEEN
		 *       CALLED!  BE CAREFUL.
		 */</span>

		<span class="enscript-comment">/*
		 * mark the buffer as B_META if indicated
		 * so that when buffer is released it will goto META queue
		 */</span>
		<span class="enscript-keyword">if</span> (operation == BLK_META)
		        SET(bp-&gt;b_flags, B_META);

		bp-&gt;b_blkno = bp-&gt;b_lblkno = blkno;
		bp-&gt;b_vp = vp;

		<span class="enscript-comment">/*
		 * Insert in the hash so that incore() can find it 
		 */</span>
		binshash(bp, BUFHASH(vp, blkno)); 

		bgetvp_locked(vp, bp);

		lck_mtx_unlock(buf_mtxp);

		allocbuf(bp, size);

		upl_flags = 0;
		<span class="enscript-keyword">switch</span> (operation) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BLK_META</span>:
			<span class="enscript-comment">/*
			 * buffer data is invalid...
			 *
			 * I don't want to have to retake buf_mtxp,
			 * so the miss and vmhits counters are done
			 * with Atomic updates... all other counters
			 * in bufstats are protected with either
			 * buf_mtxp or iobuffer_mtxp
			 */</span>
		        OSAddAtomicLong(1, &amp;bufstats.bufs_miss);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BLK_WRITE</span>:
			<span class="enscript-comment">/*
			 * &quot;write&quot; operation:  let the UPL subsystem know
			 * that we intend to modify the buffer cache pages
			 * we're gathering.
			 */</span>
			upl_flags |= UPL_WILL_MODIFY;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BLK_READ</span>:
		  {     off_t	f_offset;
			size_t 	contig_bytes;
			<span class="enscript-type">int</span>	bmap_flags;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
			<span class="enscript-comment">/*
			 * Apple implemented file systems use UBC excludively; they should
			 * not call in here.&quot;
			 */</span>
			<span class="enscript-type">const</span> <span class="enscript-type">char</span>* excldfs[] = {<span class="enscript-string">&quot;hfs&quot;</span>, <span class="enscript-string">&quot;afpfs&quot;</span>, <span class="enscript-string">&quot;smbfs&quot;</span>, <span class="enscript-string">&quot;acfs&quot;</span>,
						 <span class="enscript-string">&quot;exfat&quot;</span>, <span class="enscript-string">&quot;msdos&quot;</span>, <span class="enscript-string">&quot;webdav&quot;</span>, NULL};

			<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; excldfs[i] != NULL; i++) {
				<span class="enscript-keyword">if</span> (vp-&gt;v_mount &amp;&amp;
				    !strcmp(vp-&gt;v_mount-&gt;mnt_vfsstat.f_fstypename,
						excldfs[i])) {
					panic(<span class="enscript-string">&quot;%s %s calls buf_getblk&quot;</span>,
						excldfs[i],
						operation == BLK_READ ? <span class="enscript-string">&quot;BLK_READ&quot;</span> : <span class="enscript-string">&quot;BLK_WRITE&quot;</span>);
				}
			}
#<span class="enscript-reference">endif</span>

			<span class="enscript-keyword">if</span> ( (bp-&gt;b_upl) )
				panic(<span class="enscript-string">&quot;bp already has UPL: %p&quot;</span>,bp);

			f_offset = ubc_blktooff(vp, blkno);

			upl_flags |= UPL_PRECIOUS;
			kret = ubc_create_upl(vp,
					      f_offset,
					      bp-&gt;b_bufsize, 
					      &amp;upl,
					      &amp;pl,
					      upl_flags);

			<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
				panic(<span class="enscript-string">&quot;Failed to create UPL&quot;</span>);
#<span class="enscript-reference">if</span>  <span class="enscript-variable-name">UPL_DEBUG</span>
			upl_ubc_alias_set(upl, (uintptr_t) bp, (uintptr_t) 4);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* UPL_DEBUG */</span>
			bp-&gt;b_upl = upl;

			<span class="enscript-keyword">if</span> (upl_valid_page(pl, 0)) {

			        <span class="enscript-keyword">if</span> (operation == BLK_READ)
				        bmap_flags = VNODE_READ;
				<span class="enscript-keyword">else</span>
				        bmap_flags = VNODE_WRITE;

				SET(bp-&gt;b_flags, B_CACHE | B_DONE);

			        OSAddAtomicLong(1, &amp;bufstats.bufs_vmhits);

				bp-&gt;b_validoff = 0;
				bp-&gt;b_dirtyoff = 0;

				<span class="enscript-keyword">if</span> (upl_dirty_page(pl, 0)) {
					<span class="enscript-comment">/* page is dirty */</span>
				        SET(bp-&gt;b_flags, B_WASDIRTY);

					bp-&gt;b_validend = bp-&gt;b_bcount;
					bp-&gt;b_dirtyend = bp-&gt;b_bcount;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* page is clean */</span>
					bp-&gt;b_validend = bp-&gt;b_bcount;
					bp-&gt;b_dirtyend = 0;
				}
				<span class="enscript-comment">/*
				 * try to recreate the physical block number associated with
				 * this buffer...
				 */</span>
				<span class="enscript-keyword">if</span> (VNOP_BLOCKMAP(vp, f_offset, bp-&gt;b_bcount, &amp;bp-&gt;b_blkno, &amp;contig_bytes, NULL, bmap_flags, NULL))
				        panic(<span class="enscript-string">&quot;getblk: VNOP_BLOCKMAP failed&quot;</span>);
				<span class="enscript-comment">/*
				 * if the extent represented by this buffer
				 * is not completely physically contiguous on
				 * disk, than we can't cache the physical mapping
				 * in the buffer header
				 */</span>
				<span class="enscript-keyword">if</span> ((<span class="enscript-type">long</span>)contig_bytes &lt; bp-&gt;b_bcount)
				        bp-&gt;b_blkno = bp-&gt;b_lblkno;
			} <span class="enscript-keyword">else</span> {
			        OSAddAtomicLong(1, &amp;bufstats.bufs_miss);
			}
			kret = ubc_upl_map(upl, (vm_offset_t *)&amp;(bp-&gt;b_datap));

			<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
			        panic(<span class="enscript-string">&quot;getblk: ubc_upl_map() failed with (%d)&quot;</span>, kret);
			<span class="enscript-keyword">break</span>;
		  }
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;getblk: paging or unknown operation - %x&quot;</span>, operation);
			<span class="enscript-comment">/*NOTREACHED*/</span>
			<span class="enscript-keyword">break</span>;
		}
	}
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 386)) | DBG_FUNC_END,
		     bp, bp-&gt;b_datap, bp-&gt;b_flags, 3, 0);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	(<span class="enscript-type">void</span>) OSBacktrace(&amp;bp-&gt;b_stackgetblk[0], 6);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (bp);
}

<span class="enscript-comment">/*
 * Get an empty, disassociated buffer of given size.
 */</span>
buf_t
<span class="enscript-function-name">buf_geteblk</span>(<span class="enscript-type">int</span> size)
{
	buf_t	bp = NULL;
	<span class="enscript-type">int</span> queue = BQ_EMPTY;

	<span class="enscript-keyword">do</span> {
		lck_mtx_lock_spin(buf_mtxp);

		bp = getnewbuf(0, 0, &amp;queue);
	} <span class="enscript-keyword">while</span> (bp == NULL);

	SET(bp-&gt;b_flags, (B_META|B_INVAL));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	assert(queue == BQ_EMPTY);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAGNOSTIC */</span>
	<span class="enscript-comment">/* XXX need to implement logic to deal with other queues */</span>

	binshash(bp, &amp;invalhash);
	bufstats.bufs_eblk++;

	lck_mtx_unlock(buf_mtxp);

	allocbuf(bp, size);

	<span class="enscript-keyword">return</span> (bp);
}

uint32_t
<span class="enscript-function-name">buf_redundancy_flags</span>(buf_t bp)
{
	<span class="enscript-keyword">return</span> bp-&gt;b_redundancy_flags;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_set_redundancy_flags</span>(buf_t bp, uint32_t flags)
{
	SET(bp-&gt;b_redundancy_flags, flags);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_clear_redundancy_flags</span>(buf_t bp, uint32_t flags)
{
	CLR(bp-&gt;b_redundancy_flags, flags);
}



<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">recycle_buf_from_pool</span>(<span class="enscript-type">int</span> nsize)
{
	buf_t	bp;
	<span class="enscript-type">void</span>	*ptr = NULL;

	lck_mtx_lock_spin(buf_mtxp);

	TAILQ_FOREACH(bp, &amp;bufqueues[BQ_META], b_freelist) {
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_DELWRI) || bp-&gt;b_bufsize != nsize)
			<span class="enscript-keyword">continue</span>;
		ptr = (<span class="enscript-type">void</span> *)bp-&gt;b_datap;
		bp-&gt;b_bufsize = 0;

		bcleanbuf(bp, TRUE);
		<span class="enscript-keyword">break</span>;
	}
	lck_mtx_unlock(buf_mtxp);

	<span class="enscript-keyword">return</span> (ptr);
}



<span class="enscript-type">int</span> zalloc_nopagewait_failed = 0;
<span class="enscript-type">int</span> recycle_buf_failed = 0;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">grab_memory_for_meta_buf</span>(<span class="enscript-type">int</span> nsize)
{
	zone_t z;
	<span class="enscript-type">void</span> *ptr;
	boolean_t was_vmpriv;

	z = getbufzone(nsize);

	<span class="enscript-comment">/*
	 * make sure we're NOT priviliged so that
	 * if a vm_page_grab is needed, it won't
	 * block if we're out of free pages... if
	 * it blocks, then we can't honor the
	 * nopagewait request
	 */</span>
	was_vmpriv = set_vm_privilege(FALSE);

	ptr = zalloc_nopagewait(z);

	<span class="enscript-keyword">if</span> (was_vmpriv == TRUE)
		set_vm_privilege(TRUE);

	<span class="enscript-keyword">if</span> (ptr == NULL) {

		zalloc_nopagewait_failed++;

		ptr = recycle_buf_from_pool(nsize);

		<span class="enscript-keyword">if</span> (ptr == NULL) {

			recycle_buf_failed++;

			<span class="enscript-keyword">if</span> (was_vmpriv == FALSE)
				set_vm_privilege(TRUE);

			ptr = zalloc(z);

			<span class="enscript-keyword">if</span> (was_vmpriv == FALSE)
				set_vm_privilege(FALSE);
		}
	}
	<span class="enscript-keyword">return</span> (ptr);
}

<span class="enscript-comment">/*
 * With UBC, there is no need to expand / shrink the file data 
 * buffer. The VM uses the same pages, hence no waste.
 * All the file data buffers can have one size.
 * In fact expand / shrink would be an expensive operation.
 *
 * Only exception to this is meta-data buffers. Most of the
 * meta data operations are smaller than PAGE_SIZE. Having the
 * meta-data buffers grow and shrink as needed, optimizes use
 * of the kernel wired memory.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">allocbuf</span>(buf_t bp, <span class="enscript-type">int</span> size)
{
	vm_size_t desired_size;

	desired_size = roundup(size, CLBYTES);

	<span class="enscript-keyword">if</span> (desired_size &lt; PAGE_SIZE)
		desired_size = PAGE_SIZE;
	<span class="enscript-keyword">if</span> (desired_size &gt; MAXBSIZE)
		panic(<span class="enscript-string">&quot;allocbuf: buffer larger than MAXBSIZE requested&quot;</span>);

	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_META)) {
		<span class="enscript-type">int</span>    nsize = roundup(size, MINMETA);

		<span class="enscript-keyword">if</span> (bp-&gt;b_datap) {
			vm_offset_t elem = (vm_offset_t)bp-&gt;b_datap;

			<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_ZALLOC)) {
			        <span class="enscript-keyword">if</span> (bp-&gt;b_bufsize &lt; nsize) {
				        zone_t zprev;

				        <span class="enscript-comment">/* reallocate to a bigger size */</span>

				        zprev = getbufzone(bp-&gt;b_bufsize);
					<span class="enscript-keyword">if</span> (nsize &lt;= MAXMETA) {
					        desired_size = nsize;

						<span class="enscript-comment">/* b_datap not really a ptr */</span>
						*(<span class="enscript-type">void</span> **)(&amp;bp-&gt;b_datap) = grab_memory_for_meta_buf(nsize);
					} <span class="enscript-keyword">else</span> {
					        bp-&gt;b_datap = (uintptr_t)NULL;
					        kmem_alloc_kobject(kernel_map, (vm_offset_t *)&amp;bp-&gt;b_datap, desired_size, VM_KERN_MEMORY_FILE);
						CLR(bp-&gt;b_flags, B_ZALLOC);
					}
					bcopy((<span class="enscript-type">void</span> *)elem, (caddr_t)bp-&gt;b_datap, bp-&gt;b_bufsize);
					zfree(zprev, (<span class="enscript-type">void</span> *)elem);
				} <span class="enscript-keyword">else</span> {
				        desired_size = bp-&gt;b_bufsize;
				}

			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> ((vm_size_t)bp-&gt;b_bufsize &lt; desired_size) {
					<span class="enscript-comment">/* reallocate to a bigger size */</span>
				        bp-&gt;b_datap = (uintptr_t)NULL;
					kmem_alloc_kobject(kernel_map, (vm_offset_t *)&amp;bp-&gt;b_datap, desired_size, VM_KERN_MEMORY_FILE);
					bcopy((<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)elem, (caddr_t)bp-&gt;b_datap, bp-&gt;b_bufsize);
					kmem_free(kernel_map, elem, bp-&gt;b_bufsize); 
				} <span class="enscript-keyword">else</span> {
					desired_size = bp-&gt;b_bufsize;
				}
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* new allocation */</span>
			<span class="enscript-keyword">if</span> (nsize &lt;= MAXMETA) {
				desired_size = nsize;

				<span class="enscript-comment">/* b_datap not really a ptr */</span>
				*(<span class="enscript-type">void</span> **)(&amp;bp-&gt;b_datap) = grab_memory_for_meta_buf(nsize);
				SET(bp-&gt;b_flags, B_ZALLOC);
			} <span class="enscript-keyword">else</span>
				kmem_alloc_kobject(kernel_map, (vm_offset_t *)&amp;bp-&gt;b_datap, desired_size, VM_KERN_MEMORY_FILE);
		}

		<span class="enscript-keyword">if</span> (bp-&gt;b_datap == 0)
		        panic(<span class="enscript-string">&quot;allocbuf: NULL b_datap&quot;</span>);
	}
	bp-&gt;b_bufsize = desired_size;
	bp-&gt;b_bcount = size;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 *	Get a new buffer from one of the free lists.
 *
 *	Request for a queue is passes in. The queue from which the buffer was taken
 *	from is returned. Out of range queue requests get BQ_EMPTY. Request for
 *	BQUEUE means no preference. Use heuristics in that case.
 *	Heuristics is as follows:
 *	Try BQ_AGE, BQ_LRU, BQ_EMPTY, BQ_META in that order.
 *	If none available block till one is made available.
 *	If buffers available on both BQ_AGE and BQ_LRU, check the timestamps.
 *	Pick the most stale buffer.
 *	If found buffer was marked delayed write, start the async. write
 *	and restart the search.
 *	Initialize the fields and disassociate the buffer from the vnode.
 *	Remove the buffer from the hash. Return the buffer and the queue
 *	on which it was found.
 *
 *	buf_mtxp is held upon entry
 *	returns with buf_mtxp locked if new buf available
 *	returns with buf_mtxp UNlocked if new buf NOT available
 */</span>

<span class="enscript-type">static</span> buf_t
<span class="enscript-function-name">getnewbuf</span>(<span class="enscript-type">int</span> slpflag, <span class="enscript-type">int</span> slptimeo, <span class="enscript-type">int</span> * queue)
{
	buf_t	bp;
	buf_t	lru_bp;
	buf_t	age_bp;
	buf_t	meta_bp;
	<span class="enscript-type">int</span>	age_time, lru_time, bp_time, meta_time;
	<span class="enscript-type">int</span>	req = *queue;	<span class="enscript-comment">/* save it for restarts */</span>
	<span class="enscript-type">struct</span> timespec ts;

<span class="enscript-reference">start</span>:
	<span class="enscript-comment">/*
	 * invalid request gets empty queue
	 */</span>
	<span class="enscript-keyword">if</span> ((*queue &gt;= BQUEUES) || (*queue &lt; 0)
		|| (*queue == BQ_LAUNDRY) || (*queue == BQ_LOCKED))
		*queue = BQ_EMPTY;


	<span class="enscript-keyword">if</span> (*queue == BQ_EMPTY &amp;&amp; (bp = bufqueues[*queue].tqh_first))
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;

	<span class="enscript-comment">/*
	 * need to grow number of bufs, add another one rather than recycling
	 */</span>
	<span class="enscript-keyword">if</span> (nbuf_headers &lt; max_nbuf_headers) {
		<span class="enscript-comment">/*
		 * Increment  count now as lock 
		 * is dropped for allocation.
		 * That avoids over commits
		 */</span>
		nbuf_headers++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">add_newbufs</span>;
	}
	<span class="enscript-comment">/* Try for the requested queue first */</span>
	bp = bufqueues[*queue].tqh_first;
	<span class="enscript-keyword">if</span> (bp)
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;

	<span class="enscript-comment">/* Unable to use requested queue */</span>
	age_bp = bufqueues[BQ_AGE].tqh_first;
	lru_bp = bufqueues[BQ_LRU].tqh_first;
	meta_bp = bufqueues[BQ_META].tqh_first;

	<span class="enscript-keyword">if</span> (!age_bp &amp;&amp; !lru_bp &amp;&amp; !meta_bp) {
		<span class="enscript-comment">/*
		 * Unavailble on AGE or LRU or META queues
		 * Try the empty list first
		 */</span>
		bp = bufqueues[BQ_EMPTY].tqh_first;
		<span class="enscript-keyword">if</span> (bp) {
			*queue = BQ_EMPTY;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
		}
		<span class="enscript-comment">/*
		 * We have seen is this is hard to trigger.
		 * This is an overcommit of nbufs but needed 
		 * in some scenarios with diskiamges
		 */</span>

<span class="enscript-reference">add_newbufs</span>:
		lck_mtx_unlock(buf_mtxp);

		<span class="enscript-comment">/* Create a new temporary buffer header */</span>
		bp = (<span class="enscript-type">struct</span> buf *)zalloc(buf_hdr_zone);
		
		<span class="enscript-keyword">if</span> (bp) {
			bufhdrinit(bp);
			bp-&gt;b_whichq = BQ_EMPTY;
			bp-&gt;b_timestamp = buf_timestamp();
			BLISTNONE(bp);
			SET(bp-&gt;b_flags, B_HDRALLOC);
			*queue = BQ_EMPTY;
		}
		lck_mtx_lock_spin(buf_mtxp);

		<span class="enscript-keyword">if</span> (bp) {
			binshash(bp, &amp;invalhash);
			binsheadfree(bp, &amp;bufqueues[BQ_EMPTY], BQ_EMPTY);
			buf_hdr_count++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
		}
		<span class="enscript-comment">/* subtract already accounted bufcount */</span>
		nbuf_headers--;

		bufstats.bufs_sleeps++;

		<span class="enscript-comment">/* wait for a free buffer of any kind */</span>
		needbuffer = 1;
		<span class="enscript-comment">/* hz value is 100 */</span>
		ts.tv_sec = (slptimeo/1000);
		<span class="enscript-comment">/* the hz value is 100; which leads to 10ms */</span>
		ts.tv_nsec = (slptimeo % 1000) * NSEC_PER_USEC * 1000 * 10;

		msleep(&amp;needbuffer, buf_mtxp, slpflag | PDROP | (PRIBIO+1), <span class="enscript-string">&quot;getnewbuf&quot;</span>, &amp;ts);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-comment">/* Buffer available either on AGE or LRU or META */</span>
	bp = NULL;
	*queue = -1;

	<span class="enscript-comment">/* Buffer available either on AGE or LRU */</span>
	<span class="enscript-keyword">if</span> (!age_bp) {
		bp = lru_bp;
		*queue = BQ_LRU;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!lru_bp) {
		bp = age_bp;
		*queue = BQ_AGE;
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* buffer available on both AGE and LRU */</span>
		<span class="enscript-type">int</span>		t = buf_timestamp();

		age_time = t - age_bp-&gt;b_timestamp;
		lru_time = t - lru_bp-&gt;b_timestamp;
		<span class="enscript-keyword">if</span> ((age_time &lt; 0) || (lru_time &lt; 0)) { <span class="enscript-comment">/* time set backwards */</span>
			bp = age_bp;
			*queue = BQ_AGE;
			<span class="enscript-comment">/*
			 * we should probably re-timestamp eveything in the
			 * queues at this point with the current time
			 */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> ((lru_time &gt;= lru_is_stale) &amp;&amp; (age_time &lt; age_is_stale)) {
				bp = lru_bp;
				*queue = BQ_LRU;
			} <span class="enscript-keyword">else</span> {
				bp = age_bp;
				*queue = BQ_AGE;
			}
		}
	}

	<span class="enscript-keyword">if</span> (!bp) { <span class="enscript-comment">/* Neither on AGE nor on LRU */</span>
		bp = meta_bp;
		*queue = BQ_META;
	}  <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (meta_bp) {
		<span class="enscript-type">int</span>		t = buf_timestamp();

		bp_time = t - bp-&gt;b_timestamp;
		meta_time = t - meta_bp-&gt;b_timestamp;

		<span class="enscript-keyword">if</span> (!(bp_time &lt; 0) &amp;&amp; !(meta_time &lt; 0)) {
			<span class="enscript-comment">/* time not set backwards */</span>
			<span class="enscript-type">int</span> bp_is_stale;
			bp_is_stale = (*queue == BQ_LRU) ? 
					lru_is_stale : age_is_stale;

			<span class="enscript-keyword">if</span> ((meta_time &gt;= meta_is_stale) &amp;&amp; 
					(bp_time &lt; bp_is_stale)) {
				bp = meta_bp;
				*queue = BQ_META;
			}
		}
	}
<span class="enscript-reference">found</span>:
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_LOCKED) || ISSET(bp-&gt;b_lflags, BL_BUSY))
	        panic(<span class="enscript-string">&quot;getnewbuf: bp @ %p is LOCKED or BUSY! (flags 0x%x)\n&quot;</span>, bp, bp-&gt;b_flags);

	<span class="enscript-comment">/* Clean it */</span>
	<span class="enscript-keyword">if</span> (bcleanbuf(bp, FALSE)) {
		<span class="enscript-comment">/*
		 * moved to the laundry thread, buffer not ready
		 */</span>
		*queue = req;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">start</span>;
	}
	<span class="enscript-keyword">return</span> (bp); 
}


<span class="enscript-comment">/* 
 * Clean a buffer.
 * Returns 0 if buffer is ready to use,
 * Returns 1 if issued a buf_bawrite() to indicate 
 * that the buffer is not ready.
 * 
 * buf_mtxp is held upon entry
 * returns with buf_mtxp locked
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">bcleanbuf</span>(buf_t bp, boolean_t discard)
{
	<span class="enscript-comment">/* Remove from the queue */</span>
	bremfree_locked(bp);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	bp-&gt;b_owner = current_thread();
	bp-&gt;b_tag   = 2;
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * If buffer was a delayed write, start the IO by queuing
	 * it on the LAUNDRY queue, and return 1
	 */</span>
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_DELWRI)) {
		<span class="enscript-keyword">if</span> (discard) {
			SET(bp-&gt;b_lflags, BL_WANTDEALLOC);
		}

		bmovelaundry(bp);

		lck_mtx_unlock(buf_mtxp);

		wakeup(&amp;bufqueues[BQ_LAUNDRY]);
		<span class="enscript-comment">/*
		 * and give it a chance to run
		 */</span>
		(<span class="enscript-type">void</span>)thread_block(THREAD_CONTINUE_NULL);

		lck_mtx_lock_spin(buf_mtxp);

		<span class="enscript-keyword">return</span> (1);
	}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	bp-&gt;b_owner = current_thread();
	bp-&gt;b_tag   = 8;
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Buffer is no longer on any free list... we own it
	 */</span>
	SET(bp-&gt;b_lflags, BL_BUSY);
	buf_busycount++;
	
	bremhash(bp);

	<span class="enscript-comment">/*
	 * disassociate us from our vnode, if we had one...
	 */</span>
	<span class="enscript-keyword">if</span> (bp-&gt;b_vp)
		brelvp_locked(bp);

	lck_mtx_unlock(buf_mtxp);

	BLISTNONE(bp);

	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_META))
		buf_free_meta_store(bp);

	trace(TR_BRELSE, pack(bp-&gt;b_vp, bp-&gt;b_bufsize), bp-&gt;b_lblkno);

	buf_release_credentials(bp);
	
	<span class="enscript-comment">/* If discarding, just move to the empty queue */</span>
	<span class="enscript-keyword">if</span> (discard) {
		lck_mtx_lock_spin(buf_mtxp);
		CLR(bp-&gt;b_flags, (B_META | B_ZALLOC | B_DELWRI | B_LOCKED | B_AGE | B_ASYNC | B_NOCACHE | B_FUA));
		bp-&gt;b_whichq = BQ_EMPTY;
		binshash(bp, &amp;invalhash);
		binsheadfree(bp, &amp;bufqueues[BQ_EMPTY], BQ_EMPTY);
		CLR(bp-&gt;b_lflags, BL_BUSY);
		buf_busycount--;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Not discarding: clean up and prepare for reuse */</span>
		bp-&gt;b_bufsize = 0;
		bp-&gt;b_datap = (uintptr_t)NULL;
		bp-&gt;b_upl = (<span class="enscript-type">void</span> *)NULL;
		bp-&gt;b_fsprivate = (<span class="enscript-type">void</span> *)NULL;
		<span class="enscript-comment">/*
		 * preserve the state of whether this buffer
		 * was allocated on the fly or not...
		 * the only other flag that should be set at
		 * this point is BL_BUSY...
		 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
		bp-&gt;b_owner = current_thread();
		bp-&gt;b_tag   = 3;
#<span class="enscript-reference">endif</span>
		bp-&gt;b_lflags = BL_BUSY;
		bp-&gt;b_flags = (bp-&gt;b_flags &amp; B_HDRALLOC);
		bp-&gt;b_redundancy_flags = 0;
		bp-&gt;b_dev = NODEV;
		bp-&gt;b_blkno = bp-&gt;b_lblkno = 0;
		bp-&gt;b_iodone = NULL;
		bp-&gt;b_error = 0;
		bp-&gt;b_resid = 0;
		bp-&gt;b_bcount = 0;
		bp-&gt;b_dirtyoff = bp-&gt;b_dirtyend = 0;
		bp-&gt;b_validoff = bp-&gt;b_validend = 0;
		bzero(&amp;bp-&gt;b_attr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bufattr));

		lck_mtx_lock_spin(buf_mtxp);
	}
	<span class="enscript-keyword">return</span> (0);
}



errno_t
<span class="enscript-function-name">buf_invalblkno</span>(vnode_t vp, daddr64_t lblkno, <span class="enscript-type">int</span> flags)
{
        buf_t	bp;
	errno_t	error;
	<span class="enscript-type">struct</span> bufhashhdr *dp;

	dp = BUFHASH(vp, lblkno);

<span class="enscript-reference">relook</span>:	
	lck_mtx_lock_spin(buf_mtxp);

	<span class="enscript-keyword">if</span> ((bp = incore_locked(vp, lblkno, dp)) == (<span class="enscript-type">struct</span> buf *)0) {
	        lck_mtx_unlock(buf_mtxp);
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_lflags, BL_BUSY)) {
	        <span class="enscript-keyword">if</span> ( !ISSET(flags, BUF_WAIT)) {
		        lck_mtx_unlock(buf_mtxp);
			<span class="enscript-keyword">return</span> (EBUSY);
		}
	        SET(bp-&gt;b_lflags, BL_WANTED);

		error = msleep((caddr_t)bp, buf_mtxp, PDROP | (PRIBIO + 1), <span class="enscript-string">&quot;buf_invalblkno&quot;</span>, NULL);

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">relook</span>;
	}
	bremfree_locked(bp);
	SET(bp-&gt;b_lflags, BL_BUSY);
	SET(bp-&gt;b_flags, B_INVAL);
	buf_busycount++;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	bp-&gt;b_owner = current_thread();
	bp-&gt;b_tag   = 4;
#<span class="enscript-reference">endif</span>
	lck_mtx_unlock(buf_mtxp);
	buf_brelse(bp);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_drop</span>(buf_t bp)
{
        <span class="enscript-type">int</span> need_wakeup = 0;

	lck_mtx_lock_spin(buf_mtxp);

	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_lflags, BL_WANTED)) {
	        <span class="enscript-comment">/*	
		 * delay the actual wakeup until after we
		 * clear BL_BUSY and we've dropped buf_mtxp
		 */</span>
		need_wakeup = 1;
	}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	bp-&gt;b_owner = current_thread();
	bp-&gt;b_tag   = 9;
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Unlock the buffer.
	 */</span>
	CLR(bp-&gt;b_lflags, (BL_BUSY | BL_WANTED));
	buf_busycount--;

	lck_mtx_unlock(buf_mtxp);

	<span class="enscript-keyword">if</span> (need_wakeup) {
	        <span class="enscript-comment">/*
		 * Wake up any proceeses waiting for _this_ buffer to become free.
		 */</span>
	        wakeup(bp);
	}
}


errno_t
<span class="enscript-function-name">buf_acquire</span>(buf_t bp, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> slpflag, <span class="enscript-type">int</span> slptimeo) {
        errno_t error;

        lck_mtx_lock_spin(buf_mtxp);

	error = buf_acquire_locked(bp, flags, slpflag, slptimeo);

       	lck_mtx_unlock(buf_mtxp);

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">buf_acquire_locked</span>(buf_t bp, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> slpflag, <span class="enscript-type">int</span> slptimeo)
{
	errno_t error;
	<span class="enscript-type">struct</span> timespec ts;

	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_LOCKED)) {
	        <span class="enscript-keyword">if</span> ((flags &amp; BAC_SKIP_LOCKED))
			<span class="enscript-keyword">return</span> (EDEADLK);
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-keyword">if</span> ((flags &amp; BAC_SKIP_NONLOCKED))
			<span class="enscript-keyword">return</span> (EDEADLK);
	}
        <span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_lflags, BL_BUSY)) {
	        <span class="enscript-comment">/*	
		 * since the lck_mtx_lock may block, the buffer
		 * may become BUSY, so we need to
		 * recheck for a NOWAIT request
		 */</span>
	        <span class="enscript-keyword">if</span> (flags &amp; BAC_NOWAIT)
			<span class="enscript-keyword">return</span> (EBUSY);
	        SET(bp-&gt;b_lflags, BL_WANTED);

		<span class="enscript-comment">/* the hz value is 100; which leads to 10ms */</span>
		ts.tv_sec = (slptimeo/100);
		ts.tv_nsec = (slptimeo % 100) * 10  * NSEC_PER_USEC * 1000;
		error = msleep((caddr_t)bp, buf_mtxp, slpflag | (PRIBIO + 1), <span class="enscript-string">&quot;buf_acquire&quot;</span>, &amp;ts);

		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">return</span> (EAGAIN);
	}
	<span class="enscript-keyword">if</span> (flags &amp; BAC_REMOVE)
	        bremfree_locked(bp);
	SET(bp-&gt;b_lflags, BL_BUSY);
	buf_busycount++;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	bp-&gt;b_owner = current_thread();
	bp-&gt;b_tag   = 5;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Wait for operations on the buffer to complete.
 * When they do, extract and return the I/O's error value.
 */</span>
errno_t
<span class="enscript-function-name">buf_biowait</span>(buf_t bp)
{
	<span class="enscript-keyword">while</span> (!ISSET(bp-&gt;b_flags, B_DONE)) {

		lck_mtx_lock_spin(buf_mtxp);

		<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;b_flags, B_DONE)) {
			DTRACE_IO1(wait__start, buf_t, bp);
			(<span class="enscript-type">void</span>) msleep(bp, buf_mtxp, PDROP | (PRIBIO+1), <span class="enscript-string">&quot;buf_biowait&quot;</span>, NULL);
			DTRACE_IO1(wait__done, buf_t, bp);
		} <span class="enscript-keyword">else</span>
			lck_mtx_unlock(buf_mtxp);
	}
	<span class="enscript-comment">/* check for interruption of I/O (e.g. via NFS), then errors. */</span>
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_EINTR)) {
		CLR(bp-&gt;b_flags, B_EINTR);
		<span class="enscript-keyword">return</span> (EINTR);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_ERROR))
		<span class="enscript-keyword">return</span> (bp-&gt;b_error ? bp-&gt;b_error : EIO);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Mark I/O complete on a buffer.
 *
 * If a callback has been requested, e.g. the pageout
 * daemon, do so. Otherwise, awaken waiting processes.
 *
 * [ Leffler, et al., says on p.247:
 *	&quot;This routine wakes up the blocked process, frees the buffer
 *	for an asynchronous write, or, for a request by the pagedaemon
 *	process, invokes a procedure specified in the buffer structure&quot; ]
 *
 * In real life, the pagedaemon (or other system processes) wants
 * to do async stuff to, and doesn't want the buffer buf_brelse()'d.
 * (for swap pager, that puts swap buffers on the free lists (!!!),
 * for the vn device, that puts malloc'd buffers on the free lists!)
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_biodone</span>(buf_t bp)
{
	mount_t mp;
	<span class="enscript-type">struct</span> bufattr *bap;
	
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 387)) | DBG_FUNC_START,
		     bp, bp-&gt;b_datap, bp-&gt;b_flags, 0, 0);

	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_DONE))
		panic(<span class="enscript-string">&quot;biodone already&quot;</span>);

	bap = &amp;bp-&gt;b_attr;

	<span class="enscript-keyword">if</span> (bp-&gt;b_vp &amp;&amp; bp-&gt;b_vp-&gt;v_mount) {
		mp = bp-&gt;b_vp-&gt;v_mount;
	} <span class="enscript-keyword">else</span> {
		mp = NULL;
	}
	
	<span class="enscript-keyword">if</span> (mp &amp;&amp; (bp-&gt;b_flags &amp; B_READ) == 0) {
		update_last_io_time(mp);
		INCR_PENDING_IO(-(pending_io_t)buf_count(bp), mp-&gt;mnt_pending_write_size);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mp) {
		INCR_PENDING_IO(-(pending_io_t)buf_count(bp), mp-&gt;mnt_pending_read_size);
	}

	<span class="enscript-keyword">if</span> (kdebug_enable) {
		<span class="enscript-type">int</span> code    = DKIO_DONE;
		<span class="enscript-type">int</span> io_tier = GET_BUFATTR_IO_TIER(bap);

		<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_READ)
		        code |= DKIO_READ;
		<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_ASYNC)
		        code |= DKIO_ASYNC;

		<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_META)
		        code |= DKIO_META;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_PAGEIO)
		        code |= DKIO_PAGING;

		<span class="enscript-keyword">if</span> (io_tier != 0)
			code |= DKIO_THROTTLE;

		code |= ((io_tier &lt;&lt; DKIO_TIER_SHIFT) &amp; DKIO_TIER_MASK);

		<span class="enscript-keyword">if</span> (bp-&gt;b_flags &amp; B_PASSIVE)
			code |= DKIO_PASSIVE;

		<span class="enscript-keyword">if</span> (bap-&gt;ba_flags &amp; BA_NOCACHE)
			code |= DKIO_NOCACHE;

		KERNEL_DEBUG_CONSTANT_IST(KDEBUG_COMMON, FSDBG_CODE(DBG_DKRW, code) | DBG_FUNC_NONE,
		                          buf_kernel_addrperm_addr(bp), (uintptr_t)VM_KERNEL_ADDRPERM(bp-&gt;b_vp), bp-&gt;b_resid, bp-&gt;b_error, 0);
        }

	<span class="enscript-comment">/*
	 * I/O was done, so don't believe
	 * the DIRTY state from VM anymore...
	 * and we need to reset the THROTTLED/PASSIVE
	 * indicators
	 */</span>
	CLR(bp-&gt;b_flags, (B_WASDIRTY | B_PASSIVE));
	CLR(bap-&gt;ba_flags, (BA_META | BA_NOCACHE | BA_DELAYIDLESLEEP));

	SET_BUFATTR_IO_TIER(bap, 0);

	DTRACE_IO1(done, buf_t, bp);

	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;b_flags, B_READ) &amp;&amp; !ISSET(bp-&gt;b_flags, B_RAW))
	        <span class="enscript-comment">/*
		 * wake up any writer's blocked
		 * on throttle or waiting for I/O
		 * to drain
		 */</span>
		vnode_writedone(bp-&gt;b_vp);

	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, (B_CALL | B_FILTER))) {	<span class="enscript-comment">/* if necessary, call out */</span>
		<span class="enscript-type">void</span>	(*iodone_func)(<span class="enscript-type">struct</span> buf *, <span class="enscript-type">void</span> *) = bp-&gt;b_iodone;
		<span class="enscript-type">void</span> 	*arg = bp-&gt;b_transaction;
		<span class="enscript-type">int</span>     callout = ISSET(bp-&gt;b_flags, B_CALL);

		<span class="enscript-keyword">if</span> (iodone_func == NULL)
			panic(<span class="enscript-string">&quot;biodone: bp @ %p has NULL b_iodone!\n&quot;</span>, bp);			

		CLR(bp-&gt;b_flags, (B_CALL | B_FILTER));	<span class="enscript-comment">/* filters and callouts are one-shot */</span>
		bp-&gt;b_iodone = NULL;
		bp-&gt;b_transaction = NULL;

		<span class="enscript-keyword">if</span> (callout)
		        SET(bp-&gt;b_flags, B_DONE);	<span class="enscript-comment">/* note that it's done */</span>

		(*iodone_func)(bp, arg);

		<span class="enscript-keyword">if</span> (callout) {
			<span class="enscript-comment">/*
			 * assumes that the callback function takes
			 * ownership of the bp and deals with releasing it if necessary
			 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">biodone_done</span>;
		}
		<span class="enscript-comment">/*
		 * in this case the call back function is acting
		 * strictly as a filter... it does not take
		 * ownership of the bp and is expecting us
		 * to finish cleaning up... this is currently used
		 * by the HFS journaling code
		 */</span>
	}
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_ASYNC)) {	<span class="enscript-comment">/* if async, release it */</span>
		SET(bp-&gt;b_flags, B_DONE);	<span class="enscript-comment">/* note that it's done */</span>

		buf_brelse(bp);
	} <span class="enscript-keyword">else</span> {				<span class="enscript-comment">/* or just wakeup the buffer */</span>	
	        <span class="enscript-comment">/*
		 * by taking the mutex, we serialize
		 * the buf owner calling buf_biowait so that we'll
		 * only see him in one of 2 states...
		 * state 1: B_DONE wasn't set and he's
		 * blocked in msleep
		 * state 2: he's blocked trying to take the
		 * mutex before looking at B_DONE
		 * BL_WANTED is cleared in case anyone else
		 * is blocked waiting for the buffer... note
		 * that we haven't cleared B_BUSY yet, so if
		 * they do get to run, their going to re-set
		 * BL_WANTED and go back to sleep
		 */</span>
	        lck_mtx_lock_spin(buf_mtxp);

		CLR(bp-&gt;b_lflags, BL_WANTED);
		SET(bp-&gt;b_flags, B_DONE);		<span class="enscript-comment">/* note that it's done */</span>

	        lck_mtx_unlock(buf_mtxp);

		wakeup(bp);
	}
<span class="enscript-reference">biodone_done</span>:
	KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, 387)) | DBG_FUNC_END,
                 (uintptr_t)bp, (uintptr_t)bp-&gt;b_datap, bp-&gt;b_flags, 0, 0);
}

<span class="enscript-comment">/*
 * Obfuscate buf pointers.
 */</span>
vm_offset_t
<span class="enscript-function-name">buf_kernel_addrperm_addr</span>(<span class="enscript-type">void</span> * addr)
{
	<span class="enscript-keyword">if</span> ((vm_offset_t)addr == 0)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> ((vm_offset_t)addr + buf_kernel_addrperm);
}

<span class="enscript-comment">/*
 * Return a count of buffers on the &quot;locked&quot; queue.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">count_lock_queue</span>(<span class="enscript-type">void</span>)
{
	buf_t	bp;
	<span class="enscript-type">int</span>	n = 0;

	lck_mtx_lock_spin(buf_mtxp);

	<span class="enscript-keyword">for</span> (bp = bufqueues[BQ_LOCKED].tqh_first; bp;
	    bp = bp-&gt;b_freelist.tqe_next)
		n++;
	lck_mtx_unlock(buf_mtxp);

	<span class="enscript-keyword">return</span> (n);
}

<span class="enscript-comment">/*
 * Return a count of 'busy' buffers. Used at the time of shutdown.
 * note: This is also called from the mach side in debug context in kdp.c
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">count_busy_buffers</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> buf_busycount + bufstats.bufs_iobufinuse;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
<span class="enscript-comment">/*
 * Print out statistics on the current allocation of the buffer pool.
 * Can be enabled to print out on every ``sync'' by setting &quot;syncprt&quot;
 * in vfs_syscalls.c using sysctl.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vfs_bufstats</span>()
{
	<span class="enscript-type">int</span> i, j, count;
	<span class="enscript-type">struct</span> buf *bp;
	<span class="enscript-type">struct</span> bqueues *dp;
	<span class="enscript-type">int</span> counts[MAXBSIZE/CLBYTES+1];
	<span class="enscript-type">static</span> <span class="enscript-type">char</span> *bname[BQUEUES] =
		{ <span class="enscript-string">&quot;LOCKED&quot;</span>, <span class="enscript-string">&quot;LRU&quot;</span>, <span class="enscript-string">&quot;AGE&quot;</span>, <span class="enscript-string">&quot;EMPTY&quot;</span>, <span class="enscript-string">&quot;META&quot;</span>, <span class="enscript-string">&quot;LAUNDRY&quot;</span> };

	<span class="enscript-keyword">for</span> (dp = bufqueues, i = 0; dp &lt; &amp;bufqueues[BQUEUES]; dp++, i++) {
		count = 0;
		<span class="enscript-keyword">for</span> (j = 0; j &lt;= MAXBSIZE/CLBYTES; j++)
			counts[j] = 0;

		lck_mtx_lock(buf_mtxp);

		<span class="enscript-keyword">for</span> (bp = dp-&gt;tqh_first; bp; bp = bp-&gt;b_freelist.tqe_next) {
			counts[bp-&gt;b_bufsize/CLBYTES]++;
			count++;
		}
		lck_mtx_unlock(buf_mtxp);

		printf(<span class="enscript-string">&quot;%s: total-%d&quot;</span>, bname[i], count);
		<span class="enscript-keyword">for</span> (j = 0; j &lt;= MAXBSIZE/CLBYTES; j++)
			<span class="enscript-keyword">if</span> (counts[j] != 0)
				printf(<span class="enscript-string">&quot;, %d-%d&quot;</span>, j * CLBYTES, counts[j]);
		printf(<span class="enscript-string">&quot;\n&quot;</span>);
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAGNOSTIC */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NRESERVEDIOBUFS</span>	128


buf_t
<span class="enscript-function-name">alloc_io_buf</span>(vnode_t vp, <span class="enscript-type">int</span> priv)
{
	buf_t	bp;

	lck_mtx_lock_spin(iobuffer_mtxp);

	<span class="enscript-keyword">while</span> (((niobuf_headers - NRESERVEDIOBUFS &lt; bufstats.bufs_iobufinuse) &amp;&amp; !priv) || 
	       (bp = iobufqueue.tqh_first) == NULL) {
		bufstats.bufs_iobufsleeps++;

		need_iobuffer = 1;
		(<span class="enscript-type">void</span>) msleep(&amp;need_iobuffer, iobuffer_mtxp, PSPIN | (PRIBIO+1), (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)<span class="enscript-string">&quot;alloc_io_buf&quot;</span>, NULL);
	}
	TAILQ_REMOVE(&amp;iobufqueue, bp, b_freelist);

	bufstats.bufs_iobufinuse++;
	<span class="enscript-keyword">if</span> (bufstats.bufs_iobufinuse &gt; bufstats.bufs_iobufmax)
		bufstats.bufs_iobufmax = bufstats.bufs_iobufinuse;

	lck_mtx_unlock(iobuffer_mtxp);

	<span class="enscript-comment">/*
	 * initialize various fields
	 * we don't need to hold the mutex since the buffer
	 * is now private... the vp should have a reference 
	 * on it and is not protected by this mutex in any event
	 */</span>
	bp-&gt;b_timestamp = 0; 
	bp-&gt;b_proc = NULL;

	bp-&gt;b_datap = 0;
	bp-&gt;b_flags = 0;
	bp-&gt;b_lflags = BL_BUSY | BL_IOBUF;
	bp-&gt;b_redundancy_flags = 0;
	bp-&gt;b_blkno = bp-&gt;b_lblkno = 0;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
	bp-&gt;b_owner = current_thread();
	bp-&gt;b_tag   = 6;
#<span class="enscript-reference">endif</span>
	bp-&gt;b_iodone = NULL;
	bp-&gt;b_error = 0;
	bp-&gt;b_resid = 0;
	bp-&gt;b_bcount = 0;
	bp-&gt;b_bufsize = 0;
	bp-&gt;b_upl = NULL;
	bp-&gt;b_fsprivate = (<span class="enscript-type">void</span> *)NULL;
	bp-&gt;b_vp = vp;
	bzero(&amp;bp-&gt;b_attr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bufattr));

	<span class="enscript-keyword">if</span> (vp &amp;&amp; (vp-&gt;v_type == VBLK || vp-&gt;v_type == VCHR))
		bp-&gt;b_dev = vp-&gt;v_rdev;
	<span class="enscript-keyword">else</span>
		bp-&gt;b_dev = NODEV;

	<span class="enscript-keyword">return</span> (bp);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">free_io_buf</span>(buf_t bp)
{
        <span class="enscript-type">int</span> need_wakeup = 0;

	<span class="enscript-comment">/*
	 * put buffer back on the head of the iobufqueue
	 */</span>
	bp-&gt;b_vp = NULL;
	bp-&gt;b_flags = B_INVAL;

	<span class="enscript-comment">/* Zero out the bufattr and its flags before relinquishing this iobuf */</span>
	bzero (&amp;bp-&gt;b_attr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bufattr));
	
	lck_mtx_lock_spin(iobuffer_mtxp);

	binsheadfree(bp, &amp;iobufqueue, -1);

	<span class="enscript-keyword">if</span> (need_iobuffer) {
	        <span class="enscript-comment">/*
		 * Wake up any processes waiting because they need an io buffer
		 *
		 * do the wakeup after we drop the mutex... it's possible that the
		 * wakeup will be superfluous if need_iobuffer gets set again and
		 * another thread runs this path, but it's highly unlikely, doesn't
		 * hurt, and it means we don't hold up I/O progress if the wakeup blocks
		 * trying to grab a task related lock...
		 */</span>
		need_iobuffer = 0;
		need_wakeup = 1;
	}
	<span class="enscript-keyword">if</span> (bufstats.bufs_iobufinuse &lt;= 0)
		panic(<span class="enscript-string">&quot;free_io_buf: bp(%p) - bufstats.bufs_iobufinuse &lt; 0&quot;</span>, bp);

	bufstats.bufs_iobufinuse--;

	lck_mtx_unlock(iobuffer_mtxp);

	<span class="enscript-keyword">if</span> (need_wakeup)
	        wakeup(&amp;need_iobuffer);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_list_lock</span>(<span class="enscript-type">void</span>)
{
        lck_mtx_lock_spin(buf_mtxp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">buf_list_unlock</span>(<span class="enscript-type">void</span>)
{
        lck_mtx_unlock(buf_mtxp);
}

<span class="enscript-comment">/*
 * If getnewbuf() calls bcleanbuf() on the same thread
 * there is a potential for stack overrun and deadlocks.
 * So we always handoff the work to a worker thread for completion
 */</span>


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bcleanbuf_thread_init</span>(<span class="enscript-type">void</span>)
{
	thread_t	thread = THREAD_NULL;

	<span class="enscript-comment">/* create worker thread */</span>
	kernel_thread_start((thread_continue_t)bcleanbuf_thread, NULL, &amp;thread);
	thread_deallocate(thread);
}

<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*bcleanbufcontinuation)(<span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bcleanbuf_thread</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> buf *bp;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> loopcnt = 0;

	<span class="enscript-keyword">for</span> (;;) {
	        lck_mtx_lock_spin(buf_mtxp);

		<span class="enscript-keyword">while</span> ( (bp = TAILQ_FIRST(&amp;bufqueues[BQ_LAUNDRY])) == NULL) {
			(<span class="enscript-type">void</span>)msleep0(&amp;bufqueues[BQ_LAUNDRY], buf_mtxp, PRIBIO|PDROP, <span class="enscript-string">&quot;blaundry&quot;</span>, 0, (bcleanbufcontinuation)bcleanbuf_thread);
		}
		
		<span class="enscript-comment">/*
		 * Remove from the queue
		 */</span>
		bremfree_locked(bp);

		<span class="enscript-comment">/*
		 * Buffer is no longer on any free list
		 */</span>
		SET(bp-&gt;b_lflags, BL_BUSY);
		buf_busycount++;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
		bp-&gt;b_owner = current_thread();
		bp-&gt;b_tag   = 10;
#<span class="enscript-reference">endif</span>

		lck_mtx_unlock(buf_mtxp);
		<span class="enscript-comment">/*
		 * do the IO
		 */</span>
		error = bawrite_internal(bp, 0);

		<span class="enscript-keyword">if</span> (error) {
		        bp-&gt;b_whichq = BQ_LAUNDRY;
			bp-&gt;b_timestamp = buf_timestamp();

		        lck_mtx_lock_spin(buf_mtxp);

			binstailfree(bp, &amp;bufqueues[BQ_LAUNDRY], BQ_LAUNDRY);
			blaundrycnt++;

			<span class="enscript-comment">/* we never leave a busy page on the laundry queue */</span>
			CLR(bp-&gt;b_lflags, BL_BUSY);
			buf_busycount--;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
			bp-&gt;b_owner = current_thread();
			bp-&gt;b_tag   = 11;
#<span class="enscript-reference">endif</span>

			lck_mtx_unlock(buf_mtxp);
			
			<span class="enscript-keyword">if</span> (loopcnt &gt; MAXLAUNDRY) {
				<span class="enscript-comment">/*
				 * bawrite_internal() can return errors if we're throttled. If we've
				 * done several I/Os and failed, give the system some time to unthrottle
				 * the vnode
				 */</span>
				(<span class="enscript-type">void</span>)tsleep((<span class="enscript-type">void</span> *)&amp;bufqueues[BQ_LAUNDRY], PRIBIO, <span class="enscript-string">&quot;blaundry&quot;</span>, 1);
				loopcnt = 0;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* give other threads a chance to run */</span>
				(<span class="enscript-type">void</span>)thread_block(THREAD_CONTINUE_NULL);
				loopcnt++;
			}
		}
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">brecover_data</span>(buf_t bp)
{
	<span class="enscript-type">int</span>	upl_offset;
        upl_t	upl;
	upl_page_info_t *pl;
	kern_return_t kret;
	vnode_t	vp = bp-&gt;b_vp;
	<span class="enscript-type">int</span> upl_flags;


	<span class="enscript-keyword">if</span> ( !UBCINFOEXISTS(vp) || bp-&gt;b_bufsize == 0)
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">dump_buffer</span>;

	upl_flags = UPL_PRECIOUS;
	<span class="enscript-keyword">if</span> (! (buf_flags(bp) &amp; B_READ)) {
		<span class="enscript-comment">/*
		 * &quot;write&quot; operation:  let the UPL subsystem know
		 * that we intend to modify the buffer cache pages we're
		 * gathering.
		 */</span>
		upl_flags |= UPL_WILL_MODIFY;
	}
		
	kret = ubc_create_upl(vp,
			      ubc_blktooff(vp, bp-&gt;b_lblkno), 
			      bp-&gt;b_bufsize, 
			      &amp;upl, 
			      &amp;pl,
			      upl_flags);
	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
	        panic(<span class="enscript-string">&quot;Failed to create UPL&quot;</span>);

	<span class="enscript-keyword">for</span> (upl_offset = 0; upl_offset &lt; bp-&gt;b_bufsize; upl_offset += PAGE_SIZE) {

	        <span class="enscript-keyword">if</span> (!upl_valid_page(pl, upl_offset / PAGE_SIZE) || !upl_dirty_page(pl, upl_offset / PAGE_SIZE)) {
		        ubc_upl_abort(upl, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dump_buffer</span>;
		}
	}
	bp-&gt;b_upl = upl;
					
	kret = ubc_upl_map(upl, (vm_offset_t *)&amp;(bp-&gt;b_datap));

	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
	        panic(<span class="enscript-string">&quot;getblk: ubc_upl_map() failed with (%d)&quot;</span>, kret);
	<span class="enscript-keyword">return</span> (1);

<span class="enscript-reference">dump_buffer</span>:
	bp-&gt;b_bufsize = 0;
	SET(bp-&gt;b_flags, B_INVAL);
	buf_brelse(bp);

	<span class="enscript-keyword">return</span>(0);
}

boolean_t 
<span class="enscript-function-name">buffer_cache_gc</span>(<span class="enscript-type">int</span> all)
{
	buf_t bp;
	boolean_t did_large_zfree = FALSE;
	boolean_t need_wakeup = FALSE;
	<span class="enscript-type">int</span> now = buf_timestamp();
	uint32_t found = 0;
	<span class="enscript-type">struct</span> bqueues privq;
	<span class="enscript-type">int</span> thresh_hold = BUF_STALE_THRESHHOLD;

	<span class="enscript-keyword">if</span> (all)
		thresh_hold = 0;
	<span class="enscript-comment">/* 
	 * We only care about metadata (incore storage comes from zalloc()).
	 * Unless &quot;all&quot; is set (used to evict meta data buffers in preparation
	 * for deep sleep), we only evict up to BUF_MAX_GC_BATCH_SIZE buffers
	 * that have not been accessed in the last BUF_STALE_THRESHOLD seconds.
	 * BUF_MAX_GC_BATCH_SIZE controls both the hold time of the global lock
	 * &quot;buf_mtxp&quot; and the length of time we spend compute bound in the GC
	 * thread which calls this function
	 */</span>
	lck_mtx_lock(buf_mtxp);

	<span class="enscript-keyword">do</span> {
		found = 0;
		TAILQ_INIT(&amp;privq);
		need_wakeup = FALSE;

		<span class="enscript-keyword">while</span> (((bp = TAILQ_FIRST(&amp;bufqueues[BQ_META]))) &amp;&amp; 
				(now &gt; bp-&gt;b_timestamp) &amp;&amp;
				(now - bp-&gt;b_timestamp &gt; thresh_hold) &amp;&amp; 
				(found &lt; BUF_MAX_GC_BATCH_SIZE)) {

			<span class="enscript-comment">/* Remove from free list */</span>
			bremfree_locked(bp);
			found++;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
			bp-&gt;b_owner = current_thread();
			bp-&gt;b_tag   = 12;
#<span class="enscript-reference">endif</span>

			<span class="enscript-comment">/* If dirty, move to laundry queue and remember to do wakeup */</span>
			<span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_DELWRI)) {
				SET(bp-&gt;b_lflags, BL_WANTDEALLOC);

				bmovelaundry(bp);
				need_wakeup = TRUE;

				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/* 
			 * Mark busy and put on private list.  We could technically get 
			 * away without setting BL_BUSY here.
			 */</span>
			SET(bp-&gt;b_lflags, BL_BUSY);
			buf_busycount++;

			<span class="enscript-comment">/* 
			 * Remove from hash and dissociate from vp.
			 */</span>
			bremhash(bp);
			<span class="enscript-keyword">if</span> (bp-&gt;b_vp) {
				brelvp_locked(bp);
			}

			TAILQ_INSERT_TAIL(&amp;privq, bp, b_freelist);
		}

		<span class="enscript-keyword">if</span> (found == 0) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* Drop lock for batch processing */</span>
		lck_mtx_unlock(buf_mtxp);

		<span class="enscript-comment">/* Wakeup and yield for laundry if need be */</span>
		<span class="enscript-keyword">if</span> (need_wakeup) {
			wakeup(&amp;bufqueues[BQ_LAUNDRY]);
			(<span class="enscript-type">void</span>)thread_block(THREAD_CONTINUE_NULL);
		}

		<span class="enscript-comment">/* Clean up every buffer on private list */</span>
		TAILQ_FOREACH(bp, &amp;privq, b_freelist) {
			<span class="enscript-comment">/* Take note if we've definitely freed at least a page to a zone */</span>
			<span class="enscript-keyword">if</span> ((ISSET(bp-&gt;b_flags, B_ZALLOC)) &amp;&amp; (buf_size(bp) &gt;= PAGE_SIZE)) {
				did_large_zfree = TRUE;
			}    

			trace(TR_BRELSE, pack(bp-&gt;b_vp, bp-&gt;b_bufsize), bp-&gt;b_lblkno);

			<span class="enscript-comment">/* Free Storage */</span>
			buf_free_meta_store(bp);

			<span class="enscript-comment">/* Release credentials */</span>
			buf_release_credentials(bp);

			<span class="enscript-comment">/* Prepare for moving to empty queue */</span>
			CLR(bp-&gt;b_flags, (B_META | B_ZALLOC | B_DELWRI | B_LOCKED 
						| B_AGE | B_ASYNC | B_NOCACHE | B_FUA));
			bp-&gt;b_whichq = BQ_EMPTY;
			BLISTNONE(bp);
		}
		lck_mtx_lock(buf_mtxp);

		<span class="enscript-comment">/* Back under lock, move them all to invalid hash and clear busy */</span>
		TAILQ_FOREACH(bp, &amp;privq, b_freelist) {
			binshash(bp, &amp;invalhash);
			CLR(bp-&gt;b_lflags, BL_BUSY);
			buf_busycount--;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
			<span class="enscript-keyword">if</span> (bp-&gt;b_owner != current_thread()) {
				panic(<span class="enscript-string">&quot;Buffer stolen from buffer_cache_gc()&quot;</span>);
			}
			bp-&gt;b_owner = current_thread();
			bp-&gt;b_tag   = 13;
#<span class="enscript-reference">endif</span>
		}

		<span class="enscript-comment">/* And do a big bulk move to the empty queue */</span>
		TAILQ_CONCAT(&amp;bufqueues[BQ_EMPTY], &amp;privq, b_freelist);

	} <span class="enscript-keyword">while</span> (all &amp;&amp; (found == BUF_MAX_GC_BATCH_SIZE));

	lck_mtx_unlock(buf_mtxp);

	<span class="enscript-keyword">return</span> did_large_zfree;
}


<span class="enscript-comment">/*
 * disabled for now
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FLUSH_QUEUES</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFLUSH</span> 32

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bp_cmp</span>(<span class="enscript-type">void</span> *a, <span class="enscript-type">void</span> *b)
{
    buf_t *bp_a = *(buf_t **)a,
          *bp_b = *(buf_t **)b;
    daddr64_t res;

    <span class="enscript-comment">// don't have to worry about negative block
</span>    <span class="enscript-comment">// numbers so this is ok to do.
</span>    <span class="enscript-comment">//
</span>    res = (bp_a-&gt;b_blkno - bp_b-&gt;b_blkno);

    <span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)res;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">bflushq</span>(<span class="enscript-type">int</span> whichq, mount_t mp)
{
	buf_t	bp, next;
	<span class="enscript-type">int</span>	i, buf_count;
	<span class="enscript-type">int</span>	total_writes = 0;
	<span class="enscript-type">static</span> buf_t flush_table[NFLUSH];

	<span class="enscript-keyword">if</span> (whichq &lt; 0 || whichq &gt;= BQUEUES) {
	    <span class="enscript-keyword">return</span> (0);
	}

  <span class="enscript-reference">restart</span>:
	lck_mtx_lock(buf_mtxp);

	bp = TAILQ_FIRST(&amp;bufqueues[whichq]);

	<span class="enscript-keyword">for</span> (buf_count = 0; bp; bp = next) {
	    next = bp-&gt;b_freelist.tqe_next;
			
	    <span class="enscript-keyword">if</span> (bp-&gt;b_vp == NULL || bp-&gt;b_vp-&gt;v_mount != mp) {
		<span class="enscript-keyword">continue</span>;
	    }

	    <span class="enscript-keyword">if</span> (ISSET(bp-&gt;b_flags, B_DELWRI) &amp;&amp; !ISSET(bp-&gt;b_lflags, BL_BUSY)) {

		bremfree_locked(bp);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">JOE_DEBUG</span>
		bp-&gt;b_owner = current_thread();
		bp-&gt;b_tag   = 7;
#<span class="enscript-reference">endif</span>
		SET(bp-&gt;b_lflags, BL_BUSY);
		buf_busycount++;

		flush_table[buf_count] = bp;
		buf_count++;
		total_writes++;

		<span class="enscript-keyword">if</span> (buf_count &gt;= NFLUSH) {
		    lck_mtx_unlock(buf_mtxp);

		    qsort(flush_table, buf_count, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> buf *), bp_cmp);

		    <span class="enscript-keyword">for</span> (i = 0; i &lt; buf_count; i++) {
			buf_bawrite(flush_table[i]);
		    }
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		}
	    }
	}
	lck_mtx_unlock(buf_mtxp);

	<span class="enscript-keyword">if</span> (buf_count &gt; 0) {
	    qsort(flush_table, buf_count, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> buf *), bp_cmp);

	    <span class="enscript-keyword">for</span> (i = 0; i &lt; buf_count; i++) {
		buf_bawrite(flush_table[i]);
	    }
	}

	<span class="enscript-keyword">return</span> (total_writes);
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>