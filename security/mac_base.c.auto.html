<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mac_base.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mac_base.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*-
 * Copyright (c) 1999, 2000, 2001, 2002 Robert N. M. Watson
 * Copyright (c) 2001 Ilmar S. Habibulin
 * Copyright (c) 2001, 2002, 2003, 2004 Networks Associates Technology, Inc.
 * Copyright (c) 2005-2006 SPARTA, Inc.
 *
 * This software was developed by Robert Watson and Ilmar Habibulin for the
 * TrustedBSD Project.
 *
 * This software was developed for the FreeBSD Project in part by Network
 * Associates Laboratories, the Security Research Division of Network
 * Associates, Inc. under DARPA/SPAWAR contract N66001-01-C-8035 (&quot;CBOSS&quot;),
 * as part of the DARPA CHATS research program.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */</span>

<span class="enscript-comment">/*-
 * Framework for extensible kernel access control.  This file contains
 * Kernel and userland interface to the framework, policy registration
 * and composition.  Per-object interfaces, controls, and labeling may be
 * found in src/sys/mac/.  Sample policies may be found in src/sys/mac*.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_mach_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vfs_context.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsd/bsm/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsd/security/audit/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/exception_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;osfmk/kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;osfmk/kern/kalloc.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_mach_internal.h&gt;</span>
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* 
 * define MB_DEBUG to display run-time debugging information
 * #define MB_DEBUG 1
 */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MB_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPRINTF</span>(x)	printf x
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MB_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DPRINTF</span>(x)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
<span class="enscript-function-name">SYSCTL_NODE</span>(, OID_AUTO, security, CTLFLAG_RW|CTLFLAG_LOCKED, 0, 
    <span class="enscript-string">&quot;Security Controls&quot;</span>);
<span class="enscript-function-name">SYSCTL_NODE</span>(_security, OID_AUTO, mac, CTLFLAG_RW|CTLFLAG_LOCKED, 0,
    <span class="enscript-string">&quot;TrustedBSD MAC policy controls&quot;</span>);

<span class="enscript-comment">/*
 * Declare that the kernel provides MAC support, version 1.  This permits
 * modules to refuse to be loaded if the necessary support isn't present,
 * even if it's pre-boot.
 */</span>
#<span class="enscript-reference">if</span> 0
<span class="enscript-function-name">MODULE_VERSION</span>(kernel_mac_support, 1);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MAC_MAX_SLOTS</span> &gt; 32
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;MAC_MAX_SLOTS too large&quot;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mac_max_slots = MAC_MAX_SLOTS;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mac_slot_offsets_free = (1 &lt;&lt; MAC_MAX_SLOTS) - 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, max_slots, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;mac_max_slots, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/*
 * Has the kernel started generating labeled objects yet?  All read/write
 * access to this variable is serialized during the boot process.  Following
 * the end of serialization, we don't update this flag; no locking.
 */</span>
<span class="enscript-type">int</span>	mac_late = 0;

<span class="enscript-comment">/*
 * Flag to indicate whether or not we should allocate label storage for
 * new mbufs.  Since most dynamic policies we currently work with don't
 * rely on mbuf labeling, try to avoid paying the cost of mtag allocation
 * unless specifically notified of interest.  One result of this is
 * that if a dynamically loaded policy requests mbuf labels, it must
 * be able to deal with a NULL label being returned on any mbufs that
 * were already in flight when the policy was loaded.  Since the policy
 * already has to deal with uninitialized labels, this probably won't
 * be a problem.  Note: currently no locking.  Will this be a problem?
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mac_label_mbufs	= 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, label_mbufs, SECURITY_MAC_CTLFLAGS,
	&amp;mac_label_mbufs, 0, <span class="enscript-string">&quot;Label all MBUFs&quot;</span>);
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 * Flag to indicate whether or not we should allocate label storage for
 * new vnodes.  Since most dynamic policies we currently work with don't
 * rely on vnode labeling, try to avoid paying the cost of mtag allocation
 * unless specifically notified of interest.  One result of this is
 * that if a dynamically loaded policy requests vnode labels, it must
 * be able to deal with a NULL label being returned on any vnodes that
 * were already in flight when the policy was loaded.  Since the policy
 * already has to deal with uninitialized labels, this probably won't
 * be a problem.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mac_label_vnodes = 0;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, labelvnodes, SECURITY_MAC_CTLFLAGS,
    &amp;mac_label_vnodes, 0, <span class="enscript-string">&quot;Label all vnodes&quot;</span>);


<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mac_mmap_revocation = 0;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, mmap_revocation, SECURITY_MAC_CTLFLAGS,
    &amp;mac_mmap_revocation, 0, <span class="enscript-string">&quot;Revoke mmap access to files on subject &quot;</span>
    <span class="enscript-string">&quot;relabel&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mac_mmap_revocation_via_cow = 0;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, mmap_revocation_via_cow, SECURITY_MAC_CTLFLAGS,
    &amp;mac_mmap_revocation_via_cow, 0, <span class="enscript-string">&quot;Revoke mmap access to files via &quot;</span>
    <span class="enscript-string">&quot;copy-on-write semantics, or by removing all write access&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mac_device_enforce = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, device_enforce, SECURITY_MAC_CTLFLAGS,
	   &amp;mac_device_enforce, 0, <span class="enscript-string">&quot;Enforce MAC policy on device operations&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mac_pipe_enforce = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, pipe_enforce, SECURITY_MAC_CTLFLAGS,
    &amp;mac_pipe_enforce, 0, <span class="enscript-string">&quot;Enforce MAC policy on pipe operations&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mac_posixsem_enforce = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, posixsem_enforce, SECURITY_MAC_CTLFLAGS,
    &amp;mac_posixsem_enforce, 0, <span class="enscript-string">&quot;Enforce MAC policy on POSIX semaphores&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mac_posixshm_enforce = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, posixshm_enforce, SECURITY_MAC_CTLFLAGS,
    &amp;mac_posixshm_enforce, 0, <span class="enscript-string">&quot;Enforce MAC policy on Posix Shared Memory&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mac_proc_enforce = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, proc_enforce, SECURITY_MAC_CTLFLAGS,
	   &amp;mac_proc_enforce, 0, <span class="enscript-string">&quot;Enforce MAC policy on process operations&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mac_socket_enforce = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, socket_enforce, SECURITY_MAC_CTLFLAGS,
	&amp;mac_socket_enforce, 0, <span class="enscript-string">&quot;Enforce MAC policy on socket operations&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mac_system_enforce = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, system_enforce, SECURITY_MAC_CTLFLAGS,
    &amp;mac_system_enforce, 0, <span class="enscript-string">&quot;Enforce MAC policy on system-wide interfaces&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mac_sysvmsg_enforce = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, sysvmsg_enforce, SECURITY_MAC_CTLFLAGS,
    &amp;mac_sysvmsg_enforce, 0, <span class="enscript-string">&quot;Enforce MAC policy on System V IPC message queues&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mac_sysvsem_enforce = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, sysvsem_enforce, SECURITY_MAC_CTLFLAGS,
    &amp;mac_sysvsem_enforce, 0, <span class="enscript-string">&quot;Enforce MAC policy on System V IPC semaphores&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mac_sysvshm_enforce = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_security_mac, OID_AUTO, sysvshm_enforce, SECURITY_MAC_CTLFLAGS,
    &amp;mac_sysvshm_enforce, 0, <span class="enscript-string">&quot;Enforce MAC policy on System V Shared Memory&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mac_vm_enforce = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_security_mac, OID_AUTO, vm_enforce, SECURITY_MAC_CTLFLAGS,
	   &amp;mac_vm_enforce, 0, <span class="enscript-string">&quot;Enforce MAC policy on VM operations&quot;</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	mac_vnode_enforce = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_security_mac, OID_AUTO, vnode_enforce, SECURITY_MAC_CTLFLAGS,
	   &amp;mac_vnode_enforce, 0, <span class="enscript-string">&quot;Enforce MAC policy on vnode operations&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_AUDIT</span>
<span class="enscript-comment">/*
 * mac_audit_data_zone is the zone used for data pushed into the audit
 * record by policies. Using a zone simplifies memory management of this
 * data, and allows tracking of the amount of data in flight.
 */</span>
<span class="enscript-type">extern</span> zone_t mac_audit_data_zone;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * mac_policy_list holds the list of policy modules.  Modules with a
 * handle lower than staticmax are considered &quot;static&quot; and cannot be
 * unloaded.  Such policies can be invoked without holding the busy count.
 *
 * Modules with a handle at or above the staticmax high water mark
 * are considered to be &quot;dynamic&quot; policies.  A busy count is maintained
 * for the list, stored in mac_policy_busy.  The busy count is protected
 * by mac_policy_mtx; the list may be modified only while the busy
 * count is 0, requiring that the lock be held to prevent new references
 * to the list from being acquired.  For almost all operations,
 * incrementing the busy count is sufficient to guarantee consistency,
 * as the list cannot be modified while the busy count is elevated.
 * For a few special operations involving a change to the list of
 * active policies, the mtx itself must be held.
 */</span>
<span class="enscript-type">static</span> lck_mtx_t *mac_policy_mtx;

<span class="enscript-comment">/*
 * Policy list array allocation chunk size. Trying to set this so that we
 * allocate a page at a time.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAC_POLICY_LIST_CHUNKSIZE</span> 512

<span class="enscript-type">static</span> <span class="enscript-type">int</span> mac_policy_busy;

mac_policy_list_t mac_policy_list;

<span class="enscript-comment">/*
 * mac_label_element_list holds the master list of label namespaces for
 * all the policies. When a policy is loaded, each of it's label namespace
 * elements is added to the master list if not already present. When a
 * policy is unloaded, the namespace elements are removed if no other 
 * policy is interested in that namespace element.
 */</span>
<span class="enscript-type">struct</span> mac_label_element_list_t mac_label_element_list;
<span class="enscript-type">struct</span> mac_label_element_list_t mac_static_label_element_list;

<span class="enscript-type">static</span> __inline <span class="enscript-type">void</span>
<span class="enscript-function-name">mac_policy_grab_exclusive</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock(mac_policy_mtx);
	<span class="enscript-keyword">while</span> (mac_policy_busy != 0) {
		lck_mtx_sleep(mac_policy_mtx, LCK_SLEEP_UNLOCK,
			      (event_t)&amp;mac_policy_busy, THREAD_UNINT);
		lck_mtx_lock(mac_policy_mtx);
	}
}

<span class="enscript-type">static</span> __inline <span class="enscript-type">void</span>
<span class="enscript-function-name">mac_policy_release_exclusive</span>(<span class="enscript-type">void</span>)
{

	KASSERT(mac_policy_busy == 0,
	    (<span class="enscript-string">&quot;mac_policy_release_exclusive(): not exclusive&quot;</span>));
	lck_mtx_unlock(mac_policy_mtx);
	thread_wakeup((event_t) &amp;mac_policy_busy);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mac_policy_list_busy</span>(<span class="enscript-type">void</span>)
{
        lck_mtx_lock(mac_policy_mtx);
	mac_policy_busy++;
	lck_mtx_unlock(mac_policy_mtx);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_policy_list_conditional_busy</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> ret;

	<span class="enscript-keyword">if</span> (mac_policy_list.numloaded &lt;= mac_policy_list.staticmax)
		<span class="enscript-keyword">return</span>(0);

	lck_mtx_lock(mac_policy_mtx);
	<span class="enscript-keyword">if</span> (mac_policy_list.numloaded &gt; mac_policy_list.staticmax) {
		mac_policy_busy++;
		ret = 1;
	} <span class="enscript-keyword">else</span>
		ret = 0;
	lck_mtx_unlock(mac_policy_mtx);
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mac_policy_list_unbusy</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock(mac_policy_mtx);
	mac_policy_busy--;
	KASSERT(mac_policy_busy &gt;= 0, (<span class="enscript-string">&quot;MAC_POLICY_LIST_LOCK&quot;</span>));
	<span class="enscript-keyword">if</span> (mac_policy_busy == 0)
		thread_wakeup(&amp;mac_policy_busy);
	lck_mtx_unlock(mac_policy_mtx);
}

<span class="enscript-comment">/*
 * Early pre-malloc MAC initialization, including appropriate SMP locks.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mac_policy_init</span>(<span class="enscript-type">void</span>)
{
	lck_grp_attr_t *mac_lck_grp_attr;
	lck_attr_t *mac_lck_attr;
	lck_grp_t *mac_lck_grp;

	mac_policy_list.numloaded = 0;
	mac_policy_list.max = MAC_POLICY_LIST_CHUNKSIZE;
	mac_policy_list.maxindex = 0;
	mac_policy_list.staticmax = 0;
	mac_policy_list.freehint = 0;
	mac_policy_list.chunks = 1;

	mac_policy_list.entries = kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mac_policy_list_element) * MAC_POLICY_LIST_CHUNKSIZE);
	bzero(mac_policy_list.entries, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mac_policy_list_element) * MAC_POLICY_LIST_CHUNKSIZE); 

	LIST_INIT(&amp;mac_label_element_list);
	LIST_INIT(&amp;mac_static_label_element_list);

	mac_lck_grp_attr = lck_grp_attr_alloc_init();
	lck_grp_attr_setstat(mac_lck_grp_attr);
	mac_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;MAC lock&quot;</span>, mac_lck_grp_attr);
	mac_lck_attr = lck_attr_alloc_init();
	lck_attr_setdefault(mac_lck_attr);
	mac_policy_mtx = lck_mtx_alloc_init(mac_lck_grp, mac_lck_attr);
	lck_attr_free(mac_lck_attr);
	lck_grp_attr_free(mac_lck_grp_attr);
	lck_grp_free(mac_lck_grp);
	
	mac_labelzone_init();
}

<span class="enscript-comment">/* Function pointer set up for loading security extensions.
 * It is set to an actual function after OSlibkernInit()
 * has been called, and is set back to 0 by OSKextRemoveKextBootstrap()
 * after bsd_init().
 */</span>
<span class="enscript-function-name">void</span> (*load_security_extensions_function)(<span class="enscript-type">void</span>) = 0;

<span class="enscript-comment">/*
 * Init after early Mach startup, but before BSD
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mac_policy_initmach</span>(<span class="enscript-type">void</span>)
{

	<span class="enscript-comment">/*
	 * For the purposes of modules that want to know if they were
	 * loaded &quot;early&quot;, set the mac_late flag once we've processed
	 * modules either linked into the kernel, or loaded before the
	 * kernel startup.
	 */</span>

	<span class="enscript-keyword">if</span> (load_security_extensions_function) {
		load_security_extensions_function();
	}
	mac_late = 1;
}

<span class="enscript-comment">/*
 * BSD startup.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mac_policy_initbsd</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> mac_policy_conf *mpc;
	u_int i;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_AUDIT</span>
	mac_audit_data_zone = zinit(MAC_AUDIT_DATA_LIMIT,
				    AQ_HIWATER * MAC_AUDIT_DATA_LIMIT,
				    8192, <span class="enscript-string">&quot;mac_audit_data_zone&quot;</span>);
#<span class="enscript-reference">endif</span>

	printf(<span class="enscript-string">&quot;MAC Framework successfully initialized\n&quot;</span>);

	<span class="enscript-comment">/* Call bsd init functions of already loaded policies */</span>

	<span class="enscript-comment">/*
	 * Using the exclusive lock means no other framework entry
	 * points can proceed while initializations are running.
	 * This may not be necessary.
	 */</span>
	mac_policy_grab_exclusive();

	<span class="enscript-keyword">for</span> (i = 0; i &lt;= mac_policy_list.maxindex; i++) {
		mpc = mac_get_mpc(i);
		<span class="enscript-keyword">if</span> ((mpc != NULL) &amp;&amp; (mpc-&gt;mpc_ops-&gt;mpo_policy_initbsd != NULL))
			(*(mpc-&gt;mpc_ops-&gt;mpo_policy_initbsd))(mpc);
	}

	mac_policy_release_exclusive();
}

<span class="enscript-comment">/*
 * After a policy has been loaded, add the label namespaces managed by the
 * policy to either the static or non-static label namespace list.  
 * A namespace is added to the the list only if it is not already on one of 
 * the lists.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mac_policy_addto_labellist</span>(mac_policy_handle_t handle, <span class="enscript-type">int</span> static_entry)
{
	<span class="enscript-type">struct</span> mac_label_listener **new_mlls;
	<span class="enscript-type">struct</span> mac_label_element *mle, **new_mles;
	<span class="enscript-type">struct</span> mac_label_element_list_t *list;
	<span class="enscript-type">struct</span> mac_policy_conf *mpc;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, *name2;
	u_int idx, mle_free, mll_free;

	mpc = mac_get_mpc(handle);

	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_labelnames == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_labelname_count == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (static_entry)
		list = &amp;mac_static_label_element_list;
	<span class="enscript-keyword">else</span>
		list = &amp;mac_label_element_list;

	<span class="enscript-comment">/*
	 * Before we grab the policy list lock, allocate enough memory
	 * to contain the potential new elements so we don't have to 
	 * give up the lock, or allocate with the lock held.
	 */</span>
	MALLOC(new_mles, <span class="enscript-type">struct</span> mac_label_element **,
	    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mac_label_element *) *
	    mpc-&gt;mpc_labelname_count, M_MACTEMP, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">for</span> (idx = 0; idx &lt; mpc-&gt;mpc_labelname_count; idx++)
		MALLOC(new_mles[idx], <span class="enscript-type">struct</span> mac_label_element *, 
		    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mac_label_element),
		    M_MACTEMP, M_WAITOK);
	mle_free = 0;
	MALLOC(new_mlls, <span class="enscript-type">struct</span> mac_label_listener **,
	    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mac_label_listener *) *
	    mpc-&gt;mpc_labelname_count, M_MACTEMP, M_WAITOK);
	<span class="enscript-keyword">for</span> (idx = 0; idx &lt; mpc-&gt;mpc_labelname_count; idx++)
		MALLOC(new_mlls[idx], <span class="enscript-type">struct</span> mac_label_listener *,
		    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mac_label_listener), M_MACTEMP, M_WAITOK);
	mll_free = 0;

	<span class="enscript-keyword">if</span> (mac_late)
		mac_policy_grab_exclusive();
	<span class="enscript-keyword">for</span> (idx = 0; idx &lt; mpc-&gt;mpc_labelname_count; idx++) {

		<span class="enscript-keyword">if</span> (*(name = mpc-&gt;mpc_labelnames[idx]) == <span class="enscript-string">'?'</span>)
			name++;
		<span class="enscript-comment">/*
		 * Check both label element lists and add to the 
		 * appropriate list only if not already on a list.
		 */</span>
		LIST_FOREACH(mle, &amp;mac_static_label_element_list, mle_list) {
			<span class="enscript-keyword">if</span> (*(name2 = mle-&gt;mle_name) == <span class="enscript-string">'?'</span>)
				name2++;
			<span class="enscript-keyword">if</span> (strcmp(name, name2) == 0)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (mle == NULL) {
			LIST_FOREACH(mle, &amp;mac_label_element_list, mle_list) {
				<span class="enscript-keyword">if</span> (*(name2 = mle-&gt;mle_name) == <span class="enscript-string">'?'</span>)
					name2++;
				<span class="enscript-keyword">if</span> (strcmp(name, name2) == 0)
					<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (mle == NULL) {
			mle = new_mles[mle_free];
			strlcpy(mle-&gt;mle_name, mpc-&gt;mpc_labelnames[idx],
					MAC_MAX_LABEL_ELEMENT_NAME);
			LIST_INIT(&amp;mle-&gt;mle_listeners);
			LIST_INSERT_HEAD(list, mle, mle_list);
			mle_free++;
		}
		<span class="enscript-comment">/* Add policy handler as a listener. */</span>
		new_mlls[mll_free]-&gt;mll_handle = handle;
		LIST_INSERT_HEAD(&amp;mle-&gt;mle_listeners, new_mlls[mll_free],
		    mll_list);
		mll_free++;
	}
	<span class="enscript-keyword">if</span> (mac_late)
		mac_policy_release_exclusive();

	<span class="enscript-comment">/* Free up any unused label elements and listeners */</span>
	<span class="enscript-keyword">for</span> (idx = mle_free; idx &lt; mpc-&gt;mpc_labelname_count; idx++)
		FREE(new_mles[idx], M_MACTEMP);
	FREE(new_mles, M_MACTEMP);
	<span class="enscript-keyword">for</span> (idx = mll_free; idx &lt; mpc-&gt;mpc_labelname_count; idx++)
		FREE(new_mlls[idx], M_MACTEMP);
	FREE(new_mlls, M_MACTEMP);
}

<span class="enscript-comment">/*
 * After a policy has been unloaded, remove the label namespaces that the
 * the policy manages from the non-static list of namespaces.
 * The removal only takes place when no other policy is interested in the
 * namespace.
 *
 * Must be called with the policy exclusive lock held.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mac_policy_removefrom_labellist</span>(mac_policy_handle_t handle)
{
	<span class="enscript-type">struct</span> mac_label_listener *mll;
	<span class="enscript-type">struct</span> mac_label_element *mle;
	<span class="enscript-type">struct</span> mac_policy_conf *mpc;

	mpc = mac_get_mpc(handle);

	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_labelnames == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_labelname_count == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Unregister policy as being interested in any label
	 * namespaces.  If no other policy is listening, remove
	 * that label element from the list.  Note that we only
	 * have to worry about the non-static list.
	 */</span>
	LIST_FOREACH(mle, &amp;mac_label_element_list, mle_list) {
		LIST_FOREACH(mll, &amp;mle-&gt;mle_listeners, mll_list) {
			<span class="enscript-keyword">if</span> (mll-&gt;mll_handle == handle) {
				LIST_REMOVE(mll, mll_list);
				FREE(mll, M_MACTEMP);
				<span class="enscript-keyword">if</span> (LIST_EMPTY(&amp;mle-&gt;mle_listeners)) {
					LIST_REMOVE(mle, mle_list);
					FREE(mle, M_MACTEMP);
				}
				<span class="enscript-keyword">return</span>;
			}
		}
	}
}

<span class="enscript-comment">/*
 * After the policy list has changed, walk the list to update any global
 * flags.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mac_policy_updateflags</span>(<span class="enscript-type">void</span>)
{
}

<span class="enscript-type">static</span> __inline <span class="enscript-type">void</span>
<span class="enscript-function-name">mac_policy_fixup_mmd_list</span>(<span class="enscript-type">struct</span> mac_module_data *new)
{
	<span class="enscript-type">struct</span> mac_module_data *old;
	<span class="enscript-type">struct</span> mac_module_data_element *ele, *aele;
	<span class="enscript-type">struct</span> mac_module_data_list *arr, *dict;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i, j, k;

	old = new-&gt;base_addr;
	DPRINTF((<span class="enscript-string">&quot;fixup_mmd: old %p new %p\n&quot;</span>, old, new));
	<span class="enscript-keyword">for</span> (i = 0; i &lt; new-&gt;count; i++) {
		ele = &amp;(new-&gt;data[i]);
		DPRINTF((<span class="enscript-string">&quot;fixup_mmd: ele %p\n&quot;</span>, ele));
		DPRINTF((<span class="enscript-string">&quot;   key %p value %p\n&quot;</span>, ele-&gt;key, ele-&gt;value));
		mmd_fixup_ele(old, new, ele); <span class="enscript-comment">/* Fix up key/value ptrs.       */</span>
		DPRINTF((<span class="enscript-string">&quot;   key %p value %p\n&quot;</span>, ele-&gt;key, ele-&gt;value));
		<span class="enscript-keyword">if</span> (ele-&gt;value_type == MAC_DATA_TYPE_ARRAY) {
			arr = (<span class="enscript-type">struct</span> mac_module_data_list *)ele-&gt;value;
			DPRINTF((<span class="enscript-string">&quot;fixup_mmd: array @%p\n&quot;</span>, arr));
			<span class="enscript-keyword">for</span> (j = 0; j &lt; arr-&gt;count; j++) {
				aele = &amp;(arr-&gt;list[j]);
				DPRINTF((<span class="enscript-string">&quot;fixup_mmd: aele %p\n&quot;</span>, aele));
				DPRINTF((<span class="enscript-string">&quot;   key %p value %p\n&quot;</span>, aele-&gt;key, aele-&gt;value));
				mmd_fixup_ele(old, new, aele);
				DPRINTF((<span class="enscript-string">&quot;   key %p value %p\n&quot;</span>, aele-&gt;key, aele-&gt;value));
				<span class="enscript-keyword">if</span> (arr-&gt;type == MAC_DATA_TYPE_DICT) {
					dict = (<span class="enscript-type">struct</span> mac_module_data_list *)aele-&gt;value;
					DPRINTF((<span class="enscript-string">&quot;fixup_mmd: dict @%p\n&quot;</span>, dict));
					<span class="enscript-keyword">for</span> (k = 0; k &lt; dict-&gt;count; k++)
						mmd_fixup_ele(old, new,
						    &amp;(dict-&gt;list[k]));
				}
			}
		}
	}
	new-&gt;base_addr = new;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_policy_register</span>(<span class="enscript-type">struct</span> mac_policy_conf *mpc, mac_policy_handle_t *handlep,
    <span class="enscript-type">void</span> *xd)
{
	<span class="enscript-type">struct</span> mac_policy_list_element *tmac_policy_list_element;
	<span class="enscript-type">int</span> error, slot, static_entry = 0;
	u_int i;

	<span class="enscript-comment">/*
	 * Some preliminary checks to make sure the policy's conf structure
	 * contains the required fields.
	 */</span>
	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_name == NULL)
		panic(<span class="enscript-string">&quot;policy's name is not set\n&quot;</span>);

	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_fullname == NULL)
		panic(<span class="enscript-string">&quot;policy's full name is not set\n&quot;</span>);

	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_labelname_count &gt; MAC_MAX_MANAGED_NAMESPACES)
		panic(<span class="enscript-string">&quot;policy's managed label namespaces exceeds maximum\n&quot;</span>);

	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_ops == NULL)
		panic(<span class="enscript-string">&quot;policy's OPs field is NULL\n&quot;</span>);

	error = 0;

	<span class="enscript-keyword">if</span> (mac_late) {
		<span class="enscript-keyword">if</span> (mpc-&gt;mpc_loadtime_flags &amp; MPC_LOADTIME_FLAG_NOTLATE) {
			printf(<span class="enscript-string">&quot;Module %s does not support late loading.\n&quot;</span>,
			    mpc-&gt;mpc_name);
			<span class="enscript-keyword">return</span> (EPERM);
		}
		mac_policy_grab_exclusive();
	}

	<span class="enscript-keyword">if</span> (mac_policy_list.numloaded &gt;= mac_policy_list.max) {
		<span class="enscript-comment">/* allocate new policy list array, zero new chunk */</span>
		tmac_policy_list_element =
		    kalloc((<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mac_policy_list_element) *
		    MAC_POLICY_LIST_CHUNKSIZE) * (mac_policy_list.chunks + 1));
		bzero(&amp;tmac_policy_list_element[mac_policy_list.max],
		    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mac_policy_list_element) *
		    MAC_POLICY_LIST_CHUNKSIZE);
		
		<span class="enscript-comment">/* copy old entries into new list */</span>
		memcpy(tmac_policy_list_element, mac_policy_list.entries, 
		   <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mac_policy_list_element) *
		   MAC_POLICY_LIST_CHUNKSIZE * mac_policy_list.chunks);
	
		<span class="enscript-comment">/* free old array */</span>
		kfree(mac_policy_list.entries,
		    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mac_policy_list_element) *
		    MAC_POLICY_LIST_CHUNKSIZE * mac_policy_list.chunks);
		
		mac_policy_list.entries = tmac_policy_list_element;

		<span class="enscript-comment">/* Update maximums, etc */</span>
		mac_policy_list.max += MAC_POLICY_LIST_CHUNKSIZE;
		mac_policy_list.chunks++;
	}

	<span class="enscript-comment">/* Check for policy with same name already loaded */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt;= mac_policy_list.maxindex; i++) {
		<span class="enscript-keyword">if</span> (mac_policy_list.entries[i].mpc == NULL) 
			<span class="enscript-keyword">continue</span>;	

		<span class="enscript-keyword">if</span> (strcmp(mac_policy_list.entries[i].mpc-&gt;mpc_name,
		    mpc-&gt;mpc_name) == 0) {
			error = EEXIST;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_field_off != NULL) {
		slot = ffs(mac_slot_offsets_free);
		<span class="enscript-keyword">if</span> (slot == 0) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		slot--;
		mac_slot_offsets_free &amp;= ~(1 &lt;&lt; slot);
		*mpc-&gt;mpc_field_off = slot;
	}
	mpc-&gt;mpc_runtime_flags |= MPC_RUNTIME_FLAG_REGISTERED;

	<span class="enscript-keyword">if</span> (xd) {
		<span class="enscript-type">struct</span> mac_module_data *mmd = xd; <span class="enscript-comment">/* module data from plist */</span>

		<span class="enscript-comment">/* Make a copy of the data. */</span>
		mpc-&gt;mpc_data = (<span class="enscript-type">void</span> *)kalloc(mmd-&gt;size);
		<span class="enscript-keyword">if</span> (mpc-&gt;mpc_data != NULL) {
			memcpy(mpc-&gt;mpc_data, mmd, mmd-&gt;size);

			<span class="enscript-comment">/* Fix up pointers after copy. */</span>
			mac_policy_fixup_mmd_list(mpc-&gt;mpc_data);
		}
	}

	<span class="enscript-comment">/* Find the first free handle in the list (using our hint). */</span>
	<span class="enscript-keyword">for</span> (i = mac_policy_list.freehint; i &lt; mac_policy_list.max; i++) {
		<span class="enscript-keyword">if</span> (mac_policy_list.entries[i].mpc == NULL) {
			*handlep = i;
			mac_policy_list.freehint = ++i;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">/*
	 * If we are loading a MAC module before the framework has
	 * finished initializing or the module is not unloadable and
	 * we can place its handle adjacent to the last static entry,
	 * bump the static policy high water mark.
	 * Static policies can get by with weaker locking requirements.
	 */</span>
	<span class="enscript-keyword">if</span> (!mac_late ||
	    ((mpc-&gt;mpc_loadtime_flags &amp; MPC_LOADTIME_FLAG_UNLOADOK) == 0 &amp;&amp;
	    *handlep == mac_policy_list.staticmax)) {
		static_entry = 1;
		mac_policy_list.staticmax++;
	}

	mac_policy_list.entries[*handlep].mpc = mpc;

	<span class="enscript-comment">/* Update counters, etc */</span>
	<span class="enscript-keyword">if</span> (*handlep &gt; mac_policy_list.maxindex) 
		mac_policy_list.maxindex = *handlep;
	mac_policy_list.numloaded++;
	
	<span class="enscript-comment">/* Per-policy initialization. */</span>
	printf (<span class="enscript-string">&quot;calling mpo_policy_init for %s\n&quot;</span>, mpc-&gt;mpc_name);
	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_ops-&gt;mpo_policy_init != NULL)
		(*(mpc-&gt;mpc_ops-&gt;mpo_policy_init))(mpc);

	<span class="enscript-keyword">if</span> (mac_late &amp;&amp; mpc-&gt;mpc_ops-&gt;mpo_policy_initbsd != NULL) {
		printf (<span class="enscript-string">&quot;calling mpo_policy_initbsd for %s\n&quot;</span>, mpc-&gt;mpc_name);
		(*(mpc-&gt;mpc_ops-&gt;mpo_policy_initbsd))(mpc);
	}

	mac_policy_updateflags();

	<span class="enscript-keyword">if</span> (mac_late)
		mac_policy_release_exclusive();

	mac_policy_addto_labellist(*handlep, static_entry);

	printf(<span class="enscript-string">&quot;Security policy loaded: %s (%s)\n&quot;</span>, mpc-&gt;mpc_fullname,
	    mpc-&gt;mpc_name);

	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (mac_late)
		mac_policy_release_exclusive();

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_policy_unregister</span>(mac_policy_handle_t handle)
{
	<span class="enscript-type">struct</span> mac_policy_conf *mpc;

	<span class="enscript-comment">/*
	 * If we fail the load, we may get a request to unload.  Check
	 * to see if we did the run-time registration, and if not,
	 * silently succeed.
	 */</span>
	mac_policy_grab_exclusive();
	mpc = mac_get_mpc(handle);
	<span class="enscript-keyword">if</span> ((mpc-&gt;mpc_runtime_flags &amp; MPC_RUNTIME_FLAG_REGISTERED) == 0) {
		mac_policy_release_exclusive();
		<span class="enscript-keyword">return</span> (0);
	}

#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * Don't allow unloading modules with private data.
	 */</span>
	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_field_off != NULL) {
		MAC_POLICY_LIST_UNLOCK();
		<span class="enscript-keyword">return</span> (EBUSY);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Only allow the unload to proceed if the module is unloadable
	 * by its own definition.
	 */</span>
	<span class="enscript-keyword">if</span> ((mpc-&gt;mpc_loadtime_flags &amp; MPC_LOADTIME_FLAG_UNLOADOK) == 0) {
		mac_policy_release_exclusive();
		<span class="enscript-keyword">return</span> (EBUSY);
	}

	mac_policy_removefrom_labellist(handle);

	mac_get_mpc(handle) = NULL;
	<span class="enscript-keyword">if</span> (handle &lt; mac_policy_list.freehint &amp;&amp;
	    handle &gt;= mac_policy_list.staticmax)
		mac_policy_list.freehint = handle;

	<span class="enscript-keyword">if</span> (handle == mac_policy_list.maxindex)
		mac_policy_list.maxindex--;

	mac_policy_list.numloaded--; 
	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_field_off != NULL) {
		mac_slot_offsets_free |= (1 &lt;&lt; *mpc-&gt;mpc_field_off);
	}

	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_ops-&gt;mpo_policy_destroy != NULL)
		(*(mpc-&gt;mpc_ops-&gt;mpo_policy_destroy))(mpc);

	mpc-&gt;mpc_runtime_flags &amp;= ~MPC_RUNTIME_FLAG_REGISTERED;
	mac_policy_updateflags();

	mac_policy_release_exclusive();

	<span class="enscript-keyword">if</span> (mpc-&gt;mpc_data) {
		<span class="enscript-type">struct</span> mac_module_data *mmd = mpc-&gt;mpc_data;
		kfree(mmd, mmd-&gt;size);
		mpc-&gt;mpc_data = NULL;
	}

	printf(<span class="enscript-string">&quot;Security policy unload: %s (%s)\n&quot;</span>, mpc-&gt;mpc_fullname,
	    mpc-&gt;mpc_name);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Define an error value precedence, and given two arguments, selects the
 * value with the higher precedence.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_error_select</span>(<span class="enscript-type">int</span> error1, <span class="enscript-type">int</span> error2)
{

	<span class="enscript-comment">/* Certain decision-making errors take top priority. */</span>
	<span class="enscript-keyword">if</span> (error1 == EDEADLK || error2 == EDEADLK)
		<span class="enscript-keyword">return</span> (EDEADLK);

	<span class="enscript-comment">/* Invalid arguments should be reported where possible. */</span>
	<span class="enscript-keyword">if</span> (error1 == EINVAL || error2 == EINVAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* Precedence goes to &quot;visibility&quot;, with both process and file. */</span>
	<span class="enscript-keyword">if</span> (error1 == ESRCH || error2 == ESRCH)
		<span class="enscript-keyword">return</span> (ESRCH);

	<span class="enscript-keyword">if</span> (error1 == ENOENT || error2 == ENOENT)
		<span class="enscript-keyword">return</span> (ENOENT);

	<span class="enscript-comment">/* Precedence goes to DAC/MAC protections. */</span>
	<span class="enscript-keyword">if</span> (error1 == EACCES || error2 == EACCES)
		<span class="enscript-keyword">return</span> (EACCES);

	<span class="enscript-comment">/* Precedence goes to privilege. */</span>
	<span class="enscript-keyword">if</span> (error1 == EPERM || error2 == EPERM)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-comment">/* Precedence goes to error over success; otherwise, arbitrary. */</span>
	<span class="enscript-keyword">if</span> (error1 != 0)
		<span class="enscript-keyword">return</span> (error1);
	<span class="enscript-keyword">return</span> (error2);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mac_label_init</span>(<span class="enscript-type">struct</span> label *label)
{

	bzero(label, <span class="enscript-keyword">sizeof</span>(*label));
	label-&gt;l_flags = MAC_FLAG_INITIALIZED;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mac_label_destroy</span>(<span class="enscript-type">struct</span> label *label)
{

	KASSERT(label-&gt;l_flags &amp; MAC_FLAG_INITIALIZED,
	    (<span class="enscript-string">&quot;destroying uninitialized label&quot;</span>));

	bzero(label, <span class="enscript-keyword">sizeof</span>(*label));
	<span class="enscript-comment">/* implicit: label-&gt;l_flags &amp;= ~MAC_FLAG_INITIALIZED; */</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_check_structmac_consistent</span>(<span class="enscript-type">struct</span> user_mac *mac)
{

	<span class="enscript-keyword">if</span> (mac-&gt;m_buflen &gt; MAC_MAX_LABEL_BUF_LEN || mac-&gt;m_buflen == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Get the external forms of labels from all policies, for a single
 * label namespace or &quot;*&quot; for all namespaces.  Returns ENOENT if no policy
 * is registered for the namespace, unless the namespace begins with a '?'.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mac_label_externalize</span>(size_t mpo_externalize_off, <span class="enscript-type">struct</span> label *label,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *element, <span class="enscript-type">struct</span> sbuf *sb)
{
	<span class="enscript-type">struct</span> mac_policy_conf *mpc;
	<span class="enscript-type">struct</span> mac_label_listener *mll;
	<span class="enscript-type">struct</span> mac_label_element *mle;
	<span class="enscript-type">struct</span> mac_label_element_list_t *element_list;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name;
	<span class="enscript-type">int</span> (*mpo_externalize)(<span class="enscript-type">struct</span> label *, <span class="enscript-type">char</span> *, <span class="enscript-type">struct</span> sbuf *);
	<span class="enscript-type">int</span> all_labels = 0, ignorenotfound = 0, error = 0, busy = FALSE;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count = 0;

	<span class="enscript-keyword">if</span> (element[0] == <span class="enscript-string">'?'</span>) {
		element++;
		ignorenotfound = 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (element[0] == <span class="enscript-string">'*'</span> &amp;&amp; element[1] == <span class="enscript-string">'\0'</span>)
		all_labels = 1;

	element_list = &amp;mac_static_label_element_list;
<span class="enscript-reference">element_loop</span>:
	LIST_FOREACH(mle, element_list, mle_list) {
		name = mle-&gt;mle_name;
		<span class="enscript-keyword">if</span> (all_labels) {
			<span class="enscript-keyword">if</span> (*name == <span class="enscript-string">'?'</span>)
			    <span class="enscript-keyword">continue</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (*name == <span class="enscript-string">'?'</span>)
				name++;
			<span class="enscript-keyword">if</span> (strcmp(name, element) != 0)
				<span class="enscript-keyword">continue</span>;
		}
		LIST_FOREACH(mll, &amp;mle-&gt;mle_listeners, mll_list) {
			mpc = mac_policy_list.entries[mll-&gt;mll_handle].mpc;
			<span class="enscript-keyword">if</span> (mpc == NULL)
				<span class="enscript-keyword">continue</span>;
			mpo_externalize = *(typeof(mpo_externalize) *)
			    ((<span class="enscript-type">char</span> *)mpc-&gt;mpc_ops + mpo_externalize_off);
			<span class="enscript-keyword">if</span> (mpo_externalize == NULL)
				<span class="enscript-keyword">continue</span>;
			error = sbuf_printf(sb, <span class="enscript-string">&quot;%s/&quot;</span>, name);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			error = mpo_externalize(label, mle-&gt;mle_name, sb);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">if</span> (error != ENOENT)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				<span class="enscript-comment">/*
				 * If a policy doesn't have a label to
				 * externalize it returns ENOENT.  This
				 * may occur for policies that support
				 * multiple label elements for some
				 * (but not all) object types.
				 */</span>
				sbuf_setpos(sb, sbuf_len(sb) -
				    (strlen(name) + 1));
				error = 0;
				<span class="enscript-keyword">continue</span>;
			}
			error = sbuf_putc(sb, <span class="enscript-string">','</span>);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			count++;
		}
	}
	<span class="enscript-comment">/* If there are dynamic policies present, check their elements too. */</span>
	<span class="enscript-keyword">if</span> (!busy &amp;&amp; mac_policy_list_conditional_busy() == 1) {
		element_list = &amp;mac_label_element_list;
		busy = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">element_loop</span>;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (busy)
		mac_policy_list_unbusy();
	<span class="enscript-keyword">if</span> (!error &amp;&amp; count == 0) {
		<span class="enscript-keyword">if</span> (!all_labels &amp;&amp; !ignorenotfound)
			error = ENOENT;	<span class="enscript-comment">/* XXX: ENOLABEL? */</span>
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Get the external forms of labels from all policies, for all label
 * namespaces contained in a list.
 *
 * XXX This may be leaking an sbuf.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_externalize</span>(size_t mpo_externalize_off, <span class="enscript-type">struct</span> label *label,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *elementlist, <span class="enscript-type">char</span> *outbuf, size_t outbuflen)
{
	<span class="enscript-type">char</span> *element;
	<span class="enscript-type">char</span> *scratch_base;
	<span class="enscript-type">char</span> *scratch;
	<span class="enscript-type">struct</span> sbuf sb;
	<span class="enscript-type">int</span> error = 0, len;

	<span class="enscript-comment">/* allocate a scratch buffer the size of the string */</span>
	MALLOC(scratch_base, <span class="enscript-type">char</span> *, strlen(elementlist)+1, M_MACTEMP, M_WAITOK); 
	<span class="enscript-keyword">if</span> (scratch_base == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* copy the elementlist to the scratch buffer */</span>
	strlcpy(scratch_base, elementlist, strlen(elementlist)+1);

	<span class="enscript-comment">/*
	 * set up a temporary pointer that can be used to iterate the
	 * scratch buffer without losing the allocation address
	 */</span>
	scratch = scratch_base;

	<span class="enscript-comment">/* get an sbuf */</span>
	<span class="enscript-keyword">if</span> (sbuf_new(&amp;sb, outbuf, outbuflen, SBUF_FIXEDLEN) == NULL) {
		<span class="enscript-comment">/* could not allocate interior buffer */</span>
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/* iterate the scratch buffer; NOTE: buffer contents modified! */</span>
	<span class="enscript-keyword">while</span> ((element = strsep(&amp;scratch, <span class="enscript-string">&quot;,&quot;</span>)) != NULL) {
		error = mac_label_externalize(mpo_externalize_off, label,
		    element, &amp;sb);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> ((len = sbuf_len(&amp;sb)) &gt; 0)
		sbuf_setpos(&amp;sb, len - 1);	<span class="enscript-comment">/* trim trailing comma */</span>
	sbuf_finish(&amp;sb);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (scratch_base != NULL)
		FREE(scratch_base, M_MACTEMP);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Have all policies set the internal form of a label, for a single
 * label namespace.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mac_label_internalize</span>(size_t mpo_internalize_off, <span class="enscript-type">struct</span> label *label,
    <span class="enscript-type">char</span> *element_name, <span class="enscript-type">char</span> *element_data)
{
	<span class="enscript-type">struct</span> mac_policy_conf *mpc;
	<span class="enscript-type">struct</span> mac_label_listener *mll;
	<span class="enscript-type">struct</span> mac_label_element *mle;
	<span class="enscript-type">struct</span> mac_label_element_list_t *element_list;
	<span class="enscript-type">int</span> (*mpo_internalize)(<span class="enscript-type">struct</span> label *, <span class="enscript-type">char</span> *, <span class="enscript-type">char</span> *);
	<span class="enscript-type">int</span> error = 0, busy = FALSE;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count = 0;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name;

	element_list = &amp;mac_static_label_element_list;
<span class="enscript-reference">element_loop</span>:
	LIST_FOREACH(mle, element_list, mle_list) {
		<span class="enscript-keyword">if</span> (*(name = mle-&gt;mle_name) == <span class="enscript-string">'?'</span>)
			name++;
		<span class="enscript-keyword">if</span> (strcmp(element_name, name) != 0)
			<span class="enscript-keyword">continue</span>;
		LIST_FOREACH(mll, &amp;mle-&gt;mle_listeners, mll_list) {
			mpc = mac_policy_list.entries[mll-&gt;mll_handle].mpc;
			<span class="enscript-keyword">if</span> (mpc == NULL)
				<span class="enscript-keyword">continue</span>;
			mpo_internalize = *(typeof(mpo_internalize) *)
			    ((<span class="enscript-type">char</span> *)mpc-&gt;mpc_ops + mpo_internalize_off);
			<span class="enscript-keyword">if</span> (mpo_internalize == NULL)
				<span class="enscript-keyword">continue</span>;
			error = mpo_internalize(label, element_name,
			    element_data);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			count++;
		}
	}
	<span class="enscript-comment">/* If there are dynamic policies present, check their elements too. */</span>
	<span class="enscript-keyword">if</span> (!busy &amp;&amp; mac_policy_list_conditional_busy() == 1) {
		element_list = &amp;mac_label_element_list;
		busy = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">element_loop</span>;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (busy)
		mac_policy_list_unbusy();
	<span class="enscript-keyword">if</span> (!error &amp;&amp; count == 0)
		error = ENOPOLICY;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_internalize</span>(size_t mpo_internalize_off, <span class="enscript-type">struct</span> label *label,
    <span class="enscript-type">char</span> *textlabels)
{
	<span class="enscript-type">char</span> *element_name, *element_data;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">while</span> (!error &amp;&amp; (element_name = strsep(&amp;textlabels, <span class="enscript-string">&quot;,&quot;</span>)) != NULL) {
		element_data = strchr(element_name, <span class="enscript-string">'/'</span>);
		<span class="enscript-keyword">if</span> (element_data == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		*element_data++ = <span class="enscript-string">'\0'</span>;
		error = mac_label_internalize(mpo_internalize_off, label,
		    element_name, element_data);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* system calls */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_get_pid</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> __mac_get_pid_args *uap, <span class="enscript-type">int</span> *ret __unused)
{
	<span class="enscript-type">char</span> *elements, *buffer;
	<span class="enscript-type">struct</span> user_mac mac;
	<span class="enscript-type">struct</span> proc *tproc;
	<span class="enscript-type">struct</span> ucred *tcred;
	<span class="enscript-type">int</span> error;
	size_t ulen;

	AUDIT_ARG(pid, uap-&gt;pid);
	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		<span class="enscript-type">struct</span> user64_mac mac64;
		error = copyin(uap-&gt;mac_p, &amp;mac64, <span class="enscript-keyword">sizeof</span>(mac64));
		mac.m_buflen = mac64.m_buflen;
		mac.m_string = mac64.m_string;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_mac mac32;
		error = copyin(uap-&gt;mac_p, &amp;mac32, <span class="enscript-keyword">sizeof</span>(mac32));
		mac.m_buflen = mac32.m_buflen;
		mac.m_string = mac32.m_string;
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	error = mac_check_structmac_consistent(&amp;mac);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	tproc = proc_find(uap-&gt;pid);
	<span class="enscript-keyword">if</span> (tproc == NULL)
		<span class="enscript-keyword">return</span> (ESRCH);
	tcred = kauth_cred_proc_ref(tproc);
	proc_rele(tproc);

	MALLOC(elements, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK);
	error = copyinstr(mac.m_string, elements, mac.m_buflen, &amp;ulen);
	<span class="enscript-keyword">if</span> (error) {
		FREE(elements, M_MACTEMP);
		kauth_cred_unref(&amp;tcred);
		<span class="enscript-keyword">return</span> (error);
	}
	AUDIT_ARG(mac_string, elements);

	MALLOC(buffer, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK | M_ZERO);
	error = mac_cred_label_externalize(tcred-&gt;cr_label, elements,
	    buffer, mac.m_buflen, M_WAITOK);
	<span class="enscript-keyword">if</span> (error == 0)
		error = copyout(buffer, mac.m_string, strlen(buffer)+1);

	FREE(buffer, M_MACTEMP);
	FREE(elements, M_MACTEMP);
	kauth_cred_unref(&amp;tcred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_get_proc</span>(proc_t p, <span class="enscript-type">struct</span> __mac_get_proc_args *uap, <span class="enscript-type">int</span> *ret __unused)
{
	<span class="enscript-type">char</span> *elements, *buffer;
	<span class="enscript-type">struct</span> user_mac mac;
	kauth_cred_t cr;
	<span class="enscript-type">int</span> error;
	size_t ulen;

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		<span class="enscript-type">struct</span> user64_mac mac64;
		error = copyin(uap-&gt;mac_p, &amp;mac64, <span class="enscript-keyword">sizeof</span>(mac64));
		mac.m_buflen = mac64.m_buflen;
		mac.m_string = mac64.m_string;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_mac mac32;
		error = copyin(uap-&gt;mac_p, &amp;mac32, <span class="enscript-keyword">sizeof</span>(mac32));
		mac.m_buflen = mac32.m_buflen;
		mac.m_string = mac32.m_string;
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	error = mac_check_structmac_consistent(&amp;mac);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	MALLOC(elements, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK);
	error = copyinstr(mac.m_string, elements, mac.m_buflen, &amp;ulen);
	<span class="enscript-keyword">if</span> (error) {
		FREE(elements, M_MACTEMP);
		<span class="enscript-keyword">return</span> (error);
	}
	AUDIT_ARG(mac_string, elements);

	cr = kauth_cred_proc_ref(p);

	MALLOC(buffer, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK | M_ZERO);
	error = mac_cred_label_externalize(cr-&gt;cr_label,
	    elements, buffer, mac.m_buflen, M_WAITOK);
	<span class="enscript-keyword">if</span> (error == 0)
		error = copyout(buffer, mac.m_string, strlen(buffer)+1);

	FREE(buffer, M_MACTEMP);
	FREE(elements, M_MACTEMP);
	kauth_cred_unref(&amp;cr);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_set_proc</span>(proc_t p, <span class="enscript-type">struct</span> __mac_set_proc_args *uap, <span class="enscript-type">int</span> *ret __unused)
{
	<span class="enscript-type">struct</span> label *intlabel;
	<span class="enscript-type">struct</span> user_mac mac;
	<span class="enscript-type">char</span> *buffer;
	<span class="enscript-type">int</span> error;
	size_t ulen;

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		<span class="enscript-type">struct</span> user64_mac mac64;
		error = copyin(uap-&gt;mac_p, &amp;mac64, <span class="enscript-keyword">sizeof</span>(mac64));
		mac.m_buflen = mac64.m_buflen;
		mac.m_string = mac64.m_string;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_mac mac32;
		error = copyin(uap-&gt;mac_p, &amp;mac32, <span class="enscript-keyword">sizeof</span>(mac32));
		mac.m_buflen = mac32.m_buflen;
		mac.m_string = mac32.m_string;
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	error = mac_check_structmac_consistent(&amp;mac);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	MALLOC(buffer, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK);
	error = copyinstr(mac.m_string, buffer, mac.m_buflen, &amp;ulen);
	<span class="enscript-keyword">if</span> (error) {
		FREE(buffer, M_MACTEMP);
		<span class="enscript-keyword">return</span> (error);
	}
	AUDIT_ARG(mac_string, buffer);

	intlabel = mac_cred_label_alloc();
	error = mac_cred_label_internalize(intlabel, buffer);
	FREE(buffer, M_MACTEMP);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	error = mac_cred_check_label_update(kauth_cred_get(), intlabel);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = kauth_proc_label_update(p, intlabel);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

<span class="enscript-reference">out</span>:
	mac_cred_label_free(intlabel);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_get_fd</span>(proc_t p, <span class="enscript-type">struct</span> __mac_get_fd_args *uap, <span class="enscript-type">int</span> *ret __unused)
{
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">struct</span> user_mac mac;
	<span class="enscript-type">char</span> *elements, *buffer;
	<span class="enscript-type">int</span> error;
	size_t ulen;
	kauth_cred_t my_cred;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	<span class="enscript-type">struct</span> socket *so;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MAC_SOCKET */</span>
	<span class="enscript-type">struct</span> label *intlabel;

	AUDIT_ARG(fd, uap-&gt;fd);

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		<span class="enscript-type">struct</span> user64_mac mac64;
		error = copyin(uap-&gt;mac_p, &amp;mac64, <span class="enscript-keyword">sizeof</span>(mac64));
		mac.m_buflen = mac64.m_buflen;
		mac.m_string = mac64.m_string;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_mac mac32;
		error = copyin(uap-&gt;mac_p, &amp;mac32, <span class="enscript-keyword">sizeof</span>(mac32));
		mac.m_buflen = mac32.m_buflen;
		mac.m_string = mac32.m_string;
	}

	<span class="enscript-keyword">if</span> (error) 
		<span class="enscript-keyword">return</span> (error);

	error = mac_check_structmac_consistent(&amp;mac);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
			
	MALLOC(elements, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK);
	error = copyinstr(mac.m_string, elements, mac.m_buflen, &amp;ulen);
	<span class="enscript-keyword">if</span> (error) {
		FREE(elements, M_MACTEMP);
		<span class="enscript-keyword">return</span> (error);
	}
	AUDIT_ARG(mac_string, elements);

	MALLOC(buffer, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK);
	error = fp_lookup(p, uap-&gt;fd, &amp;fp, 0);
	<span class="enscript-keyword">if</span> (error) {
		FREE(buffer, M_MACTEMP);
		FREE(elements, M_MACTEMP);
		<span class="enscript-keyword">return</span> (error);
	}
	
	my_cred = kauth_cred_proc_ref(p);
	error = mac_file_check_get(my_cred, fp-&gt;f_fglob, elements, mac.m_buflen);
	kauth_cred_unref(&amp;my_cred);
	<span class="enscript-keyword">if</span> (error) {
		fp_drop(p, uap-&gt;fd, fp, 0);
		FREE(buffer, M_MACTEMP);
		FREE(elements, M_MACTEMP);
		<span class="enscript-keyword">return</span> (error);
	}
	
	<span class="enscript-keyword">switch</span> (FILEGLOB_DTYPE(fp-&gt;f_fglob)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_VNODE</span>:
			intlabel = mac_vnode_label_alloc();
			<span class="enscript-keyword">if</span> (intlabel == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">break</span>;
			}
			vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_fglob-&gt;fg_data;
			error = vnode_getwithref(vp);
			<span class="enscript-keyword">if</span> (error == 0) {
				mac_vnode_label_copy(vp-&gt;v_label, intlabel);
				error = mac_vnode_label_externalize(intlabel,
						elements, buffer,
						mac.m_buflen, M_WAITOK);
				vnode_put(vp);
			}
			mac_vnode_label_free(intlabel);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_SOCKET</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
			so = (<span class="enscript-type">struct</span> socket *) fp-&gt;f_fglob-&gt;fg_data;
			intlabel = mac_socket_label_alloc(MAC_WAITOK);
			sock_lock(so, 1);
			mac_socket_label_copy(so-&gt;so_label, intlabel);
			sock_unlock(so, 1);
			error = mac_socket_label_externalize(intlabel, elements, buffer, mac.m_buflen);
			mac_socket_label_free(intlabel);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PSXSHM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PSXSEM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PIPE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_KQUEUE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_FSEVENTS</span>:
		<span class="enscript-reference">default</span>:
			error = ENOSYS;   <span class="enscript-comment">// only sockets/vnodes so far
</span>			<span class="enscript-keyword">break</span>;
	}
	fp_drop(p, uap-&gt;fd, fp, 0);
	
	<span class="enscript-keyword">if</span> (error == 0)
		error = copyout(buffer, mac.m_string, strlen(buffer)+1);
		
	FREE(buffer, M_MACTEMP);
	FREE(elements, M_MACTEMP);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mac_get_filelink</span>(proc_t p, user_addr_t mac_p, user_addr_t path_p, <span class="enscript-type">int</span> follow)
{
	<span class="enscript-type">struct</span> vnode *vp;
	vfs_context_t ctx;
	<span class="enscript-type">char</span> *elements, *buffer;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">struct</span> label *intlabel;
	<span class="enscript-type">struct</span> user_mac mac;
	<span class="enscript-type">int</span> error;
	size_t ulen;

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		<span class="enscript-type">struct</span> user64_mac mac64;
		error = copyin(mac_p, &amp;mac64, <span class="enscript-keyword">sizeof</span>(mac64));
		mac.m_buflen = mac64.m_buflen;
		mac.m_string = mac64.m_string;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_mac mac32;
		error = copyin(mac_p, &amp;mac32, <span class="enscript-keyword">sizeof</span>(mac32));
		mac.m_buflen = mac32.m_buflen;
		mac.m_string = mac32.m_string;
	}

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	error = mac_check_structmac_consistent(&amp;mac);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	MALLOC(elements, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK);
	MALLOC(buffer, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK | M_ZERO);

	error = copyinstr(mac.m_string, elements, mac.m_buflen, &amp;ulen);
	<span class="enscript-keyword">if</span> (error) {
		FREE(buffer, M_MACTEMP);
		FREE(elements, M_MACTEMP);
		<span class="enscript-keyword">return</span> (error);
	}
	AUDIT_ARG(mac_string, elements);

	ctx = vfs_context_current();

	NDINIT(&amp;nd, LOOKUP, OP_LOOKUP,
		LOCKLEAF | (follow ? FOLLOW : NOFOLLOW) | AUDITVNPATH1,
		UIO_USERSPACE, path_p, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error) {
		FREE(buffer, M_MACTEMP);
		FREE(elements, M_MACTEMP);
		<span class="enscript-keyword">return</span> (error);
	}
	vp = nd.ni_vp;

	nameidone(&amp;nd);

	intlabel = mac_vnode_label_alloc();
	mac_vnode_label_copy(vp-&gt;v_label, intlabel);
	error = mac_vnode_label_externalize(intlabel, elements, buffer,
				    	    mac.m_buflen, M_WAITOK);
	mac_vnode_label_free(intlabel);
	<span class="enscript-keyword">if</span> (error == 0)
		error = copyout(buffer, mac.m_string, strlen(buffer) + 1);

	vnode_put(vp);

	FREE(buffer, M_MACTEMP);
	FREE(elements, M_MACTEMP);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_get_file</span>(proc_t p, <span class="enscript-type">struct</span> __mac_get_file_args *uap,
	       <span class="enscript-type">int</span> *ret __unused)
{

	<span class="enscript-keyword">return</span> (mac_get_filelink(p, uap-&gt;mac_p, uap-&gt;path_p, 1));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_get_link</span>(proc_t p, <span class="enscript-type">struct</span> __mac_get_link_args *uap,
	       <span class="enscript-type">int</span> *ret __unused)
{

	<span class="enscript-keyword">return</span> (mac_get_filelink(p, uap-&gt;mac_p, uap-&gt;path_p, 0));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_set_fd</span>(proc_t p, <span class="enscript-type">struct</span> __mac_set_fd_args *uap, <span class="enscript-type">int</span> *ret __unused)
{

	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> user_mac mac;
	<span class="enscript-type">struct</span> vfs_context *ctx = vfs_context_current();
	<span class="enscript-type">int</span> error;
	size_t ulen;
	<span class="enscript-type">char</span> *buffer;
	<span class="enscript-type">struct</span> label *intlabel;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	<span class="enscript-type">struct</span> socket *so;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> vnode *vp;

	AUDIT_ARG(fd, uap-&gt;fd);

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		<span class="enscript-type">struct</span> user64_mac mac64;
		error = copyin(uap-&gt;mac_p, &amp;mac64, <span class="enscript-keyword">sizeof</span>(mac64));
		mac.m_buflen = mac64.m_buflen;
		mac.m_string = mac64.m_string;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_mac mac32;
		error = copyin(uap-&gt;mac_p, &amp;mac32, <span class="enscript-keyword">sizeof</span>(mac32));
		mac.m_buflen = mac32.m_buflen;
		mac.m_string = mac32.m_string;
	}
	<span class="enscript-keyword">if</span> (error) 
		<span class="enscript-keyword">return</span> (error);
		
	error = mac_check_structmac_consistent(&amp;mac);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	
	MALLOC(buffer, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK);
	error = copyinstr(mac.m_string, buffer, mac.m_buflen, &amp;ulen);
	<span class="enscript-keyword">if</span> (error) {
		FREE(buffer, M_MACTEMP);
		<span class="enscript-keyword">return</span> (error);
	}
	AUDIT_ARG(mac_string, buffer);
	
	error = fp_lookup(p, uap-&gt;fd, &amp;fp, 0);
	<span class="enscript-keyword">if</span> (error) {
		FREE(buffer, M_MACTEMP);
		<span class="enscript-keyword">return</span> (error);
	}
	

	error = mac_file_check_set(vfs_context_ucred(ctx), fp-&gt;f_fglob, buffer, mac.m_buflen);
	<span class="enscript-keyword">if</span> (error) {
		fp_drop(p, uap-&gt;fd, fp, 0);
		FREE(buffer, M_MACTEMP);
		<span class="enscript-keyword">return</span> (error);
	}
	
	<span class="enscript-keyword">switch</span> (FILEGLOB_DTYPE(fp-&gt;f_fglob)) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_VNODE</span>:
			<span class="enscript-keyword">if</span> (mac_label_vnodes == 0) {
				error = ENOSYS;
				<span class="enscript-keyword">break</span>;
			}

			intlabel = mac_vnode_label_alloc();

			error = mac_vnode_label_internalize(intlabel, buffer);
			<span class="enscript-keyword">if</span> (error) {
				mac_vnode_label_free(intlabel);
				<span class="enscript-keyword">break</span>;
			}


			vp = (<span class="enscript-type">struct</span> vnode *)fp-&gt;f_fglob-&gt;fg_data;

			error = vnode_getwithref(vp);
			<span class="enscript-keyword">if</span> (error == 0) {
				error = vn_setlabel(vp, intlabel, ctx);
				vnode_put(vp);
			}
			mac_vnode_label_free(intlabel);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_SOCKET</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
			intlabel = mac_socket_label_alloc(MAC_WAITOK);
			error = mac_socket_label_internalize(intlabel, buffer);
			<span class="enscript-keyword">if</span> (error == 0) {
				so = (<span class="enscript-type">struct</span> socket *) fp-&gt;f_fglob-&gt;fg_data;
				SOCK_LOCK(so);
				error = mac_socket_label_update(vfs_context_ucred(ctx), so, intlabel);
				SOCK_UNLOCK(so);
			}
			mac_socket_label_free(intlabel);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PSXSHM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PSXSEM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PIPE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_KQUEUE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_FSEVENTS</span>:
		<span class="enscript-reference">default</span>:
			error = ENOSYS;  <span class="enscript-comment">// only sockets/vnodes so far
</span>			<span class="enscript-keyword">break</span>;
	}

	fp_drop(p, uap-&gt;fd, fp, 0);
	FREE(buffer, M_MACTEMP);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mac_set_filelink</span>(proc_t p, user_addr_t mac_p, user_addr_t path_p,
		 <span class="enscript-type">int</span> follow)
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">struct</span> vfs_context *ctx = vfs_context_current();
	<span class="enscript-type">struct</span> label *intlabel;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">struct</span> user_mac mac;
	<span class="enscript-type">char</span> *buffer;
	<span class="enscript-type">int</span> error;
	size_t ulen;

	<span class="enscript-keyword">if</span> (mac_label_vnodes == 0)
		<span class="enscript-keyword">return</span> ENOSYS;

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		<span class="enscript-type">struct</span> user64_mac mac64;
		error = copyin(mac_p, &amp;mac64, <span class="enscript-keyword">sizeof</span>(mac64));
		mac.m_buflen = mac64.m_buflen;
		mac.m_string = mac64.m_string;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_mac mac32;
		error = copyin(mac_p, &amp;mac32, <span class="enscript-keyword">sizeof</span>(mac32));
		mac.m_buflen = mac32.m_buflen;
		mac.m_string = mac32.m_string;
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	error = mac_check_structmac_consistent(&amp;mac);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;mac_set_file: failed structure consistency check\n&quot;</span>);
		<span class="enscript-keyword">return</span> (error);
	}

	MALLOC(buffer, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK);
	error = copyinstr(mac.m_string, buffer, mac.m_buflen, &amp;ulen);
	<span class="enscript-keyword">if</span> (error) {
		FREE(buffer, M_MACTEMP);
		<span class="enscript-keyword">return</span> (error);
	}
	AUDIT_ARG(mac_string, buffer);

	intlabel = mac_vnode_label_alloc();
	error = mac_vnode_label_internalize(intlabel, buffer);
	FREE(buffer, M_MACTEMP);
	<span class="enscript-keyword">if</span> (error) {
		mac_vnode_label_free(intlabel);
		<span class="enscript-keyword">return</span> (error);
	}

	NDINIT(&amp;nd, LOOKUP, OP_LOOKUP,
		LOCKLEAF | (follow ? FOLLOW : NOFOLLOW) | AUDITVNPATH1,
		UIO_USERSPACE, path_p, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error) {
		mac_vnode_label_free(intlabel);
		<span class="enscript-keyword">return</span> (error);
	}
	vp = nd.ni_vp;

	nameidone(&amp;nd);

	error = vn_setlabel(vp, intlabel, ctx);
	vnode_put(vp);
	mac_vnode_label_free(intlabel);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_set_file</span>(proc_t p, <span class="enscript-type">struct</span> __mac_set_file_args *uap,
	       <span class="enscript-type">int</span> *ret __unused)
{

	<span class="enscript-keyword">return</span> (mac_set_filelink(p, uap-&gt;mac_p, uap-&gt;path_p, 1));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_set_link</span>(proc_t p, <span class="enscript-type">struct</span> __mac_set_link_args *uap,
	       <span class="enscript-type">int</span> *ret __unused)
{

	<span class="enscript-keyword">return</span> (mac_set_filelink(p, uap-&gt;mac_p, uap-&gt;path_p, 0));
}

<span class="enscript-comment">/*
 * __mac_syscall: Perform a MAC policy system call
 *
 * Parameters:    p                       Process calling this routine
 *                uap                     User argument descriptor (see below)
 *                retv                    (Unused)
 *
 * Indirect:      uap-&gt;policy             Name of target MAC policy
 *                uap-&gt;call               MAC policy-specific system call to perform
 *                uap-&gt;arg                MAC policy-specific system call arguments
 *                
 * Returns:        0                      Success
 *                !0                      Not success
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_syscall</span>(proc_t p, <span class="enscript-type">struct</span> __mac_syscall_args *uap, <span class="enscript-type">int</span> *retv __unused)
{
	<span class="enscript-type">struct</span> mac_policy_conf *mpc;
	<span class="enscript-type">char</span> target[MAC_MAX_POLICY_NAME];
	<span class="enscript-type">int</span> error;
	u_int i;
	size_t ulen;

	error = copyinstr(uap-&gt;policy, target, <span class="enscript-keyword">sizeof</span>(target), &amp;ulen);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	AUDIT_ARG(value32, uap-&gt;call);
	AUDIT_ARG(mac_string, target);

	error = ENOPOLICY;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; mac_policy_list.staticmax; i++) {
		mpc = mac_policy_list.entries[i].mpc;
		<span class="enscript-keyword">if</span> (mpc == NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (strcmp(mpc-&gt;mpc_name, target) == 0 &amp;&amp;
		    mpc-&gt;mpc_ops-&gt;mpo_policy_syscall != NULL) {
			error = mpc-&gt;mpc_ops-&gt;mpo_policy_syscall(p,
			    uap-&gt;call, uap-&gt;arg);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
 		}
	}
	<span class="enscript-keyword">if</span> (mac_policy_list_conditional_busy() != 0) {
		<span class="enscript-keyword">for</span> (; i &lt;= mac_policy_list.maxindex; i++) {
			mpc = mac_policy_list.entries[i].mpc;
			<span class="enscript-keyword">if</span> (mpc == NULL)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (strcmp(mpc-&gt;mpc_name, target) == 0 &amp;&amp;
			    mpc-&gt;mpc_ops-&gt;mpo_policy_syscall != NULL) {
				error = mpc-&gt;mpc_ops-&gt;mpo_policy_syscall(p,
				    uap-&gt;call, uap-&gt;arg);
				<span class="enscript-keyword">break</span>;
			}
		}
		mac_policy_list_unbusy();
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_mount_label_get</span>(<span class="enscript-type">struct</span> mount *mp, user_addr_t mac_p)
{
	<span class="enscript-type">char</span> *elements, *buffer;
	<span class="enscript-type">struct</span> label *label;
	<span class="enscript-type">struct</span> user_mac mac;
	<span class="enscript-type">int</span> error;
	size_t ulen;

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(current_proc())) {
		<span class="enscript-type">struct</span> user64_mac mac64;
		error = copyin(mac_p, &amp;mac64, <span class="enscript-keyword">sizeof</span>(mac64));
		mac.m_buflen = mac64.m_buflen;
		mac.m_string = mac64.m_string;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_mac mac32;
		error = copyin(mac_p, &amp;mac32, <span class="enscript-keyword">sizeof</span>(mac32));
		mac.m_buflen = mac32.m_buflen;
		mac.m_string = mac32.m_string;
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	error = mac_check_structmac_consistent(&amp;mac);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	MALLOC(elements, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK);
	error = copyinstr(mac.m_string, elements, mac.m_buflen, &amp;ulen);
	<span class="enscript-keyword">if</span> (error) {
		FREE(elements, M_MACTEMP);
		<span class="enscript-keyword">return</span> (error);
	}
	AUDIT_ARG(mac_string, elements);

	label = mp-&gt;mnt_mntlabel;
	MALLOC(buffer, <span class="enscript-type">char</span> *, mac.m_buflen, M_MACTEMP, M_WAITOK | M_ZERO);
	error = mac_mount_label_externalize(label, elements, buffer,
	    mac.m_buflen);
	FREE(elements, M_MACTEMP);

	<span class="enscript-keyword">if</span> (error == 0)
		error = copyout(buffer, mac.m_string, strlen(buffer) + 1);
	FREE(buffer, M_MACTEMP);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * __mac_get_mount: Get mount point label information for a given pathname
 *
 * Parameters:    p                        (ignored)
 *                uap                      User argument descriptor (see below)
 *                ret                      (ignored)
 *
 * Indirect:      uap-&gt;path                Pathname
 *                uap-&gt;mac_p               MAC info 
 *
 * Returns:        0                       Success
 *                !0                       Not success
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_get_mount</span>(proc_t p __unused, <span class="enscript-type">struct</span> __mac_get_mount_args *uap,
    <span class="enscript-type">int</span> *ret __unused)
{
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">struct</span> vfs_context *ctx = vfs_context_current();
	<span class="enscript-type">struct</span> mount *mp;
	<span class="enscript-type">int</span> error;

	NDINIT(&amp;nd, LOOKUP, OP_LOOKUP, FOLLOW | AUDITVNPATH1,
		UIO_USERSPACE, uap-&gt;path, ctx);
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> (error);
	}
	mp = nd.ni_vp-&gt;v_mount;
	vnode_put(nd.ni_vp);
	nameidone(&amp;nd);

	<span class="enscript-keyword">return</span> mac_mount_label_get(mp, uap-&gt;mac_p);
}

<span class="enscript-comment">/*
 * mac_schedule_userret()
 *
 * Schedule a callback to the mpo_thread_userret hook. The mpo_thread_userret
 * hook is called just before the thread exit from the kernel in ast_taken().
 *
 * Returns:	 0		Success
 * 		!0		Not successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_schedule_userret</span>(<span class="enscript-type">void</span>)
{

	act_set_astmacf(current_thread());
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * mac_do_machexc()
 *
 * Do a Mach exception.  This should only be done in the mpo_thread_userret
 * callback.
 *
 * params:	code		exception code
 * 		subcode		exception subcode
 * 		flags		flags:
 * 				MAC_DOEXCF_TRACED  Only do exception if being
 * 						   ptrace()'ed.
 *
 *
 * Returns:	 0		Success
 * 		!0		Not successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_do_machexc</span>(int64_t code, int64_t subcode, uint32_t flags)
{
	mach_exception_data_type_t  codes[EXCEPTION_CODE_MAX];
	proc_t p = current_proc();

	<span class="enscript-comment">/* Only allow execption codes in MACF's reserved range. */</span>
	<span class="enscript-keyword">if</span> ((code &lt; EXC_MACF_MIN) || (code &gt; EXC_MACF_MAX))
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">if</span> (flags &amp; MAC_DOEXCF_TRACED &amp;&amp;
	    !(p-&gt;p_lflag &amp; P_LTRACED &amp;&amp; (p-&gt;p_lflag &amp; P_LPPWAIT) == 0))
		<span class="enscript-keyword">return</span> (0);


	<span class="enscript-comment">/* Send the Mach exception */</span>
	codes[0] = (mach_exception_data_type_t)code;
	codes[1] = (mach_exception_data_type_t)subcode;

	<span class="enscript-keyword">return</span> (bsd_exception(EXC_SOFTWARE, codes, 2) != KERN_SUCCESS);
}

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* MAC */</span>

<span class="enscript-function-name">void</span> (*load_security_extensions_function)(<span class="enscript-type">void</span>) = 0;

<span class="enscript-type">struct</span> sysctl_oid_list sysctl__security_mac_children;

<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_policy_register</span>(<span class="enscript-type">struct</span> mac_policy_conf *mpc __unused, 
	mac_policy_handle_t *handlep __unused, <span class="enscript-type">void</span> *xd __unused)
{

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_policy_unregister</span>(mac_policy_handle_t handle __unused)
{

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_audit_text</span>(<span class="enscript-type">char</span> *text __unused, mac_policy_handle_t handle __unused)
{

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_vnop_setxattr</span>(<span class="enscript-type">struct</span> vnode *vp __unused, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name __unused, <span class="enscript-type">char</span> *buf __unused, size_t len __unused)
{

	<span class="enscript-keyword">return</span> (ENOENT);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_vnop_getxattr</span>(<span class="enscript-type">struct</span> vnode *vp __unused, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name __unused, 
	<span class="enscript-type">char</span> *buf __unused, size_t len __unused, size_t *attrlen __unused)
{

	<span class="enscript-keyword">return</span> (ENOENT);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mac_vnop_removexattr</span>(<span class="enscript-type">struct</span> vnode *vp __unused, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name __unused)
{

	<span class="enscript-keyword">return</span> (ENOENT);
}

intptr_t <span class="enscript-function-name">mac_label_get</span>(<span class="enscript-type">struct</span> label *l __unused, <span class="enscript-type">int</span> slot __unused)
{
        <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">mac_label_set</span>(<span class="enscript-type">struct</span> label *l __unused, <span class="enscript-type">int</span> slot __unused, intptr_t v __unused)
{
		<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">mac_proc_set_enforce</span>(proc_t p, <span class="enscript-type">int</span> enforce_flags);
<span class="enscript-type">void</span> <span class="enscript-function-name">mac_proc_set_enforce</span>(proc_t p __unused, <span class="enscript-type">int</span> enforce_flags __unused)
{
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">mac_iokit_check_hid_control</span>(kauth_cred_t cred __unused);
<span class="enscript-type">int</span> <span class="enscript-function-name">mac_iokit_check_hid_control</span>(kauth_cred_t cred __unused)
{
        <span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !MAC */</span>
</pre>
<hr />
</body></html>