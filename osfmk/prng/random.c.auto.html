<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>random.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">random.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/startup.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/simple_lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/random.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;prng/random.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;corecrypto/ccdrbg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;corecrypto/ccsha1.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;console/serial_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPlatformExpert.h&gt;</span>

<span class="enscript-type">static</span> lck_grp_t *gPRNGGrp;
<span class="enscript-type">static</span> lck_attr_t *gPRNGAttr;
<span class="enscript-type">static</span> lck_grp_attr_t *gPRNGGrpAttr;
<span class="enscript-type">static</span> lck_mtx_t *gPRNGMutex = NULL;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> prngContext {
	<span class="enscript-type">struct</span> ccdrbg_info	*infop;
	<span class="enscript-type">struct</span> ccdrbg_state	*statep;
	uint64_t		bytes_generated;
	uint64_t		bytes_reseeded;
} *prngContextp;

ccdrbg_factory_t prng_ccdrbg_factory = NULL;

entropy_data_t	EntropyData = { .index_ptr = EntropyData.buffer };

boolean_t		erandom_seed_set = FALSE;
<span class="enscript-type">char</span>			erandom_seed[EARLY_RANDOM_SEED_SIZE];
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ccdrbg_state ccdrbg_state_t;
uint8_t			master_erandom_state[EARLY_RANDOM_STATE_STATIC_SIZE];
ccdrbg_state_t		*erandom_state[MAX_CPUS];
<span class="enscript-type">struct</span> ccdrbg_info	erandom_info;
<span class="enscript-function-name">decl_simple_lock_data</span>(,entropy_lock);

<span class="enscript-type">struct</span> ccdrbg_nisthmac_custom erandom_custom = {
	.di = &amp;ccsha1_eay_di,
	.strictFIPS = 0,
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">read_erandom</span>(<span class="enscript-type">void</span> *buffer, u_int numBytes);	<span class="enscript-comment">/* Forward */</span>

<span class="enscript-type">void</span> 
<span class="enscript-function-name">entropy_buffer_read</span>(<span class="enscript-type">char</span>		*buffer,
		    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	*count)
{
	boolean_t       current_state;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    i, j;

	<span class="enscript-keyword">if</span> (!erandom_seed_set) {
		panic(<span class="enscript-string">&quot;early_random was never invoked&quot;</span>);
	}

	<span class="enscript-keyword">if</span> ((*count) &gt; (ENTROPY_BUFFER_SIZE * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)))
		*count = ENTROPY_BUFFER_SIZE * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);

	current_state = ml_set_interrupts_enabled(FALSE);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
	simple_lock(&amp;entropy_lock);
#<span class="enscript-reference">endif</span>

	memcpy((<span class="enscript-type">char</span> *) buffer, (<span class="enscript-type">char</span> *) EntropyData.buffer, *count);

	<span class="enscript-keyword">for</span> (i = 0, j = (ENTROPY_BUFFER_SIZE - 1); i &lt; ENTROPY_BUFFER_SIZE; j = i, i++)
		EntropyData.buffer[i] = EntropyData.buffer[i] ^ EntropyData.buffer[j];

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
	simple_unlock(&amp;entropy_lock);
#<span class="enscript-reference">endif</span>
	(<span class="enscript-type">void</span>) ml_set_interrupts_enabled(current_state);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
	uint32_t	*word = (uint32_t *) (<span class="enscript-type">void</span> *) buffer;
	<span class="enscript-comment">/* Good for both 32-bit and 64-bit kernels. */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; ENTROPY_BUFFER_SIZE; i += 4)
		<span class="enscript-comment">/* 
		 * We use &quot;EARLY&quot; here so that we can grab early entropy on
		 * ARM, where tracing is not started until after PRNG is
		 * initialized.
		*/</span>
		KERNEL_DEBUG_EARLY(ENTROPY_READ(i/4),
			word[i+0], word[i+1], word[i+2], word[i+3]);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 * Return a uniformly distributed 64-bit random number.
 *
 * This interface should have minimal dependencies on kernel
 * services, and thus be available very early in the life
 * of the kernel.
 * This provides cryptographically secure randomness.
 * Each processor has its own generator instance.
 * It is seeded (lazily) with entropy provided by the Booter.
*
 * For &lt;rdar://problem/17292592&gt; the algorithm switched from LCG to
 * NIST HMAC DBRG as follows:
 *  - When first called (on OSX this is very early while page tables are being
 *    built) early_random() calls ccdrbg_factory_hmac() to set-up a ccdbrg info
 *    structure.
 *  - The boot processor's ccdrbg state structure is a statically allocated area
 *    which is then initialized by calling the ccdbrg_init method.
 *    The initial entropy is 16 bytes of boot entropy.
 *    The nonce is the first 8 bytes of entropy xor'ed with a timestamp
 *    from ml_get_timebase().
 *    The personalization data provided is null. 
 *  - The first 64-bit random value is returned on the boot processor from
 *    an invocation of the ccdbrg_generate method.
 *  - Non-boot processor's DRBG state structures are allocated dynamically
 *    from prng_init(). Each is initialized with the same 16 bytes of entropy
 *    but with a different timestamped nonce and cpu number as personalization.
 *  - Subsequent calls to early_random() pass to read_erandom() to generate
 *    an 8-byte random value.  read_erandom() ensures that pre-emption is
 *    disabled and selects the DBRG state from the current processor.
 *    The ccdbrg_generate method is called for the required random output.
 *    If this method returns CCDRBG_STATUS_NEED_RESEED, the erandom_seed buffer
 *    is re-filled with kernel-harvested entropy and the ccdbrg_reseed method is
 *    called with this new entropy. The kernel panics if a reseed fails.
 */</span>
uint64_t
<span class="enscript-function-name">early_random</span>(<span class="enscript-type">void</span>)
{
	uint32_t	cnt = 0;
	uint64_t	result;
	uint64_t	nonce;
	<span class="enscript-type">int</span>		rc;
	<span class="enscript-type">int</span>		ps;
	ccdrbg_state_t	*state;

	<span class="enscript-keyword">if</span> (!erandom_seed_set) {
		simple_lock_init(&amp;entropy_lock,0);
		erandom_seed_set = TRUE;
		cnt = PE_get_random_seed((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) EntropyData.buffer,
					 <span class="enscript-keyword">sizeof</span>(EntropyData.buffer));

		<span class="enscript-keyword">if</span> (cnt &lt; <span class="enscript-keyword">sizeof</span>(EntropyData.buffer)) {
			<span class="enscript-comment">/*
			 * Insufficient entropy is fatal.  We must fill the
			 * entire entropy buffer during initializaton.
			 */</span>
			panic(<span class="enscript-string">&quot;EntropyData needed %lu bytes, but got %u.\n&quot;</span>,
				<span class="enscript-keyword">sizeof</span>(EntropyData.buffer), cnt);
		}		

		<span class="enscript-comment">/*
		 * Use some of the supplied entropy as a basis for early_random;
		 * reuse is ugly, but simplifies things. Ideally, we would guard
		 * early random values well enough that it isn't safe to attack
		 * them, but this cannot be guaranteed; thus, initial entropy
		 * can be considered 8 bytes weaker for a given boot if any
		 * early random values are conclusively determined.
		 *
		 * early_random_seed could be larger than EntopyData.buffer...
		 * but it won't be.
		 */</span>
		bcopy(EntropyData.buffer, &amp;erandom_seed, <span class="enscript-keyword">sizeof</span>(erandom_seed));

		<span class="enscript-comment">/* Init DRBG for NIST HMAC */</span>
		ccdrbg_factory_nisthmac(&amp;erandom_info, &amp;erandom_custom);
		assert(erandom_info.size &lt;= <span class="enscript-keyword">sizeof</span>(master_erandom_state));
		state = (ccdrbg_state_t *) master_erandom_state;
		erandom_state[0] = state;

		<span class="enscript-comment">/*
		 * Init our DBRG from the boot entropy and a timestamp as nonce
		 * and the cpu number as personalization.
		 */</span>
		assert(<span class="enscript-keyword">sizeof</span>(erandom_seed) &gt; <span class="enscript-keyword">sizeof</span>(nonce));
		nonce = ml_get_timebase();
		ps = 0;				<span class="enscript-comment">/* boot cpu */</span>
		rc = ccdrbg_init(&amp;erandom_info, state,
				 <span class="enscript-keyword">sizeof</span>(erandom_seed), erandom_seed,
				 <span class="enscript-keyword">sizeof</span>(nonce), &amp;nonce,
				 <span class="enscript-keyword">sizeof</span>(ps), &amp;ps);
		cc_clear(<span class="enscript-keyword">sizeof</span>(nonce), &amp;nonce);
		<span class="enscript-keyword">if</span> (rc != CCDRBG_STATUS_OK)
			panic(<span class="enscript-string">&quot;ccdrbg_init() returned %d&quot;</span>, rc);

		<span class="enscript-comment">/* Generate output */</span>
		rc = ccdrbg_generate(&amp;erandom_info, state,
				     <span class="enscript-keyword">sizeof</span>(result), &amp;result,
				     0, NULL);
		<span class="enscript-keyword">if</span> (rc != CCDRBG_STATUS_OK)
			panic(<span class="enscript-string">&quot;ccdrbg_generate() returned %d&quot;</span>, rc);
	
		<span class="enscript-keyword">return</span> result;
	};

	read_erandom(&amp;result, <span class="enscript-keyword">sizeof</span>(result));

	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">read_erandom</span>(<span class="enscript-type">void</span> *buffer, u_int numBytes)
{
	<span class="enscript-type">int</span>		cpu;
	<span class="enscript-type">int</span>		rc;
	uint32_t	cnt;
	ccdrbg_state_t	*state;

	mp_disable_preemption();
	cpu = cpu_number();
	state = erandom_state[cpu];
	assert(state);
	<span class="enscript-keyword">while</span> (TRUE) {
		<span class="enscript-comment">/* Generate output */</span>
		rc = ccdrbg_generate(&amp;erandom_info, state,
				     numBytes, buffer,
				     0, NULL);
		<span class="enscript-keyword">if</span> (rc == CCDRBG_STATUS_OK)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (rc == CCDRBG_STATUS_NEED_RESEED) {
			<span class="enscript-comment">/* It's time to reseed. Get more entropy */</span>
			cnt = <span class="enscript-keyword">sizeof</span>(erandom_seed);
			entropy_buffer_read(erandom_seed, &amp;cnt);
			assert(cnt == <span class="enscript-keyword">sizeof</span>(erandom_seed));
			rc = ccdrbg_reseed(&amp;erandom_info, state,
					   <span class="enscript-keyword">sizeof</span>(erandom_seed), erandom_seed,
					   0, NULL);
			cc_clear(<span class="enscript-keyword">sizeof</span>(erandom_seed), erandom_seed);
			<span class="enscript-keyword">if</span> (rc == CCDRBG_STATUS_OK)
				<span class="enscript-keyword">continue</span>;
			panic(<span class="enscript-string">&quot;read_erandom reseed error %d\n&quot;</span>, rc);
		}
		panic(<span class="enscript-string">&quot;read_erandom ccdrbg error %d\n&quot;</span>, rc);
	}
	mp_enable_preemption();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">read_frandom</span>(<span class="enscript-type">void</span> *buffer, u_int numBytes)
{
	<span class="enscript-type">char</span>		*cp = (<span class="enscript-type">char</span> *) buffer;
	<span class="enscript-type">int</span>		nbytes;

	<span class="enscript-comment">/*
	 * Split up into requests for blocks smaller than
	 * than the DBRG request limit. iThis limit is private but
	 * for NISTHMAC it's known to be greater then 4096.
	 */</span>
	<span class="enscript-keyword">while</span> (numBytes) {
		nbytes = MIN(numBytes, PAGE_SIZE);
		read_erandom(cp, nbytes);
		cp += nbytes;
		numBytes -= nbytes;
	}
}

<span class="enscript-comment">/*
 * Register a DRBG factory routine to e used in constructing the kernel PRNG.
 * XXX to be called from the corecrypto kext.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">prng_factory_register</span>(ccdrbg_factory_t factory)
{
	prng_ccdrbg_factory = factory;
	thread_wakeup((event_t) &amp;prng_ccdrbg_factory);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">prng_cpu_init</span>(<span class="enscript-type">int</span> cpu)
{	
	uint64_t	nonce;
	<span class="enscript-type">int</span>		rc;
	ccdrbg_state_t	*state;
	prngContextp	pp;

	<span class="enscript-comment">/*
	 * Allocate state and initialize DBRG state for early_random()
	 * for this processor, if necessary.
	 */</span>
	<span class="enscript-keyword">if</span> (erandom_state[cpu] == NULL) {
		
		state = kalloc(erandom_info.size);
		<span class="enscript-keyword">if</span> (state == NULL) {
			panic(<span class="enscript-string">&quot;prng_init kalloc failed\n&quot;</span>);
		}
		erandom_state[cpu] = state;

		<span class="enscript-comment">/*
		 * Init our DBRG from boot entropy, nonce as timestamp
		 * and use the cpu number as the personalization parameter.
		 */</span>
		nonce = ml_get_timebase();
		rc = ccdrbg_init(&amp;erandom_info, state,
				 <span class="enscript-keyword">sizeof</span>(erandom_seed), erandom_seed,
				 <span class="enscript-keyword">sizeof</span>(nonce), &amp;nonce,
				 <span class="enscript-keyword">sizeof</span>(cpu), &amp;cpu);
		cc_clear(<span class="enscript-keyword">sizeof</span>(nonce), &amp;nonce);
		<span class="enscript-keyword">if</span> (rc != CCDRBG_STATUS_OK)
			panic(<span class="enscript-string">&quot;ccdrbg_init() returned %d&quot;</span>, rc);
	}

	<span class="enscript-comment">/* Non-boot cpus use the master cpu's global context */</span>
	<span class="enscript-keyword">if</span> (cpu != master_cpu) {
		cpu_datap(cpu)-&gt;cpu_prng = master_prng_context();
		<span class="enscript-keyword">return</span>;
	}

	assert(gPRNGMutex == NULL);		<span class="enscript-comment">/* Once only, please */</span>

	<span class="enscript-comment">/* make a mutex to control access */</span>
	gPRNGGrpAttr = lck_grp_attr_alloc_init();
	gPRNGGrp     = lck_grp_alloc_init(<span class="enscript-string">&quot;random&quot;</span>, gPRNGGrpAttr);
	gPRNGAttr    = lck_attr_alloc_init();
	gPRNGMutex   = lck_mtx_alloc_init(gPRNGGrp, gPRNGAttr);

	pp = kalloc(<span class="enscript-keyword">sizeof</span>(*pp));
	<span class="enscript-keyword">if</span> (pp == NULL)
		panic(<span class="enscript-string">&quot;Unable to allocate prng context&quot;</span>);
	pp-&gt;bytes_generated = 0;
	pp-&gt;bytes_reseeded = 0;
	pp-&gt;infop = NULL;

	<span class="enscript-comment">/* XXX Temporary registration */</span>
	prng_factory_register(ccdrbg_factory_yarrow);

	master_prng_context() = pp;
}

<span class="enscript-type">static</span> ccdrbg_info_t *
<span class="enscript-function-name">prng_infop</span>(prngContextp pp)
{
	lck_mtx_assert(gPRNGMutex, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* Usual case: the info is all set */</span>
	<span class="enscript-keyword">if</span> (pp-&gt;infop)
		<span class="enscript-keyword">return</span> pp-&gt;infop;

	<span class="enscript-comment">/*
	 * Possibly wait for the CCDRBG factory routune to be registered
	 * by corecypto. But panic after waiting for more than 10 seconds.
	 */</span>
	<span class="enscript-keyword">while</span> (prng_ccdrbg_factory == NULL ) {
		wait_result_t	wait_result;
		assert_wait_timeout((event_t) &amp;prng_ccdrbg_factory, TRUE,
				    10, NSEC_PER_USEC);
		lck_mtx_unlock(gPRNGMutex);
		wait_result = thread_block(THREAD_CONTINUE_NULL);
		<span class="enscript-keyword">if</span> (wait_result == THREAD_TIMED_OUT)
			panic(<span class="enscript-string">&quot;prng_ccdrbg_factory registration timeout&quot;</span>);
		lck_mtx_lock(gPRNGMutex);
	}
	<span class="enscript-comment">/* Check we didn't lose the set-up race */</span>
	<span class="enscript-keyword">if</span> (pp-&gt;infop)
		<span class="enscript-keyword">return</span> pp-&gt;infop;

	pp-&gt;infop = (ccdrbg_info_t *) kalloc(<span class="enscript-keyword">sizeof</span>(ccdrbg_info_t));
	<span class="enscript-keyword">if</span> (pp-&gt;infop == NULL)
		panic(<span class="enscript-string">&quot;Unable to allocate prng info&quot;</span>);

	prng_ccdrbg_factory(pp-&gt;infop, NULL);

	pp-&gt;statep = kalloc(pp-&gt;infop-&gt;size);
	<span class="enscript-keyword">if</span> (pp-&gt;statep == NULL)
		panic(<span class="enscript-string">&quot;Unable to allocate prng state&quot;</span>);

	<span class="enscript-type">char</span> rdBuffer[ENTROPY_BUFFER_BYTE_SIZE];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bytesToInput = <span class="enscript-keyword">sizeof</span>(rdBuffer);

	entropy_buffer_read(rdBuffer, &amp;bytesToInput);

	(<span class="enscript-type">void</span>) ccdrbg_init(pp-&gt;infop, pp-&gt;statep,
			   bytesToInput, rdBuffer,
			   0, NULL,
			   0, NULL);
	cc_clear(<span class="enscript-keyword">sizeof</span>(rdBuffer), rdBuffer);
	<span class="enscript-keyword">return</span> pp-&gt;infop;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">Reseed</span>(prngContextp pp)
{
	<span class="enscript-type">char</span>		rdBuffer[ENTROPY_BUFFER_BYTE_SIZE];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	bytesToInput = <span class="enscript-keyword">sizeof</span>(rdBuffer);

	entropy_buffer_read(rdBuffer, &amp;bytesToInput);

	PRNG_CCDRBG((<span class="enscript-type">void</span>) ccdrbg_reseed(pp-&gt;infop, pp-&gt;statep,
					 bytesToInput, rdBuffer,
					 0, NULL)); 

	cc_clear(<span class="enscript-keyword">sizeof</span>(rdBuffer), rdBuffer);
	pp-&gt;bytes_reseeded = pp-&gt;bytes_generated;
}


<span class="enscript-comment">/* export good random numbers to the rest of the kernel */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">read_random</span>(<span class="enscript-type">void</span>* buffer, u_int numbytes)
{
	prngContextp	pp;
	ccdrbg_info_t	*infop;
	<span class="enscript-type">int</span>		ccdrbg_err;

	lck_mtx_lock(gPRNGMutex);

	pp = current_prng_context();
	infop = prng_infop(pp);

	<span class="enscript-comment">/*
	 * Call DRBG, reseeding and retrying if requested.
	 */</span>
	<span class="enscript-keyword">while</span> (TRUE) {
		PRNG_CCDRBG(
			ccdrbg_err = ccdrbg_generate(infop, pp-&gt;statep,
						     numbytes, buffer,
						     0, NULL));
		<span class="enscript-keyword">if</span> (ccdrbg_err == CCDRBG_STATUS_OK)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (ccdrbg_err == CCDRBG_STATUS_NEED_RESEED) {
			Reseed(pp);
			<span class="enscript-keyword">continue</span>;
		}
		panic(<span class="enscript-string">&quot;read_random ccdrbg error %d\n&quot;</span>, ccdrbg_err);
	}

	pp-&gt;bytes_generated += numbytes;
	lck_mtx_unlock(gPRNGMutex);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">write_random</span>(<span class="enscript-type">void</span>* buffer, u_int numbytes)
{
#<span class="enscript-reference">if</span> 0
	<span class="enscript-type">int</span>		retval = 0;
	prngContextp	pp;

	lck_mtx_lock(gPRNGMutex);

	pp = current_prng_context();

	<span class="enscript-keyword">if</span> (ccdrbg_reseed(prng_infop(pp), pp-&gt;statep,
			  bytesToInput, rdBuffer, 0, NULL) != 0)
		retval = EIO;

	lck_mtx_unlock(gPRNGMutex);
	<span class="enscript-keyword">return</span> retval;
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">pragma</span>  <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">buffer</span>, <span class="enscript-variable-name">numbytes</span>)
    <span class="enscript-keyword">return</span> 0;
#<span class="enscript-reference">endif</span>
}
</pre>
<hr />
</body></html>