<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>sha1mod.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">sha1mod.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1999, 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
SHA-1 in C
By Steve Reid &lt;<a href="mailto:steve@edmweb.com">steve@edmweb.com</a>&gt;
100% Public Domain
*/</span>
<span class="enscript-comment">/* Header portion split from main code for convenience (AYB 3/02/98) */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;sha1mod.h&quot;</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SHA1HANDSOFF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">rol</span>(value, bits) (((value) &lt;&lt; (bits)) | ((value) &gt;&gt; (32 - (bits))))

<span class="enscript-comment">/*
 * Apple change...
 */</span>
#<span class="enscript-reference">if</span>	<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">macintosh</span>) || <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">LITTLE_ENDIAN</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* blk0() and blk() perform the initial expand. */</span>
<span class="enscript-comment">/* I got the idea of expanding during the round function from SSLeay */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LITTLE_ENDIAN</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">blk0</span>(i) (block-&gt;l[i] = (rol(block-&gt;l[i],24)&amp;0xFF00FF00) \
    |(rol(block-&gt;l[i],8)&amp;0x00FF00FF))
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">blk0</span>(i) block-&gt;l[i]
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">blk</span>(i) (block-&gt;l[i&amp;15] = rol(block-&gt;l[(i+13)&amp;15]^block-&gt;l[(i+8)&amp;15] \
    ^block-&gt;l[(i+2)&amp;15]^block-&gt;l[i&amp;15],1))

<span class="enscript-comment">/* (R0+R1), R2, R3, R4 are the different operations used in SHA1 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">R0</span>(v,w,x,y,z,i) z+=((w&amp;(x^y))^y)+blk0(i)+0x5A827999+rol(v,5);w=rol(w,30);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">R1</span>(v,w,x,y,z,i) z+=((w&amp;(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=rol(w,30);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">R2</span>(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=rol(w,30);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">R3</span>(v,w,x,y,z,i) z+=(((w|x)&amp;y)|(w&amp;x))+blk(i)+0x8F1BBCDC+rol(v,5);w=rol(w,30);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">R4</span>(v,w,x,y,z,i) z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=rol(w,30);


<span class="enscript-comment">/* Hash a single 512-bit block. This is the core of the algorithm. */</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">YSHA1Transform</span>(u_int32_t state[5], <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> buffer[64])
{
u_int32_t a, b, c, d, e;
<span class="enscript-type">typedef</span> <span class="enscript-type">union</span> {
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> c[64];
    u_int32_t l[16];
} CHAR64LONG16;
CHAR64LONG16* block;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SHA1HANDSOFF</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> workspace[64];
    block = (CHAR64LONG16*)workspace;
    memcpy(block, buffer, 64);
#<span class="enscript-reference">else</span>
    block = (CHAR64LONG16*)buffer;
#<span class="enscript-reference">endif</span>
    <span class="enscript-comment">/* Copy context-&gt;state[] to working vars */</span>
    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];
    <span class="enscript-comment">/* 4 rounds of 20 operations each. Loop unrolled. */</span>
    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
    R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
    R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
    R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
    R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
    R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
    R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
    R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
    R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
    R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
    R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
    R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
    R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
    R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
    R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
    R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
    R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
    R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
    R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
    <span class="enscript-comment">/* Add the working vars back into context.state[] */</span>
    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;
    state[4] += e;
    <span class="enscript-comment">/* Wipe variables */</span>
    a = b = c = d = e = 0;
}


<span class="enscript-comment">/* YSHA1Init - Initialize new context */</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">YSHA1Init</span>(YSHA1_CTX* context)
{
    <span class="enscript-comment">/* SHA1 initialization constants */</span>
    context-&gt;state[0] = 0x67452301;
    context-&gt;state[1] = 0xEFCDAB89;
    context-&gt;state[2] = 0x98BADCFE;
    context-&gt;state[3] = 0x10325476;
    context-&gt;state[4] = 0xC3D2E1F0;
    context-&gt;count[0] = context-&gt;count[1] = 0;
}


<span class="enscript-comment">/* Run your data through this. */</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">YSHA1Update</span>(YSHA1_CTX* context, <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>* data, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len)
{
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i, j;

    j = (context-&gt;count[0] &gt;&gt; 3) &amp; 63;
    <span class="enscript-keyword">if</span> ((context-&gt;count[0] += len &lt;&lt; 3) &lt; (len &lt;&lt; 3)) context-&gt;count[1]++;
    context-&gt;count[1] += (len &gt;&gt; 29);
    <span class="enscript-keyword">if</span> ((j + len) &gt; 63) {
        memcpy(&amp;context-&gt;buffer[j], data, (i = 64-j));
        YSHA1Transform(context-&gt;state, context-&gt;buffer);
        <span class="enscript-keyword">for</span> ( ; i + 63 &lt; len; i += 64) {
            YSHA1Transform(context-&gt;state, &amp;data[i]);
        }
        j = 0;
    }
    <span class="enscript-keyword">else</span> i = 0;
    memcpy(&amp;context-&gt;buffer[j], &amp;data[i], len - i);
}


<span class="enscript-comment">/* Add padding and return the message digest. */</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">YSHA1Final</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> digest[20], YSHA1_CTX* context)
{
u_int32_t i, j;
<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> finalcount[8];

    <span class="enscript-keyword">for</span> (i = 0; i &lt; 8; i++) {
        finalcount[i] = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>)((context-&gt;count[(i &gt;= 4 ? 0 : 1)]
         &gt;&gt; ((3-(i &amp; 3)) * 8) ) &amp; 255);  <span class="enscript-comment">/* Endian independent */</span>
    }
    YSHA1Update(context, (<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)<span class="enscript-string">&quot;\200&quot;</span>, 1);
    <span class="enscript-keyword">while</span> ((context-&gt;count[0] &amp; 504) != 448) {
        YSHA1Update(context, (<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)<span class="enscript-string">&quot;\0&quot;</span>, 1);
    }
    YSHA1Update(context, finalcount, 8);  <span class="enscript-comment">/* Should cause a YSHA1Transform() */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; 20; i++) {
        digest[i] = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>)
         ((context-&gt;state[i&gt;&gt;2] &gt;&gt; ((3-(i &amp; 3)) * 8) ) &amp; 255);
    }
    <span class="enscript-comment">/* Wipe variables */</span>
    i = j = 0;
    memset(context-&gt;buffer, 0, 64);
    memset(context-&gt;state, 0, 20);
    memset(context-&gt;count, 0, 8);
    memset(finalcount, 0, 8);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SHA1HANDSOFF</span>  <span class="enscript-comment">/* make YSHA1Transform overwrite it's own static vars */</span>
    YSHA1Transform(context-&gt;state, context-&gt;buffer);
#<span class="enscript-reference">endif</span>
}


<span class="enscript-comment">/*************************************************************/</span>

<span class="enscript-comment">/* Test Code */</span>

#<span class="enscript-reference">if</span> 0

<span class="enscript-type">int</span> <span class="enscript-function-name">main</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span>** argv)
{
<span class="enscript-type">int</span> i, j;
YSHA1_CTX context;
<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> digest[20], buffer[16384];
FILE* file;

    <span class="enscript-keyword">if</span> (argc &gt; 2) {
        puts(<span class="enscript-string">&quot;Public domain SHA-1 implementation - by Steve Reid &lt;<a href="mailto:steve@edmweb.com">steve@edmweb.com</a>&gt;&quot;</span>);
        puts(<span class="enscript-string">&quot;Produces the SHA-1 hash of a file, or stdin if no file is specified.&quot;</span>);
        exit(0);
    }
    <span class="enscript-keyword">if</span> (argc &lt; 2) {
        file = stdin;
    }
    <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> (!(file = fopen(argv[1], <span class="enscript-string">&quot;rb&quot;</span>))) {
            fputs(<span class="enscript-string">&quot;Unable to open file.&quot;</span>, stderr);
            exit(-1);
        }
    } 
    YSHA1Init(&amp;context);
    <span class="enscript-keyword">while</span> (!feof(file)) {  <span class="enscript-comment">/* note: what if ferror(file) */</span>
        i = fread(buffer, 1, 16384, file);
        YSHA1Update(&amp;context, buffer, i);
    }
    YSHA1Final(digest, &amp;context);
    fclose(file);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; 5; i++) {
        <span class="enscript-keyword">for</span> (j = 0; j &lt; 4; j++) {
            printf(<span class="enscript-string">&quot;%02X&quot;</span>, digest[i*4+j]);
        }
        putchar(<span class="enscript-string">' '</span>);
    }
    putchar(<span class="enscript-string">'\n'</span>);
    exit(0);
}

#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>