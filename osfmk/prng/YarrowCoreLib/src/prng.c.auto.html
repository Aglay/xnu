<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>prng.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">prng.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1999, 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
	File:		prng.c

	Contains:	Core routines for the Counterpane Yarrow PRNG.

	Written by:	Counterpane, Inc. 

	Copyright: (c) 2000 by Apple Computer, Inc., all rights reserved.

	Change History (most recent first):

		02/10/99	dpm		Created, based on Counterpane source.
 
*/</span>
<span class="enscript-comment">/*
	prng.c

	Core routines for the Counterpane PRNG
*/</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;userdefines.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;assertverify.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;prng/YarrowCoreLib/include/yarrowUtils.h&quot;</span>

#<span class="enscript-reference">if</span>		<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">macintosh</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
<span class="enscript-comment">/* FIXME - this file needs to be in a platform-independent place */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;macOnly.h&quot;</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* macintosh */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;smf.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;sha1mod.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;entropysources.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;comp.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;prng/YarrowCoreLib/include/yarrow.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;prng.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;prngpriv.h&quot;</span>


#<span class="enscript-reference">define</span> <span class="enscript-function-name">_MAX</span>(a,b) (((a)&gt;(b))?(a):(b))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">_MIN</span>(a,b) (((a)&lt;(b))?(a):(b))

#<span class="enscript-reference">if</span>		<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">macintosh</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
<span class="enscript-comment">/*
 * No mutexes in this module for Macintosh/OSX. We handle the
 * required locking elsewhere. 
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MUTEX_ENABLE</span>	0

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>		<span class="enscript-comment">/* memcpy, etc. */</span>
#<span class="enscript-reference">if</span>		<span class="enscript-variable-name">TARGET_API_MAC_OSX</span>
	#include &lt;sys/time.h&gt;		<span class="enscript-comment">/* for timespec */</span>
#<span class="enscript-reference">elif</span>	<span class="enscript-variable-name">TARGET_API_MAC_CARBON</span>
	#include &lt;Timer.h&gt;				<span class="enscript-comment">/* Microseconds */</span>
	#include &lt;Math64.h&gt;
#<span class="enscript-reference">elif</span>	<span class="enscript-variable-name">KERNEL_BUILD</span>
	#include &lt;sys/time.h&gt;
#<span class="enscript-reference">elif</span>	<span class="enscript-variable-name">MACH_KERNEL_PRIVATE</span>
	#include &lt;mach/mach_time.h&gt;
	#include &lt;mach/clock_types.h&gt;
#<span class="enscript-reference">else</span>
	#error Unknown TARGET_API
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* TARGET_API */</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MUTEX_ENABLE</span>	1
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* macintosh */</span>

#<span class="enscript-reference">if</span>		<span class="enscript-variable-name">MUTEX_ENABLE</span>
<span class="enscript-type">static</span> HANDLE Statmutex = NULL;
<span class="enscript-type">static</span> DWORD mutexCreatorId = 0;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> * * * <span class="enscript-variable-name">Static</span> <span class="enscript-variable-name">Utility</span> <span class="enscript-variable-name">functions</span> * * * 
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* All error checking should be done in the function that calls these */</span>

<span class="enscript-comment">/*
 * out := SHA1(IV | out) 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">prng_do_SHA1</span>(GEN_CTX *ctx) 
{
	YSHA1_CTX sha;

	YSHA1Init(&amp;sha);
	YSHA1Update(&amp;sha,ctx-&gt;IV,20);
	YSHA1Update(&amp;sha,ctx-&gt;out,20);
	YSHA1Final(ctx-&gt;out,&amp;sha);
	ctx-&gt;index = 0;
}

<span class="enscript-comment">/*
 * IV  := newState
 * out := SHA1(IV)
 *
 * Called from init, prngForceReseed(), and prngOutput()
 * as anti-backtracking mechanism.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">prng_make_new_state</span>(GEN_CTX *ctx,BYTE *newState) 
{
	YSHA1_CTX sha;

	memcpy(ctx-&gt;IV,newState,20);
	YSHA1Init(&amp;sha);
	YSHA1Update(&amp;sha,ctx-&gt;IV,20);
	YSHA1Final(ctx-&gt;out,&amp;sha);
	ctx-&gt;numout = 0;
	ctx-&gt;index = 0;
}

#<span class="enscript-reference">if</span>		<span class="enscript-variable-name">SLOW_POLL_ENABLE</span>


<span class="enscript-comment">/* Initialize the secret state with a slow poll */</span>
<span class="enscript-comment">/* Currently only called from prngInitialize */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SPLEN</span> 65536  <span class="enscript-comment">/* 64K */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">prng_slow_init</span>(PRNG *p)
<span class="enscript-comment">/* This fails silently and must be fixed. */</span>
{
	YSHA1_CTX* ctx = NULL;
	MMPTR mmctx = MM_NULL;
	BYTE* bigbuf = NULL;
	MMPTR mmbigbuf = MM_NULL;
	BYTE* buf = NULL;
	MMPTR mmbuf = MM_NULL;
	DWORD polllength;

	mmbigbuf = mmMalloc(SPLEN);
	<span class="enscript-keyword">if</span>(mmbigbuf == MM_NULL) {<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_slow_init</span>;}
	bigbuf = (BYTE*)mmGetPtr(mmbigbuf);

	mmbuf = mmMalloc(20);
	<span class="enscript-keyword">if</span>(mmbuf == MM_NULL) {<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_slow_init</span>;}
	buf = (BYTE*)mmGetPtr(mmbuf);

	mmctx = mmMalloc(<span class="enscript-keyword">sizeof</span>(YSHA1_CTX));
	<span class="enscript-keyword">if</span>(mmctx == MM_NULL) {<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_slow_init</span>;}
	ctx = (YSHA1_CTX*)mmGetPtr(mmctx);


	<span class="enscript-comment">/* Initialize the secret state. */</span>
	<span class="enscript-comment">/* Init entropy pool */</span>
	YSHA1Init(&amp;p-&gt;pool);
	<span class="enscript-comment">/* Init output generator */</span>
	polllength = prng_slow_poll(bigbuf,SPLEN);
	YSHA1Init(ctx);
	YSHA1Update(ctx,bigbuf,polllength);
	YSHA1Final(buf,ctx);
	prng_make_new_state(&amp;p-&gt;outstate, buf);

<span class="enscript-reference">cleanup_slow_init</span>:
	mmFree(mmctx);
	mmFree(mmbigbuf);
	mmFree(mmbuf);

	<span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* SLOW_POLL_ENABLE */</span>

<span class="enscript-comment">/* In-place modifed bubble sort */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">bubbleSort</span>( UINT *data, LONG len ) 
{
	LONG 	i,last,newlast;
	UINT	temp;

	last = len-1; 
	<span class="enscript-keyword">while</span>(last!=-1) 
	{
		newlast = -1;
		<span class="enscript-keyword">for</span>(i=0;i&lt;last;i++) 
		{
			<span class="enscript-keyword">if</span>(data[i+1] &gt; data[i]) 
			{
				newlast = i;
				temp = data[i];
				data[i] = data[i+1];
				data[i+1] = temp;
			}
		}
		last = newlast;
	}		
}

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> * * * <span class="enscript-variable-name">Public</span> <span class="enscript-variable-name">functions</span> * * * 
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Set up the PRNG */</span>
prng_error_status
<span class="enscript-function-name">prngInitialize</span>(PrngRef *prng) 
{
	UINT i;
	comp_error_status resp;
	prng_error_status retval = PRNG_ERR_LOW_MEMORY;
	MMPTR	mmp;
	PRNG	*p;
	
	mmInit();
	
	#<span class="enscript-keyword">if</span>	MUTEX_ENABLE
	<span class="enscript-comment">/* Create the mutex */</span>
	<span class="enscript-comment">/* NOTE: on return the mutex should bve held, since our caller (prngInitialize)
	 * will release it. 
	 */</span>
	<span class="enscript-keyword">if</span>(mutexCreatorId!=0) {<span class="enscript-keyword">return</span> PRNG_ERR_REINIT;}
	Statmutex = CreateMutex(NULL,TRUE,NULL);
	<span class="enscript-keyword">if</span>(Statmutex == NULL) {mutexCreatorId = 0; <span class="enscript-keyword">return</span> PRNG_ERR_MUTEX;}
	DuplicateHandle(GetCurrentProcess(),Statmutex,GetCurrentProcess(),&amp;mutex,SYNCHRONIZE,FALSE,0);
	mutexCreatorId = GetCurrentProcessId();
	#endif	<span class="enscript-comment">/* MUTEX_ENABLE */</span>
	
	<span class="enscript-comment">/* Assign memory */</span>
	mmp = mmMalloc(<span class="enscript-keyword">sizeof</span>(PRNG));
	<span class="enscript-keyword">if</span>(mmp==MM_NULL)
	{
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_init</span>;
	}
	<span class="enscript-keyword">else</span>
	{
		p = (PRNG*)mmGetPtr(mmp);
		memset(p, 0, <span class="enscript-keyword">sizeof</span>(PRNG));
	}

	<span class="enscript-comment">/* Initialize Variables */</span>
	<span class="enscript-keyword">for</span>(i=0;i&lt;TOTAL_SOURCES;i++) 
	{
		p-&gt;poolSize[i] = 0;
		p-&gt;poolEstBits[i] = 0;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WIN_NT</span>
	<span class="enscript-comment">/* Setup security on the registry so that remote users cannot predict the slow pool */</span>
	prng_set_NT_security();
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Initialize the secret state. */</span>
	<span class="enscript-comment">/* FIXME - might want to make this an option here and have the caller
	 * do it after we return....? */</span>
	YSHA1Init(&amp;p-&gt;pool);
#<span class="enscript-reference">if</span>		<span class="enscript-variable-name">SLOW_POLL_ENABLE</span>
	prng_slow_init(p);	<span class="enscript-comment">/* Does a slow poll and then calls prng_make_state(...) */</span>
#<span class="enscript-reference">else</span>	
	<span class="enscript-comment">/* NULL init */</span>
	prng_do_SHA1(&amp;p-&gt;outstate);
	prng_make_new_state(&amp;p-&gt;outstate, p-&gt;outstate.out);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* SLOW_POLL_ENABLE */</span>

	<span class="enscript-comment">/* Initialize compression routines */</span>
	<span class="enscript-keyword">for</span>(i=0;i&lt;COMP_SOURCES;i++) 
	{
		resp = comp_init((p-&gt;comp_state)+i);
		<span class="enscript-keyword">if</span>(resp!=COMP_SUCCESS) {retval = PRNG_ERR_COMPRESSION; <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_init</span>;}
	}
	
	p-&gt;ready = PRNG_READY;
	*prng = (PrngRef)p;
	
	<span class="enscript-keyword">return</span> PRNG_SUCCESS;

<span class="enscript-reference">cleanup_init</span>:
	<span class="enscript-comment">/* Program failed on one of the mmmallocs */</span>
	mmFree(mmp);
	mmp = MM_NULL;
	
	#<span class="enscript-keyword">if</span>		MUTEX_ENABLE
	CloseHandle(Statmutex);
	Statmutex = NULL;
	mutexCreatorId = 0;
	#endif
	
	<span class="enscript-keyword">return</span> retval; <span class="enscript-comment">/* default PRNG_ERR_LOW_MEMORY */</span>
}

<span class="enscript-comment">/* Provide output */</span>
prng_error_status
<span class="enscript-function-name">prngOutput</span>(PRNG *p, BYTE *outbuf,UINT outbuflen) 
{
	UINT i;
	GEN_CTX	*ctx = &amp;p-&gt;outstate;
	
	CHECKSTATE(p);
	GENCHECK(p);
	PCHECK(outbuf);
	chASSERT(BACKTRACKLIMIT &gt; 0);

	<span class="enscript-keyword">for</span>(i=0;i&lt;outbuflen;i++,ctx-&gt;index++,ctx-&gt;numout++) 
	{
		<span class="enscript-comment">/* Check backtracklimit */</span>
		<span class="enscript-keyword">if</span>(ctx-&gt;numout &gt; BACKTRACKLIMIT) 
		{
			prng_do_SHA1(ctx);	
			prng_make_new_state(ctx, ctx-&gt;out);
		}
		<span class="enscript-comment">/* Check position in IV */</span>
		<span class="enscript-keyword">if</span>(ctx-&gt;index&gt;=20) 
		{
			prng_do_SHA1(ctx);
		}
		<span class="enscript-comment">/* Output data */</span>
		outbuf[i] = (ctx-&gt;out)[ctx-&gt;index];
	}

	<span class="enscript-keyword">return</span> PRNG_SUCCESS;
}


<span class="enscript-comment">/* Cause the PRNG to reseed now regardless of entropy pool */</span> 
<span class="enscript-comment">/* Should this be public? */</span>
prng_error_status
<span class="enscript-function-name">prngForceReseed</span>(PRNG *p, LONGLONG ticks) 
{
	<span class="enscript-type">int</span> i;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WIN_NT</span>
	FILETIME a,b,c,usertime;
#<span class="enscript-reference">endif</span>
	BYTE buf[64];
	BYTE dig[20];
#<span class="enscript-reference">if</span>	<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">macintosh</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
	#<span class="enscript-keyword">if</span>		(defined(TARGET_API_MAC_OSX) || defined(KERNEL_BUILD))
		<span class="enscript-type">struct</span> timeval 	tv;		
		int64_t			endTime, curTime;
	#elif		defined(MACH_KERNEL_PRIVATE)
		int64_t			endTime, curTime;
	#<span class="enscript-keyword">else</span>	<span class="enscript-comment">/* TARGET_API_MAC_CARBON */</span>
		UnsignedWide 	uwide;		<span class="enscript-comment">/* struct needed for Microseconds() */</span>
		LONGLONG 		start;
		LONGLONG 		now;
	#endif
#<span class="enscript-reference">endif</span>

	CHECKSTATE(p);
	POOLCHECK(p);
	ZCHECK(ticks);
	
	<span class="enscript-comment">/* Set up start and end times */</span>
	#<span class="enscript-keyword">if</span>		defined(macintosh) || defined(__APPLE__)
		#<span class="enscript-keyword">if</span>		(defined(TARGET_API_MAC_OSX) || defined(KERNEL_BUILD))
			<span class="enscript-comment">/* note we can't loop for more than a million microseconds */</span>
            #ifdef KERNEL_BUILD
                microuptime (&amp;tv);
            #<span class="enscript-keyword">else</span>
                gettimeofday(&amp;tv, NULL);
            #endif
			endTime = (int64_t)tv.tv_sec*1000000LL + (int64_t)tv.tv_usec + ticks;
		#elif		defined(MACH_KERNEL_PRIVATE)
			endTime = mach_absolute_time() + (ticks*NSEC_PER_USEC);
		#<span class="enscript-keyword">else</span>	<span class="enscript-comment">/* TARGET_API_MAC_OSX */</span>
			Microseconds(&amp;uwide);
			start = UnsignedWideToUInt64(uwide);
		#endif	<span class="enscript-comment">/* TARGET_API_xxx */</span>
	#endif	<span class="enscript-comment">/* macintosh */</span>
	<span class="enscript-keyword">do</span>
	{
		<span class="enscript-comment">/* Do a couple of iterations between time checks */</span>
		prngOutput(p, buf,64);
		YSHA1Update(&amp;p-&gt;pool,buf,64);
		prngOutput(p, buf,64);
		YSHA1Update(&amp;p-&gt;pool,buf,64);
		prngOutput(p, buf,64);
		YSHA1Update(&amp;p-&gt;pool,buf,64);
		prngOutput(p, buf,64);
		YSHA1Update(&amp;p-&gt;pool,buf,64);
		prngOutput(p, buf,64);
		YSHA1Update(&amp;p-&gt;pool,buf,64);

#<span class="enscript-reference">if</span>		<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">macintosh</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
	#<span class="enscript-keyword">if</span>		defined(TARGET_API_MAC_OSX) || defined(KERNEL_BUILD)
        #ifdef TARGET_API_MAC_OSX
            gettimeofday(&amp;tv, NULL);
        #<span class="enscript-keyword">else</span>
            microuptime (&amp;tv);
	    curTime = (int64_t)tv.tv_sec*1000000LL + (int64_t)tv.tv_usec;
        #endif
	} <span class="enscript-keyword">while</span>(curTime &lt; endTime);
	#elif		defined(MACH_KERNEL_PRIVATE)
	    curTime = mach_absolute_time();	
	} <span class="enscript-keyword">while</span>(curTime &lt; endTime);
	#<span class="enscript-keyword">else</span>
		Microseconds(&amp;uwide);
		now = UnsignedWideToUInt64(uwide);
	} <span class="enscript-keyword">while</span> ( (now-start) &lt; ticks) ;
	#endif
#<span class="enscript-reference">else</span>
	} <span class="enscript-keyword">while</span> ( (now-start) &lt; ticks) ;
#<span class="enscript-reference">endif</span>
	YSHA1Final(dig,&amp;p-&gt;pool);
	YSHA1Update(&amp;p-&gt;pool,dig,20); 
	YSHA1Final(dig,&amp;p-&gt;pool);

	<span class="enscript-comment">/* Reset secret state */</span>
	YSHA1Init(&amp;p-&gt;pool);
	prng_make_new_state(&amp;p-&gt;outstate,dig);

	<span class="enscript-comment">/* Clear counter variables */</span>
	<span class="enscript-keyword">for</span>(i=0;i&lt;TOTAL_SOURCES;i++) 
	{
		p-&gt;poolSize[i] = 0;
		p-&gt;poolEstBits[i] = 0;
	}

	<span class="enscript-comment">/* Cleanup memory */</span>
	trashMemory(dig,20*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>));
	trashMemory(buf,64*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>));

	<span class="enscript-keyword">return</span> PRNG_SUCCESS;
}


<span class="enscript-comment">/* Input a state into the PRNG */</span>
prng_error_status
<span class="enscript-function-name">prngProcessSeedBuffer</span>(PRNG *p, BYTE *buf,LONGLONG ticks) 
{
	CHECKSTATE(p);
	GENCHECK(p);
	PCHECK(buf);

	<span class="enscript-comment">/* Put the data into the entropy, add some data from the unknown state, reseed */</span>
	YSHA1Update(&amp;p-&gt;pool,buf,20);			<span class="enscript-comment">/* Put it into the entropy pool */</span>
	prng_do_SHA1(&amp;p-&gt;outstate);				<span class="enscript-comment">/* Output 20 more bytes and     */</span>
	YSHA1Update(&amp;p-&gt;pool,p-&gt;outstate.out,20);<span class="enscript-comment">/* add it to the pool as well.  */</span>
	prngForceReseed(p, ticks); 				<span class="enscript-comment">/* Do a reseed */</span>
	<span class="enscript-keyword">return</span> prngOutput(p, buf,20); <span class="enscript-comment">/* Return the first 20 bytes of output in buf */</span>
}


<span class="enscript-comment">/* Take some &quot;random&quot; data and make more &quot;random-looking&quot; data from it */</span>
<span class="enscript-comment">/* note: this routine has no context, no mutex wrapper */</span>
prng_error_status
<span class="enscript-function-name">prngStretch</span>(BYTE *inbuf,UINT inbuflen,BYTE *outbuf,UINT outbuflen) {
	<span class="enscript-type">long</span> <span class="enscript-type">int</span> left,prev;
	YSHA1_CTX ctx;
	BYTE dig[20];

	PCHECK(inbuf);
	PCHECK(outbuf);

	<span class="enscript-keyword">if</span>(inbuflen &gt;= outbuflen) 
	{
		memcpy(outbuf,inbuf,outbuflen);
		<span class="enscript-keyword">return</span> PRNG_SUCCESS;
	}
	<span class="enscript-keyword">else</span>  <span class="enscript-comment">/* Extend using SHA1 hash of inbuf */</span>
	{
		YSHA1Init(&amp;ctx);
		YSHA1Update(&amp;ctx,inbuf,inbuflen);
		YSHA1Final(dig,&amp;ctx);
		<span class="enscript-keyword">for</span>(prev=0,left=outbuflen;left&gt;0;prev+=20,left-=20) 
		{
			YSHA1Update(&amp;ctx,dig,20);
			YSHA1Final(dig,&amp;ctx);
			memcpy(outbuf+prev,dig,(left&gt;20)?20:left);
		}
		trashMemory(dig,20*<span class="enscript-keyword">sizeof</span>(BYTE));
		
		<span class="enscript-keyword">return</span> PRNG_SUCCESS;
	}

	<span class="enscript-keyword">return</span> PRNG_ERR_PROGRAM_FLOW;
}


<span class="enscript-comment">/* Add entropy to the PRNG from a source */</span>
prng_error_status
<span class="enscript-function-name">prngInput</span>(PRNG *p, BYTE *inbuf,UINT inbuflen,UINT poolnum, __unused UINT estbits)
{
	#ifndef	YARROW_KERNEL
	comp_error_status resp;
	#endif
	
	CHECKSTATE(p);
	POOLCHECK(p);
	PCHECK(inbuf);
	<span class="enscript-keyword">if</span>(poolnum &gt;= TOTAL_SOURCES) {<span class="enscript-keyword">return</span> PRNG_ERR_OUT_OF_BOUNDS;}

	<span class="enscript-comment">/* Add to entropy pool */</span>
	YSHA1Update(&amp;p-&gt;pool,inbuf,inbuflen);
	
	#ifndef	YARROW_KERNEL
	<span class="enscript-comment">/* skip this step for the kernel */</span>
	
	<span class="enscript-comment">/* Update pool size, pool user estimate and pool compression context */</span>
	p-&gt;poolSize[poolnum] += inbuflen;
	p-&gt;poolEstBits[poolnum] += estbits;
	<span class="enscript-keyword">if</span>(poolnum&lt;COMP_SOURCES)
	{
		resp = comp_add_data((p-&gt;comp_state)+poolnum,inbuf,inbuflen);
		<span class="enscript-keyword">if</span>(resp!=COMP_SUCCESS) {<span class="enscript-keyword">return</span> PRNG_ERR_COMPRESSION;}
	}
	#endif	<span class="enscript-comment">/* YARROW_KERNEL */</span>
	
	<span class="enscript-keyword">return</span> PRNG_SUCCESS;
}



<span class="enscript-comment">/* If we have enough entropy, allow a reseed of the system */</span>
prng_error_status
<span class="enscript-function-name">prngAllowReseed</span>(PRNG *p, LONGLONG ticks) 
{
	UINT temp[TOTAL_SOURCES];
	LONG i;
	UINT sum;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">KERNEL_BUILD</span>
	<span class="enscript-type">float</span> ratio;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">KERNEL_BUILD</span>
	comp_error_status resp;
#<span class="enscript-reference">endif</span>

	CHECKSTATE(p);

	<span class="enscript-keyword">for</span>(i=0;i&lt;ENTROPY_SOURCES;i++)
	{
		<span class="enscript-comment">/* Make sure that compression-based entropy estimates are current */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">KERNEL_BUILD</span> // <span class="enscript-variable-name">floating</span> <span class="enscript-variable-name">point</span> <span class="enscript-variable-name">in</span> <span class="enscript-variable-name">a</span> <span class="enscript-variable-name">kernel</span> <span class="enscript-variable-name">is</span> <span class="enscript-variable-name">BAD</span>!
		resp = comp_get_ratio((p-&gt;comp_state)+i,&amp;ratio);
		<span class="enscript-keyword">if</span>(resp!=COMP_SUCCESS) {<span class="enscript-keyword">return</span> PRNG_ERR_COMPRESSION;}
		<span class="enscript-comment">/* Use 4 instead of 8 to half compression estimate */</span>
		temp[i] = (<span class="enscript-type">int</span>)(ratio*p-&gt;poolSize[i]*4);
#<span class="enscript-reference">else</span>
        temp[i] = p-&gt;poolSize[i] * 4;
#<span class="enscript-reference">endif</span>

	}
	<span class="enscript-comment">/* Use minumum of user and compression estimate for compressed sources */</span>
	<span class="enscript-keyword">for</span>(i=ENTROPY_SOURCES;i&lt;COMP_SOURCES;i++)
	{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">KERNEL_BUILD</span>
		<span class="enscript-comment">/* Make sure that compression-based entropy estimates are current */</span>
		resp = comp_get_ratio((p-&gt;comp_state)+i,&amp;ratio);
		<span class="enscript-keyword">if</span>(resp!=COMP_SUCCESS) {<span class="enscript-keyword">return</span> PRNG_ERR_COMPRESSION;}
		<span class="enscript-comment">/* Use 4 instead of 8 to half compression estimate */</span>
		temp[i] = _MIN((<span class="enscript-type">int</span>)(ratio*p-&gt;poolSize[i]*4),(<span class="enscript-type">int</span>)p-&gt;poolEstBits[i]);
#<span class="enscript-reference">else</span>
        temp[i] = _MIN (p-&gt;poolSize[i] * 4, p-&gt;poolEstBits[i]);
#<span class="enscript-reference">endif</span>

	}
	<span class="enscript-comment">/* Use user estimate for remaining sources */</span>
	<span class="enscript-keyword">for</span>(i=COMP_SOURCES;i&lt;TOTAL_SOURCES;i++) {temp[i] = p-&gt;poolEstBits[i];}

	<span class="enscript-keyword">if</span>(K &gt; 0) {
		<span class="enscript-comment">/* pointless if we're not ignoring any sources */</span>
		bubbleSort(temp,TOTAL_SOURCES);
	}
	<span class="enscript-keyword">for</span>(i=K,sum=0;i&lt;TOTAL_SOURCES;sum+=temp[i++]); <span class="enscript-comment">/* Stupid C trick */</span>
	<span class="enscript-keyword">if</span>(sum&gt;THRESHOLD) 
		<span class="enscript-keyword">return</span> prngForceReseed(p, ticks);
	<span class="enscript-keyword">else</span> 
		<span class="enscript-keyword">return</span> PRNG_ERR_NOT_ENOUGH_ENTROPY;

	<span class="enscript-keyword">return</span> PRNG_ERR_PROGRAM_FLOW;
}

#<span class="enscript-reference">if</span>		<span class="enscript-variable-name">SLOW_POLL_ENABLE</span>
<span class="enscript-comment">/* Call a slow poll and insert the data into the entropy pool */</span>
<span class="enscript-type">static</span> prng_error_status
<span class="enscript-function-name">prngSlowPoll</span>(PRNG *p, UINT pollsize)
{
	BYTE *buf;
	DWORD len;
	prng_error_status retval;

	CHECKSTATE(p);

	buf = (BYTE*)malloc(pollsize);
	<span class="enscript-keyword">if</span>(buf==NULL) {<span class="enscript-keyword">return</span> PRNG_ERR_LOW_MEMORY;}
	len = prng_slow_poll(buf,pollsize);	<span class="enscript-comment">/* OS specific call */</span>
	retval = prngInput(p, buf,len,SLOWPOLLSOURCE, len * 8);
	trashMemory(buf,pollsize);
	free(buf);

	<span class="enscript-keyword">return</span> retval;
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* SLOW_POLL_ENABLE */</span>


<span class="enscript-comment">/* Delete the PRNG */</span>
prng_error_status
<span class="enscript-function-name">prngDestroy</span>(PRNG *p) 
{
	UINT i;

	#<span class="enscript-keyword">if</span>	MUTEX_ENABLE
	<span class="enscript-keyword">if</span>(GetCurrentProcessId()!=mutexCreatorId) {<span class="enscript-keyword">return</span> PRNG_ERR_WRONG_CALLER;}
	#endif
	<span class="enscript-keyword">if</span>(p==NULL) {<span class="enscript-keyword">return</span> PRNG_SUCCESS;} <span class="enscript-comment">/* Well, there is nothing to destroy... */</span>

	p-&gt;ready = PRNG_NOT_READY;
	
	<span class="enscript-keyword">for</span>(i=0;i&lt;COMP_SOURCES;i++)
	{
		comp_end((p-&gt;comp_state)+i);
	}

	#<span class="enscript-keyword">if</span>	MUTEX_ENABLE
	CloseHandle(Statmutex);
	Statmutex = NULL;
	mutexCreatorId = 0;
	#endif
	
	<span class="enscript-keyword">return</span> PRNG_SUCCESS;
}


</pre>
<hr />
</body></html>