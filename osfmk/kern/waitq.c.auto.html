<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>waitq.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">waitq.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_FREE_COPYRIGHT@
 */</span>
<span class="enscript-comment">/*
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ast.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/simple_lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/waitq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sync_policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqdbg</span>(fmt,...) \
	printf(<span class="enscript-string">&quot;WQ[%s]:  &quot;</span> fmt <span class="enscript-string">&quot;\n&quot;</span>, __func__, ## __VA_ARGS__)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqdbg</span>(fmt,...) do { } while (0)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">WAITQ_VERBOSE_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqdbg_v</span>(fmt,...) \
	printf(<span class="enscript-string">&quot;WQ[v:%s]:  &quot;</span> fmt <span class="enscript-string">&quot;\n&quot;</span>, __func__, ## __VA_ARGS__)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqdbg_v</span>(fmt,...) do { } while (0)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqinfo</span>(fmt,...) \
	printf(<span class="enscript-string">&quot;WQ[%s]: &quot;</span> fmt <span class="enscript-string">&quot;\n&quot;</span>, __func__,  ## __VA_ARGS__)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqerr</span>(fmt,...) \
	printf(<span class="enscript-string">&quot;WQ[%s] ERROR: &quot;</span> fmt <span class="enscript-string">&quot;\n&quot;</span>, __func__, ## __VA_ARGS__)


<span class="enscript-comment">/*
 * un-comment the following lines to debug the link/prepost tables
 * NOTE: this expands each element by ~40 bytes
 */</span>
<span class="enscript-comment">//#define CONFIG_WAITQ_LINK_STATS
</span><span class="enscript-comment">//#define CONFIG_WAITQ_PREPOST_STATS
</span>
<span class="enscript-comment">/*
 * file-static functions / data
 */</span>
<span class="enscript-type">static</span> thread_t <span class="enscript-function-name">waitq_select_one_locked</span>(<span class="enscript-type">struct</span> waitq *waitq, event64_t event,
					uint64_t *reserved_preposts,
					<span class="enscript-type">int</span> priority, spl_t *spl);

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">waitq_select_thread_locked</span>(<span class="enscript-type">struct</span> waitq *waitq,
						event64_t event,
						thread_t thread, spl_t *spl);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WAITQ_SET_MAX</span> (task_max * 3)
<span class="enscript-type">static</span> zone_t waitq_set_zone;


#<span class="enscript-reference">define</span>	<span class="enscript-function-name">P2ROUNDUP</span>(x, align) (-(-((uint32_t)(x)) &amp; -(align)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ROUNDDOWN</span>(x,y)	(((x)/(y))*(y))


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">waitq_grab_backtrace</span>(uintptr_t bt[NWAITQ_BTFRAMES], <span class="enscript-type">int</span> skip);
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* ----------------------------------------------------------------------
 *
 * Wait Queue Link/Prepost Table Implementation
 *
 * ---------------------------------------------------------------------- */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_MIN_FREE_TABLE_ELEM</span>    100
<span class="enscript-type">static</span> uint32_t g_min_free_table_elem;
<span class="enscript-type">static</span> uint32_t g_min_free_cache;

<span class="enscript-type">static</span> vm_size_t   g_wqt_max_tbl_size;
<span class="enscript-type">static</span> lck_grp_t   g_wqt_lck_grp;

<span class="enscript-comment">/* 1 prepost table, 1 setid link table */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NUM_WQ_TABLES</span> 2

<span class="enscript-comment">/* default VA space for waitq tables (zone allocated) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_MAX_TABLE_SIZE</span>  P2ROUNDUP(8 * 1024 * 1024, PAGE_SIZE)

<span class="enscript-type">struct</span> wq_id {
	<span class="enscript-type">union</span> {
		uint64_t id;
		<span class="enscript-type">struct</span> {
			<span class="enscript-comment">/*
			 * this bitfied is OK because we don't need to
			 * enforce a particular memory layout
			 */</span>
			uint64_t idx:18, <span class="enscript-comment">/* allows indexing up to 8MB of 32byte link objects */</span>
				 <span class="enscript-reference">generation</span>:46;
		};
	};
};

<span class="enscript-type">enum</span> wqt_elem_type {
	WQT_FREE     = 0,
	WQT_ELEM     = 1,
	WQT_LINK     = 2,
	WQT_RESERVED = 3,
};

<span class="enscript-type">struct</span> wqt_elem {
	uint32_t wqt_bits;

	uint32_t wqt_next_idx;

	<span class="enscript-type">struct</span> wq_id wqt_id;
};

<span class="enscript-comment">/* this _must_ match the idx bitfield definition in struct wq_id */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WQT_IDX_MAX</span>           (0x3ffff)
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEVELOPMENT</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEBUG</span>)
<span class="enscript-comment">/* global for lldb macros */</span>
uint64_t g_wqt_idx_max = WQT_IDX_MAX;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* reference count bits should _always_ be the low-order bits */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WQT_BITS_REFCNT_MASK</span>  (0x1FFFFFFF)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WQT_BITS_REFCNT_SHIFT</span> (0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WQT_BITS_REFCNT</span>       (WQT_BITS_REFCNT_MASK &lt;&lt; WQT_BITS_REFCNT_SHIFT)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WQT_BITS_TYPE_MASK</span>    (0x3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WQT_BITS_TYPE_SHIFT</span>   (29)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WQT_BITS_TYPE</span>         (WQT_BITS_TYPE_MASK &lt;&lt; WQT_BITS_TYPE_SHIFT)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WQT_BITS_VALID_MASK</span>   (0x1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WQT_BITS_VALID_SHIFT</span>  (31)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WQT_BITS_VALID</span>        (WQT_BITS_VALID_MASK &lt;&lt; WQT_BITS_VALID_SHIFT)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqt_bits_refcnt</span>(bits) \
	(((bits) &gt;&gt; WQT_BITS_REFCNT_SHIFT) &amp; WQT_BITS_REFCNT_MASK)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqt_bits_type</span>(bits) \
	(((bits) &gt;&gt; WQT_BITS_TYPE_SHIFT) &amp; WQT_BITS_TYPE_MASK)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqt_bits_valid</span>(bits) \
	((bits) &amp; WQT_BITS_VALID)

<span class="enscript-type">struct</span> wq_table;
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*wq_table_poison_func)(<span class="enscript-type">struct</span> wq_table *, <span class="enscript-type">struct</span> wqt_elem *);

<span class="enscript-comment">/*
 * A table is a container for slabs of elements. Each slab is 'slab_sz' bytes
 * and contains 'slab_sz/elem_sz' elements (of 'elem_sz' bytes each). These
 * slabs allow the table to be broken up into potentially dis-contiguous VA
 * space. On 32-bit platforms with large amounts of physical RAM, this is
 * quite important. Keeping slabs like this slightly complicates retrieval of
 * table elements, but not by much.
 */</span>
<span class="enscript-type">struct</span> wq_table {
	<span class="enscript-type">struct</span> wqt_elem **table;   <span class="enscript-comment">/* an array of 'slabs' of elements */</span>
	<span class="enscript-type">struct</span> wqt_elem **next_free_slab;
	<span class="enscript-type">struct</span> wq_id     free_list __attribute__((aligned(8)));

	uint32_t         nelem;
	uint32_t         used_elem;
	uint32_t         elem_sz;  <span class="enscript-comment">/* size of a table element (bytes) */</span>

	uint32_t         slab_sz;  <span class="enscript-comment">/* size of a table 'slab' object (bytes) */</span>
	uint32_t         slab_shift;
	uint32_t         slab_msk;
	uint32_t         slab_elem;
	zone_t           slab_zone;

	wq_table_poison_func poison;

	lck_mtx_t        lock;
	uint32_t         state;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
	uint32_t         nslabs;

	uint64_t         nallocs;
	uint64_t         nreallocs;
	uint64_t         npreposts;
	int64_t          nreservations;
	uint64_t         nreserved_releases;
	uint64_t         nspins;

	uint64_t         max_used;
	uint64_t         avg_used;
	uint64_t         max_reservations;
	uint64_t         avg_reservations;
#<span class="enscript-reference">endif</span>
} __attribute__((aligned(8)));

#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqt_elem_ofst_slab</span>(slab, slab_msk, ofst) \
	<span class="enscript-comment">/* cast through 'void *' to avoid compiler alignment warning messages */</span> \
	((<span class="enscript-type">struct</span> wqt_elem *)((<span class="enscript-type">void</span> *)((uintptr_t)(slab) + ((ofst) &amp; (slab_msk)))))

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_WAITQ_LINK_STATS</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_WAITQ_PREPOST_STATS</span>)
<span class="enscript-comment">/* version that makes no assumption on waste within a slab */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">struct</span> wqt_elem *
<span class="enscript-function-name">wqt_elem_idx</span>(<span class="enscript-type">struct</span> wq_table *table, uint32_t idx)
{
	<span class="enscript-type">int</span> slab_idx = idx / table-&gt;slab_elem;
	<span class="enscript-type">struct</span> wqt_elem *slab = table-&gt;table[slab_idx];
	<span class="enscript-keyword">if</span> (!slab)
		panic(<span class="enscript-string">&quot;Invalid index:%d slab:%d (NULL) for table:%p\n&quot;</span>,
		      idx, slab_idx, table);
	assert(slab-&gt;wqt_id.idx &lt;= idx &amp;&amp; (slab-&gt;wqt_id.idx + table-&gt;slab_elem) &gt; idx);
	<span class="enscript-keyword">return</span> wqt_elem_ofst_slab(slab, table-&gt;slab_msk, (idx - slab-&gt;wqt_id.idx) * table-&gt;elem_sz);
}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !CONFIG_WAITQ_[LINK|PREPOST]_STATS */</span>
<span class="enscript-comment">/* verion that assumes 100% ultilization of slabs (no waste) */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">struct</span> wqt_elem *
<span class="enscript-function-name">wqt_elem_idx</span>(<span class="enscript-type">struct</span> wq_table *table, uint32_t idx)
{
	uint32_t ofst = idx * table-&gt;elem_sz;
	<span class="enscript-type">struct</span> wqt_elem *slab = table-&gt;table[ofst &gt;&gt; table-&gt;slab_shift];
	<span class="enscript-keyword">if</span> (!slab)
		panic(<span class="enscript-string">&quot;Invalid index:%d slab:%d (NULL) for table:%p\n&quot;</span>,
		      idx, (ofst &gt;&gt; table-&gt;slab_shift), table);
	assert(slab-&gt;wqt_id.idx &lt;= idx &amp;&amp; (slab-&gt;wqt_id.idx + table-&gt;slab_elem) &gt; idx);
	<span class="enscript-keyword">return</span> wqt_elem_ofst_slab(slab, table-&gt;slab_msk, ofst);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !CONFIG_WAITQ_[LINK|PREPOST]_STATS */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> __assert_only <span class="enscript-function-name">wqt_elem_in_range</span>(<span class="enscript-type">struct</span> wqt_elem *elem,
					   <span class="enscript-type">struct</span> wq_table *table)
{
	<span class="enscript-type">struct</span> wqt_elem **base = table-&gt;table;
	uintptr_t e = (uintptr_t)elem;
	assert(base != NULL);
	<span class="enscript-keyword">while</span> (*base != NULL) {
		uintptr_t b = (uintptr_t)(*base);
		<span class="enscript-keyword">if</span> (e &gt;= b &amp;&amp; e &lt; b + table-&gt;slab_sz)
			<span class="enscript-keyword">return</span> 1;
		base++;
		<span class="enscript-keyword">if</span> ((uintptr_t)base &gt;= (uintptr_t)table-&gt;table + PAGE_SIZE)
			<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wqt_elem *<span class="enscript-function-name">wq_table_get_elem</span>(<span class="enscript-type">struct</span> wq_table *table, uint64_t id);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_table_put_elem</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">struct</span> wqt_elem *elem);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wqt_elem_list_link</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">struct</span> wqt_elem *parent,
			      <span class="enscript-type">struct</span> wqt_elem *child);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wqt_elem_invalidate</span>(<span class="enscript-type">struct</span> wqt_elem *elem)
{
	uint32_t __assert_only old = OSBitAndAtomic(~WQT_BITS_VALID, &amp;elem-&gt;wqt_bits);
	OSMemoryBarrier();
	assert(((wqt_bits_type(old) != WQT_RESERVED) &amp;&amp; (old &amp; WQT_BITS_VALID)) ||
	       ((wqt_bits_type(old) == WQT_RESERVED) &amp;&amp; !(old &amp; WQT_BITS_VALID)));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wqt_elem_mkvalid</span>(<span class="enscript-type">struct</span> wqt_elem *elem)
{
	uint32_t __assert_only old = OSBitOrAtomic(WQT_BITS_VALID, &amp;elem-&gt;wqt_bits);
	OSMemoryBarrier();
	assert(!(old &amp; WQT_BITS_VALID));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wqt_elem_set_type</span>(<span class="enscript-type">struct</span> wqt_elem *elem, <span class="enscript-type">int</span> type)
{
	uint32_t old_bits, new_bits;
	<span class="enscript-keyword">do</span> {
		old_bits = elem-&gt;wqt_bits;
		new_bits = (old_bits &amp; ~WQT_BITS_TYPE) |
			   ((type &amp; WQT_BITS_TYPE_MASK) &lt;&lt; WQT_BITS_TYPE_SHIFT);
	} <span class="enscript-keyword">while</span> (OSCompareAndSwap(old_bits, new_bits, &amp;elem-&gt;wqt_bits) == FALSE);
	OSMemoryBarrier();
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_table_bootstrap</span>(<span class="enscript-type">void</span>)
{
	uint32_t      tmp32 = 0;

	g_min_free_cache = 0;
	g_min_free_table_elem = DEFAULT_MIN_FREE_TABLE_ELEM;
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;wqt_min_free&quot;</span>, &amp;tmp32, <span class="enscript-keyword">sizeof</span>(tmp32)) == TRUE)
		g_min_free_table_elem = tmp32;
	wqdbg(<span class="enscript-string">&quot;Minimum free table elements: %d&quot;</span>, tmp32);

	g_wqt_max_tbl_size = DEFAULT_MAX_TABLE_SIZE;
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;wqt_tbl_size&quot;</span>, &amp;tmp32, <span class="enscript-keyword">sizeof</span>(tmp32)) == TRUE)
		g_wqt_max_tbl_size = (vm_size_t)P2ROUNDUP(tmp32, PAGE_SIZE);

	lck_grp_init(&amp;g_wqt_lck_grp, <span class="enscript-string">&quot;waitq_table_locks&quot;</span>, LCK_GRP_ATTR_NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_table_init</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
			  uint32_t max_tbl_elem, uint32_t elem_sz,
			  wq_table_poison_func poison)
{
	kern_return_t kr;
	uint32_t slab_sz, slab_shift, slab_msk, slab_elem;
	zone_t slab_zone;
	size_t max_tbl_sz;
	<span class="enscript-type">struct</span> wqt_elem *e, **base;

	<span class="enscript-comment">/*
	 * First, allocate a single page of memory to act as the base
	 * for the table's element slabs
	 */</span>
	kr = kernel_memory_allocate(kernel_map, (vm_offset_t *)&amp;base,
				    PAGE_SIZE, 0, KMA_NOPAGEWAIT, VM_KERN_MEMORY_WAITQ);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;Cannot initialize %s table: &quot;</span>
		      <span class="enscript-string">&quot;kernel_memory_allocate failed:%d\n&quot;</span>, name, kr);
	memset(base, 0, PAGE_SIZE);

	<span class="enscript-comment">/*
	 * Based on the maximum table size, calculate the slab size:
	 * we allocate 1 page of slab pointers for the table, and we need to
	 * index elements of 'elem_sz', this gives us the slab size based on
	 * the maximum size the table should grow.
	 */</span>
	max_tbl_sz = (max_tbl_elem * elem_sz);
	max_tbl_sz = P2ROUNDUP(max_tbl_sz, PAGE_SIZE);

	<span class="enscript-comment">/* system maximum table size divided by number of slots in a page */</span>
	slab_sz = (uint32_t)(max_tbl_sz / (PAGE_SIZE / (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *))));
	<span class="enscript-keyword">if</span> (slab_sz &lt; PAGE_SIZE)
		slab_sz = PAGE_SIZE;

	<span class="enscript-comment">/* make sure the slab size is a power of two */</span>
	slab_shift = 0;
	slab_msk = ~0;
	<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; 31; i++) {
		uint32_t bit = (1 &lt;&lt; i);
		<span class="enscript-keyword">if</span> ((slab_sz &amp; bit) == slab_sz) {
			slab_shift = i;
			slab_msk = 0;
			<span class="enscript-keyword">for</span> (uint32_t j = 0; j &lt; i; j++)
				slab_msk |= (1 &lt;&lt; j);
			<span class="enscript-keyword">break</span>;
		}
		slab_sz &amp;= ~bit;
	}
	slab_elem = slab_sz / elem_sz;

	<span class="enscript-comment">/* initialize the table's slab zone (for table growth) */</span>
	wqdbg(<span class="enscript-string">&quot;Initializing %s zone: slab:%d (%d,0x%x) max:%ld&quot;</span>,
	      name, slab_sz, slab_shift, slab_msk, max_tbl_sz);
	slab_zone = zinit(slab_sz, max_tbl_sz, slab_sz, name);
	assert(slab_zone != ZONE_NULL);

	<span class="enscript-comment">/* allocate the first slab and populate it */</span>
	base[0] = (<span class="enscript-type">struct</span> wqt_elem *)zalloc(slab_zone);
	<span class="enscript-keyword">if</span> (base[0] == NULL)
		panic(<span class="enscript-string">&quot;Can't allocate a %s table slab from zone:%p&quot;</span>,
		      name, slab_zone);

	memset(base[0], 0, slab_sz);

	<span class="enscript-comment">/* setup the initial freelist */</span>
	wqdbg(<span class="enscript-string">&quot;initializing %d links (%d bytes each)...&quot;</span>, slab_elem, elem_sz);
	<span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> l = 0; l &lt; slab_elem; l++) {
		e = wqt_elem_ofst_slab(base[0], slab_msk, l * elem_sz);
		e-&gt;wqt_id.idx = l;
		<span class="enscript-comment">/*
		 * setting generation to 0 ensures that a setid of 0 is
		 * invalid because the generation will be incremented before
		 * each element's allocation.
		 */</span>
		e-&gt;wqt_id.generation = 0;
		e-&gt;wqt_next_idx = l + 1;
	}

	<span class="enscript-comment">/* make sure the last free element points to a never-valid idx */</span>
	e = wqt_elem_ofst_slab(base[0], slab_msk, (slab_elem - 1) * elem_sz);
	e-&gt;wqt_next_idx = WQT_IDX_MAX;

	lck_mtx_init(&amp;table-&gt;lock, &amp;g_wqt_lck_grp, LCK_ATTR_NULL);

	table-&gt;slab_sz = slab_sz;
	table-&gt;slab_shift = slab_shift;
	table-&gt;slab_msk = slab_msk;
	table-&gt;slab_elem = slab_elem;
	table-&gt;slab_zone = slab_zone;

	table-&gt;elem_sz = elem_sz;
	table-&gt;nelem = slab_elem;
	table-&gt;used_elem = 0;
	table-&gt;elem_sz = elem_sz;
	table-&gt;poison = poison;

	table-&gt;table = base;
	table-&gt;next_free_slab = &amp;base[1];
	table-&gt;free_list.id = base[0]-&gt;wqt_id.id;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
	table-&gt;nslabs = 1;
	table-&gt;nallocs = 0;
	table-&gt;nreallocs = 0;
	table-&gt;npreposts = 0;
	table-&gt;nreservations = 0;
	table-&gt;nreserved_releases = 0;

	table-&gt;max_used = 0;
	table-&gt;avg_used = 0;
	table-&gt;max_reservations = 0;
	table-&gt;avg_reservations = 0;
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/**
 * grow a waitq table by adding another 'slab' of table elements
 *
 * Conditions:
 *	table mutex is unlocked
 *	calling thread can block
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_table_grow</span>(<span class="enscript-type">struct</span> wq_table *table, uint32_t min_free)
{
	<span class="enscript-type">struct</span> wqt_elem *slab, **slot;
	<span class="enscript-type">struct</span> wqt_elem *e = NULL, *first_new_elem, *last_new_elem;
	<span class="enscript-type">struct</span> wq_id free_id;
	uint32_t free_elem;

	assert(get_preemption_level() == 0);
	assert(table &amp;&amp; table-&gt;slab_zone);

	lck_mtx_lock(&amp;table-&gt;lock);

	free_elem = table-&gt;nelem - table-&gt;used_elem;

	<span class="enscript-comment">/*
	 * If the caller just wanted to ensure a minimum number of elements,
	 * do that (and don't just blindly grow the table). Also, don't grow
	 * the table unnecessarily - we could have been beaten by a higher
	 * priority thread who acquired the lock and grew the table before we
	 * got here.
	 */</span>
	<span class="enscript-keyword">if</span> (free_elem &gt; min_free) {
		lck_mtx_unlock(&amp;table-&gt;lock);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* we are now committed to table growth */</span>
	wqdbg_v(<span class="enscript-string">&quot;BEGIN&quot;</span>);

	<span class="enscript-keyword">if</span> (table-&gt;next_free_slab == NULL) {
		<span class="enscript-comment">/*
		 * before we panic, check one more time to see if any other
		 * threads have free'd from space in the table.
		 */</span>
		<span class="enscript-keyword">if</span> ((table-&gt;nelem - table-&gt;used_elem) &gt; 0) {
			<span class="enscript-comment">/* there's at least 1 free element: don't panic yet */</span>
			lck_mtx_unlock(&amp;table-&gt;lock);
			<span class="enscript-keyword">return</span>;
		}
		panic(<span class="enscript-string">&quot;No more room to grow table: %p (nelem: %d, used: %d)&quot;</span>,
		      table, table-&gt;nelem, table-&gt;used_elem);
	}
	slot = table-&gt;next_free_slab;
	table-&gt;next_free_slab++;
	<span class="enscript-keyword">if</span> ((uintptr_t)table-&gt;next_free_slab &gt;= (uintptr_t)table-&gt;table + PAGE_SIZE)
		table-&gt;next_free_slab = NULL;

	assert(*slot == NULL);

	<span class="enscript-comment">/* allocate another slab */</span>
	slab = (<span class="enscript-type">struct</span> wqt_elem *)zalloc(table-&gt;slab_zone);
	<span class="enscript-keyword">if</span> (slab == NULL)
		panic(<span class="enscript-string">&quot;Can't allocate a %s table (%p) slab from zone:%p&quot;</span>,
		      table-&gt;slab_zone-&gt;zone_name, table, table-&gt;slab_zone);

	memset(slab, 0, table-&gt;slab_sz);

	<span class="enscript-comment">/* put the new elements into a freelist */</span>
	wqdbg_v(<span class="enscript-string">&quot;    init %d new links...&quot;</span>, table-&gt;slab_elem);
	<span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> l = 0; l &lt; table-&gt;slab_elem; l++) {
		uint32_t idx = l + table-&gt;nelem;
		<span class="enscript-keyword">if</span> (idx &gt;= (WQT_IDX_MAX - 1))
			<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* the last element of the last slab */</span>
		e = wqt_elem_ofst_slab(slab, table-&gt;slab_msk, l * table-&gt;elem_sz);
		e-&gt;wqt_id.idx = idx;
		e-&gt;wqt_next_idx = idx + 1;
	}
	last_new_elem = e;
	assert(last_new_elem != NULL);

	first_new_elem = wqt_elem_ofst_slab(slab, table-&gt;slab_msk, 0);

	<span class="enscript-comment">/* update table book keeping, and atomically swap the freelist head */</span>
	*slot = slab;
	<span class="enscript-keyword">if</span> (table-&gt;nelem + table-&gt;slab_elem &gt;= WQT_IDX_MAX)
		table-&gt;nelem = WQT_IDX_MAX - 1;
	<span class="enscript-keyword">else</span>
		table-&gt;nelem += table-&gt;slab_elem;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
	table-&gt;nslabs += 1;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * The atomic swap of the free list head marks the end of table
	 * growth. Incoming requests may now use the newly allocated slab
	 * of table elements
	 */</span>
	free_id = table-&gt;free_list;
	<span class="enscript-comment">/* connect the existing free list to the end of the new free list */</span>
	last_new_elem-&gt;wqt_next_idx = free_id.idx;
	<span class="enscript-keyword">while</span> (OSCompareAndSwap64(free_id.id, first_new_elem-&gt;wqt_id.id,
				  &amp;table-&gt;free_list.id) == FALSE) {
		OSMemoryBarrier();
		free_id = table-&gt;free_list;
		last_new_elem-&gt;wqt_next_idx = free_id.idx;
	}
	OSMemoryBarrier();

	lck_mtx_unlock(&amp;table-&gt;lock);

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline))
<span class="enscript-type">struct</span> wqt_elem *<span class="enscript-function-name">wq_table_alloc_elem</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">int</span> type, <span class="enscript-type">int</span> nelem)
{
	<span class="enscript-type">int</span> nspins = 0, ntries = 0, nalloc = 0;
	uint32_t table_size;
	<span class="enscript-type">struct</span> wqt_elem *elem = NULL;
	<span class="enscript-type">struct</span> wq_id free_id, next_id;

	<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> max_retries = 500;

	<span class="enscript-keyword">if</span> (type != WQT_ELEM &amp;&amp; type != WQT_LINK &amp;&amp; type != WQT_RESERVED)
		panic(<span class="enscript-string">&quot;wq_table_aloc of invalid elem type:%d from table @%p&quot;</span>,
		      type, table);

	assert(nelem &gt; 0);
	elem = NULL;

<span class="enscript-reference">try_again</span>:
	<span class="enscript-keyword">if</span> (ntries++ &gt; max_retries) {
		<span class="enscript-type">struct</span> wqt_elem *tmp;
		<span class="enscript-keyword">if</span> (table-&gt;used_elem + nelem &gt;= table_size)
			panic(<span class="enscript-string">&quot;No more room to grow table: 0x%p size:%d, used:%d, requested elem:%d&quot;</span>,
			      table, table_size, table-&gt;used_elem, nelem);
		<span class="enscript-keyword">if</span> (nelem == 1)
			panic(<span class="enscript-string">&quot;Too many alloc retries: %d, table:%p, type:%d, nelem:%d&quot;</span>,
			      ntries, table, type, nelem);
		<span class="enscript-comment">/* don't panic: try allocating one-at-a-time */</span>
		<span class="enscript-keyword">while</span> (nelem &gt; 0) {
			tmp = wq_table_alloc_elem(table, type, 1);
			<span class="enscript-keyword">if</span> (elem)
				wqt_elem_list_link(table, tmp, elem);
			elem = tmp;
			--nelem;
		}
		assert(elem != NULL);
		<span class="enscript-keyword">return</span> elem;
	}

	nalloc = 0;
	table_size = table-&gt;nelem;

	<span class="enscript-keyword">if</span> (table-&gt;used_elem + nelem &gt;= table_size) {
		<span class="enscript-keyword">if</span> (get_preemption_level() != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
			table-&gt;nspins += 1;
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/*
			 * We may have just raced with table growth: check
			 * again to make sure there really isn't any space.
			 */</span>
			<span class="enscript-keyword">if</span> (++nspins &gt; 4)
				panic(<span class="enscript-string">&quot;Can't grow table %p with preemption&quot;</span>
				      <span class="enscript-string">&quot; disabled!&quot;</span>, table);
			delay(1);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;
		}
		wq_table_grow(table, nelem);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;
	}

	<span class="enscript-comment">/* read this value only once before the CAS */</span>
	free_id = table-&gt;free_list;
	<span class="enscript-keyword">if</span> (free_id.idx &gt;= table_size)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;

	<span class="enscript-comment">/*
	 * Find the item on the free list which will become the new free list
	 * head, but be careful not to modify any memory (read only)!  Other
	 * threads can alter table state at any time up until the CAS.  We
	 * don't modify any memory until we've successfully swapped out the
	 * free list head with the one we've investigated.
	 */</span>
	<span class="enscript-keyword">for</span> (<span class="enscript-type">struct</span> wqt_elem *next_elem = wqt_elem_idx(table, free_id.idx);
	     nalloc &lt; nelem;
	     nalloc++) {
		elem = next_elem;
		next_id.generation = 0;
		next_id.idx = next_elem-&gt;wqt_next_idx;
		<span class="enscript-keyword">if</span> (next_id.idx &lt; table-&gt;nelem) {
			next_elem = wqt_elem_idx(table, next_id.idx);
			next_id.id = next_elem-&gt;wqt_id.id;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;
		}
	}
	<span class="enscript-comment">/* 'elem' points to the last element being allocated */</span>

	<span class="enscript-keyword">if</span> (OSCompareAndSwap64(free_id.id, next_id.id,
			       &amp;table-&gt;free_list.id) == FALSE)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;

	<span class="enscript-comment">/* load barrier */</span>
	OSMemoryBarrier();

	<span class="enscript-comment">/*
	 * After the CAS, we know that we own free_id, and it points to a
	 * valid table entry (checked above). Grab the table pointer and
	 * reset some values.
	 */</span>
	OSAddAtomic(nelem, &amp;table-&gt;used_elem);

	<span class="enscript-comment">/* end the list of allocated elements */</span>
	elem-&gt;wqt_next_idx = WQT_IDX_MAX;
	<span class="enscript-comment">/* reset 'elem' to point to the first allocated element */</span>
	elem = wqt_elem_idx(table, free_id.idx);

	<span class="enscript-comment">/*
	 * Update the generation count, and return the element(s)
	 * with a single reference (and no valid bit). If the
	 * caller immediately calls _put() on any element, then
	 * it will be released back to the free list. If the caller
	 * subsequently marks the element as valid, then the put
	 * will simply drop the reference.
	 */</span>
	<span class="enscript-keyword">for</span> (<span class="enscript-type">struct</span> wqt_elem *tmp = elem; ; ) {
		assert(!wqt_bits_valid(tmp-&gt;wqt_bits) &amp;&amp;
		       (wqt_bits_refcnt(tmp-&gt;wqt_bits) == 0));
		--nalloc;
		tmp-&gt;wqt_id.generation += 1;
		tmp-&gt;wqt_bits = 1;
		wqt_elem_set_type(tmp, type);
		<span class="enscript-keyword">if</span> (tmp-&gt;wqt_next_idx == WQT_IDX_MAX)
			<span class="enscript-keyword">break</span>;
		assert(tmp-&gt;wqt_next_idx != WQT_IDX_MAX);
		tmp = wqt_elem_idx(table, tmp-&gt;wqt_next_idx);
	}
	assert(nalloc == 0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
	uint64_t nreservations;
	table-&gt;nallocs += nelem;
	<span class="enscript-keyword">if</span> (type == WQT_RESERVED)
		OSIncrementAtomic64(&amp;table-&gt;nreservations);
	nreservations = table-&gt;nreservations;
	<span class="enscript-keyword">if</span> (table-&gt;used_elem &gt; table-&gt;max_used)
		table-&gt;max_used = table-&gt;used_elem;
	<span class="enscript-keyword">if</span> (nreservations &gt; table-&gt;max_reservations)
		table-&gt;max_reservations = nreservations;
	table-&gt;avg_used = (table-&gt;avg_used + table-&gt;used_elem) / 2;
	table-&gt;avg_reservations = (table-&gt;avg_reservations + nreservations) / 2;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> elem;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_table_realloc_elem</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">struct</span> wqt_elem *elem, <span class="enscript-type">int</span> type)
{
	(<span class="enscript-type">void</span>)table;
	assert(wqt_elem_in_range(elem, table) &amp;&amp;
	       !wqt_bits_valid(elem-&gt;wqt_bits));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
	table-&gt;nreallocs += 1;
	<span class="enscript-keyword">if</span> (wqt_bits_type(elem-&gt;wqt_bits) == WQT_RESERVED &amp;&amp; type != WQT_RESERVED) {
		<span class="enscript-comment">/*
		 * This isn't under any lock, so we'll clamp it.
		 * the stats are meant to be informative, not perfectly
		 * accurate
		 */</span>
		OSDecrementAtomic64(&amp;table-&gt;nreservations);
	}
	table-&gt;avg_reservations = (table-&gt;avg_reservations + table-&gt;nreservations) / 2;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Return the same element with a new generation count, and a
	 * (potentially) new type. Don't touch the refcount: the caller
	 * is responsible for getting that (and the valid bit) correct.
	 */</span>
	elem-&gt;wqt_id.generation += 1;
	elem-&gt;wqt_next_idx = WQT_IDX_MAX;
	wqt_elem_set_type(elem, type);

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_table_free_elem</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">struct</span> wqt_elem *elem)
{
	<span class="enscript-type">struct</span> wq_id next_id;

	assert(wqt_elem_in_range(elem, table) &amp;&amp;
	       !wqt_bits_valid(elem-&gt;wqt_bits) &amp;&amp;
	       (wqt_bits_refcnt(elem-&gt;wqt_bits) == 0));

	OSDecrementAtomic(&amp;table-&gt;used_elem);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
	table-&gt;avg_used = (table-&gt;avg_used + table-&gt;used_elem) / 2;
	<span class="enscript-keyword">if</span> (wqt_bits_type(elem-&gt;wqt_bits) == WQT_RESERVED)
		OSDecrementAtomic64(&amp;table-&gt;nreservations);
	table-&gt;avg_reservations = (table-&gt;avg_reservations + table-&gt;nreservations) / 2;
#<span class="enscript-reference">endif</span>

	elem-&gt;wqt_bits = 0;

	<span class="enscript-keyword">if</span> (table-&gt;poison)
		(table-&gt;poison)(table, elem);

<span class="enscript-reference">again</span>:
	next_id = table-&gt;free_list;
	<span class="enscript-keyword">if</span> (next_id.idx &gt;= table-&gt;nelem)
		elem-&gt;wqt_next_idx = WQT_IDX_MAX;
	<span class="enscript-keyword">else</span>
		elem-&gt;wqt_next_idx = next_id.idx;

	<span class="enscript-comment">/* store barrier */</span>
	OSMemoryBarrier();
	<span class="enscript-keyword">if</span> (OSCompareAndSwap64(next_id.id, elem-&gt;wqt_id.id,
			       &amp;table-&gt;free_list.id) == FALSE)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
}

<span class="enscript-comment">/* get a reference to a table element identified by 'id' */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wqt_elem *<span class="enscript-function-name">wq_table_get_elem</span>(<span class="enscript-type">struct</span> wq_table *table, uint64_t id)
{
	<span class="enscript-type">struct</span> wqt_elem *elem;
	uint32_t idx, bits, new_bits;

	<span class="enscript-comment">/*
	 * Here we have a reference to the table which is guaranteed to remain
	 * valid until we drop the reference
	 */</span>

	idx = ((<span class="enscript-type">struct</span> wq_id *)&amp;id)-&gt;idx;

	<span class="enscript-keyword">if</span> (idx &gt;= table-&gt;nelem)
		panic(<span class="enscript-string">&quot;id:0x%llx : idx:%d &gt; %d&quot;</span>, id, idx, table-&gt;nelem);

	elem = wqt_elem_idx(table, idx);

	<span class="enscript-comment">/* verify the validity by taking a reference on the table object */</span>
	bits = elem-&gt;wqt_bits;
	<span class="enscript-keyword">if</span> (!wqt_bits_valid(bits))
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-comment">/*
	 * do a pre-verify on the element ID to potentially
	 * avoid 2 compare-and-swaps
	 */</span>
	<span class="enscript-keyword">if</span> (elem-&gt;wqt_id.id != id)
		<span class="enscript-keyword">return</span> NULL;

	new_bits = bits + 1;

	<span class="enscript-comment">/* check for overflow */</span>
	assert(wqt_bits_refcnt(new_bits) &gt; 0);

	<span class="enscript-keyword">while</span> (OSCompareAndSwap(bits, new_bits, &amp;elem-&gt;wqt_bits) == FALSE) {
		<span class="enscript-comment">/*
		 * either the element became invalid,
		 * or someone else grabbed/removed a reference.
		 */</span>
		bits = elem-&gt;wqt_bits;
		<span class="enscript-keyword">if</span> (!wqt_bits_valid(bits)) {
			<span class="enscript-comment">/* don't return invalid elements */</span>
			<span class="enscript-keyword">return</span> NULL;
		}
		new_bits = bits + 1;
		assert(wqt_bits_refcnt(new_bits) &gt; 0);
	}

	<span class="enscript-comment">/* load barrier */</span>
	OSMemoryBarrier();

	<span class="enscript-comment">/* check to see that our reference is to the same generation! */</span>
	<span class="enscript-keyword">if</span> (elem-&gt;wqt_id.id != id) {
		<span class="enscript-comment">/*
		wqdbg(&quot;ID:0x%llx table generation (%d) != %d&quot;,
		      id, elem-&gt;wqt_id.generation,
		      ((struct wq_id *)&amp;id)-&gt;generation);
		 */</span>
		wq_table_put_elem(table, elem);
		<span class="enscript-keyword">return</span> NULL;
	}

	<span class="enscript-comment">/* We now have a reference on a valid object */</span>
	<span class="enscript-keyword">return</span> elem;
}

<span class="enscript-comment">/* release a ref to table element - puts it back on free list as appropriate */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_table_put_elem</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">struct</span> wqt_elem *elem)
{
	uint32_t bits, new_bits;

	assert(wqt_elem_in_range(elem, table));

	bits = elem-&gt;wqt_bits;
	new_bits = bits - 1;

	<span class="enscript-comment">/* check for underflow */</span>
	assert(wqt_bits_refcnt(new_bits) &lt; WQT_BITS_REFCNT_MASK);

	<span class="enscript-keyword">while</span> (OSCompareAndSwap(bits, new_bits, &amp;elem-&gt;wqt_bits) == FALSE) {
		bits = elem-&gt;wqt_bits;
		new_bits = bits - 1;
		<span class="enscript-comment">/* catch underflow */</span>
		assert(wqt_bits_refcnt(new_bits) &lt; WQT_BITS_REFCNT_MASK);
	}

	<span class="enscript-comment">/* load barrier */</span>
	OSMemoryBarrier();

	<span class="enscript-comment">/*
	 * if this was the last reference, and it was marked as invalid,
	 * then we can add this link object back to the free list
	 */</span>
	<span class="enscript-keyword">if</span> (!wqt_bits_valid(new_bits) &amp;&amp; (wqt_bits_refcnt(new_bits) == 0))
		wq_table_free_elem(table, elem);

	<span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *
 * API: wqt_elem_list_...
 *
 * Reuse the free list linkage member, 'wqt_next_idx' of a table element
 * in a slightly more generic singly-linked list. All members of this
 * list have been allocated from a table, but have not been made valid.
 *
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/</span>

<span class="enscript-comment">/* link parent-&gt;child */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wqt_elem_list_link</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">struct</span> wqt_elem *parent, <span class="enscript-type">struct</span> wqt_elem *child)
{
	<span class="enscript-type">int</span> nelem = 1;

	assert(wqt_elem_in_range(parent, table));

	<span class="enscript-comment">/* find the end of the parent's list */</span>
	<span class="enscript-keyword">while</span> (parent-&gt;wqt_next_idx != WQT_IDX_MAX) {
		assert(parent-&gt;wqt_next_idx &lt; table-&gt;nelem);
		parent = wqt_elem_idx(table, parent-&gt;wqt_next_idx);
		nelem++;
	}

	<span class="enscript-keyword">if</span> (child) {
		assert(wqt_elem_in_range(child, table));
		parent-&gt;wqt_next_idx = child-&gt;wqt_id.idx;
	}

	<span class="enscript-keyword">return</span> nelem;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wqt_elem *<span class="enscript-function-name">wqt_elem_list_next</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">struct</span> wqt_elem *head)
{
	<span class="enscript-type">struct</span> wqt_elem *elem;

	<span class="enscript-keyword">if</span> (!head)
		<span class="enscript-keyword">return</span> NULL;
	<span class="enscript-keyword">if</span> (head-&gt;wqt_next_idx &gt;= table-&gt;nelem)
		<span class="enscript-keyword">return</span> NULL;

	elem = wqt_elem_idx(table, head-&gt;wqt_next_idx);
	assert(wqt_elem_in_range(elem, table));

	<span class="enscript-keyword">return</span> elem;
}

<span class="enscript-comment">/*
 * Obtain a pointer to the first element of a list.  Don't take an extra
 * reference on the object - the list implicitly holds that reference.
 *
 * This function is used to convert the head of a singly-linked list
 * to a real wqt_elem object.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wqt_elem *<span class="enscript-function-name">wqt_elem_list_first</span>(<span class="enscript-type">struct</span> wq_table *table, uint64_t id)
{
	uint32_t idx;
	<span class="enscript-type">struct</span> wqt_elem *elem = NULL;

	<span class="enscript-keyword">if</span> (id == 0)
		<span class="enscript-keyword">return</span> NULL;

	idx = ((<span class="enscript-type">struct</span> wq_id *)&amp;id)-&gt;idx;

	<span class="enscript-keyword">if</span> (idx &gt; table-&gt;nelem)
		panic(<span class="enscript-string">&quot;Invalid element for id:0x%llx&quot;</span>, id);
	elem = wqt_elem_idx(table, idx);

	<span class="enscript-comment">/* invalid element: reserved ID was probably already reallocated */</span>
	<span class="enscript-keyword">if</span> (elem-&gt;wqt_id.id != id)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-comment">/* the returned element should _not_ be marked valid! */</span>
	<span class="enscript-keyword">if</span> (wqt_bits_valid(elem-&gt;wqt_bits) ||
	    wqt_bits_type(elem-&gt;wqt_bits) != WQT_RESERVED ||
	    wqt_bits_refcnt(elem-&gt;wqt_bits) != 1) {
		panic(<span class="enscript-string">&quot;Valid/unreserved element %p (0x%x) in reserved list&quot;</span>,
		      elem, elem-&gt;wqt_bits);
	}

	<span class="enscript-keyword">return</span> elem;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wqt_elem_reset_next</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">struct</span> wqt_elem *wqp)
{
	(<span class="enscript-type">void</span>)table;

	<span class="enscript-keyword">if</span> (!wqp)
		<span class="enscript-keyword">return</span>;
	assert(wqt_elem_in_range(wqp, table));

	wqp-&gt;wqt_next_idx = WQT_IDX_MAX;
}

<span class="enscript-comment">/*
 * Pop an item off the list.
 * New list head returned in *id, caller responsible for reference on returned
 * object. We do a realloc here to reset the type of the object, but still
 * leave it invalid.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wqt_elem *<span class="enscript-function-name">wqt_elem_list_pop</span>(<span class="enscript-type">struct</span> wq_table *table, uint64_t *id, <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> wqt_elem *first, *next;

	<span class="enscript-keyword">if</span> (!id || *id == 0)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-comment">/* pop an item off the reserved stack */</span>

	first = wqt_elem_list_first(table, *id);
	<span class="enscript-keyword">if</span> (!first) {
		*id = 0;
		<span class="enscript-keyword">return</span> NULL;
	}

	next = wqt_elem_list_next(table, first);
	<span class="enscript-keyword">if</span> (next)
		*id = next-&gt;wqt_id.id;
	<span class="enscript-keyword">else</span>
		*id = 0;

	wq_table_realloc_elem(table, first, type);

	<span class="enscript-keyword">return</span> first;
}

<span class="enscript-comment">/*
 * Free an entire list of linked/reserved elements
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wqt_elem_list_release</span>(<span class="enscript-type">struct</span> wq_table *table,
				 <span class="enscript-type">struct</span> wqt_elem *head,
				 <span class="enscript-type">int</span> __assert_only type)
{
	<span class="enscript-type">struct</span> wqt_elem *elem;
	<span class="enscript-type">struct</span> wq_id free_id;
	<span class="enscript-type">int</span> nelem = 0;

	<span class="enscript-keyword">if</span> (!head)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">for</span> (elem = head; ; ) {
		assert(wqt_elem_in_range(elem, table));
		assert(!wqt_bits_valid(elem-&gt;wqt_bits) &amp;&amp; (wqt_bits_refcnt(elem-&gt;wqt_bits) == 1));
		assert(wqt_bits_type(elem-&gt;wqt_bits) == type);

		nelem++;
		elem-&gt;wqt_bits = 0;
		<span class="enscript-keyword">if</span> (table-&gt;poison)
			(table-&gt;poison)(table, elem);

		<span class="enscript-keyword">if</span> (elem-&gt;wqt_next_idx == WQT_IDX_MAX)
			<span class="enscript-keyword">break</span>;
		assert(elem-&gt;wqt_next_idx &lt; table-&gt;nelem);
		elem = wqt_elem_idx(table, elem-&gt;wqt_next_idx);
	}

	<span class="enscript-comment">/*
	 * 'elem' now points to the end of our list, and 'head' points to the
	 * beginning. We want to atomically swap the free list pointer with
	 * the 'head' and ensure that 'elem' points to the previous free list
	 * head.
	 */</span>

<span class="enscript-reference">again</span>:
	free_id = table-&gt;free_list;
	<span class="enscript-keyword">if</span> (free_id.idx &gt;= table-&gt;nelem)
		elem-&gt;wqt_next_idx = WQT_IDX_MAX;
	<span class="enscript-keyword">else</span>
		elem-&gt;wqt_next_idx = free_id.idx;

	<span class="enscript-comment">/* store barrier */</span>
	OSMemoryBarrier();
	<span class="enscript-keyword">if</span> (OSCompareAndSwap64(free_id.id, head-&gt;wqt_id.id,
			       &amp;table-&gt;free_list.id) == FALSE)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;

	OSAddAtomic(-nelem, &amp;table-&gt;used_elem);
	<span class="enscript-keyword">return</span> nelem;
}


<span class="enscript-comment">/* ----------------------------------------------------------------------
 *
 * SetID Link Table Implementation
 *
 * ---------------------------------------------------------------------- */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wq_table g_linktable;

<span class="enscript-type">enum</span> setid_link_type {
	SLT_ALL     = -1,
	SLT_FREE    = WQT_FREE,
	SLT_WQS     = WQT_ELEM,
	SLT_LINK    = WQT_LINK,
};

<span class="enscript-type">struct</span> setid_link {
	<span class="enscript-type">struct</span> wqt_elem wqte;

	<span class="enscript-type">union</span> {
		<span class="enscript-comment">/* wqt_type == SLT_WQS (WQT_ELEM) */</span>
		<span class="enscript-type">struct</span> {
			<span class="enscript-type">struct</span> waitq_set *sl_set;
			<span class="enscript-comment">/* uint64_t          sl_prepost_id; */</span>
		} sl_wqs;

		<span class="enscript-comment">/* wqt_type == SLT_LINK (WQT_LINK) */</span>
		<span class="enscript-type">struct</span> {
			uint64_t          sl_left_setid;
			uint64_t          sl_right_setid;
		} sl_link;
	};
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_WAITQ_LINK_STATS</span>
	thread_t  sl_alloc_th;
	task_t    sl_alloc_task;
	uintptr_t sl_alloc_bt[NWAITQ_BTFRAMES];
	uint64_t  sl_alloc_ts;
	uintptr_t sl_invalidate_bt[NWAITQ_BTFRAMES];
	uint64_t  sl_invalidate_ts;
	uintptr_t sl_mkvalid_bt[NWAITQ_BTFRAMES];
	uint64_t  sl_mkvalid_ts;
	uint64_t  sl_free_ts;
#<span class="enscript-reference">endif</span>
};
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_WAITQ_LINK_STATS</span>)
<span class="enscript-function-name">_Static_assert</span>((<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> setid_link) &amp; (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> setid_link) - 1)) == 0,
	       <span class="enscript-string">&quot;setid_link struct must be a power of two!&quot;</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">sl_refcnt</span>(link) \
	(wqt_bits_refcnt((link)-&gt;wqte.wqt_bits))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">sl_type</span>(link) \
	(wqt_bits_type((link)-&gt;wqte.wqt_bits))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">sl_set_valid</span>(link) \
	<span class="enscript-keyword">do</span> { \
		wqt_elem_mkvalid(&amp;(link)-&gt;wqte); \
		lt_do_mkvalid_stats(&amp;(link)-&gt;wqte); \
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">sl_is_valid</span>(link) \
	wqt_bits_valid((link)-&gt;wqte.wqt_bits)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">sl_set_id</span> wqte.wqt_id

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SLT_WQS_POISON</span>         ((void *)(0xf00df00d))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SLT_LINK_POISON</span>        (0x0bad0badffffffffull)

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">lt_poison</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">struct</span> wqt_elem *elem)
{
	<span class="enscript-type">struct</span> setid_link *sl_link = (<span class="enscript-type">struct</span> setid_link *)elem;
	(<span class="enscript-type">void</span>)table;

	<span class="enscript-keyword">switch</span> (sl_type(sl_link)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SLT_WQS</span>:
		sl_link-&gt;sl_wqs.sl_set = SLT_WQS_POISON;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SLT_LINK</span>:
		sl_link-&gt;sl_link.sl_left_setid = SLT_LINK_POISON;
		sl_link-&gt;sl_link.sl_right_setid = SLT_LINK_POISON;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_WAITQ_LINK_STATS</span>
	memset(sl_link-&gt;sl_alloc_bt, 0, <span class="enscript-keyword">sizeof</span>(sl_link-&gt;sl_alloc_bt));
	sl_link-&gt;sl_alloc_ts = 0;
	memset(sl_link-&gt;sl_mkvalid_bt, 0, <span class="enscript-keyword">sizeof</span>(sl_link-&gt;sl_mkvalid_bt));
	sl_link-&gt;sl_mkvalid_ts = 0;

	sl_link-&gt;sl_alloc_th = THREAD_NULL;
	<span class="enscript-comment">/* leave the sl_alloc_task in place for debugging */</span>

	sl_link-&gt;sl_free_ts = mach_absolute_time();
#<span class="enscript-reference">endif</span>
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_WAITQ_LINK_STATS</span>
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">lt_do_alloc_stats</span>(<span class="enscript-type">struct</span> wqt_elem *elem)
{
	<span class="enscript-keyword">if</span> (elem) {
		<span class="enscript-type">struct</span> setid_link *link = (<span class="enscript-type">struct</span> setid_link *)elem;
		memset(link-&gt;sl_alloc_bt, 0, <span class="enscript-keyword">sizeof</span>(link-&gt;sl_alloc_bt));
		waitq_grab_backtrace(link-&gt;sl_alloc_bt, 0);
		link-&gt;sl_alloc_th = current_thread();
		link-&gt;sl_alloc_task = current_task();

		assert(link-&gt;sl_alloc_ts == 0);
		link-&gt;sl_alloc_ts = mach_absolute_time();

		memset(link-&gt;sl_invalidate_bt, 0, <span class="enscript-keyword">sizeof</span>(link-&gt;sl_invalidate_bt));
		link-&gt;sl_invalidate_ts = 0;
	}
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">lt_do_invalidate_stats</span>(<span class="enscript-type">struct</span> wqt_elem *elem)
{
	<span class="enscript-type">struct</span> setid_link *link = (<span class="enscript-type">struct</span> setid_link *)elem;

	<span class="enscript-keyword">if</span> (!elem)
		<span class="enscript-keyword">return</span>;

	assert(link-&gt;sl_mkvalid_ts &gt; 0);

	memset(link-&gt;sl_invalidate_bt, 0, <span class="enscript-keyword">sizeof</span>(link-&gt;sl_invalidate_bt));
	link-&gt;sl_invalidate_ts = mach_absolute_time();
	waitq_grab_backtrace(link-&gt;sl_invalidate_bt, 0);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">lt_do_mkvalid_stats</span>(<span class="enscript-type">struct</span> wqt_elem *elem)
{
	<span class="enscript-type">struct</span> setid_link *link = (<span class="enscript-type">struct</span> setid_link *)elem;

	<span class="enscript-keyword">if</span> (!elem)
		<span class="enscript-keyword">return</span>;

	memset(link-&gt;sl_mkvalid_bt, 0, <span class="enscript-keyword">sizeof</span>(link-&gt;sl_mkvalid_bt));
	link-&gt;sl_mkvalid_ts = mach_absolute_time();
	waitq_grab_backtrace(link-&gt;sl_mkvalid_bt, 0);
}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">lt_do_alloc_stats</span>(e)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">lt_do_invalidate_stats</span>(e)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">lt_do_mkvalid_stats</span>(e)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_WAITQ_LINK_STATS */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">lt_init</span>(<span class="enscript-type">void</span>)
{
	uint32_t tablesz = 0, max_links = 0;

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;wql_tsize&quot;</span>, &amp;tablesz, <span class="enscript-keyword">sizeof</span>(tablesz)) != TRUE)
		tablesz = (uint32_t)g_wqt_max_tbl_size;

	tablesz = P2ROUNDUP(tablesz, PAGE_SIZE);
	max_links = tablesz / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> setid_link);
	assert(max_links &gt; 0 &amp;&amp; tablesz &gt; 0);

	<span class="enscript-comment">/* we have a restricted index range */</span>
	<span class="enscript-keyword">if</span> (max_links &gt; (WQT_IDX_MAX + 1))
		max_links = WQT_IDX_MAX + 1;

	wqinfo(<span class="enscript-string">&quot;init linktable with max:%d elements (%d bytes)&quot;</span>,
	       max_links, tablesz);
	wq_table_init(&amp;g_linktable, <span class="enscript-string">&quot;wqslab.links&quot;</span>, max_links,
		      <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> setid_link), lt_poison);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">lt_ensure_free_space</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (g_linktable.nelem - g_linktable.used_elem &lt; g_min_free_table_elem) {
		<span class="enscript-comment">/*
		 * we don't hold locks on these values, so check for underflow
		 */</span>
		<span class="enscript-keyword">if</span> (g_linktable.used_elem &lt;= g_linktable.nelem) {
			wqdbg_v(<span class="enscript-string">&quot;Forcing table growth: nelem=%d, used=%d, min_free=%d&quot;</span>,
				g_linktable.nelem, g_linktable.used_elem,
				g_min_free_table_elem);
			wq_table_grow(&amp;g_linktable, g_min_free_table_elem);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> setid_link *<span class="enscript-function-name">lt_alloc_link</span>(<span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> wqt_elem *elem;

	elem = wq_table_alloc_elem(&amp;g_linktable, type, 1);
	lt_do_alloc_stats(elem);
	<span class="enscript-keyword">return</span> (<span class="enscript-type">struct</span> setid_link *)elem;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">lt_realloc_link</span>(<span class="enscript-type">struct</span> setid_link *link, <span class="enscript-type">int</span> type)
{
	wq_table_realloc_elem(&amp;g_linktable, &amp;link-&gt;wqte, type);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_WAITQ_LINK_STATS</span>
	memset(link-&gt;sl_alloc_bt, 0, <span class="enscript-keyword">sizeof</span>(link-&gt;sl_alloc_bt));
	link-&gt;sl_alloc_ts = 0;
	lt_do_alloc_stats(&amp;link-&gt;wqte);

	memset(link-&gt;sl_invalidate_bt, 0, <span class="enscript-keyword">sizeof</span>(link-&gt;sl_invalidate_bt));
	link-&gt;sl_invalidate_ts = 0;
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">lt_invalidate</span>(<span class="enscript-type">struct</span> setid_link *link)
{
	wqt_elem_invalidate(&amp;link-&gt;wqte);
	lt_do_invalidate_stats(&amp;link-&gt;wqte);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> setid_link *<span class="enscript-function-name">lt_get_link</span>(uint64_t setid)
{
	<span class="enscript-type">struct</span> wqt_elem *elem;

	elem = wq_table_get_elem(&amp;g_linktable, setid);
	<span class="enscript-keyword">return</span> (<span class="enscript-type">struct</span> setid_link *)elem;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">lt_put_link</span>(<span class="enscript-type">struct</span> setid_link *link)
{
	<span class="enscript-keyword">if</span> (!link)
		<span class="enscript-keyword">return</span>;
	wq_table_put_elem(&amp;g_linktable, (<span class="enscript-type">struct</span> wqt_elem *)link);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> setid_link *<span class="enscript-function-name">lt_get_reserved</span>(uint64_t setid, <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> wqt_elem *elem;

	elem = wqt_elem_list_first(&amp;g_linktable, setid);
	<span class="enscript-keyword">if</span> (!elem)
		<span class="enscript-keyword">return</span> NULL;
	wq_table_realloc_elem(&amp;g_linktable, elem, type);
	<span class="enscript-keyword">return</span> (<span class="enscript-type">struct</span> setid_link *)elem;
}


<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_maybe_remove_link</span>(<span class="enscript-type">struct</span> waitq *waitq,
					  uint64_t setid,
					  <span class="enscript-type">struct</span> setid_link *parent,
					  <span class="enscript-type">struct</span> setid_link *left,
					  <span class="enscript-type">struct</span> setid_link *right);

<span class="enscript-type">enum</span> {
	LINK_WALK_ONE_LEVEL = 0,
	LINK_WALK_FULL_DAG  = 1,
	LINK_WALK_FULL_DAG_UNLOCKED = 2,
};

<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*lt_callback_func)(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">void</span> *ctx,
				<span class="enscript-type">struct</span> setid_link *link);

<span class="enscript-comment">/**
 * walk all table elements (of type 'link_type') pointed to by 'setid'
 *
 * Conditions:
 *	waitq is locked (or NULL)
 *	'setid' is managed by 'waitq'
 *		this could be direct (waitq-&gt;waitq_set_id == setid)
 *		OR indirect (setid is the left/right ID in a LINK chain,
 *		             whose root is waitq-&gt;waitq_set_id)
 *
 * Notes:
 *	This function uses recursion to walk the set of table elements
 *	pointed to by 'setid'. For each element encountered, 'cb' will be
 *	called. If non-zero, the return value of this callback function can
 *	early-out of the table walk.
 *
 *	For each link element encountered, the function takes a reference to
 *	it. The reference is dropped only after the callback and any recursion
 *	has completed.
 *
 *	The assumed table/link/tree structure:
 *                   'setid'
 *                   /    \
 *                  /      \
 *              L(LINK)     R(LINK)
 *               /\             /\
 *              /  \           /  \
 *             /    \       Rl(*)  Rr(*)
 *         Ll(*)  Lr(*)      /\    /\
 *           /\     /\    ... ... ... ...
 *        ...  ... ... ...
 *                    \
 *                    WQS(wqset_q.waitq_setid == Sx)
 *                    [waitq set is a membet of setid, 'Sx')
 *
 *                    'Sx'
 *                   /    \
 *                  /      \
 *              L(LINK)     R(LINK)
 *               /\             /\
 *             ... ...        ... ...
 *
 *	The basic algorithm is as follows:
 *	*) take a reference to the table object pointed to by 'setid'
 *	*) if appropriate, call 'cb' (potentially early-out on non-zero return)
 *	*) if the link object points to a waitq set, and the walk type
 *	   is 'FULL_DAG' (full directed-acyclic-graph), then try to lock
 *	   the associated waitq set object and recursively walk all sets to
 *	   which that set belongs. This is a DFS of the tree structure.
 *	*) recurse down the left side of the tree (following the
 *	   'sl_left_setid' pointer in the link object
 *	*) recurse down the right side of the tree (following the
 *	   'sl_right_setid' pointer in the link object
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline))
<span class="enscript-type">int</span> <span class="enscript-function-name">walk_setid_links</span>(<span class="enscript-type">int</span> walk_type, <span class="enscript-type">struct</span> waitq *waitq,
		     uint64_t setid, <span class="enscript-type">int</span> link_type,
		     <span class="enscript-type">void</span> *ctx, lt_callback_func cb)
{
	<span class="enscript-type">struct</span> setid_link *link;
	uint64_t nextid;
	<span class="enscript-type">int</span> sl_type;

	link = lt_get_link(setid);

	<span class="enscript-comment">/* invalid link */</span>
	<span class="enscript-keyword">if</span> (!link)
		<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;

	setid = nextid = 0;
	sl_type = sl_type(link);
	<span class="enscript-keyword">if</span> (sl_type == SLT_LINK) {
		setid  = link-&gt;sl_link.sl_left_setid;
		nextid = link-&gt;sl_link.sl_right_setid;
	}

	<span class="enscript-comment">/*
	 * Make the callback only on specified link_type (or all links)
	 * Note that after the callback, the link object may be
	 * invalid. The only valid thing we can do is put our
	 * reference to it (which may put it back on the free list)
	 */</span>
	<span class="enscript-keyword">if</span> (link_type == SLT_ALL || link_type == sl_type) {
		<span class="enscript-comment">/* allow the callback to early-out */</span>
		<span class="enscript-type">int</span> ret = cb(waitq, ctx, link);
		<span class="enscript-keyword">if</span> (ret != WQ_ITERATE_CONTINUE) {
			lt_put_link(link);
			<span class="enscript-keyword">return</span> ret;
		}
	}

	<span class="enscript-keyword">if</span> (sl_type == SLT_WQS &amp;&amp;
	    (walk_type == LINK_WALK_FULL_DAG ||
	     walk_type == LINK_WALK_FULL_DAG_UNLOCKED)) {
		<span class="enscript-comment">/*
		 * Recurse down any sets to which this wait queue set was
		 * added.  We do this just before we put our reference to
		 * the link object (which may free it).
		 */</span>
		<span class="enscript-type">struct</span> waitq_set *wqset = link-&gt;sl_wqs.sl_set;
		<span class="enscript-type">int</span> ret = WQ_ITERATE_CONTINUE;
		<span class="enscript-type">int</span> get_spl = 0;
		<span class="enscript-type">int</span> should_unlock = 0;
		uint64_t wqset_setid = 0;
		spl_t set_spl;

		<span class="enscript-keyword">if</span> (waitq_set_is_valid(wqset) &amp;&amp; walk_type == LINK_WALK_FULL_DAG) {
			<span class="enscript-keyword">if</span> ((!waitq || !waitq_irq_safe(waitq)) &amp;&amp;
			    waitq_irq_safe(&amp;wqset-&gt;wqset_q)) {
				get_spl = 1;
				set_spl = splsched();
			}
			waitq_set_lock(wqset);
			should_unlock = 1;
		}

		<span class="enscript-comment">/*
		 * verify the linked waitq set as it could have been
		 * invalidated before we grabbed the lock!
		 */</span>
		<span class="enscript-keyword">if</span> (wqset-&gt;wqset_id != link-&gt;sl_set_id.id) {
			<span class="enscript-comment">/*This is the bottom of the tree: just get out */</span>
			<span class="enscript-keyword">if</span> (should_unlock) {
				waitq_set_unlock(wqset);
				<span class="enscript-keyword">if</span> (get_spl)
					splx(set_spl);
			}
			lt_put_link(link);
			<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;
		}

		wqset_setid = wqset-&gt;wqset_q.waitq_set_id;

		<span class="enscript-keyword">if</span> (wqset_setid &gt; 0)
			ret = walk_setid_links(walk_type, &amp;wqset-&gt;wqset_q,
					       wqset_setid, link_type, ctx, cb);
		<span class="enscript-keyword">if</span> (should_unlock) {
			waitq_set_unlock(wqset);
			<span class="enscript-keyword">if</span> (get_spl)
				splx(set_spl);
		}
		<span class="enscript-keyword">if</span> (ret != WQ_ITERATE_CONTINUE) {
			lt_put_link(link);
			<span class="enscript-keyword">return</span> ret;
		}
	}

	lt_put_link(link);

	<span class="enscript-comment">/* recurse down left side of the tree */</span>
	<span class="enscript-keyword">if</span> (setid) {
		<span class="enscript-type">int</span> ret = walk_setid_links(walk_type, waitq, setid, link_type, ctx, cb);
		<span class="enscript-keyword">if</span> (ret != WQ_ITERATE_CONTINUE)
			<span class="enscript-keyword">return</span> ret;
	}

	<span class="enscript-comment">/* recurse down right side of the tree */</span>
	<span class="enscript-keyword">if</span> (nextid)
		<span class="enscript-keyword">return</span> walk_setid_links(walk_type, waitq, nextid, link_type, ctx, cb);

	<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;
}

<span class="enscript-comment">/* ----------------------------------------------------------------------
 *
 * Prepost Link Table Implementation
 *
 * ---------------------------------------------------------------------- */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wq_table g_prepost_table;

<span class="enscript-type">enum</span> wq_prepost_type {
	WQP_FREE  = WQT_FREE,
	WQP_WQ    = WQT_ELEM,
	WQP_POST  = WQT_LINK,
};

<span class="enscript-type">struct</span> wq_prepost {
	<span class="enscript-type">struct</span> wqt_elem wqte;

	<span class="enscript-type">union</span> {
		<span class="enscript-comment">/* wqt_type == WQP_WQ (WQT_ELEM) */</span>
		<span class="enscript-type">struct</span> {
			<span class="enscript-type">struct</span> waitq *wqp_wq_ptr;
		} wqp_wq;
		<span class="enscript-comment">/* wqt_type == WQP_POST (WQT_LINK) */</span>
		<span class="enscript-type">struct</span> {
			uint64_t      wqp_next_id;
			uint64_t      wqp_wq_id;
		} wqp_post;
	};
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_WAITQ_PREPOST_STATS</span>
	thread_t  wqp_alloc_th;
	task_t    wqp_alloc_task;
	uintptr_t wqp_alloc_bt[NWAITQ_BTFRAMES];
#<span class="enscript-reference">endif</span>
};
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_WAITQ_PREPOST_STATS</span>)
<span class="enscript-function-name">_Static_assert</span>((<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> wq_prepost) &amp; (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> wq_prepost) - 1)) == 0,
	       <span class="enscript-string">&quot;wq_prepost struct must be a power of two!&quot;</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqp_refcnt</span>(wqp) \
	(wqt_bits_refcnt((wqp)-&gt;wqte.wqt_bits))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqp_type</span>(wqp) \
	(wqt_bits_type((wqp)-&gt;wqte.wqt_bits))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqp_set_valid</span>(wqp) \
	wqt_elem_mkvalid(&amp;(wqp)-&gt;wqte)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqp_is_valid</span>(wqp) \
	wqt_bits_valid((wqp)-&gt;wqte.wqt_bits)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">wqp_prepostid</span> wqte.wqt_id

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WQP_WQ_POISON</span>              (0x0bad0badffffffffull)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WQP_POST_POISON</span>            (0xf00df00df00df00d)

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wqp_poison</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">struct</span> wqt_elem *elem)
{
	<span class="enscript-type">struct</span> wq_prepost *wqp = (<span class="enscript-type">struct</span> wq_prepost *)elem;
	(<span class="enscript-type">void</span>)table;

	<span class="enscript-keyword">switch</span> (wqp_type(wqp)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">WQP_WQ</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">WQP_POST</span>:
		wqp-&gt;wqp_post.wqp_next_id = WQP_POST_POISON;
		wqp-&gt;wqp_post.wqp_wq_id = WQP_POST_POISON;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_WAITQ_PREPOST_STATS</span>
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">wqp_do_alloc_stats</span>(<span class="enscript-type">struct</span> wqt_elem *elem)
{
	<span class="enscript-keyword">if</span> (elem) {
		<span class="enscript-type">struct</span> wq_prepost *wqp = (<span class="enscript-type">struct</span> wq_prepost *)elem;

		<span class="enscript-comment">/* be sure the take stats for _all_ allocated objects */</span>
		<span class="enscript-keyword">for</span> (;;) {
			uint32_t next_idx;

			memset(wqp-&gt;wqp_alloc_bt, 0, <span class="enscript-keyword">sizeof</span>(wqp-&gt;wqp_alloc_bt));
			waitq_grab_backtrace(wqp-&gt;wqp_alloc_bt, 4);
			wqp-&gt;wqp_alloc_th = current_thread();
			wqp-&gt;wqp_alloc_task = current_task();
			next_idx = wqp-&gt;wqte.wqt_next_idx;

			<span class="enscript-keyword">if</span> (next_idx == WQT_IDX_MAX)
				<span class="enscript-keyword">break</span>;
			assert(next_idx &lt; g_prepost_table.nelem);

			wqp = (<span class="enscript-type">struct</span> wq_prepost *)wqt_elem_idx(&amp;g_prepost_table,
								next_idx);
		}
	}
}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">wqp_do_alloc_stats</span>(e)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_WAITQ_LINK_STATS */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wqp_init</span>(<span class="enscript-type">void</span>)
{
	uint32_t tablesz = 0, max_wqp = 0;

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;wqp_tsize&quot;</span>, &amp;tablesz, <span class="enscript-keyword">sizeof</span>(tablesz)) != TRUE)
		tablesz = (uint32_t)g_wqt_max_tbl_size;

	tablesz = P2ROUNDUP(tablesz, PAGE_SIZE);
	max_wqp = tablesz / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> wq_prepost);
	assert(max_wqp &gt; 0 &amp;&amp; tablesz &gt; 0);

	<span class="enscript-comment">/* we have a restricted index range */</span>
	<span class="enscript-keyword">if</span> (max_wqp &gt; (WQT_IDX_MAX + 1))
		max_wqp = WQT_IDX_MAX + 1;

	wqinfo(<span class="enscript-string">&quot;init prepost table with max:%d elements (%d bytes)&quot;</span>,
	       max_wqp, tablesz);
	wq_table_init(&amp;g_prepost_table, <span class="enscript-string">&quot;wqslab.prepost&quot;</span>, max_wqp,
		      <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> wq_prepost), wqp_poison);
}

<span class="enscript-comment">/*
 * Refill the per-CPU cache.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_prepost_refill_cpu_cache</span>(uint32_t nalloc)
{
	<span class="enscript-type">struct</span> wqt_elem *new_head, *old_head;
	<span class="enscript-type">struct</span> wqp_cache *cache;

	<span class="enscript-comment">/* require preemption enabled to allocate elements */</span>
	<span class="enscript-keyword">if</span> (get_preemption_level() != 0)
		<span class="enscript-keyword">return</span>;

	new_head = wq_table_alloc_elem(&amp;g_prepost_table,
				       WQT_RESERVED, nalloc);
	<span class="enscript-keyword">if</span> (new_head == NULL)
		<span class="enscript-keyword">return</span>;

	disable_preemption();
	cache = &amp;PROCESSOR_DATA(current_processor(), wqp_cache);
	cache-&gt;avail += nalloc;
	<span class="enscript-keyword">if</span> (cache-&gt;head == 0 || cache-&gt;head == WQT_IDX_MAX) {
		cache-&gt;head = new_head-&gt;wqt_id.id;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	old_head = wqt_elem_list_first(&amp;g_prepost_table, cache-&gt;head);
	(<span class="enscript-type">void</span>)wqt_elem_list_link(&amp;g_prepost_table, new_head, old_head);
	cache-&gt;head = new_head-&gt;wqt_id.id;

<span class="enscript-reference">out</span>:
	enable_preemption();
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_prepost_ensure_free_space</span>(<span class="enscript-type">void</span>)
{
	uint32_t free_elem;
	uint32_t min_free;
	<span class="enscript-type">struct</span> wqp_cache *cache;

	<span class="enscript-keyword">if</span> (g_min_free_cache == 0)
		g_min_free_cache = (WQP_CACHE_MAX * ml_get_max_cpus());

	<span class="enscript-comment">/*
	 * Ensure that we always have a pool of per-CPU prepost elements
	 */</span>
	disable_preemption();
	cache = &amp;PROCESSOR_DATA(current_processor(), wqp_cache);
	free_elem = cache-&gt;avail;
	enable_preemption();

	<span class="enscript-keyword">if</span> (free_elem &lt; (WQP_CACHE_MAX / 3))
		wq_prepost_refill_cpu_cache(WQP_CACHE_MAX - free_elem);

	<span class="enscript-comment">/*
	 * Now ensure that we have a sufficient amount of free table space
	 */</span>
	free_elem = g_prepost_table.nelem - g_prepost_table.used_elem;
	min_free = g_min_free_table_elem + g_min_free_cache;
	<span class="enscript-keyword">if</span> (free_elem &lt; min_free) {
		<span class="enscript-comment">/*
		 * we don't hold locks on these values, so check for underflow
		 */</span>
		<span class="enscript-keyword">if</span> (g_prepost_table.used_elem &lt;= g_prepost_table.nelem) {
			wqdbg_v(<span class="enscript-string">&quot;Forcing table growth: nelem=%d, used=%d, min_free=%d+%d&quot;</span>,
				g_prepost_table.nelem, g_prepost_table.used_elem,
				g_min_free_table_elem, g_min_free_cache);
			wq_table_grow(&amp;g_prepost_table, min_free);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wq_prepost *<span class="enscript-function-name">wq_prepost_alloc</span>(<span class="enscript-type">int</span> type, <span class="enscript-type">int</span> nelem)
{
	<span class="enscript-type">struct</span> wqt_elem *elem;
	<span class="enscript-type">struct</span> wq_prepost *wqp;
	<span class="enscript-type">struct</span> wqp_cache *cache;

	<span class="enscript-keyword">if</span> (type != WQT_RESERVED)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">do_alloc</span>;
	<span class="enscript-keyword">if</span> (nelem == 0)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-comment">/*
	 * First try to grab the elements from the per-CPU cache if we are
	 * allocating RESERVED elements
	 */</span>
	disable_preemption();
	cache = &amp;PROCESSOR_DATA(current_processor(), wqp_cache);
	<span class="enscript-keyword">if</span> (nelem &lt;= (<span class="enscript-type">int</span>)cache-&gt;avail) {
		<span class="enscript-type">struct</span> wqt_elem *first, *next = NULL;
		<span class="enscript-type">int</span> nalloc = nelem;

		cache-&gt;avail -= nelem;

		<span class="enscript-comment">/* grab the first element */</span>
		first = wqt_elem_list_first(&amp;g_prepost_table, cache-&gt;head);

		<span class="enscript-comment">/* find the last element and re-adjust the cache head */</span>
		<span class="enscript-keyword">for</span> (elem = first; elem != NULL &amp;&amp; nalloc &gt; 0; elem = next) {
			next = wqt_elem_list_next(&amp;g_prepost_table, elem);
			<span class="enscript-keyword">if</span> (--nalloc == 0) {
				<span class="enscript-comment">/* terminate the allocated list */</span>
				elem-&gt;wqt_next_idx = WQT_IDX_MAX;
				<span class="enscript-keyword">break</span>;
			}
		}
		assert(nalloc == 0);
		<span class="enscript-keyword">if</span> (!next)
			cache-&gt;head = WQT_IDX_MAX;
		<span class="enscript-keyword">else</span>
			cache-&gt;head = next-&gt;wqt_id.id;
		<span class="enscript-comment">/* assert that we don't have mis-matched book keeping */</span>
		assert(!(cache-&gt;head == WQT_IDX_MAX &amp;&amp; cache-&gt;avail &gt; 0));
		enable_preemption();
		elem = first;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	enable_preemption();

<span class="enscript-reference">do_alloc</span>:
	<span class="enscript-comment">/* fall-back to standard table allocation */</span>
	elem = wq_table_alloc_elem(&amp;g_prepost_table, type, nelem);
	<span class="enscript-keyword">if</span> (!elem)
		<span class="enscript-keyword">return</span> NULL;

<span class="enscript-reference">out</span>:
	wqp = (<span class="enscript-type">struct</span> wq_prepost *)elem;
	wqp_do_alloc_stats(elem);
	<span class="enscript-keyword">return</span> wqp;
}

<span class="enscript-comment">/*
static void wq_prepost_realloc(struct wq_prepost *wqp, int type)
{
	wq_table_realloc_elem(&amp;g_prepost_table, &amp;wqp-&gt;wqte, type);
}
*/</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_prepost_invalidate</span>(<span class="enscript-type">struct</span> wq_prepost *wqp)
{
	wqt_elem_invalidate(&amp;wqp-&gt;wqte);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wq_prepost *<span class="enscript-function-name">wq_prepost_get</span>(uint64_t wqp_id)
{
	<span class="enscript-type">struct</span> wqt_elem *elem;

	elem = wq_table_get_elem(&amp;g_prepost_table, wqp_id);
	<span class="enscript-keyword">return</span> (<span class="enscript-type">struct</span> wq_prepost *)elem;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_prepost_put</span>(<span class="enscript-type">struct</span> wq_prepost *wqp)
{
	wq_table_put_elem(&amp;g_prepost_table, (<span class="enscript-type">struct</span> wqt_elem *)wqp);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wq_prepost_rlink</span>(<span class="enscript-type">struct</span> wq_prepost *parent, <span class="enscript-type">struct</span> wq_prepost *child)
{
	<span class="enscript-keyword">return</span> wqt_elem_list_link(&amp;g_prepost_table, &amp;parent-&gt;wqte, &amp;child-&gt;wqte);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wq_prepost *<span class="enscript-function-name">wq_prepost_get_rnext</span>(<span class="enscript-type">struct</span> wq_prepost *head)
{
	<span class="enscript-type">struct</span> wqt_elem *elem;
	<span class="enscript-type">struct</span> wq_prepost *wqp;
	uint64_t id;

	elem = wqt_elem_list_next(&amp;g_prepost_table, &amp;head-&gt;wqte);
	<span class="enscript-keyword">if</span> (!elem)
		<span class="enscript-keyword">return</span> NULL;
	id = elem-&gt;wqt_id.id;
	elem = wq_table_get_elem(&amp;g_prepost_table, id);

	<span class="enscript-keyword">if</span> (!elem)
		<span class="enscript-keyword">return</span> NULL;
	wqp = (<span class="enscript-type">struct</span> wq_prepost *)elem;
	<span class="enscript-keyword">if</span> (elem-&gt;wqt_id.id != id ||
	    wqp_type(wqp) != WQP_POST ||
	    wqp-&gt;wqp_post.wqp_next_id != head-&gt;wqp_prepostid.id) {
		wq_table_put_elem(&amp;g_prepost_table, elem);
		<span class="enscript-keyword">return</span> NULL;
	}

	<span class="enscript-keyword">return</span> wqp;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_prepost_reset_rnext</span>(<span class="enscript-type">struct</span> wq_prepost *wqp)
{
	wqt_elem_reset_next(&amp;g_prepost_table, &amp;wqp-&gt;wqte);
}


<span class="enscript-comment">/**
 * remove 'wqp' from the prepost list on 'wqset'
 *
 * Conditions:
 *	wqset is locked
 *	caller holds a reference on wqp (and is responsible to release it)
 *
 * Result:
 *	wqp is invalidated, wqset is potentially updated with a new
 *	prepost ID, and the next element of the prepost list may be
 *	consumed as well (if the list contained only 2 objects)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wq_prepost_remove</span>(<span class="enscript-type">struct</span> waitq_set *wqset,
			     <span class="enscript-type">struct</span> wq_prepost *wqp)
{
	<span class="enscript-type">int</span> more_posts = 1;
	uint64_t next_id = wqp-&gt;wqp_post.wqp_next_id;
	uint64_t wqp_id = wqp-&gt;wqp_prepostid.id;
	<span class="enscript-type">struct</span> wq_prepost *prev_wqp, *next_wqp;

	assert(wqp_type(wqp) == WQP_POST);

	<span class="enscript-keyword">if</span> (next_id == wqp_id) {
		<span class="enscript-comment">/* the list is singular and becoming empty */</span>
		wqset-&gt;wqset_prepost_id = 0;
		more_posts = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	prev_wqp = wq_prepost_get_rnext(wqp);
	assert(prev_wqp != NULL);
	assert(prev_wqp-&gt;wqp_post.wqp_next_id == wqp_id);
	assert(prev_wqp-&gt;wqp_prepostid.id != wqp_id);
	assert(wqp_type(prev_wqp) == WQP_POST);

	<span class="enscript-keyword">if</span> (prev_wqp-&gt;wqp_prepostid.id == next_id) {
		<span class="enscript-comment">/*
		 * There are two items in the list, and we're removing one. We
		 * only need to keep the WQP_WQ pointer from 'prev_wqp'
		 */</span>
		wqset-&gt;wqset_prepost_id = prev_wqp-&gt;wqp_post.wqp_wq_id;
		wq_prepost_invalidate(prev_wqp);
		wq_prepost_put(prev_wqp);
		more_posts = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* prev-&gt;next = next */</span>
	prev_wqp-&gt;wqp_post.wqp_next_id = next_id;

	<span class="enscript-comment">/* next-&gt;prev = prev */</span>
	next_wqp = wq_prepost_get(next_id);
	assert(next_wqp != NULL);
	assert(next_wqp != wqp);
	assert(next_wqp != prev_wqp);
	assert(wqp_type(next_wqp) == WQP_POST);

	wq_prepost_reset_rnext(next_wqp);
	wq_prepost_rlink(next_wqp, prev_wqp);

	<span class="enscript-comment">/* If we remove the head of the list, update the wqset */</span>
	<span class="enscript-keyword">if</span> (wqp_id == wqset-&gt;wqset_prepost_id)
		wqset-&gt;wqset_prepost_id = next_id;

	wq_prepost_put(prev_wqp);
	wq_prepost_put(next_wqp);

<span class="enscript-reference">out</span>:
	wq_prepost_reset_rnext(wqp);
	wq_prepost_invalidate(wqp);
	<span class="enscript-keyword">return</span> more_posts;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wq_prepost *<span class="enscript-function-name">wq_prepost_rfirst</span>(uint64_t id)
{
	<span class="enscript-type">struct</span> wqt_elem *elem;
	elem = wqt_elem_list_first(&amp;g_prepost_table, id);
	wqp_do_alloc_stats(elem);
	<span class="enscript-keyword">return</span> (<span class="enscript-type">struct</span> wq_prepost *)(<span class="enscript-type">void</span> *)elem;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wq_prepost *<span class="enscript-function-name">wq_prepost_rpop</span>(uint64_t *id, <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> wqt_elem *elem;
	elem = wqt_elem_list_pop(&amp;g_prepost_table, id, type);
	wqp_do_alloc_stats(elem);
	<span class="enscript-keyword">return</span> (<span class="enscript-type">struct</span> wq_prepost *)(<span class="enscript-type">void</span> *)elem;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_prepost_release_rlist</span>(<span class="enscript-type">struct</span> wq_prepost *wqp)
{
	<span class="enscript-type">int</span> nelem = 0;
	<span class="enscript-type">struct</span> wqp_cache *cache;
	<span class="enscript-type">struct</span> wqt_elem *elem;

	<span class="enscript-keyword">if</span> (!wqp)
		<span class="enscript-keyword">return</span>;

	elem = &amp;wqp-&gt;wqte;

	<span class="enscript-comment">/*
	 * These are reserved elements: release them back to the per-cpu pool
	 * if our cache is running low.
	 */</span>
	disable_preemption();
	cache = &amp;PROCESSOR_DATA(current_processor(), wqp_cache);
	<span class="enscript-keyword">if</span> (cache-&gt;avail &lt; WQP_CACHE_MAX) {
		<span class="enscript-type">struct</span> wqt_elem *tmp = NULL;
		<span class="enscript-keyword">if</span> (cache-&gt;head != WQT_IDX_MAX)
			tmp = wqt_elem_list_first(&amp;g_prepost_table, cache-&gt;head);
		nelem = wqt_elem_list_link(&amp;g_prepost_table, elem, tmp);
		cache-&gt;head = elem-&gt;wqt_id.id;
		cache-&gt;avail += nelem;
		enable_preemption();
		<span class="enscript-keyword">return</span>;
	}
	enable_preemption();

	<span class="enscript-comment">/* release these elements back to the main table */</span>
	nelem = wqt_elem_list_release(&amp;g_prepost_table, elem, WQT_RESERVED);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
	g_prepost_table.nreserved_releases += 1;
	OSDecrementAtomic64(&amp;g_prepost_table.nreservations);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*wqp_callback_func)(<span class="enscript-type">struct</span> waitq_set *wqset,
				 <span class="enscript-type">void</span> *ctx,
				 <span class="enscript-type">struct</span> wq_prepost *wqp,
				 <span class="enscript-type">struct</span> waitq *waitq);

<span class="enscript-comment">/**
 * iterate over a chain of preposts associated with a waitq set.
 *
 * Conditions:
 *	wqset is locked
 *
 * Notes:
 *	This loop performs automatic prepost chain management / culling, and
 *	may reset or adjust the waitq set's prepost ID pointer. If you don't
 *	want this extra processing, you can use wq_prepost_iterate().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wq_prepost_foreach_locked</span>(<span class="enscript-type">struct</span> waitq_set *wqset,
				     <span class="enscript-type">void</span> *ctx, wqp_callback_func cb)
{
	<span class="enscript-type">int</span> ret;
	<span class="enscript-type">struct</span> wq_prepost *wqp, *tmp_wqp;

	<span class="enscript-keyword">if</span> (!wqset || !wqset-&gt;wqset_prepost_id)
		<span class="enscript-keyword">return</span> WQ_ITERATE_SUCCESS;

<span class="enscript-reference">restart</span>:
	wqp = wq_prepost_get(wqset-&gt;wqset_prepost_id);
	<span class="enscript-keyword">if</span> (!wqp) {
		<span class="enscript-comment">/*
		 * The prepost object is no longer valid, reset the waitq
		 * set's prepost id.
		 */</span>
		wqset-&gt;wqset_prepost_id = 0;
		<span class="enscript-keyword">return</span> WQ_ITERATE_SUCCESS;
	}

	<span class="enscript-keyword">if</span> (wqp_type(wqp) == WQP_WQ) {
		uint64_t __assert_only wqp_id = wqp-&gt;wqp_prepostid.id;
		<span class="enscript-keyword">if</span> (cb)
			ret = cb(wqset, ctx, wqp, wqp-&gt;wqp_wq.wqp_wq_ptr);

		<span class="enscript-keyword">switch</span> (ret) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">WQ_ITERATE_INVALIDATE_CONTINUE</span>:
			<span class="enscript-comment">/* the caller wants to remove the only prepost here */</span>
			assert(wqp_id == wqset-&gt;wqset_prepost_id);
			wqset-&gt;wqset_prepost_id = 0;
			<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">WQ_ITERATE_CONTINUE</span>:
			wq_prepost_put(wqp);
			ret = WQ_ITERATE_SUCCESS;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">WQ_ITERATE_RESTART</span>:
			wq_prepost_put(wqp);
			<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">WQ_ITERATE_DROPPED</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		<span class="enscript-reference">default</span>:
			wq_prepost_put(wqp);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">return</span> ret;
	}

	assert(wqp-&gt;wqp_prepostid.id == wqset-&gt;wqset_prepost_id);
	assert(wqp_type(wqp) == WQP_POST);

	<span class="enscript-comment">/*
	 * At this point we know we have a list of POST objects.
	 * Grab a handle to the last element in the list and start
	 * the iteration.
	 */</span>
	tmp_wqp = wq_prepost_get_rnext(wqp);
	assert(tmp_wqp != NULL &amp;&amp; wqp_type(tmp_wqp) == WQP_POST);

	uint64_t last_id = tmp_wqp-&gt;wqp_prepostid.id;
	wq_prepost_put(tmp_wqp);

	ret = WQ_ITERATE_SUCCESS;
	<span class="enscript-keyword">for</span> (;;) {
		uint64_t wqp_id, first_id, next_id;

		wqp_id = wqp-&gt;wqp_prepostid.id;
		first_id = wqset-&gt;wqset_prepost_id;
		next_id = wqp-&gt;wqp_post.wqp_next_id;

		<span class="enscript-comment">/* grab the WQP_WQ object this _POST points to */</span>
		tmp_wqp = wq_prepost_get(wqp-&gt;wqp_post.wqp_wq_id);
		<span class="enscript-keyword">if</span> (!tmp_wqp) {
			<span class="enscript-comment">/*
			 * This WQP_POST object points to an invalid
			 * WQP_WQ object - remove the POST object from
			 * the list.
			 */</span>
			<span class="enscript-keyword">if</span> (wq_prepost_remove(wqset, wqp) == 0) {
				wq_prepost_put(wqp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next_prepost</span>;
		}
		assert(wqp_type(tmp_wqp) == WQP_WQ);
		<span class="enscript-comment">/*
		 * make the callback: note that this could remove 'wqp' or
		 * drop the lock on our waitq set. We need to re-validate
		 * our state when this function returns.
		 */</span>
		<span class="enscript-keyword">if</span> (cb)
			ret = cb(wqset, ctx, wqp,
				 tmp_wqp-&gt;wqp_wq.wqp_wq_ptr);
		wq_prepost_put(tmp_wqp);

		<span class="enscript-keyword">switch</span> (ret) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">WQ_ITERATE_CONTINUE</span>:
			<span class="enscript-comment">/* continue iteration */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">WQ_ITERATE_INVALIDATE_CONTINUE</span>:
			assert(next_id == wqp-&gt;wqp_post.wqp_next_id);
			<span class="enscript-keyword">if</span> (wq_prepost_remove(wqset, wqp) == 0) {
				wq_prepost_put(wqp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next_prepost</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">WQ_ITERATE_RESTART</span>:
			wq_prepost_put(wqp);
			<span class="enscript-comment">/* fall-through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">WQ_ITERATE_DROPPED</span>:
			<span class="enscript-comment">/* the callback dropped the ref to wqp: just restart */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* break out of the iteration for some other reason */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish_prepost_foreach</span>;
		}

		<span class="enscript-comment">/*
		 * the set lock may have been dropped during callback,
		 * if something looks different, restart the prepost iteration
		 */</span>
		<span class="enscript-keyword">if</span> (!wqp_is_valid(wqp) ||
		    (wqp-&gt;wqp_post.wqp_next_id != next_id) ||
		    wqset-&gt;wqset_prepost_id != first_id) {
			wq_prepost_put(wqp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		}

<span class="enscript-reference">next_prepost</span>:
		<span class="enscript-comment">/* this was the last object in the list */</span>
		<span class="enscript-keyword">if</span> (wqp_id == last_id)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* get the next object */</span>
		tmp_wqp = wq_prepost_get(next_id);
		<span class="enscript-keyword">if</span> (!tmp_wqp) {
			<span class="enscript-comment">/*
			 * At this point we've already checked our state
			 * after the callback (which may have dropped the set
			 * lock). If we find an invalid member of the list
			 * then something is wrong.
			 */</span>
			panic(<span class="enscript-string">&quot;Invalid WQP_POST member 0x%llx in waitq set &quot;</span>
			      <span class="enscript-string">&quot;0x%llx prepost list (first:%llx, &quot;</span>
			      <span class="enscript-string">&quot;wqp:%p)&quot;</span>,
			      next_id, wqset-&gt;wqset_id, first_id, wqp);
		}
		wq_prepost_put(wqp);
		wqp = tmp_wqp;

		assert(wqp_type(wqp) == WQP_POST);
	}

<span class="enscript-reference">finish_prepost_foreach</span>:
	wq_prepost_put(wqp);
	<span class="enscript-keyword">if</span> (ret == WQ_ITERATE_CONTINUE)
		ret = WQ_ITERATE_SUCCESS;

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/**
 * Perform a simple loop over a chain of prepost objects
 *
 * Conditions:
 *	If 'prepost_id' is associated with a waitq (set) then that object must
 *	be locked before calling this function.
 *	Callback function, 'cb', must be able to handle a NULL wqset pointer
 *	and a NULL waitq pointer!
 *
 * Notes:
 *	This prepost chain iteration will _not_ automatically adjust any chain
 *	element or linkage. This is the responsibility of the caller! If you
 *	want automatic prepost chain management (at a cost of extra CPU time),
 *	you can use: wq_prepost_foreach_locked().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wq_prepost_iterate</span>(uint64_t prepost_id,
			      <span class="enscript-type">void</span> *ctx, wqp_callback_func cb)
{
	<span class="enscript-type">int</span> ret;
	<span class="enscript-type">struct</span> wq_prepost *wqp;

	<span class="enscript-keyword">if</span> (!prepost_id)
		<span class="enscript-keyword">return</span> WQ_ITERATE_SUCCESS;

	wqp = wq_prepost_get(prepost_id);
	<span class="enscript-keyword">if</span> (!wqp)
		<span class="enscript-keyword">return</span> WQ_ITERATE_SUCCESS;

	<span class="enscript-keyword">if</span> (wqp_type(wqp) == WQP_WQ) {
		ret = WQ_ITERATE_SUCCESS;
		<span class="enscript-keyword">if</span> (cb)
			ret = cb(NULL, ctx, wqp, wqp-&gt;wqp_wq.wqp_wq_ptr);

		<span class="enscript-keyword">if</span> (ret != WQ_ITERATE_DROPPED)
			wq_prepost_put(wqp);
		<span class="enscript-keyword">return</span> ret;
	}

	assert(wqp-&gt;wqp_prepostid.id == prepost_id);
	assert(wqp_type(wqp) == WQP_POST);

	<span class="enscript-comment">/* at this point we know we have a list of POST objects */</span>
	uint64_t next_id;

	ret = WQ_ITERATE_CONTINUE;
	<span class="enscript-keyword">do</span> {
		<span class="enscript-type">struct</span> wq_prepost *tmp_wqp;
		<span class="enscript-type">struct</span> waitq *wq = NULL;

		next_id = wqp-&gt;wqp_post.wqp_next_id;

		<span class="enscript-comment">/* grab the WQP_WQ object this _POST points to */</span>
		tmp_wqp = wq_prepost_get(wqp-&gt;wqp_post.wqp_wq_id);
		<span class="enscript-keyword">if</span> (tmp_wqp) {
			assert(wqp_type(tmp_wqp) == WQP_WQ);
			wq = tmp_wqp-&gt;wqp_wq.wqp_wq_ptr;
		}

		<span class="enscript-keyword">if</span> (cb)
			ret = cb(NULL, ctx, wqp, wq);
		<span class="enscript-keyword">if</span> (tmp_wqp)
			wq_prepost_put(tmp_wqp);

		<span class="enscript-keyword">if</span> (ret != WQ_ITERATE_CONTINUE)
			<span class="enscript-keyword">break</span>;

		tmp_wqp = wq_prepost_get(next_id);
		<span class="enscript-keyword">if</span> (!tmp_wqp) {
			<span class="enscript-comment">/*
			 * the chain is broken: nothing we can do here besides
			 * bail from the iteration.
			 */</span>
			ret = WQ_ITERATE_ABORTED;
			<span class="enscript-keyword">break</span>;
		}

		wq_prepost_put(wqp);
		wqp = tmp_wqp;

		assert(wqp_type(wqp) == WQP_POST);
	} <span class="enscript-keyword">while</span> (next_id != prepost_id);

	<span class="enscript-keyword">if</span> (ret != WQ_ITERATE_DROPPED)
		wq_prepost_put(wqp);

	<span class="enscript-keyword">if</span> (ret == WQ_ITERATE_CONTINUE)
		ret = WQ_ITERATE_SUCCESS;
	<span class="enscript-keyword">return</span> ret;
}


<span class="enscript-type">struct</span> _is_posted_ctx {
	<span class="enscript-type">struct</span> waitq *posting_wq;
	<span class="enscript-type">int</span> did_prepost;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wq_is_preposted_on_set_cb</span>(<span class="enscript-type">struct</span> waitq_set *wqset, <span class="enscript-type">void</span> *ctx,
				     <span class="enscript-type">struct</span> wq_prepost *wqp, <span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-type">struct</span> _is_posted_ctx *pctx = (<span class="enscript-type">struct</span> _is_posted_ctx *)ctx;

	(<span class="enscript-type">void</span>)wqset;
	(<span class="enscript-type">void</span>)wqp;

	<span class="enscript-comment">/*
	 * Don't early-out, run through the _entire_ list:
	 * This ensures that we retain a minimum number of invalid elements.
	 */</span>
	<span class="enscript-keyword">if</span> (pctx-&gt;posting_wq == waitq)
		pctx-&gt;did_prepost = 1;

	<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;
}


<span class="enscript-comment">/**
 * checks if 'waitq' has already preposted on 'wqset'
 *
 * Parameters:
 *	waitq    The waitq that's preposting
 *	wqset    The set onto which waitq may be preposted
 *
 * Conditions:
 *	both waitq and wqset are locked
 *
 * Returns non-zero if 'waitq' has already preposted to 'wqset'
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wq_is_preposted_on_set</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">struct</span> waitq_set *wqset)
{
	<span class="enscript-type">int</span> ret;
	<span class="enscript-type">struct</span> _is_posted_ctx pctx;

	<span class="enscript-comment">/*
	 * If the set's only prepost matches the waitq's prepost ID,
	 * then it obviously already preposted to the set.
	 */</span>
	<span class="enscript-keyword">if</span> (waitq-&gt;waitq_prepost_id != 0 &amp;&amp;
	    wqset-&gt;wqset_prepost_id == waitq-&gt;waitq_prepost_id)
		<span class="enscript-keyword">return</span> 1;

	<span class="enscript-comment">/* use full prepost iteration: always trim the list */</span>
	pctx.posting_wq = waitq;
	pctx.did_prepost = 0;
	ret = wq_prepost_foreach_locked(wqset, (<span class="enscript-type">void</span> *)&amp;pctx,
					wq_is_preposted_on_set_cb);
	<span class="enscript-keyword">return</span> pctx.did_prepost;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> wq_prepost *<span class="enscript-function-name">wq_get_prepost_obj</span>(uint64_t *reserved, <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> wq_prepost *wqp = NULL;
	<span class="enscript-comment">/*
	 * don't fail just because the caller doesn't have enough
	 * reservations, we've kept a low-water mark on the prepost table,
	 * so there should be some available for us.
	 */</span>
	<span class="enscript-keyword">if</span> (reserved &amp;&amp; *reserved) {
		wqp = wq_prepost_rpop(reserved, type);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * TODO: if in interrupt context, grab from a special
		 *       region / reserved list!
		 */</span>
		wqp = wq_prepost_alloc(type, 1);
	}

	<span class="enscript-keyword">if</span> (wqp == NULL)
		panic(<span class="enscript-string">&quot;Couldn't allocate prepost object!&quot;</span>);
	<span class="enscript-keyword">return</span> wqp;
}


<span class="enscript-comment">/**
 * prepost a waitq onto a waitq set
 *
 * Parameters:
 *	wqset    The set onto which waitq will be preposted
 *	waitq    The waitq that's preposting
 *	reserved List (wqt_elem_list_ style) of pre-allocated prepost elements
 *	         Could be NULL
 *
 * Conditions:
 *	both wqset and waitq are locked
 *
 * Notes:
 *	If reserved is NULL, this may block on prepost table growth.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_prepost_do_post_locked</span>(<span class="enscript-type">struct</span> waitq_set *wqset,
				      <span class="enscript-type">struct</span> waitq *waitq,
				      uint64_t *reserved)
{
	<span class="enscript-type">struct</span> wq_prepost *wqp_post, *wqp_head, *wqp_tail;

	assert(waitq_held(waitq) &amp;&amp; waitq_held(&amp;wqset-&gt;wqset_q));

	<span class="enscript-comment">/*
	 * nothing to do if it's already preposted:
	 * note that this also culls any invalid prepost objects
	 */</span>
	<span class="enscript-keyword">if</span> (wq_is_preposted_on_set(waitq, wqset))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * This function is called because an event is being posted to 'waitq'.
	 * We need a prepost object associated with this queue. Allocate one
	 * now if the waitq isn't already associated with one.
	 */</span>
	<span class="enscript-keyword">if</span> (waitq-&gt;waitq_prepost_id == 0) {
		<span class="enscript-type">struct</span> wq_prepost *wqp;
		wqp = wq_get_prepost_obj(reserved, WQP_WQ);
		wqp-&gt;wqp_wq.wqp_wq_ptr = waitq;
		wqp_set_valid(wqp);
		waitq-&gt;waitq_prepost_id = wqp-&gt;wqp_prepostid.id;
		wq_prepost_put(wqp);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
	g_prepost_table.npreposts += 1;
#<span class="enscript-reference">endif</span>

	wqdbg_v(<span class="enscript-string">&quot;preposting waitq %p (0x%llx) to set 0x%llx&quot;</span>,
		(<span class="enscript-type">void</span> *)VM_KERNEL_UNSLIDE_OR_PERM(waitq),
		waitq-&gt;waitq_prepost_id, wqset-&gt;wqset_id);

	<span class="enscript-keyword">if</span> (wqset-&gt;wqset_prepost_id == 0) {
		<span class="enscript-comment">/* the set has no previous preposts */</span>
		wqset-&gt;wqset_prepost_id = waitq-&gt;waitq_prepost_id;
		<span class="enscript-keyword">return</span>;
	}

	wqp_head = wq_prepost_get(wqset-&gt;wqset_prepost_id);
	<span class="enscript-keyword">if</span> (!wqp_head) {
		<span class="enscript-comment">/* the previous prepost has become invalid */</span>
		wqset-&gt;wqset_prepost_id = waitq-&gt;waitq_prepost_id;
		<span class="enscript-keyword">return</span>;
	}

	assert(wqp_head-&gt;wqp_prepostid.id == wqset-&gt;wqset_prepost_id);

	<span class="enscript-comment">/*
	 * If we get here, we're going to need at least one new wq_prepost
	 * object. If the previous wqset_prepost_id points to a WQP_WQ, we
	 * actually need to allocate 2 wq_prepost objects because the WQP_WQ
	 * is tied to the waitq and shared across all sets.
	 */</span>
	wqp_post = wq_get_prepost_obj(reserved, WQP_POST);

	wqp_post-&gt;wqp_post.wqp_wq_id = waitq-&gt;waitq_prepost_id;
	wqdbg_v(<span class="enscript-string">&quot;POST 0x%llx :: WQ 0x%llx&quot;</span>, wqp_post-&gt;wqp_prepostid.id,
		waitq-&gt;waitq_prepost_id);

	<span class="enscript-keyword">if</span> (wqp_type(wqp_head) == WQP_WQ) {
		<span class="enscript-comment">/*
		 * We must replace the wqset_prepost_id with a pointer
		 * to two new WQP_POST objects
		 */</span>
		uint64_t wqp_id = wqp_head-&gt;wqp_prepostid.id;
		wqdbg_v(<span class="enscript-string">&quot;set 0x%llx previous had 1 WQ prepost (0x%llx): &quot;</span>
			<span class="enscript-string">&quot;replacing with two POST preposts&quot;</span>,
			wqset-&gt;wqset_id, wqp_id);

		<span class="enscript-comment">/* drop the old reference */</span>
		wq_prepost_put(wqp_head);

		<span class="enscript-comment">/* grab another new object (the 2nd of two) */</span>
		wqp_head = wq_get_prepost_obj(reserved, WQP_POST);

		<span class="enscript-comment">/* point this one to the original WQP_WQ object */</span>
		wqp_head-&gt;wqp_post.wqp_wq_id = wqp_id;
		wqdbg_v(<span class="enscript-string">&quot;POST 0x%llx :: WQ 0x%llx&quot;</span>,
			wqp_head-&gt;wqp_prepostid.id, wqp_id);
	
		<span class="enscript-comment">/* link it to the new wqp_post object allocated earlier */</span>
		wqp_head-&gt;wqp_post.wqp_next_id = wqp_post-&gt;wqp_prepostid.id;
		<span class="enscript-comment">/* make the list a double-linked and circular */</span>
		wq_prepost_rlink(wqp_head, wqp_post);

		<span class="enscript-comment">/*
		 * Finish setting up the new prepost: point it back to the
		 * POST object we allocated to replace the original wqset
		 * WQ prepost object
		 */</span>
		wqp_post-&gt;wqp_post.wqp_next_id = wqp_head-&gt;wqp_prepostid.id;
		wq_prepost_rlink(wqp_post, wqp_head);

		<span class="enscript-comment">/* mark objects valid, and reset the wqset prepost list head */</span>
		wqp_set_valid(wqp_head);
		wqp_set_valid(wqp_post);
		wqset-&gt;wqset_prepost_id = wqp_head-&gt;wqp_prepostid.id;

		<span class="enscript-comment">/* release both references */</span>
		wq_prepost_put(wqp_head);
		wq_prepost_put(wqp_post);

		wqdbg_v(<span class="enscript-string">&quot;set 0x%llx: 0x%llx/0x%llx -&gt; 0x%llx/0x%llx -&gt; 0x%llx&quot;</span>,
			wqset-&gt;wqset_id, wqset-&gt;wqset_prepost_id,
			wqp_head-&gt;wqp_prepostid.id, wqp_head-&gt;wqp_post.wqp_next_id,
			wqp_post-&gt;wqp_prepostid.id,
			wqp_post-&gt;wqp_post.wqp_next_id);
		<span class="enscript-keyword">return</span>;
	}

	assert(wqp_type(wqp_head) == WQP_POST);

	<span class="enscript-comment">/*
	 * Add the new prepost to the end of the prepost list
	 */</span>
	wqp_tail = wq_prepost_get_rnext(wqp_head);
	assert(wqp_tail != NULL);
	assert(wqp_tail-&gt;wqp_post.wqp_next_id == wqset-&gt;wqset_prepost_id);

	<span class="enscript-comment">/*
	 * link the head to the new tail
	 * NOTE: this needs to happen first in case wqp_tail == wqp_head
	 */</span>
	wq_prepost_reset_rnext(wqp_head);
	wq_prepost_rlink(wqp_head, wqp_post);

	<span class="enscript-comment">/* point the new object to the list head, and list tail */</span>
	wqp_post-&gt;wqp_post.wqp_next_id = wqp_head-&gt;wqp_prepostid.id;
	wq_prepost_rlink(wqp_post, wqp_tail);

	<span class="enscript-comment">/* point the last item in the waitq set's list to the new object */</span>
	wqp_tail-&gt;wqp_post.wqp_next_id = wqp_post-&gt;wqp_prepostid.id;

	wqp_set_valid(wqp_post);

	wq_prepost_put(wqp_head);
	wq_prepost_put(wqp_tail);
	wq_prepost_put(wqp_post);

	wqdbg_v(<span class="enscript-string">&quot;set 0x%llx (wqp:0x%llx) last_prepost:0x%llx, &quot;</span>
		<span class="enscript-string">&quot;new_prepost:0x%llx-&gt;0x%llx&quot;</span>, wqset-&gt;wqset_id,
		wqset-&gt;wqset_prepost_id, wqp_head-&gt;wqp_prepostid.id,
		wqp_post-&gt;wqp_prepostid.id, wqp_post-&gt;wqp_post.wqp_next_id);

	<span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/* ----------------------------------------------------------------------
 *
 * Stats collection / reporting
 *
 * ---------------------------------------------------------------------- */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">wq_table_stats</span>(<span class="enscript-type">struct</span> wq_table *table, <span class="enscript-type">struct</span> wq_table_stats *stats)
{
	stats-&gt;version = WAITQ_STATS_VERSION;
	stats-&gt;table_elements = table-&gt;nelem;
	stats-&gt;table_used_elems = table-&gt;used_elem;
	stats-&gt;table_elem_sz = table-&gt;elem_sz;
	stats-&gt;table_slabs = table-&gt;nslabs;
	stats-&gt;table_slab_sz = table-&gt;slab_sz;

	stats-&gt;table_num_allocs = table-&gt;nallocs;
	stats-&gt;table_num_preposts = table-&gt;npreposts;
	stats-&gt;table_num_reservations = table-&gt;nreservations;

	stats-&gt;table_max_used = table-&gt;max_used;
	stats-&gt;table_avg_used = table-&gt;avg_used;
	stats-&gt;table_max_reservations = table-&gt;max_reservations;
	stats-&gt;table_avg_reservations = table-&gt;avg_reservations;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_link_stats</span>(<span class="enscript-type">struct</span> wq_table_stats *stats)
{
	<span class="enscript-keyword">if</span> (!stats)
		<span class="enscript-keyword">return</span>;
	wq_table_stats(&amp;g_linktable, stats);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_prepost_stats</span>(<span class="enscript-type">struct</span> wq_table_stats *stats)
{
	wq_table_stats(&amp;g_prepost_table, stats);
}
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* ----------------------------------------------------------------------
 *
 * Global Wait Queues
 *
 * ---------------------------------------------------------------------- */</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> waitq g_boot_waitq;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> waitq *global_waitqs = &amp;g_boot_waitq;
<span class="enscript-type">static</span> uint32_t g_num_waitqs = 1;

<span class="enscript-comment">/*
 * Zero out the used MSBs of the event.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">_CAST_TO_EVENT_MASK</span>(event)   ((uintptr_t)(event) &amp; ((1ul &lt;&lt; _EVENT_MASK_BITS) - 1ul))

<span class="enscript-comment">/*
 * The Jenkins &quot;one at a time&quot; hash.
 * TBD: There may be some value to unrolling here,
 * depending on the architecture.
 */</span>
<span class="enscript-type">static</span> __inline__ uint32_t <span class="enscript-function-name">waitq_hash</span>(<span class="enscript-type">char</span> *key, size_t length)
{
	uint32_t hash = 0;
	size_t i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; length; i++) {
		hash += key[i];
		hash += (hash &lt;&lt; 10);
		hash ^= (hash &gt;&gt; 6);
	}

	hash += (hash &lt;&lt; 3);
	hash ^= (hash &gt;&gt; 11);
	hash += (hash &lt;&lt; 15);

	hash &amp;= (g_num_waitqs - 1);
	<span class="enscript-keyword">return</span> hash;
}

<span class="enscript-comment">/* return a global waitq pointer corresponding to the given event */</span>
<span class="enscript-type">struct</span> waitq *<span class="enscript-function-name">_global_eventq</span>(<span class="enscript-type">char</span> *event, size_t event_length)
{
	<span class="enscript-keyword">return</span> &amp;global_waitqs[waitq_hash(event, event_length)];
}

<span class="enscript-comment">/* return an indexed global waitq pointer */</span>
<span class="enscript-type">struct</span> waitq *<span class="enscript-function-name">global_waitq</span>(<span class="enscript-type">int</span> index)
{
	<span class="enscript-keyword">return</span> &amp;global_waitqs[index % g_num_waitqs];
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
<span class="enscript-comment">/* this global is for lldb */</span>
<span class="enscript-type">const</span> uint32_t g_nwaitq_btframes = NWAITQ_BTFRAMES;
<span class="enscript-type">struct</span> wq_stats g_boot_stats;
<span class="enscript-type">struct</span> wq_stats *g_waitq_stats = &amp;g_boot_stats;

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">waitq_grab_backtrace</span>(uintptr_t bt[NWAITQ_BTFRAMES], <span class="enscript-type">int</span> skip)
{
	uintptr_t buf[NWAITQ_BTFRAMES + skip];
	<span class="enscript-keyword">if</span> (skip &lt; 0)
		skip = 0;
	memset(buf, 0, (NWAITQ_BTFRAMES + skip) * <span class="enscript-keyword">sizeof</span>(uintptr_t));
	fastbacktrace(buf, g_nwaitq_btframes + skip);
	memcpy(&amp;bt[0], &amp;buf[skip], NWAITQ_BTFRAMES * <span class="enscript-keyword">sizeof</span>(uintptr_t));
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">struct</span> wq_stats *<span class="enscript-function-name">waitq_global_stats</span>(<span class="enscript-type">struct</span> waitq *waitq) {
	<span class="enscript-type">struct</span> wq_stats *wqs;
	uint32_t idx;

	<span class="enscript-keyword">if</span> (!waitq_is_global(waitq))
		<span class="enscript-keyword">return</span> NULL;

	idx = (uint32_t)(((uintptr_t)waitq - (uintptr_t)global_waitqs) / <span class="enscript-keyword">sizeof</span>(*waitq));
	assert(idx &lt; g_num_waitqs);
	wqs = &amp;g_waitq_stats[idx];
	<span class="enscript-keyword">return</span> wqs;
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">waitq_stats_count_wait</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-type">struct</span> wq_stats *wqs = waitq_global_stats(waitq);
	<span class="enscript-keyword">if</span> (wqs != NULL) {
		wqs-&gt;waits++;
		waitq_grab_backtrace(wqs-&gt;last_wait, 2);
	}
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">waitq_stats_count_wakeup</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-type">struct</span> wq_stats *wqs = waitq_global_stats(waitq);
	<span class="enscript-keyword">if</span> (wqs != NULL) {
		wqs-&gt;wakeups++;
		waitq_grab_backtrace(wqs-&gt;last_wakeup, 2);
	}
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">waitq_stats_count_clear_wakeup</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-type">struct</span> wq_stats *wqs = waitq_global_stats(waitq);
	<span class="enscript-keyword">if</span> (wqs != NULL) {
		wqs-&gt;wakeups++;
		wqs-&gt;clears++;
		waitq_grab_backtrace(wqs-&gt;last_wakeup, 2);
	}
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">waitq_stats_count_fail</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-type">struct</span> wq_stats *wqs = waitq_global_stats(waitq);
	<span class="enscript-keyword">if</span> (wqs != NULL) {
		wqs-&gt;failed_wakeups++;
		waitq_grab_backtrace(wqs-&gt;last_failed_wakeup, 2);
	}
}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">waitq_stats_count_wait</span>(q)         do { } while (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">waitq_stats_count_wakeup</span>(q)       do { } while (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">waitq_stats_count_clear_wakeup</span>(q) do { } while (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">waitq_stats_count_fail</span>(q)         do { } while (0)
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">waitq_is_valid</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-keyword">return</span> (waitq != NULL) &amp;&amp; ((waitq-&gt;waitq_type &amp; ~1) == WQT_QUEUE);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">waitq_set_is_valid</span>(<span class="enscript-type">struct</span> waitq_set *wqset)
{
	<span class="enscript-keyword">return</span> (wqset != NULL) &amp;&amp; waitqs_is_set(wqset);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">waitq_is_global</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-keyword">if</span> (waitq &gt;= global_waitqs &amp;&amp; waitq &lt; global_waitqs + g_num_waitqs)
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">waitq_irq_safe</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-comment">/* global wait queues have this bit set on initialization */</span>
	<span class="enscript-keyword">return</span> waitq-&gt;waitq_irq;
}

<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">waitq_hash_size</span>(<span class="enscript-type">void</span>)
{
	uint32_t hsize, queues;
	
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;wqsize&quot;</span>, &amp;hsize, <span class="enscript-keyword">sizeof</span>(hsize)))
		<span class="enscript-keyword">return</span> (hsize);

	queues = thread_max / 11;
	hsize = P2ROUNDUP(queues * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> waitq), PAGE_SIZE);

	<span class="enscript-keyword">return</span> hsize;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_bootstrap</span>(<span class="enscript-type">void</span>)
{
	kern_return_t kret;
	uint32_t whsize, qsz;

	wq_table_bootstrap();
	lt_init();
	wqp_init();

	<span class="enscript-comment">/*
	 * Determine the amount of memory we're willing to reserve for
	 * the waitqueue hash table
	 */</span>
	whsize = waitq_hash_size();

	<span class="enscript-comment">/* Determine the number of waitqueues we can fit. */</span>
	qsz = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> waitq);
	whsize = ROUNDDOWN(whsize, qsz);
	g_num_waitqs = whsize / qsz;

	<span class="enscript-comment">/*
	 * The hash algorithm requires that this be a power of 2, so we
	 * just mask off all the low-order bits.
	 */</span>
	<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; 31; i++) {
		uint32_t bit = (1 &lt;&lt; i);
		<span class="enscript-keyword">if</span> ((g_num_waitqs &amp; bit) == g_num_waitqs)
			<span class="enscript-keyword">break</span>;
		g_num_waitqs &amp;= ~bit;
	}
	assert(g_num_waitqs &gt; 0);

	<span class="enscript-comment">/* Now determine how much memory we really need. */</span>
	whsize = P2ROUNDUP(g_num_waitqs * qsz, PAGE_SIZE);

	wqdbg(<span class="enscript-string">&quot;allocating %d global queues  (%d bytes)&quot;</span>, g_num_waitqs, whsize);
	kret = kernel_memory_allocate(kernel_map, (vm_offset_t *)&amp;global_waitqs,
				      whsize, 0, KMA_KOBJECT|KMA_NOPAGEWAIT, VM_KERN_MEMORY_WAITQ);
	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS || global_waitqs == NULL)
		panic(<span class="enscript-string">&quot;kernel_memory_allocate() failed to alloc global_waitqs&quot;</span>
		      <span class="enscript-string">&quot;, error: %d, whsize: 0x%x&quot;</span>, kret, whsize);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
	whsize = P2ROUNDUP(g_num_waitqs * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> wq_stats), PAGE_SIZE);
	kret = kernel_memory_allocate(kernel_map, (vm_offset_t *)&amp;g_waitq_stats,
				      whsize, 0, KMA_KOBJECT|KMA_NOPAGEWAIT, VM_KERN_MEMORY_WAITQ);
	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS || global_waitqs == NULL)
		panic(<span class="enscript-string">&quot;kernel_memory_allocate() failed to alloc g_waitq_stats&quot;</span>
		      <span class="enscript-string">&quot;, error: %d, whsize: 0x%x&quot;</span>, kret, whsize);
	memset(g_waitq_stats, 0, whsize);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; g_num_waitqs; i++) {
		waitq_init(&amp;global_waitqs[i], SYNC_POLICY_FIFO|SYNC_POLICY_DISABLE_IRQ);
	}


	waitq_set_zone = zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> waitq_set),
			       WAITQ_SET_MAX * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> waitq_set),
			       <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> waitq_set),
			       <span class="enscript-string">&quot;waitq sets&quot;</span>);
	zone_change(waitq_set_zone, Z_NOENCRYPT, TRUE);
}


<span class="enscript-comment">/* ----------------------------------------------------------------------
 *
 * Wait Queue Implementation
 *
 * ---------------------------------------------------------------------- */</span>

<span class="enscript-comment">/*
 * Double the standard lock timeout, because wait queues tend
 * to iterate over a number of threads - locking each.  If there is
 * a problem with a thread lock, it normally times out at the wait
 * queue level first, hiding the real problem.
 */</span>
<span class="enscript-comment">/* For x86, the hardware timeout is in TSC units. */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">hwLockTimeOut</span> LockTimeOutTSC
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">hwLockTimeOut</span> LockTimeOut
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_lock</span>(<span class="enscript-type">struct</span> waitq *wq)
{
	<span class="enscript-keyword">if</span> (__improbable(hw_lock_to(&amp;(wq)-&gt;waitq_interlock,
				    hwLockTimeOut * 2) == 0)) {
		boolean_t wql_acquired = FALSE;

		<span class="enscript-keyword">while</span> (machine_timeout_suspended()) {
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
			<span class="enscript-comment">/*
			 * i386/x86_64 return with preemption disabled on a
			 * timeout for diagnostic purposes.
			 */</span>
			mp_enable_preemption();
#<span class="enscript-reference">endif</span>
			wql_acquired = hw_lock_to(&amp;(wq)-&gt;waitq_interlock,
						  hwLockTimeOut * 2);
			<span class="enscript-keyword">if</span> (wql_acquired)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (wql_acquired == FALSE)
			panic(<span class="enscript-string">&quot;waitq deadlock - waitq=%p, cpu=%d\n&quot;</span>,
			      wq, cpu_number());
	}
	assert(waitq_held(wq));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_unlock</span>(<span class="enscript-type">struct</span> waitq *wq)
{
	assert(waitq_held(wq));
	hw_lock_unlock(&amp;(wq)-&gt;waitq_interlock);
}


<span class="enscript-comment">/**
 * clear the thread-related waitq state
 *
 * Conditions:
 *	'thread' is locked
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">thread_clear_waitq_state</span>(thread_t thread)
{
	thread-&gt;waitq = NULL;
	thread-&gt;wait_event = NO_EVENT64;
	thread-&gt;at_safe_point = FALSE;
}


<span class="enscript-type">typedef</span> <span class="enscript-function-name">thread_t</span> (*waitq_select_cb)(<span class="enscript-type">void</span> *ctx, <span class="enscript-type">struct</span> waitq *waitq,
				    <span class="enscript-type">int</span> is_global, thread_t thread);

<span class="enscript-type">struct</span> waitq_select_args {
	<span class="enscript-comment">/* input parameters */</span>
	<span class="enscript-type">struct</span> waitq    *posted_waitq;
	<span class="enscript-type">struct</span> waitq    *waitq;
	event64_t        event;
	waitq_select_cb  select_cb;
	<span class="enscript-type">void</span>            *select_ctx;

	uint64_t        *reserved_preposts;

	<span class="enscript-comment">/* output parameters */</span>
	queue_t       threadq;
	<span class="enscript-type">int</span>           max_threads;
	<span class="enscript-type">int</span>          *nthreads;
	spl_t        *spl;
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">do_waitq_select_n_locked</span>(<span class="enscript-type">struct</span> waitq_select_args *args);

<span class="enscript-comment">/**
 * callback invoked once for every waitq set to which a waitq belongs
 *
 * Conditions:
 *	ctx-&gt;posted_waitq is locked
 *	'link' points to a valid waitq set
 *
 * Notes:
 *	Takes the waitq set lock on the set pointed to by 'link'
 *	Calls do_waitq_select_n_locked() which could recurse back into
 *	this function if the waitq set is a member of other sets.
 *	If no threads were selected, it preposts the input waitq
 *	onto the waitq set pointed to by 'link'.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_select_walk_cb</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">void</span> *ctx,
				<span class="enscript-type">struct</span> setid_link *link)
{
	<span class="enscript-type">int</span> ret = WQ_ITERATE_CONTINUE;
	<span class="enscript-type">struct</span> waitq_select_args args = *((<span class="enscript-type">struct</span> waitq_select_args *)ctx);
	<span class="enscript-type">struct</span> waitq_set *wqset;
	<span class="enscript-type">int</span> get_spl = 0;
	spl_t set_spl;

	(<span class="enscript-type">void</span>)waitq;
	assert(sl_type(link) == SLT_WQS);

	wqset = link-&gt;sl_wqs.sl_set;
	args.waitq = &amp;wqset-&gt;wqset_q;

	<span class="enscript-keyword">if</span> (!waitq_irq_safe(waitq) &amp;&amp; waitq_irq_safe(&amp;wqset-&gt;wqset_q)) {
		get_spl = 1;
		set_spl = splsched();
	}
	waitq_set_lock(wqset);
	<span class="enscript-comment">/*
	 * verify that the link wasn't invalidated just before
	 * we were able to take the lock.
	 */</span>
	<span class="enscript-keyword">if</span> (wqset-&gt;wqset_id != link-&gt;sl_set_id.id)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;

	<span class="enscript-comment">/*
	 * Find any threads waiting on this wait queue set,
	 * and recurse into any waitq set to which this set belongs.
	 */</span>
	do_waitq_select_n_locked(&amp;args);

	<span class="enscript-keyword">if</span> (*(args.nthreads) &gt; 0 ||
	    (args.threadq &amp;&amp; !queue_empty(args.threadq))) {
		<span class="enscript-comment">/* at least 1 thread was selected and returned: don't prepost */</span>
		<span class="enscript-keyword">if</span> (args.max_threads &gt; 0 &amp;&amp;
		    *(args.nthreads) &gt;= args.max_threads) {
			<span class="enscript-comment">/* break out of the setid walk */</span>
			ret = WQ_ITERATE_FOUND;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * No thread selected: prepost 'waitq' to 'wqset'
		 * if wqset can handle preposts and the event is set to 0.
		 * We also make sure to not post waitq sets to other sets.
		 *
		 * In the future, we may consider an optimization to prepost
		 * 'args.posted_waitq' directly to 'wqset' to avoid
		 * unnecessary data structure manipulations in the kqueue path
		 */</span>
		<span class="enscript-keyword">if</span> (args.event == NO_EVENT64 &amp;&amp; waitq_set_can_prepost(wqset)) {
			wq_prepost_do_post_locked(wqset, waitq,
						  args.reserved_preposts);
		}
	}

<span class="enscript-reference">out_unlock</span>:
	waitq_set_unlock(wqset);
	<span class="enscript-keyword">if</span> (get_spl)
		splx(set_spl);
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/**
 * generic thread selection from a waitq (and sets to which the waitq belongs)
 *
 * Conditions:
 *	args-&gt;waitq (and args-&gt;posted_waitq) is locked
 *
 * Notes:
 *	Uses the optional select callback function to refine the selection
 *	of one or more threads from a waitq and any set to which the waitq
 *	belongs. The select callback is invoked once for every thread that
 *	is found to be waiting on the input args-&gt;waitq.
 *
 *	If one or more threads are selected, this may disable interrupts.
 *	The previous interrupt state is returned in args-&gt;spl and should
 *	be used in a call to splx() if threads are returned to the caller.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">do_waitq_select_n_locked</span>(<span class="enscript-type">struct</span> waitq_select_args *args)
{
	<span class="enscript-type">struct</span> waitq *waitq = args-&gt;waitq;
	<span class="enscript-type">int</span> max_threads = args-&gt;max_threads;
	thread_t thread = THREAD_NULL, first_thread = THREAD_NULL;
	<span class="enscript-type">int</span> global_q = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> eventmask = 0;
	<span class="enscript-type">int</span> *nthreads = args-&gt;nthreads;

	assert(max_threads != 0);

	global_q = waitq_is_global(waitq);
	<span class="enscript-keyword">if</span> (global_q) {
		eventmask = _CAST_TO_EVENT_MASK(args-&gt;event);
		<span class="enscript-comment">/* make sure this waitq accepts this event mask */</span>
		<span class="enscript-keyword">if</span> ((waitq-&gt;waitq_eventmask &amp; eventmask) != eventmask)
			<span class="enscript-keyword">return</span>;
		eventmask = 0;
	}

	<span class="enscript-comment">/* look through each thread waiting directly on the waitq */</span>
	qe_foreach_element_safe(thread, &amp;waitq-&gt;waitq_queue, links) {
		thread_t t = THREAD_NULL;
		assert(thread-&gt;waitq == waitq);
		<span class="enscript-keyword">if</span> (thread-&gt;wait_event == args-&gt;event) {
			t = thread;
			<span class="enscript-keyword">if</span> (first_thread == THREAD_NULL)
				first_thread = thread;

			<span class="enscript-comment">/* allow the caller to futher refine the selection */</span>
			<span class="enscript-keyword">if</span> (args-&gt;select_cb)
				t = args-&gt;select_cb(args-&gt;select_ctx, waitq,
						    global_q, thread);
			<span class="enscript-keyword">if</span> (t != THREAD_NULL) {
				*nthreads += 1;
				<span class="enscript-keyword">if</span> (args-&gt;threadq) {
					<span class="enscript-keyword">if</span> (*nthreads == 1)
						*(args-&gt;spl) = splsched();
					thread_lock(t);
					thread_clear_waitq_state(t);
					<span class="enscript-comment">/* put locked thread on output queue */</span>
					re_queue_tail(args-&gt;threadq, &amp;t-&gt;links);
				}
				<span class="enscript-comment">/* only enqueue up to 'max' threads */</span>
				<span class="enscript-keyword">if</span> (*nthreads &gt;= max_threads &amp;&amp; max_threads &gt; 0)
					<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-comment">/* thread wasn't selected, and the waitq is global */</span>
		<span class="enscript-keyword">if</span> (t == THREAD_NULL &amp;&amp; global_q)
			eventmask |= _CAST_TO_EVENT_MASK(thread-&gt;wait_event);
	}

	<span class="enscript-comment">/*
	 * Update the eventmask of global queues:
	 * - If we selected all the threads in the queue, or we selected zero
	 *   threads on the queue, set the eventmask to the calculated value
	 *   (potentially 0 if we selected them all)
	 * - If we just pulled out a subset of threads from the queue, then we
	 *   can't assume the calculated mask is complete (because we may not
	 *   have made it through all the threads in the queue), so we have to
	 *   leave it alone.
	 */</span>
	<span class="enscript-keyword">if</span> (global_q &amp;&amp; (queue_empty(&amp;waitq-&gt;waitq_queue) || *nthreads == 0))
		waitq-&gt;waitq_eventmask = (typeof(waitq-&gt;waitq_eventmask))eventmask;

	<span class="enscript-comment">/*
	 * Grab the first thread in the queue if no other thread was selected.
	 * We can guarantee that no one has manipulated this thread because
	 * it's waiting on the given waitq, and we have that waitq locked.
	 */</span>
	<span class="enscript-keyword">if</span> (*nthreads == 0 &amp;&amp; first_thread != THREAD_NULL &amp;&amp; args-&gt;threadq) {
		<span class="enscript-comment">/* we know this is the first (and only) thread */</span>
		++(*nthreads);
		*(args-&gt;spl) = splsched();
		thread_lock(first_thread);
		thread_clear_waitq_state(first_thread);
		re_queue_tail(args-&gt;threadq, &amp;first_thread-&gt;links);

		<span class="enscript-comment">/* update the eventmask on global queues */</span>
		<span class="enscript-keyword">if</span> (global_q &amp;&amp; queue_empty(&amp;waitq-&gt;waitq_queue))
			waitq-&gt;waitq_eventmask = 0;
	}

	<span class="enscript-keyword">if</span> (max_threads &gt; 0 &amp;&amp; *nthreads &gt;= max_threads)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * wait queues that are not in any sets
	 * are the bottom of the recursion
	 */</span>
	<span class="enscript-keyword">if</span> (!waitq-&gt;waitq_set_id)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* check to see if the set ID for this wait queue is valid */</span>
	<span class="enscript-type">struct</span> setid_link *link = lt_get_link(waitq-&gt;waitq_set_id);
	<span class="enscript-keyword">if</span> (!link) {
		<span class="enscript-comment">/* the waitq set to which this waitq belonged, has been invalidated */</span>
		waitq-&gt;waitq_set_id = 0;
		<span class="enscript-keyword">return</span>;
	}

	lt_put_link(link);

	<span class="enscript-comment">/*
	 * If this waitq is a member of any wait queue sets, we need to look
	 * for waiting thread(s) in any of those sets, and prepost all sets that
	 * don't have active waiters.
	 *
	 * Note that we do a local walk of this waitq's links - we manually
	 * recurse down wait queue set's with non-zero wqset_q.waitq_set_id
	 */</span>
	(<span class="enscript-type">void</span>)walk_setid_links(LINK_WALK_ONE_LEVEL, waitq, waitq-&gt;waitq_set_id,
			       SLT_WQS, (<span class="enscript-type">void</span> *)args, waitq_select_walk_cb);
}

<span class="enscript-comment">/**
 * main entry point for thread selection from a waitq
 *
 * Conditions:
 *	waitq is locked
 *
 * Returns:
 *	The number of threads waiting on 'waitq' for 'event' which have
 *	been placed onto the input 'threadq'
 *
 * Notes:
 *	The 'select_cb' function is invoked for every thread found waiting
 *	on 'waitq' for 'event'. The thread is _not_ locked upon callback
 *	invocation. This parameter may be NULL.
 *
 *	If one or more threads are returned in 'threadq' then the caller is
 *	responsible to call splx() using the returned 'spl' value. Each
 *	returned thread is locked.
 */</span>
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_select_n_locked</span>(<span class="enscript-type">struct</span> waitq *waitq,
					    event64_t event,
					    waitq_select_cb select_cb,
					    <span class="enscript-type">void</span> *select_ctx,
					    uint64_t *reserved_preposts,
					    queue_t threadq,
					    <span class="enscript-type">int</span> max_threads, spl_t *spl)
{
	<span class="enscript-type">int</span> nthreads = 0;

	<span class="enscript-type">struct</span> waitq_select_args args = {
		.posted_waitq = waitq,
		.waitq = waitq,
		.event = event,
		.select_cb = select_cb,
		.select_ctx = select_ctx,
		.reserved_preposts = reserved_preposts,
		.threadq = threadq,
		.max_threads = max_threads,
		.nthreads = &amp;nthreads,
		.spl = spl,
	};

	do_waitq_select_n_locked(&amp;args);
	<span class="enscript-keyword">return</span> nthreads;
}


<span class="enscript-comment">/**
 * callback function that uses thread parameters to determine wakeup eligibility
 *
 * Conditions:
 *	'waitq' is locked
 *	'thread' is not locked
 */</span>
<span class="enscript-type">static</span> thread_t <span class="enscript-function-name">waitq_select_one_cb</span>(<span class="enscript-type">void</span> *ctx, <span class="enscript-type">struct</span> waitq *waitq,
				    <span class="enscript-type">int</span> is_global, thread_t thread)
{
	<span class="enscript-type">int</span> fifo_q, realtime;
	boolean_t thread_imp_donor = FALSE;

	(<span class="enscript-type">void</span>)ctx;
	(<span class="enscript-type">void</span>)waitq;
	(<span class="enscript-type">void</span>)is_global;
	realtime = 0;

	fifo_q = 1; <span class="enscript-comment">/* default to FIFO for all queues for now */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-keyword">if</span> (is_global)
		fifo_q = 0; <span class="enscript-comment">/* 'thread_imp_donor' takes the place of FIFO checking */</span>
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (thread-&gt;sched_pri &gt;= BASEPRI_REALTIME)
		realtime = 1;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-comment">/* 
	 * Checking imp donor bit does not need thread lock or
	 * or task lock since we have the wait queue lock and
	 * thread can not be removed from it without acquiring
	 * wait queue lock. The imp donor bit may change
	 * once we read its value, but it is ok to wake
	 * a thread while someone drops importance assertion
	 * on the that thread.
	 */</span>
	thread_imp_donor = task_is_importance_donor(thread-&gt;task);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	<span class="enscript-keyword">if</span> (fifo_q || thread_imp_donor == TRUE
	    || realtime || (thread-&gt;options &amp; TH_OPT_VMPRIV)) {
		<span class="enscript-comment">/*
		 * If this thread's task is an importance donor,
		 * or it's a realtime thread, or it's a VM privileged
		 * thread, OR the queue is marked as FIFO:
		 *     select the thread
		 */</span>
		<span class="enscript-keyword">return</span> thread;
	}

	<span class="enscript-comment">/* by default, _don't_ select the thread */</span>
	<span class="enscript-keyword">return</span> THREAD_NULL;
}

<span class="enscript-comment">/**
 * select a single thread from a waitq that's waiting for a given event
 *
 * Conditions:
 *	'waitq' is locked
 *
 * Returns:
 *	A locked thread that's been removed from the waitq, but has not
 *	yet been put on a run queue. Caller is responsible to call splx
 *	with the '*spl' value.
 */</span>
<span class="enscript-type">static</span> thread_t <span class="enscript-function-name">waitq_select_one_locked</span>(<span class="enscript-type">struct</span> waitq *waitq, event64_t event,
					uint64_t *reserved_preposts,
					<span class="enscript-type">int</span> priority, spl_t *spl)
{
	<span class="enscript-type">int</span> nthreads;
	queue_head_t threadq;

	(<span class="enscript-type">void</span>)priority;

	queue_init(&amp;threadq);

	nthreads = waitq_select_n_locked(waitq, event, waitq_select_one_cb, NULL,
					 reserved_preposts, &amp;threadq, 1, spl);

	<span class="enscript-comment">/* if we selected a thread, return it (still locked) */</span>
	<span class="enscript-keyword">if</span> (!queue_empty(&amp;threadq)) {
		thread_t t;
		queue_entry_t qe = dequeue_head(&amp;threadq);
		t = qe_element(qe, <span class="enscript-type">struct</span> thread, links);
		assert(queue_empty(&amp;threadq)); <span class="enscript-comment">/* there should be 1 entry */</span>
		<span class="enscript-comment">/* t has been locked and removed from all queues */</span>
		<span class="enscript-keyword">return</span> t;
	}

	<span class="enscript-keyword">return</span> THREAD_NULL;
}


<span class="enscript-type">struct</span> select_thread_ctx {
	thread_t      thread;
	event64_t     event;
	spl_t        *spl;
};

<span class="enscript-comment">/**
 * link walk callback invoked once for each set to which a waitq belongs
 *
 * Conditions:
 *	initial waitq is locked
 *	ctx-&gt;thread is unlocked
 *
 * Notes:
 *	This may disable interrupts and early-out of the full DAG link walk by
 *	returning KERN_ALREADY_IN_SET. In this case, the returned thread has
 *	been removed from the waitq, it's waitq state has been reset, and the
 *	caller is responsible to call splx() with the returned interrupt state
 *	in ctx-&gt;spl.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_select_thread_cb</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">void</span> *ctx,
				  <span class="enscript-type">struct</span> setid_link *link)
{
	<span class="enscript-type">struct</span> select_thread_ctx *stctx = (<span class="enscript-type">struct</span> select_thread_ctx *)ctx;
	<span class="enscript-type">struct</span> waitq_set *wqset;

	(<span class="enscript-type">void</span>)waitq;

	thread_t thread = stctx-&gt;thread;
	event64_t event = stctx-&gt;event;

	<span class="enscript-keyword">if</span> (sl_type(link) != SLT_WQS)
		<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;

	wqset = link-&gt;sl_wqs.sl_set;

	<span class="enscript-keyword">if</span> (!waitq_irq_safe(waitq) &amp;&amp; waitq_irq_safe(&amp;wqset-&gt;wqset_q)) {
		*(stctx-&gt;spl) = splsched();
		waitq_set_lock(wqset);
		thread_lock(thread);
	} <span class="enscript-keyword">else</span> {
		waitq_set_lock(wqset);
		*(stctx-&gt;spl) = splsched();
		thread_lock(thread);
	}

	<span class="enscript-keyword">if</span> ((thread-&gt;waitq == &amp;wqset-&gt;wqset_q)
	    &amp;&amp; (thread-&gt;wait_event == event)) {
		remqueue(&amp;thread-&gt;links);
		thread_clear_waitq_state(thread);
		<span class="enscript-comment">/*
		 * thread still locked,
		 * return non-zero to break out of WQS walk
		 */</span>
		waitq_set_unlock(wqset);
		<span class="enscript-keyword">return</span> WQ_ITERATE_FOUND;
	}

	thread_unlock(thread);
	waitq_set_unlock(wqset);
	splx(*(stctx-&gt;spl));

	<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;
}

<span class="enscript-comment">/**
 * returns KERN_SUCCESS and locks 'thread' if-and-only-if 'thread' is waiting
 * on 'waitq' (or any set to which waitq belongs) for 'event'
 *
 * Conditions:
 *	'waitq' is locked
 *	'thread' is unlocked
 */</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">waitq_select_thread_locked</span>(<span class="enscript-type">struct</span> waitq *waitq,
						event64_t event,
						thread_t thread, spl_t *spl)
{
	<span class="enscript-type">struct</span> setid_link *link;
	<span class="enscript-type">struct</span> select_thread_ctx ctx;
	kern_return_t kr;

	*spl = splsched();
	thread_lock(thread);

	<span class="enscript-keyword">if</span> ((thread-&gt;waitq == waitq) &amp;&amp; (thread-&gt;wait_event == event)) {
		remqueue(&amp;thread-&gt;links);
		thread_clear_waitq_state(thread);
		<span class="enscript-comment">/* thread still locked */</span>
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	thread_unlock(thread);
	splx(*spl);

	<span class="enscript-keyword">if</span> (!waitq-&gt;waitq_set_id)
		<span class="enscript-keyword">return</span> KERN_NOT_WAITING;

	<span class="enscript-comment">/* check to see if the set ID for this wait queue is valid */</span>
	link = lt_get_link(waitq-&gt;waitq_set_id);
	<span class="enscript-keyword">if</span> (!link) {
		<span class="enscript-comment">/* the waitq to which this set belonged, has been invalidated */</span>
		waitq-&gt;waitq_set_id = 0;
		<span class="enscript-keyword">return</span> KERN_NOT_WAITING;
	}

	<span class="enscript-comment">/*
	 * The thread may be waiting on a wait queue set to which
	 * the input 'waitq' belongs. Go look for the thread in
	 * all wait queue sets. If it's there, we'll remove it
	 * because it's equivalent to waiting directly on the input waitq.
	 */</span>
	ctx.thread = thread;
	ctx.event = event;
	ctx.spl = spl;
	kr = walk_setid_links(LINK_WALK_FULL_DAG, waitq, waitq-&gt;waitq_set_id,
			      SLT_WQS, (<span class="enscript-type">void</span> *)&amp;ctx, waitq_select_thread_cb);

	lt_put_link(link);

	<span class="enscript-comment">/* we found a thread, return success */</span>
	<span class="enscript-keyword">if</span> (kr == WQ_ITERATE_FOUND)
		<span class="enscript-keyword">return</span> KERN_SUCCESS;

	<span class="enscript-keyword">return</span> KERN_NOT_WAITING;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">prepost_exists_cb</span>(<span class="enscript-type">struct</span> waitq_set __unused *wqset,
			     <span class="enscript-type">void</span> __unused *ctx,
			     <span class="enscript-type">struct</span> wq_prepost __unused *wqp,
			     <span class="enscript-type">struct</span> waitq __unused *waitq)
{
	<span class="enscript-comment">/* if we get here, then we know that there is a valid prepost object! */</span>
	<span class="enscript-keyword">return</span> WQ_ITERATE_FOUND;
}

<span class="enscript-comment">/**
 * declare a thread's intent to wait on 'waitq' for 'wait_event'
 *
 * Conditions:
 *	'waitq' is locked
 *	'thread' is locked
 */</span>
wait_result_t <span class="enscript-function-name">waitq_assert_wait64_locked</span>(<span class="enscript-type">struct</span> waitq *waitq,
					  event64_t wait_event,
					  wait_interrupt_t interruptible,
					  wait_timeout_urgency_t urgency,
					  uint64_t deadline,
					  uint64_t leeway,
					  thread_t thread)
{
	wait_result_t wait_result;
	<span class="enscript-type">int</span> realtime = 0;

	<span class="enscript-comment">/*
	 * Warning: Do _not_ place debugging print statements here.
	 *          The thread is locked!
	 */</span>

	<span class="enscript-keyword">if</span> (thread-&gt;waitq != NULL)
		panic(<span class="enscript-string">&quot;thread already waiting on %p&quot;</span>, thread-&gt;waitq);

	<span class="enscript-keyword">if</span> (waitq_is_set(waitq)) {
		<span class="enscript-type">struct</span> waitq_set *wqset = (<span class="enscript-type">struct</span> waitq_set *)waitq;
		<span class="enscript-comment">/*
		 * early-out if the thread is waiting on a wait queue set
		 * that has already been pre-posted.
		 */</span>
		<span class="enscript-keyword">if</span> (wait_event == NO_EVENT64 &amp;&amp; waitq_set_maybe_preposted(wqset)) {
			<span class="enscript-type">int</span> ret;
			<span class="enscript-comment">/*
			 * Run through the list of potential preposts. Because
			 * this is a hot path, we short-circuit the iteration
			 * if we find just one prepost object.
			 */</span>
			ret = wq_prepost_foreach_locked(wqset, NULL,
							prepost_exists_cb);
			<span class="enscript-keyword">if</span> (ret == WQ_ITERATE_FOUND) {
				thread-&gt;wait_result = THREAD_AWAKENED;
				<span class="enscript-keyword">return</span> THREAD_AWAKENED;
			}
		}
	}

	<span class="enscript-comment">/*
	 * Realtime threads get priority for wait queue placements.
	 * This allows wait_queue_wakeup_one to prefer a waiting
	 * realtime thread, similar in principle to performing
	 * a wait_queue_wakeup_all and allowing scheduler prioritization
	 * to run the realtime thread, but without causing the
	 * lock contention of that scenario.
	 */</span>
	<span class="enscript-keyword">if</span> (thread-&gt;sched_pri &gt;= BASEPRI_REALTIME)
		realtime = 1;

	<span class="enscript-comment">/*
	 * This is the extent to which we currently take scheduling attributes
	 * into account.  If the thread is vm priviledged, we stick it at
	 * the front of the queue.  Later, these queues will honor the policy
	 * value set at waitq_init time.
	 */</span>
	wait_result = thread_mark_wait_locked(thread, interruptible);
	<span class="enscript-comment">/* thread-&gt;wait_result has been set */</span>
	<span class="enscript-keyword">if</span> (wait_result == THREAD_WAITING) {
		<span class="enscript-keyword">if</span> (!waitq-&gt;waitq_fifo
		    || (thread-&gt;options &amp; TH_OPT_VMPRIV) || realtime)
			enqueue_head(&amp;waitq-&gt;waitq_queue, &amp;thread-&gt;links);
		<span class="enscript-keyword">else</span>
			enqueue_tail(&amp;waitq-&gt;waitq_queue, &amp;thread-&gt;links);

		thread-&gt;wait_event = wait_event;
		thread-&gt;waitq = waitq;

		<span class="enscript-keyword">if</span> (deadline != 0) {
			boolean_t act;
			act = timer_call_enter_with_leeway(&amp;thread-&gt;wait_timer,
							   NULL,
							   deadline, leeway,
							   urgency, FALSE);
			<span class="enscript-keyword">if</span> (!act)
				thread-&gt;wait_timer_active++;
			thread-&gt;wait_timer_is_set = TRUE;
		}

		<span class="enscript-keyword">if</span> (waitq_is_global(waitq))
			waitq-&gt;waitq_eventmask = waitq-&gt;waitq_eventmask
						| _CAST_TO_EVENT_MASK(wait_event);

		waitq_stats_count_wait(waitq);
	}

	<span class="enscript-keyword">return</span> wait_result;
}

<span class="enscript-comment">/**
 * remove 'thread' from its current blocking state on 'waitq'
 *
 * Conditions:
 *	'waitq' is locked
 *	'thread' is locked
 *
 * Notes:
 *	This function is primarily used by clear_wait_internal in
 *	sched_prim.c from the thread timer wakeup path
 *	(i.e. the thread was waiting on 'waitq' with a timeout that expired)
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_pull_thread_locked</span>(<span class="enscript-type">struct</span> waitq *waitq, thread_t thread)
{
	(<span class="enscript-type">void</span>)waitq;
	assert(thread-&gt;waitq == waitq);

	remqueue(&amp;thread-&gt;links);
	thread_clear_waitq_state(thread);
	waitq_stats_count_clear_wakeup(waitq);

	<span class="enscript-comment">/* clear the global event mask if this was the last thread there! */</span>
	<span class="enscript-keyword">if</span> (waitq_is_global(waitq) &amp;&amp; queue_empty(&amp;waitq-&gt;waitq_queue))
		waitq-&gt;waitq_eventmask = 0;
}


<span class="enscript-type">static</span> __inline__
<span class="enscript-type">void</span> <span class="enscript-function-name">maybe_adjust_thread_pri</span>(thread_t thread, <span class="enscript-type">int</span> priority) {
	<span class="enscript-keyword">if</span> (thread-&gt;sched_pri &lt; priority) {
		<span class="enscript-keyword">if</span> (priority &lt;= MAXPRI) {
			set_sched_pri(thread, priority);

			thread-&gt;was_promoted_on_wakeup = 1;
			thread-&gt;sched_flags |= TH_SFLAG_PROMOTED;
		}
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * If the caller is requesting the waitq subsystem to promote the
	 * priority of the awoken thread, then boost the thread's priority to
	 * the default WAITQ_BOOST_PRIORITY (if it's not already equal or
	 * higher priority).  This boost must be removed via a call to
	 * waitq_clear_promotion_locked.
	 */</span>
	<span class="enscript-keyword">if</span> (priority == WAITQ_PROMOTE_PRIORITY &amp;&amp;
	    (thread-&gt;sched_pri &lt; WAITQ_BOOST_PRIORITY ||
	     !(thread-&gt;sched_flags &amp; TH_SFLAG_WAITQ_PROMOTED))) {

		KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED, MACH_WAITQ_PROMOTE) | DBG_FUNC_NONE,
				      (uintptr_t)thread_tid(thread),
				      thread-&gt;sched_pri, thread-&gt;base_pri,
				      WAITQ_BOOST_PRIORITY, 0);
		thread-&gt;sched_flags |= TH_SFLAG_WAITQ_PROMOTED;
		<span class="enscript-keyword">if</span> (thread-&gt;sched_pri &lt; WAITQ_BOOST_PRIORITY)
			set_sched_pri(thread, WAITQ_BOOST_PRIORITY);
	}
}

<span class="enscript-comment">/**
 * Clear a thread's waitq priority promotion state and the waitq's boost flag
 *
 * This function will always clear the waitq's 'waitq_boost' flag. If the
 * 'thread' parameter is non-null, the this function will also check the
 * priority promotion (boost) state of that thread. If this thread was boosted
 * (by having been awoken from a boosting waitq), then this boost state is
 * cleared. This function is to be paired with waitq_enable_promote_locked.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_clear_promotion_locked</span>(<span class="enscript-type">struct</span> waitq *waitq, thread_t thread)
{
	spl_t s;

	assert(waitq_held(waitq));
	<span class="enscript-keyword">if</span> (thread == THREAD_NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (!waitq_irq_safe(waitq))
		s = splsched();
	thread_lock(thread);

	<span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_WAITQ_PROMOTED) {
		thread-&gt;sched_flags &amp;= ~TH_SFLAG_WAITQ_PROMOTED;

		<span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_PROMOTED_MASK) {
			<span class="enscript-comment">/* it still has other promotions (mutex/rw_lock) */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_DEPRESSED_MASK) {
			KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED, MACH_WAITQ_DEMOTE) | DBG_FUNC_NONE,
					      (uintptr_t)thread_tid(thread),
					      thread-&gt;sched_pri,
					      thread-&gt;base_pri,
					      DEPRESSPRI, 0);
			set_sched_pri(thread, DEPRESSPRI);
		} <span class="enscript-keyword">else</span> {
			KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED, MACH_WAITQ_DEMOTE) | DBG_FUNC_NONE,
					      (uintptr_t)thread_tid(thread),
					      thread-&gt;sched_pri,
					      thread-&gt;base_pri,
					      thread-&gt;base_pri, 0);
			thread_recompute_sched_pri(thread, FALSE);
		}
	}

	thread_unlock(thread);
	<span class="enscript-keyword">if</span> (!waitq_irq_safe(waitq))
		splx(s);
}

<span class="enscript-comment">/**
 * wakeup all threads waiting on 'waitq' for 'wake_event'
 *
 * Conditions:
 *	'waitq' is locked
 *
 * Notes:
 *	May temporarily disable and re-enable interrupts
 *	and re-adjust thread priority of each awoken thread.
 *
 *	If the input 'lock_state' == WAITQ_UNLOCK then the waitq will have
 *	been unlocked before calling thread_go() on any returned threads, and
 *	is guaranteed to be unlocked upon function return.
 */</span>
kern_return_t <span class="enscript-function-name">waitq_wakeup64_all_locked</span>(<span class="enscript-type">struct</span> waitq *waitq,
					event64_t wake_event,
					wait_result_t result,
					uint64_t *reserved_preposts,
					<span class="enscript-type">int</span> priority,
					waitq_lock_state_t lock_state)
{
	kern_return_t ret;
	thread_t thread;
	spl_t th_spl;
	<span class="enscript-type">int</span> nthreads;
	queue_head_t wakeup_queue;

	assert(waitq_held(waitq));
	queue_init(&amp;wakeup_queue);

	nthreads = waitq_select_n_locked(waitq, wake_event, NULL, NULL,
					 reserved_preposts,
					 &amp;wakeup_queue, -1, &amp;th_spl);

	<span class="enscript-comment">/* set each thread running */</span>
	ret = KERN_NOT_WAITING;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
	qe_foreach_element(thread, &amp;wakeup_queue, links)
		waitq_stats_count_wakeup(waitq);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (lock_state == WAITQ_UNLOCK)
		waitq_unlock(waitq);

	qe_foreach_element_safe(thread, &amp;wakeup_queue, links) {
		remqueue(&amp;thread-&gt;links);
		maybe_adjust_thread_pri(thread, priority);
		ret = thread_go(thread, result);
		assert(ret == KERN_SUCCESS);
		thread_unlock(thread);
	}
	<span class="enscript-keyword">if</span> (nthreads &gt; 0)
		splx(th_spl);
	<span class="enscript-keyword">else</span>
		waitq_stats_count_fail(waitq);

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/**
 * wakeup one thread waiting on 'waitq' for 'wake_event'
 *
 * Conditions:
 *	'waitq' is locked
 *
 * Notes:
 *	May temporarily disable and re-enable interrupts.
 */</span>
kern_return_t <span class="enscript-function-name">waitq_wakeup64_one_locked</span>(<span class="enscript-type">struct</span> waitq *waitq,
					event64_t wake_event,
					wait_result_t result,
					uint64_t *reserved_preposts,
					<span class="enscript-type">int</span> priority,
					waitq_lock_state_t lock_state)
{
	thread_t thread;
	spl_t th_spl;

	assert(waitq_held(waitq));

	thread = waitq_select_one_locked(waitq, wake_event,
					 reserved_preposts,
					 priority, &amp;th_spl);

	<span class="enscript-keyword">if</span> (thread != THREAD_NULL)
		waitq_stats_count_wakeup(waitq);
	<span class="enscript-keyword">else</span>
		waitq_stats_count_fail(waitq);

	<span class="enscript-keyword">if</span> (lock_state == WAITQ_UNLOCK)
		waitq_unlock(waitq);

	<span class="enscript-keyword">if</span> (thread != THREAD_NULL) {
		maybe_adjust_thread_pri(thread, priority);
		kern_return_t ret = thread_go(thread, result);
		assert(ret == KERN_SUCCESS);
		thread_unlock(thread);
		splx(th_spl);
		<span class="enscript-keyword">return</span> ret;
	}

	<span class="enscript-keyword">return</span> KERN_NOT_WAITING;
}

<span class="enscript-comment">/**
 * wakeup one thread waiting on 'waitq' for 'wake_event'
 *
 * Conditions:
 *	'waitq' is locked
 *
 * Returns:
 *	A locked, runnable thread.
 *	If return value is non-NULL, interrupts have also
 *	been disabled, and the caller is responsible to call
 *	splx() with the returned '*spl' value.
 */</span>
thread_t <span class="enscript-function-name">waitq_wakeup64_identity_locked</span>(<span class="enscript-type">struct</span> waitq *waitq,
					event64_t wake_event,
					wait_result_t result,
					spl_t *spl,
					uint64_t *reserved_preposts,
					waitq_lock_state_t lock_state)
{
	thread_t thread;

	assert(waitq_held(waitq));

	thread = waitq_select_one_locked(waitq, wake_event,
					 reserved_preposts,
					 WAITQ_ALL_PRIORITIES, spl);

	<span class="enscript-keyword">if</span> (thread != THREAD_NULL)
		waitq_stats_count_wakeup(waitq);
	<span class="enscript-keyword">else</span>
		waitq_stats_count_fail(waitq);

	<span class="enscript-keyword">if</span> (lock_state == WAITQ_UNLOCK)
		waitq_unlock(waitq);

	<span class="enscript-keyword">if</span> (thread != THREAD_NULL) {
		kern_return_t __assert_only ret;
		ret = thread_go(thread, result);
		assert(ret == KERN_SUCCESS);
	}

	<span class="enscript-keyword">return</span> thread; <span class="enscript-comment">/* locked if not NULL (caller responsible for spl) */</span>
}

<span class="enscript-comment">/**
 * wakeup a specific thread iff it's waiting on 'waitq' for 'wake_event'
 *
 * Conditions:
 *	'waitq' is locked
 *	'thread' is unlocked
 *
 * Notes:
 *	May temporarily disable and re-enable interrupts
 *
 *	If the input lock_state == WAITQ_UNLOCK then the waitq will have been
 *	unlocked before calling thread_go() if 'thread' is to be awoken, and
 *	is guaranteed to be unlocked upon function return.
 */</span>
kern_return_t <span class="enscript-function-name">waitq_wakeup64_thread_locked</span>(<span class="enscript-type">struct</span> waitq *waitq,
					   event64_t wake_event,
					   thread_t thread,
					   wait_result_t result,
					   waitq_lock_state_t lock_state)
{
	kern_return_t ret;
	spl_t th_spl;

	assert(waitq_held(waitq));

	<span class="enscript-comment">/*
	 * See if the thread was still waiting there.  If so, it got
	 * dequeued and returned locked.
	 */</span>
	ret = waitq_select_thread_locked(waitq, wake_event, thread, &amp;th_spl);

	<span class="enscript-keyword">if</span> (ret == KERN_SUCCESS)
		waitq_stats_count_wakeup(waitq);
	<span class="enscript-keyword">else</span>
		waitq_stats_count_fail(waitq);

	<span class="enscript-keyword">if</span> (lock_state == WAITQ_UNLOCK)
		waitq_unlock(waitq);

	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> KERN_NOT_WAITING;

	ret = thread_go(thread, result);
	assert(ret == KERN_SUCCESS);
	thread_unlock(thread);
	splx(th_spl);

	<span class="enscript-keyword">return</span> ret;
}



<span class="enscript-comment">/* ----------------------------------------------------------------------
 *
 * In-Kernel API
 *
 * ---------------------------------------------------------------------- */</span>

<span class="enscript-comment">/**
 * initialize a waitq object
 */</span>
kern_return_t <span class="enscript-function-name">waitq_init</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">int</span> policy)
{
	assert(waitq != NULL);

	<span class="enscript-comment">/* only FIFO and LIFO for now */</span>
	<span class="enscript-keyword">if</span> ((policy &amp; SYNC_POLICY_FIXED_PRIORITY) != 0)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	waitq-&gt;waitq_fifo = ((policy &amp; SYNC_POLICY_REVERSED) == 0);
	waitq-&gt;waitq_irq = !!(policy &amp; SYNC_POLICY_DISABLE_IRQ);
	waitq-&gt;waitq_prepost = 0;
	waitq-&gt;waitq_type = WQT_QUEUE;
	waitq-&gt;waitq_eventmask = 0;

	waitq-&gt;waitq_set_id = 0;
	waitq-&gt;waitq_prepost_id = 0;

	hw_lock_init(&amp;waitq-&gt;waitq_interlock);
	queue_init(&amp;waitq-&gt;waitq_queue);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">struct</span> wq_unlink_ctx {
	<span class="enscript-type">struct</span> waitq *unlink_wq;
	<span class="enscript-type">struct</span> waitq_set *unlink_wqset;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_unlink_prepost_cb</span>(<span class="enscript-type">struct</span> waitq_set __unused *wqset, <span class="enscript-type">void</span> *ctx,
				   <span class="enscript-type">struct</span> wq_prepost *wqp, <span class="enscript-type">struct</span> waitq *waitq);

<span class="enscript-comment">/**
 * walk_setid_links callback to invalidate 'link' parameter
 *
 * Conditions:
 *	Called from walk_setid_links.
 *	Note that unlink other callbacks, this one make no assumptions about
 *	the 'waitq' parameter, specifically it does not have to be locked or
 *	even valid.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_unlink_all_cb</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">void</span> *ctx,
			       <span class="enscript-type">struct</span> setid_link *link)
{
	(<span class="enscript-type">void</span>)waitq;
	(<span class="enscript-type">void</span>)ctx;
	<span class="enscript-keyword">if</span> (sl_type(link) == SLT_LINK &amp;&amp; sl_is_valid(link))
		lt_invalidate(link);

	<span class="enscript-keyword">if</span> (sl_type(link) == SLT_WQS) {
		<span class="enscript-type">struct</span> waitq_set *wqset;
		<span class="enscript-type">int</span> do_spl = 0;
		spl_t spl;
		<span class="enscript-type">struct</span> wq_unlink_ctx ulctx;

		<span class="enscript-comment">/*
		 * When destroying the waitq, take the time to clear out any
		 * preposts it may have made. This could potentially save time
		 * on the IPC send path which would otherwise have to iterate
		 * over lots of dead port preposts.
		 */</span>
		<span class="enscript-keyword">if</span> (waitq-&gt;waitq_prepost_id == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		wqset = link-&gt;sl_wqs.sl_set;
		assert(wqset != NULL);

		<span class="enscript-keyword">if</span> (waitq_set_is_valid(wqset) &amp;&amp;
		    waitq_irq_safe(&amp;wqset-&gt;wqset_q)) {
			spl = splsched();
			do_spl = 1;
		}
		waitq_set_lock(wqset);

		<span class="enscript-keyword">if</span> (!waitq_set_is_valid(wqset)) {
			<span class="enscript-comment">/* someone raced us to teardown */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
		}
		<span class="enscript-keyword">if</span> (!waitq_set_maybe_preposted(wqset))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;

		ulctx.unlink_wq = waitq;
		ulctx.unlink_wqset = wqset;
		(<span class="enscript-type">void</span>)wq_prepost_iterate(wqset-&gt;wqset_prepost_id, &amp;ulctx,
					 waitq_unlink_prepost_cb);
<span class="enscript-reference">out_unlock</span>:
		waitq_set_unlock(wqset);
		<span class="enscript-keyword">if</span> (do_spl)
			splx(spl);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;
}


<span class="enscript-comment">/**
 * cleanup any link/prepost table resources associated with a waitq
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_deinit</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	uint64_t setid = 0;
	spl_t s;

	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		s = splsched();
	waitq_lock(waitq);
	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	waitq_unlink_all_locked(waitq, &amp;setid, &amp;s, NULL);
	waitq-&gt;waitq_type = WQT_INVALID;
	assert(queue_empty(&amp;waitq-&gt;waitq_queue));

<span class="enscript-reference">out</span>:
	waitq_unlock(waitq);
	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(s);

	<span class="enscript-keyword">if</span> (setid)
		(<span class="enscript-type">void</span>)walk_setid_links(LINK_WALK_ONE_LEVEL, waitq, setid,
				       SLT_ALL, NULL, waitq_unlink_all_cb);
}


<span class="enscript-comment">/**
 * invalidate the given wq_prepost object
 *
 * Conditions:
 *	Called from wq_prepost_iterate (_not_ from wq_prepost_foreach_locked!)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wqset_clear_prepost_chain_cb</span>(<span class="enscript-type">struct</span> waitq_set __unused *wqset,
					<span class="enscript-type">void</span> __unused *ctx,
					<span class="enscript-type">struct</span> wq_prepost *wqp,
					<span class="enscript-type">struct</span> waitq __unused *waitq)
{
	<span class="enscript-keyword">if</span> (wqp_type(wqp) == WQP_POST)
		wq_prepost_invalidate(wqp);
	<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;
}


<span class="enscript-comment">/**
 * allocate and initialize a waitq set object
 *
 * Conditions:
 *	may block
 *
 * Returns:
 *	allocated / initialized waitq_set object
 *	NULL on failure
 */</span>
<span class="enscript-type">struct</span> waitq_set *<span class="enscript-function-name">waitq_set_alloc</span>(<span class="enscript-type">int</span> policy)
{
	<span class="enscript-type">struct</span> waitq_set *wqset;

	wqset = (<span class="enscript-type">struct</span> waitq_set *)zalloc(waitq_set_zone);
	<span class="enscript-keyword">if</span> (!wqset)
		panic(<span class="enscript-string">&quot;Can't allocate a new waitq set from zone %p&quot;</span>, waitq_set_zone);

	kern_return_t ret;
	ret = waitq_set_init(wqset, policy, NULL);
	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS) {
		zfree(waitq_set_zone, wqset);
		wqset = NULL;
	}

	<span class="enscript-keyword">return</span> wqset;
}

<span class="enscript-comment">/**
 * initialize a waitq set object
 *
 * Conditions:
 *	may (rarely) block if link table needs to grow, and
 *	no 'reserved_link' object is passed.
 */</span>
kern_return_t <span class="enscript-function-name">waitq_set_init</span>(<span class="enscript-type">struct</span> waitq_set *wqset,
			     <span class="enscript-type">int</span> policy, uint64_t *reserved_link)
{
	<span class="enscript-type">struct</span> setid_link *link;
	kern_return_t ret;

	memset(wqset, 0, <span class="enscript-keyword">sizeof</span>(*wqset));

	ret = waitq_init(&amp;wqset-&gt;wqset_q, policy);
	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> ret;

	wqset-&gt;wqset_q.waitq_type = WQT_SET;
	<span class="enscript-keyword">if</span> (policy &amp; SYNC_POLICY_PREPOST)
		wqset-&gt;wqset_q.waitq_prepost = 1;
	<span class="enscript-keyword">else</span>
		wqset-&gt;wqset_q.waitq_prepost = 0;

	<span class="enscript-keyword">if</span> (reserved_link &amp;&amp; *reserved_link != 0) {
		link = lt_get_reserved(*reserved_link, SLT_WQS);
		<span class="enscript-comment">/* always consume the caller's reference */</span>
		*reserved_link = 0;
	} <span class="enscript-keyword">else</span> {
		link = lt_alloc_link(SLT_WQS);
	}
	<span class="enscript-keyword">if</span> (!link)
		panic(<span class="enscript-string">&quot;Can't allocate link object for waitq set: %p&quot;</span>, wqset);

	link-&gt;sl_wqs.sl_set = wqset;
	sl_set_valid(link);

	wqset-&gt;wqset_id = link-&gt;sl_set_id.id;
	wqset-&gt;wqset_prepost_id = 0;
	lt_put_link(link);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/**
 * clear out / release any resources associated with a waitq set
 *
 * Conditions:
 *	may block
 * Note:
 *	This will render the waitq set invalid, and it must
 *	be re-initialized with waitq_set_init before it can be used again
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_set_deinit</span>(<span class="enscript-type">struct</span> waitq_set *wqset)
{
	<span class="enscript-type">struct</span> setid_link *link = NULL;
	uint64_t set_id, set_links_id, prepost_id;
	<span class="enscript-type">int</span> do_spl = 0;
	spl_t s;

	<span class="enscript-keyword">if</span> (!waitqs_is_set(wqset))
		panic(<span class="enscript-string">&quot;trying to de-initialize an invalid wqset @%p&quot;</span>, wqset);

	<span class="enscript-keyword">if</span> (waitq_irq_safe(&amp;wqset-&gt;wqset_q)) {
		s = splsched();
		do_spl = 1;
	}
	waitq_set_lock(wqset);

	set_id = wqset-&gt;wqset_id;

	<span class="enscript-comment">/* grab the set's link object */</span>
	link = lt_get_link(set_id);
	<span class="enscript-keyword">if</span> (link)
		lt_invalidate(link);

	<span class="enscript-comment">/* someone raced us to deinit */</span>
	<span class="enscript-keyword">if</span> (!link || wqset-&gt;wqset_id != set_id || set_id != link-&gt;sl_set_id.id) {
		<span class="enscript-keyword">if</span> (link)
			lt_put_link(link);
		waitq_set_unlock(wqset);
		<span class="enscript-keyword">if</span> (do_spl)
			splx(s);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* every wait queue set should have a valid link object */</span>
	assert(link != NULL &amp;&amp; sl_type(link) == SLT_WQS);

	wqset-&gt;wqset_id = 0;

	wqset-&gt;wqset_q.waitq_type = WQT_INVALID;
	wqset-&gt;wqset_q.waitq_fifo = 0;
	wqset-&gt;wqset_q.waitq_prepost = 0;
	<span class="enscript-comment">/* don't clear the 'waitq_irq' bit: it's used in locking! */</span>
	wqset-&gt;wqset_q.waitq_eventmask = 0;

	<span class="enscript-comment">/*
	 * This set may have a lot of preposts, or may have been a member of
	 * many other sets. To minimize spinlock hold times, we clear out the
	 * waitq set data structure under the lock-hold, but don't clear any
	 * table objects. We keep handles to the prepost and set linkage
	 * objects and free those outside the critical section.
	 */</span>
	prepost_id = wqset-&gt;wqset_prepost_id;
	wqset-&gt;wqset_prepost_id = 0;

	set_links_id = 0;
	waitq_unlink_all_locked(&amp;wqset-&gt;wqset_q, &amp;set_links_id, &amp;s, NULL);

	waitq_set_unlock(wqset);
	<span class="enscript-keyword">if</span> (do_spl)
		splx(s);

	<span class="enscript-comment">/*
	 * walk_setid_links may race with us for access to the waitq set.
	 * If walk_setid_links has a reference to the set, then we should wait
	 * until the link's refcount goes to 1 (our reference) before we exit
	 * this function. That way we ensure that the waitq set memory will
	 * remain valid even though it's been cleared out.
	 */</span>
	<span class="enscript-keyword">while</span> (sl_refcnt(link) &gt; 1)
		delay(1);
	lt_put_link(link);

	<span class="enscript-comment">/*
	 * release all the set link objects
	 * (links to other sets to which this set was previously added)
	 */</span>
	<span class="enscript-keyword">if</span> (set_links_id)
		(<span class="enscript-type">void</span>)walk_setid_links(LINK_WALK_ONE_LEVEL, NULL, set_links_id,
				       SLT_ALL, NULL, waitq_unlink_all_cb);

	<span class="enscript-comment">/* drop / unlink all the prepost table objects */</span>
	(<span class="enscript-type">void</span>)wq_prepost_iterate(prepost_id, NULL, wqset_clear_prepost_chain_cb);
}

<span class="enscript-comment">/**
 * de-initialize and free an allocated waitq set object
 *
 * Conditions:
 *	may block
 */</span>
kern_return_t <span class="enscript-function-name">waitq_set_free</span>(<span class="enscript-type">struct</span> waitq_set *wqset)
{
	waitq_set_deinit(wqset);

	memset(wqset, 0, <span class="enscript-keyword">sizeof</span>(*wqset));
	zfree(waitq_set_zone, wqset);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEVLEOPMENT</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEBUG</span>)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_DEBUG</span>
<span class="enscript-comment">/**
 * return the set ID of 'wqset'
 */</span>
uint64_t <span class="enscript-function-name">wqset_id</span>(<span class="enscript-type">struct</span> waitq_set *wqset)
{
	<span class="enscript-keyword">if</span> (!wqset)
		<span class="enscript-keyword">return</span> 0;

	assert(waitqs_is_set(wqset));
	<span class="enscript-keyword">return</span> wqset-&gt;wqset_id;
}

<span class="enscript-comment">/**
 * returns a pointer to the waitq object embedded in 'wqset'
 */</span>
<span class="enscript-type">struct</span> waitq *<span class="enscript-function-name">wqset_waitq</span>(<span class="enscript-type">struct</span> waitq_set *wqset)
{
	<span class="enscript-keyword">if</span> (!wqset)
		<span class="enscript-keyword">return</span> NULL;

	assert(waitqs_is_set(wqset));

	<span class="enscript-keyword">return</span> &amp;wqset-&gt;wqset_q;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_WAITQ_DEBUG */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>


<span class="enscript-comment">/**
 * clear all preposts originating from 'waitq'
 *
 * Conditions:
 *	'waitq' locked
 *	may (rarely) spin waiting for another on-core thread to
 *	release the last reference to the waitq's prepost link object
 *
 * NOTE:
 *	If this function needs to spin, it will drop the waitq lock!
 *	The return value of the function indicates whether or not this
 *	happened: 1 == lock was dropped, 0 == lock held
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">waitq_clear_prepost_locked</span>(<span class="enscript-type">struct</span> waitq *waitq, spl_t *s)
{
	<span class="enscript-type">struct</span> wq_prepost *wqp;
	<span class="enscript-type">int</span> dropped_lock = 0;

	<span class="enscript-keyword">if</span> (waitq-&gt;waitq_prepost_id == 0)
		<span class="enscript-keyword">return</span> 0;

	wqp = wq_prepost_get(waitq-&gt;waitq_prepost_id);
	waitq-&gt;waitq_prepost_id = 0;
	<span class="enscript-keyword">if</span> (wqp) {
		uint64_t wqp_id = wqp-&gt;wqp_prepostid.id;
		wqdbg_v(<span class="enscript-string">&quot;invalidate prepost 0x%llx (refcnt:%d)&quot;</span>,
			wqp-&gt;wqp_prepostid.id, wqp_refcnt(wqp));
		wq_prepost_invalidate(wqp);
		<span class="enscript-keyword">while</span> (wqp_refcnt(wqp) &gt; 1) {
			<span class="enscript-type">int</span> do_spl = waitq_irq_safe(waitq);

			<span class="enscript-comment">/*
			 * Some other thread must have raced us to grab a link
			 * object reference before we invalidated it. This
			 * means that they are probably trying to access the
			 * waitq to which the prepost object points. We need
			 * to wait here until the other thread drops their
			 * reference. We know that no one else can get a
			 * reference (the object has been invalidated), and
			 * that prepost references are short-lived (dropped on
			 * a call to wq_prepost_put). We also know that no one
			 * blocks while holding a reference therefore the
			 * other reference holder must be on-core. We'll just
			 * sit and wait for the other reference to be dropped.
			 */</span>
			disable_preemption();

			waitq_unlock(waitq);
			<span class="enscript-keyword">if</span> (s &amp;&amp; do_spl)
				splx(*s);
			dropped_lock = 1;
			<span class="enscript-comment">/*
			 * don't yield here, just spin and assume the other
			 * consumer is already on core...
			 */</span>
			delay(1);
			<span class="enscript-keyword">if</span> (s &amp;&amp; do_spl)
				*s = splsched();
			waitq_lock(waitq);

			enable_preemption();
		}
		<span class="enscript-keyword">if</span> (wqp_refcnt(wqp) &gt; 0 &amp;&amp; wqp-&gt;wqp_prepostid.id == wqp_id)
			wq_prepost_put(wqp);
	}

	<span class="enscript-keyword">return</span> dropped_lock;
}

<span class="enscript-comment">/**
 * clear all preposts originating from 'waitq'
 *
 * Conditions:
 *	'waitq' is not locked
 *	may disable and re-enable interrupts
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_clear_prepost</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	spl_t s;
	<span class="enscript-type">int</span> do_spl = waitq_irq_safe(waitq);

	assert(waitq_valid(waitq));

	<span class="enscript-keyword">if</span> (do_spl)
		s = splsched();
	waitq_lock(waitq);
	<span class="enscript-comment">/* it doesn't matter to us if the lock is dropped here */</span>
	(<span class="enscript-type">void</span>)waitq_clear_prepost_locked(waitq, &amp;s);
	waitq_unlock(waitq);
	<span class="enscript-keyword">if</span> (do_spl)
		splx(s);
}

<span class="enscript-comment">/**
 * return a the waitq's prepost object ID (allocate if necessary)
 *
 * Conditions:
 *	'waitq' is unlocked
 */</span>
uint64_t <span class="enscript-function-name">waitq_get_prepost_id</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-type">struct</span> wq_prepost *wqp;
	uint64_t wqp_id = 0;
	spl_t s;

	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		s = splsched();
	waitq_lock(waitq);

	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;

	<span class="enscript-keyword">if</span> (waitq-&gt;waitq_prepost_id) {
		wqp_id = waitq-&gt;waitq_prepost_id;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
	}

	<span class="enscript-comment">/* don't hold a spinlock while allocating a prepost object */</span>
	waitq_unlock(waitq);
	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(s);

	wqp = wq_prepost_alloc(WQP_WQ, 1);
	<span class="enscript-keyword">if</span> (!wqp)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-comment">/* re-acquire the waitq lock */</span>
	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		s = splsched();
	waitq_lock(waitq);

	<span class="enscript-keyword">if</span> (!waitq_valid(waitq)) {
		wq_prepost_put(wqp);
		wqp_id = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
	}

	<span class="enscript-keyword">if</span> (waitq-&gt;waitq_prepost_id) {
		<span class="enscript-comment">/* we were beat by someone else */</span>
		wq_prepost_put(wqp);
		wqp_id = waitq-&gt;waitq_prepost_id;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
	}

	wqp-&gt;wqp_wq.wqp_wq_ptr = waitq;

	wqp_set_valid(wqp);
	wqp_id = wqp-&gt;wqp_prepostid.id;
	waitq-&gt;waitq_prepost_id = wqp_id;

	wq_prepost_put(wqp);

<span class="enscript-reference">out_unlock</span>:
	waitq_unlock(waitq);
	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(s);

	<span class="enscript-keyword">return</span> wqp_id;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_inset_cb</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">void</span> *ctx, <span class="enscript-type">struct</span> setid_link *link)
{
	uint64_t setid = *(uint64_t *)ctx;
	<span class="enscript-type">int</span> ltype = sl_type(link);
	(<span class="enscript-type">void</span>)waitq;
	<span class="enscript-keyword">if</span> (ltype == SLT_WQS &amp;&amp; link-&gt;sl_set_id.id == setid) {
		wqdbg_v(<span class="enscript-string">&quot;  waitq already in set 0x%llx&quot;</span>, setid);
		<span class="enscript-keyword">return</span> WQ_ITERATE_FOUND;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ltype == SLT_LINK) {
		<span class="enscript-comment">/*
		 * break out early if we see a link that points to the setid
		 * in question. This saves us a step in the
		 * iteration/recursion
		 */</span>
		wqdbg_v(<span class="enscript-string">&quot;  waitq already in set 0x%llx (SLT_LINK)&quot;</span>, setid);
		<span class="enscript-keyword">if</span> (link-&gt;sl_link.sl_left_setid == setid ||
		    link-&gt;sl_link.sl_right_setid == setid)
			<span class="enscript-keyword">return</span> WQ_ITERATE_FOUND;
	}

	<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;
}

<span class="enscript-comment">/**
 * determine if 'waitq' is a member of 'wqset'
 *
 * Conditions:
 *	neither 'waitq' nor 'wqset' is not locked
 *	may disable and re-enable interrupts while locking 'waitq'
 */</span>
boolean_t <span class="enscript-function-name">waitq_member</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">struct</span> waitq_set *wqset)
{
	kern_return_t kr = WQ_ITERATE_SUCCESS;
	uint64_t setid;
	spl_t s;

	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		panic(<span class="enscript-string">&quot;Invalid waitq: %p&quot;</span>, waitq);

	<span class="enscript-keyword">if</span> (!waitqs_is_set(wqset))
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		s = splsched();
	waitq_lock(waitq);

	setid = wqset-&gt;wqset_id;
	<span class="enscript-keyword">if</span> (!setid)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;

	<span class="enscript-comment">/* fast path: most waitqs are members of only 1 set */</span>
	<span class="enscript-keyword">if</span> (waitq-&gt;waitq_set_id == setid) {
		waitq_unlock(waitq);
		<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
			splx(s);
		<span class="enscript-keyword">return</span> TRUE;
	}

	<span class="enscript-comment">/* walk the link table and look for the Set ID of wqset */</span>
	kr = walk_setid_links(LINK_WALK_ONE_LEVEL, waitq, waitq-&gt;waitq_set_id,
			      SLT_ALL, (<span class="enscript-type">void</span> *)&amp;setid, waitq_inset_cb);

<span class="enscript-reference">out_unlock</span>:
	waitq_unlock(waitq);
	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(s);

	<span class="enscript-keyword">if</span> (kr == WQ_ITERATE_FOUND)
		<span class="enscript-keyword">return</span> TRUE;
	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-comment">/**
 * Returns true is the given waitq is a member of at least 1 set
 */</span>
boolean_t <span class="enscript-function-name">waitq_in_set</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-type">struct</span> setid_link *link;
	boolean_t inset = FALSE;
	spl_t s;

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		s = splsched();
	waitq_lock(waitq);

	<span class="enscript-keyword">if</span> (!waitq-&gt;waitq_set_id)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;

	link = lt_get_link(waitq-&gt;waitq_set_id);
	<span class="enscript-keyword">if</span> (link) {
		<span class="enscript-comment">/* if we get here, the waitq is in _at_least_one_ set */</span>
		inset = TRUE;
		lt_put_link(link);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* we can just optimize this for next time */</span>
		waitq-&gt;waitq_set_id = 0;
	}

<span class="enscript-reference">out_unlock</span>:
	waitq_unlock(waitq);
	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(s);
	<span class="enscript-keyword">return</span> inset;
}


<span class="enscript-comment">/**
 * pre-allocate a waitq link structure from the link table
 *
 * Conditions:
 *	'waitq' is not locked
 *	may (rarely) block if link table needs to grow
 */</span>
uint64_t <span class="enscript-function-name">waitq_link_reserve</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-type">struct</span> setid_link *link;
	uint64_t reserved_id = 0;

	assert(get_preemption_level() == 0 &amp;&amp; waitq_wait_possible(current_thread()));

	<span class="enscript-comment">/*
	 * We've asserted that the caller can block, so we enforce a
	 * minimum-free table element policy here.
	 */</span>
	lt_ensure_free_space();

	(<span class="enscript-type">void</span>)waitq;
	link = lt_alloc_link(WQT_RESERVED);
	<span class="enscript-keyword">if</span> (!link)
		<span class="enscript-keyword">return</span> 0;

	reserved_id = link-&gt;sl_set_id.id;

	<span class="enscript-keyword">return</span> reserved_id;
}

<span class="enscript-comment">/**
 * release a pre-allocated waitq link structure
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_link_release</span>(uint64_t id)
{
	<span class="enscript-type">struct</span> setid_link *link;

	<span class="enscript-keyword">if</span> (id == 0)
		<span class="enscript-keyword">return</span>;

	link = lt_get_reserved(id, SLT_LINK);
	<span class="enscript-keyword">if</span> (!link)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * if we successfully got a link object, then we know
	 * it's not been marked valid, and can be released with
	 * a standard lt_put_link() which should free the element.
	 */</span>
	lt_put_link(link);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_WAITQ_STATS</span>
	g_linktable.nreserved_releases += 1;
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/**
 * link 'waitq' to the set identified by 'setid' using the 'link' structure
 *
 * Conditions:
 *	'waitq' is locked
 *	caller should have a reference to the 'link' object
 */</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">waitq_link_internal</span>(<span class="enscript-type">struct</span> waitq *waitq,
					 uint64_t setid, <span class="enscript-type">struct</span> setid_link *link)
{
	<span class="enscript-type">struct</span> setid_link *qlink;
	kern_return_t kr;

	assert(waitq_held(waitq));

	<span class="enscript-comment">/*
	 * If the waitq_set_id field is empty, then this waitq is not
	 * a member of any other set. All we have to do is update the
	 * field.
	 */</span>
	<span class="enscript-keyword">if</span> (!waitq-&gt;waitq_set_id) {
		waitq-&gt;waitq_set_id = setid;
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	qlink = lt_get_link(waitq-&gt;waitq_set_id);
	<span class="enscript-keyword">if</span> (!qlink) {
		<span class="enscript-comment">/*
		 * The set to which this wait queue belonged has been
		 * destroyed / invalidated. We can re-use the waitq field.
		 */</span>
		waitq-&gt;waitq_set_id = setid;
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
	lt_put_link(qlink);

	<span class="enscript-comment">/*
	 * Check to see if it's already a member of the set.
	 *
	 * TODO: check for cycles!
	 */</span>
	kr = walk_setid_links(LINK_WALK_ONE_LEVEL, waitq, waitq-&gt;waitq_set_id,
			      SLT_ALL, (<span class="enscript-type">void</span> *)&amp;setid, waitq_inset_cb);
	<span class="enscript-keyword">if</span> (kr == WQ_ITERATE_FOUND)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-comment">/*
	 * This wait queue is a member of at least one set already,
	 * and _not_ a member of the given set. Use our previously
	 * allocated link object, and hook it up to the wait queue.
	 * Note that it's possible that one or more of the wait queue sets to
	 * which the wait queue belongs was invalidated before we allocated
	 * this link object. That's OK because the next time we use that
	 * object we'll just ignore it.
	 */</span>
	link-&gt;sl_link.sl_left_setid = setid;
	link-&gt;sl_link.sl_right_setid = waitq-&gt;waitq_set_id;
	sl_set_valid(link);

	waitq-&gt;waitq_set_id = link-&gt;sl_set_id.id;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/**
 * link 'waitq' to 'wqset'
 *
 * Conditions:
 *	if 'lock_state' contains WAITQ_SHOULD_LOCK, 'waitq' must be unlocked.
 *	Otherwise, 'waitq' must be locked.
 *
 *	may (rarely) block on link table allocation if the table has to grow,
 *	and no 'reserved_link' object is passed.
 *
 * Notes:
 *	The caller can guarantee that this function will never block by
 *	pre-allocating a link table object and passing its ID in 'reserved_link'
 */</span>
kern_return_t <span class="enscript-function-name">waitq_link</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">struct</span> waitq_set *wqset,
			 waitq_lock_state_t lock_state, uint64_t *reserved_link)
{
	kern_return_t kr;
	<span class="enscript-type">struct</span> setid_link *link;
	<span class="enscript-type">int</span> should_lock = (lock_state == WAITQ_SHOULD_LOCK);
	spl_t s;

	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		panic(<span class="enscript-string">&quot;Invalid waitq: %p&quot;</span>, waitq);

	<span class="enscript-keyword">if</span> (!waitqs_is_set(wqset))
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	wqdbg_v(<span class="enscript-string">&quot;Link waitq %p to wqset 0x%llx&quot;</span>,
		(<span class="enscript-type">void</span> *)VM_KERNEL_UNSLIDE_OR_PERM(waitq), wqset-&gt;wqset_id);

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq) &amp;&amp; (!reserved_link || *reserved_link == 0)) {
		<span class="enscript-comment">/*
		 * wait queues that need IRQs disabled cannot block waiting
		 * for table growth to complete. Even though this is rare,
		 * we require all these waitqs to pass in a reserved link
		 * object to avoid the potential to block.
		 */</span>
		panic(<span class="enscript-string">&quot;Global/IRQ-safe waitq %p cannot link to %p without&quot;</span>
		      <span class="enscript-string">&quot;reserved object!&quot;</span>, waitq, wqset);
	}

	<span class="enscript-comment">/*
	 * We _might_ need a new link object here, so we'll grab outside
	 * the lock because the alloc call _might_ block.
	 *
	 * If the caller reserved a link beforehand, then lt_get_link
	 * is guaranteed not to block because the caller holds an extra
	 * reference to the link which, in turn, hold a reference to the
	 * link table.
	 */</span>
	<span class="enscript-keyword">if</span> (reserved_link &amp;&amp; *reserved_link != 0) {
		link = lt_get_reserved(*reserved_link, SLT_LINK);
		<span class="enscript-comment">/* always consume the caller's reference */</span>
		*reserved_link = 0;
	} <span class="enscript-keyword">else</span> {
		link = lt_alloc_link(SLT_LINK);
	}
	<span class="enscript-keyword">if</span> (!link)
		<span class="enscript-keyword">return</span> KERN_NO_SPACE;

	<span class="enscript-keyword">if</span> (should_lock) {
		<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
			s = splsched();
		waitq_lock(waitq);
	}

	kr = waitq_link_internal(waitq, wqset-&gt;wqset_id, link);

	<span class="enscript-keyword">if</span> (should_lock) {
		waitq_unlock(waitq);
		<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
			splx(s);
	}

	lt_put_link(link);

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/**
 * helper: unlink 'waitq' from waitq set identified by 'setid'
 *         this function also prunes invalid objects from the tree
 *
 * Conditions:
 *	MUST be called from walk_setid_links link table walk
 *	'waitq' is locked
 *
 * Notes:
 *	This is a helper function which compresses the link table by culling
 *	unused or unnecessary links. See comments below for different
 *	scenarios.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_maybe_remove_link</span>(<span class="enscript-type">struct</span> waitq *waitq,
					  uint64_t setid,
					  <span class="enscript-type">struct</span> setid_link *parent,
					  <span class="enscript-type">struct</span> setid_link *left,
					  <span class="enscript-type">struct</span> setid_link *right)
{
	uint64_t *wq_setid = &amp;waitq-&gt;waitq_set_id;

	<span class="enscript-comment">/*
	 * There are two scenarios:
	 *
	 * Scenario 1:
	 * --------------------------------------------------------------------
	 * waitq-&gt;waitq_set_id == parent
	 *
	 *         parent(LINK)
	 *           /    \
	 *          /      \
	 *         /        \
	 *  L(LINK/WQS_l)   R(LINK/WQS_r)
	 *
	 * In this scenario, we assert that the original waitq points to the
	 * parent link we were passed in.  If WQS_l (or WQS_r) is the waitq
	 * set we're looking for, we can set the corresponding parent
	 * link id (left or right) to 0.  To compress the tree, we can reset the
	 * waitq_set_id of the original waitq to point to the side of the
	 * parent that is still valid. We then discard the parent link object.
	 */</span>
	<span class="enscript-keyword">if</span> (*wq_setid == parent-&gt;sl_set_id.id) {
		<span class="enscript-keyword">if</span> (!left &amp;&amp; !right) {
			<span class="enscript-comment">/* completely invalid children */</span>
			lt_invalidate(parent);
			wqdbg_v(<span class="enscript-string">&quot;S1, L+R&quot;</span>);
			*wq_setid = 0;
			<span class="enscript-keyword">return</span> WQ_ITERATE_INVALID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!left || left-&gt;sl_set_id.id == setid) {
			<span class="enscript-comment">/*
			 * left side matches we know it points either to the
			 * WQS we're unlinking, or to an invalid object:
			 * no need to invalidate it
			 */</span>
			*wq_setid = right-&gt;sl_set_id.id;
			lt_invalidate(parent);
			wqdbg_v(<span class="enscript-string">&quot;S1, L&quot;</span>);
			<span class="enscript-keyword">return</span> left ? WQ_ITERATE_UNLINKED : WQ_ITERATE_INVALID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!right || right-&gt;sl_set_id.id == setid) {
			<span class="enscript-comment">/*
			 * if right side matches we know it points either to the
			 * WQS we're unlinking, or to an invalid object:
			 * no need to invalidate it
			 */</span>
			*wq_setid = left-&gt;sl_set_id.id;
			lt_invalidate(parent);
			wqdbg_v(<span class="enscript-string">&quot;S1, R&quot;</span>);
			<span class="enscript-keyword">return</span> right ? WQ_ITERATE_UNLINKED : WQ_ITERATE_INVALID;
		}
	}

	<span class="enscript-comment">/*
	 * the tree walk starts at the top-of-tree and moves down,
	 * so these are safe asserts.
	 */</span>
	assert(left || right); <span class="enscript-comment">/* one of them has to be valid at this point */</span>

	<span class="enscript-comment">/*
	 * Scenario 2:
	 * --------------------------------------------------------------------
	 * waitq-&gt;waitq_set_id == ... (OR parent)
	 *
	 *                    ...
	 *                     |
	 *                   parent
	 *                   /    \
	 *                  /      \
	 *              L(LINK)     R(LINK)
	 *               /\             /\
	 *              /  \           /  \
	 *             /    \       Rl(*)  Rr(*)
	 *         Ll(WQS)  Lr(WQS)
	 *
	 * In this scenario, a leaf node of either the left or right side
	 * could be the wait queue set we're looking to unlink. We also handle
	 * the case where one of these links is invalid.  If a leaf node is
	 * invalid or it's the set we're looking for, we can safely remove the
	 * middle link (left or right) and point the parent link directly to
	 * the remaining leaf node.
	 */</span>
	<span class="enscript-keyword">if</span> (left &amp;&amp; sl_type(left) == SLT_LINK) {
		uint64_t Ll, Lr;
		<span class="enscript-type">struct</span> setid_link *linkLl, *linkLr;
		assert(left-&gt;sl_set_id.id != setid);
		Ll = left-&gt;sl_link.sl_left_setid;
		Lr = left-&gt;sl_link.sl_right_setid;
		linkLl = lt_get_link(Ll);
		linkLr = lt_get_link(Lr);
		<span class="enscript-keyword">if</span> (!linkLl &amp;&amp; !linkLr) {
			<span class="enscript-comment">/*
			 * The left object points to two invalid objects!
			 * We can invalidate the left w/o touching the parent.
			 */</span>
			lt_invalidate(left);
			wqdbg_v(<span class="enscript-string">&quot;S2, Ll+Lr&quot;</span>);
			<span class="enscript-keyword">return</span> WQ_ITERATE_INVALID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!linkLl || Ll == setid) {
			<span class="enscript-comment">/* Ll is invalid and/or the wait queue set we're looking for */</span>
			parent-&gt;sl_link.sl_left_setid = Lr;
			lt_invalidate(left);
			lt_put_link(linkLl);
			lt_put_link(linkLr);
			wqdbg_v(<span class="enscript-string">&quot;S2, Ll&quot;</span>);
			<span class="enscript-keyword">return</span> linkLl ? WQ_ITERATE_UNLINKED : WQ_ITERATE_INVALID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!linkLr || Lr == setid) {
			<span class="enscript-comment">/* Lr is invalid and/or the wait queue set we're looking for */</span>
			parent-&gt;sl_link.sl_left_setid = Ll;
			lt_invalidate(left);
			lt_put_link(linkLr);
			lt_put_link(linkLl);
			wqdbg_v(<span class="enscript-string">&quot;S2, Lr&quot;</span>);
			<span class="enscript-keyword">return</span> linkLr ? WQ_ITERATE_UNLINKED : WQ_ITERATE_INVALID;
		}
		lt_put_link(linkLl);
		lt_put_link(linkLr);
	}

	<span class="enscript-keyword">if</span> (right &amp;&amp; sl_type(right) == SLT_LINK) {
		uint64_t Rl, Rr;
		<span class="enscript-type">struct</span> setid_link *linkRl, *linkRr;
		assert(right-&gt;sl_set_id.id != setid);
		Rl = right-&gt;sl_link.sl_left_setid;
		Rr = right-&gt;sl_link.sl_right_setid;
		linkRl = lt_get_link(Rl);
		linkRr = lt_get_link(Rr);
		<span class="enscript-keyword">if</span> (!linkRl &amp;&amp; !linkRr) {
			<span class="enscript-comment">/*
			 * The right object points to two invalid objects!
			 * We can invalidate the right w/o touching the parent.
			 */</span>
			lt_invalidate(right);
			wqdbg_v(<span class="enscript-string">&quot;S2, Rl+Rr&quot;</span>);
			<span class="enscript-keyword">return</span> WQ_ITERATE_INVALID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!linkRl || Rl == setid) {
			<span class="enscript-comment">/* Rl is invalid and/or the wait queue set we're looking for */</span>
			parent-&gt;sl_link.sl_right_setid = Rr;
			lt_invalidate(right);
			lt_put_link(linkRl);
			lt_put_link(linkRr);
			wqdbg_v(<span class="enscript-string">&quot;S2, Rl&quot;</span>);
			<span class="enscript-keyword">return</span> linkRl ? WQ_ITERATE_UNLINKED : WQ_ITERATE_INVALID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!linkRr || Rr == setid) {
			<span class="enscript-comment">/* Rr is invalid and/or the wait queue set we're looking for */</span>
			parent-&gt;sl_link.sl_right_setid = Rl;
			lt_invalidate(right);
			lt_put_link(linkRl);
			lt_put_link(linkRr);
			wqdbg_v(<span class="enscript-string">&quot;S2, Rr&quot;</span>);
			<span class="enscript-keyword">return</span> linkRr ? WQ_ITERATE_UNLINKED : WQ_ITERATE_INVALID;
		}
		lt_put_link(linkRl);
		lt_put_link(linkRr);
	}

	<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;
}

<span class="enscript-comment">/**
 * link table walk callback that unlinks 'waitq' from 'ctx-&gt;setid'
 *
 * Conditions:
 *	called from walk_setid_links
 *	'waitq' is locked
 *
 * Notes:
 *	uses waitq_maybe_remove_link() to compress the linktable and
 *	perform the actual unlinking
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_unlink_cb</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">void</span> *ctx,
			   <span class="enscript-type">struct</span> setid_link *link)
{
	uint64_t setid = *((uint64_t *)ctx);
	<span class="enscript-type">struct</span> setid_link *right, *left;
	<span class="enscript-type">int</span> ret = 0;

	<span class="enscript-keyword">if</span> (sl_type(link) != SLT_LINK)
		<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;

	<span class="enscript-keyword">do</span>  {
		left  = lt_get_link(link-&gt;sl_link.sl_left_setid);
		right = lt_get_link(link-&gt;sl_link.sl_right_setid);

		ret = waitq_maybe_remove_link(waitq, setid, link, left, right);

		lt_put_link(left);
		lt_put_link(right);

		<span class="enscript-keyword">if</span> (!sl_is_valid(link))
			<span class="enscript-keyword">return</span> WQ_ITERATE_INVALID;
		<span class="enscript-comment">/* A ret value of UNLINKED will break us out of table walk */</span>
	} <span class="enscript-keyword">while</span> (ret == WQ_ITERATE_INVALID);

	<span class="enscript-keyword">return</span> ret;
}


<span class="enscript-comment">/**
 * undo/remove a prepost from 'ctx' (waitq) to 'wqset'
 *
 * Conditions:
 *	Called from wq_prepost_foreach_locked OR wq_prepost_iterate
 *	'wqset' may be NULL
 *	(ctx)-&gt;unlink_wqset is locked
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_unlink_prepost_cb</span>(<span class="enscript-type">struct</span> waitq_set __unused *wqset, <span class="enscript-type">void</span> *ctx,
				   <span class="enscript-type">struct</span> wq_prepost *wqp, <span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-type">struct</span> wq_unlink_ctx *ulctx = (<span class="enscript-type">struct</span> wq_unlink_ctx *)ctx;

	<span class="enscript-keyword">if</span> (waitq != ulctx-&gt;unlink_wq)
		<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;

	<span class="enscript-keyword">if</span> (wqp_type(wqp) == WQP_WQ &amp;&amp;
	    wqp-&gt;wqp_prepostid.id == ulctx-&gt;unlink_wqset-&gt;wqset_prepost_id) {
		<span class="enscript-comment">/* this is the only prepost on this wait queue set */</span>
		wqdbg_v(<span class="enscript-string">&quot;unlink wqp (WQ) 0x%llx&quot;</span>, wqp-&gt;wqp_prepostid.id);
		ulctx-&gt;unlink_wqset-&gt;wqset_prepost_id = 0;
		<span class="enscript-keyword">return</span> WQ_ITERATE_BREAK;
	}

	assert(wqp_type(wqp) == WQP_POST);

	<span class="enscript-comment">/*
	 * The prepost object 'wqp' points to a waitq which should no longer
	 * be preposted to 'ulctx-&gt;unlink_wqset'. We can remove the prepost
	 * object from the list and break out of the iteration. Using the
	 * context object in this way allows this same callback function to be
	 * used from both wq_prepost_foreach_locked and wq_prepost_iterate.
	 */</span>
	wq_prepost_remove(ulctx-&gt;unlink_wqset, wqp);
	<span class="enscript-keyword">return</span> WQ_ITERATE_BREAK;
}

<span class="enscript-comment">/**
 * unlink 'waitq' from 'wqset'
 *
 * Conditions:
 *	'waitq' is locked
 *	'wqset' is _not_ locked
 *	may (rarely) spin in prepost clear and drop/re-acquire 'waitq' lock
 *	(see waitq_clear_prepost_locked)
 */</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">waitq_unlink_locked</span>(<span class="enscript-type">struct</span> waitq *waitq,
					 <span class="enscript-type">struct</span> waitq_set *wqset,
					 spl_t *s)
{
	uint64_t setid;
	kern_return_t kr;

	setid = wqset-&gt;wqset_id;

	<span class="enscript-keyword">if</span> (waitq-&gt;waitq_set_id == 0) {
		<span class="enscript-comment">/*
		 * TODO:
		 * it doesn't belong to anyone, and it has a prepost object?
		 * This is an artifact of not cleaning up after kqueues when
		 * they prepost into select sets...
		 */</span>
		<span class="enscript-keyword">if</span> (waitq-&gt;waitq_prepost_id != 0)
			(<span class="enscript-type">void</span>)waitq_clear_prepost_locked(waitq, s);
		<span class="enscript-keyword">return</span> KERN_NOT_IN_SET;
	}

	<span class="enscript-keyword">if</span> (waitq-&gt;waitq_set_id == setid) {
		waitq-&gt;waitq_set_id = 0;
		<span class="enscript-comment">/*
		 * This was the only set to which the waitq belonged: we can
		 * safely release the waitq's prepost object. It doesn't
		 * matter if this function drops and re-acquires the lock
		 * because we're not manipulating waitq state any more.
		 */</span>
		(<span class="enscript-type">void</span>)waitq_clear_prepost_locked(waitq, s);
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	<span class="enscript-comment">/*
	 * The waitq was a member of more that 1 set, so we need to
	 * handle potentially compressing the link table, and
	 * adjusting the waitq-&gt;waitq_set_id value.
	 *
	 * Note: we can't free the waitq's associated prepost object (if any)
	 *       because it may be in use by the one or more _other_ sets to
	 *       which this queue belongs.
	 *
	 * Note: This function only handles a single level of the queue linkage.
	 *       Removing a waitq from a set to which it does not directly
	 *       belong is undefined. For example, if a waitq belonged to set
	 *       A, and set A belonged to set B. You can't remove the waitq
	 *       from set B.
	 */</span>
	kr = walk_setid_links(LINK_WALK_ONE_LEVEL, waitq, waitq-&gt;waitq_set_id,
			      SLT_LINK, (<span class="enscript-type">void</span> *)&amp;setid, waitq_unlink_cb);

	<span class="enscript-keyword">if</span> (kr == WQ_ITERATE_UNLINKED) {
		<span class="enscript-type">struct</span> wq_unlink_ctx ulctx;
		<span class="enscript-type">int</span> do_spl = 0;

		kr = KERN_SUCCESS; <span class="enscript-comment">/* found it and dis-associated it */</span>

		<span class="enscript-keyword">if</span> (!waitq_irq_safe(waitq) &amp;&amp; waitq_irq_safe(&amp;wqset-&gt;wqset_q)) {
			*s = splsched();
			do_spl = 1;
		}
		waitq_set_lock(wqset);
		<span class="enscript-comment">/*
		 * clear out any prepost from waitq into wqset
		 * TODO: this could be more efficient than a linear search of
		 *       the waitq set's prepost list.
		 */</span>
		ulctx.unlink_wq = waitq;
		ulctx.unlink_wqset = wqset;
		(<span class="enscript-type">void</span>)wq_prepost_iterate(wqset-&gt;wqset_prepost_id, (<span class="enscript-type">void</span> *)&amp;ulctx,
					 waitq_unlink_prepost_cb);
		waitq_set_unlock(wqset);
		<span class="enscript-keyword">if</span> (do_spl)
			splx(*s);
	} <span class="enscript-keyword">else</span> {
		kr = KERN_NOT_IN_SET; <span class="enscript-comment">/* waitq is _not_ associated with wqset */</span>
	}

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/**
 * unlink 'waitq' from 'wqset'
 *
 * Conditions:
 *	neither 'waitq' nor 'wqset' is locked
 *	may disable and re-enable interrupts
 *	may (rarely) spin in prepost clear
 *	(see waitq_clear_prepost_locked)
 */</span>
kern_return_t <span class="enscript-function-name">waitq_unlink</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">struct</span> waitq_set *wqset)
{
	kern_return_t kr = KERN_SUCCESS;
	spl_t s;

	assert(waitqs_is_set(wqset));

	<span class="enscript-comment">/*
	 * we allow the waitq to be invalid because the caller may be trying
	 * to clear out old/dirty state
	 */</span>
	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	wqdbg_v(<span class="enscript-string">&quot;unlink waitq %p from set 0x%llx&quot;</span>,
		(<span class="enscript-type">void</span> *)VM_KERNEL_UNSLIDE_OR_PERM(waitq), wqset-&gt;wqset_id);

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		s = splsched();
	waitq_lock(waitq);

	kr = waitq_unlink_locked(waitq, wqset, &amp;s);

	waitq_unlock(waitq);
	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(s);

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/**
 * unlink a waitq from a waitq set, but reference the waitq by its prepost ID
 *
 * Conditions:
 *	'wqset' is unlocked
 *	wqp_id may be valid or invalid
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_unlink_by_prepost_id</span>(uint64_t wqp_id, <span class="enscript-type">struct</span> waitq_set *wqset)
{
	<span class="enscript-type">struct</span> wq_prepost *wqp;

	disable_preemption();
	wqp = wq_prepost_get(wqp_id);
	<span class="enscript-keyword">if</span> (wqp) {
		<span class="enscript-type">struct</span> waitq *wq;
		spl_t s;

		wq = wqp-&gt;wqp_wq.wqp_wq_ptr;

		<span class="enscript-comment">/*
		 * lock the waitq, then release our prepost ID reference, then
		 * unlink the waitq from the wqset: this ensures that we don't
		 * hold a prepost ID reference during the unlink, but we also
		 * complete the unlink operation atomically to avoid a race
		 * with waitq_unlink[_all].
		 */</span>
		<span class="enscript-keyword">if</span> (waitq_irq_safe(wq))
			s = splsched();
		waitq_lock(wq);
		wq_prepost_put(wqp);

		<span class="enscript-keyword">if</span> (!waitq_valid(wq)) {
			<span class="enscript-comment">/* someone already tore down this waitq! */</span>
			waitq_unlock(wq);
			<span class="enscript-keyword">if</span> (waitq_irq_safe(wq))
				splx(s);
			enable_preemption();
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/* this _may_ drop the wq lock, but that's OK */</span>
		waitq_unlink_locked(wq, wqset, &amp;s);

		waitq_unlock(wq);
		<span class="enscript-keyword">if</span> (waitq_irq_safe(wq))
			splx(s);
	}
	enable_preemption();
	<span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/**
 * unlink 'waitq' from all sets to which it belongs
 *
 * Conditions:
 *	'waitq' is locked
 *
 * Notes:
 *	may drop and re-acquire the waitq lock
 *	may (rarely) spin (see waitq_clear_prepost_locked)
 */</span>
kern_return_t <span class="enscript-function-name">waitq_unlink_all_locked</span>(<span class="enscript-type">struct</span> waitq *waitq, uint64_t *old_set_id,
				      spl_t *s, <span class="enscript-type">int</span> *dropped_lock)
{
	wqdbg_v(<span class="enscript-string">&quot;unlink waitq %p from all sets&quot;</span>,
		(<span class="enscript-type">void</span> *)VM_KERNEL_UNSLIDE_OR_PERM(waitq));

	*old_set_id = 0;

	<span class="enscript-comment">/* it's not a member of any sets */</span>
	<span class="enscript-keyword">if</span> (waitq-&gt;waitq_set_id == 0)
		<span class="enscript-keyword">return</span> KERN_SUCCESS;

	*old_set_id = waitq-&gt;waitq_set_id;
	waitq-&gt;waitq_set_id = 0;

	<span class="enscript-comment">/*
	 * invalidate the prepost entry for this waitq.
	 * This may drop and re-acquire the waitq lock, but that's OK because
	 * if it was added to another set and preposted to that set in the
	 * time we drop the lock, the state will remain consistent.
	 */</span>
	<span class="enscript-type">int</span> dropped = waitq_clear_prepost_locked(waitq, s);
	<span class="enscript-keyword">if</span> (dropped_lock)
		*dropped_lock = dropped;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/**
 * unlink 'waitq' from all sets to which it belongs
 *
 * Conditions:
 *	'waitq' is not locked
 *	may disable and re-enable interrupts
 *	may (rarely) spin
 *	(see waitq_unlink_all_locked, waitq_clear_prepost_locked)
 */</span>
kern_return_t <span class="enscript-function-name">waitq_unlink_all</span>(<span class="enscript-type">struct</span> waitq *waitq)
{
	kern_return_t kr = KERN_SUCCESS;
	uint64_t setid = 0;
	spl_t s;

	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		panic(<span class="enscript-string">&quot;Invalid waitq: %p&quot;</span>, waitq);

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		s = splsched();
	waitq_lock(waitq);
	<span class="enscript-keyword">if</span> (waitq_valid(waitq))
		kr = waitq_unlink_all_locked(waitq, &amp;setid, &amp;s, NULL);
	waitq_unlock(waitq);
	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(s);

	<span class="enscript-keyword">if</span> (setid) {
		<span class="enscript-comment">/*
		 * Walk the link table and invalidate each LINK object that
		 * used to connect this waitq to one or more sets: this works
		 * because SLT_LINK objects are private to each wait queue
		 */</span>
		(<span class="enscript-type">void</span>)walk_setid_links(LINK_WALK_ONE_LEVEL, waitq, setid,
				       SLT_LINK, NULL, waitq_unlink_all_cb);
	}

	<span class="enscript-keyword">return</span> kr;
}


<span class="enscript-comment">/**
 * unlink all waitqs from 'wqset'
 *
 * Conditions:
 *	'wqset' is not locked
 *	may (rarely) spin/block (see waitq_clear_prepost_locked)
 */</span>
kern_return_t <span class="enscript-function-name">waitq_set_unlink_all</span>(<span class="enscript-type">struct</span> waitq_set *wqset)
{
	<span class="enscript-type">struct</span> setid_link *link;
	uint64_t prepost_id, set_links_id = 0;
	spl_t spl;

	assert(waitqs_is_set(wqset));

	wqdbg_v(<span class="enscript-string">&quot;unlink all queues from set 0x%llx&quot;</span>, wqset-&gt;wqset_id);

	<span class="enscript-comment">/*
	 * This operation does not require interaction with any of the set's
	 * constituent wait queues. All we have to do is invalidate the SetID
	 */</span>
	<span class="enscript-keyword">if</span> (waitq_irq_safe(&amp;wqset-&gt;wqset_q))
		spl = splsched();
	waitq_set_lock(wqset);

	<span class="enscript-comment">/* invalidate and re-alloc the link object first */</span>
	link = lt_get_link(wqset-&gt;wqset_id);

	<span class="enscript-comment">/* we may have raced with a waitq_set_deinit: handle this */</span>
	<span class="enscript-keyword">if</span> (!link) {
		waitq_set_unlock(wqset);
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	lt_invalidate(link);

	<span class="enscript-comment">/* re-alloc the object to get a new generation ID */</span>
	lt_realloc_link(link, SLT_WQS);
	link-&gt;sl_wqs.sl_set = wqset;

	wqset-&gt;wqset_id = link-&gt;sl_set_id.id;
	sl_set_valid(link);
	lt_put_link(link);

	<span class="enscript-comment">/* clear any preposts attached to this set */</span>
	prepost_id = wqset-&gt;wqset_prepost_id;
	wqset-&gt;wqset_prepost_id = 0;

	<span class="enscript-comment">/*
	 * clear set linkage and prepost object associated with this set:
	 * waitq sets may prepost to other sets if, for example, they are
	 * associated with a kqueue which is in a select set.
	 *
	 * This may drop and re-acquire the set lock, but that's OK because
	 * the resulting state will remain consistent.
	 */</span>
	waitq_unlink_all_locked(&amp;wqset-&gt;wqset_q, &amp;set_links_id, &amp;spl, NULL);

	waitq_set_unlock(wqset);
	<span class="enscript-keyword">if</span> (waitq_irq_safe(&amp;wqset-&gt;wqset_q))
		splx(spl);

	<span class="enscript-comment">/*
	 * release all the set link objects
	 * (links to other sets to which this set was previously added)
	 */</span>
	<span class="enscript-keyword">if</span> (set_links_id)
		(<span class="enscript-type">void</span>)walk_setid_links(LINK_WALK_ONE_LEVEL, &amp;wqset-&gt;wqset_q,
				       set_links_id, SLT_LINK, NULL,
				       waitq_unlink_all_cb);

	<span class="enscript-comment">/* drop / unlink all the prepost table objects */</span>
	<span class="enscript-keyword">if</span> (prepost_id)
		(<span class="enscript-type">void</span>)wq_prepost_iterate(prepost_id, NULL,
					 wqset_clear_prepost_chain_cb);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_prepost_reserve_cb</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">void</span> *ctx,
				    <span class="enscript-type">struct</span> setid_link *link)
{
	uint32_t *num = (uint32_t *)ctx;
	(<span class="enscript-type">void</span>)waitq;

	<span class="enscript-comment">/*
	 * In the worst case, we'll have to allocate 2 prepost objects
	 * per waitq set (if the set was already preposted by another
	 * waitq).
	 */</span>
	<span class="enscript-keyword">if</span> (sl_type(link) == SLT_WQS) {
		<span class="enscript-comment">/*
		 * check to see if the associated waitq actually supports
		 * preposting
		 */</span>
		<span class="enscript-keyword">if</span> (waitq_set_can_prepost(link-&gt;sl_wqs.sl_set))
			*num += 2;
	}
	<span class="enscript-keyword">return</span> WQ_ITERATE_CONTINUE;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_alloc_prepost_reservation</span>(<span class="enscript-type">int</span> nalloc, <span class="enscript-type">struct</span> waitq *waitq,
					   spl_t *s, <span class="enscript-type">int</span> *did_unlock,
					   <span class="enscript-type">struct</span> wq_prepost **wqp)
{
	<span class="enscript-type">struct</span> wq_prepost *tmp;
	<span class="enscript-type">struct</span> wqp_cache *cache;

	*did_unlock = 0;

	<span class="enscript-comment">/*
	 * Before we unlock the waitq, check the per-processor prepost object
	 * cache to see if there's enough there for us. If so, do the
	 * allocation, keep the lock and save an entire iteration over the set
	 * linkage!
	 */</span>
	<span class="enscript-keyword">if</span> (waitq) {
		disable_preemption();
		cache = &amp;PROCESSOR_DATA(current_processor(), wqp_cache);
		<span class="enscript-keyword">if</span> (nalloc &lt;= (<span class="enscript-type">int</span>)cache-&gt;avail)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">do_alloc</span>;
		enable_preemption();

		<span class="enscript-comment">/* unlock the waitq to perform the allocation */</span>
		*did_unlock = 1;
		waitq_unlock(waitq);
		<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
			splx(*s);
	}

<span class="enscript-reference">do_alloc</span>:
	tmp = wq_prepost_alloc(WQT_RESERVED, nalloc);
	<span class="enscript-keyword">if</span> (!tmp)
		panic(<span class="enscript-string">&quot;Couldn't reserve %d preposts for waitq @%p (wqp@%p)&quot;</span>,
		      nalloc, waitq, *wqp);
	<span class="enscript-keyword">if</span> (*wqp) {
		<span class="enscript-comment">/* link the two lists */</span>
		<span class="enscript-type">int</span> __assert_only rc;
		rc = wq_prepost_rlink(tmp, *wqp);
		assert(rc == nalloc);
	}
	*wqp = tmp;

	<span class="enscript-comment">/*
	 * If the caller can block, then enforce a minimum-free table element
	 * policy here. This helps ensure that we will have enough prepost
	 * objects for callers such as selwakeup() that can be called with
	 * spin locks held.
	 */</span>
	<span class="enscript-keyword">if</span> (get_preemption_level() == 0)
		wq_prepost_ensure_free_space();

	<span class="enscript-keyword">if</span> (waitq) {
		<span class="enscript-keyword">if</span> (*did_unlock == 0) {
			<span class="enscript-comment">/* decrement the preemption count if alloc from cache */</span>
			enable_preemption();
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* otherwise: re-lock the waitq */</span>
			<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
				*s = splsched();
			waitq_lock(waitq);
		}
	}

	<span class="enscript-keyword">return</span> nalloc;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_count_prepost_reservation</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">int</span> extra, <span class="enscript-type">int</span> keep_locked)
{
	<span class="enscript-type">int</span> npreposts = 0;

	<span class="enscript-comment">/*
	 * If the waitq is not currently part of a set, and we're not asked to
	 * keep the waitq locked then we'll want to have 3 in reserve
	 * just-in-case it becomes part of a set while we unlock and reserve.
	 * We may need up to 1 object for the waitq, and 2 for the set.
	 */</span>
	<span class="enscript-keyword">if</span> (waitq-&gt;waitq_set_id == 0) {
		npreposts = 3;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* this queue has never been preposted before */</span>
		<span class="enscript-keyword">if</span> (waitq-&gt;waitq_prepost_id == 0)
			npreposts = 3;

		<span class="enscript-comment">/*
		 * Walk the set of table linkages associated with this waitq
		 * and count the worst-case number of prepost objects that
		 * may be needed during a wakeup_all. We can walk this without
		 * locking each set along the way because the table-based IDs
		 * disconnect us from the set pointers themselves, and the
		 * table walking is careful to read the setid values only once.
		 * Locking each set up the chain also doesn't guarantee that
		 * their membership won't change between the time we unlock
		 * that set and when we actually go to prepost, so our
		 * situation is no worse than before and we've alleviated lock
		 * contention on any sets to which this waitq belongs.
		 */</span>
		(<span class="enscript-type">void</span>)walk_setid_links(LINK_WALK_FULL_DAG_UNLOCKED,
				       waitq, waitq-&gt;waitq_set_id,
				       SLT_WQS, (<span class="enscript-type">void</span> *)&amp;npreposts,
				       waitq_prepost_reserve_cb);
	}

	<span class="enscript-keyword">if</span> (extra &gt; 0)
		npreposts += extra;

	<span class="enscript-keyword">if</span> (npreposts == 0 &amp;&amp; !keep_locked) {
		<span class="enscript-comment">/*
		 * If we get here, we were asked to reserve some prepost
		 * objects for a waitq that's previously preposted, and is not
		 * currently a member of any sets. We have also been
		 * instructed to unlock the waitq when we're done. In this
		 * case, we pre-allocated enough reserved objects to handle
		 * the case where the waitq gets added to a single set when
		 * the lock is released.
		 */</span>
		npreposts = 3;
	}

	<span class="enscript-keyword">return</span> npreposts;
}


<span class="enscript-comment">/**
 * pre-allocate prepost objects for 'waitq'
 *
 * Conditions:
 *	'waitq' is not locked
 *
 * Returns:
 *	panic on error
 *
 *	0 on success, '*reserved' is set to the head of a singly-linked
 *	list of pre-allocated prepost objects.
 *
 * Notes:
 *	If 'lock_state' is WAITQ_KEEP_LOCKED, this function performs the pre-allocation
 *	atomically and returns 'waitq' locked. If the waitq requires
 *	interrupts to be disabled, then the output parameter 's' is set to the
 *	previous interrupt state (from splsched), and the caller is
 *	responsible to call splx().
 *
 *	This function attempts to pre-allocate precisely enough prepost
 *	objects based on the current set membership of 'waitq'. If the
 *	operation is performed atomically, then the caller
 *	is guaranteed to have enough pre-allocated prepost object to avoid
 *	any (rare) blocking in the wakeup path.
 */</span>
uint64_t <span class="enscript-function-name">waitq_prepost_reserve</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">int</span> extra,
			       waitq_lock_state_t lock_state, spl_t *s)
{
	uint64_t reserved = 0;
	uint64_t prev_setid = 0, prev_prepostid = 0;
	<span class="enscript-type">struct</span> wq_prepost *wqp = NULL;
	<span class="enscript-type">int</span> nalloc = 0, npreposts = 0;
	<span class="enscript-type">int</span> keep_locked = (lock_state == WAITQ_KEEP_LOCKED);
	<span class="enscript-type">int</span> unlocked = 0;

	<span class="enscript-keyword">if</span> (s)
		*s = 0;

	wqdbg_v(<span class="enscript-string">&quot;Attempting to reserve prepost linkages for waitq %p (extra:%d)&quot;</span>,
		(<span class="enscript-type">void</span> *)VM_KERNEL_UNSLIDE_OR_PERM(waitq), extra);

	<span class="enscript-keyword">if</span> (waitq == NULL &amp;&amp; extra &gt; 0) {
		<span class="enscript-comment">/*
		 * Simple prepost object allocation:
		 * we'll add 2 more because the waitq might need an object,
		 * and the set itself may need a new POST object in addition
		 * to the number of preposts requested by the caller
		 */</span>
		nalloc = waitq_alloc_prepost_reservation(extra + 2, NULL, NULL,
							 &amp;unlocked, &amp;wqp);
		assert(nalloc == extra + 2);
		<span class="enscript-keyword">return</span> wqp-&gt;wqp_prepostid.id;
	}

	assert(lock_state == WAITQ_KEEP_LOCKED || lock_state == WAITQ_UNLOCK);

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		*s = splsched();
	waitq_lock(waitq);

	<span class="enscript-comment">/* global queues are never part of any sets */</span>
	<span class="enscript-keyword">if</span> (waitq_is_global(waitq)) {
		<span class="enscript-keyword">if</span> (keep_locked)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
	}

	<span class="enscript-comment">/* remember the set ID that we started with */</span>
	prev_setid = waitq-&gt;waitq_set_id;
	prev_prepostid = waitq-&gt;waitq_prepost_id;

	<span class="enscript-comment">/*
	 * If the waitq is not part of a set, and we're asked to
	 * keep the set locked, then we don't have to reserve
	 * anything!
	 */</span>
	<span class="enscript-keyword">if</span> (prev_setid == 0 &amp;&amp; keep_locked)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	npreposts = waitq_count_prepost_reservation(waitq, extra, keep_locked);

	<span class="enscript-comment">/* nothing for us to do! */</span>
	<span class="enscript-keyword">if</span> (npreposts == 0) {
		<span class="enscript-keyword">if</span> (keep_locked)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
	}

<span class="enscript-reference">try_alloc</span>:
	<span class="enscript-comment">/* this _may_ unlock and relock the waitq! */</span>
	nalloc = waitq_alloc_prepost_reservation(npreposts, waitq, s,
						 &amp;unlocked, &amp;wqp);

	<span class="enscript-keyword">if</span> (!unlocked) {
		<span class="enscript-comment">/* allocation held the waitq lock: we'd done! */</span>
		<span class="enscript-keyword">if</span> (keep_locked)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
	}

	<span class="enscript-comment">/*
	 * Before we return, if the allocation had to unlock the waitq, we
	 * must check one more time to see if we have enough. If not, we'll
	 * try to allocate the difference. If the caller requests it, we'll
	 * also leave the waitq locked so that the use of the pre-allocated
	 * prepost objects can be guaranteed to be enough if a wakeup_all is
	 * performed before unlocking the waitq.
	 */</span>

	<span class="enscript-comment">/*
	 * If the waitq is no longer associated with a set, or if the waitq's
	 * set/prepostid has not changed since we first walked its linkage,
	 * we're done.
	 */</span>
	<span class="enscript-keyword">if</span> ((waitq-&gt;waitq_set_id == 0) ||
	    (waitq-&gt;waitq_set_id == prev_setid &amp;&amp;
	     waitq-&gt;waitq_prepost_id == prev_prepostid)) {
		<span class="enscript-keyword">if</span> (keep_locked)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
	}

	npreposts = waitq_count_prepost_reservation(waitq, extra, keep_locked);

	<span class="enscript-keyword">if</span> (npreposts &gt; nalloc) {
		prev_setid = waitq-&gt;waitq_set_id;
		prev_prepostid = waitq-&gt;waitq_prepost_id;
		npreposts = npreposts - nalloc; <span class="enscript-comment">/* only allocate the diff */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_alloc</span>;
	}

	<span class="enscript-keyword">if</span> (keep_locked)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

<span class="enscript-reference">out_unlock</span>:
	waitq_unlock(waitq);
	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(*s);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (wqp)
		reserved = wqp-&gt;wqp_prepostid.id;

	<span class="enscript-keyword">return</span> reserved;
}

<span class="enscript-comment">/**
 * release a linked list of prepost objects allocated via _prepost_reserve
 *
 * Conditions:
 *	may (rarely) spin waiting for prepost table growth memcpy
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_prepost_release_reserve</span>(uint64_t id)
{
	<span class="enscript-type">struct</span> wq_prepost *wqp;

	wqdbg_v(<span class="enscript-string">&quot;releasing reserved preposts starting at: 0x%llx&quot;</span>, id);

	wqp = wq_prepost_rfirst(id);
	<span class="enscript-keyword">if</span> (!wqp)
		<span class="enscript-keyword">return</span>;

	wq_prepost_release_rlist(wqp);
}


<span class="enscript-comment">/**
 * clear all preposts from 'wqset'
 *
 * Conditions:
 *	'wqset' is not locked
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">waitq_set_clear_preposts</span>(<span class="enscript-type">struct</span> waitq_set *wqset)
{
	uint64_t prepost_id;
	spl_t spl;

	assert(waitqs_is_set(wqset));

	wqdbg_v(<span class="enscript-string">&quot;Clearing all preposted queues on waitq_set: 0x%llx&quot;</span>,
		wqset-&gt;wqset_id);

	<span class="enscript-keyword">if</span> (waitq_irq_safe(&amp;wqset-&gt;wqset_q))
		spl = splsched();
	waitq_set_lock(wqset);
	prepost_id = wqset-&gt;wqset_prepost_id;
	wqset-&gt;wqset_prepost_id = 0;
	waitq_set_unlock(wqset);
	<span class="enscript-keyword">if</span> (waitq_irq_safe(&amp;wqset-&gt;wqset_q))
		splx(spl);

	<span class="enscript-comment">/* drop / unlink all the prepost table objects */</span>
	<span class="enscript-keyword">if</span> (prepost_id)
		(<span class="enscript-type">void</span>)wq_prepost_iterate(prepost_id, NULL,
					 wqset_clear_prepost_chain_cb);
}


<span class="enscript-comment">/* ----------------------------------------------------------------------
 *
 * Iteration: waitq -&gt; sets / waitq_set -&gt; preposts
 *
 * ---------------------------------------------------------------------- */</span>

<span class="enscript-type">struct</span> wq_it_ctx {
	<span class="enscript-type">void</span> *input;
	<span class="enscript-type">void</span> *ctx;
	waitq_iterator_t it;

	spl_t *spl;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">waitq_iterate_sets_cb</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">void</span> *ctx,
				 <span class="enscript-type">struct</span> setid_link *link)
{
	<span class="enscript-type">struct</span> wq_it_ctx *wctx = (<span class="enscript-type">struct</span> wq_it_ctx *)(ctx);
	<span class="enscript-type">struct</span> waitq_set *wqset;
	<span class="enscript-type">int</span> ret;
	spl_t spl;

	(<span class="enscript-type">void</span>)waitq;
	assert(sl_type(link) == SLT_WQS);

	<span class="enscript-comment">/*
	 * the waitq is locked, so we can just take the set lock
	 * and call the iterator function
	 */</span>
	wqset = link-&gt;sl_wqs.sl_set;
	assert(wqset != NULL);

	<span class="enscript-keyword">if</span> (!waitq_irq_safe(waitq) &amp;&amp; waitq_irq_safe(&amp;wqset-&gt;wqset_q))
		spl = splsched();
	waitq_set_lock(wqset);

	ret = wctx-&gt;it(wctx-&gt;ctx, (<span class="enscript-type">struct</span> waitq *)wctx-&gt;input, wqset);

	waitq_set_unlock(wqset);
	<span class="enscript-keyword">if</span> (!waitq_irq_safe(waitq) &amp;&amp; waitq_irq_safe(&amp;wqset-&gt;wqset_q))
		splx(spl);

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/**
 * call external iterator function for each prepost object in wqset
 *
 * Conditions:
 *	Called from wq_prepost_foreach_locked
 *	(wqset locked, waitq _not_ locked)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wqset_iterate_prepost_cb</span>(<span class="enscript-type">struct</span> waitq_set *wqset, <span class="enscript-type">void</span> *ctx,
				    <span class="enscript-type">struct</span> wq_prepost *wqp, <span class="enscript-type">struct</span> waitq *waitq)
{
	<span class="enscript-type">struct</span> wq_it_ctx *wctx = (<span class="enscript-type">struct</span> wq_it_ctx *)(ctx);
	uint64_t wqp_id;
	<span class="enscript-type">int</span> ret;
	spl_t s;

	(<span class="enscript-type">void</span>)wqp;

	<span class="enscript-comment">/*
	 * This is a bit tricky. The 'wqset' is locked, but the 'waitq' is not.
	 * Taking the 'waitq' lock is a lock order violation, so we need to be
	 * careful. We also must realize that we may have taken a reference to
	 * the 'wqp' just as the associated waitq was being torn down (or
	 * clearing all its preposts) - see waitq_clear_prepost_locked(). If
	 * the 'wqp' is valid and we can get the waitq lock, then we are good
	 * to go. If not, we need to back off, check that the 'wqp' hasn't
	 * been invalidated, and try to re-take the locks.
	 */</span>
	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		s = splsched();
	<span class="enscript-keyword">if</span> (waitq_lock_try(waitq))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">call_iterator</span>;

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(s);

	<span class="enscript-keyword">if</span> (!wqp_is_valid(wqp))
		<span class="enscript-keyword">return</span> WQ_ITERATE_RESTART;

	<span class="enscript-comment">/* We are passed a prepost object with a reference on it. If neither
	 * the waitq set nor the waitq require interrupts disabled, then we
	 * may block on the delay(1) call below. We can't hold a prepost
	 * object reference while blocking, so we have to give that up as well
	 * and re-acquire it when we come back.
	 */</span>
	wqp_id = wqp-&gt;wqp_prepostid.id;
	wq_prepost_put(wqp);
	waitq_set_unlock(wqset);
	wqdbg_v(<span class="enscript-string">&quot;dropped set:%p lock waiting for wqp:%p (0x%llx -&gt; wq:%p)&quot;</span>,
		wqset, wqp, wqp-&gt;wqp_prepostid.id, waitq);
	delay(1);
	waitq_set_lock(wqset);
	wqp = wq_prepost_get(wqp_id);
	<span class="enscript-keyword">if</span> (!wqp)
		<span class="enscript-comment">/* someone cleared preposts while we slept! */</span>
		<span class="enscript-keyword">return</span> WQ_ITERATE_DROPPED;

	<span class="enscript-comment">/*
	 * TODO:
	 * This differs slightly from the logic in ipc_mqueue.c:
	 * ipc_mqueue_receive_on_thread(). There, if the waitq lock
	 * can't be obtained, the prepost link is placed on the back of
	 * the chain, and the iteration starts from the beginning. Here,
	 * we just restart from the beginning.
	 */</span>
	<span class="enscript-keyword">return</span> WQ_ITERATE_RESTART;

<span class="enscript-reference">call_iterator</span>:
	<span class="enscript-keyword">if</span> (!wqp_is_valid(wqp)) {
		ret = WQ_ITERATE_RESTART;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;
	}

	<span class="enscript-comment">/* call the external callback */</span>
	ret = wctx-&gt;it(wctx-&gt;ctx, waitq, wqset);

	<span class="enscript-keyword">if</span> (ret == WQ_ITERATE_BREAK_KEEP_LOCKED) {
		ret = WQ_ITERATE_BREAK;
		<span class="enscript-keyword">if</span> (wctx-&gt;spl)
			*(wctx-&gt;spl) = s;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

<span class="enscript-reference">out_unlock</span>:
	waitq_unlock(waitq);
	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(s);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/**
 * iterator over all sets to which the given waitq has been linked
 *
 * Conditions:
 * 	'waitq' is locked
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">waitq_iterate_sets</span>(<span class="enscript-type">struct</span> waitq *waitq, <span class="enscript-type">void</span> *ctx, waitq_iterator_t it)
{
	<span class="enscript-type">int</span> ret;
	<span class="enscript-type">struct</span> wq_it_ctx wctx = {
		.input = (<span class="enscript-type">void</span> *)waitq,
		.ctx = ctx,
		.it = it,
	};
	<span class="enscript-keyword">if</span> (!it || !waitq)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	ret = walk_setid_links(LINK_WALK_ONE_LEVEL, waitq, waitq-&gt;waitq_set_id,
			       SLT_WQS, (<span class="enscript-type">void</span> *)&amp;wctx, waitq_iterate_sets_cb);
	<span class="enscript-keyword">if</span> (ret == WQ_ITERATE_CONTINUE)
		ret = WQ_ITERATE_SUCCESS;
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/**
 * iterator over all preposts in the given wqset
 *
 * Conditions:
 * 	'wqset' is locked
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">waitq_set_iterate_preposts</span>(<span class="enscript-type">struct</span> waitq_set *wqset,
			       <span class="enscript-type">void</span> *ctx, waitq_iterator_t it, spl_t *s)
{
	<span class="enscript-type">struct</span> wq_it_ctx wctx = {
		.input = (<span class="enscript-type">void</span> *)wqset,
		.ctx = ctx,
		.it = it,
		.spl = s,
	};
	<span class="enscript-keyword">if</span> (!it || !wqset)
		<span class="enscript-keyword">return</span> WQ_ITERATE_INVALID;

	assert(waitq_held(&amp;wqset-&gt;wqset_q));

	<span class="enscript-keyword">return</span> wq_prepost_foreach_locked(wqset, (<span class="enscript-type">void</span> *)&amp;wctx,
					 wqset_iterate_prepost_cb);
}


<span class="enscript-comment">/* ----------------------------------------------------------------------
 *
 * Higher-level APIs
 *
 * ---------------------------------------------------------------------- */</span>

<span class="enscript-comment">/**
 * declare a thread's intent to wait on 'waitq' for 'wait_event'
 *
 * Conditions:
 *	'waitq' is not locked
 *	will disable and re-enable interrupts while locking current_thread()
 */</span>
wait_result_t <span class="enscript-function-name">waitq_assert_wait64</span>(<span class="enscript-type">struct</span> waitq *waitq,
				  event64_t wait_event,
				  wait_interrupt_t interruptible,
				  uint64_t deadline)
{
	wait_result_t ret;
	thread_t thread = current_thread();
	spl_t s;

	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		panic(<span class="enscript-string">&quot;Invalid waitq: %p&quot;</span>, waitq);

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		s = splsched();
	waitq_lock(waitq);

	<span class="enscript-keyword">if</span> (!waitq_irq_safe(waitq))
		s = splsched();
	thread_lock(thread);

	ret = waitq_assert_wait64_locked(waitq, wait_event, interruptible,
					 TIMEOUT_URGENCY_SYS_NORMAL,
					 deadline, TIMEOUT_NO_LEEWAY, thread);

	thread_unlock(thread);
	waitq_unlock(waitq);

	splx(s);

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/**
 * declare a thread's intent to wait on 'waitq' for 'wait_event'
 *
 * Conditions:
 *	'waitq' is not locked
 *	will disable and re-enable interrupts while locking current_thread()
 */</span>
wait_result_t <span class="enscript-function-name">waitq_assert_wait64_leeway</span>(<span class="enscript-type">struct</span> waitq *waitq,
					 event64_t wait_event,
					 wait_interrupt_t interruptible,
					 wait_timeout_urgency_t urgency,
					 uint64_t deadline,
					 uint64_t leeway)
{
	wait_result_t ret;
	thread_t thread = current_thread();
	spl_t s;

	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		panic(<span class="enscript-string">&quot;Invalid waitq: %p&quot;</span>, waitq);

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		s = splsched();
	waitq_lock(waitq);

	<span class="enscript-keyword">if</span> (!waitq_irq_safe(waitq))
		s = splsched();
	thread_lock(thread);

	ret = waitq_assert_wait64_locked(waitq, wait_event, interruptible,
					 urgency, deadline, leeway, thread);

	thread_unlock(thread);
	waitq_unlock(waitq);

	splx(s);

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/**
 * wakeup a single thread from a waitq that's waiting for a given event
 *
 * Conditions:
 *	'waitq' is not locked
 *	may (rarely) block if 'waitq' is non-global and a member of 1 or more sets
 *	may disable and re-enable interrupts
 *
 * Notes:
 *	will _not_ block if waitq is global (or not a member of any set)
 */</span>
kern_return_t <span class="enscript-function-name">waitq_wakeup64_one</span>(<span class="enscript-type">struct</span> waitq *waitq, event64_t wake_event,
				 wait_result_t result, <span class="enscript-type">int</span> priority)
{
	kern_return_t kr;
	uint64_t reserved_preposts = 0;
	spl_t spl;

	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		panic(<span class="enscript-string">&quot;Invalid waitq: %p&quot;</span>, waitq);

	<span class="enscript-comment">/* NOTE: this will _not_ reserve anything if waitq is global */</span>
	reserved_preposts = waitq_prepost_reserve(waitq, 0,
						  WAITQ_KEEP_LOCKED, &amp;spl);

	<span class="enscript-comment">/* waitq is locked upon return */</span>
	kr = waitq_wakeup64_one_locked(waitq, wake_event, result,
				       &amp;reserved_preposts, priority, WAITQ_UNLOCK);

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(spl);

	<span class="enscript-comment">/* release any left-over prepost object (won't block/lock anything) */</span>
	waitq_prepost_release_reserve(reserved_preposts);

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/**
 * wakeup all threads from a waitq that are waiting for a given event
 *
 * Conditions:
 *	'waitq' is not locked
 *	may (rarely) block if 'waitq' is non-global and a member of 1 or more sets
 *	may disable and re-enable interrupts
 *
 * Notes:
 *	will _not_ block if waitq is global (or not a member of any set)
 */</span>
kern_return_t <span class="enscript-function-name">waitq_wakeup64_all</span>(<span class="enscript-type">struct</span> waitq *waitq,
				 event64_t wake_event,
				 wait_result_t result,
				 <span class="enscript-type">int</span> priority)
{
	kern_return_t ret;
	uint64_t reserved_preposts = 0;
	spl_t s;

	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		panic(<span class="enscript-string">&quot;Invalid waitq: %p&quot;</span>, waitq);

	<span class="enscript-comment">/* keep waitq locked upon return */</span>
	<span class="enscript-comment">/* NOTE: this will _not_ reserve anything if waitq is global */</span>
	reserved_preposts = waitq_prepost_reserve(waitq, 0,
						  WAITQ_KEEP_LOCKED, &amp;s);

	<span class="enscript-comment">/* waitq is locked */</span>

	ret = waitq_wakeup64_all_locked(waitq, wake_event, result,
					&amp;reserved_preposts, priority,
					WAITQ_UNLOCK);

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(s);

	waitq_prepost_release_reserve(reserved_preposts);

	<span class="enscript-keyword">return</span> ret;

}

<span class="enscript-comment">/**
 * wakeup a specific thread iff it's waiting on 'waitq' for 'wake_event'
 *
 * Conditions:
 *	'waitq' is not locked
 *
 * Notes:
 *	May temporarily disable and re-enable interrupts
 */</span>
kern_return_t <span class="enscript-function-name">waitq_wakeup64_thread</span>(<span class="enscript-type">struct</span> waitq *waitq,
				    event64_t wake_event,
				    thread_t thread,
				    wait_result_t result)
{
	kern_return_t ret;
	spl_t s, th_spl;

	<span class="enscript-keyword">if</span> (!waitq_valid(waitq))
		panic(<span class="enscript-string">&quot;Invalid waitq: %p&quot;</span>, waitq);

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		s = splsched();
	waitq_lock(waitq);

	ret = waitq_select_thread_locked(waitq, wake_event, thread, &amp;th_spl);
	<span class="enscript-comment">/* on success, returns 'thread' locked */</span>

	waitq_unlock(waitq);

	<span class="enscript-keyword">if</span> (ret == KERN_SUCCESS) {
		ret = thread_go(thread, result);
		assert(ret == KERN_SUCCESS);
		thread_unlock(thread);
		splx(th_spl);
		waitq_stats_count_wakeup(waitq);
	} <span class="enscript-keyword">else</span> {
		ret = KERN_NOT_WAITING;
		waitq_stats_count_fail(waitq);
	}

	<span class="enscript-keyword">if</span> (waitq_irq_safe(waitq))
		splx(s);

	<span class="enscript-keyword">return</span> ret;
}
</pre>
<hr />
</body></html>