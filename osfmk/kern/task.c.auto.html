<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>task.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">task.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2010, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_FREE_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 *	File:	kern/task.c
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young, David Golub,
 *		David Black
 *
 *	Task management primitives implementation.
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1993 The University of Utah and
 * the Computer Systems Laboratory (CSL).  All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS &quot;AS
 * IS&quot; CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSL requests users of this software to return to <a href="mailto:csl-dist@cs.utah.edu">csl-dist@cs.utah.edu</a> any
 * improvements that they make and grant CSL redistribution rights.
 *
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 * Copyright (c) 2005 SPARTA, Inc.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine/vm_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/semaphore.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task_special_ports.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_importance.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_entry.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_hash.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/coalition.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_cdata.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>	<span class="enscript-comment">/* for thread_wakeup */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_tt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sync_lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/affinity.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/exc_resource.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;corpses/task_corpse.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TELEMETRY</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/telemetry.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>		<span class="enscript-comment">/* for kernel_map, ipc_kernel_map */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_purgeable_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resource.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span> <span class="enscript-comment">/* for coredump */</span>

<span class="enscript-comment">/*
 * Exported interfaces
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_host_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_security_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_port_server.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_shared_region.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ATM</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;atm/atm_internal.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sfi.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KPERF</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kpc_force_all_ctrs</span>(task_t, <span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span>

uint32_t qos_override_mode;

task_t			kernel_task;
zone_t			task_zone;
lck_attr_t      task_lck_attr;
lck_grp_t       task_lck_grp;
lck_grp_attr_t  task_lck_grp_attr;

<span class="enscript-comment">/* Flag set by core audio when audio is playing. Used to stifle EXC_RESOURCE generation when active. */</span>
<span class="enscript-type">int</span> audio_active = 0;

zinfo_usage_store_t tasks_tkm_private;
zinfo_usage_store_t tasks_tkm_shared;

<span class="enscript-comment">/* A container to accumulate statistics for expired tasks */</span>
expired_task_statistics_t		dead_task_statistics;
lck_spin_t		dead_task_statistics_lock;

ledger_template_t task_ledger_template = NULL;

<span class="enscript-type">struct</span> _task_ledger_indices task_ledgers <span class="enscript-function-name">__attribute__</span>((used)) =
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	 { 0 <span class="enscript-comment">/* initialized at runtime */</span>},
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_BANK</span>
	 -1, -1,
#<span class="enscript-reference">endif</span>
	};

<span class="enscript-type">void</span> <span class="enscript-function-name">init_task_ledgers</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">task_footprint_exceeded</span>(<span class="enscript-type">int</span> warning, __unused <span class="enscript-type">const</span> <span class="enscript-type">void</span> *param0, __unused <span class="enscript-type">const</span> <span class="enscript-type">void</span> *param1);
<span class="enscript-type">void</span> <span class="enscript-function-name">task_wakeups_rate_exceeded</span>(<span class="enscript-type">int</span> warning, __unused <span class="enscript-type">const</span> <span class="enscript-type">void</span> *param0, __unused <span class="enscript-type">const</span> <span class="enscript-type">void</span> *param1);
<span class="enscript-type">void</span> <span class="enscript-function-name">__attribute__</span>((noinline)) THIS_PROCESS_IS_CAUSING_TOO_MANY_WAKEUPS__SENDING_EXC_RESOURCE(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">__attribute__</span>((noinline)) PROC_CROSSED_HIGH_WATERMARK__SEND_EXC_RESOURCE_AND_SUSPEND(<span class="enscript-type">int</span> max_footprint_mb);

kern_return_t <span class="enscript-function-name">task_suspend_internal</span>(task_t);
kern_return_t <span class="enscript-function-name">task_resume_internal</span>(task_t);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">task_start_halt_locked</span>(task_t task, boolean_t should_mark_corpse);


<span class="enscript-type">void</span> <span class="enscript-function-name">proc_init_cpumon_params</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">exception_deliver</span>(thread_t, exception_type_t, mach_exception_data_t, mach_msg_type_number_t, <span class="enscript-type">struct</span> exception_action *, lck_mtx_t *);

<span class="enscript-comment">// Warn tasks when they hit 80% of their memory limit.
</span>#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PHYS_FOOTPRINT_WARNING_LEVEL</span> 80

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_WAKEUPS_MONITOR_DEFAULT_LIMIT</span>		150 <span class="enscript-comment">/* wakeups per second */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_WAKEUPS_MONITOR_DEFAULT_INTERVAL</span>	300 <span class="enscript-comment">/* in seconds. */</span>

<span class="enscript-comment">/*
 * Level (in terms of percentage of the limit) at which the wakeups monitor triggers telemetry.
 *
 * (ie when the task's wakeups rate exceeds 70% of the limit, start taking user
 *  stacktraces, aka micro-stackshots)
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TASK_WAKEUPS_MONITOR_DEFAULT_USTACKSHOTS_TRIGGER</span>	70

<span class="enscript-type">int</span> task_wakeups_monitor_interval; <span class="enscript-comment">/* In seconds. Time period over which wakeups rate is observed */</span>
<span class="enscript-type">int</span> task_wakeups_monitor_rate;     <span class="enscript-comment">/* In hz. Maximum allowable wakeups per task before EXC_RESOURCE is sent */</span>

<span class="enscript-type">int</span> task_wakeups_monitor_ustackshots_trigger_pct; <span class="enscript-comment">/* Percentage. Level at which we start gathering telemetry. */</span>

<span class="enscript-type">int</span> disable_exc_resource; <span class="enscript-comment">/* Global override to supress EXC_RESOURCE for resource monitor violations. */</span>

ledger_amount_t max_task_footprint = 0;  <span class="enscript-comment">/* Per-task limit on physical memory consumption in bytes     */</span>
<span class="enscript-type">int</span> max_task_footprint_mb = 0;  <span class="enscript-comment">/* Per-task limit on physical memory consumption in megabytes */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
<span class="enscript-type">int</span> pmap_ledgers_panic = 1;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>

<span class="enscript-type">int</span> task_max = CONFIG_TASK_MAX; <span class="enscript-comment">/* Max number of tasks */</span>

<span class="enscript-type">int</span> hwm_user_cores = 0; <span class="enscript-comment">/* high watermark violations generate user core files */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	proc_getexecutableuuid(<span class="enscript-type">void</span> *, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	proc_pid(<span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	proc_selfpid(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">char</span>	*proc_name_address(<span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">extern</span> uint64_t <span class="enscript-function-name">get_dispatchqueue_offset_from_proc</span>(<span class="enscript-type">void</span> *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	proc_memstat_terminated(<span class="enscript-type">struct</span> proc* p, boolean_t set);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	memorystatus_on_ledger_footprint_exceeded(<span class="enscript-type">int</span> warning, <span class="enscript-type">const</span> <span class="enscript-type">int</span> max_footprint_mb);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> pmap_ledgers_panic;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>

<span class="enscript-comment">/* Forwards */</span>

<span class="enscript-type">void</span>		task_hold_locked(
			task_t		task);
<span class="enscript-type">void</span>		task_wait_locked(
			task_t		task,
			boolean_t	until_not_runnable);
<span class="enscript-type">void</span>		task_release_locked(
			task_t		task);
<span class="enscript-type">void</span>		task_free(
			task_t		task );
<span class="enscript-type">void</span>		task_synchronizer_destroy_all(
			task_t		task);

<span class="enscript-type">int</span> <span class="enscript-function-name">check_for_tasksuspend</span>(
			task_t task);

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_backing_store_privileged</span>(
			task_t task)
{
	task_lock(task);
	task-&gt;priv_flags |= VM_BACKING_STORE_PRIV;
	task_unlock(task);
	<span class="enscript-keyword">return</span>;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">task_set_64bit</span>(
		task_t task,
		boolean_t is64bit)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__arm64__</span>)
	thread_t thread;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(__i386__) || defined(__x86_64__) || defined(__arm64__) */</span>

	task_lock(task);

	<span class="enscript-keyword">if</span> (is64bit) {
		<span class="enscript-keyword">if</span> (task_has_64BitAddr(task))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		task_set_64BitAddr(task);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ( !task_has_64BitAddr(task))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		task_clear_64BitAddr(task);
	}
	<span class="enscript-comment">/* FIXME: On x86, the thread save state flavor can diverge from the
	 * task's 64-bit feature flag due to the 32-bit/64-bit register save
	 * state dichotomy. Since we can be pre-empted in this interval,
	 * certain routines may observe the thread as being in an inconsistent
	 * state with respect to its task's 64-bitness.
	 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__arm64__</span>)	
	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
		thread_mtx_lock(thread);
		machine_thread_switch_addrmode(thread);
		thread_mtx_unlock(thread);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(__i386__) || defined(__x86_64__) || defined(__arm64__) */</span>	

<span class="enscript-reference">out</span>:
	task_unlock(task);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">task_set_dyld_info</span>(task_t task, mach_vm_address_t addr, mach_vm_size_t size)
{
	task_lock(task);
	task-&gt;all_image_info_addr = addr;
	task-&gt;all_image_info_size = size;
	task_unlock(task);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_atm_reset</span>(__unused task_t task) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ATM</span>
	<span class="enscript-keyword">if</span> (task-&gt;atm_context != NULL) {
		 atm_task_descriptor_destroy(task-&gt;atm_context);
		 task-&gt;atm_context = NULL;
	}
#<span class="enscript-reference">endif</span>

}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TASK_REFERENCE_LEAK_DEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/btlog.h&gt;</span>

<span class="enscript-function-name">decl_simple_lock_data</span>(<span class="enscript-type">static</span>,task_ref_lock);
<span class="enscript-type">static</span> btlog_t *task_ref_btlog;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_REF_OP_INCR</span>	0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_REF_OP_DECR</span>	0x2

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_REF_BTDEPTH</span>	7

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">task_ref_lock_lock</span>(<span class="enscript-type">void</span> *context)
{
	simple_lock((simple_lock_t)context);
}
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">task_ref_lock_unlock</span>(<span class="enscript-type">void</span> *context)
{
	simple_unlock((simple_lock_t)context);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_reference_internal</span>(task_t task)
{
	<span class="enscript-type">void</span> *       bt[TASK_REF_BTDEPTH];
	<span class="enscript-type">int</span>             numsaved = 0;

	numsaved = OSBacktrace(bt, TASK_REF_BTDEPTH);
	
	(<span class="enscript-type">void</span>)hw_atomic_add(&amp;(task)-&gt;ref_count, 1);
	btlog_add_entry(task_ref_btlog, task, TASK_REF_OP_INCR,
					bt, numsaved);
}

uint32_t
<span class="enscript-function-name">task_deallocate_internal</span>(task_t task)
{
	<span class="enscript-type">void</span> *       bt[TASK_REF_BTDEPTH];
	<span class="enscript-type">int</span>             numsaved = 0;

	numsaved = OSBacktrace(bt, TASK_REF_BTDEPTH);

	btlog_add_entry(task_ref_btlog, task, TASK_REF_OP_DECR,
					bt, numsaved);
	<span class="enscript-keyword">return</span> hw_atomic_sub(&amp;(task)-&gt;ref_count, 1);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TASK_REFERENCE_LEAK_DEBUG */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_init</span>(<span class="enscript-type">void</span>)
{

	lck_grp_attr_setdefault(&amp;task_lck_grp_attr);
	lck_grp_init(&amp;task_lck_grp, <span class="enscript-string">&quot;task&quot;</span>, &amp;task_lck_grp_attr);
	lck_attr_setdefault(&amp;task_lck_attr);
	lck_mtx_init(&amp;tasks_threads_lock, &amp;task_lck_grp, &amp;task_lck_attr);

	task_zone = zinit(
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> task),
			task_max * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> task),
			TASK_CHUNK * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> task),
			<span class="enscript-string">&quot;tasks&quot;</span>);

	zone_change(task_zone, Z_NOENCRYPT, TRUE);

	<span class="enscript-comment">/*
	 * Configure per-task memory limit.
	 * The boot-arg is interpreted as Megabytes,
	 * and takes precedence over the device tree.
	 * Setting the boot-arg to 0 disables task limits.
	 */</span>
	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;max_task_pmem&quot;</span>, &amp;max_task_footprint_mb,
			<span class="enscript-keyword">sizeof</span> (max_task_footprint_mb))) {
		<span class="enscript-comment">/*
		 * No limit was found in boot-args, so go look in the device tree.
		 */</span>
		<span class="enscript-keyword">if</span> (!PE_get_default(<span class="enscript-string">&quot;kern.max_task_pmem&quot;</span>, &amp;max_task_footprint_mb,
				<span class="enscript-keyword">sizeof</span>(max_task_footprint_mb))) {
			<span class="enscript-comment">/*
			 * No limit was found in device tree.
			 */</span>
			max_task_footprint_mb = 0;
		}
	}

	<span class="enscript-keyword">if</span> (max_task_footprint_mb != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
		<span class="enscript-keyword">if</span> (max_task_footprint_mb &lt; 50) {
				printf(<span class="enscript-string">&quot;Warning: max_task_pmem %d below minimum.\n&quot;</span>,
				max_task_footprint_mb);
				max_task_footprint_mb = 50;
		}
		printf(<span class="enscript-string">&quot;Limiting task physical memory footprint to %d MB\n&quot;</span>,
			max_task_footprint_mb);

		max_task_footprint = (ledger_amount_t)max_task_footprint_mb * 1024 * 1024; <span class="enscript-comment">// Convert MB to bytes
</span>#<span class="enscript-reference">else</span>
		printf(<span class="enscript-string">&quot;Warning: max_task_footprint specified, but jetsam not configured; ignoring.\n&quot;</span>);
#<span class="enscript-reference">endif</span>
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	PE_parse_boot_argn(<span class="enscript-string">&quot;pmap_ledgers_panic&quot;</span>, &amp;pmap_ledgers_panic,
			  <span class="enscript-keyword">sizeof</span> (pmap_ledgers_panic));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;hwm_user_cores&quot;</span>, &amp;hwm_user_cores,
			<span class="enscript-keyword">sizeof</span> (hwm_user_cores))) {
		hwm_user_cores = 0;
	}

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;qos_override_mode&quot;</span>, &amp;qos_override_mode, <span class="enscript-keyword">sizeof</span>(qos_override_mode))) {
		printf(<span class="enscript-string">&quot;QOS override mode: 0x%08x\n&quot;</span>, qos_override_mode);
	} <span class="enscript-keyword">else</span> {
		qos_override_mode = QOS_OVERRIDE_MODE_FINE_GRAINED_OVERRIDE_BUT_SINGLE_MUTEX_OVERRIDE;
	}

	proc_init_cpumon_params();

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;task_wakeups_monitor_rate&quot;</span>, &amp;task_wakeups_monitor_rate, <span class="enscript-keyword">sizeof</span> (task_wakeups_monitor_rate))) {
		task_wakeups_monitor_rate = TASK_WAKEUPS_MONITOR_DEFAULT_LIMIT;
	}

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;task_wakeups_monitor_interval&quot;</span>, &amp;task_wakeups_monitor_interval, <span class="enscript-keyword">sizeof</span> (task_wakeups_monitor_interval))) {
		task_wakeups_monitor_interval = TASK_WAKEUPS_MONITOR_DEFAULT_INTERVAL;
	}

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;task_wakeups_monitor_ustackshots_trigger_pct&quot;</span>, &amp;task_wakeups_monitor_ustackshots_trigger_pct,
		<span class="enscript-keyword">sizeof</span> (task_wakeups_monitor_ustackshots_trigger_pct))) {
		task_wakeups_monitor_ustackshots_trigger_pct = TASK_WAKEUPS_MONITOR_DEFAULT_USTACKSHOTS_TRIGGER;
	}

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;disable_exc_resource&quot;</span>, &amp;disable_exc_resource,
		<span class="enscript-keyword">sizeof</span> (disable_exc_resource))) {
		disable_exc_resource = 0;
	}

<span class="enscript-comment">/*
 * If we have coalitions, coalition_init() will call init_task_ledgers() as it
 * sets up the ledgers for the default coalition. If we don't have coalitions,
 * then we have to call it now.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_COALITIONS</span>
	assert(task_ledger_template);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* CONFIG_COALITIONS */</span>
	init_task_ledgers();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_COALITIONS */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TASK_REFERENCE_LEAK_DEBUG</span>
	simple_lock_init(&amp;task_ref_lock, 0);
	task_ref_btlog = btlog_create(100000,
								  TASK_REF_BTDEPTH,
								  task_ref_lock_lock,
								  task_ref_lock_unlock,
								  &amp;task_ref_lock);
	assert(task_ref_btlog);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Create the kernel task as the first task.
	 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-keyword">if</span> (task_create_internal(TASK_NULL, NULL, FALSE, TRUE, &amp;kernel_task) != KERN_SUCCESS)
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (task_create_internal(TASK_NULL, NULL, FALSE, FALSE, &amp;kernel_task) != KERN_SUCCESS)
#<span class="enscript-reference">endif</span>
		panic(<span class="enscript-string">&quot;task_init\n&quot;</span>);

	vm_map_deallocate(kernel_task-&gt;map);
	kernel_task-&gt;map = kernel_map;
	lck_spin_init(&amp;dead_task_statistics_lock, &amp;task_lck_grp, &amp;task_lck_attr);

}

<span class="enscript-comment">/*
 * Create a task running in the kernel address space.  It may
 * have its own map of size mem_size and may have ipc privileges.
 */</span>
kern_return_t
<span class="enscript-function-name">kernel_task_create</span>(
	__unused task_t		parent_task,
	__unused vm_offset_t		map_base,
	__unused vm_size_t		map_size,
	__unused task_t		*child_task)
{
	<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
}

kern_return_t
<span class="enscript-function-name">task_create</span>(
	task_t				parent_task,
	__unused ledger_port_array_t	ledger_ports,
	__unused mach_msg_type_number_t	num_ledger_ports,
	__unused boolean_t		inherit_memory,
	__unused task_t			*child_task)	<span class="enscript-comment">/* OUT */</span>
{
	<span class="enscript-keyword">if</span> (parent_task == TASK_NULL)
		<span class="enscript-keyword">return</span>(KERN_INVALID_ARGUMENT);

	<span class="enscript-comment">/*
	 * No longer supported: too many calls assume that a task has a valid
	 * process attached.
	 */</span>
	<span class="enscript-keyword">return</span>(KERN_FAILURE);
}

kern_return_t
<span class="enscript-function-name">host_security_create_task_token</span>(
	host_security_t			host_security,
	task_t				parent_task,
	__unused security_token_t	sec_token,
	__unused audit_token_t		audit_token,
	__unused host_priv_t		host_priv,
	__unused ledger_port_array_t	ledger_ports,
	__unused mach_msg_type_number_t	num_ledger_ports,
	__unused boolean_t		inherit_memory,
	__unused task_t			*child_task)	<span class="enscript-comment">/* OUT */</span>
{
	<span class="enscript-keyword">if</span> (parent_task == TASK_NULL)
		<span class="enscript-keyword">return</span>(KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (host_security == HOST_NULL)
		<span class="enscript-keyword">return</span>(KERN_INVALID_SECURITY);

	<span class="enscript-comment">/*
	 * No longer supported.
	 */</span>
	<span class="enscript-keyword">return</span>(KERN_FAILURE);
}

<span class="enscript-comment">/*
 * Task ledgers
 * ------------
 *
 * phys_footprint
 *   Physical footprint: This is the sum of:
 *     + (internal - alternate_accounting)
 *     + (internal_compressed - alternate_accounting_compressed)
 *     + iokit_mapped
 *     + purgeable_nonvolatile
 *     + purgeable_nonvolatile_compressed
 *
 * internal
 *   The task's anonymous memory, which on iOS is always resident.
 *
 * internal_compressed
 *   Amount of this task's internal memory which is held by the compressor.
 *   Such memory is no longer actually resident for the task [i.e., resident in its pmap],
 *   and could be either decompressed back into memory, or paged out to storage, depending
 *   on our implementation.
 *
 * iokit_mapped
 *   IOKit mappings: The total size of all IOKit mappings in this task, regardless of
     clean/dirty or internal/external state].
 *
 * alternate_accounting
 *   The number of internal dirty pages which are part of IOKit mappings. By definition, these pages
 *   are counted in both internal *and* iokit_mapped, so we must subtract them from the total to avoid
 *   double counting.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">init_task_ledgers</span>(<span class="enscript-type">void</span>)
{
	ledger_template_t t;
	
	assert(task_ledger_template == NULL);
	assert(kernel_task == TASK_NULL);

	<span class="enscript-keyword">if</span> ((t = ledger_template_create(<span class="enscript-string">&quot;Per-task ledger&quot;</span>)) == NULL)
		panic(<span class="enscript-string">&quot;couldn't create task ledger template&quot;</span>);

	task_ledgers.cpu_time = ledger_entry_add(t, <span class="enscript-string">&quot;cpu_time&quot;</span>, <span class="enscript-string">&quot;sched&quot;</span>, <span class="enscript-string">&quot;ns&quot;</span>);
	task_ledgers.tkm_private = ledger_entry_add(t, <span class="enscript-string">&quot;tkm_private&quot;</span>,
	    <span class="enscript-string">&quot;physmem&quot;</span>, <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.tkm_shared = ledger_entry_add(t, <span class="enscript-string">&quot;tkm_shared&quot;</span>, <span class="enscript-string">&quot;physmem&quot;</span>,
	    <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.phys_mem = ledger_entry_add(t, <span class="enscript-string">&quot;phys_mem&quot;</span>, <span class="enscript-string">&quot;physmem&quot;</span>,
	    <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.wired_mem = ledger_entry_add(t, <span class="enscript-string">&quot;wired_mem&quot;</span>, <span class="enscript-string">&quot;physmem&quot;</span>,
	    <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.internal = ledger_entry_add(t, <span class="enscript-string">&quot;internal&quot;</span>, <span class="enscript-string">&quot;physmem&quot;</span>,
	    <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.iokit_mapped = ledger_entry_add(t, <span class="enscript-string">&quot;iokit_mapped&quot;</span>, <span class="enscript-string">&quot;mappings&quot;</span>,
 	    <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.alternate_accounting = ledger_entry_add(t, <span class="enscript-string">&quot;alternate_accounting&quot;</span>, <span class="enscript-string">&quot;physmem&quot;</span>,
 	    <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.alternate_accounting_compressed = ledger_entry_add(t, <span class="enscript-string">&quot;alternate_accounting_compressed&quot;</span>, <span class="enscript-string">&quot;physmem&quot;</span>,
 	    <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.phys_footprint = ledger_entry_add(t, <span class="enscript-string">&quot;phys_footprint&quot;</span>, <span class="enscript-string">&quot;physmem&quot;</span>,
 	    <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.internal_compressed = ledger_entry_add(t, <span class="enscript-string">&quot;internal_compressed&quot;</span>, <span class="enscript-string">&quot;physmem&quot;</span>,
 	    <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.purgeable_volatile = ledger_entry_add(t, <span class="enscript-string">&quot;purgeable_volatile&quot;</span>, <span class="enscript-string">&quot;physmem&quot;</span>, <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.purgeable_nonvolatile = ledger_entry_add(t, <span class="enscript-string">&quot;purgeable_nonvolatile&quot;</span>, <span class="enscript-string">&quot;physmem&quot;</span>, <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.purgeable_volatile_compressed = ledger_entry_add(t, <span class="enscript-string">&quot;purgeable_volatile_compress&quot;</span>, <span class="enscript-string">&quot;physmem&quot;</span>, <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.purgeable_nonvolatile_compressed = ledger_entry_add(t, <span class="enscript-string">&quot;purgeable_nonvolatile_compress&quot;</span>, <span class="enscript-string">&quot;physmem&quot;</span>, <span class="enscript-string">&quot;bytes&quot;</span>);
	task_ledgers.platform_idle_wakeups = ledger_entry_add(t, <span class="enscript-string">&quot;platform_idle_wakeups&quot;</span>, <span class="enscript-string">&quot;power&quot;</span>,
 	    <span class="enscript-string">&quot;count&quot;</span>);
	task_ledgers.interrupt_wakeups = ledger_entry_add(t, <span class="enscript-string">&quot;interrupt_wakeups&quot;</span>, <span class="enscript-string">&quot;power&quot;</span>,
 	    <span class="enscript-string">&quot;count&quot;</span>);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SCHED_SFI</span>
	sfi_class_id_t class_id, ledger_alias;
	<span class="enscript-keyword">for</span> (class_id = SFI_CLASS_UNSPECIFIED; class_id &lt; MAX_SFI_CLASS_ID; class_id++) {
		task_ledgers.sfi_wait_times[class_id] = -1;
	}

	<span class="enscript-comment">/* don't account for UNSPECIFIED */</span>
	<span class="enscript-keyword">for</span> (class_id = SFI_CLASS_UNSPECIFIED + 1; class_id &lt; MAX_SFI_CLASS_ID; class_id++) {
		ledger_alias = sfi_get_ledger_alias_for_class(class_id);
		<span class="enscript-keyword">if</span> (ledger_alias != SFI_CLASS_UNSPECIFIED) {
			<span class="enscript-comment">/* Check to see if alias has been registered yet */</span>
			<span class="enscript-keyword">if</span> (task_ledgers.sfi_wait_times[ledger_alias] != -1) {
				task_ledgers.sfi_wait_times[class_id] = task_ledgers.sfi_wait_times[ledger_alias];
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Otherwise, initialize it first */</span>
				task_ledgers.sfi_wait_times[class_id] = task_ledgers.sfi_wait_times[ledger_alias] = sfi_ledger_entry_add(t, ledger_alias);
			}
		} <span class="enscript-keyword">else</span> {
			task_ledgers.sfi_wait_times[class_id] = sfi_ledger_entry_add(t, class_id);
		}

		<span class="enscript-keyword">if</span> (task_ledgers.sfi_wait_times[class_id] &lt; 0) {
			panic(<span class="enscript-string">&quot;couldn't create entries for task ledger template for SFI class 0x%x&quot;</span>, class_id);
		}
	}

	assert(task_ledgers.sfi_wait_times[MAX_SFI_CLASS_ID -1] != -1);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_SCHED_SFI */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_BANK</span>
	task_ledgers.cpu_time_billed_to_me = ledger_entry_add(t, <span class="enscript-string">&quot;cpu_time_billed_to_me&quot;</span>, <span class="enscript-string">&quot;sched&quot;</span>, <span class="enscript-string">&quot;ns&quot;</span>);
	task_ledgers.cpu_time_billed_to_others = ledger_entry_add(t, <span class="enscript-string">&quot;cpu_time_billed_to_others&quot;</span>, <span class="enscript-string">&quot;sched&quot;</span>, <span class="enscript-string">&quot;ns&quot;</span>);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((task_ledgers.cpu_time &lt; 0) ||
	    (task_ledgers.tkm_private &lt; 0) ||
	    (task_ledgers.tkm_shared &lt; 0) ||
	    (task_ledgers.phys_mem &lt; 0) ||
	    (task_ledgers.wired_mem &lt; 0) ||
	    (task_ledgers.internal &lt; 0) ||
	    (task_ledgers.iokit_mapped &lt; 0) ||
	    (task_ledgers.alternate_accounting &lt; 0) ||
	    (task_ledgers.alternate_accounting_compressed &lt; 0) ||
	    (task_ledgers.phys_footprint &lt; 0) ||
	    (task_ledgers.internal_compressed &lt; 0) ||
	    (task_ledgers.purgeable_volatile &lt; 0) ||
	    (task_ledgers.purgeable_nonvolatile &lt; 0) ||
	    (task_ledgers.purgeable_volatile_compressed &lt; 0) ||
	    (task_ledgers.purgeable_nonvolatile_compressed &lt; 0) ||
	    (task_ledgers.platform_idle_wakeups &lt; 0) ||
	    (task_ledgers.interrupt_wakeups &lt; 0)
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_BANK</span>
	    || (task_ledgers.cpu_time_billed_to_me &lt; 0) || (task_ledgers.cpu_time_billed_to_others &lt; 0)
#<span class="enscript-reference">endif</span>
	    ) {
		panic(<span class="enscript-string">&quot;couldn't create entries for task ledger template&quot;</span>);
	}

	ledger_track_maximum(t, task_ledgers.phys_footprint, 60);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">if</span> (pmap_ledgers_panic) {
		ledger_panic_on_negative(t, task_ledgers.phys_footprint);
		ledger_panic_on_negative(t, task_ledgers.internal);
		ledger_panic_on_negative(t, task_ledgers.internal_compressed);
		ledger_panic_on_negative(t, task_ledgers.iokit_mapped);
		ledger_panic_on_negative(t, task_ledgers.alternate_accounting);
		ledger_panic_on_negative(t, task_ledgers.alternate_accounting_compressed);
		ledger_panic_on_negative(t, task_ledgers.purgeable_volatile);
		ledger_panic_on_negative(t, task_ledgers.purgeable_nonvolatile);
		ledger_panic_on_negative(t, task_ledgers.purgeable_volatile_compressed);
		ledger_panic_on_negative(t, task_ledgers.purgeable_nonvolatile_compressed);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
	ledger_set_callback(t, task_ledgers.phys_footprint, task_footprint_exceeded, NULL, NULL);
#<span class="enscript-reference">endif</span>

	ledger_set_callback(t, task_ledgers.interrupt_wakeups,
		task_wakeups_rate_exceeded, NULL, NULL);
	
	task_ledger_template = t;
}

kern_return_t
<span class="enscript-function-name">task_create_internal</span>(
	task_t		parent_task,
	coalition_t	*parent_coalitions __unused,
	boolean_t	inherit_memory,
	boolean_t	is_64bit,
	task_t		*child_task)		<span class="enscript-comment">/* OUT */</span>
{
	task_t			new_task;
	vm_shared_region_t	shared_region;
	ledger_t		ledger = NULL;

	new_task = (task_t) zalloc(task_zone);

	<span class="enscript-keyword">if</span> (new_task == TASK_NULL)
		<span class="enscript-keyword">return</span>(KERN_RESOURCE_SHORTAGE);

	<span class="enscript-comment">/* one ref for just being alive; one for our caller */</span>
	new_task-&gt;ref_count = 2;

	<span class="enscript-comment">/* allocate with active entries */</span>
	assert(task_ledger_template != NULL);
	<span class="enscript-keyword">if</span> ((ledger = ledger_instantiate(task_ledger_template,
			LEDGER_CREATE_ACTIVE_ENTRIES)) == NULL) {
		zfree(task_zone, new_task);
		<span class="enscript-keyword">return</span>(KERN_RESOURCE_SHORTAGE);
	}

	new_task-&gt;ledger = ledger;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_SCHED_MULTIQ</span>)
	new_task-&gt;sched_group = sched_group_create();
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* if inherit_memory is true, parent_task MUST not be NULL */</span>
	<span class="enscript-keyword">if</span> (inherit_memory)
		new_task-&gt;map = vm_map_fork(ledger, parent_task-&gt;map);
	<span class="enscript-keyword">else</span>
		new_task-&gt;map = vm_map_create(pmap_create(ledger, 0, is_64bit),
				(vm_map_offset_t)(VM_MIN_ADDRESS),
				(vm_map_offset_t)(VM_MAX_ADDRESS), TRUE);

	<span class="enscript-comment">/* Inherit memlock limit from parent */</span>
	<span class="enscript-keyword">if</span> (parent_task)
		vm_map_set_user_wire_limit(new_task-&gt;map, (vm_size_t)parent_task-&gt;map-&gt;user_wire_limit);

	lck_mtx_init(&amp;new_task-&gt;lock, &amp;task_lck_grp, &amp;task_lck_attr);
	queue_init(&amp;new_task-&gt;threads);
	new_task-&gt;suspend_count = 0;
	new_task-&gt;thread_count = 0;
	new_task-&gt;active_thread_count = 0;
	new_task-&gt;user_stop_count = 0;
	new_task-&gt;legacy_stop_count = 0;
	new_task-&gt;active = TRUE;
	new_task-&gt;halting = FALSE;
	new_task-&gt;user_data = NULL;
	new_task-&gt;faults = 0;
	new_task-&gt;cow_faults = 0;
	new_task-&gt;pageins = 0;
	new_task-&gt;messages_sent = 0;
	new_task-&gt;messages_received = 0;
	new_task-&gt;syscalls_mach = 0;
	new_task-&gt;priv_flags = 0;
	new_task-&gt;syscalls_unix=0;
	new_task-&gt;c_switch = new_task-&gt;p_switch = new_task-&gt;ps_switch = 0;
	new_task-&gt;t_flags = 0;
	new_task-&gt;importance = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ATM</span>
	new_task-&gt;atm_context = NULL;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_BANK</span>
	new_task-&gt;bank_context = NULL;
#<span class="enscript-reference">endif</span>

	zinfo_task_init(new_task);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
	new_task-&gt;bsd_info = NULL;
	new_task-&gt;corpse_info = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_BSD */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
	<span class="enscript-keyword">if</span> (max_task_footprint != 0) {
		ledger_set_limit(ledger, task_ledgers.phys_footprint, max_task_footprint, PHYS_FOOTPRINT_WARNING_LEVEL);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (task_wakeups_monitor_rate != 0) {
		uint32_t flags = WAKEMON_ENABLE | WAKEMON_SET_DEFAULTS;
		int32_t  rate; <span class="enscript-comment">// Ignored because of WAKEMON_SET_DEFAULTS
</span>		task_wakeups_monitor_ctl(new_task, &amp;flags, &amp;rate);
	}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
	new_task-&gt;i386_ldt = 0;
#<span class="enscript-reference">endif</span>

	new_task-&gt;task_debug = NULL;

	queue_init(&amp;new_task-&gt;semaphore_list);
	new_task-&gt;semaphores_owned = 0;

	ipc_task_init(new_task, parent_task);

	new_task-&gt;total_user_time = 0;
	new_task-&gt;total_system_time = 0;

	new_task-&gt;vtimers = 0;

	new_task-&gt;shared_region = NULL;

	new_task-&gt;affinity_space = NULL;

	new_task-&gt;pidsuspended = FALSE;
	new_task-&gt;frozen = FALSE;
	new_task-&gt;changing_freeze_state = FALSE;
	new_task-&gt;rusage_cpu_flags = 0;
	new_task-&gt;rusage_cpu_percentage = 0;
	new_task-&gt;rusage_cpu_interval = 0;
	new_task-&gt;rusage_cpu_deadline = 0;
	new_task-&gt;rusage_cpu_callt = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	new_task-&gt;suspends_outstanding = 0;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HYPERVISOR</span>
	new_task-&gt;hv_task_target = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HYPERVISOR */</span>


	new_task-&gt;low_mem_notified_warn = 0;
	new_task-&gt;low_mem_notified_critical = 0;
	new_task-&gt;low_mem_privileged_listener = 0;
	new_task-&gt;purged_memory_warn = 0;
	new_task-&gt;purged_memory_critical = 0;
	new_task-&gt;mem_notify_reserved = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	new_task-&gt;task_imp_base = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

#<span class="enscript-reference">if</span>	<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)	
	new_task-&gt;uexc_range_start = new_task-&gt;uexc_range_size = new_task-&gt;uexc_handler = 0;
#<span class="enscript-reference">endif</span>

	new_task-&gt;requested_policy = default_task_requested_policy;
	new_task-&gt;effective_policy = default_task_effective_policy;
	new_task-&gt;pended_policy    = default_task_pended_policy;

	<span class="enscript-keyword">if</span> (parent_task != TASK_NULL) {
		new_task-&gt;sec_token = parent_task-&gt;sec_token;
		new_task-&gt;audit_token = parent_task-&gt;audit_token;

		<span class="enscript-comment">/* inherit the parent's shared region */</span>
		shared_region = vm_shared_region_get(parent_task);
		vm_shared_region_set(new_task, shared_region);

		<span class="enscript-keyword">if</span>(task_has_64BitAddr(parent_task))
			task_set_64BitAddr(new_task);
		new_task-&gt;all_image_info_addr = parent_task-&gt;all_image_info_addr;
		new_task-&gt;all_image_info_size = parent_task-&gt;all_image_info_size;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
		<span class="enscript-keyword">if</span> (inherit_memory &amp;&amp; parent_task-&gt;i386_ldt)
			new_task-&gt;i386_ldt = user_ldt_copy(parent_task-&gt;i386_ldt);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (inherit_memory &amp;&amp; parent_task-&gt;affinity_space)
			task_affinity_create(parent_task, new_task);

		new_task-&gt;pset_hint = parent_task-&gt;pset_hint = task_choose_pset(parent_task);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
		ipc_importance_task_t new_task_imp = IIT_NULL;

		<span class="enscript-keyword">if</span> (task_is_marked_importance_donor(parent_task)) {
			new_task_imp = ipc_importance_for_task(new_task, FALSE);
			assert(IIT_NULL != new_task_imp);
			ipc_importance_task_mark_donor(new_task_imp, TRUE);
		}
		<span class="enscript-comment">/* Embedded doesn't want this to inherit */</span>
		<span class="enscript-keyword">if</span> (task_is_marked_importance_receiver(parent_task)) {
			<span class="enscript-keyword">if</span> (IIT_NULL == new_task_imp)
				new_task_imp = ipc_importance_for_task(new_task, FALSE);
			assert(IIT_NULL != new_task_imp);
			ipc_importance_task_mark_receiver(new_task_imp, TRUE);
		}
		<span class="enscript-keyword">if</span> (task_is_marked_importance_denap_receiver(parent_task)) {
			<span class="enscript-keyword">if</span> (IIT_NULL == new_task_imp)
				new_task_imp = ipc_importance_for_task(new_task, FALSE);
			assert(IIT_NULL != new_task_imp);
			ipc_importance_task_mark_denap_receiver(new_task_imp, TRUE);
		}
		
		<span class="enscript-keyword">if</span> (IIT_NULL != new_task_imp) {
			assert(new_task-&gt;task_imp_base == new_task_imp);
			ipc_importance_task_release(new_task_imp);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

		new_task-&gt;priority = BASEPRI_DEFAULT;
		new_task-&gt;max_priority = MAXPRI_USER;

		new_task-&gt;requested_policy.t_apptype     = parent_task-&gt;requested_policy.t_apptype;

		new_task-&gt;requested_policy.int_darwinbg  = parent_task-&gt;requested_policy.int_darwinbg;
		new_task-&gt;requested_policy.ext_darwinbg  = parent_task-&gt;requested_policy.ext_darwinbg;
		new_task-&gt;requested_policy.int_iotier    = parent_task-&gt;requested_policy.int_iotier;
		new_task-&gt;requested_policy.ext_iotier    = parent_task-&gt;requested_policy.ext_iotier;
		new_task-&gt;requested_policy.int_iopassive = parent_task-&gt;requested_policy.int_iopassive;
		new_task-&gt;requested_policy.ext_iopassive = parent_task-&gt;requested_policy.ext_iopassive;
		new_task-&gt;requested_policy.bg_iotier     = parent_task-&gt;requested_policy.bg_iotier;
		new_task-&gt;requested_policy.terminated    = parent_task-&gt;requested_policy.terminated;
		new_task-&gt;requested_policy.t_qos_clamp   = parent_task-&gt;requested_policy.t_qos_clamp;

		task_policy_create(new_task, parent_task-&gt;requested_policy.t_boosted);
	} <span class="enscript-keyword">else</span> {
		new_task-&gt;sec_token = KERNEL_SECURITY_TOKEN;
		new_task-&gt;audit_token = KERNEL_AUDIT_TOKEN;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
		<span class="enscript-keyword">if</span>(is_64bit)
			task_set_64BitAddr(new_task);
#<span class="enscript-reference">endif</span>
		new_task-&gt;all_image_info_addr = (mach_vm_address_t)0;
		new_task-&gt;all_image_info_size = (mach_vm_size_t)0;

		new_task-&gt;pset_hint = PROCESSOR_SET_NULL;

		<span class="enscript-keyword">if</span> (kernel_task == TASK_NULL) {
			new_task-&gt;priority = BASEPRI_KERNEL;
			new_task-&gt;max_priority = MAXPRI_KERNEL;
		} <span class="enscript-keyword">else</span> {
			new_task-&gt;priority = BASEPRI_DEFAULT;
			new_task-&gt;max_priority = MAXPRI_USER;
		}
	}

	bzero(new_task-&gt;coalition, <span class="enscript-keyword">sizeof</span>(new_task-&gt;coalition));
	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; COALITION_NUM_TYPES; i++)
		queue_chain_init(new_task-&gt;task_coalition[i]);

	<span class="enscript-comment">/* Allocate I/O Statistics */</span>
	new_task-&gt;task_io_stats = (io_stat_info_t)kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> io_stat_info));
	assert(new_task-&gt;task_io_stats != NULL);
	bzero(new_task-&gt;task_io_stats, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> io_stat_info));

	bzero(&amp;(new_task-&gt;cpu_time_qos_stats), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> _cpu_time_qos_stats));

	bzero(&amp;new_task-&gt;extmod_statistics, <span class="enscript-keyword">sizeof</span>(new_task-&gt;extmod_statistics));
	new_task-&gt;task_timer_wakeups_bin_1 = new_task-&gt;task_timer_wakeups_bin_2 = 0;
	new_task-&gt;task_gpu_ns = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_COALITIONS</span>

	<span class="enscript-comment">/* TODO: there is no graceful failure path here... */</span>
	<span class="enscript-keyword">if</span> (parent_coalitions &amp;&amp; parent_coalitions[COALITION_TYPE_RESOURCE]) {
		coalitions_adopt_task(parent_coalitions, new_task);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (parent_task &amp;&amp; parent_task-&gt;coalition[COALITION_TYPE_RESOURCE]) {
		<span class="enscript-comment">/*
		 * all tasks at least have a resource coalition, so
		 * if the parent has one then inherit all coalitions
		 * the parent is a part of
		 */</span>
		coalitions_adopt_task(parent_task-&gt;coalition, new_task);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* TODO: assert that new_task will be PID 1 (launchd) */</span>
		coalitions_adopt_init_task(new_task);
	}

	<span class="enscript-keyword">if</span> (new_task-&gt;coalition[COALITION_TYPE_RESOURCE] == COALITION_NULL) {
		panic(<span class="enscript-string">&quot;created task is not a member of a resource coalition&quot;</span>);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_COALITIONS */</span>

	new_task-&gt;dispatchqueue_offset = 0;
	<span class="enscript-keyword">if</span> (parent_task != NULL) {
		new_task-&gt;dispatchqueue_offset = parent_task-&gt;dispatchqueue_offset;
	}

	<span class="enscript-keyword">if</span> (vm_backing_store_low &amp;&amp; parent_task != NULL)
		new_task-&gt;priv_flags |= (parent_task-&gt;priv_flags&amp;VM_BACKING_STORE_PRIV);

	new_task-&gt;task_volatile_objects = 0;
	new_task-&gt;task_nonvolatile_objects = 0;
	new_task-&gt;task_purgeable_disowning = FALSE;
	new_task-&gt;task_purgeable_disowned = FALSE;

	ipc_task_enable(new_task);

	lck_mtx_lock(&amp;tasks_threads_lock);
	queue_enter(&amp;tasks, new_task, task_t, tasks);
	tasks_count++;
	lck_mtx_unlock(&amp;tasks_threads_lock);

	*child_task = new_task;
	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}

<span class="enscript-type">int</span> task_dropped_imp_count = 0;

<span class="enscript-comment">/*
 *	task_deallocate:
 *
 *	Drop a reference on a task.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_deallocate</span>(
	task_t		task)
{
	ledger_amount_t credit, debit, interrupt_wakeups, platform_idle_wakeups;
	uint32_t refs;

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
	    <span class="enscript-keyword">return</span>;

	refs = task_deallocate_internal(task);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	<span class="enscript-keyword">if</span> (refs &gt; 1)
		<span class="enscript-keyword">return</span>;
	
	<span class="enscript-keyword">if</span> (refs == 1) {
		<span class="enscript-comment">/*
		 * If last ref potentially comes from the task's importance,
		 * disconnect it.  But more task refs may be added before
		 * that completes, so wait for the reference to go to zero
		 * naturually (it may happen on a recursive task_deallocate()
		 * from the ipc_importance_disconnect_task() call).
		 */</span>
		<span class="enscript-keyword">if</span> (IIT_NULL != task-&gt;task_imp_base)
			ipc_importance_disconnect_task(task);
		<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (refs &gt; 0)
		<span class="enscript-keyword">return</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

	lck_mtx_lock(&amp;tasks_threads_lock);
	queue_remove(&amp;terminated_tasks, task, task_t, tasks);
	terminated_tasks_count--;
	lck_mtx_unlock(&amp;tasks_threads_lock);

	<span class="enscript-comment">/*
	 * remove the reference on atm descriptor
	 */</span>
	 task_atm_reset(task);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_BANK</span>
	<span class="enscript-comment">/*
	 * remove the reference on bank context
	 */</span>
	<span class="enscript-keyword">if</span> (task-&gt;bank_context != NULL) {
		bank_task_destroy(task-&gt;bank_context);
		task-&gt;bank_context = NULL;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (task-&gt;task_io_stats)
		kfree(task-&gt;task_io_stats, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> io_stat_info));

	<span class="enscript-comment">/*
	 *	Give the machine dependent code a chance
	 *	to perform cleanup before ripping apart
	 *	the task.
	 */</span>
	machine_task_terminate(task);

	ipc_task_terminate(task);

	<span class="enscript-keyword">if</span> (task-&gt;affinity_space)
		task_affinity_deallocate(task);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">if</span> (task-&gt;ledger != NULL &amp;&amp;
	    task-&gt;map != NULL &amp;&amp;
	    task-&gt;map-&gt;pmap != NULL &amp;&amp;
	    task-&gt;map-&gt;pmap-&gt;ledger != NULL) {
		assert(task-&gt;ledger == task-&gt;map-&gt;pmap-&gt;ledger);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>

	vm_purgeable_disown(task);
	assert(task-&gt;task_purgeable_disowned);
	<span class="enscript-keyword">if</span> (task-&gt;task_volatile_objects != 0 ||
	    task-&gt;task_nonvolatile_objects != 0) {
		panic(<span class="enscript-string">&quot;task_deallocate(%p): &quot;</span>
		      <span class="enscript-string">&quot;volatile_objects=%d nonvolatile_objects=%d\n&quot;</span>,
		      task,
		      task-&gt;task_volatile_objects,
		      task-&gt;task_nonvolatile_objects);
	}

	vm_map_deallocate(task-&gt;map);
	is_release(task-&gt;itk_space);

	ledger_get_entries(task-&gt;ledger, task_ledgers.interrupt_wakeups,
	                   &amp;interrupt_wakeups, &amp;debit);
	ledger_get_entries(task-&gt;ledger, task_ledgers.platform_idle_wakeups,
	                   &amp;platform_idle_wakeups, &amp;debit);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_SCHED_MULTIQ</span>)
	sched_group_destroy(task-&gt;sched_group);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Accumulate statistics for dead tasks */</span>
	lck_spin_lock(&amp;dead_task_statistics_lock);
	dead_task_statistics.total_user_time += task-&gt;total_user_time;
	dead_task_statistics.total_system_time += task-&gt;total_system_time;

	dead_task_statistics.task_interrupt_wakeups += interrupt_wakeups;
	dead_task_statistics.task_platform_idle_wakeups += platform_idle_wakeups;

	dead_task_statistics.task_timer_wakeups_bin_1 += task-&gt;task_timer_wakeups_bin_1;
	dead_task_statistics.task_timer_wakeups_bin_2 += task-&gt;task_timer_wakeups_bin_2;

	lck_spin_unlock(&amp;dead_task_statistics_lock);
	lck_mtx_destroy(&amp;task-&gt;lock, &amp;task_lck_grp);

	<span class="enscript-keyword">if</span> (!ledger_get_entries(task-&gt;ledger, task_ledgers.tkm_private, &amp;credit,
	    &amp;debit)) {
		OSAddAtomic64(credit, (int64_t *)&amp;tasks_tkm_private.alloc);
		OSAddAtomic64(debit, (int64_t *)&amp;tasks_tkm_private.free);
	}
	<span class="enscript-keyword">if</span> (!ledger_get_entries(task-&gt;ledger, task_ledgers.tkm_shared, &amp;credit,
	    &amp;debit)) {
		OSAddAtomic64(credit, (int64_t *)&amp;tasks_tkm_shared.alloc);
		OSAddAtomic64(debit, (int64_t *)&amp;tasks_tkm_shared.free);
	}
	ledger_dereference(task-&gt;ledger);
	zinfo_task_free(task);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TASK_REFERENCE_LEAK_DEBUG</span>
	btlog_remove_entries_for_element(task_ref_btlog, task);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_COALITIONS</span>
	<span class="enscript-keyword">if</span> (!task-&gt;coalition[COALITION_TYPE_RESOURCE])
		panic(<span class="enscript-string">&quot;deallocating task was not a member of a resource coalition&quot;</span>);
	task_release_coalitions(task);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_COALITIONS */</span>

	bzero(task-&gt;coalition, <span class="enscript-keyword">sizeof</span>(task-&gt;coalition));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_BSD</span>
	<span class="enscript-comment">/* clean up collected information since last reference to task is gone */</span>
	<span class="enscript-keyword">if</span> (task-&gt;corpse_info) {
		task_crashinfo_destroy(task-&gt;corpse_info);
		task-&gt;corpse_info = NULL;
	}
#<span class="enscript-reference">endif</span>

	zfree(task_zone, task);
}

<span class="enscript-comment">/*
 *	task_name_deallocate:
 *
 *	Drop a reference on a task name.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_name_deallocate</span>(
	task_name_t		task_name)
{
	<span class="enscript-keyword">return</span>(task_deallocate((task_t)task_name));
}

<span class="enscript-comment">/*
 *	task_suspension_token_deallocate:
 *
 *	Drop a reference on a task suspension token.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_suspension_token_deallocate</span>(
	task_suspension_token_t		token)
{
	<span class="enscript-keyword">return</span>(task_deallocate((task_t)token));
}


<span class="enscript-comment">/*
 * task_collect_crash_info:
 *
 * collect crash info from bsd and mach based data
 */</span>
kern_return_t
<span class="enscript-function-name">task_collect_crash_info</span>(task_t task)
{
	kern_return_t kr = KERN_SUCCESS;

	kcdata_descriptor_t crash_data = NULL;
	kcdata_descriptor_t crash_data_release = NULL;
	mach_msg_type_number_t size = CORPSEINFO_ALLOCATION_SIZE;
	mach_vm_offset_t crash_data_user_ptr = 0;

	<span class="enscript-keyword">if</span> (!corpses_enabled()) {
		<span class="enscript-keyword">return</span> KERN_NOT_SUPPORTED;
	}

	task_lock(task);
	assert(task-&gt;bsd_info != NULL);
	<span class="enscript-keyword">if</span> (task-&gt;corpse_info == NULL &amp;&amp; task-&gt;bsd_info != NULL) {
		task_unlock(task);
		<span class="enscript-comment">/* map crash data memory in task's vm map */</span>
		kr = mach_vm_allocate(task-&gt;map, &amp;crash_data_user_ptr, size, (VM_MAKE_TAG(VM_MEMORY_CORPSEINFO) | VM_FLAGS_ANYWHERE));

		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_no_lock</span>;

		crash_data = task_crashinfo_alloc_init((mach_vm_address_t)crash_data_user_ptr, size);
		<span class="enscript-keyword">if</span> (crash_data) {
			task_lock(task);
			crash_data_release = task-&gt;corpse_info;
			task-&gt;corpse_info = crash_data;
			task_unlock(task);
			kr = KERN_SUCCESS;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* if failed to create corpse info, free the mapping */</span>
			<span class="enscript-keyword">if</span> (KERN_SUCCESS != mach_vm_deallocate(task-&gt;map, crash_data_user_ptr, size)) {
				printf(<span class="enscript-string">&quot;mach_vm_deallocate failed to clear corpse_data for pid %d.\n&quot;</span>, task_pid(task));
			}
			kr = KERN_FAILURE;
		}

		<span class="enscript-keyword">if</span> (crash_data_release != NULL) {
			task_crashinfo_destroy(crash_data_release);
		}
	} <span class="enscript-keyword">else</span> {
		task_unlock(task);
	}

<span class="enscript-reference">out_no_lock</span>:
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 * task_deliver_crash_notification:
 *
 * Makes outcall to registered host port for a corpse.
 */</span>
kern_return_t
<span class="enscript-function-name">task_deliver_crash_notification</span>(task_t task)
{
	kcdata_descriptor_t crash_info = task-&gt;corpse_info;
	thread_t th_iter = NULL;
	kern_return_t kr = KERN_SUCCESS;
	wait_interrupt_t wsave;
	mach_exception_data_type_t code[EXCEPTION_CODE_MAX];

	<span class="enscript-keyword">if</span> (crash_info == NULL)
		<span class="enscript-keyword">return</span> KERN_FAILURE;

	code[0] = crash_info-&gt;kcd_addr_begin;
	code[1] = crash_info-&gt;kcd_length;

	task_lock(task);
	queue_iterate(&amp;task-&gt;threads, th_iter, thread_t, task_threads)
	{
		ipc_thread_reset(th_iter);
	}
	task_unlock(task);

	wsave = thread_interrupt_level(THREAD_UNINT);
	kr = exception_triage(EXC_CORPSE_NOTIFY, code, EXCEPTION_CODE_MAX);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		printf(<span class="enscript-string">&quot;Failed to send exception EXC_CORPSE_NOTIFY. error code: %d for pid %d\n&quot;</span>, kr, task_pid(task));
	}

	<span class="enscript-comment">/*
	 * crash reporting is done. Now release threads
	 * for reaping by thread_terminate_daemon
	 */</span>
	task_lock(task);
	assert(task-&gt;active_thread_count == 0);
	queue_iterate(&amp;task-&gt;threads, th_iter, thread_t, task_threads)
	{
		thread_mtx_lock(th_iter);
		assert(th_iter-&gt;inspection == TRUE);
		th_iter-&gt;inspection = FALSE;
		<span class="enscript-comment">/* now that the corpse has been autopsied, dispose of the thread name */</span>
		uthread_cleanup_name(th_iter-&gt;uthread);
		thread_mtx_unlock(th_iter);
	}

	thread_terminate_crashed_threads();
	<span class="enscript-comment">/* remove the pending corpse report flag */</span>
	task_clear_corpse_pending_report(task);

	task_unlock(task);

	(<span class="enscript-type">void</span>)thread_interrupt_level(wsave);
	task_terminate_internal(task);

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 *	task_terminate:
 *
 *	Terminate the specified task.  See comments on thread_terminate
 *	(kern/thread.c) about problems with terminating the &quot;current task.&quot;
 */</span>

kern_return_t
<span class="enscript-function-name">task_terminate</span>(
	task_t		task)
{
	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (task-&gt;bsd_info)
		<span class="enscript-keyword">return</span> (KERN_FAILURE);

	<span class="enscript-keyword">return</span> (task_terminate_internal(task));
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_pid</span>(<span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_name_kdp</span>(task_t t, <span class="enscript-type">char</span> *buf, <span class="enscript-type">int</span> size);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_MAP_PARTIAL_REAP</span> 0x54  <span class="enscript-comment">/* 0x150 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
__unused task_partial_reap(task_t task, __unused <span class="enscript-type">int</span> pid)
{
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    reclaimed_resident = 0;
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    reclaimed_compressed = 0;
	uint64_t        task_page_count;

	task_page_count = (get_task_phys_footprint(task) / PAGE_SIZE_64);

	KERNEL_DEBUG_CONSTANT((MACHDBG_CODE(DBG_MACH_VM, VM_MAP_PARTIAL_REAP) | DBG_FUNC_START),
                              pid, task_page_count, 0, 0, 0);

	vm_map_partial_reap(task-&gt;map, &amp;reclaimed_resident, &amp;reclaimed_compressed);

        KERNEL_DEBUG_CONSTANT((MACHDBG_CODE(DBG_MACH_VM, VM_MAP_PARTIAL_REAP) | DBG_FUNC_END),
                              pid, reclaimed_resident, reclaimed_compressed, 0, 0);
}

kern_return_t
<span class="enscript-function-name">task_mark_corpse</span>(task_t task)
{
	kern_return_t kr = KERN_SUCCESS;
	thread_t self_thread;
	(<span class="enscript-type">void</span>) self_thread;
	wait_interrupt_t wsave;

	assert(task != kernel_task);
	assert(task == current_task());
	assert(!task_is_a_corpse(task));

	kr = task_collect_crash_info(task);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		<span class="enscript-keyword">return</span> kr;
	}

	self_thread = current_thread();

	wsave = thread_interrupt_level(THREAD_UNINT);
	task_lock(task);

	task_set_corpse_pending_report(task);
	task_set_corpse(task);

	kr = task_start_halt_locked(task, TRUE);
	assert(kr == KERN_SUCCESS);
	ipc_task_reset(task);
	ipc_task_enable(task);

	task_unlock(task);
	<span class="enscript-comment">/* terminate the ipc space */</span>
	ipc_space_terminate(task-&gt;itk_space);
	
	task_start_halt(task);
	thread_terminate_internal(self_thread);
	(<span class="enscript-type">void</span>) thread_interrupt_level(wsave);
	assert(task-&gt;halting == TRUE);
	<span class="enscript-keyword">return</span> kr;
}

kern_return_t
<span class="enscript-function-name">task_terminate_internal</span>(
	task_t			task)
{
	thread_t			thread, self;
	task_t				self_task;
	boolean_t			interrupt_save;
	<span class="enscript-type">int</span>				pid = 0;

	assert(task != kernel_task);

	self = current_thread();
	self_task = self-&gt;task;

	<span class="enscript-comment">/*
	 *	Get the task locked and make sure that we are not racing
	 *	with someone else trying to terminate us.
	 */</span>
	<span class="enscript-keyword">if</span> (task == self_task)
		task_lock(task);
	<span class="enscript-keyword">else</span>
	<span class="enscript-keyword">if</span> (task &lt; self_task) {
		task_lock(task);
		task_lock(self_task);
	}
	<span class="enscript-keyword">else</span> {
		task_lock(self_task);
		task_lock(task);
	}

	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		<span class="enscript-comment">/*
		 *	Task is already being terminated.
		 *	Just return an error. If we are dying, this will
		 *	just get us to our AST special handler and that
		 *	will get us to finalize the termination of ourselves.
		 */</span>
		task_unlock(task);
		<span class="enscript-keyword">if</span> (self_task != task)
			task_unlock(self_task);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	<span class="enscript-keyword">if</span> (task_corpse_pending_report(task)) {
		<span class="enscript-comment">/*
		 *	Task is marked for reporting as corpse.
		 *	Just return an error. This will
		 *	just get us to our AST special handler and that
		 *	will get us to finish the path to death
		 */</span>
		task_unlock(task);
		<span class="enscript-keyword">if</span> (self_task != task)
			task_unlock(self_task);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	<span class="enscript-keyword">if</span> (self_task != task)
		task_unlock(self_task);

	<span class="enscript-comment">/*
	 * Make sure the current thread does not get aborted out of
	 * the waits inside these operations.
	 */</span>
	interrupt_save = thread_interrupt_level(THREAD_UNINT);

	<span class="enscript-comment">/*
	 *	Indicate that we want all the threads to stop executing
	 *	at user space by holding the task (we would have held
	 *	each thread independently in thread_terminate_internal -
	 *	but this way we may be more likely to already find it
	 *	held there).  Mark the task inactive, and prevent
	 *	further task operations via the task port.
	 */</span>
	task_hold_locked(task);
	task-&gt;active = FALSE;
	ipc_task_disable(task);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TELEMETRY</span>
	<span class="enscript-comment">/*
	 * Notify telemetry that this task is going away.
	 */</span>
	telemetry_task_ctl_locked(task, TF_TELEMETRY, 0);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 *	Terminate each thread in the task.
	 */</span>
	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
			thread_terminate_internal(thread);
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
	<span class="enscript-keyword">if</span> (task-&gt;bsd_info != NULL) {
		pid = proc_pid(task-&gt;bsd_info);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_BSD */</span>

	task_unlock(task);

	proc_set_task_policy(task, THREAD_NULL, TASK_POLICY_ATTRIBUTE,
			     TASK_POLICY_TERMINATED, TASK_POLICY_ENABLE);

        <span class="enscript-comment">/* Early object reap phase */</span>

<span class="enscript-comment">// PR-17045188: Revisit implementation
</span><span class="enscript-comment">//        task_partial_reap(task, pid);
</span>

	<span class="enscript-comment">/*
	 *	Destroy all synchronizers owned by the task.
	 */</span>
	task_synchronizer_destroy_all(task);

	<span class="enscript-comment">/*
	 *	Destroy the IPC space, leaving just a reference for it.
	 */</span>
	ipc_space_terminate(task-&gt;itk_space);

#<span class="enscript-reference">if</span> 00
	<span class="enscript-comment">/* if some ledgers go negative on tear-down again... */</span>
	ledger_disable_panic_on_negative(task-&gt;map-&gt;pmap-&gt;ledger,
					 task_ledgers.phys_footprint);
	ledger_disable_panic_on_negative(task-&gt;map-&gt;pmap-&gt;ledger,
					 task_ledgers.internal);
	ledger_disable_panic_on_negative(task-&gt;map-&gt;pmap-&gt;ledger,
					 task_ledgers.internal_compressed);
	ledger_disable_panic_on_negative(task-&gt;map-&gt;pmap-&gt;ledger,
					 task_ledgers.iokit_mapped);
	ledger_disable_panic_on_negative(task-&gt;map-&gt;pmap-&gt;ledger,
					 task_ledgers.alternate_accounting);
	ledger_disable_panic_on_negative(task-&gt;map-&gt;pmap-&gt;ledger,
					 task_ledgers.alternate_accounting_compressed);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * If the current thread is a member of the task
	 * being terminated, then the last reference to
	 * the task will not be dropped until the thread
	 * is finally reaped.  To avoid incurring the
	 * expense of removing the address space regions
	 * at reap time, we do it explictly here.
	 */</span>

	vm_map_lock(task-&gt;map);
	vm_map_disable_hole_optimization(task-&gt;map);
	vm_map_unlock(task-&gt;map);

	vm_map_remove(task-&gt;map,
		      task-&gt;map-&gt;min_offset,
		      task-&gt;map-&gt;max_offset,
		      <span class="enscript-comment">/* no unnesting on final cleanup: */</span>
		      VM_MAP_REMOVE_NO_UNNESTING);

	<span class="enscript-comment">/* release our shared region */</span>
	vm_shared_region_set(task, NULL);


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-comment">/*
	 * Identify the pmap's process, in case the pmap ledgers drift
	 * and we have to report it.
	 */</span>
	<span class="enscript-type">char</span> procname[17];
	<span class="enscript-keyword">if</span> (task-&gt;bsd_info) {
		pid = proc_pid(task-&gt;bsd_info);
		proc_name_kdp(task, procname, <span class="enscript-keyword">sizeof</span> (procname));
	} <span class="enscript-keyword">else</span> {
		pid = 0;
		strlcpy(procname, <span class="enscript-string">&quot;&lt;unknown&gt;&quot;</span>, <span class="enscript-keyword">sizeof</span> (procname));
	}
	pmap_set_process(task-&gt;map-&gt;pmap, pid, procname);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>

	lck_mtx_lock(&amp;tasks_threads_lock);
	queue_remove(&amp;tasks, task, task_t, tasks);
	queue_enter(&amp;terminated_tasks, task, task_t, tasks);
	tasks_count--;
	terminated_tasks_count++;
	lck_mtx_unlock(&amp;tasks_threads_lock);

	<span class="enscript-comment">/*
	 * We no longer need to guard against being aborted, so restore
	 * the previous interruptible state.
	 */</span>
	thread_interrupt_level(interrupt_save);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KPERF</span>
	<span class="enscript-comment">/* force the task to release all ctrs */</span>
	<span class="enscript-keyword">if</span> (task-&gt;t_chud &amp; TASK_KPC_FORCED_ALL_CTRS)
		kpc_force_all_ctrs(task, 0);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_COALITIONS</span>
	<span class="enscript-comment">/*
	 * Leave our coalitions. (drop activation but not reference)
	 */</span>
	coalitions_remove_task(task);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Get rid of the task active reference on itself.
	 */</span>
	task_deallocate(task);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * task_start_halt:
 *
 * 	Shut the current task down (except for the current thread) in
 *	preparation for dramatic changes to the task (probably exec).
 *	We hold the task and mark all other threads in the task for
 *	termination.
 */</span>
kern_return_t
<span class="enscript-function-name">task_start_halt</span>(task_t task)
{
	kern_return_t kr = KERN_SUCCESS;
	task_lock(task);
	kr = task_start_halt_locked(task, FALSE);
	task_unlock(task);
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">task_start_halt_locked</span>(task_t task, boolean_t should_mark_corpse)
{
	thread_t thread, self;
	uint64_t dispatchqueue_offset;

	assert(task != kernel_task);

	self = current_thread();

	<span class="enscript-keyword">if</span> (task != self-&gt;task)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (task-&gt;halting || !task-&gt;active || !self-&gt;active) {
		<span class="enscript-comment">/*
		 * Task or current thread is already being terminated.
		 * Hurry up and return out of the current kernel context
		 * so that we run our AST special handler to terminate
		 * ourselves.
		 */</span>
		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	task-&gt;halting = TRUE;

	<span class="enscript-comment">/*
	 * Mark all the threads to keep them from starting any more
	 * user-level execution.  The thread_terminate_internal code
	 * would do this on a thread by thread basis anyway, but this
	 * gives us a better chance of not having to wait there.
	 */</span>
	task_hold_locked(task);
	dispatchqueue_offset = get_dispatchqueue_offset_from_proc(task-&gt;bsd_info);

	<span class="enscript-comment">/*
	 * Terminate all the other threads in the task.
	 */</span>
	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads)
	{
		<span class="enscript-keyword">if</span> (should_mark_corpse) {
			thread_mtx_lock(thread);
			thread-&gt;inspection = TRUE;
			thread_mtx_unlock(thread);
		}
		<span class="enscript-keyword">if</span> (thread != self)
			thread_terminate_internal(thread);
	}
	task-&gt;dispatchqueue_offset = dispatchqueue_offset;

	task_release_locked(task);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-comment">/*
 * task_complete_halt:
 *
 *	Complete task halt by waiting for threads to terminate, then clean
 *	up task resources (VM, port namespace, etc...) and then let the
 *	current thread go in the (practically empty) task context.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_complete_halt</span>(task_t task)
{
	task_lock(task);
	assert(task-&gt;halting);
	assert(task == current_task());

	<span class="enscript-comment">/*
	 *	Wait for the other threads to get shut down.
	 *      When the last other thread is reaped, we'll be
	 *	woken up.
	 */</span>
	<span class="enscript-keyword">if</span> (task-&gt;thread_count &gt; 1) {
		assert_wait((event_t)&amp;task-&gt;halting, THREAD_UNINT);
		task_unlock(task);
		thread_block(THREAD_CONTINUE_NULL);
	} <span class="enscript-keyword">else</span> {
		task_unlock(task);
	}

	<span class="enscript-comment">/*
	 *	Give the machine dependent code a chance
	 *	to perform cleanup of task-level resources
	 *	associated with the current thread before
	 *	ripping apart the task.
	 */</span>
	machine_task_terminate(task);

	<span class="enscript-comment">/*
	 *	Destroy all synchronizers owned by the task.
	 */</span>
	task_synchronizer_destroy_all(task);

	<span class="enscript-comment">/*
	 *	Destroy the contents of the IPC space, leaving just
	 *	a reference for it.
	 */</span>
	ipc_space_clean(task-&gt;itk_space);

	<span class="enscript-comment">/*
	 * Clean out the address space, as we are going to be
	 * getting a new one.
	 */</span>
	vm_map_remove(task-&gt;map, task-&gt;map-&gt;min_offset,
		      task-&gt;map-&gt;max_offset,
		      <span class="enscript-comment">/* no unnesting on final cleanup: */</span>
		      VM_MAP_REMOVE_NO_UNNESTING);

	task-&gt;halting = FALSE;
}

<span class="enscript-comment">/*
 *	task_hold_locked:
 *
 *	Suspend execution of the specified task.
 *	This is a recursive-style suspension of the task, a count of
 *	suspends is maintained.
 *
 * 	CONDITIONS: the task is locked and active.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_hold_locked</span>(
	<span class="enscript-type">register</span> task_t		task)
{
	<span class="enscript-type">register</span> thread_t	thread;

	assert(task-&gt;active);

	<span class="enscript-keyword">if</span> (task-&gt;suspend_count++ &gt; 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 *	Iterate through all the threads and hold them.
	 */</span>
	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
		thread_mtx_lock(thread);
		thread_hold(thread);
		thread_mtx_unlock(thread);
	}
}

<span class="enscript-comment">/*
 *	task_hold:
 *
 *	Same as the internal routine above, except that is must lock
 *	and verify that the task is active.  This differs from task_suspend
 *	in that it places a kernel hold on the task rather than just a 
 *	user-level hold.  This keeps users from over resuming and setting
 *	it running out from under the kernel.
 *
 * 	CONDITIONS: the caller holds a reference on the task
 */</span>
kern_return_t
<span class="enscript-function-name">task_hold</span>(
	<span class="enscript-type">register</span> task_t		task)
{
	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	task_lock(task);

	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		task_unlock(task);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	task_hold_locked(task);
	task_unlock(task);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">task_wait</span>(
		task_t		task,
		boolean_t	until_not_runnable)
{
	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	task_lock(task);

	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		task_unlock(task);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	task_wait_locked(task, until_not_runnable);
	task_unlock(task);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 *	task_wait_locked:
 *
 *	Wait for all threads in task to stop.
 *
 * Conditions:
 *	Called with task locked, active, and held.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_wait_locked</span>(
	<span class="enscript-type">register</span> task_t		task,
	boolean_t		until_not_runnable)
{
	<span class="enscript-type">register</span> thread_t	thread, self;

	assert(task-&gt;active);
	assert(task-&gt;suspend_count &gt; 0);

	self = current_thread();

	<span class="enscript-comment">/*
	 *	Iterate through all the threads and wait for them to
	 *	stop.  Do not wait for the current thread if it is within
	 *	the task.
	 */</span>
	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
		<span class="enscript-keyword">if</span> (thread != self)
			thread_wait(thread, until_not_runnable);
	}
}

<span class="enscript-comment">/*
 *	task_release_locked:
 *
 *	Release a kernel hold on a task.
 *
 * 	CONDITIONS: the task is locked and active
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_release_locked</span>(
	<span class="enscript-type">register</span> task_t		task)
{
	<span class="enscript-type">register</span> thread_t	thread;

	assert(task-&gt;active);
	assert(task-&gt;suspend_count &gt; 0);

	<span class="enscript-keyword">if</span> (--task-&gt;suspend_count &gt; 0)
		<span class="enscript-keyword">return</span>;

	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
		thread_mtx_lock(thread);
		thread_release(thread);
		thread_mtx_unlock(thread);
	}
}

<span class="enscript-comment">/*
 *	task_release:
 *
 *	Same as the internal routine above, except that it must lock
 *	and verify that the task is active.
 *
 * 	CONDITIONS: The caller holds a reference to the task
 */</span>
kern_return_t
<span class="enscript-function-name">task_release</span>(
	task_t		task)
{
	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	task_lock(task);

	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		task_unlock(task);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	task_release_locked(task);
	task_unlock(task);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">task_threads</span>(
	task_t					task,
	thread_act_array_t		*threads_out,
	mach_msg_type_number_t	*count)
{
	mach_msg_type_number_t	actual;
	thread_t				*thread_list;
	thread_t				thread;
	vm_size_t				size, size_needed;
	<span class="enscript-type">void</span>					*addr;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			i, j;

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	size = 0; addr = NULL;

	<span class="enscript-keyword">for</span> (;;) {
		task_lock(task);
		<span class="enscript-keyword">if</span> (!task-&gt;active) {
			task_unlock(task);

			<span class="enscript-keyword">if</span> (size != 0)
				kfree(addr, size);

			<span class="enscript-keyword">return</span> (KERN_FAILURE);
		}

		actual = task-&gt;thread_count;

		<span class="enscript-comment">/* do we have the memory we need? */</span>
		size_needed = actual * <span class="enscript-keyword">sizeof</span> (mach_port_t);
		<span class="enscript-keyword">if</span> (size_needed &lt;= size)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* unlock the task and allocate more memory */</span>
		task_unlock(task);

		<span class="enscript-keyword">if</span> (size != 0)
			kfree(addr, size);

		assert(size_needed &gt; 0);
		size = size_needed;

		addr = kalloc(size);
		<span class="enscript-keyword">if</span> (addr == 0)
			<span class="enscript-keyword">return</span> (KERN_RESOURCE_SHORTAGE);
	}

	<span class="enscript-comment">/* OK, have memory and the task is locked &amp; active */</span>
	thread_list = (thread_t *)addr;

	i = j = 0;

	<span class="enscript-keyword">for</span> (thread = (thread_t)queue_first(&amp;task-&gt;threads); i &lt; actual;
				++i, thread = (thread_t)queue_next(&amp;thread-&gt;task_threads)) {
		thread_reference_internal(thread);
		thread_list[j++] = thread;
	}

	assert(queue_end(&amp;task-&gt;threads, (queue_entry_t)thread));

	actual = j;
	size_needed = actual * <span class="enscript-keyword">sizeof</span> (mach_port_t);

	<span class="enscript-comment">/* can unlock task now that we've got the thread refs */</span>
	task_unlock(task);

	<span class="enscript-keyword">if</span> (actual == 0) {
		<span class="enscript-comment">/* no threads, so return null pointer and deallocate memory */</span>

		*threads_out = NULL;
		*count = 0;

		<span class="enscript-keyword">if</span> (size != 0)
			kfree(addr, size);
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* if we allocated too much, must copy */</span>

		<span class="enscript-keyword">if</span> (size_needed &lt; size) {
			<span class="enscript-type">void</span> *newaddr;

			newaddr = kalloc(size_needed);
			<span class="enscript-keyword">if</span> (newaddr == 0) {
				<span class="enscript-keyword">for</span> (i = 0; i &lt; actual; ++i)
					thread_deallocate(thread_list[i]);
				kfree(addr, size);
				<span class="enscript-keyword">return</span> (KERN_RESOURCE_SHORTAGE);
			}

			bcopy(addr, newaddr, size_needed);
			kfree(addr, size);
			thread_list = (thread_t *)newaddr;
		}

		*threads_out = thread_list;
		*count = actual;

		<span class="enscript-comment">/* do the conversion that Mig should handle */</span>

		<span class="enscript-keyword">for</span> (i = 0; i &lt; actual; ++i)
			((ipc_port_t *) thread_list)[i] = convert_thread_to_port(thread_list[i]);
	}

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_HOLD_NORMAL</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_HOLD_PIDSUSPEND</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_HOLD_LEGACY</span>	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_HOLD_LEGACY_ALL</span>	3

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">place_task_hold</span>    (
	<span class="enscript-type">register</span> task_t task,
	<span class="enscript-type">int</span> mode)
{    
	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
	    MACHDBG_CODE(DBG_MACH_IPC,MACH_TASK_SUSPEND) | DBG_FUNC_NONE,
	    task_pid(task), ((thread_t)queue_first(&amp;task-&gt;threads))-&gt;thread_id,
	    task-&gt;user_stop_count, task-&gt;user_stop_count + 1, 0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	current_task()-&gt;suspends_outstanding++;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (mode == TASK_HOLD_LEGACY)
		task-&gt;legacy_stop_count++;

	<span class="enscript-keyword">if</span> (task-&gt;user_stop_count++ &gt; 0) {
		<span class="enscript-comment">/*
		 *	If the stop count was positive, the task is
		 *	already stopped and we can exit.
		 */</span>
		<span class="enscript-keyword">return</span> (KERN_SUCCESS);
	}

	<span class="enscript-comment">/*
	 * Put a kernel-level hold on the threads in the task (all
	 * user-level task suspensions added together represent a
	 * single kernel-level hold).  We then wait for the threads
	 * to stop executing user code.
	 */</span>
	task_hold_locked(task);
	task_wait_locked(task, FALSE);
	
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">release_task_hold</span>    (
	<span class="enscript-type">register</span> task_t		task,
	<span class="enscript-type">int</span>           		mode)
{
	<span class="enscript-type">register</span> boolean_t release = FALSE;
    
	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}
	
	<span class="enscript-keyword">if</span> (mode == TASK_HOLD_PIDSUSPEND) {
	    <span class="enscript-keyword">if</span> (task-&gt;pidsuspended == FALSE) {
		    <span class="enscript-keyword">return</span> (KERN_FAILURE);
	    }
	    task-&gt;pidsuspended = FALSE;
	}

	<span class="enscript-keyword">if</span> (task-&gt;user_stop_count &gt; (task-&gt;pidsuspended ? 1 : 0)) {

		KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
		    MACHDBG_CODE(DBG_MACH_IPC,MACH_TASK_RESUME) | DBG_FUNC_NONE,
		    task_pid(task), ((thread_t)queue_first(&amp;task-&gt;threads))-&gt;thread_id,
		    task-&gt;user_stop_count, mode, task-&gt;legacy_stop_count);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
		<span class="enscript-comment">/*
		 * This is obviously not robust; if we suspend one task and then resume a different one,
		 * we'll fly under the radar. This is only meant to catch the common case of a crashed
		 * or buggy suspender.
		 */</span>
		current_task()-&gt;suspends_outstanding--;
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">if</span> (mode == TASK_HOLD_LEGACY_ALL) {
			<span class="enscript-keyword">if</span> (task-&gt;legacy_stop_count &gt;= task-&gt;user_stop_count) {
				task-&gt;user_stop_count = 0;
				release = TRUE;
			} <span class="enscript-keyword">else</span> {
				task-&gt;user_stop_count -= task-&gt;legacy_stop_count;
			}
			task-&gt;legacy_stop_count = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (mode == TASK_HOLD_LEGACY &amp;&amp; task-&gt;legacy_stop_count &gt; 0)
				task-&gt;legacy_stop_count--;
			<span class="enscript-keyword">if</span> (--task-&gt;user_stop_count == 0)
				release = TRUE;
		}
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	<span class="enscript-comment">/*
	 *	Release the task if necessary.
	 */</span>
	<span class="enscript-keyword">if</span> (release)
		task_release_locked(task);
		
    <span class="enscript-keyword">return</span> (KERN_SUCCESS);
}


<span class="enscript-comment">/*
 *	task_suspend:
 *
 *	Implement an (old-fashioned) user-level suspension on a task.
 *
 *	Because the user isn't expecting to have to manage a suspension
 *	token, we'll track it for him in the kernel in the form of a naked
 *	send right to the task's resume port.  All such send rights
 *	account for a single suspension against the task (unlike task_suspend2()
 *	where each caller gets a unique suspension count represented by a
 *	unique send-once right).
 *
 * Conditions:
 * 	The caller holds a reference to the task
 */</span>
kern_return_t
<span class="enscript-function-name">task_suspend</span>(
	<span class="enscript-type">register</span> task_t		task)
{
	kern_return_t	 		kr;
	mach_port_t			port, send, old_notify;
	mach_port_name_t		name;

	<span class="enscript-keyword">if</span> (task == TASK_NULL || task == kernel_task)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	task_lock(task);

	<span class="enscript-comment">/* 
	 * Claim a send right on the task resume port, and request a no-senders
	 * notification on that port (if none outstanding). 
	 */</span>
	<span class="enscript-keyword">if</span> (task-&gt;itk_resume == IP_NULL) {
		task-&gt;itk_resume = ipc_port_alloc_kernel();
		<span class="enscript-keyword">if</span> (!IP_VALID(task-&gt;itk_resume))
			panic(<span class="enscript-string">&quot;failed to create resume port&quot;</span>);
		ipc_kobject_set(task-&gt;itk_resume, (ipc_kobject_t)task, IKOT_TASK_RESUME);
	}

	port = task-&gt;itk_resume;
	ip_lock(port);
	assert(ip_active(port));

	send = ipc_port_make_send_locked(port);
	assert(IP_VALID(send));

	<span class="enscript-keyword">if</span> (port-&gt;ip_nsrequest == IP_NULL) {
		ipc_port_nsrequest(port, port-&gt;ip_mscount, ipc_port_make_sonce_locked(port), &amp;old_notify);
		assert(old_notify == IP_NULL);
		<span class="enscript-comment">/* port unlocked */</span>
	} <span class="enscript-keyword">else</span> {
		ip_unlock(port);
	}

	<span class="enscript-comment">/*
	 * place a legacy hold on the task.
	 */</span>
	kr = place_task_hold(task, TASK_HOLD_LEGACY);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		task_unlock(task);
		ipc_port_release_send(send);
		<span class="enscript-keyword">return</span> kr;
	}

	task_unlock(task);

	<span class="enscript-comment">/*
	 * Copyout the send right into the calling task's IPC space.  It won't know it is there,
	 * but we'll look it up when calling a traditional resume.  Any IPC operations that
	 * deallocate the send right will auto-release the suspension.
	 */</span>
	<span class="enscript-keyword">if</span> ((kr = ipc_kmsg_copyout_object(current_task()-&gt;itk_space, (ipc_object_t)send,
		MACH_MSG_TYPE_MOVE_SEND, &amp;name)) != KERN_SUCCESS) {
		printf(<span class="enscript-string">&quot;warning: %s(%d) failed to copyout suspension token for pid %d with error: %d\n&quot;</span>,
				proc_name_address(current_task()-&gt;bsd_info), proc_pid(current_task()-&gt;bsd_info),
				task_pid(task), kr);
		<span class="enscript-keyword">return</span> (kr);
	}

	<span class="enscript-keyword">return</span> (kr);
}

<span class="enscript-comment">/*
 *	task_resume:
 *		Release a user hold on a task.
 *		
 * Conditions:
 *		The caller holds a reference to the task
 */</span>
kern_return_t 
<span class="enscript-function-name">task_resume</span>(
	<span class="enscript-type">register</span> task_t	task)
{
	kern_return_t	 kr;
	mach_port_name_t resume_port_name;
	ipc_entry_t		 resume_port_entry;
	ipc_space_t		 space = current_task()-&gt;itk_space;

	<span class="enscript-keyword">if</span> (task == TASK_NULL || task == kernel_task )
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-comment">/* release a legacy task hold */</span>
	task_lock(task);
	kr = release_task_hold(task, TASK_HOLD_LEGACY);
	task_unlock(task);

	is_write_lock(space);
	<span class="enscript-keyword">if</span> (is_active(space) &amp;&amp; IP_VALID(task-&gt;itk_resume) &amp;&amp;
	    ipc_hash_lookup(space, (ipc_object_t)task-&gt;itk_resume, &amp;resume_port_name, &amp;resume_port_entry) == TRUE) {
		<span class="enscript-comment">/*
		 * We found a suspension token in the caller's IPC space. Release a send right to indicate that
		 * we are holding one less legacy hold on the task from this caller.  If the release failed,
		 * go ahead and drop all the rights, as someone either already released our holds or the task
		 * is gone.
		 */</span>
		<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS)
			ipc_right_dealloc(space, resume_port_name, resume_port_entry);
		<span class="enscript-keyword">else</span>
			ipc_right_destroy(space, resume_port_name, resume_port_entry, FALSE, 0);
		<span class="enscript-comment">/* space unlocked */</span>
	} <span class="enscript-keyword">else</span> {
		is_write_unlock(space);
		<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS)
			printf(<span class="enscript-string">&quot;warning: %s(%d) performed out-of-band resume on pid %d\n&quot;</span>,
			       proc_name_address(current_task()-&gt;bsd_info), proc_pid(current_task()-&gt;bsd_info),
			       task_pid(task));
	}

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 * Suspend the target task.
 * Making/holding a token/reference/port is the callers responsibility.
 */</span>
kern_return_t
<span class="enscript-function-name">task_suspend_internal</span>(task_t task)
{
	kern_return_t	 kr;
       
	<span class="enscript-keyword">if</span> (task == TASK_NULL || task == kernel_task)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	task_lock(task);
	kr = place_task_hold(task, TASK_HOLD_NORMAL);
	task_unlock(task);
	<span class="enscript-keyword">return</span> (kr);
}

<span class="enscript-comment">/*
 * Suspend the target task, and return a suspension token. The token
 * represents a reference on the suspended task.
 */</span>
kern_return_t
<span class="enscript-function-name">task_suspend2</span>(
	<span class="enscript-type">register</span> task_t			task,
	task_suspension_token_t *suspend_token)
{
	kern_return_t	 kr;
 
	kr = task_suspend_internal(task);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		*suspend_token = TASK_NULL;
		<span class="enscript-keyword">return</span> (kr);
	}

	<span class="enscript-comment">/*
	 * Take a reference on the target task and return that to the caller
	 * as a &quot;suspension token,&quot; which can be converted into an SO right to
	 * the now-suspended task's resume port.
	 */</span>
	task_reference_internal(task);
	*suspend_token = task;

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Resume the task
 * (reference/token/port management is caller's responsibility).
 */</span>
kern_return_t
<span class="enscript-function-name">task_resume_internal</span>(
	<span class="enscript-type">register</span> task_suspension_token_t		task)
{
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (task == TASK_NULL || task == kernel_task)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	task_lock(task);
	kr = release_task_hold(task, TASK_HOLD_NORMAL);
	task_unlock(task);
	<span class="enscript-keyword">return</span> (kr);
}

<span class="enscript-comment">/*
 * Resume the task using a suspension token. Consumes the token's ref.
 */</span>
kern_return_t
<span class="enscript-function-name">task_resume2</span>(
	<span class="enscript-type">register</span> task_suspension_token_t		task)
{
	kern_return_t kr;

	kr = task_resume_internal(task);
	task_suspension_token_deallocate(task);

	<span class="enscript-keyword">return</span> (kr);
}

boolean_t
<span class="enscript-function-name">task_suspension_notify</span>(mach_msg_header_t *request_header)
{
	ipc_port_t port = (ipc_port_t) request_header-&gt;msgh_remote_port;
	task_t task = convert_port_to_task_suspension_token(port);
	mach_msg_type_number_t not_count;

	<span class="enscript-keyword">if</span> (task == TASK_NULL || task == kernel_task)
		<span class="enscript-keyword">return</span> TRUE;  <span class="enscript-comment">/* nothing to do */</span>

	<span class="enscript-keyword">switch</span> (request_header-&gt;msgh_id) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_NOTIFY_SEND_ONCE</span>:
		<span class="enscript-comment">/* release the hold held by this specific send-once right */</span>
		task_lock(task);
		release_task_hold(task, TASK_HOLD_NORMAL);
		task_unlock(task);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_NOTIFY_NO_SENDERS</span>:
		not_count = ((mach_no_senders_notification_t *)request_header)-&gt;not_count;

		task_lock(task);
		ip_lock(port);
		<span class="enscript-keyword">if</span> (port-&gt;ip_mscount == not_count) {

			<span class="enscript-comment">/* release all the [remaining] outstanding legacy holds */</span>
			assert(port-&gt;ip_nsrequest == IP_NULL);
			ip_unlock(port);
			release_task_hold(task, TASK_HOLD_LEGACY_ALL);
			task_unlock(task);

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (port-&gt;ip_nsrequest == IP_NULL) {
			ipc_port_t old_notify;

			task_unlock(task);
			<span class="enscript-comment">/* new send rights, re-arm notification at current make-send count */</span>
			ipc_port_nsrequest(port, port-&gt;ip_mscount, ipc_port_make_sonce_locked(port), &amp;old_notify);
			assert(old_notify == IP_NULL);
			<span class="enscript-comment">/* port unlocked */</span>
		} <span class="enscript-keyword">else</span> {
			ip_unlock(port);
			task_unlock(task);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	task_suspension_token_deallocate(task); <span class="enscript-comment">/* drop token reference */</span>
	<span class="enscript-keyword">return</span> TRUE;
}

kern_return_t
<span class="enscript-function-name">task_pidsuspend_locked</span>(task_t task)
{
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (task-&gt;pidsuspended) {
		kr = KERN_FAILURE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	task-&gt;pidsuspended = TRUE;

	kr = place_task_hold(task, TASK_HOLD_PIDSUSPEND);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		task-&gt;pidsuspended = FALSE;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span>(kr);
}


<span class="enscript-comment">/*
 *	task_pidsuspend:
 *
 *	Suspends a task by placing a hold on its threads.
 *
 * Conditions:
 * 	The caller holds a reference to the task
 */</span>
kern_return_t
<span class="enscript-function-name">task_pidsuspend</span>(
	<span class="enscript-type">register</span> task_t		task)
{
	kern_return_t	 kr;
    
	<span class="enscript-keyword">if</span> (task == TASK_NULL || task == kernel_task)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	task_lock(task);

	kr = task_pidsuspend_locked(task);

	task_unlock(task);

	<span class="enscript-keyword">return</span> (kr);
}

<span class="enscript-comment">/* If enabled, we bring all the frozen pages back in prior to resumption; otherwise, they're faulted back in on demand */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">THAW_ON_RESUME</span> 1

<span class="enscript-comment">/*
 *	task_pidresume:
 *		Resumes a previously suspended task.
 *		
 * Conditions:
 *		The caller holds a reference to the task
 */</span>
kern_return_t 
<span class="enscript-function-name">task_pidresume</span>(
	<span class="enscript-type">register</span> task_t	task)
{
	kern_return_t	 kr;

	<span class="enscript-keyword">if</span> (task == TASK_NULL || task == kernel_task)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	task_lock(task);
	
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">CONFIG_FREEZE</span> &amp;&amp; <span class="enscript-variable-name">THAW_ON_RESUME</span>)

	<span class="enscript-keyword">while</span> (task-&gt;changing_freeze_state) {

		assert_wait((event_t)&amp;task-&gt;changing_freeze_state, THREAD_UNINT);
		task_unlock(task);
		thread_block(THREAD_CONTINUE_NULL);

		task_lock(task);
	}
	task-&gt;changing_freeze_state = TRUE;
#<span class="enscript-reference">endif</span>

	kr = release_task_hold(task, TASK_HOLD_PIDSUSPEND);

	task_unlock(task);

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">CONFIG_FREEZE</span> &amp;&amp; <span class="enscript-variable-name">THAW_ON_RESUME</span>)
	<span class="enscript-keyword">if</span> ((kr == KERN_SUCCESS) &amp;&amp; (task-&gt;frozen == TRUE)) {

		<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE) {

			kr = KERN_SUCCESS;
		} <span class="enscript-keyword">else</span> {

			kr = vm_map_thaw(task-&gt;map);
		}
	}
	task_lock(task);

	<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS)
		task-&gt;frozen = FALSE;
	task-&gt;changing_freeze_state = FALSE;
	thread_wakeup(&amp;task-&gt;changing_freeze_state);
	
	task_unlock(task);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (kr);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>

<span class="enscript-comment">/*
 *	task_freeze:
 *
 *	Freeze a task.
 *
 * Conditions:
 * 	The caller holds a reference to the task
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_wake_compactor_swapper();
<span class="enscript-type">extern</span> queue_head_t	c_swapout_list_head;

kern_return_t
<span class="enscript-function-name">task_freeze</span>(
	<span class="enscript-type">register</span> task_t    task,
	uint32_t           *purgeable_count,
	uint32_t           *wired_count,
	uint32_t           *clean_count,
	uint32_t           *dirty_count,
	uint32_t           dirty_budget,
	boolean_t          *shared,
	boolean_t          walk_only)
{
	kern_return_t kr;
    
	<span class="enscript-keyword">if</span> (task == TASK_NULL || task == kernel_task)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	task_lock(task);

	<span class="enscript-keyword">while</span> (task-&gt;changing_freeze_state) {

		assert_wait((event_t)&amp;task-&gt;changing_freeze_state, THREAD_UNINT);
		task_unlock(task);
		thread_block(THREAD_CONTINUE_NULL);

		task_lock(task);
	}
	<span class="enscript-keyword">if</span> (task-&gt;frozen) {
		task_unlock(task);
		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}
	task-&gt;changing_freeze_state = TRUE;

	task_unlock(task);

	<span class="enscript-keyword">if</span> (walk_only) {
		kr = vm_map_freeze_walk(task-&gt;map, purgeable_count, wired_count, clean_count, dirty_count, dirty_budget, shared);		
	} <span class="enscript-keyword">else</span> {
		kr = vm_map_freeze(task-&gt;map, purgeable_count, wired_count, clean_count, dirty_count, dirty_budget, shared);
	}

	task_lock(task);

	<span class="enscript-keyword">if</span> (walk_only == FALSE &amp;&amp; kr == KERN_SUCCESS)
		task-&gt;frozen = TRUE;
	task-&gt;changing_freeze_state = FALSE;
	thread_wakeup(&amp;task-&gt;changing_freeze_state);
	
	task_unlock(task);

	<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE) {
		vm_wake_compactor_swapper();
		<span class="enscript-comment">/*
		 * We do an explicit wakeup of the swapout thread here
		 * because the compact_and_swap routines don't have
		 * knowledge about these kind of &quot;per-task packed c_segs&quot;
		 * and so will not be evaluating whether we need to do
		 * a wakeup there.
		 */</span>
		thread_wakeup((event_t)&amp;c_swapout_list_head);
	}

	<span class="enscript-keyword">return</span> (kr);
}

<span class="enscript-comment">/*
 *	task_thaw:
 *
 *	Thaw a currently frozen task.
 *
 * Conditions:
 * 	The caller holds a reference to the task
 */</span>
kern_return_t
<span class="enscript-function-name">task_thaw</span>(
	<span class="enscript-type">register</span> task_t		task)
{
	kern_return_t kr;
    
	<span class="enscript-keyword">if</span> (task == TASK_NULL || task == kernel_task)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	task_lock(task);
	
	<span class="enscript-keyword">while</span> (task-&gt;changing_freeze_state) {

		assert_wait((event_t)&amp;task-&gt;changing_freeze_state, THREAD_UNINT);
		task_unlock(task);
		thread_block(THREAD_CONTINUE_NULL);

		task_lock(task);
	}
	<span class="enscript-keyword">if</span> (!task-&gt;frozen) {
		task_unlock(task);
		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}
	task-&gt;changing_freeze_state = TRUE;

	<span class="enscript-keyword">if</span> (DEFAULT_PAGER_IS_ACTIVE || DEFAULT_FREEZER_IS_ACTIVE) {
		task_unlock(task);

		kr = vm_map_thaw(task-&gt;map);

		task_lock(task);
	
		<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS)
			task-&gt;frozen = FALSE;
	} <span class="enscript-keyword">else</span> {
		task-&gt;frozen = FALSE;
		kr = KERN_SUCCESS;
	}

	task-&gt;changing_freeze_state = FALSE;
	thread_wakeup(&amp;task-&gt;changing_freeze_state);
	
	task_unlock(task);

	<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE) {
		vm_wake_compactor_swapper();
	}

	<span class="enscript-keyword">return</span> (kr);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>

kern_return_t
<span class="enscript-function-name">host_security_set_task_token</span>(
        host_security_t  host_security,
        task_t		 task,
        security_token_t sec_token,
	audit_token_t	 audit_token,
	host_priv_t	 host_priv)
{
	ipc_port_t	 host_port;
	kern_return_t	 kr;

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span>(KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (host_security == HOST_NULL)
		<span class="enscript-keyword">return</span>(KERN_INVALID_SECURITY);

        task_lock(task);
        task-&gt;sec_token = sec_token;
	task-&gt;audit_token = audit_token;

	task_unlock(task);

	<span class="enscript-keyword">if</span> (host_priv != HOST_PRIV_NULL) {
		kr = host_get_host_priv_port(host_priv, &amp;host_port);
	} <span class="enscript-keyword">else</span> {
		kr = host_get_host_port(host_priv_self(), &amp;host_port);
	}
	assert(kr == KERN_SUCCESS);
	kr = task_set_special_port(task, TASK_HOST_PORT, host_port);
        <span class="enscript-keyword">return</span>(kr);
}

kern_return_t
<span class="enscript-function-name">task_send_trace_memory</span>(
	task_t        target_task,
	__unused uint32_t pid,
	__unused uint64_t uniqueid)
{
	kern_return_t kr = KERN_INVALID_ARGUMENT;
	<span class="enscript-keyword">if</span> (target_task == TASK_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ATM</span>
	kr = atm_send_proc_inspect_notification(target_task,
				  pid,
				  uniqueid);

#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (kr);
}
<span class="enscript-comment">/*
 * This routine was added, pretty much exclusively, for registering the
 * RPC glue vector for in-kernel short circuited tasks.  Rather than
 * removing it completely, I have only disabled that feature (which was
 * the only feature at the time).  It just appears that we are going to
 * want to add some user data to tasks in the future (i.e. bsd info,
 * task names, etc...), so I left it in the formal task interface.
 */</span>
kern_return_t
<span class="enscript-function-name">task_set_info</span>(
	task_t		task,
	task_flavor_t	flavor,
	__unused task_info_t	task_info_in,		<span class="enscript-comment">/* pointer to IN array */</span>
	__unused mach_msg_type_number_t	task_info_count)
{
	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span>(KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">switch</span> (flavor) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ATM</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_TRACE_MEMORY_INFO</span>:
		{
			<span class="enscript-keyword">if</span> (task_info_count != TASK_TRACE_MEMORY_INFO_COUNT)
				<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
			
			assert(task_info_in != NULL);
			task_trace_memory_info_t mem_info;
			mem_info = (task_trace_memory_info_t) task_info_in;
			kern_return_t kr = atm_register_trace_memory(task,
						mem_info-&gt;user_memory_address,
						mem_info-&gt;buffer_size);
			<span class="enscript-keyword">return</span> kr;
			<span class="enscript-keyword">break</span>;
		}

#<span class="enscript-reference">endif</span>
	    <span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
	}
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-type">int</span> radar_20146450 = 1;
kern_return_t
<span class="enscript-function-name">task_info</span>(
	task_t			task,
	task_flavor_t		flavor,
	task_info_t		task_info_out,
	mach_msg_type_number_t	*task_info_count)
{
	kern_return_t error = KERN_SUCCESS;

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	task_lock(task);

	<span class="enscript-keyword">if</span> ((task != current_task()) &amp;&amp; (!task-&gt;active)) {
		task_unlock(task);
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
	}

	<span class="enscript-keyword">switch</span> (flavor) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BASIC_INFO_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BASIC2_INFO_32</span>:
	{
		task_basic_info_32_t	basic_info;
		vm_map_t				map;
		clock_sec_t				secs;
		clock_usec_t			usecs;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_BASIC_INFO_32_COUNT) {
		    error = KERN_INVALID_ARGUMENT;
		    <span class="enscript-keyword">break</span>;
		}

		basic_info = (task_basic_info_32_t)task_info_out;

		map = (task == kernel_task)? kernel_map: task-&gt;map;
		basic_info-&gt;virtual_size = (typeof(basic_info-&gt;virtual_size))map-&gt;size;
		<span class="enscript-keyword">if</span> (flavor == TASK_BASIC2_INFO_32) {
			<span class="enscript-comment">/*
			 * The &quot;BASIC2&quot; flavor gets the maximum resident
			 * size instead of the current resident size...
			 */</span>
			basic_info-&gt;resident_size = pmap_resident_max(map-&gt;pmap);
		} <span class="enscript-keyword">else</span> {
			basic_info-&gt;resident_size = pmap_resident_count(map-&gt;pmap);
		}
		basic_info-&gt;resident_size *= PAGE_SIZE;

		basic_info-&gt;policy = ((task != kernel_task)?
										  <span class="enscript-reference">POLICY_TIMESHARE</span>: POLICY_RR);
		basic_info-&gt;suspend_count = task-&gt;user_stop_count;

		absolutetime_to_microtime(task-&gt;total_user_time, &amp;secs, &amp;usecs);
		basic_info-&gt;user_time.seconds = 
			(typeof(basic_info-&gt;user_time.seconds))secs;
		basic_info-&gt;user_time.microseconds = usecs;

		absolutetime_to_microtime(task-&gt;total_system_time, &amp;secs, &amp;usecs);
		basic_info-&gt;system_time.seconds = 
			(typeof(basic_info-&gt;system_time.seconds))secs;
		basic_info-&gt;system_time.microseconds = usecs;

		*task_info_count = TASK_BASIC_INFO_32_COUNT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BASIC_INFO_64</span>:
	{
		task_basic_info_64_t	basic_info;
		vm_map_t				map;
		clock_sec_t				secs;
		clock_usec_t			usecs;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_BASIC_INFO_64_COUNT) {
		    error = KERN_INVALID_ARGUMENT;
		    <span class="enscript-keyword">break</span>;
		}

		basic_info = (task_basic_info_64_t)task_info_out;

		map = (task == kernel_task)? kernel_map: task-&gt;map;
		basic_info-&gt;virtual_size  = map-&gt;size;
		basic_info-&gt;resident_size =
			(mach_vm_size_t)(pmap_resident_count(map-&gt;pmap))
			* PAGE_SIZE_64;

		basic_info-&gt;policy = ((task != kernel_task)?
										  <span class="enscript-reference">POLICY_TIMESHARE</span>: POLICY_RR);
		basic_info-&gt;suspend_count = task-&gt;user_stop_count;

		absolutetime_to_microtime(task-&gt;total_user_time, &amp;secs, &amp;usecs);
		basic_info-&gt;user_time.seconds = 
			(typeof(basic_info-&gt;user_time.seconds))secs;
		basic_info-&gt;user_time.microseconds = usecs;

		absolutetime_to_microtime(task-&gt;total_system_time, &amp;secs, &amp;usecs);
		basic_info-&gt;system_time.seconds =
			(typeof(basic_info-&gt;system_time.seconds))secs;
		basic_info-&gt;system_time.microseconds = usecs;

		*task_info_count = TASK_BASIC_INFO_64_COUNT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_TASK_BASIC_INFO</span>:
	{
		mach_task_basic_info_t  basic_info;
		vm_map_t                map;
		clock_sec_t             secs;
		clock_usec_t            usecs;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; MACH_TASK_BASIC_INFO_COUNT) {
		    error = KERN_INVALID_ARGUMENT;
		    <span class="enscript-keyword">break</span>;
		}

		basic_info = (mach_task_basic_info_t)task_info_out;

		map = (task == kernel_task) ? kernel_map : task-&gt;map;

		basic_info-&gt;virtual_size  = map-&gt;size;

		basic_info-&gt;resident_size =
		    (mach_vm_size_t)(pmap_resident_count(map-&gt;pmap));
		basic_info-&gt;resident_size *= PAGE_SIZE_64;

		basic_info-&gt;resident_size_max =
		    (mach_vm_size_t)(pmap_resident_max(map-&gt;pmap));
		basic_info-&gt;resident_size_max *= PAGE_SIZE_64;

		basic_info-&gt;policy = ((task != kernel_task) ? 
		                      POLICY_TIMESHARE : POLICY_RR);

		basic_info-&gt;suspend_count = task-&gt;user_stop_count;

		absolutetime_to_microtime(task-&gt;total_user_time, &amp;secs, &amp;usecs);
		basic_info-&gt;user_time.seconds = 
		    (typeof(basic_info-&gt;user_time.seconds))secs;
		basic_info-&gt;user_time.microseconds = usecs;

		absolutetime_to_microtime(task-&gt;total_system_time, &amp;secs, &amp;usecs);
		basic_info-&gt;system_time.seconds =
		    (typeof(basic_info-&gt;system_time.seconds))secs;
		basic_info-&gt;system_time.microseconds = usecs;

		*task_info_count = MACH_TASK_BASIC_INFO_COUNT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_THREAD_TIMES_INFO</span>:
	{
		<span class="enscript-type">register</span> task_thread_times_info_t	times_info;
		<span class="enscript-type">register</span> thread_t					thread;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_THREAD_TIMES_INFO_COUNT) {
		    error = KERN_INVALID_ARGUMENT;
		    <span class="enscript-keyword">break</span>;
		}

		times_info = (task_thread_times_info_t) task_info_out;
		times_info-&gt;user_time.seconds = 0;
		times_info-&gt;user_time.microseconds = 0;
		times_info-&gt;system_time.seconds = 0;
		times_info-&gt;system_time.microseconds = 0;


		queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
			time_value_t	user_time, system_time;

			<span class="enscript-keyword">if</span> (thread-&gt;options &amp; TH_OPT_IDLE_THREAD)
				<span class="enscript-keyword">continue</span>;

			thread_read_times(thread, &amp;user_time, &amp;system_time);

			time_value_add(&amp;times_info-&gt;user_time, &amp;user_time);
			time_value_add(&amp;times_info-&gt;system_time, &amp;system_time);
		}

		*task_info_count = TASK_THREAD_TIMES_INFO_COUNT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_ABSOLUTETIME_INFO</span>:
	{
		task_absolutetime_info_t	info;
		<span class="enscript-type">register</span> thread_t			thread;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_ABSOLUTETIME_INFO_COUNT) {
			error = KERN_INVALID_ARGUMENT;
			<span class="enscript-keyword">break</span>;
		}

		info = (task_absolutetime_info_t)task_info_out;
		info-&gt;threads_user = info-&gt;threads_system = 0;


		info-&gt;total_user = task-&gt;total_user_time;
		info-&gt;total_system = task-&gt;total_system_time;

		queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
			uint64_t	tval;
			spl_t 		x;

			<span class="enscript-keyword">if</span> (thread-&gt;options &amp; TH_OPT_IDLE_THREAD)
				<span class="enscript-keyword">continue</span>;

			x = splsched();
			thread_lock(thread);

			tval = timer_grab(&amp;thread-&gt;user_timer);
			info-&gt;threads_user += tval;
			info-&gt;total_user += tval;

			tval = timer_grab(&amp;thread-&gt;system_timer);
			<span class="enscript-keyword">if</span> (thread-&gt;precise_user_kernel_time) {
				info-&gt;threads_system += tval;
				info-&gt;total_system += tval;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* system_timer may represent either sys or user */</span>
				info-&gt;threads_user += tval;
				info-&gt;total_user += tval;
			}

			thread_unlock(thread);
			splx(x);
		}


		*task_info_count = TASK_ABSOLUTETIME_INFO_COUNT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_DYLD_INFO</span>:
	{
		task_dyld_info_t info;

		<span class="enscript-comment">/*
		 * We added the format field to TASK_DYLD_INFO output.  For
		 * temporary backward compatibility, accept the fact that
		 * clients may ask for the old version - distinquished by the
		 * size of the expected result structure.
		 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_LEGACY_DYLD_INFO_COUNT</span> \
		offsetof(<span class="enscript-type">struct</span> task_dyld_info, all_image_info_format)/<span class="enscript-keyword">sizeof</span>(natural_t)

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_LEGACY_DYLD_INFO_COUNT) {
			error = KERN_INVALID_ARGUMENT;
			<span class="enscript-keyword">break</span>;
		}

		info = (task_dyld_info_t)task_info_out;
		info-&gt;all_image_info_addr = task-&gt;all_image_info_addr;
		info-&gt;all_image_info_size = task-&gt;all_image_info_size;

		<span class="enscript-comment">/* only set format on output for those expecting it */</span>
		<span class="enscript-keyword">if</span> (*task_info_count &gt;= TASK_DYLD_INFO_COUNT) {
			info-&gt;all_image_info_format = task_has_64BitAddr(task) ?
				                 TASK_DYLD_ALL_IMAGE_INFO_64 : 
				                 TASK_DYLD_ALL_IMAGE_INFO_32 ;
			*task_info_count = TASK_DYLD_INFO_COUNT;
		} <span class="enscript-keyword">else</span> {
			*task_info_count = TASK_LEGACY_DYLD_INFO_COUNT;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_EXTMOD_INFO</span>:
	{
		task_extmod_info_t info;
		<span class="enscript-type">void</span> *p;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_EXTMOD_INFO_COUNT) {
			error = KERN_INVALID_ARGUMENT;
			<span class="enscript-keyword">break</span>;
		}

		info = (task_extmod_info_t)task_info_out;

		p = get_bsdtask_info(task);
		<span class="enscript-keyword">if</span> (p) {
			proc_getexecutableuuid(p, info-&gt;task_uuid, <span class="enscript-keyword">sizeof</span>(info-&gt;task_uuid));
		} <span class="enscript-keyword">else</span> {
			bzero(info-&gt;task_uuid, <span class="enscript-keyword">sizeof</span>(info-&gt;task_uuid));
		}
		info-&gt;extmod_statistics = task-&gt;extmod_statistics;
		*task_info_count = TASK_EXTMOD_INFO_COUNT;

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_KERNELMEMORY_INFO</span>:
	{
		task_kernelmemory_info_t	tkm_info;
		ledger_amount_t			credit, debit;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_KERNELMEMORY_INFO_COUNT) {
		   error = KERN_INVALID_ARGUMENT;
		   <span class="enscript-keyword">break</span>;
		}

		tkm_info = (task_kernelmemory_info_t) task_info_out;
		tkm_info-&gt;total_palloc = 0;
		tkm_info-&gt;total_pfree = 0;
		tkm_info-&gt;total_salloc = 0;
		tkm_info-&gt;total_sfree = 0;

		<span class="enscript-keyword">if</span> (task == kernel_task) {
			<span class="enscript-comment">/*
			 * All shared allocs/frees from other tasks count against
			 * the kernel private memory usage.  If we are looking up
			 * info for the kernel task, gather from everywhere.
			 */</span>
			task_unlock(task);

			<span class="enscript-comment">/* start by accounting for all the terminated tasks against the kernel */</span>
			tkm_info-&gt;total_palloc = tasks_tkm_private.alloc + tasks_tkm_shared.alloc;
			tkm_info-&gt;total_pfree = tasks_tkm_private.free + tasks_tkm_shared.free;

			<span class="enscript-comment">/* count all other task/thread shared alloc/free against the kernel */</span>
			lck_mtx_lock(&amp;tasks_threads_lock);

			<span class="enscript-comment">/* XXX this really shouldn't be using the function parameter 'task' as a local var! */</span>
			queue_iterate(&amp;tasks, task, task_t, tasks) {
				<span class="enscript-keyword">if</span> (task == kernel_task) {
					<span class="enscript-keyword">if</span> (ledger_get_entries(task-&gt;ledger,
					    task_ledgers.tkm_private, &amp;credit,
					    &amp;debit) == KERN_SUCCESS) {
						tkm_info-&gt;total_palloc += credit;
						tkm_info-&gt;total_pfree += debit;
					}
				}
				<span class="enscript-keyword">if</span> (!ledger_get_entries(task-&gt;ledger,
				    task_ledgers.tkm_shared, &amp;credit, &amp;debit)) {
					tkm_info-&gt;total_palloc += credit;
					tkm_info-&gt;total_pfree += debit;
				}
			}
			lck_mtx_unlock(&amp;tasks_threads_lock);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (!ledger_get_entries(task-&gt;ledger,
			    task_ledgers.tkm_private, &amp;credit, &amp;debit)) {
				tkm_info-&gt;total_palloc = credit;
				tkm_info-&gt;total_pfree = debit;
			}
			<span class="enscript-keyword">if</span> (!ledger_get_entries(task-&gt;ledger,
			    task_ledgers.tkm_shared, &amp;credit, &amp;debit)) {
				tkm_info-&gt;total_salloc = credit;
				tkm_info-&gt;total_sfree = debit;
			}
			task_unlock(task);
		}

		*task_info_count = TASK_KERNELMEMORY_INFO_COUNT;
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	<span class="enscript-comment">/* OBSOLETE */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_SCHED_FIFO_INFO</span>:
	{

		<span class="enscript-keyword">if</span> (*task_info_count &lt; POLICY_FIFO_BASE_COUNT) {
			error = KERN_INVALID_ARGUMENT;
			<span class="enscript-keyword">break</span>;
		}

		error = KERN_INVALID_POLICY;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* OBSOLETE */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_SCHED_RR_INFO</span>:
	{
		<span class="enscript-type">register</span> policy_rr_base_t	rr_base;
		uint32_t quantum_time;
		uint64_t quantum_ns;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; POLICY_RR_BASE_COUNT) {
			error = KERN_INVALID_ARGUMENT;
			<span class="enscript-keyword">break</span>;
		}

		rr_base = (policy_rr_base_t) task_info_out;

		<span class="enscript-keyword">if</span> (task != kernel_task) {
			error = KERN_INVALID_POLICY;
			<span class="enscript-keyword">break</span>;
		}

		rr_base-&gt;base_priority = task-&gt;priority;

		quantum_time = SCHED(initial_quantum_size)(THREAD_NULL);
		absolutetime_to_nanoseconds(quantum_time, &amp;quantum_ns);
		
		rr_base-&gt;quantum = (uint32_t)(quantum_ns / 1000 / 1000);

		*task_info_count = POLICY_RR_BASE_COUNT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* OBSOLETE */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_SCHED_TIMESHARE_INFO</span>:
	{
		<span class="enscript-type">register</span> policy_timeshare_base_t	ts_base;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; POLICY_TIMESHARE_BASE_COUNT) {
			error = KERN_INVALID_ARGUMENT;
			<span class="enscript-keyword">break</span>;
		}

		ts_base = (policy_timeshare_base_t) task_info_out;

		<span class="enscript-keyword">if</span> (task == kernel_task) {
			error = KERN_INVALID_POLICY;
			<span class="enscript-keyword">break</span>;
		}

		ts_base-&gt;base_priority = task-&gt;priority;

		*task_info_count = POLICY_TIMESHARE_BASE_COUNT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_SECURITY_TOKEN</span>:
	{
		<span class="enscript-type">register</span> security_token_t	*sec_token_p;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_SECURITY_TOKEN_COUNT) {
		    error = KERN_INVALID_ARGUMENT;
		    <span class="enscript-keyword">break</span>;
		}

		sec_token_p = (security_token_t *) task_info_out;

		*sec_token_p = task-&gt;sec_token;

		*task_info_count = TASK_SECURITY_TOKEN_COUNT;
		<span class="enscript-keyword">break</span>;
	}
            
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_AUDIT_TOKEN</span>:
	{
		<span class="enscript-type">register</span> audit_token_t	*audit_token_p;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_AUDIT_TOKEN_COUNT) {
		    error = KERN_INVALID_ARGUMENT;
		    <span class="enscript-keyword">break</span>;
		}

		audit_token_p = (audit_token_t *) task_info_out;

		*audit_token_p = task-&gt;audit_token;

		*task_info_count = TASK_AUDIT_TOKEN_COUNT;
		<span class="enscript-keyword">break</span>;
	}
            
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_SCHED_INFO</span>:
		error = KERN_INVALID_ARGUMENT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_EVENTS_INFO</span>:
	{
		<span class="enscript-type">register</span> task_events_info_t	events_info;
		<span class="enscript-type">register</span> thread_t			thread;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_EVENTS_INFO_COUNT) {
		   error = KERN_INVALID_ARGUMENT;
		   <span class="enscript-keyword">break</span>;
		}

		events_info = (task_events_info_t) task_info_out;


		events_info-&gt;faults = task-&gt;faults;
		events_info-&gt;pageins = task-&gt;pageins;
		events_info-&gt;cow_faults = task-&gt;cow_faults;
		events_info-&gt;messages_sent = task-&gt;messages_sent;
		events_info-&gt;messages_received = task-&gt;messages_received;
		events_info-&gt;syscalls_mach = task-&gt;syscalls_mach;
		events_info-&gt;syscalls_unix = task-&gt;syscalls_unix;

		events_info-&gt;csw = task-&gt;c_switch;

		queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
			events_info-&gt;csw	   += thread-&gt;c_switch;
			events_info-&gt;syscalls_mach += thread-&gt;syscalls_mach;
			events_info-&gt;syscalls_unix += thread-&gt;syscalls_unix;
		}


		*task_info_count = TASK_EVENTS_INFO_COUNT;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_AFFINITY_TAG_INFO</span>:
	{
		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_AFFINITY_TAG_INFO_COUNT) {
		    error = KERN_INVALID_ARGUMENT;
		    <span class="enscript-keyword">break</span>;
		}

		error = task_affinity_info(task, task_info_out, task_info_count);
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POWER_INFO</span>:
	{
		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_POWER_INFO_COUNT) {
			error = KERN_INVALID_ARGUMENT;
			<span class="enscript-keyword">break</span>;
		}

		task_power_info_locked(task, (task_power_info_t)task_info_out, NULL);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POWER_INFO_V2</span>:
	{
		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_POWER_INFO_V2_COUNT) {
			error = KERN_INVALID_ARGUMENT;
			<span class="enscript-keyword">break</span>;
		}
		task_power_info_v2_t tpiv2 = (task_power_info_v2_t) task_info_out;
		task_power_info_locked(task, &amp;tpiv2-&gt;cpu_energy, &amp;tpiv2-&gt;gpu_energy);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_VM_INFO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_VM_INFO_PURGEABLE</span>:
	{
		task_vm_info_t		vm_info;
		vm_map_t		map;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_VM_INFO_REV0_COUNT) {
		    error = KERN_INVALID_ARGUMENT;
		    <span class="enscript-keyword">break</span>;
		}

		vm_info = (task_vm_info_t)task_info_out;

		<span class="enscript-keyword">if</span> (task == kernel_task) {
			map = kernel_map;
			<span class="enscript-comment">/* no lock */</span>
		} <span class="enscript-keyword">else</span> {
			map = task-&gt;map;
			vm_map_lock_read(map);
		}

		vm_info-&gt;virtual_size = (typeof(vm_info-&gt;virtual_size))map-&gt;size;
		vm_info-&gt;region_count = map-&gt;hdr.nentries;
		vm_info-&gt;page_size = vm_map_page_size(map);

		vm_info-&gt;resident_size = pmap_resident_count(map-&gt;pmap);
		vm_info-&gt;resident_size *= PAGE_SIZE;
		vm_info-&gt;resident_size_peak = pmap_resident_max(map-&gt;pmap);
		vm_info-&gt;resident_size_peak *= PAGE_SIZE;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">_VM_INFO</span>(_name) \
	vm_info-&gt;_name = ((mach_vm_size_t) map-&gt;pmap-&gt;stats._name) * PAGE_SIZE

		_VM_INFO(device);
		_VM_INFO(device_peak);
		_VM_INFO(external);
		_VM_INFO(external_peak);
		_VM_INFO(internal);
		_VM_INFO(internal_peak);
		_VM_INFO(reusable);
		_VM_INFO(reusable_peak);
		_VM_INFO(compressed);
		_VM_INFO(compressed_peak);
		_VM_INFO(compressed_lifetime);

		vm_info-&gt;purgeable_volatile_pmap = 0;
		vm_info-&gt;purgeable_volatile_resident = 0;
		vm_info-&gt;purgeable_volatile_virtual = 0;
		<span class="enscript-keyword">if</span> (task == kernel_task) {
			<span class="enscript-comment">/*
			 * We do not maintain the detailed stats for the
			 * kernel_pmap, so just count everything as
			 * &quot;internal&quot;...
			 */</span>
			vm_info-&gt;internal = vm_info-&gt;resident_size;
			<span class="enscript-comment">/*
			 * ... but since the memory held by the VM compressor
			 * in the kernel address space ought to be attributed
			 * to user-space tasks, we subtract it from &quot;internal&quot;
			 * to give memory reporting tools a more accurate idea
			 * of what the kernel itself is actually using, instead
			 * of making it look like the kernel is leaking memory
			 * when the system is under memory pressure.
			 */</span>
			vm_info-&gt;internal -= (VM_PAGE_COMPRESSOR_COUNT *
					      PAGE_SIZE);
		} <span class="enscript-keyword">else</span> {
			mach_vm_size_t	volatile_virtual_size;
			mach_vm_size_t	volatile_resident_size;
			mach_vm_size_t	volatile_compressed_size;
			mach_vm_size_t	volatile_pmap_size;
			mach_vm_size_t	volatile_compressed_pmap_size;
			kern_return_t	kr;

			<span class="enscript-keyword">if</span> (flavor == TASK_VM_INFO_PURGEABLE) {
				kr = vm_map_query_volatile(
					map,
					&amp;volatile_virtual_size,
					&amp;volatile_resident_size,
					&amp;volatile_compressed_size,
					&amp;volatile_pmap_size,
					&amp;volatile_compressed_pmap_size);
				<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
					vm_info-&gt;purgeable_volatile_pmap =
						volatile_pmap_size;
					<span class="enscript-keyword">if</span> (radar_20146450) {
					vm_info-&gt;compressed -=
						volatile_compressed_pmap_size;
					}
					vm_info-&gt;purgeable_volatile_resident =
						volatile_resident_size;
					vm_info-&gt;purgeable_volatile_virtual =
						volatile_virtual_size;
				}
			}
			vm_map_unlock_read(map);
		}

		<span class="enscript-keyword">if</span> (*task_info_count &gt;= TASK_VM_INFO_COUNT) {
			vm_info-&gt;phys_footprint = 0;
			*task_info_count = TASK_VM_INFO_COUNT;
		} <span class="enscript-keyword">else</span> {
			*task_info_count = TASK_VM_INFO_REV0_COUNT;
		}

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_WAIT_STATE_INFO</span>:
	{
		<span class="enscript-comment">/* 
		 * Deprecated flavor. Currently allowing some results until all users 
		 * stop calling it. The results may not be accurate.
         */</span>
		task_wait_state_info_t	wait_state_info;
		uint64_t total_sfi_ledger_val = 0;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_WAIT_STATE_INFO_COUNT) {
		   error = KERN_INVALID_ARGUMENT;
		   <span class="enscript-keyword">break</span>;
		}

		wait_state_info = (task_wait_state_info_t) task_info_out;

		wait_state_info-&gt;total_wait_state_time = 0;
		bzero(wait_state_info-&gt;_reserved, <span class="enscript-keyword">sizeof</span>(wait_state_info-&gt;_reserved));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SCHED_SFI</span>
		<span class="enscript-type">int</span> i, prev_lentry = -1;
		int64_t  val_credit, val_debit;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; MAX_SFI_CLASS_ID; i++){
			val_credit =0;
			<span class="enscript-comment">/*
			 * checking with prev_lentry != entry ensures adjacent classes 
			 * which share the same ledger do not add wait times twice.
			 * Note: Use ledger() call to get data for each individual sfi class.
			 */</span>
			<span class="enscript-keyword">if</span> (prev_lentry != task_ledgers.sfi_wait_times[i] &amp;&amp;
				KERN_SUCCESS == ledger_get_entries(task-&gt;ledger, 
				                task_ledgers.sfi_wait_times[i], &amp;val_credit, &amp;val_debit)) {
				total_sfi_ledger_val += val_credit;
			}
			prev_lentry = task_ledgers.sfi_wait_times[i];
		}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_SCHED_SFI */</span>
		wait_state_info-&gt;total_wait_sfi_state_time = total_sfi_ledger_val; 
		*task_info_count = TASK_WAIT_STATE_INFO_COUNT;

		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_VM_INFO_PURGEABLE_ACCOUNT</span>:
	{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
		pvm_account_info_t	acnt_info;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; PVM_ACCOUNT_INFO_COUNT) {
			error = KERN_INVALID_ARGUMENT;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (task_info_out == NULL) {
			error = KERN_INVALID_ARGUMENT;
			<span class="enscript-keyword">break</span>;
		}

		acnt_info = (pvm_account_info_t) task_info_out;

		error = vm_purgeable_account(task, acnt_info);

		*task_info_count = PVM_ACCOUNT_INFO_COUNT;

		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
		error = KERN_NOT_SUPPORTED;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_FLAGS_INFO</span>:
	{
		task_flags_info_t  		flags_info;

		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_FLAGS_INFO_COUNT) {
		    error = KERN_INVALID_ARGUMENT;
		    <span class="enscript-keyword">break</span>;
		}

		flags_info = (task_flags_info_t)task_info_out;

		<span class="enscript-comment">/* only publish the 64-bit flag of the task */</span>
		flags_info-&gt;flags = task-&gt;t_flags &amp; TF_64B_ADDR;

		*task_info_count = TASK_FLAGS_INFO_COUNT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_DEBUG_INFO_INTERNAL</span>:
	{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
		task_debug_info_internal_t dbg_info;
		<span class="enscript-keyword">if</span> (*task_info_count &lt; TASK_DEBUG_INFO_INTERNAL_COUNT) {
			error = KERN_NOT_SUPPORTED;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (task_info_out == NULL) {
			error = KERN_INVALID_ARGUMENT;
			<span class="enscript-keyword">break</span>;
		}
		dbg_info = (task_debug_info_internal_t) task_info_out;
		dbg_info-&gt;ipc_space_size = 0;
		<span class="enscript-keyword">if</span> (task-&gt;itk_space){
			dbg_info-&gt;ipc_space_size = task-&gt;itk_space-&gt;is_table_size;
		}

		error = KERN_SUCCESS;
		*task_info_count = TASK_DEBUG_INFO_INTERNAL_COUNT;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
		error = KERN_NOT_SUPPORTED;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
	}
	<span class="enscript-reference">default</span>:
		error = KERN_INVALID_ARGUMENT;
	}

	task_unlock(task);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* 
 *	task_power_info
 *
 *	Returns power stats for the task.
 *	Note: Called with task locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_power_info_locked</span>(
	task_t			task,
	task_power_info_t	info,
	gpu_energy_data_t	ginfo)
{
	thread_t		thread;
	ledger_amount_t		tmp;

	task_lock_assert_owned(task);

	ledger_get_entries(task-&gt;ledger, task_ledgers.interrupt_wakeups,
		(ledger_amount_t *)&amp;info-&gt;task_interrupt_wakeups, &amp;tmp);
	ledger_get_entries(task-&gt;ledger, task_ledgers.platform_idle_wakeups,
		(ledger_amount_t *)&amp;info-&gt;task_platform_idle_wakeups, &amp;tmp);

	info-&gt;task_timer_wakeups_bin_1 = task-&gt;task_timer_wakeups_bin_1;
	info-&gt;task_timer_wakeups_bin_2 = task-&gt;task_timer_wakeups_bin_2;

	info-&gt;total_user = task-&gt;total_user_time;
	info-&gt;total_system = task-&gt;total_system_time;

	<span class="enscript-keyword">if</span> (ginfo) {
		ginfo-&gt;task_gpu_utilisation = task-&gt;task_gpu_ns;
	}

	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
		uint64_t	tval;
		spl_t 		x;

		<span class="enscript-keyword">if</span> (thread-&gt;options &amp; TH_OPT_IDLE_THREAD)
			<span class="enscript-keyword">continue</span>;

		x = splsched();
		thread_lock(thread);

		info-&gt;task_timer_wakeups_bin_1 += thread-&gt;thread_timer_wakeups_bin_1;
		info-&gt;task_timer_wakeups_bin_2 += thread-&gt;thread_timer_wakeups_bin_2;

		tval = timer_grab(&amp;thread-&gt;user_timer);
		info-&gt;total_user += tval;

		tval = timer_grab(&amp;thread-&gt;system_timer);
		<span class="enscript-keyword">if</span> (thread-&gt;precise_user_kernel_time) {
			info-&gt;total_system += tval;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* system_timer may represent either sys or user */</span>
			info-&gt;total_user += tval;
		}

		<span class="enscript-keyword">if</span> (ginfo) {
			ginfo-&gt;task_gpu_utilisation += ml_gpu_stat(thread);
		}
		thread_unlock(thread);
		splx(x);
	}
}

<span class="enscript-comment">/* 
 *	task_gpu_utilisation
 *
 *	Returns the total gpu time used by the all the threads of the task
 *  (both dead and alive)
 */</span>
uint64_t
<span class="enscript-function-name">task_gpu_utilisation</span>(
	task_t	task)
{
	uint64_t gpu_time = 0;
	thread_t thread;

	task_lock(task);
	gpu_time += task-&gt;task_gpu_ns;

	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
		spl_t x;
		x = splsched();
		thread_lock(thread);
		gpu_time += ml_gpu_stat(thread);
		thread_unlock(thread);
		splx(x);
	}

	task_unlock(task);
	<span class="enscript-keyword">return</span> gpu_time;
}

kern_return_t
<span class="enscript-function-name">task_purgable_info</span>(
	task_t			task,
	task_purgable_info_t	*stats)
{
	<span class="enscript-keyword">if</span> (task == TASK_NULL || stats == NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	<span class="enscript-comment">/* Take task reference */</span>
	task_reference(task);
	vm_purgeable_stats((vm_purgeable_info_t)stats, task);
	<span class="enscript-comment">/* Drop task reference */</span>
	task_deallocate(task);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_vtimer_set</span>(
	task_t		task,
	integer_t	which)
{
	thread_t	thread;
	spl_t		x;

	<span class="enscript-comment">/* assert(task == current_task()); */</span> <span class="enscript-comment">/* bogus assert 4803227 4807483 */</span>

	task_lock(task);

	task-&gt;vtimers |= which;

	<span class="enscript-keyword">switch</span> (which) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_VTIMER_USER</span>:
		queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
			x = splsched();
			thread_lock(thread);
			<span class="enscript-keyword">if</span> (thread-&gt;precise_user_kernel_time)
				thread-&gt;vtimer_user_save = timer_grab(&amp;thread-&gt;user_timer);
			<span class="enscript-keyword">else</span>
				thread-&gt;vtimer_user_save = timer_grab(&amp;thread-&gt;system_timer);
			thread_unlock(thread);
			splx(x);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_VTIMER_PROF</span>:
		queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
			x = splsched();
			thread_lock(thread);
			thread-&gt;vtimer_prof_save = timer_grab(&amp;thread-&gt;user_timer);
			thread-&gt;vtimer_prof_save += timer_grab(&amp;thread-&gt;system_timer);
			thread_unlock(thread);
			splx(x);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_VTIMER_RLIM</span>:
		queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
			x = splsched();
			thread_lock(thread);
			thread-&gt;vtimer_rlim_save = timer_grab(&amp;thread-&gt;user_timer);
			thread-&gt;vtimer_rlim_save += timer_grab(&amp;thread-&gt;system_timer);
			thread_unlock(thread);
			splx(x);
		}
		<span class="enscript-keyword">break</span>;
	}

	task_unlock(task);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_vtimer_clear</span>(
	task_t		task,
	integer_t	which)
{
	assert(task == current_task());

	task_lock(task);

	task-&gt;vtimers &amp;= ~which;

	task_unlock(task);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_vtimer_update</span>(
__unused
	task_t		task,
	integer_t	which,
	uint32_t	*microsecs)
{
	thread_t	thread = current_thread();
	uint32_t	tdelt;
	clock_sec_t	secs;
	uint64_t	tsum;

	assert(task == current_task());

	assert(task-&gt;vtimers &amp; which);

	secs = tdelt = 0;

	<span class="enscript-keyword">switch</span> (which) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_VTIMER_USER</span>:
		<span class="enscript-keyword">if</span> (thread-&gt;precise_user_kernel_time) {
			tdelt = (uint32_t)timer_delta(&amp;thread-&gt;user_timer,
								&amp;thread-&gt;vtimer_user_save);
		} <span class="enscript-keyword">else</span> {
			tdelt = (uint32_t)timer_delta(&amp;thread-&gt;system_timer,
								&amp;thread-&gt;vtimer_user_save);
		}
		absolutetime_to_microtime(tdelt, &amp;secs, microsecs);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_VTIMER_PROF</span>:
		tsum = timer_grab(&amp;thread-&gt;user_timer);
		tsum += timer_grab(&amp;thread-&gt;system_timer);
		tdelt = (uint32_t)(tsum - thread-&gt;vtimer_prof_save);
		absolutetime_to_microtime(tdelt, &amp;secs, microsecs);
		<span class="enscript-comment">/* if the time delta is smaller than a usec, ignore */</span>
		<span class="enscript-keyword">if</span> (*microsecs != 0)
			thread-&gt;vtimer_prof_save = tsum;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_VTIMER_RLIM</span>:
		tsum = timer_grab(&amp;thread-&gt;user_timer);
		tsum += timer_grab(&amp;thread-&gt;system_timer);
		tdelt = (uint32_t)(tsum - thread-&gt;vtimer_rlim_save);
		thread-&gt;vtimer_rlim_save = tsum;
		absolutetime_to_microtime(tdelt, &amp;secs, microsecs);
		<span class="enscript-keyword">break</span>;
	}

}

<span class="enscript-comment">/*
 *	task_assign:
 *
 *	Change the assigned processor set for the task
 */</span>
kern_return_t
<span class="enscript-function-name">task_assign</span>(
	__unused task_t		task,
	__unused processor_set_t	new_pset,
	__unused boolean_t	assign_threads)
{
	<span class="enscript-keyword">return</span>(KERN_FAILURE);
}

<span class="enscript-comment">/*
 *	task_assign_default:
 *
 *	Version of task_assign to assign to default processor set.
 */</span>
kern_return_t
<span class="enscript-function-name">task_assign_default</span>(
	task_t		task,
	boolean_t	assign_threads)
{
    <span class="enscript-keyword">return</span> (task_assign(task, &amp;pset0, assign_threads));
}

<span class="enscript-comment">/*
 *	task_get_assignment
 *
 *	Return name of processor set that task is assigned to.
 */</span>
kern_return_t
<span class="enscript-function-name">task_get_assignment</span>(
	task_t		task,
	processor_set_t	*pset)
{
	<span class="enscript-keyword">if</span> (!task-&gt;active)
		<span class="enscript-keyword">return</span>(KERN_FAILURE);

	*pset = &amp;pset0;

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

uint64_t
<span class="enscript-function-name">get_task_dispatchqueue_offset</span>(
		task_t 		task)
{
	<span class="enscript-keyword">return</span> task-&gt;dispatchqueue_offset;
}

<span class="enscript-comment">/*
 * 	task_policy
 *
 *	Set scheduling policy and parameters, both base and limit, for
 *	the given task. Policy must be a policy which is enabled for the
 *	processor set. Change contained threads if requested. 
 */</span>
kern_return_t
<span class="enscript-function-name">task_policy</span>(
	__unused task_t			task,
	__unused policy_t			policy_id,
	__unused policy_base_t		base,
	__unused mach_msg_type_number_t	count,
	__unused boolean_t			set_limit,
	__unused boolean_t			change)
{
	<span class="enscript-keyword">return</span>(KERN_FAILURE);
}

<span class="enscript-comment">/*
 *	task_set_policy
 *
 *	Set scheduling policy and parameters, both base and limit, for 
 *	the given task. Policy can be any policy implemented by the
 *	processor set, whether enabled or not. Change contained threads
 *	if requested.
 */</span>
kern_return_t
<span class="enscript-function-name">task_set_policy</span>(
	__unused task_t			task,
	__unused processor_set_t		pset,
	__unused policy_t			policy_id,
	__unused policy_base_t		base,
	__unused mach_msg_type_number_t	base_count,
	__unused policy_limit_t		limit,
	__unused mach_msg_type_number_t	limit_count,
	__unused boolean_t			change)
{
	<span class="enscript-keyword">return</span>(KERN_FAILURE);
}

kern_return_t
<span class="enscript-function-name">task_set_ras_pc</span>(
 	__unused task_t	task,
 	__unused vm_offset_t	pc,
 	__unused vm_offset_t	endpc)
{
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_synchronizer_destroy_all</span>(task_t task)
{
	semaphore_t	semaphore;

	<span class="enscript-comment">/*
	 *  Destroy owned semaphores
	 */</span>

	<span class="enscript-keyword">while</span> (!queue_empty(&amp;task-&gt;semaphore_list)) {
		semaphore = (semaphore_t) queue_first(&amp;task-&gt;semaphore_list);
		(<span class="enscript-type">void</span>) semaphore_destroy_internal(task, semaphore);
	}
}

<span class="enscript-comment">/*
 * Install default (machine-dependent) initial thread state 
 * on the task.  Subsequent thread creation will have this initial
 * state set on the thread by machine_thread_inherit_taskwide().
 * Flavors and structures are exactly the same as those to thread_set_state()
 */</span>
kern_return_t 
<span class="enscript-function-name">task_set_state</span>(
	task_t task, 
	<span class="enscript-type">int</span> flavor, 
	thread_state_t state, 
	mach_msg_type_number_t state_count)
{
	kern_return_t ret;

	<span class="enscript-keyword">if</span> (task == TASK_NULL) {
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
	}

	task_lock(task);

	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		task_unlock(task);
		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	ret = machine_task_set_state(task, flavor, state, state_count);

	task_unlock(task);
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/*
 * Examine the default (machine-dependent) initial thread state 
 * on the task, as set by task_set_state().  Flavors and structures
 * are exactly the same as those passed to thread_get_state().
 */</span>
kern_return_t 
<span class="enscript-function-name">task_get_state</span>(
	task_t 	task, 
	<span class="enscript-type">int</span>	flavor,
	thread_state_t state,
	mach_msg_type_number_t *state_count)
{
	kern_return_t ret;

	<span class="enscript-keyword">if</span> (task == TASK_NULL) {
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
	}

	task_lock(task);

	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		task_unlock(task);
		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	ret = machine_task_get_state(task, flavor, state, state_count);

	task_unlock(task);
	<span class="enscript-keyword">return</span> ret;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HWM_USERCORE_MINSPACE</span> 250 // free space (in MB) required *after* core file creation

<span class="enscript-type">void</span> <span class="enscript-function-name">__attribute__</span>((noinline))
<span class="enscript-function-name">PROC_CROSSED_HIGH_WATERMARK__SEND_EXC_RESOURCE_AND_SUSPEND</span>(<span class="enscript-type">int</span> max_footprint_mb)
{
	task_t						task 		= current_task();
	<span class="enscript-type">int</span>							pid         = 0;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>					*procname 	= <span class="enscript-string">&quot;unknown&quot;</span>;
	mach_exception_data_type_t	code[EXCEPTION_CODE_MAX];

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
	pid = proc_selfpid();

	<span class="enscript-keyword">if</span> (pid == 1) {
		<span class="enscript-comment">/*
		 * Cannot have ReportCrash analyzing
		 * a suspended initproc.
		 */</span>
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (task-&gt;bsd_info != NULL)
		procname = proc_name_address(current_task()-&gt;bsd_info);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (hwm_user_cores) {
		<span class="enscript-type">int</span>				error;
		uint64_t		starttime, end;
		clock_sec_t		secs = 0;
		uint32_t		microsecs = 0;

		starttime = mach_absolute_time();
		<span class="enscript-comment">/*
		 * Trigger a coredump of this process. Don't proceed unless we know we won't
		 * be filling up the disk; and ignore the core size resource limit for this
		 * core file.
		 */</span>
		<span class="enscript-keyword">if</span> ((error = coredump(current_task()-&gt;bsd_info, HWM_USERCORE_MINSPACE, COREDUMP_IGNORE_ULIMIT)) != 0) {
			printf(<span class="enscript-string">&quot;couldn't take coredump of %s[%d]: %d\n&quot;</span>, procname, pid, error);
		}
		<span class="enscript-comment">/*
		* coredump() leaves the task suspended.
		*/</span>
		task_resume_internal(current_task());

		end = mach_absolute_time();
		absolutetime_to_microtime(end - starttime, &amp;secs, &amp;microsecs);
		printf(<span class="enscript-string">&quot;coredump of %s[%d] taken in %d secs %d microsecs\n&quot;</span>,
		       proc_name_address(current_task()-&gt;bsd_info), pid, (<span class="enscript-type">int</span>)secs, microsecs);
	}

	<span class="enscript-keyword">if</span> (disable_exc_resource) {
		printf(<span class="enscript-string">&quot;process %s[%d] crossed memory high watermark (%d MB); EXC_RESOURCE &quot;</span>
			<span class="enscript-string">&quot;supressed by a boot-arg.\n&quot;</span>, procname, pid, max_footprint_mb);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * A task that has triggered an EXC_RESOURCE, should not be
	 * jetsammed when the device is under memory pressure.  Here
	 * we set the P_MEMSTAT_TERMINATED flag so that the process
	 * will be skipped if the memorystatus_thread wakes up.
	 */</span>
	proc_memstat_terminated(current_task()-&gt;bsd_info, TRUE);

	printf(<span class="enscript-string">&quot;process %s[%d] crossed memory high watermark (%d MB); sending &quot;</span>
		<span class="enscript-string">&quot;EXC_RESOURCE.\n&quot;</span>, procname, pid, max_footprint_mb);

	code[0] = code[1] = 0;
	EXC_RESOURCE_ENCODE_TYPE(code[0], RESOURCE_TYPE_MEMORY);
	EXC_RESOURCE_ENCODE_FLAVOR(code[0], FLAVOR_HIGH_WATERMARK);
	EXC_RESOURCE_HWM_ENCODE_LIMIT(code[0], max_footprint_mb);

	<span class="enscript-comment">/*
	 * Use the _internal_ variant so that no user-space
	 * process can resume our task from under us.
	 */</span>
	task_suspend_internal(task);
	exception_triage(EXC_RESOURCE, code, EXCEPTION_CODE_MAX);
	task_resume_internal(task);

	<span class="enscript-comment">/*
	 * After the EXC_RESOURCE has been handled, we must clear the
	 * P_MEMSTAT_TERMINATED flag so that the process can again be
	 * considered for jetsam if the memorystatus_thread wakes up.
	 */</span>
	proc_memstat_terminated(current_task()-&gt;bsd_info, FALSE);  <span class="enscript-comment">/* clear the flag */</span>
}

<span class="enscript-comment">/*
 * Callback invoked when a task exceeds its physical footprint limit.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_footprint_exceeded</span>(<span class="enscript-type">int</span> warning, __unused <span class="enscript-type">const</span> <span class="enscript-type">void</span> *param0, __unused <span class="enscript-type">const</span> <span class="enscript-type">void</span> *param1)
{
	ledger_amount_t max_footprint, max_footprint_mb;
	ledger_amount_t footprint_after_purge;
	task_t task;

	<span class="enscript-keyword">if</span> (warning == LEDGER_WARNING_DIPPED_BELOW) {
		<span class="enscript-comment">/*
		 * Task memory limits only provide a warning on the way up.
		 */</span>
		<span class="enscript-keyword">return</span>;
	}

	task = current_task();

	ledger_get_limit(task-&gt;ledger, task_ledgers.phys_footprint, &amp;max_footprint);
	max_footprint_mb = max_footprint &gt;&gt; 20;

	<span class="enscript-comment">/*
	 * Try and purge all &quot;volatile&quot; memory in that task first.
	 */</span>
	(<span class="enscript-type">void</span>) task_purge_volatile_memory(task);
	<span class="enscript-comment">/* are we still over the limit ? */</span>
	ledger_get_balance(task-&gt;ledger,
			   task_ledgers.phys_footprint,
			   &amp;footprint_after_purge);
	<span class="enscript-keyword">if</span> ((!warning &amp;&amp;
	     footprint_after_purge &lt;= max_footprint) ||
	    (warning &amp;&amp;
	     footprint_after_purge &lt;= ((max_footprint *
					PHYS_FOOTPRINT_WARNING_LEVEL) / 100))) {
		<span class="enscript-comment">/* all better now */</span>
		ledger_reset_callback_state(task-&gt;ledger,
					    task_ledgers.phys_footprint);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/* still over the limit after purging... */</span>

	<span class="enscript-comment">/*
	 * If this an actual violation (not a warning),
	 * generate a non-fatal high watermark EXC_RESOURCE.
	 */</span>
	<span class="enscript-keyword">if</span> ((warning == 0) &amp;&amp; (task-&gt;rusage_cpu_flags &amp; TASK_RUSECPU_FLAGS_PHYS_FOOTPRINT_EXCEPTION)) {
		PROC_CROSSED_HIGH_WATERMARK__SEND_EXC_RESOURCE_AND_SUSPEND((<span class="enscript-type">int</span>)max_footprint_mb);
	}

	memorystatus_on_ledger_footprint_exceeded((warning == LEDGER_WARNING_ROSE_ABOVE) ? TRUE : FALSE,
		(<span class="enscript-type">int</span>)max_footprint_mb);
}

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_check_footprint_priv</span>(<span class="enscript-type">void</span>);

kern_return_t
<span class="enscript-function-name">task_set_phys_footprint_limit</span>(
	task_t task,
	<span class="enscript-type">int</span> new_limit_mb,
	<span class="enscript-type">int</span> *old_limit_mb)
{
	kern_return_t error;

	<span class="enscript-keyword">if</span> ((error = proc_check_footprint_priv())) {
		<span class="enscript-keyword">return</span> (KERN_NO_ACCESS);
	}

	<span class="enscript-keyword">return</span> task_set_phys_footprint_limit_internal(task, new_limit_mb, old_limit_mb, FALSE);
}

kern_return_t
<span class="enscript-function-name">task_convert_phys_footprint_limit</span>(
	<span class="enscript-type">int</span> limit_mb,
	<span class="enscript-type">int</span> *converted_limit_mb)
{
	<span class="enscript-keyword">if</span> (limit_mb == -1) {
		<span class="enscript-comment">/*
		 * No limit
		 */</span>
		<span class="enscript-keyword">if</span> (max_task_footprint != 0) {
			*converted_limit_mb = (<span class="enscript-type">int</span>)(max_task_footprint / 1024 / 1024);   <span class="enscript-comment">/* bytes to MB */</span>
		} <span class="enscript-keyword">else</span> {
			*converted_limit_mb = (<span class="enscript-type">int</span>)(LEDGER_LIMIT_INFINITY &gt;&gt; 20);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* nothing to convert */</span>
		*converted_limit_mb = limit_mb;
	}
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}


kern_return_t
<span class="enscript-function-name">task_set_phys_footprint_limit_internal</span>(
	task_t task,
	<span class="enscript-type">int</span> new_limit_mb,
	<span class="enscript-type">int</span> *old_limit_mb,
	boolean_t trigger_exception)
{
	ledger_amount_t	old;

	ledger_get_limit(task-&gt;ledger, task_ledgers.phys_footprint, &amp;old);
	
	<span class="enscript-keyword">if</span> (old_limit_mb) {
		<span class="enscript-comment">/* 
		 * Check that limit &gt;&gt; 20 will not give an &quot;unexpected&quot; 32-bit
		 * result. There are, however, implicit assumptions that -1 mb limit
		 * equates to LEDGER_LIMIT_INFINITY.
		 */</span>
		assert(((old &amp; 0xFFF0000000000000LL) == 0) || (old == LEDGER_LIMIT_INFINITY));
		*old_limit_mb = (<span class="enscript-type">int</span>)(old &gt;&gt; 20);
	}

	<span class="enscript-keyword">if</span> (new_limit_mb == -1) {
		<span class="enscript-comment">/*
		 * Caller wishes to remove the limit.
		 */</span>
		ledger_set_limit(task-&gt;ledger, task_ledgers.phys_footprint,
		                 max_task_footprint ? max_task_footprint : LEDGER_LIMIT_INFINITY,
		                 max_task_footprint ? PHYS_FOOTPRINT_WARNING_LEVEL : 0);
		<span class="enscript-keyword">return</span> (KERN_SUCCESS);
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_NOMONITORS</span>
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_NOMONITORS */</span>

	task_lock(task);

	<span class="enscript-keyword">if</span> (trigger_exception) {
		task-&gt;rusage_cpu_flags |= TASK_RUSECPU_FLAGS_PHYS_FOOTPRINT_EXCEPTION;
	} <span class="enscript-keyword">else</span> {
		task-&gt;rusage_cpu_flags &amp;= ~TASK_RUSECPU_FLAGS_PHYS_FOOTPRINT_EXCEPTION;
	}

	ledger_set_limit(task-&gt;ledger, task_ledgers.phys_footprint,
		(ledger_amount_t)new_limit_mb &lt;&lt; 20, PHYS_FOOTPRINT_WARNING_LEVEL);

        <span class="enscript-keyword">if</span> (task == current_task()) {
                ledger_check_new_balance(task-&gt;ledger, task_ledgers.phys_footprint);
        }

	task_unlock(task);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">task_get_phys_footprint_limit</span>(  	
	task_t task,
	<span class="enscript-type">int</span> *limit_mb)
{
	ledger_amount_t	limit;
    
	ledger_get_limit(task-&gt;ledger, task_ledgers.phys_footprint, &amp;limit);
	<span class="enscript-comment">/* 
	 * Check that limit &gt;&gt; 20 will not give an &quot;unexpected&quot; signed, 32-bit
	 * result. There are, however, implicit assumptions that -1 mb limit
	 * equates to LEDGER_LIMIT_INFINITY.
	 */</span>
	assert(((limit &amp; 0xFFF0000000000000LL) == 0) || (limit == LEDGER_LIMIT_INFINITY));
	*limit_mb = (<span class="enscript-type">int</span>)(limit &gt;&gt; 20);
	
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>
kern_return_t
<span class="enscript-function-name">task_set_phys_footprint_limit</span>(
	__unused task_t task,
	__unused <span class="enscript-type">int</span> new_limit_mb,
	__unused <span class="enscript-type">int</span> *old_limit_mb)
{
	<span class="enscript-keyword">return</span> (KERN_FAILURE);
}

kern_return_t
<span class="enscript-function-name">task_get_phys_footprint_limit</span>(  	
	__unused task_t task,
	__unused <span class="enscript-type">int</span> *limit_mb)
{
	<span class="enscript-keyword">return</span> (KERN_FAILURE);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

<span class="enscript-comment">/*
 * We need to export some functions to other components that
 * are currently implemented in macros within the osfmk
 * component.  Just export them as functions of the same name.
 */</span>
boolean_t <span class="enscript-function-name">is_kerneltask</span>(task_t t)
{
	<span class="enscript-keyword">if</span> (t == kernel_task)
		<span class="enscript-keyword">return</span> (TRUE);

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">check_for_tasksuspend</span>(task_t task)
{

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span> (task-&gt;suspend_count &gt; 0);
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">current_task</span>
task_t <span class="enscript-function-name">current_task</span>(<span class="enscript-type">void</span>);
task_t <span class="enscript-function-name">current_task</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (current_task_fast());
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">task_reference</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">task_reference</span>(task_t task);
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_reference</span>(
	task_t		task)
{
	<span class="enscript-keyword">if</span> (task != TASK_NULL)
		task_reference_internal(task);
}

<span class="enscript-comment">/* defined in bsd/kern/kern_prot.c */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">get_audit_token_pid</span>(audit_token_t *audit_token);

<span class="enscript-type">int</span> <span class="enscript-function-name">task_pid</span>(task_t task)
{
	<span class="enscript-keyword">if</span> (task)
		<span class="enscript-keyword">return</span> get_audit_token_pid(&amp;task-&gt;audit_token);
	<span class="enscript-keyword">return</span> -1;
}


<span class="enscript-comment">/* 
 * This routine is called always with task lock held.
 * And it returns a thread handle without reference as the caller
 * operates on it under the task lock held.
 */</span>
thread_t
<span class="enscript-function-name">task_findtid</span>(task_t task, uint64_t tid)
{
	thread_t thread= THREAD_NULL;

	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
			<span class="enscript-keyword">if</span> (thread-&gt;thread_id == tid)
				<span class="enscript-keyword">return</span>(thread);
	}
	<span class="enscript-keyword">return</span>(THREAD_NULL);
}

<span class="enscript-comment">/*
 * Control the CPU usage monitor for a task.
 */</span>
kern_return_t
<span class="enscript-function-name">task_cpu_usage_monitor_ctl</span>(task_t task, uint32_t *flags)
{
	<span class="enscript-type">int</span> error = KERN_SUCCESS;

	<span class="enscript-keyword">if</span> (*flags &amp; CPUMON_MAKE_FATAL) {
		task-&gt;rusage_cpu_flags |= TASK_RUSECPU_FLAGS_FATAL_CPUMON;
	} <span class="enscript-keyword">else</span> {
		error = KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Control the wakeups monitor for a task.
 */</span>
kern_return_t
<span class="enscript-function-name">task_wakeups_monitor_ctl</span>(task_t task, uint32_t *flags, int32_t *rate_hz)
{
	ledger_t ledger = task-&gt;ledger;

	task_lock(task);
	<span class="enscript-keyword">if</span> (*flags &amp; WAKEMON_GET_PARAMS) {
		ledger_amount_t	limit;
		uint64_t		period;

		ledger_get_limit(ledger, task_ledgers.interrupt_wakeups, &amp;limit);
		ledger_get_period(ledger, task_ledgers.interrupt_wakeups, &amp;period);

		<span class="enscript-keyword">if</span> (limit != LEDGER_LIMIT_INFINITY) {
			<span class="enscript-comment">/*
			 * An active limit means the wakeups monitor is enabled.
			 */</span>
			*rate_hz = (int32_t)(limit / (int64_t)(period / NSEC_PER_SEC));
			*flags = WAKEMON_ENABLE;
			<span class="enscript-keyword">if</span> (task-&gt;rusage_cpu_flags &amp; TASK_RUSECPU_FLAGS_FATAL_WAKEUPSMON) {
				*flags |= WAKEMON_MAKE_FATAL;
			}
		} <span class="enscript-keyword">else</span> {
			*flags = WAKEMON_DISABLE;
			*rate_hz = -1;
		}

		<span class="enscript-comment">/*
		 * If WAKEMON_GET_PARAMS is present in flags, all other flags are ignored.
		 */</span>
 		task_unlock(task);
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	<span class="enscript-keyword">if</span> (*flags &amp; WAKEMON_ENABLE) {
		<span class="enscript-keyword">if</span> (*flags &amp; WAKEMON_SET_DEFAULTS) {
			*rate_hz = task_wakeups_monitor_rate;
		}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">CONFIG_NOMONITORS</span>
		<span class="enscript-keyword">if</span> (*flags &amp; WAKEMON_MAKE_FATAL) {
			task-&gt;rusage_cpu_flags |= TASK_RUSECPU_FLAGS_FATAL_WAKEUPSMON;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_NOMONITORS */</span>

		<span class="enscript-keyword">if</span> (*rate_hz &lt; 0) {
			task_unlock(task);
			<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
		}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">CONFIG_NOMONITORS</span>
		ledger_set_limit(ledger, task_ledgers.interrupt_wakeups, *rate_hz * task_wakeups_monitor_interval,
			task_wakeups_monitor_ustackshots_trigger_pct);
		ledger_set_period(ledger, task_ledgers.interrupt_wakeups, task_wakeups_monitor_interval * NSEC_PER_SEC);
		ledger_enable_callback(ledger, task_ledgers.interrupt_wakeups);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_NOMONITORS */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*flags &amp; WAKEMON_DISABLE) {
		<span class="enscript-comment">/*
		 * Caller wishes to disable wakeups monitor on the task.
		 *
		 * Disable telemetry if it was triggered by the wakeups monitor, and
		 * remove the limit &amp; callback on the wakeups ledger entry.
		 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TELEMETRY</span>
		telemetry_task_ctl_locked(current_task(), TF_WAKEMON_WARNING, 0);
#<span class="enscript-reference">endif</span>
		ledger_disable_refill(ledger, task_ledgers.interrupt_wakeups);
		ledger_disable_callback(ledger, task_ledgers.interrupt_wakeups);
	}

	task_unlock(task);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_wakeups_rate_exceeded</span>(<span class="enscript-type">int</span> warning, __unused <span class="enscript-type">const</span> <span class="enscript-type">void</span> *param0, __unused <span class="enscript-type">const</span> <span class="enscript-type">void</span> *param1)
{
	<span class="enscript-keyword">if</span> (warning == LEDGER_WARNING_ROSE_ABOVE) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TELEMETRY</span>		
		<span class="enscript-comment">/*
		 * This task is in danger of violating the wakeups monitor. Enable telemetry on this task
		 * so there are micro-stackshots available if and when EXC_RESOURCE is triggered.
		 */</span>
		telemetry_task_ctl(current_task(), TF_WAKEMON_WARNING, 1);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TELEMETRY</span>
	<span class="enscript-comment">/*
	 * If the balance has dipped below the warning level (LEDGER_WARNING_DIPPED_BELOW) or
	 * exceeded the limit, turn telemetry off for the task.
	 */</span>
	telemetry_task_ctl(current_task(), TF_WAKEMON_WARNING, 0);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (warning == 0) {
		THIS_PROCESS_IS_CAUSING_TOO_MANY_WAKEUPS__SENDING_EXC_RESOURCE();
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">__attribute__</span>((noinline))
<span class="enscript-function-name">THIS_PROCESS_IS_CAUSING_TOO_MANY_WAKEUPS__SENDING_EXC_RESOURCE</span>(<span class="enscript-type">void</span>)
{
	task_t						task 		= current_task();
	<span class="enscript-type">int</span>							pid         = 0;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>					*procname 	= <span class="enscript-string">&quot;unknown&quot;</span>;
	uint64_t					observed_wakeups_rate;
	uint64_t					permitted_wakeups_rate;
	uint64_t					observation_interval;
	mach_exception_data_type_t	code[EXCEPTION_CODE_MAX];
	<span class="enscript-type">struct</span> ledger_entry_info	lei;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
	pid = proc_selfpid();
	<span class="enscript-keyword">if</span> (task-&gt;bsd_info != NULL)
		procname = proc_name_address(current_task()-&gt;bsd_info);
#<span class="enscript-reference">endif</span>

	ledger_get_entry_info(task-&gt;ledger, task_ledgers.interrupt_wakeups, &amp;lei);

	<span class="enscript-comment">/*
	 * Disable the exception notification so we don't overwhelm
	 * the listener with an endless stream of redundant exceptions.
	 */</span>
	uint32_t flags = WAKEMON_DISABLE;
	task_wakeups_monitor_ctl(task, &amp;flags, NULL);

	observed_wakeups_rate = (lei.lei_balance * (int64_t)NSEC_PER_SEC) / lei.lei_last_refill;
	permitted_wakeups_rate = lei.lei_limit / task_wakeups_monitor_interval;
	observation_interval = lei.lei_refill_period / NSEC_PER_SEC;

	<span class="enscript-keyword">if</span> (disable_exc_resource) {
		printf(<span class="enscript-string">&quot;process %s[%d] caught causing excessive wakeups. EXC_RESOURCE &quot;</span>
			<span class="enscript-string">&quot;supressed by a boot-arg\n&quot;</span>, procname, pid);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (audio_active) {
		printf(<span class="enscript-string">&quot;process %s[%d] caught causing excessive wakeups. EXC_RESOURCE &quot;</span>
		       <span class="enscript-string">&quot;supressed due to audio playback\n&quot;</span>, procname, pid);
		<span class="enscript-keyword">return</span>;
	}
	printf(<span class="enscript-string">&quot;process %s[%d] caught causing excessive wakeups. Observed wakeups rate &quot;</span>
		<span class="enscript-string">&quot;(per sec): %lld; Maximum permitted wakeups rate (per sec): %lld; Observation &quot;</span>
		<span class="enscript-string">&quot;period: %lld seconds; Task lifetime number of wakeups: %lld\n&quot;</span>,
		procname, pid, observed_wakeups_rate, permitted_wakeups_rate,
		observation_interval, lei.lei_credit);

	code[0] = code[1] = 0;
	EXC_RESOURCE_ENCODE_TYPE(code[0], RESOURCE_TYPE_WAKEUPS);
	EXC_RESOURCE_ENCODE_FLAVOR(code[0], FLAVOR_WAKEUPS_MONITOR);
	EXC_RESOURCE_CPUMONITOR_ENCODE_WAKEUPS_PERMITTED(code[0], task_wakeups_monitor_rate);
	EXC_RESOURCE_CPUMONITOR_ENCODE_OBSERVATION_INTERVAL(code[0], observation_interval);
	EXC_RESOURCE_CPUMONITOR_ENCODE_WAKEUPS_OBSERVED(code[1], lei.lei_balance * (int64_t)NSEC_PER_SEC / lei.lei_last_refill);	
	exception_triage(EXC_RESOURCE, code, EXCEPTION_CODE_MAX);

	<span class="enscript-keyword">if</span> (task-&gt;rusage_cpu_flags &amp; TASK_RUSECPU_FLAGS_FATAL_WAKEUPSMON) {
		task_terminate_internal(task);
	}
}

kern_return_t
<span class="enscript-function-name">task_purge_volatile_memory</span>(
	task_t	task)
{
	vm_map_t	map;
	<span class="enscript-type">int</span>		num_object_purged;

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	task_lock(task);

	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		task_unlock(task);
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;
	}
	map = task-&gt;map;
	<span class="enscript-keyword">if</span> (map == VM_MAP_NULL) {
		task_unlock(task);
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;
	}
	vm_map_reference(task-&gt;map);

	task_unlock(task);

	num_object_purged = vm_map_purge(map);
	vm_map_deallocate(map);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/* Placeholders for the task set/get voucher interfaces */</span>
kern_return_t 
<span class="enscript-function-name">task_get_mach_voucher</span>(
	task_t			task,
	mach_voucher_selector_t __unused which,
	ipc_voucher_t		*voucher)
{
	<span class="enscript-keyword">if</span> (TASK_NULL == task)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	*voucher = NULL;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t 
<span class="enscript-function-name">task_set_mach_voucher</span>(
	task_t			task,
	ipc_voucher_t		__unused voucher)
{
	<span class="enscript-keyword">if</span> (TASK_NULL == task)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">task_swap_mach_voucher</span>(
	task_t			task,
	ipc_voucher_t		new_voucher,
	ipc_voucher_t		*in_out_old_voucher)
{
	<span class="enscript-keyword">if</span> (TASK_NULL == task)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	*in_out_old_voucher = new_voucher;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">task_set_gpu_denied</span>(task_t task, boolean_t denied)
{
	task_lock(task);

	<span class="enscript-keyword">if</span> (denied) {
		task-&gt;t_flags |= TF_GPU_DENIED;
	} <span class="enscript-keyword">else</span> {
		task-&gt;t_flags &amp;= ~TF_GPU_DENIED;
	}

	task_unlock(task);
}

boolean_t <span class="enscript-function-name">task_is_gpu_denied</span>(task_t task)
{
	<span class="enscript-comment">/* We don't need the lock to read this flag */</span>
	<span class="enscript-keyword">return</span> (task-&gt;t_flags &amp; TF_GPU_DENIED) ? TRUE : FALSE;
}
</pre>
<hr />
</body></html>