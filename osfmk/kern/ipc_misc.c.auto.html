<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ipc_misc.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ipc_misc.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008, 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/notify.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_kobject.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_misc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">fileport_releasefg</span>(<span class="enscript-type">struct</span> fileglob *);

<span class="enscript-comment">/*
 * fileport_alloc
 *
 * Description: Obtain a send right for the given fileglob, which must be
 *		referenced.
 *
 * Parameters: 	fg		A fileglob.
 *
 * Returns: 	Port of type IKOT_FILEPORT with fileglob set as its kobject. 
 * 		Port is returned with a send right.
 */</span>
ipc_port_t
<span class="enscript-function-name">fileport_alloc</span>(<span class="enscript-type">struct</span> fileglob *fg)
{
	ipc_port_t fileport;
	ipc_port_t sendport;
	ipc_port_t notifyport;

	fileport = ipc_port_alloc_kernel();
	<span class="enscript-keyword">if</span> (fileport == IP_NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	ipc_kobject_set(fileport, (ipc_kobject_t)fg, IKOT_FILEPORT);
	ip_lock(fileport); <span class="enscript-comment">/* unlocked by ipc_port_nsrequest */</span>
	notifyport = ipc_port_make_sonce_locked(fileport);
	ipc_port_nsrequest(fileport, 1, notifyport, &amp;notifyport);

	sendport = ipc_port_make_send(fileport);
	<span class="enscript-keyword">if</span> (!IP_VALID(sendport)) {
		panic(<span class="enscript-string">&quot;Couldn't allocate send right for fileport!\n&quot;</span>);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> fileport;
}


<span class="enscript-comment">/*
 * fileport_get_fileglob
 *
 * Description: Obtain the fileglob associated with a given port.
 *
 * Parameters: port		A Mach port of type IKOT_FILEPORT.
 *
 * Returns:    NULL		The given Mach port did not reference a
 *				fileglob.
 *	       !NULL		The fileglob that is associated with the
 *				Mach port.
 *
 * Notes: The caller must have a reference on the fileport.
 */</span>
<span class="enscript-type">struct</span> fileglob *
<span class="enscript-function-name">fileport_port_to_fileglob</span>(ipc_port_t port)
{
	<span class="enscript-type">struct</span> fileglob *fg = NULL;

	<span class="enscript-keyword">if</span> (!IP_VALID(port))
		<span class="enscript-keyword">return</span> NULL;

	ip_lock(port);
	<span class="enscript-keyword">if</span> (ip_active(port) &amp;&amp; IKOT_FILEPORT == ip_kotype(port))
		fg = (<span class="enscript-type">void</span> *)port-&gt;ip_kobject;
	ip_unlock(port);

	<span class="enscript-keyword">return</span> fg;
}


<span class="enscript-comment">/*
 * fileport_notify
 *
 * Description: Handle a no-senders notification for a fileport.  Unless
 * 		the message is spoofed, destroys the port and releases
 * 		its reference on the fileglob.
 *
 * Parameters: msg		A Mach no-senders notification message.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fileport_notify</span>(mach_msg_header_t *msg)
{
	mach_no_senders_notification_t *notification = (<span class="enscript-type">void</span> *)msg;
	ipc_port_t port = notification-&gt;not_header.msgh_remote_port;
	<span class="enscript-type">struct</span> fileglob *fg = NULL;

	<span class="enscript-keyword">if</span> (!IP_VALID(port))
		panic(<span class="enscript-string">&quot;Invalid port passed to fileport_notify()\n&quot;</span>);

	ip_lock(port);

	fg = (<span class="enscript-type">struct</span> fileglob *)port-&gt;ip_kobject;

	<span class="enscript-keyword">if</span> (!ip_active(port)) 
		panic(<span class="enscript-string">&quot;Inactive port passed to fileport_notify()\n&quot;</span>);
	<span class="enscript-keyword">if</span> (ip_kotype(port) != IKOT_FILEPORT) 
		panic(<span class="enscript-string">&quot;Port of type other than IKOT_FILEPORT passed to fileport_notify()\n&quot;</span>);
	<span class="enscript-keyword">if</span> (fg == NULL) 
		panic(<span class="enscript-string">&quot;fileport without an assocated fileglob\n&quot;</span>);

	<span class="enscript-keyword">if</span> (port-&gt;ip_srights == 0) {
		ip_unlock(port);

		fileport_releasefg(fg);
		ipc_port_dealloc_kernel(port);
	} <span class="enscript-keyword">else</span> {
		ip_unlock(port);
	}
}

<span class="enscript-comment">/*
 * fileport_invoke
 *
 * Description: Invoke a function with the fileglob underlying the fileport.
 *		Returns the error code related to the fileglob lookup.
 *
 * Parameters:	task		The target task
 *		action		The function to invoke with the fileglob
 *		arg		Anonymous pointer to caller state
 *		rval		The value returned from calling 'action'
 */</span>
kern_return_t
<span class="enscript-function-name">fileport_invoke</span>(task_t task, mach_port_name_t name,
	<span class="enscript-type">int</span> (*action)(mach_port_name_t, <span class="enscript-type">struct</span> fileglob *, <span class="enscript-type">void</span> *),
	<span class="enscript-type">void</span> *arg, <span class="enscript-type">int</span> *rval)
{
	kern_return_t kr;
	ipc_port_t fileport;
	<span class="enscript-type">struct</span> fileglob *fg;

	kr = ipc_object_copyin(task-&gt;itk_space, name,
	    MACH_MSG_TYPE_COPY_SEND, (ipc_object_t *)&amp;fileport);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> (kr);

	<span class="enscript-keyword">if</span> ((fg = fileport_port_to_fileglob(fileport)) != NULL)
		*rval = (*action)(name, fg, arg);
	<span class="enscript-keyword">else</span>
		kr = KERN_FAILURE;
	ipc_port_release_send(fileport);
	<span class="enscript-keyword">return</span> (kr);
}

<span class="enscript-comment">/*
 * fileport_walk
 *
 * Description: Invoke the action function on every fileport in the task.
 *
 *		This could be more efficient if we refactored mach_port_names()
 *		so that (a) it didn't compute the type information unless asked
 *		and (b) it could be asked to -not- unwire/copyout the memory
 *		and (c) if we could ask for port names by kobject type. Not
 *		clear that it's worth all that complexity, though.
 *
 * Parameters: 	task		The target task
 *		action		The function to invoke on each fileport
 *		arg		Anonymous pointer to caller state.
 */</span>
kern_return_t
<span class="enscript-function-name">fileport_walk</span>(task_t task,
	<span class="enscript-type">int</span> (*action)(mach_port_name_t, <span class="enscript-type">struct</span> fileglob *, <span class="enscript-type">void</span> *arg),
	<span class="enscript-type">void</span> *arg)
{
	mach_port_name_t *names;
	mach_msg_type_number_t ncnt, tcnt;
	vm_map_copy_t map_copy_names, map_copy_types;
	vm_map_address_t map_names;
	kern_return_t kr;
	uint_t i;
	<span class="enscript-type">int</span> rval;

	<span class="enscript-comment">/*
	 * mach_port_names returns the 'name' and 'types' in copied-in
	 * form.  Discard 'types' immediately, then copyout 'names'
	 * back into the kernel before walking the array.
	 */</span>

	kr = mach_port_names(task-&gt;itk_space,
	    (mach_port_name_t **)&amp;map_copy_names, &amp;ncnt,
	    (mach_port_type_t **)&amp;map_copy_types, &amp;tcnt);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> (kr);

	vm_map_copy_discard(map_copy_types);

	kr = vm_map_copyout(ipc_kernel_map, &amp;map_names, map_copy_names);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		vm_map_copy_discard(map_copy_names);
		<span class="enscript-keyword">return</span> (kr);
	}
	names = (mach_port_name_t *)(uintptr_t)map_names;

	<span class="enscript-keyword">for</span> (rval = 0, i = 0; i &lt; ncnt; i++)
		<span class="enscript-keyword">if</span> (fileport_invoke(task, names[i], action, arg,
		    &amp;rval) == KERN_SUCCESS &amp;&amp; -1 == rval)
			<span class="enscript-keyword">break</span>;		<span class="enscript-comment">/* early termination clause */</span>

	vm_deallocate(ipc_kernel_map,
	    (vm_address_t)names, ncnt * <span class="enscript-keyword">sizeof</span> (*names));
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}
</pre>
<hr />
</body></html>