<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ledger.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ledger.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2010 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ledger.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>

<span class="enscript-comment">/*
 * Ledger entry flags. Bits in second nibble (masked by 0xF0) are used for
 * ledger actions (LEDGER_ACTION_BLOCK, etc).
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LF_ENTRY_ACTIVE</span>         0x0001	<span class="enscript-comment">/* entry is active if set */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LF_WAKE_NEEDED</span>          0x0100	<span class="enscript-comment">/* one or more threads are asleep */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LF_WAKE_INPROGRESS</span>      0x0200	<span class="enscript-comment">/* the wait queue is being processed */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LF_REFILL_SCHEDULED</span>     0x0400	<span class="enscript-comment">/* a refill timer has been set */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LF_REFILL_INPROGRESS</span>    0x0800	<span class="enscript-comment">/* the ledger is being refilled */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LF_CALLED_BACK</span>          0x1000	<span class="enscript-comment">/* callback was called for balance in deficit */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LF_WARNED</span>               0x2000	<span class="enscript-comment">/* callback was called for balance warning */</span> 
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LF_TRACKING_MAX</span>		0x4000	<span class="enscript-comment">/* track max balance over user-specfied time */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LF_PANIC_ON_NEGATIVE</span>	0x8000	<span class="enscript-comment">/* panic if it goes negative */</span>

<span class="enscript-comment">/* Determine whether a ledger entry exists and has been initialized and active */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ENTRY_VALID</span>(l, e)					\
	(((l) != NULL) &amp;&amp; ((e) &gt;= 0) &amp;&amp; ((e) &lt; (l)-&gt;l_size) &amp;&amp;	\
	(((l)-&gt;l_entries[e].le_flags &amp; LF_ENTRY_ACTIVE) == LF_ENTRY_ACTIVE))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT</span>(a) assert(a)

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LEDGER_DEBUG</span>
<span class="enscript-type">int</span> ledger_debug = 0;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">lprintf</span>(a) if (ledger_debug) {					\
	printf(<span class="enscript-string">&quot;%lld  &quot;</span>, abstime_to_nsecs(mach_absolute_time() / 1000000)); \
	printf a ;							\
}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">lprintf</span>(a)
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> ledger_callback {
	ledger_callback_t	lc_func;
	<span class="enscript-type">const</span> <span class="enscript-type">void</span>		*lc_param0;
	<span class="enscript-type">const</span> <span class="enscript-type">void</span>		*lc_param1;
};

<span class="enscript-type">struct</span> entry_template {
	<span class="enscript-type">char</span>			et_key[LEDGER_NAME_MAX];
	<span class="enscript-type">char</span>			et_group[LEDGER_NAME_MAX];
	<span class="enscript-type">char</span>			et_units[LEDGER_NAME_MAX];
	uint32_t		et_flags;
	<span class="enscript-type">struct</span> ledger_callback	*et_callback;
};

lck_grp_t ledger_lck_grp;

<span class="enscript-comment">/*
 * Modifying the reference count, table size, or table contents requires
 * holding the lt_lock.  Modfying the table address requires both lt_lock
 * and setting the inuse bit.  This means that the lt_entries field can be
 * safely dereferenced if you hold either the lock or the inuse bit.  The
 * inuse bit exists solely to allow us to swap in a new, larger entries
 * table without requiring a full lock to be acquired on each lookup.
 * Accordingly, the inuse bit should never be held for longer than it takes
 * to extract a value from the table - i.e., 2 or 3 memory references.
 */</span>
<span class="enscript-type">struct</span> ledger_template {
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>		*lt_name;
	<span class="enscript-type">int</span>			lt_refs;
	<span class="enscript-type">int</span>			lt_cnt;
	<span class="enscript-type">int</span>			lt_table_size;
	<span class="enscript-type">volatile</span> uint32_t	lt_inuse;
	lck_mtx_t		lt_lock;
	<span class="enscript-type">struct</span> entry_template	*lt_entries;
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">template_lock</span>(template)		lck_mtx_lock(&amp;(template)-&gt;lt_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">template_unlock</span>(template)	lck_mtx_unlock(&amp;(template)-&gt;lt_lock)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">TEMPLATE_INUSE</span>(s, t) { 					\
	s = splsched();						\
	<span class="enscript-keyword">while</span> (OSCompareAndSwap(0, 1, &amp;((t)-&gt;lt_inuse)))	\
		;						\
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">TEMPLATE_IDLE</span>(s, t) { 					\
	(t)-&gt;lt_inuse = 0;					\
	splx(s);						\
}

<span class="enscript-comment">/*
 * Use 2 &quot;tocks&quot; to track the rolling maximum balance of a ledger entry.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NTOCKS</span> 2
<span class="enscript-comment">/*
 * The explicit alignment is to ensure that atomic operations don't panic
 * on ARM.
 */</span>
<span class="enscript-type">struct</span> ledger_entry {
        <span class="enscript-type">volatile</span> uint32_t               le_flags;
        ledger_amount_t                 le_limit;
        ledger_amount_t                 le_warn_level;
        <span class="enscript-type">volatile</span> ledger_amount_t        le_credit __attribute__((aligned(8)));
        <span class="enscript-type">volatile</span> ledger_amount_t        le_debit  __attribute__((aligned(8)));
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			<span class="enscript-comment">/*
			 * XXX - the following two fields can go away if we move all of
			 * the refill logic into process policy
			 */</span>
		        uint64_t	le_refill_period;
		        uint64_t	le_last_refill;
		} le_refill;
		<span class="enscript-type">struct</span> _le_peak {
			uint32_t 	le_max;  <span class="enscript-comment">/* Lower 32-bits of observed max balance */</span>
			uint32_t	le_time; <span class="enscript-comment">/* time when this peak was observed */</span>
		} le_peaks[NTOCKS];
	} _le;
} __attribute__((aligned(8)));

<span class="enscript-type">struct</span> ledger {
	<span class="enscript-type">int</span>			l_id;
	<span class="enscript-type">struct</span> ledger_template	*l_template;
	<span class="enscript-type">int</span>			l_refs;
	<span class="enscript-type">int</span>			l_size;
	<span class="enscript-type">struct</span> ledger_entry	*l_entries;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ledger_cnt = 0;
<span class="enscript-comment">/* ledger ast helper functions */</span>
<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">ledger_check_needblock</span>(ledger_t l, uint64_t now);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">ledger_perform_blocking</span>(ledger_t l);
<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">flag_set</span>(<span class="enscript-type">volatile</span> uint32_t *flags, uint32_t bit);
<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">flag_clear</span>(<span class="enscript-type">volatile</span> uint32_t *flags, uint32_t bit);

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">debug_callback</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *p0, __unused <span class="enscript-type">const</span> <span class="enscript-type">void</span> *p1)
{
	printf(<span class="enscript-string">&quot;ledger: resource exhausted [%s] for task %p\n&quot;</span>,
	    (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)p0, p1);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/************************************/</span>

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">abstime_to_nsecs</span>(uint64_t abstime)
{
	uint64_t nsecs;

	absolutetime_to_nanoseconds(abstime, &amp;nsecs);
	<span class="enscript-keyword">return</span> (nsecs);
}

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">nsecs_to_abstime</span>(uint64_t nsecs)
{
	uint64_t abstime;

	nanoseconds_to_absolutetime(nsecs, &amp;abstime);
	<span class="enscript-keyword">return</span> (abstime);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ledger_init</span>(<span class="enscript-type">void</span>)
{
        lck_grp_init(&amp;ledger_lck_grp, <span class="enscript-string">&quot;ledger&quot;</span>, LCK_GRP_ATTR_NULL);
}

ledger_template_t
<span class="enscript-function-name">ledger_template_create</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	ledger_template_t template;

	template = (ledger_template_t)kalloc(<span class="enscript-keyword">sizeof</span> (*template));
	<span class="enscript-keyword">if</span> (template == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	template-&gt;lt_name = name;
	template-&gt;lt_refs = 1;
	template-&gt;lt_cnt = 0;
	template-&gt;lt_table_size = 1;
	template-&gt;lt_inuse = 0;
	lck_mtx_init(&amp;template-&gt;lt_lock, &amp;ledger_lck_grp, LCK_ATTR_NULL);

	template-&gt;lt_entries = (<span class="enscript-type">struct</span> entry_template *)
	    kalloc(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> entry_template) * template-&gt;lt_table_size);
	<span class="enscript-keyword">if</span> (template-&gt;lt_entries == NULL) {
		kfree(template, <span class="enscript-keyword">sizeof</span> (*template));
		template = NULL;
	}

	<span class="enscript-keyword">return</span> (template);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ledger_template_dereference</span>(ledger_template_t template)
{
	template_lock(template);
	template-&gt;lt_refs--;
	template_unlock(template);

	<span class="enscript-keyword">if</span> (template-&gt;lt_refs == 0)
		kfree(template, <span class="enscript-keyword">sizeof</span> (*template));
}

<span class="enscript-comment">/*
 * Add a new entry to the list of entries in a ledger template. There is
 * currently no mechanism to remove an entry.  Implementing such a mechanism
 * would require us to maintain per-entry reference counts, which we would
 * prefer to avoid if possible.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ledger_entry_add</span>(ledger_template_t template, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *key,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *group, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *units)
{
	<span class="enscript-type">int</span> idx;
	<span class="enscript-type">struct</span> entry_template *et;

	<span class="enscript-keyword">if</span> ((key == NULL) || (strlen(key) &gt;= LEDGER_NAME_MAX))
		<span class="enscript-keyword">return</span> (-1);

	template_lock(template);

	<span class="enscript-comment">/* If the table is full, attempt to double its size */</span>
	<span class="enscript-keyword">if</span> (template-&gt;lt_cnt == template-&gt;lt_table_size) {
		<span class="enscript-type">struct</span> entry_template *new_entries, *old_entries;
		<span class="enscript-type">int</span> old_cnt, old_sz;
		spl_t s;

		old_cnt = template-&gt;lt_table_size;
		old_sz = (<span class="enscript-type">int</span>)(old_cnt * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> entry_template));
		new_entries = kalloc(old_sz * 2);
		<span class="enscript-keyword">if</span> (new_entries == NULL) {
			template_unlock(template);
			<span class="enscript-keyword">return</span> (-1);
		}
		memcpy(new_entries, template-&gt;lt_entries, old_sz);
		memset(((<span class="enscript-type">char</span> *)new_entries) + old_sz, 0, old_sz);
		template-&gt;lt_table_size = old_cnt * 2;

		old_entries = template-&gt;lt_entries;

		TEMPLATE_INUSE(s, template);
		template-&gt;lt_entries = new_entries;
		TEMPLATE_IDLE(s, template);

		kfree(old_entries, old_sz);
	}

	et = &amp;template-&gt;lt_entries[template-&gt;lt_cnt];
	strlcpy(et-&gt;et_key, key, LEDGER_NAME_MAX);
	strlcpy(et-&gt;et_group, group, LEDGER_NAME_MAX);
	strlcpy(et-&gt;et_units, units, LEDGER_NAME_MAX);
	et-&gt;et_flags = LF_ENTRY_ACTIVE;
	et-&gt;et_callback = NULL;

	idx = template-&gt;lt_cnt++;
	template_unlock(template);

	<span class="enscript-keyword">return</span> (idx);
}


kern_return_t
<span class="enscript-function-name">ledger_entry_setactive</span>(ledger_t ledger, <span class="enscript-type">int</span> entry)
{
	<span class="enscript-type">struct</span> ledger_entry *le;

	<span class="enscript-keyword">if</span> ((ledger == NULL)  || (entry &lt; 0) || (entry &gt;= ledger-&gt;l_size))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	le = &amp;ledger-&gt;l_entries[entry];
	<span class="enscript-keyword">if</span> ((le-&gt;le_flags &amp; LF_ENTRY_ACTIVE) == 0) {
		flag_set(&amp;le-&gt;le_flags, LF_ENTRY_ACTIVE);
	}
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">ledger_key_lookup</span>(ledger_template_t template, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *key)
{
	<span class="enscript-type">int</span> idx;

	template_lock(template);
	<span class="enscript-keyword">for</span> (idx = 0; idx &lt; template-&gt;lt_cnt; idx++)
		<span class="enscript-keyword">if</span> (template-&gt;lt_entries != NULL &amp;&amp;
		    (strcmp(key, template-&gt;lt_entries[idx].et_key) == 0))
			<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">if</span> (idx &gt;= template-&gt;lt_cnt)
		idx = -1;
	template_unlock(template);

	<span class="enscript-keyword">return</span> (idx);
}

<span class="enscript-comment">/*
 * Create a new ledger based on the specified template.  As part of the
 * ledger creation we need to allocate space for a table of ledger entries.
 * The size of the table is based on the size of the template at the time
 * the ledger is created.  If additional entries are added to the template
 * after the ledger is created, they will not be tracked in this ledger.
 */</span>
ledger_t
<span class="enscript-function-name">ledger_instantiate</span>(ledger_template_t template, <span class="enscript-type">int</span> entry_type)
{
	ledger_t ledger;
	size_t sz;
	<span class="enscript-type">int</span> i;

	ledger = (ledger_t)kalloc(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ledger));
	<span class="enscript-keyword">if</span> (ledger == NULL)
		<span class="enscript-keyword">return</span> (LEDGER_NULL);

	ledger-&gt;l_template = template;
	ledger-&gt;l_id = ledger_cnt++;
	ledger-&gt;l_refs = 1;

	template_lock(template);
	template-&gt;lt_refs++;
	ledger-&gt;l_size = template-&gt;lt_cnt;
	template_unlock(template);

	sz = ledger-&gt;l_size * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ledger_entry);
	ledger-&gt;l_entries = kalloc(sz);
	<span class="enscript-keyword">if</span> (sz &amp;&amp; (ledger-&gt;l_entries == NULL)) {
		ledger_template_dereference(template);
		kfree(ledger, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ledger));
		<span class="enscript-keyword">return</span> (LEDGER_NULL);
	}

	template_lock(template);
	assert(ledger-&gt;l_size &lt;= template-&gt;lt_cnt);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; ledger-&gt;l_size; i++) {
		<span class="enscript-type">struct</span> ledger_entry *le = &amp;ledger-&gt;l_entries[i];
		<span class="enscript-type">struct</span> entry_template *et = &amp;template-&gt;lt_entries[i];

		le-&gt;le_flags = et-&gt;et_flags;
		<span class="enscript-comment">/* make entry inactive by removing  active bit */</span>
		<span class="enscript-keyword">if</span> (entry_type == LEDGER_CREATE_INACTIVE_ENTRIES)
			flag_clear(&amp;le-&gt;le_flags, LF_ENTRY_ACTIVE);
		<span class="enscript-comment">/*
		 * If template has a callback, this entry is opted-in,
		 * by default.
		 */</span>
		<span class="enscript-keyword">if</span> (et-&gt;et_callback != NULL)
			flag_set(&amp;le-&gt;le_flags, LEDGER_ACTION_CALLBACK);
		le-&gt;le_credit        = 0;
		le-&gt;le_debit         = 0;
		le-&gt;le_limit         = LEDGER_LIMIT_INFINITY;
		le-&gt;le_warn_level    = LEDGER_LIMIT_INFINITY;		
		le-&gt;_le.le_refill.le_refill_period = 0;
		le-&gt;_le.le_refill.le_last_refill   = 0;
	}
	template_unlock(template);

	<span class="enscript-keyword">return</span> (ledger);
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">flag_set</span>(<span class="enscript-type">volatile</span> uint32_t *flags, uint32_t bit)
{
	<span class="enscript-keyword">return</span> (OSBitOrAtomic(bit, flags));
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">flag_clear</span>(<span class="enscript-type">volatile</span> uint32_t *flags, uint32_t bit)
{
	<span class="enscript-keyword">return</span> (OSBitAndAtomic(~bit, flags));
}

<span class="enscript-comment">/*
 * Take a reference on a ledger
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_reference</span>(ledger_t ledger)
{
	<span class="enscript-keyword">if</span> (!LEDGER_VALID(ledger))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
	OSIncrementAtomic(&amp;ledger-&gt;l_refs);
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ledger_reference_count</span>(ledger_t ledger)
{
	<span class="enscript-keyword">if</span> (!LEDGER_VALID(ledger))
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">return</span> (ledger-&gt;l_refs);
}

<span class="enscript-comment">/*
 * Remove a reference on a ledger.  If this is the last reference,
 * deallocate the unused ledger.
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_dereference</span>(ledger_t ledger)
{
	<span class="enscript-type">int</span> v;

	<span class="enscript-keyword">if</span> (!LEDGER_VALID(ledger))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	v = OSDecrementAtomic(&amp;ledger-&gt;l_refs);
	ASSERT(v &gt;= 1);

	<span class="enscript-comment">/* Just released the last reference.  Free it. */</span>
	<span class="enscript-keyword">if</span> (v == 1) {
		kfree(ledger-&gt;l_entries,
		    ledger-&gt;l_size * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ledger_entry));
		kfree(ledger, <span class="enscript-keyword">sizeof</span> (*ledger));
	}

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Determine whether an entry has exceeded its warning level.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">warn_level_exceeded</span>(<span class="enscript-type">struct</span> ledger_entry *le)
{
	ledger_amount_t balance;

	assert((le-&gt;le_credit &gt;= 0) &amp;&amp; (le-&gt;le_debit &gt;= 0));

	<span class="enscript-comment">/*
	 * XXX - Currently, we only support warnings for ledgers which
	 * use positive limits.
	 */</span>
	balance = le-&gt;le_credit - le-&gt;le_debit;
	<span class="enscript-keyword">if</span> ((le-&gt;le_warn_level != LEDGER_LIMIT_INFINITY) &amp;&amp; (balance &gt; le-&gt;le_warn_level))
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Determine whether an entry has exceeded its limit.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">limit_exceeded</span>(<span class="enscript-type">struct</span> ledger_entry *le)
{
	ledger_amount_t balance;

	assert((le-&gt;le_credit &gt;= 0) &amp;&amp; (le-&gt;le_debit &gt;= 0));

	balance = le-&gt;le_credit - le-&gt;le_debit;
	<span class="enscript-keyword">if</span> ((le-&gt;le_limit &lt;= 0) &amp;&amp; (balance &lt; le-&gt;le_limit))
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">if</span> ((le-&gt;le_limit &gt; 0) &amp;&amp; (balance &gt; le-&gt;le_limit))
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">struct</span> ledger_callback *
<span class="enscript-function-name">entry_get_callback</span>(ledger_t ledger, <span class="enscript-type">int</span> entry)
{
	<span class="enscript-type">struct</span> ledger_callback *callback;
	spl_t s;

	TEMPLATE_INUSE(s, ledger-&gt;l_template);
	callback = ledger-&gt;l_template-&gt;lt_entries[entry].et_callback;
	TEMPLATE_IDLE(s, ledger-&gt;l_template);

	<span class="enscript-keyword">return</span> (callback);
}

<span class="enscript-comment">/*
 * If the ledger value is positive, wake up anybody waiting on it.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">ledger_limit_entry_wakeup</span>(<span class="enscript-type">struct</span> ledger_entry *le)
{
	uint32_t flags;

	<span class="enscript-keyword">if</span> (!limit_exceeded(le)) {
		flags = flag_clear(&amp;le-&gt;le_flags, LF_CALLED_BACK);

		<span class="enscript-keyword">while</span> (le-&gt;le_flags &amp; LF_WAKE_NEEDED) {
			flag_clear(&amp;le-&gt;le_flags, LF_WAKE_NEEDED);
			thread_wakeup((event_t)le);
		}
	}
}

<span class="enscript-comment">/*
 * Refill the coffers.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ledger_refill</span>(uint64_t now, ledger_t ledger, <span class="enscript-type">int</span> entry)
{
	uint64_t elapsed, period, periods;
	<span class="enscript-type">struct</span> ledger_entry *le;
	ledger_amount_t balance, due;

	le = &amp;ledger-&gt;l_entries[entry];

	assert(le-&gt;le_limit != LEDGER_LIMIT_INFINITY);

	<span class="enscript-comment">/*
	 * If another thread is handling the refill already, we're not
	 * needed.
	 */</span>
	<span class="enscript-keyword">if</span> (flag_set(&amp;le-&gt;le_flags, LF_REFILL_INPROGRESS) &amp; LF_REFILL_INPROGRESS) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * If the timestamp we're about to use to refill is older than the
	 * last refill, then someone else has already refilled this ledger
	 * and there's nothing for us to do here.
	 */</span>
	<span class="enscript-keyword">if</span> (now &lt;= le-&gt;_le.le_refill.le_last_refill) {
		flag_clear(&amp;le-&gt;le_flags, LF_REFILL_INPROGRESS);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * See how many refill periods have passed since we last
	 * did a refill.
	 */</span>
	period = le-&gt;_le.le_refill.le_refill_period;
	elapsed = now - le-&gt;_le.le_refill.le_last_refill;
	<span class="enscript-keyword">if</span> ((period == 0) || (elapsed &lt; period)) {
		flag_clear(&amp;le-&gt;le_flags, LF_REFILL_INPROGRESS);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * Optimize for the most common case of only one or two
	 * periods elapsing.
	 */</span>
	periods = 0;
	<span class="enscript-keyword">while</span> ((periods &lt; 2) &amp;&amp; (elapsed &gt; 0)) {
		periods++;
		elapsed -= period;
	}

	<span class="enscript-comment">/*
	 * OK, it's been a long time.  Do a divide to figure out
	 * how long.
	 */</span>
	<span class="enscript-keyword">if</span> (elapsed &gt; 0)
		periods = (now - le-&gt;_le.le_refill.le_last_refill) / period;

	balance = le-&gt;le_credit - le-&gt;le_debit;
	due = periods * le-&gt;le_limit;
	<span class="enscript-keyword">if</span> (balance - due &lt; 0)
		due = balance;

	assert(due &gt;= 0);

	OSAddAtomic64(due, &amp;le-&gt;le_debit);

	assert(le-&gt;le_debit &gt;= 0);

	<span class="enscript-comment">/*
	 * If we've completely refilled the pool, set the refill time to now.
	 * Otherwise set it to the time at which it last should have been
	 * fully refilled.
	 */</span>
	<span class="enscript-keyword">if</span> (balance == due)
		le-&gt;_le.le_refill.le_last_refill = now;
	<span class="enscript-keyword">else</span>
		le-&gt;_le.le_refill.le_last_refill += (le-&gt;_le.le_refill.le_refill_period * periods);

	flag_clear(&amp;le-&gt;le_flags, LF_REFILL_INPROGRESS);

	lprintf((<span class="enscript-string">&quot;Refill %lld %lld-&gt;%lld\n&quot;</span>, periods, balance, balance - due));
	<span class="enscript-keyword">if</span> (!limit_exceeded(le))
		ledger_limit_entry_wakeup(le);
}

<span class="enscript-comment">/*
 * In tenths of a second, the length of one lookback period (a &quot;tock&quot;) for
 * ledger rolling maximum calculations. The effective lookback window will be this times
 * NTOCKS.
 *
 * Use a tock length of 2.5 seconds to get a total lookback period of 5 seconds.
 *
 * XXX Could make this caller-definable, at the point that rolling max tracking
 * is enabled for the entry.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TOCKLEN</span> 25

<span class="enscript-comment">/*
 * How many sched_tick's are there in one tock (one of our lookback periods)?
 *
 *  X sched_ticks        2.5 sec      N sched_ticks
 * ---------------   =  ----------  * -------------
 *      tock               tock            sec
 *
 * where N sched_ticks/sec is calculated via 1 &lt;&lt; SCHED_TICK_SHIFT (see sched_prim.h)
 *
 * This should give us 20 sched_tick's in one 2.5 second-long tock.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SCHED_TICKS_PER_TOCK</span> ((TOCKLEN * (1 &lt;&lt; SCHED_TICK_SHIFT)) / 10)

<span class="enscript-comment">/*
 * Rolling max timestamps use their own unit (let's call this a &quot;tock&quot;). One tock is the
 * length of one lookback period that we use for our rolling max calculation.
 *
 * Calculate the current time in tocks from sched_tick (which runs at a some
 * fixed rate).
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">CURRENT_TOCKSTAMP</span>() (sched_tick / SCHED_TICKS_PER_TOCK)

<span class="enscript-comment">/*
 * Does the given tockstamp fall in either the current or the previous tocks?
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TOCKSTAMP_IS_STALE</span>(now, tock) ((((now) - (tock)) &lt; NTOCKS) ? FALSE : TRUE)

<span class="enscript-type">void</span>
<span class="enscript-function-name">ledger_check_new_balance</span>(ledger_t ledger, <span class="enscript-type">int</span> entry)
{
	<span class="enscript-type">struct</span> ledger_entry *le;

	le = &amp;ledger-&gt;l_entries[entry];

	<span class="enscript-keyword">if</span> (le-&gt;le_flags &amp; LF_TRACKING_MAX) {
		ledger_amount_t balance = le-&gt;le_credit - le-&gt;le_debit;
		uint32_t now = CURRENT_TOCKSTAMP();
		<span class="enscript-type">struct</span> _le_peak *p = &amp;le-&gt;_le.le_peaks[now % NTOCKS];

		<span class="enscript-keyword">if</span> (!TOCKSTAMP_IS_STALE(now, p-&gt;le_time) || (balance &gt; p-&gt;le_max)) {
			<span class="enscript-comment">/*
			 * The current balance is greater than the previously
			 * observed peak for the current time block, *or* we
			 * haven't yet recorded a peak for the current time block --
			 * so this is our new peak.
			 *
			 * (We only track the lower 32-bits of a balance for rolling
			 * max purposes.)
			 */</span>
			p-&gt;le_max = (uint32_t)balance;
			p-&gt;le_time = now;
		}
	}

	<span class="enscript-comment">/* Check to see whether we're due a refill */</span>
	<span class="enscript-keyword">if</span> (le-&gt;le_flags &amp; LF_REFILL_SCHEDULED) {
		uint64_t now = mach_absolute_time();
		<span class="enscript-keyword">if</span> ((now - le-&gt;_le.le_refill.le_last_refill) &gt; le-&gt;_le.le_refill.le_refill_period)
			ledger_refill(now, ledger, entry);
	}

	<span class="enscript-keyword">if</span> (limit_exceeded(le)) {
		<span class="enscript-comment">/*
		 * We've exceeded the limit for this entry.  There
		 * are several possible ways to handle it.  We can block,
		 * we can execute a callback, or we can ignore it.  In
		 * either of the first two cases, we want to set the AST
		 * flag so we can take the appropriate action just before
		 * leaving the kernel.  The one caveat is that if we have
		 * already called the callback, we don't want to do it
		 * again until it gets rearmed.
		 */</span>
		<span class="enscript-keyword">if</span> ((le-&gt;le_flags &amp; LEDGER_ACTION_BLOCK) ||
		    (!(le-&gt;le_flags &amp; LF_CALLED_BACK) &amp;&amp;
		    entry_get_callback(ledger, entry))) {
			set_astledger(current_thread());
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * The balance on the account is below the limit.
		 *
		 * If there are any threads blocked on this entry, now would
		 * be a good time to wake them up.
		 */</span>
		<span class="enscript-keyword">if</span> (le-&gt;le_flags &amp; LF_WAKE_NEEDED)
			ledger_limit_entry_wakeup(le);

		<span class="enscript-keyword">if</span> (le-&gt;le_flags &amp; LEDGER_ACTION_CALLBACK) {
			<span class="enscript-comment">/*
			 * Client has requested that a callback be invoked whenever
			 * the ledger's balance crosses into or out of the warning
			 * level.
			 */</span>
		 	<span class="enscript-keyword">if</span> (warn_level_exceeded(le)) {
		 		<span class="enscript-comment">/*
		 		 * This ledger's balance is above the warning level.
		 		 */</span> 
		 		<span class="enscript-keyword">if</span> ((le-&gt;le_flags &amp; LF_WARNED) == 0) {
		 			<span class="enscript-comment">/*
		 			 * If we are above the warning level and
		 			 * have not yet invoked the callback,
		 			 * set the AST so it can be done before returning
		 			 * to userland.
		 			 */</span>
					set_astledger(current_thread());
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * This ledger's balance is below the warning level.
				 */</span>
		 		<span class="enscript-keyword">if</span> (le-&gt;le_flags &amp; LF_WARNED) {
					<span class="enscript-comment">/*
					 * If we are below the warning level and
					 * the LF_WARNED flag is still set, we need
					 * to invoke the callback to let the client
					 * know the ledger balance is now back below
					 * the warning level.
					 */</span>
					set_astledger(current_thread());
				}
			}
		}
	}

	<span class="enscript-keyword">if</span> ((le-&gt;le_flags &amp; LF_PANIC_ON_NEGATIVE) &amp;&amp;
	    (le-&gt;le_credit &lt; le-&gt;le_debit)) {
		panic(<span class="enscript-string">&quot;ledger_check_new_balance(%p,%d): negative ledger %p balance:%lld\n&quot;</span>,
		      ledger, entry, le, le-&gt;le_credit - le-&gt;le_debit);
	}
}

<span class="enscript-comment">/*
 * Add value to an entry in a ledger.
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_credit</span>(ledger_t ledger, <span class="enscript-type">int</span> entry, ledger_amount_t amount)
{
	ledger_amount_t old, new;
	<span class="enscript-type">struct</span> ledger_entry *le;

	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry) || (amount &lt; 0))
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	<span class="enscript-keyword">if</span> (amount == 0)
		<span class="enscript-keyword">return</span> (KERN_SUCCESS);

	le = &amp;ledger-&gt;l_entries[entry];

	old = OSAddAtomic64(amount, &amp;le-&gt;le_credit);
	new = old + amount;
	lprintf((<span class="enscript-string">&quot;%p Credit %lld-&gt;%lld\n&quot;</span>, current_thread(), old, new));
	ledger_check_new_balance(ledger, entry);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/* Add all of one ledger's values into another.
 * They must have been created from the same template.
 * This is not done atomically. Another thread (if not otherwise synchronized)
 * may see bogus values when comparing one entry to another.
 * As each entry's credit &amp; debit are modified one at a time, the warning/limit
 * may spuriously trip, or spuriously fail to trip, or another thread (if not
 * otherwise synchronized) may see a bogus balance.
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_rollup</span>(ledger_t to_ledger, ledger_t from_ledger)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> ledger_entry *from_le, *to_le;

	assert(to_ledger-&gt;l_template == from_ledger-&gt;l_template);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; to_ledger-&gt;l_size; i++) {
		<span class="enscript-keyword">if</span> (ENTRY_VALID(from_ledger, i) &amp;&amp; ENTRY_VALID(to_ledger, i)) {
			from_le = &amp;from_ledger-&gt;l_entries[i];
			to_le   =   &amp;to_ledger-&gt;l_entries[i];
			OSAddAtomic64(from_le-&gt;le_credit, &amp;to_le-&gt;le_credit);
			OSAddAtomic64(from_le-&gt;le_debit,  &amp;to_le-&gt;le_debit);
		}
	}

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Zero the balance of a ledger by adding to its credit or debit, whichever is smaller.
 * Note that some clients of ledgers (notably, task wakeup statistics) require that 
 * le_credit only ever increase as a function of ledger_credit().
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_zero_balance</span>(ledger_t ledger, <span class="enscript-type">int</span> entry)
{
	<span class="enscript-type">struct</span> ledger_entry *le;

	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	le = &amp;ledger-&gt;l_entries[entry];

<span class="enscript-reference">top</span>:
	<span class="enscript-keyword">if</span> (le-&gt;le_credit &gt; le-&gt;le_debit) {
		<span class="enscript-keyword">if</span> (!OSCompareAndSwap64(le-&gt;le_debit, le-&gt;le_credit, &amp;le-&gt;le_debit))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">top</span>;
		lprintf((<span class="enscript-string">&quot;%p zeroed %lld-&gt;%lld\n&quot;</span>, current_thread(), le-&gt;le_debit, le-&gt;le_credit));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (le-&gt;le_credit &lt; le-&gt;le_debit) {
		<span class="enscript-keyword">if</span> (!OSCompareAndSwap64(le-&gt;le_credit, le-&gt;le_debit, &amp;le-&gt;le_credit))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">top</span>;
		lprintf((<span class="enscript-string">&quot;%p zeroed %lld-&gt;%lld\n&quot;</span>, current_thread(), le-&gt;le_credit, le-&gt;le_debit));
	}

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">ledger_get_limit</span>(ledger_t ledger, <span class="enscript-type">int</span> entry, ledger_amount_t *limit)
{
	<span class="enscript-type">struct</span> ledger_entry *le;

	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	le = &amp;ledger-&gt;l_entries[entry];
	*limit = le-&gt;le_limit;

	lprintf((<span class="enscript-string">&quot;ledger_get_limit: %lld\n&quot;</span>, *limit));

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Adjust the limit of a limited resource.  This does not affect the
 * current balance, so the change doesn't affect the thread until the
 * next refill.
 *
 * warn_level: If non-zero, causes the callback to be invoked when 
 * the balance exceeds this level. Specified as a percentage [of the limit].
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_set_limit</span>(ledger_t ledger, <span class="enscript-type">int</span> entry, ledger_amount_t limit,
 		 uint8_t warn_level_percentage)
{
	<span class="enscript-type">struct</span> ledger_entry *le;

	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	lprintf((<span class="enscript-string">&quot;ledger_set_limit: %lld\n&quot;</span>, limit));
	le = &amp;ledger-&gt;l_entries[entry];

	<span class="enscript-keyword">if</span> (limit == LEDGER_LIMIT_INFINITY) {
		<span class="enscript-comment">/*
		 * Caller wishes to disable the limit. This will implicitly
		 * disable automatic refill, as refills implicitly depend
		 * on the limit.
		 */</span>
		ledger_disable_refill(ledger, entry);
	}

	le-&gt;le_limit = limit;
	le-&gt;_le.le_refill.le_last_refill = 0;
	flag_clear(&amp;le-&gt;le_flags, LF_CALLED_BACK);
	flag_clear(&amp;le-&gt;le_flags, LF_WARNED);        
	ledger_limit_entry_wakeup(le);

	<span class="enscript-keyword">if</span> (warn_level_percentage != 0) {
		assert(warn_level_percentage &lt;= 100);
		assert(limit &gt; 0); <span class="enscript-comment">/* no negative limit support for warnings */</span>
		assert(limit != LEDGER_LIMIT_INFINITY); <span class="enscript-comment">/* warn % without limit makes no sense */</span>
		le-&gt;le_warn_level = (le-&gt;le_limit * warn_level_percentage) / 100;
	} <span class="enscript-keyword">else</span> {
		le-&gt;le_warn_level = LEDGER_LIMIT_INFINITY;
	}

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">ledger_get_maximum</span>(ledger_t ledger, <span class="enscript-type">int</span> entry,
	ledger_amount_t *max_observed_balance)
{
	<span class="enscript-type">struct</span> ledger_entry	*le;
	uint32_t		now = CURRENT_TOCKSTAMP();
	<span class="enscript-type">int</span>			i;

	le = &amp;ledger-&gt;l_entries[entry];

	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry) || !(le-&gt;le_flags &amp; LF_TRACKING_MAX)) {
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);
	}

	<span class="enscript-comment">/*
	 * Start with the current balance; if neither of the recorded peaks are
	 * within recent history, we use this.
	 */</span>
	*max_observed_balance = le-&gt;le_credit - le-&gt;le_debit;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; NTOCKS; i++) {
		<span class="enscript-keyword">if</span> (!TOCKSTAMP_IS_STALE(now, le-&gt;_le.le_peaks[i].le_time) &amp;&amp;
		    (le-&gt;_le.le_peaks[i].le_max &gt; *max_observed_balance)) {
		    	<span class="enscript-comment">/*
		    	 * The peak for this time block isn't stale, and it
		    	 * is greater than the current balance -- so use it.
		    	 */</span>
		    	*max_observed_balance = le-&gt;_le.le_peaks[i].le_max;
		}
	}
	
	lprintf((<span class="enscript-string">&quot;ledger_get_maximum: %lld\n&quot;</span>, *max_observed_balance));

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Enable tracking of periodic maximums for this ledger entry.
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_track_maximum</span>(ledger_template_t template, <span class="enscript-type">int</span> entry,
	__unused <span class="enscript-type">int</span> period_in_secs)
{
	template_lock(template);

	<span class="enscript-keyword">if</span> ((entry &lt; 0) || (entry &gt;= template-&gt;lt_cnt)) {
		template_unlock(template);	
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);
	}

	template-&gt;lt_entries[entry].et_flags |= LF_TRACKING_MAX;
	template_unlock(template);	

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">ledger_panic_on_negative</span>(ledger_template_t template, <span class="enscript-type">int</span> entry)
{
	template_lock(template);

	<span class="enscript-keyword">if</span> ((entry &lt; 0) || (entry &gt;= template-&gt;lt_cnt)) {
		template_unlock(template);	
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);
	}

	template-&gt;lt_entries[entry].et_flags |= LF_PANIC_ON_NEGATIVE;

	template_unlock(template);	

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}
<span class="enscript-comment">/*
 * Add a callback to be executed when the resource goes into deficit.
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_set_callback</span>(ledger_template_t template, <span class="enscript-type">int</span> entry,
   ledger_callback_t func, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *param0, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *param1)
{
	<span class="enscript-type">struct</span> entry_template *et;
	<span class="enscript-type">struct</span> ledger_callback *old_cb, *new_cb;

	<span class="enscript-keyword">if</span> ((entry &lt; 0) || (entry &gt;= template-&gt;lt_cnt))
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	<span class="enscript-keyword">if</span> (func) {
		new_cb = (<span class="enscript-type">struct</span> ledger_callback *)kalloc(<span class="enscript-keyword">sizeof</span> (*new_cb));
		new_cb-&gt;lc_func = func;
		new_cb-&gt;lc_param0 = param0;
		new_cb-&gt;lc_param1 = param1;
	} <span class="enscript-keyword">else</span> {
		new_cb = NULL;
	}

	template_lock(template);
	et = &amp;template-&gt;lt_entries[entry];
	old_cb = et-&gt;et_callback;
	et-&gt;et_callback = new_cb;
	template_unlock(template);
	<span class="enscript-keyword">if</span> (old_cb)
		kfree(old_cb, <span class="enscript-keyword">sizeof</span> (*old_cb));

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Disable callback notification for a specific ledger entry.
 *
 * Otherwise, if using a ledger template which specified a
 * callback function (ledger_set_callback()), it will be invoked when
 * the resource goes into deficit.
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_disable_callback</span>(ledger_t ledger, <span class="enscript-type">int</span> entry)
{
	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	<span class="enscript-comment">/*
	 * le_warn_level is used to indicate *if* this ledger has a warning configured,
	 * in addition to what that warning level is set to.
	 * This means a side-effect of ledger_disable_callback() is that the
	 * warning level is forgotten.
	 */</span>
	ledger-&gt;l_entries[entry].le_warn_level = LEDGER_LIMIT_INFINITY;
	flag_clear(&amp;ledger-&gt;l_entries[entry].le_flags, LEDGER_ACTION_CALLBACK);
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Enable callback notification for a specific ledger entry.
 *
 * This is only needed if ledger_disable_callback() has previously
 * been invoked against an entry; there must already be a callback
 * configured.
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_enable_callback</span>(ledger_t ledger, <span class="enscript-type">int</span> entry)
{
	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	assert(entry_get_callback(ledger, entry) != NULL);

	flag_set(&amp;ledger-&gt;l_entries[entry].le_flags, LEDGER_ACTION_CALLBACK);
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Query the automatic refill period for this ledger entry.
 *
 * A period of 0 means this entry has none configured.
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_get_period</span>(ledger_t ledger, <span class="enscript-type">int</span> entry, uint64_t *period)
{
	<span class="enscript-type">struct</span> ledger_entry *le;

	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	le = &amp;ledger-&gt;l_entries[entry];
	*period = abstime_to_nsecs(le-&gt;_le.le_refill.le_refill_period);
	lprintf((<span class="enscript-string">&quot;ledger_get_period: %llx\n&quot;</span>, *period));
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Adjust the automatic refill period.
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_set_period</span>(ledger_t ledger, <span class="enscript-type">int</span> entry, uint64_t period)
{
	<span class="enscript-type">struct</span> ledger_entry *le;

	lprintf((<span class="enscript-string">&quot;ledger_set_period: %llx\n&quot;</span>, period));
	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	le = &amp;ledger-&gt;l_entries[entry];

	<span class="enscript-comment">/*
	 * A refill period refills the ledger in multiples of the limit,
	 * so if you haven't set one yet, you need a lesson on ledgers.
	 */</span>
	assert(le-&gt;le_limit != LEDGER_LIMIT_INFINITY);

	<span class="enscript-keyword">if</span> (le-&gt;le_flags &amp; LF_TRACKING_MAX) {
		<span class="enscript-comment">/*
		 * Refill is incompatible with rolling max tracking.
		 */</span>
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);
	}

	le-&gt;_le.le_refill.le_refill_period = nsecs_to_abstime(period);

	<span class="enscript-comment">/*
	 * Set the 'starting time' for the next refill to now. Since
	 * we're resetting the balance to zero here, we consider this
	 * moment the starting time for accumulating a balance that
	 * counts towards the limit.
	 */</span>
	le-&gt;_le.le_refill.le_last_refill = mach_absolute_time();
	ledger_zero_balance(ledger, entry);

	flag_set(&amp;le-&gt;le_flags, LF_REFILL_SCHEDULED);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Disable automatic refill.
 */</span>
kern_return_t
<span class="enscript-function-name">ledger_disable_refill</span>(ledger_t ledger, <span class="enscript-type">int</span> entry)
{
	<span class="enscript-type">struct</span> ledger_entry *le;

	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	le = &amp;ledger-&gt;l_entries[entry];

	flag_clear(&amp;le-&gt;le_flags, LF_REFILL_SCHEDULED);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">ledger_get_actions</span>(ledger_t ledger, <span class="enscript-type">int</span> entry, <span class="enscript-type">int</span> *actions)
{
	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	*actions = ledger-&gt;l_entries[entry].le_flags &amp; LEDGER_ACTION_MASK;
	lprintf((<span class="enscript-string">&quot;ledger_get_actions: %#x\n&quot;</span>, *actions));	
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">ledger_set_action</span>(ledger_t ledger, <span class="enscript-type">int</span> entry, <span class="enscript-type">int</span> action)
{
	lprintf((<span class="enscript-string">&quot;ledger_set_action: %#x\n&quot;</span>, action));
	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_VALUE);

	flag_set(&amp;ledger-&gt;l_entries[entry].le_flags, action);
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">ledger_debit</span>(ledger_t ledger, <span class="enscript-type">int</span> entry, ledger_amount_t amount)
{
	<span class="enscript-type">struct</span> ledger_entry *le;
	ledger_amount_t old, new;

	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry) || (amount &lt; 0))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (amount == 0)
		<span class="enscript-keyword">return</span> (KERN_SUCCESS);

	le = &amp;ledger-&gt;l_entries[entry];

	old = OSAddAtomic64(amount, &amp;le-&gt;le_debit);
	new = old + amount;

	lprintf((<span class="enscript-string">&quot;%p Debit %lld-&gt;%lld\n&quot;</span>, thread, old, new));
	ledger_check_new_balance(ledger, entry);
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);

}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ledger_ast</span>(thread_t thread)
{
	<span class="enscript-type">struct</span> ledger	*l = thread-&gt;t_ledger;
	<span class="enscript-type">struct</span> ledger 	*thl;
	uint32_t	block;
	uint64_t	now;
	uint8_t		task_flags;
	uint8_t		task_percentage;
	uint64_t	task_interval;

	kern_return_t ret;
	task_t task = thread-&gt;task;

	lprintf((<span class="enscript-string">&quot;Ledger AST for %p\n&quot;</span>, thread));

	ASSERT(task != NULL);
	ASSERT(thread == current_thread());

<span class="enscript-reference">top</span>:
	<span class="enscript-comment">/*
	 * Take a self-consistent snapshot of the CPU usage monitor parameters. The task
	 * can change them at any point (with the task locked).
	 */</span>
	task_lock(task);
	task_flags = task-&gt;rusage_cpu_flags;
	task_percentage = task-&gt;rusage_cpu_perthr_percentage;
	task_interval = task-&gt;rusage_cpu_perthr_interval;
	task_unlock(task);

	<span class="enscript-comment">/*
	 * Make sure this thread is up to date with regards to any task-wide per-thread
	 * CPU limit, but only if it doesn't have a thread-private blocking CPU limit.
	 */</span>
	<span class="enscript-keyword">if</span> (((task_flags &amp; TASK_RUSECPU_FLAGS_PERTHR_LIMIT) != 0) &amp;&amp;
	    ((thread-&gt;options &amp; TH_OPT_PRVT_CPULIMIT) == 0)) {
		uint8_t	 percentage;
		uint64_t interval;
		<span class="enscript-type">int</span>	 action;

		thread_get_cpulimit(&amp;action, &amp;percentage, &amp;interval);

		<span class="enscript-comment">/*
		 * If the thread's CPU limits no longer match the task's, or the
		 * task has a limit but the thread doesn't, update the limit.
		 */</span>
		<span class="enscript-keyword">if</span> (((thread-&gt;options &amp; TH_OPT_PROC_CPULIMIT) == 0) ||
		    (interval != task_interval) || (percentage != task_percentage)) {
			thread_set_cpulimit(THREAD_CPULIMIT_EXCEPTION, task_percentage, task_interval);
			assert((thread-&gt;options &amp; TH_OPT_PROC_CPULIMIT) != 0);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((task_flags &amp; TASK_RUSECPU_FLAGS_PERTHR_LIMIT) == 0) &amp;&amp;
		   (thread-&gt;options &amp; TH_OPT_PROC_CPULIMIT)) {
		assert((thread-&gt;options &amp; TH_OPT_PRVT_CPULIMIT) == 0);

		<span class="enscript-comment">/*
		 * Task no longer has a per-thread CPU limit; remove this thread's
		 * corresponding CPU limit.
		 */</span>
		thread_set_cpulimit(THREAD_CPULIMIT_DISABLE, 0, 0);
		assert((thread-&gt;options &amp; TH_OPT_PROC_CPULIMIT) == 0);
	}

	<span class="enscript-comment">/*
	 * If the task or thread is being terminated, let's just get on with it
	 */</span>
	<span class="enscript-keyword">if</span> ((l == NULL) || !task-&gt;active || task-&gt;halting || !thread-&gt;active)
		<span class="enscript-keyword">return</span>;
	
	<span class="enscript-comment">/*
	 * Examine all entries in deficit to see which might be eligble for
	 * an automatic refill, which require callbacks to be issued, and
	 * which require blocking.
	 */</span>
	block = 0;
	now = mach_absolute_time();

	<span class="enscript-comment">/*
	 * Note that thread-&gt;t_threadledger may have been changed by the
	 * thread_set_cpulimit() call above - so don't examine it until afterwards.
	 */</span>
	thl = thread-&gt;t_threadledger;
	<span class="enscript-keyword">if</span> (LEDGER_VALID(thl)) {
		block |= ledger_check_needblock(thl, now);
	}
	block |= ledger_check_needblock(l, now);

	<span class="enscript-comment">/*
	 * If we are supposed to block on the availability of one or more
	 * resources, find the first entry in deficit for which we should wait.
	 * Schedule a refill if necessary and then sleep until the resource
	 * becomes available.
	 */</span>
	<span class="enscript-keyword">if</span> (block) {
		<span class="enscript-keyword">if</span> (LEDGER_VALID(thl)) {
			ret = ledger_perform_blocking(thl);
			<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">top</span>;
		}
		ret = ledger_perform_blocking(l);
		<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">top</span>;
	} <span class="enscript-comment">/* block */</span>
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">ledger_check_needblock</span>(ledger_t l, uint64_t now)
{
	<span class="enscript-type">int</span> i;
	uint32_t flags, block = 0;
	<span class="enscript-type">struct</span> ledger_entry *le;
	<span class="enscript-type">struct</span> ledger_callback *lc;


	<span class="enscript-keyword">for</span> (i = 0; i &lt; l-&gt;l_size; i++) {
		le = &amp;l-&gt;l_entries[i];

		lc = entry_get_callback(l, i);

		<span class="enscript-keyword">if</span> (limit_exceeded(le) == FALSE) {
			<span class="enscript-keyword">if</span> (le-&gt;le_flags &amp; LEDGER_ACTION_CALLBACK) {
				<span class="enscript-comment">/*
				 * If needed, invoke the callback as a warning.
				 * This needs to happen both when the balance rises above
				 * the warning level, and also when it dips back below it.
				 */</span>
				assert(lc != NULL);
				<span class="enscript-comment">/*
				 * See comments for matching logic in ledger_check_new_balance().
				 */</span>
				<span class="enscript-keyword">if</span> (warn_level_exceeded(le)) {
					flags = flag_set(&amp;le-&gt;le_flags, LF_WARNED);
					<span class="enscript-keyword">if</span> ((flags &amp; LF_WARNED) == 0) {
						lc-&gt;lc_func(LEDGER_WARNING_ROSE_ABOVE, lc-&gt;lc_param0, lc-&gt;lc_param1);
					}
				} <span class="enscript-keyword">else</span> {
					flags = flag_clear(&amp;le-&gt;le_flags, LF_WARNED);
					<span class="enscript-keyword">if</span> (flags &amp; LF_WARNED) {
						lc-&gt;lc_func(LEDGER_WARNING_DIPPED_BELOW, lc-&gt;lc_param0, lc-&gt;lc_param1);
					}
				}
			}

			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* We're over the limit, so refill if we are eligible and past due. */</span>
		<span class="enscript-keyword">if</span> (le-&gt;le_flags &amp; LF_REFILL_SCHEDULED) {
			<span class="enscript-keyword">if</span> ((le-&gt;_le.le_refill.le_last_refill + le-&gt;_le.le_refill.le_refill_period) &gt; now) {
				ledger_refill(now, l, i);
				<span class="enscript-keyword">if</span> (limit_exceeded(le) == FALSE)
					<span class="enscript-keyword">continue</span>;
			}
		}

		<span class="enscript-keyword">if</span> (le-&gt;le_flags &amp; LEDGER_ACTION_BLOCK)
			block = 1;
		<span class="enscript-keyword">if</span> ((le-&gt;le_flags &amp; LEDGER_ACTION_CALLBACK) == 0)
			<span class="enscript-keyword">continue</span>;

                <span class="enscript-comment">/*
                 * If the LEDGER_ACTION_CALLBACK flag is on, we expect there to
                 * be a registered callback.
                 */</span>
		assert(lc != NULL);
		flags = flag_set(&amp;le-&gt;le_flags, LF_CALLED_BACK);
		<span class="enscript-comment">/* Callback has already been called */</span>
		<span class="enscript-keyword">if</span> (flags &amp; LF_CALLED_BACK)
			<span class="enscript-keyword">continue</span>;
		lc-&gt;lc_func(FALSE, lc-&gt;lc_param0, lc-&gt;lc_param1);
	}
	<span class="enscript-keyword">return</span>(block);
}


<span class="enscript-comment">/* return KERN_SUCCESS to continue, KERN_FAILURE to restart */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">ledger_perform_blocking</span>(ledger_t l)
{
	<span class="enscript-type">int</span> i;
	kern_return_t ret;
	<span class="enscript-type">struct</span> ledger_entry *le;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; l-&gt;l_size; i++) {
		le = &amp;l-&gt;l_entries[i];
		<span class="enscript-keyword">if</span> ((!limit_exceeded(le)) ||
		    ((le-&gt;le_flags &amp; LEDGER_ACTION_BLOCK) == 0))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* Prepare to sleep until the resource is refilled */</span>
		ret = assert_wait_deadline(le, TRUE,
		    le-&gt;_le.le_refill.le_last_refill + le-&gt;_le.le_refill.le_refill_period);
		<span class="enscript-keyword">if</span> (ret != THREAD_WAITING)
			<span class="enscript-keyword">return</span>(KERN_SUCCESS);

		<span class="enscript-comment">/* Mark that somebody is waiting on this entry  */</span>
		flag_set(&amp;le-&gt;le_flags, LF_WAKE_NEEDED);

		ret = thread_block_reason(THREAD_CONTINUE_NULL, NULL,
		    AST_LEDGER);
		<span class="enscript-keyword">if</span> (ret != THREAD_AWAKENED)
			<span class="enscript-keyword">return</span>(KERN_SUCCESS);

		<span class="enscript-comment">/*
		 * The world may have changed while we were asleep.
		 * Some other resource we need may have gone into
		 * deficit.  Or maybe we're supposed to die now.
		 * Go back to the top and reevaluate.
		 */</span>
		<span class="enscript-keyword">return</span>(KERN_FAILURE);
	}
	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}


kern_return_t
<span class="enscript-function-name">ledger_get_entries</span>(ledger_t ledger, <span class="enscript-type">int</span> entry, ledger_amount_t *credit,
    ledger_amount_t *debit)
{
	<span class="enscript-type">struct</span> ledger_entry *le;

	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	le = &amp;ledger-&gt;l_entries[entry];

	*credit = le-&gt;le_credit;
	*debit = le-&gt;le_debit;

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">ledger_reset_callback_state</span>(ledger_t ledger, <span class="enscript-type">int</span> entry)
{
	<span class="enscript-type">struct</span> ledger_entry *le;

	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	le = &amp;ledger-&gt;l_entries[entry];

	flag_clear(&amp;le-&gt;le_flags, LF_CALLED_BACK);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">ledger_disable_panic_on_negative</span>(ledger_t ledger, <span class="enscript-type">int</span> entry)
{
	<span class="enscript-type">struct</span> ledger_entry *le;

	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	le = &amp;ledger-&gt;l_entries[entry];

	flag_clear(&amp;le-&gt;le_flags, LF_PANIC_ON_NEGATIVE);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">ledger_get_balance</span>(ledger_t ledger, <span class="enscript-type">int</span> entry, ledger_amount_t *balance)
{
	<span class="enscript-type">struct</span> ledger_entry *le;

	<span class="enscript-keyword">if</span> (!ENTRY_VALID(ledger, entry))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	le = &amp;ledger-&gt;l_entries[entry];

	assert((le-&gt;le_credit &gt;= 0) &amp;&amp; (le-&gt;le_debit &gt;= 0));

	*balance = le-&gt;le_credit - le-&gt;le_debit;

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ledger_template_info</span>(<span class="enscript-type">void</span> **buf, <span class="enscript-type">int</span> *len)
{
	<span class="enscript-type">struct</span> ledger_template_info *lti;
	<span class="enscript-type">struct</span> entry_template *et;
	<span class="enscript-type">int</span> i;
	ledger_t l;

	<span class="enscript-comment">/*
	 * Since all tasks share a ledger template, we'll just use the
	 * caller's as the source.
	 */</span>
	l = current_task()-&gt;ledger;
	<span class="enscript-keyword">if</span> ((*len &lt; 0) || (l == NULL))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (*len &gt; l-&gt;l_size)
		 *len = l-&gt;l_size;
	lti = kalloc((*len) * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ledger_template_info));
	<span class="enscript-keyword">if</span> (lti == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);
	*buf = lti;

	template_lock(l-&gt;l_template);
	et = l-&gt;l_template-&gt;lt_entries;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; *len; i++) {
		memset(lti, 0, <span class="enscript-keyword">sizeof</span> (*lti));
		strlcpy(lti-&gt;lti_name, et-&gt;et_key, LEDGER_NAME_MAX);
		strlcpy(lti-&gt;lti_group, et-&gt;et_group, LEDGER_NAME_MAX);
		strlcpy(lti-&gt;lti_units, et-&gt;et_units, LEDGER_NAME_MAX);
		et++;
		lti++;
	}
	template_unlock(l-&gt;l_template);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ledger_fill_entry_info</span>(<span class="enscript-type">struct</span> ledger_entry      *le,
                       <span class="enscript-type">struct</span> ledger_entry_info *lei,
                       uint64_t                  now)
{
	assert(le  != NULL);
	assert(lei != NULL);

	memset(lei, 0, <span class="enscript-keyword">sizeof</span> (*lei));

	lei-&gt;lei_limit         = le-&gt;le_limit;
	lei-&gt;lei_credit        = le-&gt;le_credit;
	lei-&gt;lei_debit         = le-&gt;le_debit;
	lei-&gt;lei_balance       = lei-&gt;lei_credit - lei-&gt;lei_debit;
	lei-&gt;lei_refill_period = (le-&gt;le_flags &amp; LF_REFILL_SCHEDULED) ? 
							     abstime_to_nsecs(le-&gt;_le.le_refill.le_refill_period) : 0;
	lei-&gt;lei_last_refill   = abstime_to_nsecs(now - le-&gt;_le.le_refill.le_last_refill);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ledger_get_task_entry_info_multiple</span>(task_t task, <span class="enscript-type">void</span> **buf, <span class="enscript-type">int</span> *len)
{
	<span class="enscript-type">struct</span> ledger_entry_info *lei;
	<span class="enscript-type">struct</span> ledger_entry *le;
	uint64_t now = mach_absolute_time();
	<span class="enscript-type">int</span> i;
	ledger_t l;

	<span class="enscript-keyword">if</span> ((*len &lt; 0) || ((l = task-&gt;ledger) == NULL))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (*len &gt; l-&gt;l_size)
		 *len = l-&gt;l_size;
	lei = kalloc((*len) * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ledger_entry_info));
	<span class="enscript-keyword">if</span> (lei == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);
	*buf = lei;

	le = l-&gt;l_entries;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; *len; i++) {
		ledger_fill_entry_info(le, lei, now);
		le++;
		lei++;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ledger_get_entry_info</span>(ledger_t                  ledger,
                      <span class="enscript-type">int</span>                       entry,
                      <span class="enscript-type">struct</span> ledger_entry_info *lei)
{
	uint64_t now = mach_absolute_time();

	assert(ledger != NULL);
	assert(lei != NULL);
	assert(entry &lt; ledger-&gt;l_size);

	<span class="enscript-type">struct</span> ledger_entry *le = &amp;ledger-&gt;l_entries[entry];

	ledger_fill_entry_info(le, lei, now);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ledger_info</span>(task_t task, <span class="enscript-type">struct</span> ledger_info *info)
{
	ledger_t l;

	<span class="enscript-keyword">if</span> ((l = task-&gt;ledger) == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	memset(info, 0, <span class="enscript-keyword">sizeof</span> (*info));

	strlcpy(info-&gt;li_name, l-&gt;l_template-&gt;lt_name, LEDGER_NAME_MAX);
	info-&gt;li_id = l-&gt;l_id;
	info-&gt;li_entries = l-&gt;l_size;
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LEDGER_DEBUG</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ledger_limit</span>(task_t task, <span class="enscript-type">struct</span> ledger_limit_args *args)
{
	ledger_t l;
	int64_t limit;
	<span class="enscript-type">int</span> idx;

	<span class="enscript-keyword">if</span> ((l = task-&gt;ledger) == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	idx = ledger_key_lookup(l-&gt;l_template, args-&gt;lla_name);
	<span class="enscript-keyword">if</span> ((idx &lt; 0) || (idx &gt;= l-&gt;l_size))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/*
	 * XXX - this doesn't really seem like the right place to have
	 * a context-sensitive conversion of userspace units into kernel
	 * units.  For now I'll handwave and say that the ledger() system
	 * call isn't meant for civilians to use - they should be using
	 * the process policy interfaces.
	 */</span>
	<span class="enscript-keyword">if</span> (idx == task_ledgers.cpu_time) {
		int64_t nsecs;

		<span class="enscript-keyword">if</span> (args-&gt;lla_refill_period) {
			<span class="enscript-comment">/*
			 * If a refill is scheduled, then the limit is 
			 * specified as a percentage of one CPU.  The
			 * syscall specifies the refill period in terms of
			 * milliseconds, so we need to convert to nsecs.
			 */</span>
			args-&gt;lla_refill_period *= 1000000;
			nsecs = args-&gt;lla_limit *
			    (args-&gt;lla_refill_period / 100);
			lprintf((<span class="enscript-string">&quot;CPU limited to %lld nsecs per second\n&quot;</span>,
			    nsecs));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * If no refill is scheduled, then this is a
			 * fixed amount of CPU time (in nsecs) that can
			 * be consumed.
			 */</span>
			nsecs = args-&gt;lla_limit;
			lprintf((<span class="enscript-string">&quot;CPU limited to %lld nsecs\n&quot;</span>, nsecs));
		}
		limit = nsecs_to_abstime(nsecs);
	} <span class="enscript-keyword">else</span> {
		limit = args-&gt;lla_limit;
		lprintf((<span class="enscript-string">&quot;%s limited to %lld\n&quot;</span>, args-&gt;lla_name, limit));
	}

	<span class="enscript-keyword">if</span> (args-&gt;lla_refill_period &gt; 0)
		ledger_set_period(l, idx, args-&gt;lla_refill_period);

	ledger_set_limit(l, idx, limit);
	flag_set(&amp;l-&gt;l_entries[idx].le_flags, LEDGER_ACTION_BLOCK);
	<span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>