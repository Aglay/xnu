<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>btlog.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">btlog.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stddef.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/btlog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>

<span class="enscript-comment">/*
 * Since all records are located contiguously in memory,
 * we use indices to them as the primary lookup mechanism,
 * and to maintain the linked list of active records
 * in chronological order.
 */</span>
<span class="enscript-type">typedef</span> uint32_t btlog_recordindex_t; <span class="enscript-comment">/* only 24 bits used */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BTLOG_RECORDINDEX_NONE</span> (0xFFFFFF)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BTLOG_MAX_RECORDS</span> (0xFFFFFF <span class="enscript-comment">/* 16777215 */</span>)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> btlog_record {
    btlog_recordindex_t next:24;
    uint8_t         operation;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
    uint32_t        _pad;
#<span class="enscript-reference">endif</span>
    <span class="enscript-type">void</span>           *element;
    <span class="enscript-type">void</span>           *bt[]; <span class="enscript-comment">/* variable sized, based on btlog_t params */</span>
} btlog_record_t;

<span class="enscript-type">struct</span> btlog {
    vm_address_t    btlog_buffer;       <span class="enscript-comment">/* all memory for this btlog_t */</span>
    vm_size_t       btlog_buffersize;

    btlog_lock_t    lock_callback;      <span class="enscript-comment">/* caller-provided locking */</span>
    btlog_unlock_t  unlock_callback;
    <span class="enscript-type">void</span>           *callback_context;

    uintptr_t       btrecords;      <span class="enscript-comment">/* use btlog_recordindex_t to lookup */</span>
    size_t          btrecord_count;
    size_t          btrecord_btdepth; <span class="enscript-comment">/* BT entries per record */</span>
    size_t          btrecord_size;

    btlog_recordindex_t head; <span class="enscript-comment">/* active record list */</span>
    btlog_recordindex_t tail;
    size_t          activecount;

    btlog_recordindex_t freelist;
};

<span class="enscript-type">extern</span> boolean_t vm_kernel_ready;
<span class="enscript-type">extern</span> boolean_t kmem_alloc_ready;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">lookup_btrecord</span>(btlog, index) \
	((btlog_record_t *)(btlog-&gt;btrecords + index * btlog-&gt;btrecord_size))

btlog_t *
<span class="enscript-function-name">btlog_create</span>(size_t numrecords,
			 size_t record_btdepth,
			 btlog_lock_t lock_callback,
			 btlog_unlock_t unlock_callback,
			 <span class="enscript-type">void</span> *callback_context)
{
	btlog_t *btlog;
	vm_size_t buffersize_needed;
	vm_address_t buffer = 0;
	size_t i;
	kern_return_t ret;
	size_t btrecord_size;

	<span class="enscript-keyword">if</span> (vm_kernel_ready &amp;&amp; !kmem_alloc_ready)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">if</span> (numrecords &gt; BTLOG_MAX_RECORDS)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">if</span> (numrecords == 0)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">if</span> (record_btdepth &gt; BTLOG_MAX_DEPTH)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">if</span> ((lock_callback &amp;&amp; !unlock_callback) ||
		(!lock_callback &amp;&amp; unlock_callback))
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-comment">/* btlog_record_t is variable-sized, calculate needs now */</span>
	btrecord_size = <span class="enscript-keyword">sizeof</span>(btlog_record_t)
		+ <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *) * record_btdepth;

	buffersize_needed = <span class="enscript-keyword">sizeof</span>(btlog_t) + numrecords * btrecord_size;
	buffersize_needed = round_page(buffersize_needed);

	<span class="enscript-comment">/* since rounding to a page size might hold more, recalculate */</span>
	numrecords = MIN(BTLOG_MAX_RECORDS,
					 (buffersize_needed - <span class="enscript-keyword">sizeof</span>(btlog_t))/btrecord_size);

	<span class="enscript-keyword">if</span> (kmem_alloc_ready) {
		ret = kmem_alloc(kernel_map, &amp;buffer, buffersize_needed, VM_KERN_MEMORY_DIAG);
	} <span class="enscript-keyword">else</span> {
		buffer = (vm_address_t)pmap_steal_memory(buffersize_needed);
		ret = KERN_SUCCESS;
	}
	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> NULL;

	btlog = (btlog_t *)buffer;
	btlog-&gt;btlog_buffer = buffer;
	btlog-&gt;btlog_buffersize = buffersize_needed;

	btlog-&gt;lock_callback = lock_callback;
	btlog-&gt;unlock_callback = unlock_callback;
	btlog-&gt;callback_context = callback_context;

	btlog-&gt;btrecords = (uintptr_t)(buffer + <span class="enscript-keyword">sizeof</span>(btlog_t));
	btlog-&gt;btrecord_count = numrecords;
	btlog-&gt;btrecord_btdepth = record_btdepth;
	btlog-&gt;btrecord_size = btrecord_size;

	btlog-&gt;head = BTLOG_RECORDINDEX_NONE;
	btlog-&gt;tail = BTLOG_RECORDINDEX_NONE;
	btlog-&gt;activecount = 0;

	<span class="enscript-comment">/* populate freelist with all records in order */</span>
	btlog-&gt;freelist = 0;
	<span class="enscript-keyword">for</span> (i=0; i &lt; (numrecords - 1); i++) {
		btlog_record_t *rec = lookup_btrecord(btlog, i);
		rec-&gt;next = (btlog_recordindex_t)(i + 1);
	}
	lookup_btrecord(btlog, i)-&gt;next = BTLOG_RECORDINDEX_NONE; <span class="enscript-comment">/* terminate */</span>

	<span class="enscript-keyword">return</span> btlog;
}

<span class="enscript-comment">/* Assumes btlog is already locked */</span>
<span class="enscript-type">static</span> btlog_recordindex_t
<span class="enscript-function-name">btlog_get_record_from_freelist</span>(btlog_t *btlog)
{
	btlog_recordindex_t	recindex = btlog-&gt;freelist;

	<span class="enscript-keyword">if</span> (recindex == BTLOG_RECORDINDEX_NONE) {
		<span class="enscript-comment">/* nothing on freelist */</span>
		<span class="enscript-keyword">return</span> BTLOG_RECORDINDEX_NONE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* remove the head of the freelist */</span>
		btlog_record_t *record = lookup_btrecord(btlog, recindex);
		btlog-&gt;freelist = record-&gt;next;
		<span class="enscript-keyword">return</span> recindex;
	}
}

<span class="enscript-comment">/* Assumes btlog is already locked */</span>
<span class="enscript-type">static</span> btlog_recordindex_t
<span class="enscript-function-name">btlog_evict_record_from_activelist</span>(btlog_t *btlog)
{
	btlog_recordindex_t	recindex = btlog-&gt;head;

	<span class="enscript-keyword">if</span> (recindex == BTLOG_RECORDINDEX_NONE) {
		<span class="enscript-comment">/* nothing on active list */</span>
		<span class="enscript-keyword">return</span> BTLOG_RECORDINDEX_NONE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* remove the head of the active list */</span>
		btlog_record_t *record = lookup_btrecord(btlog, recindex);
		btlog-&gt;head = record-&gt;next;
		btlog-&gt;activecount--;
		<span class="enscript-keyword">if</span> (btlog-&gt;head == BTLOG_RECORDINDEX_NONE) {
			<span class="enscript-comment">/* active list is now empty, update tail */</span>
			btlog-&gt;tail = BTLOG_RECORDINDEX_NONE;
		}
		<span class="enscript-keyword">return</span> recindex;
	}
}

<span class="enscript-comment">/* Assumes btlog is already locked */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">btlog_append_record_to_activelist</span>(btlog_t *btlog, btlog_recordindex_t recindex)
{
	<span class="enscript-keyword">if</span> (btlog-&gt;head == BTLOG_RECORDINDEX_NONE) {
		<span class="enscript-comment">/* empty active list, update both head and tail */</span>
		btlog-&gt;head = btlog-&gt;tail = recindex;
	} <span class="enscript-keyword">else</span> {
		btlog_record_t *record = lookup_btrecord(btlog, btlog-&gt;tail);
		record-&gt;next = recindex;
		btlog-&gt;tail = recindex;
	}
	btlog-&gt;activecount++;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">btlog_add_entry</span>(btlog_t *btlog,
				<span class="enscript-type">void</span> *element,
				uint8_t operation,
				<span class="enscript-type">void</span> *bt[],
				size_t btcount)
{
	btlog_recordindex_t recindex;
	btlog_record_t *record;
	size_t i;

	<span class="enscript-keyword">if</span> (btlog-&gt;lock_callback)
		btlog-&gt;lock_callback(btlog-&gt;callback_context);

	<span class="enscript-comment">/* If there's a free record, use it */</span>
	recindex = btlog_get_record_from_freelist(btlog);
	<span class="enscript-keyword">if</span> (recindex == BTLOG_RECORDINDEX_NONE) {
		<span class="enscript-comment">/* Use the first active record (FIFO age-out) */</span>
		recindex = btlog_evict_record_from_activelist(btlog);
		assert(recindex != BTLOG_RECORDINDEX_NONE);
	}

	record = lookup_btrecord(btlog, recindex);

	<span class="enscript-comment">/* we always add to the tail, so there is no next pointer */</span>
	record-&gt;next = BTLOG_RECORDINDEX_NONE;
	record-&gt;operation = operation;
	record-&gt;element = element;
	<span class="enscript-keyword">for</span> (i=0; i &lt; MIN(btcount, btlog-&gt;btrecord_btdepth); i++) {
		record-&gt;bt[i] = bt[i];
	}
	<span class="enscript-keyword">for</span> (; i &lt; btlog-&gt;btrecord_btdepth; i++) {
		record-&gt;bt[i] = NULL;
	}

	btlog_append_record_to_activelist(btlog, recindex);

	<span class="enscript-keyword">if</span> (btlog-&gt;unlock_callback)
		btlog-&gt;unlock_callback(btlog-&gt;callback_context);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">btlog_remove_entries_for_element</span>(btlog_t *btlog,
								 <span class="enscript-type">void</span> *element)
{
	btlog_recordindex_t recindex;
	btlog_record_t *record;

	<span class="enscript-keyword">if</span> (btlog-&gt;lock_callback)
		btlog-&gt;lock_callback(btlog-&gt;callback_context);

	<span class="enscript-comment">/*
	 * Since the btlog_t anchors the active
	 * list with a pointer to the head of
	 * the list, first loop making sure
	 * the head is correct (and doesn't
	 * match the element being removed).
	 */</span>
	recindex = btlog-&gt;head;
	record = lookup_btrecord(btlog, recindex);
	<span class="enscript-keyword">while</span> (recindex != BTLOG_RECORDINDEX_NONE) {
		<span class="enscript-keyword">if</span> (record-&gt;element == element) {
			<span class="enscript-comment">/* remove head of active list */</span>
			btlog-&gt;head = record-&gt;next;
			btlog-&gt;activecount--;

			<span class="enscript-comment">/* add to freelist */</span>
			record-&gt;next = btlog-&gt;freelist;
			btlog-&gt;freelist = recindex;

			<span class="enscript-comment">/* check the new head */</span>
			recindex = btlog-&gt;head;
			record = lookup_btrecord(btlog, recindex);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* head didn't match, so we can move on */</span>
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (recindex == BTLOG_RECORDINDEX_NONE) {
		<span class="enscript-comment">/* we iterated over the entire active list removing the element */</span>
		btlog-&gt;tail = BTLOG_RECORDINDEX_NONE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* the head of the active list is stable, now remove other entries */</span>
		btlog_recordindex_t precindex = recindex;
		btlog_record_t *precord = record;
		
		recindex = precord-&gt;next;
		record = lookup_btrecord(btlog, recindex);
		<span class="enscript-keyword">while</span> (recindex != BTLOG_RECORDINDEX_NONE) {
			<span class="enscript-keyword">if</span> (record-&gt;element == element) {
				<span class="enscript-comment">/* remove in place */</span>
				precord-&gt;next = record-&gt;next;
				btlog-&gt;activecount--;

				<span class="enscript-comment">/* add to freelist */</span>
				record-&gt;next = btlog-&gt;freelist;
				btlog-&gt;freelist = recindex;

				<span class="enscript-comment">/* check the next record */</span>
				recindex = precord-&gt;next;
				record = lookup_btrecord(btlog, recindex);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* check the next record */</span>
				precindex = recindex;
				precord = record;

				recindex = record-&gt;next;
				record = lookup_btrecord(btlog, recindex);
			}
		}

		<span class="enscript-comment">/* We got to the end of the active list. Update the tail */</span>
		btlog-&gt;tail = precindex;
	}

	<span class="enscript-keyword">if</span> (btlog-&gt;unlock_callback)
		btlog-&gt;unlock_callback(btlog-&gt;callback_context);

}
</pre>
<hr />
</body></html>