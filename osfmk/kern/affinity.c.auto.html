<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>affinity.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">affinity.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/affinity.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/cpu_affinity.h&gt;</span>

<span class="enscript-comment">/*
 * Affinity involves 2 objects:
 * - affinity namespace:
 *	shared by a task family, this controls affinity tag lookup and
 *	allocation; it anchors all affinity sets in one namespace
 * - affinity set:
 * 	anchors all threads with membership of this affinity set
 *	and which share an affinity tag in the owning namespace.
 * 
 * Locking:
 * - The task lock protects the creation of an affinity namespace.
 * - The affinity namespace mutex protects the inheritance of a namespace
 *   and its thread membership. This includes its destruction when the task
 *   reference count goes to zero.
 * - The thread mutex protects a thread's affinity set membership, but in
 *   addition, the thread_lock is taken to write thread-&gt;affinity_set since this
 *   field (representng the active affinity set) is read by the scheduler.
 * 
 * The lock ordering is: task lock, thread mutex, namespace mutex, thread lock.
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">AFFINITY_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DBG</span>(x...)	kprintf(<span class="enscript-string">&quot;DBG: &quot;</span> x)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DBG</span>(x...)
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> affinity_space {
	lck_mtx_t		aspc_lock;
	uint32_t		aspc_task_count;
	queue_head_t	aspc_affinities;
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> affinity_space *affinity_space_t;

<span class="enscript-type">static</span> affinity_space_t <span class="enscript-function-name">affinity_space_alloc</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">affinity_space_free</span>(affinity_space_t aspc);
<span class="enscript-type">static</span> affinity_set_t <span class="enscript-function-name">affinity_set_alloc</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">affinity_set_free</span>(affinity_set_t aset);
<span class="enscript-type">static</span> affinity_set_t <span class="enscript-function-name">affinity_set_find</span>(affinity_space_t aspc, uint32_t tag);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">affinity_set_place</span>(affinity_space_t aspc, affinity_set_t aset);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">affinity_set_add</span>(affinity_set_t aset, thread_t thread);
<span class="enscript-type">static</span> affinity_set_t <span class="enscript-function-name">affinity_set_remove</span>(affinity_set_t aset, thread_t thread);

<span class="enscript-comment">/*
 * The following globals may be modified by the sysctls
 *   kern.affinity_sets_enabled	- disables hinting if cleared
 *   kern.affinity_sets_mapping	- controls cache distribution policy
 * See bsd/kern_sysctl.c
 *
 * Affinity sets are not used on embedded, which typically only
 * has a single pset, and last-processor affinity is
 * more important than pset affinity.
 */</span>
boolean_t	affinity_sets_enabled = TRUE;
<span class="enscript-type">int</span>		affinity_sets_mapping = 1;

boolean_t
<span class="enscript-function-name">thread_affinity_is_supported</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (ml_get_max_affinity_sets() != 0);
}


<span class="enscript-comment">/*
 * thread_affinity_get() 
 * Return the affinity tag for a thread. 
 * Called with the thread mutex held.
 */</span>
uint32_t
<span class="enscript-function-name">thread_affinity_get</span>(thread_t thread)
{
	uint32_t tag;

	<span class="enscript-keyword">if</span> (thread-&gt;affinity_set != NULL)
		tag = thread-&gt;affinity_set-&gt;aset_tag;
	<span class="enscript-keyword">else</span>
		tag = THREAD_AFFINITY_TAG_NULL;

	<span class="enscript-keyword">return</span> tag;
}


<span class="enscript-comment">/*
 * thread_affinity_set() 
 * Place a thread in an affinity set identified by a tag.
 * Called with thread referenced but not locked.
 */</span>
kern_return_t
<span class="enscript-function-name">thread_affinity_set</span>(thread_t thread, uint32_t tag)
{
	affinity_set_t		aset;
	affinity_set_t		empty_aset = NULL;
	affinity_space_t	aspc;
	affinity_space_t	new_aspc = NULL;

	DBG(<span class="enscript-string">&quot;thread_affinity_set(%p,%u)\n&quot;</span>, thread, tag);

	task_lock(thread-&gt;task);
	aspc = thread-&gt;task-&gt;affinity_space;
	<span class="enscript-keyword">if</span> (aspc == NULL) {
		task_unlock(thread-&gt;task);
		new_aspc = affinity_space_alloc();
		<span class="enscript-keyword">if</span> (new_aspc == NULL)
			<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
		task_lock(thread-&gt;task);
		<span class="enscript-keyword">if</span> (thread-&gt;task-&gt;affinity_space == NULL) {
			thread-&gt;task-&gt;affinity_space = new_aspc;
			new_aspc = NULL;
		}
		aspc = thread-&gt;task-&gt;affinity_space;
	}
	task_unlock(thread-&gt;task);
	<span class="enscript-keyword">if</span> (new_aspc)
		affinity_space_free(new_aspc);

	thread_mtx_lock(thread);
	<span class="enscript-keyword">if</span> (!thread-&gt;active) {
		<span class="enscript-comment">/* Beaten to lock and the thread is dead */</span>
		thread_mtx_unlock(thread);
		<span class="enscript-keyword">return</span> KERN_TERMINATED;
	}

	lck_mtx_lock(&amp;aspc-&gt;aspc_lock);
	aset = thread-&gt;affinity_set;
	<span class="enscript-keyword">if</span> (aset != NULL) {
		<span class="enscript-comment">/*
		 * Remove thread from current affinity set
		 */</span>
		DBG(<span class="enscript-string">&quot;thread_affinity_set(%p,%u) removing from aset %p\n&quot;</span>,
			thread, tag, aset);
		empty_aset = affinity_set_remove(aset, thread);
	}

	<span class="enscript-keyword">if</span> (tag != THREAD_AFFINITY_TAG_NULL) {
		aset = affinity_set_find(aspc, tag);
		<span class="enscript-keyword">if</span> (aset != NULL) {
			<span class="enscript-comment">/*
			 * Add thread to existing affinity set
			 */</span>
			DBG(<span class="enscript-string">&quot;thread_affinity_set(%p,%u) found aset %p\n&quot;</span>,
				thread, tag, aset);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Use the new affinity set, add this thread
			 * and place it in a suitable processor set.
			 */</span>
			<span class="enscript-keyword">if</span> (empty_aset != NULL) {
				aset = empty_aset;
				empty_aset = NULL;
			} <span class="enscript-keyword">else</span> {
				aset = affinity_set_alloc();
				<span class="enscript-keyword">if</span> (aset == NULL) {
					lck_mtx_unlock(&amp;aspc-&gt;aspc_lock);
					thread_mtx_unlock(thread);
					<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
				}
			}
			DBG(<span class="enscript-string">&quot;thread_affinity_set(%p,%u) (re-)using aset %p\n&quot;</span>,
				thread, tag, aset);
			aset-&gt;aset_tag = tag;
			affinity_set_place(aspc, aset);
		}
		affinity_set_add(aset, thread);
	}

	lck_mtx_unlock(&amp;aspc-&gt;aspc_lock);
	thread_mtx_unlock(thread);

	<span class="enscript-comment">/*
	 * If we wound up not using an empty aset we created,
	 * free it here.
	 */</span>
	<span class="enscript-keyword">if</span> (empty_aset != NULL)
		affinity_set_free(empty_aset);

	<span class="enscript-keyword">if</span> (thread == current_thread())
	        thread_block(THREAD_CONTINUE_NULL);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 * task_affinity_create()
 * Called from task create.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_affinity_create</span>(task_t parent_task, task_t child_task)
{
	affinity_space_t	aspc = parent_task-&gt;affinity_space;

	DBG(<span class="enscript-string">&quot;task_affinity_create(%p,%p)\n&quot;</span>, parent_task, child_task);

	assert(aspc);

	<span class="enscript-comment">/*
	 * Bump the task reference count on the shared namespace and
	 * give it to the child.
	 */</span>
	lck_mtx_lock(&amp;aspc-&gt;aspc_lock);
	aspc-&gt;aspc_task_count++;
	child_task-&gt;affinity_space = aspc;
	lck_mtx_unlock(&amp;aspc-&gt;aspc_lock);
}

<span class="enscript-comment">/*
 * task_affinity_deallocate()
 * Called from task_deallocate() when there's a namespace to dereference.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_affinity_deallocate</span>(task_t	task)
{
	affinity_space_t	aspc = task-&gt;affinity_space;

	DBG(<span class="enscript-string">&quot;task_affinity_deallocate(%p) aspc %p task_count %d\n&quot;</span>,
		task, aspc, aspc-&gt;aspc_task_count);

	lck_mtx_lock(&amp;aspc-&gt;aspc_lock);
	<span class="enscript-keyword">if</span> (--(aspc-&gt;aspc_task_count) == 0) {
		assert(queue_empty(&amp;aspc-&gt;aspc_affinities));
		lck_mtx_unlock(&amp;aspc-&gt;aspc_lock);
		affinity_space_free(aspc);
	} <span class="enscript-keyword">else</span> {
		lck_mtx_unlock(&amp;aspc-&gt;aspc_lock);
	}
}

<span class="enscript-comment">/*
 * task_affinity_info()
 * Return affinity tag info (number, min, max) for the task.
 *
 * Conditions: task is locked.
 */</span>
kern_return_t
<span class="enscript-function-name">task_affinity_info</span>(
	task_t			task,
	task_info_t		task_info_out,
	mach_msg_type_number_t	*task_info_count)
{
	affinity_set_t			aset;
	affinity_space_t		aspc;
	task_affinity_tag_info_t	info;

	*task_info_count = TASK_AFFINITY_TAG_INFO_COUNT;
	info = (task_affinity_tag_info_t) task_info_out;
	info-&gt;set_count = 0;
	info-&gt;task_count = 0;
	info-&gt;min = THREAD_AFFINITY_TAG_NULL;
	info-&gt;max = THREAD_AFFINITY_TAG_NULL;

	aspc = task-&gt;affinity_space;
	<span class="enscript-keyword">if</span> (aspc) {
		lck_mtx_lock(&amp;aspc-&gt;aspc_lock);
		queue_iterate(&amp;aspc-&gt;aspc_affinities,
				 aset, affinity_set_t, aset_affinities) {	
			info-&gt;set_count++;
			<span class="enscript-keyword">if</span> (info-&gt;min == THREAD_AFFINITY_TAG_NULL ||
			    aset-&gt;aset_tag &lt; (uint32_t) info-&gt;min)
				info-&gt;min = aset-&gt;aset_tag;
			<span class="enscript-keyword">if</span> (info-&gt;max == THREAD_AFFINITY_TAG_NULL ||
			    aset-&gt;aset_tag &gt; (uint32_t) info-&gt;max)
				info-&gt;max = aset-&gt;aset_tag;
		}
		info-&gt;task_count = aspc-&gt;aspc_task_count;
		lck_mtx_unlock(&amp;aspc-&gt;aspc_lock);
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 * Called from thread_dup() during fork() with child's mutex held.
 * Set the child into the parent's affinity set.
 * Note the affinity space is shared.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">thread_affinity_dup</span>(thread_t parent, thread_t child)
{
	affinity_set_t			aset;
	affinity_space_t		aspc;

	thread_mtx_lock(parent);
	aset = parent-&gt;affinity_set;
	DBG(<span class="enscript-string">&quot;thread_affinity_dup(%p,%p) aset %p\n&quot;</span>, parent, child, aset);
	<span class="enscript-keyword">if</span> (aset == NULL) {
		thread_mtx_unlock(parent);
		<span class="enscript-keyword">return</span>;
	}

	aspc = aset-&gt;aset_space;
	assert(aspc == parent-&gt;task-&gt;affinity_space);
	assert(aspc == child-&gt;task-&gt;affinity_space);

	lck_mtx_lock(&amp;aspc-&gt;aspc_lock);
	affinity_set_add(aset, child);
	lck_mtx_unlock(&amp;aspc-&gt;aspc_lock);

	thread_mtx_unlock(parent);
}

<span class="enscript-comment">/*
 * thread_affinity_terminate() 
 * Remove thread from any affinity set.
 * Called with the thread mutex locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">thread_affinity_terminate</span>(thread_t thread)
{
	affinity_set_t		aset = thread-&gt;affinity_set;
	affinity_space_t	aspc;

	DBG(<span class="enscript-string">&quot;thread_affinity_terminate(%p)\n&quot;</span>, thread);

	aspc = aset-&gt;aset_space;
	lck_mtx_lock(&amp;aspc-&gt;aspc_lock);
	<span class="enscript-keyword">if</span> (affinity_set_remove(aset, thread)) {
		affinity_set_free(aset);
	}
	lck_mtx_unlock(&amp;aspc-&gt;aspc_lock);
}

<span class="enscript-comment">/*
 * thread_affinity_exec()
 * Called from execve() to cancel any current affinity - a new image implies
 * the calling thread terminates any expressed or inherited affinity.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">thread_affinity_exec</span>(thread_t thread)
{
	<span class="enscript-keyword">if</span> (thread-&gt;affinity_set != AFFINITY_SET_NULL)
		thread_affinity_terminate(thread);
}

<span class="enscript-comment">/*
 * Create an empty affinity namespace data structure.
 */</span>
<span class="enscript-type">static</span> affinity_space_t
<span class="enscript-function-name">affinity_space_alloc</span>(<span class="enscript-type">void</span>) 
{
	affinity_space_t	aspc;

	aspc = (affinity_space_t) kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> affinity_space));
	<span class="enscript-keyword">if</span> (aspc == NULL)
		<span class="enscript-keyword">return</span> NULL;

	lck_mtx_init(&amp;aspc-&gt;aspc_lock, &amp;task_lck_grp, &amp;task_lck_attr);
	queue_init(&amp;aspc-&gt;aspc_affinities);
	aspc-&gt;aspc_task_count = 1;

	DBG(<span class="enscript-string">&quot;affinity_space_create() returns %p\n&quot;</span>, aspc);
	<span class="enscript-keyword">return</span> aspc;
}

<span class="enscript-comment">/*
 * Destroy the given empty affinity namespace data structure.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">affinity_space_free</span>(affinity_space_t aspc)
{
	assert(queue_empty(&amp;aspc-&gt;aspc_affinities));

	lck_mtx_destroy(&amp;aspc-&gt;aspc_lock, &amp;task_lck_grp);
	DBG(<span class="enscript-string">&quot;affinity_space_free(%p)\n&quot;</span>, aspc);
	kfree(aspc, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> affinity_space));
}


<span class="enscript-comment">/*
 * Create an empty affinity set data structure
 * entering it into a list anchored by the owning task.
 */</span>
<span class="enscript-type">static</span> affinity_set_t
<span class="enscript-function-name">affinity_set_alloc</span>(<span class="enscript-type">void</span>) 
{
	affinity_set_t	aset;

	aset = (affinity_set_t) kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> affinity_set));
	<span class="enscript-keyword">if</span> (aset == NULL)
		<span class="enscript-keyword">return</span> NULL;

	aset-&gt;aset_thread_count = 0;
	queue_init(&amp;aset-&gt;aset_affinities);
	queue_init(&amp;aset-&gt;aset_threads);
	aset-&gt;aset_num = 0;
	aset-&gt;aset_pset = PROCESSOR_SET_NULL;
	aset-&gt;aset_space = NULL;

	DBG(<span class="enscript-string">&quot;affinity_set_create() returns %p\n&quot;</span>, aset);
	<span class="enscript-keyword">return</span> aset;
}

<span class="enscript-comment">/*
 * Destroy the given empty affinity set data structure
 * after removing it from the parent task.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">affinity_set_free</span>(affinity_set_t aset)
{
	assert(queue_empty(&amp;aset-&gt;aset_threads));

	DBG(<span class="enscript-string">&quot;affinity_set_free(%p)\n&quot;</span>, aset);
	kfree(aset, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> affinity_set));
}

<span class="enscript-comment">/*
 * Add a thread to an affinity set.
 * The caller must have the thread mutex and space locked.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">affinity_set_add</span>(affinity_set_t aset, thread_t thread)
{
	spl_t	s;

	DBG(<span class="enscript-string">&quot;affinity_set_add(%p,%p)\n&quot;</span>, aset, thread);
	queue_enter(&amp;aset-&gt;aset_threads,
		thread, thread_t, affinity_threads);
	aset-&gt;aset_thread_count++;
	s = splsched();
	thread_lock(thread);
	thread-&gt;affinity_set = affinity_sets_enabled ? aset : NULL;
	thread_unlock(thread);
	splx(s);
}

<span class="enscript-comment">/*
 * Remove a thread from an affinity set returning the set if now empty.
 * The caller must have the thread mutex and space locked.
 */</span>
<span class="enscript-type">static</span> affinity_set_t
<span class="enscript-function-name">affinity_set_remove</span>(affinity_set_t aset, thread_t thread)
{
	spl_t	s;

	s = splsched();
	thread_lock(thread);
	thread-&gt;affinity_set = NULL;
	thread_unlock(thread);
	splx(s);

	aset-&gt;aset_thread_count--;
	queue_remove(&amp;aset-&gt;aset_threads,
		thread, thread_t, affinity_threads);
	<span class="enscript-keyword">if</span> (queue_empty(&amp;aset-&gt;aset_threads)) {
		queue_remove(&amp;aset-&gt;aset_space-&gt;aspc_affinities,
				aset, affinity_set_t, aset_affinities);
		assert(aset-&gt;aset_thread_count == 0);
		aset-&gt;aset_tag = THREAD_AFFINITY_TAG_NULL;
		aset-&gt;aset_num = 0;
		aset-&gt;aset_pset = PROCESSOR_SET_NULL;
		aset-&gt;aset_space = NULL;
		DBG(<span class="enscript-string">&quot;affinity_set_remove(%p,%p) set now empty\n&quot;</span>, aset, thread);
		<span class="enscript-keyword">return</span> aset;
	} <span class="enscript-keyword">else</span> {
		DBG(<span class="enscript-string">&quot;affinity_set_remove(%p,%p)\n&quot;</span>, aset, thread);
		<span class="enscript-keyword">return</span> NULL;
	}
}

<span class="enscript-comment">/*
 * Find an affinity set in the parent task with the given affinity tag.
 * The caller must have the space locked.
 */</span>
<span class="enscript-type">static</span> affinity_set_t
<span class="enscript-function-name">affinity_set_find</span>(affinity_space_t space, uint32_t tag)
{
	affinity_set_t	aset;

	queue_iterate(&amp;space-&gt;aspc_affinities,
			 aset, affinity_set_t, aset_affinities) {	
		<span class="enscript-keyword">if</span> (aset-&gt;aset_tag == tag) {
			DBG(<span class="enscript-string">&quot;affinity_set_find(%p,%u) finds %p\n&quot;</span>,
		 	    space, tag, aset);
			<span class="enscript-keyword">return</span> aset;
		}
	}
	DBG(<span class="enscript-string">&quot;affinity_set_find(%p,%u) not found\n&quot;</span>, space, tag);
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * affinity_set_place() assigns an affinity set to a suitable processor_set.
 * The selection criteria is:
 *  - the set currently occupied by the least number of affinities
 *    belonging to the owning the task.
 * The caller must have the space locked.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">affinity_set_place</span>(affinity_space_t aspc, affinity_set_t new_aset)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	num_cpu_asets = ml_get_max_affinity_sets();
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	set_occupancy[num_cpu_asets];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i_least_occupied;
	affinity_set_t	aset;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; num_cpu_asets; i++)
		set_occupancy[i] = 0;

	<span class="enscript-comment">/*
	 * Scan the affinity sets calculating the number of sets
	 * occupy the available physical affinities.
	 */</span>
	queue_iterate(&amp;aspc-&gt;aspc_affinities,
			 aset, affinity_set_t, aset_affinities) {
		<span class="enscript-keyword">if</span>(aset-&gt;aset_num &lt; num_cpu_asets)
			set_occupancy[aset-&gt;aset_num]++;
		<span class="enscript-keyword">else</span>
			panic(<span class="enscript-string">&quot;aset_num = %d in %s\n&quot;</span>, aset-&gt;aset_num, __FUNCTION__);
	}

	<span class="enscript-comment">/*
	 * Find the least occupied set (or the first empty set).
	 * To distribute placements somewhat, start searching from
	 * a cpu affinity chosen randomly per namespace:
	 *   [(unsigned int)aspc % 127] % num_cpu_asets
	 * unless this mapping policy is overridden.
	 */</span>
	<span class="enscript-keyword">if</span> (affinity_sets_mapping == 0)
		i_least_occupied = 0;
	<span class="enscript-keyword">else</span>
		i_least_occupied = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(((uintptr_t)aspc % 127) % num_cpu_asets);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; num_cpu_asets; i++) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	j = (i_least_occupied + i) % num_cpu_asets;
		<span class="enscript-keyword">if</span> (set_occupancy[j] == 0) {
			i_least_occupied = j;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (set_occupancy[j] &lt; set_occupancy[i_least_occupied])
			i_least_occupied = j;
	}
	new_aset-&gt;aset_num = i_least_occupied;
	new_aset-&gt;aset_pset = ml_affinity_to_pset(i_least_occupied);

	<span class="enscript-comment">/* Add the new affinity set to the group */</span>
	new_aset-&gt;aset_space = aspc;
	queue_enter(&amp;aspc-&gt;aspc_affinities,
			new_aset, affinity_set_t, aset_affinities);

	DBG(<span class="enscript-string">&quot;affinity_set_place(%p,%p) selected affinity %u pset %p\n&quot;</span>,
	    aspc, new_aset, new_aset-&gt;aset_num, new_aset-&gt;aset_pset);
}
</pre>
<hr />
</body></html>