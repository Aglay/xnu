<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>zalloc.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">zalloc.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	kern/zalloc.c
 *	Author:	Avadis Tevanian, Jr.
 *
 *	Zone-based memory allocator.  A zone is a collection of fixed size
 *	data blocks for which quick allocation/deallocation is possible.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;zone_debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;zone_alias_addr.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_host_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine/vm_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug/zone_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/macro_help.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/btlog.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machparam.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>  <span class="enscript-comment">/* ml_cpu_get_info */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

<span class="enscript-comment">/*
 *  ZONE_ALIAS_ADDR
 *
 * With this option enabled, zones with alloc_size &lt;= PAGE_SIZE allocate
 * a virtual page from the zone_map, but before zcram-ing the allocated memory
 * into the zone, the page is translated to use the alias address of the page
 * in the static kernel region. zone_gc reverses that translation when
 * scanning the freelist to collect free pages so that it can look up the page
 * in the zone_page_table, and free it to kmem_free.
 *
 * The static kernel region is a flat 1:1 mapping of physical memory passed
 * to xnu by the booter. It is mapped to the range:
 * [gVirtBase, gVirtBase + gPhysSize]
 *
 * Accessing memory via the static kernel region is faster due to the
 * entire region being mapped via large pages, cutting down
 * on TLB misses.
 *
 * zinit favors using PAGE_SIZE backing allocations for a zone unless it would
 * waste more than 10% space to use a single page, in order to take advantage
 * of the speed benefit for as many zones as possible.
 *
 * Zones with &gt; PAGE_SIZE allocations can't take advantage of this
 * because kernel_memory_allocate doesn't give out physically contiguous pages.
 *
 * zone_virtual_addr()
 *  - translates an address from the static kernel region to the zone_map
 *  - returns the same address if it's not from the static kernel region
 * It relies on the fact that a physical page mapped to the
 * zone_map is not mapped anywhere else (except the static kernel region).
 *
 * zone_alias_addr()
 *  - translates a virtual memory address from the zone_map to the
 *    corresponding address in the static kernel region
 *
 */</span>

#<span class="enscript-reference">if</span>     !<span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">from_zone_map</span>(addr, size) \
        ((vm_offset_t)(addr)             &gt;= zone_map_min_address &amp;&amp; \
        ((vm_offset_t)(addr) + size - 1) &lt;  zone_map_max_address )
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">from_zone_map</span>(addr, size) \
        ((vm_offset_t)(zone_virtual_addr((vm_map_address_t)(uintptr_t)addr))            &gt;= zone_map_min_address &amp;&amp; \
        ((vm_offset_t)(zone_virtual_addr((vm_map_address_t)(uintptr_t)addr)) + size -1) &lt;  zone_map_max_address )
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Zone Corruption Debugging
 *
 * We use three techniques to detect modification of a zone element
 * after it's been freed.
 *
 * (1) Check the freelist next pointer for sanity.
 * (2) Store a backup of the next pointer at the end of the element,
 *     and compare it to the primary next pointer when the element is allocated
 *     to detect corruption of the freelist due to use-after-free bugs.
 *     The backup pointer is also XORed with a per-boot random cookie.
 * (3) Poison the freed element by overwriting it with 0xdeadbeef,
 *     and check for that value when the element is being reused to make sure
 *     no part of the element has been modified while it was on the freelist.
 *     This will also help catch read-after-frees, as code will now dereference
 *     0xdeadbeef instead of a valid but freed pointer.
 *
 * (1) and (2) occur for every allocation and free to a zone.
 * This is done to make it slightly more difficult for an attacker to
 * manipulate the freelist to behave in a specific way.
 *
 * Poisoning (3) occurs periodically for every N frees (counted per-zone)
 * and on every free for zones smaller than a cacheline.  If -zp
 * is passed as a boot arg, poisoning occurs for every free.
 *
 * Performance slowdown is inversely proportional to the frequency of poisoning,
 * with a 4-5% hit around N=1, down to ~0.3% at N=16 and just &quot;noise&quot; at N=32
 * and higher. You can expect to find a 100% reproducible bug in an average of
 * N tries, with a standard deviation of about N, but you will want to set
 * &quot;-zp&quot; to always poison every free if you are attempting to reproduce
 * a known bug.
 *
 * For a more heavyweight, but finer-grained method of detecting misuse
 * of zone memory, look up the &quot;Guard mode&quot; zone allocator in gzalloc.c.
 *
 * Zone Corruption Logging
 *
 * You can also track where corruptions come from by using the boot-arguments
 * &quot;zlog=&lt;zone name to log&gt; -zc&quot;. Search for &quot;Zone corruption logging&quot; later
 * in this document for more implementation and usage information.
 *
 * Zone Leak Detection
 *
 * To debug leaks of zone memory, use the zone leak detection tool 'zleaks'
 * found later in this file via the showtopztrace and showz* macros in kgmacros,
 * or use zlog without the -zc argument.
 *
 */</span>

<span class="enscript-comment">/* Returns TRUE if we rolled over the counter at factor */</span>
<span class="enscript-type">static</span> inline boolean_t
<span class="enscript-function-name">sample_counter</span>(<span class="enscript-type">volatile</span> uint32_t * count_p, uint32_t factor)
{
	uint32_t old_count, new_count;
	boolean_t rolled_over;

	<span class="enscript-keyword">do</span> {
		new_count = old_count = *count_p;

		<span class="enscript-keyword">if</span> (++new_count &gt;= factor) {
			rolled_over = TRUE;
			new_count = 0;
		} <span class="enscript-keyword">else</span> {
			rolled_over = FALSE;
		}

	} <span class="enscript-keyword">while</span> (!OSCompareAndSwap(old_count, new_count, count_p));

	<span class="enscript-keyword">return</span> rolled_over;
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZP_POISON</span>       0xdeadbeefdeadbeef
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZP_POISON</span>       0xdeadbeef
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZP_DEFAULT_SAMPLING_FACTOR</span> 16
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZP_DEFAULT_SCALE_FACTOR</span> 4

<span class="enscript-comment">/*
 *  A zp_factor of 0 indicates zone poisoning is disabled,
 *  however, we still poison zones smaller than zp_tiny_zone_limit (a cacheline).
 *  Passing the -no-zp boot-arg disables even this behavior.
 *  In all cases, we record and check the integrity of a backup pointer.
 */</span>

<span class="enscript-comment">/* set by zp-factor=N boot arg, zero indicates non-tiny poisoning disabled */</span>
uint32_t        zp_factor               = 0;

<span class="enscript-comment">/* set by zp-scale=N boot arg, scales zp_factor by zone size */</span>
uint32_t        zp_scale                = 0;

<span class="enscript-comment">/* set in zp_init, zero indicates -no-zp boot-arg */</span>
vm_size_t       zp_tiny_zone_limit      = 0;

<span class="enscript-comment">/* initialized to a per-boot random value in zp_init */</span>
uintptr_t       zp_poisoned_cookie      = 0;
uintptr_t       zp_nopoison_cookie      = 0;


<span class="enscript-comment">/*
 * initialize zone poisoning
 * called from zone_bootstrap before any allocations are made from zalloc
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">zp_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">char</span> temp_buf[16];

	<span class="enscript-comment">/*
	 * Initialize backup pointer random cookie for poisoned elements
	 * Try not to call early_random() back to back, it may return
	 * the same value if mach_absolute_time doesn't have sufficient time
	 * to tick over between calls.  &lt;rdar://problem/11597395&gt;
	 * (This is only a problem on embedded devices)
	 */</span>
	zp_poisoned_cookie = (uintptr_t) early_random();

	<span class="enscript-comment">/*
	 * Always poison zones smaller than a cacheline,
	 * because it's pretty close to free
	 */</span>
	ml_cpu_info_t cpu_info;
	ml_cpu_get_info(&amp;cpu_info);
	zp_tiny_zone_limit = (vm_size_t) cpu_info.cache_line_size;

	zp_factor = ZP_DEFAULT_SAMPLING_FACTOR;
	zp_scale  = ZP_DEFAULT_SCALE_FACTOR;

	<span class="enscript-comment">//TODO: Bigger permutation?
</span>	<span class="enscript-comment">/*
	 * Permute the default factor +/- 1 to make it less predictable
	 * This adds or subtracts ~4 poisoned objects per 1000 frees.
	 */</span>
	<span class="enscript-keyword">if</span> (zp_factor != 0) {
		uint32_t rand_bits = early_random() &amp; 0x3;

		<span class="enscript-keyword">if</span> (rand_bits == 0x1)
			zp_factor += 1;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rand_bits == 0x2)
			zp_factor -= 1;
		<span class="enscript-comment">/* if 0x0 or 0x3, leave it alone */</span>
	}

	<span class="enscript-comment">/* -zp: enable poisoning for every alloc and free */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-zp&quot;</span>, temp_buf, <span class="enscript-keyword">sizeof</span>(temp_buf))) {
		zp_factor = 1;
	}

	<span class="enscript-comment">/* -no-zp: disable poisoning completely even for tiny zones */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-no-zp&quot;</span>, temp_buf, <span class="enscript-keyword">sizeof</span>(temp_buf))) {
		zp_factor          = 0;
		zp_tiny_zone_limit = 0;
		printf(<span class="enscript-string">&quot;Zone poisoning disabled\n&quot;</span>);
	}

	<span class="enscript-comment">/* zp-factor=XXXX: override how often to poison freed zone elements */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;zp-factor&quot;</span>, &amp;zp_factor, <span class="enscript-keyword">sizeof</span>(zp_factor))) {
		printf(<span class="enscript-string">&quot;Zone poisoning factor override: %u\n&quot;</span>, zp_factor);
	}

	<span class="enscript-comment">/* zp-scale=XXXX: override how much zone size scales zp-factor by */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;zp-scale&quot;</span>, &amp;zp_scale, <span class="enscript-keyword">sizeof</span>(zp_scale))) {
		printf(<span class="enscript-string">&quot;Zone poisoning scale factor override: %u\n&quot;</span>, zp_scale);
	}

	<span class="enscript-comment">/* Initialize backup pointer random cookie for unpoisoned elements */</span>
	zp_nopoison_cookie = (uintptr_t) early_random();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">if</span> (zp_poisoned_cookie == zp_nopoison_cookie)
		panic(<span class="enscript-string">&quot;early_random() is broken: %p and %p are not random\n&quot;</span>,
		      (<span class="enscript-type">void</span> *) zp_poisoned_cookie, (<span class="enscript-type">void</span> *) zp_nopoison_cookie);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Use the last bit in the backup pointer to hint poisoning state
	 * to backup_ptr_mismatch_panic. Valid zone pointers are aligned, so
	 * the low bits are zero.
	 */</span>
	zp_poisoned_cookie |=   (uintptr_t)0x1ULL;
	zp_nopoison_cookie &amp;= ~((uintptr_t)0x1ULL);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	<span class="enscript-comment">/*
	 * Make backup pointers more obvious in GDB for 64 bit
	 * by making OxFFFFFF... ^ cookie = 0xFACADE...
	 * (0xFACADE = 0xFFFFFF ^ 0x053521)
	 * (0xC0FFEE = 0xFFFFFF ^ 0x3f0011)
	 * The high 3 bytes of a zone pointer are always 0xFFFFFF, and are checked
	 * by the sanity check, so it's OK for that part of the cookie to be predictable.
	 *
	 * TODO: Use #defines, xors, and shifts
	 */</span>

	zp_poisoned_cookie &amp;= 0x000000FFFFFFFFFF;
	zp_poisoned_cookie |= 0x0535210000000000; <span class="enscript-comment">/* 0xFACADE */</span>

	zp_nopoison_cookie &amp;= 0x000000FFFFFFFFFF;
	zp_nopoison_cookie |= 0x3f00110000000000; <span class="enscript-comment">/* 0xC0FFEE */</span>
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/* zone_map page count for page table structure */</span>
uint64_t zone_map_table_page_count = 0;

<span class="enscript-comment">/*
 * These macros are used to keep track of the number
 * of pages being used by the zone currently. The
 * z-&gt;page_count is protected by the zone lock.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ZONE_PAGE_COUNT_INCR</span>(z, count)		\
{						\
	OSAddAtomic64(count, &amp;(z-&gt;page_count));	\
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ZONE_PAGE_COUNT_DECR</span>(z, count)			\
{							\
	OSAddAtomic64(-count, &amp;(z-&gt;page_count));	\
}

<span class="enscript-comment">/* for is_sane_zone_element and garbage collection */</span>

vm_offset_t     zone_map_min_address = 0;  <span class="enscript-comment">/* initialized in zone_init */</span>
vm_offset_t     zone_map_max_address = 0;

<span class="enscript-comment">/* Helpful for walking through a zone's free element list. */</span>
<span class="enscript-type">struct</span> zone_free_element {
	<span class="enscript-type">struct</span> zone_free_element *next;
	<span class="enscript-comment">/* ... */</span>
	<span class="enscript-comment">/* void *backup_ptr; */</span>
};

<span class="enscript-type">struct</span> zone_page_metadata {
	queue_chain_t				pages;
	<span class="enscript-type">struct</span> zone_free_element	*elements;
	zone_t						zone;
	uint16_t					alloc_count;
	uint16_t					free_count;
};

<span class="enscript-comment">/* The backup pointer is stored in the last pointer-sized location in an element. */</span>
<span class="enscript-type">static</span> inline vm_offset_t *
<span class="enscript-function-name">get_backup_ptr</span>(vm_size_t  elem_size,
               vm_offset_t *element)
{
	<span class="enscript-keyword">return</span> (vm_offset_t *) ((vm_offset_t)element + elem_size - <span class="enscript-keyword">sizeof</span>(vm_offset_t));
}

<span class="enscript-type">static</span> inline <span class="enscript-type">struct</span> zone_page_metadata *
<span class="enscript-function-name">get_zone_page_metadata</span>(<span class="enscript-type">struct</span> zone_free_element *element)
{
	<span class="enscript-keyword">return</span> (<span class="enscript-type">struct</span> zone_page_metadata *)(trunc_page((vm_offset_t)element));
}

<span class="enscript-comment">/*
 * Zone checking helper function.
 * A pointer that satisfies these conditions is OK to be a freelist next pointer
 * A pointer that doesn't satisfy these conditions indicates corruption
 */</span>
<span class="enscript-type">static</span> inline boolean_t
<span class="enscript-function-name">is_sane_zone_ptr</span>(zone_t		zone,
                 vm_offset_t	addr,
		 size_t		obj_size)
{
	<span class="enscript-comment">/*  Must be aligned to pointer boundary */</span>
	<span class="enscript-keyword">if</span> (__improbable((addr &amp; (<span class="enscript-keyword">sizeof</span>(vm_offset_t) - 1)) != 0))
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-comment">/*  Must be a kernel address */</span>
	<span class="enscript-keyword">if</span> (__improbable(!pmap_kernel_va(addr)))
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-comment">/*  Must be from zone map if the zone only uses memory from the zone_map */</span>
	<span class="enscript-comment">/*
	 *  TODO: Remove the zone-&gt;collectable check when every
	 *  zone using foreign memory is properly tagged with allows_foreign
	 */</span>
	<span class="enscript-keyword">if</span> (zone-&gt;collectable &amp;&amp; !zone-&gt;allows_foreign) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
		<span class="enscript-comment">/*
		 * If this address is in the static kernel region, it might be
		 * the alias address of a valid zone element.
		 * If we tried to find the zone_virtual_addr() of an invalid
		 * address in the static kernel region, it will panic, so don't 
		 * check addresses in this region.
		 *
		 * TODO: Use a safe variant of zone_virtual_addr to
		 *  make this check more accurate
		 *
		 * The static kernel region is mapped at:
		 * [gVirtBase, gVirtBase + gPhysSize]
		 */</span>
		<span class="enscript-keyword">if</span> ((addr - gVirtBase) &lt; gPhysSize)
			<span class="enscript-keyword">return</span> TRUE;
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/*  check if addr is from zone map */</span>
		<span class="enscript-keyword">if</span> (addr                 &gt;= zone_map_min_address &amp;&amp;
		   (addr + obj_size - 1) &lt;  zone_map_max_address )
			<span class="enscript-keyword">return</span> TRUE;

		<span class="enscript-keyword">return</span> FALSE;
	}

	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-type">static</span> inline boolean_t
<span class="enscript-function-name">is_sane_zone_page_metadata</span>(zone_t 	zone,
			   vm_offset_t 	page_meta)
{
	<span class="enscript-comment">/* NULL page metadata structures are invalid */</span>
	<span class="enscript-keyword">if</span> (page_meta == 0)
		<span class="enscript-keyword">return</span> FALSE;
	<span class="enscript-keyword">return</span> is_sane_zone_ptr(zone, page_meta, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zone_page_metadata));
}

<span class="enscript-type">static</span> inline boolean_t
<span class="enscript-function-name">is_sane_zone_element</span>(zone_t      zone,
                     vm_offset_t addr)
{
	<span class="enscript-comment">/*  NULL is OK because it indicates the tail of the list */</span>
	<span class="enscript-keyword">if</span> (addr == 0)
		<span class="enscript-keyword">return</span> TRUE;
	<span class="enscript-keyword">return</span> is_sane_zone_ptr(zone, addr, zone-&gt;elem_size);
}
	
<span class="enscript-comment">/* Someone wrote to freed memory. */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-comment">/* noreturn */</span>
<span class="enscript-function-name">zone_element_was_modified_panic</span>(zone_t        zone,
                                vm_offset_t   element,
                                vm_offset_t   found,
                                vm_offset_t   expected,
                                vm_offset_t   offset)
{
	panic(<span class="enscript-string">&quot;a freed zone element has been modified in zone %s: expected %p but found %p, bits changed %p, at offset %d of %d in element %p, cookies %p %p&quot;</span>,
	                 zone-&gt;zone_name,
	      (<span class="enscript-type">void</span> *)   expected,
	      (<span class="enscript-type">void</span> *)   found,
	      (<span class="enscript-type">void</span> *)   (expected ^ found),
	      (uint32_t) offset,
	      (uint32_t) zone-&gt;elem_size,
	      (<span class="enscript-type">void</span> *)   element,
	      (<span class="enscript-type">void</span> *)   zp_nopoison_cookie,
	      (<span class="enscript-type">void</span> *)   zp_poisoned_cookie);
}

<span class="enscript-comment">/*
 * The primary and backup pointers don't match.
 * Determine which one was likely the corrupted pointer, find out what it
 * probably should have been, and panic.
 * I would like to mark this as noreturn, but panic() isn't marked noreturn.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-comment">/* noreturn */</span>
<span class="enscript-function-name">backup_ptr_mismatch_panic</span>(zone_t        zone,
                          vm_offset_t   element,
                          vm_offset_t   primary,
                          vm_offset_t   backup)
{
	vm_offset_t likely_backup;

	boolean_t   sane_backup;
	boolean_t   sane_primary = is_sane_zone_element(zone, primary);
	boolean_t   element_was_poisoned = (backup &amp; 0x1) ? TRUE : FALSE;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	<span class="enscript-comment">/* We can inspect the tag in the upper bits for additional confirmation */</span>
	<span class="enscript-keyword">if</span> ((backup &amp; 0xFFFFFF0000000000) == 0xFACADE0000000000)
		element_was_poisoned = TRUE;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((backup &amp; 0xFFFFFF0000000000) == 0xC0FFEE0000000000)
		element_was_poisoned = FALSE;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (element_was_poisoned) {
		likely_backup = backup ^ zp_poisoned_cookie;
		sane_backup = is_sane_zone_element(zone, likely_backup);
	} <span class="enscript-keyword">else</span> {
		likely_backup = backup ^ zp_nopoison_cookie;
		sane_backup = is_sane_zone_element(zone, likely_backup);
	}

	<span class="enscript-comment">/* The primary is definitely the corrupted one */</span>
	<span class="enscript-keyword">if</span> (!sane_primary &amp;&amp; sane_backup)
		zone_element_was_modified_panic(zone, element, primary, likely_backup, 0);

	<span class="enscript-comment">/* The backup is definitely the corrupted one */</span>
	<span class="enscript-keyword">if</span> (sane_primary &amp;&amp; !sane_backup)
		zone_element_was_modified_panic(zone, element, backup,
		                                (primary ^ (element_was_poisoned ? zp_poisoned_cookie : zp_nopoison_cookie)),
		                                zone-&gt;elem_size - <span class="enscript-keyword">sizeof</span>(vm_offset_t));

	<span class="enscript-comment">/*
	 * Not sure which is the corrupted one.
	 * It's less likely that the backup pointer was overwritten with
	 * ( (sane address) ^ (valid cookie) ), so we'll guess that the
	 * primary pointer has been overwritten with a sane but incorrect address.
	 */</span>
	<span class="enscript-keyword">if</span> (sane_primary &amp;&amp; sane_backup)
		zone_element_was_modified_panic(zone, element, primary, likely_backup, 0);

	<span class="enscript-comment">/* Neither are sane, so just guess. */</span>
	zone_element_was_modified_panic(zone, element, primary, likely_backup, 0);
}

<span class="enscript-comment">/*
 * Sets the next element of tail to elem.
 * elem can be NULL.
 * Preserves the poisoning state of the element.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">append_zone_element</span>(zone_t                    zone,
                    <span class="enscript-type">struct</span> zone_free_element *tail,
                    <span class="enscript-type">struct</span> zone_free_element *elem)
{
	vm_offset_t *backup = get_backup_ptr(zone-&gt;elem_size, (vm_offset_t *) tail);

	vm_offset_t old_backup = *backup;

	vm_offset_t old_next = (vm_offset_t) tail-&gt;next;
	vm_offset_t new_next = (vm_offset_t) elem;

	<span class="enscript-keyword">if</span>      (old_next == (old_backup ^ zp_nopoison_cookie))
		*backup = new_next ^ zp_nopoison_cookie;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (old_next == (old_backup ^ zp_poisoned_cookie))
		*backup = new_next ^ zp_poisoned_cookie;
	<span class="enscript-keyword">else</span>
		backup_ptr_mismatch_panic(zone,
		                          (vm_offset_t) tail,
		                          old_next,
		                          old_backup);

	tail-&gt;next = elem;
}


<span class="enscript-comment">/*
 * Insert a linked list of elements (delineated by head and tail) at the head of
 * the zone free list. Every element in the list being added has already gone
 * through append_zone_element, so their backup pointers are already
 * set properly.
 * Precondition: There should be no elements after tail
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">add_list_to_zone</span>(zone_t                    zone,
                 <span class="enscript-type">struct</span> zone_free_element *head,
                 <span class="enscript-type">struct</span> zone_free_element *tail)
{
	assert(tail-&gt;next == NULL);
	assert(!zone-&gt;use_page_list);

	append_zone_element(zone, tail, zone-&gt;free_elements);

	zone-&gt;free_elements = head;
}


<span class="enscript-comment">/*
 * Adds the element to the head of the zone's free list
 * Keeps a backup next-pointer at the end of the element
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">free_to_zone</span>(zone_t      zone,
             vm_offset_t element,
             boolean_t   poison)
{
	vm_offset_t old_head;
	<span class="enscript-type">struct</span> zone_page_metadata *page_meta;

	vm_offset_t *primary  = (vm_offset_t *) element;
	vm_offset_t *backup   = get_backup_ptr(zone-&gt;elem_size, primary);

	<span class="enscript-keyword">if</span> (zone-&gt;use_page_list) {
		page_meta = get_zone_page_metadata((<span class="enscript-type">struct</span> zone_free_element *)element);
		assert(page_meta-&gt;zone == zone);
		old_head = (vm_offset_t)page_meta-&gt;elements;
	} <span class="enscript-keyword">else</span> {
		old_head = (vm_offset_t)zone-&gt;free_elements;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">if</span> (__improbable(!is_sane_zone_element(zone, old_head)))
		panic(<span class="enscript-string">&quot;zfree: invalid head pointer %p for freelist of zone %s\n&quot;</span>,
		      (<span class="enscript-type">void</span> *) old_head, zone-&gt;zone_name);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (__improbable(!is_sane_zone_element(zone, element)))
		panic(<span class="enscript-string">&quot;zfree: freeing invalid pointer %p to zone %s\n&quot;</span>,
		      (<span class="enscript-type">void</span> *) element, zone-&gt;zone_name);

	<span class="enscript-comment">/*
	 * Always write a redundant next pointer
	 * So that it is more difficult to forge, xor it with a random cookie
	 * A poisoned element is indicated by using zp_poisoned_cookie
	 * instead of zp_nopoison_cookie
	 */</span>

	*backup = old_head ^ (poison ? zp_poisoned_cookie : zp_nopoison_cookie);

	<span class="enscript-comment">/* Insert this element at the head of the free list */</span>
	*primary             = old_head;
	<span class="enscript-keyword">if</span> (zone-&gt;use_page_list) {
		page_meta-&gt;elements = (<span class="enscript-type">struct</span> zone_free_element *)element;
		page_meta-&gt;free_count++;
		<span class="enscript-keyword">if</span> (zone-&gt;allows_foreign &amp;&amp; !from_zone_map(element, zone-&gt;elem_size)) {
			<span class="enscript-keyword">if</span> (page_meta-&gt;free_count == 1) {
				<span class="enscript-comment">/* first foreign element freed on page, move from all_used */</span>
				remqueue((queue_entry_t)page_meta);
				enqueue_tail(&amp;zone-&gt;pages.any_free_foreign, (queue_entry_t)page_meta);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* no other list transitions */</span>
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (page_meta-&gt;free_count == page_meta-&gt;alloc_count) {
			<span class="enscript-comment">/* whether the page was on the intermediate or all_used, queue, move it to free */</span>
			remqueue((queue_entry_t)page_meta);
			enqueue_tail(&amp;zone-&gt;pages.all_free, (queue_entry_t)page_meta);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (page_meta-&gt;free_count == 1) {
			<span class="enscript-comment">/* first free element on page, move from all_used */</span>
			remqueue((queue_entry_t)page_meta);
			enqueue_tail(&amp;zone-&gt;pages.intermediate, (queue_entry_t)page_meta);
		}
	} <span class="enscript-keyword">else</span> {
		zone-&gt;free_elements = (<span class="enscript-type">struct</span> zone_free_element *)element;
	}
	zone-&gt;count--;
	zone-&gt;countfree++;
}


<span class="enscript-comment">/*
 * Removes an element from the zone's free list, returning 0 if the free list is empty.
 * Verifies that the next-pointer and backup next-pointer are intact,
 * and verifies that a poisoned element hasn't been modified.
 */</span>
<span class="enscript-type">static</span> inline vm_offset_t
<span class="enscript-function-name">try_alloc_from_zone</span>(zone_t zone,
                    boolean_t* check_poison)
{
	vm_offset_t  element;
	<span class="enscript-type">struct</span> zone_page_metadata *page_meta;

	*check_poison = FALSE;

	<span class="enscript-comment">/* if zone is empty, bail */</span>
	<span class="enscript-keyword">if</span> (zone-&gt;use_page_list) {
		<span class="enscript-keyword">if</span> (zone-&gt;allows_foreign &amp;&amp; !queue_empty(&amp;zone-&gt;pages.any_free_foreign))
			page_meta = (<span class="enscript-type">struct</span> zone_page_metadata *)queue_first(&amp;zone-&gt;pages.any_free_foreign);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!queue_empty(&amp;zone-&gt;pages.intermediate))
			page_meta = (<span class="enscript-type">struct</span> zone_page_metadata *)queue_first(&amp;zone-&gt;pages.intermediate);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!queue_empty(&amp;zone-&gt;pages.all_free))
			page_meta = (<span class="enscript-type">struct</span> zone_page_metadata *)queue_first(&amp;zone-&gt;pages.all_free);
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span> 0;
		}

		<span class="enscript-comment">/* Check if page_meta passes is_sane_zone_element */</span>
		<span class="enscript-keyword">if</span> (__improbable(!is_sane_zone_page_metadata(zone, (vm_offset_t)page_meta)))
			panic(<span class="enscript-string">&quot;zalloc: invalid metadata structure %p for freelist of zone %s\n&quot;</span>,
				(<span class="enscript-type">void</span> *) page_meta, zone-&gt;zone_name);
		assert(page_meta-&gt;zone == zone);
		element = (vm_offset_t)page_meta-&gt;elements;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (zone-&gt;free_elements == NULL)
			<span class="enscript-keyword">return</span> 0;

		element = (vm_offset_t)zone-&gt;free_elements;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">if</span> (__improbable(!is_sane_zone_element(zone, element)))
		panic(<span class="enscript-string">&quot;zfree: invalid head pointer %p for freelist of zone %s\n&quot;</span>,
		      (<span class="enscript-type">void</span> *) element, zone-&gt;zone_name);
#<span class="enscript-reference">endif</span>

	vm_offset_t *primary = (vm_offset_t *) element;
	vm_offset_t *backup  = get_backup_ptr(zone-&gt;elem_size, primary);

	vm_offset_t  next_element          = *primary;
	vm_offset_t  next_element_backup   = *backup;

	<span class="enscript-comment">/*
	 * backup_ptr_mismatch_panic will determine what next_element
	 * should have been, and print it appropriately
	 */</span>
	<span class="enscript-keyword">if</span> (__improbable(!is_sane_zone_element(zone, next_element)))
		backup_ptr_mismatch_panic(zone, element, next_element, next_element_backup);

	<span class="enscript-comment">/* Check the backup pointer for the regular cookie */</span>
	<span class="enscript-keyword">if</span> (__improbable(next_element != (next_element_backup ^ zp_nopoison_cookie))) {

		<span class="enscript-comment">/* Check for the poisoned cookie instead */</span>
		<span class="enscript-keyword">if</span> (__improbable(next_element != (next_element_backup ^ zp_poisoned_cookie)))
			<span class="enscript-comment">/* Neither cookie is valid, corruption has occurred */</span>
			backup_ptr_mismatch_panic(zone, element, next_element, next_element_backup);

		<span class="enscript-comment">/*
		 * Element was marked as poisoned, so check its integrity before using it.
		 */</span>
		*check_poison = TRUE;
	}

	<span class="enscript-keyword">if</span> (zone-&gt;use_page_list) {
			
		<span class="enscript-comment">/* Make sure the page_meta is at the correct offset from the start of page */</span>
		<span class="enscript-keyword">if</span> (__improbable(page_meta != get_zone_page_metadata((<span class="enscript-type">struct</span> zone_free_element *)element)))
			panic(<span class="enscript-string">&quot;zalloc: metadata located at incorrect location on page of zone %s\n&quot;</span>,
				zone-&gt;zone_name);

		<span class="enscript-comment">/* Make sure next_element belongs to the same page as page_meta */</span>
		<span class="enscript-keyword">if</span> (next_element) {
			<span class="enscript-keyword">if</span> (__improbable(page_meta != get_zone_page_metadata((<span class="enscript-type">struct</span> zone_free_element *)next_element)))
				panic(<span class="enscript-string">&quot;zalloc: next element pointer %p for element %p points to invalid element for zone %s\n&quot;</span>,
					(<span class="enscript-type">void</span> *)next_element, (<span class="enscript-type">void</span> *)element, zone-&gt;zone_name);
		}
	}

	<span class="enscript-comment">/* Remove this element from the free list */</span>
	<span class="enscript-keyword">if</span> (zone-&gt;use_page_list) {

		page_meta-&gt;elements = (<span class="enscript-type">struct</span> zone_free_element *)next_element;
		page_meta-&gt;free_count--;

		<span class="enscript-keyword">if</span> (zone-&gt;allows_foreign &amp;&amp; !from_zone_map(element, zone-&gt;elem_size)) {
			<span class="enscript-keyword">if</span> (page_meta-&gt;free_count == 0) {
				<span class="enscript-comment">/* move to all used */</span>
				remqueue((queue_entry_t)page_meta);
				enqueue_tail(&amp;zone-&gt;pages.all_used, (queue_entry_t)page_meta);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* no other list transitions */</span>
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (page_meta-&gt;free_count == 0) {
			<span class="enscript-comment">/* remove from intermediate or free, move to all_used */</span>
			remqueue((queue_entry_t)page_meta);
			enqueue_tail(&amp;zone-&gt;pages.all_used, (queue_entry_t)page_meta);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (page_meta-&gt;alloc_count == page_meta-&gt;free_count + 1) {
			<span class="enscript-comment">/* remove from free, move to intermediate */</span>
			remqueue((queue_entry_t)page_meta);
			enqueue_tail(&amp;zone-&gt;pages.intermediate, (queue_entry_t)page_meta);
		}
	} <span class="enscript-keyword">else</span> {
		zone-&gt;free_elements = (<span class="enscript-type">struct</span> zone_free_element *)next_element;
	}
	zone-&gt;countfree--;
	zone-&gt;count++;
	zone-&gt;sum_count++;

	<span class="enscript-keyword">return</span> element;
}


<span class="enscript-comment">/*
 * End of zone poisoning
 */</span>

<span class="enscript-comment">/*
 * Fake zones for things that want to report via zprint but are not actually zones.
 */</span>
<span class="enscript-type">struct</span> fake_zone_info {
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>* name;
	<span class="enscript-type">void</span> (*init)(<span class="enscript-type">int</span>);
	<span class="enscript-type">void</span> (*query)(<span class="enscript-type">int</span> *,
		     vm_size_t *, vm_size_t *, vm_size_t *, vm_size_t *,
		      uint64_t *, <span class="enscript-type">int</span> *, <span class="enscript-type">int</span> *, <span class="enscript-type">int</span> *);
};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> fake_zone_info fake_zones[] = {
};
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_fake_zones =
	<span class="enscript-keyword">sizeof</span> (fake_zones) / <span class="enscript-keyword">sizeof</span> (fake_zones[0]);

<span class="enscript-comment">/*
 * Zone info options
 */</span>
boolean_t zinfo_per_task = FALSE;		<span class="enscript-comment">/* enabled by -zinfop in boot-args */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZINFO_SLOTS</span> 200				<span class="enscript-comment">/* for now */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZONES_MAX</span> (ZINFO_SLOTS - num_fake_zones - 1)

<span class="enscript-comment">/*
 * Support for garbage collection of unused zone pages
 *
 * The kernel virtually allocates the &quot;zone map&quot; submap of the kernel
 * map. When an individual zone needs more storage, memory is allocated
 * out of the zone map, and the two-level &quot;zone_page_table&quot; is
 * on-demand expanded so that it has entries for those pages.
 * zone_page_init()/zone_page_alloc() initialize &quot;alloc_count&quot;
 * to the number of zone elements that occupy the zone page (which may
 * be a minimum of 1, including if a zone element spans multiple
 * pages).
 *
 * Asynchronously, the zone_gc() logic attempts to walk zone free
 * lists to see if all the elements on a zone page are free. If
 * &quot;collect_count&quot; (which it increments during the scan) matches
 * &quot;alloc_count&quot;, the zone page is a candidate for collection and the
 * physical page is returned to the VM system. During this process, the
 * first word of the zone page is re-used to maintain a linked list of
 * to-be-collected zone pages.
 */</span>
<span class="enscript-type">typedef</span> uint32_t zone_page_index_t;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZONE_PAGE_INDEX_INVALID</span> ((zone_page_index_t)0xFFFFFFFFU)

<span class="enscript-type">struct</span> zone_page_table_entry {
	<span class="enscript-type">volatile</span>	uint16_t	alloc_count;
	<span class="enscript-type">volatile</span>	uint16_t	collect_count;
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ZONE_PAGE_USED</span>  0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZONE_PAGE_UNUSED</span> 0xffff

<span class="enscript-comment">/* Forwards */</span>
<span class="enscript-type">void</span>		zone_page_init(
				vm_offset_t	addr,
				vm_size_t	size);

<span class="enscript-type">void</span>		zone_page_alloc(
				vm_offset_t	addr,
				vm_size_t	size);

<span class="enscript-type">void</span>		zone_page_free_element(
				zone_page_index_t	*free_page_head,
				zone_page_index_t	*free_page_tail,
				vm_offset_t	addr,
				vm_size_t	size);

<span class="enscript-type">void</span>		zone_page_collect(
				vm_offset_t	addr,
				vm_size_t	size);

boolean_t	zone_page_collectable(
				vm_offset_t	addr,
				vm_size_t	size);

<span class="enscript-type">void</span>		zone_page_keep(
				vm_offset_t	addr,
				vm_size_t	size);

<span class="enscript-type">void</span>		zone_display_zprint(<span class="enscript-type">void</span>);

zone_t		zone_find_largest(<span class="enscript-type">void</span>);

<span class="enscript-comment">/* 
 * Async allocation of zones 
 * This mechanism allows for bootstrapping an empty zone which is setup with 
 * non-blocking flags. The first call to zalloc_noblock() will kick off a thread_call
 * to zalloc_async. We perform a zalloc() (which may block) and then an immediate free. 
 * This will prime the zone for the next use.
 *
 * Currently the thread_callout function (zalloc_async) will loop through all zones
 * looking for any zone with async_pending set and do the work for it. 
 * 
 * NOTE: If the calling thread for zalloc_noblock is lower priority than thread_call,
 * then zalloc_noblock to an empty zone may succeed. 
 */</span>
<span class="enscript-type">void</span>		zalloc_async(
				thread_call_param_t	p0,  
				thread_call_param_t	p1);

<span class="enscript-type">static</span> thread_call_data_t call_async_alloc;

vm_map_t	zone_map = VM_MAP_NULL;

zone_t		zone_zone = ZONE_NULL;	<span class="enscript-comment">/* the zone containing other zones */</span>

zone_t		zinfo_zone = ZONE_NULL; <span class="enscript-comment">/* zone of per-task zone info */</span>

<span class="enscript-comment">/*
 *	The VM system gives us an initial chunk of memory.
 *	It has to be big enough to allocate the zone_zone
 *	all the way through the pmap zone.
 */</span>

vm_offset_t	zdata;
vm_size_t	zdata_size;
<span class="enscript-comment">/*
 * Align elements that use the zone page list to 32 byte boundaries.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZONE_ELEMENT_ALIGNMENT</span> 32

#<span class="enscript-reference">define</span> <span class="enscript-function-name">zone_wakeup</span>(zone) thread_wakeup((event_t)(zone))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">zone_sleep</span>(zone)				\
	(<span class="enscript-type">void</span>) lck_mtx_sleep(&amp;(zone)-&gt;lock, LCK_SLEEP_SPIN, (event_t)(zone), THREAD_UNINT);

<span class="enscript-comment">/*
 *	The zone_locks_grp allows for collecting lock statistics.
 *	All locks are associated to this group in zinit.
 *	Look at tools/lockstat for debugging lock contention.
 */</span>

lck_grp_t	zone_locks_grp;
lck_grp_attr_t	zone_locks_grp_attr;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">lock_zone_init</span>(zone)				\
MACRO_BEGIN						\
	lck_attr_setdefault(&amp;(zone)-&gt;lock_attr);			\
	lck_mtx_init_ext(&amp;(zone)-&gt;lock, &amp;(zone)-&gt;lock_ext,		\
	    &amp;zone_locks_grp, &amp;(zone)-&gt;lock_attr);			\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">lock_try_zone</span>(zone)	lck_mtx_try_lock_spin(&amp;zone-&gt;lock)

<span class="enscript-comment">/*
 *	Garbage collection map information
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZONE_PAGE_TABLE_FIRST_LEVEL_SIZE</span> (32)
<span class="enscript-type">struct</span> zone_page_table_entry * <span class="enscript-type">volatile</span> zone_page_table[ZONE_PAGE_TABLE_FIRST_LEVEL_SIZE];
vm_size_t			zone_page_table_used_size;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			zone_pages;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>                   zone_page_table_second_level_size;                      <span class="enscript-comment">/* power of 2 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>                   zone_page_table_second_level_shift_amount;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">zone_page_table_first_level_slot</span>(x)  ((x) &gt;&gt; zone_page_table_second_level_shift_amount)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">zone_page_table_second_level_slot</span>(x) ((x) &amp; (zone_page_table_second_level_size - 1))

<span class="enscript-type">void</span>   <span class="enscript-function-name">zone_page_table_expand</span>(zone_page_index_t pindex);
<span class="enscript-type">struct</span> zone_page_table_entry *<span class="enscript-function-name">zone_page_table_lookup</span>(zone_page_index_t pindex);

<span class="enscript-comment">/*
 *	Exclude more than one concurrent garbage collection
 */</span>
<span class="enscript-function-name">decl_lck_mtx_data</span>(, zone_gc_lock)

lck_attr_t      zone_gc_lck_attr;
lck_grp_t       zone_gc_lck_grp;
lck_grp_attr_t  zone_gc_lck_grp_attr;
lck_mtx_ext_t   zone_gc_lck_ext;

<span class="enscript-comment">/*
 *	Protects first_zone, last_zone, num_zones,
 *	and the next_zone field of zones.
 */</span>
<span class="enscript-function-name">decl_simple_lock_data</span>(,	all_zones_lock)
zone_t			first_zone;
zone_t			*last_zone;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		num_zones;

boolean_t zone_gc_allowed = TRUE;
boolean_t zone_gc_forced = FALSE;
boolean_t panic_include_zprint = FALSE;
boolean_t zone_gc_allowed_by_time_throttle = TRUE;

vm_offset_t panic_kext_memory_info = 0;
vm_size_t panic_kext_memory_size = 0;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZALLOC_DEBUG_ZONEGC</span>		0x00000001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZALLOC_DEBUG_ZCRAM</span>		0x00000002
uint32_t zalloc_debug = 0;

<span class="enscript-comment">/*
 * Zone leak debugging code
 *
 * When enabled, this code keeps a log to track allocations to a particular zone that have not
 * yet been freed.  Examining this log will reveal the source of a zone leak.  The log is allocated
 * only when logging is enabled, so there is no effect on the system when it's turned off.  Logging is
 * off by default.
 *
 * Enable the logging via the boot-args. Add the parameter &quot;zlog=&lt;zone&gt;&quot; to boot-args where &lt;zone&gt;
 * is the name of the zone you wish to log.  
 *
 * This code only tracks one zone, so you need to identify which one is leaking first.
 * Generally, you'll know you have a leak when you get a &quot;zalloc retry failed 3&quot; panic from the zone
 * garbage collector.  Note that the zone name printed in the panic message is not necessarily the one
 * containing the leak.  So do a zprint from gdb and locate the zone with the bloated size.  This
 * is most likely the problem zone, so set zlog in boot-args to this zone name, reboot and re-run the test.  The
 * next time it panics with this message, examine the log using the kgmacros zstack, findoldest and countpcs.
 * See the help in the kgmacros for usage info.
 *
 *
 * Zone corruption logging
 *
 * Logging can also be used to help identify the source of a zone corruption.  First, identify the zone
 * that is being corrupted, then add &quot;-zc zlog=&lt;zone name&gt;&quot; to the boot-args.  When -zc is used in conjunction
 * with zlog, it changes the logging style to track both allocations and frees to the zone.  So when the
 * corruption is detected, examining the log will show you the stack traces of the callers who last allocated
 * and freed any particular element in the zone.  Use the findelem kgmacro with the address of the element that's been
 * corrupted to examine its history.  This should lead to the source of the corruption.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> log_records;	<span class="enscript-comment">/* size of the log, expressed in number of records */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_ZONE_NAME</span>	32	<span class="enscript-comment">/* max length of a zone name we can take from the boot-args */</span>

<span class="enscript-type">static</span> <span class="enscript-type">char</span> zone_name_to_log[MAX_ZONE_NAME] = <span class="enscript-string">&quot;&quot;</span>;	<span class="enscript-comment">/* the zone name we're logging, if any */</span>

<span class="enscript-comment">/* Log allocations and frees to help debug a zone element corruption */</span>
boolean_t       corruption_debug_flag    = FALSE;    <span class="enscript-comment">/* enabled by &quot;-zc&quot; boot-arg */</span>

<span class="enscript-comment">/*
 * The number of records in the log is configurable via the zrecs parameter in boot-args.  Set this to 
 * the number of records you want in the log.  For example, &quot;zrecs=1000&quot; sets it to 1000 records.  Note
 * that the larger the size of the log, the slower the system will run due to linear searching in the log,
 * but one doesn't generally care about performance when tracking down a leak.  The log is capped at 8000
 * records since going much larger than this tends to make the system unresponsive and unbootable on small
 * memory configurations.  The default value is 4000 records.
 */</span>

#<span class="enscript-reference">if</span>	<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZRECORDS_MAX</span> 		128000		<span class="enscript-comment">/* Max records allowed in the log */</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZRECORDS_MAX</span> 		8000		<span class="enscript-comment">/* Max records allowed in the log */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZRECORDS_DEFAULT</span>	4000		<span class="enscript-comment">/* default records in log if zrecs is not specificed in boot-args */</span>

<span class="enscript-comment">/*
 * Each record in the log contains a pointer to the zone element it refers to,
 * and a small array to hold the pc's from the stack trace.  A
 * record is added to the log each time a zalloc() is done in the zone_of_interest.  For leak debugging,
 * the record is cleared when a zfree() is done.  For corruption debugging, the log tracks both allocs and frees.
 * If the log fills, old records are replaced as if it were a circular buffer.
 */</span>


<span class="enscript-comment">/*
 * Opcodes for the btlog operation field:
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZOP_ALLOC</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZOP_FREE</span>	0

<span class="enscript-comment">/*
 * The allocation log and all the related variables are protected by the zone lock for the zone_of_interest
 */</span>
<span class="enscript-type">static</span> btlog_t *zlog_btlog;		<span class="enscript-comment">/* the log itself, dynamically allocated when logging is enabled  */</span>
<span class="enscript-type">static</span> zone_t  zone_of_interest = NULL;		<span class="enscript-comment">/* the zone being watched; corresponds to zone_name_to_log */</span>

<span class="enscript-comment">/*
 * Decide if we want to log this zone by doing a string compare between a zone name and the name
 * of the zone to log. Return true if the strings are equal, false otherwise.  Because it's not
 * possible to include spaces in strings passed in via the boot-args, a period in the logname will
 * match a space in the zone name.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">log_this_zone</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *zonename, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *logname) 
{
	<span class="enscript-type">int</span> len;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *zc = zonename;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *lc = logname;

	<span class="enscript-comment">/*
	 * Compare the strings.  We bound the compare by MAX_ZONE_NAME.
	 */</span>

	<span class="enscript-keyword">for</span> (len = 1; len &lt;= MAX_ZONE_NAME; zc++, lc++, len++) {

		<span class="enscript-comment">/*
		 * If the current characters don't match, check for a space in
		 * in the zone name and a corresponding period in the log name.
		 * If that's not there, then the strings don't match.
		 */</span>

		<span class="enscript-keyword">if</span> (*zc != *lc &amp;&amp; !(*zc == <span class="enscript-string">' '</span> &amp;&amp; *lc == <span class="enscript-string">'.'</span>)) 
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * The strings are equal so far.  If we're at the end, then it's a match.
		 */</span>

		<span class="enscript-keyword">if</span> (*zc == <span class="enscript-string">'\0'</span>)
			<span class="enscript-keyword">return</span> TRUE;
	}

	<span class="enscript-keyword">return</span> FALSE;
}


<span class="enscript-comment">/*
 * Test if we want to log this zalloc/zfree event.  We log if this is the zone we're interested in and
 * the buffer for the records has been allocated.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DO_LOGGING</span>(z)		(zlog_btlog &amp;&amp; (z) == zone_of_interest)

<span class="enscript-type">extern</span> boolean_t kmem_alloc_ready;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Zone</span> <span class="enscript-variable-name">Leak</span> <span class="enscript-variable-name">Detection</span>

<span class="enscript-comment">/* 
 * The zone leak detector, abbreviated 'zleak', keeps track of a subset of the currently outstanding
 * allocations made by the zone allocator.  Every zleak_sample_factor allocations in each zone, we capture a
 * backtrace.  Every free, we examine the table and determine if the allocation was being tracked, 
 * and stop tracking it if it was being tracked.
 *
 * We track the allocations in the zallocations hash table, which stores the address that was returned from 
 * the zone allocator.  Each stored entry in the zallocations table points to an entry in the ztraces table, which
 * stores the backtrace associated with that allocation.  This provides uniquing for the relatively large
 * backtraces - we don't store them more than once.
 *
 * Data collection begins when the zone map is 50% full, and only occurs for zones that are taking up
 * a large amount of virtual space.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZLEAK_STATE_ENABLED</span>		0x01	<span class="enscript-comment">/* Zone leak monitoring should be turned on if zone_map fills up. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZLEAK_STATE_ACTIVE</span> 		0x02	<span class="enscript-comment">/* We are actively collecting traces. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZLEAK_STATE_ACTIVATING</span> 		0x04	<span class="enscript-comment">/* Some thread is doing setup; others should move along. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZLEAK_STATE_FAILED</span>		0x08	<span class="enscript-comment">/* Attempt to allocate tables failed.  We will not try again. */</span>
uint32_t	zleak_state = 0;		<span class="enscript-comment">/* State of collection, as above */</span>

boolean_t	panic_include_ztrace	= FALSE;  	<span class="enscript-comment">/* Enable zleak logging on panic */</span>
vm_size_t 	zleak_global_tracking_threshold;	<span class="enscript-comment">/* Size of zone map at which to start collecting data */</span>
vm_size_t 	zleak_per_zone_tracking_threshold;	<span class="enscript-comment">/* Size a zone will have before we will collect data on it */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 	zleak_sample_factor	= 1000;		<span class="enscript-comment">/* Allocations per sample attempt */</span>

<span class="enscript-comment">/*
 * Counters for allocation statistics.
 */</span> 

<span class="enscript-comment">/* Times two active records want to occupy the same spot */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> z_alloc_collisions = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> z_trace_collisions = 0;

<span class="enscript-comment">/* Times a new record lands on a spot previously occupied by a freed allocation */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> z_alloc_overwrites = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> z_trace_overwrites = 0;

<span class="enscript-comment">/* Times a new alloc or trace is put into the hash table */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> z_alloc_recorded	= 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> z_trace_recorded	= 0;

<span class="enscript-comment">/* Times zleak_log returned false due to not being able to acquire the lock */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> z_total_conflicts	= 0;


#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">struct</span> <span class="enscript-variable-name">zallocation</span>
<span class="enscript-comment">/*
 * Structure for keeping track of an allocation
 * An allocation bucket is in use if its element is not NULL
 */</span>
<span class="enscript-type">struct</span> zallocation {
	uintptr_t		za_element;		<span class="enscript-comment">/* the element that was zalloc'ed or zfree'ed, NULL if bucket unused */</span>
	vm_size_t		za_size;			<span class="enscript-comment">/* how much memory did this allocation take up? */</span>
	uint32_t		za_trace_index;	<span class="enscript-comment">/* index into ztraces for backtrace associated with allocation */</span>
	<span class="enscript-comment">/* TODO: #if this out */</span>
	uint32_t		za_hit_count;		<span class="enscript-comment">/* for determining effectiveness of hash function */</span>
};

<span class="enscript-comment">/* Size must be a power of two for the zhash to be able to just mask off bits instead of mod */</span>
uint32_t zleak_alloc_buckets = CONFIG_ZLEAK_ALLOCATION_MAP_NUM;
uint32_t zleak_trace_buckets = CONFIG_ZLEAK_TRACE_MAP_NUM;

vm_size_t zleak_max_zonemap_size;

<span class="enscript-comment">/* Hashmaps of allocations and their corresponding traces */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zallocation*	zallocations;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ztrace*		ztraces;

<span class="enscript-comment">/* not static so that panic can see this, see kern/debug.c */</span>
<span class="enscript-type">struct</span> ztrace*				top_ztrace;

<span class="enscript-comment">/* Lock to protect zallocations, ztraces, and top_ztrace from concurrent modification. */</span>
<span class="enscript-type">static</span> lck_spin_t			zleak_lock;
<span class="enscript-type">static</span> lck_attr_t			zleak_lock_attr;
<span class="enscript-type">static</span> lck_grp_t			zleak_lock_grp;
<span class="enscript-type">static</span> lck_grp_attr_t			zleak_lock_grp_attr;

<span class="enscript-comment">/*
 * Initializes the zone leak monitor.  Called from zone_init()
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">zleak_init</span>(vm_size_t max_zonemap_size) 
{
	<span class="enscript-type">char</span>			scratch_buf[16];
	boolean_t		zleak_enable_flag = FALSE;

	zleak_max_zonemap_size = max_zonemap_size;
	zleak_global_tracking_threshold = max_zonemap_size / 2;	
	zleak_per_zone_tracking_threshold = zleak_global_tracking_threshold / 8;

	<span class="enscript-comment">/* -zleakoff (flag to disable zone leak monitor) */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-zleakoff&quot;</span>, scratch_buf, <span class="enscript-keyword">sizeof</span>(scratch_buf))) {
		zleak_enable_flag = FALSE;
		printf(<span class="enscript-string">&quot;zone leak detection disabled\n&quot;</span>);
	} <span class="enscript-keyword">else</span> {
		zleak_enable_flag = TRUE;
		printf(<span class="enscript-string">&quot;zone leak detection enabled\n&quot;</span>);
	}
	
	<span class="enscript-comment">/* zfactor=XXXX (override how often to sample the zone allocator) */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;zfactor&quot;</span>, &amp;zleak_sample_factor, <span class="enscript-keyword">sizeof</span>(zleak_sample_factor))) {
		printf(<span class="enscript-string">&quot;Zone leak factor override: %u\n&quot;</span>, zleak_sample_factor);
	}

	<span class="enscript-comment">/* zleak-allocs=XXXX (override number of buckets in zallocations) */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;zleak-allocs&quot;</span>, &amp;zleak_alloc_buckets, <span class="enscript-keyword">sizeof</span>(zleak_alloc_buckets))) {
		printf(<span class="enscript-string">&quot;Zone leak alloc buckets override: %u\n&quot;</span>, zleak_alloc_buckets);
		<span class="enscript-comment">/* uses 'is power of 2' trick: (0x01000 &amp; 0x00FFF == 0) */</span>
		<span class="enscript-keyword">if</span> (zleak_alloc_buckets == 0 || (zleak_alloc_buckets &amp; (zleak_alloc_buckets-1))) {
			printf(<span class="enscript-string">&quot;Override isn't a power of two, bad things might happen!\n&quot;</span>);
		}
	}
	
	<span class="enscript-comment">/* zleak-traces=XXXX (override number of buckets in ztraces) */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;zleak-traces&quot;</span>, &amp;zleak_trace_buckets, <span class="enscript-keyword">sizeof</span>(zleak_trace_buckets))) {
		printf(<span class="enscript-string">&quot;Zone leak trace buckets override: %u\n&quot;</span>, zleak_trace_buckets);
		<span class="enscript-comment">/* uses 'is power of 2' trick: (0x01000 &amp; 0x00FFF == 0) */</span>
		<span class="enscript-keyword">if</span> (zleak_trace_buckets == 0 || (zleak_trace_buckets &amp; (zleak_trace_buckets-1))) {
			printf(<span class="enscript-string">&quot;Override isn't a power of two, bad things might happen!\n&quot;</span>);
		}
	}
	
	<span class="enscript-comment">/* allocate the zleak_lock */</span>
	lck_grp_attr_setdefault(&amp;zleak_lock_grp_attr);
	lck_grp_init(&amp;zleak_lock_grp, <span class="enscript-string">&quot;zleak_lock&quot;</span>, &amp;zleak_lock_grp_attr);
	lck_attr_setdefault(&amp;zleak_lock_attr);
	lck_spin_init(&amp;zleak_lock, &amp;zleak_lock_grp, &amp;zleak_lock_attr);
	
	<span class="enscript-keyword">if</span> (zleak_enable_flag) {
		zleak_state = ZLEAK_STATE_ENABLED;
	}
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>

<span class="enscript-comment">/*
 * Support for kern.zleak.active sysctl - a simplified
 * version of the zleak_state variable.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">get_zleak_state</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (zleak_state &amp; ZLEAK_STATE_FAILED)
		<span class="enscript-keyword">return</span> (-1);
	<span class="enscript-keyword">if</span> (zleak_state &amp; ZLEAK_STATE_ACTIVE)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">endif</span>


kern_return_t
<span class="enscript-function-name">zleak_activate</span>(<span class="enscript-type">void</span>)
{
	kern_return_t retval;
	vm_size_t z_alloc_size = zleak_alloc_buckets * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zallocation);
	vm_size_t z_trace_size = zleak_trace_buckets * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ztrace);
	<span class="enscript-type">void</span> *allocations_ptr = NULL;
	<span class="enscript-type">void</span> *traces_ptr = NULL;

	<span class="enscript-comment">/* Only one thread attempts to activate at a time */</span>
	<span class="enscript-keyword">if</span> (zleak_state &amp; (ZLEAK_STATE_ACTIVE | ZLEAK_STATE_ACTIVATING | ZLEAK_STATE_FAILED)) {
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	<span class="enscript-comment">/* Indicate that we're doing the setup */</span>
	lck_spin_lock(&amp;zleak_lock);
	<span class="enscript-keyword">if</span> (zleak_state &amp; (ZLEAK_STATE_ACTIVE | ZLEAK_STATE_ACTIVATING | ZLEAK_STATE_FAILED)) {
		lck_spin_unlock(&amp;zleak_lock);
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}

	zleak_state |= ZLEAK_STATE_ACTIVATING;
	lck_spin_unlock(&amp;zleak_lock);

	<span class="enscript-comment">/* Allocate and zero tables */</span>
	retval = kmem_alloc_kobject(kernel_map, (vm_offset_t*)&amp;allocations_ptr, z_alloc_size, VM_KERN_MEMORY_OSFMK);
	<span class="enscript-keyword">if</span> (retval != KERN_SUCCESS) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	retval = kmem_alloc_kobject(kernel_map, (vm_offset_t*)&amp;traces_ptr, z_trace_size, VM_KERN_MEMORY_OSFMK);
	<span class="enscript-keyword">if</span> (retval != KERN_SUCCESS) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	bzero(allocations_ptr, z_alloc_size);
	bzero(traces_ptr, z_trace_size);

	<span class="enscript-comment">/* Everything's set.  Install tables, mark active. */</span>
	zallocations = allocations_ptr;
	ztraces = traces_ptr;

	<span class="enscript-comment">/*
	 * Initialize the top_ztrace to the first entry in ztraces, 
	 * so we don't have to check for null in zleak_log
	 */</span>
	top_ztrace = &amp;ztraces[0];

	<span class="enscript-comment">/*
	 * Note that we do need a barrier between installing
	 * the tables and setting the active flag, because the zfree()
	 * path accesses the table without a lock if we're active.
	 */</span>
	lck_spin_lock(&amp;zleak_lock);
	zleak_state |= ZLEAK_STATE_ACTIVE;
	zleak_state &amp;= ~ZLEAK_STATE_ACTIVATING;
	lck_spin_unlock(&amp;zleak_lock);
	
	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">fail</span>:	
	<span class="enscript-comment">/*
	 * If we fail to allocate memory, don't further tax
	 * the system by trying again.
	 */</span>
	lck_spin_lock(&amp;zleak_lock);
	zleak_state |= ZLEAK_STATE_FAILED;
	zleak_state &amp;= ~ZLEAK_STATE_ACTIVATING;
	lck_spin_unlock(&amp;zleak_lock);

	<span class="enscript-keyword">if</span> (allocations_ptr != NULL) {
		kmem_free(kernel_map, (vm_offset_t)allocations_ptr, z_alloc_size);
	}

	<span class="enscript-keyword">if</span> (traces_ptr != NULL) {
		kmem_free(kernel_map, (vm_offset_t)traces_ptr, z_trace_size);
	}

	<span class="enscript-keyword">return</span> retval;
}

<span class="enscript-comment">/*
 * TODO: What about allocations that never get deallocated, 
 * especially ones with unique backtraces? Should we wait to record
 * until after boot has completed?  
 * (How many persistent zallocs are there?)
 */</span>

<span class="enscript-comment">/*
 * This function records the allocation in the allocations table, 
 * and stores the associated backtrace in the traces table 
 * (or just increments the refcount if the trace is already recorded)
 * If the allocation slot is in use, the old allocation is replaced with the new allocation, and
 * the associated trace's refcount is decremented.
 * If the trace slot is in use, it returns.
 * The refcount is incremented by the amount of memory the allocation consumes.
 * The return value indicates whether to try again next time.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">zleak_log</span>(uintptr_t* bt,
		  uintptr_t addr,
		  uint32_t depth,
		  vm_size_t allocation_size) 
{
	<span class="enscript-comment">/* Quit if there's someone else modifying the hash tables */</span>
	<span class="enscript-keyword">if</span> (!lck_spin_try_lock(&amp;zleak_lock)) {
		z_total_conflicts++;
		<span class="enscript-keyword">return</span> FALSE;
	}
	
	<span class="enscript-type">struct</span> zallocation* allocation	= &amp;zallocations[hashaddr(addr, zleak_alloc_buckets)];
	
	uint32_t trace_index = hashbacktrace(bt, depth, zleak_trace_buckets);
	<span class="enscript-type">struct</span> ztrace* trace = &amp;ztraces[trace_index];
	
	allocation-&gt;za_hit_count++;
	trace-&gt;zt_hit_count++;
	
	<span class="enscript-comment">/* 
	 * If the allocation bucket we want to be in is occupied, and if the occupier
	 * has the same trace as us, just bail.  
	 */</span>
	<span class="enscript-keyword">if</span> (allocation-&gt;za_element != (uintptr_t) 0 &amp;&amp; trace_index == allocation-&gt;za_trace_index) {
		z_alloc_collisions++;
		
		lck_spin_unlock(&amp;zleak_lock);
		<span class="enscript-keyword">return</span> TRUE;
	}
	
	<span class="enscript-comment">/* STEP 1: Store the backtrace in the traces array. */</span>
	<span class="enscript-comment">/* A size of zero indicates that the trace bucket is free. */</span>
	
	<span class="enscript-keyword">if</span> (trace-&gt;zt_size &gt; 0 &amp;&amp; bcmp(trace-&gt;zt_stack, bt, (depth * <span class="enscript-keyword">sizeof</span>(uintptr_t))) != 0 ) {
		<span class="enscript-comment">/* 
		 * Different unique trace with same hash!
		 * Just bail - if we're trying to record the leaker, hopefully the other trace will be deallocated
		 * and get out of the way for later chances
		 */</span>
		trace-&gt;zt_collisions++;
		z_trace_collisions++;
		
		lck_spin_unlock(&amp;zleak_lock);
		<span class="enscript-keyword">return</span> TRUE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (trace-&gt;zt_size &gt; 0) {
		<span class="enscript-comment">/* Same trace, already added, so increment refcount */</span>
		trace-&gt;zt_size += allocation_size;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Found an unused trace bucket, record the trace here! */</span>
		<span class="enscript-keyword">if</span> (trace-&gt;zt_depth != 0) <span class="enscript-comment">/* if this slot was previously used but not currently in use */</span>
			z_trace_overwrites++;
		
		z_trace_recorded++;
		trace-&gt;zt_size			= allocation_size;
		memcpy(trace-&gt;zt_stack, bt, (depth * <span class="enscript-keyword">sizeof</span>(uintptr_t)) );
		
		trace-&gt;zt_depth		= depth;
		trace-&gt;zt_collisions	= 0;
	}
	
	<span class="enscript-comment">/* STEP 2: Store the allocation record in the allocations array. */</span>
	
	<span class="enscript-keyword">if</span> (allocation-&gt;za_element != (uintptr_t) 0) {
		<span class="enscript-comment">/* 
		 * Straight up replace any allocation record that was there.  We don't want to do the work
		 * to preserve the allocation entries that were there, because we only record a subset of the 
		 * allocations anyways.
		 */</span>
		
		z_alloc_collisions++;
		
		<span class="enscript-type">struct</span> ztrace* associated_trace = &amp;ztraces[allocation-&gt;za_trace_index];
		<span class="enscript-comment">/* Knock off old allocation's size, not the new allocation */</span>
		associated_trace-&gt;zt_size -= allocation-&gt;za_size;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (allocation-&gt;za_trace_index != 0) {
		<span class="enscript-comment">/* Slot previously used but not currently in use */</span>
		z_alloc_overwrites++;
	}

	allocation-&gt;za_element		= addr;
	allocation-&gt;za_trace_index	= trace_index;
	allocation-&gt;za_size		= allocation_size;
	
	z_alloc_recorded++;
	
	<span class="enscript-keyword">if</span> (top_ztrace-&gt;zt_size &lt; trace-&gt;zt_size)
		top_ztrace = trace;
	
	lck_spin_unlock(&amp;zleak_lock);
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * Free the allocation record and release the stacktrace.
 * This should be as fast as possible because it will be called for every free.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">zleak_free</span>(uintptr_t addr,
		   vm_size_t allocation_size) 
{
	<span class="enscript-keyword">if</span> (addr == (uintptr_t) 0)
		<span class="enscript-keyword">return</span>;
	
	<span class="enscript-type">struct</span> zallocation* allocation = &amp;zallocations[hashaddr(addr, zleak_alloc_buckets)];
	
	<span class="enscript-comment">/* Double-checked locking: check to find out if we're interested, lock, check to make
	 * sure it hasn't changed, then modify it, and release the lock.
	 */</span>
	
	<span class="enscript-keyword">if</span> (allocation-&gt;za_element == addr &amp;&amp; allocation-&gt;za_trace_index &lt; zleak_trace_buckets) {
		<span class="enscript-comment">/* if the allocation was the one, grab the lock, check again, then delete it */</span>
		lck_spin_lock(&amp;zleak_lock);
		
		<span class="enscript-keyword">if</span> (allocation-&gt;za_element == addr &amp;&amp; allocation-&gt;za_trace_index &lt; zleak_trace_buckets) {
			<span class="enscript-type">struct</span> ztrace *trace;

			<span class="enscript-comment">/* allocation_size had better match what was passed into zleak_log - otherwise someone is freeing into the wrong zone! */</span>
			<span class="enscript-keyword">if</span> (allocation-&gt;za_size != allocation_size) {
				panic(<span class="enscript-string">&quot;Freeing as size %lu memory that was allocated with size %lu\n&quot;</span>, 
						(uintptr_t)allocation_size, (uintptr_t)allocation-&gt;za_size);
			}
			
			trace = &amp;ztraces[allocation-&gt;za_trace_index];
			
			<span class="enscript-comment">/* size of 0 indicates trace bucket is unused */</span>
			<span class="enscript-keyword">if</span> (trace-&gt;zt_size &gt; 0) {
				trace-&gt;zt_size -= allocation_size;
			}
			
			<span class="enscript-comment">/* A NULL element means the allocation bucket is unused */</span>
			allocation-&gt;za_element = 0;
		}
		lck_spin_unlock(&amp;zleak_lock);
	}
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>

<span class="enscript-comment">/*  These functions outside of CONFIG_ZLEAKS because they are also used in
 *  mbuf.c for mbuf leak-detection.  This is why they lack the z_ prefix.
 */</span>

<span class="enscript-comment">/*
 * This function captures a backtrace from the current stack and
 * returns the number of frames captured, limited by max_frames.
 * It's fast because it does no checking to make sure there isn't bad data.
 * Since it's only called from threads that we're going to keep executing,
 * if there's bad data we were going to die eventually.
 * If this function is inlined, it doesn't record the frame of the function it's inside.
 * (because there's no stack frame!)
 */</span>

uint32_t
<span class="enscript-function-name">fastbacktrace</span>(uintptr_t* bt, uint32_t max_frames)
{
	uintptr_t* frameptr = NULL, *frameptr_next = NULL;
	uintptr_t retaddr = 0;
	uint32_t frame_index = 0, frames = 0;
	uintptr_t kstackb, kstackt;
	thread_t cthread = current_thread();

	<span class="enscript-keyword">if</span> (__improbable(cthread == NULL))
		<span class="enscript-keyword">return</span> 0;

	kstackb = cthread-&gt;kernel_stack;
	kstackt = kstackb + kernel_stack_size;
	<span class="enscript-comment">/* Load stack frame pointer (EBP on x86) into frameptr */</span>
	frameptr = __builtin_frame_address(0);
	<span class="enscript-keyword">if</span> (((uintptr_t)frameptr &gt; kstackt) || ((uintptr_t)frameptr &lt; kstackb))
		frameptr = NULL;

	<span class="enscript-keyword">while</span> (frameptr != NULL &amp;&amp; frame_index &lt; max_frames ) {
		<span class="enscript-comment">/* Next frame pointer is pointed to by the previous one */</span>
		frameptr_next = (uintptr_t*) *frameptr;

		<span class="enscript-comment">/* Bail if we see a zero in the stack frame, that means we've reached the top of the stack */</span>
                <span class="enscript-comment">/* That also means the return address is worthless, so don't record it */</span>
		<span class="enscript-keyword">if</span> (frameptr_next == NULL)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* Verify thread stack bounds */</span>
		<span class="enscript-keyword">if</span> (((uintptr_t)frameptr_next &gt; kstackt) || ((uintptr_t)frameptr_next &lt; kstackb))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* Pull return address from one spot above the frame pointer */</span>
		retaddr = *(frameptr + 1);

		<span class="enscript-comment">/* Store it in the backtrace array */</span>
		bt[frame_index++] = retaddr;

		frameptr = frameptr_next;
	}

	<span class="enscript-comment">/* Save the number of frames captured for return value */</span>
	frames = frame_index;

	<span class="enscript-comment">/* Fill in the rest of the backtrace with zeros */</span>
	<span class="enscript-keyword">while</span> (frame_index &lt; max_frames)
		bt[frame_index++] = 0;

	<span class="enscript-keyword">return</span> frames;
}

<span class="enscript-comment">/* &quot;Thomas Wang's 32/64 bit mix functions.&quot;  <a href="http://www.concentric.net/~Ttwang/tech/inthash.htm">http://www.concentric.net/~Ttwang/tech/inthash.htm</a> */</span>
uintptr_t
<span class="enscript-function-name">hash_mix</span>(uintptr_t x)
{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
	x += ~(x &lt;&lt; 15);
	x ^=  (x &gt;&gt; 10);
	x +=  (x &lt;&lt; 3 );
	x ^=  (x &gt;&gt; 6 );
	x += ~(x &lt;&lt; 11);
	x ^=  (x &gt;&gt; 16);
#<span class="enscript-reference">else</span>
	x += ~(x &lt;&lt; 32);
	x ^=  (x &gt;&gt; 22);
	x += ~(x &lt;&lt; 13);
	x ^=  (x &gt;&gt; 8 );
	x +=  (x &lt;&lt; 3 );
	x ^=  (x &gt;&gt; 15);
	x += ~(x &lt;&lt; 27);
	x ^=  (x &gt;&gt; 31);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> x;
}

uint32_t
<span class="enscript-function-name">hashbacktrace</span>(uintptr_t* bt, uint32_t depth, uint32_t max_size)
{

	uintptr_t hash = 0;
	uintptr_t mask = max_size - 1;

	<span class="enscript-keyword">while</span> (depth) {
		hash += bt[--depth];
	}

	hash = hash_mix(hash) &amp; mask;

	assert(hash &lt; max_size);

	<span class="enscript-keyword">return</span> (uint32_t) hash;
}

<span class="enscript-comment">/*
 *  TODO: Determine how well distributed this is
 *      max_size must be a power of 2. i.e 0x10000 because 0x10000-1 is 0x0FFFF which is a great bitmask
 */</span>
uint32_t
<span class="enscript-function-name">hashaddr</span>(uintptr_t pt, uint32_t max_size)
{
	uintptr_t hash = 0;
	uintptr_t mask = max_size - 1;

	hash = hash_mix(pt) &amp; mask;

	assert(hash &lt; max_size);

	<span class="enscript-keyword">return</span> (uint32_t) hash;
}

<span class="enscript-comment">/* End of all leak-detection code */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -

<span class="enscript-comment">/*
 *	zinit initializes a new zone.  The zone data structures themselves
 *	are stored in a zone, which is initially a static structure that
 *	is initialized by zone_init.
 */</span>
zone_t
<span class="enscript-function-name">zinit</span>(
	vm_size_t	size,		<span class="enscript-comment">/* the size of an element */</span>
	vm_size_t	max,		<span class="enscript-comment">/* maximum memory to use */</span>
	vm_size_t	alloc,		<span class="enscript-comment">/* allocation size */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*name)		<span class="enscript-comment">/* a name for the zone */</span>
{
	zone_t		z;
	boolean_t	use_page_list = FALSE;

	<span class="enscript-keyword">if</span> (zone_zone == ZONE_NULL) {

		z = (<span class="enscript-type">struct</span> zone *)zdata;
		<span class="enscript-comment">/* special handling in zcram() because the first element is being used */</span>
	} <span class="enscript-keyword">else</span>
		z = (zone_t) zalloc(zone_zone);

	<span class="enscript-keyword">if</span> (z == ZONE_NULL)
		<span class="enscript-keyword">return</span>(ZONE_NULL);

	<span class="enscript-comment">/* Zone elements must fit both a next pointer and a backup pointer */</span>
	vm_size_t  minimum_element_size = <span class="enscript-keyword">sizeof</span>(vm_offset_t) * 2;
	<span class="enscript-keyword">if</span> (size &lt; minimum_element_size)
		size = minimum_element_size;

	<span class="enscript-comment">/*
	 *  Round element size to a multiple of sizeof(pointer)
	 *  This also enforces that allocations will be aligned on pointer boundaries
	 */</span>
	size = ((size-1) + <span class="enscript-keyword">sizeof</span>(vm_offset_t)) -
	       ((size-1) % <span class="enscript-keyword">sizeof</span>(vm_offset_t));

	<span class="enscript-keyword">if</span> (alloc == 0)
		alloc = PAGE_SIZE;

	alloc = round_page(alloc);
	max   = round_page(max);

	<span class="enscript-comment">/*
	 * we look for an allocation size with less than 1% waste
	 * up to 5 pages in size...
	 * otherwise, we look for an allocation size with least fragmentation
	 * in the range of 1 - 5 pages
	 * This size will be used unless
	 * the user suggestion is larger AND has less fragmentation
	 */</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
	<span class="enscript-comment">/* Favor PAGE_SIZE allocations unless we waste &gt;10% space */</span>
	<span class="enscript-keyword">if</span> ((size &lt; PAGE_SIZE) &amp;&amp; (PAGE_SIZE % size &lt;= PAGE_SIZE / 10))
		alloc = PAGE_SIZE;
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span>	<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)		
		<span class="enscript-keyword">if</span> (((alloc % size) != 0) || (alloc &gt; PAGE_SIZE * 8))
#<span class="enscript-reference">endif</span>
		{
		vm_size_t best, waste; <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
		best  = PAGE_SIZE;
		waste = best % size;

		<span class="enscript-keyword">for</span> (i = 1; i &lt;= 5; i++) {
			vm_size_t tsize, twaste;

			tsize = i * PAGE_SIZE;

			<span class="enscript-keyword">if</span> ((tsize % size) &lt; (tsize / 100)) {
			        alloc = tsize;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">use_this_allocation</span>;
			}
			twaste = tsize % size;
			<span class="enscript-keyword">if</span> (twaste &lt; waste)
				best = tsize, waste = twaste;
		}
		<span class="enscript-keyword">if</span> (alloc &lt;= best || (alloc % size &gt;= waste))
			alloc = best;
	}
<span class="enscript-reference">use_this_allocation</span>:
	<span class="enscript-keyword">if</span> (max &amp;&amp; (max &lt; alloc))
		max = alloc;

	<span class="enscript-comment">/*
	 * Opt into page list tracking if we can reliably map an allocation
	 * to its page_metadata, and if the wastage in the tail of
	 * the allocation is not too large
	 */</span>

	<span class="enscript-comment">/* zone_zone can't use page metadata since the page metadata will overwrite zone metadata */</span>
	<span class="enscript-keyword">if</span> (alloc == PAGE_SIZE &amp;&amp; zone_zone != ZONE_NULL) {
		vm_offset_t first_element_offset;
		size_t zone_page_metadata_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zone_page_metadata);

		<span class="enscript-keyword">if</span> (zone_page_metadata_size % ZONE_ELEMENT_ALIGNMENT == 0) {
			first_element_offset = zone_page_metadata_size;
		} <span class="enscript-keyword">else</span> {
			first_element_offset = zone_page_metadata_size + (ZONE_ELEMENT_ALIGNMENT - (zone_page_metadata_size % ZONE_ELEMENT_ALIGNMENT));
		}

		<span class="enscript-keyword">if</span> (((PAGE_SIZE - first_element_offset) % size) &lt;= PAGE_SIZE / 100) {
			use_page_list = TRUE;
		}
	}

	z-&gt;free_elements = NULL;
	queue_init(&amp;z-&gt;pages.any_free_foreign);
	queue_init(&amp;z-&gt;pages.all_free);
	queue_init(&amp;z-&gt;pages.intermediate);
	queue_init(&amp;z-&gt;pages.all_used);
	z-&gt;cur_size = 0;
	z-&gt;page_count = 0;
	z-&gt;max_size = max;
	z-&gt;elem_size = size;
	z-&gt;alloc_size = alloc;
	z-&gt;zone_name = name;
	z-&gt;count = 0;
	z-&gt;countfree = 0;
	z-&gt;sum_count = 0LL;
	z-&gt;doing_alloc_without_vm_priv = FALSE;
	z-&gt;doing_alloc_with_vm_priv = FALSE;
	z-&gt;doing_gc = FALSE;
	z-&gt;exhaustible = FALSE;
	z-&gt;collectable = TRUE;
	z-&gt;allows_foreign = FALSE;
	z-&gt;expandable  = TRUE;
	z-&gt;waiting = FALSE;
	z-&gt;async_pending = FALSE;
	z-&gt;caller_acct = TRUE;
	z-&gt;noencrypt = FALSE;
	z-&gt;no_callout = FALSE;
	z-&gt;async_prio_refill = FALSE;
	z-&gt;gzalloc_exempt = FALSE;
	z-&gt;alignment_required = FALSE;
	z-&gt;use_page_list = use_page_list;
	z-&gt;prio_refill_watermark = 0;
	z-&gt;zone_replenish_thread = NULL;
	z-&gt;zp_count = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
	z-&gt;zleak_capture = 0;
	z-&gt;zleak_on = FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_DEBUG</span>
	z-&gt;active_zones.next = z-&gt;active_zones.prev = NULL;	
	zone_debug_enable(z);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* ZONE_DEBUG */</span>
	lock_zone_init(z);

	<span class="enscript-comment">/*
	 *	Add the zone to the all-zones list.
	 *	If we are tracking zone info per task, and we have
	 *	already used all the available stat slots, then keep
	 *	using the overflow zone slot.
	 */</span>
	z-&gt;next_zone = ZONE_NULL;
	simple_lock(&amp;all_zones_lock);
	*last_zone = z;
	last_zone = &amp;z-&gt;next_zone;
	z-&gt;index = num_zones;
	<span class="enscript-keyword">if</span> (zinfo_per_task) {
		<span class="enscript-keyword">if</span> (num_zones &gt; ZONES_MAX)
			z-&gt;index = ZONES_MAX;
	}
	num_zones++;
	simple_unlock(&amp;all_zones_lock);

	<span class="enscript-comment">/*
	 * Check if we should be logging this zone.  If so, remember the zone pointer.
	 */</span>
	<span class="enscript-keyword">if</span> (log_this_zone(z-&gt;zone_name, zone_name_to_log)) {
	 	zone_of_interest = z;
	}

	<span class="enscript-comment">/*
	 * If we want to log a zone, see if we need to allocate buffer space for the log.  Some vm related zones are
	 * zinit'ed before we can do a kmem_alloc, so we have to defer allocation in that case.  kmem_alloc_ready is set to
	 * TRUE once enough of the VM system is up and running to allow a kmem_alloc to work.  If we want to log one
	 * of the VM related zones that's set up early on, we will skip allocation of the log until zinit is called again
	 * later on some other zone.  So note we may be allocating a buffer to log a zone other than the one being initialized
	 * right now.
	 */</span>
	<span class="enscript-keyword">if</span> (zone_of_interest != NULL &amp;&amp; zlog_btlog == NULL &amp;&amp; kmem_alloc_ready) {
		zlog_btlog = btlog_create(log_records, MAX_ZTRACE_DEPTH, NULL, NULL, NULL);
		<span class="enscript-keyword">if</span> (zlog_btlog) {
			printf(<span class="enscript-string">&quot;zone: logging started for zone %s\n&quot;</span>, zone_of_interest-&gt;zone_name);
		} <span class="enscript-keyword">else</span> {
			printf(<span class="enscript-string">&quot;zone: couldn't allocate memory for zrecords, turning off zleak logging\n&quot;</span>);
			zone_of_interest = NULL;
		}
	}
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_GZALLOC</span>	
	gzalloc_zone_init(z);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span>(z);
}
<span class="enscript-type">unsigned</span>	zone_replenish_loops, zone_replenish_wakeups, zone_replenish_wakeups_initiated, zone_replenish_throttle_count;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">zone_replenish_thread</span>(zone_t);

<span class="enscript-comment">/* High priority VM privileged thread used to asynchronously refill a designated
 * zone, such as the reserved VM map entry zone.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">zone_replenish_thread</span>(zone_t z) {
	vm_size_t free_size;
	current_thread()-&gt;options |= TH_OPT_VMPRIV;

	<span class="enscript-keyword">for</span> (;;) {
		lock_zone(z);
		assert(z-&gt;prio_refill_watermark != 0);
		<span class="enscript-keyword">while</span> ((free_size = (z-&gt;cur_size - (z-&gt;count * z-&gt;elem_size))) &lt; (z-&gt;prio_refill_watermark * z-&gt;elem_size)) {
			assert(z-&gt;doing_alloc_without_vm_priv == FALSE);
			assert(z-&gt;doing_alloc_with_vm_priv == FALSE);
			assert(z-&gt;async_prio_refill == TRUE);

			unlock_zone(z);
			<span class="enscript-type">int</span>	zflags = KMA_KOBJECT|KMA_NOPAGEWAIT;
			vm_offset_t space, alloc_size;
			kern_return_t kr;
				
			<span class="enscript-keyword">if</span> (vm_pool_low())
				alloc_size = round_page(z-&gt;elem_size);
			<span class="enscript-keyword">else</span>
				alloc_size = z-&gt;alloc_size;
				
			<span class="enscript-keyword">if</span> (z-&gt;noencrypt)
				zflags |= KMA_NOENCRYPT;
				
			kr = kernel_memory_allocate(zone_map, &amp;space, alloc_size, 0, zflags, VM_KERN_MEMORY_ZONE);

			<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
				<span class="enscript-keyword">if</span> (alloc_size == PAGE_SIZE)
					space = zone_alias_addr(space);
#<span class="enscript-reference">endif</span>
				zcram(z, space, alloc_size);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kr == KERN_RESOURCE_SHORTAGE) {
				VM_PAGE_WAIT();
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kr == KERN_NO_SPACE) {
				kr = kernel_memory_allocate(kernel_map, &amp;space, alloc_size, 0, zflags, VM_KERN_MEMORY_ZONE);
				<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
					<span class="enscript-keyword">if</span> (alloc_size == PAGE_SIZE)
						space = zone_alias_addr(space);
#<span class="enscript-reference">endif</span>
					zcram(z, space, alloc_size);
				} <span class="enscript-keyword">else</span> {
					assert_wait_timeout(&amp;z-&gt;zone_replenish_thread, THREAD_UNINT, 1, 100 * NSEC_PER_USEC);
					thread_block(THREAD_CONTINUE_NULL);
				}
			}

			lock_zone(z);
			zone_replenish_loops++;
		}

		unlock_zone(z);
		<span class="enscript-comment">/* Signal any potential throttled consumers, terminating
		 * their timer-bounded waits.
		 */</span>
		thread_wakeup(z);

		assert_wait(&amp;z-&gt;zone_replenish_thread, THREAD_UNINT);
		thread_block(THREAD_CONTINUE_NULL);
		zone_replenish_wakeups++;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_prio_refill_configure</span>(zone_t z, vm_size_t low_water_mark) {
	z-&gt;prio_refill_watermark = low_water_mark;

	z-&gt;async_prio_refill = TRUE;
	OSMemoryBarrier();
	kern_return_t tres = kernel_thread_start_priority((thread_continue_t)zone_replenish_thread, z, MAXPRI_KERNEL, &amp;z-&gt;zone_replenish_thread);

	<span class="enscript-keyword">if</span> (tres != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;zone_prio_refill_configure, thread create: 0x%x&quot;</span>, tres);
	}

	thread_deallocate(z-&gt;zone_replenish_thread);
}

<span class="enscript-comment">/*
 *	Cram the given memory into the specified zone. Update the zone page count accordingly.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">zcram</span>(
	zone_t		zone,
	vm_offset_t			newmem,
	vm_size_t		size)
{
	vm_size_t	elem_size;
	boolean_t   from_zm = FALSE;

	<span class="enscript-comment">/* Basic sanity checks */</span>
	assert(zone != ZONE_NULL &amp;&amp; newmem != (vm_offset_t)0);
	assert(!zone-&gt;collectable || zone-&gt;allows_foreign
		|| (from_zone_map(newmem, size)));

	elem_size = zone-&gt;elem_size;

	<span class="enscript-keyword">if</span> (from_zone_map(newmem, size))
		from_zm = TRUE;

	<span class="enscript-keyword">if</span> (zalloc_debug &amp; ZALLOC_DEBUG_ZCRAM)
		kprintf(<span class="enscript-string">&quot;zcram(%p[%s], 0x%lx%s, 0x%lx)\n&quot;</span>, zone, zone-&gt;zone_name,
				(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)newmem, from_zm ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;[F]&quot;</span>, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)size);

	<span class="enscript-keyword">if</span> (from_zm &amp;&amp; !zone-&gt;use_page_list)
		zone_page_init(newmem, size);

	ZONE_PAGE_COUNT_INCR(zone, (size / PAGE_SIZE));

	lock_zone(zone);

	<span class="enscript-keyword">if</span> (zone-&gt;use_page_list) {
		<span class="enscript-type">struct</span> zone_page_metadata *page_metadata;
		size_t zone_page_metadata_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zone_page_metadata);

		assert((newmem &amp; PAGE_MASK) == 0);
		assert((size &amp; PAGE_MASK) == 0);
		<span class="enscript-keyword">for</span> (; size &gt; 0; newmem += PAGE_SIZE, size -= PAGE_SIZE) {

			vm_size_t pos_in_page;
			page_metadata = (<span class="enscript-type">struct</span> zone_page_metadata *)(newmem);
			
			page_metadata-&gt;pages.next = NULL;
			page_metadata-&gt;pages.prev = NULL;
			page_metadata-&gt;elements = NULL;
			page_metadata-&gt;zone = zone;
			page_metadata-&gt;alloc_count = 0;
			page_metadata-&gt;free_count = 0;

			enqueue_tail(&amp;zone-&gt;pages.all_used, (queue_entry_t)page_metadata);

			vm_offset_t first_element_offset;
			<span class="enscript-keyword">if</span> (zone_page_metadata_size % ZONE_ELEMENT_ALIGNMENT == 0){
				first_element_offset = zone_page_metadata_size;
			} <span class="enscript-keyword">else</span> {
				first_element_offset = zone_page_metadata_size + (ZONE_ELEMENT_ALIGNMENT - (zone_page_metadata_size % ZONE_ELEMENT_ALIGNMENT));
			}

			<span class="enscript-keyword">for</span> (pos_in_page = first_element_offset; (newmem + pos_in_page + elem_size) &lt; (vm_offset_t)(newmem + PAGE_SIZE); pos_in_page += elem_size) {
				page_metadata-&gt;alloc_count++;
				zone-&gt;count++;	<span class="enscript-comment">/* compensate for free_to_zone */</span>
				free_to_zone(zone, newmem + pos_in_page, FALSE);
				zone-&gt;cur_size += elem_size;
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">while</span> (size &gt;= elem_size) {
			zone-&gt;count++;	<span class="enscript-comment">/* compensate for free_to_zone */</span>
			<span class="enscript-keyword">if</span> (newmem == (vm_offset_t)zone) {
				<span class="enscript-comment">/* Don't free zone_zone zone */</span>
			} <span class="enscript-keyword">else</span> {
				free_to_zone(zone, newmem, FALSE);
			}
			<span class="enscript-keyword">if</span> (from_zm)
				zone_page_alloc(newmem, elem_size);
			size -= elem_size;
			newmem += elem_size;
			zone-&gt;cur_size += elem_size;
		}
	}
	unlock_zone(zone);
}


<span class="enscript-comment">/*
 *	Steal memory for the zone package.  Called from
 *	vm_page_bootstrap().
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_steal_memory</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_GZALLOC</span>
	gzalloc_configure();
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* Request enough early memory to get to the pmap zone */</span>
	zdata_size = 12 * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zone);
	zdata_size = round_page(zdata_size);
	zdata = (vm_offset_t)pmap_steal_memory(zdata_size);
}


<span class="enscript-comment">/*
 * Fill a zone with enough memory to contain at least nelem elements.
 * Memory is obtained with kmem_alloc_kobject from the kernel_map.
 * Return the number of elements actually put into the zone, which may
 * be more than the caller asked for since the memory allocation is
 * rounded up to a full page.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">zfill</span>(
	zone_t	zone,
	<span class="enscript-type">int</span>	nelem)
{
	kern_return_t	kr;
	vm_size_t	size;
	vm_offset_t	memory;
	<span class="enscript-type">int</span>		nalloc;

	assert(nelem &gt; 0);
	<span class="enscript-keyword">if</span> (nelem &lt;= 0)
		<span class="enscript-keyword">return</span> 0;
	size = nelem * zone-&gt;elem_size;
	size = round_page(size);
	kr = kmem_alloc_kobject(kernel_map, &amp;memory, size, VM_KERN_MEMORY_ZONE);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> 0;

	zone_change(zone, Z_FOREIGN, TRUE);
	zcram(zone, memory, size);
	nalloc = (<span class="enscript-type">int</span>)(size / zone-&gt;elem_size);
	assert(nalloc &gt;= nelem);

	<span class="enscript-keyword">return</span> nalloc;
}

<span class="enscript-comment">/*
 *	Initialize the &quot;zone of zones&quot; which uses fixed memory allocated
 *	earlier in memory initialization.  zone_bootstrap is called
 *	before zone_init.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_bootstrap</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">char</span> temp_buf[16];

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-zinfop&quot;</span>, temp_buf, <span class="enscript-keyword">sizeof</span>(temp_buf))) {
		zinfo_per_task = TRUE;
	}

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;zalloc_debug&quot;</span>, &amp;zalloc_debug, <span class="enscript-keyword">sizeof</span>(zalloc_debug)))
		zalloc_debug = 0;

	<span class="enscript-comment">/* Set up zone element poisoning */</span>
	zp_init();

	<span class="enscript-comment">/* should zlog log to debug zone corruption instead of leaks? */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-zc&quot;</span>, temp_buf, <span class="enscript-keyword">sizeof</span>(temp_buf))) {
		corruption_debug_flag = TRUE;
	}	

	<span class="enscript-comment">/*
	 * Check for and set up zone leak detection if requested via boot-args.  We recognized two
	 * boot-args:
	 *
	 *	zlog=&lt;zone_to_log&gt;
	 *	zrecs=&lt;num_records_in_log&gt;
	 *
	 * The zlog arg is used to specify the zone name that should be logged, and zrecs is used to
	 * control the size of the log.  If zrecs is not specified, a default value is used.
	 */</span>

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;zlog&quot;</span>, zone_name_to_log, <span class="enscript-keyword">sizeof</span>(zone_name_to_log)) == TRUE) {
		<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;zrecs&quot;</span>, &amp;log_records, <span class="enscript-keyword">sizeof</span>(log_records)) == TRUE) {

			<span class="enscript-comment">/*
			 * Don't allow more than ZRECORDS_MAX records even if the user asked for more.
			 * This prevents accidentally hogging too much kernel memory and making the system
			 * unusable.
			 */</span>

			log_records = MIN(ZRECORDS_MAX, log_records);

		} <span class="enscript-keyword">else</span> {
			log_records = ZRECORDS_DEFAULT;
		}
	}

	simple_lock_init(&amp;all_zones_lock, 0);

	first_zone = ZONE_NULL;
	last_zone = &amp;first_zone;
	num_zones = 0;
	thread_call_setup(&amp;call_async_alloc, zalloc_async, NULL);

	<span class="enscript-comment">/* assertion: nobody else called zinit before us */</span>
	assert(zone_zone == ZONE_NULL);
	
	<span class="enscript-comment">/* initializing global lock group for zones */</span>
	lck_grp_attr_setdefault(&amp;zone_locks_grp_attr);
	lck_grp_init(&amp;zone_locks_grp, <span class="enscript-string">&quot;zone_locks&quot;</span>, &amp;zone_locks_grp_attr);

	zone_zone = zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zone), 128 * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zone),
			  <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zone), <span class="enscript-string">&quot;zones&quot;</span>);
	zone_change(zone_zone, Z_COLLECT, FALSE);
	zone_change(zone_zone, Z_CALLERACCT, FALSE);
	zone_change(zone_zone, Z_NOENCRYPT, TRUE);

	zcram(zone_zone, zdata, zdata_size);
	VM_PAGE_MOVE_STOLEN(atop_64(zdata_size));

	<span class="enscript-comment">/* initialize fake zones and zone info if tracking by task */</span>
	<span class="enscript-keyword">if</span> (zinfo_per_task) {
		vm_size_t zisize = <span class="enscript-keyword">sizeof</span>(zinfo_usage_store_t) * ZINFO_SLOTS;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; num_fake_zones; i++)
			fake_zones[i].init(ZINFO_SLOTS - num_fake_zones + i);
		zinfo_zone = zinit(zisize, zisize * CONFIG_TASK_MAX,
				   zisize, <span class="enscript-string">&quot;per task zinfo&quot;</span>);
		zone_change(zinfo_zone, Z_CALLERACCT, FALSE);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">zinfo_task_init</span>(task_t task)
{
	<span class="enscript-keyword">if</span> (zinfo_per_task) {
		task-&gt;tkm_zinfo = zalloc(zinfo_zone);
		memset(task-&gt;tkm_zinfo, 0, <span class="enscript-keyword">sizeof</span>(zinfo_usage_store_t) * ZINFO_SLOTS);
	} <span class="enscript-keyword">else</span> {
		task-&gt;tkm_zinfo = NULL;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">zinfo_task_free</span>(task_t task)
{
	assert(task != kernel_task);
	<span class="enscript-keyword">if</span> (task-&gt;tkm_zinfo != NULL) {
		zfree(zinfo_zone, task-&gt;tkm_zinfo);
		task-&gt;tkm_zinfo = NULL;
	}
}
		
<span class="enscript-comment">/* Global initialization of Zone Allocator.
 * Runs after zone_bootstrap.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_init</span>(
	vm_size_t max_zonemap_size)
{
	kern_return_t	retval;
	vm_offset_t	zone_min;
	vm_offset_t	zone_max;

	retval = kmem_suballoc(kernel_map, &amp;zone_min, max_zonemap_size,
			       FALSE, VM_FLAGS_ANYWHERE | VM_FLAGS_PERMANENT | VM_MAKE_TAG(VM_KERN_MEMORY_ZONE),
			       &amp;zone_map);

	<span class="enscript-keyword">if</span> (retval != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;zone_init: kmem_suballoc failed&quot;</span>);
	zone_max = zone_min + round_page(max_zonemap_size);
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_GZALLOC</span>
	gzalloc_init(max_zonemap_size);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Setup garbage collection information:
	 */</span>
	zone_map_min_address = zone_min;
	zone_map_max_address = zone_max;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	<span class="enscript-comment">/*
	 * ensure that any vm_page_t that gets created from
	 * the vm_page zone can be packed properly (see vm_page.h
	 * for the packing requirements
	 */</span>
	<span class="enscript-keyword">if</span> (VM_PAGE_UNPACK_PTR(VM_PAGE_PACK_PTR(zone_map_min_address)) != (vm_page_t)zone_map_min_address)
		panic(<span class="enscript-string">&quot;VM_PAGE_PACK_PTR failed on zone_map_min_address - %p&quot;</span>, (<span class="enscript-type">void</span> *)zone_map_min_address);

	<span class="enscript-keyword">if</span> (VM_PAGE_UNPACK_PTR(VM_PAGE_PACK_PTR(zone_map_max_address)) != (vm_page_t)zone_map_max_address)
		panic(<span class="enscript-string">&quot;VM_PAGE_PACK_PTR failed on zone_map_max_address - %p&quot;</span>, (<span class="enscript-type">void</span> *)zone_map_max_address);
#<span class="enscript-reference">endif</span>

	zone_pages = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)atop_kernel(zone_max - zone_min);
	zone_page_table_used_size = <span class="enscript-keyword">sizeof</span>(zone_page_table);

	zone_page_table_second_level_size = 1;
	zone_page_table_second_level_shift_amount = 0;
	
	<span class="enscript-comment">/*
	 * Find the power of 2 for the second level that allows
	 * the first level to fit in ZONE_PAGE_TABLE_FIRST_LEVEL_SIZE
	 * slots.
	 */</span>
	<span class="enscript-keyword">while</span> ((zone_page_table_first_level_slot(zone_pages-1)) &gt;= ZONE_PAGE_TABLE_FIRST_LEVEL_SIZE) {
		zone_page_table_second_level_size &lt;&lt;= 1;
		zone_page_table_second_level_shift_amount++;
	}
	
	lck_grp_attr_setdefault(&amp;zone_gc_lck_grp_attr);
	lck_grp_init(&amp;zone_gc_lck_grp, <span class="enscript-string">&quot;zone_gc&quot;</span>, &amp;zone_gc_lck_grp_attr);
	lck_attr_setdefault(&amp;zone_gc_lck_attr);
	lck_mtx_init_ext(&amp;zone_gc_lock, &amp;zone_gc_lck_ext, &amp;zone_gc_lck_grp, &amp;zone_gc_lck_attr);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
	<span class="enscript-comment">/*
	 * Initialize the zone leak monitor
	 */</span>
	zleak_init(max_zonemap_size);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_page_table_expand</span>(zone_page_index_t pindex)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> first_index;
	<span class="enscript-type">struct</span> zone_page_table_entry * <span class="enscript-type">volatile</span> * first_level_ptr;

	assert(pindex &lt; zone_pages);

	first_index = zone_page_table_first_level_slot(pindex);
	first_level_ptr = &amp;zone_page_table[first_index];

	<span class="enscript-keyword">if</span> (*first_level_ptr == NULL) {
		<span class="enscript-comment">/*
		 * We were able to verify the old first-level slot
		 * had NULL, so attempt to populate it.
		 */</span>

		vm_offset_t second_level_array = 0;
		vm_size_t second_level_size = round_page(zone_page_table_second_level_size * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zone_page_table_entry));
		zone_page_index_t i;
		<span class="enscript-type">struct</span> zone_page_table_entry *entry_array;

		<span class="enscript-keyword">if</span> (kmem_alloc_kobject(zone_map, &amp;second_level_array,
							   second_level_size, VM_KERN_MEMORY_OSFMK) != KERN_SUCCESS) {
			panic(<span class="enscript-string">&quot;zone_page_table_expand&quot;</span>);
		}
		zone_map_table_page_count += (second_level_size / PAGE_SIZE);

		<span class="enscript-comment">/*
		 * zone_gc() may scan the &quot;zone_page_table&quot; directly,
		 * so make sure any slots have a valid unused state.
		 */</span>
		entry_array = (<span class="enscript-type">struct</span> zone_page_table_entry *)second_level_array;
		<span class="enscript-keyword">for</span> (i=0; i &lt; zone_page_table_second_level_size; i++) {
			entry_array[i].alloc_count = ZONE_PAGE_UNUSED;
			entry_array[i].collect_count = 0;
		}

		<span class="enscript-keyword">if</span> (OSCompareAndSwapPtr(NULL, entry_array, first_level_ptr)) {
			<span class="enscript-comment">/* Old slot was NULL, replaced with expanded level */</span>
			OSAddAtomicLong(second_level_size, &amp;zone_page_table_used_size);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Old slot was not NULL, someone else expanded first */</span>
			kmem_free(zone_map, second_level_array, second_level_size);
			zone_map_table_page_count -= (second_level_size / PAGE_SIZE);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Old slot was not NULL, already been expanded */</span>
	}
}

<span class="enscript-type">struct</span> zone_page_table_entry *
<span class="enscript-function-name">zone_page_table_lookup</span>(zone_page_index_t pindex)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> first_index = zone_page_table_first_level_slot(pindex);
	<span class="enscript-type">struct</span> zone_page_table_entry *second_level = zone_page_table[first_index];

	<span class="enscript-keyword">if</span> (second_level) {
		<span class="enscript-keyword">return</span> &amp;second_level[zone_page_table_second_level_slot(pindex)];
	}

	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">extern</span> <span class="enscript-type">volatile</span> SInt32 kfree_nop_count;

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">zalloc_canblock</span>

<span class="enscript-comment">/*
 *	zalloc returns an element from the specified zone.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">zalloc_internal</span>(
	zone_t	zone,
	boolean_t canblock,
	boolean_t nopagewait)
{
	vm_offset_t	addr = 0;
	kern_return_t	retval;
	uintptr_t	zbt[MAX_ZTRACE_DEPTH];	<span class="enscript-comment">/* used in zone leak logging and zone leak detection */</span>
	<span class="enscript-type">int</span> 		numsaved = 0;
	boolean_t	zone_replenish_wakeup = FALSE, zone_alloc_throttle = FALSE;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_GZALLOC</span> || <span class="enscript-variable-name">ZONE_DEBUG</span>	
	boolean_t	did_gzalloc = FALSE;
#<span class="enscript-reference">endif</span>
	thread_t thr = current_thread();
	boolean_t       check_poison = FALSE;
	boolean_t       set_doing_alloc_with_vm_priv = FALSE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
	uint32_t	zleak_tracedepth = 0;  <span class="enscript-comment">/* log this allocation if nonzero */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>

	assert(zone != ZONE_NULL);

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_GZALLOC</span>
	addr = gzalloc_alloc(zone, canblock);
	did_gzalloc = (addr != 0);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * If zone logging is turned on and this is the zone we're tracking, grab a backtrace.
	 */</span>
	<span class="enscript-keyword">if</span> (__improbable(DO_LOGGING(zone)))
	        numsaved = OSBacktrace((<span class="enscript-type">void</span>*) zbt, MAX_ZTRACE_DEPTH);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
	<span class="enscript-comment">/*
	 * Zone leak detection: capture a backtrace every zleak_sample_factor
	 * allocations in this zone.
	 */</span>
	<span class="enscript-keyword">if</span> (__improbable(zone-&gt;zleak_on &amp;&amp; sample_counter(&amp;zone-&gt;zleak_capture, zleak_sample_factor) == TRUE)) {
		<span class="enscript-comment">/* Avoid backtracing twice if zone logging is on */</span>
		<span class="enscript-keyword">if</span> (numsaved == 0)
			zleak_tracedepth = fastbacktrace(zbt, MAX_ZTRACE_DEPTH);
		<span class="enscript-keyword">else</span>
			zleak_tracedepth = numsaved;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>

	lock_zone(zone);

	<span class="enscript-keyword">if</span> (zone-&gt;async_prio_refill &amp;&amp; zone-&gt;zone_replenish_thread) {
		    <span class="enscript-keyword">do</span> {
			    vm_size_t zfreec = (zone-&gt;cur_size - (zone-&gt;count * zone-&gt;elem_size));
			    vm_size_t zrefillwm = zone-&gt;prio_refill_watermark * zone-&gt;elem_size;
			    zone_replenish_wakeup = (zfreec &lt; zrefillwm);
			    zone_alloc_throttle = (zfreec &lt; (zrefillwm / 2)) &amp;&amp; ((thr-&gt;options &amp; TH_OPT_VMPRIV) == 0);

			    <span class="enscript-keyword">if</span> (zone_replenish_wakeup) {
				    zone_replenish_wakeups_initiated++;
				    unlock_zone(zone);
				    <span class="enscript-comment">/* Signal the potentially waiting
				     * refill thread.
				     */</span>
				    thread_wakeup(&amp;zone-&gt;zone_replenish_thread);

				    <span class="enscript-comment">/* Scheduling latencies etc. may prevent
				     * the refill thread from keeping up
				     * with demand. Throttle consumers
				     * when we fall below half the
				     * watermark, unless VM privileged
				     */</span>
				    <span class="enscript-keyword">if</span> (zone_alloc_throttle) {
					    zone_replenish_throttle_count++;
					    assert_wait_timeout(zone, THREAD_UNINT, 1, NSEC_PER_MSEC);
					    thread_block(THREAD_CONTINUE_NULL);
				    }
				    lock_zone(zone);
			    }
		    } <span class="enscript-keyword">while</span> (zone_alloc_throttle == TRUE);
	}
	
	<span class="enscript-keyword">if</span> (__probable(addr == 0))
		addr = try_alloc_from_zone(zone, &amp;check_poison);


	<span class="enscript-keyword">while</span> ((addr == 0) &amp;&amp; canblock) {
		<span class="enscript-comment">/*
 		 * zone is empty, try to expand it
		 * 
		 * Note that we now allow up to 2 threads (1 vm_privliged and 1 non-vm_privliged)
		 * to expand the zone concurrently...  this is necessary to avoid stalling
		 * vm_privileged threads running critical code necessary to continue compressing/swapping
		 * pages (i.e. making new free pages) from stalling behind non-vm_privileged threads
		 * waiting to acquire free pages when the vm_page_free_count is below the
		 * vm_page_free_reserved limit.
		 */</span>
		<span class="enscript-keyword">if</span> ((zone-&gt;doing_alloc_without_vm_priv || zone-&gt;doing_alloc_with_vm_priv) &amp;&amp;
		    (((thr-&gt;options &amp; TH_OPT_VMPRIV) == 0) || zone-&gt;doing_alloc_with_vm_priv)) {
			<span class="enscript-comment">/*
			 * This is a non-vm_privileged thread and a non-vm_privileged or
			 * a vm_privileged thread is already expanding the zone...
			 *    OR
			 * this is a vm_privileged thread and a vm_privileged thread is
			 * already expanding the zone...
			 *
			 * In either case wait for a thread to finish, then try again.
			 */</span>
			zone-&gt;waiting = TRUE;
			zone_sleep(zone);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (zone-&gt;doing_gc) {
			<span class="enscript-comment">/*
			 * zone_gc() is running. Since we need an element
			 * from the free list that is currently being
			 * collected, set the waiting bit and 
			 * wait for the GC process to finish
			 * before trying again
			 */</span>
			zone-&gt;waiting = TRUE;
			zone_sleep(zone);
		} <span class="enscript-keyword">else</span> {
			vm_offset_t space;
			vm_size_t alloc_size;
			<span class="enscript-type">int</span> retry = 0;

			<span class="enscript-keyword">if</span> ((zone-&gt;cur_size + zone-&gt;elem_size) &gt;
			    zone-&gt;max_size) {
				<span class="enscript-keyword">if</span> (zone-&gt;exhaustible)
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">if</span> (zone-&gt;expandable) {
					<span class="enscript-comment">/*
					 * We're willing to overflow certain
					 * zones, but not without complaining.
					 *
					 * This is best used in conjunction
					 * with the collectable flag. What we
					 * want is an assurance we can get the
					 * memory back, assuming there's no
					 * leak. 
					 */</span>
					zone-&gt;max_size += (zone-&gt;max_size &gt;&gt; 1);
				} <span class="enscript-keyword">else</span> {
					unlock_zone(zone);

					panic_include_zprint = TRUE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
					<span class="enscript-keyword">if</span> (zleak_state &amp; ZLEAK_STATE_ACTIVE)
						panic_include_ztrace = TRUE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>
					panic(<span class="enscript-string">&quot;zalloc: zone \&quot;%s\&quot; empty.&quot;</span>, zone-&gt;zone_name);
				}
			}
			<span class="enscript-keyword">if</span> ((thr-&gt;options &amp; TH_OPT_VMPRIV)) {
			        zone-&gt;doing_alloc_with_vm_priv = TRUE;
				set_doing_alloc_with_vm_priv = TRUE;
			} <span class="enscript-keyword">else</span> {
			        zone-&gt;doing_alloc_without_vm_priv = TRUE;
			}
			unlock_zone(zone);

			<span class="enscript-keyword">for</span> (;;) {
				<span class="enscript-type">int</span>	zflags = KMA_KOBJECT|KMA_NOPAGEWAIT;

				<span class="enscript-keyword">if</span> (vm_pool_low() || retry &gt;= 1)
					alloc_size = 
						round_page(zone-&gt;elem_size);
				<span class="enscript-keyword">else</span>
					alloc_size = zone-&gt;alloc_size;
				
				<span class="enscript-keyword">if</span> (zone-&gt;noencrypt)
					zflags |= KMA_NOENCRYPT;
				
				retval = kernel_memory_allocate(zone_map, &amp;space, alloc_size, 0, zflags, VM_KERN_MEMORY_ZONE);
				<span class="enscript-keyword">if</span> (retval == KERN_SUCCESS) {
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
					<span class="enscript-keyword">if</span> (alloc_size == PAGE_SIZE)
						space = zone_alias_addr(space);
#<span class="enscript-reference">endif</span>
					
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
					<span class="enscript-keyword">if</span> ((zleak_state &amp; (ZLEAK_STATE_ENABLED | ZLEAK_STATE_ACTIVE)) == ZLEAK_STATE_ENABLED) {
						<span class="enscript-keyword">if</span> (zone_map-&gt;size &gt;= zleak_global_tracking_threshold) {
							kern_return_t kr;
							
							kr = zleak_activate();
							<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
								printf(<span class="enscript-string">&quot;Failed to activate live zone leak debugging (%d).\n&quot;</span>, kr);
							}
						}
					}
					
					<span class="enscript-keyword">if</span> ((zleak_state &amp; ZLEAK_STATE_ACTIVE) &amp;&amp; !(zone-&gt;zleak_on)) {
						<span class="enscript-keyword">if</span> (zone-&gt;cur_size &gt; zleak_per_zone_tracking_threshold) {
							zone-&gt;zleak_on = TRUE;
						}	
					}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>
					zcram(zone, space, alloc_size);
					
					<span class="enscript-keyword">break</span>;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (retval != KERN_RESOURCE_SHORTAGE) {
					retry++;
					
					<span class="enscript-keyword">if</span> (retry == 2) {
						zone_gc(TRUE);
						printf(<span class="enscript-string">&quot;zalloc did gc\n&quot;</span>);
						zone_display_zprint();
					}
					<span class="enscript-keyword">if</span> (retry == 3) {
						panic_include_zprint = TRUE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
						<span class="enscript-keyword">if</span> ((zleak_state &amp; ZLEAK_STATE_ACTIVE)) {
							panic_include_ztrace = TRUE;
						}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>		
						<span class="enscript-keyword">if</span> (retval == KERN_NO_SPACE) {
							zone_t zone_largest = zone_find_largest();
							panic(<span class="enscript-string">&quot;zalloc: zone map exhausted while allocating from zone %s, likely due to memory leak in zone %s (%lu total bytes, %d elements allocated)&quot;</span>,
							zone-&gt;zone_name, zone_largest-&gt;zone_name,
							(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)zone_largest-&gt;cur_size, zone_largest-&gt;count);

						}
						panic(<span class="enscript-string">&quot;zalloc: \&quot;%s\&quot; (%d elements) retry fail %d, kfree_nop_count: %d&quot;</span>, zone-&gt;zone_name, zone-&gt;count, retval, (<span class="enscript-type">int</span>)kfree_nop_count);
					}
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">break</span>;
				}
			}
			lock_zone(zone);

			<span class="enscript-keyword">if</span> (set_doing_alloc_with_vm_priv == TRUE)
			        zone-&gt;doing_alloc_with_vm_priv = FALSE;
			<span class="enscript-keyword">else</span>
			        zone-&gt;doing_alloc_without_vm_priv = FALSE; 
			
			<span class="enscript-keyword">if</span> (zone-&gt;waiting) {
			        zone-&gt;waiting = FALSE;
				zone_wakeup(zone);
			}
			addr = try_alloc_from_zone(zone, &amp;check_poison);
			<span class="enscript-keyword">if</span> (addr == 0 &amp;&amp;
			    retval == KERN_RESOURCE_SHORTAGE) {
				<span class="enscript-keyword">if</span> (nopagewait == TRUE)
					<span class="enscript-keyword">break</span>;	<span class="enscript-comment">/* out of the main while loop */</span>
				unlock_zone(zone);

				VM_PAGE_WAIT();
				lock_zone(zone);
			}
		}
		<span class="enscript-keyword">if</span> (addr == 0)
			addr = try_alloc_from_zone(zone, &amp;check_poison);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
	<span class="enscript-comment">/* Zone leak detection:
	 * If we're sampling this allocation, add it to the zleaks hash table. 
	 */</span>
	<span class="enscript-keyword">if</span> (addr &amp;&amp; zleak_tracedepth &gt; 0)  {
		<span class="enscript-comment">/* Sampling can fail if another sample is happening at the same time in a different zone. */</span>
		<span class="enscript-keyword">if</span> (!zleak_log(zbt, addr, zleak_tracedepth, zone-&gt;elem_size)) {
			<span class="enscript-comment">/* If it failed, roll back the counter so we sample the next allocation instead. */</span>
			zone-&gt;zleak_capture = zleak_sample_factor;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>			
			
			
	<span class="enscript-keyword">if</span> ((addr == 0) &amp;&amp; (!canblock || nopagewait) &amp;&amp; (zone-&gt;async_pending == FALSE) &amp;&amp; (zone-&gt;no_callout == FALSE) &amp;&amp; (zone-&gt;exhaustible == FALSE) &amp;&amp; (!vm_pool_low())) {
		zone-&gt;async_pending = TRUE;
		unlock_zone(zone);
		thread_call_enter(&amp;call_async_alloc);
		lock_zone(zone);
		addr = try_alloc_from_zone(zone, &amp;check_poison);
	}

	<span class="enscript-comment">/*
	 * See if we should be logging allocations in this zone.  Logging is rarely done except when a leak is
	 * suspected, so this code rarely executes.  We need to do this code while still holding the zone lock
	 * since it protects the various log related data structures.
	 */</span>

	<span class="enscript-keyword">if</span> (__improbable(DO_LOGGING(zone) &amp;&amp; addr)) {
		btlog_add_entry(zlog_btlog, (<span class="enscript-type">void</span> *)addr, ZOP_ALLOC, (<span class="enscript-type">void</span> **)zbt, numsaved);
	}

	vm_offset_t     inner_size = zone-&gt;elem_size;
	
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_DEBUG</span>
	<span class="enscript-keyword">if</span> (!did_gzalloc &amp;&amp; addr &amp;&amp; zone_debug_enabled(zone)) {
		enqueue_tail(&amp;zone-&gt;active_zones, (queue_entry_t)addr);
		addr += ZONE_DEBUG_OFFSET;
		inner_size -= ZONE_DEBUG_OFFSET;
	}
#<span class="enscript-reference">endif</span>

	unlock_zone(zone);

	<span class="enscript-keyword">if</span> (__improbable(check_poison &amp;&amp; addr)) {
		vm_offset_t *element_cursor  = ((vm_offset_t *) addr) + 1;
		vm_offset_t *backup  = get_backup_ptr(inner_size, (vm_offset_t *) addr);

		<span class="enscript-keyword">for</span> ( ; element_cursor &lt; backup ; element_cursor++)
			<span class="enscript-keyword">if</span> (__improbable(*element_cursor != ZP_POISON))
				zone_element_was_modified_panic(zone,
				                                addr,
				                                *element_cursor,
				                                ZP_POISON,
				                                ((vm_offset_t)element_cursor) - addr);
	}

	<span class="enscript-keyword">if</span> (addr) {
		<span class="enscript-comment">/*
		 * Clear out the old next pointer and backup to avoid leaking the cookie
		 * and so that only values on the freelist have a valid cookie
		 */</span>

		vm_offset_t *primary  = (vm_offset_t *) addr;
		vm_offset_t *backup   = get_backup_ptr(inner_size, primary);

		*primary = ZP_POISON;
		*backup  = ZP_POISON;
	}

	TRACE_MACHLEAKS(ZALLOC_CODE, ZALLOC_CODE_2, zone-&gt;elem_size, addr);

	<span class="enscript-keyword">if</span> (addr) {
		task_t task;
		zinfo_usage_t zinfo;
		vm_size_t sz = zone-&gt;elem_size;

		<span class="enscript-keyword">if</span> (zone-&gt;caller_acct)
			ledger_credit(thr-&gt;t_ledger, task_ledgers.tkm_private, sz);
		<span class="enscript-keyword">else</span>
			ledger_credit(thr-&gt;t_ledger, task_ledgers.tkm_shared, sz);

		<span class="enscript-keyword">if</span> ((task = thr-&gt;task) != NULL &amp;&amp; (zinfo = task-&gt;tkm_zinfo) != NULL)
			OSAddAtomic64(sz, (int64_t *)&amp;zinfo[zone-&gt;index].alloc);
	}
	<span class="enscript-keyword">return</span>((<span class="enscript-type">void</span> *)addr);
}


<span class="enscript-type">void</span> *
<span class="enscript-function-name">zalloc</span>(zone_t zone)
{
	<span class="enscript-keyword">return</span> (zalloc_internal(zone, TRUE, FALSE));
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">zalloc_noblock</span>(zone_t zone)
{
	<span class="enscript-keyword">return</span> (zalloc_internal(zone, FALSE, FALSE));
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">zalloc_nopagewait</span>(zone_t zone)
{
	<span class="enscript-keyword">return</span> (zalloc_internal(zone, TRUE, TRUE));
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">zalloc_canblock</span>(zone_t zone, boolean_t canblock)
{
	<span class="enscript-keyword">return</span> (zalloc_internal(zone, canblock, FALSE));
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">zalloc_async</span>(
	__unused thread_call_param_t          p0,
	__unused thread_call_param_t p1)
{
	zone_t current_z = NULL, head_z;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> max_zones, i;
	<span class="enscript-type">void</span> *elt = NULL;
	boolean_t pending = FALSE;
	
	simple_lock(&amp;all_zones_lock);
	head_z = first_zone;
	max_zones = num_zones;
	simple_unlock(&amp;all_zones_lock);
	current_z = head_z;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; max_zones; i++) {
		lock_zone(current_z);
		<span class="enscript-keyword">if</span> (current_z-&gt;async_pending == TRUE) {
			current_z-&gt;async_pending = FALSE;
			pending = TRUE;
		}
		unlock_zone(current_z);

		<span class="enscript-keyword">if</span> (pending == TRUE) {
			elt = zalloc_canblock(current_z, TRUE);
			zfree(current_z, elt);
			pending = FALSE;
		}
		<span class="enscript-comment">/*
		 * This is based on assumption that zones never get
		 * freed once allocated and linked. 
		 * Hence a read outside of lock is OK.
		 */</span>
		current_z = current_z-&gt;next_zone;
	}
}

<span class="enscript-comment">/*
 *	zget returns an element from the specified zone
 *	and immediately returns nothing if there is nothing there.
 *
 *	This form should be used when you can not block (like when
 *	processing an interrupt).
 *
 *	XXX: It seems like only vm_page_grab_fictitious_common uses this, and its
 *  friend vm_page_more_fictitious can block, so it doesn't seem like 
 *  this is used for interrupts any more....
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">zget</span>(
	<span class="enscript-type">register</span> zone_t	zone)
{
	vm_offset_t	addr;
	boolean_t       check_poison = FALSE;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
	uintptr_t	zbt[MAX_ZTRACE_DEPTH];		<span class="enscript-comment">/* used for zone leak detection */</span>
	uint32_t	zleak_tracedepth = 0;  <span class="enscript-comment">/* log this allocation if nonzero */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>

	assert( zone != ZONE_NULL );

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
	<span class="enscript-comment">/*
	 * Zone leak detection: capture a backtrace
	 */</span>
	<span class="enscript-keyword">if</span> (__improbable(zone-&gt;zleak_on &amp;&amp; sample_counter(&amp;zone-&gt;zleak_capture, zleak_sample_factor) == TRUE)) {
		zleak_tracedepth = fastbacktrace(zbt, MAX_ZTRACE_DEPTH);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>

	<span class="enscript-keyword">if</span> (!lock_try_zone(zone))
		<span class="enscript-keyword">return</span> NULL;
	
	addr = try_alloc_from_zone(zone, &amp;check_poison);

	vm_offset_t     inner_size = zone-&gt;elem_size;
	
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_DEBUG</span>
	<span class="enscript-keyword">if</span> (addr &amp;&amp; zone_debug_enabled(zone)) {
		enqueue_tail(&amp;zone-&gt;active_zones, (queue_entry_t)addr);
		addr += ZONE_DEBUG_OFFSET;
		inner_size -= ZONE_DEBUG_OFFSET;
	}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* ZONE_DEBUG */</span>
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
	<span class="enscript-comment">/*
	 * Zone leak detection: record the allocation 
	 */</span>
	<span class="enscript-keyword">if</span> (zone-&gt;zleak_on &amp;&amp; zleak_tracedepth &gt; 0 &amp;&amp; addr) {
		<span class="enscript-comment">/* Sampling can fail if another sample is happening at the same time in a different zone. */</span>
		<span class="enscript-keyword">if</span> (!zleak_log(zbt, addr, zleak_tracedepth, zone-&gt;elem_size)) {
			<span class="enscript-comment">/* If it failed, roll back the counter so we sample the next allocation instead. */</span>
			zone-&gt;zleak_capture = zleak_sample_factor;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>
	
	unlock_zone(zone);

	<span class="enscript-keyword">if</span> (__improbable(check_poison &amp;&amp; addr)) {
		vm_offset_t *element_cursor  = ((vm_offset_t *) addr) + 1;
		vm_offset_t *backup  = get_backup_ptr(inner_size, (vm_offset_t *) addr);

		<span class="enscript-keyword">for</span> ( ; element_cursor &lt; backup ; element_cursor++)
			<span class="enscript-keyword">if</span> (__improbable(*element_cursor != ZP_POISON))
				zone_element_was_modified_panic(zone,
				                                addr,
				                                *element_cursor,
				                                ZP_POISON,
				                                ((vm_offset_t)element_cursor) - addr);
	}

	<span class="enscript-keyword">if</span> (addr) {
		<span class="enscript-comment">/*
		 * Clear out the old next pointer and backup to avoid leaking the cookie
		 * and so that only values on the freelist have a valid cookie
		 */</span>
		vm_offset_t *primary  = (vm_offset_t *) addr;
		vm_offset_t *backup   = get_backup_ptr(inner_size, primary);

		*primary = ZP_POISON;
		*backup  = ZP_POISON;
	}

	<span class="enscript-keyword">return</span>((<span class="enscript-type">void</span> *) addr);
}

<span class="enscript-comment">/* Keep this FALSE by default.  Large memory machine run orders of magnitude
   slower in debug mode when true.  Use debugger to enable if needed */</span>
<span class="enscript-comment">/* static */</span> boolean_t zone_check = FALSE;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">zone_check_freelist</span>(zone_t zone, vm_offset_t elem)
{
	<span class="enscript-type">struct</span> zone_free_element *this;
	<span class="enscript-type">struct</span> zone_page_metadata *thispage;

	<span class="enscript-keyword">if</span> (zone-&gt;use_page_list) {
		<span class="enscript-keyword">if</span> (zone-&gt;allows_foreign) {
			<span class="enscript-keyword">for</span> (thispage = (<span class="enscript-type">struct</span> zone_page_metadata *)queue_first(&amp;zone-&gt;pages.any_free_foreign);
				 !queue_end(&amp;zone-&gt;pages.any_free_foreign, (queue_entry_t)thispage);
				 thispage = (<span class="enscript-type">struct</span> zone_page_metadata *)queue_next((queue_chain_t *)thispage)) {
				<span class="enscript-keyword">for</span> (this = thispage-&gt;elements;
					 this != NULL;
					 this = this-&gt;next) {
					<span class="enscript-keyword">if</span> (!is_sane_zone_element(zone, (vm_address_t)this) || (vm_address_t)this == elem)
						panic(<span class="enscript-string">&quot;zone_check_freelist&quot;</span>);
				}
			}
		}
		<span class="enscript-keyword">for</span> (thispage = (<span class="enscript-type">struct</span> zone_page_metadata *)queue_first(&amp;zone-&gt;pages.all_free);
			 !queue_end(&amp;zone-&gt;pages.all_free, (queue_entry_t)thispage);
			 thispage = (<span class="enscript-type">struct</span> zone_page_metadata *)queue_next((queue_chain_t *)thispage)) {
			<span class="enscript-keyword">for</span> (this = thispage-&gt;elements;
				 this != NULL;
				 this = this-&gt;next) {
				<span class="enscript-keyword">if</span> (!is_sane_zone_element(zone, (vm_address_t)this) || (vm_address_t)this == elem)
					panic(<span class="enscript-string">&quot;zone_check_freelist&quot;</span>);
			}
		}
		<span class="enscript-keyword">for</span> (thispage = (<span class="enscript-type">struct</span> zone_page_metadata *)queue_first(&amp;zone-&gt;pages.intermediate);
			 !queue_end(&amp;zone-&gt;pages.intermediate, (queue_entry_t)thispage);
			 thispage = (<span class="enscript-type">struct</span> zone_page_metadata *)queue_next((queue_chain_t *)thispage)) {
			<span class="enscript-keyword">for</span> (this = thispage-&gt;elements;
				 this != NULL;
				 this = this-&gt;next) {
				<span class="enscript-keyword">if</span> (!is_sane_zone_element(zone, (vm_address_t)this) || (vm_address_t)this == elem)
					panic(<span class="enscript-string">&quot;zone_check_freelist&quot;</span>);
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">for</span> (this = zone-&gt;free_elements;
			 this != NULL;
			 this = this-&gt;next) {
			<span class="enscript-keyword">if</span> (!is_sane_zone_element(zone, (vm_address_t)this) || (vm_address_t)this == elem)
				panic(<span class="enscript-string">&quot;zone_check_freelist&quot;</span>);
		}
	}
}

<span class="enscript-type">static</span> zone_t zone_last_bogus_zone = ZONE_NULL;
<span class="enscript-type">static</span> vm_offset_t zone_last_bogus_elem = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">zfree</span>(
	<span class="enscript-type">register</span> zone_t	zone,
	<span class="enscript-type">void</span> 		*addr)
{
	vm_offset_t	elem = (vm_offset_t) addr;
	uintptr_t	zbt[MAX_ZTRACE_DEPTH];			<span class="enscript-comment">/* only used if zone logging is enabled via boot-args */</span>
	<span class="enscript-type">int</span>		numsaved = 0;
	boolean_t	gzfreed = FALSE;
	boolean_t       poison = FALSE;

	assert(zone != ZONE_NULL);

#<span class="enscript-reference">if</span> 1
	<span class="enscript-keyword">if</span> (zone-&gt;use_page_list) {
		<span class="enscript-type">struct</span> zone_page_metadata *page_meta = get_zone_page_metadata((<span class="enscript-type">struct</span> zone_free_element *)addr);
		<span class="enscript-keyword">if</span> (zone != page_meta-&gt;zone) {
			<span class="enscript-comment">/*
			 * Something bad has happened. Someone tried to zfree a pointer but the metadata says it is from
			 * a different zone (or maybe it's from a zone that doesn't use page free lists at all). We can repair
			 * some cases of this, if:
			 * 1) The specified zone had use_page_list, and the true zone also has use_page_list set. In that case
			 *    we can swap the zone_t
			 * 2) The specified zone had use_page_list, but the true zone does not. In this case page_meta is garbage,
			 *    and dereferencing page_meta-&gt;zone might panic.
			 * To distinguish the two, we enumerate the zone list to match it up.
			 * We do not handle the case where an incorrect zone is passed that does not have use_page_list set,
			 * even if the true zone did have this set.
			 */</span>
			zone_t fixed_zone = NULL;
			<span class="enscript-type">int</span> fixed_i, max_zones;

			simple_lock(&amp;all_zones_lock);
			max_zones = num_zones;
			fixed_zone = first_zone;
			simple_unlock(&amp;all_zones_lock);

			<span class="enscript-keyword">for</span> (fixed_i=0; fixed_i &lt; max_zones; fixed_i++, fixed_zone = fixed_zone-&gt;next_zone) {
				<span class="enscript-keyword">if</span> (fixed_zone == page_meta-&gt;zone &amp;&amp; fixed_zone-&gt;use_page_list) {
					<span class="enscript-comment">/* we can fix this */</span>
					printf(<span class="enscript-string">&quot;Fixing incorrect zfree from zone %s to zone %s\n&quot;</span>, zone-&gt;zone_name, fixed_zone-&gt;zone_name);
					zone = fixed_zone;
					<span class="enscript-keyword">break</span>;
				}
			}
		}
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * If zone logging is turned on and this is the zone we're tracking, grab a backtrace.
	 */</span>

	<span class="enscript-keyword">if</span> (__improbable(DO_LOGGING(zone) &amp;&amp; corruption_debug_flag))
		numsaved = OSBacktrace((<span class="enscript-type">void</span> *)zbt, MAX_ZTRACE_DEPTH);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-comment">/* Basic sanity checks */</span>
	<span class="enscript-keyword">if</span> (zone == ZONE_NULL || elem == (vm_offset_t)0)
		panic(<span class="enscript-string">&quot;zfree: NULL&quot;</span>);
	<span class="enscript-comment">/* zone_gc assumes zones are never freed */</span>
	<span class="enscript-keyword">if</span> (zone == zone_zone)
		panic(<span class="enscript-string">&quot;zfree: freeing to zone_zone breaks zone_gc!&quot;</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_GZALLOC</span>	
	gzfreed = gzalloc_free(zone, addr);
#<span class="enscript-reference">endif</span>

	TRACE_MACHLEAKS(ZFREE_CODE, ZFREE_CODE_2, zone-&gt;elem_size, (uintptr_t)addr);

	<span class="enscript-keyword">if</span> (__improbable(!gzfreed &amp;&amp; zone-&gt;collectable &amp;&amp; !zone-&gt;allows_foreign &amp;&amp;
		!from_zone_map(elem, zone-&gt;elem_size))) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
		panic(<span class="enscript-string">&quot;zfree: non-allocated memory in collectable zone!&quot;</span>);
#<span class="enscript-reference">endif</span>
		zone_last_bogus_zone = zone;
		zone_last_bogus_elem = elem;
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> ((zp_factor != 0 || zp_tiny_zone_limit != 0) &amp;&amp; !gzfreed) {
		<span class="enscript-comment">/*
		 * Poison the memory before it ends up on the freelist to catch
		 * use-after-free and use of uninitialized memory
		 *
		 * Always poison tiny zones' elements (limit is 0 if -no-zp is set)
		 * Also poison larger elements periodically
		 */</span>

		vm_offset_t     inner_size = zone-&gt;elem_size;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_DEBUG</span>
		<span class="enscript-keyword">if</span> (!gzfreed &amp;&amp; zone_debug_enabled(zone)) {
			inner_size -= ZONE_DEBUG_OFFSET;
		}
#<span class="enscript-reference">endif</span>
		uint32_t sample_factor = zp_factor + (((uint32_t)inner_size) &gt;&gt; zp_scale);

		<span class="enscript-keyword">if</span> (inner_size &lt;= zp_tiny_zone_limit)
			poison = TRUE;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (zp_factor != 0 &amp;&amp; sample_counter(&amp;zone-&gt;zp_count, sample_factor) == TRUE)
			poison = TRUE;

		<span class="enscript-keyword">if</span> (__improbable(poison)) {

			<span class="enscript-comment">/* memset_pattern{4|8} could help make this faster: &lt;rdar://problem/4662004&gt; */</span>
			<span class="enscript-comment">/* Poison everything but primary and backup */</span>
			vm_offset_t *element_cursor  = ((vm_offset_t *) elem) + 1;
			vm_offset_t *backup   = get_backup_ptr(inner_size, (vm_offset_t *)elem);

			<span class="enscript-keyword">for</span> ( ; element_cursor &lt; backup; element_cursor++)
				*element_cursor = ZP_POISON;
		}
	}

	lock_zone(zone);

	<span class="enscript-comment">/*
	 * See if we're doing logging on this zone.  There are two styles of logging used depending on
	 * whether we're trying to catch a leak or corruption.  See comments above in zalloc for details.
	 */</span>

	<span class="enscript-keyword">if</span> (__improbable(DO_LOGGING(zone))) {
		<span class="enscript-keyword">if</span> (corruption_debug_flag) {
			<span class="enscript-comment">/*
			 * We're logging to catch a corruption.  Add a record of this zfree operation
			 * to log.
			 */</span>
			btlog_add_entry(zlog_btlog, (<span class="enscript-type">void</span> *)addr, ZOP_FREE, (<span class="enscript-type">void</span> **)zbt, numsaved);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * We're logging to catch a leak. Remove any record we might have for this
			 * element since it's being freed.  Note that we may not find it if the buffer
			 * overflowed and that's OK.  Since the log is of a limited size, old records
			 * get overwritten if there are more zallocs than zfrees.
			 */</span>
			btlog_remove_entries_for_element(zlog_btlog, (<span class="enscript-type">void</span> *)addr);
		}
	}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_DEBUG</span>
	<span class="enscript-keyword">if</span> (!gzfreed &amp;&amp; zone_debug_enabled(zone)) {
		queue_t tmp_elem;

		elem -= ZONE_DEBUG_OFFSET;
		<span class="enscript-keyword">if</span> (zone_check) {
			<span class="enscript-comment">/* check the zone's consistency */</span>

			<span class="enscript-keyword">for</span> (tmp_elem = queue_first(&amp;zone-&gt;active_zones);
			     !queue_end(tmp_elem, &amp;zone-&gt;active_zones);
			     tmp_elem = queue_next(tmp_elem))
				<span class="enscript-keyword">if</span> (elem == (vm_offset_t)tmp_elem)
					<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (elem != (vm_offset_t)tmp_elem)
				panic(<span class="enscript-string">&quot;zfree()ing element from wrong zone&quot;</span>);
		}
		remqueue((queue_t) elem);
	}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* ZONE_DEBUG */</span>
	<span class="enscript-keyword">if</span> (zone_check) {
		zone_check_freelist(zone, elem);
	}

	<span class="enscript-keyword">if</span> (__probable(!gzfreed))
		free_to_zone(zone, elem, poison);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">if</span> (zone-&gt;count &lt; 0)
		panic(<span class="enscript-string">&quot;zfree: zone count underflow in zone %s while freeing element %p, possible cause: double frees or freeing memory that did not come from this zone&quot;</span>,
		zone-&gt;zone_name, addr);
#<span class="enscript-reference">endif</span>
	

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
	<span class="enscript-comment">/*
	 * Zone leak detection: un-track the allocation 
	 */</span>
	<span class="enscript-keyword">if</span> (zone-&gt;zleak_on) {
		zleak_free(elem, zone-&gt;elem_size);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>
	
	<span class="enscript-comment">/*
	 * If elements have one or more pages, and memory is low,
	 * request to run the garbage collection in the zone  the next 
	 * time the pageout thread runs.
	 */</span>
	<span class="enscript-keyword">if</span> (zone-&gt;elem_size &gt;= PAGE_SIZE &amp;&amp; 
	    vm_pool_low()){
		zone_gc_forced = TRUE;
	}
	unlock_zone(zone);

	{
		thread_t thr = current_thread();
		task_t task;
		zinfo_usage_t zinfo;
		vm_size_t sz = zone-&gt;elem_size;

		<span class="enscript-keyword">if</span> (zone-&gt;caller_acct)
			ledger_debit(thr-&gt;t_ledger, task_ledgers.tkm_private, sz);
		<span class="enscript-keyword">else</span>
			ledger_debit(thr-&gt;t_ledger, task_ledgers.tkm_shared, sz);

		<span class="enscript-keyword">if</span> ((task = thr-&gt;task) != NULL &amp;&amp; (zinfo = task-&gt;tkm_zinfo) != NULL)
			OSAddAtomic64(sz, (int64_t *)&amp;zinfo[zone-&gt;index].free);
	}
}


<span class="enscript-comment">/*	Change a zone's flags.
 *	This routine must be called immediately after zinit.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_change</span>(
	zone_t		zone,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	item,
	boolean_t	value)
{
	assert( zone != ZONE_NULL );
	assert( value == TRUE || value == FALSE );

	<span class="enscript-keyword">switch</span>(item){
	        <span class="enscript-keyword">case</span> <span class="enscript-reference">Z_NOENCRYPT</span>:
			zone-&gt;noencrypt = value;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">Z_EXHAUST</span>:
			zone-&gt;exhaustible = value;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">Z_COLLECT</span>:
			zone-&gt;collectable = value;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">Z_EXPAND</span>:
			zone-&gt;expandable = value;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">Z_FOREIGN</span>:
			zone-&gt;allows_foreign = value;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">Z_CALLERACCT</span>:
			zone-&gt;caller_acct = value;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">Z_NOCALLOUT</span>:
			zone-&gt;no_callout = value;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">Z_GZALLOC_EXEMPT</span>:
			zone-&gt;gzalloc_exempt = value;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_GZALLOC</span>
			gzalloc_reconfigure(zone);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">Z_ALIGNMENT_REQUIRED</span>:
			zone-&gt;alignment_required = value;
			<span class="enscript-comment">/*
			 * Disable the page list optimization here to provide
			 * more of an alignment guarantee. This prevents
			 * the alignment from being modified by the metadata stored
			 * at the beginning of the page.
			 */</span>
			zone-&gt;use_page_list = FALSE;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_DEBUG</span>			
			zone_debug_disable(zone);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_GZALLOC</span>
			gzalloc_reconfigure(zone);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;Zone_change: Wrong Item Type!&quot;</span>);
			<span class="enscript-comment">/* break; */</span>
	}
}

<span class="enscript-comment">/*
 * Return the expected number of free elements in the zone.
 * This calculation will be incorrect if items are zfree'd that
 * were never zalloc'd/zget'd. The correct way to stuff memory
 * into a zone is by zcram.
 */</span>

integer_t
<span class="enscript-function-name">zone_free_count</span>(zone_t zone)
{
	integer_t free_count;

	lock_zone(zone);
	free_count = zone-&gt;countfree;
	unlock_zone(zone);

	assert(free_count &gt;= 0);

	<span class="enscript-keyword">return</span>(free_count);
}

<span class="enscript-comment">/*
 *  Zone garbage collection subroutines
 */</span>

boolean_t
<span class="enscript-function-name">zone_page_collectable</span>(
	vm_offset_t	addr,
	vm_size_t	size)
{
	<span class="enscript-type">struct</span> zone_page_table_entry	*zp;
	zone_page_index_t i, j;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
	addr = zone_virtual_addr(addr);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">if</span> (!from_zone_map(addr, size))
		panic(<span class="enscript-string">&quot;zone_page_collectable&quot;</span>);
#<span class="enscript-reference">endif</span>

	i = (zone_page_index_t)atop_kernel(addr-zone_map_min_address);
	j = (zone_page_index_t)atop_kernel((addr+size-1) - zone_map_min_address);

	<span class="enscript-keyword">for</span> (; i &lt;= j; i++) {
		zp = zone_page_table_lookup(i);
		<span class="enscript-keyword">if</span> (zp-&gt;collect_count == zp-&gt;alloc_count)
			<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_page_keep</span>(
	vm_offset_t	addr,
	vm_size_t	size)
{
	<span class="enscript-type">struct</span> zone_page_table_entry	*zp;
	zone_page_index_t i, j;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
	addr = zone_virtual_addr(addr);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">if</span> (!from_zone_map(addr, size))
		panic(<span class="enscript-string">&quot;zone_page_keep&quot;</span>);
#<span class="enscript-reference">endif</span>

	i = (zone_page_index_t)atop_kernel(addr-zone_map_min_address);
	j = (zone_page_index_t)atop_kernel((addr+size-1) - zone_map_min_address);

	<span class="enscript-keyword">for</span> (; i &lt;= j; i++) {
		zp = zone_page_table_lookup(i);
		zp-&gt;collect_count = 0;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_page_collect</span>(
	vm_offset_t	addr,
	vm_size_t	size)
{
	<span class="enscript-type">struct</span> zone_page_table_entry	*zp;
	zone_page_index_t i, j;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
	addr = zone_virtual_addr(addr);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">if</span> (!from_zone_map(addr, size))
		panic(<span class="enscript-string">&quot;zone_page_collect&quot;</span>);
#<span class="enscript-reference">endif</span>

	i = (zone_page_index_t)atop_kernel(addr-zone_map_min_address);
	j = (zone_page_index_t)atop_kernel((addr+size-1) - zone_map_min_address);

	<span class="enscript-keyword">for</span> (; i &lt;= j; i++) {
		zp = zone_page_table_lookup(i);
		++zp-&gt;collect_count;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_page_init</span>(
	vm_offset_t	addr,
	vm_size_t	size)
{
	<span class="enscript-type">struct</span> zone_page_table_entry	*zp;
	zone_page_index_t i, j;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
	addr = zone_virtual_addr(addr);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">if</span> (!from_zone_map(addr, size))
		panic(<span class="enscript-string">&quot;zone_page_init&quot;</span>);
#<span class="enscript-reference">endif</span>

	i = (zone_page_index_t)atop_kernel(addr-zone_map_min_address);
	j = (zone_page_index_t)atop_kernel((addr+size-1) - zone_map_min_address);

	<span class="enscript-keyword">for</span> (; i &lt;= j; i++) {
		<span class="enscript-comment">/* make sure entry exists before marking unused */</span>
		zone_page_table_expand(i);

		zp = zone_page_table_lookup(i);
		assert(zp);
		zp-&gt;alloc_count = ZONE_PAGE_UNUSED;
		zp-&gt;collect_count = 0;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_page_alloc</span>(
	vm_offset_t	addr,
	vm_size_t	size)
{
	<span class="enscript-type">struct</span> zone_page_table_entry	*zp;
	zone_page_index_t i, j;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
	addr = zone_virtual_addr(addr);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">if</span> (!from_zone_map(addr, size))
		panic(<span class="enscript-string">&quot;zone_page_alloc&quot;</span>);
#<span class="enscript-reference">endif</span>

	i = (zone_page_index_t)atop_kernel(addr-zone_map_min_address);
	j = (zone_page_index_t)atop_kernel((addr+size-1) - zone_map_min_address);

	<span class="enscript-keyword">for</span> (; i &lt;= j; i++) {
		zp = zone_page_table_lookup(i);
		assert(zp);

		<span class="enscript-comment">/*
		 * Set alloc_count to ZONE_PAGE_USED if
		 * it was previously set to ZONE_PAGE_UNUSED.
		 */</span>
		<span class="enscript-keyword">if</span> (zp-&gt;alloc_count == ZONE_PAGE_UNUSED)
			zp-&gt;alloc_count = ZONE_PAGE_USED;

		++zp-&gt;alloc_count;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_page_free_element</span>(
	zone_page_index_t	*free_page_head,
	zone_page_index_t	*free_page_tail,
	vm_offset_t	addr,
	vm_size_t	size)
{
	<span class="enscript-type">struct</span> zone_page_table_entry	*zp;
	zone_page_index_t i, j;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
	addr = zone_virtual_addr(addr);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">if</span> (!from_zone_map(addr, size))
		panic(<span class="enscript-string">&quot;zone_page_free_element&quot;</span>);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Clear out the old next and backup pointers */</span>
	vm_offset_t *primary  = (vm_offset_t *) addr;
	vm_offset_t *backup   = get_backup_ptr(size, primary);

	*primary = ZP_POISON;
	*backup  = ZP_POISON;

	i = (zone_page_index_t)atop_kernel(addr-zone_map_min_address);
	j = (zone_page_index_t)atop_kernel((addr+size-1) - zone_map_min_address);

	<span class="enscript-keyword">for</span> (; i &lt;= j; i++) {
		zp = zone_page_table_lookup(i);

		<span class="enscript-keyword">if</span> (zp-&gt;collect_count &gt; 0)
			--zp-&gt;collect_count;
		<span class="enscript-keyword">if</span> (--zp-&gt;alloc_count == 0) {
			vm_address_t        free_page_address;
			vm_address_t        prev_free_page_address;

			zp-&gt;alloc_count  = ZONE_PAGE_UNUSED;
			zp-&gt;collect_count = 0;


			<span class="enscript-comment">/*
			 * This element was the last one on this page, re-use the page's
			 * storage for a page freelist
			 */</span>
			free_page_address = zone_map_min_address + PAGE_SIZE * ((vm_size_t)i);
			*(zone_page_index_t *)free_page_address = ZONE_PAGE_INDEX_INVALID;

			<span class="enscript-keyword">if</span> (*free_page_head == ZONE_PAGE_INDEX_INVALID) {
				*free_page_head = i;
				*free_page_tail = i;
			} <span class="enscript-keyword">else</span> {
				prev_free_page_address = zone_map_min_address + PAGE_SIZE * ((vm_size_t)(*free_page_tail));
				*(zone_page_index_t *)prev_free_page_address = i;
				*free_page_tail = i;
			}
		}
	}
}


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZONEGC_SMALL_ELEMENT_SIZE</span> 	4096

<span class="enscript-type">struct</span> {
	uint64_t	zgc_invoked;
	uint64_t	zgc_bailed;
	uint32_t	pgs_freed;

	uint32_t	elems_collected,
				elems_freed,
				elems_kept;
} zgc_stats;

<span class="enscript-comment">/*	Zone garbage collection
 *
 *	zone_gc will walk through all the free elements in all the
 *	zones that are marked collectable looking for reclaimable
 *	pages.  zone_gc is called by consider_zone_gc when the system
 *	begins to run out of memory.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_gc</span>(boolean_t all_zones)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	max_zones;
	zone_t			z;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;
	uint32_t 	old_pgs_freed;
	zone_page_index_t zone_free_page_head;
	zone_page_index_t zone_free_page_tail;
	thread_t	mythread = current_thread();

	lck_mtx_lock(&amp;zone_gc_lock);

	zgc_stats.zgc_invoked++;
	old_pgs_freed = zgc_stats.pgs_freed;

	simple_lock(&amp;all_zones_lock);
	max_zones = num_zones;
	z = first_zone;
	simple_unlock(&amp;all_zones_lock);

	<span class="enscript-keyword">if</span> (zalloc_debug &amp; ZALLOC_DEBUG_ZONEGC)
		kprintf(<span class="enscript-string">&quot;zone_gc(all_zones=%s) starting...\n&quot;</span>, all_zones ? <span class="enscript-string">&quot;TRUE&quot;</span> : <span class="enscript-string">&quot;FALSE&quot;</span>);

	<span class="enscript-comment">/*
	 * it's ok to allow eager kernel preemption while
	 * while holding a zone lock since it's taken
	 * as a spin lock (which prevents preemption)
	 */</span>
	thread_set_eager_preempt(mythread);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; zone_pages; i++) {
		<span class="enscript-type">struct</span> zone_page_table_entry	*zp;
	
		zp = zone_page_table_lookup(i);
		assert(!zp || (zp-&gt;collect_count == 0));
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>

	<span class="enscript-keyword">for</span> (i = 0; i &lt; max_zones; i++, z = z-&gt;next_zone) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			n, m;
		vm_size_t			elt_size, size_freed;
		<span class="enscript-type">struct</span> zone_free_element	*elt, *base_elt, *base_prev, *prev, *scan, *keep, *tail;
		<span class="enscript-type">int</span>				kmem_frees = 0, total_freed_pages = 0;
		<span class="enscript-type">struct</span> zone_page_metadata		*page_meta;
		queue_head_t	page_meta_head;

		assert(z != ZONE_NULL);

		<span class="enscript-keyword">if</span> (!z-&gt;collectable)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (all_zones == FALSE &amp;&amp; z-&gt;elem_size &lt; ZONEGC_SMALL_ELEMENT_SIZE &amp;&amp; !z-&gt;use_page_list)
			<span class="enscript-keyword">continue</span>;

		lock_zone(z);

		elt_size = z-&gt;elem_size;

		<span class="enscript-comment">/*
		 * Do a quick feasibility check before we scan the zone: 
		 * skip unless there is likelihood of getting pages back
		 * (i.e we need a whole allocation block's worth of free
		 * elements before we can garbage collect) and
		 * the zone has more than 10 percent of it's elements free
		 * or the element size is a multiple of the PAGE_SIZE 
		 */</span>
		<span class="enscript-keyword">if</span> ((elt_size &amp; PAGE_MASK) &amp;&amp; 
		    !z-&gt;use_page_list &amp;&amp;
		     (((z-&gt;cur_size - z-&gt;count * elt_size) &lt;= (2 * z-&gt;alloc_size)) ||
		      ((z-&gt;cur_size - z-&gt;count * elt_size) &lt;= (z-&gt;cur_size / 10)))) {
			unlock_zone(z);		
			<span class="enscript-keyword">continue</span>;
		}

		z-&gt;doing_gc = TRUE;

		<span class="enscript-comment">/*
		 * Snatch all of the free elements away from the zone.
		 */</span>

		<span class="enscript-keyword">if</span> (z-&gt;use_page_list) {
			queue_new_head(&amp;z-&gt;pages.all_free, &amp;page_meta_head, <span class="enscript-type">struct</span> zone_page_metadata *, pages);
			queue_init(&amp;z-&gt;pages.all_free);
		} <span class="enscript-keyword">else</span> {
			scan = (<span class="enscript-type">void</span> *)z-&gt;free_elements;
			z-&gt;free_elements = 0;
		}

		unlock_zone(z);

		<span class="enscript-keyword">if</span> (z-&gt;use_page_list) {
			<span class="enscript-comment">/*
			 * For zones that maintain page lists (which in turn
			 * track free elements on those pages), zone_gc()
			 * is incredibly easy, and we bypass all the logic
			 * for scanning elements and mapping them to
			 * collectable pages
			 */</span>

			size_freed = 0;

			queue_iterate(&amp;page_meta_head, page_meta, <span class="enscript-type">struct</span> zone_page_metadata *, pages) {
				assert(from_zone_map((vm_address_t)page_meta, <span class="enscript-keyword">sizeof</span>(*page_meta))); <span class="enscript-comment">/* foreign elements should be in any_free_foreign */</span>

				zgc_stats.elems_freed += page_meta-&gt;free_count;
				size_freed += elt_size * page_meta-&gt;free_count;
				zgc_stats.elems_collected += page_meta-&gt;free_count;
			}
			
			lock_zone(z);

			<span class="enscript-keyword">if</span> (size_freed &gt; 0) {
				z-&gt;cur_size -= size_freed;
				z-&gt;countfree -= size_freed/elt_size;
			}

			z-&gt;doing_gc = FALSE;
			<span class="enscript-keyword">if</span> (z-&gt;waiting) {
				z-&gt;waiting = FALSE;
				zone_wakeup(z);
			}

			unlock_zone(z);

			<span class="enscript-keyword">if</span> (queue_empty(&amp;page_meta_head))
				<span class="enscript-keyword">continue</span>;

			thread_clear_eager_preempt(mythread);

			<span class="enscript-keyword">while</span> ((page_meta = (<span class="enscript-type">struct</span> zone_page_metadata *)dequeue_head(&amp;page_meta_head)) != NULL) {
				vm_address_t		free_page_address;

				free_page_address = trunc_page((vm_address_t)page_meta);
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_ALIAS_ADDR</span>
				free_page_address = zone_virtual_addr(free_page_address);
#<span class="enscript-reference">endif</span>
				kmem_free(zone_map, free_page_address, PAGE_SIZE);
				ZONE_PAGE_COUNT_DECR(z, 1);
				total_freed_pages++;
				zgc_stats.pgs_freed += 1;
				
				<span class="enscript-keyword">if</span> (++kmem_frees == 32) {
					thread_yield_internal(1);
					kmem_frees = 0;
				}
			}

			<span class="enscript-keyword">if</span> (zalloc_debug &amp; ZALLOC_DEBUG_ZONEGC)
				kprintf(<span class="enscript-string">&quot;zone_gc() of zone %s freed %lu elements, %d pages\n&quot;</span>, z-&gt;zone_name, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)size_freed/elt_size, total_freed_pages);

			thread_set_eager_preempt(mythread);
			<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* go to next zone */</span>
		}

		<span class="enscript-comment">/*
		 * Pass 1:
		 *
		 * Determine which elements we can attempt to collect
		 * and count them up in the page table.  Foreign elements
		 * are returned to the zone.
		 */</span>

		prev = (<span class="enscript-type">void</span> *)&amp;scan;
		elt = scan;
		n = 0; tail = keep = NULL;

		zone_free_page_head = ZONE_PAGE_INDEX_INVALID;
		zone_free_page_tail = ZONE_PAGE_INDEX_INVALID;


		<span class="enscript-keyword">while</span> (elt != NULL) {
			<span class="enscript-keyword">if</span> (from_zone_map(elt, elt_size)) {
				zone_page_collect((vm_offset_t)elt, elt_size);

				prev = elt;
				elt = elt-&gt;next;

				++zgc_stats.elems_collected;
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (keep == NULL)
					keep = tail = elt;
				<span class="enscript-keyword">else</span> {
					append_zone_element(z, tail, elt);
					tail = elt;
				}

				append_zone_element(z, prev, elt-&gt;next);
				elt = elt-&gt;next;
				append_zone_element(z, tail, NULL);
			}

			<span class="enscript-comment">/*
			 * Dribble back the elements we are keeping.
			 * If there are none, give some elements that we haven't looked at yet
			 * back to the freelist so that others waiting on the zone don't get stuck
			 * for too long.  This might prevent us from recovering some memory,
			 * but allows us to avoid having to allocate new memory to serve requests
			 * while zone_gc has all the free memory tied up.
			 * &lt;rdar://problem/3893406&gt;
			 */</span>

			<span class="enscript-keyword">if</span> (++n &gt;= 50) {
				<span class="enscript-keyword">if</span> (z-&gt;waiting == TRUE) {
					<span class="enscript-comment">/* z-&gt;waiting checked without lock held, rechecked below after locking */</span>
					lock_zone(z);

					<span class="enscript-keyword">if</span> (keep != NULL) {
						add_list_to_zone(z, keep, tail);
						tail = keep = NULL;
					} <span class="enscript-keyword">else</span> {
						m =0;
						base_elt = elt;
						base_prev = prev;
						<span class="enscript-keyword">while</span> ((elt != NULL) &amp;&amp; (++m &lt; 50)) { 
							prev = elt;
							elt = elt-&gt;next;
						}
						<span class="enscript-keyword">if</span> (m !=0 ) {
							<span class="enscript-comment">/* Extract the elements from the list and
							 * give them back */</span>
							append_zone_element(z, prev, NULL);
							add_list_to_zone(z, base_elt, prev);
							append_zone_element(z, base_prev, elt);
							prev = base_prev;
						}
					}

					<span class="enscript-keyword">if</span> (z-&gt;waiting) {
						z-&gt;waiting = FALSE;
						zone_wakeup(z);
					}

					unlock_zone(z);
				}
				n =0;
			}
		}

		<span class="enscript-comment">/*
		 * Return any remaining elements.
		 */</span>

		<span class="enscript-keyword">if</span> (keep != NULL) {
			lock_zone(z);

			add_list_to_zone(z, keep, tail);

			<span class="enscript-keyword">if</span> (z-&gt;waiting) {
				z-&gt;waiting = FALSE;
				zone_wakeup(z);
			}

			unlock_zone(z);
		}

		<span class="enscript-comment">/*
		 * Pass 2:
		 *
		 * Determine which pages we can reclaim and
		 * free those elements.
		 */</span>

		size_freed = 0;
		elt = scan;
		n = 0; tail = keep = NULL;

		<span class="enscript-keyword">while</span> (elt != NULL) {
			<span class="enscript-keyword">if</span> (zone_page_collectable((vm_offset_t)elt, elt_size)) {
				<span class="enscript-type">struct</span> zone_free_element *next_elt = elt-&gt;next;

				size_freed += elt_size;

				<span class="enscript-comment">/*
				 * If this is the last allocation on the page(s),
				 * we may use their storage to maintain the linked
				 * list of free-able pages. So store elt-&gt;next because
				 * &quot;elt&quot; may be scribbled over.
				 */</span>
				zone_page_free_element(&amp;zone_free_page_head, &amp;zone_free_page_tail, (vm_offset_t)elt, elt_size);

				elt = next_elt;

				++zgc_stats.elems_freed;
			}
			<span class="enscript-keyword">else</span> {
				zone_page_keep((vm_offset_t)elt, elt_size);

				<span class="enscript-keyword">if</span> (keep == NULL)
					keep = tail = elt;
				<span class="enscript-keyword">else</span> {
					append_zone_element(z, tail, elt);
					tail = elt;
				}

				elt = elt-&gt;next;
				append_zone_element(z, tail, NULL);

				++zgc_stats.elems_kept;
			}

			<span class="enscript-comment">/*
			 * Dribble back the elements we are keeping,
			 * and update the zone size info.
			 */</span>

			<span class="enscript-keyword">if</span> (++n &gt;= 50) {
				lock_zone(z);

				z-&gt;cur_size -= size_freed;
				z-&gt;countfree -= size_freed/elt_size;
				size_freed = 0;

				<span class="enscript-keyword">if</span> (keep != NULL) {
					add_list_to_zone(z, keep, tail);
				}

				<span class="enscript-keyword">if</span> (z-&gt;waiting) {
					z-&gt;waiting = FALSE;
					zone_wakeup(z);
				}

				unlock_zone(z);

				n = 0; tail = keep = NULL;
			}
		}

		<span class="enscript-comment">/*
		 * Return any remaining elements, and update
		 * the zone size info.
		 */</span>

		lock_zone(z);

		<span class="enscript-keyword">if</span> (size_freed &gt; 0 || keep != NULL) {

			z-&gt;cur_size -= size_freed;
			z-&gt;countfree -= size_freed/elt_size;

			<span class="enscript-keyword">if</span> (keep != NULL) {
				add_list_to_zone(z, keep, tail);
			}

		}

		z-&gt;doing_gc = FALSE;
		<span class="enscript-keyword">if</span> (z-&gt;waiting) {
			z-&gt;waiting = FALSE;
			zone_wakeup(z);
		}
		unlock_zone(z);

		<span class="enscript-keyword">if</span> (zone_free_page_head == ZONE_PAGE_INDEX_INVALID)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * we don't want to allow eager kernel preemption while holding the
		 * various locks taken in the kmem_free path of execution
		 */</span>
		thread_clear_eager_preempt(mythread);


		<span class="enscript-comment">/*
		 * This loop counts the number of pages that should be freed by the
		 * next loop that tries to coalesce the kmem_frees()
		 */</span>
		uint32_t pages_to_free_count = 0;
		vm_address_t		fpa;
		zone_page_index_t index;
		<span class="enscript-keyword">for</span> (index = zone_free_page_head; index != ZONE_PAGE_INDEX_INVALID;) {
			pages_to_free_count++;
			fpa = zone_map_min_address + PAGE_SIZE * ((vm_size_t)index);
			index = *(zone_page_index_t *)fpa;
		}

		<span class="enscript-comment">/*
		 * Reclaim the pages we are freeing.
		 */</span>
		<span class="enscript-keyword">while</span> (zone_free_page_head != ZONE_PAGE_INDEX_INVALID) {
			zone_page_index_t	zind = zone_free_page_head;
			vm_address_t		free_page_address;
			<span class="enscript-type">int</span>			page_count;

			<span class="enscript-comment">/*
			 * Use the first word of the page about to be freed to find the next free page
			 */</span>
			free_page_address = zone_map_min_address + PAGE_SIZE * ((vm_size_t)zind);
			zone_free_page_head = *(zone_page_index_t *)free_page_address;

			page_count = 1;
			total_freed_pages++;

			<span class="enscript-keyword">while</span> (zone_free_page_head != ZONE_PAGE_INDEX_INVALID) {
				zone_page_index_t	next_zind = zone_free_page_head;
				vm_address_t		next_free_page_address;

				next_free_page_address = zone_map_min_address + PAGE_SIZE * ((vm_size_t)next_zind);

				<span class="enscript-keyword">if</span> (next_free_page_address == (free_page_address - PAGE_SIZE)) {
					free_page_address = next_free_page_address;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (next_free_page_address != (free_page_address + (PAGE_SIZE * page_count)))
					<span class="enscript-keyword">break</span>;

				zone_free_page_head = *(zone_page_index_t *)next_free_page_address;
				page_count++;
				total_freed_pages++;
			}
			kmem_free(zone_map, free_page_address, page_count * PAGE_SIZE);
			ZONE_PAGE_COUNT_DECR(z, page_count);
			zgc_stats.pgs_freed += page_count;
			pages_to_free_count -= page_count;

			<span class="enscript-keyword">if</span> (++kmem_frees == 32) {
				thread_yield_internal(1);
				kmem_frees = 0;
			}
		}

		<span class="enscript-comment">/* Check that we actually free the exact number of pages we were supposed to */</span>
		assert(pages_to_free_count == 0);

		<span class="enscript-keyword">if</span> (zalloc_debug &amp; ZALLOC_DEBUG_ZONEGC)
			kprintf(<span class="enscript-string">&quot;zone_gc() of zone %s freed %lu elements, %d pages\n&quot;</span>, z-&gt;zone_name, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)size_freed/elt_size, total_freed_pages);

		thread_set_eager_preempt(mythread);
	}

	<span class="enscript-keyword">if</span> (old_pgs_freed == zgc_stats.pgs_freed)
		zgc_stats.zgc_bailed++;

	thread_clear_eager_preempt(mythread);

	lck_mtx_unlock(&amp;zone_gc_lock);

}

<span class="enscript-type">extern</span> vm_offset_t kmapoff_kaddr;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> kmapoff_pgcnt;

<span class="enscript-comment">/*
 *	consider_zone_gc:
 *
 *	Called by the pageout daemon when the system needs more free pages.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">consider_zone_gc</span>(boolean_t force)
{
	boolean_t all_zones = FALSE;

	<span class="enscript-keyword">if</span> (kmapoff_kaddr != 0) {
		<span class="enscript-comment">/*
		 * One-time reclaim of kernel_map resources we allocated in
		 * early boot.
		 */</span>
		(<span class="enscript-type">void</span>) vm_deallocate(kernel_map,
		    kmapoff_kaddr, kmapoff_pgcnt * PAGE_SIZE_64);
		kmapoff_kaddr = 0;
	}

	<span class="enscript-keyword">if</span> (zone_gc_allowed &amp;&amp;
	    (zone_gc_allowed_by_time_throttle ||
	     zone_gc_forced ||
	     force)) {
		<span class="enscript-keyword">if</span> (zone_gc_allowed_by_time_throttle == TRUE) {
			zone_gc_allowed_by_time_throttle = FALSE;
			all_zones = TRUE;
		}
		zone_gc_forced = FALSE;

		zone_gc(all_zones);
	}
}

<span class="enscript-comment">/*
 *	By default, don't attempt zone GC more frequently
 *	than once / 1 minutes.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">compute_zone_gc_throttle</span>(<span class="enscript-type">void</span> *arg __unused)
{
	zone_gc_allowed_by_time_throttle = TRUE;
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TASK_ZONE_INFO</span>

kern_return_t
<span class="enscript-function-name">task_zone_info</span>(
	task_t			task,
	mach_zone_name_array_t	*namesp,
	mach_msg_type_number_t  *namesCntp,
	task_zone_info_array_t	*infop,
	mach_msg_type_number_t  *infoCntp)
{
	mach_zone_name_t	*names;
	vm_offset_t		names_addr;
	vm_size_t		names_size;
	task_zone_info_t	*info;
	vm_offset_t		info_addr;
	vm_size_t		info_size;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		max_zones, i;
	zone_t			z;
	mach_zone_name_t	*zn;
	task_zone_info_t    	*zi;
	kern_return_t		kr;

	vm_size_t		used;
	vm_map_copy_t		copy;


	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_TASK;

	<span class="enscript-comment">/*
	 *	We assume that zones aren't freed once allocated.
	 *	We won't pick up any zones that are allocated later.
	 */</span>

	simple_lock(&amp;all_zones_lock);
	max_zones = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(num_zones + num_fake_zones);
	z = first_zone;
	simple_unlock(&amp;all_zones_lock);

	names_size = round_page(max_zones * <span class="enscript-keyword">sizeof</span> *names);
	kr = kmem_alloc_pageable(ipc_kernel_map,
				 &amp;names_addr, names_size, VM_KERN_MEMORY_IPC);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	names = (mach_zone_name_t *) names_addr;

	info_size = round_page(max_zones * <span class="enscript-keyword">sizeof</span> *info);
	kr = kmem_alloc_pageable(ipc_kernel_map,
				 &amp;info_addr, info_size, VM_KERN_MEMORY_IPC);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		kmem_free(ipc_kernel_map,
			  names_addr, names_size);
		<span class="enscript-keyword">return</span> kr;
	}

	info = (task_zone_info_t *) info_addr;

	zn = &amp;names[0];
	zi = &amp;info[0];

	<span class="enscript-keyword">for</span> (i = 0; i &lt; max_zones - num_fake_zones; i++) {
		<span class="enscript-type">struct</span> zone zcopy;

		assert(z != ZONE_NULL);

		lock_zone(z);
		zcopy = *z;
		unlock_zone(z);

		simple_lock(&amp;all_zones_lock);
		z = z-&gt;next_zone;
		simple_unlock(&amp;all_zones_lock);

		<span class="enscript-comment">/* assuming here the name data is static */</span>
		(<span class="enscript-type">void</span>) strncpy(zn-&gt;mzn_name, zcopy.zone_name,
			       <span class="enscript-keyword">sizeof</span> zn-&gt;mzn_name);
		zn-&gt;mzn_name[<span class="enscript-keyword">sizeof</span> zn-&gt;mzn_name - 1] = <span class="enscript-string">'\0'</span>;

		zi-&gt;tzi_count = (uint64_t)zcopy.count;
		zi-&gt;tzi_cur_size = ptoa_64(zcopy.page_count);
		zi-&gt;tzi_max_size = (uint64_t)zcopy.max_size;
		zi-&gt;tzi_elem_size = (uint64_t)zcopy.elem_size;
		zi-&gt;tzi_alloc_size = (uint64_t)zcopy.alloc_size;
		zi-&gt;tzi_sum_size = zcopy.sum_count * zcopy.elem_size;
		zi-&gt;tzi_exhaustible = (uint64_t)zcopy.exhaustible;
		zi-&gt;tzi_collectable = (uint64_t)zcopy.collectable;
		zi-&gt;tzi_caller_acct = (uint64_t)zcopy.caller_acct;
		<span class="enscript-keyword">if</span> (task-&gt;tkm_zinfo != NULL) {
			zi-&gt;tzi_task_alloc = task-&gt;tkm_zinfo[zcopy.index].alloc;
			zi-&gt;tzi_task_free = task-&gt;tkm_zinfo[zcopy.index].free;
		} <span class="enscript-keyword">else</span> {
			zi-&gt;tzi_task_alloc = 0;
			zi-&gt;tzi_task_free = 0;
		}
		zn++;
		zi++;
	}

	<span class="enscript-comment">/*
	 * loop through the fake zones and fill them using the specialized
	 * functions
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; num_fake_zones; i++) {
		<span class="enscript-type">int</span> count, collectable, exhaustible, caller_acct, index;
		vm_size_t cur_size, max_size, elem_size, alloc_size;
		uint64_t sum_size;

		strncpy(zn-&gt;mzn_name, fake_zones[i].name, <span class="enscript-keyword">sizeof</span> zn-&gt;mzn_name);
		zn-&gt;mzn_name[<span class="enscript-keyword">sizeof</span> zn-&gt;mzn_name - 1] = <span class="enscript-string">'\0'</span>;
		fake_zones[i].query(&amp;count, &amp;cur_size,
				    &amp;max_size, &amp;elem_size,
				    &amp;alloc_size, &amp;sum_size,
				    &amp;collectable, &amp;exhaustible, &amp;caller_acct);
		zi-&gt;tzi_count = (uint64_t)count;
		zi-&gt;tzi_cur_size = (uint64_t)cur_size;
		zi-&gt;tzi_max_size = (uint64_t)max_size;
		zi-&gt;tzi_elem_size = (uint64_t)elem_size;
		zi-&gt;tzi_alloc_size = (uint64_t)alloc_size;
		zi-&gt;tzi_sum_size = sum_size;
		zi-&gt;tzi_collectable = (uint64_t)collectable;
		zi-&gt;tzi_exhaustible = (uint64_t)exhaustible;
		zi-&gt;tzi_caller_acct = (uint64_t)caller_acct;
		<span class="enscript-keyword">if</span> (task-&gt;tkm_zinfo != NULL) {
			index = ZINFO_SLOTS - num_fake_zones + i;
			zi-&gt;tzi_task_alloc = task-&gt;tkm_zinfo[index].alloc;
			zi-&gt;tzi_task_free = task-&gt;tkm_zinfo[index].free;
		} <span class="enscript-keyword">else</span> {
			zi-&gt;tzi_task_alloc = 0;
			zi-&gt;tzi_task_free = 0;
		}
		zn++;
		zi++;
	}

	used = max_zones * <span class="enscript-keyword">sizeof</span> *names;
	<span class="enscript-keyword">if</span> (used != names_size)
		bzero((<span class="enscript-type">char</span> *) (names_addr + used), names_size - used);

	kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)names_addr,
			   (vm_map_size_t)names_size, TRUE, &amp;copy);
	assert(kr == KERN_SUCCESS);

	*namesp = (mach_zone_name_t *) copy;
	*namesCntp = max_zones;

	used = max_zones * <span class="enscript-keyword">sizeof</span> *info;

	<span class="enscript-keyword">if</span> (used != info_size)
		bzero((<span class="enscript-type">char</span> *) (info_addr + used), info_size - used);

	kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)info_addr,
			   (vm_map_size_t)info_size, TRUE, &amp;copy);
	assert(kr == KERN_SUCCESS);

	*infop = (task_zone_info_t *) copy;
	*infoCntp = max_zones;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* CONFIG_TASK_ZONE_INFO */</span>

kern_return_t
<span class="enscript-function-name">task_zone_info</span>(
	__unused task_t		task,
	__unused mach_zone_name_array_t *namesp,
	__unused mach_msg_type_number_t *namesCntp,
	__unused task_zone_info_array_t *infop,
	__unused mach_msg_type_number_t *infoCntp)
{
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONFIG_TASK_ZONE_INFO */</span>

kern_return_t
<span class="enscript-function-name">mach_zone_info</span>(
	host_priv_t		host,
	mach_zone_name_array_t	*namesp,
	mach_msg_type_number_t  *namesCntp,
	mach_zone_info_array_t	*infop,
	mach_msg_type_number_t  *infoCntp)
{
	<span class="enscript-keyword">return</span> (mach_memory_info(host, namesp, namesCntp, infop, infoCntp, NULL, NULL));
}

kern_return_t
<span class="enscript-function-name">mach_memory_info</span>(
	host_priv_t		host,
	mach_zone_name_array_t	*namesp,
	mach_msg_type_number_t  *namesCntp,
	mach_zone_info_array_t	*infop,
	mach_msg_type_number_t  *infoCntp,
	mach_memory_info_array_t *memoryInfop,
	mach_msg_type_number_t   *memoryInfoCntp)
{
	mach_zone_name_t	*names;
	vm_offset_t		names_addr;
	vm_size_t		names_size;

	mach_zone_info_t	*info;
	vm_offset_t		info_addr;
	vm_size_t		info_size;

	mach_memory_info_t	*memory_info;
	vm_offset_t		memory_info_addr;
	vm_size_t		memory_info_size;
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		num_sites;

	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		max_zones, i;
	zone_t			z;
	mach_zone_name_t	*zn;
	mach_zone_info_t    	*zi;
	kern_return_t		kr;
	
	vm_size_t		used;
	vm_map_copy_t		copy;


	<span class="enscript-keyword">if</span> (host == HOST_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_HOST;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DEBUGGER_FOR_ZONE_INFO</span>
	<span class="enscript-keyword">if</span> (!PE_i_can_has_debugger(NULL))
		<span class="enscript-keyword">return</span> KERN_INVALID_HOST;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 *	We assume that zones aren't freed once allocated.
	 *	We won't pick up any zones that are allocated later.
	 */</span>

	simple_lock(&amp;all_zones_lock);
	max_zones = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(num_zones + num_fake_zones);
	z = first_zone;
	simple_unlock(&amp;all_zones_lock);

	names_size = round_page(max_zones * <span class="enscript-keyword">sizeof</span> *names);
	kr = kmem_alloc_pageable(ipc_kernel_map,
				 &amp;names_addr, names_size, VM_KERN_MEMORY_IPC);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	names = (mach_zone_name_t *) names_addr;

	info_size = round_page(max_zones * <span class="enscript-keyword">sizeof</span> *info);
	kr = kmem_alloc_pageable(ipc_kernel_map,
				 &amp;info_addr, info_size, VM_KERN_MEMORY_IPC);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		kmem_free(ipc_kernel_map,
			  names_addr, names_size);
		<span class="enscript-keyword">return</span> kr;
	}
	info = (mach_zone_info_t *) info_addr;

	num_sites = 0;
	memory_info_addr = 0;
	<span class="enscript-keyword">if</span> (memoryInfop &amp;&amp; memoryInfoCntp)
	{
		num_sites = VM_KERN_MEMORY_COUNT + VM_KERN_COUNTER_COUNT;
		memory_info_size = round_page(num_sites * <span class="enscript-keyword">sizeof</span> *info);
		kr = kmem_alloc_pageable(ipc_kernel_map,
					 &amp;memory_info_addr, memory_info_size, VM_KERN_MEMORY_IPC);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			kmem_free(ipc_kernel_map,
				  names_addr, names_size);
			kmem_free(ipc_kernel_map,
				  info_addr, info_size);
			<span class="enscript-keyword">return</span> kr;
		}

		kr = vm_map_wire(ipc_kernel_map, memory_info_addr, memory_info_addr + memory_info_size,
				     VM_PROT_READ|VM_PROT_WRITE|VM_PROT_MEMORY_TAG_MAKE(VM_KERN_MEMORY_IPC), FALSE);
		assert(kr == KERN_SUCCESS);

		memory_info = (mach_memory_info_t *) memory_info_addr;
		vm_page_diagnose(memory_info, num_sites);

		kr = vm_map_unwire(ipc_kernel_map, memory_info_addr, memory_info_addr + memory_info_size, FALSE);
		assert(kr == KERN_SUCCESS);
	}

	zn = &amp;names[0];
	zi = &amp;info[0];

	<span class="enscript-keyword">for</span> (i = 0; i &lt; max_zones - num_fake_zones; i++) {
		<span class="enscript-type">struct</span> zone zcopy;

		assert(z != ZONE_NULL);

		lock_zone(z);
		zcopy = *z;
		unlock_zone(z);

		simple_lock(&amp;all_zones_lock);
		z = z-&gt;next_zone;
		simple_unlock(&amp;all_zones_lock);

		<span class="enscript-comment">/* assuming here the name data is static */</span>
		(<span class="enscript-type">void</span>) strncpy(zn-&gt;mzn_name, zcopy.zone_name,
			       <span class="enscript-keyword">sizeof</span> zn-&gt;mzn_name);
		zn-&gt;mzn_name[<span class="enscript-keyword">sizeof</span> zn-&gt;mzn_name - 1] = <span class="enscript-string">'\0'</span>;

		zi-&gt;mzi_count = (uint64_t)zcopy.count;
		zi-&gt;mzi_cur_size = ptoa_64(zcopy.page_count);
		zi-&gt;mzi_max_size = (uint64_t)zcopy.max_size;
		zi-&gt;mzi_elem_size = (uint64_t)zcopy.elem_size;
		zi-&gt;mzi_alloc_size = (uint64_t)zcopy.alloc_size;
		zi-&gt;mzi_sum_size = zcopy.sum_count * zcopy.elem_size;
		zi-&gt;mzi_exhaustible = (uint64_t)zcopy.exhaustible;
		zi-&gt;mzi_collectable = (uint64_t)zcopy.collectable;
		zn++;
		zi++;
	}

	<span class="enscript-comment">/*
	 * loop through the fake zones and fill them using the specialized
	 * functions
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; num_fake_zones; i++) {
		<span class="enscript-type">int</span> count, collectable, exhaustible, caller_acct;
		vm_size_t cur_size, max_size, elem_size, alloc_size;
		uint64_t sum_size;

		strncpy(zn-&gt;mzn_name, fake_zones[i].name, <span class="enscript-keyword">sizeof</span> zn-&gt;mzn_name);
		zn-&gt;mzn_name[<span class="enscript-keyword">sizeof</span> zn-&gt;mzn_name - 1] = <span class="enscript-string">'\0'</span>;
		fake_zones[i].query(&amp;count, &amp;cur_size,
				    &amp;max_size, &amp;elem_size,
				    &amp;alloc_size, &amp;sum_size,
				    &amp;collectable, &amp;exhaustible, &amp;caller_acct);
		zi-&gt;mzi_count = (uint64_t)count;
		zi-&gt;mzi_cur_size = (uint64_t)cur_size;
		zi-&gt;mzi_max_size = (uint64_t)max_size;
		zi-&gt;mzi_elem_size = (uint64_t)elem_size;
		zi-&gt;mzi_alloc_size = (uint64_t)alloc_size;
		zi-&gt;mzi_sum_size = sum_size;
		zi-&gt;mzi_collectable = (uint64_t)collectable;
		zi-&gt;mzi_exhaustible = (uint64_t)exhaustible;

		zn++;
		zi++;
	}

	used = max_zones * <span class="enscript-keyword">sizeof</span> *names;
	<span class="enscript-keyword">if</span> (used != names_size)
		bzero((<span class="enscript-type">char</span> *) (names_addr + used), names_size - used);

	kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)names_addr,
			   (vm_map_size_t)names_size, TRUE, &amp;copy);
	assert(kr == KERN_SUCCESS);

	*namesp = (mach_zone_name_t *) copy;
	*namesCntp = max_zones;

	used = max_zones * <span class="enscript-keyword">sizeof</span> *info;

	<span class="enscript-keyword">if</span> (used != info_size)
		bzero((<span class="enscript-type">char</span> *) (info_addr + used), info_size - used);

	kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)info_addr,
			   (vm_map_size_t)info_size, TRUE, &amp;copy);
	assert(kr == KERN_SUCCESS);

	*infop = (mach_zone_info_t *) copy;
	*infoCntp = max_zones;

	<span class="enscript-keyword">if</span> (memoryInfop &amp;&amp; memoryInfoCntp)
	{
		kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)memory_info_addr,
				   (vm_map_size_t)memory_info_size, TRUE, &amp;copy);
		assert(kr == KERN_SUCCESS);

		*memoryInfop = (mach_memory_info_t *) copy;
		*memoryInfoCntp = num_sites;
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 * host_zone_info - LEGACY user interface for Mach zone information
 * 		    Should use mach_zone_info() instead!
 */</span>
kern_return_t
<span class="enscript-function-name">host_zone_info</span>(
	host_priv_t		host,
	zone_name_array_t	*namesp,
	mach_msg_type_number_t  *namesCntp,
	zone_info_array_t	*infop,
	mach_msg_type_number_t  *infoCntp)
{
	zone_name_t	*names;
	vm_offset_t	names_addr;
	vm_size_t	names_size;
	zone_info_t	*info;
	vm_offset_t	info_addr;
	vm_size_t	info_size;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	max_zones, i;
	zone_t		z;
	zone_name_t    *zn;
	zone_info_t    *zi;
	kern_return_t	kr;

	vm_size_t	used;
	vm_map_copy_t	copy;


	<span class="enscript-keyword">if</span> (host == HOST_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_HOST;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DEBUGGER_FOR_ZONE_INFO</span>
	<span class="enscript-keyword">if</span> (!PE_i_can_has_debugger(NULL))
		<span class="enscript-keyword">return</span> KERN_INVALID_HOST;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	<span class="enscript-keyword">if</span> (!thread_is_64bit(current_thread()))
		<span class="enscript-keyword">return</span> KERN_NOT_SUPPORTED;
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (thread_is_64bit(current_thread()))
		<span class="enscript-keyword">return</span> KERN_NOT_SUPPORTED;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 *	We assume that zones aren't freed once allocated.
	 *	We won't pick up any zones that are allocated later.
	 */</span>

	simple_lock(&amp;all_zones_lock);
	max_zones = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(num_zones + num_fake_zones);
	z = first_zone;
	simple_unlock(&amp;all_zones_lock);

	names_size = round_page(max_zones * <span class="enscript-keyword">sizeof</span> *names);
	kr = kmem_alloc_pageable(ipc_kernel_map,
				 &amp;names_addr, names_size, VM_KERN_MEMORY_IPC);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	names = (zone_name_t *) names_addr;

	info_size = round_page(max_zones * <span class="enscript-keyword">sizeof</span> *info);
	kr = kmem_alloc_pageable(ipc_kernel_map,
				 &amp;info_addr, info_size, VM_KERN_MEMORY_IPC);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		kmem_free(ipc_kernel_map,
			  names_addr, names_size);
		<span class="enscript-keyword">return</span> kr;
	}

	info = (zone_info_t *) info_addr;

	zn = &amp;names[0];
	zi = &amp;info[0];

	<span class="enscript-keyword">for</span> (i = 0; i &lt; max_zones - num_fake_zones; i++) {
		<span class="enscript-type">struct</span> zone zcopy;

		assert(z != ZONE_NULL);

		lock_zone(z);
		zcopy = *z;
		unlock_zone(z);

		simple_lock(&amp;all_zones_lock);
		z = z-&gt;next_zone;
		simple_unlock(&amp;all_zones_lock);

		<span class="enscript-comment">/* assuming here the name data is static */</span>
		(<span class="enscript-type">void</span>) strncpy(zn-&gt;zn_name, zcopy.zone_name,
			       <span class="enscript-keyword">sizeof</span> zn-&gt;zn_name);
		zn-&gt;zn_name[<span class="enscript-keyword">sizeof</span> zn-&gt;zn_name - 1] = <span class="enscript-string">'\0'</span>;

		zi-&gt;zi_count = zcopy.count;
		zi-&gt;zi_cur_size = ptoa(zcopy.page_count);
		zi-&gt;zi_max_size = zcopy.max_size;
		zi-&gt;zi_elem_size = zcopy.elem_size;
		zi-&gt;zi_alloc_size = zcopy.alloc_size;
		zi-&gt;zi_exhaustible = zcopy.exhaustible;
		zi-&gt;zi_collectable = zcopy.collectable;

		zn++;
		zi++;
	}

	<span class="enscript-comment">/*
	 * loop through the fake zones and fill them using the specialized
	 * functions
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; num_fake_zones; i++) {
		<span class="enscript-type">int</span> caller_acct;
		uint64_t sum_space;
		strncpy(zn-&gt;zn_name, fake_zones[i].name, <span class="enscript-keyword">sizeof</span> zn-&gt;zn_name);
		zn-&gt;zn_name[<span class="enscript-keyword">sizeof</span> zn-&gt;zn_name - 1] = <span class="enscript-string">'\0'</span>;
		fake_zones[i].query(&amp;zi-&gt;zi_count, &amp;zi-&gt;zi_cur_size,
				    &amp;zi-&gt;zi_max_size, &amp;zi-&gt;zi_elem_size,
				    &amp;zi-&gt;zi_alloc_size, &amp;sum_space,
				    &amp;zi-&gt;zi_collectable, &amp;zi-&gt;zi_exhaustible, &amp;caller_acct);
		zn++;
		zi++;
	}

	used = max_zones * <span class="enscript-keyword">sizeof</span> *names;
	<span class="enscript-keyword">if</span> (used != names_size)
		bzero((<span class="enscript-type">char</span> *) (names_addr + used), names_size - used);

	kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)names_addr,
			   (vm_map_size_t)names_size, TRUE, &amp;copy);
	assert(kr == KERN_SUCCESS);

	*namesp = (zone_name_t *) copy;
	*namesCntp = max_zones;

	used = max_zones * <span class="enscript-keyword">sizeof</span> *info;
	<span class="enscript-keyword">if</span> (used != info_size)
		bzero((<span class="enscript-type">char</span> *) (info_addr + used), info_size - used);

	kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)info_addr,
			   (vm_map_size_t)info_size, TRUE, &amp;copy);
	assert(kr == KERN_SUCCESS);

	*infop = (zone_info_t *) copy;
	*infoCntp = max_zones;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">mach_zone_force_gc</span>(
	host_t host)
{

	<span class="enscript-keyword">if</span> (host == HOST_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_HOST;

	consider_zone_gc(TRUE);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> stack_total;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> stack_allocs;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> inuse_ptepages_count;
<span class="enscript-type">extern</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> alloc_ptepages_count;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">zone_display_zprint</span>()
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    i;
	zone_t		the_zone;

	<span class="enscript-keyword">if</span>(first_zone!=NULL) {
		the_zone = first_zone;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; num_zones; i++) {
			<span class="enscript-keyword">if</span>(the_zone-&gt;cur_size &gt; (1024*1024)) {
				printf(<span class="enscript-string">&quot;%.20s:\t%lu\n&quot;</span>,the_zone-&gt;zone_name,(uintptr_t)the_zone-&gt;cur_size);
			}

			<span class="enscript-keyword">if</span>(the_zone-&gt;next_zone == NULL) {
				<span class="enscript-keyword">break</span>;
			}

			the_zone = the_zone-&gt;next_zone;
		}
	}

	printf(<span class="enscript-string">&quot;Kernel Stacks:\t%lu\n&quot;</span>,(uintptr_t)(kernel_stack_size * stack_total));

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
	printf(<span class="enscript-string">&quot;PageTables:\t%lu\n&quot;</span>,(uintptr_t)(PAGE_SIZE * inuse_ptepages_count));
#<span class="enscript-reference">endif</span>

	printf(<span class="enscript-string">&quot;Kalloc.Large:\t%lu\n&quot;</span>,(uintptr_t)kalloc_large_total);
}

zone_t
<span class="enscript-function-name">zone_find_largest</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    i;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    max_zones;
	zone_t 	        the_zone;
	zone_t          zone_largest;

	simple_lock(&amp;all_zones_lock);
	the_zone = first_zone;
	max_zones = num_zones;
	simple_unlock(&amp;all_zones_lock);
	
	zone_largest = the_zone;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; max_zones; i++) {
		<span class="enscript-keyword">if</span> (the_zone-&gt;cur_size &gt; zone_largest-&gt;cur_size) {
			zone_largest = the_zone;
		}

		<span class="enscript-keyword">if</span> (the_zone-&gt;next_zone == NULL) {
			<span class="enscript-keyword">break</span>;
		}

		the_zone = the_zone-&gt;next_zone;
	}
	<span class="enscript-keyword">return</span> zone_largest;
}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_DEBUG</span>

<span class="enscript-comment">/* should we care about locks here ? */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">zone_in_use</span>(z) 	( z-&gt;count || z-&gt;free_elements \
						  || !queue_empty(&amp;z-&gt;pages.all_free) \
						  || !queue_empty(&amp;z-&gt;pages.intermediate) \
						  || (z-&gt;allows_foreign &amp;&amp; !queue_empty(&amp;z-&gt;pages.any_free_foreign)))

<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_debug_enable</span>(
	zone_t		z)
{
	<span class="enscript-keyword">if</span> (zone_debug_enabled(z) || zone_in_use(z) ||
	    z-&gt;alloc_size &lt; (z-&gt;elem_size + ZONE_DEBUG_OFFSET))
		<span class="enscript-keyword">return</span>;
	queue_init(&amp;z-&gt;active_zones);
	z-&gt;elem_size += ZONE_DEBUG_OFFSET;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">zone_debug_disable</span>(
	zone_t		z)
{
	<span class="enscript-keyword">if</span> (!zone_debug_enabled(z) || zone_in_use(z))
		<span class="enscript-keyword">return</span>;
	z-&gt;elem_size -= ZONE_DEBUG_OFFSET;
	z-&gt;active_zones.next = z-&gt;active_zones.prev = NULL;
}


#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* ZONE_DEBUG */</span>
</pre>
<hr />
</body></html>