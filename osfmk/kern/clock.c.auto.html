<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>clock.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">clock.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/*
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host_notify.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPlatformExpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/commpage.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_traps.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_time.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

uint32_t	hz_tick_interval = 1;


<span class="enscript-function-name">decl_simple_lock_data</span>(,clock_lock)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">clock_lock</span>()	\
	simple_lock(&amp;clock_lock)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">clock_unlock</span>()	\
	simple_unlock(&amp;clock_lock)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">clock_lock_init</span>()	\
	simple_lock_init(&amp;clock_lock, 0)


<span class="enscript-comment">/*
 *	Time of day (calendar) variables.
 *
 *	Algorithm:
 *
 *	TOD &lt;- (seconds + epoch, fraction) &lt;- CONV(current absolute time + offset)
 *
 *	where CONV converts absolute time units into seconds and a fraction.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> clock_calend {
	uint64_t	epoch;
	uint64_t	offset;
	uint64_t    epoch_absolute;

	int32_t		adjdelta;	<span class="enscript-comment">/* Nanosecond time delta for this adjustment period */</span>
	uint64_t	adjstart;	<span class="enscript-comment">/* Absolute time value for start of this adjustment period */</span>
	uint32_t	adjoffset;	<span class="enscript-comment">/* Absolute time offset for this adjustment period as absolute value */</span>
} clock_calend;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>

<span class="enscript-comment">/*
 *	Unlocked calendar flipflop; this is used to track a clock_calend such
 *	that we can safely access a snapshot of a valid  clock_calend structure
 *	without needing to take any locks to do it.
 *
 *	The trick is to use a generation count and set the low bit when it is
 *	being updated/read; by doing this, we guarantee, through use of the
 *	hw_atomic functions, that the generation is incremented when the bit
 *	is cleared atomically (by using a 1 bit add).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> unlocked_clock_calend {
	<span class="enscript-type">struct</span> clock_calend	calend;		<span class="enscript-comment">/* copy of calendar */</span>
	uint32_t		gen;		<span class="enscript-comment">/* generation count */</span>
} flipflop[ 2];

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">clock_track_calend_nowait</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *	Calendar adjustment variables and values.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">calend_adjperiod</span>	(NSEC_PER_SEC / 100)	<span class="enscript-comment">/* adjustment period, ns */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">calend_adjskew</span>		(40 * NSEC_PER_USEC)	<span class="enscript-comment">/* &quot;standard&quot; skew, ns / period */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">calend_adjbig</span>		(NSEC_PER_SEC)			<span class="enscript-comment">/* use 10x skew above adjbig ns */</span>

<span class="enscript-type">static</span> int64_t				calend_adjtotal;		<span class="enscript-comment">/* Nanosecond remaining total adjustment */</span>
<span class="enscript-type">static</span> uint64_t				calend_adjdeadline;		<span class="enscript-comment">/* Absolute time value for next adjustment period */</span>
<span class="enscript-type">static</span> uint32_t				calend_adjinterval;		<span class="enscript-comment">/* Absolute time interval of adjustment period */</span>

<span class="enscript-type">static</span> timer_call_data_t	calend_adjcall;
<span class="enscript-type">static</span> uint32_t				calend_adjactive;

<span class="enscript-type">static</span> uint32_t		calend_set_adjustment(
						<span class="enscript-type">long</span>			*secs,
						<span class="enscript-type">int</span>				*microsecs);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>			calend_adjust_call(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> uint32_t		calend_adjust(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span> <span class="enscript-function-name">_clock_delay_until_deadline</span>(uint64_t		interval,
								 uint64_t		deadline);
<span class="enscript-type">void</span> <span class="enscript-function-name">_clock_delay_until_deadline_with_leeway</span>(uint64_t		interval,
											 uint64_t		deadline,
											 uint64_t		leeway);

<span class="enscript-type">static</span> uint64_t		clock_boottime;				<span class="enscript-comment">/* Seconds boottime epoch */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">TIME_ADD</span>(rsecs, secs, rfrac, frac, unit)	\
MACRO_BEGIN											\
	<span class="enscript-keyword">if</span> (((rfrac) += (frac)) &gt;= (unit)) {			\
		(rfrac) -= (unit);							\
		(rsecs) += 1;								\
	}												\
	(rsecs) += (secs);								\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">TIME_SUB</span>(rsecs, secs, rfrac, frac, unit)	\
MACRO_BEGIN											\
	<span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)((rfrac) -= (frac)) &lt; 0) {				\
		(rfrac) += (unit);							\
		(rsecs) -= 1;								\
	}												\
	(rsecs) -= (secs);								\
MACRO_END

<span class="enscript-comment">/*
 *	clock_config:
 *
 *	Called once at boot to configure the clock subsystem.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_config</span>(<span class="enscript-type">void</span>)
{
	clock_lock_init();

	timer_call_setup(&amp;calend_adjcall, (timer_call_func_t)calend_adjust_call, NULL);

	clock_oldconfig();
}

<span class="enscript-comment">/*
 *	clock_init:
 *
 *	Called on a processor each time started.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_init</span>(<span class="enscript-type">void</span>)
{
	clock_oldinit();
}

<span class="enscript-comment">/*
 *	clock_timebase_init:
 *
 *	Called by machine dependent code
 *	to initialize areas dependent on the
 *	timebase value.  May be called multiple
 *	times during start up.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_timebase_init</span>(<span class="enscript-type">void</span>)
{
	uint64_t	abstime;

	nanoseconds_to_absolutetime(calend_adjperiod, &amp;abstime);
	calend_adjinterval = (uint32_t)abstime;

	nanoseconds_to_absolutetime(NSEC_PER_SEC / 100, &amp;abstime);
	hz_tick_interval = (uint32_t)abstime;

	sched_timebase_init();
}

<span class="enscript-comment">/*
 *	mach_timebase_info_trap:
 *
 *	User trap returns timebase constant.
 */</span>
kern_return_t
<span class="enscript-function-name">mach_timebase_info_trap</span>(
	<span class="enscript-type">struct</span> mach_timebase_info_trap_args *args)
{
	mach_vm_address_t 			out_info_addr = args-&gt;info;
	mach_timebase_info_data_t	info;

	clock_timebase_info(&amp;info);

	copyout((<span class="enscript-type">void</span> *)&amp;info, out_info_addr, <span class="enscript-keyword">sizeof</span> (info));

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 *	Calendar routines.
 */</span>

<span class="enscript-comment">/*
 *	clock_get_calendar_microtime:
 *
 *	Returns the current calendar value,
 *	microseconds as the fraction.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_get_calendar_microtime</span>(
	clock_sec_t			*secs,
	clock_usec_t		*microsecs)
{
	clock_get_calendar_absolute_and_microtime(secs, microsecs, NULL);
}

<span class="enscript-comment">/*
 *	clock_get_calendar_absolute_and_microtime:
 *
 *	Returns the current calendar value,
 *	microseconds as the fraction. Also
 *	returns mach_absolute_time if abstime
 *	is not NULL.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_get_calendar_absolute_and_microtime</span>(
	clock_sec_t			*secs,
	clock_usec_t		*microsecs,
	uint64_t    		*abstime)
{
	uint64_t		now;
	spl_t			s;

	s = splclock();
	clock_lock();

	now = mach_absolute_time();
	<span class="enscript-keyword">if</span> (abstime)
		*abstime = now;

	<span class="enscript-keyword">if</span> (clock_calend.adjdelta &lt; 0) {
		uint32_t	t32;

		<span class="enscript-comment">/* 
		 * Since offset is decremented during a negative adjustment,
		 * ensure that time increases monotonically without going
		 * temporarily backwards.
		 * If the delta has not yet passed, now is set to the start
		 * of the current adjustment period; otherwise, we're between
		 * the expiry of the delta and the next call to calend_adjust(),
		 * and we offset accordingly.
		 */</span>
		<span class="enscript-keyword">if</span> (now &gt; clock_calend.adjstart) {
			t32 = (uint32_t)(now - clock_calend.adjstart);

			<span class="enscript-keyword">if</span> (t32 &gt; clock_calend.adjoffset)
				now -= clock_calend.adjoffset;
			<span class="enscript-keyword">else</span>
				now = clock_calend.adjstart;
		}
	}

	now += clock_calend.offset;

	absolutetime_to_microtime(now, secs, microsecs);

	*secs += (clock_sec_t)clock_calend.epoch;

	clock_unlock();
	splx(s);
}

<span class="enscript-comment">/*
 *	clock_get_calendar_nanotime:
 *
 *	Returns the current calendar value,
 *	nanoseconds as the fraction.
 *
 *	Since we do not have an interface to
 *	set the calendar with resolution greater
 *	than a microsecond, we honor that here.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_get_calendar_nanotime</span>(
	clock_sec_t			*secs,
	clock_nsec_t		*nanosecs)
{
	uint64_t		now;
	spl_t			s;

	s = splclock();
	clock_lock();

	now = mach_absolute_time();

	<span class="enscript-keyword">if</span> (clock_calend.adjdelta &lt; 0) {
		uint32_t	t32;

		<span class="enscript-keyword">if</span> (now &gt; clock_calend.adjstart) {
			t32 = (uint32_t)(now - clock_calend.adjstart);

			<span class="enscript-keyword">if</span> (t32 &gt; clock_calend.adjoffset)
				now -= clock_calend.adjoffset;
			<span class="enscript-keyword">else</span>
				now = clock_calend.adjstart;
		}
	}

	now += clock_calend.offset;

	absolutetime_to_microtime(now, secs, nanosecs);

	*nanosecs *= NSEC_PER_USEC;

	*secs += (clock_sec_t)clock_calend.epoch;

	clock_unlock();
	splx(s);
}

<span class="enscript-comment">/*
 *	clock_gettimeofday:
 *
 *	Kernel interface for commpage implementation of
 *	gettimeofday() syscall.
 *
 *	Returns the current calendar value, and updates the
 *	commpage info as appropriate.  Because most calls to
 *	gettimeofday() are handled in user mode by the commpage,
 *	this routine should be used infrequently.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_gettimeofday</span>(
	clock_sec_t		*secs,
	clock_usec_t	*microsecs)
{
	uint64_t		now;
	spl_t			s;

	s = splclock();
	clock_lock();

	now = mach_absolute_time();

	<span class="enscript-keyword">if</span> (clock_calend.adjdelta &gt;= 0) {
		clock_gettimeofday_set_commpage(now, clock_calend.epoch, clock_calend.offset, secs, microsecs);
	}
	<span class="enscript-keyword">else</span> {
		uint32_t	t32;

		<span class="enscript-keyword">if</span> (now &gt; clock_calend.adjstart) {
			t32 = (uint32_t)(now - clock_calend.adjstart);

			<span class="enscript-keyword">if</span> (t32 &gt; clock_calend.adjoffset)
				now -= clock_calend.adjoffset;
			<span class="enscript-keyword">else</span>
				now = clock_calend.adjstart;
		}

		now += clock_calend.offset;

		absolutetime_to_microtime(now, secs, microsecs);

		*secs += (clock_sec_t)clock_calend.epoch;
	}

	clock_unlock();
	splx(s);
}

<span class="enscript-comment">/*
 *	clock_set_calendar_microtime:
 *
 *	Sets the current calendar value by
 *	recalculating the epoch and offset
 *	from the system clock.
 *
 *	Also adjusts the boottime to keep the
 *	value consistent, writes the new
 *	calendar value to the platform clock,
 *	and sends calendar change notifications.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_set_calendar_microtime</span>(
	clock_sec_t			secs,
	clock_usec_t		microsecs)
{
	clock_sec_t			sys;
	clock_usec_t		microsys;
	clock_sec_t			newsecs;
    clock_usec_t        newmicrosecs;
	spl_t				s;

    newsecs = secs;
    newmicrosecs = microsecs;

	s = splclock();
	clock_lock();

	commpage_disable_timestamp();

	<span class="enscript-comment">/*
	 *	Calculate the new calendar epoch based on
	 *	the new value and the system clock.
	 */</span>
	clock_get_system_microtime(&amp;sys, &amp;microsys);
	TIME_SUB(secs, sys, microsecs, microsys, USEC_PER_SEC);

	<span class="enscript-comment">/*
	 *	Adjust the boottime based on the delta.
	 */</span>
	clock_boottime += secs - clock_calend.epoch;

	<span class="enscript-comment">/*
	 *	Set the new calendar epoch.
	 */</span>
	clock_calend.epoch = secs;

	nanoseconds_to_absolutetime((uint64_t)microsecs * NSEC_PER_USEC, &amp;clock_calend.offset);

	clock_interval_to_absolutetime_interval((uint32_t) secs, NSEC_PER_SEC, &amp;clock_calend.epoch_absolute);
	clock_calend.epoch_absolute += clock_calend.offset;

	<span class="enscript-comment">/*
	 *	Cancel any adjustment in progress.
	 */</span>
	calend_adjtotal = clock_calend.adjdelta = 0;

	clock_unlock();

	<span class="enscript-comment">/*
	 *	Set the new value for the platform clock.
	 */</span>
	PESetUTCTimeOfDay(newsecs, newmicrosecs);

	splx(s);

	<span class="enscript-comment">/*
	 *	Send host notifications.
	 */</span>
	host_notify_calendar_change();
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	clock_track_calend_nowait();
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 *	clock_initialize_calendar:
 *
 *	Set the calendar and related clocks
 *	from the platform clock at boot or
 *	wake event.
 *
 *	Also sends host notifications.
 */</span>

uint64_t mach_absolutetime_asleep;
uint64_t mach_absolutetime_last_sleep;

<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_initialize_calendar</span>(<span class="enscript-type">void</span>)
{
	clock_sec_t			sys, secs;
	clock_usec_t 		microsys, microsecs;
	uint64_t			new_epoch;
	spl_t				s;

    PEGetUTCTimeOfDay(&amp;secs, &amp;microsecs);

	s = splclock();
	clock_lock();

	commpage_disable_timestamp();

	<span class="enscript-keyword">if</span> ((<span class="enscript-type">long</span>)secs &gt;= (<span class="enscript-type">long</span>)clock_boottime) {
		<span class="enscript-comment">/*
		 *	Initialize the boot time based on the platform clock.
		 */</span>
		<span class="enscript-keyword">if</span> (clock_boottime == 0)
			clock_boottime = secs;

		<span class="enscript-comment">/*
		 *	Calculate the new calendar epoch based on
		 *	the platform clock and the system clock.
		 */</span>
		clock_get_system_microtime(&amp;sys, &amp;microsys);
		TIME_SUB(secs, sys, microsecs, microsys, USEC_PER_SEC);

		<span class="enscript-comment">/*
		 *	Set the new calendar epoch.
		 */</span>

		clock_calend.epoch = secs;

		nanoseconds_to_absolutetime((uint64_t)microsecs * NSEC_PER_USEC, &amp;clock_calend.offset);

		clock_interval_to_absolutetime_interval((uint32_t) secs, NSEC_PER_SEC, &amp;new_epoch);
		new_epoch += clock_calend.offset;

		<span class="enscript-keyword">if</span> (clock_calend.epoch_absolute)
		{
			mach_absolutetime_last_sleep = new_epoch - clock_calend.epoch_absolute;
			mach_absolutetime_asleep += mach_absolutetime_last_sleep;
			KERNEL_DEBUG_CONSTANT(
				  MACHDBG_CODE(DBG_MACH_CLOCK,MACH_EPOCH_CHANGE) | DBG_FUNC_NONE,
				  (uintptr_t) mach_absolutetime_last_sleep, 
				  (uintptr_t) mach_absolutetime_asleep, 
				  (uintptr_t) (mach_absolutetime_last_sleep &gt;&gt; 32), 
				  (uintptr_t) (mach_absolutetime_asleep &gt;&gt; 32), 
				  0);
		}
		clock_calend.epoch_absolute = new_epoch;

		<span class="enscript-comment">/*
		 *	 Cancel any adjustment in progress.
		 */</span>
		calend_adjtotal = clock_calend.adjdelta = 0;
	}

	clock_unlock();
	splx(s);

	<span class="enscript-comment">/*
	 *	Send host notifications.
	 */</span>
	host_notify_calendar_change();
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	clock_track_calend_nowait();
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 *	clock_get_boottime_nanotime:
 *
 *	Return the boottime, used by sysctl.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_get_boottime_nanotime</span>(
	clock_sec_t			*secs,
	clock_nsec_t		*nanosecs)
{
	spl_t	s;

	s = splclock();
	clock_lock();

	*secs = (clock_sec_t)clock_boottime;
	*nanosecs = 0;

	clock_unlock();
	splx(s);
}

<span class="enscript-comment">/*
 *	clock_adjtime:
 *
 *	Interface to adjtime() syscall.
 *
 *	Calculates adjustment variables and
 *	initiates adjustment.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_adjtime</span>(
	<span class="enscript-type">long</span>		*secs,
	<span class="enscript-type">int</span>			*microsecs)
{
	uint32_t	interval;
	spl_t		s;

	s = splclock();
	clock_lock();

	interval = calend_set_adjustment(secs, microsecs);
	<span class="enscript-keyword">if</span> (interval != 0) {
		calend_adjdeadline = mach_absolute_time() + interval;
		<span class="enscript-keyword">if</span> (!timer_call_enter(&amp;calend_adjcall, calend_adjdeadline, TIMER_CALL_SYS_CRITICAL))
			calend_adjactive++;
	}
	<span class="enscript-keyword">else</span>
	<span class="enscript-keyword">if</span> (timer_call_cancel(&amp;calend_adjcall))
		calend_adjactive--;

	clock_unlock();
	splx(s);
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">calend_set_adjustment</span>(
	<span class="enscript-type">long</span>			*secs,
	<span class="enscript-type">int</span>				*microsecs)
{
	uint64_t		now, t64;
	int64_t			total, ototal;
	uint32_t		interval = 0;

	<span class="enscript-comment">/* 
	 * Compute the total adjustment time in nanoseconds.
	 */</span>
	total = ((int64_t)*secs * (int64_t)NSEC_PER_SEC) + (*microsecs * (int64_t)NSEC_PER_USEC);

	<span class="enscript-comment">/* 
	 * Disable commpage gettimeofday().
	 */</span>
	commpage_disable_timestamp();

	<span class="enscript-comment">/* 
	 * Get current absolute time.
	 */</span>
	now = mach_absolute_time();

	<span class="enscript-comment">/* 
	 * Save the old adjustment total for later return.
	 */</span>
	ototal = calend_adjtotal;

	<span class="enscript-comment">/*
	 * Is a new correction specified?
	 */</span>
	<span class="enscript-keyword">if</span> (total != 0) {
		<span class="enscript-comment">/*
		 * Set delta to the standard, small, adjustment skew.
		 */</span>
		int32_t		delta = calend_adjskew;

		<span class="enscript-keyword">if</span> (total &gt; 0) {
			<span class="enscript-comment">/*
			 * Positive adjustment. If greater than the preset 'big' 
			 * threshold, slew at a faster rate, capping if necessary.
			 */</span>
			<span class="enscript-keyword">if</span> (total &gt; (int64_t) calend_adjbig)
				delta *= 10;
			<span class="enscript-keyword">if</span> (delta &gt; total)
				delta = (int32_t)total;

			<span class="enscript-comment">/* 
			 * Convert the delta back from ns to absolute time and store in adjoffset.
			 */</span>
			nanoseconds_to_absolutetime((uint64_t)delta, &amp;t64);
			clock_calend.adjoffset = (uint32_t)t64;
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Negative adjustment; therefore, negate the delta. If 
			 * greater than the preset 'big' threshold, slew at a faster 
			 * rate, capping if necessary.
			 */</span>
			<span class="enscript-keyword">if</span> (total &lt; (int64_t) -calend_adjbig)
				delta *= 10;
			delta = -delta;
			<span class="enscript-keyword">if</span> (delta &lt; total)
				delta = (int32_t)total;

			<span class="enscript-comment">/* 
			 * Save the current absolute time. Subsequent time operations occuring
			 * during this negative correction can make use of this value to ensure 
			 * that time increases monotonically.
			 */</span>
			clock_calend.adjstart = now;

			<span class="enscript-comment">/* 
			 * Convert the delta back from ns to absolute time and store in adjoffset.
			 */</span>
			nanoseconds_to_absolutetime((uint64_t)-delta, &amp;t64);
			clock_calend.adjoffset = (uint32_t)t64;
		}

		<span class="enscript-comment">/* 
		 * Store the total adjustment time in ns. 
		 */</span>
		calend_adjtotal = total;
		
		<span class="enscript-comment">/* 
		 * Store the delta for this adjustment period in ns. 
		 */</span>
		clock_calend.adjdelta = delta;

		<span class="enscript-comment">/* 
		 * Set the interval in absolute time for later return. 
		 */</span>
		interval = calend_adjinterval;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* 
		 * No change; clear any prior adjustment.
		 */</span>
		calend_adjtotal = clock_calend.adjdelta = 0;
	}

	<span class="enscript-comment">/* 
	 * If an prior correction was in progress, return the
	 * remaining uncorrected time from it. 
	 */</span>
	<span class="enscript-keyword">if</span> (ototal != 0) {
		*secs = (<span class="enscript-type">long</span>)(ototal / (<span class="enscript-type">long</span>)NSEC_PER_SEC);
		*microsecs = (<span class="enscript-type">int</span>)((ototal % (<span class="enscript-type">int</span>)NSEC_PER_SEC) / (<span class="enscript-type">int</span>)NSEC_PER_USEC);
	}
	<span class="enscript-keyword">else</span>
		*secs = *microsecs = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	clock_track_calend_nowait();
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-keyword">return</span> (interval);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">calend_adjust_call</span>(<span class="enscript-type">void</span>)
{
	uint32_t	interval;
	spl_t		s;

	s = splclock();
	clock_lock();

	<span class="enscript-keyword">if</span> (--calend_adjactive == 0) {
		interval = calend_adjust();
		<span class="enscript-keyword">if</span> (interval != 0) {
			clock_deadline_for_periodic_event(interval, mach_absolute_time(), &amp;calend_adjdeadline);

			<span class="enscript-keyword">if</span> (!timer_call_enter(&amp;calend_adjcall, calend_adjdeadline, TIMER_CALL_SYS_CRITICAL))
				calend_adjactive++;
		}
	}

	clock_unlock();
	splx(s);
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">calend_adjust</span>(<span class="enscript-type">void</span>)
{
	uint64_t		now, t64;
	int32_t			delta;
	uint32_t		interval = 0;

	commpage_disable_timestamp();

	now = mach_absolute_time();

	delta = clock_calend.adjdelta;

	<span class="enscript-keyword">if</span> (delta &gt; 0) {
		clock_calend.offset += clock_calend.adjoffset;

		calend_adjtotal -= delta;
		<span class="enscript-keyword">if</span> (delta &gt; calend_adjtotal) {
			clock_calend.adjdelta = delta = (int32_t)calend_adjtotal;

			nanoseconds_to_absolutetime((uint64_t)delta, &amp;t64);
			clock_calend.adjoffset = (uint32_t)t64;
		}
	}
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">if</span> (delta &lt; 0) {
			clock_calend.offset -= clock_calend.adjoffset;

			calend_adjtotal -= delta;
			<span class="enscript-keyword">if</span> (delta &lt; calend_adjtotal) {
				clock_calend.adjdelta = delta = (int32_t)calend_adjtotal;

				nanoseconds_to_absolutetime((uint64_t)-delta, &amp;t64);
				clock_calend.adjoffset = (uint32_t)t64;
			}

			<span class="enscript-keyword">if</span> (clock_calend.adjdelta != 0)
				clock_calend.adjstart = now;
		}

	<span class="enscript-keyword">if</span> (clock_calend.adjdelta != 0)
		interval = calend_adjinterval;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	clock_track_calend_nowait();
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (interval);
}

<span class="enscript-comment">/*
 *	Wait / delay routines.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mach_wait_until_continue</span>(
	__unused <span class="enscript-type">void</span>	*parameter,
	wait_result_t	wresult)
{
	thread_syscall_return((wresult == THREAD_INTERRUPTED)? KERN_ABORTED: KERN_SUCCESS);
	<span class="enscript-comment">/*NOTREACHED*/</span>
}

<span class="enscript-comment">/*
 * mach_wait_until_trap: Suspend execution of calling thread until the specified time has passed
 *
 * Parameters:    args-&gt;deadline          Amount of time to wait
 *
 * Returns:        0                      Success
 *                !0                      Not success           
 *
 */</span>
kern_return_t
<span class="enscript-function-name">mach_wait_until_trap</span>(
	<span class="enscript-type">struct</span> mach_wait_until_trap_args	*args)
{
	uint64_t		deadline = args-&gt;deadline;
	wait_result_t	wresult;

	wresult = assert_wait_deadline_with_leeway((event_t)mach_wait_until_trap, THREAD_ABORTSAFE,
						   TIMEOUT_URGENCY_USER_NORMAL, deadline, 0);
	<span class="enscript-keyword">if</span> (wresult == THREAD_WAITING)
		wresult = thread_block(mach_wait_until_continue);

	<span class="enscript-keyword">return</span> ((wresult == THREAD_INTERRUPTED)? KERN_ABORTED: KERN_SUCCESS);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_delay_until</span>(
	uint64_t		deadline)
{
	uint64_t		now = mach_absolute_time();

	<span class="enscript-keyword">if</span> (now &gt;= deadline)
		<span class="enscript-keyword">return</span>;

	_clock_delay_until_deadline(deadline - now, deadline);
}

<span class="enscript-comment">/*
 * Preserve the original precise interval that the client
 * requested for comparison to the spin threshold.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_clock_delay_until_deadline</span>(
	uint64_t		interval,
	uint64_t		deadline)
{
	_clock_delay_until_deadline_with_leeway(interval, deadline, 0);
}

<span class="enscript-comment">/*
 * Like _clock_delay_until_deadline, but it accepts a
 * leeway value.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_clock_delay_until_deadline_with_leeway</span>(
	uint64_t		interval,
	uint64_t		deadline,
	uint64_t		leeway)
{

	<span class="enscript-keyword">if</span> (interval == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (	ml_delay_should_spin(interval)	||
			get_preemption_level() != 0				||
			ml_get_interrupts_enabled() == FALSE	) {
		machine_delay_until(interval, deadline);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * For now, assume a leeway request of 0 means the client does not want a leeway
		 * value. We may want to change this interpretation in the future.
		 */</span>

		<span class="enscript-keyword">if</span> (leeway) {
			assert_wait_deadline_with_leeway((event_t)clock_delay_until, THREAD_UNINT, TIMEOUT_URGENCY_LEEWAY, deadline, leeway);
		} <span class="enscript-keyword">else</span> {
			assert_wait_deadline((event_t)clock_delay_until, THREAD_UNINT, deadline);
		}

		thread_block(THREAD_CONTINUE_NULL);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">delay_for_interval</span>(
	uint32_t		interval,
	uint32_t		scale_factor)
{
	uint64_t		abstime;

	clock_interval_to_absolutetime_interval(interval, scale_factor, &amp;abstime);

	_clock_delay_until_deadline(abstime, mach_absolute_time() + abstime);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">delay_for_interval_with_leeway</span>(
	uint32_t		interval,
	uint32_t		leeway,
	uint32_t		scale_factor)
{
	uint64_t		abstime_interval;
	uint64_t		abstime_leeway;

	clock_interval_to_absolutetime_interval(interval, scale_factor, &amp;abstime_interval);
	clock_interval_to_absolutetime_interval(leeway, scale_factor, &amp;abstime_leeway);

	_clock_delay_until_deadline_with_leeway(abstime_interval, mach_absolute_time() + abstime_interval, abstime_leeway);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">delay</span>(
	<span class="enscript-type">int</span>		usec)
{
	delay_for_interval((usec &lt; 0)? -usec: usec, NSEC_PER_USEC);
}

<span class="enscript-comment">/*
 *	Miscellaneous routines.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_interval_to_deadline</span>(
	uint32_t			interval,
	uint32_t			scale_factor,
	uint64_t			*result)
{
	uint64_t	abstime;

	clock_interval_to_absolutetime_interval(interval, scale_factor, &amp;abstime);

	*result = mach_absolute_time() + abstime;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_absolutetime_interval_to_deadline</span>(
	uint64_t			abstime,
	uint64_t			*result)
{
	*result = mach_absolute_time() + abstime;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_get_uptime</span>(
	uint64_t	*result)
{
	*result = mach_absolute_time();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_deadline_for_periodic_event</span>(
	uint64_t			interval,
	uint64_t			abstime,
	uint64_t			*deadline)
{
	assert(interval != 0);

	*deadline += interval;

	<span class="enscript-keyword">if</span> (*deadline &lt;= abstime) {
		*deadline = abstime + interval;
		abstime = mach_absolute_time();

		<span class="enscript-keyword">if</span> (*deadline &lt;= abstime)
			*deadline = abstime + interval;
	}
}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>

<span class="enscript-comment">/*
 * clock_get_calendar_nanotime_nowait
 *
 * Description:	Non-blocking version of clock_get_calendar_nanotime()
 *
 * Notes:	This function operates by separately tracking calendar time
 *		updates using a two element structure to copy the calendar
 *		state, which may be asynchronously modified.  It utilizes
 *		barrier instructions in the tracking process and in the local
 *		stable snapshot process in order to ensure that a consistent
 *		snapshot is used to perform the calculation.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">clock_get_calendar_nanotime_nowait</span>(
	clock_sec_t			*secs,
	clock_nsec_t		*nanosecs)
{
	<span class="enscript-type">int</span> i = 0;
	uint64_t		now;
	<span class="enscript-type">struct</span> unlocked_clock_calend stable;

	<span class="enscript-keyword">for</span> (;;) {
		stable = flipflop[i];		<span class="enscript-comment">/* take snapshot */</span>

		<span class="enscript-comment">/*
		 * Use a barrier instructions to ensure atomicity.  We AND
		 * off the &quot;in progress&quot; bit to get the current generation
		 * count.
		 */</span>
		(<span class="enscript-type">void</span>)hw_atomic_and(&amp;stable.gen, ~(uint32_t)1);

		<span class="enscript-comment">/*
		 * If an update _is_ in progress, the generation count will be
		 * off by one, if it _was_ in progress, it will be off by two,
		 * and if we caught it at a good time, it will be equal (and
		 * our snapshot is threfore stable).
		 */</span>
		<span class="enscript-keyword">if</span> (flipflop[i].gen == stable.gen)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* Switch to the oher element of the flipflop, and try again. */</span>
		i ^= 1;
	}

	now = mach_absolute_time();

	<span class="enscript-keyword">if</span> (stable.calend.adjdelta &lt; 0) {
		uint32_t	t32;

		<span class="enscript-keyword">if</span> (now &gt; stable.calend.adjstart) {
			t32 = (uint32_t)(now - stable.calend.adjstart);

			<span class="enscript-keyword">if</span> (t32 &gt; stable.calend.adjoffset)
				now -= stable.calend.adjoffset;
			<span class="enscript-keyword">else</span>
				now = stable.calend.adjstart;
		}
	}

	now += stable.calend.offset;

	absolutetime_to_microtime(now, secs, nanosecs);
	*nanosecs *= NSEC_PER_USEC;

	*secs += (clock_sec_t)stable.calend.epoch;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">clock_track_calend_nowait</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; 2; i++) {
		<span class="enscript-type">struct</span> clock_calend tmp = clock_calend;

		<span class="enscript-comment">/*
		 * Set the low bit if the generation count; since we use a
		 * barrier instruction to do this, we are guaranteed that this
		 * will flag an update in progress to an async caller trying
		 * to examine the contents.
		 */</span>
		(<span class="enscript-type">void</span>)hw_atomic_or(&amp;flipflop[i].gen, 1);

		flipflop[i].calend = tmp;

		<span class="enscript-comment">/*
		 * Increment the generation count to clear the low bit to
		 * signal completion.  If a caller compares the generation
		 * count after taking a copy while in progress, the count
		 * will be off by two.
		 */</span>
		(<span class="enscript-type">void</span>)hw_atomic_add(&amp;flipflop[i].gen, 1);
	}
}

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONFIG_DTRACE */</span>

</pre>
<hr />
</body></html>