<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ipc_tt.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ipc_tt.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>
<span class="enscript-comment">/*
 */</span>

<span class="enscript-comment">/*
 * File:	ipc_tt.c
 * Purpose:
 *	Task and thread related IPC functions.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task_special_ports.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_special_ports.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_status.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/exception_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_traps.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_host_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map_server.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_kobject.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_tt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_mach_internal.h&gt;</span>

<span class="enscript-comment">/* forward declarations */</span>
task_t <span class="enscript-function-name">convert_port_to_locked_task</span>(ipc_port_t port);


<span class="enscript-comment">/*
 *	Routine:	ipc_task_init
 *	Purpose:
 *		Initialize a task's IPC state.
 *
 *		If non-null, some state will be inherited from the parent.
 *		The parent must be appropriately initialized.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_task_init</span>(
	task_t		task,
	task_t		parent)
{
	ipc_space_t space;
	ipc_port_t kport;
	ipc_port_t nport;
	kern_return_t kr;
	<span class="enscript-type">int</span> i;


	kr = ipc_space_create(&amp;ipc_table_entries[0], &amp;space);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;ipc_task_init&quot;</span>);

	space-&gt;is_task = task;

	kport = ipc_port_alloc_kernel();
	<span class="enscript-keyword">if</span> (kport == IP_NULL)
		panic(<span class="enscript-string">&quot;ipc_task_init&quot;</span>);

	nport = ipc_port_alloc_kernel();
	<span class="enscript-keyword">if</span> (nport == IP_NULL)
		panic(<span class="enscript-string">&quot;ipc_task_init&quot;</span>);

	itk_lock_init(task);
	task-&gt;itk_self = kport;
	task-&gt;itk_nself = nport;
	task-&gt;itk_resume = IP_NULL; <span class="enscript-comment">/* Lazily allocated on-demand */</span>
	task-&gt;itk_sself = ipc_port_make_send(kport);
	task-&gt;itk_debug_control = IP_NULL;
	task-&gt;itk_space = space;

	<span class="enscript-keyword">if</span> (parent == TASK_NULL) {
		ipc_port_t port;

		<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; i++) {
			task-&gt;exc_actions[i].port = IP_NULL;
		}<span class="enscript-comment">/* for */</span>
		
		kr = host_get_host_port(host_priv_self(), &amp;port);
		assert(kr == KERN_SUCCESS);
		task-&gt;itk_host = port;

		task-&gt;itk_bootstrap = IP_NULL;
		task-&gt;itk_seatbelt = IP_NULL;
		task-&gt;itk_gssd = IP_NULL;
		task-&gt;itk_task_access = IP_NULL;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; TASK_PORT_REGISTER_MAX; i++)
			task-&gt;itk_registered[i] = IP_NULL;
	} <span class="enscript-keyword">else</span> {
		itk_lock(parent);
		assert(parent-&gt;itk_self != IP_NULL);

		<span class="enscript-comment">/* inherit registered ports */</span>

		<span class="enscript-keyword">for</span> (i = 0; i &lt; TASK_PORT_REGISTER_MAX; i++)
			task-&gt;itk_registered[i] =
				ipc_port_copy_send(parent-&gt;itk_registered[i]);

		<span class="enscript-comment">/* inherit exception and bootstrap ports */</span>

		<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; i++) {
		    task-&gt;exc_actions[i].port =
		  		ipc_port_copy_send(parent-&gt;exc_actions[i].port);
		    task-&gt;exc_actions[i].flavor =
				parent-&gt;exc_actions[i].flavor;
		    task-&gt;exc_actions[i].behavior = 
				parent-&gt;exc_actions[i].behavior;
		    task-&gt;exc_actions[i].privileged =
				parent-&gt;exc_actions[i].privileged;
		}<span class="enscript-comment">/* for */</span>
		task-&gt;itk_host =
			ipc_port_copy_send(parent-&gt;itk_host);

		task-&gt;itk_bootstrap =
			ipc_port_copy_send(parent-&gt;itk_bootstrap);

		task-&gt;itk_seatbelt =
			ipc_port_copy_send(parent-&gt;itk_seatbelt);

		task-&gt;itk_gssd =
			ipc_port_copy_send(parent-&gt;itk_gssd);

		task-&gt;itk_task_access =
			ipc_port_copy_send(parent-&gt;itk_task_access);

		itk_unlock(parent);
	}
}

<span class="enscript-comment">/*
 *	Routine:	ipc_task_enable
 *	Purpose:
 *		Enable a task for IPC access.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_task_enable</span>(
	task_t		task)
{
	ipc_port_t kport;
	ipc_port_t nport;

	itk_lock(task);
	kport = task-&gt;itk_self;
	<span class="enscript-keyword">if</span> (kport != IP_NULL)
		ipc_kobject_set(kport, (ipc_kobject_t) task, IKOT_TASK);
	nport = task-&gt;itk_nself;
	<span class="enscript-keyword">if</span> (nport != IP_NULL)
		ipc_kobject_set(nport, (ipc_kobject_t) task, IKOT_TASK_NAME);
	itk_unlock(task);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_task_disable
 *	Purpose:
 *		Disable IPC access to a task.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_task_disable</span>(
	task_t		task)
{
	ipc_port_t kport;
	ipc_port_t nport;
	ipc_port_t rport;

	itk_lock(task);
	kport = task-&gt;itk_self;
	<span class="enscript-keyword">if</span> (kport != IP_NULL)
		ipc_kobject_set(kport, IKO_NULL, IKOT_NONE);
	nport = task-&gt;itk_nself;
	<span class="enscript-keyword">if</span> (nport != IP_NULL)
		ipc_kobject_set(nport, IKO_NULL, IKOT_NONE);

	rport = task-&gt;itk_resume;
	<span class="enscript-keyword">if</span> (rport != IP_NULL) {
		<span class="enscript-comment">/*
		 * From this point onwards this task is no longer accepting
		 * resumptions.
		 *
		 * There are still outstanding suspensions on this task,
		 * even as it is being torn down. Disconnect the task
		 * from the rport, thereby &quot;orphaning&quot; the rport. The rport 
		 * itself will go away only when the last suspension holder
		 * destroys his SO right to it -- when he either
		 * exits, or tries to actually use that last SO right to
		 * resume this (now non-existent) task.
		 */</span>
		ipc_kobject_set(rport, IKO_NULL, IKOT_NONE);
	}
	itk_unlock(task);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_task_terminate
 *	Purpose:
 *		Clean up and destroy a task's IPC state.
 *	Conditions:
 *		Nothing locked.  The task must be suspended.
 *		(Or the current thread must be in the task.)
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_task_terminate</span>(
	task_t		task)
{
	ipc_port_t kport;
	ipc_port_t nport;
	ipc_port_t rport;	
	<span class="enscript-type">int</span> i;

	itk_lock(task);
	kport = task-&gt;itk_self;

	<span class="enscript-keyword">if</span> (kport == IP_NULL) {
		<span class="enscript-comment">/* the task is already terminated (can this happen?) */</span>
		itk_unlock(task);
		<span class="enscript-keyword">return</span>;
	}
	task-&gt;itk_self = IP_NULL;

	nport = task-&gt;itk_nself;
	assert(nport != IP_NULL);
	task-&gt;itk_nself = IP_NULL;

	rport = task-&gt;itk_resume;
	task-&gt;itk_resume = IP_NULL;

	itk_unlock(task);

	<span class="enscript-comment">/* release the naked send rights */</span>

	<span class="enscript-keyword">if</span> (IP_VALID(task-&gt;itk_sself))
		ipc_port_release_send(task-&gt;itk_sself);

	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; i++) {
		<span class="enscript-keyword">if</span> (IP_VALID(task-&gt;exc_actions[i].port)) {
			ipc_port_release_send(task-&gt;exc_actions[i].port);
		}
	}

	<span class="enscript-keyword">if</span> (IP_VALID(task-&gt;itk_host))
		ipc_port_release_send(task-&gt;itk_host);

	<span class="enscript-keyword">if</span> (IP_VALID(task-&gt;itk_bootstrap))
		ipc_port_release_send(task-&gt;itk_bootstrap);

	<span class="enscript-keyword">if</span> (IP_VALID(task-&gt;itk_seatbelt))
		ipc_port_release_send(task-&gt;itk_seatbelt);
	
	<span class="enscript-keyword">if</span> (IP_VALID(task-&gt;itk_gssd))
		ipc_port_release_send(task-&gt;itk_gssd);

	<span class="enscript-keyword">if</span> (IP_VALID(task-&gt;itk_task_access))
		ipc_port_release_send(task-&gt;itk_task_access);

	<span class="enscript-keyword">if</span> (IP_VALID(task-&gt;itk_debug_control))
		ipc_port_release_send(task-&gt;itk_debug_control);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; TASK_PORT_REGISTER_MAX; i++)
		<span class="enscript-keyword">if</span> (IP_VALID(task-&gt;itk_registered[i]))
			ipc_port_release_send(task-&gt;itk_registered[i]);

	<span class="enscript-comment">/* destroy the kernel ports */</span>
	ipc_port_dealloc_kernel(kport);
	ipc_port_dealloc_kernel(nport);
	<span class="enscript-keyword">if</span> (rport != IP_NULL)
		ipc_port_dealloc_kernel(rport);	

	itk_lock_destroy(task);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_task_reset
 *	Purpose:
 *		Reset a task's IPC state to protect it when
 *		it enters an elevated security context. The
 *		task name port can remain the same - since
 *		it represents no specific privilege.
 *	Conditions:
 *		Nothing locked.  The task must be suspended.
 *		(Or the current thread must be in the task.)
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_task_reset</span>(
	task_t		task)
{
	ipc_port_t old_kport, new_kport;
	ipc_port_t old_sself;
	ipc_port_t old_exc_actions[EXC_TYPES_COUNT];
	<span class="enscript-type">int</span> i;

	new_kport = ipc_port_alloc_kernel();
	<span class="enscript-keyword">if</span> (new_kport == IP_NULL)
		panic(<span class="enscript-string">&quot;ipc_task_reset&quot;</span>);

	itk_lock(task);

	old_kport = task-&gt;itk_self;

	<span class="enscript-keyword">if</span> (old_kport == IP_NULL) {
		<span class="enscript-comment">/* the task is already terminated (can this happen?) */</span>
		itk_unlock(task);
		ipc_port_dealloc_kernel(new_kport);
		<span class="enscript-keyword">return</span>;
	}

	task-&gt;itk_self = new_kport;
	old_sself = task-&gt;itk_sself;
	task-&gt;itk_sself = ipc_port_make_send(new_kport);
	ipc_kobject_set(old_kport, IKO_NULL, IKOT_NONE);
	ipc_kobject_set(new_kport, (ipc_kobject_t) task, IKOT_TASK);

	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; i++) {
		old_exc_actions[i] = IP_NULL;

		<span class="enscript-keyword">if</span> (i == EXC_CORPSE_NOTIFY &amp;&amp; task_corpse_pending_report(task)) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (!task-&gt;exc_actions[i].privileged) {
			old_exc_actions[i] = task-&gt;exc_actions[i].port;
			task-&gt;exc_actions[i].port = IP_NULL;
		}
	}<span class="enscript-comment">/* for */</span>
	
	<span class="enscript-keyword">if</span> (IP_VALID(task-&gt;itk_debug_control)) {
		ipc_port_release_send(task-&gt;itk_debug_control);
	}
	task-&gt;itk_debug_control = IP_NULL;
	
	itk_unlock(task);

	<span class="enscript-comment">/* release the naked send rights */</span>

	<span class="enscript-keyword">if</span> (IP_VALID(old_sself))
		ipc_port_release_send(old_sself);

	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; i++) {
		<span class="enscript-keyword">if</span> (IP_VALID(old_exc_actions[i])) {
			ipc_port_release_send(old_exc_actions[i]);
		}
	}<span class="enscript-comment">/* for */</span>

	<span class="enscript-comment">/* destroy the kernel port */</span>
	ipc_port_dealloc_kernel(old_kport);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_thread_init
 *	Purpose:
 *		Initialize a thread's IPC state.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_thread_init</span>(
	thread_t	thread)
{
	ipc_port_t	kport;

	kport = ipc_port_alloc_kernel();
	<span class="enscript-keyword">if</span> (kport == IP_NULL)
		panic(<span class="enscript-string">&quot;ipc_thread_init&quot;</span>);

	thread-&gt;ith_self = kport;
	thread-&gt;ith_sself = ipc_port_make_send(kport);
	thread-&gt;exc_actions = NULL;

	ipc_kobject_set(kport, (ipc_kobject_t)thread, IKOT_THREAD);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	thread-&gt;ith_assertions = 0;
#<span class="enscript-reference">endif</span>

	ipc_kmsg_queue_init(&amp;thread-&gt;ith_messages);

	thread-&gt;ith_rpc_reply = IP_NULL;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_thread_init_exc_actions</span>(
	thread_t	thread)
{
	assert(thread-&gt;exc_actions == NULL);

	thread-&gt;exc_actions = kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> exception_action) * EXC_TYPES_COUNT);
	bzero(thread-&gt;exc_actions, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> exception_action) * EXC_TYPES_COUNT);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_thread_destroy_exc_actions</span>(
	thread_t	thread)
{
	<span class="enscript-keyword">if</span> (thread-&gt;exc_actions != NULL) {
		kfree(thread-&gt;exc_actions, 
		      <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> exception_action) * EXC_TYPES_COUNT);
		thread-&gt;exc_actions = NULL;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_thread_disable</span>(
	thread_t	thread)
{
	ipc_port_t	kport = thread-&gt;ith_self;

	<span class="enscript-keyword">if</span> (kport != IP_NULL)
		ipc_kobject_set(kport, IKO_NULL, IKOT_NONE);
}

<span class="enscript-comment">/*
 *	Routine:	ipc_thread_terminate
 *	Purpose:
 *		Clean up and destroy a thread's IPC state.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_thread_terminate</span>(
	thread_t	thread)
{
	ipc_port_t	kport = thread-&gt;ith_self;

	<span class="enscript-keyword">if</span> (kport != IP_NULL) {
		<span class="enscript-type">int</span>			i;

		<span class="enscript-keyword">if</span> (IP_VALID(thread-&gt;ith_sself))
			ipc_port_release_send(thread-&gt;ith_sself);

		thread-&gt;ith_sself = thread-&gt;ith_self = IP_NULL;

		<span class="enscript-keyword">if</span> (thread-&gt;exc_actions != NULL) {
			<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; ++i) {
				<span class="enscript-keyword">if</span> (IP_VALID(thread-&gt;exc_actions[i].port))
					ipc_port_release_send(thread-&gt;exc_actions[i].port);
			}
			ipc_thread_destroy_exc_actions(thread);
		}

		ipc_port_dealloc_kernel(kport);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	assert(thread-&gt;ith_assertions == 0);
#<span class="enscript-reference">endif</span>

	assert(ipc_kmsg_queue_empty(&amp;thread-&gt;ith_messages));

	<span class="enscript-keyword">if</span> (thread-&gt;ith_rpc_reply != IP_NULL)
		ipc_port_dealloc_reply(thread-&gt;ith_rpc_reply);

	thread-&gt;ith_rpc_reply = IP_NULL;
}

<span class="enscript-comment">/*
 *	Routine:	ipc_thread_reset
 *	Purpose:
 *		Reset the IPC state for a given Mach thread when
 *		its task enters an elevated security context.
 * 		Both the thread port and its exception ports have
 *		to be reset.  Its RPC reply port cannot have any
 *		rights outstanding, so it should be fine.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_thread_reset</span>(
	thread_t	thread)
{
	ipc_port_t old_kport, new_kport;
	ipc_port_t old_sself;
	ipc_port_t old_exc_actions[EXC_TYPES_COUNT];
	boolean_t  has_old_exc_actions = FALSE;	
	<span class="enscript-type">int</span>		   i;

	new_kport = ipc_port_alloc_kernel();
	<span class="enscript-keyword">if</span> (new_kport == IP_NULL)
		panic(<span class="enscript-string">&quot;ipc_task_reset&quot;</span>);

	thread_mtx_lock(thread);

	old_kport = thread-&gt;ith_self;

	<span class="enscript-keyword">if</span> (old_kport == IP_NULL &amp;&amp; thread-&gt;inspection == FALSE) {
		<span class="enscript-comment">/* the  is already terminated (can this happen?) */</span>
		thread_mtx_unlock(thread);
		ipc_port_dealloc_kernel(new_kport);
		<span class="enscript-keyword">return</span>;
	}

	thread-&gt;ith_self = new_kport;
	old_sself = thread-&gt;ith_sself;
	thread-&gt;ith_sself = ipc_port_make_send(new_kport);
	<span class="enscript-keyword">if</span> (old_kport != IP_NULL) {
		ipc_kobject_set(old_kport, IKO_NULL, IKOT_NONE);
	}
	ipc_kobject_set(new_kport, (ipc_kobject_t) thread, IKOT_THREAD);

	<span class="enscript-comment">/*
	 * Only ports that were set by root-owned processes
	 * (privileged ports) should survive 
	 */</span>
	<span class="enscript-keyword">if</span> (thread-&gt;exc_actions != NULL) {
		has_old_exc_actions = TRUE;
		<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; i++) {
			<span class="enscript-keyword">if</span> (thread-&gt;exc_actions[i].privileged) {
				old_exc_actions[i] = IP_NULL;
			} <span class="enscript-keyword">else</span> {
				old_exc_actions[i] = thread-&gt;exc_actions[i].port;
				thread-&gt;exc_actions[i].port = IP_NULL;		
			}
		}
	}

	thread_mtx_unlock(thread);

	<span class="enscript-comment">/* release the naked send rights */</span>

	<span class="enscript-keyword">if</span> (IP_VALID(old_sself))
		ipc_port_release_send(old_sself);

	<span class="enscript-keyword">if</span> (has_old_exc_actions) {
		<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; i++) {
			ipc_port_release_send(old_exc_actions[i]);
		}
	}

	<span class="enscript-comment">/* destroy the kernel port */</span>
	<span class="enscript-keyword">if</span> (old_kport != IP_NULL) {
		ipc_port_dealloc_kernel(old_kport);
	}
}

<span class="enscript-comment">/*
 *	Routine:	retrieve_task_self_fast
 *	Purpose:
 *		Optimized version of retrieve_task_self,
 *		that only works for the current task.
 *
 *		Return a send right (possibly null/dead)
 *		for the task's user-visible self port.
 *	Conditions:
 *		Nothing locked.
 */</span>

ipc_port_t
<span class="enscript-function-name">retrieve_task_self_fast</span>(
	<span class="enscript-type">register</span> task_t		task)
{
	<span class="enscript-type">register</span> ipc_port_t port;

	assert(task == current_task());

	itk_lock(task);
	assert(task-&gt;itk_self != IP_NULL);

	<span class="enscript-keyword">if</span> ((port = task-&gt;itk_sself) == task-&gt;itk_self) {
		<span class="enscript-comment">/* no interposing */</span>

		ip_lock(port);
		assert(ip_active(port));
		ip_reference(port);
		port-&gt;ip_srights++;
		ip_unlock(port);
	} <span class="enscript-keyword">else</span>
		port = ipc_port_copy_send(port);
	itk_unlock(task);

	<span class="enscript-keyword">return</span> port;
}

<span class="enscript-comment">/*
 *	Routine:	retrieve_thread_self_fast
 *	Purpose:
 *		Return a send right (possibly null/dead)
 *		for the thread's user-visible self port.
 *
 *		Only works for the current thread.
 *
 *	Conditions:
 *		Nothing locked.
 */</span>

ipc_port_t
<span class="enscript-function-name">retrieve_thread_self_fast</span>(
	thread_t		thread)
{
	<span class="enscript-type">register</span> ipc_port_t port;

	assert(thread == current_thread());

	thread_mtx_lock(thread);

	assert(thread-&gt;ith_self != IP_NULL);

	<span class="enscript-keyword">if</span> ((port = thread-&gt;ith_sself) == thread-&gt;ith_self) {
		<span class="enscript-comment">/* no interposing */</span>

		ip_lock(port);
		assert(ip_active(port));
		ip_reference(port);
		port-&gt;ip_srights++;
		ip_unlock(port);
	}
	<span class="enscript-keyword">else</span>
		port = ipc_port_copy_send(port);

	thread_mtx_unlock(thread);

	<span class="enscript-keyword">return</span> port;
}

<span class="enscript-comment">/*
 *	Routine:	task_self_trap [mach trap]
 *	Purpose:
 *		Give the caller send rights for his own task port.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		MACH_PORT_NULL if there are any resource failures
 *		or other errors.
 */</span>

mach_port_name_t
<span class="enscript-function-name">task_self_trap</span>(
	__unused <span class="enscript-type">struct</span> task_self_trap_args *args)
{
	task_t task = current_task();
	ipc_port_t sright;
	mach_port_name_t name;

	sright = retrieve_task_self_fast(task);
	name = ipc_port_copyout_send(sright, task-&gt;itk_space);
	<span class="enscript-keyword">return</span> name;
}

<span class="enscript-comment">/*
 *	Routine:	thread_self_trap [mach trap]
 *	Purpose:
 *		Give the caller send rights for his own thread port.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		MACH_PORT_NULL if there are any resource failures
 *		or other errors.
 */</span>

mach_port_name_t
<span class="enscript-function-name">thread_self_trap</span>(
	__unused <span class="enscript-type">struct</span> thread_self_trap_args *args)
{
	thread_t  thread = current_thread();
	task_t task = thread-&gt;task;
	ipc_port_t sright;
	mach_port_name_t name;

	sright = retrieve_thread_self_fast(thread);
	name = ipc_port_copyout_send(sright, task-&gt;itk_space);
	<span class="enscript-keyword">return</span> name;

}

<span class="enscript-comment">/*
 *	Routine:	mach_reply_port [mach trap]
 *	Purpose:
 *		Allocate a port for the caller.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		MACH_PORT_NULL if there are any resource failures
 *		or other errors.
 */</span>

mach_port_name_t
<span class="enscript-function-name">mach_reply_port</span>(
	__unused <span class="enscript-type">struct</span> mach_reply_port_args *args)
{
	ipc_port_t port;
	mach_port_name_t name;
	kern_return_t kr;

	kr = ipc_port_alloc(current_task()-&gt;itk_space, &amp;name, &amp;port);
	<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS)
		ip_unlock(port);
	<span class="enscript-keyword">else</span>
		name = MACH_PORT_NULL;
	<span class="enscript-keyword">return</span> name;
}

<span class="enscript-comment">/*
 *	Routine:	thread_get_special_port [kernel call]
 *	Purpose:
 *		Clones a send right for one of the thread's
 *		special ports.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Extracted a send right.
 *		KERN_INVALID_ARGUMENT	The thread is null.
 *		KERN_FAILURE		The thread is dead.
 *		KERN_INVALID_ARGUMENT	Invalid special port.
 */</span>

kern_return_t
<span class="enscript-function-name">thread_get_special_port</span>(
	thread_t		thread,
	<span class="enscript-type">int</span>				which,
	ipc_port_t		*portp)
{
	kern_return_t	result = KERN_SUCCESS;
	ipc_port_t		*whichp;

	<span class="enscript-keyword">if</span> (thread == THREAD_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">switch</span> (which) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_KERNEL_PORT</span>:
		whichp = &amp;thread-&gt;ith_sself;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
	}

 	thread_mtx_lock(thread);

	<span class="enscript-keyword">if</span> (thread-&gt;active)
		*portp = ipc_port_copy_send(*whichp);
	<span class="enscript-keyword">else</span>
		result = KERN_FAILURE;

	thread_mtx_unlock(thread);

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/*
 *	Routine:	thread_set_special_port [kernel call]
 *	Purpose:
 *		Changes one of the thread's special ports,
 *		setting it to the supplied send right.
 *	Conditions:
 *		Nothing locked.  If successful, consumes
 *		the supplied send right.
 *	Returns:
 *		KERN_SUCCESS		Changed the special port.
 *		KERN_INVALID_ARGUMENT	The thread is null.
 *		KERN_FAILURE		The thread is dead.
 *		KERN_INVALID_ARGUMENT	Invalid special port.
 */</span>

kern_return_t
<span class="enscript-function-name">thread_set_special_port</span>(
	thread_t		thread,
	<span class="enscript-type">int</span>			which,
	ipc_port_t	port)
{
	kern_return_t	result = KERN_SUCCESS;
	ipc_port_t		*whichp, old = IP_NULL;

	<span class="enscript-keyword">if</span> (thread == THREAD_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">switch</span> (which) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_KERNEL_PORT</span>:
		whichp = &amp;thread-&gt;ith_sself;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
	}

	thread_mtx_lock(thread);

	<span class="enscript-keyword">if</span> (thread-&gt;active) {
		old = *whichp;
		*whichp = port;
	}
	<span class="enscript-keyword">else</span>
		result = KERN_FAILURE;

	thread_mtx_unlock(thread);

	<span class="enscript-keyword">if</span> (IP_VALID(old))
		ipc_port_release_send(old);

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/*
 *	Routine:	task_get_special_port [kernel call]
 *	Purpose:
 *		Clones a send right for one of the task's
 *		special ports.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Extracted a send right.
 *		KERN_INVALID_ARGUMENT	The task is null.
 *		KERN_FAILURE		The task/space is dead.
 *		KERN_INVALID_ARGUMENT	Invalid special port.
 */</span>

kern_return_t
<span class="enscript-function-name">task_get_special_port</span>(
	task_t		task,
	<span class="enscript-type">int</span>		which,
	ipc_port_t	*portp)
{
	ipc_port_t port;

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	itk_lock(task);
	<span class="enscript-keyword">if</span> (task-&gt;itk_self == IP_NULL) {
		itk_unlock(task);
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	<span class="enscript-keyword">switch</span> (which) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_KERNEL_PORT</span>:
		port = ipc_port_copy_send(task-&gt;itk_sself);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_NAME_PORT</span>:
		port = ipc_port_make_send(task-&gt;itk_nself);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_HOST_PORT</span>:
		port = ipc_port_copy_send(task-&gt;itk_host);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BOOTSTRAP_PORT</span>:
		port = ipc_port_copy_send(task-&gt;itk_bootstrap);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_SEATBELT_PORT</span>:
		port = ipc_port_copy_send(task-&gt;itk_seatbelt);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_ACCESS_PORT</span>:
		port = ipc_port_copy_send(task-&gt;itk_task_access);
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_DEBUG_CONTROL_PORT</span>:
		port = ipc_port_copy_send(task-&gt;itk_debug_control);
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
               itk_unlock(task);
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}
	itk_unlock(task);

	*portp = port;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	task_set_special_port [kernel call]
 *	Purpose:
 *		Changes one of the task's special ports,
 *		setting it to the supplied send right.
 *	Conditions:
 *		Nothing locked.  If successful, consumes
 *		the supplied send right.
 *	Returns:
 *		KERN_SUCCESS		Changed the special port.
 *		KERN_INVALID_ARGUMENT	The task is null.
 *		KERN_FAILURE		The task/space is dead.
 *		KERN_INVALID_ARGUMENT	Invalid special port.
 * 		KERN_NO_ACCESS		Attempted overwrite of seatbelt port.
 */</span>

kern_return_t
<span class="enscript-function-name">task_set_special_port</span>(
	task_t		task,
	<span class="enscript-type">int</span>		which,
	ipc_port_t	port)
{
	ipc_port_t *whichp;
	ipc_port_t old;

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	<span class="enscript-keyword">switch</span> (which) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_KERNEL_PORT</span>:
		whichp = &amp;task-&gt;itk_sself;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_HOST_PORT</span>:
		whichp = &amp;task-&gt;itk_host;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BOOTSTRAP_PORT</span>:
		whichp = &amp;task-&gt;itk_bootstrap;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_SEATBELT_PORT</span>:
		whichp = &amp;task-&gt;itk_seatbelt;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_ACCESS_PORT</span>:
		whichp = &amp;task-&gt;itk_task_access;
		<span class="enscript-keyword">break</span>;
		
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_DEBUG_CONTROL_PORT</span>: 
		whichp = &amp;task-&gt;itk_debug_control;
		<span class="enscript-keyword">break</span>;


	    <span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}<span class="enscript-comment">/* switch */</span>

	itk_lock(task);
	<span class="enscript-keyword">if</span> (task-&gt;itk_self == IP_NULL) {
		itk_unlock(task);
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	<span class="enscript-comment">/* do not allow overwrite of seatbelt or task access ports */</span>
	<span class="enscript-keyword">if</span> ((TASK_SEATBELT_PORT == which  || TASK_ACCESS_PORT == which) 
		&amp;&amp; IP_VALID(*whichp)) {
			itk_unlock(task);
			<span class="enscript-keyword">return</span> KERN_NO_ACCESS;
	}

	old = *whichp;
	*whichp = port;
	itk_unlock(task);

	<span class="enscript-keyword">if</span> (IP_VALID(old))
		ipc_port_release_send(old);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-comment">/*
 *	Routine:	mach_ports_register [kernel call]
 *	Purpose:
 *		Stash a handful of port send rights in the task.
 *		Child tasks will inherit these rights, but they
 *		must use mach_ports_lookup to acquire them.
 *
 *		The rights are supplied in a (wired) kalloc'd segment.
 *		Rights which aren't supplied are assumed to be null.
 *	Conditions:
 *		Nothing locked.  If successful, consumes
 *		the supplied rights and memory.
 *	Returns:
 *		KERN_SUCCESS		Stashed the port rights.
 *		KERN_INVALID_ARGUMENT	The task is null.
 *		KERN_INVALID_ARGUMENT	The task is dead.
 *		KERN_INVALID_ARGUMENT	The memory param is null.
 *		KERN_INVALID_ARGUMENT	Too many port rights supplied.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_ports_register</span>(
	task_t			task,
	mach_port_array_t	memory,
	mach_msg_type_number_t	portsCnt)
{
	ipc_port_t ports[TASK_PORT_REGISTER_MAX];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> ((task == TASK_NULL) ||
	    (portsCnt &gt; TASK_PORT_REGISTER_MAX) ||
	    (portsCnt &amp;&amp; memory == NULL))
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	<span class="enscript-comment">/*
	 *	Pad the port rights with nulls.
	 */</span>

	<span class="enscript-keyword">for</span> (i = 0; i &lt; portsCnt; i++)
		ports[i] = memory[i];
	<span class="enscript-keyword">for</span> (; i &lt; TASK_PORT_REGISTER_MAX; i++)
		ports[i] = IP_NULL;

	itk_lock(task);
	<span class="enscript-keyword">if</span> (task-&gt;itk_self == IP_NULL) {
		itk_unlock(task);
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-comment">/*
	 *	Replace the old send rights with the new.
	 *	Release the old rights after unlocking.
	 */</span>

	<span class="enscript-keyword">for</span> (i = 0; i &lt; TASK_PORT_REGISTER_MAX; i++) {
		ipc_port_t old;

		old = task-&gt;itk_registered[i];
		task-&gt;itk_registered[i] = ports[i];
		ports[i] = old;
	}

	itk_unlock(task);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; TASK_PORT_REGISTER_MAX; i++)
		<span class="enscript-keyword">if</span> (IP_VALID(ports[i]))
			ipc_port_release_send(ports[i]);

	<span class="enscript-comment">/*
	 *	Now that the operation is known to be successful,
	 *	we can free the memory.
	 */</span>

	<span class="enscript-keyword">if</span> (portsCnt != 0)
		kfree(memory,
		      (vm_size_t) (portsCnt * <span class="enscript-keyword">sizeof</span>(mach_port_t)));

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	mach_ports_lookup [kernel call]
 *	Purpose:
 *		Retrieves (clones) the stashed port send rights.
 *	Conditions:
 *		Nothing locked.  If successful, the caller gets
 *		rights and memory.
 *	Returns:
 *		KERN_SUCCESS		Retrieved the send rights.
 *		KERN_INVALID_ARGUMENT	The task is null.
 *		KERN_INVALID_ARGUMENT	The task is dead.
 *		KERN_RESOURCE_SHORTAGE	Couldn't allocate memory.
 */</span>

kern_return_t
<span class="enscript-function-name">mach_ports_lookup</span>(
	task_t			task,
	mach_port_array_t	*portsp,
	mach_msg_type_number_t	*portsCnt)
{
	<span class="enscript-type">void</span>  *memory;
	vm_size_t size;
	ipc_port_t *ports;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	size = (vm_size_t) (TASK_PORT_REGISTER_MAX * <span class="enscript-keyword">sizeof</span>(ipc_port_t));

	memory = kalloc(size);
	<span class="enscript-keyword">if</span> (memory == 0)
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;

	itk_lock(task);
	<span class="enscript-keyword">if</span> (task-&gt;itk_self == IP_NULL) {
		itk_unlock(task);

		kfree(memory, size);
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	ports = (ipc_port_t *) memory;

	<span class="enscript-comment">/*
	 *	Clone port rights.  Because kalloc'd memory
	 *	is wired, we won't fault while holding the task lock.
	 */</span>

	<span class="enscript-keyword">for</span> (i = 0; i &lt; TASK_PORT_REGISTER_MAX; i++)
		ports[i] = ipc_port_copy_send(task-&gt;itk_registered[i]);

	itk_unlock(task);

	*portsp = (mach_port_array_t) ports;
	*portsCnt = TASK_PORT_REGISTER_MAX;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine: convert_port_to_locked_task
 *	Purpose:
 *		Internal helper routine to convert from a port to a locked
 *		task.  Used by several routines that try to convert from a
 *		task port to a reference on some task related object.
 *	Conditions:
 *		Nothing locked, blocking OK.
 */</span>
task_t
<span class="enscript-function-name">convert_port_to_locked_task</span>(ipc_port_t port)
{
        <span class="enscript-type">int</span> try_failed_count = 0;

	<span class="enscript-keyword">while</span> (IP_VALID(port)) {
		task_t task;

		ip_lock(port);
		<span class="enscript-keyword">if</span> (!ip_active(port) || (ip_kotype(port) != IKOT_TASK)) {
			ip_unlock(port);
			<span class="enscript-keyword">return</span> TASK_NULL;
		}
		task = (task_t) port-&gt;ip_kobject;
		assert(task != TASK_NULL);

		<span class="enscript-comment">/*
		 * Normal lock ordering puts task_lock() before ip_lock().
		 * Attempt out-of-order locking here.
		 */</span>
		<span class="enscript-keyword">if</span> (task_lock_try(task)) {
			ip_unlock(port);
			<span class="enscript-keyword">return</span>(task);
		}
		try_failed_count++;

		ip_unlock(port);
		mutex_pause(try_failed_count);
	}
	<span class="enscript-keyword">return</span> TASK_NULL;
}

<span class="enscript-comment">/*
 *	Routine:	convert_port_to_task
 *	Purpose:
 *		Convert from a port to a task.
 *		Doesn't consume the port ref; produces a task ref,
 *		which may be null.
 *	Conditions:
 *		Nothing locked.
 */</span>
task_t
<span class="enscript-function-name">convert_port_to_task</span>(
	ipc_port_t		port)
{
	task_t		task = TASK_NULL;

	<span class="enscript-keyword">if</span> (IP_VALID(port)) {
		ip_lock(port);

		<span class="enscript-keyword">if</span> (	ip_active(port)					&amp;&amp;
				ip_kotype(port) == IKOT_TASK		) {
			task = (task_t)port-&gt;ip_kobject;
			assert(task != TASK_NULL);

			task_reference_internal(task);
		}

		ip_unlock(port);
	}

	<span class="enscript-keyword">return</span> (task);
}

<span class="enscript-comment">/*
 *	Routine:	convert_port_to_task_name
 *	Purpose:
 *		Convert from a port to a task name.
 *		Doesn't consume the port ref; produces a task name ref,
 *		which may be null.
 *	Conditions:
 *		Nothing locked.
 */</span>
task_name_t
<span class="enscript-function-name">convert_port_to_task_name</span>(
	ipc_port_t		port)
{
	task_name_t		task = TASK_NULL;

	<span class="enscript-keyword">if</span> (IP_VALID(port)) {
		ip_lock(port);

		<span class="enscript-keyword">if</span> (	ip_active(port)					&amp;&amp;
				(ip_kotype(port) == IKOT_TASK	||
				 ip_kotype(port) == IKOT_TASK_NAME)) {
			task = (task_name_t)port-&gt;ip_kobject;
			assert(task != TASK_NAME_NULL);

			task_reference_internal(task);
		}

		ip_unlock(port);
	}

	<span class="enscript-keyword">return</span> (task);
}

<span class="enscript-comment">/*
 *	Routine:	convert_port_to_task_suspension_token
 *	Purpose:
 *		Convert from a port to a task suspension token.
 *		Doesn't consume the port ref; produces a suspension token ref,
 *		which may be null.
 *	Conditions:
 *		Nothing locked.
 */</span>
task_suspension_token_t
<span class="enscript-function-name">convert_port_to_task_suspension_token</span>(
	ipc_port_t		port)
{
	task_suspension_token_t		task = TASK_NULL;

	<span class="enscript-keyword">if</span> (IP_VALID(port)) {
		ip_lock(port);

		<span class="enscript-keyword">if</span> (	ip_active(port)					&amp;&amp;
				ip_kotype(port) == IKOT_TASK_RESUME) {
			task = (task_suspension_token_t)port-&gt;ip_kobject;
			assert(task != TASK_NULL);

			task_reference_internal(task);
		}

		ip_unlock(port);
	}

	<span class="enscript-keyword">return</span> (task);
}

<span class="enscript-comment">/*
 *	Routine:	convert_port_to_space
 *	Purpose:
 *		Convert from a port to a space.
 *		Doesn't consume the port ref; produces a space ref,
 *		which may be null.
 *	Conditions:
 *		Nothing locked.
 */</span>
ipc_space_t
<span class="enscript-function-name">convert_port_to_space</span>(
	ipc_port_t	port)
{
	ipc_space_t space;
	task_t task;

	task = convert_port_to_locked_task(port);

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> IPC_SPACE_NULL;

	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		task_unlock(task);
		<span class="enscript-keyword">return</span> IPC_SPACE_NULL;
	}
		
	space = task-&gt;itk_space;
	is_reference(space);
	task_unlock(task);
	<span class="enscript-keyword">return</span> (space);
}

<span class="enscript-comment">/*
 *	Routine:	convert_port_to_map
 *	Purpose:
 *		Convert from a port to a map.
 *		Doesn't consume the port ref; produces a map ref,
 *		which may be null.
 *	Conditions:
 *		Nothing locked.
 */</span>

vm_map_t
<span class="enscript-function-name">convert_port_to_map</span>(
	ipc_port_t	port)
{
	task_t task;
	vm_map_t map;

	task = convert_port_to_locked_task(port);
		
	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> VM_MAP_NULL;

	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		task_unlock(task);
		<span class="enscript-keyword">return</span> VM_MAP_NULL;
	}
		
	map = task-&gt;map;
	vm_map_reference_swap(map);
	task_unlock(task);
	<span class="enscript-keyword">return</span> map;
}


<span class="enscript-comment">/*
 *	Routine:	convert_port_to_thread
 *	Purpose:
 *		Convert from a port to a thread.
 *		Doesn't consume the port ref; produces an thread ref,
 *		which may be null.
 *	Conditions:
 *		Nothing locked.
 */</span>

thread_t
<span class="enscript-function-name">convert_port_to_thread</span>(
	ipc_port_t		port)
{
	thread_t	thread = THREAD_NULL;

	<span class="enscript-keyword">if</span> (IP_VALID(port)) {
		ip_lock(port);

		<span class="enscript-keyword">if</span> (	ip_active(port)					&amp;&amp;
				ip_kotype(port) == IKOT_THREAD		) {
			thread = (thread_t)port-&gt;ip_kobject;
			assert(thread != THREAD_NULL);

			thread_reference_internal(thread);
		}

		ip_unlock(port);
	}

	<span class="enscript-keyword">return</span> (thread);
}

<span class="enscript-comment">/*
 *	Routine:	port_name_to_thread
 *	Purpose:
 *		Convert from a port name to an thread reference
 *		A name of MACH_PORT_NULL is valid for the null thread.
 *	Conditions:
 *		Nothing locked.
 *
 *	TODO: Could this be faster if it were ipc_port_translate_send based, like thread_switch?
 *	      We could avoid extra lock/unlock and extra ref operations on the port.
 */</span>
thread_t
<span class="enscript-function-name">port_name_to_thread</span>(
	mach_port_name_t	name)
{
	thread_t	thread = THREAD_NULL;
	ipc_port_t	kport;

	<span class="enscript-keyword">if</span> (MACH_PORT_VALID(name)) {
		<span class="enscript-keyword">if</span> (ipc_object_copyin(current_space(), name,
					       MACH_MSG_TYPE_COPY_SEND,
							  (ipc_object_t *)&amp;kport) != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> (THREAD_NULL);

		thread = convert_port_to_thread(kport);
		
		<span class="enscript-keyword">if</span> (IP_VALID(kport))
			ipc_port_release_send(kport);
	}

	<span class="enscript-keyword">return</span> (thread);
}

task_t
<span class="enscript-function-name">port_name_to_task</span>(
	mach_port_name_t name)
{
	ipc_port_t kern_port;
	kern_return_t kr;
	task_t task = TASK_NULL;

	<span class="enscript-keyword">if</span> (MACH_PORT_VALID(name)) {
		kr = ipc_object_copyin(current_space(), name,
				       MACH_MSG_TYPE_COPY_SEND,
				       (ipc_object_t *) &amp;kern_port);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> TASK_NULL;

		task = convert_port_to_task(kern_port);

		<span class="enscript-keyword">if</span> (IP_VALID(kern_port))
			ipc_port_release_send(kern_port);
	}
	<span class="enscript-keyword">return</span> task;
}

<span class="enscript-comment">/*
 *	Routine:	convert_task_to_port
 *	Purpose:
 *		Convert from a task to a port.
 *		Consumes a task ref; produces a naked send right
 *		which may be invalid.  
 *	Conditions:
 *		Nothing locked.
 */</span>

ipc_port_t
<span class="enscript-function-name">convert_task_to_port</span>(
	task_t		task)
{
	ipc_port_t port;

	itk_lock(task);
	<span class="enscript-keyword">if</span> (task-&gt;itk_self != IP_NULL)
		port = ipc_port_make_send(task-&gt;itk_self);
	<span class="enscript-keyword">else</span>
		port = IP_NULL;
	itk_unlock(task);

	task_deallocate(task);
	<span class="enscript-keyword">return</span> port;
}

<span class="enscript-comment">/*
 *	Routine:	convert_task_suspend_token_to_port
 *	Purpose:
 *		Convert from a task suspension token to a port.
 *		Consumes a task suspension token ref; produces a naked send-once right
 *		which may be invalid.  
 *	Conditions:
 *		Nothing locked.
 */</span>
ipc_port_t
<span class="enscript-function-name">convert_task_suspension_token_to_port</span>(
	task_suspension_token_t		task)
{
	ipc_port_t port;

	task_lock(task);
	<span class="enscript-keyword">if</span> (task-&gt;active) {
		<span class="enscript-keyword">if</span> (task-&gt;itk_resume == IP_NULL) {
			task-&gt;itk_resume = ipc_port_alloc_kernel();
			<span class="enscript-keyword">if</span> (!IP_VALID(task-&gt;itk_resume)) {
				panic(<span class="enscript-string">&quot;failed to create resume port&quot;</span>);
			}

			ipc_kobject_set(task-&gt;itk_resume, (ipc_kobject_t) task, IKOT_TASK_RESUME);
		}

		<span class="enscript-comment">/*
		 * Create a send-once right for each instance of a direct user-called
		 * task_suspend2 call. Each time one of these send-once rights is abandoned,
		 * the notification handler will resume the target task.
		 */</span>
		port = ipc_port_make_sonce(task-&gt;itk_resume);
		assert(IP_VALID(port));
	} <span class="enscript-keyword">else</span> {
		port = IP_NULL;
	}

	task_unlock(task);
	task_suspension_token_deallocate(task);

	<span class="enscript-keyword">return</span> port;
}


<span class="enscript-comment">/*
 *	Routine:	convert_task_name_to_port
 *	Purpose:
 *		Convert from a task name ref to a port.
 *		Consumes a task name ref; produces a naked send right
 *		which may be invalid.  
 *	Conditions:
 *		Nothing locked.
 */</span>

ipc_port_t
<span class="enscript-function-name">convert_task_name_to_port</span>(
	task_name_t		task_name)
{
	ipc_port_t port;

	itk_lock(task_name);
	<span class="enscript-keyword">if</span> (task_name-&gt;itk_nself != IP_NULL)
		port = ipc_port_make_send(task_name-&gt;itk_nself);
	<span class="enscript-keyword">else</span>
		port = IP_NULL;
	itk_unlock(task_name);

	task_name_deallocate(task_name);
	<span class="enscript-keyword">return</span> port;
}

<span class="enscript-comment">/*
 *	Routine:	convert_thread_to_port
 *	Purpose:
 *		Convert from a thread to a port.
 *		Consumes an thread ref; produces a naked send right
 *		which may be invalid.
 *	Conditions:
 *		Nothing locked.
 */</span>

ipc_port_t
<span class="enscript-function-name">convert_thread_to_port</span>(
	thread_t		thread)
{
	ipc_port_t		port;

	thread_mtx_lock(thread);

	<span class="enscript-keyword">if</span> (thread-&gt;ith_self != IP_NULL)
		port = ipc_port_make_send(thread-&gt;ith_self);
	<span class="enscript-keyword">else</span>
		port = IP_NULL;

	thread_mtx_unlock(thread);

	thread_deallocate(thread);

	<span class="enscript-keyword">return</span> (port);
}

<span class="enscript-comment">/*
 *	Routine:	space_deallocate
 *	Purpose:
 *		Deallocate a space ref produced by convert_port_to_space.
 *	Conditions:
 *		Nothing locked.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">space_deallocate</span>(
	ipc_space_t	space)
{
	<span class="enscript-keyword">if</span> (space != IS_NULL)
		is_release(space);
}

<span class="enscript-comment">/*
 *	Routine:	thread/task_set_exception_ports [kernel call]
 *	Purpose:
 *			Sets the thread/task exception port, flavor and
 *			behavior for the exception types specified by the mask.
 *			There will be one send right per exception per valid
 *			port.
 *	Conditions:
 *		Nothing locked.  If successful, consumes
 *		the supplied send right.
 *	Returns:
 *		KERN_SUCCESS		Changed the special port.
 *		KERN_INVALID_ARGUMENT	The thread is null,
 *					Illegal mask bit set.
 *					Illegal exception behavior
 *		KERN_FAILURE		The thread is dead.
 */</span>

kern_return_t
<span class="enscript-function-name">thread_set_exception_ports</span>(
	thread_t		 		thread,
	exception_mask_t		exception_mask,
	ipc_port_t				new_port,
	exception_behavior_t	new_behavior,
	thread_state_flavor_t	new_flavor)
{
	ipc_port_t		old_port[EXC_TYPES_COUNT];
	boolean_t privileged = current_task()-&gt;sec_token.val[0] == 0;
	<span class="enscript-type">register</span> <span class="enscript-type">int</span>	i;

	<span class="enscript-keyword">if</span> (thread == THREAD_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (exception_mask &amp; ~EXC_MASK_VALID)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (IP_VALID(new_port)) {
		<span class="enscript-keyword">switch</span> (new_behavior &amp; ~MACH_EXCEPTION_CODES) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_DEFAULT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_STATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_STATE_IDENTITY</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
		}
	}

	<span class="enscript-comment">/* 
	 * Check the validity of the thread_state_flavor by calling the
	 * VALID_THREAD_STATE_FLAVOR architecture dependent macro defined in
	 * osfmk/mach/ARCHITECTURE/thread_status.h
	 */</span>
	<span class="enscript-keyword">if</span> (new_flavor != 0 &amp;&amp; !VALID_THREAD_STATE_FLAVOR(new_flavor))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	thread_mtx_lock(thread);

	<span class="enscript-keyword">if</span> (!thread-&gt;active) {
		thread_mtx_unlock(thread);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	<span class="enscript-keyword">if</span> (thread-&gt;exc_actions == NULL) {
		ipc_thread_init_exc_actions(thread);
	}
	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; ++i) {
		<span class="enscript-keyword">if</span> (exception_mask &amp; (1 &lt;&lt; i)) {
			old_port[i] = thread-&gt;exc_actions[i].port;
			thread-&gt;exc_actions[i].port = ipc_port_copy_send(new_port);
			thread-&gt;exc_actions[i].behavior = new_behavior;
			thread-&gt;exc_actions[i].flavor = new_flavor;
			thread-&gt;exc_actions[i].privileged = privileged;
		}
		<span class="enscript-keyword">else</span>
			old_port[i] = IP_NULL;
	}

	thread_mtx_unlock(thread);

	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; ++i)
		<span class="enscript-keyword">if</span> (IP_VALID(old_port[i]))
			ipc_port_release_send(old_port[i]);

	<span class="enscript-keyword">if</span> (IP_VALID(new_port))		 <span class="enscript-comment">/* consume send right */</span>
		ipc_port_release_send(new_port);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">task_set_exception_ports</span>(
	task_t					task,
	exception_mask_t		exception_mask,
	ipc_port_t				new_port,
	exception_behavior_t	new_behavior,
	thread_state_flavor_t	new_flavor)
{
	ipc_port_t		old_port[EXC_TYPES_COUNT];
	boolean_t privileged = current_task()-&gt;sec_token.val[0] == 0;
	<span class="enscript-type">register</span> <span class="enscript-type">int</span>	i;

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (exception_mask &amp; ~EXC_MASK_VALID)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (IP_VALID(new_port)) {
		<span class="enscript-keyword">switch</span> (new_behavior &amp; ~MACH_EXCEPTION_CODES) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_DEFAULT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_STATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_STATE_IDENTITY</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
		}
	}

	<span class="enscript-comment">/*
	 * Check the validity of the thread_state_flavor by calling the
	 * VALID_THREAD_STATE_FLAVOR architecture dependent macro defined in
	 * osfmk/mach/ARCHITECTURE/thread_status.h
	 */</span>
	<span class="enscript-keyword">if</span> (new_flavor != 0 &amp;&amp; !VALID_THREAD_STATE_FLAVOR(new_flavor))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	itk_lock(task);

	<span class="enscript-keyword">if</span> (task-&gt;itk_self == IP_NULL) {
		itk_unlock(task);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; ++i) {
		<span class="enscript-keyword">if</span> (exception_mask &amp; (1 &lt;&lt; i)) {
			old_port[i] = task-&gt;exc_actions[i].port;
			task-&gt;exc_actions[i].port =
				ipc_port_copy_send(new_port);
			task-&gt;exc_actions[i].behavior = new_behavior;
			task-&gt;exc_actions[i].flavor = new_flavor;
			task-&gt;exc_actions[i].privileged = privileged;
		}
		<span class="enscript-keyword">else</span>
			old_port[i] = IP_NULL;
	}

	itk_unlock(task);

	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; ++i)
		<span class="enscript-keyword">if</span> (IP_VALID(old_port[i]))
			ipc_port_release_send(old_port[i]);

	<span class="enscript-keyword">if</span> (IP_VALID(new_port))		 <span class="enscript-comment">/* consume send right */</span>
		ipc_port_release_send(new_port);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 *	Routine:	thread/task_swap_exception_ports [kernel call]
 *	Purpose:
 *			Sets the thread/task exception port, flavor and
 *			behavior for the exception types specified by the
 *			mask.
 *
 *			The old ports, behavior and flavors are returned
 *			Count specifies the array sizes on input and
 *			the number of returned ports etc. on output.  The
 *			arrays must be large enough to hold all the returned
 *			data, MIG returnes an error otherwise.  The masks
 *			array specifies the corresponding exception type(s).
 *
 *	Conditions:
 *		Nothing locked.  If successful, consumes
 *		the supplied send right.
 *
 *		Returns upto [in} CountCnt elements.
 *	Returns:
 *		KERN_SUCCESS		Changed the special port.
 *		KERN_INVALID_ARGUMENT	The thread is null,
 *					Illegal mask bit set.
 *					Illegal exception behavior
 *		KERN_FAILURE		The thread is dead.
 */</span>

kern_return_t
<span class="enscript-function-name">thread_swap_exception_ports</span>(
	thread_t					thread,
	exception_mask_t			exception_mask,
	ipc_port_t					new_port,
	exception_behavior_t		new_behavior,
	thread_state_flavor_t		new_flavor,
	exception_mask_array_t		masks,
	mach_msg_type_number_t		*CountCnt,
	exception_port_array_t		ports,
	exception_behavior_array_t	behaviors,
	thread_state_flavor_array_t	flavors)
{
	ipc_port_t		old_port[EXC_TYPES_COUNT];
	boolean_t privileged = current_task()-&gt;sec_token.val[0] == 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i, j, count;

	<span class="enscript-keyword">if</span> (thread == THREAD_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (exception_mask &amp; ~EXC_MASK_VALID)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (IP_VALID(new_port)) {
		<span class="enscript-keyword">switch</span> (new_behavior &amp; ~MACH_EXCEPTION_CODES) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_DEFAULT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_STATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_STATE_IDENTITY</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
		}
	}

	<span class="enscript-keyword">if</span> (new_flavor != 0 &amp;&amp; !VALID_THREAD_STATE_FLAVOR(new_flavor))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	thread_mtx_lock(thread);

	<span class="enscript-keyword">if</span> (!thread-&gt;active) {
		thread_mtx_unlock(thread);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	<span class="enscript-keyword">if</span> (thread-&gt;exc_actions == NULL) {
		ipc_thread_init_exc_actions(thread);
	}

	assert(EXC_TYPES_COUNT &gt; FIRST_EXCEPTION);
	<span class="enscript-keyword">for</span> (count = 0, i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT &amp;&amp; count &lt; *CountCnt; ++i) {
		<span class="enscript-keyword">if</span> (exception_mask &amp; (1 &lt;&lt; i)) {
			<span class="enscript-keyword">for</span> (j = 0; j &lt; count; ++j) {
				<span class="enscript-comment">/*
				 * search for an identical entry, if found
				 * set corresponding mask for this exception.
				 */</span>
				<span class="enscript-keyword">if</span> (	thread-&gt;exc_actions[i].port == ports[j]				&amp;&amp;
						thread-&gt;exc_actions[i].behavior == behaviors[j]		&amp;&amp;
						thread-&gt;exc_actions[i].flavor == flavors[j]			) {
					masks[j] |= (1 &lt;&lt; i);
					<span class="enscript-keyword">break</span>;
				}
			}

			<span class="enscript-keyword">if</span> (j == count) {
				masks[j] = (1 &lt;&lt; i);
				ports[j] = ipc_port_copy_send(thread-&gt;exc_actions[i].port);

				behaviors[j] = thread-&gt;exc_actions[i].behavior;
				flavors[j] = thread-&gt;exc_actions[i].flavor;
				++count;
			}

			old_port[i] = thread-&gt;exc_actions[i].port;
			thread-&gt;exc_actions[i].port = ipc_port_copy_send(new_port);
			thread-&gt;exc_actions[i].behavior = new_behavior;
			thread-&gt;exc_actions[i].flavor = new_flavor;
			thread-&gt;exc_actions[i].privileged = privileged;
		}
		<span class="enscript-keyword">else</span>
			old_port[i] = IP_NULL;
	}

	thread_mtx_unlock(thread);

	<span class="enscript-keyword">while</span> (--i &gt;= FIRST_EXCEPTION) {
		<span class="enscript-keyword">if</span> (IP_VALID(old_port[i]))
			ipc_port_release_send(old_port[i]);
	}

	<span class="enscript-keyword">if</span> (IP_VALID(new_port))		 <span class="enscript-comment">/* consume send right */</span>
		ipc_port_release_send(new_port);

	*CountCnt = count;

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">task_swap_exception_ports</span>(
	task_t						task,
	exception_mask_t			exception_mask,
	ipc_port_t					new_port,
	exception_behavior_t		new_behavior,
	thread_state_flavor_t		new_flavor,
	exception_mask_array_t		masks,
	mach_msg_type_number_t		*CountCnt,
	exception_port_array_t		ports,
	exception_behavior_array_t	behaviors,
	thread_state_flavor_array_t	flavors)
{
	ipc_port_t		old_port[EXC_TYPES_COUNT];
	boolean_t privileged = current_task()-&gt;sec_token.val[0] == 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i, j, count;

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (exception_mask &amp; ~EXC_MASK_VALID)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (IP_VALID(new_port)) {
		<span class="enscript-keyword">switch</span> (new_behavior &amp; ~MACH_EXCEPTION_CODES) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_DEFAULT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_STATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_STATE_IDENTITY</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
		}
	}

	<span class="enscript-keyword">if</span> (new_flavor != 0 &amp;&amp; !VALID_THREAD_STATE_FLAVOR(new_flavor))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	itk_lock(task);

	<span class="enscript-keyword">if</span> (task-&gt;itk_self == IP_NULL) {
		itk_unlock(task);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	assert(EXC_TYPES_COUNT &gt; FIRST_EXCEPTION);
	<span class="enscript-keyword">for</span> (count = 0, i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT &amp;&amp; count &lt; *CountCnt; ++i) {
		<span class="enscript-keyword">if</span> (exception_mask &amp; (1 &lt;&lt; i)) {
			<span class="enscript-keyword">for</span> (j = 0; j &lt; count; j++) {
				<span class="enscript-comment">/*
				 * search for an identical entry, if found
				 * set corresponding mask for this exception.
				 */</span>
				<span class="enscript-keyword">if</span> (	task-&gt;exc_actions[i].port == ports[j]			&amp;&amp;
						task-&gt;exc_actions[i].behavior == behaviors[j]	&amp;&amp;
						task-&gt;exc_actions[i].flavor == flavors[j]		) {
					masks[j] |= (1 &lt;&lt; i);
					<span class="enscript-keyword">break</span>;
				}
			}

			<span class="enscript-keyword">if</span> (j == count) {
				masks[j] = (1 &lt;&lt; i);
				ports[j] = ipc_port_copy_send(task-&gt;exc_actions[i].port);
				behaviors[j] = task-&gt;exc_actions[i].behavior;
				flavors[j] = task-&gt;exc_actions[i].flavor;
				++count;
			}

			old_port[i] = task-&gt;exc_actions[i].port;

			task-&gt;exc_actions[i].port =	ipc_port_copy_send(new_port);
			task-&gt;exc_actions[i].behavior = new_behavior;
			task-&gt;exc_actions[i].flavor = new_flavor;
			task-&gt;exc_actions[i].privileged = privileged;
		}
		<span class="enscript-keyword">else</span>
			old_port[i] = IP_NULL;
	}

	itk_unlock(task);

	<span class="enscript-keyword">while</span> (--i &gt;= FIRST_EXCEPTION) {
		<span class="enscript-keyword">if</span> (IP_VALID(old_port[i]))
			ipc_port_release_send(old_port[i]);
	}

	<span class="enscript-keyword">if</span> (IP_VALID(new_port))		 <span class="enscript-comment">/* consume send right */</span>
		ipc_port_release_send(new_port);

	*CountCnt = count;

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 *	Routine:	thread/task_get_exception_ports [kernel call]
 *	Purpose:
 *		Clones a send right for each of the thread/task's exception
 *		ports specified in the mask and returns the behaviour
 *		and flavor of said port.
 *
 *		Returns upto [in} CountCnt elements.
 *
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Extracted a send right.
 *		KERN_INVALID_ARGUMENT	The thread is null,
 *					Invalid special port,
 *					Illegal mask bit set.
 *		KERN_FAILURE		The thread is dead.
 */</span>

kern_return_t
<span class="enscript-function-name">thread_get_exception_ports</span>(
	thread_t					thread,
	exception_mask_t			exception_mask,
	exception_mask_array_t		masks,
	mach_msg_type_number_t		*CountCnt,
	exception_port_array_t		ports,
	exception_behavior_array_t	behaviors,
	thread_state_flavor_array_t	flavors)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i, j, count;

	<span class="enscript-keyword">if</span> (thread == THREAD_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (exception_mask &amp; ~EXC_MASK_VALID)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	thread_mtx_lock(thread);

	<span class="enscript-keyword">if</span> (!thread-&gt;active) {
		thread_mtx_unlock(thread);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	count = 0;

	<span class="enscript-keyword">if</span> (thread-&gt;exc_actions == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; ++i) {
		<span class="enscript-keyword">if</span> (exception_mask &amp; (1 &lt;&lt; i)) {
			<span class="enscript-keyword">for</span> (j = 0; j &lt; count; ++j) {
				<span class="enscript-comment">/*
				 * search for an identical entry, if found
				 * set corresponding mask for this exception.
				 */</span>
				<span class="enscript-keyword">if</span> (	thread-&gt;exc_actions[i].port == ports[j]			&amp;&amp;
						thread-&gt;exc_actions[i].behavior ==behaviors[j]	&amp;&amp;
						thread-&gt;exc_actions[i].flavor == flavors[j]		) {
					masks[j] |= (1 &lt;&lt; i);
					<span class="enscript-keyword">break</span>;
				}
			}

			<span class="enscript-keyword">if</span> (j == count) {
				masks[j] = (1 &lt;&lt; i);
				ports[j] = ipc_port_copy_send(thread-&gt;exc_actions[i].port);
				behaviors[j] = thread-&gt;exc_actions[i].behavior;
				flavors[j] = thread-&gt;exc_actions[i].flavor;
				++count;
				<span class="enscript-keyword">if</span> (count &gt;= *CountCnt)
					<span class="enscript-keyword">break</span>;
			}
		}
	}

<span class="enscript-reference">done</span>:
	thread_mtx_unlock(thread);

	*CountCnt = count;

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">task_get_exception_ports</span>(
	task_t						task,
	exception_mask_t			exception_mask,
	exception_mask_array_t		masks,
	mach_msg_type_number_t		*CountCnt,
	exception_port_array_t		ports,
	exception_behavior_array_t	behaviors,
	thread_state_flavor_array_t	flavors)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i, j, count;

	<span class="enscript-keyword">if</span> (task == TASK_NULL)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">if</span> (exception_mask &amp; ~EXC_MASK_VALID)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	itk_lock(task);

	<span class="enscript-keyword">if</span> (task-&gt;itk_self == IP_NULL) {
		itk_unlock(task);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	count = 0;

	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; ++i) {
		<span class="enscript-keyword">if</span> (exception_mask &amp; (1 &lt;&lt; i)) {
			<span class="enscript-keyword">for</span> (j = 0; j &lt; count; ++j) {
				<span class="enscript-comment">/*
				 * search for an identical entry, if found
				 * set corresponding mask for this exception.
				 */</span>
				<span class="enscript-keyword">if</span> (	task-&gt;exc_actions[i].port == ports[j]			&amp;&amp;
						task-&gt;exc_actions[i].behavior == behaviors[j]	&amp;&amp;
						task-&gt;exc_actions[i].flavor == flavors[j]		) {
					masks[j] |= (1 &lt;&lt; i);
					<span class="enscript-keyword">break</span>;
				}
			}

			<span class="enscript-keyword">if</span> (j == count) {
				masks[j] = (1 &lt;&lt; i);
				ports[j] = ipc_port_copy_send(task-&gt;exc_actions[i].port);
				behaviors[j] = task-&gt;exc_actions[i].behavior;
				flavors[j] = task-&gt;exc_actions[i].flavor;
				++count;
				<span class="enscript-keyword">if</span> (count &gt; *CountCnt)
					<span class="enscript-keyword">break</span>;
			}
		}
	}

	itk_unlock(task);

	*CountCnt = count;

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}
</pre>
<hr />
</body></html>