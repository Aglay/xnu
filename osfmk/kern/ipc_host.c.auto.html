<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ipc_host.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ipc_host.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>

<span class="enscript-comment">/*
 *	kern/ipc_host.c
 *
 *	Routines to implement host ports.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/message.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_traps.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_host_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_kobject.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_space.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_mach_internal.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Forward declarations
 */</span>

boolean_t
<span class="enscript-function-name">ref_pset_port_locked</span>(
	ipc_port_t port, boolean_t matchn, processor_set_t *ppset);

<span class="enscript-comment">/*
 *	ipc_host_init: set up various things.
 */</span>

<span class="enscript-type">extern</span> lck_grp_t		host_notify_lock_grp;
<span class="enscript-type">extern</span> lck_attr_t		host_notify_lock_attr;

<span class="enscript-type">void</span> <span class="enscript-function-name">ipc_host_init</span>(<span class="enscript-type">void</span>)
{
	ipc_port_t	port;
	<span class="enscript-type">int</span> i;

	lck_mtx_init(&amp;realhost.lock, &amp;host_notify_lock_grp, &amp;host_notify_lock_attr);

	<span class="enscript-comment">/*
	 *	Allocate and set up the two host ports.
	 */</span>
	port = ipc_port_alloc_kernel();
	<span class="enscript-keyword">if</span> (port == IP_NULL)
		panic(<span class="enscript-string">&quot;ipc_host_init&quot;</span>);

	ipc_kobject_set(port, (ipc_kobject_t) &amp;realhost, IKOT_HOST_SECURITY);
	kernel_set_special_port(&amp;realhost, HOST_SECURITY_PORT,
				ipc_port_make_send(port));

	port = ipc_port_alloc_kernel();
	<span class="enscript-keyword">if</span> (port == IP_NULL)
		panic(<span class="enscript-string">&quot;ipc_host_init&quot;</span>);

	ipc_kobject_set(port, (ipc_kobject_t) &amp;realhost, IKOT_HOST);
	kernel_set_special_port(&amp;realhost, HOST_PORT,
				ipc_port_make_send(port));

	port = ipc_port_alloc_kernel();
	<span class="enscript-keyword">if</span> (port == IP_NULL)
		panic(<span class="enscript-string">&quot;ipc_host_init&quot;</span>);

	ipc_kobject_set(port, (ipc_kobject_t) &amp;realhost, IKOT_HOST_PRIV);
	kernel_set_special_port(&amp;realhost, HOST_PRIV_PORT,
				ipc_port_make_send(port));

	<span class="enscript-comment">/* the rest of the special ports will be set up later */</span>

	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; i++) {
			realhost.exc_actions[i].port = IP_NULL;
		}<span class="enscript-comment">/* for */</span>

	<span class="enscript-comment">/*
	 *	Set up ipc for default processor set.
	 */</span>
	ipc_pset_init(&amp;pset0);
	ipc_pset_enable(&amp;pset0);

	<span class="enscript-comment">/*
	 *	And for master processor
	 */</span>
	ipc_processor_init(master_processor);
	ipc_processor_enable(master_processor);
}

<span class="enscript-comment">/*
 *	Routine:	host_self_trap [mach trap]
 *	Purpose:
 *		Give the caller send rights for his own host port.
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		MACH_PORT_NULL if there are any resource failures
 *		or other errors.
 */</span>

mach_port_name_t
<span class="enscript-function-name">host_self_trap</span>(
	__unused <span class="enscript-type">struct</span> host_self_trap_args *args)
{
	ipc_port_t sright;
	mach_port_name_t name;

	sright = ipc_port_copy_send(current_task()-&gt;itk_host);
	name = ipc_port_copyout_send(sright, current_space());
	<span class="enscript-keyword">return</span> name;
}

<span class="enscript-comment">/*
 *	ipc_processor_init:
 *
 *	Initialize ipc access to processor by allocating port.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_processor_init</span>(
	processor_t	processor)
{
	ipc_port_t	port;

	port = ipc_port_alloc_kernel();
	<span class="enscript-keyword">if</span> (port == IP_NULL)
		panic(<span class="enscript-string">&quot;ipc_processor_init&quot;</span>);
	processor-&gt;processor_self = port;
}

<span class="enscript-comment">/*
 *	ipc_processor_enable:
 *
 *	Enable ipc control of processor by setting port object.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_processor_enable</span>(
	processor_t	processor)
{
	ipc_port_t	myport;

	myport = processor-&gt;processor_self;
	ipc_kobject_set(myport, (ipc_kobject_t) processor, IKOT_PROCESSOR);
}
	
<span class="enscript-comment">/*
 *	ipc_pset_init:
 *
 *	Initialize ipc control of a processor set by allocating its ports.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_pset_init</span>(
	processor_set_t		pset)
{
	ipc_port_t	port;

	port = ipc_port_alloc_kernel();
	<span class="enscript-keyword">if</span> (port == IP_NULL)
		panic(<span class="enscript-string">&quot;ipc_pset_init&quot;</span>);
	pset-&gt;pset_self = port;

	port = ipc_port_alloc_kernel();
	<span class="enscript-keyword">if</span> (port == IP_NULL)
		panic(<span class="enscript-string">&quot;ipc_pset_init&quot;</span>);
	pset-&gt;pset_name_self = port;
}

<span class="enscript-comment">/*
 *	ipc_pset_enable:
 *
 *	Enable ipc access to a processor set.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ipc_pset_enable</span>(
	processor_set_t		pset)
{
	ipc_kobject_set(pset-&gt;pset_self, (ipc_kobject_t) pset, IKOT_PSET);
	ipc_kobject_set(pset-&gt;pset_name_self, (ipc_kobject_t) pset, IKOT_PSET_NAME);
}

<span class="enscript-comment">/*
 *	processor_set_default:
 *
 *	Return ports for manipulating default_processor set.
 */</span>
kern_return_t
<span class="enscript-function-name">processor_set_default</span>(
	host_t			host,
	processor_set_t		*pset)
{
	<span class="enscript-keyword">if</span> (host == HOST_NULL)
		<span class="enscript-keyword">return</span>(KERN_INVALID_ARGUMENT);

	*pset = &amp;pset0;

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 *	Routine:	convert_port_to_host
 *	Purpose:
 *		Convert from a port to a host.
 *		Doesn't consume the port ref; the host produced may be null.
 *	Conditions:
 *		Nothing locked.
 */</span>

host_t
<span class="enscript-function-name">convert_port_to_host</span>(
	ipc_port_t	port)
{
	host_t host = HOST_NULL;

	<span class="enscript-keyword">if</span> (IP_VALID(port)) {
		ip_lock(port);
		<span class="enscript-keyword">if</span> (ip_active(port) &amp;&amp;
		    ((ip_kotype(port) == IKOT_HOST) ||
		     (ip_kotype(port) == IKOT_HOST_PRIV) 
		     ))
			host = (host_t) port-&gt;ip_kobject;
		ip_unlock(port);
	}

	<span class="enscript-keyword">return</span> host;
}

<span class="enscript-comment">/*
 *	Routine:	convert_port_to_host_priv
 *	Purpose:
 *		Convert from a port to a host.
 *		Doesn't consume the port ref; the host produced may be null.
 *	Conditions:
 *		Nothing locked.
 */</span>

host_t
<span class="enscript-function-name">convert_port_to_host_priv</span>(
	ipc_port_t	port)
{
	host_t host = HOST_NULL;

	<span class="enscript-keyword">if</span> (IP_VALID(port)) {
		ip_lock(port);
		<span class="enscript-keyword">if</span> (ip_active(port) &amp;&amp;
		    (ip_kotype(port) == IKOT_HOST_PRIV))
			host = (host_t) port-&gt;ip_kobject;
		ip_unlock(port);
	}

	<span class="enscript-keyword">return</span> host;
}

<span class="enscript-comment">/*
 *	Routine:	convert_port_to_processor
 *	Purpose:
 *		Convert from a port to a processor.
 *		Doesn't consume the port ref;
 *		the processor produced may be null.
 *	Conditions:
 *		Nothing locked.
 */</span>

processor_t
<span class="enscript-function-name">convert_port_to_processor</span>(
	ipc_port_t	port)
{
	processor_t processor = PROCESSOR_NULL;

	<span class="enscript-keyword">if</span> (IP_VALID(port)) {
		ip_lock(port);
		<span class="enscript-keyword">if</span> (ip_active(port) &amp;&amp;
		    (ip_kotype(port) == IKOT_PROCESSOR))
			processor = (processor_t) port-&gt;ip_kobject;
		ip_unlock(port);
	}

	<span class="enscript-keyword">return</span> processor;
}

<span class="enscript-comment">/*
 *	Routine:	convert_port_to_pset
 *	Purpose:
 *		Convert from a port to a pset.
 *		Doesn't consume the port ref; produces a pset ref,
 *		which may be null.
 *	Conditions:
 *		Nothing locked.
 */</span>

processor_set_t
<span class="enscript-function-name">convert_port_to_pset</span>(
	ipc_port_t	port)
{
	boolean_t r;
	processor_set_t pset = PROCESSOR_SET_NULL;

	r = FALSE;
	<span class="enscript-keyword">while</span> (!r &amp;&amp; IP_VALID(port)) {
		ip_lock(port);
		r = ref_pset_port_locked(port, FALSE, &amp;pset);
		<span class="enscript-comment">/* port unlocked */</span>
	}
	<span class="enscript-keyword">return</span> pset;
}

<span class="enscript-comment">/*
 *	Routine:	convert_port_to_pset_name
 *	Purpose:
 *		Convert from a port to a pset.
 *		Doesn't consume the port ref; produces a pset ref,
 *		which may be null.
 *	Conditions:
 *		Nothing locked.
 */</span>

processor_set_name_t
<span class="enscript-function-name">convert_port_to_pset_name</span>(
	ipc_port_t	port)
{
	boolean_t r;
	processor_set_t pset = PROCESSOR_SET_NULL;

	r = FALSE;
	<span class="enscript-keyword">while</span> (!r &amp;&amp; IP_VALID(port)) {
		ip_lock(port);
		r = ref_pset_port_locked(port, TRUE, &amp;pset);
		<span class="enscript-comment">/* port unlocked */</span>
	}
	<span class="enscript-keyword">return</span> pset;
}

boolean_t
<span class="enscript-function-name">ref_pset_port_locked</span>(ipc_port_t port, boolean_t matchn, processor_set_t *ppset)
{
	processor_set_t pset;

	pset = PROCESSOR_SET_NULL;
	<span class="enscript-keyword">if</span> (ip_active(port) &amp;&amp;
		((ip_kotype(port) == IKOT_PSET) ||
			(matchn &amp;&amp; (ip_kotype(port) == IKOT_PSET_NAME)))) {
		pset = (processor_set_t) port-&gt;ip_kobject;
	}

	*ppset = pset;
	ip_unlock(port);

	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-comment">/*
 *	Routine:	convert_host_to_port
 *	Purpose:
 *		Convert from a host to a port.
 *		Produces a naked send right which may be invalid.
 *	Conditions:
 *		Nothing locked.
 */</span>

ipc_port_t
<span class="enscript-function-name">convert_host_to_port</span>(
	host_t		host)
{
	ipc_port_t port;

	host_get_host_port(host, &amp;port);
	<span class="enscript-keyword">return</span> port;
}

<span class="enscript-comment">/*
 *	Routine:	convert_processor_to_port
 *	Purpose:
 *		Convert from a processor to a port.
 *		Produces a naked send right which may be invalid.
 *		Processors are not reference counted, so nothing to release.
 *	Conditions:
 *		Nothing locked.
 */</span>

ipc_port_t
<span class="enscript-function-name">convert_processor_to_port</span>(
	processor_t		processor)
{
	ipc_port_t port = processor-&gt;processor_self;

	<span class="enscript-keyword">if</span> (port != IP_NULL)
		port = ipc_port_make_send(port);
	<span class="enscript-keyword">return</span> port;
}

<span class="enscript-comment">/*
 *	Routine:	convert_pset_to_port
 *	Purpose:
 *		Convert from a pset to a port.
 *		Produces a naked send right which may be invalid.
 *		Processor sets are not reference counted, so nothing to release.
 *	Conditions:
 *		Nothing locked.
 */</span>

ipc_port_t
<span class="enscript-function-name">convert_pset_to_port</span>(
	processor_set_t		pset)
{
	ipc_port_t port = pset-&gt;pset_self;

	<span class="enscript-keyword">if</span> (port != IP_NULL)
		port = ipc_port_make_send(port);

	<span class="enscript-keyword">return</span> port;
}

<span class="enscript-comment">/*
 *	Routine:	convert_pset_name_to_port
 *	Purpose:
 *		Convert from a pset to a port.
 *		Produces a naked send right which may be invalid.
 *		Processor sets are not reference counted, so nothing to release.
 *	Conditions:
 *		Nothing locked.
 */</span>

ipc_port_t
<span class="enscript-function-name">convert_pset_name_to_port</span>(
	processor_set_name_t		pset)
{
	ipc_port_t port = pset-&gt;pset_name_self;

	<span class="enscript-keyword">if</span> (port != IP_NULL)
		port = ipc_port_make_send(port);

	<span class="enscript-keyword">return</span> port;
}

<span class="enscript-comment">/*
 *	Routine:	convert_port_to_host_security
 *	Purpose:
 *		Convert from a port to a host security.
 *		Doesn't consume the port ref; the port produced may be null.
 *	Conditions:
 *		Nothing locked.
 */</span>

host_t
<span class="enscript-function-name">convert_port_to_host_security</span>(
	ipc_port_t port)
{
	host_t host = HOST_NULL;

	<span class="enscript-keyword">if</span> (IP_VALID(port)) {
		ip_lock(port);
		<span class="enscript-keyword">if</span> (ip_active(port) &amp;&amp;
		    (ip_kotype(port) == IKOT_HOST_SECURITY))
			host = (host_t) port-&gt;ip_kobject;
		ip_unlock(port);
	}

	<span class="enscript-keyword">return</span> host;
}

<span class="enscript-comment">/*
 *	Routine:	host_set_exception_ports [kernel call]
 *	Purpose:
 *			Sets the host exception port, flavor and
 *			behavior for the exception types specified by the mask.
 *			There will be one send right per exception per valid
 *			port.
 *	Conditions:
 *		Nothing locked.  If successful, consumes
 *		the supplied send right.
 *	Returns:
 *		KERN_SUCCESS		Changed the special port.
 *		KERN_INVALID_ARGUMENT	The host_priv is not valid,
 *					Illegal mask bit set.
 *					Illegal exception behavior
 */</span>
kern_return_t
<span class="enscript-function-name">host_set_exception_ports</span>(
	host_priv_t			host_priv,
	exception_mask_t		exception_mask,
	ipc_port_t			new_port,
	exception_behavior_t		new_behavior,
	thread_state_flavor_t		new_flavor)
{
	<span class="enscript-type">register</span> <span class="enscript-type">int</span>	i;
	ipc_port_t	old_port[EXC_TYPES_COUNT];

	<span class="enscript-keyword">if</span> (host_priv == HOST_PRIV_NULL) {
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-keyword">if</span> (exception_mask &amp; ~EXC_MASK_VALID) {
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-keyword">if</span> (IP_VALID(new_port)) {
		<span class="enscript-keyword">switch</span> (new_behavior &amp; ~MACH_EXCEPTION_CODES) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_DEFAULT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_STATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_STATE_IDENTITY</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
		}
	}

	<span class="enscript-comment">/*
	 * Check the validity of the thread_state_flavor by calling the
	 * VALID_THREAD_STATE_FLAVOR architecture dependent macro defined in
	 * osfmk/mach/ARCHITECTURE/thread_status.h
	 */</span>
	<span class="enscript-keyword">if</span> (new_flavor != 0 &amp;&amp; !VALID_THREAD_STATE_FLAVOR(new_flavor))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (mac_task_check_set_host_exception_ports(current_task(), exception_mask) != 0)
		<span class="enscript-keyword">return</span> KERN_NO_ACCESS;
#<span class="enscript-reference">endif</span>

	assert(host_priv == &amp;realhost);

	host_lock(host_priv);

	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; i++) {
		<span class="enscript-keyword">if</span> (exception_mask &amp; (1 &lt;&lt; i)) {
			old_port[i] = host_priv-&gt;exc_actions[i].port;
			host_priv-&gt;exc_actions[i].port =
				ipc_port_copy_send(new_port);
			host_priv-&gt;exc_actions[i].behavior = new_behavior;
			host_priv-&gt;exc_actions[i].flavor = new_flavor;
		} <span class="enscript-keyword">else</span>
			old_port[i] = IP_NULL;
	}<span class="enscript-comment">/* for */</span>

	<span class="enscript-comment">/*
	 * Consume send rights without any lock held.
	 */</span>
	host_unlock(host_priv);
	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; i++)
		<span class="enscript-keyword">if</span> (IP_VALID(old_port[i]))
			ipc_port_release_send(old_port[i]);
	<span class="enscript-keyword">if</span> (IP_VALID(new_port))		 <span class="enscript-comment">/* consume send right */</span>
		ipc_port_release_send(new_port);

        <span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *	Routine:	host_get_exception_ports [kernel call]
 *	Purpose:
 *		Clones a send right for each of the host's exception
 *		ports specified in the mask and returns the behaviour
 *		and flavor of said port.
 *
 *		Returns upto [in} CountCnt elements.
 *
 *	Conditions:
 *		Nothing locked.
 *	Returns:
 *		KERN_SUCCESS		Extracted a send right.
 *		KERN_INVALID_ARGUMENT	Invalid host_priv specified,
 *					Invalid special port,
 *					Illegal mask bit set.
 *		KERN_FAILURE		The thread is dead.
 */</span>
kern_return_t
<span class="enscript-function-name">host_get_exception_ports</span>(
	host_priv_t			host_priv,
	exception_mask_t                exception_mask,
	exception_mask_array_t		masks,
	mach_msg_type_number_t		* CountCnt,
	exception_port_array_t		ports,
	exception_behavior_array_t      behaviors,
	thread_state_flavor_array_t     flavors		)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i, j, count;

	<span class="enscript-keyword">if</span> (host_priv == HOST_PRIV_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	<span class="enscript-keyword">if</span> (exception_mask &amp; ~EXC_MASK_VALID) {
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	assert (host_priv == &amp;realhost);

	host_lock(host_priv);

	count = 0;

	<span class="enscript-keyword">for</span> (i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT; i++) {
		<span class="enscript-keyword">if</span> (exception_mask &amp; (1 &lt;&lt; i)) {
			<span class="enscript-keyword">for</span> (j = 0; j &lt; count; j++) {
<span class="enscript-comment">/*
 *				search for an identical entry, if found
 *				set corresponding mask for this exception.
 */</span>
				<span class="enscript-keyword">if</span> (host_priv-&gt;exc_actions[i].port == ports[j] &amp;&amp;
					host_priv-&gt;exc_actions[i].behavior == behaviors[j]
				  &amp;&amp; host_priv-&gt;exc_actions[i].flavor == flavors[j])
				{
					masks[j] |= (1 &lt;&lt; i);
					<span class="enscript-keyword">break</span>;
				}
			}<span class="enscript-comment">/* for */</span>
			<span class="enscript-keyword">if</span> (j == count) {
				masks[j] = (1 &lt;&lt; i);
				ports[j] =
				  ipc_port_copy_send(host_priv-&gt;exc_actions[i].port);
				behaviors[j] = host_priv-&gt;exc_actions[i].behavior;
				flavors[j] = host_priv-&gt;exc_actions[i].flavor;
				count++;
				<span class="enscript-keyword">if</span> (count &gt; *CountCnt) {
					<span class="enscript-keyword">break</span>;
				}
			}
		}
	}<span class="enscript-comment">/* for */</span>
	host_unlock(host_priv);

	*CountCnt = count;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">host_swap_exception_ports</span>(
	host_priv_t			host_priv,
	exception_mask_t		exception_mask,
	ipc_port_t			new_port,
	exception_behavior_t		new_behavior,
	thread_state_flavor_t		new_flavor,
	exception_mask_array_t		masks,
	mach_msg_type_number_t		* CountCnt,
	exception_port_array_t		ports,
	exception_behavior_array_t      behaviors,
	thread_state_flavor_array_t     flavors		)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i,
			j,
			count;
	ipc_port_t	old_port[EXC_TYPES_COUNT];

	<span class="enscript-keyword">if</span> (host_priv == HOST_PRIV_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	<span class="enscript-keyword">if</span> (exception_mask &amp; ~EXC_MASK_VALID) {
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-keyword">if</span> (IP_VALID(new_port)) {
		<span class="enscript-keyword">switch</span> (new_behavior) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_DEFAULT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_STATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EXCEPTION_STATE_IDENTITY</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
		}
	}

	<span class="enscript-keyword">if</span> (new_flavor != 0 &amp;&amp; !VALID_THREAD_STATE_FLAVOR(new_flavor))
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (mac_task_check_set_host_exception_ports(current_task(), exception_mask) != 0)
		<span class="enscript-keyword">return</span> KERN_NO_ACCESS;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF */</span>

	host_lock(host_priv);

	assert(EXC_TYPES_COUNT &gt; FIRST_EXCEPTION);
	<span class="enscript-keyword">for</span> (count=0, i = FIRST_EXCEPTION; i &lt; EXC_TYPES_COUNT &amp;&amp; count &lt; *CountCnt; i++) {
		<span class="enscript-keyword">if</span> (exception_mask &amp; (1 &lt;&lt; i)) {
			<span class="enscript-keyword">for</span> (j = 0; j &lt; count; j++) {
<span class="enscript-comment">/*
 *				search for an identical entry, if found
 *				set corresponding mask for this exception.
 */</span>
				<span class="enscript-keyword">if</span> (host_priv-&gt;exc_actions[i].port == ports[j] &amp;&amp;
				  host_priv-&gt;exc_actions[i].behavior == behaviors[j]
				  &amp;&amp; host_priv-&gt;exc_actions[i].flavor == flavors[j])
				{
					masks[j] |= (1 &lt;&lt; i);
					<span class="enscript-keyword">break</span>;
				}
			}<span class="enscript-comment">/* for */</span>
			<span class="enscript-keyword">if</span> (j == count) {
				masks[j] = (1 &lt;&lt; i);
				ports[j] =
				ipc_port_copy_send(host_priv-&gt;exc_actions[i].port);
				behaviors[j] = host_priv-&gt;exc_actions[i].behavior;
				flavors[j] = host_priv-&gt;exc_actions[i].flavor;
				count++;
			}
			old_port[i] = host_priv-&gt;exc_actions[i].port;
			host_priv-&gt;exc_actions[i].port =
				ipc_port_copy_send(new_port);
			host_priv-&gt;exc_actions[i].behavior = new_behavior;
			host_priv-&gt;exc_actions[i].flavor = new_flavor;
		} <span class="enscript-keyword">else</span>
			old_port[i] = IP_NULL;
	}<span class="enscript-comment">/* for */</span>
	host_unlock(host_priv);

	<span class="enscript-comment">/*
	 * Consume send rights without any lock held.
	 */</span>
	<span class="enscript-keyword">while</span> (--i &gt;= FIRST_EXCEPTION) {
		<span class="enscript-keyword">if</span> (IP_VALID(old_port[i]))
			ipc_port_release_send(old_port[i]);
	}

	<span class="enscript-keyword">if</span> (IP_VALID(new_port))		 <span class="enscript-comment">/* consume send right */</span>
		ipc_port_release_send(new_port);
	*CountCnt = count;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}
</pre>
<hr />
</body></html>