<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>gzalloc.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">gzalloc.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 *	File:	kern/gzalloc.c
 *	Author:	Derek Kumar
 *
 *	&quot;Guard mode&quot; zone allocator, used to trap use-after-free errors,
 *	overruns, underruns, mismatched allocations/frees, uninitialized
 *	zone element use, timing dependent races etc.
 *
 *	The allocator is configured by these boot-args:
 *	gzalloc_size=&lt;size&gt;: target all zones with elements of &lt;size&gt; bytes
 *	gzalloc_min=&lt;size&gt;: target zones with elements &gt;= size
 *	gzalloc_max=&lt;size&gt;: target zones with elements &lt;= size
 * 	gzalloc_min/max can be specified in conjunction to target a range of
 *	sizes
 *	gzalloc_fc_size=&lt;size&gt;: number of zone elements (effectively page
 *	multiple sized) to retain in the free VA cache. This cache is evicted
 *	(backing pages and VA released) in a least-recently-freed fashion.
 *	Larger free VA caches allow for a longer window of opportunity to trap
 *	delayed use-after-free operations, but use more memory.
 *	-gzalloc_wp: Write protect, rather than unmap, freed allocations
 *	lingering in the free VA cache. Useful to disambiguate between
 *	read-after-frees/read overruns and writes. Also permits direct inspection
 *	of the freed element in the cache via the kernel debugger. As each
 *	element has a &quot;header&quot; (trailer in underflow detection mode), the zone
 *	of origin of the element can be easily determined in this mode.
 *	-gzalloc_uf_mode: Underflow detection mode, where the guard page
 *	adjoining each element is placed *before* the element page rather than
 *	after. The element is also located at the top of the page, rather than
 *	abutting the bottom as with the standard overflow detection mode.
 *	-gzalloc_noconsistency: disable consistency checks that flag mismatched
 *	frees, corruptions of the header/trailer signatures etc.
 *	-nogzalloc_mode: Disables the guard mode allocator. The DEBUG kernel
 *	enables the guard allocator for zones sized 8K-16K (if present) by
 *	default, this option can disable that behaviour.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;zone_debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;zone_alias_addr.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine/vm_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug/zone_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machparam.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

<span class="enscript-type">extern</span> boolean_t vm_kernel_ready, kmem_ready;
boolean_t gzalloc_mode = FALSE;
uint32_t pdzalloc_count, pdzfree_count;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">GZALLOC_MIN_DEFAULT</span> (1024)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GZDEADZONE</span> ((zone_t) 0xDEAD201E)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GZALLOC_SIGNATURE</span> (0xABADCAFE)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GZALLOC_RESERVE_SIZE_DEFAULT</span> (2 * 1024 * 1024)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GZFC_DEFAULT_SIZE</span> (1024)

<span class="enscript-type">char</span> gzalloc_fill_pattern = 0x67; <span class="enscript-comment">/* 'g' */</span>

uint32_t gzalloc_min = ~0U;
uint32_t gzalloc_max = 0;
uint32_t gzalloc_size = 0;
uint64_t gzalloc_allocated, gzalloc_freed, gzalloc_early_alloc, gzalloc_early_free, gzalloc_wasted;
boolean_t gzalloc_uf_mode = FALSE, gzalloc_consistency_checks = TRUE;
vm_prot_t gzalloc_prot = VM_PROT_NONE;
uint32_t gzalloc_guard = KMA_GUARD_LAST;
uint32_t gzfc_size = GZFC_DEFAULT_SIZE;

vm_map_t gzalloc_map;
vm_offset_t gzalloc_map_min, gzalloc_map_max;
vm_offset_t gzalloc_reserve;
vm_size_t gzalloc_reserve_size;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> gzalloc_header {
	zone_t gzone;
	uint32_t  gzsize;
	uint32_t  gzsig;
} gzhdr_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GZHEADER_SIZE</span> (sizeof(gzhdr_t))

<span class="enscript-type">extern</span> zone_t vm_page_zone;

<span class="enscript-type">void</span> <span class="enscript-function-name">gzalloc_reconfigure</span>(__unused zone_t z) {
	<span class="enscript-comment">/* Nothing for now */</span>
}

boolean_t <span class="enscript-function-name">gzalloc_enabled</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">return</span> gzalloc_mode;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">gzalloc_zone_init</span>(zone_t z) {
	<span class="enscript-keyword">if</span> (gzalloc_mode) {
		bzero(&amp;z-&gt;gz, <span class="enscript-keyword">sizeof</span>(z-&gt;gz));

		<span class="enscript-keyword">if</span> (gzfc_size &amp;&amp; (z-&gt;elem_size &gt;= gzalloc_min) &amp;&amp; (z-&gt;elem_size &lt;= gzalloc_max) &amp;&amp; (z-&gt;gzalloc_exempt == FALSE)) {
			vm_size_t gzfcsz = round_page(<span class="enscript-keyword">sizeof</span>(*z-&gt;gz.gzfc) * gzfc_size);

			<span class="enscript-comment">/* If the VM/kmem system aren't yet configured, carve
			 * out the free element cache structure directly from the
			 * gzalloc_reserve supplied by the pmap layer.
			*/</span>
			<span class="enscript-keyword">if</span> (!kmem_ready) {
				<span class="enscript-keyword">if</span> (gzalloc_reserve_size &lt; gzfcsz)
					panic(<span class="enscript-string">&quot;gzalloc reserve exhausted&quot;</span>);

				z-&gt;gz.gzfc = (vm_offset_t *)gzalloc_reserve;
				gzalloc_reserve += gzfcsz;
				gzalloc_reserve_size -= gzfcsz;
			} <span class="enscript-keyword">else</span> {
				kern_return_t kr;

				<span class="enscript-keyword">if</span> ((kr = kernel_memory_allocate(kernel_map, (vm_offset_t *)&amp;z-&gt;gz.gzfc, gzfcsz, 0, KMA_KOBJECT, VM_KERN_MEMORY_OSFMK)) != KERN_SUCCESS) {
					panic(<span class="enscript-string">&quot;zinit/gzalloc: kernel_memory_allocate failed (%d) for 0x%lx bytes&quot;</span>, kr, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) gzfcsz);
				}
			}
			bzero((<span class="enscript-type">void</span> *)z-&gt;gz.gzfc, gzfcsz);
		}
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">gzalloc_configure</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-type">char</span> temp_buf[16];

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-gzalloc_mode&quot;</span>, temp_buf, <span class="enscript-keyword">sizeof</span> (temp_buf))) {
		gzalloc_mode = TRUE;
		gzalloc_min = GZALLOC_MIN_DEFAULT;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_DEBUG</span>		
		gzalloc_min += (typeof(gzalloc_min))ZONE_DEBUG_OFFSET;
#<span class="enscript-reference">endif</span>
		gzalloc_max = ~0U;
	}

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;gzalloc_min&quot;</span>, &amp;gzalloc_min, <span class="enscript-keyword">sizeof</span>(gzalloc_min))) {
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_DEBUG</span>		
		gzalloc_min += (typeof(gzalloc_min))ZONE_DEBUG_OFFSET;
#<span class="enscript-reference">endif</span>
		gzalloc_mode = TRUE;
		gzalloc_max = ~0U;
	}

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;gzalloc_max&quot;</span>, &amp;gzalloc_max, <span class="enscript-keyword">sizeof</span>(gzalloc_max))) {
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_DEBUG</span>		
		gzalloc_max += (typeof(gzalloc_min))ZONE_DEBUG_OFFSET;
#<span class="enscript-reference">endif</span>
		gzalloc_mode = TRUE;
		<span class="enscript-keyword">if</span> (gzalloc_min == ~0U)
			gzalloc_min = 0;
	}

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;gzalloc_size&quot;</span>, &amp;gzalloc_size, <span class="enscript-keyword">sizeof</span>(gzalloc_size))) {
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">ZONE_DEBUG</span>		
		gzalloc_size += (typeof(gzalloc_min))ZONE_DEBUG_OFFSET;
#<span class="enscript-reference">endif</span>
		gzalloc_min = gzalloc_max = gzalloc_size;
		gzalloc_mode = TRUE;
	}

	(<span class="enscript-type">void</span>)PE_parse_boot_argn(<span class="enscript-string">&quot;gzalloc_fc_size&quot;</span>, &amp;gzfc_size, <span class="enscript-keyword">sizeof</span>(gzfc_size));

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-gzalloc_wp&quot;</span>, temp_buf, <span class="enscript-keyword">sizeof</span> (temp_buf))) {
		gzalloc_prot = VM_PROT_READ;
	}

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-gzalloc_uf_mode&quot;</span>, temp_buf, <span class="enscript-keyword">sizeof</span> (temp_buf))) {
		gzalloc_uf_mode = TRUE;
		gzalloc_guard = KMA_GUARD_FIRST;
	}

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-gzalloc_noconsistency&quot;</span>, temp_buf, <span class="enscript-keyword">sizeof</span> (temp_buf))) {
		gzalloc_consistency_checks = FALSE;
	}
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (gzalloc_mode == FALSE) {
		gzalloc_min = 8192;
		gzalloc_max = 16384;
		gzalloc_prot = VM_PROT_READ;
		gzalloc_mode = TRUE;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-nogzalloc_mode&quot;</span>, temp_buf, <span class="enscript-keyword">sizeof</span> (temp_buf)))
		gzalloc_mode = FALSE;

	<span class="enscript-keyword">if</span> (gzalloc_mode) {
		gzalloc_reserve_size = GZALLOC_RESERVE_SIZE_DEFAULT;
		gzalloc_reserve = (vm_offset_t) pmap_steal_memory(gzalloc_reserve_size);
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">gzalloc_init</span>(vm_size_t max_zonemap_size) {
	kern_return_t retval;

	<span class="enscript-keyword">if</span> (gzalloc_mode) {
		retval = kmem_suballoc(kernel_map, &amp;gzalloc_map_min, (max_zonemap_size &lt;&lt; 2),
		    FALSE, VM_FLAGS_ANYWHERE | VM_FLAGS_PERMANENT | VM_MAKE_TAG(VM_KERN_MEMORY_ZONE),
		    &amp;gzalloc_map);
	
		<span class="enscript-keyword">if</span> (retval != KERN_SUCCESS)
			panic(<span class="enscript-string">&quot;zone_init: kmem_suballoc(gzalloc) failed&quot;</span>);
		gzalloc_map_max = gzalloc_map_min + (max_zonemap_size &lt;&lt; 2);
	}
}

vm_offset_t
<span class="enscript-function-name">gzalloc_alloc</span>(zone_t zone, boolean_t canblock) {
	vm_offset_t addr = 0;

	<span class="enscript-keyword">if</span> (__improbable(gzalloc_mode &amp;&amp;
		(((zone-&gt;elem_size &gt;= gzalloc_min) &amp;&amp;
		    (zone-&gt;elem_size &lt;= gzalloc_max))) &amp;&amp;
		(zone-&gt;gzalloc_exempt == 0))) {

		<span class="enscript-keyword">if</span> (get_preemption_level() != 0) {
			<span class="enscript-keyword">if</span> (canblock == TRUE) {
				pdzalloc_count++;
			}
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">return</span> 0;
		}

		vm_offset_t rounded_size = round_page(zone-&gt;elem_size + GZHEADER_SIZE);
		vm_offset_t residue = rounded_size - zone-&gt;elem_size;
		vm_offset_t gzaddr = 0;
		gzhdr_t *gzh;

		<span class="enscript-keyword">if</span> (!kmem_ready || (vm_page_zone == ZONE_NULL)) {
			<span class="enscript-comment">/* Early allocations are supplied directly from the
			 * reserve.
			 */</span>
			<span class="enscript-keyword">if</span> (gzalloc_reserve_size &lt; rounded_size)
				panic(<span class="enscript-string">&quot;gzalloc reserve exhausted&quot;</span>);
			gzaddr = gzalloc_reserve;
			<span class="enscript-comment">/* No guard page for these early allocations, just
			 * waste an additional page.
			 */</span>
			gzalloc_reserve += rounded_size + PAGE_SIZE;
			gzalloc_reserve_size -= rounded_size + PAGE_SIZE;
			OSAddAtomic64((SInt32) (rounded_size), &amp;gzalloc_early_alloc);
		}
		<span class="enscript-keyword">else</span> {
			kern_return_t kr = kernel_memory_allocate(gzalloc_map,
			    &amp;gzaddr, rounded_size + (1*PAGE_SIZE),
			    0, KMA_KOBJECT | gzalloc_guard,
			    VM_KERN_MEMORY_OSFMK);
			<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
				panic(<span class="enscript-string">&quot;gzalloc: kernel_memory_allocate for size 0x%llx failed with %d&quot;</span>, (uint64_t)rounded_size, kr);

		}

		<span class="enscript-keyword">if</span> (gzalloc_uf_mode) {
			gzaddr += PAGE_SIZE;
			<span class="enscript-comment">/* The &quot;header&quot; becomes a &quot;footer&quot; in underflow
			 * mode.
			 */</span>
			gzh = (gzhdr_t *) (gzaddr + zone-&gt;elem_size);
			addr = gzaddr;
		} <span class="enscript-keyword">else</span> {
			gzh = (gzhdr_t *) (gzaddr + residue - GZHEADER_SIZE);
			addr = (gzaddr + residue);
		}

		<span class="enscript-comment">/* Fill with a pattern on allocation to trap uninitialized
		 * data use. Since the element size may be &quot;rounded up&quot;
		 * by higher layers such as the kalloc layer, this may
		 * also identify overruns between the originally requested
		 * size and the rounded size via visual inspection.
		 * TBD: plumb through the originally requested size,
		 * prior to rounding by kalloc/IOMalloc etc.
		 * We also add a signature and the zone of origin in a header
		 * prefixed to the allocation.
		 */</span>
		memset((<span class="enscript-type">void</span> *)gzaddr, gzalloc_fill_pattern, rounded_size);

		gzh-&gt;gzone = (kmem_ready &amp;&amp; vm_page_zone) ? zone : GZDEADZONE;
		gzh-&gt;gzsize = (uint32_t) zone-&gt;elem_size;
		gzh-&gt;gzsig = GZALLOC_SIGNATURE;

		lock_zone(zone);
		zone-&gt;count++;
		zone-&gt;sum_count++;
		zone-&gt;cur_size += rounded_size;
		unlock_zone(zone);

		OSAddAtomic64((SInt32) rounded_size, &amp;gzalloc_allocated);
		OSAddAtomic64((SInt32) (rounded_size - zone-&gt;elem_size), &amp;gzalloc_wasted);
	}
	<span class="enscript-keyword">return</span> addr;
}

boolean_t <span class="enscript-function-name">gzalloc_free</span>(zone_t zone, <span class="enscript-type">void</span> *addr) {
	boolean_t gzfreed = FALSE;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (__improbable(gzalloc_mode &amp;&amp;
		(((zone-&gt;elem_size &gt;= gzalloc_min) &amp;&amp;
		    (zone-&gt;elem_size &lt;= gzalloc_max))) &amp;&amp;
		(zone-&gt;gzalloc_exempt == 0))) {
		gzhdr_t *gzh;
		vm_offset_t rounded_size = round_page(zone-&gt;elem_size + GZHEADER_SIZE);
		vm_offset_t residue = rounded_size - zone-&gt;elem_size;
		vm_offset_t saddr;
		vm_offset_t free_addr = 0;

		<span class="enscript-keyword">if</span> (gzalloc_uf_mode) {
			gzh = (gzhdr_t *)((vm_offset_t)addr + zone-&gt;elem_size);
			saddr = (vm_offset_t) addr - PAGE_SIZE;
		} <span class="enscript-keyword">else</span> {
			gzh = (gzhdr_t *)((vm_offset_t)addr - GZHEADER_SIZE);
			saddr = ((vm_offset_t)addr) - residue;
		}

		assert((saddr &amp; PAGE_MASK) == 0);

		<span class="enscript-keyword">if</span> (gzalloc_consistency_checks) {
			<span class="enscript-keyword">if</span> (gzh-&gt;gzsig != GZALLOC_SIGNATURE) {
				panic(<span class="enscript-string">&quot;GZALLOC signature mismatch for element %p, expected 0x%x, found 0x%x&quot;</span>, addr, GZALLOC_SIGNATURE, gzh-&gt;gzsig);
			}

			<span class="enscript-keyword">if</span> (gzh-&gt;gzone != zone &amp;&amp; (gzh-&gt;gzone != GZDEADZONE))
				panic(<span class="enscript-string">&quot;%s: Mismatched zone or under/overflow, current zone: %p, recorded zone: %p, address: %p&quot;</span>, __FUNCTION__, zone, gzh-&gt;gzone, (<span class="enscript-type">void</span> *)addr);
			<span class="enscript-comment">/* Partially redundant given the zone check, but may flag header corruption */</span>
			<span class="enscript-keyword">if</span> (gzh-&gt;gzsize != zone-&gt;elem_size) {
				panic(<span class="enscript-string">&quot;Mismatched zfree or under/overflow for zone %p, recorded size: 0x%x, element size: 0x%x, address: %p\n&quot;</span>, zone, gzh-&gt;gzsize, (uint32_t) zone-&gt;elem_size, (<span class="enscript-type">void</span> *)addr);
			}
		}

		<span class="enscript-keyword">if</span> (!kmem_ready || gzh-&gt;gzone == GZDEADZONE) {
			<span class="enscript-comment">/* For now, just leak frees of early allocations
			 * performed before kmem is fully configured.
			 * They don't seem to get freed currently;
			 * consider ml_static_mfree in the future.
			 */</span>
			OSAddAtomic64((SInt32) (rounded_size), &amp;gzalloc_early_free);
			<span class="enscript-keyword">return</span> TRUE;
		}

		<span class="enscript-keyword">if</span> (get_preemption_level() != 0) {
				pdzfree_count++;
		}

		<span class="enscript-keyword">if</span> (gzfc_size) {
			<span class="enscript-comment">/* Either write protect or unmap the newly freed
			 * allocation
			 */</span>
			kr = vm_map_protect(
				gzalloc_map,
				saddr,
				saddr + rounded_size + (1 * PAGE_SIZE),
				gzalloc_prot,
				FALSE);
			<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
				panic(<span class="enscript-string">&quot;%s: vm_map_protect: %p, 0x%x&quot;</span>, __FUNCTION__, (<span class="enscript-type">void</span> *)saddr, kr);
		} <span class="enscript-keyword">else</span> {
			free_addr = saddr;
		}

		lock_zone(zone);

		<span class="enscript-comment">/* Insert newly freed element into the protected free element
		 * cache, and rotate out the LRU element.
		 */</span>
		<span class="enscript-keyword">if</span> (gzfc_size) {
			<span class="enscript-keyword">if</span> (zone-&gt;gz.gzfc_index &gt;= gzfc_size) {
				zone-&gt;gz.gzfc_index = 0;
			}
			free_addr = zone-&gt;gz.gzfc[zone-&gt;gz.gzfc_index];
			zone-&gt;gz.gzfc[zone-&gt;gz.gzfc_index++] = saddr;
		}

		<span class="enscript-keyword">if</span> (free_addr) {
			zone-&gt;count--;
			zone-&gt;cur_size -= rounded_size;
		}

		unlock_zone(zone);

		<span class="enscript-keyword">if</span> (free_addr) {
			kr = vm_map_remove(
				gzalloc_map,
				free_addr,
				free_addr + rounded_size + (1 * PAGE_SIZE),
				VM_MAP_REMOVE_KUNWIRE);
			<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
				panic(<span class="enscript-string">&quot;gzfree: vm_map_remove: %p, 0x%x&quot;</span>, (<span class="enscript-type">void</span> *)free_addr, kr);

			OSAddAtomic64((SInt32)rounded_size, &amp;gzalloc_freed);
			OSAddAtomic64(-((SInt32) (rounded_size - zone-&gt;elem_size)), &amp;gzalloc_wasted);
		}

		gzfreed = TRUE;
	}
	<span class="enscript-keyword">return</span> gzfreed;
}
</pre>
<hr />
</body></html>