<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>coalition.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">coalition.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2013 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/coalition.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ledger.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span> <span class="enscript-comment">/* for TASK_CHUNK */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/coalition_notification_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_special_ports.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>

<span class="enscript-comment">/*
 * BSD interface functions
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">coalitions_get_list</span>(<span class="enscript-type">int</span> type, <span class="enscript-type">struct</span> procinfo_coalinfo *coal_list, <span class="enscript-type">int</span> list_sz);
boolean_t <span class="enscript-function-name">coalition_is_leader</span>(task_t task, <span class="enscript-type">int</span> coal_type, coalition_t *coal);
<span class="enscript-type">int</span> <span class="enscript-function-name">coalition_get_task_count</span>(coalition_t coal);
uint64_t <span class="enscript-function-name">coalition_get_page_count</span>(coalition_t coal, <span class="enscript-type">int</span> *ntasks);
<span class="enscript-type">int</span> <span class="enscript-function-name">coalition_get_pid_list</span>(coalition_t coal, uint32_t rolemask, <span class="enscript-type">int</span> sort_order,
				  <span class="enscript-type">int</span> *pid_list, <span class="enscript-type">int</span> list_sz);

<span class="enscript-comment">/* defined in task.c */</span>
<span class="enscript-type">extern</span> ledger_template_t task_ledger_template;

<span class="enscript-comment">/*
 * Coalition zone needs limits. We expect there will be as many coalitions as
 * tasks (same order of magnitude), so use the task zone's limits.
 * */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CONFIG_COALITION_MAX</span> CONFIG_TASK_MAX
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COALITION_CHUNK</span> TASK_CHUNK

<span class="enscript-type">int</span> unrestrict_coalition_syscalls;

lck_attr_t coalitions_lck_attr;
lck_grp_t coalitions_lck_grp;
lck_grp_attr_t coalitions_lck_grp_attr;

<span class="enscript-comment">/* coalitions_list_lock protects coalition_count, coalitions queue, next_coalition_id. */</span>
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>,coalitions_list_lock);
<span class="enscript-type">static</span> uint64_t coalition_count;
<span class="enscript-type">static</span> uint64_t coalition_next_id = 1;
<span class="enscript-type">static</span> queue_head_t coalitions_q;

coalition_t init_coalition[COALITION_NUM_TYPES];

zone_t coalition_zone;

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">coal_type_str</span>(<span class="enscript-type">int</span> type)
{
	<span class="enscript-keyword">switch</span>(type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_TYPE_RESOURCE</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;RESOURCE&quot;</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_TYPE_JETSAM</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;JETSAM&quot;</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;&lt;unknown&gt;&quot;</span>;
	}
}

<span class="enscript-type">struct</span> coalition_type {
	<span class="enscript-type">int</span> type;
	<span class="enscript-type">int</span> has_default;
	<span class="enscript-comment">/*
	 * init
	 * pre-condition: coalition just allocated (unlocked), unreferenced,
	 *                type field set
	 */</span>
	kern_return_t (*init)(coalition_t coal, boolean_t privileged);

	<span class="enscript-comment">/*
	 * dealloc
	 * pre-condition: coalition unlocked
	 * pre-condition: coalition refcount=0, active_count=0,
	 *                termrequested=1, terminated=1, reaped=1
	 */</span>
	<span class="enscript-type">void</span>          (*dealloc)(coalition_t coal);

	<span class="enscript-comment">/*
	 * adopt_task
	 * pre-condition: coalition locked
	 * pre-condition: coalition !repead and !terminated
	 */</span>
	kern_return_t (*adopt_task)(coalition_t coal, task_t task);

	<span class="enscript-comment">/*
	 * remove_task
	 * pre-condition: coalition locked
	 * pre-condition: task has been removed from coalition's task list
	 */</span>
	kern_return_t (*remove_task)(coalition_t coal, task_t task);

	<span class="enscript-comment">/*
	 * set_taskrole
	 * pre-condition: coalition locked
	 * pre-condition: task added to coalition's task list,
	 *                active_count &gt;= 1 (at least the given task is active)
	 */</span>
	kern_return_t (*set_taskrole)(coalition_t coal, task_t task, <span class="enscript-type">int</span> role);

	<span class="enscript-comment">/*
	 * get_taskrole
	 * pre-condition: coalition locked
	 * pre-condition: task added to coalition's task list,
	 *                active_count &gt;= 1 (at least the given task is active)
	 */</span>
	<span class="enscript-type">int</span> (*get_taskrole)(coalition_t coal, task_t task);

	<span class="enscript-comment">/*
	 * iterate_tasks
	 * pre-condition: coalition locked
	 */</span>
	<span class="enscript-type">void</span> (*iterate_tasks)(coalition_t coal, <span class="enscript-type">void</span> *ctx, <span class="enscript-type">void</span> (*callback)(coalition_t, <span class="enscript-type">void</span> *, task_t));
};

<span class="enscript-comment">/*
 * COALITION_TYPE_RESOURCE
 */</span>

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">i_coal_resource_init</span>(coalition_t coal, boolean_t privileged);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>          <span class="enscript-function-name">i_coal_resource_dealloc</span>(coalition_t coal);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">i_coal_resource_adopt_task</span>(coalition_t coal, task_t task);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">i_coal_resource_remove_task</span>(coalition_t coal, task_t task);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">i_coal_resource_set_taskrole</span>(coalition_t coal,
						 task_t task, <span class="enscript-type">int</span> role);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>           <span class="enscript-function-name">i_coal_resource_get_taskrole</span>(coalition_t coal, task_t task);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>          <span class="enscript-function-name">i_coal_resource_iterate_tasks</span>(coalition_t coal, <span class="enscript-type">void</span> *ctx,
						   <span class="enscript-type">void</span> (*callback)(coalition_t, <span class="enscript-type">void</span> *, task_t));

<span class="enscript-type">struct</span> i_resource_coalition {
	ledger_t ledger;
	uint64_t bytesread;
	uint64_t byteswritten;
	uint64_t gpu_time;

	uint64_t task_count;      <span class="enscript-comment">/* tasks that have started in this coalition */</span>
	uint64_t dead_task_count; <span class="enscript-comment">/* tasks that have exited in this coalition;
				     subtract from task_count to get count
				     of &quot;active&quot; tasks */</span>
	<span class="enscript-comment">/*
	 * Count the length of time this coalition had at least one active task.
	 * This can be a 'denominator' to turn e.g. cpu_time to %cpu.
	 * */</span>
	uint64_t last_became_nonempty_time;
	uint64_t time_nonempty;

	queue_head_t tasks;         <span class="enscript-comment">/* List of active tasks in the coalition */</span>
};

<span class="enscript-comment">/*
 * COALITION_TYPE_JETSAM
 */</span>

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">i_coal_jetsam_init</span>(coalition_t coal, boolean_t privileged);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>          <span class="enscript-function-name">i_coal_jetsam_dealloc</span>(coalition_t coal);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">i_coal_jetsam_adopt_task</span>(coalition_t coal, task_t task);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">i_coal_jetsam_remove_task</span>(coalition_t coal, task_t task);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">i_coal_jetsam_set_taskrole</span>(coalition_t coal,
					       task_t task, <span class="enscript-type">int</span> role);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>           <span class="enscript-function-name">i_coal_jetsam_get_taskrole</span>(coalition_t coal, task_t task);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>          <span class="enscript-function-name">i_coal_jetsam_iterate_tasks</span>(coalition_t coal, <span class="enscript-type">void</span> *ctx,
						 <span class="enscript-type">void</span> (*callback)(coalition_t, <span class="enscript-type">void</span> *, task_t));

<span class="enscript-type">struct</span> i_jetsam_coalition {
	task_t       leader;
	queue_head_t extensions;
	queue_head_t services;
	queue_head_t other;
};


<span class="enscript-comment">/*
 * main coalition structure
 */</span>
<span class="enscript-type">struct</span> coalition {
	uint64_t id;                <span class="enscript-comment">/* monotonically increasing */</span>
	uint32_t type;
	uint32_t ref_count;         <span class="enscript-comment">/* Number of references to the memory containing this struct */</span>
	uint32_t active_count;      <span class="enscript-comment">/* Number of members of (tasks in) the
				       coalition, plus vouchers referring
				       to the coalition */</span>
	uint32_t focal_task_count;   <span class="enscript-comment">/* Number of TASK_FOREGROUND_APPLICATION tasks in the coalition */</span>
	uint32_t nonfocal_task_count; <span class="enscript-comment">/* Number of TASK_BACKGROUND_APPLICATION tasks in the coalition */</span>

	<span class="enscript-comment">/* coalition flags */</span>
	uint32_t privileged : 1;    <span class="enscript-comment">/* Members of this coalition may create
				       and manage coalitions and may posix_spawn
				       processes into selected coalitions */</span>
	<span class="enscript-comment">/* ast? */</span>
	<span class="enscript-comment">/* voucher */</span>
	uint32_t termrequested : 1; <span class="enscript-comment">/* launchd has requested termination when coalition becomes empty */</span>
	uint32_t terminated : 1;    <span class="enscript-comment">/* coalition became empty and spawns are now forbidden */</span>
	uint32_t reaped : 1;        <span class="enscript-comment">/* reaped, invisible to userspace, but waiting for ref_count to go to zero */</span>
	uint32_t notified : 1;      <span class="enscript-comment">/* no-more-processes notification was sent via special port */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEVELOPMENT</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEBUG</span>)
	uint32_t should_notify : 1; <span class="enscript-comment">/* should this coalition send notifications (default: yes) */</span>
#<span class="enscript-reference">endif</span>

	queue_chain_t coalitions;   <span class="enscript-comment">/* global list of coalitions */</span>

	decl_lck_mtx_data(,lock)    <span class="enscript-comment">/* Coalition lock. */</span>

	<span class="enscript-comment">/* put coalition type-specific structures here */</span>
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> i_resource_coalition  r;
		<span class="enscript-type">struct</span> i_jetsam_coalition    j;
	};
};

<span class="enscript-comment">/*
 * register different coalition types:
 * these must be kept in the order specified in coalition.h
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> coalition_type
s_coalition_types[COALITION_NUM_TYPES] = {
	{
		COALITION_TYPE_RESOURCE,
		1,
		i_coal_resource_init,
		i_coal_resource_dealloc,
		i_coal_resource_adopt_task,
		i_coal_resource_remove_task,
		i_coal_resource_set_taskrole,
		i_coal_resource_get_taskrole,
		i_coal_resource_iterate_tasks,
	},
	{
		COALITION_TYPE_JETSAM,
		1,
		i_coal_jetsam_init,
		i_coal_jetsam_dealloc,
		i_coal_jetsam_adopt_task,
		i_coal_jetsam_remove_task,
		i_coal_jetsam_set_taskrole,
		i_coal_jetsam_get_taskrole,
		i_coal_jetsam_iterate_tasks,
	},
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">coal_call</span>(coal, func, ...) \
	(s_coalition_types[(coal)-&gt;type].func)(coal, ## __VA_ARGS__)


#<span class="enscript-reference">define</span> <span class="enscript-function-name">coalition_lock</span>(c) do{ lck_mtx_lock(&amp;c-&gt;lock); }while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">coalition_unlock</span>(c) do{ lck_mtx_unlock(&amp;c-&gt;lock); }while(0)

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">coalition_notify_user</span>(uint64_t id, uint32_t flags)
{
	mach_port_t user_port;
	kern_return_t kr;

	kr = host_get_coalition_port(host_priv_self(), &amp;user_port);
	<span class="enscript-keyword">if</span> ((kr != KERN_SUCCESS) || !IPC_PORT_VALID(user_port)) {
		<span class="enscript-keyword">return</span>;
	}

	coalition_notification(user_port, id, flags);
}

<span class="enscript-comment">/*
 *
 * COALITION_TYPE_RESOURCE
 *
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">i_coal_resource_init</span>(coalition_t coal, boolean_t privileged)
{
	(<span class="enscript-type">void</span>)privileged;
	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_RESOURCE);
	coal-&gt;r.ledger = ledger_instantiate(task_ledger_template,
					    LEDGER_CREATE_ACTIVE_ENTRIES);
	<span class="enscript-keyword">if</span> (coal-&gt;r.ledger == NULL)
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;

	queue_init(&amp;coal-&gt;r.tasks);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">i_coal_resource_dealloc</span>(coalition_t coal)
{
	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_RESOURCE);
	ledger_dereference(coal-&gt;r.ledger);
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">i_coal_resource_adopt_task</span>(coalition_t coal, task_t task)
{
	<span class="enscript-type">struct</span> i_resource_coalition *cr;

	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_RESOURCE);
	assert(queue_empty(&amp;task-&gt;task_coalition[COALITION_TYPE_RESOURCE]));

	cr = &amp;coal-&gt;r;
	cr-&gt;task_count++;

	<span class="enscript-keyword">if</span> (cr-&gt;task_count &lt; cr-&gt;dead_task_count) {
		panic(<span class="enscript-string">&quot;%s: coalition %p id:%llu type:%s task_count(%llu) &lt; dead_task_count(%llu)&quot;</span>,
		      __func__, coal, coal-&gt;id, coal_type_str(coal-&gt;type),
		      cr-&gt;task_count, cr-&gt;dead_task_count);
	}

	<span class="enscript-comment">/* If moving from 0-&gt;1 active tasks */</span>
	<span class="enscript-keyword">if</span> (cr-&gt;task_count - cr-&gt;dead_task_count == 1) {
		cr-&gt;last_became_nonempty_time = mach_absolute_time();
	}

	<span class="enscript-comment">/* put the task on the coalition's list of tasks */</span>
	enqueue_tail(&amp;cr-&gt;tasks, &amp;task-&gt;task_coalition[COALITION_TYPE_RESOURCE]);

	coal_dbg(<span class="enscript-string">&quot;Added PID:%d to id:%llu, task_count:%llu, dead_count:%llu, nonempty_time:%llu&quot;</span>,
		 task_pid(task), coal-&gt;id, cr-&gt;task_count, cr-&gt;dead_task_count,
		 cr-&gt;last_became_nonempty_time);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">i_coal_resource_remove_task</span>(coalition_t coal, task_t task)
{
	<span class="enscript-type">struct</span> i_resource_coalition *cr;

	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_RESOURCE);
	assert(task-&gt;coalition[COALITION_TYPE_RESOURCE] == coal);
	assert(!queue_empty(&amp;task-&gt;task_coalition[COALITION_TYPE_RESOURCE]));

	<span class="enscript-comment">/*
	 * handle resource coalition accounting rollup for dead tasks
	 */</span>
	cr = &amp;coal-&gt;r;

	cr-&gt;dead_task_count++;

	<span class="enscript-keyword">if</span> (cr-&gt;task_count &lt; cr-&gt;dead_task_count) {
		panic(<span class="enscript-string">&quot;%s: coalition %p id:%llu type:%s task_count(%llu) &lt; dead_task_count(%llu)&quot;</span>,
		      __func__, coal, coal-&gt;id, coal_type_str(coal-&gt;type), cr-&gt;task_count, cr-&gt;dead_task_count);
	}

	<span class="enscript-comment">/* If moving from 1-&gt;0 active tasks */</span>
	<span class="enscript-keyword">if</span> (cr-&gt;task_count - cr-&gt;dead_task_count == 0) {
		uint64_t last_time_nonempty = mach_absolute_time() - cr-&gt;last_became_nonempty_time;
		cr-&gt;last_became_nonempty_time = 0;
		cr-&gt;time_nonempty += last_time_nonempty;
	}

	ledger_rollup(cr-&gt;ledger, task-&gt;ledger);
	cr-&gt;bytesread += task-&gt;task_io_stats-&gt;disk_reads.size;
	cr-&gt;byteswritten += task-&gt;task_io_stats-&gt;total_io.size - task-&gt;task_io_stats-&gt;disk_reads.size;
	cr-&gt;gpu_time += task_gpu_utilisation(task);

	<span class="enscript-comment">/* remove the task from the coalition's list */</span>
	remqueue(&amp;task-&gt;task_coalition[COALITION_TYPE_RESOURCE]);
	queue_chain_init(task-&gt;task_coalition[COALITION_TYPE_RESOURCE]);

	coal_dbg(<span class="enscript-string">&quot;removed PID:%d from id:%llu, task_count:%llu, dead_count:%llu&quot;</span>,
		 task_pid(task), coal-&gt;id, cr-&gt;task_count, cr-&gt;dead_task_count);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">i_coal_resource_set_taskrole</span>(__unused coalition_t coal,
			    __unused task_t task, __unused <span class="enscript-type">int</span> role)
{
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">i_coal_resource_get_taskrole</span>(__unused coalition_t coal, __unused task_t task)
{
	task_t t;

	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_RESOURCE);

	qe_foreach_element(t, &amp;coal-&gt;r.tasks, task_coalition[COALITION_TYPE_RESOURCE]) {
		<span class="enscript-keyword">if</span> (t == task)
			<span class="enscript-keyword">return</span> COALITION_TASKROLE_UNDEF;
	}

	<span class="enscript-keyword">return</span> -1;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">i_coal_resource_iterate_tasks</span>(coalition_t coal, <span class="enscript-type">void</span> *ctx, <span class="enscript-type">void</span> (*callback)(coalition_t, <span class="enscript-type">void</span> *, task_t))
{
	task_t t;
	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_RESOURCE);

	qe_foreach_element(t, &amp;coal-&gt;r.tasks, task_coalition[COALITION_TYPE_RESOURCE])
		callback(coal, ctx, t);
}

kern_return_t
<span class="enscript-function-name">coalition_resource_usage_internal</span>(coalition_t coal, <span class="enscript-type">struct</span> coalition_resource_usage *cru_out)
{
	kern_return_t kr;
	ledger_amount_t credit, debit;

	<span class="enscript-keyword">if</span> (coal-&gt;type != COALITION_TYPE_RESOURCE)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	ledger_t sum_ledger = ledger_instantiate(task_ledger_template, LEDGER_CREATE_ACTIVE_ENTRIES);
	<span class="enscript-keyword">if</span> (sum_ledger == LEDGER_NULL)
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;

	coalition_lock(coal);

	<span class="enscript-comment">/*
	 * Start with the coalition's ledger, which holds the totals from all
	 * the dead tasks.
	 */</span>
	ledger_rollup(sum_ledger, coal-&gt;r.ledger);
	uint64_t bytesread = coal-&gt;r.bytesread;
	uint64_t byteswritten = coal-&gt;r.byteswritten;
	uint64_t gpu_time = coal-&gt;r.gpu_time;
	int64_t cpu_time_billed_to_me = 0;
	int64_t cpu_time_billed_to_others = 0;

	kr = ledger_get_balance(sum_ledger, task_ledgers.cpu_time_billed_to_me, (int64_t *)&amp;cpu_time_billed_to_me);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS || cpu_time_billed_to_me &lt; 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
		printf(<span class="enscript-string">&quot;ledger_get_balance failed or ledger negative in coalition_resource_usage_internal: %lld\n&quot;</span>, cpu_time_billed_to_me);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
		cpu_time_billed_to_me = 0;
	}

	kr = ledger_get_balance(sum_ledger, task_ledgers.cpu_time_billed_to_others, (int64_t *)&amp;cpu_time_billed_to_others);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS || cpu_time_billed_to_others &lt; 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
		printf(<span class="enscript-string">&quot;ledger_get_balance failed or ledger negative in coalition_resource_usage_internal: %lld\n&quot;</span>, cpu_time_billed_to_others);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
		cpu_time_billed_to_others = 0;
	}

	<span class="enscript-comment">/*
	 * Add to that all the active tasks' ledgers. Tasks cannot deallocate
	 * out from under us, since we hold the coalition lock.
	 * Do not use the on-behalf of cpu time from ledger for live tasks, since
	 * it will not have cpu time for active linkages between tasks.
	 */</span>
	task_t task;
	qe_foreach_element(task, &amp;coal-&gt;r.tasks, task_coalition[COALITION_TYPE_RESOURCE]) {
		ledger_rollup(sum_ledger, task-&gt;ledger);
		bytesread += task-&gt;task_io_stats-&gt;disk_reads.size;
		byteswritten += task-&gt;task_io_stats-&gt;total_io.size - task-&gt;task_io_stats-&gt;disk_reads.size;
		gpu_time += task_gpu_utilisation(task);
		cpu_time_billed_to_me += (int64_t)bank_billed_time(task-&gt;bank_context);
		cpu_time_billed_to_others += (int64_t)bank_serviced_time(task-&gt;bank_context);
	}

	<span class="enscript-comment">/* collect information from the coalition itself */</span>
	cru_out-&gt;tasks_started = coal-&gt;r.task_count;
	cru_out-&gt;tasks_exited = coal-&gt;r.dead_task_count;

	uint64_t time_nonempty = coal-&gt;r.time_nonempty;
	uint64_t last_became_nonempty_time = coal-&gt;r.last_became_nonempty_time;

	coalition_unlock(coal);

	<span class="enscript-comment">/* Copy the totals out of sum_ledger */</span>
	kr = ledger_get_entries(sum_ledger, task_ledgers.cpu_time,
			&amp;credit, &amp;debit);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		credit = 0;
	}
	cru_out-&gt;cpu_time = credit;
	cru_out-&gt;cpu_time_billed_to_me = (uint64_t)cpu_time_billed_to_me;
	cru_out-&gt;cpu_time_billed_to_others = (uint64_t)cpu_time_billed_to_others;

	kr = ledger_get_entries(sum_ledger, task_ledgers.interrupt_wakeups,
			&amp;credit, &amp;debit);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		credit = 0;
	}
	cru_out-&gt;interrupt_wakeups = credit;

	kr = ledger_get_entries(sum_ledger, task_ledgers.platform_idle_wakeups,
			&amp;credit, &amp;debit);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		credit = 0;
	}
	cru_out-&gt;platform_idle_wakeups = credit;

	cru_out-&gt;bytesread = bytesread;
	cru_out-&gt;byteswritten = byteswritten;
	cru_out-&gt;gpu_time = gpu_time;

	ledger_dereference(sum_ledger);
	sum_ledger = LEDGER_NULL;

	<span class="enscript-keyword">if</span> (last_became_nonempty_time) {
		time_nonempty += mach_absolute_time() - last_became_nonempty_time;
	}
	absolutetime_to_nanoseconds(time_nonempty, &amp;cru_out-&gt;time_nonempty);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 *
 * COALITION_TYPE_JETSAM
 *
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">i_coal_jetsam_init</span>(coalition_t coal, boolean_t privileged)
{
	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_JETSAM);
	(<span class="enscript-type">void</span>)privileged;

	coal-&gt;j.leader= TASK_NULL;
	queue_head_init(coal-&gt;j.extensions);
	queue_head_init(coal-&gt;j.services);
	queue_head_init(coal-&gt;j.other);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">i_coal_jetsam_dealloc</span>(__unused coalition_t coal)
{
	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_JETSAM);

	<span class="enscript-comment">/* the coalition should be completely clear at this point */</span>
	assert(queue_empty(&amp;coal-&gt;j.extensions));
	assert(queue_empty(&amp;coal-&gt;j.services));
	assert(queue_empty(&amp;coal-&gt;j.other));
	assert(coal-&gt;j.leader == TASK_NULL);
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">i_coal_jetsam_adopt_task</span>(coalition_t coal, task_t task)
{
	<span class="enscript-type">struct</span> i_jetsam_coalition *cj;
	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_JETSAM);

	cj = &amp;coal-&gt;j;

	assert(queue_empty(&amp;task-&gt;task_coalition[COALITION_TYPE_JETSAM]));

	<span class="enscript-comment">/* put each task initially in the &quot;other&quot; list */</span>
	enqueue_tail(&amp;cj-&gt;other, &amp;task-&gt;task_coalition[COALITION_TYPE_JETSAM]);
	coal_dbg(<span class="enscript-string">&quot;coalition %lld adopted PID:%d as UNDEF&quot;</span>,
		 coal-&gt;id, task_pid(task));

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">i_coal_jetsam_remove_task</span>(coalition_t coal, task_t task)
{
	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_JETSAM);
	assert(task-&gt;coalition[COALITION_TYPE_JETSAM] == coal);

	coal_dbg(<span class="enscript-string">&quot;removing PID:%d from coalition id:%lld&quot;</span>,
		 task_pid(task), coal-&gt;id);

	<span class="enscript-keyword">if</span> (task == coal-&gt;j.leader) {
		coal-&gt;j.leader = NULL;
		coal_dbg(<span class="enscript-string">&quot;    PID:%d was the leader!&quot;</span>, task_pid(task));
	} <span class="enscript-keyword">else</span> {
		assert(!queue_empty(&amp;task-&gt;task_coalition[COALITION_TYPE_JETSAM]));
	}

	<span class="enscript-comment">/* remove the task from the specific coalition role queue */</span>
	remqueue(&amp;task-&gt;task_coalition[COALITION_TYPE_JETSAM]);
	queue_chain_init(task-&gt;task_coalition[COALITION_TYPE_RESOURCE]);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">i_coal_jetsam_set_taskrole</span>(coalition_t coal, task_t task, <span class="enscript-type">int</span> role)
{
	<span class="enscript-type">struct</span> i_jetsam_coalition *cj;
	queue_t q = NULL;
	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_JETSAM);
	assert(task-&gt;coalition[COALITION_TYPE_JETSAM] == coal);

	cj = &amp;coal-&gt;j;

	<span class="enscript-keyword">switch</span> (role) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_TASKROLE_LEADER</span>:
		coal_dbg(<span class="enscript-string">&quot;setting PID:%d as LEADER of %lld&quot;</span>,
			 task_pid(task), coal-&gt;id);
		<span class="enscript-keyword">if</span> (cj-&gt;leader != TASK_NULL) {
			<span class="enscript-comment">/* re-queue the exiting leader onto the &quot;other&quot; list */</span>
			coal_dbg(<span class="enscript-string">&quot;    re-queue existing leader (%d) as OTHER&quot;</span>,
				 task_pid(cj-&gt;leader));
			re_queue_tail(&amp;cj-&gt;other, &amp;cj-&gt;leader-&gt;task_coalition[COALITION_TYPE_JETSAM]);
		}
		<span class="enscript-comment">/*
		 * remove the task from the &quot;other&quot; list
		 * (where it was put by default)
		 */</span>
		remqueue(&amp;task-&gt;task_coalition[COALITION_TYPE_JETSAM]);
		queue_chain_init(task-&gt;task_coalition[COALITION_TYPE_JETSAM]);

		<span class="enscript-comment">/* set the coalition leader */</span>
		cj-&gt;leader = task;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_TASKROLE_UNDEF</span>:
		coal_dbg(<span class="enscript-string">&quot;setting PID:%d as UNDEF in %lld&quot;</span>,
			 task_pid(task), coal-&gt;id);
		q = (queue_t)&amp;cj-&gt;other;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_TASKROLE_XPC</span>:
		coal_dbg(<span class="enscript-string">&quot;setting PID:%d as XPC in %lld&quot;</span>,
			 task_pid(task), coal-&gt;id);
		q = (queue_t)&amp;cj-&gt;services;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_TASKROLE_EXT</span>:
		coal_dbg(<span class="enscript-string">&quot;setting PID:%d as EXT in %lld&quot;</span>,
			 task_pid(task), coal-&gt;id);
		q = (queue_t)&amp;cj-&gt;extensions;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;%s: invalid role(%d) for task&quot;</span>, __func__, role);
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-keyword">if</span> (q != NULL)
		re_queue_tail(q, &amp;task-&gt;task_coalition[COALITION_TYPE_JETSAM]);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">i_coal_jetsam_get_taskrole</span>(coalition_t coal, task_t task)
{
	<span class="enscript-type">struct</span> i_jetsam_coalition *cj;
	task_t t;

	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_JETSAM);
	assert(task-&gt;coalition[COALITION_TYPE_JETSAM] == coal);

	cj = &amp;coal-&gt;j;

	<span class="enscript-keyword">if</span> (task == cj-&gt;leader)
		<span class="enscript-keyword">return</span> COALITION_TASKROLE_LEADER;

	qe_foreach_element(t, &amp;cj-&gt;services, task_coalition[COALITION_TYPE_JETSAM]) {
		<span class="enscript-keyword">if</span> (t == task)
			<span class="enscript-keyword">return</span> COALITION_TASKROLE_XPC;
	}

	qe_foreach_element(t, &amp;cj-&gt;extensions, task_coalition[COALITION_TYPE_JETSAM]) {
		<span class="enscript-keyword">if</span> (t == task)
			<span class="enscript-keyword">return</span> COALITION_TASKROLE_EXT;
	}

	qe_foreach_element(t, &amp;cj-&gt;other, task_coalition[COALITION_TYPE_JETSAM]) {
		<span class="enscript-keyword">if</span> (t == task)
			<span class="enscript-keyword">return</span> COALITION_TASKROLE_UNDEF;
	}

	<span class="enscript-comment">/* task not in the coalition?! */</span>
	<span class="enscript-keyword">return</span> -1;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">i_coal_jetsam_iterate_tasks</span>(coalition_t coal, <span class="enscript-type">void</span> *ctx, <span class="enscript-type">void</span> (*callback)(coalition_t, <span class="enscript-type">void</span> *, task_t))
{
	<span class="enscript-type">struct</span> i_jetsam_coalition *cj;
	task_t t;

	assert(coal &amp;&amp; coal-&gt;type == COALITION_TYPE_JETSAM);

	cj = &amp;coal-&gt;j;

	<span class="enscript-keyword">if</span> (cj-&gt;leader)
		callback(coal, ctx, cj-&gt;leader);

	qe_foreach_element(t, &amp;cj-&gt;services, task_coalition[COALITION_TYPE_JETSAM])
		callback(coal, ctx, t);

	qe_foreach_element(t, &amp;cj-&gt;extensions, task_coalition[COALITION_TYPE_JETSAM])
		callback(coal, ctx, t);

	qe_foreach_element(t, &amp;cj-&gt;other, task_coalition[COALITION_TYPE_JETSAM])
		callback(coal, ctx, t);
}


<span class="enscript-comment">/*
 *
 * Main Coalition implementation
 *
 */</span>

<span class="enscript-comment">/*
 * coalition_create_internal
 * Returns: New coalition object, referenced for the caller and unlocked.
 * Condition: coalitions_list_lock must be UNLOCKED.
 */</span>
kern_return_t
<span class="enscript-function-name">coalition_create_internal</span>(<span class="enscript-type">int</span> type, boolean_t privileged, coalition_t *out)
{
	kern_return_t kr;
	<span class="enscript-type">struct</span> coalition *new_coal;

	<span class="enscript-keyword">if</span> (type &lt; 0 || type &gt; COALITION_TYPE_MAX)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	new_coal = (<span class="enscript-type">struct</span> coalition *)zalloc(coalition_zone);
	<span class="enscript-keyword">if</span> (new_coal == COALITION_NULL)
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	bzero(new_coal, <span class="enscript-keyword">sizeof</span>(*new_coal));

	new_coal-&gt;type = type;

	<span class="enscript-comment">/* initialize type-specific resources */</span>
	kr = coal_call(new_coal, init, privileged);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		zfree(coalition_zone, new_coal);
		<span class="enscript-keyword">return</span> kr;
	}

	<span class="enscript-comment">/* One for caller, one for coalitions list */</span>
	new_coal-&gt;ref_count = 2;

	new_coal-&gt;privileged = privileged ? TRUE : FALSE;
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEVELOPMENT</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEBUG</span>)
	new_coal-&gt;should_notify = 1;
#<span class="enscript-reference">endif</span>

	lck_mtx_init(&amp;new_coal-&gt;lock, &amp;coalitions_lck_grp, &amp;coalitions_lck_attr);

	lck_mtx_lock(&amp;coalitions_list_lock);
	new_coal-&gt;id = coalition_next_id++;
	coalition_count++;
	enqueue_tail(&amp;coalitions_q, &amp;new_coal-&gt;coalitions);
	lck_mtx_unlock(&amp;coalitions_list_lock);

	coal_dbg(<span class="enscript-string">&quot;id:%llu, type:%s&quot;</span>, new_coal-&gt;id, coal_type_str(new_coal-&gt;type));

	*out = new_coal;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 * coalition_release
 * Condition: coalition must be UNLOCKED.
 * */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">coalition_release</span>(coalition_t coal)
{
	<span class="enscript-comment">/* TODO: This can be done with atomics. */</span>
	coalition_lock(coal);
	coal-&gt;ref_count--;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COALITION_DEBUG</span>
	uint32_t rc = coal-&gt;ref_count;
	uint32_t ac = coal-&gt;active_count;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* COALITION_DEBUG */</span>

	coal_dbg(<span class="enscript-string">&quot;id:%llu type:%s ref_count:%u active_count:%u%s&quot;</span>,
		 coal-&gt;id, coal_type_str(coal-&gt;type), rc, ac,
		 rc &lt;= 0 ? <span class="enscript-string">&quot;, will deallocate now&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);

	<span class="enscript-keyword">if</span> (coal-&gt;ref_count &gt; 0) {
		coalition_unlock(coal);
		<span class="enscript-keyword">return</span>;
	}

	assert(coal-&gt;termrequested);
	assert(coal-&gt;terminated);
	assert(coal-&gt;active_count == 0);
	assert(coal-&gt;reaped);
	assert(coal-&gt;focal_task_count == 0);
	assert(coal-&gt;nonfocal_task_count == 0);

	coal_call(coal, dealloc);

	coalition_unlock(coal);

	lck_mtx_destroy(&amp;coal-&gt;lock, &amp;coalitions_lck_grp);

	zfree(coalition_zone, coal);
}

<span class="enscript-comment">/*
 * coalition_find_by_id_internal
 * Returns: Coalition object with specified id, NOT referenced.
 *          If not found, returns COALITION_NULL.
 * Condition: coalitions_list_lock must be LOCKED.
 */</span>
<span class="enscript-type">static</span> coalition_t
<span class="enscript-function-name">coalition_find_by_id_internal</span>(uint64_t coal_id)
{
	<span class="enscript-keyword">if</span> (coal_id == 0) {
		<span class="enscript-keyword">return</span> COALITION_NULL;
	}

	lck_mtx_assert(&amp;coalitions_list_lock, LCK_MTX_ASSERT_OWNED);
	coalition_t coal;
	qe_foreach_element(coal, &amp;coalitions_q, coalitions) {
		<span class="enscript-keyword">if</span> (coal-&gt;id == coal_id) {
			<span class="enscript-keyword">return</span> coal;
		}
	}
	<span class="enscript-keyword">return</span> COALITION_NULL;
}

<span class="enscript-comment">/*
 * coalition_find_by_id
 * Returns: Coalition object with specified id, referenced.
 * Condition: coalitions_list_lock must be UNLOCKED.
 */</span>
coalition_t
<span class="enscript-function-name">coalition_find_by_id</span>(uint64_t cid)
{
	<span class="enscript-keyword">if</span> (cid == 0) {
		<span class="enscript-keyword">return</span> COALITION_NULL;
	}

	lck_mtx_lock(&amp;coalitions_list_lock);

	coalition_t coal = coalition_find_by_id_internal(cid);
	<span class="enscript-keyword">if</span> (coal == COALITION_NULL) {
		lck_mtx_unlock(&amp;coalitions_list_lock);
		<span class="enscript-keyword">return</span> COALITION_NULL;
	}

	coalition_lock(coal);

	<span class="enscript-keyword">if</span> (coal-&gt;reaped) {
		coalition_unlock(coal);
		lck_mtx_unlock(&amp;coalitions_list_lock);
		<span class="enscript-keyword">return</span> COALITION_NULL;
	}

	<span class="enscript-keyword">if</span> (coal-&gt;ref_count == 0) {
		panic(<span class="enscript-string">&quot;resurrecting coalition %p id:%llu type:%s, active_count:%u\n&quot;</span>,
				coal, coal-&gt;id, coal_type_str(coal-&gt;type), coal-&gt;active_count);
	}
	coal-&gt;ref_count++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COALITION_DEBUG</span>
	uint32_t rc = coal-&gt;ref_count;
#<span class="enscript-reference">endif</span>

	coalition_unlock(coal);
	lck_mtx_unlock(&amp;coalitions_list_lock);

	coal_dbg(<span class="enscript-string">&quot;id:%llu type:%s ref_count:%u&quot;</span>,
		 coal-&gt;id, coal_type_str(coal-&gt;type), rc);

	<span class="enscript-keyword">return</span> coal;
}

<span class="enscript-comment">/*
 * coalition_find_and_activate_by_id
 * Returns: Coalition object with specified id, referenced, and activated.
 * Condition: coalitions_list_lock must be UNLOCKED.
 * This is the function to use when putting a 'new' thing into a coalition,
 * like posix_spawn of an XPC service by launchd.
 * See also coalition_extend_active.
 */</span>
coalition_t
<span class="enscript-function-name">coalition_find_and_activate_by_id</span>(uint64_t cid)
{
	<span class="enscript-keyword">if</span> (cid == 0) {
		<span class="enscript-keyword">return</span> COALITION_NULL;
	}

	lck_mtx_lock(&amp;coalitions_list_lock);

	coalition_t coal = coalition_find_by_id_internal(cid);
	<span class="enscript-keyword">if</span> (coal == COALITION_NULL) {
		lck_mtx_unlock(&amp;coalitions_list_lock);
		<span class="enscript-keyword">return</span> COALITION_NULL;
	}

	coalition_lock(coal);

	<span class="enscript-keyword">if</span> (coal-&gt;reaped || coal-&gt;terminated) {
		<span class="enscript-comment">/* Too late to put something new into this coalition, it's
		 * already on its way out the door */</span>
		coalition_unlock(coal);
		lck_mtx_unlock(&amp;coalitions_list_lock);
		<span class="enscript-keyword">return</span> COALITION_NULL;
	}

	<span class="enscript-keyword">if</span> (coal-&gt;ref_count == 0) {
		panic(<span class="enscript-string">&quot;resurrecting coalition %p id:%llu type:%s, active_count:%u\n&quot;</span>,
				coal, coal-&gt;id, coal_type_str(coal-&gt;type), coal-&gt;active_count);
	}

	coal-&gt;ref_count++;
	coal-&gt;active_count++;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COALITION_DEBUG</span>
	uint32_t rc = coal-&gt;ref_count;
	uint32_t ac = coal-&gt;active_count;
#<span class="enscript-reference">endif</span>

	coalition_unlock(coal);
	lck_mtx_unlock(&amp;coalitions_list_lock);

	coal_dbg(<span class="enscript-string">&quot;id:%llu type:%s ref_count:%u, active_count:%u&quot;</span>,
		 coal-&gt;id, coal_type_str(coal-&gt;type), rc, ac);

	<span class="enscript-keyword">return</span> coal;
}

uint64_t
<span class="enscript-function-name">coalition_id</span>(coalition_t coal)
{
	<span class="enscript-keyword">return</span> coal-&gt;id;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_coalition_ids</span>(task_t task, uint64_t ids[COALITION_NUM_TYPES])
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; COALITION_NUM_TYPES; i++) {
		<span class="enscript-keyword">if</span> (task-&gt;coalition[i])
			ids[i] = task-&gt;coalition[i]-&gt;id;
		<span class="enscript-keyword">else</span>
			ids[i] = 0;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_coalition_roles</span>(task_t task, <span class="enscript-type">int</span> roles[COALITION_NUM_TYPES])
{
	<span class="enscript-type">int</span> i;
	memset(roles, 0, COALITION_NUM_TYPES * <span class="enscript-keyword">sizeof</span>(roles[0]));

	<span class="enscript-keyword">for</span> (i = 0; i &lt; COALITION_NUM_TYPES; i++) {
		<span class="enscript-keyword">if</span> (task-&gt;coalition[i]) {
			coalition_lock(task-&gt;coalition[i]);
			roles[i] = coal_call(task-&gt;coalition[i],
					     get_taskrole, task);
			coalition_unlock(task-&gt;coalition[i]);
		} <span class="enscript-keyword">else</span> {
			roles[i] = -1;
		}
	}
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">coalition_type</span>(coalition_t coal)
{
	<span class="enscript-keyword">return</span> coal-&gt;type;
}

boolean_t
<span class="enscript-function-name">coalition_is_privileged</span>(coalition_t coal)
{
	<span class="enscript-keyword">return</span> coal-&gt;privileged || unrestrict_coalition_syscalls;
}

boolean_t
<span class="enscript-function-name">task_is_in_privileged_coalition</span>(task_t task, <span class="enscript-type">int</span> type)
{
	<span class="enscript-keyword">if</span> (type &lt; 0 || type &gt; COALITION_TYPE_MAX)
		<span class="enscript-keyword">return</span> FALSE;
	<span class="enscript-keyword">if</span> (unrestrict_coalition_syscalls)
		<span class="enscript-keyword">return</span> TRUE;
	<span class="enscript-keyword">if</span> (!task-&gt;coalition[type])
		<span class="enscript-keyword">return</span> FALSE;
	<span class="enscript-keyword">return</span> task-&gt;coalition[type]-&gt;privileged;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">task_coalition_update_gpu_stats</span>(task_t task, uint64_t gpu_ns_delta)
{
	coalition_t coal;

	assert(task != TASK_NULL);
	<span class="enscript-keyword">if</span> (gpu_ns_delta == 0)
		<span class="enscript-keyword">return</span>;

	coal = task-&gt;coalition[COALITION_TYPE_RESOURCE];
	assert(coal != COALITION_NULL);

	coalition_lock(coal);
	coal-&gt;r.gpu_time += gpu_ns_delta;
	coalition_unlock(coal);
}

uint32_t <span class="enscript-function-name">task_coalition_adjust_focal_count</span>(task_t task, <span class="enscript-type">int</span> count)
{
	coalition_t coal;
	uint32_t ret;

	<span class="enscript-comment">/*
	 * For now: only use the resource coalition. Perhaps in the
	 * future we may combine all coalition types, or even make
	 * a special coalition type just for this.
	 */</span>
	coal = task-&gt;coalition[COALITION_TYPE_RESOURCE];
	assert(coal != COALITION_NULL);

	ret = hw_atomic_add(&amp;coal-&gt;focal_task_count, count);

	<span class="enscript-comment">/* catch underflow */</span>
	assert(ret != UINT32_MAX);
	<span class="enscript-keyword">return</span> ret;
}

uint32_t <span class="enscript-function-name">task_coalition_focal_count</span>(task_t task)
{
	coalition_t coal;
	coal = task-&gt;coalition[COALITION_TYPE_RESOURCE];
	assert(coal != COALITION_NULL);

	<span class="enscript-keyword">return</span> coal-&gt;focal_task_count;
}

uint32_t <span class="enscript-function-name">task_coalition_adjust_nonfocal_count</span>(task_t task, <span class="enscript-type">int</span> count)
{
	coalition_t coal;
	uint32_t ret;

	<span class="enscript-comment">/*
	 * For now: only use the resource coalition. Perhaps in the
	 * future we may combine all coalition types, or even make
	 * a special coalition type just for this.
	 */</span>
	coal = task-&gt;coalition[COALITION_TYPE_RESOURCE];
	assert(coal != COALITION_NULL);

	ret = hw_atomic_add(&amp;coal-&gt;nonfocal_task_count, count);

	<span class="enscript-comment">/* catch underflow */</span>
	assert(ret != UINT32_MAX);
	<span class="enscript-keyword">return</span> ret;
}

uint32_t <span class="enscript-function-name">task_coalition_nonfocal_count</span>(task_t task)
{
	coalition_t coal;
	coal = task-&gt;coalition[COALITION_TYPE_RESOURCE];
	assert(coal != COALITION_NULL);

	<span class="enscript-keyword">return</span> coal-&gt;nonfocal_task_count;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">coalition_for_each_task</span>(coalition_t coal, <span class="enscript-type">void</span> *ctx,
			     <span class="enscript-type">void</span> (*callback)(coalition_t, <span class="enscript-type">void</span> *, task_t))
{
	assert(coal != COALITION_NULL);

	coal_dbg(<span class="enscript-string">&quot;iterating tasks in coalition %p id:%llu type:%s, active_count:%u&quot;</span>,
		 coal, coal-&gt;id, coal_type_str(coal-&gt;type), coal-&gt;active_count);

	coalition_lock(coal);

	coal_call(coal, iterate_tasks, ctx, callback);

	coalition_unlock(coal);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">coalition_remove_active</span>(coalition_t coal)
{
	coalition_lock(coal);

	assert(!coal-&gt;reaped);
	assert(coal-&gt;active_count &gt; 0);

	coal-&gt;active_count--;

	boolean_t do_notify = FALSE;
	uint64_t notify_id = 0;
	uint32_t notify_flags = 0;
	<span class="enscript-keyword">if</span> (coal-&gt;termrequested &amp;&amp; coal-&gt;active_count == 0) {
		<span class="enscript-comment">/* We only notify once, when active_count reaches zero.
		 * We just decremented, so if it reached zero, we mustn't have
		 * notified already.
		 */</span>
		assert(!coal-&gt;terminated);
		coal-&gt;terminated = TRUE;

		assert(!coal-&gt;notified);

		coal-&gt;notified = TRUE;
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEVELOPMENT</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEBUG</span>)
		do_notify = coal-&gt;should_notify;
#<span class="enscript-reference">else</span>
		do_notify = TRUE;
#<span class="enscript-reference">endif</span>
		notify_id = coal-&gt;id;
		notify_flags = 0;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COALITION_DEBUG</span>
	uint64_t cid = coal-&gt;id;
	uint32_t rc = coal-&gt;ref_count;
	<span class="enscript-type">int</span>      ac = coal-&gt;active_count;
	<span class="enscript-type">int</span>      ct = coal-&gt;type;
#<span class="enscript-reference">endif</span>
	coalition_unlock(coal);

	coal_dbg(<span class="enscript-string">&quot;id:%llu type:%s ref_count:%u, active_count:%u,%s&quot;</span>,
		 cid, coal_type_str(ct), rc, ac, do_notify ? <span class="enscript-string">&quot; NOTIFY&quot;</span> : <span class="enscript-string">&quot; &quot;</span>);

	<span class="enscript-keyword">if</span> (do_notify) {
		coalition_notify_user(notify_id, notify_flags);
	}
}

<span class="enscript-comment">/* Used for kernel_task, launchd, launchd's early boot tasks... */</span>
kern_return_t
<span class="enscript-function-name">coalitions_adopt_init_task</span>(task_t task)
{
	kern_return_t kr;
	kr = coalitions_adopt_task(init_coalition, task);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		panic(<span class="enscript-string">&quot;failed to adopt task %p into default coalition: %d&quot;</span>, task, kr);
	}
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 * coalition_adopt_task_internal
 * Condition: Coalition must be referenced and unlocked. Will fail if coalition
 * is already terminated.
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">coalition_adopt_task_internal</span>(coalition_t coal, task_t task)
{
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (task-&gt;coalition[coal-&gt;type]) {
		<span class="enscript-keyword">return</span> KERN_ALREADY_IN_SET;
	}

	coalition_lock(coal);

	<span class="enscript-keyword">if</span> (coal-&gt;reaped || coal-&gt;terminated) {
		coalition_unlock(coal);
		<span class="enscript-keyword">return</span> KERN_TERMINATED;
	}

	kr = coal_call(coal, adopt_task, task);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_unlock</span>;

	coal-&gt;active_count++;

	coal-&gt;ref_count++;

	task-&gt;coalition[coal-&gt;type] = coal;

<span class="enscript-reference">out_unlock</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COALITION_DEBUG</span>
	(<span class="enscript-type">void</span>)coal; <span class="enscript-comment">/* need expression after label */</span>
	uint64_t cid = coal-&gt;id;
	uint32_t rc = coal-&gt;ref_count;
	uint32_t ct = coal-&gt;type;
#<span class="enscript-reference">endif</span>
	coalition_unlock(coal);

	coal_dbg(<span class="enscript-string">&quot;task:%d, id:%llu type:%s ref_count:%u, kr=%d&quot;</span>,
		 task_pid(task), cid, coal_type_str(ct), rc, kr);
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">coalition_remove_task_internal</span>(task_t task, <span class="enscript-type">int</span> type)
{
	kern_return_t kr;

	coalition_t coal = task-&gt;coalition[type];

	<span class="enscript-keyword">if</span> (!coal)
		<span class="enscript-keyword">return</span> KERN_SUCCESS;

	assert(coal-&gt;type == (uint32_t)type);

	coalition_lock(coal);

	kr = coal_call(coal, remove_task, task);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COALITION_DEBUG</span>
	uint64_t cid = coal-&gt;id;
	uint32_t rc = coal-&gt;ref_count;
	<span class="enscript-type">int</span>      ac = coal-&gt;active_count;
	<span class="enscript-type">int</span>      ct = coal-&gt;type;
#<span class="enscript-reference">endif</span>
	coalition_unlock(coal);

	coal_dbg(<span class="enscript-string">&quot;id:%llu type:%s ref_count:%u, active_count:%u, kr=%d&quot;</span>,
		 cid, coal_type_str(ct), rc, ac, kr);

	coalition_remove_active(coal);

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 * coalitions_adopt_task
 * Condition: All coalitions must be referenced and unlocked.
 * Will fail if any coalition is already terminated.
 */</span>
kern_return_t
<span class="enscript-function-name">coalitions_adopt_task</span>(coalition_t *coals, task_t task)
{
	<span class="enscript-type">int</span> i;
	kern_return_t kr;

	<span class="enscript-keyword">if</span> (!coals || coals[COALITION_TYPE_RESOURCE] == COALITION_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	<span class="enscript-comment">/* verify that the incoming coalitions are what they say they are */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; COALITION_NUM_TYPES; i++)
		<span class="enscript-keyword">if</span> (coals[i] &amp;&amp; coals[i]-&gt;type != (uint32_t)i)
			<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; COALITION_NUM_TYPES; i++) {
		kr = KERN_SUCCESS;
		<span class="enscript-keyword">if</span> (coals[i])
			kr = coalition_adopt_task_internal(coals[i], task);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			<span class="enscript-comment">/* dis-associate any coalitions that just adopted this task */</span>
			<span class="enscript-keyword">while</span> (--i &gt;= 0) {
				<span class="enscript-keyword">if</span> (task-&gt;coalition[i])
					coalition_remove_task_internal(task, i);
			}
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 * coalitions_remove_task
 * Condition: task must be referenced and UNLOCKED; all task's coalitions must be UNLOCKED
 */</span>
kern_return_t
<span class="enscript-function-name">coalitions_remove_task</span>(task_t task)
{
	kern_return_t kr;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; COALITION_NUM_TYPES; i++) {
		kr = coalition_remove_task_internal(task, i);
		assert(kr == KERN_SUCCESS);
	}

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 * task_release_coalitions
 * helper function to release references to all coalitions in which
 * 'task' is a member.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_release_coalitions</span>(task_t task)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; COALITION_NUM_TYPES; i++) {
		<span class="enscript-keyword">if</span> (task-&gt;coalition[i])
			coalition_release(task-&gt;coalition[i]);
	}
}

<span class="enscript-comment">/*
 * coalitions_set_roles
 * for each type of coalition, if the task is a member of a coalition of
 * that type (given in the coalitions parameter) then set the role of
 * the task within that that coalition.
 */</span>
kern_return_t <span class="enscript-function-name">coalitions_set_roles</span>(coalition_t coalitions[COALITION_NUM_TYPES],
				   task_t task, <span class="enscript-type">int</span> roles[COALITION_NUM_TYPES])
{
	kern_return_t kr = KERN_SUCCESS;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; COALITION_NUM_TYPES; i++) {
		<span class="enscript-keyword">if</span> (!coalitions[i])
			<span class="enscript-keyword">continue</span>;
		coalition_lock(coalitions[i]);
		kr = coal_call(coalitions[i], set_taskrole, task, roles[i]);
		coalition_unlock(coalitions[i]);
		assert(kr == KERN_SUCCESS);
	}

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 * coalition_terminate_internal
 * Condition: Coalition must be referenced and UNLOCKED.
 */</span>
kern_return_t
<span class="enscript-function-name">coalition_request_terminate_internal</span>(coalition_t coal)
{
	assert(coal-&gt;type &gt;= 0 &amp;&amp; coal-&gt;type &lt;= COALITION_TYPE_MAX);

	<span class="enscript-keyword">if</span> (coal == init_coalition[coal-&gt;type]) {
		<span class="enscript-keyword">return</span> KERN_DEFAULT_SET;
	}

	coalition_lock(coal);

	<span class="enscript-keyword">if</span> (coal-&gt;reaped) {
		coalition_unlock(coal);
		<span class="enscript-keyword">return</span> KERN_INVALID_NAME;
	}

	<span class="enscript-keyword">if</span> (coal-&gt;terminated || coal-&gt;termrequested) {
		coalition_unlock(coal);
		<span class="enscript-keyword">return</span> KERN_TERMINATED;
	}

	coal-&gt;termrequested = TRUE;

	boolean_t do_notify = FALSE;
	uint64_t note_id = 0;
	uint32_t note_flags = 0;

	<span class="enscript-keyword">if</span> (coal-&gt;active_count == 0) {
		<span class="enscript-comment">/*
		 * We only notify once, when active_count reaches zero.
		 * We just set termrequested to zero. If the active count
		 * was already at zero (tasks died before we could request
		 * a termination notification), we should notify.
		 */</span>
		assert(!coal-&gt;terminated);
		coal-&gt;terminated = TRUE;

		assert(!coal-&gt;notified);

		coal-&gt;notified = TRUE;
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEVELOPMENT</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEBUG</span>)
		do_notify = coal-&gt;should_notify;
#<span class="enscript-reference">else</span>
		do_notify = TRUE;
#<span class="enscript-reference">endif</span>
		note_id = coal-&gt;id;
		note_flags = 0;
	}

	coalition_unlock(coal);

	<span class="enscript-keyword">if</span> (do_notify) {
		coalition_notify_user(note_id, note_flags);
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 * coalition_reap_internal
 * Condition: Coalition must be referenced and UNLOCKED.
 */</span>
kern_return_t
<span class="enscript-function-name">coalition_reap_internal</span>(coalition_t coal)
{
	assert(coal-&gt;type &lt;= COALITION_TYPE_MAX);

	<span class="enscript-keyword">if</span> (coal == init_coalition[coal-&gt;type]) {
		<span class="enscript-keyword">return</span> KERN_DEFAULT_SET;
	}

	coalition_lock(coal);
	<span class="enscript-keyword">if</span> (coal-&gt;reaped) {
		coalition_unlock(coal);
		<span class="enscript-keyword">return</span> KERN_TERMINATED;
	}
	<span class="enscript-keyword">if</span> (!coal-&gt;terminated) {
		coalition_unlock(coal);
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}
	assert(coal-&gt;termrequested);
	<span class="enscript-keyword">if</span> (coal-&gt;active_count &gt; 0) {
		coalition_unlock(coal);
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	coal-&gt;reaped = TRUE;

	<span class="enscript-comment">/* Caller, launchd, and coalitions list should each have a reference */</span>
	assert(coal-&gt;ref_count &gt; 2);

	coalition_unlock(coal);

	lck_mtx_lock(&amp;coalitions_list_lock);
	coalition_count--;
	remqueue(&amp;coal-&gt;coalitions);
	lck_mtx_unlock(&amp;coalitions_list_lock);

	<span class="enscript-comment">/* Release the list's reference and launchd's reference. */</span>
	coalition_release(coal);
	coalition_release(coal);

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEVELOPMENT</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEBUG</span>)
<span class="enscript-type">int</span> <span class="enscript-function-name">coalition_should_notify</span>(coalition_t coal)
{
	<span class="enscript-type">int</span> should;
	<span class="enscript-keyword">if</span> (!coal)
		<span class="enscript-keyword">return</span> -1;
	coalition_lock(coal);
	should = coal-&gt;should_notify;
	coalition_unlock(coal);

	<span class="enscript-keyword">return</span> should;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">coalition_set_notify</span>(coalition_t coal, <span class="enscript-type">int</span> notify)
{
	<span class="enscript-keyword">if</span> (!coal)
		<span class="enscript-keyword">return</span>;
	coalition_lock(coal);
	coal-&gt;should_notify = !!notify;
	coalition_unlock(coal);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">coalitions_init</span>(<span class="enscript-type">void</span>)
{
	kern_return_t kr;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coalition_type *ctype;

	coalition_zone = zinit(
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> coalition),
			CONFIG_COALITION_MAX * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> coalition),
			COALITION_CHUNK * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> coalition),
			<span class="enscript-string">&quot;coalitions&quot;</span>);
	zone_change(coalition_zone, Z_NOENCRYPT, TRUE);
	queue_head_init(coalitions_q);

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;unrestrict_coalition_syscalls&quot;</span>, &amp;unrestrict_coalition_syscalls,
		<span class="enscript-keyword">sizeof</span> (unrestrict_coalition_syscalls))) {
		unrestrict_coalition_syscalls = 0;
	}

	lck_grp_attr_setdefault(&amp;coalitions_lck_grp_attr);
	lck_grp_init(&amp;coalitions_lck_grp, <span class="enscript-string">&quot;coalition&quot;</span>, &amp;coalitions_lck_grp_attr);
	lck_attr_setdefault(&amp;coalitions_lck_attr);
	lck_mtx_init(&amp;coalitions_list_lock, &amp;coalitions_lck_grp, &amp;coalitions_lck_attr);

	init_task_ledgers();

	<span class="enscript-keyword">for</span> (i = 0, ctype = &amp;s_coalition_types[0]; i &lt; COALITION_NUM_TYPES; ctype++, i++) {
		<span class="enscript-comment">/* verify the entry in the global coalition types array */</span>
		<span class="enscript-keyword">if</span> (ctype-&gt;type != i ||
		    !ctype-&gt;init ||
		    !ctype-&gt;dealloc ||
		    !ctype-&gt;adopt_task ||
		    !ctype-&gt;remove_task) {
			panic(<span class="enscript-string">&quot;%s: Malformed coalition type %s(%d) in slot for type:%s(%d)&quot;</span>,
			      __func__, coal_type_str(ctype-&gt;type), ctype-&gt;type, coal_type_str(i), i);
		}
		<span class="enscript-keyword">if</span> (!ctype-&gt;has_default)
			<span class="enscript-keyword">continue</span>;
		kr = coalition_create_internal(ctype-&gt;type, TRUE, &amp;init_coalition[ctype-&gt;type]);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			panic(<span class="enscript-string">&quot;%s: could not create init %s coalition: kr:%d&quot;</span>,
			      __func__, coal_type_str(i), kr);
	}

	<span class="enscript-comment">/* &quot;Leak&quot; our reference to the global object */</span>
}

<span class="enscript-comment">/*
 * BSD Kernel interface functions
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">coalition_fill_procinfo</span>(<span class="enscript-type">struct</span> coalition *coal,
				    <span class="enscript-type">struct</span> procinfo_coalinfo *coalinfo)
{
	coalinfo-&gt;coalition_id = coal-&gt;id;
	coalinfo-&gt;coalition_type = coal-&gt;type;
	coalinfo-&gt;coalition_tasks = coalition_get_task_count(coal);
}


<span class="enscript-type">int</span> <span class="enscript-function-name">coalitions_get_list</span>(<span class="enscript-type">int</span> type, <span class="enscript-type">struct</span> procinfo_coalinfo *coal_list, <span class="enscript-type">int</span> list_sz)
{
	<span class="enscript-type">int</span> ncoals = 0;
	<span class="enscript-type">struct</span> coalition *coal;

	lck_mtx_lock(&amp;coalitions_list_lock);
	qe_foreach_element(coal, &amp;coalitions_q, coalitions) {
		<span class="enscript-keyword">if</span> (!coal-&gt;reaped &amp;&amp; (type &lt; 0 || type == (<span class="enscript-type">int</span>)coal-&gt;type)) {
			<span class="enscript-keyword">if</span> (coal_list &amp;&amp; ncoals &lt; list_sz)
				coalition_fill_procinfo(coal, &amp;coal_list[ncoals]);
			++ncoals;
		}
	}
	lck_mtx_unlock(&amp;coalitions_list_lock);

	<span class="enscript-keyword">return</span> ncoals;
}

<span class="enscript-comment">/*
 * Jetsam coalition interface
 *
 */</span>
boolean_t <span class="enscript-function-name">coalition_is_leader</span>(task_t task, <span class="enscript-type">int</span> coal_type, coalition_t *coal)
{
	coalition_t c;
	boolean_t ret;

	<span class="enscript-keyword">if</span> (coal) <span class="enscript-comment">/* handle the error cases gracefully */</span>
		*coal = COALITION_NULL;

	<span class="enscript-keyword">if</span> (!task)
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">if</span> (coal_type &gt; COALITION_TYPE_MAX)
		<span class="enscript-keyword">return</span> FALSE;

	c = task-&gt;coalition[coal_type];
	<span class="enscript-keyword">if</span> (!c)
		<span class="enscript-keyword">return</span> FALSE;

	assert((<span class="enscript-type">int</span>)c-&gt;type == coal_type);

	coalition_lock(c);

	<span class="enscript-keyword">if</span> (coal)
		*coal = c;

	ret = FALSE;
	<span class="enscript-keyword">if</span> (c-&gt;type == COALITION_TYPE_JETSAM &amp;&amp; c-&gt;j.leader == task)
		ret = TRUE;

	coalition_unlock(c);

	<span class="enscript-keyword">return</span> ret;
}


<span class="enscript-type">int</span> <span class="enscript-function-name">coalition_get_task_count</span>(coalition_t coal)
{
	<span class="enscript-type">int</span> ntasks = 0;
	<span class="enscript-type">struct</span> queue_entry *qe;
	<span class="enscript-keyword">if</span> (!coal)
		<span class="enscript-keyword">return</span> 0;

	coalition_lock(coal);
	<span class="enscript-keyword">switch</span> (coal-&gt;type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_TYPE_RESOURCE</span>:
		qe_foreach(qe, &amp;coal-&gt;r.tasks)
			ntasks++;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_TYPE_JETSAM</span>:
		<span class="enscript-keyword">if</span> (coal-&gt;j.leader)
			ntasks++;
		qe_foreach(qe, &amp;coal-&gt;j.other)
			ntasks++;
		qe_foreach(qe, &amp;coal-&gt;j.extensions)
			ntasks++;
		qe_foreach(qe, &amp;coal-&gt;j.services)
			ntasks++;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
	coalition_unlock(coal);

	<span class="enscript-keyword">return</span> ntasks;
}


<span class="enscript-type">static</span> uint64_t <span class="enscript-function-name">i_get_list_footprint</span>(queue_t list, <span class="enscript-type">int</span> type, <span class="enscript-type">int</span> *ntasks)
{
	task_t task;
	uint64_t bytes = 0;

	qe_foreach_element(task, list, task_coalition[type]) {
		bytes += get_task_phys_footprint(task);
		coal_dbg(<span class="enscript-string">&quot;    [%d] task_pid:%d, type:%d, footprint:%lld&quot;</span>,
			 *ntasks, task_pid(task), type, bytes);
		*ntasks += 1;
	}

	<span class="enscript-keyword">return</span> bytes;
}

uint64_t <span class="enscript-function-name">coalition_get_page_count</span>(coalition_t coal, <span class="enscript-type">int</span> *ntasks)
{
	uint64_t bytes = 0;
	<span class="enscript-type">int</span> num_tasks = 0;

	<span class="enscript-keyword">if</span> (ntasks)
		*ntasks = 0;
	<span class="enscript-keyword">if</span> (!coal)
		<span class="enscript-keyword">return</span> bytes;

	coalition_lock(coal);

	<span class="enscript-keyword">switch</span> (coal-&gt;type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_TYPE_RESOURCE</span>:
		bytes += i_get_list_footprint(&amp;coal-&gt;r.tasks, COALITION_TYPE_RESOURCE, &amp;num_tasks);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_TYPE_JETSAM</span>:
		<span class="enscript-keyword">if</span> (coal-&gt;j.leader) {
			bytes += get_task_phys_footprint(coal-&gt;j.leader);
			num_tasks = 1;
		}
		bytes += i_get_list_footprint(&amp;coal-&gt;j.extensions, COALITION_TYPE_JETSAM, &amp;num_tasks);
		bytes += i_get_list_footprint(&amp;coal-&gt;j.services, COALITION_TYPE_JETSAM, &amp;num_tasks);
		bytes += i_get_list_footprint(&amp;coal-&gt;j.other, COALITION_TYPE_JETSAM, &amp;num_tasks);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	coalition_unlock(coal);

	<span class="enscript-keyword">if</span> (ntasks)
		*ntasks = num_tasks;

	<span class="enscript-keyword">return</span> bytes / PAGE_SIZE_64;
}

<span class="enscript-type">struct</span> coal_sort_s {
	<span class="enscript-type">int</span> pid;
	<span class="enscript-type">int</span> usr_order;
	uint64_t bytes;
};

<span class="enscript-comment">/*
 * return &lt; 0 for a &lt; b
 *          0 for a == b
 *        &gt; 0 for a &gt; b
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*cmpfunc_t)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *b);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">qsort</span>(<span class="enscript-type">void</span> *a, size_t n, size_t es, cmpfunc_t cmp);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dflt_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *b)
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *csA = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *)a;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *csB = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *)b;

	<span class="enscript-comment">/*
	 * if both A and B are equal, use a memory descending sort
	 */</span>
	<span class="enscript-keyword">if</span> (csA-&gt;usr_order == csB-&gt;usr_order)
		<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)((int64_t)csB-&gt;bytes - (int64_t)csA-&gt;bytes);

	<span class="enscript-comment">/* otherwise, return the relationship between user specified orders */</span>
	<span class="enscript-keyword">return</span> (csA-&gt;usr_order - csB-&gt;usr_order);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mem_asc_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *b)
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *csA = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *)a;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *csB = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *)b;

	<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)((int64_t)csA-&gt;bytes - (int64_t)csB-&gt;bytes);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mem_dec_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *b)
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *csA = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *)a;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *csB = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *)b;

	<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)((int64_t)csB-&gt;bytes - (int64_t)csA-&gt;bytes);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">usr_asc_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *b)
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *csA = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *)a;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *csB = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *)b;

	<span class="enscript-keyword">return</span> (csA-&gt;usr_order - csB-&gt;usr_order);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">usr_dec_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *b)
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *csA = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *)a;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *csB = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> coal_sort_s *)b;

	<span class="enscript-keyword">return</span> (csB-&gt;usr_order - csA-&gt;usr_order);
}

<span class="enscript-comment">/* avoid dynamic allocation in this path */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_SORTED_PIDS</span>  80

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">coalition_get_sort_list</span>(coalition_t coal, <span class="enscript-type">int</span> sort_order, queue_t list,
				   <span class="enscript-type">struct</span> coal_sort_s *sort_array, <span class="enscript-type">int</span> array_sz)
{
	<span class="enscript-type">int</span> ntasks = 0;
	task_t task;

	assert(sort_array != NULL);

	<span class="enscript-keyword">if</span> (array_sz &lt;= 0)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">if</span> (!list) {
		<span class="enscript-comment">/*
		 * this function will only be called with a NULL
		 * list for JETSAM-type coalitions, and is intended
		 * to investigate the leader process
		 */</span>
		<span class="enscript-keyword">if</span> (coal-&gt;type != COALITION_TYPE_JETSAM ||
		    coal-&gt;j.leader == TASK_NULL)
			<span class="enscript-keyword">return</span> 0;
		sort_array[0].pid = task_pid(coal-&gt;j.leader);
		<span class="enscript-keyword">switch</span> (sort_order) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_DEFAULT</span>:
			sort_array[0].usr_order = 0;
			<span class="enscript-comment">/* fall-through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_MEM_ASC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_MEM_DEC</span>:
			sort_array[0].bytes = get_task_phys_footprint(coal-&gt;j.leader);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_USER_ASC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_USER_DEC</span>:
			sort_array[0].usr_order = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">return</span> 1;
	}

	qe_foreach_element(task, list, task_coalition[coal-&gt;type]) {
		<span class="enscript-keyword">if</span> (ntasks &gt;= array_sz) {
			printf(<span class="enscript-string">&quot;WARNING: more than %d pids in coalition %llu\n&quot;</span>,
			       MAX_SORTED_PIDS, coal-&gt;id);
			<span class="enscript-keyword">break</span>;
		}

		sort_array[ntasks].pid = task_pid(task);

		<span class="enscript-keyword">switch</span> (sort_order) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_DEFAULT</span>:
			sort_array[ntasks].usr_order = 0;
			<span class="enscript-comment">/* fall-through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_MEM_ASC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_MEM_DEC</span>:
			sort_array[ntasks].bytes = get_task_phys_footprint(task);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_USER_ASC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_USER_DEC</span>:
			sort_array[ntasks].usr_order = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}

		ntasks++;
	}

	<span class="enscript-keyword">return</span> ntasks;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">coalition_get_pid_list</span>(coalition_t coal, uint32_t rolemask, <span class="enscript-type">int</span> sort_order,
			   <span class="enscript-type">int</span> *pid_list, <span class="enscript-type">int</span> list_sz)
{
	<span class="enscript-type">struct</span> i_jetsam_coalition *cj;
	<span class="enscript-type">int</span> ntasks = 0;
	cmpfunc_t cmp_func = NULL;
	<span class="enscript-type">struct</span> coal_sort_s sort_array[MAX_SORTED_PIDS] = { {0,0,0} }; <span class="enscript-comment">/* keep to &lt; 2k */</span>

	<span class="enscript-keyword">if</span> (!coal ||
	    !(rolemask &amp; COALITION_ROLEMASK_ALLROLES) ||
	    !pid_list || list_sz &lt; 1) {
		coal_dbg(<span class="enscript-string">&quot;Invalid parameters: coal:%p, type:%d, rolemask:0x%x, &quot;</span>
			 <span class="enscript-string">&quot;pid_list:%p, list_sz:%d&quot;</span>, coal, coal ? coal-&gt;type : -1,
			 rolemask, pid_list, list_sz);
		<span class="enscript-keyword">return</span> -EINVAL;
	}

	<span class="enscript-keyword">switch</span> (sort_order) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_NOSORT</span>:
		cmp_func = NULL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_DEFAULT</span>:
		cmp_func = dflt_cmp;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_MEM_ASC</span>:
		cmp_func = mem_asc_cmp;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_MEM_DEC</span>:
		cmp_func = mem_dec_cmp;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_USER_ASC</span>:
		cmp_func = usr_asc_cmp;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_SORT_USER_DEC</span>:
		cmp_func = usr_dec_cmp;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> -ENOTSUP;
	}

	coalition_lock(coal);

	<span class="enscript-keyword">if</span> (coal-&gt;type == COALITION_TYPE_RESOURCE) {
		ntasks += coalition_get_sort_list(coal, sort_order, &amp;coal-&gt;r.tasks,
						  sort_array, MAX_SORTED_PIDS);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock_coal</span>;
	}

	cj = &amp;coal-&gt;j;

	<span class="enscript-keyword">if</span> (rolemask &amp; COALITION_ROLEMASK_UNDEF)
		ntasks += coalition_get_sort_list(coal, sort_order, &amp;cj-&gt;other,
						  sort_array + ntasks,
						  MAX_SORTED_PIDS - ntasks);

	<span class="enscript-keyword">if</span> (rolemask &amp; COALITION_ROLEMASK_XPC)
		ntasks += coalition_get_sort_list(coal, sort_order, &amp;cj-&gt;services,
						  sort_array + ntasks,
						  MAX_SORTED_PIDS - ntasks);

	<span class="enscript-keyword">if</span> (rolemask &amp; COALITION_ROLEMASK_EXT)
		ntasks += coalition_get_sort_list(coal, sort_order, &amp;cj-&gt;extensions,
						  sort_array + ntasks,
						  MAX_SORTED_PIDS - ntasks);

	<span class="enscript-keyword">if</span> (rolemask &amp; COALITION_ROLEMASK_LEADER)
		ntasks += coalition_get_sort_list(coal, sort_order, NULL,
						  sort_array + ntasks,
						  MAX_SORTED_PIDS - ntasks);

<span class="enscript-reference">unlock_coal</span>:
	coalition_unlock(coal);

	<span class="enscript-comment">/* sort based on the chosen criterion (no sense sorting 1 item) */</span>
	<span class="enscript-keyword">if</span> (cmp_func &amp;&amp; ntasks &gt; 1)
		qsort(sort_array, ntasks, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> coal_sort_s), cmp_func);

	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; ntasks; i++) {
		<span class="enscript-keyword">if</span> (i &gt;= list_sz)
			<span class="enscript-keyword">break</span>;
		coal_dbg(<span class="enscript-string">&quot; [%d] PID:%d, footprint:%lld, usr_order:%d&quot;</span>,
			 i, sort_array[i].pid, sort_array[i].bytes,
			 sort_array[i].usr_order);
		pid_list[i] = sort_array[i].pid;
	}

	<span class="enscript-keyword">return</span> ntasks;
}
</pre>
<hr />
</body></html>