<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kalloc.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kalloc.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2011 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	kern/kalloc.c
 *	Author:	Avadis Tevanian, Jr.
 *	Date:	1985
 *
 *	General kernel memory allocator.  This allocator is designed
 *	to be used by the kernel to manage dynamic memory fast.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;zone_debug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine/vm_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ledger.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSMalloc.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
zone_t <span class="enscript-function-name">kalloc_zone</span>(vm_size_t);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KALLOC_MAP_SIZE_MIN</span>  (16 * 1024 * 1024)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KALLOC_MAP_SIZE_MAX</span>  (128 * 1024 * 1024)
vm_map_t kalloc_map;
vm_size_t kalloc_max;
vm_size_t kalloc_max_prerounded;
vm_size_t kalloc_kernmap_size;	<span class="enscript-comment">/* size of kallocs that can come from kernel map */</span>

<span class="enscript-comment">/* how many times we couldn't allocate out of kalloc_map and fell back to kernel_map */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> kalloc_fallback_count;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> kalloc_large_inuse;
vm_size_t    kalloc_large_total;
vm_size_t    kalloc_large_max;
vm_size_t    kalloc_largest_allocated = 0;
uint64_t    kalloc_large_sum;

<span class="enscript-type">int</span>	kalloc_fake_zone_index = -1; <span class="enscript-comment">/* index of our fake zone in statistics arrays */</span>

vm_offset_t	kalloc_map_min;
vm_offset_t	kalloc_map_max;

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">MUTEX_ZONE</span>
<span class="enscript-comment">/*
 * Diagnostic code to track mutexes separately rather than via the 2^ zones
 */</span>
	zone_t		lck_mtx_zone;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">KALLOC_ZINFO_SALLOC</span>(vm_size_t bytes)
{
	thread_t thr = current_thread();
	task_t task;
	zinfo_usage_t zinfo;

	ledger_debit(thr-&gt;t_ledger, task_ledgers.tkm_shared, bytes);

	<span class="enscript-keyword">if</span> (kalloc_fake_zone_index != -1 &amp;&amp; 
	    (task = thr-&gt;task) != NULL &amp;&amp; (zinfo = task-&gt;tkm_zinfo) != NULL)
		zinfo[kalloc_fake_zone_index].alloc += bytes;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">KALLOC_ZINFO_SFREE</span>(vm_size_t bytes)
{
	thread_t thr = current_thread();
	task_t task;
	zinfo_usage_t zinfo;

	ledger_credit(thr-&gt;t_ledger, task_ledgers.tkm_shared, bytes);

	<span class="enscript-keyword">if</span> (kalloc_fake_zone_index != -1 &amp;&amp; 
	    (task = thr-&gt;task) != NULL &amp;&amp; (zinfo = task-&gt;tkm_zinfo) != NULL)
		zinfo[kalloc_fake_zone_index].free += bytes;
}

<span class="enscript-comment">/*
 *	All allocations of size less than kalloc_max are rounded to the
 *	next nearest sized zone.  This allocator is built on top of
 *	the zone allocator.  A zone is created for each potential size
 *	that we are willing to get in small blocks.
 *
 *	We assume that kalloc_max is not greater than 64K;
 *
 *	Note that kalloc_max is somewhat confusingly named.
 *	It represents the first power of two for which no zone exists.
 *	kalloc_max_prerounded is the smallest allocation size, before
 *	rounding, for which no zone exists.
 *
 *	Also if the allocation size is more than kalloc_kernmap_size 
 *	then allocate from kernel map rather than kalloc_map.
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KALLOC_MINSIZE</span> == 16 &amp;&amp; <span class="enscript-variable-name">KALLOC_LOG2_MINALIGN</span> == 4

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">K_ZONE_SIZES</span>			\
	16,				\
	32,				\
	48,				\
<span class="enscript-comment">/* 3 */</span>	64,				\
	80,				\
	96,				\
<span class="enscript-comment">/* 6 */</span>	128,				\
	160,				\
	256,				\
<span class="enscript-comment">/* 9 */</span>	288,				\
	512,				\
	1024,				\
<span class="enscript-comment">/* C */</span>	1280,				\
	2048,				\
	4096

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">K_ZONE_NAMES</span>			\
	<span class="enscript-string">&quot;kalloc.16&quot;</span>,			\
	<span class="enscript-string">&quot;kalloc.32&quot;</span>,			\
	<span class="enscript-string">&quot;kalloc.48&quot;</span>,			\
<span class="enscript-comment">/* 3 */</span>	<span class="enscript-string">&quot;kalloc.64&quot;</span>,			\
	<span class="enscript-string">&quot;kalloc.80&quot;</span>,			\
	<span class="enscript-string">&quot;kalloc.96&quot;</span>,			\
<span class="enscript-comment">/* 6 */</span>	<span class="enscript-string">&quot;kalloc.128&quot;</span>,			\
	<span class="enscript-string">&quot;kalloc.160&quot;</span>,			\
	<span class="enscript-string">&quot;kalloc.256&quot;</span>,			\
<span class="enscript-comment">/* 9 */</span>	<span class="enscript-string">&quot;kalloc.288&quot;</span>,			\
	<span class="enscript-string">&quot;kalloc.512&quot;</span>,			\
	<span class="enscript-string">&quot;kalloc.1024&quot;</span>,			\
<span class="enscript-comment">/* C */</span>	<span class="enscript-string">&quot;kalloc.1280&quot;</span>,			\
	<span class="enscript-string">&quot;kalloc.2048&quot;</span>,			\
	<span class="enscript-string">&quot;kalloc.4096&quot;</span>

#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">KALLOC_MINSIZE</span> == 8 &amp;&amp; <span class="enscript-variable-name">KALLOC_LOG2_MINALIGN</span> == 3

<span class="enscript-comment">/*
 * Tweaked for ARM (and x64) in 04/2011
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">K_ZONE_SIZES</span>			\
<span class="enscript-comment">/* 3 */</span>	8,				\
	16,	24,			\
	32,	40,	48,		\
<span class="enscript-comment">/* 6 */</span>	64,	72,	88,	112, 	\
	128, 	192,			\
	256, 	288,	384,	440,	\
<span class="enscript-comment">/* 9 */</span>	512,	768,			\
	1024,	1152,	1536,		\
	2048,	3072,			\
	4096,	6144

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">K_ZONE_NAMES</span>			\
<span class="enscript-comment">/* 3 */</span>	<span class="enscript-string">&quot;kalloc.8&quot;</span>,			\
	<span class="enscript-string">&quot;kalloc.16&quot;</span>,	<span class="enscript-string">&quot;kalloc.24&quot;</span>,	\
	<span class="enscript-string">&quot;kalloc.32&quot;</span>,	<span class="enscript-string">&quot;kalloc.40&quot;</span>,	<span class="enscript-string">&quot;kalloc.48&quot;</span>,	\
<span class="enscript-comment">/* 6 */</span>	<span class="enscript-string">&quot;kalloc.64&quot;</span>,	<span class="enscript-string">&quot;kalloc.72&quot;</span>,	<span class="enscript-string">&quot;kalloc.88&quot;</span>,	<span class="enscript-string">&quot;kalloc.112&quot;</span>,	\
	<span class="enscript-string">&quot;kalloc.128&quot;</span>,	<span class="enscript-string">&quot;kalloc.192&quot;</span>,	\
	<span class="enscript-string">&quot;kalloc.256&quot;</span>,	<span class="enscript-string">&quot;kalloc.288&quot;</span>,	<span class="enscript-string">&quot;kalloc.384&quot;</span>,	<span class="enscript-string">&quot;kalloc.440&quot;</span>,	\
<span class="enscript-comment">/* 9 */</span>	<span class="enscript-string">&quot;kalloc.512&quot;</span>,	<span class="enscript-string">&quot;kalloc.768&quot;</span>,	\
	<span class="enscript-string">&quot;kalloc.1024&quot;</span>,	<span class="enscript-string">&quot;kalloc.1152&quot;</span>,	<span class="enscript-string">&quot;kalloc.1536&quot;</span>,	\
	<span class="enscript-string">&quot;kalloc.2048&quot;</span>,	<span class="enscript-string">&quot;kalloc.3072&quot;</span>,	\
	<span class="enscript-string">&quot;kalloc.4096&quot;</span>,	<span class="enscript-string">&quot;kalloc.6144&quot;</span>

#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span>	<span class="enscript-variable-name">missing</span> <span class="enscript-variable-name">zone</span> <span class="enscript-variable-name">size</span> <span class="enscript-variable-name">parameters</span> <span class="enscript-variable-name">for</span> <span class="enscript-variable-name">kalloc</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KALLOC_MINALIGN</span> (1 &lt;&lt; KALLOC_LOG2_MINALIGN)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KiB</span>(x) (1024 * (x))

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> k_zone_size[] = {
	K_ZONE_SIZES,
	KiB(8),
	KiB(16),
	KiB(32)
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_K_ZONE</span>	(sizeof (k_zone_size) / sizeof (k_zone_size[0]))

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *k_zone_name[MAX_K_ZONE] = {
	K_ZONE_NAMES,
	<span class="enscript-string">&quot;kalloc.8192&quot;</span>,
	<span class="enscript-string">&quot;kalloc.16384&quot;</span>,
	<span class="enscript-string">&quot;kalloc.32768&quot;</span>
};


<span class="enscript-comment">/*
 * Many kalloc() allocations are for small structures containing a few
 * pointers and longs - the k_zone_dlut[] direct lookup table, indexed by
 * size normalized to the minimum alignment, finds the right zone index
 * for them in one dereference.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">INDEX_ZDLUT</span>(size)	\
			(((size) + KALLOC_MINALIGN - 1) / KALLOC_MINALIGN)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">N_K_ZDLUT</span>	(2048 / KALLOC_MINALIGN)
				<span class="enscript-comment">/* covers sizes [0 .. 2048 - KALLOC_MINALIGN] */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_SIZE_ZDLUT</span>	((N_K_ZDLUT - 1) * KALLOC_MINALIGN)

<span class="enscript-type">static</span> int8_t k_zone_dlut[N_K_ZDLUT];	<span class="enscript-comment">/* table of indices into k_zone[] */</span>

<span class="enscript-comment">/*
 * If there's no hit in the DLUT, then start searching from k_zindex_start.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> k_zindex_start;

<span class="enscript-type">static</span> zone_t k_zone[MAX_K_ZONE];

<span class="enscript-comment">/* #define KALLOC_DEBUG		1 */</span>

<span class="enscript-comment">/* forward declarations */</span>

lck_grp_t kalloc_lck_grp;
lck_mtx_t kalloc_lock;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">kalloc_spin_lock</span>()	lck_mtx_lock_spin(&amp;kalloc_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">kalloc_unlock</span>()		lck_mtx_unlock(&amp;kalloc_lock)


<span class="enscript-comment">/* OSMalloc local data declarations */</span>
<span class="enscript-type">static</span>
queue_head_t    OSMalloc_tag_list;

lck_grp_t *OSMalloc_tag_lck_grp;
lck_mtx_t OSMalloc_tag_lock;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSMalloc_tag_spin_lock</span>()	lck_mtx_lock_spin(&amp;OSMalloc_tag_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OSMalloc_tag_unlock</span>()		lck_mtx_unlock(&amp;OSMalloc_tag_lock)


<span class="enscript-comment">/* OSMalloc forward declarations */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">OSMalloc_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">OSMalloc_Tagref</span>(OSMallocTag	tag);
<span class="enscript-type">void</span> <span class="enscript-function-name">OSMalloc_Tagrele</span>(OSMallocTag	tag);

<span class="enscript-comment">/*
 *	Initialize the memory allocator.  This should be called only
 *	once on a system wide basis (i.e. first processor to get here
 *	does the initialization).
 *
 *	This initializes all of the zones.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">kalloc_init</span>(
	<span class="enscript-type">void</span>)
{
	kern_return_t retval;
	vm_offset_t min;
	vm_size_t size, kalloc_map_size;
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> i;

	<span class="enscript-comment">/* 
	 * Scale the kalloc_map_size to physical memory size: stay below 
	 * 1/8th the total zone map size, or 128 MB (for a 32-bit kernel).
	 */</span>
	kalloc_map_size = (vm_size_t)(sane_size &gt;&gt; 5);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-keyword">if</span> (kalloc_map_size &gt; KALLOC_MAP_SIZE_MAX)
		kalloc_map_size = KALLOC_MAP_SIZE_MAX;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
	<span class="enscript-keyword">if</span> (kalloc_map_size &lt; KALLOC_MAP_SIZE_MIN)
		kalloc_map_size = KALLOC_MAP_SIZE_MIN;

	retval = kmem_suballoc(kernel_map, &amp;min, kalloc_map_size,
			       FALSE, VM_FLAGS_ANYWHERE | VM_FLAGS_PERMANENT | VM_MAKE_TAG(0),
			       &amp;kalloc_map);

	<span class="enscript-keyword">if</span> (retval != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;kalloc_init: kmem_suballoc failed&quot;</span>);

	kalloc_map_min = min;
	kalloc_map_max = min + kalloc_map_size - 1;

	<span class="enscript-comment">/*
	 * Create zones up to a least 2 pages because small page-multiples are common
	 * allocations. Also ensure that zones up to size 8192 bytes exist. This is
	 * desirable because messages are allocated with kalloc(), and messages up
	 * through size 8192 are common.
	 */</span>
	kalloc_max = PAGE_SIZE &lt;&lt; 2;
	<span class="enscript-keyword">if</span> (kalloc_max &lt; KiB(16)) {
	    kalloc_max = KiB(16);
	}
	assert(kalloc_max &lt;= KiB(64)); <span class="enscript-comment">/* assumption made in size arrays */</span>

	kalloc_max_prerounded = kalloc_max / 2 + 1;
	<span class="enscript-comment">/* allocations larger than 16 times kalloc_max go directly to kernel map */</span>
	kalloc_kernmap_size = (kalloc_max * 16) + 1;
	kalloc_largest_allocated = kalloc_kernmap_size;

	<span class="enscript-comment">/*
	 * Allocate a zone for each size we are going to handle. Don't charge the
	 * caller for the allocation, as we aren't sure how the memory will be
	 * handled.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)MAX_K_ZONE &amp;&amp; (size = k_zone_size[i]) &lt; kalloc_max; i++) {
		k_zone[i] = zinit(size, size, size, k_zone_name[i]);
		zone_change(k_zone[i], Z_CALLERACCT, FALSE);
	}

	<span class="enscript-comment">/*
	 * Build the Direct LookUp Table for small allocations
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0, size = 0; i &lt;= N_K_ZDLUT; i++, size += KALLOC_MINALIGN) {
		<span class="enscript-type">int</span> zindex = 0;

		<span class="enscript-keyword">while</span> ((vm_size_t)k_zone_size[zindex] &lt; size)
			zindex++;

		<span class="enscript-keyword">if</span> (i == N_K_ZDLUT) {
			k_zindex_start = zindex;
			<span class="enscript-keyword">break</span>;
		}
		k_zone_dlut[i] = (int8_t)zindex;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KALLOC_DEBUG</span>
	printf(<span class="enscript-string">&quot;kalloc_init: k_zindex_start %d\n&quot;</span>, k_zindex_start);

	<span class="enscript-comment">/*
	 * Do a quick synthesis to see how well/badly we can
	 * find-a-zone for a given size.
	 * Useful when debugging/tweaking the array of zone sizes.
	 * Cache misses probably more critical than compare-branches!
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)MAX_K_ZONE; i++) {
		vm_size_t testsize = (vm_size_t)k_zone_size[i] - 1;
		<span class="enscript-type">int</span> compare = 0;
		<span class="enscript-type">int</span> zindex;

		<span class="enscript-keyword">if</span> (testsize &lt; MAX_SIZE_ZDLUT) {
			compare += 1;	<span class="enscript-comment">/* 'if' (T) */</span>

			<span class="enscript-type">long</span> dindex = INDEX_ZDLUT(testsize);
			zindex = (<span class="enscript-type">int</span>)k_zone_dlut[dindex];

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (testsize &lt; kalloc_max_prerounded) {

			compare += 2;	<span class="enscript-comment">/* 'if' (F), 'if' (T) */</span>

			zindex = k_zindex_start;
			<span class="enscript-keyword">while</span> ((vm_size_t)k_zone_size[zindex] &lt; testsize) {
				zindex++;
				compare++;	<span class="enscript-comment">/* 'while' (T) */</span>
			}
			compare++;	<span class="enscript-comment">/* 'while' (F) */</span>
		} <span class="enscript-keyword">else</span>
			<span class="enscript-keyword">break</span>;	<span class="enscript-comment">/* not zone-backed */</span>

		zone_t z = k_zone[zindex];
		printf(<span class="enscript-string">&quot;kalloc_init: req size %4lu: %11s took %d compare%s\n&quot;</span>,
		    (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)testsize, z-&gt;zone_name, compare,
		    compare == 1 ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;s&quot;</span>);
	}
#<span class="enscript-reference">endif</span>

	lck_grp_init(&amp;kalloc_lck_grp, <span class="enscript-string">&quot;kalloc.large&quot;</span>, LCK_GRP_ATTR_NULL);
	lck_mtx_init(&amp;kalloc_lock, &amp;kalloc_lck_grp, LCK_ATTR_NULL);
	OSMalloc_init();
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">MUTEX_ZONE</span>
	lck_mtx_zone = zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> _lck_mtx_), 1024*256, 4096, <span class="enscript-string">&quot;lck_mtx&quot;</span>);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 * Given an allocation size, return the kalloc zone it belongs to.
 * Direct LookUp Table variant.
 */</span>
<span class="enscript-type">static</span> __inline zone_t
<span class="enscript-function-name">get_zone_dlut</span>(vm_size_t size)
{
	<span class="enscript-type">long</span> dindex = INDEX_ZDLUT(size);
	<span class="enscript-type">int</span> zindex = (<span class="enscript-type">int</span>)k_zone_dlut[dindex];
	<span class="enscript-keyword">return</span> (k_zone[zindex]);
}

<span class="enscript-comment">/* As above, but linear search k_zone_size[] for the next zone that fits. */</span>

<span class="enscript-type">static</span> __inline zone_t
<span class="enscript-function-name">get_zone_search</span>(vm_size_t size, <span class="enscript-type">int</span> zindex)
{
	assert(size &lt; kalloc_max_prerounded);

	<span class="enscript-keyword">while</span> ((vm_size_t)k_zone_size[zindex] &lt; size)
		zindex++;

	assert((<span class="enscript-type">unsigned</span>)zindex &lt; MAX_K_ZONE &amp;&amp;
	    (vm_size_t)k_zone_size[zindex] &lt; kalloc_max);

	<span class="enscript-keyword">return</span> (k_zone[zindex]);
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">kalloc_canblock</span>(
		vm_size_t	       size,
		boolean_t              canblock,
		vm_allocation_site_t * site)
{
	zone_t z;

	<span class="enscript-keyword">if</span> (size &lt; MAX_SIZE_ZDLUT)
		z = get_zone_dlut(size);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (size &lt; kalloc_max_prerounded)
		z = get_zone_search(size, k_zindex_start);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * If size is too large for a zone, then use kmem_alloc.
		 * (We use kmem_alloc instead of kmem_alloc_kobject so that
		 * krealloc can use kmem_realloc.)
		 */</span>
		vm_map_t alloc_map;
		<span class="enscript-type">void</span> *addr;

		<span class="enscript-comment">/* kmem_alloc could block so we return if noblock */</span>
		<span class="enscript-keyword">if</span> (!canblock) {
			<span class="enscript-keyword">return</span>(NULL);
		}

		<span class="enscript-keyword">if</span> (size &gt;= kalloc_kernmap_size)
		        alloc_map = kernel_map;
		<span class="enscript-keyword">else</span>
			alloc_map = kalloc_map;

		vm_tag_t tag;
		tag = (site ? tag = vm_tag_alloc(site) : VM_KERN_MEMORY_KALLOC);

		<span class="enscript-keyword">if</span> (kmem_alloc(alloc_map, (vm_offset_t *)&amp;addr, size, tag) != KERN_SUCCESS) {
			<span class="enscript-keyword">if</span> (alloc_map != kernel_map) {
				<span class="enscript-keyword">if</span> (kalloc_fallback_count++ == 0) {
					printf(<span class="enscript-string">&quot;%s: falling back to kernel_map\n&quot;</span>, __func__);
				}
				<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;addr, size, tag) != KERN_SUCCESS)
					addr = NULL;
			}
			<span class="enscript-keyword">else</span>
				addr = NULL;
		}

		<span class="enscript-keyword">if</span> (addr != NULL) {
			kalloc_spin_lock();
			<span class="enscript-comment">/*
			 * Thread-safe version of the workaround for 4740071
			 * (a double FREE())
			 */</span>
			<span class="enscript-keyword">if</span> (size &gt; kalloc_largest_allocated)
				kalloc_largest_allocated = size;

		        kalloc_large_inuse++;
		        kalloc_large_total += size;
			kalloc_large_sum += size;

			<span class="enscript-keyword">if</span> (kalloc_large_total &gt; kalloc_large_max)
			        kalloc_large_max = kalloc_large_total;

			kalloc_unlock();

			KALLOC_ZINFO_SALLOC(size);
		}
		<span class="enscript-keyword">return</span>(addr);
	}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KALLOC_DEBUG</span>
	<span class="enscript-keyword">if</span> (size &gt; z-&gt;elem_size)
		panic(<span class="enscript-string">&quot;%s: z %p (%s) but requested size %lu&quot;</span>, __func__,
		    z, z-&gt;zone_name, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)size);
#<span class="enscript-reference">endif</span>
	assert(size &lt;= z-&gt;elem_size);
	<span class="enscript-keyword">return</span> zalloc_canblock(z, canblock);
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">kalloc_external</span>(
       vm_size_t size);
<span class="enscript-type">void</span> *
<span class="enscript-function-name">kalloc_external</span>(
       vm_size_t size)
{
	<span class="enscript-keyword">return</span>( kalloc_tag_bt(size, VM_KERN_MEMORY_KALLOC) );
}

<span class="enscript-type">volatile</span> SInt32 kfree_nop_count = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">kfree</span>(
	<span class="enscript-type">void</span> 		*data,
	vm_size_t	size)
{
	zone_t z;

	<span class="enscript-keyword">if</span> (size &lt; MAX_SIZE_ZDLUT)
		z = get_zone_dlut(size);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (size &lt; kalloc_max_prerounded)
		z = get_zone_search(size, k_zindex_start);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* if size was too large for a zone, then use kmem_free */</span>

		vm_map_t alloc_map = kernel_map;

		<span class="enscript-keyword">if</span> ((((vm_offset_t) data) &gt;= kalloc_map_min) &amp;&amp; (((vm_offset_t) data) &lt;= kalloc_map_max))
			alloc_map = kalloc_map;
		<span class="enscript-keyword">if</span> (size &gt; kalloc_largest_allocated) {
			        <span class="enscript-comment">/*
				 * work around double FREEs of small MALLOCs
				 * this used to end up being a nop
				 * since the pointer being freed from an
				 * alloc backed by the zalloc world could
				 * never show up in the kalloc_map... however,
				 * the kernel_map is a different issue... since it
				 * was released back into the zalloc pool, a pointer
				 * would have gotten written over the 'size' that 
				 * the MALLOC was retaining in the first 4 bytes of
				 * the underlying allocation... that pointer ends up 
				 * looking like a really big size on the 2nd FREE and
				 * pushes the kfree into the kernel_map...  we
				 * end up removing a ton of virtual space before we panic
				 * this check causes us to ignore the kfree for a size
				 * that must be 'bogus'... note that it might not be due
				 * to the above scenario, but it would still be wrong and
				 * cause serious damage.
				 */</span>

				OSAddAtomic(1, &amp;kfree_nop_count);
			        <span class="enscript-keyword">return</span>;
		}
		kmem_free(alloc_map, (vm_offset_t)data, size);

		kalloc_spin_lock();

		kalloc_large_total -= size;
		kalloc_large_inuse--;

		kalloc_unlock();

		KALLOC_ZINFO_SFREE(size);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* free to the appropriate zone */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KALLOC_DEBUG</span>
	<span class="enscript-keyword">if</span> (size &gt; z-&gt;elem_size)
		panic(<span class="enscript-string">&quot;%s: z %p (%s) but requested size %lu&quot;</span>, __func__,
		    z, z-&gt;zone_name, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)size);
#<span class="enscript-reference">endif</span>
	assert(size &lt;= z-&gt;elem_size);
	zfree(z, data);
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
zone_t
<span class="enscript-function-name">kalloc_zone</span>(
	vm_size_t       size)
{
	<span class="enscript-keyword">if</span> (size &lt; MAX_SIZE_ZDLUT)
		<span class="enscript-keyword">return</span> (get_zone_dlut(size));
	<span class="enscript-keyword">if</span> (size &lt;= kalloc_max)
		<span class="enscript-keyword">return</span> (get_zone_search(size, k_zindex_start));
	<span class="enscript-keyword">return</span> (ZONE_NULL);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">kalloc_fake_zone_init</span>(<span class="enscript-type">int</span> zone_index)
{
	kalloc_fake_zone_index = zone_index;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kalloc_fake_zone_info</span>(<span class="enscript-type">int</span> *count, 
		      vm_size_t *cur_size, vm_size_t *max_size, vm_size_t *elem_size, vm_size_t *alloc_size,
		      uint64_t *sum_size, <span class="enscript-type">int</span> *collectable, <span class="enscript-type">int</span> *exhaustable, <span class="enscript-type">int</span> *caller_acct)
{
	*count      = kalloc_large_inuse;
	*cur_size   = kalloc_large_total;
	*max_size   = kalloc_large_max;

	<span class="enscript-keyword">if</span> (kalloc_large_inuse) {
		*elem_size  = kalloc_large_total / kalloc_large_inuse;
		*alloc_size = kalloc_large_total / kalloc_large_inuse;
	} <span class="enscript-keyword">else</span> {
		*elem_size  = 0;
		*alloc_size = 0;
	}
	*sum_size   = kalloc_large_sum;
	*collectable = 0;
	*exhaustable = 0;
	*caller_acct = 0;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">OSMalloc_init</span>(
	<span class="enscript-type">void</span>)
{
	queue_init(&amp;OSMalloc_tag_list);

	OSMalloc_tag_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;OSMalloc_tag&quot;</span>, LCK_GRP_ATTR_NULL);
	lck_mtx_init(&amp;OSMalloc_tag_lock, OSMalloc_tag_lck_grp, LCK_ATTR_NULL);
}

OSMallocTag
<span class="enscript-function-name">OSMalloc_Tagalloc</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>			*str,
	uint32_t			flags)
{
	OSMallocTag       OSMTag;

	OSMTag = (OSMallocTag)kalloc(<span class="enscript-keyword">sizeof</span>(*OSMTag));

	bzero((<span class="enscript-type">void</span> *)OSMTag, <span class="enscript-keyword">sizeof</span>(*OSMTag));

	<span class="enscript-keyword">if</span> (flags &amp; OSMT_PAGEABLE)
		OSMTag-&gt;OSMT_attr = OSMT_ATTR_PAGEABLE;

	OSMTag-&gt;OSMT_refcnt = 1;

	strlcpy(OSMTag-&gt;OSMT_name, str, OSMT_MAX_NAME);

	OSMalloc_tag_spin_lock();
	enqueue_tail(&amp;OSMalloc_tag_list, (queue_entry_t)OSMTag);
	OSMalloc_tag_unlock();
	OSMTag-&gt;OSMT_state = OSMT_VALID;
	<span class="enscript-keyword">return</span>(OSMTag);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">OSMalloc_Tagref</span>(
	 OSMallocTag		tag)
{
	<span class="enscript-keyword">if</span> (!((tag-&gt;OSMT_state &amp; OSMT_VALID_MASK) == OSMT_VALID)) 
		panic(<span class="enscript-string">&quot;OSMalloc_Tagref():'%s' has bad state 0x%08X\n&quot;</span>, tag-&gt;OSMT_name, tag-&gt;OSMT_state);

	(<span class="enscript-type">void</span>)hw_atomic_add(&amp;tag-&gt;OSMT_refcnt, 1);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">OSMalloc_Tagrele</span>(
	 OSMallocTag		tag)
{
	<span class="enscript-keyword">if</span> (!((tag-&gt;OSMT_state &amp; OSMT_VALID_MASK) == OSMT_VALID))
		panic(<span class="enscript-string">&quot;OSMalloc_Tagref():'%s' has bad state 0x%08X\n&quot;</span>, tag-&gt;OSMT_name, tag-&gt;OSMT_state);

	<span class="enscript-keyword">if</span> (hw_atomic_sub(&amp;tag-&gt;OSMT_refcnt, 1) == 0) {
		<span class="enscript-keyword">if</span> (hw_compare_and_store(OSMT_VALID|OSMT_RELEASED, OSMT_VALID|OSMT_RELEASED, &amp;tag-&gt;OSMT_state)) {
			OSMalloc_tag_spin_lock();
			(<span class="enscript-type">void</span>)remque((queue_entry_t)tag);
			OSMalloc_tag_unlock();
			kfree((<span class="enscript-type">void</span>*)tag, <span class="enscript-keyword">sizeof</span>(*tag));
		} <span class="enscript-keyword">else</span>
			panic(<span class="enscript-string">&quot;OSMalloc_Tagrele():'%s' has refcnt 0\n&quot;</span>, tag-&gt;OSMT_name);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">OSMalloc_Tagfree</span>(
	 OSMallocTag		tag)
{
	<span class="enscript-keyword">if</span> (!hw_compare_and_store(OSMT_VALID, OSMT_VALID|OSMT_RELEASED, &amp;tag-&gt;OSMT_state))
		panic(<span class="enscript-string">&quot;OSMalloc_Tagfree():'%s' has bad state 0x%08X \n&quot;</span>, tag-&gt;OSMT_name, tag-&gt;OSMT_state);

	<span class="enscript-keyword">if</span> (hw_atomic_sub(&amp;tag-&gt;OSMT_refcnt, 1) == 0) {
		OSMalloc_tag_spin_lock();
		(<span class="enscript-type">void</span>)remque((queue_entry_t)tag);
		OSMalloc_tag_unlock();
		kfree((<span class="enscript-type">void</span>*)tag, <span class="enscript-keyword">sizeof</span>(*tag));
	}
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">OSMalloc</span>(
	uint32_t			size,
	OSMallocTag			tag)
{
	<span class="enscript-type">void</span>			*addr=NULL;
	kern_return_t	kr;

	OSMalloc_Tagref(tag);
	<span class="enscript-keyword">if</span> ((tag-&gt;OSMT_attr &amp; OSMT_PAGEABLE)
	    &amp;&amp; (size &amp; ~PAGE_MASK)) {
		<span class="enscript-keyword">if</span> ((kr = kmem_alloc_pageable_external(kernel_map, (vm_offset_t *)&amp;addr, size)) != KERN_SUCCESS)
			addr = NULL;
	} <span class="enscript-keyword">else</span> 
		addr = kalloc_tag_bt((vm_size_t)size, VM_KERN_MEMORY_KALLOC);

	<span class="enscript-keyword">if</span> (!addr)
		OSMalloc_Tagrele(tag);

	<span class="enscript-keyword">return</span>(addr);
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">OSMalloc_nowait</span>(
	uint32_t			size,
	OSMallocTag			tag)
{
	<span class="enscript-type">void</span>	*addr=NULL;

	<span class="enscript-keyword">if</span> (tag-&gt;OSMT_attr &amp; OSMT_PAGEABLE)
		<span class="enscript-keyword">return</span>(NULL);

	OSMalloc_Tagref(tag);
	<span class="enscript-comment">/* XXX: use non-blocking kalloc for now */</span>
	addr = kalloc_noblock_tag_bt((vm_size_t)size, VM_KERN_MEMORY_KALLOC);
	<span class="enscript-keyword">if</span> (addr == NULL)
		OSMalloc_Tagrele(tag);

	<span class="enscript-keyword">return</span>(addr);
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">OSMalloc_noblock</span>(
	uint32_t			size,
	OSMallocTag			tag)
{
	<span class="enscript-type">void</span>	*addr=NULL;

	<span class="enscript-keyword">if</span> (tag-&gt;OSMT_attr &amp; OSMT_PAGEABLE)
		<span class="enscript-keyword">return</span>(NULL);

	OSMalloc_Tagref(tag);
	addr = kalloc_noblock_tag_bt((vm_size_t)size, VM_KERN_MEMORY_KALLOC);
	<span class="enscript-keyword">if</span> (addr == NULL)
		OSMalloc_Tagrele(tag);

	<span class="enscript-keyword">return</span>(addr);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">OSFree</span>(
	<span class="enscript-type">void</span>				*addr,
	uint32_t			size,
	OSMallocTag			tag) 
{
	<span class="enscript-keyword">if</span> ((tag-&gt;OSMT_attr &amp; OSMT_PAGEABLE)
	    &amp;&amp; (size &amp; ~PAGE_MASK)) {
		kmem_free(kernel_map, (vm_offset_t)addr, size);
	} <span class="enscript-keyword">else</span>
		kfree((<span class="enscript-type">void</span> *)addr, size);

	OSMalloc_Tagrele(tag);
}
</pre>
<hr />
</body></html>