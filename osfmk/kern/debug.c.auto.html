<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>debug.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">debug.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_kdp.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/telemetry.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ecc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_cdata.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>
#<span class="enscript-reference">if</span> !(<span class="enscript-variable-name">MACH_KDP</span> &amp;&amp; <span class="enscript-variable-name">CONFIG_KDP_INTERACTIVE_DEBUGGING</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/kdp_udp.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpu_threads.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/pmCPU.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPlatformExpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_routines.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSKextLibPrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kernel_mach_header.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;uuid/uuid.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug/zone_info.h&gt;</span>

#<span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__arm64__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NAND_PANIC_DEVICE</span>)) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">LEGACY_PANIC_LOGS</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span> <span class="enscript-comment">/* For gPanicBase */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	halt_in_debugger = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	switch_debugger = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	current_debugger = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	active_debugger = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	debug_mode=0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 	disable_debug_output = TRUE;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 	systemLogDiags = FALSE;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 	panicDebugging = FALSE;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	logPanicDataToScreen = FALSE;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	kdebug_serial = FALSE;

<span class="enscript-type">int</span> mach_assert = 1;

<span class="enscript-type">const</span> <span class="enscript-type">char</span>		*panicstr = (<span class="enscript-type">char</span> *) 0;
<span class="enscript-function-name">decl_simple_lock_data</span>(,panic_lock)
<span class="enscript-type">int</span>			paniccpu;
<span class="enscript-type">volatile</span> <span class="enscript-type">int</span>		panicwait;
<span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	nestedpanic= 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		panic_is_inited = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		return_on_panic = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>		panic_caller;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_BUF_SIZE</span> (3 * PAGE_SIZE)

<span class="enscript-comment">/* debug_buf is directly linked with iBoot panic region for ARM64 targets */</span>
#<span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__arm64__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NAND_PANIC_DEVICE</span>)) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">LEGACY_PANIC_LOGS</span>)
<span class="enscript-type">char</span> *debug_buf_addr = NULL;
<span class="enscript-type">char</span> *debug_buf_ptr = NULL;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> debug_buf_size = 0;
#<span class="enscript-reference">else</span>
<span class="enscript-type">char</span> debug_buf[DEBUG_BUF_SIZE];
__used <span class="enscript-type">char</span> *debug_buf_addr = debug_buf;
<span class="enscript-type">char</span> *debug_buf_ptr = debug_buf;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> debug_buf_size = <span class="enscript-keyword">sizeof</span>(debug_buf);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">char</span> model_name[64];
<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *kernel_uuid;
<span class="enscript-comment">/* uuid_string_t */</span> <span class="enscript-type">char</span> kernel_uuid_string[37];

<span class="enscript-type">static</span> spl_t <span class="enscript-function-name">panic_prologue</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *str);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">panic_epilogue</span>(spl_t s);

<span class="enscript-type">struct</span> pasc {
  <span class="enscript-type">unsigned</span> a: 7;
  <span class="enscript-type">unsigned</span> b: 7;
  <span class="enscript-type">unsigned</span> c: 7;
  <span class="enscript-type">unsigned</span> d: 7;
  <span class="enscript-type">unsigned</span> e: 7;
  <span class="enscript-type">unsigned</span> f: 7;
  <span class="enscript-type">unsigned</span> g: 7;
  <span class="enscript-type">unsigned</span> h: 7;
}  __attribute__((packed));

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> pasc pasc_t;

<span class="enscript-comment">/* Prevent CPP from breaking the definition below */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_NO_PANIC_STRINGS</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">Assert</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">__attribute__</span>((noinline))
<span class="enscript-function-name">Assert</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*file,
	<span class="enscript-type">int</span>		line,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*expression
      )
{
	<span class="enscript-type">int</span> saved_return_on_panic;

	<span class="enscript-keyword">if</span> (!mach_assert) {
		kprintf(<span class="enscript-string">&quot;%s:%d non-fatal Assertion: %s&quot;</span>, file, line, expression);
		<span class="enscript-keyword">return</span>;
	}

	saved_return_on_panic = return_on_panic;

	<span class="enscript-comment">/*
	 * If we don't have a debugger configured, returning from an
	 * assert is a bad, bad idea; there is no guarantee that we
	 * didn't simply assert before we were able to restart the
	 * platform.
	 */</span>
	<span class="enscript-keyword">if</span> (current_debugger != NO_CUR_DB)
		return_on_panic = 1;

	panic_plain(<span class="enscript-string">&quot;%s:%d Assertion failed: %s&quot;</span>, file, line, expression);

	return_on_panic = saved_return_on_panic;
}

<span class="enscript-comment">/*
 *	Carefully use the panic_lock.  There's always a chance that
 *	somehow we'll call panic before getting to initialize the
 *	panic_lock -- in this case, we'll assume that the world is
 *	in uniprocessor mode and just avoid using the panic lock.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PANIC_LOCK</span>()							\
MACRO_BEGIN								\
	<span class="enscript-keyword">if</span> (panic_is_inited)						\
		simple_lock(&amp;panic_lock);				\
MACRO_END

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PANIC_UNLOCK</span>()							\
MACRO_BEGIN								\
	<span class="enscript-keyword">if</span> (panic_is_inited)						\
		simple_unlock(&amp;panic_lock);				\
MACRO_END

<span class="enscript-type">void</span>
<span class="enscript-function-name">panic_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> uuidlen = 0;
	<span class="enscript-type">void</span> *uuid;

	uuid = getuuidfromheader(&amp;_mh_execute_header, &amp;uuidlen);
	<span class="enscript-keyword">if</span> ((uuid != NULL) &amp;&amp; (uuidlen == <span class="enscript-keyword">sizeof</span>(uuid_t))) {
		kernel_uuid = uuid;
		uuid_unparse_upper(*(uuid_t *)uuid, kernel_uuid_string);
	}

	simple_lock_init(&amp;panic_lock, 0);
	panic_is_inited = 1;
	panic_caller = 0;

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;assertions&quot;</span>, &amp;mach_assert, <span class="enscript-keyword">sizeof</span>(mach_assert))) {
		mach_assert = 1;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">debug_log_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (debug_buf_size != 0)
		<span class="enscript-keyword">return</span>;
#<span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__arm64__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NAND_PANIC_DEVICE</span>)) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">LEGACY_PANIC_LOGS</span>)
	<span class="enscript-keyword">if</span> (!gPanicBase) {
		printf(<span class="enscript-string">&quot;debug_log_init: Error!! gPanicBase is still not initialized\n&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/* Shift debug buf start location and size by 8 bytes for magic header and crc value */</span>
	debug_buf_addr = (<span class="enscript-type">char</span>*)gPanicBase + 8;
	debug_buf_ptr = debug_buf_addr;
	debug_buf_size = gPanicSize - 8;
#<span class="enscript-reference">else</span>
	debug_buf_addr = debug_buf;
	debug_buf_ptr = debug_buf;
	debug_buf_size = <span class="enscript-keyword">sizeof</span>(debug_buf);
#<span class="enscript-reference">endif</span>
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">panic_stop</span>()	pmCPUHalt(PM_HALT_PANIC)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">panic_safe</span>()	pmSafeMode(x86_lcpu(), PM_SAFE_FL_SAFE)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">panic_normal</span>()	pmSafeMode(x86_lcpu(), PM_SAFE_FL_NORMAL)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">panic_stop</span>()	{ while (1) ; }
#<span class="enscript-reference">define</span> <span class="enscript-function-name">panic_safe</span>()
#<span class="enscript-reference">define</span> <span class="enscript-function-name">panic_normal</span>()
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Prevent CPP from breaking the definition below,
 * since all clients get a #define to prepend line numbers
 */</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">panic</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">_consume_panic_args</span>(<span class="enscript-type">int</span> a __unused, ...)
{
    panic(<span class="enscript-string">&quot;panic&quot;</span>);
}

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> write_trace_on_panic;

<span class="enscript-type">static</span> spl_t
<span class="enscript-function-name">panic_prologue</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *str)
{
	spl_t	s;

	<span class="enscript-keyword">if</span> (write_trace_on_panic &amp;&amp; kdebug_enable) {
		<span class="enscript-keyword">if</span> (get_preemption_level() == 0 &amp;&amp; !ml_at_interrupt_context()) {
			ml_set_interrupts_enabled(TRUE);
			kdbg_dump_trace_to_file(<span class="enscript-string">&quot;/var/tmp/panic.trace&quot;</span>);
		}
	}

	s = splhigh();
	disable_preemption();

#<span class="enscript-reference">if</span>	<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
	<span class="enscript-comment">/* Attempt to display the unparsed panic string */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *tstr = str;

	kprintf(<span class="enscript-string">&quot;Panic initiated, string: &quot;</span>);
	<span class="enscript-keyword">while</span> (tstr &amp;&amp; *tstr)
		kprintf(<span class="enscript-string">&quot;%c&quot;</span>, *tstr++);
	kprintf(<span class="enscript-string">&quot;\n&quot;</span>);
#<span class="enscript-reference">endif</span>

	panic_safe();

	<span class="enscript-keyword">if</span>( logPanicDataToScreen )
		disable_debug_output = FALSE;
		
	debug_mode = TRUE;

<span class="enscript-reference">restart</span>:
	PANIC_LOCK();

	<span class="enscript-keyword">if</span> (panicstr) {
		<span class="enscript-keyword">if</span> (cpu_number() != paniccpu) {
			PANIC_UNLOCK();
			<span class="enscript-comment">/*
			 * Wait until message has been printed to identify correct
			 * cpu that made the first panic.
			 */</span>
			<span class="enscript-keyword">while</span> (panicwait)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	    } <span class="enscript-keyword">else</span> {
			nestedpanic +=1;
			PANIC_UNLOCK();
			Debugger(<span class="enscript-string">&quot;double panic&quot;</span>);
			printf(<span class="enscript-string">&quot;double panic:  We are hanging here...\n&quot;</span>);
			panic_stop();
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
	}
	panicstr = str;
	paniccpu = cpu_number();
	panicwait = 1;

	PANIC_UNLOCK();
	<span class="enscript-keyword">return</span>(s);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">panic_epilogue</span>(spl_t	s)
{
	<span class="enscript-comment">/*
	 * Release panicstr so that we can handle normally other panics.
	 */</span>
	PANIC_LOCK();
	panicstr = (<span class="enscript-type">char</span> *)0;
	PANIC_UNLOCK();

	<span class="enscript-keyword">if</span> (return_on_panic) {
		panic_normal();
		enable_preemption();
		splx(s);
		<span class="enscript-keyword">return</span>;
	}
	kdb_printf(<span class="enscript-string">&quot;panic: We are hanging here...\n&quot;</span>);
	panic_stop();
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">panic</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *str, ...)
{
	va_list	listp;
	spl_t	s;
	boolean_t	old_doprnt_hide_pointers = doprnt_hide_pointers;


	<span class="enscript-comment">/* panic_caller is initialized to 0.  If set, don't change it */</span>
	<span class="enscript-keyword">if</span> ( ! panic_caller )
		panic_caller = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(<span class="enscript-type">char</span> *)__builtin_return_address(0);
	
	s = panic_prologue(str);

	<span class="enscript-comment">/* Never hide pointers from panic logs. */</span>
	doprnt_hide_pointers = FALSE;

	kdb_printf(<span class="enscript-string">&quot;panic(cpu %d caller 0x%lx): &quot;</span>, (<span class="enscript-type">unsigned</span>) paniccpu, panic_caller);
	<span class="enscript-keyword">if</span> (str) {
		va_start(listp, str);
		_doprnt(str, &amp;listp, consdebug_putc, 0);
		va_end(listp);
	}
	kdb_printf(<span class="enscript-string">&quot;\n&quot;</span>);

	<span class="enscript-comment">/*
	 * Release panicwait indicator so that other cpus may call Debugger().
	 */</span>
	panicwait = 0;
	Debugger(<span class="enscript-string">&quot;panic&quot;</span>);

	doprnt_hide_pointers = old_doprnt_hide_pointers;

	panic_epilogue(s);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">panic_context</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> reason, <span class="enscript-type">void</span> *ctx, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *str, ...)
{
	va_list	listp;
	spl_t	s;


	<span class="enscript-comment">/* panic_caller is initialized to 0.  If set, don't change it */</span>
	<span class="enscript-keyword">if</span> ( ! panic_caller )
		panic_caller = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(<span class="enscript-type">char</span> *)__builtin_return_address(0);
	
	s = panic_prologue(str);
	kdb_printf(<span class="enscript-string">&quot;panic(cpu %d caller 0x%lx): &quot;</span>, (<span class="enscript-type">unsigned</span>) paniccpu, panic_caller);
	<span class="enscript-keyword">if</span> (str) {
		va_start(listp, str);
		_doprnt(str, &amp;listp, consdebug_putc, 0);
		va_end(listp);
	}
	kdb_printf(<span class="enscript-string">&quot;\n&quot;</span>);

	<span class="enscript-comment">/*
	 * Release panicwait indicator so that other cpus may call Debugger().
	 */</span>
	panicwait = 0;
	DebuggerWithContext(reason, ctx, <span class="enscript-string">&quot;panic&quot;</span>);
	panic_epilogue(s);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">log</span>(__unused <span class="enscript-type">int</span> level, <span class="enscript-type">char</span> *fmt, ...)
{
	va_list	listp;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">lint</span>
	level++;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* lint */</span>
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">MACH_BSD</span>
	disable_preemption();
	va_start(listp, fmt);
	_doprnt(fmt, &amp;listp, conslog_putc, 0);
	va_end(listp);
	enable_preemption();
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">debug_putc</span>(<span class="enscript-type">char</span> c)
{
	<span class="enscript-keyword">if</span> ((debug_buf_size != 0) &amp;&amp;
		((debug_buf_ptr-debug_buf_addr) &lt; (<span class="enscript-type">int</span>)debug_buf_size)) {
		*debug_buf_ptr=c;
		debug_buf_ptr++;
	}
}

<span class="enscript-comment">/* In-place packing routines -- inefficient, but they're called at most once.
 * Assumes &quot;buflen&quot; is a multiple of 8.
 */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">packA</span>(<span class="enscript-type">char</span> *inbuf, uint32_t length, uint32_t buflen)
{
  <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i, j = 0;
  pasc_t pack;
  
  length = MIN(((length + 7) &amp; ~7), buflen);

  <span class="enscript-keyword">for</span> (i = 0; i &lt; length; i+=8)
    {
      pack.a = inbuf[i];
      pack.b = inbuf[i+1];
      pack.c = inbuf[i+2];
      pack.d = inbuf[i+3];
      pack.e = inbuf[i+4];
      pack.f = inbuf[i+5];
      pack.g = inbuf[i+6];
      pack.h = inbuf[i+7];
      bcopy ((<span class="enscript-type">char</span> *) &amp;pack, inbuf + j, 7);
      j += 7;
    }
  <span class="enscript-keyword">return</span> j;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">unpackA</span>(<span class="enscript-type">char</span> *inbuf, uint32_t length)
{
	pasc_t packs;
	<span class="enscript-type">unsigned</span> i = 0;
	length = (length * 8)/7;

	<span class="enscript-keyword">while</span> (i &lt; length) {
	  packs = *(pasc_t *)&amp;inbuf[i];
	  bcopy(&amp;inbuf[i+7], &amp;inbuf[i+8], MAX(0, (<span class="enscript-type">int</span>) (length - i - 8)));
	  inbuf[i++] = packs.a;
	  inbuf[i++] = packs.b;
	  inbuf[i++] = packs.c;
	  inbuf[i++] = packs.d;
	  inbuf[i++] = packs.e;
	  inbuf[i++] = packs.f;
	  inbuf[i++] = packs.g;
	  inbuf[i++] = packs.h;
	}
}

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> *<span class="enscript-function-name">proc_name_address</span>(<span class="enscript-type">void</span> *p);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">panic_display_process_name</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-comment">/* because of scoping issues len(p_comm) from proc_t is hard coded here */</span>
	<span class="enscript-type">char</span> proc_name[17] = <span class="enscript-string">&quot;Unknown&quot;</span>;
	task_t ctask = 0;
	<span class="enscript-type">void</span> *cbsd_info = 0;

	<span class="enscript-keyword">if</span> (ml_nofault_copy((vm_offset_t)&amp;current_thread()-&gt;task, (vm_offset_t) &amp;ctask, <span class="enscript-keyword">sizeof</span>(task_t)) == <span class="enscript-keyword">sizeof</span>(task_t))
		<span class="enscript-keyword">if</span>(ml_nofault_copy((vm_offset_t)&amp;ctask-&gt;bsd_info, (vm_offset_t)&amp;cbsd_info, <span class="enscript-keyword">sizeof</span>(cbsd_info)) == <span class="enscript-keyword">sizeof</span>(cbsd_info))
			<span class="enscript-keyword">if</span> (cbsd_info &amp;&amp; (ml_nofault_copy((vm_offset_t) proc_name_address(cbsd_info), (vm_offset_t) &amp;proc_name, <span class="enscript-keyword">sizeof</span>(proc_name)) &gt; 0))
				proc_name[<span class="enscript-keyword">sizeof</span>(proc_name) - 1] = <span class="enscript-string">'\0'</span>;
	kdb_printf(<span class="enscript-string">&quot;\nBSD process name corresponding to current thread: %s\n&quot;</span>, proc_name);
}

<span class="enscript-type">unsigned</span>	panic_active(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">return</span> ((panicstr != (<span class="enscript-type">char</span> *) 0));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">populate_model_name</span>(<span class="enscript-type">char</span> *model_string) {
	strlcpy(model_name, model_string, <span class="enscript-keyword">sizeof</span>(model_name));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">panic_display_model_name</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-type">char</span> tmp_model_name[<span class="enscript-keyword">sizeof</span>(model_name)];

	<span class="enscript-keyword">if</span> (ml_nofault_copy((vm_offset_t) &amp;model_name, (vm_offset_t) &amp;tmp_model_name, <span class="enscript-keyword">sizeof</span>(model_name)) != <span class="enscript-keyword">sizeof</span>(model_name))
		<span class="enscript-keyword">return</span>;

	tmp_model_name[<span class="enscript-keyword">sizeof</span>(tmp_model_name) - 1] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-keyword">if</span> (tmp_model_name[0] != 0)
		kdb_printf(<span class="enscript-string">&quot;System model name: %s\n&quot;</span>, tmp_model_name);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">panic_display_kernel_uuid</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-type">char</span> tmp_kernel_uuid[<span class="enscript-keyword">sizeof</span>(kernel_uuid_string)];

	<span class="enscript-keyword">if</span> (ml_nofault_copy((vm_offset_t) &amp;kernel_uuid_string, (vm_offset_t) &amp;tmp_kernel_uuid, <span class="enscript-keyword">sizeof</span>(kernel_uuid_string)) != <span class="enscript-keyword">sizeof</span>(kernel_uuid_string))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (tmp_kernel_uuid[0] != <span class="enscript-string">'\0'</span>)
		kdb_printf(<span class="enscript-string">&quot;Kernel UUID: %s\n&quot;</span>, tmp_kernel_uuid);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">panic_display_kernel_aslr</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">if</span> (vm_kernel_slide) {
		kdb_printf(<span class="enscript-string">&quot;Kernel slide:     0x%016lx\n&quot;</span>, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) vm_kernel_slide);
		kdb_printf(<span class="enscript-string">&quot;Kernel text base: %p\n&quot;</span>, (<span class="enscript-type">void</span> *) vm_kernel_stext);
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">panic_display_hibb</span>(<span class="enscript-type">void</span>) {
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
	kdb_printf(<span class="enscript-string">&quot;__HIB  text base: %p\n&quot;</span>, (<span class="enscript-type">void</span> *) vm_hib_base);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">panic_display_uptime</span>(<span class="enscript-type">void</span>) {
	uint64_t	uptime;
	absolutetime_to_nanoseconds(mach_absolute_time(), &amp;uptime);

	kdb_printf(<span class="enscript-string">&quot;\nSystem uptime in nanoseconds: %llu\n&quot;</span>, uptime);
}

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> version[];
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> osversion[];

<span class="enscript-type">static</span> <span class="enscript-type">volatile</span> uint32_t config_displayed = 0;

__private_extern__ <span class="enscript-type">void</span> panic_display_system_configuration(<span class="enscript-type">void</span>) {

	panic_display_process_name();
	<span class="enscript-keyword">if</span> (OSCompareAndSwap(0, 1, &amp;config_displayed)) {
		<span class="enscript-type">char</span> buf[256];
		<span class="enscript-keyword">if</span> (strlcpy(buf, PE_boot_args(), <span class="enscript-keyword">sizeof</span>(buf)))
			kdb_printf(<span class="enscript-string">&quot;Boot args: %s\n&quot;</span>, buf);
		kdb_printf(<span class="enscript-string">&quot;\nMac OS version:\n%s\n&quot;</span>,
		    (osversion[0] != 0) ? osversion : <span class="enscript-string">&quot;Not yet set&quot;</span>);
		kdb_printf(<span class="enscript-string">&quot;\nKernel version:\n%s\n&quot;</span>,version);
		panic_display_kernel_uuid();
		panic_display_kernel_aslr();
		panic_display_hibb();
		panic_display_pal_info();
		panic_display_model_name();
		panic_display_uptime();
		panic_display_zprint();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
		panic_display_ztrace();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>
		kext_dump_panic_lists(&amp;kdb_log);
	}
}

<span class="enscript-type">extern</span> zone_t		first_zone;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	num_zones, stack_total;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> stack_allocs;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	inuse_ptepages_count;
<span class="enscript-type">extern</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> alloc_ptepages_count;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> boolean_t	panic_include_zprint;
<span class="enscript-type">extern</span> vm_offset_t 	panic_kext_memory_info;
<span class="enscript-type">extern</span> vm_size_t 	panic_kext_memory_size;

__private_extern__ <span class="enscript-type">void</span> panic_display_zprint()
{
	<span class="enscript-keyword">if</span>(panic_include_zprint == TRUE) {

		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	i;
		<span class="enscript-type">struct</span> zone	zone_copy;

		kdb_printf(<span class="enscript-string">&quot;%-20s %10s %10s\n&quot;</span>, <span class="enscript-string">&quot;Zone Name&quot;</span>, <span class="enscript-string">&quot;Cur Size&quot;</span>, <span class="enscript-string">&quot;Free Size&quot;</span>);
		<span class="enscript-keyword">if</span>(first_zone!=NULL) {
			<span class="enscript-keyword">if</span>(ml_nofault_copy((vm_offset_t)first_zone, (vm_offset_t)&amp;zone_copy, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zone)) == <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zone)) {
				<span class="enscript-keyword">for</span> (i = 0; i &lt; num_zones; i++) {
					<span class="enscript-keyword">if</span>(zone_copy.cur_size &gt; (1024*1024)) {
						kdb_printf(<span class="enscript-string">&quot;%-20s %10lu %10lu\n&quot;</span>,zone_copy.zone_name, (uintptr_t)zone_copy.cur_size,(uintptr_t)(zone_copy.countfree * zone_copy.elem_size));
					}	
					
					<span class="enscript-keyword">if</span>(zone_copy.next_zone == NULL) {
						<span class="enscript-keyword">break</span>;
					}

					<span class="enscript-keyword">if</span>(ml_nofault_copy((vm_offset_t)zone_copy.next_zone, (vm_offset_t)&amp;zone_copy, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zone)) != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> zone)) {
						<span class="enscript-keyword">break</span>;
					}
				}
			}
		}

		kdb_printf(<span class="enscript-string">&quot;%-20s %10lu\n&quot;</span>, <span class="enscript-string">&quot;Kernel Stacks&quot;</span>, (uintptr_t)(kernel_stack_size * stack_total));

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
		kdb_printf(<span class="enscript-string">&quot;%-20s %10lu\n&quot;</span>, <span class="enscript-string">&quot;PageTables&quot;</span>,(uintptr_t)(PAGE_SIZE * inuse_ptepages_count));
#<span class="enscript-reference">endif</span>

		kdb_printf(<span class="enscript-string">&quot;%-20s %10lu\n&quot;</span>, <span class="enscript-string">&quot;Kalloc.Large&quot;</span>, (uintptr_t)kalloc_large_total);
		<span class="enscript-keyword">if</span> (panic_kext_memory_info) {
			mach_memory_info_t *mem_info = (mach_memory_info_t *)panic_kext_memory_info;
			kdb_printf(<span class="enscript-string">&quot;\n%-5s %10s\n&quot;</span>, <span class="enscript-string">&quot;Kmod&quot;</span>, <span class="enscript-string">&quot;Size&quot;</span>);
			<span class="enscript-keyword">for</span> (i = 0; i &lt; VM_KERN_MEMORY_COUNT + VM_KERN_COUNTER_COUNT; i++) {
				<span class="enscript-keyword">if</span> (((mem_info[i].flags &amp; VM_KERN_SITE_TYPE) == VM_KERN_SITE_KMOD) &amp;&amp; (mem_info[i].size &gt; (1024 * 1024))) {
					kdb_printf(<span class="enscript-string">&quot;%-5lld %10lld\n&quot;</span>, mem_info[i].site, mem_info[i].size);
				}
			}
		}
	}
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ECC_LOGGING</span>
__private_extern__ <span class="enscript-type">void</span> panic_display_ecc_errors() 
{
	uint32_t count = ecc_log_get_correction_count();

	<span class="enscript-keyword">if</span> (count &gt; 0) {
		kdb_printf(<span class="enscript-string">&quot;ECC Corrections:%u\n&quot;</span>, count);
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ECC_LOGGING */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ZLEAKS</span>
<span class="enscript-type">extern</span> boolean_t	panic_include_ztrace;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ztrace* top_ztrace;
<span class="enscript-type">void</span> <span class="enscript-function-name">panic_print_symbol_name</span>(vm_address_t search);

<span class="enscript-comment">/*
 * Prints the backtrace most suspected of being a leaker, if we paniced in the zone allocator.
 * top_ztrace and panic_include_ztrace comes from osfmk/kern/zalloc.c
 */</span>
__private_extern__ <span class="enscript-type">void</span> panic_display_ztrace(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span>(panic_include_ztrace == TRUE) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i = 0;
 		boolean_t keepsyms = FALSE;

		PE_parse_boot_argn(<span class="enscript-string">&quot;keepsyms&quot;</span>, &amp;keepsyms, <span class="enscript-keyword">sizeof</span> (keepsyms));
		<span class="enscript-type">struct</span> ztrace top_ztrace_copy;
		
		<span class="enscript-comment">/* Make sure not to trip another panic if there's something wrong with memory */</span>
		<span class="enscript-keyword">if</span>(ml_nofault_copy((vm_offset_t)top_ztrace, (vm_offset_t)&amp;top_ztrace_copy, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ztrace)) == <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ztrace)) {
			kdb_printf(<span class="enscript-string">&quot;\nBacktrace suspected of leaking: (outstanding bytes: %lu)\n&quot;</span>, (uintptr_t)top_ztrace_copy.zt_size);
			<span class="enscript-comment">/* Print the backtrace addresses */</span>
			<span class="enscript-keyword">for</span> (i = 0; (i &lt; top_ztrace_copy.zt_depth &amp;&amp; i &lt; MAX_ZTRACE_DEPTH) ; i++) {
				kdb_printf(<span class="enscript-string">&quot;%p &quot;</span>, top_ztrace_copy.zt_stack[i]);
				<span class="enscript-keyword">if</span> (keepsyms) {
					panic_print_symbol_name((vm_address_t)top_ztrace_copy.zt_stack[i]);
				}
				kdb_printf(<span class="enscript-string">&quot;\n&quot;</span>);
			}
			<span class="enscript-comment">/* Print any kexts in that backtrace, along with their link addresses so we can properly blame them */</span>
			kmod_panic_dump((vm_offset_t *)&amp;top_ztrace_copy.zt_stack[0], top_ztrace_copy.zt_depth);
		}
		<span class="enscript-keyword">else</span> {
			kdb_printf(<span class="enscript-string">&quot;\nCan't access top_ztrace...\n&quot;</span>);
		}
		kdb_printf(<span class="enscript-string">&quot;\n&quot;</span>);
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_ZLEAKS */</span>

#<span class="enscript-reference">if</span> ! (<span class="enscript-variable-name">MACH_KDP</span> &amp;&amp; <span class="enscript-variable-name">CONFIG_KDP_INTERACTIVE_DEBUGGING</span>)
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kdp_ether_addr kdp_current_mac_address = {{0, 0, 0, 0, 0, 0}};

<span class="enscript-comment">/* XXX ugly forward declares to stop warnings */</span>
<span class="enscript-type">void</span> *<span class="enscript-function-name">kdp_get_interface</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">kdp_set_ip_and_mac_addresses</span>(<span class="enscript-type">struct</span> kdp_in_addr *, <span class="enscript-type">struct</span> kdp_ether_addr *);
<span class="enscript-type">void</span> <span class="enscript-function-name">kdp_set_gateway_mac</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">void</span> <span class="enscript-function-name">kdp_set_interface</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">void</span> <span class="enscript-function-name">kdp_register_send_receive</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">void</span> <span class="enscript-function-name">kdp_unregister_send_receive</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">void</span> <span class="enscript-function-name">kdp_snapshot_preflight</span>(<span class="enscript-type">int</span>, <span class="enscript-type">void</span> *, uint32_t, uint32_t, kcdata_descriptor_t, boolean_t enable_faulting);
<span class="enscript-type">int</span> <span class="enscript-function-name">kdp_stack_snapshot_geterror</span>(<span class="enscript-type">void</span>);
uint32_t <span class="enscript-function-name">kdp_stack_snapshot_bytes_traced</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span> *
<span class="enscript-function-name">kdp_get_interface</span>( <span class="enscript-type">void</span>)
{
        <span class="enscript-keyword">return</span>(<span class="enscript-type">void</span> *)0;
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kdp_get_ip_address</span>(<span class="enscript-type">void</span> )
{ <span class="enscript-keyword">return</span> 0; }

<span class="enscript-type">struct</span> kdp_ether_addr
<span class="enscript-function-name">kdp_get_mac_addr</span>(<span class="enscript-type">void</span>)
{       
        <span class="enscript-keyword">return</span> kdp_current_mac_address;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_set_ip_and_mac_addresses</span>(   
        __unused <span class="enscript-type">struct</span> kdp_in_addr          *ipaddr,
        __unused <span class="enscript-type">struct</span> kdp_ether_addr       *macaddr)
{}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_set_gateway_mac</span>(__unused <span class="enscript-type">void</span> *gatewaymac)
{}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_set_interface</span>(__unused <span class="enscript-type">void</span> *ifp)
{}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_register_send_receive</span>(__unused <span class="enscript-type">void</span> *send, __unused <span class="enscript-type">void</span> *receive)
{}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kdp_unregister_send_receive</span>(__unused <span class="enscript-type">void</span> *send, __unused <span class="enscript-type">void</span> *receive)
{}

<span class="enscript-type">void</span> <span class="enscript-function-name">kdp_register_link</span>(__unused kdp_link_t link, __unused kdp_mode_t mode)
{}

<span class="enscript-type">void</span> <span class="enscript-function-name">kdp_unregister_link</span>(__unused kdp_link_t link, __unused kdp_mode_t mode)
{}

#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_TELEMETRY</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">telemetry_gather</span>(user_addr_t buffer __unused, uint32_t *length __unused, boolean_t mark __unused)
{
	<span class="enscript-keyword">return</span> KERN_NOT_SUPPORTED;
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>