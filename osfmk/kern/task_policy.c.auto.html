<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>task_policy.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">task_policy.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task_server.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resource.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/limits.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ledger.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sfi.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/coalition.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TELEMETRY</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/telemetry.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_importance.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_DEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine/sdt.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_DEBUG */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITACE */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

<span class="enscript-comment">/*
 *  Task Policy
 *
 *  This subsystem manages task and thread IO priority and backgrounding,
 *  as well as importance inheritance, process suppression, task QoS, and apptype.
 *  These properties have a suprising number of complex interactions, so they are
 *  centralized here in one state machine to simplify the implementation of those interactions.
 *
 *  Architecture:
 *  Threads and tasks have three policy fields: requested, effective, and pending.
 *  Requested represents the wishes of each interface that influences task policy.
 *  Effective represents the distillation of that policy into a set of behaviors.
 *  Pending represents updates that haven't been applied yet.
 *
 *  Each interface that has an input into the task policy state machine controls a field in requested.
 *  If the interface has a getter, it returns what is in the field in requested, but that is
 *  not necessarily what is actually in effect.
 *
 *  All kernel subsystems that behave differently based on task policy call into
 *  the get_effective_policy function, which returns the decision of the task policy state machine
 *  for that subsystem by querying only the 'effective' field.
 *
 *  Policy change operations:
 *  Here are the steps to change a policy on a task or thread:
 *  1) Lock task
 *  2) Change requested field for the relevant policy
 *  3) Run a task policy update, which recalculates effective based on requested,
 *     then takes a diff between the old and new versions of requested and calls the relevant
 *     other subsystems to apply these changes, and updates the pending field.
 *  4) Unlock task
 *  5) Run task policy update complete, which looks at the pending field to update
 *     subsystems which cannot be touched while holding the task lock.
 *
 *  To add a new requested policy, add the field in the requested struct, the flavor in task.h,
 *  the setter and getter in proc_(set|get)_task_policy*, and dump the state in task_requested_bitfield,
 *  then set up the effects of that behavior in task_policy_update*. If the policy manifests
 *  itself as a distinct effective policy, add it to the effective struct and add it to the
 *  proc_get_effective_policy accessor.
 *
 *  Most policies are set via proc_set_task_policy, but policies that don't fit that interface
 *  roll their own lock/set/update/unlock/complete code inside this file.
 *
 *
 *  Suppression policy
 *
 *  These are a set of behaviors that can be requested for a task.  They currently have specific
 *  implied actions when they're enabled, but they may be made customizable in the future.
 *
 *  When the affected task is boosted, we temporarily disable the suppression behaviors
 *  so that the affected process has a chance to run so it can call the API to permanently
 *  disable the suppression behaviors.
 *
 *  Locking
 *
 *  Changing task policy on a task or thread takes the task lock, and not the thread lock.
 *  TODO: Should changing policy on a thread take the thread lock instead?
 *
 *  Querying the effective policy does not take the task lock, to prevent deadlocks or slowdown in sensitive code.
 *  This means that any notification of state change needs to be externally synchronized.
 *
 */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> qos_policy_params_t thread_qos_policy_params;

<span class="enscript-comment">/* for task holds without dropping the lock */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">task_hold_locked</span>(task_t task);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">task_release_locked</span>(task_t task);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">task_wait_locked</span>(task_t task, boolean_t until_not_runnable);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">thread_recompute_qos</span>(thread_t thread);

<span class="enscript-comment">/* Task policy related helper functions */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_set_task_policy_locked</span>(task_t task, thread_t thread, <span class="enscript-type">int</span> category, <span class="enscript-type">int</span> flavor, <span class="enscript-type">int</span> value);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_set_task_policy2_locked</span>(task_t task, thread_t thread, <span class="enscript-type">int</span> category, <span class="enscript-type">int</span> flavor, <span class="enscript-type">int</span> value1, <span class="enscript-type">int</span> value2);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">task_policy_update_locked</span>(task_t task, thread_t thread, task_pend_token_t pend_token);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">task_policy_update_internal_locked</span>(task_t task, thread_t thread, boolean_t in_create, task_pend_token_t pend_token);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">task_policy_update_task_locked</span>(task_t task, boolean_t update_throttle, boolean_t update_bg_throttle, boolean_t update_sfi);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">task_policy_update_thread_locked</span>(thread_t thread, <span class="enscript-type">int</span> update_cpu, boolean_t update_throttle, boolean_t update_sfi, boolean_t update_qos);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SCHED_SFI</span>
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">task_policy_update_coalition_focal_tasks</span>(task_t task, <span class="enscript-type">int</span> prev_role, <span class="enscript-type">int</span> next_role);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_get_effective_policy</span>(task_t task, thread_t thread, <span class="enscript-type">int</span> policy);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_iopol_to_tier</span>(<span class="enscript-type">int</span> iopolicy, <span class="enscript-type">int</span> *tier, <span class="enscript-type">int</span> *passive);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_tier_to_iopol</span>(<span class="enscript-type">int</span> tier, <span class="enscript-type">int</span> passive);

<span class="enscript-type">static</span> uintptr_t <span class="enscript-function-name">trequested_0</span>(task_t task, thread_t thread);
<span class="enscript-type">static</span> uintptr_t <span class="enscript-function-name">trequested_1</span>(task_t task, thread_t thread);
<span class="enscript-type">static</span> uintptr_t <span class="enscript-function-name">teffective_0</span>(task_t task, thread_t thread);
<span class="enscript-type">static</span> uintptr_t <span class="enscript-function-name">teffective_1</span>(task_t task, thread_t thread);
<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">tpending</span>(task_pend_token_t pend_token);
<span class="enscript-type">static</span> uint64_t <span class="enscript-function-name">task_requested_bitfield</span>(task_t task, thread_t thread);
<span class="enscript-type">static</span> uint64_t <span class="enscript-function-name">task_effective_bitfield</span>(task_t task, thread_t thread);

<span class="enscript-type">void</span> <span class="enscript-function-name">proc_get_thread_policy</span>(thread_t thread, thread_policy_state_t info);

<span class="enscript-comment">/* CPU Limits related helper functions */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">task_get_cpuusage</span>(task_t task, uint8_t *percentagep, uint64_t *intervalp, uint64_t *deadlinep, <span class="enscript-type">int</span> *scope);
<span class="enscript-type">int</span> <span class="enscript-function-name">task_set_cpuusage</span>(task_t task, uint8_t percentage, uint64_t interval, uint64_t deadline, <span class="enscript-type">int</span> scope, <span class="enscript-type">int</span> entitled);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">task_clear_cpuusage_locked</span>(task_t task, <span class="enscript-type">int</span> cpumon_entitled);
<span class="enscript-type">int</span> <span class="enscript-function-name">task_disable_cpumon</span>(task_t task);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">task_apply_resource_actions</span>(task_t task, <span class="enscript-type">int</span> type);
<span class="enscript-type">void</span> <span class="enscript-function-name">task_action_cpuusage</span>(thread_call_param_t param0, thread_call_param_t param1);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_init_cpumon_params</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
<span class="enscript-type">int</span>             <span class="enscript-function-name">proc_pid</span>(<span class="enscript-type">void</span> *proc);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>      <span class="enscript-function-name">proc_selfpid</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> *   <span class="enscript-function-name">proc_name_address</span>(<span class="enscript-type">void</span> *p);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">rethrottle_thread</span>(<span class="enscript-type">void</span> * uthread);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">proc_apply_task_networkbg</span>(<span class="enscript-type">void</span> * bsd_info, thread_t thread);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_BSD */</span>

<span class="enscript-type">extern</span> zone_t thread_qos_override_zone;
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">_proc_thread_qos_remove_override_internal</span>(task_t task, thread_t thread, uint64_t tid, user_addr_t resource, <span class="enscript-type">int</span> resource_type, boolean_t reset);


<span class="enscript-comment">/* Importance Inheritance related helper functions */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">task_add_importance_watchport</span>(task_t task, mach_port_t port, <span class="enscript-type">int</span> *boostp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">task_importance_update_live_donor</span>(task_t target_task);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__impdebug_only</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__impdebug_only</span> __unused
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__imp_only</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__imp_only</span> __unused
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_LOCKED</span>   1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_UNLOCKED</span> 0

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DO_LOWPRI_CPU</span>   1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UNDO_LOWPRI_CPU</span> 2

<span class="enscript-comment">/* Macros for making tracing simpler */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">tpriority</span>(task, thread)  ((uintptr_t)(thread == THREAD_NULL ? (task-&gt;priority)  : (thread-&gt;base_pri)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">tisthread</span>(thread) (thread == THREAD_NULL ? TASK_POLICY_TASK  : TASK_POLICY_THREAD)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">targetid</span>(task, thread)   ((uintptr_t)(thread == THREAD_NULL ? (task_pid(task)) : (thread-&gt;thread_id)))

<span class="enscript-comment">/*
 * Default parameters for certain policies
 */</span>

<span class="enscript-type">int</span> proc_standard_daemon_tier = THROTTLE_LEVEL_TIER1;
<span class="enscript-type">int</span> proc_suppressed_disk_tier = THROTTLE_LEVEL_TIER1;
<span class="enscript-type">int</span> proc_tal_disk_tier        = THROTTLE_LEVEL_TIER1;

<span class="enscript-type">int</span> proc_graphics_timer_qos   = (LATENCY_QOS_TIER_0 &amp; 0xFF);

<span class="enscript-type">const</span> <span class="enscript-type">int</span> proc_default_bg_iotier  = THROTTLE_LEVEL_TIER2;

<span class="enscript-comment">/* Latency/throughput QoS fields remain zeroed, i.e. TIER_UNSPECIFIED at creation */</span>
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> task_requested_policy default_task_requested_policy = {
	.bg_iotier = proc_default_bg_iotier
};
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> task_effective_policy default_task_effective_policy = {};
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> task_pended_policy default_task_pended_policy = {};

<span class="enscript-comment">/*
 * Default parameters for CPU usage monitor.
 *
 * Default setting is 50% over 3 minutes.
 */</span>
#<span class="enscript-reference">define</span>         <span class="enscript-variable-name">DEFAULT_CPUMON_PERCENTAGE</span> 50
#<span class="enscript-reference">define</span>         <span class="enscript-variable-name">DEFAULT_CPUMON_INTERVAL</span>   (3 * 60)

uint8_t         proc_max_cpumon_percentage;
uint64_t	proc_max_cpumon_interval;

kern_return_t
<span class="enscript-function-name">qos_latency_policy_validate</span>(task_latency_qos_t ltier) {
	<span class="enscript-keyword">if</span> ((ltier != LATENCY_QOS_TIER_UNSPECIFIED) &amp;&amp;
	    ((ltier &gt; LATENCY_QOS_TIER_5) || (ltier &lt; LATENCY_QOS_TIER_0)))
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">qos_throughput_policy_validate</span>(task_throughput_qos_t ttier) {
	<span class="enscript-keyword">if</span> ((ttier != THROUGHPUT_QOS_TIER_UNSPECIFIED) &amp;&amp;
	    ((ttier &gt; THROUGHPUT_QOS_TIER_5) || (ttier &lt; THROUGHPUT_QOS_TIER_0)))
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">task_qos_policy_validate</span>(task_qos_policy_t qosinfo, mach_msg_type_number_t count) {
	<span class="enscript-keyword">if</span> (count &lt; TASK_QOS_POLICY_COUNT)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	task_latency_qos_t ltier = qosinfo-&gt;task_latency_qos_tier;
	task_throughput_qos_t ttier = qosinfo-&gt;task_throughput_qos_tier;

	kern_return_t kr = qos_latency_policy_validate(ltier);

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	kr = qos_throughput_policy_validate(ttier);

	<span class="enscript-keyword">return</span> kr;
}

uint32_t
<span class="enscript-function-name">qos_extract</span>(uint32_t qv) {
	<span class="enscript-keyword">return</span> (qv &amp; 0xFF);
}

uint32_t
<span class="enscript-function-name">qos_latency_policy_package</span>(uint32_t qv) {
	<span class="enscript-keyword">return</span> (qv == LATENCY_QOS_TIER_UNSPECIFIED) ? LATENCY_QOS_TIER_UNSPECIFIED : ((0xFF &lt;&lt; 16) | qv);
}

uint32_t
<span class="enscript-function-name">qos_throughput_policy_package</span>(uint32_t qv) {
	<span class="enscript-keyword">return</span> (qv == THROUGHPUT_QOS_TIER_UNSPECIFIED) ? THROUGHPUT_QOS_TIER_UNSPECIFIED : ((0xFE &lt;&lt; 16) | qv);
}

<span class="enscript-comment">/* TEMPORARY boot-arg controlling task_policy suppression (App Nap) */</span>
<span class="enscript-type">static</span> boolean_t task_policy_suppression_disable = FALSE;

kern_return_t
<span class="enscript-function-name">task_policy_set</span>(
	task_t					task,
	task_policy_flavor_t	flavor,
	task_policy_t			policy_info,
	mach_msg_type_number_t	count)
{
	kern_return_t		result = KERN_SUCCESS;

	<span class="enscript-keyword">if</span> (task == TASK_NULL || task == kernel_task)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">switch</span> (flavor) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_CATEGORY_POLICY</span>: {
		task_category_policy_t info = (task_category_policy_t)policy_info;

		<span class="enscript-keyword">if</span> (count &lt; TASK_CATEGORY_POLICY_COUNT)
			<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);


		<span class="enscript-keyword">switch</span>(info-&gt;role) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_FOREGROUND_APPLICATION</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BACKGROUND_APPLICATION</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_DEFAULT_APPLICATION</span>:
				proc_set_task_policy(task, THREAD_NULL,
				                     TASK_POLICY_ATTRIBUTE, TASK_POLICY_ROLE,
				                     info-&gt;role);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_CONTROL_APPLICATION</span>:
				<span class="enscript-keyword">if</span> (task != current_task() || task-&gt;sec_token.val[0] != 0)
					result = KERN_INVALID_ARGUMENT;
				<span class="enscript-keyword">else</span>
					proc_set_task_policy(task, THREAD_NULL,
					                     TASK_POLICY_ATTRIBUTE, TASK_POLICY_ROLE,
					                     info-&gt;role);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_GRAPHICS_SERVER</span>:
				<span class="enscript-comment">/* TODO: Restrict this role to FCFS &lt;rdar://problem/12552788&gt; */</span>
				<span class="enscript-keyword">if</span> (task != current_task() || task-&gt;sec_token.val[0] != 0)
					result = KERN_INVALID_ARGUMENT;
				<span class="enscript-keyword">else</span>
					proc_set_task_policy(task, THREAD_NULL,
					                     TASK_POLICY_ATTRIBUTE, TASK_POLICY_ROLE,
					                     info-&gt;role);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				result = KERN_INVALID_ARGUMENT;
				<span class="enscript-keyword">break</span>;
		} <span class="enscript-comment">/* switch (info-&gt;role) */</span>

		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-comment">/* Desired energy-efficiency/performance &quot;quality-of-service&quot; */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BASE_QOS_POLICY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_OVERRIDE_QOS_POLICY</span>:
	{
		task_qos_policy_t qosinfo = (task_qos_policy_t)policy_info;
		kern_return_t kr = task_qos_policy_validate(qosinfo, count);

		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;


		uint32_t lqos = qos_extract(qosinfo-&gt;task_latency_qos_tier);
		uint32_t tqos = qos_extract(qosinfo-&gt;task_throughput_qos_tier);

		proc_set_task_policy2(task, THREAD_NULL, TASK_POLICY_ATTRIBUTE,
							  flavor == TASK_BASE_QOS_POLICY ? TASK_POLICY_BASE_LATENCY_AND_THROUGHPUT_QOS : TASK_POLICY_OVERRIDE_LATENCY_AND_THROUGHPUT_QOS,
							  lqos, tqos);
	}
	<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BASE_LATENCY_QOS_POLICY</span>:
	{
		task_qos_policy_t qosinfo = (task_qos_policy_t)policy_info;
		kern_return_t kr = task_qos_policy_validate(qosinfo, count);

		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;

		uint32_t lqos = qos_extract(qosinfo-&gt;task_latency_qos_tier);

		proc_set_task_policy(task, NULL, TASK_POLICY_ATTRIBUTE, TASK_BASE_LATENCY_QOS_POLICY, lqos);
	}
	<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BASE_THROUGHPUT_QOS_POLICY</span>:
	{
		task_qos_policy_t qosinfo = (task_qos_policy_t)policy_info;
		kern_return_t kr = task_qos_policy_validate(qosinfo, count);

		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;

		uint32_t tqos = qos_extract(qosinfo-&gt;task_throughput_qos_tier);

		proc_set_task_policy(task, NULL, TASK_POLICY_ATTRIBUTE, TASK_BASE_THROUGHPUT_QOS_POLICY, tqos);
	}
	<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_SUPPRESSION_POLICY</span>:
	{

		task_suppression_policy_t info = (task_suppression_policy_t)policy_info;

		<span class="enscript-keyword">if</span> (count &lt; TASK_SUPPRESSION_POLICY_COUNT)
			<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

		<span class="enscript-type">struct</span> task_qos_policy qosinfo;

		qosinfo.task_latency_qos_tier = info-&gt;timer_throttle;
		qosinfo.task_throughput_qos_tier = info-&gt;throughput_qos;

		kern_return_t kr = task_qos_policy_validate(&amp;qosinfo, TASK_QOS_POLICY_COUNT);

		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			<span class="enscript-keyword">return</span> kr;

		<span class="enscript-comment">/* TEMPORARY disablement of task suppression */</span>
		<span class="enscript-keyword">if</span> (task_policy_suppression_disable &amp;&amp; info-&gt;active)
			<span class="enscript-keyword">return</span> KERN_SUCCESS;

		<span class="enscript-type">struct</span> task_pend_token pend_token = {};

		task_lock(task);

		KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
		                          (IMPORTANCE_CODE(IMP_TASK_SUPPRESSION, info-&gt;active)) | DBG_FUNC_START,
		                          proc_selfpid(), task_pid(task), trequested_0(task, THREAD_NULL),
		                          trequested_1(task, THREAD_NULL), 0);

		task-&gt;requested_policy.t_sup_active      = (info-&gt;active)         ? 1 : 0;
		task-&gt;requested_policy.t_sup_lowpri_cpu  = (info-&gt;lowpri_cpu)     ? 1 : 0;
		task-&gt;requested_policy.t_sup_timer       = qos_extract(info-&gt;timer_throttle);
		task-&gt;requested_policy.t_sup_disk        = (info-&gt;disk_throttle)  ? 1 : 0;
		task-&gt;requested_policy.t_sup_cpu_limit   = (info-&gt;cpu_limit)      ? 1 : 0;
		task-&gt;requested_policy.t_sup_suspend     = (info-&gt;suspend)        ? 1 : 0;
		task-&gt;requested_policy.t_sup_throughput  = qos_extract(info-&gt;throughput_qos);
		task-&gt;requested_policy.t_sup_cpu         = (info-&gt;suppressed_cpu) ? 1 : 0;
		task-&gt;requested_policy.t_sup_bg_sockets  = (info-&gt;background_sockets) ? 1 : 0;

		task_policy_update_locked(task, THREAD_NULL, &amp;pend_token);

		task_unlock(task);

		task_policy_update_complete_unlocked(task, THREAD_NULL, &amp;pend_token);

		KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
		                          (IMPORTANCE_CODE(IMP_TASK_SUPPRESSION, info-&gt;active)) | DBG_FUNC_END,
		                          proc_selfpid(), task_pid(task), trequested_0(task, THREAD_NULL),
		                          trequested_1(task, THREAD_NULL), 0);

		<span class="enscript-keyword">break</span>;

	}

	<span class="enscript-reference">default</span>:
		result = KERN_INVALID_ARGUMENT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/* Sets BSD 'nice' value on the task */</span>
kern_return_t
<span class="enscript-function-name">task_importance</span>(
	task_t				task,
	integer_t			importance)
{
	<span class="enscript-keyword">if</span> (task == TASK_NULL || task == kernel_task)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	task_lock(task);

	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		task_unlock(task);

		<span class="enscript-keyword">return</span> (KERN_TERMINATED);
	}

	<span class="enscript-keyword">if</span> (proc_get_effective_task_policy(task, TASK_POLICY_ROLE) &gt;= TASK_CONTROL_APPLICATION) {
		task_unlock(task);

		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
	}

	task-&gt;importance = importance;

	<span class="enscript-comment">/* TODO: tracepoint? */</span>

	<span class="enscript-comment">/* Redrive only the task priority calculation */</span>
	task_policy_update_task_locked(task, FALSE, FALSE, FALSE);

	task_unlock(task);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

kern_return_t
<span class="enscript-function-name">task_policy_get</span>(
	task_t					task,
	task_policy_flavor_t	flavor,
	task_policy_t			policy_info,
	mach_msg_type_number_t	*count,
	boolean_t				*get_default)
{
	<span class="enscript-keyword">if</span> (task == TASK_NULL || task == kernel_task)
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

	<span class="enscript-keyword">switch</span> (flavor) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_CATEGORY_POLICY</span>:
	{
		task_category_policy_t		info = (task_category_policy_t)policy_info;

		<span class="enscript-keyword">if</span> (*count &lt; TASK_CATEGORY_POLICY_COUNT)
			<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

		<span class="enscript-keyword">if</span> (*get_default)
			info-&gt;role = TASK_UNSPECIFIED;
		<span class="enscript-keyword">else</span>
			info-&gt;role = proc_get_task_policy(task, THREAD_NULL, TASK_POLICY_ATTRIBUTE, TASK_POLICY_ROLE);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BASE_QOS_POLICY</span>: <span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_OVERRIDE_QOS_POLICY</span>:
	{
		task_qos_policy_t info = (task_qos_policy_t)policy_info;

		<span class="enscript-keyword">if</span> (*count &lt; TASK_QOS_POLICY_COUNT)
			<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

		<span class="enscript-keyword">if</span> (*get_default) {
			info-&gt;task_latency_qos_tier = LATENCY_QOS_TIER_UNSPECIFIED;
			info-&gt;task_throughput_qos_tier = THROUGHPUT_QOS_TIER_UNSPECIFIED;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flavor == TASK_BASE_QOS_POLICY) {
			<span class="enscript-type">int</span> value1, value2;

			proc_get_task_policy2(task, THREAD_NULL, TASK_POLICY_ATTRIBUTE, TASK_POLICY_BASE_LATENCY_AND_THROUGHPUT_QOS, &amp;value1, &amp;value2);

			info-&gt;task_latency_qos_tier = qos_latency_policy_package(value1);
			info-&gt;task_throughput_qos_tier = qos_throughput_policy_package(value2);

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flavor == TASK_OVERRIDE_QOS_POLICY) {
			<span class="enscript-type">int</span> value1, value2;

			proc_get_task_policy2(task, THREAD_NULL, TASK_POLICY_ATTRIBUTE, TASK_POLICY_OVERRIDE_LATENCY_AND_THROUGHPUT_QOS, &amp;value1, &amp;value2);

			info-&gt;task_latency_qos_tier = qos_latency_policy_package(value1);
			info-&gt;task_throughput_qos_tier = qos_throughput_policy_package(value2);
		}

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_STATE</span>:
	{
		task_policy_state_t info = (task_policy_state_t)policy_info;

		<span class="enscript-keyword">if</span> (*count &lt; TASK_POLICY_STATE_COUNT)
			<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

		<span class="enscript-comment">/* Only root can get this info */</span>
		<span class="enscript-keyword">if</span> (current_task()-&gt;sec_token.val[0] != 0)
			<span class="enscript-keyword">return</span> KERN_PROTECTION_FAILURE;

		<span class="enscript-keyword">if</span> (*get_default) {
			info-&gt;requested = 0;
			info-&gt;effective = 0;
			info-&gt;pending = 0;
			info-&gt;imp_assertcnt = 0;
			info-&gt;imp_externcnt = 0;
			info-&gt;flags = 0;
			info-&gt;imp_transitions = 0;
		} <span class="enscript-keyword">else</span> {
			task_lock(task);

			info-&gt;requested = task_requested_bitfield(task, THREAD_NULL);
			info-&gt;effective = task_effective_bitfield(task, THREAD_NULL);
			info-&gt;pending   = 0;
			
			info-&gt;flags = 0;
			<span class="enscript-keyword">if</span> (task-&gt;task_imp_base != NULL) {
				info-&gt;imp_assertcnt = task-&gt;task_imp_base-&gt;iit_assertcnt;
				info-&gt;imp_externcnt = IIT_EXTERN(task-&gt;task_imp_base);
				info-&gt;flags |= (task_is_marked_importance_receiver(task) ? TASK_IMP_RECEIVER : 0);
				info-&gt;flags |= (task_is_marked_importance_denap_receiver(task) ? TASK_DENAP_RECEIVER : 0);
				info-&gt;flags |= (task_is_marked_importance_donor(task) ? TASK_IMP_DONOR : 0);
				info-&gt;flags |= (task_is_marked_live_importance_donor(task) ? TASK_IMP_LIVE_DONOR : 0);
				info-&gt;imp_transitions = task-&gt;task_imp_base-&gt;iit_transitions;
			} <span class="enscript-keyword">else</span> {
				info-&gt;imp_assertcnt = 0;
				info-&gt;imp_externcnt = 0;
				info-&gt;imp_transitions = 0;
			}
			task_unlock(task);
		}

		info-&gt;reserved[0] = 0;
		info-&gt;reserved[1] = 0;

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_SUPPRESSION_POLICY</span>:
	{
		task_suppression_policy_t info = (task_suppression_policy_t)policy_info;

		<span class="enscript-keyword">if</span> (*count &lt; TASK_SUPPRESSION_POLICY_COUNT)
			<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);

		task_lock(task);

		<span class="enscript-keyword">if</span> (*get_default) {
			info-&gt;active            = 0;
			info-&gt;lowpri_cpu        = 0;
			info-&gt;timer_throttle    = LATENCY_QOS_TIER_UNSPECIFIED;
			info-&gt;disk_throttle     = 0;
			info-&gt;cpu_limit         = 0;
			info-&gt;suspend           = 0;
			info-&gt;throughput_qos    = 0;
			info-&gt;suppressed_cpu    = 0;
		} <span class="enscript-keyword">else</span> {
			info-&gt;active            = task-&gt;requested_policy.t_sup_active;
			info-&gt;lowpri_cpu        = task-&gt;requested_policy.t_sup_lowpri_cpu;
			info-&gt;timer_throttle    = qos_latency_policy_package(task-&gt;requested_policy.t_sup_timer);
			info-&gt;disk_throttle     = task-&gt;requested_policy.t_sup_disk;
			info-&gt;cpu_limit         = task-&gt;requested_policy.t_sup_cpu_limit;
			info-&gt;suspend           = task-&gt;requested_policy.t_sup_suspend;
			info-&gt;throughput_qos    = qos_throughput_policy_package(task-&gt;requested_policy.t_sup_throughput);
			info-&gt;suppressed_cpu    = task-&gt;requested_policy.t_sup_cpu;
			info-&gt;background_sockets = task-&gt;requested_policy.t_sup_bg_sockets;
		}

		task_unlock(task);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
	}

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/*
 * Called at task creation
 * We calculate the correct effective but don't apply it to anything yet.
 * The threads, etc will inherit from the task as they get created.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_policy_create</span>(task_t task, <span class="enscript-type">int</span> parent_boosted)
{
	<span class="enscript-keyword">if</span> (task-&gt;requested_policy.t_apptype == TASK_APPTYPE_DAEMON_ADAPTIVE) {
		<span class="enscript-keyword">if</span> (parent_boosted) {
			task-&gt;requested_policy.t_apptype = TASK_APPTYPE_DAEMON_INTERACTIVE;
			task_importance_mark_donor(task, TRUE);
		} <span class="enscript-keyword">else</span> {
			task-&gt;requested_policy.t_apptype = TASK_APPTYPE_DAEMON_BACKGROUND;
			task_importance_mark_receiver(task, FALSE);
		}
	}

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(IMP_UPDATE, (IMP_UPDATE_TASK_CREATE | TASK_POLICY_TASK))) | DBG_FUNC_START,
				  task_pid(task), teffective_0(task, THREAD_NULL),
				  teffective_1(task, THREAD_NULL), tpriority(task, THREAD_NULL), 0);

	task_policy_update_internal_locked(task, THREAD_NULL, TRUE, NULL);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(IMP_UPDATE, (IMP_UPDATE_TASK_CREATE | TASK_POLICY_TASK))) | DBG_FUNC_END,
				  task_pid(task), teffective_0(task, THREAD_NULL),
				  teffective_1(task, THREAD_NULL), tpriority(task, THREAD_NULL), 0);

	task_importance_update_live_donor(task);
	task_policy_update_task_locked(task, FALSE, FALSE, FALSE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">thread_policy_create</span>(thread_t thread)
{
	task_t task = thread-&gt;task;

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(IMP_UPDATE, (IMP_UPDATE_TASK_CREATE | TASK_POLICY_THREAD))) | DBG_FUNC_START,
				  targetid(task, thread), teffective_0(task, thread),
				  teffective_1(task, thread), tpriority(task, thread), 0);

	task_policy_update_internal_locked(task, thread, TRUE, NULL);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(IMP_UPDATE, (IMP_UPDATE_TASK_CREATE | TASK_POLICY_THREAD))) | DBG_FUNC_END,
				  targetid(task, thread), teffective_0(task, thread),
				  teffective_1(task, thread), tpriority(task, thread), 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">task_policy_update_locked</span>(task_t task, thread_t thread, task_pend_token_t pend_token)
{
	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
	                          (IMPORTANCE_CODE(IMP_UPDATE, tisthread(thread)) | DBG_FUNC_START),
	                          targetid(task, thread), teffective_0(task, thread),
	                          teffective_1(task, thread), tpriority(task, thread), 0);

	task_policy_update_internal_locked(task, thread, FALSE, pend_token);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(IMP_UPDATE, tisthread(thread))) | DBG_FUNC_END,
				  targetid(task, thread), teffective_0(task, thread),
				  teffective_1(task, thread), tpriority(task, thread), 0);
}

<span class="enscript-comment">/*
 * One state update function TO RULE THEM ALL
 *
 * This function updates the task or thread effective policy fields
 * and pushes the results to the relevant subsystems.
 *
 * Must call update_complete after unlocking the task,
 * as some subsystems cannot be updated while holding the task lock.
 *
 * Called with task locked, not thread
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">task_policy_update_internal_locked</span>(task_t task, thread_t thread, boolean_t in_create, task_pend_token_t pend_token)
{
	boolean_t on_task = (thread == THREAD_NULL) ? TRUE : FALSE;

	<span class="enscript-comment">/*
	 * Step 1:
	 *  Gather requested policy
	 */</span>

	<span class="enscript-type">struct</span> task_requested_policy requested =
	        (on_task) ? task-&gt;requested_policy : thread-&gt;requested_policy;


	<span class="enscript-comment">/*
	 * Step 2:
	 *  Calculate new effective policies from requested policy and task state
	 *  Rules:
	 *      If in an 'on_task' block, must only look at and set fields starting with t_
	 *      If operating on a task, don't touch anything starting with th_
	 *      If operating on a thread, don't touch anything starting with t_
	 *      Don't change requested, it won't take effect
	 */</span>

	<span class="enscript-type">struct</span> task_effective_policy next = {};
	<span class="enscript-type">struct</span> task_effective_policy task_effective;

	<span class="enscript-comment">/* Calculate QoS policies */</span>

	<span class="enscript-keyword">if</span> (on_task) {
		<span class="enscript-comment">/* Update task role */</span>
		next.t_role = requested.t_role;

		<span class="enscript-comment">/* Set task qos clamp and ceiling */</span>
		next.t_qos_clamp = requested.t_qos_clamp;

		<span class="enscript-keyword">if</span> (requested.t_apptype == TASK_APPTYPE_APP_DEFAULT ||
		    requested.t_apptype == TASK_APPTYPE_APP_TAL) {

			<span class="enscript-keyword">switch</span> (next.t_role) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_FOREGROUND_APPLICATION</span>:
					<span class="enscript-comment">/* Foreground apps get urgent scheduler priority */</span>
					next.qos_ui_is_urgent = 1;
					next.t_qos_ceiling = THREAD_QOS_UNSPECIFIED;
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BACKGROUND_APPLICATION</span>:
					<span class="enscript-comment">/* This is really 'non-focal but on-screen' */</span>
					next.t_qos_ceiling = THREAD_QOS_UNSPECIFIED;
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_DEFAULT_APPLICATION</span>:
					<span class="enscript-comment">/* This is 'may render UI but we don't know if it's focal/nonfocal' */</span>
					next.t_qos_ceiling = THREAD_QOS_UNSPECIFIED;
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_NONUI_APPLICATION</span>:
					<span class="enscript-comment">/* i.e. 'off-screen' */</span>
					next.t_qos_ceiling = THREAD_QOS_LEGACY;
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_CONTROL_APPLICATION</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_GRAPHICS_SERVER</span>:
					next.qos_ui_is_urgent = 1;
					next.t_qos_ceiling = THREAD_QOS_UNSPECIFIED;
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_THROTTLE_APPLICATION</span>:
					<span class="enscript-comment">/* i.e. 'TAL launch' */</span>
					next.t_qos_ceiling = THREAD_QOS_UTILITY;
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_UNSPECIFIED</span>:
				<span class="enscript-reference">default</span>:
					<span class="enscript-comment">/* Apps that don't have an application role get
					 * USER_INTERACTIVE and USER_INITIATED squashed to LEGACY */</span>
					next.t_qos_ceiling = THREAD_QOS_LEGACY;
					<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Daemons get USER_INTERACTIVE squashed to USER_INITIATED */</span>
			next.t_qos_ceiling = THREAD_QOS_USER_INITIATED;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Set thread qos tier
		 * Note that an override only overrides the QoS field, not other policy settings.
		 * A thread must already be participating in QoS for override to take effect
		 */</span>

		<span class="enscript-comment">/* Snapshot the task's effective policy */</span>
		task_effective = task-&gt;effective_policy;

		next.qos_ui_is_urgent = task_effective.qos_ui_is_urgent;

		<span class="enscript-keyword">if</span> ((requested.thrp_qos_override != THREAD_QOS_UNSPECIFIED) &amp;&amp; (requested.thrp_qos != THREAD_QOS_UNSPECIFIED))
			next.thep_qos = MAX(requested.thrp_qos_override, requested.thrp_qos);
		<span class="enscript-keyword">else</span>
			next.thep_qos = requested.thrp_qos;

		<span class="enscript-comment">/* A task clamp will result in an effective QoS even when requested is UNSPECIFIED */</span>
		<span class="enscript-keyword">if</span> (task_effective.t_qos_clamp != THREAD_QOS_UNSPECIFIED) {
			<span class="enscript-keyword">if</span> (next.thep_qos != THREAD_QOS_UNSPECIFIED)
				next.thep_qos = MIN(task_effective.t_qos_clamp, next.thep_qos);
			<span class="enscript-keyword">else</span>
				next.thep_qos = task_effective.t_qos_clamp;
		}

		<span class="enscript-comment">/* The ceiling only applies to threads that are in the QoS world */</span>
		<span class="enscript-keyword">if</span> (task_effective.t_qos_ceiling != THREAD_QOS_UNSPECIFIED &amp;&amp;
		    next.thep_qos                != THREAD_QOS_UNSPECIFIED) {
			next.thep_qos = MIN(task_effective.t_qos_ceiling, next.thep_qos);
		}

		<span class="enscript-comment">/*
		 * The QoS relative priority is only applicable when the original programmer's
		 * intended (requested) QoS is in effect. When the QoS is clamped (e.g.
		 * USER_INITIATED-13REL clamped to UTILITY), the relative priority is not honored,
		 * since otherwise it would be lower than unclamped threads. Similarly, in the
		 * presence of boosting, the programmer doesn't know what other actors
		 * are boosting the thread.
		 */</span>
		<span class="enscript-keyword">if</span> ((requested.thrp_qos != THREAD_QOS_UNSPECIFIED) &amp;&amp;
		    (requested.thrp_qos == next.thep_qos) &amp;&amp;
		    (requested.thrp_qos_override == THREAD_QOS_UNSPECIFIED)) {
			next.thep_qos_relprio = requested.thrp_qos_relprio;
		} <span class="enscript-keyword">else</span> {
			next.thep_qos_relprio = 0;
		}
	}

	<span class="enscript-comment">/* Calculate DARWIN_BG */</span>
	boolean_t wants_darwinbg        = FALSE;
	boolean_t wants_all_sockets_bg  = FALSE; <span class="enscript-comment">/* Do I want my existing sockets to be bg */</span>
	boolean_t wants_watchersbg      = FALSE; <span class="enscript-comment">/* Do I want my pidbound threads to be bg */</span>

	<span class="enscript-comment">/*
	 * If DARWIN_BG has been requested at either level, it's engaged.
	 * Only true DARWIN_BG changes cause watchers to transition.
	 *
	 * Backgrounding due to apptype does.
	 */</span>
	<span class="enscript-keyword">if</span> (requested.int_darwinbg || requested.ext_darwinbg)
		wants_watchersbg = wants_all_sockets_bg = wants_darwinbg = TRUE;

	<span class="enscript-keyword">if</span> (on_task) {
		<span class="enscript-comment">/* Background TAL apps are throttled when TAL is enabled */</span>
		<span class="enscript-keyword">if</span> (requested.t_apptype      == TASK_APPTYPE_APP_TAL &amp;&amp;
		    requested.t_role         == TASK_BACKGROUND_APPLICATION &amp;&amp;
		    requested.t_tal_enabled  == 1) {
			next.t_tal_engaged = 1;
		}

		<span class="enscript-keyword">if</span> ((requested.t_apptype     == TASK_APPTYPE_APP_DEFAULT ||
		     requested.t_apptype     == TASK_APPTYPE_APP_TAL) &amp;&amp;
		    requested.t_role         == TASK_THROTTLE_APPLICATION) {
			next.t_tal_engaged = 1;
		}

		<span class="enscript-comment">/* Adaptive daemons are DARWIN_BG unless boosted, and don't get network throttled. */</span>
		<span class="enscript-keyword">if</span> (requested.t_apptype == TASK_APPTYPE_DAEMON_ADAPTIVE &amp;&amp;
		    requested.t_boosted == 0)
			wants_darwinbg = TRUE;

		<span class="enscript-comment">/* Background daemons are always DARWIN_BG, no exceptions, and don't get network throttled. */</span>
		<span class="enscript-keyword">if</span> (requested.t_apptype == TASK_APPTYPE_DAEMON_BACKGROUND)
			wants_darwinbg = TRUE;

		<span class="enscript-keyword">if</span> (next.t_qos_clamp == THREAD_QOS_BACKGROUND || next.t_qos_clamp == THREAD_QOS_MAINTENANCE)
			wants_darwinbg = TRUE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (requested.th_pidbind_bg)
			wants_all_sockets_bg = wants_darwinbg = TRUE;

		<span class="enscript-keyword">if</span> (requested.th_workq_bg)
			wants_darwinbg = TRUE;

		<span class="enscript-keyword">if</span> (next.thep_qos == THREAD_QOS_BACKGROUND || next.thep_qos == THREAD_QOS_MAINTENANCE)
			wants_darwinbg = TRUE;
	}

	<span class="enscript-comment">/* Calculate side effects of DARWIN_BG */</span>

	<span class="enscript-keyword">if</span> (wants_darwinbg) {
		next.darwinbg = 1;
		<span class="enscript-comment">/* darwinbg threads/tasks always create bg sockets, but we don't always loop over all sockets */</span>
		next.new_sockets_bg = 1;
		next.lowpri_cpu = 1;
	}

	<span class="enscript-keyword">if</span> (wants_all_sockets_bg)
		next.all_sockets_bg = 1;

	<span class="enscript-keyword">if</span> (on_task &amp;&amp; wants_watchersbg)
		next.t_watchers_bg = 1;

	<span class="enscript-comment">/* darwinbg on either task or thread implies background QOS (or lower) */</span>
	<span class="enscript-keyword">if</span> (!on_task &amp;&amp;
		(wants_darwinbg || task_effective.darwinbg) &amp;&amp;
		(next.thep_qos &gt; THREAD_QOS_BACKGROUND || next.thep_qos == THREAD_QOS_UNSPECIFIED)){
		next.thep_qos = THREAD_QOS_BACKGROUND;
		next.thep_qos_relprio = 0;
	}

	<span class="enscript-comment">/* Calculate low CPU priority */</span>

	boolean_t wants_lowpri_cpu = FALSE;

	<span class="enscript-keyword">if</span> (wants_darwinbg)
		wants_lowpri_cpu = TRUE;

	<span class="enscript-keyword">if</span> (next.t_tal_engaged)
		wants_lowpri_cpu = TRUE;

	<span class="enscript-keyword">if</span> (on_task &amp;&amp; requested.t_sup_lowpri_cpu &amp;&amp; requested.t_boosted == 0)
		wants_lowpri_cpu = TRUE;

	<span class="enscript-keyword">if</span> (wants_lowpri_cpu)
		next.lowpri_cpu = 1;

	<span class="enscript-comment">/* Calculate IO policy */</span>

	<span class="enscript-comment">/* Update BG IO policy (so we can see if it has changed) */</span>
	next.bg_iotier = requested.bg_iotier;

	<span class="enscript-type">int</span> iopol = THROTTLE_LEVEL_TIER0;

	<span class="enscript-keyword">if</span> (wants_darwinbg)
		iopol = MAX(iopol, requested.bg_iotier);

	<span class="enscript-keyword">if</span> (on_task) {
		<span class="enscript-keyword">if</span> (requested.t_apptype == TASK_APPTYPE_DAEMON_STANDARD)
			iopol = MAX(iopol, proc_standard_daemon_tier);

		<span class="enscript-keyword">if</span> (requested.t_sup_disk &amp;&amp; requested.t_boosted == 0)
			iopol = MAX(iopol, proc_suppressed_disk_tier);

		<span class="enscript-keyword">if</span> (next.t_tal_engaged)
			iopol = MAX(iopol, proc_tal_disk_tier);

		<span class="enscript-keyword">if</span> (next.t_qos_clamp != THREAD_QOS_UNSPECIFIED)
			iopol = MAX(iopol, thread_qos_policy_params.qos_iotier[next.t_qos_clamp]);

	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Look up the associated IO tier value for the QoS class */</span>
		iopol = MAX(iopol, thread_qos_policy_params.qos_iotier[next.thep_qos]);
	}

	iopol = MAX(iopol, requested.int_iotier);
	iopol = MAX(iopol, requested.ext_iotier);

	next.io_tier = iopol;

	<span class="enscript-comment">/* Calculate Passive IO policy */</span>

	<span class="enscript-keyword">if</span> (requested.ext_iopassive || requested.int_iopassive)
		next.io_passive = 1;

	<span class="enscript-comment">/* Calculate miscellaneous policy */</span>

	<span class="enscript-keyword">if</span> (on_task) {
		<span class="enscript-comment">/* Calculate suppression-active flag */</span>
		<span class="enscript-keyword">if</span> (requested.t_sup_active &amp;&amp; requested.t_boosted == 0)
			next.t_sup_active = 1;

		<span class="enscript-comment">/* Calculate suspend policy */</span>
		<span class="enscript-keyword">if</span> (requested.t_sup_suspend &amp;&amp; requested.t_boosted == 0)
			next.t_suspended = 1;

		<span class="enscript-comment">/* Calculate timer QOS */</span>
		<span class="enscript-type">int</span> latency_qos = requested.t_base_latency_qos;

		<span class="enscript-keyword">if</span> (requested.t_sup_timer &amp;&amp; requested.t_boosted == 0)
			latency_qos = requested.t_sup_timer;

		<span class="enscript-keyword">if</span> (next.t_qos_clamp != THREAD_QOS_UNSPECIFIED)
			latency_qos = MAX(latency_qos, (<span class="enscript-type">int</span>)thread_qos_policy_params.qos_latency_qos[next.t_qos_clamp]);

		<span class="enscript-keyword">if</span> (requested.t_over_latency_qos != 0)
			latency_qos = requested.t_over_latency_qos;

		<span class="enscript-comment">/* Treat the windowserver special */</span>
		<span class="enscript-keyword">if</span> (requested.t_role == TASK_GRAPHICS_SERVER)
			latency_qos = proc_graphics_timer_qos;

		next.t_latency_qos = latency_qos;

		<span class="enscript-comment">/* Calculate throughput QOS */</span>
		<span class="enscript-type">int</span> through_qos = requested.t_base_through_qos;

		<span class="enscript-keyword">if</span> (requested.t_sup_throughput &amp;&amp; requested.t_boosted == 0)
			through_qos = requested.t_sup_throughput;

		<span class="enscript-keyword">if</span> (next.t_qos_clamp != THREAD_QOS_UNSPECIFIED)
			through_qos = MAX(through_qos, (<span class="enscript-type">int</span>)thread_qos_policy_params.qos_through_qos[next.t_qos_clamp]);

		<span class="enscript-keyword">if</span> (requested.t_over_through_qos != 0)
			through_qos = requested.t_over_through_qos;

		next.t_through_qos = through_qos;

		<span class="enscript-comment">/* Calculate suppressed CPU priority */</span>
		<span class="enscript-keyword">if</span> (requested.t_sup_cpu &amp;&amp; requested.t_boosted == 0)
			next.t_suppressed_cpu = 1;

		<span class="enscript-comment">/*
		 * Calculate background sockets
		 * Don't take into account boosting to limit transition frequency.
		 */</span>
		<span class="enscript-keyword">if</span> (requested.t_sup_bg_sockets){
			next.all_sockets_bg = 1;
			next.new_sockets_bg = 1;
		}

		<span class="enscript-comment">/* Apply SFI Managed class bit */</span>
		next.t_sfi_managed = requested.t_sfi_managed;

		<span class="enscript-comment">/* Calculate 'live donor' status for live importance */</span>
		<span class="enscript-keyword">switch</span> (requested.t_apptype) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_APP_TAL</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_APP_DEFAULT</span>:
				<span class="enscript-keyword">if</span> (requested.ext_darwinbg == 0)
					next.t_live_donor = 1;
				<span class="enscript-keyword">else</span>
					next.t_live_donor = 0;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_DAEMON_INTERACTIVE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_DAEMON_STANDARD</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_DAEMON_ADAPTIVE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_DAEMON_BACKGROUND</span>:
			<span class="enscript-reference">default</span>:
				next.t_live_donor = 0;
				<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (requested.terminated) {
		<span class="enscript-comment">/*
		 * Shoot down the throttles that slow down exit or response to SIGTERM
		 * We don't need to shoot down:
		 * passive        (don't want to cause others to throttle)
		 * all_sockets_bg (don't need to iterate FDs on every exit)
		 * new_sockets_bg (doesn't matter for exiting process)
		 * pidsuspend     (jetsam-ed BG process shouldn't run again)
		 * watchers_bg    (watcher threads don't need to be unthrottled)
		 * t_latency_qos  (affects userspace timers only)
		 */</span>

		next.terminated         = 1;
		next.darwinbg           = 0;
		next.lowpri_cpu         = 0;
		next.io_tier            = THROTTLE_LEVEL_TIER0;
		<span class="enscript-keyword">if</span> (on_task) {
			next.t_tal_engaged = 0;
			next.t_role = TASK_UNSPECIFIED;
			next.t_suppressed_cpu = 0;

			<span class="enscript-comment">/* TODO: This should only be shot down on SIGTERM, not exit */</span>
			next.t_suspended   = 0;
		} <span class="enscript-keyword">else</span> {
			next.thep_qos = THREAD_QOS_UNSPECIFIED;
		}
	}

	<span class="enscript-comment">/*
	 * Step 3:
	 *  Swap out old policy for new policy
	 */</span>

	<span class="enscript-keyword">if</span> (!on_task) {
		<span class="enscript-comment">/* Acquire thread mutex to synchronize against
		 * thread_policy_set(). Consider reworking to separate qos
		 * fields, or locking the task in thread_policy_set.
		 * A more efficient model would be to make the thread bits
		 * authoritative.
		 */</span>
		thread_mtx_lock(thread);
	}

	<span class="enscript-type">struct</span> task_effective_policy prev =
	        (on_task) ? task-&gt;effective_policy : thread-&gt;effective_policy;

	<span class="enscript-comment">/*
	 * Check for invalid transitions here for easier debugging
	 * TODO: dump the structs as hex in the panic string
	 */</span>
	<span class="enscript-keyword">if</span> (task == kernel_task &amp;&amp; prev.all_sockets_bg != next.all_sockets_bg)
		panic(<span class="enscript-string">&quot;unexpected network change for kernel task&quot;</span>);

	<span class="enscript-comment">/* This is the point where the new values become visible to other threads */</span>
	<span class="enscript-keyword">if</span> (on_task)
		task-&gt;effective_policy = next;
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Preserve thread specific latency/throughput QoS modified via
		 * thread_policy_set(). Inelegant in the extreme, to be reworked.
		 *
		 * If thread QoS class is set, we don't need to preserve the previously set values.
		 * We should ensure to not accidentally preserve previous thread QoS values if you set a thread
		 * back to default QoS.
		 */</span>
		uint32_t lqos = thread-&gt;effective_policy.t_latency_qos, tqos = thread-&gt;effective_policy.t_through_qos;

		<span class="enscript-keyword">if</span> (prev.thep_qos == THREAD_QOS_UNSPECIFIED &amp;&amp; next.thep_qos == THREAD_QOS_UNSPECIFIED) {
			next.t_latency_qos = lqos;
			next.t_through_qos = tqos;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (prev.thep_qos != THREAD_QOS_UNSPECIFIED &amp;&amp; next.thep_qos == THREAD_QOS_UNSPECIFIED) {
			next.t_latency_qos = 0;
			next.t_through_qos = 0;
		} <span class="enscript-keyword">else</span> {
			next.t_latency_qos = thread_qos_policy_params.qos_latency_qos[next.thep_qos];
			next.t_through_qos = thread_qos_policy_params.qos_through_qos[next.thep_qos];
		}

		thread_update_qos_cpu_time(thread, TRUE);
		thread-&gt;effective_policy = next;
		thread_mtx_unlock(thread);
	}

	<span class="enscript-comment">/* Don't do anything further to a half-formed task or thread */</span>
	<span class="enscript-keyword">if</span> (in_create)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Step 4:
	 *  Pend updates that can't be done while holding the task lock
	 */</span>

	<span class="enscript-keyword">if</span> (prev.all_sockets_bg != next.all_sockets_bg)
		pend_token-&gt;tpt_update_sockets = 1;

	<span class="enscript-keyword">if</span> (on_task) {
		<span class="enscript-comment">/* Only re-scan the timer list if the qos level is getting less strong */</span>
		<span class="enscript-keyword">if</span> (prev.t_latency_qos &gt; next.t_latency_qos)
			pend_token-&gt;tpt_update_timers = 1;


		<span class="enscript-keyword">if</span> (prev.t_live_donor != next.t_live_donor)
			pend_token-&gt;tpt_update_live_donor = 1;
	}

	<span class="enscript-comment">/*
	 * Step 5:
	 *  Update other subsystems as necessary if something has changed
	 */</span>

	boolean_t update_throttle = (prev.io_tier != next.io_tier) ? TRUE : FALSE;

	<span class="enscript-keyword">if</span> (on_task) {
		<span class="enscript-keyword">if</span> (prev.t_suspended == 0 &amp;&amp; next.t_suspended == 1 &amp;&amp; task-&gt;active) {
			task_hold_locked(task);
			task_wait_locked(task, FALSE);
		}
		<span class="enscript-keyword">if</span> (prev.t_suspended == 1 &amp;&amp; next.t_suspended == 0 &amp;&amp; task-&gt;active) {
			task_release_locked(task);
		}

		boolean_t update_threads = FALSE;
		boolean_t update_sfi = FALSE;

		<span class="enscript-keyword">if</span> (prev.bg_iotier          != next.bg_iotier        ||
		    prev.terminated         != next.terminated       ||
		    prev.t_qos_clamp        != next.t_qos_clamp      ||
		    prev.t_qos_ceiling      != next.t_qos_ceiling    ||
		    prev.qos_ui_is_urgent   != next.qos_ui_is_urgent ||
		    prev.darwinbg           != next.darwinbg)
			update_threads = TRUE;

		<span class="enscript-comment">/*
		 * A bit of a layering violation. We know what task policy attributes
		 * sfi_thread_classify() consults, so if they change, trigger SFI
		 * re-evaluation.
		 */</span>
		<span class="enscript-keyword">if</span> ((prev.t_latency_qos != next.t_latency_qos) ||
			(prev.t_role != next.t_role) ||
			(prev.darwinbg != next.darwinbg) ||
			(prev.t_sfi_managed != next.t_sfi_managed))
			update_sfi = TRUE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SCHED_SFI</span>
		<span class="enscript-keyword">if</span> (prev.t_role != next.t_role &amp;&amp; task_policy_update_coalition_focal_tasks(task, prev.t_role, next.t_role)) {
			update_sfi = TRUE;
			pend_token-&gt;tpt_update_coal_sfi = 1;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !CONFIG_SCHED_SFI */</span>

		task_policy_update_task_locked(task, update_throttle, update_threads, update_sfi);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> update_cpu = 0;
		boolean_t update_sfi = FALSE;
		boolean_t update_qos = FALSE;

		<span class="enscript-keyword">if</span> (prev.lowpri_cpu != next.lowpri_cpu)
			update_cpu = (next.lowpri_cpu ? DO_LOWPRI_CPU : UNDO_LOWPRI_CPU);

		<span class="enscript-keyword">if</span> (prev.darwinbg != next.darwinbg ||
		    prev.thep_qos != next.thep_qos)
			update_sfi = TRUE;

		<span class="enscript-keyword">if</span> (prev.thep_qos           != next.thep_qos          ||
		    prev.thep_qos_relprio   != next.thep_qos_relprio  ||
		    prev.qos_ui_is_urgent   != next.qos_ui_is_urgent  ||
		    prev.terminated         != next.terminated) {
			update_qos = TRUE;
		}

		task_policy_update_thread_locked(thread, update_cpu, update_throttle, update_sfi, update_qos);
	}
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SCHED_SFI</span>
<span class="enscript-comment">/*
 * Yet another layering violation. We reach out and bang on the coalition directly.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">task_policy_update_coalition_focal_tasks</span>(task_t     task,
                                         <span class="enscript-type">int</span>        prev_role,
                                         <span class="enscript-type">int</span>        next_role)
{
	boolean_t sfi_transition = FALSE;

	<span class="enscript-comment">/* task moving into/out-of the foreground */</span>
	<span class="enscript-keyword">if</span> (prev_role != TASK_FOREGROUND_APPLICATION &amp;&amp; next_role == TASK_FOREGROUND_APPLICATION) {
		<span class="enscript-keyword">if</span> (task_coalition_adjust_focal_count(task, 1) == 1)
			sfi_transition = TRUE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (prev_role == TASK_FOREGROUND_APPLICATION &amp;&amp; next_role != TASK_FOREGROUND_APPLICATION) {
		<span class="enscript-keyword">if</span> (task_coalition_adjust_focal_count(task, -1) == 0)
			sfi_transition = TRUE;
	}

	<span class="enscript-comment">/* task moving into/out-of background */</span>
	<span class="enscript-keyword">if</span> (prev_role != TASK_BACKGROUND_APPLICATION &amp;&amp; next_role == TASK_BACKGROUND_APPLICATION) {
		<span class="enscript-keyword">if</span> (task_coalition_adjust_nonfocal_count(task, 1) == 1)
			sfi_transition = TRUE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (prev_role == TASK_BACKGROUND_APPLICATION &amp;&amp; next_role != TASK_BACKGROUND_APPLICATION) {
		<span class="enscript-keyword">if</span> (task_coalition_adjust_nonfocal_count(task, -1) == 0)
			sfi_transition = TRUE;
	}

	<span class="enscript-keyword">return</span> sfi_transition;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_SCHED_SFI */</span>

<span class="enscript-comment">/* Despite the name, the thread's task is locked, the thread is not */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_policy_update_thread_locked</span>(thread_t thread,
                                 <span class="enscript-type">int</span> update_cpu,
                                 boolean_t update_throttle,
                                 boolean_t update_sfi,
                                 boolean_t update_qos)
{
	thread_precedence_policy_data_t policy;

	<span class="enscript-keyword">if</span> (update_throttle) {
		rethrottle_thread(thread-&gt;uthread);
	}

	<span class="enscript-keyword">if</span> (update_sfi) {
		sfi_reevaluate(thread);
	}

	<span class="enscript-comment">/*
	 * TODO: pidbind needs to stuff remembered importance into saved_importance
	 * properly deal with bg'ed threads being pidbound and unbging while pidbound
	 *
	 * TODO: A BG thread's priority is 0 on desktop and 4 on embedded.  Need to reconcile this.
	 * */</span>
	<span class="enscript-keyword">if</span> (update_cpu == DO_LOWPRI_CPU) {
		thread-&gt;saved_importance = thread-&gt;importance;
		policy.importance = INT_MIN;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (update_cpu == UNDO_LOWPRI_CPU) {
		policy.importance = thread-&gt;saved_importance;
		thread-&gt;saved_importance = 0;
	}

	<span class="enscript-comment">/* Takes thread lock and thread mtx lock */</span>
	<span class="enscript-keyword">if</span> (update_cpu)
		thread_policy_set_internal(thread, THREAD_PRECEDENCE_POLICY,
                                           (thread_policy_t)&amp;policy,
                                           THREAD_PRECEDENCE_POLICY_COUNT);

	<span class="enscript-keyword">if</span> (update_qos)
		thread_recompute_qos(thread);
}

<span class="enscript-comment">/*
 * Calculate priority on a task, loop through its threads, and tell them about
 * priority changes and throttle changes.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_policy_update_task_locked</span>(task_t    task,
                               boolean_t update_throttle,
                               boolean_t update_threads,
                               boolean_t update_sfi)
{
	boolean_t update_priority = FALSE;

	<span class="enscript-keyword">if</span> (task == kernel_task)
		panic(<span class="enscript-string">&quot;Attempting to set task policy on kernel_task&quot;</span>);

	<span class="enscript-type">int</span> priority     = BASEPRI_DEFAULT;
	<span class="enscript-type">int</span> max_priority = MAXPRI_USER;

	<span class="enscript-keyword">if</span> (proc_get_effective_task_policy(task, TASK_POLICY_LOWPRI_CPU)) {
		priority = MAXPRI_THROTTLE;
		max_priority = MAXPRI_THROTTLE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (proc_get_effective_task_policy(task, TASK_POLICY_SUPPRESSED_CPU)) {
		priority = MAXPRI_SUPPRESSED;
		max_priority = MAXPRI_SUPPRESSED;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">switch</span> (proc_get_effective_task_policy(task, TASK_POLICY_ROLE)) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_CONTROL_APPLICATION</span>:
				priority = BASEPRI_CONTROL;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_GRAPHICS_SERVER</span>:
				priority = BASEPRI_GRAPHICS;
				max_priority = MAXPRI_RESERVED;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* factor in 'nice' value */</span>
		priority += task-&gt;importance;

		<span class="enscript-keyword">if</span> (task-&gt;effective_policy.t_qos_clamp != THREAD_QOS_UNSPECIFIED) {
			<span class="enscript-type">int</span> qos_clamp_priority = thread_qos_policy_params.qos_pri[task-&gt;effective_policy.t_qos_clamp];

			priority        = MIN(priority, qos_clamp_priority);
			max_priority    = MIN(max_priority, qos_clamp_priority);
		}
	}

	<span class="enscript-comment">/* avoid extra work if priority isn't changing */</span>
	<span class="enscript-keyword">if</span> (task-&gt;priority != priority || task-&gt;max_priority != max_priority) {
		update_priority = TRUE;

		<span class="enscript-comment">/* update the scheduling priority for the task */</span>
		task-&gt;max_priority = max_priority;

		<span class="enscript-keyword">if</span> (priority &gt; task-&gt;max_priority)
			priority = task-&gt;max_priority;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (priority &lt; MINPRI)
			priority = MINPRI;

		task-&gt;priority = priority;
	}

	<span class="enscript-comment">/* Loop over the threads in the task only once, and only if necessary */</span>
	<span class="enscript-keyword">if</span> (update_threads || update_throttle || update_priority || update_sfi ) {
		thread_t thread;

		queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
			<span class="enscript-keyword">if</span> (update_priority) {
				thread_mtx_lock(thread);

				thread_task_priority(thread, priority, max_priority);

				thread_mtx_unlock(thread);
			}

			<span class="enscript-keyword">if</span> (update_throttle) {
				rethrottle_thread(thread-&gt;uthread);
			}

			<span class="enscript-keyword">if</span> (update_sfi) {
				sfi_reevaluate(thread);
			}

			<span class="enscript-keyword">if</span> (update_threads) {
				thread-&gt;requested_policy.bg_iotier  = task-&gt;effective_policy.bg_iotier;
				thread-&gt;requested_policy.terminated = task-&gt;effective_policy.terminated;

				task_policy_update_internal_locked(task, thread, FALSE, NULL);
				<span class="enscript-comment">/*  The thread policy must not emit any completion actions due to this change. */</span>
			}
		}
	}
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SCHED_SFI</span>
<span class="enscript-comment">/* coalition object is locked */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">task_sfi_reevaluate_cb</span>(coalition_t coal, <span class="enscript-type">void</span> *ctx, task_t task)
{
	thread_t thread;

	<span class="enscript-comment">/* unused for now */</span>
	(<span class="enscript-type">void</span>)coal;

	<span class="enscript-comment">/* skip the task we're re-evaluating on behalf of: it's already updated */</span>
	<span class="enscript-keyword">if</span> (task == (task_t)ctx)
		<span class="enscript-keyword">return</span>;

	task_lock(task);

	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
		sfi_reevaluate(thread);
	}

	task_unlock(task);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_SCHED_SFI */</span>

<span class="enscript-comment">/*
 * Called with task unlocked to do things that can't be done while holding the task lock
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_policy_update_complete_unlocked</span>(task_t task, thread_t thread, task_pend_token_t pend_token)
{
	boolean_t on_task = (thread == THREAD_NULL) ? TRUE : FALSE;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
	<span class="enscript-keyword">if</span> (pend_token-&gt;tpt_update_sockets)
		proc_apply_task_networkbg(task-&gt;bsd_info, thread);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_BSD */</span>

	<span class="enscript-keyword">if</span> (on_task) {
		<span class="enscript-comment">/* The timer throttle has been removed or reduced, we need to look for expired timers and fire them */</span>
		<span class="enscript-keyword">if</span> (pend_token-&gt;tpt_update_timers)
			ml_timer_evaluate();


		<span class="enscript-keyword">if</span> (pend_token-&gt;tpt_update_live_donor)
			task_importance_update_live_donor(task);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SCHED_SFI</span>
		<span class="enscript-comment">/* use the resource coalition for SFI re-evaluation */</span>
		<span class="enscript-keyword">if</span> (pend_token-&gt;tpt_update_coal_sfi)
			coalition_for_each_task(task-&gt;coalition[COALITION_TYPE_RESOURCE],
						(<span class="enscript-type">void</span> *)task, task_sfi_reevaluate_cb);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_SCHED_SFI */</span>
	}
}

<span class="enscript-comment">/*
 * Initiate a task policy state transition
 *
 * Everything that modifies requested except functions that need to hold the task lock
 * should use this function
 *
 * Argument validation should be performed before reaching this point.
 *
 * TODO: Do we need to check task-&gt;active or thread-&gt;active?
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_set_task_policy</span>(task_t     task,
                     thread_t   thread,
                     <span class="enscript-type">int</span>        category,
                     <span class="enscript-type">int</span>        flavor,
                     <span class="enscript-type">int</span>        value)
{
	<span class="enscript-type">struct</span> task_pend_token pend_token = {};
	
	task_lock(task);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(flavor, (category | tisthread(thread)))) | DBG_FUNC_START,
				  targetid(task, thread), trequested_0(task, thread), trequested_1(task, thread), value, 0);

	proc_set_task_policy_locked(task, thread, category, flavor, value);

	task_policy_update_locked(task, thread, &amp;pend_token);

	task_unlock(task);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(flavor, (category | tisthread(thread)))) | DBG_FUNC_END,
				  targetid(task, thread), trequested_0(task, thread), trequested_1(task, thread), tpending(&amp;pend_token), 0);

	task_policy_update_complete_unlocked(task, thread, &amp;pend_token);
}

<span class="enscript-comment">/*
 * Initiate a task policy state transition on a thread with its TID
 * Useful if you cannot guarantee the thread won't get terminated
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_set_task_policy_thread</span>(task_t     task,
                            uint64_t   tid,
                            <span class="enscript-type">int</span>        category,
                            <span class="enscript-type">int</span>        flavor,
                            <span class="enscript-type">int</span>        value)
{
	thread_t thread;
	thread_t self = current_thread();
	<span class="enscript-type">struct</span> task_pend_token pend_token = {};

	task_lock(task);

	<span class="enscript-keyword">if</span> (tid == TID_NULL || tid == self-&gt;thread_id)
		thread = self;
	<span class="enscript-keyword">else</span>
		thread = task_findtid(task, tid);

	<span class="enscript-keyword">if</span> (thread == THREAD_NULL) {
		task_unlock(task);
		<span class="enscript-keyword">return</span>;
	}

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(flavor, (category | TASK_POLICY_THREAD))) | DBG_FUNC_START,
				  targetid(task, thread), trequested_0(task, thread), trequested_1(task, thread), value, 0);

	proc_set_task_policy_locked(task, thread, category, flavor, value);

	task_policy_update_locked(task, thread, &amp;pend_token);

	task_unlock(task);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(flavor, (category | TASK_POLICY_THREAD))) | DBG_FUNC_END,
				  targetid(task, thread), trequested_0(task, thread), trequested_1(task, thread), tpending(&amp;pend_token), 0);

	task_policy_update_complete_unlocked(task, thread, &amp;pend_token);
}

<span class="enscript-comment">/*
 * Variant of proc_set_task_policy() that sets two scalars in the requested policy structure.
 * Same locking rules apply.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_set_task_policy2</span>(task_t task, thread_t thread, <span class="enscript-type">int</span> category, <span class="enscript-type">int</span> flavor, <span class="enscript-type">int</span> value1, <span class="enscript-type">int</span> value2)
{
	<span class="enscript-type">struct</span> task_pend_token pend_token = {};
	
	task_lock(task);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(flavor, (category | tisthread(thread)))) | DBG_FUNC_START,
				  targetid(task, thread), trequested_0(task, thread), trequested_1(task, thread), value1, 0);

	proc_set_task_policy2_locked(task, thread, category, flavor, value1, value2);

	task_policy_update_locked(task, thread, &amp;pend_token);

	task_unlock(task);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(flavor, (category | tisthread(thread)))) | DBG_FUNC_END,
				  targetid(task, thread), trequested_0(task, thread), trequested_0(task, thread), tpending(&amp;pend_token), 0);

	task_policy_update_complete_unlocked(task, thread, &amp;pend_token);
}

<span class="enscript-comment">/*
 * Set the requested state for a specific flavor to a specific value.
 *
 *  TODO:
 *  Verify that arguments to non iopol things are 1 or 0
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">proc_set_task_policy_locked</span>(task_t      task,
                            thread_t    thread,
                            <span class="enscript-type">int</span>         category,
                            <span class="enscript-type">int</span>         flavor,
                            <span class="enscript-type">int</span>         value)
{
	boolean_t on_task = (thread == THREAD_NULL) ? TRUE : FALSE;

	<span class="enscript-type">int</span> tier, passive;

	<span class="enscript-type">struct</span> task_requested_policy requested =
	        (on_task) ? task-&gt;requested_policy : thread-&gt;requested_policy;

	<span class="enscript-keyword">switch</span> (flavor) {

	<span class="enscript-comment">/* Category: EXTERNAL and INTERNAL, thread and task */</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_DARWIN_BG</span>:
			<span class="enscript-keyword">if</span> (category == TASK_POLICY_EXTERNAL)
				requested.ext_darwinbg = value;
			<span class="enscript-keyword">else</span>
				requested.int_darwinbg = value;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_IOPOL</span>:
			proc_iopol_to_tier(value, &amp;tier, &amp;passive);
			<span class="enscript-keyword">if</span> (category == TASK_POLICY_EXTERNAL) {
				requested.ext_iotier  = tier;
				requested.ext_iopassive = passive;
			} <span class="enscript-keyword">else</span> {
				requested.int_iotier  = tier;
				requested.int_iopassive = passive;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_IO</span>:
			<span class="enscript-keyword">if</span> (category == TASK_POLICY_EXTERNAL)
				requested.ext_iotier = value;
			<span class="enscript-keyword">else</span>
				requested.int_iotier = value;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_PASSIVE_IO</span>:
			<span class="enscript-keyword">if</span> (category == TASK_POLICY_EXTERNAL)
				requested.ext_iopassive = value;
			<span class="enscript-keyword">else</span>
				requested.int_iopassive = value;
			<span class="enscript-keyword">break</span>;

	<span class="enscript-comment">/* Category: INTERNAL, task only */</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_DARWIN_BG_IOPOL</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_INTERNAL);
			proc_iopol_to_tier(value, &amp;tier, &amp;passive);
			requested.bg_iotier = tier;
			<span class="enscript-keyword">break</span>;

	<span class="enscript-comment">/* Category: ATTRIBUTE, task only */</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_TAL</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.t_tal_enabled = value;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_BOOST</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.t_boosted = value;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_ROLE</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.t_role = value;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_TERMINATED</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.terminated = value;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BASE_LATENCY_QOS_POLICY</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.t_base_latency_qos = value;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BASE_THROUGHPUT_QOS_POLICY</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.t_base_through_qos = value;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_SFI_MANAGED</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.t_sfi_managed = value;
			<span class="enscript-keyword">break</span>;

	<span class="enscript-comment">/* Category: ATTRIBUTE, thread only */</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_PIDBIND_BG</span>:
			assert(!on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.th_pidbind_bg = value;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_WORKQ_BG</span>:
			assert(!on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.th_workq_bg = value;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_QOS</span>:
			assert(!on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.thrp_qos = value;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_QOS_OVERRIDE</span>:
			assert(!on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.thrp_qos_override = value;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;unknown task policy: %d %d %d&quot;</span>, category, flavor, value);
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (on_task)
		task-&gt;requested_policy = requested;
	<span class="enscript-keyword">else</span>
		thread-&gt;requested_policy = requested;
}

<span class="enscript-comment">/*
 * Variant of proc_set_task_policy_locked() that sets two scalars in the requested policy structure.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">proc_set_task_policy2_locked</span>(task_t      task,
                             thread_t    thread,
                             <span class="enscript-type">int</span>         category,
                             <span class="enscript-type">int</span>         flavor,
                             <span class="enscript-type">int</span>         value1,
                             <span class="enscript-type">int</span>         value2)
{
	boolean_t on_task = (thread == THREAD_NULL) ? TRUE : FALSE;

	<span class="enscript-type">struct</span> task_requested_policy requested =
	        (on_task) ? task-&gt;requested_policy : thread-&gt;requested_policy;

	<span class="enscript-keyword">switch</span> (flavor) {

	<span class="enscript-comment">/* Category: ATTRIBUTE, task only */</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_BASE_LATENCY_AND_THROUGHPUT_QOS</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.t_base_latency_qos = value1;
			requested.t_base_through_qos = value2;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_OVERRIDE_LATENCY_AND_THROUGHPUT_QOS</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.t_over_latency_qos = value1;
			requested.t_over_through_qos = value2;
			<span class="enscript-keyword">break</span>;

	<span class="enscript-comment">/* Category: ATTRIBUTE, thread only */</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_QOS_AND_RELPRIO</span>:

			assert(!on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			requested.thrp_qos = value1;
			requested.thrp_qos_relprio = value2;
			DTRACE_BOOST3(qos_set, uint64_t, thread-&gt;thread_id, <span class="enscript-type">int</span>, requested.thrp_qos, <span class="enscript-type">int</span>, requested.thrp_qos_relprio);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;unknown task policy: %d %d %d %d&quot;</span>, category, flavor, value1, value2);
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (on_task)
		task-&gt;requested_policy = requested;
	<span class="enscript-keyword">else</span>
		thread-&gt;requested_policy = requested;
}


<span class="enscript-comment">/*
 * Gets what you set. Effective values may be different.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_get_task_policy</span>(task_t     task,
                     thread_t   thread,
                     <span class="enscript-type">int</span>        category,
                     <span class="enscript-type">int</span>        flavor)
{
	boolean_t on_task = (thread == THREAD_NULL) ? TRUE : FALSE;

	<span class="enscript-type">int</span> value = 0;

	task_lock(task);

	<span class="enscript-type">struct</span> task_requested_policy requested =
	        (on_task) ? task-&gt;requested_policy : thread-&gt;requested_policy;

	<span class="enscript-keyword">switch</span> (flavor) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_DARWIN_BG</span>:
			<span class="enscript-keyword">if</span> (category == TASK_POLICY_EXTERNAL)
				value = requested.ext_darwinbg;
			<span class="enscript-keyword">else</span>
				value = requested.int_darwinbg;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_IOPOL</span>:
			<span class="enscript-keyword">if</span> (category == TASK_POLICY_EXTERNAL)
				value = proc_tier_to_iopol(requested.ext_iotier,
				                            requested.ext_iopassive);
			<span class="enscript-keyword">else</span>
				value = proc_tier_to_iopol(requested.int_iotier,
				                            requested.int_iopassive);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_IO</span>:
			<span class="enscript-keyword">if</span> (category == TASK_POLICY_EXTERNAL)
				value = requested.ext_iotier;
			<span class="enscript-keyword">else</span>
				value = requested.int_iotier;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_PASSIVE_IO</span>:
			<span class="enscript-keyword">if</span> (category == TASK_POLICY_EXTERNAL)
				value = requested.ext_iopassive;
			<span class="enscript-keyword">else</span>
				value = requested.int_iopassive;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_DARWIN_BG_IOPOL</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			value = proc_tier_to_iopol(requested.bg_iotier, 0);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_ROLE</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			value = requested.t_role;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_SFI_MANAGED</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			value = requested.t_sfi_managed;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_QOS</span>:
			assert(!on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			value = requested.thrp_qos;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_QOS_OVERRIDE</span>:
			assert(!on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			value = requested.thrp_qos_override;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;unknown policy_flavor %d&quot;</span>, flavor);
			<span class="enscript-keyword">break</span>;
	}

	task_unlock(task);

	<span class="enscript-keyword">return</span> value;
}

<span class="enscript-comment">/*
 * Variant of proc_get_task_policy() that returns two scalar outputs.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_get_task_policy2</span>(task_t task, thread_t thread, <span class="enscript-type">int</span> category __unused, <span class="enscript-type">int</span> flavor, <span class="enscript-type">int</span> *value1, <span class="enscript-type">int</span> *value2)
{
	boolean_t on_task = (thread == THREAD_NULL) ? TRUE : FALSE;

	task_lock(task);

	<span class="enscript-type">struct</span> task_requested_policy requested =
	        (on_task) ? task-&gt;requested_policy : thread-&gt;requested_policy;

	<span class="enscript-keyword">switch</span> (flavor) {
		<span class="enscript-comment">/* TASK attributes */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_BASE_LATENCY_AND_THROUGHPUT_QOS</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			*value1 = requested.t_base_latency_qos;
			*value2 = requested.t_base_through_qos;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_OVERRIDE_LATENCY_AND_THROUGHPUT_QOS</span>:
			assert(on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			*value1 = requested.t_over_latency_qos;
			*value2 = requested.t_over_through_qos;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* THREAD attributes */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_QOS_AND_RELPRIO</span>:
			assert(!on_task &amp;&amp; category == TASK_POLICY_ATTRIBUTE);
			*value1 = requested.thrp_qos;
			*value2 = requested.thrp_qos_relprio;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;unknown policy_flavor %d&quot;</span>, flavor);
			<span class="enscript-keyword">break</span>;
	}

	task_unlock(task);
}


<span class="enscript-comment">/*
 * Functions for querying effective state for relevant subsystems
 * ONLY the relevant subsystem should query these.
 * NEVER take a value from one of the 'effective' functions and stuff it into a setter.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_get_effective_task_policy</span>(task_t task, <span class="enscript-type">int</span> flavor)
{
	<span class="enscript-keyword">return</span> proc_get_effective_policy(task, THREAD_NULL, flavor);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_get_effective_thread_policy</span>(thread_t thread, <span class="enscript-type">int</span> flavor)
{
	<span class="enscript-keyword">return</span> proc_get_effective_policy(thread-&gt;task, thread, flavor);
}

<span class="enscript-comment">/*
 * Gets what is actually in effect, for subsystems which pull policy instead of receive updates.
 *
 * NOTE: This accessor does not take the task lock.
 * Notifications of state updates need to be externally synchronized with state queries.
 * This routine *MUST* remain interrupt safe, as it is potentially invoked
 * within the context of a timer interrupt.  It is also called in KDP context for stackshot.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">proc_get_effective_policy</span>(task_t   task,
                          thread_t thread,
                          <span class="enscript-type">int</span>      flavor)
{
	boolean_t on_task = (thread == THREAD_NULL) ? TRUE : FALSE;
	<span class="enscript-type">int</span> value = 0;

	<span class="enscript-keyword">switch</span> (flavor) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_DARWIN_BG</span>:
			<span class="enscript-comment">/*
			 * This backs the KPI call proc_pidbackgrounded to find
			 * out if a pid is backgrounded,
			 * as well as proc_get_effective_thread_policy. 
			 * Its main use is within the timer layer, as well as
			 * prioritizing requests to the graphics system.
			 * Returns 1 for background mode, 0 for normal mode
			 */</span>
			<span class="enscript-keyword">if</span> (on_task)
				value = task-&gt;effective_policy.darwinbg;
			<span class="enscript-keyword">else</span>
				value = (task-&gt;effective_policy.darwinbg ||
				          thread-&gt;effective_policy.darwinbg) ? 1 : 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_IO</span>:
			<span class="enscript-comment">/*
			 * The I/O system calls here to find out what throttling tier to apply to an operation.
			 * Returns THROTTLE_LEVEL_* values. Some userspace spinlock operations can apply
			 * a temporary iotier override to make the I/O more aggressive to get the lock
			 * owner to release the spinlock.
			 */</span>
			<span class="enscript-keyword">if</span> (on_task)
				value = task-&gt;effective_policy.io_tier;
			<span class="enscript-keyword">else</span> {
				value = MAX(task-&gt;effective_policy.io_tier,
				             thread-&gt;effective_policy.io_tier);
				<span class="enscript-keyword">if</span> (thread-&gt;iotier_override != THROTTLE_LEVEL_NONE)
					value = MIN(value, thread-&gt;iotier_override);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_PASSIVE_IO</span>:
			<span class="enscript-comment">/*
			 * The I/O system calls here to find out whether an operation should be passive.
			 * (i.e. not cause operations with lower throttle tiers to be throttled)
			 * Returns 1 for passive mode, 0 for normal mode.
			 * If a userspace spinlock has applied an override, that I/O should always
			 * be passive to avoid self-throttling when the override is removed and lower
			 * iotier I/Os are issued.
			 */</span>
			<span class="enscript-keyword">if</span> (on_task)
				value = task-&gt;effective_policy.io_passive;
			<span class="enscript-keyword">else</span> {
				<span class="enscript-type">int</span> io_tier = MAX(task-&gt;effective_policy.io_tier, thread-&gt;effective_policy.io_tier);
				boolean_t override_in_effect = (thread-&gt;iotier_override != THROTTLE_LEVEL_NONE) &amp;&amp; (thread-&gt;iotier_override &lt; io_tier);

				value = (task-&gt;effective_policy.io_passive ||
				          thread-&gt;effective_policy.io_passive || override_in_effect) ? 1 : 0;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_ALL_SOCKETS_BG</span>:
			<span class="enscript-comment">/*
			 * do_background_socket() calls this to determine what it should do to the proc's sockets
			 * Returns 1 for background mode, 0 for normal mode
			 *
			 * This consults both thread and task so un-DBGing a thread while the task is BG
			 * doesn't get you out of the network throttle.
			 */</span>
			<span class="enscript-keyword">if</span> (on_task)
				value = task-&gt;effective_policy.all_sockets_bg;
			<span class="enscript-keyword">else</span>
				value = (task-&gt;effective_policy.all_sockets_bg ||
				         thread-&gt;effective_policy.all_sockets_bg) ? 1 : 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_NEW_SOCKETS_BG</span>:
			<span class="enscript-comment">/*
			 * socreate() calls this to determine if it should mark a new socket as background
			 * Returns 1 for background mode, 0 for normal mode
			 */</span>
			<span class="enscript-keyword">if</span> (on_task)
				value = task-&gt;effective_policy.new_sockets_bg;
			<span class="enscript-keyword">else</span>
				value = (task-&gt;effective_policy.new_sockets_bg ||
				          thread-&gt;effective_policy.new_sockets_bg) ? 1 : 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_LOWPRI_CPU</span>:
			<span class="enscript-comment">/*
			 * Returns 1 for low priority cpu mode, 0 for normal mode
			 */</span>
			<span class="enscript-keyword">if</span> (on_task)
				value = task-&gt;effective_policy.lowpri_cpu;
			<span class="enscript-keyword">else</span>
				value = (task-&gt;effective_policy.lowpri_cpu ||
				          thread-&gt;effective_policy.lowpri_cpu) ? 1 : 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_SUPPRESSED_CPU</span>:
			<span class="enscript-comment">/*
			 * Returns 1 for suppressed cpu mode, 0 for normal mode
			 */</span>
			assert(on_task);
			value = task-&gt;effective_policy.t_suppressed_cpu;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_LATENCY_QOS</span>:
			<span class="enscript-comment">/*
			 * timer arming calls into here to find out the timer coalescing level
			 * Returns a QoS tier (0-6)
			 */</span>
			<span class="enscript-keyword">if</span> (on_task) {
				value = task-&gt;effective_policy.t_latency_qos;
			} <span class="enscript-keyword">else</span> {
				value = MAX(task-&gt;effective_policy.t_latency_qos, thread-&gt;effective_policy.t_latency_qos);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_THROUGH_QOS</span>:
			<span class="enscript-comment">/*
			 * Returns a QoS tier (0-6)
			 */</span>
			assert(on_task);
			value = task-&gt;effective_policy.t_through_qos;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_ROLE</span>:
			assert(on_task);
			value = task-&gt;effective_policy.t_role;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_WATCHERS_BG</span>:
			assert(on_task);
			value = task-&gt;effective_policy.t_watchers_bg;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_SFI_MANAGED</span>:
			assert(on_task);
			value = task-&gt;effective_policy.t_sfi_managed;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_QOS</span>:
			assert(!on_task);
			value = thread-&gt;effective_policy.thep_qos;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;unknown policy_flavor %d&quot;</span>, flavor);
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> value;
}

<span class="enscript-comment">/*
 * Convert from IOPOL_* values to throttle tiers.
 *
 * TODO: Can this be made more compact, like an array lookup
 * Note that it is possible to support e.g. IOPOL_PASSIVE_STANDARD in the future
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">proc_iopol_to_tier</span>(<span class="enscript-type">int</span> iopolicy, <span class="enscript-type">int</span> *tier, <span class="enscript-type">int</span> *passive)
{
	*passive = 0;
	*tier = 0;
	<span class="enscript-keyword">switch</span> (iopolicy) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_IMPORTANT</span>:
			*tier = THROTTLE_LEVEL_TIER0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_PASSIVE</span>:
			*tier = THROTTLE_LEVEL_TIER0;
			*passive = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_STANDARD</span>:
			*tier = THROTTLE_LEVEL_TIER1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_UTILITY</span>:
			*tier = THROTTLE_LEVEL_TIER2;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_THROTTLE</span>:
			*tier = THROTTLE_LEVEL_TIER3;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;unknown I/O policy %d&quot;</span>, iopolicy);
			<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">proc_tier_to_iopol</span>(<span class="enscript-type">int</span> tier, <span class="enscript-type">int</span> passive)
{
	<span class="enscript-keyword">if</span> (passive == 1) {
		<span class="enscript-keyword">switch</span> (tier) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">THROTTLE_LEVEL_TIER0</span>:
				<span class="enscript-keyword">return</span> IOPOL_PASSIVE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				panic(<span class="enscript-string">&quot;unknown passive tier %d&quot;</span>, tier);
				<span class="enscript-keyword">return</span> IOPOL_DEFAULT;
				<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">switch</span> (tier) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">THROTTLE_LEVEL_NONE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">THROTTLE_LEVEL_TIER0</span>:
				<span class="enscript-keyword">return</span> IOPOL_DEFAULT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">THROTTLE_LEVEL_TIER1</span>:
				<span class="enscript-keyword">return</span> IOPOL_STANDARD;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">THROTTLE_LEVEL_TIER2</span>:
				<span class="enscript-keyword">return</span> IOPOL_UTILITY;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">THROTTLE_LEVEL_TIER3</span>:
				<span class="enscript-keyword">return</span> IOPOL_THROTTLE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				panic(<span class="enscript-string">&quot;unknown tier %d&quot;</span>, tier);
				<span class="enscript-keyword">return</span> IOPOL_DEFAULT;
				<span class="enscript-keyword">break</span>;
		}
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_darwin_role_to_task_role</span>(<span class="enscript-type">int</span> darwin_role, <span class="enscript-type">int</span>* task_role)
{
	integer_t role = TASK_UNSPECIFIED;

	<span class="enscript-keyword">switch</span> (darwin_role) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_ROLE_DEFAULT</span>:
			role = TASK_UNSPECIFIED;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_ROLE_UI_FOCAL</span>:
			role = TASK_FOREGROUND_APPLICATION;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_ROLE_UI</span>:
			role = TASK_DEFAULT_APPLICATION;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_ROLE_NON_UI</span>:
			role = TASK_NONUI_APPLICATION;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_ROLE_UI_NON_FOCAL</span>:
			role = TASK_BACKGROUND_APPLICATION;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_ROLE_TAL_LAUNCH</span>:
			role = TASK_THROTTLE_APPLICATION;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> EINVAL;
	}

	*task_role = role;

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_task_role_to_darwin_role</span>(<span class="enscript-type">int</span> task_role)
{
	<span class="enscript-keyword">switch</span> (task_role) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_FOREGROUND_APPLICATION</span>:
			<span class="enscript-keyword">return</span> PRIO_DARWIN_ROLE_UI_FOCAL;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_BACKGROUND_APPLICATION</span>:
			<span class="enscript-keyword">return</span> PRIO_DARWIN_ROLE_UI;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_NONUI_APPLICATION</span>:
			<span class="enscript-keyword">return</span> PRIO_DARWIN_ROLE_NON_UI;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_DEFAULT_APPLICATION</span>:
			<span class="enscript-keyword">return</span> PRIO_DARWIN_ROLE_UI_NON_FOCAL;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_THROTTLE_APPLICATION</span>:
			<span class="enscript-keyword">return</span> PRIO_DARWIN_ROLE_TAL_LAUNCH;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_UNSPECIFIED</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> PRIO_DARWIN_ROLE_DEFAULT;
	}
}


<span class="enscript-comment">/* apply internal backgrounding for workqueue threads */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_apply_workq_bgthreadpolicy</span>(thread_t thread)
{
	<span class="enscript-keyword">if</span> (thread == THREAD_NULL)
		<span class="enscript-keyword">return</span> ESRCH;

	proc_set_task_policy(thread-&gt;task, thread, TASK_POLICY_ATTRIBUTE,
	                     TASK_POLICY_WORKQ_BG, TASK_POLICY_ENABLE);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * remove internal backgrounding for workqueue threads
 * does NOT go find sockets created while BG and unbackground them
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_restore_workq_bgthreadpolicy</span>(thread_t thread)
{
	<span class="enscript-keyword">if</span> (thread == THREAD_NULL)
		<span class="enscript-keyword">return</span> ESRCH;

	proc_set_task_policy(thread-&gt;task, thread, TASK_POLICY_ATTRIBUTE,
	                     TASK_POLICY_WORKQ_BG, TASK_POLICY_DISABLE);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/* here for temporary compatibility */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_setthread_saved_importance</span>(__unused thread_t thread, __unused <span class="enscript-type">int</span> importance)
{
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Set an override on the thread which is consulted with a
 * higher priority than the task/thread policy. This should
 * only be set for temporary grants until the thread
 * returns to the userspace boundary
 *
 * We use atomic operations to swap in the override, with
 * the assumption that the thread itself can
 * read the override and clear it on return to userspace.
 *
 * No locking is performed, since it is acceptable to see
 * a stale override for one loop through throttle_lowpri_io().
 * However a thread reference must be held on the thread.
 */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">set_thread_iotier_override</span>(thread_t thread, <span class="enscript-type">int</span> policy)
{
	<span class="enscript-type">int</span> current_override;

	<span class="enscript-comment">/* Let most aggressive I/O policy win until user boundary */</span>
	<span class="enscript-keyword">do</span> {
		current_override = thread-&gt;iotier_override;

		<span class="enscript-keyword">if</span> (current_override != THROTTLE_LEVEL_NONE)
			policy = MIN(current_override, policy);

		<span class="enscript-keyword">if</span> (current_override == policy) {
			<span class="enscript-comment">/* no effective change */</span>
			<span class="enscript-keyword">return</span>;
		}
	} <span class="enscript-keyword">while</span> (!OSCompareAndSwap(current_override, policy, &amp;thread-&gt;iotier_override));

	<span class="enscript-comment">/*
	 * Since the thread may be currently throttled,
	 * re-evaluate tiers and potentially break out
	 * of an msleep
	 */</span>
	rethrottle_thread(thread-&gt;uthread);
}

<span class="enscript-comment">/*
 * Userspace synchronization routines (like pthread mutexes, pthread reader-writer locks,
 * semaphores, dispatch_sync) may result in priority inversions where a higher priority
 * (i.e. scheduler priority, I/O tier, QoS tier) is waiting on a resource owned by a lower
 * priority thread. In these cases, we attempt to propagate the priority token, as long
 * as the subsystem informs us of the relationships between the threads. The userspace
 * synchronization subsystem should maintain the information of owner-&gt;resource and
 * resource-&gt;waiters itself.
 */</span>

<span class="enscript-comment">/*
 * This helper canonicalizes the resource/resource_type given the current qos_override_mode
 * in effect. Note that wildcards (THREAD_QOS_OVERRIDE_RESOURCE_WILDCARD) may need
 * to be handled specially in the future, but for now it's fine to slam
 * *resource to USER_ADDR_NULL even if it was previously a wildcard.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">_canonicalize_resource_and_type</span>(user_addr_t *resource, <span class="enscript-type">int</span> *resource_type) {
	<span class="enscript-keyword">if</span> (qos_override_mode == QOS_OVERRIDE_MODE_OVERHANG_PEAK || qos_override_mode == QOS_OVERRIDE_MODE_IGNORE_OVERRIDE) {
		<span class="enscript-comment">/* Map all input resource/type to a single one */</span>
		*resource = USER_ADDR_NULL;
		*resource_type = THREAD_QOS_OVERRIDE_TYPE_UNKNOWN;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (qos_override_mode == QOS_OVERRIDE_MODE_FINE_GRAINED_OVERRIDE) {
		<span class="enscript-comment">/* no transform */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (qos_override_mode == QOS_OVERRIDE_MODE_FINE_GRAINED_OVERRIDE_BUT_IGNORE_DISPATCH) {
		<span class="enscript-comment">/* Map all dispatch overrides to a single one, to avoid memory overhead */</span>
		<span class="enscript-keyword">if</span> (*resource_type == THREAD_QOS_OVERRIDE_TYPE_DISPATCH_ASYNCHRONOUS_OVERRIDE) {
			*resource = USER_ADDR_NULL;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (qos_override_mode == QOS_OVERRIDE_MODE_FINE_GRAINED_OVERRIDE_BUT_SINGLE_MUTEX_OVERRIDE) {
		<span class="enscript-comment">/* Map all mutex overrides to a single one, to avoid memory overhead */</span>
		<span class="enscript-keyword">if</span> (*resource_type == THREAD_QOS_OVERRIDE_TYPE_PTHREAD_MUTEX) {
			*resource = USER_ADDR_NULL;
		}
	}
}

<span class="enscript-comment">/* This helper routine finds an existing override if known. Locking should be done by caller */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> thread_qos_override *<span class="enscript-function-name">_find_qos_override</span>(thread_t thread, user_addr_t resource, <span class="enscript-type">int</span> resource_type) {
	<span class="enscript-type">struct</span> thread_qos_override *override;

	override = thread-&gt;overrides;
	<span class="enscript-keyword">while</span> (override) {
		<span class="enscript-keyword">if</span> (override-&gt;override_resource == resource &amp;&amp;
			override-&gt;override_resource_type == resource_type) {
			<span class="enscript-keyword">return</span> override;
		}
		
		override = override-&gt;override_next;
	}

	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">_find_and_decrement_qos_override</span>(thread_t thread, user_addr_t resource, <span class="enscript-type">int</span> resource_type, boolean_t reset, <span class="enscript-type">struct</span> thread_qos_override **free_override_list) {
	<span class="enscript-type">struct</span> thread_qos_override *override, *override_prev;

	override_prev = NULL;
	override = thread-&gt;overrides;
	<span class="enscript-keyword">while</span> (override) {
		<span class="enscript-type">struct</span> thread_qos_override *override_next = override-&gt;override_next;

		<span class="enscript-keyword">if</span> ((THREAD_QOS_OVERRIDE_RESOURCE_WILDCARD == resource || override-&gt;override_resource == resource) &amp;&amp;
			override-&gt;override_resource_type == resource_type) {
			<span class="enscript-keyword">if</span> (reset) {
				override-&gt;override_contended_resource_count = 0;
			} <span class="enscript-keyword">else</span> {
				override-&gt;override_contended_resource_count--;
			}

			<span class="enscript-keyword">if</span> (override-&gt;override_contended_resource_count == 0) {
				<span class="enscript-keyword">if</span> (override_prev == NULL) {
					thread-&gt;overrides = override_next;
				} <span class="enscript-keyword">else</span> {
					override_prev-&gt;override_next = override_next;
				}
				
				<span class="enscript-comment">/* Add to out-param for later zfree */</span>
				override-&gt;override_next = *free_override_list;
				*free_override_list = override;
			} <span class="enscript-keyword">else</span> {
				override_prev = override;
			}

			<span class="enscript-keyword">if</span> (THREAD_QOS_OVERRIDE_RESOURCE_WILDCARD != resource) {
				<span class="enscript-keyword">return</span>;
			}
		} <span class="enscript-keyword">else</span> {
			override_prev = override;
		}
		
		override = override_next;
	}
}

<span class="enscript-comment">/* This helper recalculates the current requested override using the policy selected at boot */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">_calculate_requested_qos_override</span>(thread_t thread)
{
	<span class="enscript-keyword">if</span> (qos_override_mode == QOS_OVERRIDE_MODE_IGNORE_OVERRIDE) {
		<span class="enscript-keyword">return</span> THREAD_QOS_UNSPECIFIED;
	}

	<span class="enscript-comment">/* iterate over all overrides and calculate MAX */</span>
	<span class="enscript-type">struct</span> thread_qos_override *override;
	<span class="enscript-type">int</span> qos_override = THREAD_QOS_UNSPECIFIED;

	override = thread-&gt;overrides;
	<span class="enscript-keyword">while</span> (override) {
		<span class="enscript-keyword">if</span> (qos_override_mode != QOS_OVERRIDE_MODE_FINE_GRAINED_OVERRIDE_BUT_IGNORE_DISPATCH ||
			override-&gt;override_resource_type != THREAD_QOS_OVERRIDE_TYPE_DISPATCH_ASYNCHRONOUS_OVERRIDE) {
			qos_override = MAX(qos_override, override-&gt;override_qos);
		}
		
		override = override-&gt;override_next;
	}

	<span class="enscript-keyword">return</span> qos_override;
}

boolean_t <span class="enscript-function-name">proc_thread_qos_add_override</span>(task_t task, thread_t thread, uint64_t tid, <span class="enscript-type">int</span> override_qos, boolean_t first_override_for_resource, user_addr_t resource, <span class="enscript-type">int</span> resource_type)
{
	thread_t	self = current_thread();
	<span class="enscript-type">struct</span> task_pend_token pend_token = {};

	<span class="enscript-comment">/* XXX move to thread mutex when thread policy does */</span>
	task_lock(task);

	<span class="enscript-comment">/*
	 * If thread is passed, it is assumed to be most accurate, since the caller must have an explicit (or implicit) reference
	 * to the thread
	 */</span>
	
	<span class="enscript-keyword">if</span> (thread != THREAD_NULL) {
		assert(task == thread-&gt;task);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (tid == self-&gt;thread_id) {
			thread = self;
		} <span class="enscript-keyword">else</span> {
			thread = task_findtid(task, tid);

			<span class="enscript-keyword">if</span> (thread == THREAD_NULL) {
				KERNEL_DEBUG_CONSTANT((IMPORTANCE_CODE(IMP_USYNCH_QOS_OVERRIDE, IMP_USYNCH_ADD_OVERRIDE)) | DBG_FUNC_NONE,
									  tid, 0, 0xdead, 0, 0);
				task_unlock(task);
				<span class="enscript-keyword">return</span> FALSE;
			}
		}
	}

	KERNEL_DEBUG_CONSTANT((IMPORTANCE_CODE(IMP_USYNCH_QOS_OVERRIDE, IMP_USYNCH_ADD_OVERRIDE)) | DBG_FUNC_START,
						  thread_tid(thread), override_qos, first_override_for_resource ? 1 : 0, 0, 0);

	DTRACE_BOOST5(qos_add_override_pre, uint64_t, tid, uint64_t, thread-&gt;requested_policy.thrp_qos,
		uint64_t, thread-&gt;effective_policy.thep_qos, <span class="enscript-type">int</span>, override_qos, boolean_t, first_override_for_resource);

	<span class="enscript-type">struct</span> task_requested_policy requested = thread-&gt;requested_policy;
	<span class="enscript-type">struct</span> thread_qos_override *override;
	<span class="enscript-type">struct</span> thread_qos_override *deferred_free_override = NULL;
	<span class="enscript-type">int</span> new_qos_override, prev_qos_override;
	<span class="enscript-type">int</span> new_effective_qos;
	boolean_t has_thread_reference = FALSE;

	_canonicalize_resource_and_type(&amp;resource, &amp;resource_type);

	<span class="enscript-keyword">if</span> (first_override_for_resource) {
		override = _find_qos_override(thread, resource, resource_type);
		<span class="enscript-keyword">if</span> (override) {
			override-&gt;override_contended_resource_count++;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> thread_qos_override *override_new;

			<span class="enscript-comment">/* We need to allocate a new object. Drop the task lock and recheck afterwards in case someone else added the override */</span>
			thread_reference(thread);
			has_thread_reference = TRUE;
			task_unlock(task);
			override_new = zalloc(thread_qos_override_zone);
			task_lock(task);

			override = _find_qos_override(thread, resource, resource_type);
			<span class="enscript-keyword">if</span> (override) {
				<span class="enscript-comment">/* Someone else already allocated while the task lock was dropped */</span>
				deferred_free_override = override_new;
				override-&gt;override_contended_resource_count++;
			} <span class="enscript-keyword">else</span> {
				override = override_new;
				override-&gt;override_next = thread-&gt;overrides;
				override-&gt;override_contended_resource_count = 1 <span class="enscript-comment">/* since first_override_for_resource was TRUE */</span>;
				override-&gt;override_resource = resource;
				override-&gt;override_resource_type = resource_type;
				override-&gt;override_qos = THREAD_QOS_UNSPECIFIED;
				thread-&gt;overrides = override;
			}
		}
	} <span class="enscript-keyword">else</span> {
		override = _find_qos_override(thread, resource, resource_type);
	}

	<span class="enscript-keyword">if</span> (override) {
		<span class="enscript-keyword">if</span> (override-&gt;override_qos == THREAD_QOS_UNSPECIFIED)
			override-&gt;override_qos = override_qos;
		<span class="enscript-keyword">else</span>
			override-&gt;override_qos = MAX(override-&gt;override_qos, override_qos);
	}

	<span class="enscript-comment">/* Determine how to combine the various overrides into a single current requested override */</span>
	prev_qos_override = requested.thrp_qos_override;
	new_qos_override = _calculate_requested_qos_override(thread);

	<span class="enscript-keyword">if</span> (new_qos_override != prev_qos_override) {
		requested.thrp_qos_override = new_qos_override;

		thread-&gt;requested_policy = requested;

		task_policy_update_locked(task, thread, &amp;pend_token);
		
		<span class="enscript-keyword">if</span> (!has_thread_reference) {
			thread_reference(thread);
		}
		
		task_unlock(task);
		
		task_policy_update_complete_unlocked(task, thread, &amp;pend_token);

		new_effective_qos = thread-&gt;effective_policy.thep_qos;
		
		thread_deallocate(thread);
	} <span class="enscript-keyword">else</span> {
		new_effective_qos = thread-&gt;effective_policy.thep_qos;

		task_unlock(task);

		<span class="enscript-keyword">if</span> (has_thread_reference) {
			thread_deallocate(thread);
		}
	}

	<span class="enscript-keyword">if</span> (deferred_free_override) {
		zfree(thread_qos_override_zone, deferred_free_override);
	}

	DTRACE_BOOST3(qos_add_override_post, <span class="enscript-type">int</span>, prev_qos_override, <span class="enscript-type">int</span>, new_qos_override,
				  <span class="enscript-type">int</span>, new_effective_qos);

	KERNEL_DEBUG_CONSTANT((IMPORTANCE_CODE(IMP_USYNCH_QOS_OVERRIDE, IMP_USYNCH_ADD_OVERRIDE)) | DBG_FUNC_END,
						  new_qos_override, resource, resource_type, 0, 0);

	<span class="enscript-keyword">return</span> TRUE;
}


<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">_proc_thread_qos_remove_override_internal</span>(task_t task, thread_t thread, uint64_t tid, user_addr_t resource, <span class="enscript-type">int</span> resource_type, boolean_t reset)
{
	thread_t	self = current_thread();
	<span class="enscript-type">struct</span> task_pend_token pend_token = {};

	<span class="enscript-comment">/* XXX move to thread mutex when thread policy does */</span>
	task_lock(task);

	<span class="enscript-comment">/*
	 * If thread is passed, it is assumed to be most accurate, since the caller must have an explicit (or implicit) reference
	 * to the thread
	 */</span>
	<span class="enscript-keyword">if</span> (thread != THREAD_NULL) {
		assert(task == thread-&gt;task);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (tid == self-&gt;thread_id) {
			thread = self;
		} <span class="enscript-keyword">else</span> {
			thread = task_findtid(task, tid);

			<span class="enscript-keyword">if</span> (thread == THREAD_NULL) {
				KERNEL_DEBUG_CONSTANT((IMPORTANCE_CODE(IMP_USYNCH_QOS_OVERRIDE, IMP_USYNCH_REMOVE_OVERRIDE)) | DBG_FUNC_NONE,
									  tid, 0, 0xdead, 0, 0);
				task_unlock(task);
				<span class="enscript-keyword">return</span> FALSE;
			}
		}
	}

	<span class="enscript-type">struct</span> task_requested_policy requested = thread-&gt;requested_policy;
	<span class="enscript-type">struct</span> thread_qos_override *deferred_free_override_list = NULL;
	<span class="enscript-type">int</span> new_qos_override, prev_qos_override;

	_canonicalize_resource_and_type(&amp;resource, &amp;resource_type);

	_find_and_decrement_qos_override(thread, resource, resource_type, reset, &amp;deferred_free_override_list);

	KERNEL_DEBUG_CONSTANT((IMPORTANCE_CODE(IMP_USYNCH_QOS_OVERRIDE, IMP_USYNCH_REMOVE_OVERRIDE)) | DBG_FUNC_START,
						  thread_tid(thread), resource, reset, 0, 0);

	<span class="enscript-comment">/* Determine how to combine the various overrides into a single current requested override */</span>
	prev_qos_override = requested.thrp_qos_override;
	new_qos_override = _calculate_requested_qos_override(thread);

	<span class="enscript-keyword">if</span> (new_qos_override != prev_qos_override) {
		requested.thrp_qos_override = new_qos_override;

		thread-&gt;requested_policy = requested;

		task_policy_update_locked(task, thread, &amp;pend_token);
		
		thread_reference(thread);
			
		task_unlock(task);
		
		task_policy_update_complete_unlocked(task, thread, &amp;pend_token);
		
		thread_deallocate(thread);
	} <span class="enscript-keyword">else</span> {
		task_unlock(task);
	}

	<span class="enscript-keyword">while</span> (deferred_free_override_list) {
		<span class="enscript-type">struct</span> thread_qos_override *override_next = deferred_free_override_list-&gt;override_next;
		
		zfree(thread_qos_override_zone, deferred_free_override_list);
		deferred_free_override_list = override_next;
	}

	KERNEL_DEBUG_CONSTANT((IMPORTANCE_CODE(IMP_USYNCH_QOS_OVERRIDE, IMP_USYNCH_REMOVE_OVERRIDE)) | DBG_FUNC_END,
						  0, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span> TRUE;
}

boolean_t <span class="enscript-function-name">proc_thread_qos_remove_override</span>(task_t task, thread_t thread, uint64_t tid, user_addr_t resource, <span class="enscript-type">int</span> resource_type)
{
	<span class="enscript-keyword">return</span> _proc_thread_qos_remove_override_internal(task, thread, tid, resource, resource_type, FALSE);

}

boolean_t <span class="enscript-function-name">proc_thread_qos_reset_override</span>(task_t task, thread_t thread, uint64_t tid, user_addr_t resource, <span class="enscript-type">int</span> resource_type)
{
	<span class="enscript-keyword">return</span> _proc_thread_qos_remove_override_internal(task, thread, tid, resource, resource_type, TRUE);
}

<span class="enscript-comment">/* Deallocate before thread termination */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_thread_qos_deallocate</span>(thread_t thread)
{
	task_t task = thread-&gt;task;
	<span class="enscript-type">struct</span> thread_qos_override *override;

	<span class="enscript-comment">/* XXX move to thread mutex when thread policy does */</span>
	task_lock(task);
	override = thread-&gt;overrides;
	thread-&gt;overrides = NULL; 		<span class="enscript-comment">/* task policy re-evaluation needed? */</span>
	thread-&gt;requested_policy.thrp_qos_override = THREAD_QOS_UNSPECIFIED;
	task_unlock(task);

	<span class="enscript-keyword">while</span> (override) {
		<span class="enscript-type">struct</span> thread_qos_override *override_next = override-&gt;override_next;
		
		zfree(thread_qos_override_zone, override);
		override = override_next;
	}
}

<span class="enscript-comment">/* TODO: remove this variable when interactive daemon audit period is over */</span>
<span class="enscript-type">extern</span> boolean_t ipc_importance_interactive_receiver;

<span class="enscript-comment">/*
 * Called at process exec to initialize the apptype, qos clamp, and qos seed of a process
 *
 * TODO: Make this function more table-driven instead of ad-hoc
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_set_task_spawnpolicy</span>(task_t task, <span class="enscript-type">int</span> apptype, <span class="enscript-type">int</span> qos_clamp, <span class="enscript-type">int</span> role,
                          ipc_port_t * portwatch_ports, <span class="enscript-type">int</span> portwatch_count)
{
	<span class="enscript-type">struct</span> task_pend_token pend_token = {};

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(IMP_TASK_APPTYPE, apptype)) | DBG_FUNC_START,
				  task_pid(task), trequested_0(task, THREAD_NULL), trequested_1(task, THREAD_NULL),
				  apptype, 0);

	<span class="enscript-keyword">switch</span> (apptype) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_APP_TAL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_APP_DEFAULT</span>:
			<span class="enscript-comment">/* Apps become donors via the 'live-donor' flag instead of the static donor flag */</span>
			task_importance_mark_donor(task, FALSE);
			task_importance_mark_live_donor(task, TRUE);
			task_importance_mark_receiver(task, FALSE);
			<span class="enscript-comment">/* Apps are de-nap recievers on desktop for suppression behaviors */</span>
			task_importance_mark_denap_receiver(task, TRUE);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_DAEMON_INTERACTIVE</span>:
			task_importance_mark_donor(task, TRUE);
			task_importance_mark_live_donor(task, FALSE);

			<span class="enscript-comment">/* 
			 * A boot arg controls whether interactive daemons are importance receivers.
			 * Normally, they are not.  But for testing their behavior as an adaptive
			 * daemon, the boot-arg can be set.
			 *
			 * TODO: remove this when the interactive daemon audit period is over.
			 */</span>
			task_importance_mark_receiver(task, <span class="enscript-comment">/* FALSE */</span> ipc_importance_interactive_receiver);
			task_importance_mark_denap_receiver(task, FALSE);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_DAEMON_STANDARD</span>:
			task_importance_mark_donor(task, TRUE);
			task_importance_mark_live_donor(task, FALSE);
			task_importance_mark_receiver(task, FALSE);
			task_importance_mark_denap_receiver(task, FALSE);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_DAEMON_ADAPTIVE</span>:
			task_importance_mark_donor(task, FALSE);
			task_importance_mark_live_donor(task, FALSE);
			task_importance_mark_receiver(task, TRUE);
			task_importance_mark_denap_receiver(task, FALSE);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_DAEMON_BACKGROUND</span>:
			task_importance_mark_donor(task, FALSE);
			task_importance_mark_live_donor(task, FALSE);
			task_importance_mark_receiver(task, FALSE);
			task_importance_mark_denap_receiver(task, FALSE);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_NONE</span>:
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (portwatch_ports != NULL &amp;&amp; apptype == TASK_APPTYPE_DAEMON_ADAPTIVE) {
		<span class="enscript-type">int</span> portwatch_boosts = 0;

		<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; portwatch_count; i++) {
			ipc_port_t port = NULL;

			<span class="enscript-keyword">if</span> ((port = portwatch_ports[i]) != NULL) {
				<span class="enscript-type">int</span> boost = 0;
				task_add_importance_watchport(task, port, &amp;boost);
				portwatch_boosts += boost;
			}
		}

		<span class="enscript-keyword">if</span> (portwatch_boosts &gt; 0) {
			task_importance_hold_internal_assertion(task, portwatch_boosts);
		}
	}

	task_lock(task);

	<span class="enscript-keyword">if</span> (apptype == TASK_APPTYPE_APP_TAL) {
		<span class="enscript-comment">/* TAL starts off enabled by default */</span>
		task-&gt;requested_policy.t_tal_enabled = 1;
	}

	<span class="enscript-keyword">if</span> (apptype != TASK_APPTYPE_NONE) {
		task-&gt;requested_policy.t_apptype = apptype;
	}

	<span class="enscript-keyword">if</span> (role != TASK_UNSPECIFIED) {
		task-&gt;requested_policy.t_role = role;
	}

	<span class="enscript-keyword">if</span> (qos_clamp != THREAD_QOS_UNSPECIFIED) {
		task-&gt;requested_policy.t_qos_clamp = qos_clamp;
	}

	task_policy_update_locked(task, THREAD_NULL, &amp;pend_token);

	task_unlock(task);

	<span class="enscript-comment">/* Ensure the donor bit is updated to be in sync with the new live donor status */</span>
	pend_token.tpt_update_live_donor = 1;

	task_policy_update_complete_unlocked(task, THREAD_NULL, &amp;pend_token);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				  (IMPORTANCE_CODE(IMP_TASK_APPTYPE, apptype)) | DBG_FUNC_END,
				  task_pid(task), trequested_0(task, THREAD_NULL), trequested_1(task, THREAD_NULL),
				  task_is_importance_receiver(task), 0);
}

<span class="enscript-type">extern</span> task_t bsd_init_task;

<span class="enscript-comment">/* Set up the primordial thread's QoS */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_set_main_thread_qos</span>(task_t task, thread_t main_thread) {
	<span class="enscript-type">struct</span> task_pend_token pend_token = {};

	assert(main_thread-&gt;task == task);

	task_lock(task);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
	                          (IMPORTANCE_CODE(IMP_MAIN_THREAD_QOS, 0)) | DBG_FUNC_START,
	                          task_pid(task), trequested_0(task, THREAD_NULL), trequested_1(task, THREAD_NULL),
	                          main_thread-&gt;requested_policy.thrp_qos, 0);

	<span class="enscript-type">int</span> primordial_qos = THREAD_QOS_UNSPECIFIED;

	<span class="enscript-type">int</span> qos_clamp = task-&gt;requested_policy.t_qos_clamp;

	<span class="enscript-keyword">if</span> (task == bsd_init_task) {
		<span class="enscript-comment">/* PID 1 gets a special case */</span>
		primordial_qos = THREAD_QOS_USER_INITIATED;
	}

	<span class="enscript-keyword">switch</span> (task-&gt;requested_policy.t_apptype) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_APP_TAL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_APP_DEFAULT</span>:
			primordial_qos = THREAD_QOS_USER_INTERACTIVE;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_DAEMON_INTERACTIVE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_DAEMON_STANDARD</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_DAEMON_ADAPTIVE</span>:
			primordial_qos = THREAD_QOS_LEGACY;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_APPTYPE_DAEMON_BACKGROUND</span>:
			primordial_qos = THREAD_QOS_BACKGROUND;
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (qos_clamp != THREAD_QOS_UNSPECIFIED) {
		<span class="enscript-keyword">if</span> (primordial_qos != THREAD_QOS_UNSPECIFIED) {
			primordial_qos = MIN(qos_clamp, primordial_qos);
		} <span class="enscript-keyword">else</span> {
			primordial_qos = qos_clamp;
		}
	}

	main_thread-&gt;requested_policy.thrp_qos = primordial_qos;

	task_policy_update_locked(task, main_thread, &amp;pend_token);

	task_unlock(task);

	task_policy_update_complete_unlocked(task, main_thread, &amp;pend_token);

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
	                          (IMPORTANCE_CODE(IMP_MAIN_THREAD_QOS, 0)) | DBG_FUNC_END,
	                          task_pid(task), trequested_0(task, THREAD_NULL), trequested_1(task, THREAD_NULL),
	                          primordial_qos, 0);
}

<span class="enscript-comment">/* for process_policy to check before attempting to set */</span>
boolean_t
<span class="enscript-function-name">proc_task_is_tal</span>(task_t task)
{
	<span class="enscript-keyword">return</span> (task-&gt;requested_policy.t_apptype == TASK_APPTYPE_APP_TAL) ? TRUE : FALSE;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">task_get_apptype</span>(task_t task)
{
	<span class="enscript-keyword">return</span> task-&gt;requested_policy.t_apptype;
}

<span class="enscript-comment">/* for telemetry */</span>
integer_t
<span class="enscript-function-name">task_grab_latency_qos</span>(task_t task)
{
	<span class="enscript-keyword">return</span> qos_latency_policy_package(proc_get_effective_task_policy(task, TASK_POLICY_LATENCY_QOS));
}

<span class="enscript-comment">/* update the darwin background action state in the flags field for libproc */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_get_darwinbgstate</span>(task_t task, uint32_t * flagsp)
{
	<span class="enscript-keyword">if</span> (task-&gt;requested_policy.ext_darwinbg)
		*flagsp |= PROC_FLAG_EXT_DARWINBG;

	<span class="enscript-keyword">if</span> (task-&gt;requested_policy.int_darwinbg)
		*flagsp |= PROC_FLAG_DARWINBG;


	<span class="enscript-keyword">if</span> (task-&gt;requested_policy.t_apptype == TASK_APPTYPE_APP_DEFAULT ||
	    task-&gt;requested_policy.t_apptype == TASK_APPTYPE_APP_TAL)
		*flagsp |= PROC_FLAG_APPLICATION;

	<span class="enscript-keyword">if</span> (task-&gt;requested_policy.t_apptype == TASK_APPTYPE_DAEMON_ADAPTIVE)
		*flagsp |= PROC_FLAG_ADAPTIVE;

	<span class="enscript-keyword">if</span> (task-&gt;requested_policy.t_apptype == TASK_APPTYPE_DAEMON_ADAPTIVE &amp;&amp; task-&gt;requested_policy.t_boosted == 1)
		*flagsp |= PROC_FLAG_ADAPTIVE_IMPORTANT;

	<span class="enscript-keyword">if</span> (task_is_importance_donor(task))
		*flagsp |= PROC_FLAG_IMPORTANCE_DONOR;

	<span class="enscript-keyword">if</span> (task-&gt;effective_policy.t_sup_active)
		*flagsp |= PROC_FLAG_SUPPRESSED;

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/* All per-thread state is in the first 32-bits of the bitfield */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_get_thread_policy</span>(thread_t thread, thread_policy_state_t info)
{
	task_t task = thread-&gt;task;
	task_lock(task);
	info-&gt;requested = (integer_t)task_requested_bitfield(task, thread);
	info-&gt;effective = (integer_t)task_effective_bitfield(task, thread);
	info-&gt;pending   = 0;
	task_unlock(task);
}

<span class="enscript-comment">/*
 * Tracepoint data... Reading the tracepoint data can be somewhat complicated.
 * The current scheme packs as much data into a single tracepoint as it can.
 *
 * Each task/thread requested/effective structure is 64 bits in size. Any
 * given tracepoint will emit either requested or effective data, but not both.
 *
 * A tracepoint may emit any of task, thread, or task &amp; thread data.
 * 
 * The type of data emitted varies with pointer size. Where possible, both
 * task and thread data are emitted. In LP32 systems, the first and second
 * halves of either the task or thread data is emitted.
 *
 * The code uses uintptr_t array indexes instead of high/low to avoid
 * confusion WRT big vs little endian.
 *
 * The truth table for the tracepoint data functions is below, and has the
 * following invariants:
 *
 * 1) task and thread are uintptr_t*
 * 2) task may never be NULL
 *
 *
 *                                     LP32            LP64
 * trequested_0(task, NULL)            task[0]         task[0]
 * trequested_1(task, NULL)            task[1]         NULL
 * trequested_0(task, thread)          thread[0]       task[0]
 * trequested_1(task, thread)          thread[1]       thread[0]
 *
 * Basically, you get a full task or thread on LP32, and both on LP64.
 *
 * The uintptr_t munging here is squicky enough to deserve a comment.
 *
 * The variables we are accessing are laid out in memory like this:
 *
 * [            LP64 uintptr_t  0          ]
 * [ LP32 uintptr_t 0 ] [ LP32 uintptr_t 1 ]
 *
 *      1   2   3   4     5   6   7   8
 *
 */</span>

<span class="enscript-type">static</span> uintptr_t
<span class="enscript-function-name">trequested_0</span>(task_t task, thread_t thread)
{
	assert(task);
	_Static_assert(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> task_requested_policy) == <span class="enscript-keyword">sizeof</span>(uint64_t), <span class="enscript-string">&quot;size invariant violated&quot;</span>);
	_Static_assert(<span class="enscript-keyword">sizeof</span>(task-&gt;requested_policy) == <span class="enscript-keyword">sizeof</span>(thread-&gt;requested_policy), <span class="enscript-string">&quot;size invariant violated&quot;</span>);

	uintptr_t* raw = (uintptr_t*)((thread == THREAD_NULL) ? &amp;task-&gt;requested_policy : &amp;thread-&gt;requested_policy);
	<span class="enscript-keyword">return</span> raw[0];
}

<span class="enscript-type">static</span> uintptr_t
<span class="enscript-function-name">trequested_1</span>(task_t task, thread_t thread)
{
	assert(task);
	_Static_assert(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> task_requested_policy) == <span class="enscript-keyword">sizeof</span>(uint64_t), <span class="enscript-string">&quot;size invariant violated&quot;</span>);
	_Static_assert(<span class="enscript-keyword">sizeof</span>(task-&gt;requested_policy) == <span class="enscript-keyword">sizeof</span>(thread-&gt;requested_policy), <span class="enscript-string">&quot;size invariant violated&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-keyword">return</span> (thread == NULL) ? 0 : *(uintptr_t*)&amp;thread-&gt;requested_policy;
#<span class="enscript-reference">else</span>
	uintptr_t* raw = (uintptr_t*)((thread == THREAD_NULL) ? &amp;task-&gt;requested_policy : &amp;thread-&gt;requested_policy);
	<span class="enscript-keyword">return</span> raw[1];
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> uintptr_t
<span class="enscript-function-name">teffective_0</span>(task_t task, thread_t thread)
{
	assert(task);
	_Static_assert(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> task_effective_policy) == <span class="enscript-keyword">sizeof</span>(uint64_t), <span class="enscript-string">&quot;size invariant violated&quot;</span>);
	_Static_assert(<span class="enscript-keyword">sizeof</span>(task-&gt;effective_policy) == <span class="enscript-keyword">sizeof</span>(thread-&gt;effective_policy), <span class="enscript-string">&quot;size invariant violated&quot;</span>);

	uintptr_t* raw = (uintptr_t*)((thread == THREAD_NULL) ? &amp;task-&gt;effective_policy : &amp;thread-&gt;effective_policy);
	<span class="enscript-keyword">return</span> raw[0];
}

<span class="enscript-type">static</span> uintptr_t
<span class="enscript-function-name">teffective_1</span>(task_t task, thread_t thread)
{
	assert(task);
	_Static_assert(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> task_effective_policy) == <span class="enscript-keyword">sizeof</span>(uint64_t), <span class="enscript-string">&quot;size invariant violated&quot;</span>);
	_Static_assert(<span class="enscript-keyword">sizeof</span>(task-&gt;effective_policy) == <span class="enscript-keyword">sizeof</span>(thread-&gt;effective_policy), <span class="enscript-string">&quot;size invariant violated&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-keyword">return</span> (thread == NULL) ? 0 : *(uintptr_t*)&amp;thread-&gt;effective_policy;
#<span class="enscript-reference">else</span>
	uintptr_t* raw = (uintptr_t*)((thread == THREAD_NULL) ? &amp;task-&gt;effective_policy : &amp;thread-&gt;effective_policy);
	<span class="enscript-keyword">return</span> raw[1];
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/* dump pending for tracepoint */</span>
<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">tpending</span>(task_pend_token_t pend_token) { <span class="enscript-keyword">return</span> *(uint32_t*)(<span class="enscript-type">void</span>*)(pend_token); }

uint64_t
<span class="enscript-function-name">task_requested_bitfield</span>(task_t task, thread_t thread)
{
	uint64_t bits = 0;
	<span class="enscript-type">struct</span> task_requested_policy requested =
	        (thread == THREAD_NULL) ? task-&gt;requested_policy : thread-&gt;requested_policy;

	bits |= (requested.int_darwinbg         ? POLICY_REQ_INT_DARWIN_BG  : 0);
	bits |= (requested.ext_darwinbg         ? POLICY_REQ_EXT_DARWIN_BG  : 0);
	bits |= (requested.int_iotier           ? (((uint64_t)requested.int_iotier) &lt;&lt; POLICY_REQ_INT_IO_TIER_SHIFT) : 0);
	bits |= (requested.ext_iotier           ? (((uint64_t)requested.ext_iotier) &lt;&lt; POLICY_REQ_EXT_IO_TIER_SHIFT) : 0);
	bits |= (requested.int_iopassive        ? POLICY_REQ_INT_PASSIVE_IO : 0);
	bits |= (requested.ext_iopassive        ? POLICY_REQ_EXT_PASSIVE_IO : 0);
	bits |= (requested.bg_iotier            ? (((uint64_t)requested.bg_iotier)  &lt;&lt; POLICY_REQ_BG_IOTIER_SHIFT)   : 0);
	bits |= (requested.terminated           ? POLICY_REQ_TERMINATED     : 0);

	bits |= (requested.th_pidbind_bg        ? POLICY_REQ_PIDBIND_BG     : 0);
	bits |= (requested.th_workq_bg          ? POLICY_REQ_WORKQ_BG       : 0);

	<span class="enscript-keyword">if</span> (thread != THREAD_NULL) {
		bits |= (requested.thrp_qos     ? (((uint64_t)requested.thrp_qos)   &lt;&lt; POLICY_REQ_TH_QOS_SHIFT)  : 0);
		bits |= (requested.thrp_qos_override     ? (((uint64_t)requested.thrp_qos_override)   &lt;&lt; POLICY_REQ_TH_QOS_OVER_SHIFT)  : 0);
	}

	bits |= (requested.t_boosted            ? POLICY_REQ_BOOSTED        : 0);
	bits |= (requested.t_tal_enabled        ? POLICY_REQ_TAL_ENABLED    : 0);
	bits |= (requested.t_apptype            ? (((uint64_t)requested.t_apptype)    &lt;&lt; POLICY_REQ_APPTYPE_SHIFT)  : 0);
	bits |= (requested.t_role               ? (((uint64_t)requested.t_role)       &lt;&lt; POLICY_REQ_ROLE_SHIFT)     : 0);

	bits |= (requested.t_sup_active         ? POLICY_REQ_SUP_ACTIVE         : 0);
	bits |= (requested.t_sup_lowpri_cpu     ? POLICY_REQ_SUP_LOWPRI_CPU     : 0);
	bits |= (requested.t_sup_cpu            ? POLICY_REQ_SUP_CPU            : 0);
	bits |= (requested.t_sup_timer          ? (((uint64_t)requested.t_sup_timer)  &lt;&lt; POLICY_REQ_SUP_TIMER_THROTTLE_SHIFT) : 0);
	bits |= (requested.t_sup_throughput     ? (((uint64_t)requested.t_sup_throughput)   &lt;&lt; POLICY_REQ_SUP_THROUGHPUT_SHIFT)   : 0);
	bits |= (requested.t_sup_disk           ? POLICY_REQ_SUP_DISK_THROTTLE  : 0);
	bits |= (requested.t_sup_cpu_limit      ? POLICY_REQ_SUP_CPU_LIMIT      : 0);
	bits |= (requested.t_sup_suspend        ? POLICY_REQ_SUP_SUSPEND        : 0);
	bits |= (requested.t_sup_bg_sockets     ? POLICY_REQ_SUP_BG_SOCKETS     : 0);
	bits |= (requested.t_base_latency_qos   ? (((uint64_t)requested.t_base_latency_qos) &lt;&lt; POLICY_REQ_BASE_LATENCY_QOS_SHIFT) : 0);
	bits |= (requested.t_over_latency_qos   ? (((uint64_t)requested.t_over_latency_qos) &lt;&lt; POLICY_REQ_OVER_LATENCY_QOS_SHIFT) : 0);
	bits |= (requested.t_base_through_qos   ? (((uint64_t)requested.t_base_through_qos) &lt;&lt; POLICY_REQ_BASE_THROUGH_QOS_SHIFT) : 0);
	bits |= (requested.t_over_through_qos   ? (((uint64_t)requested.t_over_through_qos) &lt;&lt; POLICY_REQ_OVER_THROUGH_QOS_SHIFT) : 0);
	bits |= (requested.t_sfi_managed        ? POLICY_REQ_SFI_MANAGED        : 0);
	bits |= (requested.t_qos_clamp          ? (((uint64_t)requested.t_qos_clamp)        &lt;&lt; POLICY_REQ_QOS_CLAMP_SHIFT)        : 0);

	<span class="enscript-keyword">return</span> bits;
}

uint64_t
<span class="enscript-function-name">task_effective_bitfield</span>(task_t task, thread_t thread)
{
	uint64_t bits = 0;
	<span class="enscript-type">struct</span> task_effective_policy effective =
	        (thread == THREAD_NULL) ? task-&gt;effective_policy : thread-&gt;effective_policy;

	bits |= (effective.io_tier              ? (((uint64_t)effective.io_tier) &lt;&lt; POLICY_EFF_IO_TIER_SHIFT) : 0);
	bits |= (effective.io_passive           ? POLICY_EFF_IO_PASSIVE     : 0);
	bits |= (effective.darwinbg             ? POLICY_EFF_DARWIN_BG      : 0);
	bits |= (effective.lowpri_cpu           ? POLICY_EFF_LOWPRI_CPU     : 0);
	bits |= (effective.terminated           ? POLICY_EFF_TERMINATED     : 0);
	bits |= (effective.all_sockets_bg       ? POLICY_EFF_ALL_SOCKETS_BG : 0);
	bits |= (effective.new_sockets_bg       ? POLICY_EFF_NEW_SOCKETS_BG : 0);
	bits |= (effective.bg_iotier            ? (((uint64_t)effective.bg_iotier) &lt;&lt; POLICY_EFF_BG_IOTIER_SHIFT) : 0);
	bits |= (effective.qos_ui_is_urgent     ? POLICY_EFF_QOS_UI_IS_URGENT : 0);

	<span class="enscript-keyword">if</span> (thread != THREAD_NULL)
		bits |= (effective.thep_qos     ? (((uint64_t)effective.thep_qos)   &lt;&lt; POLICY_EFF_TH_QOS_SHIFT)  : 0);

	bits |= (effective.t_tal_engaged        ? POLICY_EFF_TAL_ENGAGED    : 0);
	bits |= (effective.t_suspended          ? POLICY_EFF_SUSPENDED      : 0);
	bits |= (effective.t_watchers_bg        ? POLICY_EFF_WATCHERS_BG    : 0);
	bits |= (effective.t_sup_active         ? POLICY_EFF_SUP_ACTIVE     : 0);
	bits |= (effective.t_suppressed_cpu     ? POLICY_EFF_SUP_CPU        : 0);
	bits |= (effective.t_role               ? (((uint64_t)effective.t_role)        &lt;&lt; POLICY_EFF_ROLE_SHIFT)        : 0);
	bits |= (effective.t_latency_qos        ? (((uint64_t)effective.t_latency_qos) &lt;&lt; POLICY_EFF_LATENCY_QOS_SHIFT) : 0);
	bits |= (effective.t_through_qos        ? (((uint64_t)effective.t_through_qos) &lt;&lt; POLICY_EFF_THROUGH_QOS_SHIFT) : 0);
	bits |= (effective.t_sfi_managed        ? POLICY_EFF_SFI_MANAGED    : 0);
	bits |= (effective.t_qos_ceiling        ? (((uint64_t)effective.t_qos_ceiling) &lt;&lt; POLICY_EFF_QOS_CEILING_SHIFT) : 0);

	<span class="enscript-keyword">return</span> bits;
}


<span class="enscript-comment">/*
 * Resource usage and CPU related routines
 */</span>

<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_get_task_ruse_cpu</span>(task_t task, uint32_t *policyp, uint8_t *percentagep, uint64_t *intervalp, uint64_t *deadlinep)
{
	
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> scope;

	task_lock(task);

	
	error = task_get_cpuusage(task, percentagep, intervalp, deadlinep, &amp;scope);
	task_unlock(task);

	<span class="enscript-comment">/*
	 * Reverse-map from CPU resource limit scopes back to policies (see comment below).
	 */</span>
	<span class="enscript-keyword">if</span> (scope == TASK_RUSECPU_FLAGS_PERTHR_LIMIT) {
		*policyp = TASK_POLICY_RESOURCE_ATTRIBUTE_NOTIFY_EXC;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (scope == TASK_RUSECPU_FLAGS_PROC_LIMIT) {
		*policyp = TASK_POLICY_RESOURCE_ATTRIBUTE_THROTTLE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (scope == TASK_RUSECPU_FLAGS_DEADLINE) {
		*policyp = TASK_POLICY_RESOURCE_ATTRIBUTE_NONE;
	}

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Configure the default CPU usage monitor parameters.
 *
 * For tasks which have this mechanism activated: if any thread in the
 * process consumes more CPU than this, an EXC_RESOURCE exception will be generated.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_init_cpumon_params</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * The max CPU percentage can be configured via the boot-args and
	 * a key in the device tree. The boot-args are honored first, then the
	 * device tree.
	 */</span>
	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;max_cpumon_percentage&quot;</span>, &amp;proc_max_cpumon_percentage,
		<span class="enscript-keyword">sizeof</span> (proc_max_cpumon_percentage)))
	{
		uint64_t max_percentage = 0ULL;

		<span class="enscript-keyword">if</span> (!PE_get_default(<span class="enscript-string">&quot;kern.max_cpumon_percentage&quot;</span>, &amp;max_percentage,
			<span class="enscript-keyword">sizeof</span>(max_percentage)))
		{
			max_percentage = DEFAULT_CPUMON_PERCENTAGE;
		}

		assert(max_percentage &lt;= UINT8_MAX);
		proc_max_cpumon_percentage = (uint8_t) max_percentage;
	}

	<span class="enscript-keyword">if</span> (proc_max_cpumon_percentage &gt; 100) {
		proc_max_cpumon_percentage = 100;
	}

	<span class="enscript-comment">/*
	 * The interval should be specified in seconds.
	 *
	 * Like the max CPU percentage, the max CPU interval can be configured
	 * via boot-args and the device tree.
	 */</span>
	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;max_cpumon_interval&quot;</span>, &amp;proc_max_cpumon_interval,
		<span class="enscript-keyword">sizeof</span> (proc_max_cpumon_interval)))
	{
		<span class="enscript-keyword">if</span> (!PE_get_default(<span class="enscript-string">&quot;kern.max_cpumon_interval&quot;</span>, &amp;proc_max_cpumon_interval,
			<span class="enscript-keyword">sizeof</span>(proc_max_cpumon_interval)))
		{
			proc_max_cpumon_interval = DEFAULT_CPUMON_INTERVAL;
		}
	}

	proc_max_cpumon_interval *= NSEC_PER_SEC;

	<span class="enscript-comment">/* TEMPORARY boot arg to control App suppression */</span>
	PE_parse_boot_argn(<span class="enscript-string">&quot;task_policy_suppression_disable&quot;</span>,
			   &amp;task_policy_suppression_disable,
			   <span class="enscript-keyword">sizeof</span>(task_policy_suppression_disable));
}

<span class="enscript-comment">/*
 * Currently supported configurations for CPU limits.
 *
 * Policy				| Deadline-based CPU limit | Percentage-based CPU limit
 * -------------------------------------+--------------------------+------------------------------
 * PROC_POLICY_RSRCACT_THROTTLE		| ENOTSUP		   | Task-wide scope only
 * PROC_POLICY_RSRCACT_SUSPEND		| Task-wide scope only	   | ENOTSUP
 * PROC_POLICY_RSRCACT_TERMINATE	| Task-wide scope only	   | ENOTSUP
 * PROC_POLICY_RSRCACT_NOTIFY_KQ	| Task-wide scope only	   | ENOTSUP
 * PROC_POLICY_RSRCACT_NOTIFY_EXC	| ENOTSUP		   | Per-thread scope only
 *
 * A deadline-based CPU limit is actually a simple wallclock timer - the requested action is performed
 * after the specified amount of wallclock time has elapsed.
 *
 * A percentage-based CPU limit performs the requested action after the specified amount of actual CPU time
 * has been consumed -- regardless of how much wallclock time has elapsed -- by either the task as an
 * aggregate entity (so-called &quot;Task-wide&quot; or &quot;Proc-wide&quot; scope, whereby the CPU time consumed by all threads
 * in the task are added together), or by any one thread in the task (so-called &quot;per-thread&quot; scope).
 *
 * We support either deadline != 0 OR percentage != 0, but not both. The original intention in having them
 * share an API was to use actual CPU time as the basis of the deadline-based limit (as in: perform an action
 * after I have used some amount of CPU time; this is different than the recurring percentage/interval model)
 * but the potential consumer of the API at the time was insisting on wallclock time instead.
 *
 * Currently, requesting notification via an exception is the only way to get per-thread scope for a
 * CPU limit. All other types of notifications force task-wide scope for the limit.
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_set_task_ruse_cpu</span>(task_t task, uint32_t policy, uint8_t percentage, uint64_t interval, uint64_t deadline,
	<span class="enscript-type">int</span> cpumon_entitled)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> scope;

 	<span class="enscript-comment">/*
 	 * Enforce the matrix of supported configurations for policy, percentage, and deadline.
 	 */</span>
 	<span class="enscript-keyword">switch</span> (policy) {
 	<span class="enscript-comment">// If no policy is explicitly given, the default is to throttle.
</span> 	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_RESOURCE_ATTRIBUTE_NONE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_RESOURCE_ATTRIBUTE_THROTTLE</span>:
		<span class="enscript-keyword">if</span> (deadline != 0)
			<span class="enscript-keyword">return</span> (ENOTSUP);
		scope = TASK_RUSECPU_FLAGS_PROC_LIMIT;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_RESOURCE_ATTRIBUTE_SUSPEND</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_RESOURCE_ATTRIBUTE_TERMINATE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_RESOURCE_ATTRIBUTE_NOTIFY_KQ</span>:
		<span class="enscript-keyword">if</span> (percentage != 0)
			<span class="enscript-keyword">return</span> (ENOTSUP);
		scope = TASK_RUSECPU_FLAGS_DEADLINE;
		<span class="enscript-keyword">break</span>;
 	<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_RESOURCE_ATTRIBUTE_NOTIFY_EXC</span>:
		<span class="enscript-keyword">if</span> (deadline != 0)
			<span class="enscript-keyword">return</span> (ENOTSUP);
		scope = TASK_RUSECPU_FLAGS_PERTHR_LIMIT;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_NOMONITORS</span>
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_NOMONITORS */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	task_lock(task);
	<span class="enscript-keyword">if</span> (task != current_task()) {
		task-&gt;policy_ru_cpu_ext = policy;
	} <span class="enscript-keyword">else</span> {
		task-&gt;policy_ru_cpu = policy;
	}
	error = task_set_cpuusage(task, percentage, interval, deadline, scope, cpumon_entitled);
	task_unlock(task);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_clear_task_ruse_cpu</span>(task_t task, <span class="enscript-type">int</span> cpumon_entitled)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> action;
	<span class="enscript-type">void</span> * bsdinfo = NULL;

	task_lock(task);
	<span class="enscript-keyword">if</span> (task != current_task()) {
		task-&gt;policy_ru_cpu_ext = TASK_POLICY_RESOURCE_ATTRIBUTE_DEFAULT;
	} <span class="enscript-keyword">else</span> {
		task-&gt;policy_ru_cpu = TASK_POLICY_RESOURCE_ATTRIBUTE_DEFAULT;
	}

	error = task_clear_cpuusage_locked(task, cpumon_entitled);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;	

	action = task-&gt;applied_ru_cpu;
	<span class="enscript-keyword">if</span> (task-&gt;applied_ru_cpu_ext != TASK_POLICY_RESOURCE_ATTRIBUTE_NONE) {
		<span class="enscript-comment">/* reset action */</span>
		task-&gt;applied_ru_cpu_ext = TASK_POLICY_RESOURCE_ATTRIBUTE_NONE;
	}
	<span class="enscript-keyword">if</span> (action != TASK_POLICY_RESOURCE_ATTRIBUTE_NONE) {
		bsdinfo = task-&gt;bsd_info;
		task_unlock(task);
		proc_restore_resource_actions(bsdinfo, TASK_POLICY_CPU_RESOURCE_USAGE, action);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}

<span class="enscript-reference">out</span>:
	task_unlock(task);
<span class="enscript-reference">out1</span>:
	<span class="enscript-keyword">return</span>(error);

}

<span class="enscript-comment">/* used to apply resource limit related actions */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">task_apply_resource_actions</span>(task_t task, <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">int</span> action = TASK_POLICY_RESOURCE_ATTRIBUTE_NONE;
	<span class="enscript-type">void</span> * bsdinfo = NULL;
	
	<span class="enscript-keyword">switch</span> (type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_CPU_RESOURCE_USAGE</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_WIREDMEM_RESOURCE_USAGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_VIRTUALMEM_RESOURCE_USAGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_DISK_RESOURCE_USAGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_NETWORK_RESOURCE_USAGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TASK_POLICY_POWER_RESOURCE_USAGE</span>:
			<span class="enscript-keyword">return</span>(0);

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span>(1);
	};

	<span class="enscript-comment">/* only cpu actions for now */</span>
	task_lock(task);
	
	<span class="enscript-keyword">if</span> (task-&gt;applied_ru_cpu_ext == TASK_POLICY_RESOURCE_ATTRIBUTE_NONE) {
		<span class="enscript-comment">/* apply action */</span>
		task-&gt;applied_ru_cpu_ext = task-&gt;policy_ru_cpu_ext;
		action = task-&gt;applied_ru_cpu_ext;
	} <span class="enscript-keyword">else</span> {
		action = task-&gt;applied_ru_cpu_ext;
	}

	<span class="enscript-keyword">if</span> (action != TASK_POLICY_RESOURCE_ATTRIBUTE_NONE) {
		bsdinfo = task-&gt;bsd_info;
		task_unlock(task);
		proc_apply_resource_actions(bsdinfo, TASK_POLICY_CPU_RESOURCE_USAGE, action);
	} <span class="enscript-keyword">else</span>
		task_unlock(task);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * XXX This API is somewhat broken; we support multiple simultaneous CPU limits, but the get/set API
 * only allows for one at a time. This means that if there is a per-thread limit active, the other
 * &quot;scopes&quot; will not be accessible via this API. We could change it to pass in the scope of interest
 * to the caller, and prefer that, but there's no need for that at the moment.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">task_get_cpuusage</span>(task_t task, uint8_t *percentagep, uint64_t *intervalp, uint64_t *deadlinep, <span class="enscript-type">int</span> *scope)
{
	*percentagep = 0;
	*intervalp = 0;
	*deadlinep = 0;

	<span class="enscript-keyword">if</span> ((task-&gt;rusage_cpu_flags &amp; TASK_RUSECPU_FLAGS_PERTHR_LIMIT) != 0) {
		*scope = TASK_RUSECPU_FLAGS_PERTHR_LIMIT;
		*percentagep = task-&gt;rusage_cpu_perthr_percentage;
		*intervalp = task-&gt;rusage_cpu_perthr_interval;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((task-&gt;rusage_cpu_flags &amp; TASK_RUSECPU_FLAGS_PROC_LIMIT) != 0) {
		*scope = TASK_RUSECPU_FLAGS_PROC_LIMIT;
		*percentagep = task-&gt;rusage_cpu_percentage;
		*intervalp = task-&gt;rusage_cpu_interval;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((task-&gt;rusage_cpu_flags &amp; TASK_RUSECPU_FLAGS_DEADLINE) != 0) {
		*scope = TASK_RUSECPU_FLAGS_DEADLINE;
		*deadlinep = task-&gt;rusage_cpu_deadline;
	} <span class="enscript-keyword">else</span> {
		*scope = 0;
	}

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Disable the CPU usage monitor for the task. Return value indicates
 * if the mechanism was actually enabled.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">task_disable_cpumon</span>(task_t task) {
	thread_t thread;
	
	task_lock_assert_owned(task);

	<span class="enscript-keyword">if</span> ((task-&gt;rusage_cpu_flags &amp; TASK_RUSECPU_FLAGS_PERTHR_LIMIT) == 0) {
		<span class="enscript-keyword">return</span> (KERN_INVALID_ARGUMENT);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TELEMETRY</span>
	<span class="enscript-comment">/*
	 * Disable task-wide telemetry if it was ever enabled by the CPU usage
	 * monitor's warning zone.
	 */</span>
	telemetry_task_ctl_locked(task, TF_CPUMON_WARNING, 0);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Disable the monitor for the task, and propagate that change to each thread.
	 */</span>
	task-&gt;rusage_cpu_flags &amp;= ~(TASK_RUSECPU_FLAGS_PERTHR_LIMIT | TASK_RUSECPU_FLAGS_FATAL_CPUMON);		
	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
		set_astledger(thread);
	}
	task-&gt;rusage_cpu_perthr_percentage = 0;
	task-&gt;rusage_cpu_perthr_interval = 0;

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">task_set_cpuusage</span>(task_t task, uint8_t percentage, uint64_t interval, uint64_t deadline, <span class="enscript-type">int</span> scope, <span class="enscript-type">int</span> cpumon_entitled)
{
	thread_t thread;	
	uint64_t abstime = 0;
	uint64_t limittime = 0;

	lck_mtx_assert(&amp;task-&gt;lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* By default, refill once per second */</span>
	<span class="enscript-keyword">if</span> (interval == 0)
		interval = NSEC_PER_SEC;

	<span class="enscript-keyword">if</span> (percentage != 0) {
		<span class="enscript-keyword">if</span> (scope == TASK_RUSECPU_FLAGS_PERTHR_LIMIT) {
			boolean_t warn = FALSE;

			<span class="enscript-comment">/*
			 * A per-thread CPU limit on a task generates an exception
			 * (LEDGER_ACTION_EXCEPTION) if any one thread in the task
			 * exceeds the limit.
			 */</span>

			<span class="enscript-keyword">if</span> (percentage == TASK_POLICY_CPUMON_DISABLE) {
				<span class="enscript-keyword">if</span> (cpumon_entitled) {
					task_disable_cpumon(task);
					<span class="enscript-keyword">return</span> (0);
				}

				<span class="enscript-comment">/*
				 * This task wishes to disable the CPU usage monitor, but it's
				 * missing the required entitlement:
				 *     com.apple.private.kernel.override-cpumon
				 *
				 * Instead, treat this as a request to reset its params 
				 * back to the defaults.
				 */</span>
				warn = TRUE;
				percentage = TASK_POLICY_CPUMON_DEFAULTS;
			}

			<span class="enscript-keyword">if</span> (percentage == TASK_POLICY_CPUMON_DEFAULTS) {
				percentage = proc_max_cpumon_percentage;
				interval   = proc_max_cpumon_interval;
			}

			<span class="enscript-keyword">if</span> (percentage &gt; 100) {
				percentage = 100;
			}

			<span class="enscript-comment">/*
			 * Passing in an interval of -1 means either:
			 * - Leave the interval as-is, if there's already a per-thread
			 *   limit configured
			 * - Use the system default.
		  	 */</span>
			<span class="enscript-keyword">if</span> (interval == -1ULL) {
				<span class="enscript-keyword">if</span> (task-&gt;rusage_cpu_flags &amp; TASK_RUSECPU_FLAGS_PERTHR_LIMIT) {
			 		interval = task-&gt;rusage_cpu_perthr_interval;
				} <span class="enscript-keyword">else</span> {
					interval = proc_max_cpumon_interval;
				}
			}

			<span class="enscript-comment">/*
			 * Enforce global caps on CPU usage monitor here if the process is not
			 * entitled to escape the global caps.
			 */</span>
			 <span class="enscript-keyword">if</span> ((percentage &gt; proc_max_cpumon_percentage) &amp;&amp; (cpumon_entitled == 0)) {
				warn = TRUE;
			 	percentage = proc_max_cpumon_percentage;
			 }

			 <span class="enscript-keyword">if</span> ((interval &gt; proc_max_cpumon_interval) &amp;&amp; (cpumon_entitled == 0)) {
				warn = TRUE;
			 	interval = proc_max_cpumon_interval;
			 }

			<span class="enscript-keyword">if</span> (warn) {
				<span class="enscript-type">int</span> 	  pid = 0;
				<span class="enscript-type">const</span> <span class="enscript-type">char</span> *procname = <span class="enscript-string">&quot;unknown&quot;</span>;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_BSD</span>
				pid = proc_selfpid();
				<span class="enscript-keyword">if</span> (current_task()-&gt;bsd_info != NULL) {
					procname = proc_name_address(current_task()-&gt;bsd_info);
				}
#<span class="enscript-reference">endif</span>

				printf(<span class="enscript-string">&quot;process %s[%d] denied attempt to escape CPU monitor&quot;</span>
					<span class="enscript-string">&quot; (missing required entitlement).\n&quot;</span>, procname, pid);
			}

			task-&gt;rusage_cpu_flags |= TASK_RUSECPU_FLAGS_PERTHR_LIMIT;
			task-&gt;rusage_cpu_perthr_percentage = percentage;
			task-&gt;rusage_cpu_perthr_interval = interval;
			queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
				set_astledger(thread);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (scope == TASK_RUSECPU_FLAGS_PROC_LIMIT) {
			<span class="enscript-comment">/*
			 * Currently, a proc-wide CPU limit always blocks if the limit is
			 * exceeded (LEDGER_ACTION_BLOCK).
			 */</span>
			task-&gt;rusage_cpu_flags |= TASK_RUSECPU_FLAGS_PROC_LIMIT;
			task-&gt;rusage_cpu_percentage = percentage;
			task-&gt;rusage_cpu_interval = interval;

			limittime = (interval * percentage) / 100;
			nanoseconds_to_absolutetime(limittime, &amp;abstime);

			ledger_set_limit(task-&gt;ledger, task_ledgers.cpu_time, abstime, 0);
			ledger_set_period(task-&gt;ledger, task_ledgers.cpu_time, interval);
			ledger_set_action(task-&gt;ledger, task_ledgers.cpu_time, LEDGER_ACTION_BLOCK);
		}
	}

	<span class="enscript-keyword">if</span> (deadline != 0) {
		assert(scope == TASK_RUSECPU_FLAGS_DEADLINE);

		<span class="enscript-comment">/* if already in use, cancel and wait for it to cleanout */</span>
		<span class="enscript-keyword">if</span> (task-&gt;rusage_cpu_callt != NULL) {
			task_unlock(task);
			thread_call_cancel_wait(task-&gt;rusage_cpu_callt);
			task_lock(task);
		}
		<span class="enscript-keyword">if</span> (task-&gt;rusage_cpu_callt == NULL) {
			task-&gt;rusage_cpu_callt = thread_call_allocate_with_priority(task_action_cpuusage, (thread_call_param_t)task, THREAD_CALL_PRIORITY_KERNEL);
		}
		<span class="enscript-comment">/* setup callout */</span>
		<span class="enscript-keyword">if</span> (task-&gt;rusage_cpu_callt != 0) {
			uint64_t save_abstime = 0;

			task-&gt;rusage_cpu_flags |= TASK_RUSECPU_FLAGS_DEADLINE;
			task-&gt;rusage_cpu_deadline = deadline;

			nanoseconds_to_absolutetime(deadline, &amp;abstime);
			save_abstime = abstime;
			clock_absolutetime_interval_to_deadline(save_abstime, &amp;abstime);
			thread_call_enter_delayed(task-&gt;rusage_cpu_callt, abstime);
		}
	}

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">task_clear_cpuusage</span>(task_t task, <span class="enscript-type">int</span> cpumon_entitled)
{
	<span class="enscript-type">int</span> retval = 0;

	task_lock(task);
	retval = task_clear_cpuusage_locked(task, cpumon_entitled);
	task_unlock(task);

	<span class="enscript-keyword">return</span>(retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">task_clear_cpuusage_locked</span>(task_t task, <span class="enscript-type">int</span> cpumon_entitled)
{
	thread_call_t savecallt;

	<span class="enscript-comment">/* cancel percentage handling if set */</span>
	<span class="enscript-keyword">if</span> (task-&gt;rusage_cpu_flags &amp; TASK_RUSECPU_FLAGS_PROC_LIMIT) {
		task-&gt;rusage_cpu_flags &amp;= ~TASK_RUSECPU_FLAGS_PROC_LIMIT;		
		ledger_set_limit(task-&gt;ledger, task_ledgers.cpu_time, LEDGER_LIMIT_INFINITY, 0);
		task-&gt;rusage_cpu_percentage = 0;
		task-&gt;rusage_cpu_interval = 0;
	}

	<span class="enscript-comment">/*
	 * Disable the CPU usage monitor.
	 */</span>
	<span class="enscript-keyword">if</span> (cpumon_entitled) {
		task_disable_cpumon(task);
	}

	<span class="enscript-comment">/* cancel deadline handling if set */</span>
	<span class="enscript-keyword">if</span> (task-&gt;rusage_cpu_flags &amp; TASK_RUSECPU_FLAGS_DEADLINE) {
		task-&gt;rusage_cpu_flags &amp;= ~TASK_RUSECPU_FLAGS_DEADLINE;
		<span class="enscript-keyword">if</span> (task-&gt;rusage_cpu_callt != 0) {
			savecallt = task-&gt;rusage_cpu_callt;
			task-&gt;rusage_cpu_callt = NULL;
			task-&gt;rusage_cpu_deadline = 0;
			task_unlock(task);
			thread_call_cancel_wait(savecallt);
			thread_call_free(savecallt);
			task_lock(task);
		}
	}
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/* called by ledger unit to enforce action due to  resource usage criteria being met */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_action_cpuusage</span>(thread_call_param_t param0, __unused thread_call_param_t param1)
{
	task_t task = (task_t)param0;
	(<span class="enscript-type">void</span>)task_apply_resource_actions(task, TASK_POLICY_CPU_RESOURCE_USAGE);
	<span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/*
 * Routines for taskwatch and pidbind
 */</span>


<span class="enscript-comment">/*
 * Routines for importance donation/inheritance/boosting
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">task_importance_update_live_donor</span>(task_t target_task)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>

	ipc_importance_task_t task_imp;

	task_imp = ipc_importance_for_task(target_task, FALSE);
	<span class="enscript-keyword">if</span> (IIT_NULL != task_imp) {
		ipc_importance_task_update_live_donor(task_imp);
		ipc_importance_task_release(task_imp);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_importance_mark_donor</span>(task_t task, boolean_t donating)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	ipc_importance_task_t task_imp;

	task_imp = ipc_importance_for_task(task, FALSE);
	<span class="enscript-keyword">if</span> (IIT_NULL != task_imp) {
		ipc_importance_task_mark_donor(task_imp, donating);
		ipc_importance_task_release(task_imp);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_importance_mark_live_donor</span>(task_t task, boolean_t live_donating)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	ipc_importance_task_t task_imp;

	task_imp = ipc_importance_for_task(task, FALSE);
	<span class="enscript-keyword">if</span> (IIT_NULL != task_imp) {
		ipc_importance_task_mark_live_donor(task_imp, live_donating);
		ipc_importance_task_release(task_imp);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_importance_mark_receiver</span>(task_t task, boolean_t receiving)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	ipc_importance_task_t task_imp;

	task_imp = ipc_importance_for_task(task, FALSE);
	<span class="enscript-keyword">if</span> (IIT_NULL != task_imp) {
		ipc_importance_task_mark_receiver(task_imp, receiving);
		ipc_importance_task_release(task_imp);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_importance_mark_denap_receiver</span>(task_t task, boolean_t denap)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	ipc_importance_task_t task_imp;

	task_imp = ipc_importance_for_task(task, FALSE);
	<span class="enscript-keyword">if</span> (IIT_NULL != task_imp) {
		ipc_importance_task_mark_denap_receiver(task_imp, denap);
		ipc_importance_task_release(task_imp);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">task_importance_reset</span>(__imp_only task_t task)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	ipc_importance_task_t task_imp;

	<span class="enscript-comment">/* TODO: Lower importance downstream before disconnect */</span>
	task_imp = task-&gt;task_imp_base;
	ipc_importance_reset(task_imp, FALSE);
	task_importance_update_live_donor(task);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>

<span class="enscript-comment">/*
 * Sets the task boost bit to the provided value.  Does NOT run the update function.
 *
 * Task lock must be held.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_set_boost_locked</span>(task_t task, boolean_t boost_active)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_DEBUG</span>
	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, (IMPORTANCE_CODE(IMP_BOOST, (boost_active ? IMP_BOOSTED : IMP_UNBOOSTED)) | DBG_FUNC_START),
	                          proc_selfpid(), task_pid(task), trequested_0(task, THREAD_NULL), trequested_1(task, THREAD_NULL), 0);
#<span class="enscript-reference">endif</span>

	task-&gt;requested_policy.t_boosted = boost_active;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_DEBUG</span>
	<span class="enscript-keyword">if</span> (boost_active == TRUE){
		DTRACE_BOOST2(boost, task_t, task, <span class="enscript-type">int</span>, task_pid(task));
	} <span class="enscript-keyword">else</span> {
		DTRACE_BOOST2(unboost, task_t, task, <span class="enscript-type">int</span>, task_pid(task));
	}
	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, (IMPORTANCE_CODE(IMP_BOOST, (boost_active ? IMP_BOOSTED : IMP_UNBOOSTED)) | DBG_FUNC_END),
	                          proc_selfpid(), task_pid(task),
	                          trequested_0(task, THREAD_NULL), trequested_1(task, THREAD_NULL), 0);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 * Sets the task boost bit to the provided value and applies the update.
 *
 * Task lock must be held.  Must call update complete after unlocking the task.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_update_boost_locked</span>(task_t task, boolean_t boost_active, task_pend_token_t pend_token)
{
	task_set_boost_locked(task, boost_active);

	task_policy_update_locked(task, THREAD_NULL, pend_token);
}

<span class="enscript-comment">/*
 * Check if this task should donate importance.
 *
 * May be called without taking the task lock. In that case, donor status can change
 * so you must check only once for each donation event.
 */</span>
boolean_t
<span class="enscript-function-name">task_is_importance_donor</span>(task_t task)
{
	<span class="enscript-keyword">if</span> (task-&gt;task_imp_base == IIT_NULL)
		<span class="enscript-keyword">return</span> FALSE;
	<span class="enscript-keyword">return</span> ipc_importance_task_is_donor(task-&gt;task_imp_base);
}

<span class="enscript-comment">/*
 * Query the status of the task's donor mark.
 */</span>
boolean_t
<span class="enscript-function-name">task_is_marked_importance_donor</span>(task_t task)
{
	<span class="enscript-keyword">if</span> (task-&gt;task_imp_base == IIT_NULL)
		<span class="enscript-keyword">return</span> FALSE;
	<span class="enscript-keyword">return</span> ipc_importance_task_is_marked_donor(task-&gt;task_imp_base);
}

<span class="enscript-comment">/*
 * Query the status of the task's live donor and donor mark.
 */</span>
boolean_t
<span class="enscript-function-name">task_is_marked_live_importance_donor</span>(task_t task)
{
	<span class="enscript-keyword">if</span> (task-&gt;task_imp_base == IIT_NULL)
		<span class="enscript-keyword">return</span> FALSE;
	<span class="enscript-keyword">return</span> ipc_importance_task_is_marked_live_donor(task-&gt;task_imp_base);
}


<span class="enscript-comment">/*
 * This routine may be called without holding task lock
 * since the value of imp_receiver can never be unset.
 */</span>
boolean_t
<span class="enscript-function-name">task_is_importance_receiver</span>(task_t task)
{
	<span class="enscript-keyword">if</span> (task-&gt;task_imp_base == IIT_NULL)
		<span class="enscript-keyword">return</span> FALSE;
	<span class="enscript-keyword">return</span> ipc_importance_task_is_marked_receiver(task-&gt;task_imp_base);
}

<span class="enscript-comment">/*
 * Query the task's receiver mark.
 */</span>
boolean_t
<span class="enscript-function-name">task_is_marked_importance_receiver</span>(task_t task)
{
	<span class="enscript-keyword">if</span> (task-&gt;task_imp_base == IIT_NULL)
		<span class="enscript-keyword">return</span> FALSE;
	<span class="enscript-keyword">return</span> ipc_importance_task_is_marked_receiver(task-&gt;task_imp_base);
}

<span class="enscript-comment">/*
 * This routine may be called without holding task lock
 * since the value of de-nap receiver can never be unset.
 */</span>
boolean_t
<span class="enscript-function-name">task_is_importance_denap_receiver</span>(task_t task)
{
	<span class="enscript-keyword">if</span> (task-&gt;task_imp_base == IIT_NULL)
		<span class="enscript-keyword">return</span> FALSE;
	<span class="enscript-keyword">return</span> ipc_importance_task_is_denap_receiver(task-&gt;task_imp_base);
}

<span class="enscript-comment">/*
 * Query the task's de-nap receiver mark.
 */</span>
boolean_t
<span class="enscript-function-name">task_is_marked_importance_denap_receiver</span>(task_t task)
{
	<span class="enscript-keyword">if</span> (task-&gt;task_imp_base == IIT_NULL)
		<span class="enscript-keyword">return</span> FALSE;
	<span class="enscript-keyword">return</span> ipc_importance_task_is_marked_denap_receiver(task-&gt;task_imp_base);
}

<span class="enscript-comment">/*
 * This routine may be called without holding task lock
 * since the value of imp_receiver can never be unset.
 */</span>
boolean_t
<span class="enscript-function-name">task_is_importance_receiver_type</span>(task_t task)
{
	<span class="enscript-keyword">if</span> (task-&gt;task_imp_base == IIT_NULL)
		<span class="enscript-keyword">return</span> FALSE;
	<span class="enscript-keyword">return</span> (task_is_importance_receiver(task) ||
		task_is_importance_denap_receiver(task));
}

<span class="enscript-comment">/*
 * External importance assertions are managed by the process in userspace
 * Internal importance assertions are the responsibility of the kernel
 * Assertions are changed from internal to external via task_importance_externalize_assertion
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">task_importance_hold_watchport_assertion</span>(task_t target_task, uint32_t count)
{
	ipc_importance_task_t task_imp;
	kern_return_t ret;

	<span class="enscript-comment">/* must already have set up an importance */</span>
	task_imp = target_task-&gt;task_imp_base;
	assert(IIT_NULL != task_imp);

	ret = ipc_importance_task_hold_internal_assertion(task_imp, count);
	<span class="enscript-keyword">return</span> (KERN_SUCCESS != ret) ? ENOTSUP : 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">task_importance_hold_internal_assertion</span>(task_t target_task, uint32_t count)
{
	ipc_importance_task_t task_imp;
	kern_return_t ret;

	<span class="enscript-comment">/* may be first time, so allow for possible importance setup */</span>
	task_imp = ipc_importance_for_task(target_task, FALSE);
	<span class="enscript-keyword">if</span> (IIT_NULL == task_imp) {
		<span class="enscript-keyword">return</span> EOVERFLOW;
	}
	ret = ipc_importance_task_hold_internal_assertion(task_imp, count);
	ipc_importance_task_release(task_imp);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS != ret) ? ENOTSUP : 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">task_importance_hold_file_lock_assertion</span>(task_t target_task, uint32_t count)
{
	ipc_importance_task_t task_imp;
	kern_return_t ret;

	<span class="enscript-comment">/* may be first time, so allow for possible importance setup */</span>
	task_imp = ipc_importance_for_task(target_task, FALSE);
	<span class="enscript-keyword">if</span> (IIT_NULL == task_imp) {
		<span class="enscript-keyword">return</span> EOVERFLOW;
	}
	ret = ipc_importance_task_hold_file_lock_assertion(task_imp, count);
	ipc_importance_task_release(task_imp);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS != ret) ? ENOTSUP : 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">task_importance_hold_legacy_external_assertion</span>(task_t target_task, uint32_t count)
{
	ipc_importance_task_t task_imp;
	kern_return_t ret;
 
	<span class="enscript-comment">/* must already have set up an importance */</span>
	task_imp = target_task-&gt;task_imp_base;
	<span class="enscript-keyword">if</span> (IIT_NULL == task_imp) {
		<span class="enscript-keyword">return</span> EOVERFLOW;
	}	  
	ret = ipc_importance_task_hold_legacy_external_assertion(task_imp, count);
	<span class="enscript-keyword">return</span> (KERN_SUCCESS != ret) ? ENOTSUP : 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">task_importance_drop_internal_assertion</span>(task_t target_task, uint32_t count)
{
	ipc_importance_task_t task_imp;
	kern_return_t ret;
 
	<span class="enscript-comment">/* must already have set up an importance */</span>
	task_imp = target_task-&gt;task_imp_base;
	<span class="enscript-keyword">if</span> (IIT_NULL == task_imp) {
		<span class="enscript-keyword">return</span> EOVERFLOW;
	}
	ret = ipc_importance_task_drop_internal_assertion(target_task-&gt;task_imp_base, count);
	<span class="enscript-keyword">return</span> (KERN_SUCCESS != ret) ? ENOTSUP : 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">task_importance_drop_file_lock_assertion</span>(task_t target_task, uint32_t count)
{
	ipc_importance_task_t task_imp;
	kern_return_t ret;
 
	<span class="enscript-comment">/* must already have set up an importance */</span>
	task_imp = target_task-&gt;task_imp_base;
	<span class="enscript-keyword">if</span> (IIT_NULL == task_imp) {
		<span class="enscript-keyword">return</span> EOVERFLOW;
	}
	ret = ipc_importance_task_drop_file_lock_assertion(target_task-&gt;task_imp_base, count);
	<span class="enscript-keyword">return</span> (KERN_SUCCESS != ret) ? EOVERFLOW : 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">task_importance_drop_legacy_external_assertion</span>(task_t target_task, uint32_t count)
{
	ipc_importance_task_t task_imp;
	kern_return_t ret;
 
	<span class="enscript-comment">/* must already have set up an importance */</span>
	task_imp = target_task-&gt;task_imp_base;
	<span class="enscript-keyword">if</span> (IIT_NULL == task_imp) {
		<span class="enscript-keyword">return</span> EOVERFLOW;
	}
	ret = ipc_importance_task_drop_legacy_external_assertion(task_imp, count);
	<span class="enscript-keyword">return</span> (KERN_SUCCESS != ret) ? EOVERFLOW : 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">task_add_importance_watchport</span>(task_t task, mach_port_t port, <span class="enscript-type">int</span> *boostp)
{
	<span class="enscript-type">int</span> boost = 0;

	__impdebug_only <span class="enscript-type">int</span> released_pid = 0;
	__impdebug_only <span class="enscript-type">int</span> pid = task_pid(task);

	ipc_importance_task_t release_imp_task = IIT_NULL;

	<span class="enscript-keyword">if</span> (IP_VALID(port) != 0) {
		ipc_importance_task_t new_imp_task = ipc_importance_for_task(task, FALSE);

		ip_lock(port);

		<span class="enscript-comment">/*
		 * The port must have been marked tempowner already.
		 * This also filters out ports whose receive rights
		 * are already enqueued in a message, as you can't
		 * change the right's destination once it's already
		 * on its way.
		 */</span>
		<span class="enscript-keyword">if</span> (port-&gt;ip_tempowner != 0) {
			assert(port-&gt;ip_impdonation != 0);

			boost = port-&gt;ip_impcount;
			<span class="enscript-keyword">if</span> (IIT_NULL != port-&gt;ip_imp_task) {
				<span class="enscript-comment">/*
				 * if this port is already bound to a task,
				 * release the task reference and drop any
				 * watchport-forwarded boosts
				 */</span>
				release_imp_task = port-&gt;ip_imp_task;
				port-&gt;ip_imp_task = IIT_NULL;
			}

			<span class="enscript-comment">/* mark the port is watching another task (reference held in port-&gt;ip_imp_task) */</span>
			<span class="enscript-keyword">if</span> (ipc_importance_task_is_marked_receiver(new_imp_task)) {
				port-&gt;ip_imp_task = new_imp_task;
				new_imp_task = IIT_NULL;
			}
		}
		ip_unlock(port);

		<span class="enscript-keyword">if</span> (IIT_NULL != new_imp_task) {
			ipc_importance_task_release(new_imp_task);
		}

		<span class="enscript-keyword">if</span> (IIT_NULL != release_imp_task) {
			<span class="enscript-keyword">if</span> (boost &gt; 0)
				ipc_importance_task_drop_internal_assertion(release_imp_task, boost);

			<span class="enscript-comment">// released_pid = task_pid(release_imp_task); /* TODO: Need ref-safe way to get pid */
</span>			ipc_importance_task_release(release_imp_task);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_DEBUG</span>
		KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, (IMPORTANCE_CODE(IMP_WATCHPORT, 0)) | DBG_FUNC_NONE,
		        proc_selfpid(), pid, boost, released_pid, 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_DEBUG */</span>
	}

	*boostp = boost;
	<span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

<span class="enscript-comment">/*
 * Routines for VM to query task importance
 */</span>


<span class="enscript-comment">/*
 * Order to be considered while estimating importance
 * for low memory notification and purging purgeable memory.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_IMPORTANCE_FOREGROUND</span>     4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TASK_IMPORTANCE_NOTDARWINBG</span>    1


<span class="enscript-comment">/*
 * (Un)Mark the task as a privileged listener for memory notifications.
 * if marked, this task will be among the first to be notified amongst
 * the bulk of all other tasks when the system enters a pressure level
 * of interest to this task.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">task_low_mem_privileged_listener</span>(task_t task, boolean_t new_value, boolean_t *old_value)
{
	<span class="enscript-keyword">if</span> (old_value != NULL) {
		*old_value = (boolean_t)task-&gt;low_mem_privileged_listener;
	} <span class="enscript-keyword">else</span> {
		task_lock(task);
		task-&gt;low_mem_privileged_listener = (uint32_t)new_value;
		task_unlock(task);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Checks if the task is already notified.
 *
 * Condition: task lock should be held while calling this function.
 */</span>
boolean_t
<span class="enscript-function-name">task_has_been_notified</span>(task_t task, <span class="enscript-type">int</span> pressurelevel)
{
	<span class="enscript-keyword">if</span> (task == NULL) {
		<span class="enscript-keyword">return</span> FALSE;
	}
	
	<span class="enscript-keyword">if</span> (pressurelevel == kVMPressureWarning) 
		<span class="enscript-keyword">return</span> (task-&gt;low_mem_notified_warn ? TRUE : FALSE);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pressurelevel == kVMPressureCritical) 
		<span class="enscript-keyword">return</span> (task-&gt;low_mem_notified_critical ? TRUE : FALSE);
	<span class="enscript-keyword">else</span> 
		<span class="enscript-keyword">return</span> TRUE;
}


<span class="enscript-comment">/*
 * Checks if the task is used for purging.
 *
 * Condition: task lock should be held while calling this function.
 */</span>
boolean_t
<span class="enscript-function-name">task_used_for_purging</span>(task_t task, <span class="enscript-type">int</span> pressurelevel)
{
	<span class="enscript-keyword">if</span> (task == NULL) {
		<span class="enscript-keyword">return</span> FALSE;
	}
	
	<span class="enscript-keyword">if</span> (pressurelevel == kVMPressureWarning)
		<span class="enscript-keyword">return</span> (task-&gt;purged_memory_warn ? TRUE : FALSE);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pressurelevel == kVMPressureCritical)
		<span class="enscript-keyword">return</span> (task-&gt;purged_memory_critical ? TRUE : FALSE);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> TRUE;
}


<span class="enscript-comment">/*
 * Mark the task as notified with memory notification.
 * 
 * Condition: task lock should be held while calling this function.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_mark_has_been_notified</span>(task_t task, <span class="enscript-type">int</span> pressurelevel)
{
	<span class="enscript-keyword">if</span> (task == NULL) {
		<span class="enscript-keyword">return</span>;
	}
	
	<span class="enscript-keyword">if</span> (pressurelevel == kVMPressureWarning)
		task-&gt;low_mem_notified_warn = 1;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pressurelevel == kVMPressureCritical)
		task-&gt;low_mem_notified_critical = 1;
}


<span class="enscript-comment">/*
 * Mark the task as purged.
 *
 * Condition: task lock should be held while calling this function.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_mark_used_for_purging</span>(task_t task, <span class="enscript-type">int</span> pressurelevel)
{
	<span class="enscript-keyword">if</span> (task == NULL) {
		<span class="enscript-keyword">return</span>;
	}
	
	<span class="enscript-keyword">if</span> (pressurelevel == kVMPressureWarning)
		task-&gt;purged_memory_warn = 1;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pressurelevel == kVMPressureCritical)
		task-&gt;purged_memory_critical = 1;
}


<span class="enscript-comment">/*
 * Mark the task eligible for low memory notification.
 * 
 * Condition: task lock should be held while calling this function.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_clear_has_been_notified</span>(task_t task, <span class="enscript-type">int</span> pressurelevel)
{
	<span class="enscript-keyword">if</span> (task == NULL) {
		<span class="enscript-keyword">return</span>;
	}
	
	<span class="enscript-keyword">if</span> (pressurelevel == kVMPressureWarning)
		task-&gt;low_mem_notified_warn = 0;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pressurelevel == kVMPressureCritical)
		task-&gt;low_mem_notified_critical = 0;
}


<span class="enscript-comment">/*
 * Mark the task eligible for purging its purgeable memory.
 *
 * Condition: task lock should be held while calling this function.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_clear_used_for_purging</span>(task_t task)
{
	<span class="enscript-keyword">if</span> (task == NULL) {
		<span class="enscript-keyword">return</span>;
	}
	
	task-&gt;purged_memory_warn = 0;
	task-&gt;purged_memory_critical = 0;
}


<span class="enscript-comment">/*
 * Estimate task importance for purging its purgeable memory 
 * and low memory notification.
 * 
 * Importance is calculated in the following order of criteria:
 * -Task role : Background vs Foreground
 * -Boost status: Not boosted vs Boosted
 * -Darwin BG status.
 *
 * Returns: Estimated task importance. Less important task will have lower 
 *          estimated importance.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">task_importance_estimate</span>(task_t task)
{
	<span class="enscript-type">int</span> task_importance = 0;

	<span class="enscript-keyword">if</span> (task == NULL) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (proc_get_effective_task_policy(task, TASK_POLICY_ROLE) == TASK_FOREGROUND_APPLICATION)
			task_importance += TASK_IMPORTANCE_FOREGROUND;

	<span class="enscript-keyword">if</span> (proc_get_effective_task_policy(task, TASK_POLICY_DARWIN_BG) == 0)
			task_importance += TASK_IMPORTANCE_NOTDARWINBG;
	
	<span class="enscript-keyword">return</span> task_importance;
}

</pre>
<hr />
</body></html>