<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>sched_multiq.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">sched_multiq.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/sched_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_cpu.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

<span class="enscript-comment">/*
 * Theory Statement
 *
 * How does the task scheduler work?
 *
 * It schedules threads across a few levels.
 *
 * RT threads are dealt with above us
 * Bound threads go into the per-processor runq
 * Non-bound threads are linked on their task's sched_group's runq
 * sched_groups' sched_entries are linked on the pset's runq
 *
 * TODO: make this explicit - bound threads should have a different enqueue fxn
 *
 * When we choose a new thread, we will decide whether to look at the bound runqueue, the global runqueue
 * or the current group's runqueue, then dequeue the next thread in that runqueue.
 *
 * We then manipulate the sched_entries to reflect the invariant that:
 * Each non-empty priority level in a group's runq is represented by one sched_entry enqueued in the global
 * runqueue.
 *
 * A sched_entry represents a chance at running - for each priority in each task, there is one chance of getting
 * to run.  This reduces the excess contention bonus given to processes which have work spread among many threads
 * as compared to processes which do the same amount of work under fewer threads.
 *
 * NOTE: Currently, the multiq scheduler only supports one pset.
 *
 * NOTE ABOUT thread-&gt;sched_pri:
 *
 * It can change after enqueue - it's changed without pset lock but with thread lock if thread-&gt;runq is 0.
 * Therefore we can only depend on it not changing during the enqueue and remove path, not the dequeue.
 *
 * TODO: Future features:
 *
 * Decouple the task priority from the sched_entry priority, allowing for:
 *      fast task priority change without having to iterate and re-dispatch all threads in the task.
 *              i.e. task-wide priority, task-wide boosting
 *      fancier group decay features
 *
 * Group (or task) decay:
 *      Decay is used for a few different things:
 *              Prioritizing latency-needing threads over throughput-needing threads for time-to-running
 *              Balancing work between threads in a process
 *              Balancing work done at the same priority between different processes
 *              Recovering from priority inversions between two threads in the same process
 *              Recovering from priority inversions between two threads in different processes
 *              Simulating a proportional share scheduler by allowing lower priority threads
 *                to run for a certain percentage of the time
 *
 *      Task decay lets us separately address the 'same process' and 'different process' needs,
 *      which will allow us to make smarter tradeoffs in different cases.
 *      For example, we could resolve priority inversion in the same process by reordering threads without dropping the
 *      process below low priority threads in other processes.
 *
 * One lock to rule them all (or at least all the runqueues) instead of the pset locks
 *
 * Shrink sched_entry size to the size of a queue_chain_t by inferring priority, group, and perhaps runq field.
 * The entries array is 5K currently so it'd be really great to reduce.
 * One way to get sched_group below 4K without a new runq structure would be to remove the extra queues above realtime.
 *
 * When preempting a processor, store a flag saying if the preemption
 * was from a thread in the same group or different group,
 * and tell choose_thread about it.
 *
 * When choosing a processor, bias towards those running in the same
 * group as I am running (at the same priority, or within a certain band?).
 *
 * Decide if we need to support psets.
 * Decide how to support psets - do we need duplicate entries for each pset,
 * or can we get away with putting the entry in either one or the other pset?
 *
 * Consider the right way to handle runq count - I don't want to iterate groups.
 * Perhaps keep a global counter.  sched_run_count will not work.
 * Alternate option - remove it from choose_processor. It doesn't add much value
 * now that we have global runq.
 *
 * Need a better way of finding group to target instead of looking at current_task.
 * Perhaps choose_thread could pass in the current thread?
 *
 * Consider unifying runq copy-pastes.
 *
 * Thoughts on having a group central quantum bucket:
 *
 * I see two algorithms to decide quanta:
 * A) Hand off only when switching thread to thread in the same group
 * B) Allocate and return quanta to the group's pool
 *
 * Issues:
 * If a task blocks completely, should it come back with the leftover quanta
 * or brand new quanta?
 *
 * Should I put a flag saying zero out a quanta you grab when youre dispatched'?
 *
 * Resolution:
 * Handing off quanta between threads will help with jumping around in the current task
 * but will not help when a thread from a different task is involved.
 * Need an algorithm that works with round robin-ing between threads in different tasks
 *
 * But wait - round robining can only be triggered by quantum expire or blocking.
 * We need something that works with preemption or yielding - that's the more interesting idea.
 *
 * Existing algorithm - preemption doesn't re-set quantum, puts thread on head of runq.
 * Blocking or quantum expiration does re-set quantum, puts thread on tail of runq.
 *
 * New algorithm -
 * Hand off quanta when hopping between threads with same sched_group
 * Even if thread was blocked it uses last thread remaining quanta when it starts.
 *
 * If we use the only cycle entry at quantum algorithm, then the quantum pool starts getting
 * interesting.
 *
 * A thought - perhaps the handoff approach doesn't work so well in the presence of
 * non-handoff wakeups i.e. wake other thread then wait then block - doesn't mean that
 * woken thread will be what I switch to - other processor may have stolen it.
 * What do we do there?
 *
 * Conclusions:
 * We currently don't know of a scenario where quantum buckets on the task is beneficial.
 * We will instead handoff quantum between threads in the task, and keep quantum
 * on the preempted thread if it's preempted by something outside the task.
 *
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">DEVELOPMENT</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MULTIQ_SANITY_CHECK</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> sched_entry {
	queue_chain_t           links;
	int16_t                 sched_pri;      <span class="enscript-comment">/* scheduled (current) priority */</span>
	int16_t                 runq;
	int32_t 		pad;
} *sched_entry_t;

<span class="enscript-type">typedef</span> run_queue_t entry_queue_t;                      <span class="enscript-comment">/* A run queue that holds sched_entries instead of threads */</span>
<span class="enscript-type">typedef</span> run_queue_t group_runq_t;                       <span class="enscript-comment">/* A run queue that is part of a sched_group */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SCHED_ENTRY_NULL</span>        ((sched_entry_t) 0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MULTIQ_ERUNQ</span>            (-4)       		<span class="enscript-comment">/* Indicates entry is on the main runq */</span>

<span class="enscript-comment">/* Each level in the run queue corresponds to one entry in the entries array */</span>
<span class="enscript-type">struct</span> sched_group {
	<span class="enscript-type">struct</span> sched_entry      entries[NRQS];
	<span class="enscript-type">struct</span> run_queue        runq;
	queue_chain_t           sched_groups;
};

<span class="enscript-comment">/*
 * Keep entry on the head of the runqueue while dequeueing threads.
 * Only cycle it to the end of the runqueue when a thread in the task
 * hits its quantum.
 */</span>
<span class="enscript-type">static</span> boolean_t        deep_drain = FALSE;

<span class="enscript-comment">/* Verify the consistency of the runq before touching it */</span>
<span class="enscript-type">static</span> boolean_t        multiq_sanity_check = FALSE;

<span class="enscript-comment">/*
 * Draining threads from the current task is preferred
 * when they're less than X steps below the current
 * global highest priority
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_DRAIN_BAND_LIMIT</span> MAXPRI
<span class="enscript-type">static</span> integer_t        drain_band_limit;

<span class="enscript-comment">/*
 * Don't go below this priority level if there is something above it in another task
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_DRAIN_DEPTH_LIMIT</span> MAXPRI_THROTTLE
<span class="enscript-type">static</span> integer_t        drain_depth_limit;

<span class="enscript-comment">/*
 * Don't favor the task when there's something above this priority in another task.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_DRAIN_CEILING</span> BASEPRI_FOREGROUND
<span class="enscript-type">static</span> integer_t        drain_ceiling;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone      *sched_group_zone;

<span class="enscript-type">static</span> uint64_t         num_sched_groups = 0;
<span class="enscript-type">static</span> queue_head_t     sched_groups;

<span class="enscript-type">static</span> lck_attr_t       sched_groups_lock_attr;
<span class="enscript-type">static</span> lck_grp_t        sched_groups_lock_grp;
<span class="enscript-type">static</span> lck_grp_attr_t   sched_groups_lock_grp_attr;

<span class="enscript-type">static</span> lck_mtx_t        sched_groups_lock;


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_multiq_init</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> thread_t
<span class="enscript-function-name">sched_multiq_steal_thread</span>(processor_set_t pset);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_multiq_thread_update_scan</span>(sched_update_scan_context_t scan_context);

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">sched_multiq_processor_enqueue</span>(processor_t processor, thread_t thread, integer_t options);

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">sched_multiq_processor_queue_remove</span>(processor_t processor, thread_t thread);

<span class="enscript-type">void</span>
<span class="enscript-function-name">sched_multiq_quantum_expire</span>(thread_t thread);

<span class="enscript-type">static</span> ast_t
<span class="enscript-function-name">sched_multiq_processor_csw_check</span>(processor_t processor);

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">sched_multiq_processor_queue_has_priority</span>(processor_t processor, <span class="enscript-type">int</span> priority, boolean_t gte);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sched_multiq_runq_count</span>(processor_t processor);

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">sched_multiq_processor_queue_empty</span>(processor_t processor);

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">sched_multiq_runq_stats_count_sum</span>(processor_t processor);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sched_multiq_processor_bound_count</span>(processor_t processor);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_multiq_pset_init</span>(processor_set_t pset);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_multiq_processor_init</span>(processor_t processor);

<span class="enscript-type">static</span> thread_t
<span class="enscript-function-name">sched_multiq_choose_thread</span>(processor_t processor, <span class="enscript-type">int</span> priority, ast_t reason);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_multiq_processor_queue_shutdown</span>(processor_t processor);

<span class="enscript-type">static</span> sched_mode_t
<span class="enscript-function-name">sched_multiq_initial_thread_sched_mode</span>(task_t parent_task);

<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sched_dispatch_table sched_multiq_dispatch = {
	.sched_name                                     = <span class="enscript-string">&quot;multiq&quot;</span>,
	.init                                           = sched_multiq_init,
	.timebase_init                                  = sched_timeshare_timebase_init,
	.processor_init                                 = sched_multiq_processor_init,
	.pset_init                                      = sched_multiq_pset_init,
	.maintenance_continuation                       = sched_timeshare_maintenance_continue,
	.choose_thread                                  = sched_multiq_choose_thread,
	.steal_thread_enabled                           = FALSE,
	.steal_thread                                   = sched_multiq_steal_thread,
	.compute_timeshare_priority                     = sched_compute_timeshare_priority,
	.choose_processor                               = choose_processor,
	.processor_enqueue                              = sched_multiq_processor_enqueue,
	.processor_queue_shutdown                       = sched_multiq_processor_queue_shutdown,
	.processor_queue_remove                         = sched_multiq_processor_queue_remove,
	.processor_queue_empty                          = sched_multiq_processor_queue_empty,
	.priority_is_urgent                             = priority_is_urgent,
	.processor_csw_check                            = sched_multiq_processor_csw_check,
	.processor_queue_has_priority                   = sched_multiq_processor_queue_has_priority,
	.initial_quantum_size                           = sched_timeshare_initial_quantum_size,
	.initial_thread_sched_mode                      = sched_multiq_initial_thread_sched_mode,
	.can_update_priority                            = can_update_priority,
	.update_priority                                = update_priority,
	.lightweight_update_priority                    = lightweight_update_priority,
	.quantum_expire                                 = sched_multiq_quantum_expire,
	.processor_runq_count                           = sched_multiq_runq_count,
	.processor_runq_stats_count_sum                 = sched_multiq_runq_stats_count_sum,
	.processor_bound_count                          = sched_multiq_processor_bound_count,
	.thread_update_scan                             = sched_multiq_thread_update_scan,
	.direct_dispatch_to_idle_processors             = FALSE,
	.multiple_psets_enabled                         = FALSE,
	.sched_groups_enabled                           = TRUE,
};


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_multiq_init</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">MULTIQ_SANITY_CHECK</span>)
	PE_parse_boot_argn(<span class="enscript-string">&quot;-multiq-sanity-check&quot;</span>, &amp;multiq_sanity_check, <span class="enscript-keyword">sizeof</span>(multiq_sanity_check));
#<span class="enscript-reference">endif</span>

	PE_parse_boot_argn(<span class="enscript-string">&quot;-multiq-deep-drain&quot;</span>, &amp;deep_drain, <span class="enscript-keyword">sizeof</span>(deep_drain));

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;multiq_drain_ceiling&quot;</span>, &amp;drain_ceiling, <span class="enscript-keyword">sizeof</span>(drain_ceiling))) {
		drain_ceiling = DEFAULT_DRAIN_CEILING;
	}

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;multiq_drain_depth_limit&quot;</span>, &amp;drain_depth_limit, <span class="enscript-keyword">sizeof</span>(drain_depth_limit))) {
		drain_depth_limit = DEFAULT_DRAIN_DEPTH_LIMIT;
	}

	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;multiq_drain_band_limit&quot;</span>, &amp;drain_band_limit, <span class="enscript-keyword">sizeof</span>(drain_band_limit))) {
		drain_band_limit = DEFAULT_DRAIN_BAND_LIMIT;
	}

	printf(<span class="enscript-string">&quot;multiq scheduler config: deep-drain %d, ceiling %d, depth limit %d, band limit %d, sanity check %d\n&quot;</span>,
	       deep_drain, drain_ceiling, drain_depth_limit, drain_band_limit, multiq_sanity_check);

	sched_group_zone = zinit(
	                         <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sched_group),
	                         task_max * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sched_group),
	                         PAGE_SIZE,
	                         <span class="enscript-string">&quot;sched groups&quot;</span>);

	zone_change(sched_group_zone, Z_NOENCRYPT, TRUE);
	zone_change(sched_group_zone, Z_NOCALLOUT, TRUE);

	queue_init(&amp;sched_groups);

	lck_grp_attr_setdefault(&amp;sched_groups_lock_grp_attr);
	lck_grp_init(&amp;sched_groups_lock_grp, <span class="enscript-string">&quot;sched_groups&quot;</span>, &amp;sched_groups_lock_grp_attr);
	lck_attr_setdefault(&amp;sched_groups_lock_attr);
	lck_mtx_init(&amp;sched_groups_lock, &amp;sched_groups_lock_grp, &amp;sched_groups_lock_attr);

	sched_timeshare_init();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_multiq_processor_init</span>(processor_t processor)
{
	run_queue_init(&amp;processor-&gt;runq);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_multiq_pset_init</span>(processor_set_t pset)
{
	run_queue_init(&amp;pset-&gt;pset_runq);
}

<span class="enscript-type">static</span> sched_mode_t
<span class="enscript-function-name">sched_multiq_initial_thread_sched_mode</span>(task_t parent_task)
{
	<span class="enscript-keyword">if</span> (parent_task == kernel_task)
		<span class="enscript-keyword">return</span> TH_MODE_FIXED;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> TH_MODE_TIMESHARE;
}

sched_group_t
<span class="enscript-function-name">sched_group_create</span>(<span class="enscript-type">void</span>)
{
	sched_group_t       sched_group;

	<span class="enscript-keyword">if</span> (!SCHED(sched_groups_enabled))
		<span class="enscript-keyword">return</span> SCHED_GROUP_NULL;

	sched_group = (sched_group_t)zalloc(sched_group_zone);

	bzero(sched_group, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sched_group));

	run_queue_init(&amp;sched_group-&gt;runq);

	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; NRQS; i++) {
		sched_group-&gt;entries[i].runq = 0;
		sched_group-&gt;entries[i].sched_pri = i;
	}

	lck_mtx_lock(&amp;sched_groups_lock);
	queue_enter(&amp;sched_groups, sched_group, sched_group_t, sched_groups);
	num_sched_groups++;
	lck_mtx_unlock(&amp;sched_groups_lock);

	<span class="enscript-keyword">return</span> (sched_group);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sched_group_destroy</span>(sched_group_t sched_group)
{
	<span class="enscript-keyword">if</span> (!SCHED(sched_groups_enabled)) {
		assert(sched_group == SCHED_GROUP_NULL);
		<span class="enscript-keyword">return</span>;
	}

	assert(sched_group != SCHED_GROUP_NULL);
	assert(sched_group-&gt;runq.count == 0);

	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; NRQS; i++) {
		assert(sched_group-&gt;entries[i].runq == 0);
		assert(sched_group-&gt;entries[i].sched_pri == i);
	}

	lck_mtx_lock(&amp;sched_groups_lock);
	queue_remove(&amp;sched_groups, sched_group, sched_group_t, sched_groups);
	num_sched_groups--;
	lck_mtx_unlock(&amp;sched_groups_lock);

	zfree(sched_group_zone, sched_group);
}

<span class="enscript-function-name">__attribute__</span>((always_inline))
<span class="enscript-type">static</span> inline entry_queue_t
<span class="enscript-function-name">multiq_main_entryq</span>(processor_t processor)
{
	<span class="enscript-keyword">return</span> (entry_queue_t)&amp;processor-&gt;processor_set-&gt;pset_runq;
}

<span class="enscript-function-name">__attribute__</span>((always_inline))
<span class="enscript-type">static</span> inline run_queue_t
<span class="enscript-function-name">multiq_bound_runq</span>(processor_t processor)
{
	<span class="enscript-keyword">return</span> &amp;processor-&gt;runq;
}

<span class="enscript-function-name">__attribute__</span>((always_inline))
<span class="enscript-type">static</span> inline sched_entry_t
<span class="enscript-function-name">group_entry_for_pri</span>(sched_group_t group, integer_t pri)
{
	<span class="enscript-keyword">return</span> &amp;group-&gt;entries[pri];
}

<span class="enscript-function-name">__attribute__</span>((always_inline))
<span class="enscript-type">static</span> inline sched_group_t
<span class="enscript-function-name">group_for_entry</span>(sched_entry_t entry)
{
	sched_group_t group = (sched_group_t)(entry - entry-&gt;sched_pri);
	<span class="enscript-keyword">return</span> group;
}	

<span class="enscript-comment">/* Peek at the head of the runqueue */</span>
<span class="enscript-type">static</span> sched_entry_t
<span class="enscript-function-name">entry_queue_first_entry</span>(entry_queue_t rq)
{
	assert(rq-&gt;count != 0);

	queue_t queue = rq-&gt;queues + rq-&gt;highq;

	sched_entry_t entry = (sched_entry_t)queue_first(queue);

	assert(entry-&gt;sched_pri == rq-&gt;highq);

	<span class="enscript-keyword">return</span> entry;
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">MULTIQ_SANITY_CHECK</span>)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
<span class="enscript-function-name">__attribute__</span>((always_inline))
<span class="enscript-type">static</span> inline boolean_t
<span class="enscript-function-name">queue_chain_linked</span>(queue_chain_t* chain)
{
	<span class="enscript-keyword">if</span> (chain-&gt;next != NULL) {
		assert(chain-&gt;prev != NULL);
		<span class="enscript-keyword">return</span> TRUE;
	} <span class="enscript-keyword">else</span> {
		assert(chain-&gt;prev == NULL);
		<span class="enscript-keyword">return</span> FALSE;
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>

<span class="enscript-type">static</span> thread_t
<span class="enscript-function-name">group_first_thread</span>(sched_group_t group)
{
	group_runq_t rq = &amp;group-&gt;runq;

	assert(rq-&gt;count != 0);

	queue_t queue = rq-&gt;queues + rq-&gt;highq;

	thread_t thread = (thread_t)(<span class="enscript-type">void</span>*)queue_first(queue);

	assert(thread != THREAD_NULL);

	assert(thread-&gt;sched_group == group);

	<span class="enscript-comment">/* TODO: May not be safe */</span>
	assert(thread-&gt;sched_pri == rq-&gt;highq);

	<span class="enscript-keyword">return</span> thread;
}

<span class="enscript-comment">/* Asserts if entry is not in entry runq at pri */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">entry_queue_check_entry</span>(entry_queue_t runq, sched_entry_t entry, <span class="enscript-type">int</span> expected_pri)
{
	queue_t q;
	sched_entry_t elem;

	assert(queue_chain_linked(&amp;entry-&gt;links));
	assert(entry-&gt;runq == MULTIQ_ERUNQ);

	q = &amp;runq-&gt;queues[expected_pri];

	queue_iterate(q, elem, sched_entry_t, links) {
		<span class="enscript-keyword">if</span> (elem == entry)
			<span class="enscript-keyword">return</span>;
	}

	panic(<span class="enscript-string">&quot;runq %p doesn't contain entry %p at pri %d&quot;</span>, runq, entry, expected_pri);
}

<span class="enscript-comment">/* Asserts if thread is not in group at its priority */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_group_check_thread</span>(sched_group_t group, thread_t thread)
{
	queue_t q;
	thread_t elem;
	<span class="enscript-type">int</span> pri = thread-&gt;sched_pri;

	assert(thread-&gt;runq != PROCESSOR_NULL);

	q = &amp;group-&gt;runq.queues[pri];

	queue_iterate(q, elem, thread_t, links) {
		<span class="enscript-keyword">if</span> (elem == thread)
			<span class="enscript-keyword">return</span>;
	}

	panic(<span class="enscript-string">&quot;group %p doesn't contain thread %p at pri %d&quot;</span>, group, thread, pri);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">global_check_entry_queue</span>(entry_queue_t main_entryq)
{
	<span class="enscript-keyword">if</span> (main_entryq-&gt;count == 0)
		<span class="enscript-keyword">return</span>;

	sched_entry_t entry = entry_queue_first_entry(main_entryq);

	assert(entry-&gt;runq == MULTIQ_ERUNQ);

	sched_group_t group = group_for_entry(entry);

	thread_t thread = group_first_thread(group);

	__assert_only sched_entry_t thread_entry = group_entry_for_pri(thread-&gt;sched_group, thread-&gt;sched_pri);

	assert(entry-&gt;sched_pri == group-&gt;runq.highq);

	assert(entry == thread_entry);
	assert(thread-&gt;runq != PROCESSOR_NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">group_check_run_queue</span>(entry_queue_t main_entryq, sched_group_t group)
{
	<span class="enscript-keyword">if</span> (group-&gt;runq.count == 0)
		<span class="enscript-keyword">return</span>;

	thread_t thread = group_first_thread(group);

	assert(thread-&gt;runq != PROCESSOR_NULL);

	sched_entry_t sched_entry = group_entry_for_pri(thread-&gt;sched_group, thread-&gt;sched_pri);

	entry_queue_check_entry(main_entryq, sched_entry, thread-&gt;sched_pri);

	assert(sched_entry-&gt;sched_pri == thread-&gt;sched_pri);
	assert(sched_entry-&gt;runq == MULTIQ_ERUNQ);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(MULTIQ_SANITY_CHECK) */</span>

<span class="enscript-comment">/*
 * The run queue must not be empty.
 */</span>
<span class="enscript-type">static</span> sched_entry_t
<span class="enscript-function-name">entry_queue_dequeue_entry</span>(entry_queue_t rq)
{
	sched_entry_t   sched_entry;
	queue_t         queue = rq-&gt;queues + rq-&gt;highq;

	assert(rq-&gt;count &gt; 0);
	assert(!queue_empty(queue));

	sched_entry = (sched_entry_t)dequeue_head(queue);

	SCHED_STATS_RUNQ_CHANGE(&amp;rq-&gt;runq_stats, rq-&gt;count);
	rq-&gt;count--;
	<span class="enscript-keyword">if</span> (SCHED(priority_is_urgent)(rq-&gt;highq)) {
		rq-&gt;urgency--; assert(rq-&gt;urgency &gt;= 0);
	}
	<span class="enscript-keyword">if</span> (queue_empty(queue)) {
		<span class="enscript-keyword">if</span> (rq-&gt;highq != IDLEPRI)
			clrbit(MAXPRI - rq-&gt;highq, rq-&gt;bitmap);
		rq-&gt;highq = MAXPRI - ffsbit(rq-&gt;bitmap);
	}

	sched_entry-&gt;runq = 0;

	<span class="enscript-keyword">return</span> (sched_entry);
}

<span class="enscript-comment">/*
 * The run queue must not be empty.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">entry_queue_enqueue_entry</span>(
                          entry_queue_t rq,
                          sched_entry_t entry,
                          integer_t     options)
{
	<span class="enscript-type">int</span>             sched_pri = entry-&gt;sched_pri;
	queue_t         queue = rq-&gt;queues + sched_pri;
	boolean_t       result = FALSE;

	assert(entry-&gt;runq == 0);

	<span class="enscript-keyword">if</span> (queue_empty(queue)) {
		enqueue_tail(queue, (queue_entry_t)entry);

		setbit(MAXPRI - sched_pri, rq-&gt;bitmap);
		<span class="enscript-keyword">if</span> (sched_pri &gt; rq-&gt;highq) {
			rq-&gt;highq = sched_pri;
			result = TRUE;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (options &amp; SCHED_TAILQ)
			enqueue_tail(queue, (queue_entry_t)entry);
		<span class="enscript-keyword">else</span>
			enqueue_head(queue, (queue_entry_t)entry);
	}
	<span class="enscript-keyword">if</span> (SCHED(priority_is_urgent)(sched_pri))
		rq-&gt;urgency++;
	SCHED_STATS_RUNQ_CHANGE(&amp;rq-&gt;runq_stats, rq-&gt;count);
	rq-&gt;count++;

	entry-&gt;runq = MULTIQ_ERUNQ;

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/*
 * The entry must be in this runqueue.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">entry_queue_remove_entry</span>(
                         entry_queue_t  rq,
                         sched_entry_t  entry)
{
	<span class="enscript-type">int</span> sched_pri = entry-&gt;sched_pri;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">MULTIQ_SANITY_CHECK</span>)
	<span class="enscript-keyword">if</span> (multiq_sanity_check) {
		entry_queue_check_entry(rq, entry, sched_pri);
	}
#<span class="enscript-reference">endif</span>

	remqueue((queue_entry_t)entry);

	SCHED_STATS_RUNQ_CHANGE(&amp;rq-&gt;runq_stats, rq-&gt;count);
	rq-&gt;count--;
	<span class="enscript-keyword">if</span> (SCHED(priority_is_urgent)(sched_pri)) {
		rq-&gt;urgency--; assert(rq-&gt;urgency &gt;= 0);
	}

	<span class="enscript-keyword">if</span> (queue_empty(rq-&gt;queues + sched_pri)) {
		<span class="enscript-comment">/* update run queue status */</span>
		<span class="enscript-keyword">if</span> (sched_pri != IDLEPRI)
			clrbit(MAXPRI - sched_pri, rq-&gt;bitmap);
		rq-&gt;highq = MAXPRI - ffsbit(rq-&gt;bitmap);
	}

	entry-&gt;runq = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">entry_queue_change_entry</span>(
                          entry_queue_t rq,
                          sched_entry_t entry,
                          integer_t     options)
{
	<span class="enscript-type">int</span>     sched_pri   = entry-&gt;sched_pri;
	queue_t queue       = rq-&gt;queues + sched_pri;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">MULTIQ_SANITY_CHECK</span>)
	<span class="enscript-keyword">if</span> (multiq_sanity_check) {
		entry_queue_check_entry(rq, entry, sched_pri);
	}
#<span class="enscript-reference">endif</span>
	remqueue((queue_entry_t)entry);

	<span class="enscript-keyword">if</span> (options &amp; SCHED_TAILQ)
		enqueue_tail(queue, (queue_entry_t)entry);
	<span class="enscript-keyword">else</span>
		enqueue_head(queue, (queue_entry_t)entry);
}
<span class="enscript-comment">/*
 * The run queue must not be empty.
 *
 * sets queue_empty to TRUE if queue is now empty at thread_pri
 */</span>
<span class="enscript-type">static</span> thread_t
<span class="enscript-function-name">group_run_queue_dequeue_thread</span>(
                         group_runq_t   rq,
                         integer_t     *thread_pri,
                         boolean_t     *queue_empty)
{
	thread_t        thread;
	queue_t         queue = rq-&gt;queues + rq-&gt;highq;

	assert(rq-&gt;count &gt; 0);
	assert(!queue_empty(queue));

	*thread_pri = rq-&gt;highq;

	thread = (thread_t)(<span class="enscript-type">void</span>*)dequeue_head(queue);

	SCHED_STATS_RUNQ_CHANGE(&amp;rq-&gt;runq_stats, rq-&gt;count);
	rq-&gt;count--;
	<span class="enscript-keyword">if</span> (SCHED(priority_is_urgent)(rq-&gt;highq)) {
		rq-&gt;urgency--; assert(rq-&gt;urgency &gt;= 0);
	}
	<span class="enscript-keyword">if</span> (queue_empty(queue)) {
		<span class="enscript-keyword">if</span> (rq-&gt;highq != IDLEPRI)
			clrbit(MAXPRI - rq-&gt;highq, rq-&gt;bitmap);
		rq-&gt;highq = MAXPRI - ffsbit(rq-&gt;bitmap);
		*queue_empty = TRUE;
	} <span class="enscript-keyword">else</span> {
		*queue_empty = FALSE;
	}

	<span class="enscript-keyword">return</span> (thread);
}

<span class="enscript-comment">/*
 * The run queue must not be empty.
 * returns TRUE if queue was empty at thread_pri
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">group_run_queue_enqueue_thread</span>(
                         group_runq_t   rq,
                         thread_t       thread,
                         integer_t      thread_pri,
                         integer_t      options)
{
	queue_t         queue = rq-&gt;queues + thread_pri;
	boolean_t       result = FALSE;

	assert(thread-&gt;runq == PROCESSOR_NULL);

	<span class="enscript-keyword">if</span> (queue_empty(queue)) {
		enqueue_tail(queue, (queue_entry_t)thread);

		setbit(MAXPRI - thread_pri, rq-&gt;bitmap);
		<span class="enscript-keyword">if</span> (thread_pri &gt; rq-&gt;highq) {
			rq-&gt;highq = thread_pri;
		}
		result = TRUE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (options &amp; SCHED_TAILQ)
			enqueue_tail(queue, (queue_entry_t)thread);
		<span class="enscript-keyword">else</span>
			enqueue_head(queue, (queue_entry_t)thread);
	}
	<span class="enscript-keyword">if</span> (SCHED(priority_is_urgent)(thread_pri))
		rq-&gt;urgency++;
	SCHED_STATS_RUNQ_CHANGE(&amp;rq-&gt;runq_stats, rq-&gt;count);
	rq-&gt;count++;

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/*
 * The thread must be in this runqueue.
 * returns TRUE if queue is now empty at thread_pri
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">group_run_queue_remove_thread</span>(
                        group_runq_t    rq,
                        thread_t        thread,
                        integer_t       thread_pri)
{
	boolean_t       result = FALSE;

	assert(thread-&gt;runq != PROCESSOR_NULL);

	remqueue((queue_entry_t)thread);

	SCHED_STATS_RUNQ_CHANGE(&amp;rq-&gt;runq_stats, rq-&gt;count);
	rq-&gt;count--;
	<span class="enscript-keyword">if</span> (SCHED(priority_is_urgent)(thread_pri)) {
		rq-&gt;urgency--; assert(rq-&gt;urgency &gt;= 0);
	}

	<span class="enscript-keyword">if</span> (queue_empty(rq-&gt;queues + thread_pri)) {
		<span class="enscript-comment">/* update run queue status */</span>
		<span class="enscript-keyword">if</span> (thread_pri != IDLEPRI)
			clrbit(MAXPRI - thread_pri, rq-&gt;bitmap);
		rq-&gt;highq = MAXPRI - ffsbit(rq-&gt;bitmap);
		result = TRUE;
	}

	thread-&gt;runq = PROCESSOR_NULL;

	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*
 * A thread's sched pri may change out from under us because
 * we're clearing thread-&gt;runq here without the thread locked.
 * Do not rely on it to be the same as when we enqueued.
 */</span>
<span class="enscript-type">static</span> thread_t
<span class="enscript-function-name">sched_global_dequeue_thread</span>(entry_queue_t main_entryq)
{
	boolean_t pri_level_empty = FALSE;
	sched_entry_t entry;
	group_runq_t group_runq;
	thread_t thread;
	integer_t thread_pri;
	sched_group_t group;

	assert(main_entryq-&gt;count &gt; 0);

	entry = entry_queue_dequeue_entry(main_entryq);

	group = group_for_entry(entry);
	group_runq = &amp;group-&gt;runq;

	thread = group_run_queue_dequeue_thread(group_runq, &amp;thread_pri, &amp;pri_level_empty);

	thread-&gt;runq = PROCESSOR_NULL;

	<span class="enscript-keyword">if</span> (!pri_level_empty) {
		entry_queue_enqueue_entry(main_entryq, entry, SCHED_TAILQ);
	}

	<span class="enscript-keyword">return</span> thread;
}

<span class="enscript-comment">/* Dequeue a thread from the global runq without moving the entry */</span>
<span class="enscript-type">static</span> thread_t
<span class="enscript-function-name">sched_global_deep_drain_dequeue_thread</span>(entry_queue_t main_entryq)
{
	boolean_t pri_level_empty = FALSE;
	sched_entry_t entry;
	group_runq_t group_runq;
	thread_t thread;
	integer_t thread_pri;
	sched_group_t group;

	assert(main_entryq-&gt;count &gt; 0);

	entry = entry_queue_first_entry(main_entryq);

	group = group_for_entry(entry);
	group_runq = &amp;group-&gt;runq;

	thread = group_run_queue_dequeue_thread(group_runq, &amp;thread_pri, &amp;pri_level_empty);

	thread-&gt;runq = PROCESSOR_NULL;

	<span class="enscript-keyword">if</span> (pri_level_empty) {
		entry_queue_remove_entry(main_entryq, entry);
	}

	<span class="enscript-keyword">return</span> thread;
}


<span class="enscript-type">static</span> thread_t
<span class="enscript-function-name">sched_group_dequeue_thread</span>(
                           entry_queue_t main_entryq,
                           sched_group_t group)
{
	group_runq_t group_runq = &amp;group-&gt;runq;
	boolean_t pri_level_empty = FALSE;
	thread_t thread;
	integer_t thread_pri;

	thread = group_run_queue_dequeue_thread(group_runq, &amp;thread_pri, &amp;pri_level_empty);

	thread-&gt;runq = PROCESSOR_NULL;

	<span class="enscript-keyword">if</span> (pri_level_empty) {
		entry_queue_remove_entry(main_entryq, group_entry_for_pri(group, thread_pri));
	}

	<span class="enscript-keyword">return</span> thread;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_group_remove_thread</span>(
                          entry_queue_t main_entryq,
                          sched_group_t group,
                          thread_t thread)
{
	integer_t thread_pri = thread-&gt;sched_pri;
	sched_entry_t sched_entry = group_entry_for_pri(group, thread_pri);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">MULTIQ_SANITY_CHECK</span>)
	<span class="enscript-keyword">if</span> (multiq_sanity_check) {
		global_check_entry_queue(main_entryq);
		group_check_run_queue(main_entryq, group);

		sched_group_check_thread(group, thread);
		entry_queue_check_entry(main_entryq, sched_entry, thread_pri);
	}
#<span class="enscript-reference">endif</span>

	boolean_t pri_level_empty = group_run_queue_remove_thread(&amp;group-&gt;runq, thread, thread_pri);

	<span class="enscript-keyword">if</span> (pri_level_empty) {
		entry_queue_remove_entry(main_entryq, sched_entry);
	}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">MULTIQ_SANITY_CHECK</span>)
	<span class="enscript-keyword">if</span> (multiq_sanity_check) {
		global_check_entry_queue(main_entryq);
		group_check_run_queue(main_entryq, group);
	}
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_group_enqueue_thread</span>(
                           entry_queue_t        main_entryq,
                           sched_group_t        group,
                           thread_t             thread,
                           integer_t            options)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">MULTIQ_SANITY_CHECK</span>)
	<span class="enscript-keyword">if</span> (multiq_sanity_check) {
		global_check_entry_queue(main_entryq);
		group_check_run_queue(main_entryq, group);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-type">int</span> sched_pri = thread-&gt;sched_pri;

	boolean_t pri_level_was_empty = group_run_queue_enqueue_thread(&amp;group-&gt;runq, thread, sched_pri, options);

	<span class="enscript-keyword">if</span> (pri_level_was_empty) {
		<span class="enscript-comment">/*
		 * TODO: Need to figure out if passing options here is a good idea or not
		 * What effects would it have?
		 */</span>
		entry_queue_enqueue_entry(main_entryq, &amp;group-&gt;entries[sched_pri], options);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (options &amp; SCHED_HEADQ) {
		<span class="enscript-comment">/* The thread should be at the head of the line - move its entry to the front */</span>
		entry_queue_change_entry(main_entryq, &amp;group-&gt;entries[sched_pri], options);
	}
}

<span class="enscript-comment">/*
 *  Locate a thread to execute from the run queue and return it.
 *  Only choose a thread with greater or equal priority.
 *
 *  pset is locked, thread is not locked.
 *
 *  Returns THREAD_NULL if it cannot find a valid thread.
 *
 *  Note: we cannot rely on the value of thread-&gt;sched_pri in this path because
 *  we don't have the thread locked.
 *
 *  TODO: Remove tracepoints
 */</span>
<span class="enscript-type">static</span> thread_t
<span class="enscript-function-name">sched_multiq_choose_thread</span>(
                           processor_t      processor,
                           <span class="enscript-type">int</span>              priority,
                           ast_t            reason)
{
	entry_queue_t   main_entryq = multiq_main_entryq(processor);
	run_queue_t     bound_runq  = multiq_bound_runq(processor);

	boolean_t choose_bound_runq = FALSE;

	<span class="enscript-keyword">if</span> (bound_runq-&gt;highq  &lt; priority &amp;&amp;
	    main_entryq-&gt;highq &lt; priority)
		<span class="enscript-keyword">return</span> THREAD_NULL;

	<span class="enscript-keyword">if</span> (bound_runq-&gt;count &amp;&amp; main_entryq-&gt;count) {
		<span class="enscript-keyword">if</span> (bound_runq-&gt;highq &gt;= main_entryq-&gt;highq) {
			choose_bound_runq = TRUE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Use main runq */</span>
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bound_runq-&gt;count) {
		choose_bound_runq = TRUE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (main_entryq-&gt;count) {
		<span class="enscript-comment">/* Use main runq */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (THREAD_NULL);
	}

	<span class="enscript-keyword">if</span> (choose_bound_runq) {
		KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
		    MACHDBG_CODE(DBG_MACH_SCHED, MACH_MULTIQ_DEQUEUE) | DBG_FUNC_NONE,
		    MACH_MULTIQ_BOUND, main_entryq-&gt;highq, bound_runq-&gt;highq, 0, 0);

		<span class="enscript-keyword">return</span> run_queue_dequeue(bound_runq, SCHED_HEADQ);
	}

	sched_group_t group = current_thread()-&gt;sched_group;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">MULTIQ_SANITY_CHECK</span>)
	<span class="enscript-keyword">if</span> (multiq_sanity_check) {
		global_check_entry_queue(main_entryq);
		group_check_run_queue(main_entryq, group);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Determine if we should look at the group or the global queue
	 *
	 * TODO:
	 * Perhaps pass reason as a 'should look inside' argument to choose_thread
	 * Should YIELD AST override drain limit?
	 */</span>
	<span class="enscript-keyword">if</span> (group-&gt;runq.count != 0 &amp;&amp; (reason &amp; AST_PREEMPTION) == 0) {
		boolean_t favor_group = TRUE;

		integer_t global_pri = main_entryq-&gt;highq;
		integer_t group_pri  = group-&gt;runq.highq;

		<span class="enscript-comment">/*
		 * Favor the current group if the group is still the globally highest.
		 *
		 * Otherwise, consider choosing a thread from the current group
		 * even if it's lower priority than the global highest priority.
		 */</span>
		<span class="enscript-keyword">if</span> (global_pri &gt; group_pri) {
			<span class="enscript-comment">/*
			 * If there's something elsewhere above the depth limit,
			 * don't pick a thread below the limit.
			 */</span>
			<span class="enscript-keyword">if</span> (global_pri &gt; drain_depth_limit &amp;&amp; group_pri &lt;= drain_depth_limit)
				favor_group = FALSE;

			<span class="enscript-comment">/*
			 * If there's something at or above the ceiling,
			 * don't favor the group.
			 */</span>
			<span class="enscript-keyword">if</span> (global_pri &gt;= drain_ceiling)
				favor_group = FALSE;

			<span class="enscript-comment">/*
			 * Don't go more than X steps below the global highest
			 */</span>
			<span class="enscript-keyword">if</span> ((global_pri - group_pri) &gt;= drain_band_limit)
				favor_group = FALSE;
		}

		<span class="enscript-keyword">if</span> (favor_group) {
			<span class="enscript-comment">/* Pull from local runq */</span>
			KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
			    MACHDBG_CODE(DBG_MACH_SCHED, MACH_MULTIQ_DEQUEUE) | DBG_FUNC_NONE,
			    MACH_MULTIQ_GROUP, global_pri, group_pri, 0, 0);

			<span class="enscript-keyword">return</span> sched_group_dequeue_thread(main_entryq, group);
		}
	}

	KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
	    MACHDBG_CODE(DBG_MACH_SCHED, MACH_MULTIQ_DEQUEUE) | DBG_FUNC_NONE,
	    MACH_MULTIQ_GLOBAL, main_entryq-&gt;highq, group-&gt;runq.highq, 0, 0);

	<span class="enscript-comment">/* Couldn't pull from local runq, pull from global runq instead */</span>
	<span class="enscript-keyword">if</span> (deep_drain) {
		<span class="enscript-keyword">return</span> sched_global_deep_drain_dequeue_thread(main_entryq);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> sched_global_dequeue_thread(main_entryq);
	}
}


<span class="enscript-comment">/*
 * Thread must be locked, and not already be on a run queue.
 * pset is locked.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">sched_multiq_processor_enqueue</span>(
                               processor_t      processor,
                               thread_t         thread,
                               integer_t        options)
{
	boolean_t       result;

	assert(processor == thread-&gt;chosen_processor);

	<span class="enscript-keyword">if</span> (thread-&gt;bound_processor != PROCESSOR_NULL) {
		assert(thread-&gt;bound_processor == processor);

		result = run_queue_enqueue(multiq_bound_runq(processor), thread, options);
		thread-&gt;runq = processor;

		<span class="enscript-keyword">return</span> result;
	}

	sched_group_enqueue_thread(multiq_main_entryq(processor),
	                           thread-&gt;sched_group,
	                           thread, options);

	thread-&gt;runq = processor;

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-comment">/*
 * Called in the context of thread with thread and pset unlocked,
 * after updating thread priority but before propagating that priority
 * to the processor
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">sched_multiq_quantum_expire</span>(thread_t thread)
{
	<span class="enscript-keyword">if</span> (deep_drain) {
		<span class="enscript-comment">/*
		 * Move the entry at this priority to the end of the queue,
		 * to allow the next task a shot at running.
		 */</span>

		processor_t processor = thread-&gt;last_processor;
		processor_set_t pset = processor-&gt;processor_set;
		entry_queue_t entryq = multiq_main_entryq(processor);

		pset_lock(pset);

		sched_entry_t entry = group_entry_for_pri(thread-&gt;sched_group, processor-&gt;current_pri);

		<span class="enscript-keyword">if</span> (entry-&gt;runq == MULTIQ_ERUNQ) {
			entry_queue_change_entry(entryq, entry, SCHED_TAILQ);
		}

		pset_unlock(pset);
	}
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">sched_multiq_processor_queue_empty</span>(processor_t processor)
{
	<span class="enscript-keyword">return</span> multiq_main_entryq(processor)-&gt;count == 0 &amp;&amp;
	       multiq_bound_runq(processor)-&gt;count  == 0;
}

<span class="enscript-type">static</span> ast_t
<span class="enscript-function-name">sched_multiq_processor_csw_check</span>(processor_t processor)
{
	boolean_t       has_higher;
	<span class="enscript-type">int</span>             pri;

	entry_queue_t main_entryq = multiq_main_entryq(processor);
	run_queue_t   bound_runq  = multiq_bound_runq(processor);

	assert(processor-&gt;active_thread != NULL);

	pri = MAX(main_entryq-&gt;highq, bound_runq-&gt;highq);

	<span class="enscript-keyword">if</span> (processor-&gt;first_timeslice) {
		has_higher = (pri &gt; processor-&gt;current_pri);
	} <span class="enscript-keyword">else</span> {
		has_higher = (pri &gt;= processor-&gt;current_pri);
	}

	<span class="enscript-keyword">if</span> (has_higher) {
		<span class="enscript-keyword">if</span> (main_entryq-&gt;urgency &gt; 0)
			<span class="enscript-keyword">return</span> (AST_PREEMPT | AST_URGENT);

		<span class="enscript-keyword">if</span> (bound_runq-&gt;urgency &gt; 0)
			<span class="enscript-keyword">return</span> (AST_PREEMPT | AST_URGENT);

		<span class="enscript-keyword">return</span> AST_PREEMPT;
	}

	<span class="enscript-keyword">return</span> AST_NONE;
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">sched_multiq_processor_queue_has_priority</span>(
                                          processor_t   processor,
                                          <span class="enscript-type">int</span>           priority,
                                          boolean_t     gte)
{
	<span class="enscript-type">int</span> qpri = MAX(multiq_main_entryq(processor)-&gt;highq, multiq_bound_runq(processor)-&gt;highq);

	<span class="enscript-keyword">if</span> (gte)
		<span class="enscript-keyword">return</span> qpri &gt;= priority;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> qpri &gt; priority;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sched_multiq_runq_count</span>(processor_t processor)
{
	<span class="enscript-comment">/*
	 *  TODO: Decide whether to keep a count of runnable threads in the pset
	 *  or just return something less than the true count.
	 *
	 *  This needs to be fast, so no iterating the whole runq.
	 *
	 *  Another possible decision is to remove this - with global runq
	 *  it doesn't make much sense.
	 */</span>
	<span class="enscript-keyword">return</span> multiq_main_entryq(processor)-&gt;count + multiq_bound_runq(processor)-&gt;count;
}

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">sched_multiq_runq_stats_count_sum</span>(processor_t processor)
{
	<span class="enscript-comment">/*
	 * TODO: This one does need to go through all the runqueues, but it's only needed for
	 * the sched stats tool
	 */</span>

	uint64_t bound_sum = multiq_bound_runq(processor)-&gt;runq_stats.count_sum;

	<span class="enscript-keyword">if</span> (processor-&gt;cpu_id == processor-&gt;processor_set-&gt;cpu_set_low)
		<span class="enscript-keyword">return</span> bound_sum + multiq_main_entryq(processor)-&gt;runq_stats.count_sum;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> bound_sum;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sched_multiq_processor_bound_count</span>(processor_t processor)
{
	<span class="enscript-keyword">return</span> multiq_bound_runq(processor)-&gt;count;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_multiq_processor_queue_shutdown</span>(processor_t processor)
{
	processor_set_t pset = processor-&gt;processor_set;
	entry_queue_t   main_entryq = multiq_main_entryq(processor);
	thread_t        thread;
	queue_head_t    tqueue;

	<span class="enscript-comment">/* We only need to migrate threads if this is the last active processor in the pset */</span>
	<span class="enscript-keyword">if</span> (pset-&gt;online_processor_count &gt; 0) {
		pset_unlock(pset);
		<span class="enscript-keyword">return</span>;
	}

	queue_init(&amp;tqueue);

	<span class="enscript-comment">/* Note that we do not remove bound threads from the queues here */</span>

	<span class="enscript-keyword">while</span> (main_entryq-&gt;count &gt; 0) {
		thread = sched_global_dequeue_thread(main_entryq);
		enqueue_tail(&amp;tqueue, (queue_entry_t)thread);
	}

	pset_unlock(pset);

	<span class="enscript-keyword">while</span> ((thread = (thread_t)(<span class="enscript-type">void</span>*)dequeue_head(&amp;tqueue)) != THREAD_NULL) {
		thread_lock(thread);

		thread_setrun(thread, SCHED_TAILQ);

		thread_unlock(thread);
	}
}

<span class="enscript-comment">/*
 * Thread is locked
 *
 * This is why we can never read sched_pri unless we have the thread locked.
 * Which we do in the enqueue and remove cases, but not the dequeue case.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">sched_multiq_processor_queue_remove</span>(
                                    processor_t processor,
                                    thread_t    thread)
{
	boolean_t removed = FALSE;
	processor_set_t pset = processor-&gt;processor_set;

	pset_lock(pset);

	<span class="enscript-keyword">if</span> (thread-&gt;runq != PROCESSOR_NULL) {
		<span class="enscript-comment">/*
		 * Thread is on a run queue and we have a lock on
		 * that run queue.
		 */</span>

		assert(thread-&gt;runq == processor);

		<span class="enscript-keyword">if</span> (thread-&gt;bound_processor != PROCESSOR_NULL) {
			assert(processor == thread-&gt;bound_processor);
			run_queue_remove(multiq_bound_runq(processor), thread);
			thread-&gt;runq = PROCESSOR_NULL;
		} <span class="enscript-keyword">else</span> {
			sched_group_remove_thread(multiq_main_entryq(processor),
			                          thread-&gt;sched_group,
			                          thread);
		}

		removed = TRUE;
	}

	pset_unlock(pset);

	<span class="enscript-keyword">return</span> removed;
}

<span class="enscript-comment">/* pset is locked, returned unlocked */</span>
<span class="enscript-type">static</span> thread_t
<span class="enscript-function-name">sched_multiq_steal_thread</span>(processor_set_t pset)
{
	pset_unlock(pset);
	<span class="enscript-keyword">return</span> (THREAD_NULL);
}

<span class="enscript-comment">/*
 * Scan the global queue for candidate groups, and scan those groups for
 * candidate threads.
 *
 * Returns TRUE if retry is needed.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">group_scan</span>(entry_queue_t runq, sched_update_scan_context_t scan_context) {
	<span class="enscript-type">int</span>             count;
	queue_t         q;
	sched_group_t   group;
	sched_entry_t   entry;

	<span class="enscript-keyword">if</span> ((count = runq-&gt;count) &gt; 0) {
		q = runq-&gt;queues + runq-&gt;highq;
		<span class="enscript-keyword">while</span> (count &gt; 0) {
			queue_iterate(q, entry, sched_entry_t, links) {
				group = group_for_entry(entry);
				<span class="enscript-keyword">if</span> (group-&gt;runq.count &gt; 0) {
					<span class="enscript-keyword">if</span> (runq_scan(&amp;group-&gt;runq, scan_context))
						<span class="enscript-keyword">return</span> (TRUE);
				}
				count--;
			}
			q--;
		}
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sched_multiq_thread_update_scan</span>(sched_update_scan_context_t scan_context)
{
	boolean_t               restart_needed = FALSE;
	processor_t             processor = processor_list;
	processor_set_t         pset;
	thread_t                thread;
	spl_t                   s;

	<span class="enscript-comment">/*
	 *  We update the threads associated with each processor (bound and idle threads)
	 *  and then update the threads in each pset runqueue.
	 */</span>

	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">do</span> {
			pset = processor-&gt;processor_set;

			s = splsched();
			pset_lock(pset);

			restart_needed = runq_scan(multiq_bound_runq(processor), scan_context);

			pset_unlock(pset);
			splx(s);

			<span class="enscript-keyword">if</span> (restart_needed)
				<span class="enscript-keyword">break</span>;

			thread = processor-&gt;idle_thread;
			<span class="enscript-keyword">if</span> (thread != THREAD_NULL &amp;&amp; thread-&gt;sched_stamp != sched_tick) {
				<span class="enscript-keyword">if</span> (thread_update_add_thread(thread) == FALSE) {
					restart_needed = TRUE;
					<span class="enscript-keyword">break</span>;
				}
			}
		} <span class="enscript-keyword">while</span> ((processor = processor-&gt;processor_list) != NULL);

		<span class="enscript-comment">/* Ok, we now have a collection of candidates -- fix them. */</span>
		thread_update_process_threads();

	} <span class="enscript-keyword">while</span> (restart_needed);

	pset = &amp;pset0;

	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">do</span> {
			s = splsched();
			pset_lock(pset);

			restart_needed = group_scan(&amp;pset-&gt;pset_runq, scan_context);

			pset_unlock(pset);
			splx(s);

			<span class="enscript-keyword">if</span> (restart_needed)
				<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">while</span> ((pset = pset-&gt;pset_list) != NULL);

		<span class="enscript-comment">/* Ok, we now have a collection of candidates -- fix them. */</span>
		thread_update_process_threads();

	} <span class="enscript-keyword">while</span> (restart_needed);
}


</pre>
<hr />
</body></html>