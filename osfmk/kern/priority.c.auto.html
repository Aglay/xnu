<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>priority.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">priority.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	priority.c
 *	Author:	Avadis Tevanian, Jr.
 *	Date:	1986
 *
 *	Priority related scheduler bits.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ledger.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machparam.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/machine.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_MACH_APPROXIMATE_TIME</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/commpage.h&gt;</span>  <span class="enscript-comment">/* for commpage_update_mach_approximate_time */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *	thread_quantum_expire:
 *
 *	Recalculate the quantum and priority for a thread.
 *
 *	Called at splsched.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">thread_quantum_expire</span>(
	timer_call_param_t	p0,
	timer_call_param_t	p1)
{
	processor_t			processor = p0;
	thread_t			thread = p1;
	ast_t				preempt;
	uint64_t			ctime;
	<span class="enscript-type">int</span>					urgency;
	uint64_t			ignore1, ignore2;

	assert(processor == current_processor());
	assert(thread == current_thread());

	SCHED_STATS_QUANTUM_TIMER_EXPIRATION(processor);

	<span class="enscript-comment">/*
	 * We bill CPU time to both the individual thread and its task.
	 *
	 * Because this balance adjustment could potentially attempt to wake this very
	 * thread, we must credit the ledger before taking the thread lock. The ledger
	 * pointers are only manipulated by the thread itself at the ast boundary.
	 */</span>
	ledger_credit(thread-&gt;t_ledger, task_ledgers.cpu_time, thread-&gt;quantum_remaining);
	ledger_credit(thread-&gt;t_threadledger, thread_ledgers.cpu_time, thread-&gt;quantum_remaining);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_BANK</span>
	<span class="enscript-keyword">if</span> (thread-&gt;t_bankledger) {
		ledger_credit(thread-&gt;t_bankledger, bank_ledgers.cpu_time,
				(thread-&gt;quantum_remaining - thread-&gt;t_deduct_bank_ledger_time));
	}
	thread-&gt;t_deduct_bank_ledger_time = 0;
#<span class="enscript-reference">endif</span>

	ctime = mach_absolute_time();

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_MACH_APPROXIMATE_TIME</span>
	commpage_update_mach_approximate_time(ctime);
#<span class="enscript-reference">endif</span>

	thread_lock(thread);

	<span class="enscript-comment">/*
	 * We've run up until our quantum expiration, and will (potentially)
	 * continue without re-entering the scheduler, so update this now.
	 */</span>
	processor-&gt;last_dispatch = ctime;
	thread-&gt;last_run_time = ctime;

	<span class="enscript-comment">/*
	 *	Check for fail-safe trip.
	 */</span>
 	<span class="enscript-keyword">if</span> ((thread-&gt;sched_mode == TH_MODE_REALTIME || thread-&gt;sched_mode == TH_MODE_FIXED) &amp;&amp; 
 	    !(thread-&gt;sched_flags &amp; TH_SFLAG_PROMOTED_MASK) &amp;&amp;
 	    !(thread-&gt;options &amp; TH_OPT_SYSTEM_CRITICAL)) {
 		uint64_t new_computation;
  
 		new_computation = ctime - thread-&gt;computation_epoch;
 		new_computation += thread-&gt;computation_metered;
 		<span class="enscript-keyword">if</span> (new_computation &gt; max_unsafe_computation) {
			KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED, MACH_FAILSAFE)|DBG_FUNC_NONE,
					(uintptr_t)thread-&gt;sched_pri, (uintptr_t)thread-&gt;sched_mode, 0, 0, 0);

			thread-&gt;safe_release = ctime + sched_safe_duration;

			sched_thread_mode_demote(thread, TH_SFLAG_FAILSAFE);
		}
	}

	<span class="enscript-comment">/*
	 *	Recompute scheduled priority if appropriate.
	 */</span>
	<span class="enscript-keyword">if</span> (SCHED(can_update_priority)(thread))
		SCHED(update_priority)(thread);
	<span class="enscript-keyword">else</span>
		SCHED(lightweight_update_priority)(thread);

	<span class="enscript-keyword">if</span> (thread-&gt;sched_mode != TH_MODE_REALTIME)
		SCHED(quantum_expire)(thread);

	processor-&gt;current_pri = thread-&gt;sched_pri;
	processor-&gt;current_thmode = thread-&gt;sched_mode;

	<span class="enscript-comment">/* Tell platform layer that we are still running this thread */</span>
	urgency = thread_get_urgency(thread, &amp;ignore1, &amp;ignore2);
	machine_thread_going_on_core(thread, urgency, 0);

	<span class="enscript-comment">/*
	 *	This quantum is up, give this thread another.
	 */</span>
	processor-&gt;first_timeslice = FALSE;

	thread_quantum_init(thread);

	<span class="enscript-comment">/* Reload precise timing global policy to thread-local policy */</span>
	thread-&gt;precise_user_kernel_time = use_precise_user_kernel_time(thread);

	<span class="enscript-comment">/*
	 * Since non-precise user/kernel time doesn't update the state/thread timer
	 * during privilege transitions, synthesize an event now.
	 */</span>
	<span class="enscript-keyword">if</span> (!thread-&gt;precise_user_kernel_time) {
		timer_switch(PROCESSOR_DATA(processor, current_state),
					 ctime,
					 PROCESSOR_DATA(processor, current_state));
		timer_switch(PROCESSOR_DATA(processor, thread_timer),
					 ctime,
					 PROCESSOR_DATA(processor, thread_timer));
	}

	processor-&gt;quantum_end = ctime + thread-&gt;quantum_remaining;

	<span class="enscript-comment">/*
	 *	Context switch check.
	 */</span>
	<span class="enscript-keyword">if</span> ((preempt = csw_check(processor, AST_QUANTUM)) != AST_NONE)
		ast_on(preempt);

	thread_unlock(thread);

	timer_call_enter1(&amp;processor-&gt;quantum_timer, thread,
	    processor-&gt;quantum_end, TIMER_CALL_SYS_CRITICAL | TIMER_CALL_LOCAL);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_SCHED_TIMESHARE_CORE</span>)
	sched_timeshare_consider_maintenance(ctime);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_SCHED_TIMESHARE_CORE */</span>

}

<span class="enscript-comment">/*
 *	sched_set_thread_base_priority:
 *
 *	Set the base priority of the thread
 *	and reset its scheduled priority.
 *
 *	This is the only path to change base_pri.
 *
 *	Called with the thread locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">sched_set_thread_base_priority</span>(thread_t thread, <span class="enscript-type">int</span> priority)
{
	thread-&gt;base_pri = priority;

	thread_recompute_sched_pri(thread, FALSE);
}

<span class="enscript-comment">/*
 *	thread_recompute_sched_pri:
 *
 *	Reset the scheduled priority of the thread
 *	according to its base priority if the
 *	thread has not been promoted or depressed.
 *
 *	This is the standard way to push base_pri changes into sched_pri,
 *	or to recalculate the appropriate sched_pri after clearing
 *	a promotion or depression.
 *
 *	Called at splsched with the thread locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">thread_recompute_sched_pri</span>(
                           thread_t thread,
                           boolean_t override_depress)
{
	<span class="enscript-type">int</span> priority;

	<span class="enscript-keyword">if</span> (thread-&gt;sched_mode == TH_MODE_TIMESHARE)
		priority = SCHED(compute_timeshare_priority)(thread);
	<span class="enscript-keyword">else</span>
		priority = thread-&gt;base_pri;

	<span class="enscript-keyword">if</span> ((!(thread-&gt;sched_flags &amp; TH_SFLAG_PROMOTED_MASK)  || (priority &gt; thread-&gt;sched_pri)) &amp;&amp;
	    (!(thread-&gt;sched_flags &amp; TH_SFLAG_DEPRESSED_MASK) || override_depress)) {
		set_sched_pri(thread, priority);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sched_default_quantum_expire</span>(thread_t thread __unused)
{
      <span class="enscript-comment">/*
       * No special behavior when a timeshare, fixed, or realtime thread
       * uses up its entire quantum
       */</span>
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_SCHED_TIMESHARE_CORE</span>)

<span class="enscript-comment">/*
 *	lightweight_update_priority:
 *
 *	Update the scheduled priority for
 *	a timesharing thread.
 *
 *	Only for use on the current thread.
 *
 *	Called with the thread locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lightweight_update_priority</span>(thread_t thread)
{
	assert(thread-&gt;runq == PROCESSOR_NULL);
	assert(thread == current_thread());

	<span class="enscript-keyword">if</span> (thread-&gt;sched_mode == TH_MODE_TIMESHARE) {
		<span class="enscript-type">int</span> priority;
		uint32_t delta;

		thread_timer_delta(thread, delta);

		<span class="enscript-comment">/*
		 *	Accumulate timesharing usage only
		 *	during contention for processor
		 *	resources.
		 */</span>
		<span class="enscript-keyword">if</span> (thread-&gt;pri_shift &lt; INT8_MAX)
			thread-&gt;sched_usage += delta;

		thread-&gt;cpu_delta += delta;

		priority = sched_compute_timeshare_priority(thread);

		<span class="enscript-comment">/*
		 * Adjust the scheduled priority like thread_recompute_sched_pri,
		 * except with the benefit of knowing the thread is on this core.
		 */</span>
		<span class="enscript-keyword">if</span> ((!(thread-&gt;sched_flags &amp; TH_SFLAG_PROMOTED_MASK)  || (priority &gt; thread-&gt;sched_pri)) &amp;&amp;
		    (!(thread-&gt;sched_flags &amp; TH_SFLAG_DEPRESSED_MASK)) &amp;&amp;
		    priority != thread-&gt;sched_pri) {

			thread-&gt;sched_pri = priority;

			KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED, MACH_SCHED_CHANGE_PRIORITY),
			                      (uintptr_t)thread_tid(thread),
			                      thread-&gt;base_pri,
			                      thread-&gt;sched_pri,
			                      0, <span class="enscript-comment">/* eventually, 'reason' */</span>
			                      0);
		}
	}
}

<span class="enscript-comment">/*
 *	Define shifts for simulating (5/8) ** n
 *
 *	Shift structures for holding update shifts.  Actual computation
 *	is  usage = (usage &gt;&gt; shift1) +/- (usage &gt;&gt; abs(shift2))  where the
 *	+/- is determined by the sign of shift 2.
 */</span>
<span class="enscript-type">struct</span> shift_data {
	<span class="enscript-type">int</span>	shift1;
	<span class="enscript-type">int</span>	shift2;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SCHED_DECAY_TICKS</span>	32
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> shift_data	sched_decay_shifts[SCHED_DECAY_TICKS] = {
	{1,1},{1,3},{1,-3},{2,-7},{3,5},{3,-5},{4,-8},{5,7},
	{5,-7},{6,-10},{7,10},{7,-9},{8,-11},{9,12},{9,-11},{10,-13},
	{11,14},{11,-13},{12,-15},{13,17},{13,-15},{14,-17},{15,19},{16,18},
	{16,-19},{17,22},{18,20},{18,-20},{19,26},{20,22},{20,-22},{21,-27}
};

<span class="enscript-comment">/*
 *	sched_compute_timeshare_priority:
 *
 *	Calculate the timesharing priority based upon usage and load.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> sched_pri_decay_band_limit;


<span class="enscript-type">int</span>
<span class="enscript-function-name">sched_compute_timeshare_priority</span>(thread_t thread)
{
	<span class="enscript-comment">/* start with base priority */</span>
	<span class="enscript-type">int</span> priority = thread-&gt;base_pri - (thread-&gt;sched_usage &gt;&gt; thread-&gt;pri_shift);

	<span class="enscript-keyword">if</span> (priority &lt; MINPRI_USER)
		priority = MINPRI_USER;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (priority &gt; MAXPRI_KERNEL)
		priority = MAXPRI_KERNEL;

	<span class="enscript-keyword">return</span> priority;
}


<span class="enscript-comment">/*
 *	can_update_priority
 *
 *	Make sure we don't do re-dispatches more frequently than a scheduler tick.
 *
 *	Called with the thread locked.
 */</span>
boolean_t
<span class="enscript-function-name">can_update_priority</span>(
					thread_t	thread)
{
	<span class="enscript-keyword">if</span> (sched_tick == thread-&gt;sched_stamp)
		<span class="enscript-keyword">return</span> (FALSE);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-comment">/*
 *	update_priority
 *
 *	Perform housekeeping operations driven by scheduler tick.
 *
 *	Called with the thread locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">update_priority</span>(
	<span class="enscript-type">register</span> thread_t	thread)
{
	<span class="enscript-type">register</span> <span class="enscript-type">unsigned</span>	ticks;
	<span class="enscript-type">register</span> uint32_t	delta;

	ticks = sched_tick - thread-&gt;sched_stamp;
	assert(ticks != 0);
	thread-&gt;sched_stamp += ticks;
	<span class="enscript-keyword">if</span> (sched_use_combined_fgbg_decay)
		thread-&gt;pri_shift = sched_combined_fgbg_pri_shift;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_THROTTLED)
		thread-&gt;pri_shift = sched_background_pri_shift;
	<span class="enscript-keyword">else</span>
		thread-&gt;pri_shift = sched_pri_shift;

	<span class="enscript-comment">/* If requested, accelerate aging of sched_usage */</span>
	<span class="enscript-keyword">if</span> (sched_decay_usage_age_factor &gt; 1)
		ticks *= sched_decay_usage_age_factor;

	<span class="enscript-comment">/*
	 *	Gather cpu usage data.
	 */</span>
	thread_timer_delta(thread, delta);
	<span class="enscript-keyword">if</span> (ticks &lt; SCHED_DECAY_TICKS) {
		<span class="enscript-type">register</span> <span class="enscript-type">struct</span> shift_data	*shiftp;

		<span class="enscript-comment">/*
		 *	Accumulate timesharing usage only
		 *	during contention for processor
		 *	resources.
		 */</span>
		<span class="enscript-keyword">if</span> (thread-&gt;pri_shift &lt; INT8_MAX)
			thread-&gt;sched_usage += delta;

		thread-&gt;cpu_usage += delta + thread-&gt;cpu_delta;
		thread-&gt;cpu_delta = 0;

		shiftp = &amp;sched_decay_shifts[ticks];
		<span class="enscript-keyword">if</span> (shiftp-&gt;shift2 &gt; 0) {
		    thread-&gt;cpu_usage =
						(thread-&gt;cpu_usage &gt;&gt; shiftp-&gt;shift1) +
						(thread-&gt;cpu_usage &gt;&gt; shiftp-&gt;shift2);
		    thread-&gt;sched_usage =
						(thread-&gt;sched_usage &gt;&gt; shiftp-&gt;shift1) +
						(thread-&gt;sched_usage &gt;&gt; shiftp-&gt;shift2);
		}
		<span class="enscript-keyword">else</span> {
		    thread-&gt;cpu_usage =
						(thread-&gt;cpu_usage &gt;&gt; shiftp-&gt;shift1) -
						(thread-&gt;cpu_usage &gt;&gt; -(shiftp-&gt;shift2));
		    thread-&gt;sched_usage =
						(thread-&gt;sched_usage &gt;&gt; shiftp-&gt;shift1) -
						(thread-&gt;sched_usage &gt;&gt; -(shiftp-&gt;shift2));
		}
	}
	<span class="enscript-keyword">else</span> {
		thread-&gt;cpu_usage = thread-&gt;cpu_delta = 0;
		thread-&gt;sched_usage = 0;
	}

	<span class="enscript-comment">/*
	 *	Check for fail-safe release.
	 */</span>
	<span class="enscript-keyword">if</span> ((thread-&gt;sched_flags &amp; TH_SFLAG_FAILSAFE) &amp;&amp;
	    mach_absolute_time() &gt;= thread-&gt;safe_release) {
		sched_thread_mode_undemote(thread, TH_SFLAG_FAILSAFE);
	}

	<span class="enscript-comment">/*
	 *	Recompute scheduled priority if appropriate.
	 */</span>
	<span class="enscript-keyword">if</span> (thread-&gt;sched_mode == TH_MODE_TIMESHARE) {
		<span class="enscript-type">int</span> priority = sched_compute_timeshare_priority(thread);

		<span class="enscript-comment">/*
		 * Adjust the scheduled priority like thread_recompute_sched_pri,
		 * except without setting an AST.
		 */</span>
		<span class="enscript-keyword">if</span> ((!(thread-&gt;sched_flags &amp; TH_SFLAG_PROMOTED_MASK)  || (priority &gt; thread-&gt;sched_pri)) &amp;&amp;
		    (!(thread-&gt;sched_flags &amp; TH_SFLAG_DEPRESSED_MASK)) &amp;&amp;
		    priority != thread-&gt;sched_pri) {

			boolean_t removed = thread_run_queue_remove(thread);

			thread-&gt;sched_pri = priority;

			KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED, MACH_SCHED_CHANGE_PRIORITY),
			                      (uintptr_t)thread_tid(thread),
			                      thread-&gt;base_pri,
			                      thread-&gt;sched_pri,
			                      0, <span class="enscript-comment">/* eventually, 'reason' */</span>
			                      0);

			<span class="enscript-keyword">if</span> (removed)
				thread_run_queue_reinsert(thread, SCHED_TAILQ);
		}
	}

	<span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_SCHED_TIMESHARE_CORE */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
<span class="enscript-comment">/* sched_mode == TH_MODE_TIMESHARE controls whether a thread has a timeshare count when it has a run count */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">sched_share_incr</span>(thread_t thread) {
	assert((thread-&gt;state &amp; (TH_RUN|TH_IDLE)) == TH_RUN);
	assert(thread-&gt;sched_mode == TH_MODE_TIMESHARE);
	assert(thread-&gt;SHARE_COUNT == 0);
	thread-&gt;SHARE_COUNT++;
	(<span class="enscript-type">void</span>)hw_atomic_add(&amp;sched_share_count, 1);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">sched_share_decr</span>(thread_t thread) {
	assert((thread-&gt;state &amp; (TH_RUN|TH_IDLE)) != TH_RUN || thread-&gt;sched_mode != TH_MODE_TIMESHARE);
	assert(thread-&gt;SHARE_COUNT == 1);
	(<span class="enscript-type">void</span>)hw_atomic_sub(&amp;sched_share_count, 1);
	thread-&gt;SHARE_COUNT--;
}

<span class="enscript-comment">/* TH_SFLAG_THROTTLED controls whether a thread has a background count when it has a run count and a share count */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">sched_background_incr</span>(thread_t thread) {
	assert((thread-&gt;state &amp; (TH_RUN|TH_IDLE)) == TH_RUN);
	assert(thread-&gt;sched_mode == TH_MODE_TIMESHARE);
	assert((thread-&gt;sched_flags &amp; TH_SFLAG_THROTTLED) == TH_SFLAG_THROTTLED);

	assert(thread-&gt;BG_COUNT == 0);
	thread-&gt;BG_COUNT++;
	<span class="enscript-type">int</span> val = hw_atomic_add(&amp;sched_background_count, 1);
	assert(val &gt;= 0);

	<span class="enscript-comment">/* Always do the background change while holding a share count */</span>
	assert(thread-&gt;SHARE_COUNT == 1);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">sched_background_decr</span>(thread_t thread) {
	<span class="enscript-keyword">if</span> ((thread-&gt;state &amp; (TH_RUN|TH_IDLE)) == TH_RUN &amp;&amp; thread-&gt;sched_mode == TH_MODE_TIMESHARE)
		assert((thread-&gt;sched_flags &amp; TH_SFLAG_THROTTLED) != TH_SFLAG_THROTTLED);
	assert(thread-&gt;BG_COUNT == 1);
	<span class="enscript-type">int</span> val = hw_atomic_sub(&amp;sched_background_count, 1);
	thread-&gt;BG_COUNT--;
	assert(val &gt;= 0);
	assert(thread-&gt;BG_COUNT == 0);

	<span class="enscript-comment">/* Always do the background change while holding a share count */</span>
	assert(thread-&gt;SHARE_COUNT == 1);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">assert_thread_sched_count</span>(thread_t thread) {
	<span class="enscript-comment">/* Only 0 or 1 are acceptable values */</span>
	assert(thread-&gt;BG_COUNT    == 0 || thread-&gt;BG_COUNT    == 1);
	assert(thread-&gt;SHARE_COUNT == 0 || thread-&gt;SHARE_COUNT == 1);

	<span class="enscript-comment">/* BG is only allowed when you already have a share count */</span>
	<span class="enscript-keyword">if</span> (thread-&gt;BG_COUNT == 1)
		assert(thread-&gt;SHARE_COUNT == 1);
	<span class="enscript-keyword">if</span> (thread-&gt;SHARE_COUNT == 0)
		assert(thread-&gt;BG_COUNT == 0);

	<span class="enscript-keyword">if</span> ((thread-&gt;state &amp; (TH_RUN|TH_IDLE)) != TH_RUN ||
	    (thread-&gt;sched_mode != TH_MODE_TIMESHARE))
		assert(thread-&gt;SHARE_COUNT == 0);

	<span class="enscript-keyword">if</span> ((thread-&gt;state &amp; (TH_RUN|TH_IDLE)) == TH_RUN &amp;&amp;
	    (thread-&gt;sched_mode == TH_MODE_TIMESHARE))
		assert(thread-&gt;SHARE_COUNT == 1);

	<span class="enscript-keyword">if</span> ((thread-&gt;state &amp; (TH_RUN|TH_IDLE)) != TH_RUN ||
	    (thread-&gt;sched_mode != TH_MODE_TIMESHARE)    ||
	    !(thread-&gt;sched_flags &amp; TH_SFLAG_THROTTLED))
		assert(thread-&gt;BG_COUNT == 0);

	<span class="enscript-keyword">if</span> ((thread-&gt;state &amp; (TH_RUN|TH_IDLE)) == TH_RUN &amp;&amp;
	    (thread-&gt;sched_mode == TH_MODE_TIMESHARE)    &amp;&amp;
	    (thread-&gt;sched_flags &amp; TH_SFLAG_THROTTLED))
		assert(thread-&gt;BG_COUNT == 1);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>

<span class="enscript-comment">/*
 * Set the thread's true scheduling mode
 * Called with thread mutex and thread locked
 * The thread has already been removed from the runqueue.
 *
 * (saved_mode is handled before this point)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">sched_set_thread_mode</span>(thread_t thread, sched_mode_t new_mode)
{
	assert_thread_sched_count(thread);
	assert(thread-&gt;runq == PROCESSOR_NULL);

	sched_mode_t old_mode = thread-&gt;sched_mode;

	thread-&gt;sched_mode = new_mode;

	<span class="enscript-keyword">switch</span> (new_mode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TH_MODE_FIXED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TH_MODE_REALTIME</span>:
			<span class="enscript-keyword">if</span> (old_mode == TH_MODE_TIMESHARE) {
				<span class="enscript-keyword">if</span> ((thread-&gt;state &amp; (TH_RUN|TH_IDLE)) == TH_RUN) {
					<span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_THROTTLED)
						sched_background_decr(thread);

					sched_share_decr(thread);
				}
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TH_MODE_TIMESHARE</span>:
			<span class="enscript-keyword">if</span> (old_mode != TH_MODE_TIMESHARE) {
				<span class="enscript-keyword">if</span> ((thread-&gt;state &amp; (TH_RUN|TH_IDLE)) == TH_RUN) {
					sched_share_incr(thread);

					<span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_THROTTLED)
						sched_background_incr(thread);
				}
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;unexpected mode: %d&quot;</span>, new_mode);
			<span class="enscript-keyword">break</span>;
	}

	assert_thread_sched_count(thread);
}

<span class="enscript-comment">/*
 * Demote the true scheduler mode to timeshare (called with the thread locked)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">sched_thread_mode_demote</span>(thread_t thread, uint32_t reason)
{
	assert(reason &amp; TH_SFLAG_DEMOTED_MASK);
	assert((thread-&gt;sched_flags &amp; reason) != reason);
	assert_thread_sched_count(thread);

	<span class="enscript-keyword">if</span> (thread-&gt;policy_reset)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_DEMOTED_MASK) {
		<span class="enscript-comment">/* Another demotion reason is already active */</span>
		thread-&gt;sched_flags |= reason;
		<span class="enscript-keyword">return</span>;
	}

	assert(thread-&gt;saved_mode == TH_MODE_NONE);

	boolean_t removed = thread_run_queue_remove(thread);

	thread-&gt;sched_flags |= reason;

	thread-&gt;saved_mode = thread-&gt;sched_mode;

	sched_set_thread_mode(thread, TH_MODE_TIMESHARE);

	thread_recompute_priority(thread);

	<span class="enscript-keyword">if</span> (removed)
		thread_run_queue_reinsert(thread, SCHED_TAILQ);

	assert_thread_sched_count(thread);
}

<span class="enscript-comment">/*
 * Un-demote the true scheduler mode back to the saved mode (called with the thread locked)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">sched_thread_mode_undemote</span>(thread_t thread, uint32_t reason)
{
	assert(reason &amp; TH_SFLAG_DEMOTED_MASK);
	assert((thread-&gt;sched_flags &amp; reason) == reason);
	assert(thread-&gt;saved_mode != TH_MODE_NONE);
	assert(thread-&gt;sched_mode == TH_MODE_TIMESHARE);
	assert(thread-&gt;policy_reset == 0);

	assert_thread_sched_count(thread);

	thread-&gt;sched_flags &amp;= ~reason;

	<span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_DEMOTED_MASK) {
		<span class="enscript-comment">/* Another demotion reason is still active */</span>
		<span class="enscript-keyword">return</span>;
	}

	boolean_t removed = thread_run_queue_remove(thread);

	sched_set_thread_mode(thread, thread-&gt;saved_mode);

	thread-&gt;saved_mode = TH_MODE_NONE;

	thread_recompute_priority(thread);

	<span class="enscript-keyword">if</span> (removed)
		thread_run_queue_reinsert(thread, SCHED_TAILQ);
}

<span class="enscript-comment">/*
 * Set the thread to be categorized as 'background'
 * Called with thread mutex and thread lock held
 *
 * TODO: Eventually, 'background' should be a true sched_mode.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">sched_set_thread_throttled</span>(thread_t thread, boolean_t wants_throttle)
{
	<span class="enscript-keyword">if</span> (thread-&gt;policy_reset)
		<span class="enscript-keyword">return</span>;

	assert(((thread-&gt;sched_flags &amp; TH_SFLAG_THROTTLED) ? TRUE : FALSE) != wants_throttle);

	assert_thread_sched_count(thread);

	<span class="enscript-comment">/*
	 * When backgrounding a thread, iOS has the semantic that
	 * realtime and fixed priority threads should be demoted
	 * to timeshare background threads.
	 *
	 * On OSX, realtime and fixed priority threads don't lose their mode.
	 */</span>

	<span class="enscript-keyword">if</span> (wants_throttle) {
		thread-&gt;sched_flags |= TH_SFLAG_THROTTLED;
		<span class="enscript-keyword">if</span> ((thread-&gt;state &amp; (TH_RUN|TH_IDLE)) == TH_RUN &amp;&amp; thread-&gt;sched_mode == TH_MODE_TIMESHARE) {
			sched_background_incr(thread);
		}

		assert_thread_sched_count(thread);

	} <span class="enscript-keyword">else</span> {
		thread-&gt;sched_flags &amp;= ~TH_SFLAG_THROTTLED;
		<span class="enscript-keyword">if</span> ((thread-&gt;state &amp; (TH_RUN|TH_IDLE)) == TH_RUN &amp;&amp; thread-&gt;sched_mode == TH_MODE_TIMESHARE) {
			sched_background_decr(thread);
		}

		assert_thread_sched_count(thread);

	}

	assert_thread_sched_count(thread);
}

</pre>
<hr />
</body></html>