<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>timer_call.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">timer_call.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1993-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Timer interrupt callout module.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/smp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/timer_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/timer_queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/call_entry.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TIMER_ASSERT</span>	1
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">//#define TIMER_ASSERT	1
</span><span class="enscript-comment">//#define TIMER_DBG	1
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TIMER_DBG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DBG</span>(x...) kprintf(<span class="enscript-string">&quot;DBG: &quot;</span> x);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DBG</span>(x...)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TIMER_TRACE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TIMER_KDEBUG_TRACE</span>	KERNEL_DEBUG_CONSTANT_IST
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TIMER_KDEBUG_TRACE</span>(x...)
#<span class="enscript-reference">endif</span>


lck_grp_t               timer_call_lck_grp;
lck_attr_t              timer_call_lck_attr;
lck_grp_attr_t          timer_call_lck_grp_attr;

lck_grp_t               timer_longterm_lck_grp;
lck_attr_t              timer_longterm_lck_attr;
lck_grp_attr_t          timer_longterm_lck_grp_attr;

<span class="enscript-comment">/* Timer queue lock must be acquired with interrupts disabled (under splclock()) */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__SMP__</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">timer_queue_lock_spin</span>(queue)					\
	lck_mtx_lock_spin_always(&amp;queue-&gt;lock_data)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">timer_queue_unlock</span>(queue)		\
	lck_mtx_unlock_always(&amp;queue-&gt;lock_data)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">timer_queue_lock_spin</span>(queue)	(void)1
#<span class="enscript-reference">define</span> <span class="enscript-function-name">timer_queue_unlock</span>(queue)		(void)1
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">QUEUE</span>(x)	((queue_t)(x))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MPQUEUE</span>(x)	((mpqueue_head_t *)(x))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TIMER_CALL</span>(x)	((timer_call_t)(x))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TCE</span>(x)		(&amp;(x-&gt;call_entry))
<span class="enscript-comment">/*
 * The longterm timer object is a global structure holding all timers
 * beyond the short-term, local timer queue threshold. The boot processor
 * is responsible for moving each timer to its local timer queue
 * if and when that timer becomes due within the threshold.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TIMER_LONGTERM_NONE</span>		EndOfAllTime
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TIMER_LONGTERM_THRESHOLD</span>	(1ULL * NSEC_PER_SEC)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TIMER_LONGTERM_THRESHOLD</span>	TIMER_LONGTERM_NONE
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	uint64_t	interval;	<span class="enscript-comment">/* longterm timer interval */</span>
	uint64_t	margin;		<span class="enscript-comment">/* fudge factor (10% of interval */</span>
	uint64_t	deadline;	<span class="enscript-comment">/* first/soonest longterm deadline */</span>
	uint64_t	preempted;	<span class="enscript-comment">/* sooner timer has pre-empted */</span>
	timer_call_t	call;		<span class="enscript-comment">/* first/soonest longterm timer call */</span>
	uint64_t	deadline_set;	<span class="enscript-comment">/* next timer set */</span>
	timer_call_data_t timer;	<span class="enscript-comment">/* timer used by threshold management */</span>
					<span class="enscript-comment">/* Stats: */</span>
	uint64_t	scans;		<span class="enscript-comment">/*   num threshold timer scans */</span>
	uint64_t	preempts;	<span class="enscript-comment">/*   num threshold reductions */</span>
	uint64_t	latency;	<span class="enscript-comment">/*   average threshold latency */</span>	
	uint64_t	latency_min;	<span class="enscript-comment">/*   minimum threshold latency */</span> 
	uint64_t	latency_max;	<span class="enscript-comment">/*   maximum threshold latency */</span>
} threshold_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	mpqueue_head_t	queue;		<span class="enscript-comment">/* longterm timer list */</span>
	uint64_t	enqueues;	<span class="enscript-comment">/* num timers queued */</span>
	uint64_t	dequeues;	<span class="enscript-comment">/* num timers dequeued */</span>
	uint64_t	escalates;	<span class="enscript-comment">/* num timers becoming shortterm */</span>
	uint64_t	scan_time;	<span class="enscript-comment">/* last time the list was scanned */</span>
	threshold_t	threshold;	<span class="enscript-comment">/* longterm timer threshold */</span>
} timer_longterm_t;

timer_longterm_t		timer_longterm;

<span class="enscript-type">static</span> mpqueue_head_t		*timer_longterm_queue = NULL;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>			timer_longterm_init(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>			timer_longterm_callout(
					timer_call_param_t	p0,
					timer_call_param_t	p1);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			timer_longterm_scan(	
					timer_longterm_t	*tlp,
					uint64_t		now);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>			timer_longterm_update(
					timer_longterm_t *tlp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>			timer_longterm_update_locked(
					timer_longterm_t *tlp);
<span class="enscript-type">static</span> mpqueue_head_t *		timer_longterm_enqueue_unlocked(
					timer_call_t		call,
					uint64_t		now,
					uint64_t		deadline,
					mpqueue_head_t **	old_queue,
					uint64_t		soft_deadline,
					uint64_t		ttd,
					timer_call_param_t	param1,
					uint32_t		callout_flags);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>			timer_longterm_dequeued_locked(
					timer_call_t		call);

uint64_t past_deadline_timers;
uint64_t past_deadline_deltas;
uint64_t past_deadline_longest;
uint64_t past_deadline_shortest = ~0ULL;
<span class="enscript-type">enum</span> {PAST_DEADLINE_TIMER_ADJUSTMENT_NS = 10 * 1000};

uint64_t past_deadline_timer_adjustment;

<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">timer_call_enter_internal</span>(timer_call_t call, timer_call_param_t param1, uint64_t deadline, uint64_t leeway, uint32_t flags, boolean_t ratelimited);
boolean_t 	mach_timer_coalescing_enabled = TRUE;

mpqueue_head_t	*timer_call_enqueue_deadline_unlocked(
			timer_call_t		call,
			mpqueue_head_t		*queue,
			uint64_t		deadline,
			uint64_t		soft_deadline,
			uint64_t		ttd,
			timer_call_param_t	param1,
			uint32_t		flags);

mpqueue_head_t	*timer_call_dequeue_unlocked(
			timer_call_t 		call);

timer_coalescing_priority_params_t tcoal_prio_params;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCOAL_PRIO_STATS</span>
int32_t nc_tcl, rt_tcl, bg_tcl, kt_tcl, fp_tcl, ts_tcl, qos_tcl;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TCOAL_PRIO_STAT</span>(x) (x++)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TCOAL_PRIO_STAT</span>(x)
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">timer_call_init_abstime</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;
	uint64_t result;
	timer_coalescing_priority_params_ns_t * tcoal_prio_params_init = timer_call_get_priority_params();
	nanoseconds_to_absolutetime(PAST_DEADLINE_TIMER_ADJUSTMENT_NS, &amp;past_deadline_timer_adjustment);
	nanoseconds_to_absolutetime(tcoal_prio_params_init-&gt;idle_entry_timer_processing_hdeadline_threshold_ns, &amp;result);
	tcoal_prio_params.idle_entry_timer_processing_hdeadline_threshold_abstime = (uint32_t)result;
	nanoseconds_to_absolutetime(tcoal_prio_params_init-&gt;interrupt_timer_coalescing_ilat_threshold_ns, &amp;result);
	tcoal_prio_params.interrupt_timer_coalescing_ilat_threshold_abstime = (uint32_t)result;
	nanoseconds_to_absolutetime(tcoal_prio_params_init-&gt;timer_resort_threshold_ns, &amp;result);
	tcoal_prio_params.timer_resort_threshold_abstime = (uint32_t)result;
	tcoal_prio_params.timer_coalesce_rt_shift = tcoal_prio_params_init-&gt;timer_coalesce_rt_shift;
	tcoal_prio_params.timer_coalesce_bg_shift = tcoal_prio_params_init-&gt;timer_coalesce_bg_shift;
	tcoal_prio_params.timer_coalesce_kt_shift = tcoal_prio_params_init-&gt;timer_coalesce_kt_shift;
	tcoal_prio_params.timer_coalesce_fp_shift = tcoal_prio_params_init-&gt;timer_coalesce_fp_shift;
	tcoal_prio_params.timer_coalesce_ts_shift = tcoal_prio_params_init-&gt;timer_coalesce_ts_shift;

	nanoseconds_to_absolutetime(tcoal_prio_params_init-&gt;timer_coalesce_rt_ns_max,
	    &amp;tcoal_prio_params.timer_coalesce_rt_abstime_max);
	nanoseconds_to_absolutetime(tcoal_prio_params_init-&gt;timer_coalesce_bg_ns_max,
	    &amp;tcoal_prio_params.timer_coalesce_bg_abstime_max);
	nanoseconds_to_absolutetime(tcoal_prio_params_init-&gt;timer_coalesce_kt_ns_max,
	    &amp;tcoal_prio_params.timer_coalesce_kt_abstime_max);
	nanoseconds_to_absolutetime(tcoal_prio_params_init-&gt;timer_coalesce_fp_ns_max,
	    &amp;tcoal_prio_params.timer_coalesce_fp_abstime_max);
	nanoseconds_to_absolutetime(tcoal_prio_params_init-&gt;timer_coalesce_ts_ns_max,
	    &amp;tcoal_prio_params.timer_coalesce_ts_abstime_max);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; NUM_LATENCY_QOS_TIERS; i++) {
		tcoal_prio_params.latency_qos_scale[i] = tcoal_prio_params_init-&gt;latency_qos_scale[i];
		nanoseconds_to_absolutetime(tcoal_prio_params_init-&gt;latency_qos_ns_max[i],
		    &amp;tcoal_prio_params.latency_qos_abstime_max[i]);
		tcoal_prio_params.latency_tier_rate_limited[i] = tcoal_prio_params_init-&gt;latency_tier_rate_limited[i];
	}
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">timer_call_init</span>(<span class="enscript-type">void</span>)
{
	lck_attr_setdefault(&amp;timer_call_lck_attr);
	lck_grp_attr_setdefault(&amp;timer_call_lck_grp_attr);
	lck_grp_init(&amp;timer_call_lck_grp, <span class="enscript-string">&quot;timer_call&quot;</span>, &amp;timer_call_lck_grp_attr);

	timer_longterm_init();
	timer_call_init_abstime();
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">timer_call_queue_init</span>(mpqueue_head_t *queue)
{
	DBG(<span class="enscript-string">&quot;timer_call_queue_init(%p)\n&quot;</span>, queue);
	mpqueue_init(queue, &amp;timer_call_lck_grp, &amp;timer_call_lck_attr);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">timer_call_setup</span>(
	timer_call_t			call,
	timer_call_func_t		func,
	timer_call_param_t		param0)
{
	DBG(<span class="enscript-string">&quot;timer_call_setup(%p,%p,%p)\n&quot;</span>, call, func, param0);
	call_entry_setup(TCE(call), func, param0);
	simple_lock_init(&amp;(call)-&gt;lock, 0);
	call-&gt;async_dequeue = FALSE;
}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TIMER_ASSERT</span>
<span class="enscript-type">static</span> __inline__ mpqueue_head_t *
<span class="enscript-function-name">timer_call_entry_dequeue</span>(
	timer_call_t		entry)
{
        mpqueue_head_t	*old_queue = MPQUEUE(TCE(entry)-&gt;queue);

	<span class="enscript-keyword">if</span> (!hw_lock_held((hw_lock_t)&amp;entry-&gt;lock))
		panic(<span class="enscript-string">&quot;_call_entry_dequeue() &quot;</span>
			<span class="enscript-string">&quot;entry %p is not locked\n&quot;</span>, entry);
	<span class="enscript-comment">/*
	 * XXX The queue lock is actually a mutex in spin mode
	 *     but there's no way to test for it being held
	 *     so we pretend it's a spinlock!
	 */</span>
	<span class="enscript-keyword">if</span> (!hw_lock_held((hw_lock_t)&amp;old_queue-&gt;lock_data))
		panic(<span class="enscript-string">&quot;_call_entry_dequeue() &quot;</span>
			<span class="enscript-string">&quot;queue %p is not locked\n&quot;</span>, old_queue);

	call_entry_dequeue(TCE(entry));
	old_queue-&gt;count--;

	<span class="enscript-keyword">return</span> (old_queue);
}

<span class="enscript-type">static</span> __inline__ mpqueue_head_t *
<span class="enscript-function-name">timer_call_entry_enqueue_deadline</span>(
	timer_call_t		entry,
	mpqueue_head_t		*queue,
	uint64_t		deadline)
{
	mpqueue_head_t	*old_queue = MPQUEUE(TCE(entry)-&gt;queue);

	<span class="enscript-keyword">if</span> (!hw_lock_held((hw_lock_t)&amp;entry-&gt;lock))
		panic(<span class="enscript-string">&quot;_call_entry_enqueue_deadline() &quot;</span>
			<span class="enscript-string">&quot;entry %p is not locked\n&quot;</span>, entry);
	<span class="enscript-comment">/* XXX More lock pretense:  */</span>
	<span class="enscript-keyword">if</span> (!hw_lock_held((hw_lock_t)&amp;queue-&gt;lock_data))
		panic(<span class="enscript-string">&quot;_call_entry_enqueue_deadline() &quot;</span>
			<span class="enscript-string">&quot;queue %p is not locked\n&quot;</span>, queue);
	<span class="enscript-keyword">if</span> (old_queue != NULL &amp;&amp; old_queue != queue)
		panic(<span class="enscript-string">&quot;_call_entry_enqueue_deadline() &quot;</span>
			<span class="enscript-string">&quot;old_queue %p != queue&quot;</span>, old_queue);

	call_entry_enqueue_deadline(TCE(entry), QUEUE(queue), deadline);

<span class="enscript-comment">/* For efficiency, track the earliest soft deadline on the queue, so that
 * fuzzy decisions can be made without lock acquisitions.
 */</span>
	timer_call_t thead = (timer_call_t)queue_first(&amp;queue-&gt;head);
	
	queue-&gt;earliest_soft_deadline = thead-&gt;flags &amp; TIMER_CALL_RATELIMITED ? TCE(thead)-&gt;deadline : thead-&gt;soft_deadline;

	<span class="enscript-keyword">if</span> (old_queue)
		old_queue-&gt;count--;
	queue-&gt;count++;

	<span class="enscript-keyword">return</span> (old_queue);
}

#<span class="enscript-reference">else</span>

<span class="enscript-type">static</span> __inline__ mpqueue_head_t *
<span class="enscript-function-name">timer_call_entry_dequeue</span>(
	timer_call_t		entry)
{
	mpqueue_head_t	*old_queue = MPQUEUE(TCE(entry)-&gt;queue);

	call_entry_dequeue(TCE(entry));
	old_queue-&gt;count--;

	<span class="enscript-keyword">return</span> old_queue;
}

<span class="enscript-type">static</span> __inline__ mpqueue_head_t *
<span class="enscript-function-name">timer_call_entry_enqueue_deadline</span>(
	timer_call_t			entry,
	mpqueue_head_t			*queue,
	uint64_t			deadline)
{
	mpqueue_head_t	*old_queue = MPQUEUE(TCE(entry)-&gt;queue);

	call_entry_enqueue_deadline(TCE(entry), QUEUE(queue), deadline);

	<span class="enscript-comment">/* For efficiency, track the earliest soft deadline on the queue,
	 * so that fuzzy decisions can be made without lock acquisitions.
	 */</span>

	timer_call_t thead = (timer_call_t)queue_first(&amp;queue-&gt;head);
	queue-&gt;earliest_soft_deadline = thead-&gt;flags &amp; TIMER_CALL_RATELIMITED ? TCE(thead)-&gt;deadline : thead-&gt;soft_deadline;

	<span class="enscript-keyword">if</span> (old_queue)
		old_queue-&gt;count--;
	queue-&gt;count++;

	<span class="enscript-keyword">return</span> old_queue;
}

#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">timer_call_entry_enqueue_tail</span>(
	timer_call_t			entry,
	mpqueue_head_t			*queue)
{
	call_entry_enqueue_tail(TCE(entry), QUEUE(queue));
	queue-&gt;count++;
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Remove timer entry from its queue but don't change the queue pointer
 * and set the async_dequeue flag. This is locking case 2b.
 */</span>
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span>
<span class="enscript-function-name">timer_call_entry_dequeue_async</span>(
	timer_call_t		entry)
{
	mpqueue_head_t	*old_queue = MPQUEUE(TCE(entry)-&gt;queue);
	<span class="enscript-keyword">if</span> (old_queue) {
		old_queue-&gt;count--;
		(<span class="enscript-type">void</span>) remque(qe(entry));
		entry-&gt;async_dequeue = TRUE;
	}
	<span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TIMER_ASSERT</span>
<span class="enscript-type">unsigned</span> timer_call_enqueue_deadline_unlocked_async1;
<span class="enscript-type">unsigned</span> timer_call_enqueue_deadline_unlocked_async2;
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*
 * Assumes call_entry and queues unlocked, interrupts disabled.
 */</span>
__inline__ mpqueue_head_t *
<span class="enscript-function-name">timer_call_enqueue_deadline_unlocked</span>(
	timer_call_t 			call,
	mpqueue_head_t			*queue,
	uint64_t			deadline,
	uint64_t			soft_deadline,
	uint64_t			ttd,
	timer_call_param_t		param1,
	uint32_t			callout_flags)
{
	call_entry_t	entry = TCE(call);
	mpqueue_head_t	*old_queue;

	DBG(<span class="enscript-string">&quot;timer_call_enqueue_deadline_unlocked(%p,%p,)\n&quot;</span>, call, queue);

	simple_lock(&amp;call-&gt;lock);

	old_queue = MPQUEUE(entry-&gt;queue);

	<span class="enscript-keyword">if</span> (old_queue != NULL) {
		timer_queue_lock_spin(old_queue);
		<span class="enscript-keyword">if</span> (call-&gt;async_dequeue) {
			<span class="enscript-comment">/* collision (1c): timer already dequeued, clear flag */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TIMER_ASSERT</span>
			TIMER_KDEBUG_TRACE(KDEBUG_TRACE, 
				DECR_TIMER_ASYNC_DEQ | DBG_FUNC_NONE,
				call,
				call-&gt;async_dequeue,
				TCE(call)-&gt;queue,
				0x1c, 0);
			timer_call_enqueue_deadline_unlocked_async1++;
#<span class="enscript-reference">endif</span>
			call-&gt;async_dequeue = FALSE;
			entry-&gt;queue = NULL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (old_queue != queue) {
			timer_call_entry_dequeue(call);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TIMER_ASSERT</span>
			timer_call_enqueue_deadline_unlocked_async2++;
#<span class="enscript-reference">endif</span>
		}
		<span class="enscript-keyword">if</span> (old_queue == timer_longterm_queue)
			timer_longterm_dequeued_locked(call);
		<span class="enscript-keyword">if</span> (old_queue != queue) {
			timer_queue_unlock(old_queue);
			timer_queue_lock_spin(queue);
		}
	} <span class="enscript-keyword">else</span> {
		timer_queue_lock_spin(queue);
	}

	call-&gt;soft_deadline = soft_deadline;
	call-&gt;flags = callout_flags;
	TCE(call)-&gt;param1 = param1;
	call-&gt;ttd = ttd;

	timer_call_entry_enqueue_deadline(call, queue, deadline);
	timer_queue_unlock(queue);
	simple_unlock(&amp;call-&gt;lock);

	<span class="enscript-keyword">return</span> (old_queue);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TIMER_ASSERT</span>
<span class="enscript-type">unsigned</span> timer_call_dequeue_unlocked_async1;
<span class="enscript-type">unsigned</span> timer_call_dequeue_unlocked_async2;
#<span class="enscript-reference">endif</span>
mpqueue_head_t *
<span class="enscript-function-name">timer_call_dequeue_unlocked</span>(
	timer_call_t 		call)
{
	call_entry_t	entry = TCE(call);
	mpqueue_head_t	*old_queue;

	DBG(<span class="enscript-string">&quot;timer_call_dequeue_unlocked(%p)\n&quot;</span>, call);

	simple_lock(&amp;call-&gt;lock);
	old_queue = MPQUEUE(entry-&gt;queue);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TIMER_ASSERT</span>
	TIMER_KDEBUG_TRACE(KDEBUG_TRACE, 
		DECR_TIMER_ASYNC_DEQ | DBG_FUNC_NONE,
		call,
		call-&gt;async_dequeue,
		TCE(call)-&gt;queue,
		0, 0);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (old_queue != NULL) {
		timer_queue_lock_spin(old_queue);
		<span class="enscript-keyword">if</span> (call-&gt;async_dequeue) {
			<span class="enscript-comment">/* collision (1c): timer already dequeued, clear flag */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TIMER_ASSERT</span>
			TIMER_KDEBUG_TRACE(KDEBUG_TRACE, 
				DECR_TIMER_ASYNC_DEQ | DBG_FUNC_NONE,
				call,
				call-&gt;async_dequeue,
				TCE(call)-&gt;queue,
				0x1c, 0);
			timer_call_dequeue_unlocked_async1++;
#<span class="enscript-reference">endif</span>
			call-&gt;async_dequeue = FALSE;
			entry-&gt;queue = NULL;
		} <span class="enscript-keyword">else</span> {
			timer_call_entry_dequeue(call);
		}
		<span class="enscript-keyword">if</span> (old_queue == timer_longterm_queue)
			timer_longterm_dequeued_locked(call);
		timer_queue_unlock(old_queue);
	}
	simple_unlock(&amp;call-&gt;lock);
	<span class="enscript-keyword">return</span> (old_queue);
}


<span class="enscript-comment">/*
 * Timer call entry locking model
 * ==============================
 *
 * Timer call entries are linked on per-cpu timer queues which are protected
 * by the queue lock and the call entry lock. The locking protocol is:
 *
 *  0) The canonical locking order is timer call entry followed by queue.
 *
 *  1) With only the entry lock held, entry.queue is valid:
 *    1a) NULL: the entry is not queued, or
 *    1b) non-NULL: this queue must be locked before the entry is modified.
 *        After locking the queue, the call.async_dequeue flag must be checked:
 *    1c) TRUE: the entry was removed from the queue by another thread
 *	        and we must NULL the entry.queue and reset this flag, or
 *    1d) FALSE: (ie. queued), the entry can be manipulated.
 *
 *  2) If a queue lock is obtained first, the queue is stable:
 *    2a) If a try-lock of a queued entry succeeds, the call can be operated on
 *	  and dequeued.
 *    2b) If a try-lock fails, it indicates that another thread is attempting
 *        to change the entry and move it to a different position in this queue
 *        or to different queue. The entry can be dequeued but it should not be
 *        operated upon since it is being changed. Furthermore, we don't null
 *	  the entry.queue pointer (protected by the entry lock we don't own).
 *	  Instead, we set the async_dequeue flag -- see (1c).
 *    2c) Same as 2b but occurring when a longterm timer is matured.
 *  3) A callout's parameters (deadline, flags, parameters, soft deadline &amp;c.)
 *     should be manipulated with the appropriate timer queue lock held,
 *     to prevent queue traversal observations from observing inconsistent
 *     updates to an in-flight callout.
 */</span>

<span class="enscript-comment">/*
 * Inlines timer_call_entry_dequeue() and timer_call_entry_enqueue_deadline()
 * cast between pointer types (mpqueue_head_t *) and (queue_t) so that
 * we can use the call_entry_dequeue() and call_entry_enqueue_deadline()
 * methods to operate on timer_call structs as if they are call_entry structs.
 * These structures are identical except for their queue head pointer fields.
 *
 * In the debug case, we assert that the timer call locking protocol 
 * is being obeyed.
 */</span>

<span class="enscript-type">static</span> boolean_t 
<span class="enscript-function-name">timer_call_enter_internal</span>(
	timer_call_t 		call,
	timer_call_param_t	param1,
	uint64_t 		deadline,
	uint64_t 		leeway,
	uint32_t 		flags,
	boolean_t		ratelimited)
{
	mpqueue_head_t		*queue = NULL;
	mpqueue_head_t		*old_queue;
	spl_t			s;
	uint64_t 		slop;
	uint32_t		urgency;
	uint64_t		sdeadline, ttd;

	s = splclock();

	sdeadline = deadline;
	uint64_t ctime = mach_absolute_time();

	TIMER_KDEBUG_TRACE(KDEBUG_TRACE,
        	DECR_TIMER_ENTER | DBG_FUNC_START,
		call,
		param1, deadline, flags, 0); 

	urgency = (flags &amp; TIMER_CALL_URGENCY_MASK);

	boolean_t slop_ratelimited = FALSE;
	slop = timer_call_slop(deadline, ctime, urgency, current_thread(), &amp;slop_ratelimited);

	<span class="enscript-keyword">if</span> ((flags &amp; TIMER_CALL_LEEWAY) != 0 &amp;&amp; leeway &gt; slop)
		slop = leeway;

	<span class="enscript-keyword">if</span> (UINT64_MAX - deadline &lt;= slop) {
		deadline = UINT64_MAX;
	} <span class="enscript-keyword">else</span> {
		deadline += slop;
	}

	<span class="enscript-keyword">if</span> (__improbable(deadline &lt; ctime)) {
		uint64_t delta = (ctime - deadline);

		past_deadline_timers++;
		past_deadline_deltas += delta;
		<span class="enscript-keyword">if</span> (delta &gt; past_deadline_longest)
			past_deadline_longest = deadline;
		<span class="enscript-keyword">if</span> (delta &lt; past_deadline_shortest)
			past_deadline_shortest = delta;

		deadline = ctime + past_deadline_timer_adjustment;
		sdeadline = deadline;
	}

	<span class="enscript-keyword">if</span> (ratelimited || slop_ratelimited) {
		flags |= TIMER_CALL_RATELIMITED;
	} <span class="enscript-keyword">else</span> {
		flags &amp;= ~TIMER_CALL_RATELIMITED;
	}

	ttd =  sdeadline - ctime;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	DTRACE_TMR7(callout__create, timer_call_func_t, TCE(call)-&gt;func,
	timer_call_param_t, TCE(call)-&gt;param0, uint32_t, flags,
	    (deadline - sdeadline),
	    (ttd &gt;&gt; 32), (<span class="enscript-type">unsigned</span>) (ttd &amp; 0xFFFFFFFF), call);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Program timer callout parameters under the appropriate per-CPU or
	 * longterm queue lock. The callout may have been previously enqueued
	 * and in-flight on this or another timer queue.
	 */</span>
	<span class="enscript-keyword">if</span> (!ratelimited &amp;&amp; !slop_ratelimited) {
		queue = timer_longterm_enqueue_unlocked(call, ctime, deadline, &amp;old_queue, sdeadline, ttd, param1, flags);
	}

	<span class="enscript-keyword">if</span> (queue == NULL) {
		queue = timer_queue_assign(deadline);
		old_queue = timer_call_enqueue_deadline_unlocked(call, queue, deadline, sdeadline, ttd, param1, flags);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TIMER_TRACE</span>
	TCE(call)-&gt;entry_time = ctime;
#<span class="enscript-reference">endif</span>

	TIMER_KDEBUG_TRACE(KDEBUG_TRACE,
        	DECR_TIMER_ENTER | DBG_FUNC_END,
		call,
		(old_queue != NULL), deadline, queue-&gt;count, 0); 

	splx(s);

	<span class="enscript-keyword">return</span> (old_queue != NULL);
}

<span class="enscript-comment">/*
 * timer_call_*()
 *	return boolean indicating whether the call was previously queued.
 */</span>
boolean_t
<span class="enscript-function-name">timer_call_enter</span>(
	timer_call_t		call,
	uint64_t		deadline,
	uint32_t		flags)
{
	<span class="enscript-keyword">return</span> timer_call_enter_internal(call, NULL, deadline, 0, flags, FALSE);
}

boolean_t
<span class="enscript-function-name">timer_call_enter1</span>(
	timer_call_t		call,
	timer_call_param_t	param1,
	uint64_t		deadline,
	uint32_t		flags)
{
	<span class="enscript-keyword">return</span> timer_call_enter_internal(call, param1, deadline, 0, flags, FALSE);
}

boolean_t
<span class="enscript-function-name">timer_call_enter_with_leeway</span>(
	timer_call_t		call,
	timer_call_param_t	param1,
	uint64_t		deadline,
	uint64_t		leeway,
	uint32_t		flags,
	boolean_t		ratelimited)
{
	<span class="enscript-keyword">return</span> timer_call_enter_internal(call, param1, deadline, leeway, flags, ratelimited);
}

boolean_t
<span class="enscript-function-name">timer_call_cancel</span>(
	timer_call_t		call)
{
	mpqueue_head_t		*old_queue;
	spl_t			s;

	s = splclock();

	TIMER_KDEBUG_TRACE(KDEBUG_TRACE,
        	DECR_TIMER_CANCEL | DBG_FUNC_START,
		call,
		TCE(call)-&gt;deadline, call-&gt;soft_deadline, call-&gt;flags, 0);

	old_queue = timer_call_dequeue_unlocked(call);

	<span class="enscript-keyword">if</span> (old_queue != NULL) {
		timer_queue_lock_spin(old_queue);
		<span class="enscript-keyword">if</span> (!queue_empty(&amp;old_queue-&gt;head)) {
			timer_queue_cancel(old_queue, TCE(call)-&gt;deadline, CE(queue_first(&amp;old_queue-&gt;head))-&gt;deadline);
 			timer_call_t thead = (timer_call_t)queue_first(&amp;old_queue-&gt;head);
 			old_queue-&gt;earliest_soft_deadline = thead-&gt;flags &amp; TIMER_CALL_RATELIMITED ? TCE(thead)-&gt;deadline : thead-&gt;soft_deadline;
		}
		<span class="enscript-keyword">else</span> {
			timer_queue_cancel(old_queue, TCE(call)-&gt;deadline, UINT64_MAX);
			old_queue-&gt;earliest_soft_deadline = UINT64_MAX;
		}
		timer_queue_unlock(old_queue);
	}
	TIMER_KDEBUG_TRACE(KDEBUG_TRACE,
        	DECR_TIMER_CANCEL | DBG_FUNC_END,
		call,
		old_queue,
		TCE(call)-&gt;deadline - mach_absolute_time(),
		TCE(call)-&gt;deadline - TCE(call)-&gt;entry_time, 0);
	splx(s);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	DTRACE_TMR6(callout__cancel, timer_call_func_t, TCE(call)-&gt;func,
	    timer_call_param_t, TCE(call)-&gt;param0, uint32_t, call-&gt;flags, 0,
	    (call-&gt;ttd &gt;&gt; 32), (<span class="enscript-type">unsigned</span>) (call-&gt;ttd &amp; 0xFFFFFFFF));
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (old_queue != NULL);
}

<span class="enscript-type">static</span> uint32_t	timer_queue_shutdown_lock_skips;
<span class="enscript-type">static</span> uint32_t timer_queue_shutdown_discarded;

<span class="enscript-type">void</span>
<span class="enscript-function-name">timer_queue_shutdown</span>(
	mpqueue_head_t		*queue)
{
	timer_call_t		call;
	mpqueue_head_t		*new_queue;
	spl_t			s;


	DBG(<span class="enscript-string">&quot;timer_queue_shutdown(%p)\n&quot;</span>, queue);

	s = splclock();

	<span class="enscript-comment">/* Note comma operator in while expression re-locking each iteration */</span>
	<span class="enscript-keyword">while</span> (timer_queue_lock_spin(queue), !queue_empty(&amp;queue-&gt;head)) {
		call = TIMER_CALL(queue_first(&amp;queue-&gt;head));

		<span class="enscript-keyword">if</span> (!simple_lock_try(&amp;call-&gt;lock)) {
			<span class="enscript-comment">/*
			 * case (2b) lock order inversion, dequeue and skip
			 * Don't change the call_entry queue back-pointer
			 * but set the async_dequeue field.
			 */</span>
			timer_queue_shutdown_lock_skips++;
			timer_call_entry_dequeue_async(call);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TIMER_ASSERT</span>
			TIMER_KDEBUG_TRACE(KDEBUG_TRACE, 
				DECR_TIMER_ASYNC_DEQ | DBG_FUNC_NONE,
				call,
				call-&gt;async_dequeue,
				TCE(call)-&gt;queue,
				0x2b, 0);
#<span class="enscript-reference">endif</span>
			timer_queue_unlock(queue);
			<span class="enscript-keyword">continue</span>;
		}

		boolean_t call_local = ((call-&gt;flags &amp; TIMER_CALL_LOCAL) != 0);

		<span class="enscript-comment">/* remove entry from old queue */</span>
		timer_call_entry_dequeue(call);
		timer_queue_unlock(queue);

		<span class="enscript-keyword">if</span> (call_local == FALSE) {
			<span class="enscript-comment">/* and queue it on new, discarding LOCAL timers */</span>
			new_queue = timer_queue_assign(TCE(call)-&gt;deadline);
			timer_queue_lock_spin(new_queue);
			timer_call_entry_enqueue_deadline(
				call, new_queue, TCE(call)-&gt;deadline);
			timer_queue_unlock(new_queue);
		} <span class="enscript-keyword">else</span> {
			timer_queue_shutdown_discarded++;
		}

		<span class="enscript-comment">/* The only lingering LOCAL timer should be this thread's
		 * quantum expiration timer.
		 */</span>
		assert((call_local == FALSE) ||
		    (TCE(call)-&gt;func == thread_quantum_expire));

		simple_unlock(&amp;call-&gt;lock);
	}

	timer_queue_unlock(queue);
	splx(s);
}

<span class="enscript-type">static</span> uint32_t	timer_queue_expire_lock_skips;
uint64_t
<span class="enscript-function-name">timer_queue_expire_with_options</span>(
	mpqueue_head_t		*queue,
	uint64_t		deadline,
	boolean_t		rescan)
{
	timer_call_t	call = NULL;
	uint32_t tc_iterations = 0;
	DBG(<span class="enscript-string">&quot;timer_queue_expire(%p,)\n&quot;</span>, queue);

	uint64_t cur_deadline = deadline;
	timer_queue_lock_spin(queue);

	<span class="enscript-keyword">while</span> (!queue_empty(&amp;queue-&gt;head)) {
		<span class="enscript-comment">/* Upon processing one or more timer calls, refresh the
		 * deadline to account for time elapsed in the callout
		 */</span>
		<span class="enscript-keyword">if</span> (++tc_iterations &gt; 1)
			cur_deadline = mach_absolute_time();

		<span class="enscript-keyword">if</span> (call == NULL)
			call = TIMER_CALL(queue_first(&amp;queue-&gt;head));

		<span class="enscript-keyword">if</span> (call-&gt;soft_deadline &lt;= cur_deadline) {
			timer_call_func_t		func;
			timer_call_param_t		param0, param1;

			TCOAL_DEBUG(0xDDDD0000, queue-&gt;earliest_soft_deadline, call-&gt;soft_deadline, 0, 0, 0);
			TIMER_KDEBUG_TRACE(KDEBUG_TRACE, 
				DECR_TIMER_EXPIRE | DBG_FUNC_NONE,
				call,
				call-&gt;soft_deadline,
				TCE(call)-&gt;deadline,
				TCE(call)-&gt;entry_time, 0);

			<span class="enscript-keyword">if</span> ((call-&gt;flags &amp; TIMER_CALL_RATELIMITED) &amp;&amp;
			    (TCE(call)-&gt;deadline &gt; cur_deadline)) {
				<span class="enscript-keyword">if</span> (rescan == FALSE)
					<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (!simple_lock_try(&amp;call-&gt;lock)) {
				<span class="enscript-comment">/* case (2b) lock inversion, dequeue and skip */</span>
				timer_queue_expire_lock_skips++;
				timer_call_entry_dequeue_async(call);
				call = NULL;
				<span class="enscript-keyword">continue</span>;
			}

			timer_call_entry_dequeue(call);

			func = TCE(call)-&gt;func;
			param0 = TCE(call)-&gt;param0;
			param1 = TCE(call)-&gt;param1;

			simple_unlock(&amp;call-&gt;lock);
			timer_queue_unlock(queue);

			TIMER_KDEBUG_TRACE(KDEBUG_TRACE, 
				DECR_TIMER_CALLOUT | DBG_FUNC_START,
				call, VM_KERNEL_UNSLIDE(func), param0, param1, 0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
			DTRACE_TMR7(callout__start, timer_call_func_t, func,
			    timer_call_param_t, param0, <span class="enscript-type">unsigned</span>, call-&gt;flags,
			    0, (call-&gt;ttd &gt;&gt; 32),
			    (<span class="enscript-type">unsigned</span>) (call-&gt;ttd &amp; 0xFFFFFFFF), call);
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/* Maintain time-to-deadline in per-processor data
			 * structure for thread wakeup deadline statistics.
			 */</span>
			uint64_t *ttdp = &amp;(PROCESSOR_DATA(current_processor(), timer_call_ttd));
			*ttdp = call-&gt;ttd;
			(*func)(param0, param1);
			*ttdp = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
			DTRACE_TMR4(callout__end, timer_call_func_t, func,
			    param0, param1, call);
#<span class="enscript-reference">endif</span>

			TIMER_KDEBUG_TRACE(KDEBUG_TRACE, 
				DECR_TIMER_CALLOUT | DBG_FUNC_END,
				call, VM_KERNEL_UNSLIDE(func), param0, param1, 0);
			call = NULL;
			timer_queue_lock_spin(queue);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (__probable(rescan == FALSE)) {
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> {
				int64_t skew = TCE(call)-&gt;deadline - call-&gt;soft_deadline;
				assert(TCE(call)-&gt;deadline &gt;= call-&gt;soft_deadline);

				<span class="enscript-comment">/* DRK: On a latency quality-of-service level change,
				 * re-sort potentially rate-limited timers. The platform
				 * layer determines which timers require
				 * this. In the absence of the per-callout
				 * synchronization requirement, a global resort could
				 * be more efficient. The re-sort effectively
				 * annuls all timer adjustments, i.e. the &quot;soft
				 * deadline&quot; is the sort key.
				 */</span>
	
				<span class="enscript-keyword">if</span> (timer_resort_threshold(skew)) {
					<span class="enscript-keyword">if</span> (__probable(simple_lock_try(&amp;call-&gt;lock))) {
						timer_call_entry_dequeue(call);
						timer_call_entry_enqueue_deadline(call, queue, call-&gt;soft_deadline);
						simple_unlock(&amp;call-&gt;lock);
						call = NULL;
					}
				}
				<span class="enscript-keyword">if</span> (call) {
					call = TIMER_CALL(queue_next(qe(call)));
					<span class="enscript-keyword">if</span> (queue_end(&amp;queue-&gt;head, qe(call)))
						<span class="enscript-keyword">break</span>;
				}
			}
		}
	}

	<span class="enscript-keyword">if</span> (!queue_empty(&amp;queue-&gt;head)) {
		call = TIMER_CALL(queue_first(&amp;queue-&gt;head));
		cur_deadline = TCE(call)-&gt;deadline;
		queue-&gt;earliest_soft_deadline = (call-&gt;flags &amp; TIMER_CALL_RATELIMITED) ? TCE(call)-&gt;deadline: call-&gt;soft_deadline;
	} <span class="enscript-keyword">else</span> {
		queue-&gt;earliest_soft_deadline = cur_deadline = UINT64_MAX;
	}

	timer_queue_unlock(queue);

	<span class="enscript-keyword">return</span> (cur_deadline);
}

uint64_t
<span class="enscript-function-name">timer_queue_expire</span>(
	mpqueue_head_t		*queue,
	uint64_t		deadline)
{
	<span class="enscript-keyword">return</span> timer_queue_expire_with_options(queue, deadline, FALSE);
}

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> serverperfmode;
<span class="enscript-type">static</span> uint32_t	timer_queue_migrate_lock_skips;
<span class="enscript-comment">/*
 * timer_queue_migrate() is called by timer_queue_migrate_cpu()
 * to move timer requests from the local processor (queue_from)
 * to a target processor's (queue_to).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">timer_queue_migrate</span>(mpqueue_head_t *queue_from, mpqueue_head_t *queue_to)
{
	timer_call_t	call;
	timer_call_t	head_to;
	<span class="enscript-type">int</span>		timers_migrated = 0;

	DBG(<span class="enscript-string">&quot;timer_queue_migrate(%p,%p)\n&quot;</span>, queue_from, queue_to);

	assert(!ml_get_interrupts_enabled());
	assert(queue_from != queue_to);

	<span class="enscript-keyword">if</span> (serverperfmode) {
		<span class="enscript-comment">/*
		 * if we're running a high end server
		 * avoid migrations... they add latency
		 * and don't save us power under typical
		 * server workloads
		 */</span>
		<span class="enscript-keyword">return</span> -4;
	}

	<span class="enscript-comment">/*
	 * Take both local (from) and target (to) timer queue locks while
	 * moving the timers from the local queue to the target processor.
	 * We assume that the target is always the boot processor.
	 * But only move if all of the following is true:
	 *  - the target queue is non-empty
	 *  - the local queue is non-empty
	 *  - the local queue's first deadline is later than the target's
	 *  - the local queue contains no non-migrateable &quot;local&quot; call
	 * so that we need not have the target resync.
	 */</span>

        timer_queue_lock_spin(queue_to);

	head_to = TIMER_CALL(queue_first(&amp;queue_to-&gt;head));
	<span class="enscript-keyword">if</span> (queue_empty(&amp;queue_to-&gt;head)) {
		timers_migrated = -1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">abort1</span>;
	}

        timer_queue_lock_spin(queue_from);

	<span class="enscript-keyword">if</span> (queue_empty(&amp;queue_from-&gt;head)) {
		timers_migrated = -2;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">abort2</span>;
	}

	call = TIMER_CALL(queue_first(&amp;queue_from-&gt;head));
	<span class="enscript-keyword">if</span> (TCE(call)-&gt;deadline &lt; TCE(head_to)-&gt;deadline) {
		timers_migrated = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">abort2</span>;
	}

	<span class="enscript-comment">/* perform scan for non-migratable timers */</span>
	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (call-&gt;flags &amp; TIMER_CALL_LOCAL) {
			timers_migrated = -3;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">abort2</span>;
		}
		call = TIMER_CALL(queue_next(qe(call)));
	} <span class="enscript-keyword">while</span> (!queue_end(&amp;queue_from-&gt;head, qe(call)));

	<span class="enscript-comment">/* migration loop itself -- both queues are locked */</span>
	<span class="enscript-keyword">while</span> (!queue_empty(&amp;queue_from-&gt;head)) {
		call = TIMER_CALL(queue_first(&amp;queue_from-&gt;head));
		<span class="enscript-keyword">if</span> (!simple_lock_try(&amp;call-&gt;lock)) {
			<span class="enscript-comment">/* case (2b) lock order inversion, dequeue only */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">TIMER_ASSERT</span>
			TIMER_KDEBUG_TRACE(KDEBUG_TRACE, 
				DECR_TIMER_ASYNC_DEQ | DBG_FUNC_NONE,
				call,
				TCE(call)-&gt;queue,
				call-&gt;lock.interlock.lock_data,
				0x2b, 0);
#<span class="enscript-reference">endif</span>
			timer_queue_migrate_lock_skips++;
			timer_call_entry_dequeue_async(call);
			<span class="enscript-keyword">continue</span>;
		}
		timer_call_entry_dequeue(call);
		timer_call_entry_enqueue_deadline(
			call, queue_to, TCE(call)-&gt;deadline);
		timers_migrated++;
		simple_unlock(&amp;call-&gt;lock);
	}
	queue_from-&gt;earliest_soft_deadline = UINT64_MAX;
<span class="enscript-reference">abort2</span>:
       	timer_queue_unlock(queue_from);
<span class="enscript-reference">abort1</span>:
       	timer_queue_unlock(queue_to);

	<span class="enscript-keyword">return</span> timers_migrated;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">timer_queue_trace_cpu</span>(<span class="enscript-type">int</span> ncpu)
{
	timer_call_nosync_cpu(
		ncpu,
		(<span class="enscript-type">void</span>(*)())timer_queue_trace,
		(<span class="enscript-type">void</span>*) timer_queue_cpu(ncpu));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">timer_queue_trace</span>(
	mpqueue_head_t			*queue)
{
	timer_call_t	call;
	spl_t		s;

	<span class="enscript-keyword">if</span> (!kdebug_enable)
		<span class="enscript-keyword">return</span>;

	s = splclock();
	timer_queue_lock_spin(queue);

	TIMER_KDEBUG_TRACE(KDEBUG_TRACE,
        	DECR_TIMER_QUEUE | DBG_FUNC_START,
		queue-&gt;count, mach_absolute_time(), 0, 0, 0); 

	<span class="enscript-keyword">if</span> (!queue_empty(&amp;queue-&gt;head)) {
		call = TIMER_CALL(queue_first(&amp;queue-&gt;head));
		<span class="enscript-keyword">do</span> {
			TIMER_KDEBUG_TRACE(KDEBUG_TRACE,
        			DECR_TIMER_QUEUE | DBG_FUNC_NONE,
				call-&gt;soft_deadline,
				TCE(call)-&gt;deadline,
				TCE(call)-&gt;entry_time,
				TCE(call)-&gt;func,
				0);
			call = TIMER_CALL(queue_next(qe(call)));
		} <span class="enscript-keyword">while</span> (!queue_end(&amp;queue-&gt;head, qe(call)));
	}

	TIMER_KDEBUG_TRACE(KDEBUG_TRACE,
        	DECR_TIMER_QUEUE | DBG_FUNC_END,
		queue-&gt;count, mach_absolute_time(), 0, 0, 0); 

	timer_queue_unlock(queue);
	splx(s);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">timer_longterm_dequeued_locked</span>(timer_call_t call)
{
	timer_longterm_t	*tlp = &amp;timer_longterm;

	tlp-&gt;dequeues++;
	<span class="enscript-keyword">if</span> (call == tlp-&gt;threshold.call)
		tlp-&gt;threshold.call = NULL;
}

<span class="enscript-comment">/*
 * Place a timer call in the longterm list
 * and adjust the next timer callout deadline if the new timer is first.
 */</span>
mpqueue_head_t *
<span class="enscript-function-name">timer_longterm_enqueue_unlocked</span>(timer_call_t	call,
				uint64_t	now,
				uint64_t	deadline,
				mpqueue_head_t	**old_queue,
				uint64_t	soft_deadline,
				uint64_t	ttd,
				timer_call_param_t	param1,
				uint32_t	callout_flags)
{
	timer_longterm_t	*tlp = &amp;timer_longterm;
	boolean_t		update_required = FALSE;
	uint64_t		longterm_threshold;

	longterm_threshold = now + tlp-&gt;threshold.interval;

	<span class="enscript-comment">/*
	 * Return NULL without doing anything if:
	 *  - this timer is local, or
	 *  - the longterm mechanism is disabled, or
	 *  - this deadline is too short.
	 */</span>
	<span class="enscript-keyword">if</span> ((callout_flags &amp; TIMER_CALL_LOCAL) != 0 ||
	    (tlp-&gt;threshold.interval == TIMER_LONGTERM_NONE) ||
		(deadline &lt;= longterm_threshold))
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-comment">/*
 	 * Remove timer from its current queue, if any.
	 */</span>
	*old_queue = timer_call_dequeue_unlocked(call);

	<span class="enscript-comment">/*
	 * Lock the longterm queue, queue timer and determine
	 * whether an update is necessary.
	 */</span>
	assert(!ml_get_interrupts_enabled());
	simple_lock(&amp;call-&gt;lock);
	timer_queue_lock_spin(timer_longterm_queue);
	TCE(call)-&gt;deadline = deadline;
	TCE(call)-&gt;param1 = param1;
	call-&gt;ttd = ttd;
	call-&gt;soft_deadline = soft_deadline;
	call-&gt;flags = callout_flags;
	timer_call_entry_enqueue_tail(call, timer_longterm_queue);
	
	tlp-&gt;enqueues++;

	<span class="enscript-comment">/*
	 * We'll need to update the currently set threshold timer
	 * if the new deadline is sooner and no sooner update is in flight.
	 */</span> 
	<span class="enscript-keyword">if</span> (deadline &lt; tlp-&gt;threshold.deadline &amp;&amp;
	    deadline &lt; tlp-&gt;threshold.preempted) {
		tlp-&gt;threshold.preempted = deadline;
		tlp-&gt;threshold.call = call;
		update_required = TRUE;
	}
	timer_queue_unlock(timer_longterm_queue);
	simple_unlock(&amp;call-&gt;lock);
	
	<span class="enscript-keyword">if</span> (update_required) {
		<span class="enscript-comment">/*
		 * Note: this call expects that calling the master cpu
		 * alone does not involve locking the topo lock.
		 */</span>
		timer_call_nosync_cpu(
			master_cpu,
			(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *)) timer_longterm_update,
			(<span class="enscript-type">void</span> *)tlp);
	}

	<span class="enscript-keyword">return</span> timer_longterm_queue;
}

<span class="enscript-comment">/*
 * Scan for timers below the longterm threshold.
 * Move these to the local timer queue (of the boot processor on which the
 * calling thread is running).
 * Both the local (boot) queue and the longterm queue are locked.
 * The scan is similar to the timer migrate sequence but is performed by
 * successively examining each timer on the longterm queue:
 *  - if within the short-term threshold
 *    - enter on the local queue (unless being deleted), 
 *  - otherwise:
 *    - if sooner, deadline becomes the next threshold deadline.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">timer_longterm_scan</span>(timer_longterm_t	*tlp,
		    uint64_t		now)
{
	queue_entry_t	qe;
	timer_call_t	call;
	uint64_t	threshold;
	uint64_t	deadline;
	mpqueue_head_t	*timer_master_queue;

	assert(!ml_get_interrupts_enabled());
	assert(cpu_number() == master_cpu);

	<span class="enscript-keyword">if</span> (tlp-&gt;threshold.interval != TIMER_LONGTERM_NONE)
		threshold = now + tlp-&gt;threshold.interval;
	<span class="enscript-keyword">else</span>
		threshold = TIMER_LONGTERM_NONE;

	tlp-&gt;threshold.deadline = TIMER_LONGTERM_NONE;
	tlp-&gt;threshold.call = NULL;

	<span class="enscript-keyword">if</span> (queue_empty(&amp;timer_longterm_queue-&gt;head))
		<span class="enscript-keyword">return</span>;

	timer_master_queue = timer_queue_cpu(master_cpu);
	timer_queue_lock_spin(timer_master_queue);

	qe = queue_first(&amp;timer_longterm_queue-&gt;head);
	<span class="enscript-keyword">while</span> (!queue_end(&amp;timer_longterm_queue-&gt;head, qe)) {
		call = TIMER_CALL(qe);
		deadline = call-&gt;soft_deadline;
		qe = queue_next(qe);
		<span class="enscript-keyword">if</span> (!simple_lock_try(&amp;call-&gt;lock)) {
			<span class="enscript-comment">/* case (2c) lock order inversion, dequeue only */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">TIMER_ASSERT</span>
			TIMER_KDEBUG_TRACE(KDEBUG_TRACE,
				DECR_TIMER_ASYNC_DEQ | DBG_FUNC_NONE,
				call,
				TCE(call)-&gt;queue,
				call-&gt;lock.interlock.lock_data,
				0x2c, 0);
#<span class="enscript-reference">endif</span>
			timer_call_entry_dequeue_async(call);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (deadline &lt; threshold) {
			<span class="enscript-comment">/*
			 * This timer needs moving (escalating)
			 * to the local (boot) processor's queue.
			 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">TIMER_ASSERT</span>
			<span class="enscript-keyword">if</span> (deadline &lt; now)
				TIMER_KDEBUG_TRACE(KDEBUG_TRACE,
       		 			DECR_TIMER_OVERDUE | DBG_FUNC_NONE,
					call,
					deadline,
					now,
					threshold,
					0);
#<span class="enscript-reference">endif</span>
			TIMER_KDEBUG_TRACE(KDEBUG_TRACE,
       	 			DECR_TIMER_ESCALATE | DBG_FUNC_NONE,
				call,
				TCE(call)-&gt;deadline,
				TCE(call)-&gt;entry_time,
				TCE(call)-&gt;func,
				0);
			tlp-&gt;escalates++;
			timer_call_entry_dequeue(call);
			timer_call_entry_enqueue_deadline(
				call, timer_master_queue, TCE(call)-&gt;deadline);
			<span class="enscript-comment">/*
			 * A side-effect of the following call is to update
			 * the actual hardware deadline if required.
			 */</span>
			(<span class="enscript-type">void</span>) timer_queue_assign(deadline);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (deadline &lt; tlp-&gt;threshold.deadline) {
				tlp-&gt;threshold.deadline = deadline;
				tlp-&gt;threshold.call = call;
			}
		}
		simple_unlock(&amp;call-&gt;lock);
	}

	timer_queue_unlock(timer_master_queue);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">timer_longterm_callout</span>(timer_call_param_t p0, __unused timer_call_param_t p1)
{
	timer_longterm_t	*tlp = (timer_longterm_t *) p0;

	timer_longterm_update(tlp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">timer_longterm_update_locked</span>(timer_longterm_t *tlp)
{
	uint64_t	latency;

	TIMER_KDEBUG_TRACE(KDEBUG_TRACE, 
		DECR_TIMER_UPDATE | DBG_FUNC_START,
		&amp;tlp-&gt;queue,
		tlp-&gt;threshold.deadline,
		tlp-&gt;threshold.preempted,
		tlp-&gt;queue.count, 0);

	tlp-&gt;scan_time = mach_absolute_time();
	<span class="enscript-keyword">if</span> (tlp-&gt;threshold.preempted != TIMER_LONGTERM_NONE) {
		tlp-&gt;threshold.preempts++;
		tlp-&gt;threshold.deadline = tlp-&gt;threshold.preempted;
		tlp-&gt;threshold.preempted = TIMER_LONGTERM_NONE;
		<span class="enscript-comment">/*
		 * Note: in the unlikely event that a pre-empted timer has
		 * itself been cancelled, we'll simply re-scan later at the
		 * time of the preempted/cancelled timer.
		 */</span>
	} <span class="enscript-keyword">else</span> {
		tlp-&gt;threshold.scans++;

		<span class="enscript-comment">/*
		 * Maintain a moving average of our wakeup latency.
		 * Clamp latency to 0 and ignore above threshold interval.
		 */</span>
		<span class="enscript-keyword">if</span> (tlp-&gt;scan_time &gt; tlp-&gt;threshold.deadline_set)
			latency = tlp-&gt;scan_time - tlp-&gt;threshold.deadline_set;
		<span class="enscript-keyword">else</span>
			latency = 0;
		<span class="enscript-keyword">if</span> (latency &lt; tlp-&gt;threshold.interval) {
			tlp-&gt;threshold.latency_min =
				MIN(tlp-&gt;threshold.latency_min, latency);
			tlp-&gt;threshold.latency_max =
				MAX(tlp-&gt;threshold.latency_max, latency);
			tlp-&gt;threshold.latency =
				(tlp-&gt;threshold.latency*99 + latency) / 100;
		}

		timer_longterm_scan(tlp, tlp-&gt;scan_time); 
	}

	tlp-&gt;threshold.deadline_set = tlp-&gt;threshold.deadline;
	<span class="enscript-comment">/* The next deadline timer to be set is adjusted */</span>
	<span class="enscript-keyword">if</span> (tlp-&gt;threshold.deadline != TIMER_LONGTERM_NONE) {
		tlp-&gt;threshold.deadline_set -= tlp-&gt;threshold.margin;
		tlp-&gt;threshold.deadline_set -= tlp-&gt;threshold.latency;
	}

	TIMER_KDEBUG_TRACE(KDEBUG_TRACE, 
		DECR_TIMER_UPDATE | DBG_FUNC_END,
		&amp;tlp-&gt;queue,
		tlp-&gt;threshold.deadline,
		tlp-&gt;threshold.scans,
		tlp-&gt;queue.count, 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">timer_longterm_update</span>(timer_longterm_t *tlp)
{
	spl_t	s = splclock();

	timer_queue_lock_spin(timer_longterm_queue);

	<span class="enscript-keyword">if</span> (cpu_number() != master_cpu)
		panic(<span class="enscript-string">&quot;timer_longterm_update_master() on non-boot cpu&quot;</span>);

	timer_longterm_update_locked(tlp);

	<span class="enscript-keyword">if</span> (tlp-&gt;threshold.deadline != TIMER_LONGTERM_NONE)
		timer_call_enter(
			&amp;tlp-&gt;threshold.timer,
			tlp-&gt;threshold.deadline_set,
			TIMER_CALL_LOCAL | TIMER_CALL_SYS_CRITICAL);
	
	timer_queue_unlock(timer_longterm_queue);
	splx(s);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">timer_longterm_init</span>(<span class="enscript-type">void</span>)
{
	uint32_t		longterm;
	timer_longterm_t	*tlp = &amp;timer_longterm;

	DBG(<span class="enscript-string">&quot;timer_longterm_init() tlp: %p, queue: %p\n&quot;</span>, tlp, &amp;tlp-&gt;queue);

	<span class="enscript-comment">/*
	 * Set the longterm timer threshold. Defaults to TIMER_LONGTERM_THRESHOLD
	 * or TIMER_LONGTERM_NONE (disabled) for server;
	 * overridden longterm boot-arg 
	 */</span>
	tlp-&gt;threshold.interval = serverperfmode ? TIMER_LONGTERM_NONE
						 : TIMER_LONGTERM_THRESHOLD;
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;longterm&quot;</span>, &amp;longterm, <span class="enscript-keyword">sizeof</span> (longterm))) {
		tlp-&gt;threshold.interval = (longterm == 0) ?
						TIMER_LONGTERM_NONE :
						longterm * NSEC_PER_MSEC;
	}
	<span class="enscript-keyword">if</span> (tlp-&gt;threshold.interval != TIMER_LONGTERM_NONE) {
		printf(<span class="enscript-string">&quot;Longterm timer threshold: %llu ms\n&quot;</span>,
			tlp-&gt;threshold.interval / NSEC_PER_MSEC); 
		kprintf(<span class="enscript-string">&quot;Longterm timer threshold: %llu ms\n&quot;</span>,
			tlp-&gt;threshold.interval / NSEC_PER_MSEC); 
		nanoseconds_to_absolutetime(tlp-&gt;threshold.interval,
					    &amp;tlp-&gt;threshold.interval);
		tlp-&gt;threshold.margin = tlp-&gt;threshold.interval / 10;
		tlp-&gt;threshold.latency_min = EndOfAllTime;
		tlp-&gt;threshold.latency_max = 0;
	}

	tlp-&gt;threshold.preempted = TIMER_LONGTERM_NONE;
	tlp-&gt;threshold.deadline = TIMER_LONGTERM_NONE;

	lck_attr_setdefault(&amp;timer_longterm_lck_attr);
	lck_grp_attr_setdefault(&amp;timer_longterm_lck_grp_attr);
	lck_grp_init(&amp;timer_longterm_lck_grp,
		     <span class="enscript-string">&quot;timer_longterm&quot;</span>, &amp;timer_longterm_lck_grp_attr);
	mpqueue_init(&amp;tlp-&gt;queue,
		     &amp;timer_longterm_lck_grp, &amp;timer_longterm_lck_attr);

	timer_call_setup(&amp;tlp-&gt;threshold.timer,
			 timer_longterm_callout, (timer_call_param_t) tlp);

	timer_longterm_queue = &amp;tlp-&gt;queue;
}

<span class="enscript-type">enum</span> {
	THRESHOLD, QCOUNT,
	ENQUEUES, DEQUEUES, ESCALATES, SCANS, PREEMPTS,
	LATENCY, LATENCY_MIN, LATENCY_MAX
};
uint64_t
<span class="enscript-function-name">timer_sysctl_get</span>(<span class="enscript-type">int</span> oid)
{
	timer_longterm_t	*tlp = &amp;timer_longterm;

	<span class="enscript-keyword">switch</span> (oid) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">THRESHOLD</span>:
		<span class="enscript-keyword">return</span> (tlp-&gt;threshold.interval == TIMER_LONGTERM_NONE) ?
			0 : tlp-&gt;threshold.interval / NSEC_PER_MSEC;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">QCOUNT</span>:
		<span class="enscript-keyword">return</span> tlp-&gt;queue.count;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENQUEUES</span>:
		<span class="enscript-keyword">return</span> tlp-&gt;enqueues;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DEQUEUES</span>:
		<span class="enscript-keyword">return</span> tlp-&gt;dequeues;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ESCALATES</span>:
		<span class="enscript-keyword">return</span> tlp-&gt;escalates;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SCANS</span>:
		<span class="enscript-keyword">return</span> tlp-&gt;threshold.scans;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PREEMPTS</span>:
		<span class="enscript-keyword">return</span> tlp-&gt;threshold.preempts;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LATENCY</span>:
		<span class="enscript-keyword">return</span> tlp-&gt;threshold.latency;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LATENCY_MIN</span>:
		<span class="enscript-keyword">return</span> tlp-&gt;threshold.latency_min;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LATENCY_MAX</span>:
		<span class="enscript-keyword">return</span> tlp-&gt;threshold.latency_max;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> 0;
	}
}

<span class="enscript-comment">/*
 * timer_master_scan() is the inverse of timer_longterm_scan()
 * since it un-escalates timers to the longterm queue.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">timer_master_scan</span>(timer_longterm_t	*tlp,
		  uint64_t		now)
{
	queue_entry_t	qe;
	timer_call_t	call;
	uint64_t	threshold;
	uint64_t	deadline;
	mpqueue_head_t	*timer_master_queue;

	<span class="enscript-keyword">if</span> (tlp-&gt;threshold.interval != TIMER_LONGTERM_NONE)
		threshold = now + tlp-&gt;threshold.interval;
	<span class="enscript-keyword">else</span>
		threshold = TIMER_LONGTERM_NONE;

	timer_master_queue = timer_queue_cpu(master_cpu);
	timer_queue_lock_spin(timer_master_queue);

	qe = queue_first(&amp;timer_master_queue-&gt;head);
	<span class="enscript-keyword">while</span> (!queue_end(&amp;timer_master_queue-&gt;head, qe)) {
		call = TIMER_CALL(qe);
		deadline = TCE(call)-&gt;deadline;
		qe = queue_next(qe);
		<span class="enscript-keyword">if</span> ((call-&gt;flags &amp; TIMER_CALL_LOCAL) != 0)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (!simple_lock_try(&amp;call-&gt;lock)) {
			<span class="enscript-comment">/* case (2c) lock order inversion, dequeue only */</span>
			timer_call_entry_dequeue_async(call);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (deadline &gt; threshold) {
			<span class="enscript-comment">/* move from master to longterm */</span>
			timer_call_entry_dequeue(call);
			timer_call_entry_enqueue_tail(call, timer_longterm_queue);
			<span class="enscript-keyword">if</span> (deadline &lt; tlp-&gt;threshold.deadline) {
				tlp-&gt;threshold.deadline = deadline;
				tlp-&gt;threshold.call = call;
			}
		}
		simple_unlock(&amp;call-&gt;lock);
	}
	timer_queue_unlock(timer_master_queue);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">timer_sysctl_set_threshold</span>(uint64_t value)
{
	timer_longterm_t	*tlp = &amp;timer_longterm;
	spl_t			s = splclock();
	boolean_t		threshold_increase;

	timer_queue_lock_spin(timer_longterm_queue);

	timer_call_cancel(&amp;tlp-&gt;threshold.timer);

	<span class="enscript-comment">/*
	 * Set the new threshold and note whther it's increasing.
	 */</span>
	<span class="enscript-keyword">if</span> (value == 0) {
		tlp-&gt;threshold.interval = TIMER_LONGTERM_NONE;
		threshold_increase = TRUE;
		timer_call_cancel(&amp;tlp-&gt;threshold.timer);
	} <span class="enscript-keyword">else</span> {
		uint64_t	old_interval = tlp-&gt;threshold.interval;
		tlp-&gt;threshold.interval = value * NSEC_PER_MSEC;
		nanoseconds_to_absolutetime(tlp-&gt;threshold.interval,
					    &amp;tlp-&gt;threshold.interval);
		tlp-&gt;threshold.margin = tlp-&gt;threshold.interval / 10;
		<span class="enscript-keyword">if</span>  (old_interval == TIMER_LONGTERM_NONE)
			threshold_increase = FALSE;
		<span class="enscript-keyword">else</span>
			threshold_increase = (tlp-&gt;threshold.interval &gt; old_interval);
	}

	<span class="enscript-keyword">if</span> (threshold_increase <span class="enscript-comment">/* or removal */</span>) {
		<span class="enscript-comment">/* Escalate timers from the longterm queue */</span>
		timer_longterm_scan(tlp, mach_absolute_time());
	} <span class="enscript-keyword">else</span> <span class="enscript-comment">/* decrease or addition  */</span> {
		<span class="enscript-comment">/*
		 * We scan the local/master queue for timers now longterm.
		 * To be strictly correct, we should scan all processor queues
		 * but timer migration results in most timers gravitating to the
		 * master processor in any case.
		 */</span>
		timer_master_scan(tlp, mach_absolute_time());
	}

	<span class="enscript-comment">/* Set new timer accordingly */</span>
	tlp-&gt;threshold.deadline_set = tlp-&gt;threshold.deadline;
	<span class="enscript-keyword">if</span> (tlp-&gt;threshold.deadline != TIMER_LONGTERM_NONE) {
		tlp-&gt;threshold.deadline_set -= tlp-&gt;threshold.margin;
		tlp-&gt;threshold.deadline_set -= tlp-&gt;threshold.latency;
		timer_call_enter(
			&amp;tlp-&gt;threshold.timer,
			tlp-&gt;threshold.deadline_set,
			TIMER_CALL_LOCAL | TIMER_CALL_SYS_CRITICAL);
	}

	<span class="enscript-comment">/* Reset stats */</span>
	tlp-&gt;enqueues = 0;
	tlp-&gt;dequeues = 0;
	tlp-&gt;escalates = 0;
	tlp-&gt;threshold.scans = 0;
	tlp-&gt;threshold.preempts = 0;
	tlp-&gt;threshold.latency = 0;
	tlp-&gt;threshold.latency_min = EndOfAllTime;
	tlp-&gt;threshold.latency_max = 0;

	timer_queue_unlock(timer_longterm_queue);
	splx(s);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">timer_sysctl_set</span>(<span class="enscript-type">int</span> oid, uint64_t value)
{
	<span class="enscript-keyword">switch</span> (oid) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">THRESHOLD</span>:
		timer_call_cpu(
			master_cpu,
			(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *)) timer_sysctl_set_threshold,
			(<span class="enscript-type">void</span> *) value);
		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}
}


<span class="enscript-comment">/* Select timer coalescing window based on per-task quality-of-service hints */</span>
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">tcoal_qos_adjust</span>(thread_t t, int32_t *tshift, uint64_t *tmax_abstime, boolean_t *pratelimited) {
	uint32_t latency_qos;
	boolean_t adjusted = FALSE;
	task_t ctask = t-&gt;task;

	<span class="enscript-keyword">if</span> (ctask) {
		latency_qos = proc_get_effective_thread_policy(t, TASK_POLICY_LATENCY_QOS);

		assert(latency_qos &lt;= NUM_LATENCY_QOS_TIERS);

		<span class="enscript-keyword">if</span> (latency_qos) {
			*tshift = tcoal_prio_params.latency_qos_scale[latency_qos - 1];
			*tmax_abstime = tcoal_prio_params.latency_qos_abstime_max[latency_qos - 1];
			*pratelimited = tcoal_prio_params.latency_tier_rate_limited[latency_qos - 1];
			adjusted = TRUE;
		}
	}
	<span class="enscript-keyword">return</span> adjusted;
}


<span class="enscript-comment">/* Adjust timer deadlines based on priority of the thread and the
 * urgency value provided at timeout establishment. With this mechanism,
 * timers are no longer necessarily sorted in order of soft deadline
 * on a given timer queue, i.e. they may be differentially skewed.
 * In the current scheme, this could lead to fewer pending timers
 * processed than is technically possible when the HW deadline arrives.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">timer_compute_leeway</span>(thread_t cthread, int32_t urgency, int32_t *tshift, uint64_t *tmax_abstime, boolean_t *pratelimited) {
	int16_t tpri = cthread-&gt;sched_pri;
	<span class="enscript-keyword">if</span> ((urgency &amp; TIMER_CALL_USER_MASK) != 0) {
		<span class="enscript-keyword">if</span> (tpri &gt;= BASEPRI_RTQUEUES ||
		urgency == TIMER_CALL_USER_CRITICAL) {
			*tshift = tcoal_prio_params.timer_coalesce_rt_shift;
			*tmax_abstime = tcoal_prio_params.timer_coalesce_rt_abstime_max;
			TCOAL_PRIO_STAT(rt_tcl);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (proc_get_effective_thread_policy(cthread, TASK_POLICY_DARWIN_BG) ||
		(urgency == TIMER_CALL_USER_BACKGROUND)) {
			<span class="enscript-comment">/* Determine if timer should be subjected to a lower QoS */</span>
			<span class="enscript-keyword">if</span> (tcoal_qos_adjust(cthread, tshift, tmax_abstime, pratelimited)) {
				<span class="enscript-keyword">if</span> (*tmax_abstime &gt; tcoal_prio_params.timer_coalesce_bg_abstime_max) {
					<span class="enscript-keyword">return</span>;
				} <span class="enscript-keyword">else</span> {
					*pratelimited = FALSE;
				}
			}
			*tshift = tcoal_prio_params.timer_coalesce_bg_shift;
			*tmax_abstime = tcoal_prio_params.timer_coalesce_bg_abstime_max;
			TCOAL_PRIO_STAT(bg_tcl);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tpri &gt;= MINPRI_KERNEL) {
			*tshift = tcoal_prio_params.timer_coalesce_kt_shift;
			*tmax_abstime = tcoal_prio_params.timer_coalesce_kt_abstime_max;
			TCOAL_PRIO_STAT(kt_tcl);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cthread-&gt;sched_mode == TH_MODE_FIXED) {
			*tshift = tcoal_prio_params.timer_coalesce_fp_shift;
			*tmax_abstime = tcoal_prio_params.timer_coalesce_fp_abstime_max;
			TCOAL_PRIO_STAT(fp_tcl);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tcoal_qos_adjust(cthread, tshift, tmax_abstime, pratelimited)) {
			TCOAL_PRIO_STAT(qos_tcl);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cthread-&gt;sched_mode == TH_MODE_TIMESHARE) {
			*tshift = tcoal_prio_params.timer_coalesce_ts_shift;
			*tmax_abstime = tcoal_prio_params.timer_coalesce_ts_abstime_max;
			TCOAL_PRIO_STAT(ts_tcl);
		} <span class="enscript-keyword">else</span> {
			TCOAL_PRIO_STAT(nc_tcl);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (urgency == TIMER_CALL_SYS_BACKGROUND) {
		*tshift = tcoal_prio_params.timer_coalesce_bg_shift;
		*tmax_abstime = tcoal_prio_params.timer_coalesce_bg_abstime_max;
		TCOAL_PRIO_STAT(bg_tcl);
	} <span class="enscript-keyword">else</span> {
		*tshift = tcoal_prio_params.timer_coalesce_kt_shift;
		*tmax_abstime = tcoal_prio_params.timer_coalesce_kt_abstime_max;
		TCOAL_PRIO_STAT(kt_tcl);
	}
}


<span class="enscript-type">int</span> timer_user_idle_level;

uint64_t
<span class="enscript-function-name">timer_call_slop</span>(uint64_t deadline, uint64_t now, uint32_t flags, thread_t cthread, boolean_t *pratelimited)
{
	int32_t tcs_shift = 0;
	uint64_t tcs_max_abstime = 0;
	uint64_t adjval;
	uint32_t urgency = (flags &amp; TIMER_CALL_URGENCY_MASK);

	<span class="enscript-keyword">if</span> (mach_timer_coalescing_enabled &amp;&amp; 
	    (deadline &gt; now) &amp;&amp; (urgency != TIMER_CALL_SYS_CRITICAL)) {
		timer_compute_leeway(cthread, urgency, &amp;tcs_shift, &amp;tcs_max_abstime, pratelimited);
	
		<span class="enscript-keyword">if</span> (tcs_shift &gt;= 0)
			adjval =  MIN((deadline - now) &gt;&gt; tcs_shift, tcs_max_abstime);
		<span class="enscript-keyword">else</span>
			adjval =  MIN((deadline - now) &lt;&lt; (-tcs_shift), tcs_max_abstime);
		<span class="enscript-comment">/* Apply adjustments derived from &quot;user idle level&quot; heuristic */</span>
		adjval += (adjval * timer_user_idle_level) &gt;&gt; 7;
		<span class="enscript-keyword">return</span> adjval;
 	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> 0;
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">timer_get_user_idle_level</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">return</span> timer_user_idle_level;
}

kern_return_t <span class="enscript-function-name">timer_set_user_idle_level</span>(<span class="enscript-type">int</span> ilevel) {
	boolean_t do_reeval = FALSE;

	<span class="enscript-keyword">if</span> ((ilevel &lt; 0) || (ilevel &gt; 128))
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	<span class="enscript-keyword">if</span> (ilevel &lt; timer_user_idle_level) {
		do_reeval = TRUE;
	}

	timer_user_idle_level = ilevel;

	<span class="enscript-keyword">if</span> (do_reeval)
		ml_timer_evaluate();

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}
</pre>
<hr />
</body></html>