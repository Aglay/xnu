<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kext_alloc.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kext_alloc.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kext_alloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/loader.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kernel_mach_header.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KASLR_IOREG_DEBUG</span> 0


vm_map_t g_kext_map = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KASLR_IOREG_DEBUG</span>
mach_vm_offset_t kext_alloc_base = 0;
mach_vm_offset_t kext_alloc_max = 0;
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> mach_vm_offset_t kext_alloc_base = 0;
<span class="enscript-type">static</span> mach_vm_offset_t kext_alloc_max = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_KEXT_BASEMENT</span>
<span class="enscript-type">static</span> mach_vm_offset_t kext_post_boot_base = 0;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * On x86_64 systems, kernel extension text must remain within 2GB of the
 * kernel's text segment.  To ensure this happens, we snag 2GB of kernel VM
 * as early as possible for kext allocations.
 */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">kext_alloc_init</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_KEXT_BASEMENT</span>
    kern_return_t rval = 0;
    kernel_segment_command_t *text = NULL;
    kernel_segment_command_t *prelinkTextSegment = NULL;
    mach_vm_offset_t text_end, text_start;
    mach_vm_size_t text_size;
    mach_vm_size_t kext_alloc_size;

    <span class="enscript-comment">/* Determine the start of the kernel's __TEXT segment and determine the
     * lower bound of the allocated submap for kext allocations.
     */</span>

    text = getsegbyname(SEG_TEXT);
    text_start = vm_map_trunc_page(text-&gt;vmaddr,
				   VM_MAP_PAGE_MASK(kernel_map));
    text_start &amp;= ~((512ULL * 1024 * 1024 * 1024) - 1);
    text_end = vm_map_round_page(text-&gt;vmaddr + text-&gt;vmsize,
				 VM_MAP_PAGE_MASK(kernel_map));
    text_size = text_end - text_start;

    kext_alloc_base = KEXT_ALLOC_BASE(text_end);
    kext_alloc_size = KEXT_ALLOC_SIZE(text_size);
    kext_alloc_max = kext_alloc_base + kext_alloc_size;
    
    <span class="enscript-comment">/* Post boot kext allocation will start after the prelinked kexts */</span>
    prelinkTextSegment = getsegbyname(<span class="enscript-string">&quot;__PRELINK_TEXT&quot;</span>);
    <span class="enscript-keyword">if</span> (prelinkTextSegment) {
        <span class="enscript-comment">/* use kext_post_boot_base to start allocations past all the prelinked 
         * kexts
         */</span>
        kext_post_boot_base = 
		vm_map_round_page(kext_alloc_base + prelinkTextSegment-&gt;vmsize,
				  VM_MAP_PAGE_MASK(kernel_map));
    }
    <span class="enscript-keyword">else</span> {
        kext_post_boot_base = kext_alloc_base;
    }

    <span class="enscript-comment">/* Allocate the sub block of the kernel map */</span>
    rval = kmem_suballoc(kernel_map, (vm_offset_t *) &amp;kext_alloc_base, 
			 kext_alloc_size, <span class="enscript-comment">/* pageable */</span> TRUE,
			 VM_FLAGS_FIXED|VM_FLAGS_OVERWRITE | VM_MAKE_TAG(VM_KERN_MEMORY_KEXT),
			 &amp;g_kext_map);
    <span class="enscript-keyword">if</span> (rval != KERN_SUCCESS) {
	    panic(<span class="enscript-string">&quot;kext_alloc_init: kmem_suballoc failed 0x%x\n&quot;</span>, rval);
    }

    <span class="enscript-keyword">if</span> ((kext_alloc_base + kext_alloc_size) &gt; kext_alloc_max) {
        panic(<span class="enscript-string">&quot;kext_alloc_init: failed to get first 2GB\n&quot;</span>);
    }

    <span class="enscript-keyword">if</span> (kernel_map-&gt;min_offset &gt; kext_alloc_base) {
	    kernel_map-&gt;min_offset = kext_alloc_base;
    }

    printf(<span class="enscript-string">&quot;kext submap [0x%lx - 0x%lx], kernel text [0x%lx - 0x%lx]\n&quot;</span>,
	   VM_KERNEL_UNSLIDE(kext_alloc_base),
	   VM_KERNEL_UNSLIDE(kext_alloc_max),
	   VM_KERNEL_UNSLIDE(text-&gt;vmaddr),
	   VM_KERNEL_UNSLIDE(text-&gt;vmaddr + text-&gt;vmsize));

#<span class="enscript-reference">else</span>
    g_kext_map = kernel_map;
    kext_alloc_base = VM_MIN_KERNEL_ADDRESS;
    kext_alloc_max = VM_MAX_KERNEL_ADDRESS;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_KEXT_BASEMENT */</span>
}

kern_return_t
<span class="enscript-function-name">kext_alloc</span>(vm_offset_t *_addr, vm_size_t size, boolean_t fixed)
{
    kern_return_t rval = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_KEXT_BASEMENT</span>
    mach_vm_offset_t addr = (fixed) ? *_addr : kext_post_boot_base;
#<span class="enscript-reference">else</span>
    mach_vm_offset_t addr = (fixed) ? *_addr : kext_alloc_base;
#<span class="enscript-reference">endif</span>
    <span class="enscript-type">int</span> flags = (fixed) ? VM_FLAGS_FIXED : VM_FLAGS_ANYWHERE;
 
    flags |= VM_MAKE_TAG(VM_KERN_MEMORY_KEXT);
     
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_KEXT_BASEMENT</span>
    <span class="enscript-comment">/* Allocate the kext virtual memory
     * 10608884 - use mach_vm_map since we want VM_FLAGS_ANYWHERE allocated past
     * kext_post_boot_base (when possible).  mach_vm_allocate will always 
     * start at 0 into the map no matter what you pass in addr.  We want non 
     * fixed (post boot) kext allocations to start looking for free space 
     * just past where prelinked kexts have loaded.  
     */</span>
    rval = mach_vm_map(g_kext_map, 
                       &amp;addr, 
                       size, 
                       0,
                       flags,
                       MACH_PORT_NULL,
                       0,
                       TRUE,
                       VM_PROT_DEFAULT,
                       VM_PROT_ALL,
                       VM_INHERIT_DEFAULT);
    <span class="enscript-keyword">if</span> (rval != KERN_SUCCESS) {
        printf(<span class="enscript-string">&quot;mach_vm_map failed - %d\n&quot;</span>, rval);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
#<span class="enscript-reference">else</span>
    rval = mach_vm_allocate(g_kext_map, &amp;addr, size, flags);
    <span class="enscript-keyword">if</span> (rval != KERN_SUCCESS) {
        printf(<span class="enscript-string">&quot;vm_allocate failed - %d\n&quot;</span>, rval);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">/* Check that the memory is reachable by kernel text */</span>
    <span class="enscript-keyword">if</span> ((addr + size) &gt; kext_alloc_max) {
        kext_free((vm_offset_t)addr, size);
        rval = KERN_INVALID_ADDRESS;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    *_addr = (vm_offset_t)addr;
    rval = KERN_SUCCESS;

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">kext_free</span>(vm_offset_t addr, vm_size_t size)
{
    kern_return_t rval;

    rval = mach_vm_deallocate(g_kext_map, addr, size);
    assert(rval == KERN_SUCCESS);
}

</pre>
<hr />
</body></html>