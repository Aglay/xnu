<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_cdata.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_cdata.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_cdata.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_vm.h&gt;</span>

<span class="enscript-comment">/*
 *
 * The format for data is setup in a generic format as follows
 *
 * Layout of data structure:
 *
 *   |         8 - bytes         |
 *   |  type = MAGIC |  LENGTH   |
 *   |            0              |
 *   |      type     |  size     |
 *   |          flags            |
 *   |           data            |
 *   |___________data____________|
 *   |      type     |   size    |
 *   |          flags            |
 *   |___________data____________|
 *   |  type = END   |  size=0   |
 *   |            0              |
 *
 *
 * The type field describes what kind of data is passed. For example type = TASK_CRASHINFO_UUID means the following data is a uuid.
 * These types need to be defined in task_corpses.h for easy consumption by userspace inspection tools.
 *
 * Some range of types is reserved for special types like ints, longs etc. A cool new functionality made possible with this
 * extensible data format is that kernel can decide to put more information as required without requiring user space tools to
 * re-compile to be compatible. The case of rusage struct versions could be introduced without breaking existing tools.
 *
 * Feature description: Generic data with description
 * -------------------
 * Further more generic data with description is very much possible now. For example
 *
 *   - kcdata_add_uint64_with_description(cdatainfo, 0x700, &quot;NUM MACH PORTS&quot;);
 *   - and more functions that allow adding description.
 * The userspace tools can then look at the description and print the data even if they are not compiled with knowledge of the field apriori.
 *
 *  Example data:
 * 0000  57 f1 ad de 00 00 00 00 00 00 00 00 00 00 00 00  W...............
 * 0010  01 00 00 00 00 00 00 00 30 00 00 00 00 00 00 00  ........0.......
 * 0020  50 49 44 00 00 00 00 00 00 00 00 00 00 00 00 00  PID.............
 * 0030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
 * 0040  9c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
 * 0050  01 00 00 00 00 00 00 00 30 00 00 00 00 00 00 00  ........0.......
 * 0060  50 41 52 45 4e 54 20 50 49 44 00 00 00 00 00 00  PARENT PID......
 * 0070  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
 * 0080  01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
 * 0090  ed 58 91 f1
 *
 * Feature description: Container markers for compound data
 * ------------------
 * If a given kernel data type is complex and requires adding multiple optional fields inside a container
 * object for a consumer to understand arbitrary data, we package it using container markers.
 *
 * For example, the stackshot code gathers information and describes the state of a given task with respect
 * to many subsystems. It includes data such as io stats, vm counters, process names/flags and syscall counts.
 *
 * kcdata_add_container_marker(kcdata_p, KCDATA_TYPE_CONTAINER_BEGIN, STACKSHOT_KCCONTAINER_TASK, task_uniqueid);
 * // add multiple data, or add_&lt;type&gt;_with_description()s here
 *
 * kcdata_add_container_marker(kcdata_p, KCDATA_TYPE_CONTAINER_END, STACKSHOT_KCCONTAINER_TASK, task_uniqueid);
 *
 * Feature description: Custom Data formats on demand
 * --------------------
 * With the self describing nature of format, the kernel provider can describe a data type (uniquely identified by a number) and use
 * it in the buffer for sending data. The consumer can parse the type information and have knowledge of describing incoming data.
 * Following is an example of how we can describe a kernel specific struct sample_disk_io_stats in buffer.
 *
 * struct sample_disk_io_stats {
 *     uint64_t        disk_reads_count;
 *     uint64_t        disk_reads_size;
 *     uint64_t        io_priority_count[4];
 *     uint64_t        io_priority_size;
 * } __attribute__ ((packed));
 *
 *
 * struct kcdata_subtype_descriptor disk_io_stats_def[] = {
 *     {KCS_SUBTYPE_FLAGS_NONE, KC_ST_UINT64, 0 * sizeof(uint64_t), sizeof(uint64_t), &quot;disk_reads_count&quot;},
 *     {KCS_SUBTYPE_FLAGS_NONE, KC_ST_UINT64, 1 * sizeof(uint64_t), sizeof(uint64_t), &quot;disk_reads_size&quot;},
 *     {KCS_SUBTYPE_FLAGS_ARRAY, KC_ST_UINT64, 2 * sizeof(uint64_t), KCS_SUBTYPE_PACK_SIZE(4, sizeof(uint64_t)), &quot;io_priority_count&quot;},
 *     {KCS_SUBTYPE_FLAGS_ARRAY, KC_ST_UINT64, (2 + 4) * sizeof(uint64_t), sizeof(uint64_t), &quot;io_priority_size&quot;},
 * };
 *
 * Now you can add this custom type definition into the buffer as
 * kcdata_add_type_definition(kcdata_p, KCTYPE_SAMPLE_DISK_IO_STATS, &quot;sample_disk_io_stats&quot;,
 *          &amp;disk_io_stats_def[0], sizeof(disk_io_stats_def)/sizeof(struct kcdata_subtype_descriptor));
 *
 */</span>

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">kcdata_get_memory_addr_with_flavor</span>(kcdata_descriptor_t data, uint32_t type, uint32_t size, uint64_t flags, mach_vm_address_t *user_addr);

kcdata_descriptor_t <span class="enscript-function-name">kcdata_memory_alloc_init</span>(mach_vm_address_t buffer_addr_p, <span class="enscript-type">unsigned</span> data_type, <span class="enscript-type">unsigned</span> size, <span class="enscript-type">unsigned</span> flags)
{
	kcdata_descriptor_t data = NULL;
	mach_vm_address_t user_addr = 0;

	data = kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kcdata_descriptor));
	<span class="enscript-keyword">if</span> (data == NULL) {
		<span class="enscript-keyword">return</span> NULL;
	}
	bzero(data, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kcdata_descriptor));
	data-&gt;kcd_addr_begin = buffer_addr_p;
	data-&gt;kcd_addr_end = buffer_addr_p;
	data-&gt;kcd_flags = (flags &amp; KCFLAG_USE_COPYOUT)? KCFLAG_USE_COPYOUT : KCFLAG_USE_MEMCOPY;
	data-&gt;kcd_length = size;

	<span class="enscript-comment">/* Initialize the BEGIN header */</span>
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != kcdata_get_memory_addr(data, data_type, 0, &amp;user_addr)){
		kcdata_memory_destroy(data);
		<span class="enscript-keyword">return</span> NULL;
	}

	<span class="enscript-keyword">return</span> data;
}

kern_return_t <span class="enscript-function-name">kcdata_memory_static_init</span>(kcdata_descriptor_t data, mach_vm_address_t buffer_addr_p, <span class="enscript-type">unsigned</span> data_type, <span class="enscript-type">unsigned</span> size, <span class="enscript-type">unsigned</span> flags)
{
	mach_vm_address_t user_addr = 0;

	<span class="enscript-keyword">if</span> (data == NULL) {
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}
	bzero(data, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kcdata_descriptor));
	data-&gt;kcd_addr_begin = buffer_addr_p;
	data-&gt;kcd_addr_end = buffer_addr_p;
	data-&gt;kcd_flags = (flags &amp; KCFLAG_USE_COPYOUT)? KCFLAG_USE_COPYOUT : KCFLAG_USE_MEMCOPY;
	data-&gt;kcd_length = size;

	<span class="enscript-comment">/* Initialize the BEGIN header */</span>
	<span class="enscript-keyword">return</span> kcdata_get_memory_addr(data, data_type, 0, &amp;user_addr);
}

uint64_t <span class="enscript-function-name">kcdata_memory_get_used_bytes</span>(kcdata_descriptor_t kcd)
{
	assert(kcd != NULL);
	<span class="enscript-keyword">return</span> ((uint64_t)kcd-&gt;kcd_addr_end - (uint64_t)kcd-&gt;kcd_addr_begin) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kcdata_item);
}

<span class="enscript-comment">/*
 * Free up the memory associated with kcdata
 */</span>
kern_return_t <span class="enscript-function-name">kcdata_memory_destroy</span>(kcdata_descriptor_t data)
{
	<span class="enscript-keyword">if</span> (!data) {
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-comment">/*
	 * data-&gt;kcd_addr_begin points to memory in not tracked by
	 * kcdata lib. So not clearing that here.
	 */</span>
	kfree(data, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kcdata_descriptor));
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}



<span class="enscript-comment">/*
 * Routine: kcdata_get_memory_addr
 * Desc: get memory address in the userspace memory for corpse info
 *       NOTE: The caller is responsible to zero the resulting memory or
 *             user other means to mark memory if it has failed populating the
 *             data in middle of operation.
 * params:  data - pointer describing the crash info allocation
 *	        type - type of data to be put. See corpse.h for defined types
 *          size - size requested. The header describes this size
 * returns: mach_vm_address_t address in user memory for copyout().
 */</span>
kern_return_t <span class="enscript-function-name">kcdata_get_memory_addr</span>(
		kcdata_descriptor_t data,
		uint32_t type,
		uint32_t size,
		mach_vm_address_t *user_addr)
{
	<span class="enscript-keyword">return</span> kcdata_get_memory_addr_with_flavor(data, type, size, 0, user_addr);
}

<span class="enscript-comment">/*
 * Routine: kcdata_get_memory_addr_with_flavor
 * Desc: internal function with flags field. See documentation for kcdata_get_memory_addr for details
 */</span>

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">kcdata_get_memory_addr_with_flavor</span>(
		kcdata_descriptor_t data,
		uint32_t type,
		uint32_t size,
		uint64_t flags,
		mach_vm_address_t *user_addr)
{
	<span class="enscript-type">struct</span> kcdata_item info;
	uint32_t total_size;

	<span class="enscript-keyword">if</span> (user_addr == NULL || data == NULL) {
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	}

	<span class="enscript-comment">/* make sure 16 byte aligned */</span>
	<span class="enscript-keyword">if</span> (size &amp; 0xf) {
		size += (0x10 - (size &amp; 0xf));
	}

	bzero(&amp;info, <span class="enscript-keyword">sizeof</span>(info));
	KCDATA_ITEM_TYPE(&amp;info) = type;
	KCDATA_ITEM_SIZE(&amp;info) = size;
	KCDATA_ITEM_FLAGS(&amp;info) = flags;
	total_size = size + <span class="enscript-keyword">sizeof</span>(info);

	<span class="enscript-comment">/* check available memory, including trailer size for KCDATA_TYPE_BUFFER_END */</span>
	<span class="enscript-keyword">if</span> (data-&gt;kcd_length &lt; ((data-&gt;kcd_addr_end - data-&gt;kcd_addr_begin) + total_size + <span class="enscript-keyword">sizeof</span>(info))) {
		<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}

	<span class="enscript-keyword">if</span> (data-&gt;kcd_flags &amp; KCFLAG_USE_COPYOUT) {
		<span class="enscript-keyword">if</span> (copyout(&amp;info, data-&gt;kcd_addr_end, <span class="enscript-keyword">sizeof</span>(info)))
			<span class="enscript-keyword">return</span> KERN_NO_ACCESS;
	} <span class="enscript-keyword">else</span> {
		memcpy((<span class="enscript-type">void</span> *)data-&gt;kcd_addr_end, &amp;info, <span class="enscript-keyword">sizeof</span>(info));
	}

	data-&gt;kcd_addr_end += <span class="enscript-keyword">sizeof</span>(info);
	*user_addr = data-&gt;kcd_addr_end;
	data-&gt;kcd_addr_end += size;

	<span class="enscript-comment">/* setup the end header as well */</span>
	bzero(&amp;info, <span class="enscript-keyword">sizeof</span>(info));
	KCDATA_ITEM_TYPE(&amp;info) = KCDATA_TYPE_BUFFER_END;
	KCDATA_ITEM_SIZE(&amp;info) = 0;

	<span class="enscript-keyword">if</span> (data-&gt;kcd_flags &amp; KCFLAG_USE_COPYOUT) {
		<span class="enscript-keyword">if</span> (copyout(&amp;info, data-&gt;kcd_addr_end, <span class="enscript-keyword">sizeof</span>(info)))
			<span class="enscript-keyword">return</span> KERN_NO_ACCESS;
	} <span class="enscript-keyword">else</span> {
		memcpy((<span class="enscript-type">void</span> *)data-&gt;kcd_addr_end, &amp;info, <span class="enscript-keyword">sizeof</span>(info));
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 * Routine: kcdata_get_memory_addr_for_array
 * Desc: get memory address in the userspace memory for corpse info
 *       NOTE: The caller is responsible to zero the resulting memory or
 *             user other means to mark memory if it has failed populating the
 *             data in middle of operation.
 * params:  data - pointer describing the crash info allocation
 *          type_of_element - type of data to be put. See kern_cdata.h for defined types
 *          size_of_element - size of element. The header describes this size
 *          count - num of elements in array.
 * returns: mach_vm_address_t address in user memory for copyout().
 */</span>

kern_return_t <span class="enscript-function-name">kcdata_get_memory_addr_for_array</span>(
		kcdata_descriptor_t data,
		uint32_t type_of_element,
		uint32_t size_of_element,
		uint32_t count,
		mach_vm_address_t *user_addr)
{
	uint64_t flags = type_of_element;
	flags = (flags &lt;&lt; 32) | count;
	uint32_t total_size = count * size_of_element;
	<span class="enscript-keyword">return</span> kcdata_get_memory_addr_with_flavor(data, KCDATA_TYPE_ARRAY, total_size, flags, user_addr);
}

<span class="enscript-comment">/*
 * Routine: kcdata_add_container_marker
 * Desc: Add a container marker in the buffer for type and identifier.
 * params:  data - pointer describing the crash info allocation
 *          header_type - one of (KCDATA_TYPE_CONTAINER_BEGIN ,KCDATA_TYPE_CONTAINER_END)
 *          container_type - type of data to be put. See kern_cdata.h for defined types
 *          identifier - unique identifier. This is required to match nested containers.
 * returns: return value of kcdata_get_memory_addr()
 */</span>

kern_return_t <span class="enscript-function-name">kcdata_add_container_marker</span>(
		kcdata_descriptor_t data,
		uint32_t header_type,
		uint32_t container_type,
		uint64_t identifier)
{
	mach_vm_address_t user_addr;
	kern_return_t kr;
	assert(header_type == KCDATA_TYPE_CONTAINER_END || header_type == KCDATA_TYPE_CONTAINER_BEGIN);
	uint32_t data_size = (header_type == KCDATA_TYPE_CONTAINER_BEGIN)? <span class="enscript-keyword">sizeof</span>(uint32_t): 0;
	kr = kcdata_get_memory_addr_with_flavor(data, header_type, data_size, identifier, &amp;user_addr);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-keyword">if</span> (data_size)
		kr = kcdata_memcpy(data, user_addr, &amp;container_type, data_size);
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/*
 * Routine: kcdata_memcpy
 * Desc: a common function to copy data out based on either copyout or memcopy flags
 * params:  data - pointer describing the kcdata buffer
 *          dst_addr - destination address
 *          src_addr - source address
 *          size - size in bytes to copy.
 * returns: KERN_NO_ACCESS if copyout fails.
 */</span>

kern_return_t <span class="enscript-function-name">kcdata_memcpy</span>(kcdata_descriptor_t data, mach_vm_address_t dst_addr, <span class="enscript-type">void</span> *src_addr, uint32_t size)
{
	<span class="enscript-keyword">if</span> (data-&gt;kcd_flags &amp; KCFLAG_USE_COPYOUT) {
		<span class="enscript-keyword">if</span> (copyout(src_addr, dst_addr, size))
			<span class="enscript-keyword">return</span> KERN_NO_ACCESS;
	} <span class="enscript-keyword">else</span> {
		memcpy((<span class="enscript-type">void</span> *)dst_addr, src_addr, size);
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/*
 * Routine: kcdata_add_type_definition
 * Desc: add type definition to kcdata buffer.
 *       see feature description in documentation above.
 * params:  data - pointer describing the kcdata buffer
 *          type_id - unique type identifier for this data
 *          type_name - a string of max KCDATA_DESC_MAXLEN size for name of type
 *          elements_array - address to descriptors for each field in struct
 *          elements_count - count of how many fields are there in struct.
 * returns: return code from kcdata_get_memory_addr in case of failure.
 */</span>

kern_return_t <span class="enscript-function-name">kcdata_add_type_definition</span>(
		kcdata_descriptor_t data,
		uint32_t type_id,
		<span class="enscript-type">char</span> *type_name,
		<span class="enscript-type">struct</span> kcdata_subtype_descriptor *elements_array_addr,
		uint32_t elements_count)
{
	kern_return_t kr = KERN_SUCCESS;
	<span class="enscript-type">struct</span> kcdata_type_definition kc_type_definition;
	mach_vm_address_t user_addr;
	uint32_t total_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kcdata_type_definition);

	<span class="enscript-keyword">if</span> (strnlen(type_name, KCDATA_DESC_MAXLEN + 1) &gt;= KCDATA_DESC_MAXLEN)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	strlcpy(&amp;kc_type_definition.kct_name[0], type_name, KCDATA_DESC_MAXLEN);
	kc_type_definition.kct_num_elements = elements_count;
	kc_type_definition.kct_type_identifier = type_id;

	total_size += elements_count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kcdata_subtype_descriptor);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != (kr = kcdata_get_memory_addr_with_flavor(data, KCDATA_TYPE_TYPEDEFINTION, total_size, 0, &amp;user_addr)))
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != (kr = kcdata_memcpy(data, user_addr, (<span class="enscript-type">void</span> *)&amp;kc_type_definition, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kcdata_type_definition))))
		<span class="enscript-keyword">return</span> kr;
	user_addr += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kcdata_type_definition);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != (kr = kcdata_memcpy(data, user_addr, (<span class="enscript-type">void</span> *)elements_array_addr, elements_count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kcdata_subtype_descriptor))))
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-keyword">return</span> kr;
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>(4)

<span class="enscript-comment">/* Internal structs for convenience */</span>
<span class="enscript-type">struct</span> _uint64_with_description_data {
	<span class="enscript-type">char</span> desc[KCDATA_DESC_MAXLEN];
	uint64_t data;
};

<span class="enscript-type">struct</span> _uint32_with_description_data {
	<span class="enscript-type">char</span>     desc[KCDATA_DESC_MAXLEN];
	uint32_t data;
};

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>()

kern_return_t <span class="enscript-function-name">kcdata_add_uint64_with_description</span>(
				kcdata_descriptor_t data_desc,
				uint64_t data,
				<span class="enscript-type">const</span> <span class="enscript-type">char</span> *description)
{
	<span class="enscript-keyword">if</span> (strnlen(description, KCDATA_DESC_MAXLEN + 1) &gt;= KCDATA_DESC_MAXLEN)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	kern_return_t kr = 0;
	mach_vm_address_t user_addr;
	<span class="enscript-type">struct</span> _uint64_with_description_data save_data;
	<span class="enscript-type">const</span> uint64_t size_req = <span class="enscript-keyword">sizeof</span>(save_data);
	bzero(&amp;save_data, size_req);

	strlcpy(&amp;(save_data.desc[0]), description, <span class="enscript-keyword">sizeof</span>(save_data.desc));
	save_data.data = data;

	kr = kcdata_get_memory_addr(data_desc, KCDATA_TYPE_UINT64_DESC, size_req, &amp;user_addr);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	<span class="enscript-keyword">if</span> (data_desc-&gt;kcd_flags &amp; KCFLAG_USE_COPYOUT) {
		<span class="enscript-keyword">if</span> (copyout(&amp;save_data, user_addr, size_req))
			<span class="enscript-keyword">return</span> KERN_NO_ACCESS;
	} <span class="enscript-keyword">else</span> {
		memcpy((<span class="enscript-type">void</span> *)user_addr, &amp;save_data, size_req);
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t <span class="enscript-function-name">kcdata_add_uint32_with_description</span>(
				kcdata_descriptor_t data_desc,
				uint32_t data,
				<span class="enscript-type">const</span> <span class="enscript-type">char</span> *description)
{
	assert(strlen(description) &lt; KCDATA_DESC_MAXLEN);
	<span class="enscript-keyword">if</span> (strnlen(description, KCDATA_DESC_MAXLEN + 1) &gt;= KCDATA_DESC_MAXLEN)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;
	kern_return_t kr = 0;
	mach_vm_address_t user_addr;
	<span class="enscript-type">struct</span> _uint32_with_description_data save_data;
	<span class="enscript-type">const</span> uint64_t size_req = <span class="enscript-keyword">sizeof</span>(save_data);

	bzero(&amp;save_data, size_req);
	strlcpy(&amp;(save_data.desc[0]), description, <span class="enscript-keyword">sizeof</span>(save_data.desc));
	save_data.data = data;

	kr = kcdata_get_memory_addr(data_desc, KCDATA_TYPE_UINT32_DESC, size_req, &amp;user_addr);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;
	<span class="enscript-keyword">if</span> (data_desc-&gt;kcd_flags &amp; KCFLAG_USE_COPYOUT) {
		<span class="enscript-keyword">if</span> (copyout(&amp;save_data, user_addr, size_req))
			<span class="enscript-keyword">return</span> KERN_NO_ACCESS;
	} <span class="enscript-keyword">else</span> {
		memcpy((<span class="enscript-type">void</span> *)user_addr, &amp;save_data, size_req);
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-comment">/* end buffer management api */</span>
</pre>
<hr />
</body></html>