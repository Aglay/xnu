<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>bsd_kern.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">bsd_kern.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ledger.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/spl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ast.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span> <span class="enscript-comment">/* last */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resource.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signal.h&gt;</span>

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">thread_should_halt</span>

<span class="enscript-comment">/* BSD KERN COMPONENT INTERFACE */</span>

task_t	bsd_init_task = TASK_NULL;
boolean_t init_task_died;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> not_in_kdp; <span class="enscript-comment">/* Skip acquiring locks if we're in kdp */</span>
 
thread_t <span class="enscript-function-name">get_firstthread</span>(task_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">get_task_userstop</span>(task_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">get_thread_userstop</span>(thread_t);
boolean_t <span class="enscript-function-name">current_thread_aborted</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">task_act_iterate_wth_args</span>(task_t, <span class="enscript-type">void</span>(*)(thread_t, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *);
kern_return_t <span class="enscript-function-name">get_signalact</span>(task_t , thread_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">get_vmsubmap_entries</span>(vm_map_t, vm_object_offset_t, vm_object_offset_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">fill_task_rusage</span>(task_t task, rusage_info_current *ri);
<span class="enscript-type">int</span> <span class="enscript-function-name">fill_task_io_rusage</span>(task_t task, rusage_info_current *ri);
<span class="enscript-type">int</span> <span class="enscript-function-name">fill_task_qos_rusage</span>(task_t task, rusage_info_current *ri);
<span class="enscript-type">void</span> <span class="enscript-function-name">fill_task_billed_usage</span>(task_t task, rusage_info_current *ri);
<span class="enscript-type">void</span> <span class="enscript-function-name">task_bsdtask_kill</span>(task_t);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_BSD</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">psignal</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">void</span>  *<span class="enscript-function-name">get_bsdtask_info</span>(task_t t)
{
	<span class="enscript-keyword">return</span>(t-&gt;bsd_info);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">task_bsdtask_kill</span>(task_t t)
{
	<span class="enscript-type">void</span> * bsd_info = get_bsdtask_info(t);
	<span class="enscript-keyword">if</span> (bsd_info != NULL) {
		psignal(bsd_info, SIGKILL);
	}
}
<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">void</span> *<span class="enscript-function-name">get_bsdthreadtask_info</span>(thread_t th)
{
	<span class="enscript-keyword">return</span>(th-&gt;task != TASK_NULL ? th-&gt;task-&gt;bsd_info : NULL);
}

<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">set_bsdtask_info</span>(task_t t,<span class="enscript-type">void</span> * v)
{
	t-&gt;bsd_info=v;
}

<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">void</span> *<span class="enscript-function-name">get_bsdthread_info</span>(thread_t th)
{
	<span class="enscript-keyword">return</span>(th-&gt;uthread);
}

<span class="enscript-comment">/*
 * XXX
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">get_thread_lock_count</span>(thread_t th);		<span class="enscript-comment">/* forced forward */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">get_thread_lock_count</span>(thread_t th)
{
 	<span class="enscript-keyword">return</span>(th-&gt;mutex_count);
}

<span class="enscript-comment">/*
 * XXX: wait for BSD to  fix signal code
 * Until then, we cannot block here.  We know the task
 * can't go away, so we make sure it is still active after
 * retrieving the first thread for extra safety.
 */</span>
thread_t <span class="enscript-function-name">get_firstthread</span>(task_t task)
{
	thread_t	thread = (thread_t)(<span class="enscript-type">void</span> *)queue_first(&amp;task-&gt;threads);

	<span class="enscript-keyword">if</span> (queue_end(&amp;task-&gt;threads, (queue_entry_t)thread))
		thread = THREAD_NULL;

	<span class="enscript-keyword">if</span> (!task-&gt;active)
		<span class="enscript-keyword">return</span> (THREAD_NULL);

	<span class="enscript-keyword">return</span> (thread);
}

kern_return_t
<span class="enscript-function-name">get_signalact</span>(
	task_t		task,
	thread_t	*result_out,
	<span class="enscript-type">int</span>			setast)
{
	kern_return_t	result = KERN_SUCCESS;
	thread_t		inc, thread = THREAD_NULL;

	task_lock(task);

	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		task_unlock(task);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	<span class="enscript-keyword">for</span> (inc  = (thread_t)(<span class="enscript-type">void</span> *)queue_first(&amp;task-&gt;threads);
			!queue_end(&amp;task-&gt;threads, (queue_entry_t)inc); ) {
		thread_mtx_lock(inc);
		<span class="enscript-keyword">if</span> (inc-&gt;active &amp;&amp;
				(inc-&gt;sched_flags &amp; TH_SFLAG_ABORTED_MASK) != TH_SFLAG_ABORT) {
			thread = inc;
			<span class="enscript-keyword">break</span>;
		}
		thread_mtx_unlock(inc);

		inc = (thread_t)(<span class="enscript-type">void</span> *)queue_next(&amp;inc-&gt;task_threads);
	}

	<span class="enscript-keyword">if</span> (result_out) 
		*result_out = thread;

	<span class="enscript-keyword">if</span> (thread) {
		<span class="enscript-keyword">if</span> (setast)
			act_set_astbsd(thread);

		thread_mtx_unlock(thread);
	}
	<span class="enscript-keyword">else</span>
		result = KERN_FAILURE;

	task_unlock(task);

	<span class="enscript-keyword">return</span> (result);
}


kern_return_t
<span class="enscript-function-name">check_actforsig</span>(
	task_t			task,
	thread_t		thread,
	<span class="enscript-type">int</span>				setast)
{
	kern_return_t	result = KERN_FAILURE;
	thread_t		inc;

	task_lock(task);

	<span class="enscript-keyword">if</span> (!task-&gt;active) {
		task_unlock(task);

		<span class="enscript-keyword">return</span> (KERN_FAILURE);
	}

	<span class="enscript-keyword">for</span> (inc  = (thread_t)(<span class="enscript-type">void</span> *)queue_first(&amp;task-&gt;threads);
			!queue_end(&amp;task-&gt;threads, (queue_entry_t)inc); ) {
		<span class="enscript-keyword">if</span> (inc == thread) {
			thread_mtx_lock(inc);

			<span class="enscript-keyword">if</span> (inc-&gt;active  &amp;&amp; 
					(inc-&gt;sched_flags &amp; TH_SFLAG_ABORTED_MASK) != TH_SFLAG_ABORT) {
				result = KERN_SUCCESS;
				<span class="enscript-keyword">break</span>;
			}

			thread_mtx_unlock(inc);
			<span class="enscript-keyword">break</span>;
		}

		inc = (thread_t)(<span class="enscript-type">void</span> *)queue_next(&amp;inc-&gt;task_threads);
	}

	<span class="enscript-keyword">if</span> (result == KERN_SUCCESS) {
		<span class="enscript-keyword">if</span> (setast)
			act_set_astbsd(thread);

		thread_mtx_unlock(thread);
	}

	task_unlock(task);

	<span class="enscript-keyword">return</span> (result);
}

ledger_t  <span class="enscript-function-name">get_task_ledger</span>(task_t t)
{
	<span class="enscript-keyword">return</span>(t-&gt;ledger);
}

<span class="enscript-comment">/*
 * This is only safe to call from a thread executing in
 * in the task's context or if the task is locked. Otherwise,
 * the map could be switched for the task (and freed) before
 * we go to return it here.
 */</span>
vm_map_t  <span class="enscript-function-name">get_task_map</span>(task_t t)
{
	<span class="enscript-keyword">return</span>(t-&gt;map);
}

vm_map_t  <span class="enscript-function-name">get_task_map_reference</span>(task_t t)
{
	vm_map_t m;

	<span class="enscript-keyword">if</span> (t == NULL)
		<span class="enscript-keyword">return</span> VM_MAP_NULL;

	task_lock(t);
	<span class="enscript-keyword">if</span> (!t-&gt;active) {
		task_unlock(t);
		<span class="enscript-keyword">return</span> VM_MAP_NULL;
	}
	m = t-&gt;map;
	vm_map_reference_swap(m);
	task_unlock(t);
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/*
 *
 */</span>
ipc_space_t  <span class="enscript-function-name">get_task_ipcspace</span>(task_t t)
{
	<span class="enscript-keyword">return</span>(t-&gt;itk_space);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">get_task_numactivethreads</span>(task_t task)
{
	thread_t	inc;
	<span class="enscript-type">int</span> num_active_thr=0;
	task_lock(task);

	<span class="enscript-keyword">for</span> (inc  = (thread_t)(<span class="enscript-type">void</span> *)queue_first(&amp;task-&gt;threads);
			!queue_end(&amp;task-&gt;threads, (queue_entry_t)inc); inc = (thread_t)(<span class="enscript-type">void</span> *)queue_next(&amp;inc-&gt;task_threads)) 
	{
		<span class="enscript-keyword">if</span>(inc-&gt;active)
			num_active_thr++;
	}
	task_unlock(task);
	<span class="enscript-keyword">return</span> num_active_thr;
}

<span class="enscript-type">int</span>  <span class="enscript-function-name">get_task_numacts</span>(task_t t)
{
	<span class="enscript-keyword">return</span>(t-&gt;thread_count);
}

<span class="enscript-comment">/* does this machine need  64bit register set for signal handler */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">is_64signalregset</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (task_has_64BitData(current_task())) {
		<span class="enscript-keyword">return</span>(1);
	}

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Swap in a new map for the task/thread pair; the old map reference is
 * returned.
 */</span>
vm_map_t
<span class="enscript-function-name">swap_task_map</span>(task_t task, thread_t thread, vm_map_t map, boolean_t doswitch)
{
	vm_map_t old_map;

	<span class="enscript-keyword">if</span> (task != thread-&gt;task)
		panic(<span class="enscript-string">&quot;swap_task_map&quot;</span>);

	task_lock(task);
	mp_disable_preemption();
	old_map = task-&gt;map;
	thread-&gt;map = task-&gt;map = map;
	<span class="enscript-keyword">if</span> (doswitch) {
		pmap_switch(map-&gt;pmap);
	}
	mp_enable_preemption();
	task_unlock(task);

#<span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)) &amp;&amp; <span class="enscript-variable-name">NCOPY_WINDOWS</span> &gt; 0
	inval_copy_windows(thread);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> old_map;
}

<span class="enscript-comment">/*
 *
 * This is only safe to call from a thread executing in
 * in the task's context or if the task is locked. Otherwise,
 * the map could be switched for the task (and freed) before
 * we go to return it here.
 */</span>
pmap_t  <span class="enscript-function-name">get_task_pmap</span>(task_t t)
{
	<span class="enscript-keyword">return</span>(t-&gt;map-&gt;pmap);
}

<span class="enscript-comment">/*
 *
 */</span>
uint64_t <span class="enscript-function-name">get_task_resident_size</span>(task_t task) 
{
	vm_map_t map;
	
	map = (task == kernel_task) ? kernel_map: task-&gt;map;
	<span class="enscript-keyword">return</span>((uint64_t)pmap_resident_count(map-&gt;pmap) * PAGE_SIZE_64);
}

uint64_t <span class="enscript-function-name">get_task_compressed</span>(task_t task) 
{
	vm_map_t map;
	
	map = (task == kernel_task) ? kernel_map: task-&gt;map;
	<span class="enscript-keyword">return</span>((uint64_t)pmap_compressed(map-&gt;pmap) * PAGE_SIZE_64);
}

uint64_t <span class="enscript-function-name">get_task_resident_max</span>(task_t task) 
{
	vm_map_t map;
	
	map = (task == kernel_task) ? kernel_map: task-&gt;map;
	<span class="enscript-keyword">return</span>((uint64_t)pmap_resident_max(map-&gt;pmap) * PAGE_SIZE_64);
}

uint64_t <span class="enscript-function-name">get_task_purgeable_size</span>(task_t task) 
{
	kern_return_t ret;
	ledger_amount_t credit, debit;
	uint64_t volatile_size = 0;

	ret = ledger_get_entries(task-&gt;ledger, task_ledgers.purgeable_volatile, &amp;credit, &amp;debit);
	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS) {
		<span class="enscript-keyword">return</span> 0;
	}

	volatile_size += (credit - debit);

	ret = ledger_get_entries(task-&gt;ledger, task_ledgers.purgeable_volatile_compressed, &amp;credit, &amp;debit);
	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS) {
		<span class="enscript-keyword">return</span> 0;
	}

	volatile_size += (credit - debit);

	<span class="enscript-keyword">return</span> volatile_size;
}

<span class="enscript-comment">/*
 *
 */</span>
uint64_t <span class="enscript-function-name">get_task_phys_footprint</span>(task_t task) 
{	
	kern_return_t ret;
	ledger_amount_t credit, debit;
	
	ret = ledger_get_entries(task-&gt;ledger, task_ledgers.phys_footprint, &amp;credit, &amp;debit);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS == ret) {
		<span class="enscript-keyword">return</span> (credit - debit);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 *
 */</span>
uint64_t <span class="enscript-function-name">get_task_phys_footprint_max</span>(task_t task) 
{	
	kern_return_t ret;
	ledger_amount_t max;
	
	ret = ledger_get_maximum(task-&gt;ledger, task_ledgers.phys_footprint, &amp;max);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS == ret) {
		<span class="enscript-keyword">return</span> max;
	}

	<span class="enscript-keyword">return</span> 0;
}

uint64_t <span class="enscript-function-name">get_task_cpu_time</span>(task_t task)
{
	kern_return_t ret;
	ledger_amount_t credit, debit;
	
	ret = ledger_get_entries(task-&gt;ledger, task_ledgers.cpu_time, &amp;credit, &amp;debit);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS == ret) {
		<span class="enscript-keyword">return</span> (credit - debit);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 *
 */</span>
task_t	get_threadtask(thread_t th)
{
	<span class="enscript-keyword">return</span>(th-&gt;task);
}

<span class="enscript-comment">/*
 *
 */</span>
vm_map_offset_t
<span class="enscript-function-name">get_map_min</span>(
	vm_map_t	map)
{
	<span class="enscript-keyword">return</span>(vm_map_min(map));
}

<span class="enscript-comment">/*
 *
 */</span>
vm_map_offset_t
<span class="enscript-function-name">get_map_max</span>(
	vm_map_t	map)
{
	<span class="enscript-keyword">return</span>(vm_map_max(map));
}
vm_map_size_t
<span class="enscript-function-name">get_vmmap_size</span>(
	vm_map_t	map)
{
	<span class="enscript-keyword">return</span>(map-&gt;size);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">get_vmsubmap_entries</span>(
	vm_map_t	map,
	vm_object_offset_t	start,
	vm_object_offset_t	end)
{
	<span class="enscript-type">int</span>	total_entries = 0;
	vm_map_entry_t	entry;

	<span class="enscript-keyword">if</span> (not_in_kdp)
	  vm_map_lock(map);
	entry = vm_map_first_entry(map);
	<span class="enscript-keyword">while</span>((entry != vm_map_to_entry(map)) &amp;&amp; (entry-&gt;vme_start &lt; start)) {
		entry = entry-&gt;vme_next;
	}

	<span class="enscript-keyword">while</span>((entry != vm_map_to_entry(map)) &amp;&amp; (entry-&gt;vme_start &lt; end)) {
		<span class="enscript-keyword">if</span>(entry-&gt;is_sub_map) {
			total_entries += 	
				get_vmsubmap_entries(VME_SUBMAP(entry), 
						     VME_OFFSET(entry), 
						     (VME_OFFSET(entry) + 
						      entry-&gt;vme_end -
						      entry-&gt;vme_start));
		} <span class="enscript-keyword">else</span> {
			total_entries += 1;
		}
		entry = entry-&gt;vme_next;
	}
	<span class="enscript-keyword">if</span> (not_in_kdp)
	  vm_map_unlock(map);
	<span class="enscript-keyword">return</span>(total_entries);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">get_vmmap_entries</span>(
	vm_map_t	map)
{
	<span class="enscript-type">int</span>	total_entries = 0;
	vm_map_entry_t	entry;

	<span class="enscript-keyword">if</span> (not_in_kdp)
	  vm_map_lock(map);
	entry = vm_map_first_entry(map);

	<span class="enscript-keyword">while</span>(entry != vm_map_to_entry(map)) {
		<span class="enscript-keyword">if</span>(entry-&gt;is_sub_map) {
			total_entries += 	
				get_vmsubmap_entries(VME_SUBMAP(entry), 
						     VME_OFFSET(entry),
						     (VME_OFFSET(entry) + 
						      entry-&gt;vme_end -
						      entry-&gt;vme_start));
		} <span class="enscript-keyword">else</span> {
			total_entries += 1;
		}
		entry = entry-&gt;vme_next;
	}
	<span class="enscript-keyword">if</span> (not_in_kdp)
	  vm_map_unlock(map);
	<span class="enscript-keyword">return</span>(total_entries);
}

<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">get_task_userstop</span>(
	task_t task)
{
	<span class="enscript-keyword">return</span>(task-&gt;user_stop_count);
}

<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">get_thread_userstop</span>(
	thread_t th)
{
	<span class="enscript-keyword">return</span>(th-&gt;user_stop_count);
}

<span class="enscript-comment">/*
 *
 */</span>
boolean_t
<span class="enscript-function-name">get_task_pidsuspended</span>(
	task_t task)
{
    <span class="enscript-keyword">return</span> (task-&gt;pidsuspended);
}

<span class="enscript-comment">/*
 *
 */</span>
boolean_t 
<span class="enscript-function-name">get_task_frozen</span>(
	task_t task)
{
    <span class="enscript-keyword">return</span> (task-&gt;frozen);   
}

<span class="enscript-comment">/*
 *
 */</span>
boolean_t
<span class="enscript-function-name">thread_should_abort</span>(
	thread_t th)
{
	<span class="enscript-keyword">return</span> ((th-&gt;sched_flags &amp; TH_SFLAG_ABORTED_MASK) == TH_SFLAG_ABORT);
}

<span class="enscript-comment">/*
 * This routine is like thread_should_abort() above.  It checks to
 * see if the current thread is aborted.  But unlike above, it also
 * checks to see if thread is safely aborted.  If so, it returns
 * that fact, and clears the condition (safe aborts only should
 * have a single effect, and a poll of the abort status
 * qualifies.
 */</span>
boolean_t
<span class="enscript-function-name">current_thread_aborted</span> (
		<span class="enscript-type">void</span>)
{
	thread_t th = current_thread();
	spl_t s;

	<span class="enscript-keyword">if</span> ((th-&gt;sched_flags &amp; TH_SFLAG_ABORTED_MASK) == TH_SFLAG_ABORT &amp;&amp;
			(th-&gt;options &amp; TH_OPT_INTMASK) != THREAD_UNINT)
		<span class="enscript-keyword">return</span> (TRUE);
	<span class="enscript-keyword">if</span> (th-&gt;sched_flags &amp; TH_SFLAG_ABORTSAFELY) {
		s = splsched();
		thread_lock(th);
		<span class="enscript-keyword">if</span> (th-&gt;sched_flags &amp; TH_SFLAG_ABORTSAFELY)
			th-&gt;sched_flags &amp;= ~TH_SFLAG_ABORTED_MASK;
		thread_unlock(th);
		splx(s);
	}
	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">task_act_iterate_wth_args</span>(
	task_t			task,
	<span class="enscript-type">void</span>			(*func_callback)(thread_t, <span class="enscript-type">void</span> *),
	<span class="enscript-type">void</span>			*func_arg)
{
	thread_t	inc;

	task_lock(task);

	<span class="enscript-keyword">for</span> (inc  = (thread_t)(<span class="enscript-type">void</span> *)queue_first(&amp;task-&gt;threads);
			!queue_end(&amp;task-&gt;threads, (queue_entry_t)inc); ) {
		(<span class="enscript-type">void</span>) (*func_callback)(inc, func_arg);
		inc = (thread_t)(<span class="enscript-type">void</span> *)queue_next(&amp;inc-&gt;task_threads);
	}

	task_unlock(task);
}


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/bsdtask_info.h&gt;</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">fill_taskprocinfo</span>(task_t task, <span class="enscript-type">struct</span> proc_taskinfo_internal * ptinfo)
{
	vm_map_t map;
	task_absolutetime_info_data_t   tinfo;
	thread_t thread;
	uint32_t cswitch = 0, numrunning = 0;
	uint32_t syscalls_unix = 0;
	uint32_t syscalls_mach = 0;

	task_lock(task);

	map = (task == kernel_task)? kernel_map: task-&gt;map;

	ptinfo-&gt;pti_virtual_size  = map-&gt;size;
	ptinfo-&gt;pti_resident_size =
		(mach_vm_size_t)(pmap_resident_count(map-&gt;pmap))
		* PAGE_SIZE_64;

	ptinfo-&gt;pti_policy = ((task != kernel_task)?
                                          <span class="enscript-reference">POLICY_TIMESHARE</span>: POLICY_RR);

	tinfo.threads_user = tinfo.threads_system = 0;
	tinfo.total_user = task-&gt;total_user_time;
	tinfo.total_system = task-&gt;total_system_time;

	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
		uint64_t    tval;
		spl_t x;

		<span class="enscript-keyword">if</span> (thread-&gt;options &amp; TH_OPT_IDLE_THREAD)
			<span class="enscript-keyword">continue</span>;

		x = splsched();
		thread_lock(thread);

		<span class="enscript-keyword">if</span> ((thread-&gt;state &amp; TH_RUN) == TH_RUN)
			numrunning++;
		cswitch += thread-&gt;c_switch;
		tval = timer_grab(&amp;thread-&gt;user_timer);
		tinfo.threads_user += tval;
		tinfo.total_user += tval;

		tval = timer_grab(&amp;thread-&gt;system_timer);

		<span class="enscript-keyword">if</span> (thread-&gt;precise_user_kernel_time) {
			tinfo.threads_system += tval;
			tinfo.total_system += tval;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* system_timer may represent either sys or user */</span>
			tinfo.threads_user += tval;
			tinfo.total_user += tval;
		}

		syscalls_unix += thread-&gt;syscalls_unix;
		syscalls_mach += thread-&gt;syscalls_mach;

		thread_unlock(thread);
		splx(x);
	}

	ptinfo-&gt;pti_total_system = tinfo.total_system;
	ptinfo-&gt;pti_total_user = tinfo.total_user;
	ptinfo-&gt;pti_threads_system = tinfo.threads_system;
	ptinfo-&gt;pti_threads_user = tinfo.threads_user;
	
	ptinfo-&gt;pti_faults = task-&gt;faults;
	ptinfo-&gt;pti_pageins = task-&gt;pageins;
	ptinfo-&gt;pti_cow_faults = task-&gt;cow_faults;
	ptinfo-&gt;pti_messages_sent = task-&gt;messages_sent;
	ptinfo-&gt;pti_messages_received = task-&gt;messages_received;
	ptinfo-&gt;pti_syscalls_mach = task-&gt;syscalls_mach + syscalls_mach;
	ptinfo-&gt;pti_syscalls_unix = task-&gt;syscalls_unix + syscalls_unix;
	ptinfo-&gt;pti_csw = task-&gt;c_switch + cswitch;
	ptinfo-&gt;pti_threadnum = task-&gt;thread_count;
	ptinfo-&gt;pti_numrunning = numrunning;
	ptinfo-&gt;pti_priority = task-&gt;priority;

	task_unlock(task);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">fill_taskthreadinfo</span>(task_t task, uint64_t thaddr, <span class="enscript-type">int</span> thuniqueid, <span class="enscript-type">struct</span> proc_threadinfo_internal * ptinfo, <span class="enscript-type">void</span> * vpp, <span class="enscript-type">int</span> *vidp)
{
	thread_t  thact;
	<span class="enscript-type">int</span> err=0;
	mach_msg_type_number_t count;
	thread_basic_info_data_t basic_info;
	kern_return_t kret;
	uint64_t addr = 0;

	task_lock(task);

	<span class="enscript-keyword">for</span> (thact  = (thread_t)(<span class="enscript-type">void</span> *)queue_first(&amp;task-&gt;threads);
			!queue_end(&amp;task-&gt;threads, (queue_entry_t)thact); ) {
		addr = (thuniqueid==0)?thact-&gt;machine.cthread_self: thact-&gt;thread_id;
		<span class="enscript-keyword">if</span> (addr == thaddr)
		{
		
			count = THREAD_BASIC_INFO_COUNT;
			<span class="enscript-keyword">if</span> ((kret = thread_info_internal(thact, THREAD_BASIC_INFO, (thread_info_t)&amp;basic_info, &amp;count)) != KERN_SUCCESS) {
				err = 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;	
			}
			ptinfo-&gt;pth_user_time = ((basic_info.user_time.seconds * (integer_t)NSEC_PER_SEC) + (basic_info.user_time.microseconds * (integer_t)NSEC_PER_USEC));
			ptinfo-&gt;pth_system_time = ((basic_info.system_time.seconds * (integer_t)NSEC_PER_SEC) + (basic_info.system_time.microseconds * (integer_t)NSEC_PER_USEC));

			ptinfo-&gt;pth_cpu_usage = basic_info.cpu_usage;
			ptinfo-&gt;pth_policy = basic_info.policy;
			ptinfo-&gt;pth_run_state = basic_info.run_state;
			ptinfo-&gt;pth_flags = basic_info.flags;
			ptinfo-&gt;pth_sleep_time = basic_info.sleep_time;
			ptinfo-&gt;pth_curpri = thact-&gt;sched_pri;
			ptinfo-&gt;pth_priority = thact-&gt;base_pri;
			ptinfo-&gt;pth_maxpriority = thact-&gt;max_priority;
			
			<span class="enscript-keyword">if</span> ((vpp != NULL) &amp;&amp; (thact-&gt;uthread != NULL)) 
				bsd_threadcdir(thact-&gt;uthread, vpp, vidp);
			bsd_getthreadname(thact-&gt;uthread,ptinfo-&gt;pth_name);
			err = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>; 
		}
		thact = (thread_t)(<span class="enscript-type">void</span> *)queue_next(&amp;thact-&gt;task_threads);
	}
	err = 1;

<span class="enscript-reference">out</span>:
	task_unlock(task);
	<span class="enscript-keyword">return</span>(err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fill_taskthreadlist</span>(task_t task, <span class="enscript-type">void</span> * buffer, <span class="enscript-type">int</span> thcount)
{
	<span class="enscript-type">int</span> numthr=0;
	thread_t thact;
	uint64_t * uptr;
	uint64_t  thaddr;

	uptr = (uint64_t *)buffer;

	task_lock(task);

	<span class="enscript-keyword">for</span> (thact  = (thread_t)(<span class="enscript-type">void</span> *)queue_first(&amp;task-&gt;threads);
			!queue_end(&amp;task-&gt;threads, (queue_entry_t)thact); ) {
		thaddr = thact-&gt;machine.cthread_self;
		*uptr++ = thaddr;
		numthr++;
		<span class="enscript-keyword">if</span> (numthr &gt;= thcount)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		thact = (thread_t)(<span class="enscript-type">void</span> *)queue_next(&amp;thact-&gt;task_threads);
	}

<span class="enscript-reference">out</span>:
	task_unlock(task);
	<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)(numthr * <span class="enscript-keyword">sizeof</span>(uint64_t));
	
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">get_numthreads</span>(task_t task)
{
	<span class="enscript-keyword">return</span>(task-&gt;thread_count);
}

<span class="enscript-comment">/*
 * Gather the various pieces of info about the designated task, 
 * and collect it all into a single rusage_info.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fill_task_rusage</span>(task_t task, rusage_info_current *ri)
{
	<span class="enscript-type">struct</span> task_power_info powerinfo;

	assert(task != TASK_NULL);
	task_lock(task);

	task_power_info_locked(task, &amp;powerinfo, NULL);
	ri-&gt;ri_pkg_idle_wkups = powerinfo.task_platform_idle_wakeups;
	ri-&gt;ri_interrupt_wkups = powerinfo.task_interrupt_wakeups;
	ri-&gt;ri_user_time = powerinfo.total_user;
	ri-&gt;ri_system_time = powerinfo.total_system;

	ledger_get_balance(task-&gt;ledger, task_ledgers.phys_footprint,
	                   (ledger_amount_t *)&amp;ri-&gt;ri_phys_footprint);
	ledger_get_balance(task-&gt;ledger, task_ledgers.phys_mem,
	                   (ledger_amount_t *)&amp;ri-&gt;ri_resident_size);
	ledger_get_balance(task-&gt;ledger, task_ledgers.wired_mem,
	                   (ledger_amount_t *)&amp;ri-&gt;ri_wired_size);

	ri-&gt;ri_pageins = task-&gt;pageins;

	task_unlock(task);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">fill_task_billed_usage</span>(task_t task __unused, rusage_info_current *ri)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_BANK</span>
	ri-&gt;ri_billed_system_time = bank_billed_time(task-&gt;bank_context);
	ri-&gt;ri_serviced_system_time = bank_serviced_time(task-&gt;bank_context);
#<span class="enscript-reference">else</span>
	ri-&gt;ri_billed_system_time = 0;
	ri-&gt;ri_serviced_system_time = 0;
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fill_task_io_rusage</span>(task_t task, rusage_info_current *ri)
{
	assert(task != TASK_NULL);
	task_lock(task);

	<span class="enscript-keyword">if</span> (task-&gt;task_io_stats) {
		ri-&gt;ri_diskio_bytesread = task-&gt;task_io_stats-&gt;disk_reads.size;
		ri-&gt;ri_diskio_byteswritten = (task-&gt;task_io_stats-&gt;total_io.size - task-&gt;task_io_stats-&gt;disk_reads.size);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* I/O Stats unavailable */</span>
		ri-&gt;ri_diskio_bytesread = 0;
		ri-&gt;ri_diskio_byteswritten = 0;
	}
	task_unlock(task);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fill_task_qos_rusage</span>(task_t task, rusage_info_current *ri)
{
	thread_t thread;

	assert(task != TASK_NULL);
	task_lock(task);

	<span class="enscript-comment">/* Rollup Qos time of all the threads to task */</span>
	queue_iterate(&amp;task-&gt;threads, thread, thread_t, task_threads) {
		<span class="enscript-keyword">if</span> (thread-&gt;options &amp; TH_OPT_IDLE_THREAD)
			<span class="enscript-keyword">continue</span>;

		thread_mtx_lock(thread);
		thread_update_qos_cpu_time(thread, TRUE);
		thread_mtx_unlock(thread);
		
	}
	ri-&gt;ri_cpu_time_qos_default = task-&gt;cpu_time_qos_stats.cpu_time_qos_default;
	ri-&gt;ri_cpu_time_qos_maintenance = task-&gt;cpu_time_qos_stats.cpu_time_qos_maintenance;
	ri-&gt;ri_cpu_time_qos_background = task-&gt;cpu_time_qos_stats.cpu_time_qos_background;
	ri-&gt;ri_cpu_time_qos_utility = task-&gt;cpu_time_qos_stats.cpu_time_qos_utility;
	ri-&gt;ri_cpu_time_qos_legacy = task-&gt;cpu_time_qos_stats.cpu_time_qos_legacy;
	ri-&gt;ri_cpu_time_qos_user_initiated = task-&gt;cpu_time_qos_stats.cpu_time_qos_user_initiated;
	ri-&gt;ri_cpu_time_qos_user_interactive = task-&gt;cpu_time_qos_stats.cpu_time_qos_user_interactive;

	task_unlock(task);
	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>