<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>thread.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">thread.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_FREE_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	thread.h
 *	Author:	Avadis Tevanian, Jr.
 *
 *	This file contains the structure definitions for threads.
 *
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1993 The University of Utah and
 * the Computer Systems Laboratory (CSL).  All rights reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * THE UNIVERSITY OF UTAH AND CSL ALLOW FREE USE OF THIS SOFTWARE IN ITS &quot;AS
 * IS&quot; CONDITION.  THE UNIVERSITY OF UTAH AND CSL DISCLAIM ANY LIABILITY OF
 * ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * CSL requests users of this software to return to <a href="mailto:csl-dist@cs.utah.edu">csl-dist@cs.utah.edu</a> any
 * improvements that they make and grant CSL redistribution rights.
 *
 */</span>

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">_KERN_THREAD_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_KERN_THREAD_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/message.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_status.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/exception_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">MACH_KERNEL_PRIVATE</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_ldebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/smp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/simple_lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sfi_class.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/timer_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/exception.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/affinity.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/waitq.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_kmsg.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/thread.h&gt;</span>

<span class="enscript-type">struct</span> thread {
	<span class="enscript-comment">/*
	 *	NOTE:	The runq field in the thread structure has an unusual
	 *	locking protocol.  If its value is PROCESSOR_NULL, then it is
	 *	locked by the thread_lock, but if its value is something else
	 *	then it is locked by the associated run queue lock. It is
	 *	set to PROCESSOR_NULL without holding the thread lock, but the
	 *	transition from PROCESSOR_NULL to non-null must be done
	 *	under the thread lock and the run queue lock.
	 *
	 *	New waitq APIs allow the 'links' and 'runq' fields to be
	 *	anywhere in the thread structure.
	 */</span>
  	<span class="enscript-comment">/* Items examined often, modified infrequently */</span>
	queue_chain_t	links;				<span class="enscript-comment">/* run/wait queue links */</span>
	processor_t		runq;				<span class="enscript-comment">/* run queue assignment */</span>
	event64_t		wait_event;			<span class="enscript-comment">/* wait queue event */</span>
	<span class="enscript-type">struct</span> waitq	*waitq;
	<span class="enscript-comment">/* Data updated during assert_wait/thread_wakeup */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__SMP__</span>
	decl_simple_lock_data(,sched_lock)	<span class="enscript-comment">/* scheduling lock (thread_lock()) */</span>
	decl_simple_lock_data(,wake_lock)	<span class="enscript-comment">/* for thread stop / wait (wake_lock()) */</span>
#<span class="enscript-reference">endif</span>
	integer_t		options;			<span class="enscript-comment">/* options set by thread itself */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_OPT_INTMASK</span>		0x0003		<span class="enscript-comment">/* interrupt / abort level */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_OPT_VMPRIV</span>		0x0004		<span class="enscript-comment">/* may allocate reserved memory */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_OPT_DTRACE</span>		0x0008		<span class="enscript-comment">/* executing under dtrace_probe */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_OPT_SYSTEM_CRITICAL</span>	0x0010		<span class="enscript-comment">/* Thread must always be allowed to run - even under heavy load */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_OPT_PROC_CPULIMIT</span>	0x0020		<span class="enscript-comment">/* Thread has a task-wide CPU limit applied to it */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_OPT_PRVT_CPULIMIT</span>	0x0040		<span class="enscript-comment">/* Thread has a thread-private CPU limit applied to it */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_OPT_IDLE_THREAD</span>	0x0080		<span class="enscript-comment">/* Thread is a per-processor idle thread */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_OPT_GLOBAL_FORCED_IDLE</span>	0x0100	<span class="enscript-comment">/* Thread performs forced idle for thermal control */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_OPT_SCHED_VM_GROUP</span>	0x0200		<span class="enscript-comment">/* Thread belongs to special scheduler VM group */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_OPT_HONOR_QLIMIT</span>	0x0400		<span class="enscript-comment">/* Thread will honor qlimit while sending mach_msg, regardless of MACH_SEND_ALWAYS */</span>

	boolean_t			wake_active;	<span class="enscript-comment">/* wake event on stop */</span>
	<span class="enscript-type">int</span>					at_safe_point;	<span class="enscript-comment">/* thread_abort_safely allowed */</span>
	ast_t				reason;			<span class="enscript-comment">/* why we blocked */</span>
	uint32_t 			quantum_remaining;
	wait_result_t 			wait_result; 	<span class="enscript-comment">/* outcome of wait -
							 * may be examined by this thread
							 * WITHOUT locking */</span>
	thread_continue_t	continuation;	<span class="enscript-comment">/* continue here next dispatch */</span>
	<span class="enscript-type">void</span>				*parameter;		<span class="enscript-comment">/* continuation parameter */</span>

	<span class="enscript-comment">/* Data updated/used in thread_invoke */</span>
	vm_offset_t     	kernel_stack;		<span class="enscript-comment">/* current kernel stack */</span>
	vm_offset_t			reserved_stack;		<span class="enscript-comment">/* reserved kernel stack */</span>

	<span class="enscript-comment">/* Thread state: */</span>
	<span class="enscript-type">int</span>					state;
<span class="enscript-comment">/*
 *	Thread states [bits or'ed]
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_WAIT</span>			0x01			<span class="enscript-comment">/* queued for waiting */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SUSP</span>			0x02			<span class="enscript-comment">/* stopped or requested to stop */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_RUN</span>			0x04			<span class="enscript-comment">/* running or on runq */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_UNINT</span>		0x08			<span class="enscript-comment">/* waiting uninteruptibly */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_TERMINATE</span>		0x10			<span class="enscript-comment">/* halted at termination */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_TERMINATE2</span>		0x20			<span class="enscript-comment">/* added to termination queue */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_IDLE</span>			0x80			<span class="enscript-comment">/* idling processor */</span>

	<span class="enscript-comment">/* Scheduling information */</span>
	sched_mode_t			sched_mode;		<span class="enscript-comment">/* scheduling mode */</span>
	sched_mode_t			saved_mode;		<span class="enscript-comment">/* saved mode during forced mode demotion */</span>

	sfi_class_id_t			sfi_class;		<span class="enscript-comment">/* SFI class (XXX Updated on CSW/QE/AST) */</span>
	sfi_class_id_t			sfi_wait_class;	<span class="enscript-comment">/* Currently in SFI wait for this class, protected by sfi_lock */</span>
	
	uint32_t			sched_flags;		<span class="enscript-comment">/* current flag bits */</span>
<span class="enscript-comment">/* TH_SFLAG_FAIRSHARE_TRIPPED (unused)	0x0001 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_FAILSAFE</span>		0x0002		<span class="enscript-comment">/* fail-safe has tripped */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_THROTTLED</span>		0x0004		<span class="enscript-comment">/* thread treated as background for scheduler decay purposes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_DEMOTED_MASK</span>      (TH_SFLAG_THROTTLE_DEMOTED | TH_SFLAG_FAILSAFE)	<span class="enscript-comment">/* saved_mode contains previous sched_mode */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TH_SFLAG_PROMOTED</span>		0x0008		<span class="enscript-comment">/* sched pri has been promoted */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_ABORT</span>			0x0010		<span class="enscript-comment">/* abort interruptible waits */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_ABORTSAFELY</span>		0x0020		<span class="enscript-comment">/* ... but only those at safe point */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_ABORTED_MASK</span>		(TH_SFLAG_ABORT | TH_SFLAG_ABORTSAFELY)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TH_SFLAG_DEPRESS</span>		0x0040		<span class="enscript-comment">/* normal depress yield */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_POLLDEPRESS</span>		0x0080		<span class="enscript-comment">/* polled depress yield */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_DEPRESSED_MASK</span>		(TH_SFLAG_DEPRESS | TH_SFLAG_POLLDEPRESS)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_PRI_UPDATE</span>		0x0100		<span class="enscript-comment">/* Updating priority */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_EAGERPREEMPT</span>		0x0200		<span class="enscript-comment">/* Any preemption of this thread should be treated as if AST_URGENT applied */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_RW_PROMOTED</span>		0x0400		<span class="enscript-comment">/* sched pri has been promoted due to blocking with RW lock held */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_THROTTLE_DEMOTED</span>	0x0800		<span class="enscript-comment">/* throttled thread forced to timeshare mode (may be applied in addition to failsafe) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_WAITQ_PROMOTED</span>		0x1000		<span class="enscript-comment">/* sched pri promoted from waitq wakeup (generally for IPC receive) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_PROMOTED_MASK</span>		(TH_SFLAG_PROMOTED | TH_SFLAG_RW_PROMOTED | TH_SFLAG_WAITQ_PROMOTED)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TH_SFLAG_RW_PROMOTED_BIT</span>	(10)	<span class="enscript-comment">/* 0x400 */</span>

	int16_t                         sched_pri;              <span class="enscript-comment">/* scheduled (current) priority */</span>
	int16_t                         base_pri;               <span class="enscript-comment">/* base priority */</span>
	int16_t                         max_priority;           <span class="enscript-comment">/* copy of max base priority */</span>
	int16_t                         task_priority;          <span class="enscript-comment">/* copy of task base priority */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_SCHED_GRRR</span>)
#<span class="enscript-reference">if</span> 0
	uint16_t			grrr_deficit;		<span class="enscript-comment">/* fixed point (1/1000th quantum) fractional deficit */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
	
	int16_t				promotions;			<span class="enscript-comment">/* level of promotion */</span>
	int16_t				pending_promoter_index;
	uint32_t			ref_count;		<span class="enscript-comment">/* number of references to me */</span>
	<span class="enscript-type">void</span>				*pending_promoter[2];

	uint32_t			rwlock_count;	<span class="enscript-comment">/* Number of lck_rw_t locks held by thread */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	uint32_t			SHARE_COUNT, BG_COUNT; <span class="enscript-comment">/* This thread's contribution to global sched counters (temporary debugging) */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT */</span>

	integer_t			importance;			<span class="enscript-comment">/* task-relative importance */</span>
	uint32_t                        was_promoted_on_wakeup;

	<span class="enscript-comment">/* Priority depression expiration */</span>
	integer_t			depress_timer_active;
	timer_call_data_t	depress_timer;
										<span class="enscript-comment">/* real-time parameters */</span>
	<span class="enscript-type">struct</span> {								<span class="enscript-comment">/* see mach/thread_policy.h */</span>
		uint32_t			period;
		uint32_t			computation;
		uint32_t			constraint;
		boolean_t			preemptible;
		uint64_t			deadline;
	}					realtime;

	uint64_t			last_run_time;		<span class="enscript-comment">/* time when thread was switched away from */</span>
	uint64_t			last_made_runnable_time;	<span class="enscript-comment">/* time when thread was unblocked or preempted */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_SCHED_MULTIQ</span>)
	sched_group_t			sched_group;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(CONFIG_SCHED_MULTIQ) */</span>

  <span class="enscript-comment">/* Data used during setrun/dispatch */</span>
	timer_data_t		system_timer;		<span class="enscript-comment">/* system mode timer */</span>
	processor_t			bound_processor;	<span class="enscript-comment">/* bound to a processor? */</span>
	processor_t			last_processor;		<span class="enscript-comment">/* processor last dispatched on */</span>
	processor_t			chosen_processor;	<span class="enscript-comment">/* Where we want to run this thread */</span>

	<span class="enscript-comment">/* Fail-safe computation since last unblock or qualifying yield */</span>
	uint64_t			computation_metered;
	uint64_t			computation_epoch;
	uint64_t			safe_release;	<span class="enscript-comment">/* when to release fail-safe */</span>

	<span class="enscript-comment">/* Call out from scheduler */</span>
	<span class="enscript-type">void</span>				(*sched_call)(
							<span class="enscript-type">int</span>			type,
							thread_t	thread);
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_SCHED_PROTO</span>)
	uint32_t			runqueue_generation;	<span class="enscript-comment">/* last time runqueue was drained */</span>
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-comment">/* Statistics and timesharing calculations */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_SCHED_TIMESHARE_CORE</span>)
	natural_t			sched_stamp;	<span class="enscript-comment">/* last scheduler tick */</span>
	natural_t			sched_usage;	<span class="enscript-comment">/* timesharing cpu usage [sched] */</span>
	natural_t			pri_shift;		<span class="enscript-comment">/* usage -&gt; priority from pset */</span>
	natural_t			cpu_usage;		<span class="enscript-comment">/* instrumented cpu usage [%cpu] */</span>
	natural_t			cpu_delta;		<span class="enscript-comment">/* accumulated cpu_usage delta */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_SCHED_TIMESHARE_CORE */</span>

	uint32_t			c_switch;		<span class="enscript-comment">/* total context switches */</span>
	uint32_t			p_switch;		<span class="enscript-comment">/* total processor switches */</span>
	uint32_t			ps_switch;		<span class="enscript-comment">/* total pset switches */</span>

	integer_t mutex_count;  <span class="enscript-comment">/* total count of locks held */</span>
	<span class="enscript-comment">/* Timing data structures */</span>
	<span class="enscript-type">int</span>					precise_user_kernel_time; <span class="enscript-comment">/* precise user/kernel enabled for this thread */</span>
	timer_data_t		user_timer;			<span class="enscript-comment">/* user mode timer */</span>
	uint64_t			user_timer_save;	<span class="enscript-comment">/* saved user timer value */</span>
	uint64_t			system_timer_save;	<span class="enscript-comment">/* saved system timer value */</span>
	uint64_t			vtimer_user_save;	<span class="enscript-comment">/* saved values for vtimers */</span>
	uint64_t			vtimer_prof_save;
	uint64_t			vtimer_rlim_save;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SCHED_SFI</span>
	<span class="enscript-comment">/* Timing for wait state */</span>
	uint64_t		wait_sfi_begin_time;    <span class="enscript-comment">/* start time for thread waiting in SFI */</span>
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Timed wait expiration */</span>
	timer_call_data_t	wait_timer;
	integer_t			wait_timer_active;
	boolean_t			wait_timer_is_set;


	<span class="enscript-comment">/*
	 * Processor/cache affinity
	 * - affinity_threads links task threads with the same affinity set
	 */</span>
	affinity_set_t			affinity_set;
	queue_chain_t			affinity_threads;

	<span class="enscript-comment">/* Various bits of stashed state */</span>
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
		  	mach_msg_return_t	state;		<span class="enscript-comment">/* receive state */</span>
			mach_port_seqno_t	seqno;		<span class="enscript-comment">/* seqno of recvd message */</span>
		  	ipc_object_t		object;		<span class="enscript-comment">/* object received on */</span>
		  	mach_vm_address_t	msg_addr;	<span class="enscript-comment">/* receive buffer pointer */</span>
			mach_msg_size_t		msize;		<span class="enscript-comment">/* max size for recvd msg */</span>
		  	mach_msg_option_t	option;		<span class="enscript-comment">/* options for receive */</span>
			mach_port_name_t	receiver_name;	<span class="enscript-comment">/* the receive port name */</span>
			<span class="enscript-type">struct</span> ipc_kmsg		*kmsg;		<span class="enscript-comment">/* received message */</span>
			mach_msg_continue_t	continuation;
		} receive;
		<span class="enscript-type">struct</span> {
			<span class="enscript-type">struct</span> semaphore	*waitsemaphore;  	<span class="enscript-comment">/* semaphore ref */</span>
			<span class="enscript-type">struct</span> semaphore	*signalsemaphore;	<span class="enscript-comment">/* semaphore ref */</span>
			<span class="enscript-type">int</span>					options;			<span class="enscript-comment">/* semaphore options */</span>
			kern_return_t		result;				<span class="enscript-comment">/* primary result */</span>
			mach_msg_continue_t continuation;
		} sema;
	  	<span class="enscript-type">struct</span> {
			<span class="enscript-type">int</span>					option;		<span class="enscript-comment">/* switch option */</span>
			boolean_t				reenable_workq_callback;	<span class="enscript-comment">/* on entry, callbacks were suspended */</span>
		} swtch;
		<span class="enscript-type">int</span>						misc;		<span class="enscript-comment">/* catch-all for other state */</span>
	} saved;

	<span class="enscript-comment">/* Structure to save information about guard exception */</span>
	<span class="enscript-type">struct</span> {
		<span class="enscript-type">unsigned</span>				type;		<span class="enscript-comment">/* EXC_GUARD reason/type */</span>
		mach_exception_data_type_t		code;		<span class="enscript-comment">/* Exception code */</span>
		mach_exception_data_type_t		subcode;	<span class="enscript-comment">/* Exception sub-code */</span>
	} guard_exc_info;

	<span class="enscript-comment">/* Kernel holds on this thread  */</span>
	int16_t                                         suspend_count;
	<span class="enscript-comment">/* User level suspensions */</span>
	int16_t                                         user_stop_count;

	<span class="enscript-comment">/* IPC data structures */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	natural_t ith_assertions;			<span class="enscript-comment">/* assertions pending drop */</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> ipc_kmsg_queue ith_messages;		<span class="enscript-comment">/* messages to reap */</span>
	mach_port_t ith_rpc_reply;			<span class="enscript-comment">/* reply port for kernel RPCs */</span>

	<span class="enscript-comment">/* Ast/Halt data structures */</span>
	vm_offset_t					recover;		<span class="enscript-comment">/* page fault recover(copyin/out) */</span>

	queue_chain_t				threads;		<span class="enscript-comment">/* global list of all threads */</span>

	<span class="enscript-comment">/* Activation */</span>
		queue_chain_t			task_threads;

		<span class="enscript-comment">/* Task membership */</span>
		<span class="enscript-type">struct</span> task				*task;
		vm_map_t				map;

		decl_lck_mtx_data(,mutex)


		<span class="enscript-comment">/* Pending thread ast(s) */</span>
		ast_t					ast;

		<span class="enscript-comment">/* Miscellaneous bits guarded by mutex */</span>
		uint32_t
			<span class="enscript-reference">active</span>:1,				<span class="enscript-comment">/* Thread is active and has not been terminated */</span>
			<span class="enscript-reference">started</span>:1,				<span class="enscript-comment">/* Thread has been started after creation */</span>
			<span class="enscript-reference">static_param</span>:1,			<span class="enscript-comment">/* Disallow policy parameter changes */</span>
		 	<span class="enscript-reference">inspection</span>:1,				<span class="enscript-comment">/* TRUE when task is being inspected by crash reporter */</span>
			<span class="enscript-reference">policy_reset</span>:1,			<span class="enscript-comment">/* Disallow policy parameter changes on terminating threads */</span>
			:0;
	
		<span class="enscript-comment">/* Ports associated with this thread */</span>
		<span class="enscript-type">struct</span> ipc_port			*ith_self;		<span class="enscript-comment">/* not a right, doesn't hold ref */</span>
		<span class="enscript-type">struct</span> ipc_port			*ith_sself;		<span class="enscript-comment">/* a send right */</span>
		<span class="enscript-type">struct</span> exception_action	*exc_actions;

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">MACH_BSD</span>
		<span class="enscript-type">void</span>					*uthread;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		uint32_t t_dtrace_flags;	<span class="enscript-comment">/* DTrace thread states */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TH_DTRACE_EXECSUCCESS</span>	0x01
		uint32_t t_dtrace_predcache;<span class="enscript-comment">/* DTrace per thread predicate value hint */</span>
		int64_t t_dtrace_tracing;       <span class="enscript-comment">/* Thread time under dtrace_probe() */</span>
		int64_t t_dtrace_vtime;
#<span class="enscript-reference">endif</span>

	        clock_sec_t t_page_creation_time;
	        uint32_t    t_page_creation_count;
	        uint32_t    t_page_creation_throttled;
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
	        uint64_t    t_page_creation_throttled_hard;
	        uint64_t    t_page_creation_throttled_soft;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">T_CHUD_MARKED</span>           0x01          <span class="enscript-comment">/* this thread is marked by CHUD */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">T_IN_CHUD</span>               0x02          <span class="enscript-comment">/* this thread is already in a CHUD handler */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">THREAD_PMC_FLAG</span>         0x04          <span class="enscript-comment">/* Bit in &quot;t_chud&quot; signifying PMC interest */</span>	
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">T_AST_CALLSTACK</span>         0x08          <span class="enscript-comment">/* Thread scheduled to dump a
					       * callstack on its next
					       * AST */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">T_AST_NAME</span>              0x10          <span class="enscript-comment">/* Thread scheduled to dump
					       * its name on its next
					       * AST */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">T_NAME_DONE</span>             0x20          <span class="enscript-comment">/* Thread has previously
					       * recorded its name */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">T_KPC_ALLOC</span>             0x40          <span class="enscript-comment">/* Thread needs a kpc_buf */</span>

		uint32_t t_chud;	<span class="enscript-comment">/* CHUD flags, used for Shark */</span>
		uint32_t chud_c_switch; <span class="enscript-comment">/* last dispatch detection */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KPC</span>
	<span class="enscript-comment">/* accumulated performance counters for this thread */</span>
	uint64_t *kpc_buf;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KPERF</span>
	<span class="enscript-comment">/* count of how many times a thread has been sampled since it was last scheduled */</span>
	uint64_t kperf_pet_cnt;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HYPERVISOR</span>
	<span class="enscript-comment">/* hypervisor virtual CPU object associated with this thread */</span>
	<span class="enscript-type">void</span> *hv_thread_target;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HYPERVISOR */</span>

		uint64_t thread_id;	<span class="enscript-comment">/*system wide unique thread-id*/</span>

	<span class="enscript-comment">/* Statistics accumulated per-thread and aggregated per-task */</span>
	uint32_t		syscalls_unix;
	uint32_t		syscalls_mach;
	ledger_t		t_ledger;
	ledger_t		t_threadledger;	<span class="enscript-comment">/* per thread ledger */</span>
	uint64_t 		cpu_time_last_qos;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_BANK</span>
	ledger_t		t_bankledger;  		   <span class="enscript-comment">/* ledger to charge someone */</span>
	uint64_t		t_deduct_bank_ledger_time; <span class="enscript-comment">/* cpu time to be deducted from bank ledger */</span>
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* policy is protected by the task lock */</span>
	<span class="enscript-type">struct</span> task_requested_policy     requested_policy;
	<span class="enscript-type">struct</span> task_effective_policy     effective_policy;
	<span class="enscript-type">struct</span> task_pended_policy        pended_policy;

	<span class="enscript-comment">/* usynch override is protected by the task lock, eventually will be thread mutex */</span>
	<span class="enscript-type">struct</span> thread_qos_override {
		<span class="enscript-type">struct</span> thread_qos_override	*override_next;
		uint32_t	override_contended_resource_count;
		int16_t		override_qos;
		int16_t		override_resource_type;
		user_addr_t	override_resource;
	} *overrides;

	<span class="enscript-type">int</span>	iotier_override; <span class="enscript-comment">/* atomic operations to set, cleared on ret to user */</span>
	integer_t               saved_importance;               <span class="enscript-comment">/* saved task-relative importance */</span>
	io_stat_info_t  		thread_io_stats; <span class="enscript-comment">/* per-thread I/O statistics */</span>


	uint32_t			thread_callout_interrupt_wakeups;
	uint32_t			thread_callout_platform_idle_wakeups;
	uint32_t			thread_timer_wakeups_bin_1;
	uint32_t			thread_timer_wakeups_bin_2;
	uint16_t			thread_tag;
	uint16_t			callout_woken_from_icontext:1,
					<span class="enscript-reference">callout_woken_from_platform_idle</span>:1,
					<span class="enscript-reference">callout_woke_thread</span>:1,
					<span class="enscript-reference">thread_bitfield_unused</span>:13;

	mach_port_name_t		ith_voucher_name;
	ipc_voucher_t			ith_voucher;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
	<span class="enscript-type">void</span> 				*decmp_upl;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IOSCHED */</span>

	<span class="enscript-comment">/* work interval ID (if any) associated with the thread. Uses thread mutex */</span>
	uint64_t		work_interval_id;

	<span class="enscript-comment">/*** Machine-dependent state ***/</span>
	<span class="enscript-type">struct</span> machine_thread   machine;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ith_state</span>		saved.receive.state
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ith_object</span>		saved.receive.object
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ith_msg_addr</span>			saved.receive.msg_addr
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ith_msize</span>		saved.receive.msize
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ith_option</span>		saved.receive.option
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ith_receiver_name</span>	saved.receive.receiver_name
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ith_continuation</span>	saved.receive.continuation
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ith_kmsg</span>		saved.receive.kmsg
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ith_seqno</span>		saved.receive.seqno

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">sth_waitsemaphore</span>	saved.sema.waitsemaphore
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">sth_signalsemaphore</span>	saved.sema.signalsemaphore
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">sth_options</span>		saved.sema.options
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">sth_result</span>		saved.sema.result
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">sth_continuation</span>	saved.sema.continuation

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_bootstrap(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_init(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_daemon_init(<span class="enscript-type">void</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">thread_reference_internal</span>(thread)	\
			(<span class="enscript-type">void</span>)hw_atomic_add(&amp;(thread)-&gt;ref_count, 1)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">thread_reference</span>(thread)					\
MACRO_BEGIN											\
	<span class="enscript-keyword">if</span> ((thread) != THREAD_NULL)					\
		thread_reference_internal(thread);		\
MACRO_END

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_deallocate(
						thread_t		thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_deallocate_safe(
						thread_t		thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_terminate_self(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> kern_return_t	thread_terminate_internal(
							thread_t		thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_start_internal(
							thread_t			thread) __attribute__ ((noinline));

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_terminate_enqueue(
						thread_t		thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_terminate_crashed_threads(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_stack_enqueue(
						thread_t		thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_hold(
						thread_t	thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_release(
						thread_t	thread);

<span class="enscript-comment">/* Locking for scheduler state, always acquired with interrupts disabled (splsched()) */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__SMP__</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">thread_lock_init</span>(th)	simple_lock_init(&amp;(th)-&gt;sched_lock, 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">thread_lock</span>(th)			simple_lock(&amp;(th)-&gt;sched_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">thread_unlock</span>(th)		simple_unlock(&amp;(th)-&gt;sched_lock)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">wake_lock_init</span>(th)		simple_lock_init(&amp;(th)-&gt;wake_lock, 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">wake_lock</span>(th)			simple_lock(&amp;(th)-&gt;wake_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">wake_unlock</span>(th)			simple_unlock(&amp;(th)-&gt;wake_lock)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">thread_lock_init</span>(th)	do { (void)th; } while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">thread_lock</span>(th)			do { (void)th; } while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">thread_unlock</span>(th)		do { (void)th; } while(0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">wake_lock_init</span>(th)		do { (void)th; } while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">wake_lock</span>(th)			do { (void)th; } while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">wake_unlock</span>(th)			do { (void)th; } while(0)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">thread_should_halt_fast</span>(thread)		(!(thread)-&gt;active)

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>				stack_alloc(
							thread_t		thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			stack_handoff(
					      		thread_t		from,
							thread_t		to);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>				stack_free(
							thread_t		thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>				stack_free_reserved(
							thread_t		thread);

<span class="enscript-type">extern</span> boolean_t		stack_alloc_try(
							thread_t	    thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>				stack_collect(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>				stack_init(<span class="enscript-type">void</span>);


<span class="enscript-type">extern</span> kern_return_t	thread_info_internal(
							thread_t				thread,
							thread_flavor_t			flavor,
							thread_info_t			thread_info_out,
							mach_msg_type_number_t	*thread_info_count);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>				thread_task_priority(
							thread_t		thread,
							integer_t		priority,
							integer_t		max_priority);

<span class="enscript-type">extern</span> kern_return_t                    <span class="enscript-function-name">thread_set_mode_and_absolute_pri</span>(
                                                        thread_t       thread,
                                                        integer_t      policy,
                                                        integer_t      priority);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>				thread_policy_reset(
							thread_t		thread);

<span class="enscript-type">extern</span> kern_return_t	kernel_thread_create(
							thread_continue_t	continuation,
							<span class="enscript-type">void</span>				*parameter,
							integer_t			priority,
							thread_t			*new_thread);

<span class="enscript-type">extern</span> kern_return_t	kernel_thread_start_priority(
							thread_continue_t	continuation,
							<span class="enscript-type">void</span>				*parameter,
							integer_t			priority,
							thread_t			*new_thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>				machine_stack_attach(
							thread_t		thread,
							vm_offset_t		stack);

<span class="enscript-type">extern</span> vm_offset_t		machine_stack_detach(
							thread_t		thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>				machine_stack_handoff(
							thread_t		old,
							thread_t		new);

<span class="enscript-type">extern</span> thread_t			machine_switch_context(
							thread_t			old_thread,
							thread_continue_t	continuation,
							thread_t			new_thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>				machine_load_context(
							thread_t		thread);

<span class="enscript-type">extern</span> kern_return_t	machine_thread_state_initialize(
							thread_t				thread);

<span class="enscript-type">extern</span> kern_return_t	machine_thread_neon_state_initialize(
							thread_t				thread);

<span class="enscript-type">extern</span> kern_return_t	machine_thread_set_state(
							thread_t				thread,
							thread_flavor_t			flavor,
							thread_state_t			state,
							mach_msg_type_number_t	count);

<span class="enscript-type">extern</span> kern_return_t	machine_thread_get_state(
							thread_t				thread,
							thread_flavor_t			flavor,
							thread_state_t			state,
							mach_msg_type_number_t	*count);

<span class="enscript-type">extern</span> kern_return_t	machine_thread_dup(
							thread_t		self,
							thread_t		target);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>				machine_thread_init(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> kern_return_t	machine_thread_create(
							thread_t		thread,
							task_t			task);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		machine_thread_switch_addrmode(
						       thread_t			thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> 		    machine_thread_destroy(
							thread_t		thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>				machine_set_current_thread(
							thread_t			thread);

<span class="enscript-type">extern</span> kern_return_t	machine_thread_get_kern_state(
							thread_t				thread,
							thread_flavor_t			flavor,
							thread_state_t			tstate,
							mach_msg_type_number_t	*count);

<span class="enscript-type">extern</span> kern_return_t	machine_thread_inherit_taskwide(
							thread_t		thread,
							task_t			parent_task);

<span class="enscript-type">extern</span> kern_return_t	machine_thread_set_tsd_base(
							thread_t				thread,
							mach_vm_offset_t		tsd_base);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">thread_mtx_lock</span>(thread)			lck_mtx_lock(&amp;(thread)-&gt;mutex)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">thread_mtx_try</span>(thread)			lck_mtx_try_lock(&amp;(thread)-&gt;mutex)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">thread_mtx_unlock</span>(thread)		lck_mtx_unlock(&amp;(thread)-&gt;mutex)

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			install_special_handler(
						thread_t		thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			special_handler(
						thread_t		thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">thread_update_qos_cpu_time</span>(
			thread_t thread,
			boolean_t lock_needed);

<span class="enscript-type">void</span> <span class="enscript-function-name">act_machine_sv_free</span>(thread_t, <span class="enscript-type">int</span>);

vm_offset_t			min_valid_stack_address(<span class="enscript-type">void</span>);
vm_offset_t			max_valid_stack_address(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> inline uint16_t	thread_set_tag_internal(thread_t	thread, uint16_t tag) {
	<span class="enscript-keyword">return</span> __sync_fetch_and_or(&amp;thread-&gt;thread_tag, tag);
}

<span class="enscript-type">static</span> inline uint16_t	thread_get_tag_internal(thread_t	thread) {
	<span class="enscript-keyword">return</span> thread-&gt;thread_tag;
}

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	<span class="enscript-type">int</span>             qos_pri[THREAD_QOS_LAST];
	<span class="enscript-type">int</span>             qos_iotier[THREAD_QOS_LAST];
	uint32_t        qos_through_qos[THREAD_QOS_LAST];
	uint32_t        qos_latency_qos[THREAD_QOS_LAST];
} qos_policy_params_t;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">thread_set_options</span>(uint32_t thopt);

#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* MACH_KERNEL_PRIVATE */</span>

__BEGIN_DECLS

<span class="enscript-type">extern</span> thread_t		current_thread(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_reference(
						thread_t	thread);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_deallocate(
						thread_t	thread);

__END_DECLS

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_KERNEL_PRIVATE */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">KERNEL_PRIVATE</span>

__BEGIN_DECLS

<span class="enscript-type">extern</span> uint64_t	 		thread_dispatchqaddr(
						thread_t thread);

__END_DECLS

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KERNEL_PRIVATE */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
__BEGIN_DECLS

<span class="enscript-type">extern</span> uint64_t	 		thread_tid(thread_t thread);

__END_DECLS

#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* KERNEL */</span>

__BEGIN_DECLS

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>

<span class="enscript-comment">/*
 * Thread tags; for easy identification.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">THREAD_TAG_MAINTHREAD</span> 0x1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">THREAD_TAG_CALLOUT</span> 0x2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">THREAD_TAG_IOWORKLOOP</span> 0x4

uint16_t	thread_set_tag(thread_t, uint16_t);
uint16_t	thread_get_tag(thread_t);

<span class="enscript-comment">/*
 * Allocate/assign a single work interval ID for a thread,
 * and support deallocating it.
 */</span>
<span class="enscript-type">extern</span> kern_return_t			thread_policy_create_work_interval(
	thread_t		thread,
	uint64_t		*work_interval_id);

<span class="enscript-type">extern</span> kern_return_t			thread_policy_destroy_work_interval(
	thread_t		thread,
	uint64_t		work_interval_id);

<span class="enscript-type">extern</span> kern_return_t    <span class="enscript-function-name">thread_state_initialize</span>(
							thread_t				thread);

<span class="enscript-type">extern</span> kern_return_t	thread_setstatus(
							thread_t				thread,
							<span class="enscript-type">int</span>						flavor,
							thread_state_t			tstate,
							mach_msg_type_number_t	count);

<span class="enscript-type">extern</span> kern_return_t	thread_getstatus(
							thread_t				thread,
							<span class="enscript-type">int</span>						flavor,
							thread_state_t			tstate,
							mach_msg_type_number_t	*count);

<span class="enscript-type">extern</span> kern_return_t	thread_create_with_continuation(
							task_t task,
							thread_t *new_thread,
							thread_continue_t continuation);

<span class="enscript-type">extern</span> kern_return_t	thread_create_workq(
							task_t			task,
							thread_continue_t	thread_return,
							thread_t		*new_thread);

<span class="enscript-type">extern</span>	<span class="enscript-type">void</span>	thread_yield_internal(
	mach_msg_timeout_t	interval);

<span class="enscript-comment">/*
 * Thread-private CPU limits: apply a private CPU limit to this thread only. Available actions are:
 * 
 * 1) Block. Prevent CPU consumption of the thread from exceeding the limit.
 * 2) Exception. Generate a resource consumption exception when the limit is exceeded.
 * 3) Disable. Remove any existing CPU limit.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">THREAD_CPULIMIT_BLOCK</span>		0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">THREAD_CPULIMIT_EXCEPTION</span>	0x2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">THREAD_CPULIMIT_DISABLE</span>		0x3

<span class="enscript-type">struct</span> _thread_ledger_indices {
	<span class="enscript-type">int</span> cpu_time;
};

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> _thread_ledger_indices thread_ledgers;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">thread_get_cpulimit</span>(<span class="enscript-type">int</span> *action, uint8_t *percentage, uint64_t *interval_ns);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">thread_set_cpulimit</span>(<span class="enscript-type">int</span> action, uint8_t percentage, uint64_t interval_ns);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_read_times(
						thread_t 		thread,
						time_value_t	*user_time,
						time_value_t	*system_time);

<span class="enscript-type">extern</span> uint64_t		thread_get_runtime_self(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_setuserstack(
						thread_t		thread,
						mach_vm_offset_t	user_stack);

<span class="enscript-type">extern</span> uint64_t		thread_adjuserstack(
						thread_t		thread,
						<span class="enscript-type">int</span>				adjust);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>			thread_setentrypoint(
						thread_t		thread,
						mach_vm_offset_t	entry);

<span class="enscript-type">extern</span> kern_return_t	thread_set_tsd_base(
							thread_t	thread,
							mach_vm_offset_t tsd_base);

<span class="enscript-type">extern</span> kern_return_t	thread_setsinglestep(
						thread_t		thread,
						<span class="enscript-type">int</span>			on);

<span class="enscript-type">extern</span> kern_return_t	thread_userstack(
						thread_t,
						<span class="enscript-type">int</span>,
						thread_state_t,
						<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>,
						mach_vm_offset_t *,
						<span class="enscript-type">int</span> *);

<span class="enscript-type">extern</span> kern_return_t	thread_entrypoint(
						thread_t,
						<span class="enscript-type">int</span>,
						thread_state_t,
						<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>,
						mach_vm_offset_t *); 

<span class="enscript-type">extern</span> kern_return_t	thread_userstackdefault(
						thread_t,
						mach_vm_offset_t *);

<span class="enscript-type">extern</span> kern_return_t	thread_wire_internal(
							host_priv_t		host_priv,
							thread_t		thread,
							boolean_t		wired,
							boolean_t		*prev_state);


<span class="enscript-type">extern</span> kern_return_t	thread_dup(thread_t);

<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span>	(*sched_call_t)(
					<span class="enscript-type">int</span>				type,
					thread_t		thread);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SCHED_CALL_BLOCK</span>		0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SCHED_CALL_UNBLOCK</span>		0x2

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		thread_sched_call(
					thread_t		thread,
					sched_call_t	call);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		thread_static_param(
					thread_t		thread,
					boolean_t		state);

<span class="enscript-type">extern</span> boolean_t	thread_is_static_param(
					thread_t		thread);

<span class="enscript-type">extern</span> kern_return_t	thread_policy_set_internal(
	                                thread_t		thread,
					thread_policy_flavor_t	flavor,
					thread_policy_t		policy_info,
					mach_msg_type_number_t	count);

<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">thread_has_qos_policy</span>(thread_t thread);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">thread_remove_qos_policy</span>(thread_t thread);

<span class="enscript-type">extern</span> task_t	get_threadtask(thread_t);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">thread_is_64bit</span>(thd)	\
	task_has_64BitAddr(get_threadtask(thd))


<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		*get_bsdthread_info(thread_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		set_bsdthread_info(thread_t, <span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		*uthread_alloc(task_t, thread_t, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		uthread_cleanup_name(<span class="enscript-type">void</span> *uthread);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		uthread_cleanup(task_t, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, boolean_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		uthread_zone_free(<span class="enscript-type">void</span> *); 
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		uthread_cred_free(<span class="enscript-type">void</span> *);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PROC_REF_DEBUG</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		uthread_get_proc_refcount(<span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		uthread_reset_proc_refcount(<span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		proc_ref_tracking_disabled;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> boolean_t	thread_should_halt(
						thread_t		thread);

<span class="enscript-type">extern</span> boolean_t	thread_should_abort(
						thread_t);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">is_64signalregset</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">act_set_kperf</span>(thread_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">set_astledger</span>(thread_t thread);

<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">dtrace_get_thread_predcache</span>(thread_t);
<span class="enscript-type">extern</span> int64_t <span class="enscript-function-name">dtrace_get_thread_vtime</span>(thread_t);
<span class="enscript-type">extern</span> int64_t <span class="enscript-function-name">dtrace_get_thread_tracing</span>(thread_t);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">dtrace_get_thread_reentering</span>(thread_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_get_thread_last_cpu_id</span>(thread_t);
<span class="enscript-type">extern</span> vm_offset_t <span class="enscript-function-name">dtrace_get_kernel_stack</span>(thread_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_set_thread_predcache</span>(thread_t, uint32_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_set_thread_vtime</span>(thread_t, int64_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_set_thread_tracing</span>(thread_t, int64_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_set_thread_reentering</span>(thread_t, boolean_t);
<span class="enscript-type">extern</span> vm_offset_t <span class="enscript-function-name">dtrace_set_thread_recover</span>(thread_t, vm_offset_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_thread_bootstrap</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_thread_didexec</span>(thread_t);

<span class="enscript-type">extern</span> int64_t <span class="enscript-function-name">dtrace_calc_thread_recent_vtime</span>(thread_t);


<span class="enscript-type">extern</span> kern_return_t	thread_set_wq_state32(
					      thread_t          thread,
					      thread_state_t    tstate);

<span class="enscript-type">extern</span> kern_return_t	thread_set_wq_state64(
					      thread_t          thread,
					      thread_state_t    tstate);

<span class="enscript-type">extern</span> vm_offset_t	kernel_stack_mask;
<span class="enscript-type">extern</span> vm_offset_t	kernel_stack_size;
<span class="enscript-type">extern</span> vm_offset_t	kernel_stack_depth_max;

<span class="enscript-type">void</span> <span class="enscript-function-name">guard_ast</span>(thread_t thread);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">fd_guard_ast</span>(thread_t thread);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mach_port_guard_ast</span>(thread_t thread);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">thread_guard_violation</span>(thread_t thread, <span class="enscript-type">unsigned</span> type);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">thread_update_io_stats</span>(thread_t thread, <span class="enscript-type">int</span> size, <span class="enscript-type">int</span> io_flags);

<span class="enscript-type">extern</span> kern_return_t	thread_set_voucher_name(mach_port_name_t name);
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">thread_get_current_voucher_origin_pid</span>(int32_t *pid);

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>


<span class="enscript-comment">/*! @function kernel_thread_start
    @abstract Create a kernel thread.
    @discussion This function takes three input parameters, namely reference to the function that the thread should execute, caller specified data and a reference which is used to return the newly created kernel thread. The function returns KERN_SUCCESS on success or an appropriate kernel code type indicating the error. It may be noted that the caller is responsible for explicitly releasing the reference to the created thread when no longer needed. This should be done by calling thread_deallocate(new_thread).
    @param continuation A C-function pointer where the thread will begin execution.
    @param parameter Caller specified data to be passed to the new thread.
    @param new_thread Reference to the new thread is returned in this parameter.
    @result Returns KERN_SUCCESS on success or an appropriate kernel code type.
*/</span>

<span class="enscript-type">extern</span> kern_return_t	kernel_thread_start(
							thread_continue_t	continuation,
							<span class="enscript-type">void</span>				*parameter,
							thread_t			*new_thread);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">thread_set_eager_preempt</span>(thread_t thread);
<span class="enscript-type">void</span> <span class="enscript-function-name">thread_clear_eager_preempt</span>(thread_t thread);
<span class="enscript-type">extern</span> ipc_port_t <span class="enscript-function-name">convert_thread_to_port</span>(thread_t);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">set_vm_privilege</span>(boolean_t);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>

__END_DECLS

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* _KERN_THREAD_H_ */</span>
</pre>
<hr />
</body></html>