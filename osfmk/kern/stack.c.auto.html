<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>stack.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">stack.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 *	Kernel stack management routines.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/processor_set.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ledger.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug.h&gt;</span>

<span class="enscript-comment">/*
 *	We allocate stacks from generic kernel VM.
 *
 *	The stack_free_list can only be accessed at splsched,
 *	because stack_alloc_try/thread_invoke operate at splsched.
 */</span>

<span class="enscript-function-name">decl_simple_lock_data</span>(<span class="enscript-type">static</span>,stack_lock_data)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">stack_lock</span>()		simple_lock(&amp;stack_lock_data)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">stack_unlock</span>()		simple_unlock(&amp;stack_lock_data)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">STACK_CACHE_SIZE</span>	2

<span class="enscript-type">static</span> vm_offset_t		stack_free_list;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		stack_free_count, stack_free_hiwat;		<span class="enscript-comment">/* free list count */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		stack_hiwat;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			stack_total;				<span class="enscript-comment">/* current total count */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>		stack_allocs;				<span class="enscript-comment">/* total count of allocations */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>			stack_fake_zone_index = -1;	<span class="enscript-comment">/* index in zone_info array */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		stack_free_target;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>				stack_free_delta;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		stack_new_count;						<span class="enscript-comment">/* total new stack allocations */</span>

<span class="enscript-type">static</span> vm_offset_t		stack_addr_mask;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			kernel_stack_pages;
vm_offset_t			kernel_stack_size;
vm_offset_t			kernel_stack_mask;
vm_offset_t			kernel_stack_depth_max;

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">STACK_ZINFO_PALLOC</span>(thread_t thread)
{
	task_t task;
	zinfo_usage_t zinfo;

	ledger_credit(thread-&gt;t_ledger, task_ledgers.tkm_private, kernel_stack_size);

	<span class="enscript-keyword">if</span> (stack_fake_zone_index != -1 &amp;&amp;
	    (task = thread-&gt;task) != NULL &amp;&amp; (zinfo = task-&gt;tkm_zinfo) != NULL)
		OSAddAtomic64(kernel_stack_size,
			      (int64_t *)&amp;zinfo[stack_fake_zone_index].alloc);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">STACK_ZINFO_PFREE</span>(thread_t thread)
{
	task_t task;
	zinfo_usage_t zinfo;

	ledger_debit(thread-&gt;t_ledger, task_ledgers.tkm_private, kernel_stack_size);

	<span class="enscript-keyword">if</span> (stack_fake_zone_index != -1 &amp;&amp;
	    (task = thread-&gt;task) != NULL &amp;&amp; (zinfo = task-&gt;tkm_zinfo) != NULL)
		OSAddAtomic64(kernel_stack_size, 
			      (int64_t *)&amp;zinfo[stack_fake_zone_index].free);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">STACK_ZINFO_HANDOFF</span>(thread_t from, thread_t to)
{
	ledger_debit(from-&gt;t_ledger, task_ledgers.tkm_private, kernel_stack_size);
	ledger_credit(to-&gt;t_ledger, task_ledgers.tkm_private, kernel_stack_size);

	<span class="enscript-keyword">if</span> (stack_fake_zone_index != -1) {
		task_t task;
		zinfo_usage_t zinfo;
	
		<span class="enscript-keyword">if</span> ((task = from-&gt;task) != NULL &amp;&amp; (zinfo = task-&gt;tkm_zinfo) != NULL)
			OSAddAtomic64(kernel_stack_size, 
				      (int64_t *)&amp;zinfo[stack_fake_zone_index].free);

		<span class="enscript-keyword">if</span> ((task = to-&gt;task) != NULL &amp;&amp; (zinfo = task-&gt;tkm_zinfo) != NULL)
			OSAddAtomic64(kernel_stack_size, 
				      (int64_t *)&amp;zinfo[stack_fake_zone_index].alloc);
	}
}

<span class="enscript-comment">/*
 *	The next field is at the base of the stack,
 *	so the low end is left unsullied.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">stack_next</span>(stack)	\
	(*((vm_offset_t *)((stack) + kernel_stack_size) - 1))

<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">log2</span>(vm_offset_t size)
{
	<span class="enscript-type">int</span>	result;
	<span class="enscript-keyword">for</span> (result = 0; size &gt; 0; result++)
		size &gt;&gt;= 1;
	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> inline vm_offset_t
<span class="enscript-function-name">roundup_pow2</span>(vm_offset_t size)
{
	<span class="enscript-keyword">return</span> 1UL &lt;&lt; (log2(size - 1) + 1); 
}

<span class="enscript-type">static</span> vm_offset_t <span class="enscript-function-name">stack_alloc_internal</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">stack_free_stack</span>(vm_offset_t);

<span class="enscript-type">void</span>
<span class="enscript-function-name">stack_init</span>(<span class="enscript-type">void</span>)
{
	simple_lock_init(&amp;stack_lock_data, 0);
	
	kernel_stack_pages = KERNEL_STACK_SIZE / PAGE_SIZE;
	kernel_stack_size = KERNEL_STACK_SIZE;
	kernel_stack_mask = -KERNEL_STACK_SIZE;
	kernel_stack_depth_max = 0;

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;kernel_stack_pages&quot;</span>,
			       &amp;kernel_stack_pages,
			       <span class="enscript-keyword">sizeof</span> (kernel_stack_pages))) {
		kernel_stack_size = kernel_stack_pages * PAGE_SIZE;
		printf(<span class="enscript-string">&quot;stack_init: kernel_stack_pages=%d kernel_stack_size=%p\n&quot;</span>,
			kernel_stack_pages, (<span class="enscript-type">void</span> *) kernel_stack_size);
	}

	<span class="enscript-keyword">if</span> (kernel_stack_size &lt; round_page(kernel_stack_size))
		panic(<span class="enscript-string">&quot;stack_init: stack size %p not a multiple of page size %d\n&quot;</span>,
			(<span class="enscript-type">void</span> *) kernel_stack_size, PAGE_SIZE);
	
	stack_addr_mask = roundup_pow2(kernel_stack_size) - 1;
	kernel_stack_mask = ~stack_addr_mask;
}

<span class="enscript-comment">/*
 *	stack_alloc:
 *
 *	Allocate a stack for a thread, may
 *	block.
 */</span>

<span class="enscript-type">static</span> vm_offset_t 
<span class="enscript-function-name">stack_alloc_internal</span>(<span class="enscript-type">void</span>)
{
	vm_offset_t		stack;
	spl_t			s;
	<span class="enscript-type">int</span>			guard_flags;

	s = splsched();
	stack_lock();
	stack_allocs++;
	stack = stack_free_list;
	<span class="enscript-keyword">if</span> (stack != 0) {
		stack_free_list = stack_next(stack);
		stack_free_count--;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (++stack_total &gt; stack_hiwat)
			stack_hiwat = stack_total;
		stack_new_count++;
	}
	stack_free_delta--;
	stack_unlock();
	splx(s);
		
	<span class="enscript-keyword">if</span> (stack == 0) {

		<span class="enscript-comment">/*
		 * Request guard pages on either side of the stack.  Ask
		 * kernel_memory_allocate() for two extra pages to account
		 * for these.
		 */</span>

		guard_flags = KMA_GUARD_FIRST | KMA_GUARD_LAST;
		<span class="enscript-keyword">if</span> (kernel_memory_allocate(kernel_map, &amp;stack,
					   kernel_stack_size + (2*PAGE_SIZE),
					   stack_addr_mask,
					   KMA_KSTACK | KMA_KOBJECT | guard_flags,
					   VM_KERN_MEMORY_STACK)
		    != KERN_SUCCESS)
			panic(<span class="enscript-string">&quot;stack_alloc: kernel_memory_allocate&quot;</span>);

		<span class="enscript-comment">/*
		 * The stack address that comes back is the address of the lower
		 * guard page.  Skip past it to get the actual stack base address.
		 */</span>

		stack += PAGE_SIZE;
	}
	<span class="enscript-keyword">return</span> stack;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">stack_alloc</span>(
	thread_t	thread)
{

	assert(thread-&gt;kernel_stack == 0);
	machine_stack_attach(thread, stack_alloc_internal());
	STACK_ZINFO_PALLOC(thread);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">stack_handoff</span>(thread_t from, thread_t to)
{
	assert(from == current_thread());
	machine_stack_handoff(from, to);
	STACK_ZINFO_HANDOFF(from, to);
}

<span class="enscript-comment">/*
 *	stack_free:
 *
 *	Detach and free the stack for a thread.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">stack_free</span>(
	thread_t	thread)
{
    vm_offset_t		stack = machine_stack_detach(thread);

	assert(stack);
	<span class="enscript-keyword">if</span> (stack != thread-&gt;reserved_stack) {
		STACK_ZINFO_PFREE(thread);
		stack_free_stack(stack);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">stack_free_reserved</span>(
	thread_t	thread)
{
	<span class="enscript-keyword">if</span> (thread-&gt;reserved_stack != thread-&gt;kernel_stack) {
		stack_free_stack(thread-&gt;reserved_stack);
		STACK_ZINFO_PFREE(thread);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">stack_free_stack</span>(
	vm_offset_t		stack)
{
	<span class="enscript-type">struct</span> stack_cache	*cache;
	spl_t				s;

	s = splsched();
	cache = &amp;PROCESSOR_DATA(current_processor(), stack_cache);
	<span class="enscript-keyword">if</span> (cache-&gt;count &lt; STACK_CACHE_SIZE) {
		stack_next(stack) = cache-&gt;free;
		cache-&gt;free = stack;
		cache-&gt;count++;
	}
	<span class="enscript-keyword">else</span> {
		stack_lock();
		stack_next(stack) = stack_free_list;
		stack_free_list = stack;
		<span class="enscript-keyword">if</span> (++stack_free_count &gt; stack_free_hiwat)
			stack_free_hiwat = stack_free_count;
		stack_free_delta++;
		stack_unlock();
	}
	splx(s);
}

<span class="enscript-comment">/*
 *	stack_alloc_try:
 *
 *	Non-blocking attempt to allocate a
 *	stack for a thread.
 *
 *	Returns TRUE on success.
 *
 *	Called at splsched.
 */</span>
boolean_t
<span class="enscript-function-name">stack_alloc_try</span>(
	thread_t		thread)
{
	<span class="enscript-type">struct</span> stack_cache	*cache;
	vm_offset_t			stack;

	cache = &amp;PROCESSOR_DATA(current_processor(), stack_cache);
	stack = cache-&gt;free;
	<span class="enscript-keyword">if</span> (stack != 0) {
		STACK_ZINFO_PALLOC(thread);
		cache-&gt;free = stack_next(stack);
		cache-&gt;count--;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (stack_free_list != 0) {
			stack_lock();
			stack = stack_free_list;
			<span class="enscript-keyword">if</span> (stack != 0) {
				STACK_ZINFO_PALLOC(thread);
				stack_free_list = stack_next(stack);
				stack_free_count--;
				stack_free_delta--;
			}
			stack_unlock();
		}
	}

	<span class="enscript-keyword">if</span> (stack != 0 || (stack = thread-&gt;reserved_stack) != 0) {
		machine_stack_attach(thread, stack);
		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-keyword">return</span> (FALSE);
}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		stack_collect_tick, last_stack_tick;

<span class="enscript-comment">/*
 *	stack_collect:
 *
 *	Free excess kernel stacks, may
 *	block.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">stack_collect</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (stack_collect_tick != last_stack_tick) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	target;
		vm_offset_t		stack;
		spl_t			s;

		s = splsched();
		stack_lock();

		target = stack_free_target + (STACK_CACHE_SIZE * processor_count);
		target += (stack_free_delta &gt;= 0)? stack_free_delta: -stack_free_delta;

		<span class="enscript-keyword">while</span> (stack_free_count &gt; target) {
			stack = stack_free_list;
			stack_free_list = stack_next(stack);
			stack_free_count--; stack_total--;
			stack_unlock();
			splx(s);

			<span class="enscript-comment">/*
			 * Get the stack base address, then decrement by one page
			 * to account for the lower guard page.  Add two extra pages
			 * to the size to account for the guard pages on both ends
			 * that were originally requested when the stack was allocated
			 * back in stack_alloc().
			 */</span>

			stack = (vm_offset_t)vm_map_trunc_page(
				stack,
				VM_MAP_PAGE_MASK(kernel_map));
			stack -= PAGE_SIZE;
			<span class="enscript-keyword">if</span> (vm_map_remove(
				    kernel_map,
				    stack,
				    stack + kernel_stack_size+(2*PAGE_SIZE),
				    VM_MAP_REMOVE_KUNWIRE)
			    != KERN_SUCCESS)
				panic(<span class="enscript-string">&quot;stack_collect: vm_map_remove&quot;</span>);
			stack = 0;

			s = splsched();
			stack_lock();

			target = stack_free_target + (STACK_CACHE_SIZE * processor_count);
			target += (stack_free_delta &gt;= 0)? stack_free_delta: -stack_free_delta;
		}

		last_stack_tick = stack_collect_tick;

		stack_unlock();
		splx(s);
	}
}

<span class="enscript-comment">/*
 *	compute_stack_target:
 *
 *	Computes a new target free list count
 *	based on recent alloc / free activity.
 *
 *	Limits stack collection to once per
 *	computation period.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">compute_stack_target</span>(
__unused <span class="enscript-type">void</span>		*arg)
{
	spl_t		s;

	s = splsched();
	stack_lock();

	<span class="enscript-keyword">if</span> (stack_free_target &gt; 5)
		stack_free_target = (4 * stack_free_target) / 5;
	<span class="enscript-keyword">else</span>
	<span class="enscript-keyword">if</span> (stack_free_target &gt; 0)
		stack_free_target--;

	stack_free_target += (stack_free_delta &gt;= 0)? stack_free_delta: -stack_free_delta;

	stack_free_delta = 0;
	stack_collect_tick++;

	stack_unlock();
	splx(s);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">stack_fake_zone_init</span>(<span class="enscript-type">int</span> zone_index)
{
	stack_fake_zone_index = zone_index;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">stack_fake_zone_info</span>(<span class="enscript-type">int</span> *count, 
		     vm_size_t *cur_size, vm_size_t *max_size, vm_size_t *elem_size, vm_size_t *alloc_size,
		     uint64_t *sum_size, <span class="enscript-type">int</span> *collectable, <span class="enscript-type">int</span> *exhaustable, <span class="enscript-type">int</span> *caller_acct)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	total, hiwat, free;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> all;
	spl_t			s;

	s = splsched();
	stack_lock();
	all = stack_allocs;
	total = stack_total;
	hiwat = stack_hiwat;
	free = stack_free_count;
	stack_unlock();
	splx(s);

	*count      = total - free;
	*cur_size   = kernel_stack_size * total;
	*max_size   = kernel_stack_size * hiwat;
	*elem_size  = kernel_stack_size;
	*alloc_size = kernel_stack_size;
	*sum_size = all * kernel_stack_size;

	*collectable = 1;
	*exhaustable = 0;
	*caller_acct = 1;
}

<span class="enscript-comment">/* OBSOLETE */</span>
<span class="enscript-type">void</span>	stack_privilege(
			thread_t	thread);

<span class="enscript-type">void</span>
<span class="enscript-function-name">stack_privilege</span>(
	__unused thread_t	thread)
{
	<span class="enscript-comment">/* OBSOLETE */</span>
}

<span class="enscript-comment">/*
 * Return info on stack usage for threads in a specific processor set
 */</span>
kern_return_t
<span class="enscript-function-name">processor_set_stack_usage</span>(
	processor_set_t	pset,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	*totalp,
	vm_size_t	*spacep,
	vm_size_t	*residentp,
	vm_size_t	*maxusagep,
	vm_offset_t	*maxstackp)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MACH_DEBUG</span>
        <span class="enscript-keyword">return</span> KERN_NOT_SUPPORTED;
#<span class="enscript-reference">else</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> total;
	vm_size_t maxusage;
	vm_offset_t maxstack;

	<span class="enscript-type">register</span> thread_t *thread_list;
	<span class="enscript-type">register</span> thread_t thread;

	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> actual;	<span class="enscript-comment">/* this many things */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

	vm_size_t size, size_needed;
	<span class="enscript-type">void</span> *addr;

	<span class="enscript-keyword">if</span> (pset == PROCESSOR_SET_NULL || pset != &amp;pset0)
		<span class="enscript-keyword">return</span> KERN_INVALID_ARGUMENT;

	size = 0;
	addr = NULL;

	<span class="enscript-keyword">for</span> (;;) {
		lck_mtx_lock(&amp;tasks_threads_lock);

		actual = threads_count;

		<span class="enscript-comment">/* do we have the memory we need? */</span>

		size_needed = actual * <span class="enscript-keyword">sizeof</span>(thread_t);
		<span class="enscript-keyword">if</span> (size_needed &lt;= size)
			<span class="enscript-keyword">break</span>;

		lck_mtx_unlock(&amp;tasks_threads_lock);

		<span class="enscript-keyword">if</span> (size != 0)
			kfree(addr, size);

		assert(size_needed &gt; 0);
		size = size_needed;

		addr = kalloc(size);
		<span class="enscript-keyword">if</span> (addr == 0)
			<span class="enscript-keyword">return</span> KERN_RESOURCE_SHORTAGE;
	}

	<span class="enscript-comment">/* OK, have memory and list is locked */</span>
	thread_list = (thread_t *) addr;
	<span class="enscript-keyword">for</span> (i = 0, thread = (thread_t)(<span class="enscript-type">void</span> *) queue_first(&amp;threads);
					!queue_end(&amp;threads, (queue_entry_t) thread);
					thread = (thread_t)(<span class="enscript-type">void</span> *) queue_next(&amp;thread-&gt;threads)) {
		thread_reference_internal(thread);
		thread_list[i++] = thread;
	}
	assert(i &lt;= actual);

	lck_mtx_unlock(&amp;tasks_threads_lock);

	<span class="enscript-comment">/* calculate maxusage and free thread references */</span>

	total = 0;
	maxusage = 0;
	maxstack = 0;
	<span class="enscript-keyword">while</span> (i &gt; 0) {
		thread_t threadref = thread_list[--i];

		<span class="enscript-keyword">if</span> (threadref-&gt;kernel_stack != 0)
			total++;

		thread_deallocate(threadref);
	}

	<span class="enscript-keyword">if</span> (size != 0)
		kfree(addr, size);

	*totalp = total;
	*residentp = *spacep = total * round_page(kernel_stack_size);
	*maxusagep = maxusage;
	*maxstackp = maxstack;
	<span class="enscript-keyword">return</span> KERN_SUCCESS;

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* MACH_DEBUG */</span>
}

vm_offset_t <span class="enscript-function-name">min_valid_stack_address</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (vm_offset_t)vm_map_min(kernel_map);
}

vm_offset_t <span class="enscript-function-name">max_valid_stack_address</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (vm_offset_t)vm_map_max(kernel_map);
}
</pre>
<hr />
</body></html>