<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>locks.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">locks.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_ldebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;debug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_host_server.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_debug/lockgroup_info.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/misc_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
<span class="enscript-comment">/*
 * We need only enough declarations from the BSD-side to be able to
 * test if our probe is active, and to call __dtrace_probe().  Setting
 * NEED_DTRACE_DEFS gets a local copy of those definitions pulled in.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NEED_DTRACE_DEFS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;../bsd/sys/lockstat.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_MTX_SLEEP_CODE</span>		0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_MTX_SLEEP_DEADLINE_CODE</span>	1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_MTX_LCK_WAIT_CODE</span>		2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LCK_MTX_UNLCK_WAKEUP_CODE</span>	3

<span class="enscript-type">static</span> queue_head_t	lck_grp_queue;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	lck_grp_cnt;

<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>,lck_grp_lock)
<span class="enscript-type">static</span> lck_mtx_ext_t lck_grp_lock_ext;

lck_grp_attr_t	LockDefaultGroupAttr;
lck_grp_t		LockCompatGroup;
lck_attr_t		LockDefaultLckAttr;

<span class="enscript-comment">/*
 * Routine:	lck_mod_init
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mod_init</span>(
	<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * Obtain &quot;lcks&quot; options:this currently controls lock statistics
	 */</span>
	<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;lcks&quot;</span>, &amp;LcksOpts, <span class="enscript-keyword">sizeof</span> (LcksOpts)))
		LcksOpts = 0;

	queue_init(&amp;lck_grp_queue);
	
	<span class="enscript-comment">/* 
	 * Need to bootstrap the LockCompatGroup instead of calling lck_grp_init() here. This avoids
	 * grabbing the lck_grp_lock before it is initialized.
	 */</span>
	
	bzero(&amp;LockCompatGroup, <span class="enscript-keyword">sizeof</span>(lck_grp_t));
	(<span class="enscript-type">void</span>) strncpy(LockCompatGroup.lck_grp_name, <span class="enscript-string">&quot;Compatibility APIs&quot;</span>, LCK_GRP_MAX_NAME);
	
	<span class="enscript-keyword">if</span> (LcksOpts &amp; enaLkStat)
		LockCompatGroup.lck_grp_attr = LCK_GRP_ATTR_STAT;
    <span class="enscript-keyword">else</span>
		LockCompatGroup.lck_grp_attr = LCK_ATTR_NONE;
	
	LockCompatGroup.lck_grp_refcnt = 1;
	
	enqueue_tail(&amp;lck_grp_queue, (queue_entry_t)&amp;LockCompatGroup);
	lck_grp_cnt = 1;
	
	lck_grp_attr_setdefault(&amp;LockDefaultGroupAttr);
	lck_attr_setdefault(&amp;LockDefaultLckAttr);
	
	lck_mtx_init_ext(&amp;lck_grp_lock, &amp;lck_grp_lock_ext, &amp;LockCompatGroup, &amp;LockDefaultLckAttr);
	
}

<span class="enscript-comment">/*
 * Routine:	lck_grp_attr_alloc_init
 */</span>

lck_grp_attr_t	*
<span class="enscript-function-name">lck_grp_attr_alloc_init</span>(
	<span class="enscript-type">void</span>)
{
	lck_grp_attr_t	*attr;

	<span class="enscript-keyword">if</span> ((attr = (lck_grp_attr_t *)kalloc(<span class="enscript-keyword">sizeof</span>(lck_grp_attr_t))) != 0)
		lck_grp_attr_setdefault(attr);

	<span class="enscript-keyword">return</span>(attr);
}


<span class="enscript-comment">/*
 * Routine:	lck_grp_attr_setdefault
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_grp_attr_setdefault</span>(
	lck_grp_attr_t	*attr)
{
	<span class="enscript-keyword">if</span> (LcksOpts &amp; enaLkStat)
		attr-&gt;grp_attr_val = LCK_GRP_ATTR_STAT;
	<span class="enscript-keyword">else</span>
		attr-&gt;grp_attr_val = 0;
}


<span class="enscript-comment">/*
 * Routine: 	lck_grp_attr_setstat
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_grp_attr_setstat</span>(
	lck_grp_attr_t	*attr)
{
	(<span class="enscript-type">void</span>)hw_atomic_or(&amp;attr-&gt;grp_attr_val, LCK_GRP_ATTR_STAT);
}


<span class="enscript-comment">/*
 * Routine: 	lck_grp_attr_free
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_grp_attr_free</span>(
	lck_grp_attr_t	*attr)
{
	kfree(attr, <span class="enscript-keyword">sizeof</span>(lck_grp_attr_t));
}


<span class="enscript-comment">/*
 * Routine: lck_grp_alloc_init
 */</span>

lck_grp_t *
<span class="enscript-function-name">lck_grp_alloc_init</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>*	grp_name,
	lck_grp_attr_t	*attr)
{
	lck_grp_t	*grp;

	<span class="enscript-keyword">if</span> ((grp = (lck_grp_t *)kalloc(<span class="enscript-keyword">sizeof</span>(lck_grp_t))) != 0)
		lck_grp_init(grp, grp_name, attr);

	<span class="enscript-keyword">return</span>(grp);
}

<span class="enscript-comment">/*
 * Routine: lck_grp_init
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_grp_init</span>(lck_grp_t * grp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * grp_name, lck_grp_attr_t * attr)
{
	bzero((<span class="enscript-type">void</span> *)grp, <span class="enscript-keyword">sizeof</span>(lck_grp_t));

	(<span class="enscript-type">void</span>)strlcpy(grp-&gt;lck_grp_name, grp_name, LCK_GRP_MAX_NAME);

	<span class="enscript-keyword">if</span> (attr != LCK_GRP_ATTR_NULL)
		grp-&gt;lck_grp_attr = attr-&gt;grp_attr_val;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (LcksOpts &amp; enaLkStat)
		grp-&gt;lck_grp_attr = LCK_GRP_ATTR_STAT;
	<span class="enscript-keyword">else</span>
		grp-&gt;lck_grp_attr = LCK_ATTR_NONE;

	grp-&gt;lck_grp_refcnt = 1;

	lck_mtx_lock(&amp;lck_grp_lock);
	enqueue_tail(&amp;lck_grp_queue, (queue_entry_t)grp);
	lck_grp_cnt++;
	lck_mtx_unlock(&amp;lck_grp_lock);
}

<span class="enscript-comment">/*
 * Routine: 	lck_grp_free
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_grp_free</span>(
	lck_grp_t	*grp)
{
	lck_mtx_lock(&amp;lck_grp_lock);
	lck_grp_cnt--;
	(<span class="enscript-type">void</span>)remque((queue_entry_t)grp);
	lck_mtx_unlock(&amp;lck_grp_lock);
	lck_grp_deallocate(grp);
}


<span class="enscript-comment">/*
 * Routine: 	lck_grp_reference
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_grp_reference</span>(
	lck_grp_t	*grp)
{
	(<span class="enscript-type">void</span>)hw_atomic_add(&amp;grp-&gt;lck_grp_refcnt, 1);
}


<span class="enscript-comment">/*
 * Routine: 	lck_grp_deallocate
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_grp_deallocate</span>(
	lck_grp_t	*grp)
{
	<span class="enscript-keyword">if</span> (hw_atomic_sub(&amp;grp-&gt;lck_grp_refcnt, 1) == 0)
	 	kfree(grp, <span class="enscript-keyword">sizeof</span>(lck_grp_t));
}

<span class="enscript-comment">/*
 * Routine:	lck_grp_lckcnt_incr
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_grp_lckcnt_incr</span>(
	lck_grp_t	*grp,
	lck_type_t	lck_type)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	*lckcnt;

	<span class="enscript-keyword">switch</span> (lck_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LCK_TYPE_SPIN</span>:
		lckcnt = &amp;grp-&gt;lck_grp_spincnt;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LCK_TYPE_MTX</span>:
		lckcnt = &amp;grp-&gt;lck_grp_mtxcnt;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LCK_TYPE_RW</span>:
		lckcnt = &amp;grp-&gt;lck_grp_rwcnt;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> panic(<span class="enscript-string">&quot;lck_grp_lckcnt_incr(): invalid lock type: %d\n&quot;</span>, lck_type);
	}

	(<span class="enscript-type">void</span>)hw_atomic_add(lckcnt, 1);
}

<span class="enscript-comment">/*
 * Routine:	lck_grp_lckcnt_decr
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_grp_lckcnt_decr</span>(
	lck_grp_t	*grp,
	lck_type_t	lck_type)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	*lckcnt;

	<span class="enscript-keyword">switch</span> (lck_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LCK_TYPE_SPIN</span>:
		lckcnt = &amp;grp-&gt;lck_grp_spincnt;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LCK_TYPE_MTX</span>:
		lckcnt = &amp;grp-&gt;lck_grp_mtxcnt;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LCK_TYPE_RW</span>:
		lckcnt = &amp;grp-&gt;lck_grp_rwcnt;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> panic(<span class="enscript-string">&quot;lck_grp_lckcnt_decr(): invalid lock type: %d\n&quot;</span>, lck_type);
	}

	(<span class="enscript-type">void</span>)hw_atomic_sub(lckcnt, 1);
}

<span class="enscript-comment">/*
 * Routine:	lck_attr_alloc_init
 */</span>

lck_attr_t *
<span class="enscript-function-name">lck_attr_alloc_init</span>(
	<span class="enscript-type">void</span>)
{
	lck_attr_t	*attr;

	<span class="enscript-keyword">if</span> ((attr = (lck_attr_t *)kalloc(<span class="enscript-keyword">sizeof</span>(lck_attr_t))) != 0)
		lck_attr_setdefault(attr);

	<span class="enscript-keyword">return</span>(attr);
}


<span class="enscript-comment">/*
 * Routine:	lck_attr_setdefault
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_attr_setdefault</span>(
	lck_attr_t	*attr)
{
#<span class="enscript-reference">if</span>   <span class="enscript-variable-name">__i386__</span> || <span class="enscript-variable-name">__x86_64__</span>
#<span class="enscript-reference">if</span>     !<span class="enscript-variable-name">DEBUG</span>
 	<span class="enscript-keyword">if</span> (LcksOpts &amp; enaLkDeb)
 		attr-&gt;lck_attr_val =  LCK_ATTR_DEBUG;
 	<span class="enscript-keyword">else</span>
 		attr-&gt;lck_attr_val =  LCK_ATTR_NONE;
#<span class="enscript-reference">else</span>
 	attr-&gt;lck_attr_val =  LCK_ATTR_DEBUG;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !DEBUG */</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">architecture</span>.
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* __arm__ */</span>
}


<span class="enscript-comment">/*
 * Routine:	lck_attr_setdebug
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_attr_setdebug</span>(
	lck_attr_t	*attr)
{
	(<span class="enscript-type">void</span>)hw_atomic_or(&amp;attr-&gt;lck_attr_val, LCK_ATTR_DEBUG);
}

<span class="enscript-comment">/*
 * Routine:	lck_attr_setdebug
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_attr_cleardebug</span>(
	lck_attr_t	*attr)
{
	(<span class="enscript-type">void</span>)hw_atomic_and(&amp;attr-&gt;lck_attr_val, ~LCK_ATTR_DEBUG);
}


<span class="enscript-comment">/*
 * Routine:	lck_attr_rw_shared_priority
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_attr_rw_shared_priority</span>(
	lck_attr_t	*attr)
{
	(<span class="enscript-type">void</span>)hw_atomic_or(&amp;attr-&gt;lck_attr_val, LCK_ATTR_RW_SHARED_PRIORITY);
}


<span class="enscript-comment">/*
 * Routine:	lck_attr_free
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_attr_free</span>(
	lck_attr_t	*attr)
{
	kfree(attr, <span class="enscript-keyword">sizeof</span>(lck_attr_t));
}


<span class="enscript-comment">/*
 * Routine:	lck_spin_sleep
 */</span>
wait_result_t
<span class="enscript-function-name">lck_spin_sleep</span>(
        lck_spin_t		*lck,
	lck_sleep_action_t	lck_sleep_action,
	event_t			event,
	wait_interrupt_t	interruptible)
{
	wait_result_t	res;
 
	<span class="enscript-keyword">if</span> ((lck_sleep_action &amp; ~LCK_SLEEP_MASK) != 0)
		panic(<span class="enscript-string">&quot;Invalid lock sleep action %x\n&quot;</span>, lck_sleep_action);

	res = assert_wait(event, interruptible);
	<span class="enscript-keyword">if</span> (res == THREAD_WAITING) {
		lck_spin_unlock(lck);
		res = thread_block(THREAD_CONTINUE_NULL);
		<span class="enscript-keyword">if</span> (!(lck_sleep_action &amp; LCK_SLEEP_UNLOCK))
			lck_spin_lock(lck);
	}
	<span class="enscript-keyword">else</span>
	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_UNLOCK)
		lck_spin_unlock(lck);

	<span class="enscript-keyword">return</span> res;
}


<span class="enscript-comment">/*
 * Routine:	lck_spin_sleep_deadline
 */</span>
wait_result_t
<span class="enscript-function-name">lck_spin_sleep_deadline</span>(
        lck_spin_t		*lck,
	lck_sleep_action_t	lck_sleep_action,
	event_t			event,
	wait_interrupt_t	interruptible,
	uint64_t		deadline)
{
	wait_result_t   res;

	<span class="enscript-keyword">if</span> ((lck_sleep_action &amp; ~LCK_SLEEP_MASK) != 0)
		panic(<span class="enscript-string">&quot;Invalid lock sleep action %x\n&quot;</span>, lck_sleep_action);

	res = assert_wait_deadline(event, interruptible, deadline);
	<span class="enscript-keyword">if</span> (res == THREAD_WAITING) {
		lck_spin_unlock(lck);
		res = thread_block(THREAD_CONTINUE_NULL);
		<span class="enscript-keyword">if</span> (!(lck_sleep_action &amp; LCK_SLEEP_UNLOCK))
			lck_spin_lock(lck);
	}
	<span class="enscript-keyword">else</span>
	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_UNLOCK)
		lck_spin_unlock(lck);

	<span class="enscript-keyword">return</span> res;
}


<span class="enscript-comment">/*
 * Routine:	lck_mtx_clear_promoted
 *
 * Handle clearing of TH_SFLAG_PROMOTED,
 * adjusting thread priority as needed.
 *
 * Called with thread lock held
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_clear_promoted</span> (
	thread_t 			thread,
	__kdebug_only uintptr_t		trace_lck)
{
	thread-&gt;sched_flags &amp;= ~TH_SFLAG_PROMOTED;

	<span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_RW_PROMOTED) {
		<span class="enscript-comment">/* Thread still has a RW lock promotion */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_DEPRESSED_MASK) {
		KERNEL_DEBUG_CONSTANT(
			MACHDBG_CODE(DBG_MACH_SCHED,MACH_DEMOTE) | DBG_FUNC_NONE,
				thread-&gt;sched_pri, DEPRESSPRI, 0, trace_lck, 0);
		set_sched_pri(thread, DEPRESSPRI);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (thread-&gt;base_pri &lt; thread-&gt;sched_pri) {
			KERNEL_DEBUG_CONSTANT(
				MACHDBG_CODE(DBG_MACH_SCHED,MACH_DEMOTE) | DBG_FUNC_NONE,
					thread-&gt;sched_pri, thread-&gt;base_pri, 0, trace_lck, 0);
		}
		thread_recompute_sched_pri(thread, FALSE);
	}
}


<span class="enscript-comment">/*
 * Routine:	lck_mtx_sleep
 */</span>
wait_result_t
<span class="enscript-function-name">lck_mtx_sleep</span>(
        lck_mtx_t		*lck,
	lck_sleep_action_t	lck_sleep_action,
	event_t			event,
	wait_interrupt_t	interruptible)
{
	wait_result_t	res;
	thread_t		thread = current_thread();
 
	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_SLEEP_CODE) | DBG_FUNC_START,
		     VM_KERNEL_UNSLIDE_OR_PERM(lck), (<span class="enscript-type">int</span>)lck_sleep_action, VM_KERNEL_UNSLIDE_OR_PERM(event), (<span class="enscript-type">int</span>)interruptible, 0);

	<span class="enscript-keyword">if</span> ((lck_sleep_action &amp; ~LCK_SLEEP_MASK) != 0)
		panic(<span class="enscript-string">&quot;Invalid lock sleep action %x\n&quot;</span>, lck_sleep_action);

	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_PROMOTED_PRI) {
		<span class="enscript-comment">/*
		 * We overload the RW lock promotion to give us a priority ceiling
		 * during the time that this thread is asleep, so that when it
		 * is re-awakened (and not yet contending on the mutex), it is
		 * runnable at a reasonably high priority.
		 */</span>
		thread-&gt;rwlock_count++;
	}

	res = assert_wait(event, interruptible);
	<span class="enscript-keyword">if</span> (res == THREAD_WAITING) {
		lck_mtx_unlock(lck);
		res = thread_block(THREAD_CONTINUE_NULL);
		<span class="enscript-keyword">if</span> (!(lck_sleep_action &amp; LCK_SLEEP_UNLOCK)) {
			<span class="enscript-keyword">if</span> ((lck_sleep_action &amp; LCK_SLEEP_SPIN))
				lck_mtx_lock_spin(lck);
			<span class="enscript-keyword">else</span>
				lck_mtx_lock(lck);
		}
	}
	<span class="enscript-keyword">else</span>
	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_UNLOCK)
		lck_mtx_unlock(lck);

	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_PROMOTED_PRI) {
		<span class="enscript-keyword">if</span> ((thread-&gt;rwlock_count-- == 1 <span class="enscript-comment">/* field now 0 */</span>) &amp;&amp; (thread-&gt;sched_flags &amp; TH_SFLAG_RW_PROMOTED)) {
			<span class="enscript-comment">/* sched_flags checked without lock, but will be rechecked while clearing */</span>
			lck_rw_clear_promotion(thread);
		}
	}

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_SLEEP_CODE) | DBG_FUNC_END, (<span class="enscript-type">int</span>)res, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span> res;
}


<span class="enscript-comment">/*
 * Routine:	lck_mtx_sleep_deadline
 */</span>
wait_result_t
<span class="enscript-function-name">lck_mtx_sleep_deadline</span>(
        lck_mtx_t		*lck,
	lck_sleep_action_t	lck_sleep_action,
	event_t			event,
	wait_interrupt_t	interruptible,
	uint64_t		deadline)
{
	wait_result_t   res;
	thread_t		thread = current_thread();

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_SLEEP_DEADLINE_CODE) | DBG_FUNC_START,
		     VM_KERNEL_UNSLIDE_OR_PERM(lck), (<span class="enscript-type">int</span>)lck_sleep_action, VM_KERNEL_UNSLIDE_OR_PERM(event), (<span class="enscript-type">int</span>)interruptible, 0);

	<span class="enscript-keyword">if</span> ((lck_sleep_action &amp; ~LCK_SLEEP_MASK) != 0)
		panic(<span class="enscript-string">&quot;Invalid lock sleep action %x\n&quot;</span>, lck_sleep_action);

	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_PROMOTED_PRI) {
		<span class="enscript-comment">/*
		 * See lck_mtx_sleep().
		 */</span>
		thread-&gt;rwlock_count++;
	}

	res = assert_wait_deadline(event, interruptible, deadline);
	<span class="enscript-keyword">if</span> (res == THREAD_WAITING) {
		lck_mtx_unlock(lck);
		res = thread_block(THREAD_CONTINUE_NULL);
		<span class="enscript-keyword">if</span> (!(lck_sleep_action &amp; LCK_SLEEP_UNLOCK)) {
			<span class="enscript-keyword">if</span> ((lck_sleep_action &amp; LCK_SLEEP_SPIN))
				lck_mtx_lock_spin(lck);
			<span class="enscript-keyword">else</span>
				lck_mtx_lock(lck);
		}
	}
	<span class="enscript-keyword">else</span>
	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_UNLOCK)
		lck_mtx_unlock(lck);

	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_PROMOTED_PRI) {
		<span class="enscript-keyword">if</span> ((thread-&gt;rwlock_count-- == 1 <span class="enscript-comment">/* field now 0 */</span>) &amp;&amp; (thread-&gt;sched_flags &amp; TH_SFLAG_RW_PROMOTED)) {
			<span class="enscript-comment">/* sched_flags checked without lock, but will be rechecked while clearing */</span>
			lck_rw_clear_promotion(thread);
		}
	}

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_SLEEP_DEADLINE_CODE) | DBG_FUNC_END, (<span class="enscript-type">int</span>)res, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span> res;
}

<span class="enscript-comment">/*
 * Routine: 	lck_mtx_lock_wait
 *
 * Invoked in order to wait on contention.
 *
 * Called with the interlock locked and
 * returns it unlocked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_lock_wait</span> (
	lck_mtx_t			*lck,
	thread_t			holder)
{
	thread_t		self = current_thread();
	lck_mtx_t		*mutex;
	__kdebug_only uintptr_t	trace_lck = VM_KERNEL_UNSLIDE_OR_PERM(lck);
	__kdebug_only uintptr_t	trace_holder = VM_KERNEL_UNSLIDE_OR_PERM(holder);
	integer_t		priority;
	spl_t			s = splsched();
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
	uint64_t		sleep_start = 0;

	<span class="enscript-keyword">if</span> (lockstat_probemap[LS_LCK_MTX_LOCK_BLOCK] || lockstat_probemap[LS_LCK_MTX_EXT_LOCK_BLOCK]) {
		sleep_start = mach_absolute_time();
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (lck-&gt;lck_mtx_tag != LCK_MTX_TAG_INDIRECT)
		mutex = lck;
	<span class="enscript-keyword">else</span>
		mutex = &amp;lck-&gt;lck_mtx_ptr-&gt;lck_mtx;

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_LCK_WAIT_CODE) | DBG_FUNC_START, trace_lck, trace_holder, 0, 0, 0);

	priority = self-&gt;sched_pri;
	<span class="enscript-keyword">if</span> (priority &lt; self-&gt;base_pri)
		priority = self-&gt;base_pri;
	<span class="enscript-keyword">if</span> (priority &lt; BASEPRI_DEFAULT)
		priority = BASEPRI_DEFAULT;

	<span class="enscript-comment">/* Do not promote past promotion ceiling */</span>
	priority = MIN(priority, MAXPRI_PROMOTE);

	thread_lock(holder);
	<span class="enscript-keyword">if</span> (mutex-&gt;lck_mtx_pri == 0)
		holder-&gt;promotions++;
	holder-&gt;sched_flags |= TH_SFLAG_PROMOTED;
	<span class="enscript-keyword">if</span> (mutex-&gt;lck_mtx_pri &lt; priority &amp;&amp; holder-&gt;sched_pri &lt; priority) {
		KERNEL_DEBUG_CONSTANT(
			MACHDBG_CODE(DBG_MACH_SCHED,MACH_PROMOTE) | DBG_FUNC_NONE,
					holder-&gt;sched_pri, priority, trace_holder, trace_lck, 0);
		set_sched_pri(holder, priority);
	}
	thread_unlock(holder);
	splx(s);

	<span class="enscript-keyword">if</span> (mutex-&gt;lck_mtx_pri &lt; priority)
		mutex-&gt;lck_mtx_pri = priority;
	<span class="enscript-keyword">if</span> (self-&gt;pending_promoter[self-&gt;pending_promoter_index] == NULL) {
		self-&gt;pending_promoter[self-&gt;pending_promoter_index] = mutex;
		mutex-&gt;lck_mtx_waiters++;
	}
	<span class="enscript-keyword">else</span>
	<span class="enscript-keyword">if</span> (self-&gt;pending_promoter[self-&gt;pending_promoter_index] != mutex) {
		self-&gt;pending_promoter[++self-&gt;pending_promoter_index] = mutex;
		mutex-&gt;lck_mtx_waiters++;
	}

	assert_wait(LCK_MTX_EVENT(mutex), THREAD_UNINT);
	lck_mtx_ilk_unlock(mutex);

	thread_block(THREAD_CONTINUE_NULL);

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_LCK_WAIT_CODE) | DBG_FUNC_END, 0, 0, 0, 0, 0);
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-comment">/*
	 * Record the Dtrace lockstat probe for blocking, block time
	 * measured from when we were entered.
	 */</span>
	<span class="enscript-keyword">if</span> (sleep_start) {
		<span class="enscript-keyword">if</span> (lck-&gt;lck_mtx_tag != LCK_MTX_TAG_INDIRECT) {
			LOCKSTAT_RECORD(LS_LCK_MTX_LOCK_BLOCK, lck,
			    mach_absolute_time() - sleep_start);
		} <span class="enscript-keyword">else</span> {
			LOCKSTAT_RECORD(LS_LCK_MTX_EXT_LOCK_BLOCK, lck,
			    mach_absolute_time() - sleep_start);
		}
	}
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 * Routine: 	lck_mtx_lock_acquire
 *
 * Invoked on acquiring the mutex when there is
 * contention.
 *
 * Returns the current number of waiters.
 *
 * Called with the interlock locked.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">lck_mtx_lock_acquire</span>(
	lck_mtx_t		*lck)
{
	thread_t		thread = current_thread();
	lck_mtx_t		*mutex;
	integer_t		priority;
	spl_t			s;
	__kdebug_only uintptr_t	trace_lck = VM_KERNEL_UNSLIDE_OR_PERM(lck);

	<span class="enscript-keyword">if</span> (lck-&gt;lck_mtx_tag != LCK_MTX_TAG_INDIRECT)
		mutex = lck;
	<span class="enscript-keyword">else</span>
		mutex = &amp;lck-&gt;lck_mtx_ptr-&gt;lck_mtx;

	<span class="enscript-keyword">if</span> (thread-&gt;pending_promoter[thread-&gt;pending_promoter_index] == mutex) {
		thread-&gt;pending_promoter[thread-&gt;pending_promoter_index] = NULL;
		<span class="enscript-keyword">if</span> (thread-&gt;pending_promoter_index &gt; 0)
			thread-&gt;pending_promoter_index--;
		mutex-&gt;lck_mtx_waiters--;
	}

	<span class="enscript-keyword">if</span> (mutex-&gt;lck_mtx_waiters)
		priority = mutex-&gt;lck_mtx_pri;
	<span class="enscript-keyword">else</span> {
		mutex-&gt;lck_mtx_pri = 0;
		priority = 0;
	}

	<span class="enscript-keyword">if</span> (priority || thread-&gt;was_promoted_on_wakeup) {
		s = splsched();
		thread_lock(thread);

		<span class="enscript-keyword">if</span> (priority) {
			thread-&gt;promotions++;
			thread-&gt;sched_flags |= TH_SFLAG_PROMOTED;
			<span class="enscript-keyword">if</span> (thread-&gt;sched_pri &lt; priority) {
				KERNEL_DEBUG_CONSTANT(
					MACHDBG_CODE(DBG_MACH_SCHED,MACH_PROMOTE) | DBG_FUNC_NONE,
							thread-&gt;sched_pri, priority, 0, trace_lck, 0);
				<span class="enscript-comment">/* Do not promote past promotion ceiling */</span>
				assert(priority &lt;= MAXPRI_PROMOTE);
				set_sched_pri(thread, priority);
			}
		}
		<span class="enscript-keyword">if</span> (thread-&gt;was_promoted_on_wakeup) {
			thread-&gt;was_promoted_on_wakeup = 0;
			<span class="enscript-keyword">if</span> (thread-&gt;promotions == 0)
				lck_mtx_clear_promoted(thread, trace_lck);
		}

		thread_unlock(thread);
		splx(s);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-keyword">if</span> (lockstat_probemap[LS_LCK_MTX_LOCK_ACQUIRE] || lockstat_probemap[LS_LCK_MTX_EXT_LOCK_ACQUIRE]) {
		<span class="enscript-keyword">if</span> (lck-&gt;lck_mtx_tag != LCK_MTX_TAG_INDIRECT) {
			LOCKSTAT_RECORD(LS_LCK_MTX_LOCK_ACQUIRE, lck, 0);
		} <span class="enscript-keyword">else</span> {
			LOCKSTAT_RECORD(LS_LCK_MTX_EXT_LOCK_ACQUIRE, lck, 0);
		}
	}
#<span class="enscript-reference">endif</span>	
	<span class="enscript-keyword">return</span> (mutex-&gt;lck_mtx_waiters);
}

<span class="enscript-comment">/*
 * Routine: 	lck_mtx_unlock_wakeup
 *
 * Invoked on unlock when there is contention.
 *
 * Called with the interlock locked.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_unlock_wakeup</span> (
	lck_mtx_t			*lck,
	thread_t			holder)
{
	thread_t		thread = current_thread();
	lck_mtx_t		*mutex;
	__kdebug_only uintptr_t trace_lck = VM_KERNEL_UNSLIDE_OR_PERM(lck);

	<span class="enscript-keyword">if</span> (lck-&gt;lck_mtx_tag != LCK_MTX_TAG_INDIRECT)
		mutex = lck;
	<span class="enscript-keyword">else</span>
		mutex = &amp;lck-&gt;lck_mtx_ptr-&gt;lck_mtx;

	<span class="enscript-keyword">if</span> (thread != holder)
		panic(<span class="enscript-string">&quot;lck_mtx_unlock_wakeup: mutex %p holder %p\n&quot;</span>, mutex, holder);

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_UNLCK_WAKEUP_CODE) | DBG_FUNC_START, trace_lck, VM_KERNEL_UNSLIDE_OR_PERM(holder), 0, 0, 0);

	assert(mutex-&gt;lck_mtx_waiters &gt; 0);
	<span class="enscript-keyword">if</span> (mutex-&gt;lck_mtx_waiters &gt; 1)
		thread_wakeup_one_with_pri(LCK_MTX_EVENT(lck), lck-&gt;lck_mtx_pri);
	<span class="enscript-keyword">else</span>
		thread_wakeup_one(LCK_MTX_EVENT(lck));

	<span class="enscript-keyword">if</span> (thread-&gt;promotions &gt; 0) {
		spl_t		s = splsched();

		thread_lock(thread);
		<span class="enscript-keyword">if</span> (--thread-&gt;promotions == 0 &amp;&amp; (thread-&gt;sched_flags &amp; TH_SFLAG_PROMOTED))
			lck_mtx_clear_promoted(thread, trace_lck);
		thread_unlock(thread);
		splx(s);
	}

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_UNLCK_WAKEUP_CODE) | DBG_FUNC_END, 0, 0, 0, 0, 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_unlockspin_wakeup</span> (
	lck_mtx_t			*lck)
{
	assert(lck-&gt;lck_mtx_waiters &gt; 0);
	thread_wakeup_one(LCK_MTX_EVENT(lck));

	KERNEL_DEBUG(MACHDBG_CODE(DBG_MACH_LOCKS, LCK_MTX_UNLCK_WAKEUP_CODE) | DBG_FUNC_NONE, VM_KERNEL_UNSLIDE_OR_PERM(lck), 0, 0, 1, 0);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-comment">/*
	 * When there are waiters, we skip the hot-patch spot in the
	 * fastpath, so we record it here.
	 */</span>
	LOCKSTAT_RECORD(LS_LCK_MTX_UNLOCK_RELEASE, lck, 0);
#<span class="enscript-reference">endif</span>
}


<span class="enscript-comment">/*
 * Routine: 	mutex_pause
 *
 * Called by former callers of simple_lock_pause().
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_COLLISION_COUNTS</span>	32
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_COLLISION</span> 	8

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> max_collision_count[MAX_COLLISION_COUNTS];

uint32_t collision_backoffs[MAX_COLLISION] = {
        10, 50, 100, 200, 400, 600, 800, 1000
};


<span class="enscript-type">void</span>
<span class="enscript-function-name">mutex_pause</span>(uint32_t collisions)
{
	wait_result_t wait_result;
	uint32_t	back_off;

	<span class="enscript-keyword">if</span> (collisions &gt;= MAX_COLLISION_COUNTS)
	        collisions = MAX_COLLISION_COUNTS - 1;
	max_collision_count[collisions]++;

	<span class="enscript-keyword">if</span> (collisions &gt;= MAX_COLLISION)
	        collisions = MAX_COLLISION - 1;
	back_off = collision_backoffs[collisions];

	wait_result = assert_wait_timeout((event_t)mutex_pause, THREAD_UNINT, back_off, NSEC_PER_USEC);
	assert(wait_result == THREAD_WAITING);

	wait_result = thread_block(THREAD_CONTINUE_NULL);
	assert(wait_result == THREAD_TIMED_OUT);
}


<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mutex_yield_wait = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mutex_yield_no_wait = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">lck_mtx_yield</span>(
	    lck_mtx_t	*lck)
{
	<span class="enscript-type">int</span>	waiters;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	lck_mtx_assert(lck, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
	
	<span class="enscript-keyword">if</span> (lck-&gt;lck_mtx_tag == LCK_MTX_TAG_INDIRECT)
	        waiters = lck-&gt;lck_mtx_ptr-&gt;lck_mtx.lck_mtx_waiters;
	<span class="enscript-keyword">else</span>
	        waiters = lck-&gt;lck_mtx_waiters;

	<span class="enscript-keyword">if</span> ( !waiters) {
	        mutex_yield_no_wait++;
	} <span class="enscript-keyword">else</span> {
	        mutex_yield_wait++;
		lck_mtx_unlock(lck);
		mutex_pause(0);
		lck_mtx_lock(lck);
	}
}


<span class="enscript-comment">/*
 * Routine:	lck_rw_sleep
 */</span>
wait_result_t
<span class="enscript-function-name">lck_rw_sleep</span>(
        lck_rw_t		*lck,
	lck_sleep_action_t	lck_sleep_action,
	event_t			event,
	wait_interrupt_t	interruptible)
{
	wait_result_t	res;
	lck_rw_type_t	lck_rw_type;
	thread_t		thread = current_thread();

	<span class="enscript-keyword">if</span> ((lck_sleep_action &amp; ~LCK_SLEEP_MASK) != 0)
		panic(<span class="enscript-string">&quot;Invalid lock sleep action %x\n&quot;</span>, lck_sleep_action);

	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_PROMOTED_PRI) {
		<span class="enscript-comment">/*
		 * Although we are dropping the RW lock, the intent in most cases
		 * is that this thread remains as an observer, since it may hold
		 * some secondary resource, but must yield to avoid deadlock. In
		 * this situation, make sure that the thread is boosted to the
		 * RW lock ceiling while blocked, so that it can re-acquire the
		 * RW lock at that priority.
		 */</span>
		thread-&gt;rwlock_count++;
	}

	res = assert_wait(event, interruptible);
	<span class="enscript-keyword">if</span> (res == THREAD_WAITING) {
		lck_rw_type = lck_rw_done(lck);
		res = thread_block(THREAD_CONTINUE_NULL);
		<span class="enscript-keyword">if</span> (!(lck_sleep_action &amp; LCK_SLEEP_UNLOCK)) {
			<span class="enscript-keyword">if</span> (!(lck_sleep_action &amp; (LCK_SLEEP_SHARED|LCK_SLEEP_EXCLUSIVE)))
				lck_rw_lock(lck, lck_rw_type);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_EXCLUSIVE)
				lck_rw_lock_exclusive(lck);
			<span class="enscript-keyword">else</span>
				lck_rw_lock_shared(lck);
		}
	}
	<span class="enscript-keyword">else</span>
	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_UNLOCK)
		(<span class="enscript-type">void</span>)lck_rw_done(lck);

	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_PROMOTED_PRI) {
		<span class="enscript-keyword">if</span> ((thread-&gt;rwlock_count-- == 1 <span class="enscript-comment">/* field now 0 */</span>) &amp;&amp; (thread-&gt;sched_flags &amp; TH_SFLAG_RW_PROMOTED)) {
			<span class="enscript-comment">/* sched_flags checked without lock, but will be rechecked while clearing */</span>

			<span class="enscript-comment">/* Only if the caller wanted the lck_rw_t returned unlocked should we drop to 0 */</span>
			assert(lck_sleep_action &amp; LCK_SLEEP_UNLOCK);

			lck_rw_clear_promotion(thread);
		}
	}

	<span class="enscript-keyword">return</span> res;
}


<span class="enscript-comment">/*
 * Routine:	lck_rw_sleep_deadline
 */</span>
wait_result_t
<span class="enscript-function-name">lck_rw_sleep_deadline</span>(
	lck_rw_t		*lck,
	lck_sleep_action_t	lck_sleep_action,
	event_t			event,
	wait_interrupt_t	interruptible,
	uint64_t		deadline)
{
	wait_result_t   res;
	lck_rw_type_t	lck_rw_type;
	thread_t		thread = current_thread();

	<span class="enscript-keyword">if</span> ((lck_sleep_action &amp; ~LCK_SLEEP_MASK) != 0)
		panic(<span class="enscript-string">&quot;Invalid lock sleep action %x\n&quot;</span>, lck_sleep_action);

	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_PROMOTED_PRI) {
		thread-&gt;rwlock_count++;
	}

	res = assert_wait_deadline(event, interruptible, deadline);
	<span class="enscript-keyword">if</span> (res == THREAD_WAITING) {
		lck_rw_type = lck_rw_done(lck);
		res = thread_block(THREAD_CONTINUE_NULL);
		<span class="enscript-keyword">if</span> (!(lck_sleep_action &amp; LCK_SLEEP_UNLOCK)) {
			<span class="enscript-keyword">if</span> (!(lck_sleep_action &amp; (LCK_SLEEP_SHARED|LCK_SLEEP_EXCLUSIVE)))
				lck_rw_lock(lck, lck_rw_type);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_EXCLUSIVE)
				lck_rw_lock_exclusive(lck);
			<span class="enscript-keyword">else</span>
				lck_rw_lock_shared(lck);
		}
	}
	<span class="enscript-keyword">else</span>
	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_UNLOCK)
		(<span class="enscript-type">void</span>)lck_rw_done(lck);

	<span class="enscript-keyword">if</span> (lck_sleep_action &amp; LCK_SLEEP_PROMOTED_PRI) {
		<span class="enscript-keyword">if</span> ((thread-&gt;rwlock_count-- == 1 <span class="enscript-comment">/* field now 0 */</span>) &amp;&amp; (thread-&gt;sched_flags &amp; TH_SFLAG_RW_PROMOTED)) {
			<span class="enscript-comment">/* sched_flags checked without lock, but will be rechecked while clearing */</span>

			<span class="enscript-comment">/* Only if the caller wanted the lck_rw_t returned unlocked should we drop to 0 */</span>
			assert(lck_sleep_action &amp; LCK_SLEEP_UNLOCK);

			lck_rw_clear_promotion(thread);
		}
	}

	<span class="enscript-keyword">return</span> res;
}

<span class="enscript-comment">/*
 * Reader-writer lock promotion
 *
 * We support a limited form of reader-writer
 * lock promotion whose effects are:
 * 
 *   * Qualifying threads have decay disabled
 *   * Scheduler priority is reset to a floor of
 *     of their statically assigned priority
 *     or BASEPRI_BACKGROUND
 *
 * The rationale is that lck_rw_ts do not have
 * a single owner, so we cannot apply a directed
 * priority boost from all waiting threads
 * to all holding threads without maintaining
 * lists of all shared owners and all waiting
 * threads for every lock.
 *
 * Instead (and to preserve the uncontended fast-
 * path), acquiring (or attempting to acquire)
 * a RW lock in shared or exclusive lock increments
 * a per-thread counter. Only if that thread stops
 * making forward progress (for instance blocking
 * on a mutex, or being preempted) do we consult
 * the counter and apply the priority floor.
 * When the thread becomes runnable again (or in
 * the case of preemption it never stopped being
 * runnable), it has the priority boost and should
 * be in a good position to run on the CPU and
 * release all RW locks (at which point the priority
 * boost is cleared).
 *
 * Care must be taken to ensure that priority
 * boosts are not retained indefinitely, since unlike
 * mutex priority boosts (where the boost is tied
 * to the mutex lifecycle), the boost is tied
 * to the thread and independent of any particular
 * lck_rw_t. Assertions are in place on return
 * to userspace so that the boost is not held
 * indefinitely.
 *
 * The routines that increment/decrement the
 * per-thread counter should err on the side of
 * incrementing any time a preemption is possible
 * and the lock would be visible to the rest of the
 * system as held (so it should be incremented before
 * interlocks are dropped/preemption is enabled, or
 * before a CAS is executed to acquire the lock).
 *
 */</span>

<span class="enscript-comment">/*
 * lck_rw_clear_promotion: Undo priority promotions when the last RW
 * lock is released by a thread (if a promotion was active)
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">lck_rw_clear_promotion</span>(thread_t thread)
{
	assert(thread-&gt;rwlock_count == 0);

	<span class="enscript-comment">/* Cancel any promotions if the thread had actually blocked while holding a RW lock */</span>
	spl_t s = splsched();

	thread_lock(thread);

	<span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_RW_PROMOTED) {
		thread-&gt;sched_flags &amp;= ~TH_SFLAG_RW_PROMOTED;

		<span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_PROMOTED) {
			<span class="enscript-comment">/* Thread still has a mutex promotion */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (thread-&gt;sched_flags &amp; TH_SFLAG_DEPRESSED_MASK) {
			KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED, MACH_RW_DEMOTE) | DBG_FUNC_NONE,
							      thread-&gt;sched_pri, DEPRESSPRI, 0, 0, 0);
			
			set_sched_pri(thread, DEPRESSPRI);
		} <span class="enscript-keyword">else</span> {
			KERNEL_DEBUG_CONSTANT(MACHDBG_CODE(DBG_MACH_SCHED, MACH_RW_DEMOTE) | DBG_FUNC_NONE,
								  thread-&gt;sched_pri, thread-&gt;base_pri, 0, 0, 0);
			
			thread_recompute_sched_pri(thread, FALSE);
		}
	}

	thread_unlock(thread);
	splx(s);
}

kern_return_t
<span class="enscript-function-name">host_lockgroup_info</span>(
	host_t					host,
	lockgroup_info_array_t	*lockgroup_infop,
	mach_msg_type_number_t	*lockgroup_infoCntp)
{
	lockgroup_info_t	*lockgroup_info_base;
	lockgroup_info_t	*lockgroup_info;
	vm_offset_t			lockgroup_info_addr;
	vm_size_t			lockgroup_info_size;
	lck_grp_t			*lck_grp;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		i;
	vm_size_t			used;
	vm_map_copy_t		copy;
	kern_return_t		kr;

	<span class="enscript-keyword">if</span> (host == HOST_NULL)
		<span class="enscript-keyword">return</span> KERN_INVALID_HOST;

	lck_mtx_lock(&amp;lck_grp_lock);

	lockgroup_info_size = round_page(lck_grp_cnt * <span class="enscript-keyword">sizeof</span> *lockgroup_info);
	kr = kmem_alloc_pageable(ipc_kernel_map,
						 &amp;lockgroup_info_addr, lockgroup_info_size, VM_KERN_MEMORY_IPC);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		lck_mtx_unlock(&amp;lck_grp_lock);
		<span class="enscript-keyword">return</span>(kr);
	}

	lockgroup_info_base = (lockgroup_info_t *) lockgroup_info_addr;
	lck_grp = (lck_grp_t *)queue_first(&amp;lck_grp_queue);
	lockgroup_info = lockgroup_info_base;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; lck_grp_cnt; i++) {

		lockgroup_info-&gt;lock_spin_cnt = lck_grp-&gt;lck_grp_spincnt;
		lockgroup_info-&gt;lock_spin_util_cnt = lck_grp-&gt;lck_grp_stat.lck_grp_spin_stat.lck_grp_spin_util_cnt;
		lockgroup_info-&gt;lock_spin_held_cnt = lck_grp-&gt;lck_grp_stat.lck_grp_spin_stat.lck_grp_spin_held_cnt;
		lockgroup_info-&gt;lock_spin_miss_cnt = lck_grp-&gt;lck_grp_stat.lck_grp_spin_stat.lck_grp_spin_miss_cnt;
		lockgroup_info-&gt;lock_spin_held_max = lck_grp-&gt;lck_grp_stat.lck_grp_spin_stat.lck_grp_spin_held_max;
		lockgroup_info-&gt;lock_spin_held_cum = lck_grp-&gt;lck_grp_stat.lck_grp_spin_stat.lck_grp_spin_held_cum;

		lockgroup_info-&gt;lock_mtx_cnt = lck_grp-&gt;lck_grp_mtxcnt;
		lockgroup_info-&gt;lock_mtx_util_cnt = lck_grp-&gt;lck_grp_stat.lck_grp_mtx_stat.lck_grp_mtx_util_cnt;
		lockgroup_info-&gt;lock_mtx_held_cnt = lck_grp-&gt;lck_grp_stat.lck_grp_mtx_stat.lck_grp_mtx_held_cnt;
		lockgroup_info-&gt;lock_mtx_miss_cnt = lck_grp-&gt;lck_grp_stat.lck_grp_mtx_stat.lck_grp_mtx_miss_cnt;
		lockgroup_info-&gt;lock_mtx_wait_cnt = lck_grp-&gt;lck_grp_stat.lck_grp_mtx_stat.lck_grp_mtx_wait_cnt;
		lockgroup_info-&gt;lock_mtx_held_max = lck_grp-&gt;lck_grp_stat.lck_grp_mtx_stat.lck_grp_mtx_held_max;
		lockgroup_info-&gt;lock_mtx_held_cum = lck_grp-&gt;lck_grp_stat.lck_grp_mtx_stat.lck_grp_mtx_held_cum;
		lockgroup_info-&gt;lock_mtx_wait_max = lck_grp-&gt;lck_grp_stat.lck_grp_mtx_stat.lck_grp_mtx_wait_max;
		lockgroup_info-&gt;lock_mtx_wait_cum = lck_grp-&gt;lck_grp_stat.lck_grp_mtx_stat.lck_grp_mtx_wait_cum;

		lockgroup_info-&gt;lock_rw_cnt = lck_grp-&gt;lck_grp_rwcnt;
		lockgroup_info-&gt;lock_rw_util_cnt = lck_grp-&gt;lck_grp_stat.lck_grp_rw_stat.lck_grp_rw_util_cnt;
		lockgroup_info-&gt;lock_rw_held_cnt = lck_grp-&gt;lck_grp_stat.lck_grp_rw_stat.lck_grp_rw_held_cnt;
		lockgroup_info-&gt;lock_rw_miss_cnt = lck_grp-&gt;lck_grp_stat.lck_grp_rw_stat.lck_grp_rw_miss_cnt;
		lockgroup_info-&gt;lock_rw_wait_cnt = lck_grp-&gt;lck_grp_stat.lck_grp_rw_stat.lck_grp_rw_wait_cnt;
		lockgroup_info-&gt;lock_rw_held_max = lck_grp-&gt;lck_grp_stat.lck_grp_rw_stat.lck_grp_rw_held_max;
		lockgroup_info-&gt;lock_rw_held_cum = lck_grp-&gt;lck_grp_stat.lck_grp_rw_stat.lck_grp_rw_held_cum;
		lockgroup_info-&gt;lock_rw_wait_max = lck_grp-&gt;lck_grp_stat.lck_grp_rw_stat.lck_grp_rw_wait_max;
		lockgroup_info-&gt;lock_rw_wait_cum = lck_grp-&gt;lck_grp_stat.lck_grp_rw_stat.lck_grp_rw_wait_cum;

		(<span class="enscript-type">void</span>) strncpy(lockgroup_info-&gt;lockgroup_name,lck_grp-&gt;lck_grp_name, LOCKGROUP_MAX_NAME);

		lck_grp = (lck_grp_t *)(queue_next((queue_entry_t)(lck_grp)));
		lockgroup_info++;
	}

	*lockgroup_infoCntp = lck_grp_cnt;
	lck_mtx_unlock(&amp;lck_grp_lock);

	used = (*lockgroup_infoCntp) * <span class="enscript-keyword">sizeof</span> *lockgroup_info;

	<span class="enscript-keyword">if</span> (used != lockgroup_info_size)
		bzero((<span class="enscript-type">char</span> *) lockgroup_info, lockgroup_info_size - used);

	kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t)lockgroup_info_addr,
			   (vm_map_size_t)lockgroup_info_size, TRUE, &amp;copy);
	assert(kr == KERN_SUCCESS);

	*lockgroup_infop = (lockgroup_info_t *) copy;

	<span class="enscript-keyword">return</span>(KERN_SUCCESS);
}

</pre>
<hr />
</body></html>