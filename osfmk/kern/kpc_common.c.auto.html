<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kpc_common.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kpc_common.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kperf/buffer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kpc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kperf/kperf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kperf/sample.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kperf/context.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kperf/action.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;chud/chud_xnu.h&gt;</span>

uint32_t kpc_actionid[KPC_MAX_COUNTERS];

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COUNTERBUF_SIZE_PER_CPU</span> (KPC_MAX_COUNTERS * sizeof(uint64_t))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COUNTERBUF_SIZE</span> (machine_info.logical_cpu_max * \
                         COUNTERBUF_SIZE_PER_CPU)

<span class="enscript-comment">/* locks */</span>
<span class="enscript-type">static</span> lck_grp_attr_t *kpc_config_lckgrp_attr = NULL;
<span class="enscript-type">static</span> lck_grp_t      *kpc_config_lckgrp = NULL;
<span class="enscript-type">static</span> lck_mtx_t       kpc_config_lock;

<span class="enscript-comment">/* state specifying if all counters have been requested by kperf */</span>
<span class="enscript-type">static</span> boolean_t force_all_ctrs = FALSE;

<span class="enscript-comment">/* power manager */</span>
<span class="enscript-type">static</span> kpc_pm_handler_t		kpc_pm_handler;
<span class="enscript-type">static</span> boolean_t		kpc_pm_has_custom_config;
<span class="enscript-type">static</span> uint64_t			kpc_pm_pmc_mask;

<span class="enscript-type">void</span> <span class="enscript-function-name">kpc_common_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>
<span class="enscript-function-name">kpc_common_init</span>(<span class="enscript-type">void</span>)
{
	kpc_config_lckgrp_attr = lck_grp_attr_alloc_init();
	kpc_config_lckgrp = lck_grp_alloc_init(<span class="enscript-string">&quot;kpc&quot;</span>, kpc_config_lckgrp_attr);
	lck_mtx_init(&amp;kpc_config_lock, kpc_config_lckgrp, LCK_ATTR_NULL);
}

boolean_t
<span class="enscript-function-name">kpc_register_cpu</span>(<span class="enscript-type">struct</span> cpu_data *cpu_data)
{
	assert(cpu_data);
	assert(cpu_data-&gt;cpu_kpc_buf[0] == NULL);
	assert(cpu_data-&gt;cpu_kpc_buf[1] == NULL);
	assert(cpu_data-&gt;cpu_kpc_shadow == NULL);
	assert(cpu_data-&gt;cpu_kpc_reload == NULL);

	<span class="enscript-comment">/*
	 * Buffers allocated through kpc_counterbuf_alloc() are large enough to
	 * store all PMCs values from all CPUs. This mimics the userspace API.
	 * This does not suit well with the per-CPU kpc buffers, since:
	 * 	1. Buffers don't need to be this large.
	 * 	2. The actual number of CPUs is not known at this point.
	 *
	 * CPUs are asked to callout into kpc when being registered, we'll
	 * allocate the memory here.
	 */</span>

	<span class="enscript-keyword">if</span> ((cpu_data-&gt;cpu_kpc_buf[0] = kalloc(COUNTERBUF_SIZE_PER_CPU)) == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
	<span class="enscript-keyword">if</span> ((cpu_data-&gt;cpu_kpc_buf[1] = kalloc(COUNTERBUF_SIZE_PER_CPU)) == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
	<span class="enscript-keyword">if</span> ((cpu_data-&gt;cpu_kpc_shadow = kalloc(COUNTERBUF_SIZE_PER_CPU)) == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
	<span class="enscript-keyword">if</span> ((cpu_data-&gt;cpu_kpc_reload = kalloc(COUNTERBUF_SIZE_PER_CPU)) == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;

	memset(cpu_data-&gt;cpu_kpc_buf[0], 0, COUNTERBUF_SIZE_PER_CPU);
	memset(cpu_data-&gt;cpu_kpc_buf[1], 0, COUNTERBUF_SIZE_PER_CPU);
	memset(cpu_data-&gt;cpu_kpc_shadow, 0, COUNTERBUF_SIZE_PER_CPU);
	memset(cpu_data-&gt;cpu_kpc_reload, 0, COUNTERBUF_SIZE_PER_CPU);

	<span class="enscript-comment">/* success */</span>
	<span class="enscript-keyword">return</span> TRUE;

<span class="enscript-reference">error</span>:
	kfree(cpu_data-&gt;cpu_kpc_buf[0], COUNTERBUF_SIZE_PER_CPU);
	kfree(cpu_data-&gt;cpu_kpc_buf[1], COUNTERBUF_SIZE_PER_CPU);
	kfree(cpu_data-&gt;cpu_kpc_shadow, COUNTERBUF_SIZE_PER_CPU);
	kfree(cpu_data-&gt;cpu_kpc_reload, COUNTERBUF_SIZE_PER_CPU);

	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kpc_task_set_forced_all_ctrs</span>(task_t task, boolean_t state)
{
	assert(task);

	task_lock(task);
	<span class="enscript-keyword">if</span> (state)
		task-&gt;t_chud |= TASK_KPC_FORCED_ALL_CTRS;
	<span class="enscript-keyword">else</span>
		task-&gt;t_chud &amp;= ~TASK_KPC_FORCED_ALL_CTRS;
	task_unlock(task);
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">kpc_task_get_forced_all_ctrs</span>(task_t task)
{
	assert(task);
	<span class="enscript-keyword">return</span> task-&gt;t_chud &amp; TASK_KPC_FORCED_ALL_CTRS ? TRUE : FALSE;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kpc_force_all_ctrs</span>(task_t task, <span class="enscript-type">int</span> val)
{
	boolean_t new_state = val ? TRUE : FALSE;
	boolean_t old_state = kpc_get_force_all_ctrs();

	<span class="enscript-comment">/*
	 * Refuse to do the operation if the counters are already forced by
	 * another task.
	 */</span>
	<span class="enscript-keyword">if</span> (kpc_get_force_all_ctrs() &amp;&amp; !kpc_task_get_forced_all_ctrs(task))
		<span class="enscript-keyword">return</span> EACCES;

	<span class="enscript-comment">/* nothing to do if the state is not changing */</span>
	<span class="enscript-keyword">if</span> (old_state == new_state)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-comment">/* notify the power manager */</span>
	<span class="enscript-keyword">if</span> (kpc_pm_handler)
		kpc_pm_handler( new_state ? FALSE : TRUE );

	<span class="enscript-comment">/* update the task bits */</span>
	kpc_task_set_forced_all_ctrs(task, val);

	<span class="enscript-comment">/* update the internal state */</span>
	force_all_ctrs = val;

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kpc_get_force_all_ctrs</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> force_all_ctrs;
}

boolean_t
<span class="enscript-function-name">kpc_multiple_clients</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> kpc_pm_handler != NULL;
}

boolean_t
<span class="enscript-function-name">kpc_controls_fixed_counters</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> !kpc_pm_handler || force_all_ctrs || !kpc_pm_has_custom_config;
}

boolean_t
<span class="enscript-function-name">kpc_controls_counter</span>(uint32_t ctr)
{
	uint64_t pmc_mask = 0ULL;

	assert(ctr &lt; (kpc_fixed_count() + kpc_configurable_count()));

	<span class="enscript-keyword">if</span> (ctr &lt; kpc_fixed_count())
		<span class="enscript-keyword">return</span> kpc_controls_fixed_counters();

	<span class="enscript-comment">/*
	 * By default kpc manages all PMCs, but if the Power Manager registered
	 * with custom_config=TRUE, the Power Manager manages its reserved PMCs.
	 * However, kpc takes ownership back if a task acquired all PMCs via
	 * force_all_ctrs.
	 */</span>
	pmc_mask = (1ULL &lt;&lt; (ctr - kpc_fixed_count()));
	<span class="enscript-keyword">if</span> ((pmc_mask &amp; kpc_pm_pmc_mask) &amp;&amp; kpc_pm_has_custom_config &amp;&amp; !force_all_ctrs)
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">return</span> TRUE;
}

uint32_t
<span class="enscript-function-name">kpc_get_running</span>(<span class="enscript-type">void</span>)
{
	uint64_t pmc_mask = 0;
	uint32_t cur_state = 0;

	<span class="enscript-keyword">if</span> (kpc_is_running_fixed())
		cur_state |= KPC_CLASS_FIXED_MASK;

	pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_CONFIGURABLE_MASK);
	<span class="enscript-keyword">if</span> (kpc_is_running_configurable(pmc_mask))
		cur_state |= KPC_CLASS_CONFIGURABLE_MASK;

	pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_POWER_MASK);
	<span class="enscript-keyword">if</span> ((pmc_mask != 0) &amp;&amp; kpc_is_running_configurable(pmc_mask))
		cur_state |= KPC_CLASS_POWER_MASK;

	<span class="enscript-keyword">return</span> cur_state;
}

<span class="enscript-comment">/* may be called from an IPI */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kpc_get_curcpu_counters</span>(uint32_t classes, <span class="enscript-type">int</span> *curcpu, uint64_t *buf)
{
	<span class="enscript-type">int</span> enabled=0, offset=0;
	uint64_t pmc_mask = 0ULL;

	assert(buf);

	enabled = ml_set_interrupts_enabled(FALSE);

	<span class="enscript-comment">/* grab counters and CPU number as close as possible */</span>
	<span class="enscript-keyword">if</span> (curcpu)
		*curcpu = current_processor()-&gt;cpu_id;

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_FIXED_MASK) {
		kpc_get_fixed_counters(&amp;buf[offset]);
		offset += kpc_get_counter_count(KPC_CLASS_FIXED_MASK);
	}

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_CONFIGURABLE_MASK) {
		pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_CONFIGURABLE_MASK);
		kpc_get_configurable_counters(&amp;buf[offset], pmc_mask);
		offset += kpc_popcount(pmc_mask);
	}

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_POWER_MASK) {
		pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_POWER_MASK);
		kpc_get_configurable_counters(&amp;buf[offset], pmc_mask);
		offset += kpc_popcount(pmc_mask);
	}

	ml_set_interrupts_enabled(enabled);

	<span class="enscript-keyword">return</span> offset;
}

<span class="enscript-comment">/* generic counter reading function, public api */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kpc_get_cpu_counters</span>(boolean_t all_cpus, uint32_t classes,
                     <span class="enscript-type">int</span> *curcpu, uint64_t *buf)
{
	assert(buf);

	<span class="enscript-comment">/*
	 * Unlike reading the current CPU counters, reading counters from all
	 * CPUs is architecture dependent. This allows kpc to make the most of
	 * the platform if memory mapped registers is supported.
	 */</span>
	<span class="enscript-keyword">if</span> (all_cpus)
		<span class="enscript-keyword">return</span> kpc_get_all_cpus_counters(classes, curcpu, buf);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> kpc_get_curcpu_counters(classes, curcpu, buf);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kpc_get_shadow_counters</span>(boolean_t all_cpus, uint32_t classes,
                        <span class="enscript-type">int</span> *curcpu, uint64_t *buf)
{
	<span class="enscript-type">int</span> curcpu_id = current_processor()-&gt;cpu_id;
	uint32_t cfg_count = kpc_configurable_count(), offset = 0;
	uint64_t pmc_mask = 0ULL;
	boolean_t enabled;

	assert(buf);

	enabled = ml_set_interrupts_enabled(FALSE);

	curcpu_id = current_processor()-&gt;cpu_id;
	<span class="enscript-keyword">if</span> (curcpu)
		*curcpu = curcpu_id;

	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> cpu = 0; cpu &lt; machine_info.logical_cpu_max; ++cpu) {
		<span class="enscript-comment">/* filter if the caller did not request all cpus */</span>
		<span class="enscript-keyword">if</span> (!all_cpus &amp;&amp; (cpu != curcpu_id))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_FIXED_MASK) {
			uint32_t count = kpc_get_counter_count(KPC_CLASS_FIXED_MASK);
			memcpy(&amp;buf[offset], &amp;FIXED_SHADOW_CPU(cpu, 0), count * <span class="enscript-keyword">sizeof</span>(uint64_t));
			offset += count;
		}

		<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_CONFIGURABLE_MASK) {
			pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_CONFIGURABLE_MASK);

			<span class="enscript-keyword">for</span> (uint32_t cfg_ctr = 0; cfg_ctr &lt; cfg_count; ++cfg_ctr)
				<span class="enscript-keyword">if</span> ((1ULL &lt;&lt; cfg_ctr) &amp; pmc_mask)
					buf[offset++] = CONFIGURABLE_SHADOW_CPU(cpu, cfg_ctr);
		}

		<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_POWER_MASK) {
			pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_POWER_MASK);

			<span class="enscript-keyword">for</span> (uint32_t cfg_ctr = 0; cfg_ctr &lt; cfg_count; ++cfg_ctr)
				<span class="enscript-keyword">if</span> ((1ULL &lt;&lt; cfg_ctr) &amp; pmc_mask)
					buf[offset++] = CONFIGURABLE_SHADOW_CPU(cpu, cfg_ctr);
		}
	}

	ml_set_interrupts_enabled(enabled);

	<span class="enscript-keyword">return</span> offset;
}

uint32_t
<span class="enscript-function-name">kpc_get_counter_count</span>(uint32_t classes)
{
	uint32_t count = 0;

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_FIXED_MASK)
		count += kpc_fixed_count();

	<span class="enscript-keyword">if</span> (classes &amp; (KPC_CLASS_CONFIGURABLE_MASK | KPC_CLASS_POWER_MASK)) {
		uint64_t pmc_msk = kpc_get_configurable_pmc_mask(classes);
		uint32_t pmc_cnt = kpc_popcount(pmc_msk);
		count += pmc_cnt;
	}

	<span class="enscript-keyword">return</span> count;
}

uint32_t
<span class="enscript-function-name">kpc_get_config_count</span>(uint32_t classes)
{
	uint32_t count = 0;

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_FIXED_MASK)
		count += kpc_fixed_config_count();

	<span class="enscript-keyword">if</span> (classes &amp; (KPC_CLASS_CONFIGURABLE_MASK | KPC_CLASS_POWER_MASK)) {
		uint64_t pmc_mask = kpc_get_configurable_pmc_mask(classes);
		count += kpc_configurable_config_count(pmc_mask);
	}

	<span class="enscript-keyword">if</span> ((classes &amp; KPC_CLASS_RAWPMU_MASK) &amp;&amp; !kpc_multiple_clients())
		count += kpc_rawpmu_config_count();

	<span class="enscript-keyword">return</span> count;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kpc_get_config</span>(uint32_t classes, kpc_config_t *current_config)
{
	uint32_t count = 0;

	assert(current_config);

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_FIXED_MASK) {
		kpc_get_fixed_config(&amp;current_config[count]);
		count += kpc_get_config_count(KPC_CLASS_FIXED_MASK);
	}

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_CONFIGURABLE_MASK) {
		uint64_t pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_CONFIGURABLE_MASK);
		kpc_get_configurable_config(&amp;current_config[count], pmc_mask);
		count += kpc_get_config_count(KPC_CLASS_CONFIGURABLE_MASK);
	}

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_POWER_MASK) {
		uint64_t pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_POWER_MASK);
		kpc_get_configurable_config(&amp;current_config[count], pmc_mask);
		count += kpc_get_config_count(KPC_CLASS_POWER_MASK);
	}

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_RAWPMU_MASK)
	{
		<span class="enscript-comment">// Client shouldn't ask for config words that aren't available.
</span>		<span class="enscript-comment">// Most likely, they'd misinterpret the returned buffer if we
</span>		<span class="enscript-comment">// allowed this.
</span>		<span class="enscript-keyword">if</span>( kpc_multiple_clients() )
		{
			<span class="enscript-keyword">return</span> EPERM;
		}
		kpc_get_rawpmu_config(&amp;current_config[count]);
		count += kpc_get_config_count(KPC_CLASS_RAWPMU_MASK);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kpc_set_config</span>(uint32_t classes, kpc_config_t *configv)
{
	<span class="enscript-type">struct</span> kpc_config_remote mp_config = {
		.classes = classes, .configv = configv,
		.pmc_mask = kpc_get_configurable_pmc_mask(classes)
	};

	assert(configv);

	<span class="enscript-comment">/* don't allow RAWPMU configuration when sharing counters */</span>
	<span class="enscript-keyword">if</span> ((classes &amp; KPC_CLASS_RAWPMU_MASK) &amp;&amp; kpc_multiple_clients()) {
		<span class="enscript-keyword">return</span> EPERM;
	}

	<span class="enscript-comment">/* no clients have the right to modify both classes */</span>
	<span class="enscript-keyword">if</span> ((classes &amp; (KPC_CLASS_CONFIGURABLE_MASK)) &amp;&amp;
	    (classes &amp; (KPC_CLASS_POWER_MASK)))
	{
		<span class="enscript-keyword">return</span> EPERM;
	}

	lck_mtx_lock(&amp;kpc_config_lock);

	<span class="enscript-comment">/* translate the power class for the machine layer */</span>
	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_POWER_MASK)
		mp_config.classes |= KPC_CLASS_CONFIGURABLE_MASK;

	kpc_set_config_arch( &amp;mp_config );

	lck_mtx_unlock(&amp;kpc_config_lock);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/* allocate a buffer large enough for all possible counters */</span>
uint64_t *
<span class="enscript-function-name">kpc_counterbuf_alloc</span>(<span class="enscript-type">void</span>)
{
	uint64_t *buf = NULL;

	buf = kalloc(COUNTERBUF_SIZE);
	<span class="enscript-keyword">if</span> (buf) {
		bzero(buf, COUNTERBUF_SIZE);
	}

	<span class="enscript-keyword">return</span> buf;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kpc_counterbuf_free</span>(uint64_t *buf)
{
	<span class="enscript-keyword">if</span> (buf) {
		kfree(buf, COUNTERBUF_SIZE);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kpc_sample_kperf</span>(uint32_t actionid)
{
	<span class="enscript-type">struct</span> kperf_sample sbuf;
	<span class="enscript-type">struct</span> kperf_context ctx;
	task_t task = NULL;
	<span class="enscript-type">int</span> r;

	BUF_DATA1(PERF_KPC_HNDLR | DBG_FUNC_START, 0);

	ctx.cur_pid = 0;
	ctx.cur_thread = current_thread();

	task = chudxnu_task_for_thread(ctx.cur_thread);
	<span class="enscript-keyword">if</span> (task)
		ctx.cur_pid = chudxnu_pid_for_task(task);

	ctx.trigger_type = TRIGGER_TYPE_PMI;
	ctx.trigger_id = 0;

	r = kperf_sample(&amp;sbuf, &amp;ctx, actionid, SAMPLE_FLAG_PEND_USER);

	BUF_INFO1(PERF_KPC_HNDLR | DBG_FUNC_END, r);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">kpc_set_period</span>(uint32_t classes, uint64_t *val)
{
	<span class="enscript-type">struct</span> kpc_config_remote mp_config = {
		.classes = classes, .configv = val,
		.pmc_mask = kpc_get_configurable_pmc_mask(classes)
	};

	assert(val);

	<span class="enscript-comment">/* no clients have the right to modify both classes */</span>
	<span class="enscript-keyword">if</span> ((classes &amp; (KPC_CLASS_CONFIGURABLE_MASK)) &amp;&amp;
	    (classes &amp; (KPC_CLASS_POWER_MASK)))
	{
		<span class="enscript-keyword">return</span> EPERM;
	}

	lck_mtx_lock(&amp;kpc_config_lock);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">FIXED_COUNTER_SHADOW</span>
	<span class="enscript-keyword">if</span> ((classes &amp; KPC_CLASS_FIXED_MASK) &amp;&amp; !kpc_controls_fixed_counters()) {
		lck_mtx_unlock(&amp;kpc_config_lock);
		<span class="enscript-keyword">return</span> EPERM;
	}
# <span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_FIXED_MASK) {
		lck_mtx_unlock(&amp;kpc_config_lock);
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* translate the power class for the machine layer */</span>
	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_POWER_MASK)
		mp_config.classes |= KPC_CLASS_CONFIGURABLE_MASK;

	kprintf(<span class="enscript-string">&quot;setting period %u\n&quot;</span>, classes);
	kpc_set_period_arch( &amp;mp_config );

	lck_mtx_unlock(&amp;kpc_config_lock);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kpc_get_period</span>(uint32_t classes, uint64_t *val)
{
	uint32_t count = 0 ;
	uint64_t pmc_mask = 0ULL;

	assert(val);

	lck_mtx_lock(&amp;kpc_config_lock);

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_FIXED_MASK) {
		<span class="enscript-comment">/* convert reload values to periods */</span>
		count = kpc_get_counter_count(KPC_CLASS_FIXED_MASK);
		<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; count; ++i)
			*val++ = kpc_fixed_max() - FIXED_RELOAD(i);
	}

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_CONFIGURABLE_MASK) {
		pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_CONFIGURABLE_MASK);

		<span class="enscript-comment">/* convert reload values to periods */</span>
		count = kpc_configurable_count();
		<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; count; ++i)
			<span class="enscript-keyword">if</span> ((1ULL &lt;&lt; i) &amp; pmc_mask)
				*val++ = kpc_configurable_max() - CONFIGURABLE_RELOAD(i);
	}

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_POWER_MASK) {
		pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_POWER_MASK);

		<span class="enscript-comment">/* convert reload values to periods */</span>
		count = kpc_configurable_count();
		<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; count; ++i)
			<span class="enscript-keyword">if</span> ((1ULL &lt;&lt; i) &amp; pmc_mask)
				*val++ = kpc_configurable_max() - CONFIGURABLE_RELOAD(i);
	}

	lck_mtx_unlock(&amp;kpc_config_lock);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kpc_set_actionid</span>(uint32_t classes, uint32_t *val)
{
	uint32_t count = 0;
	uint64_t pmc_mask = 0ULL;

	assert(val);

	<span class="enscript-comment">/* NOTE: what happens if a pmi occurs while actionids are being
	 * set is undefined. */</span>
	lck_mtx_lock(&amp;kpc_config_lock);

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_FIXED_MASK) {
		count = kpc_get_counter_count(KPC_CLASS_FIXED_MASK);
		memcpy(&amp;FIXED_ACTIONID(0), val, count*<span class="enscript-keyword">sizeof</span>(uint32_t));
		val += count;
	}

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_CONFIGURABLE_MASK) {
		pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_CONFIGURABLE_MASK);

		count = kpc_configurable_count();
		<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; count; ++i)
			<span class="enscript-keyword">if</span> ((1ULL &lt;&lt; i) &amp; pmc_mask)
				CONFIGURABLE_ACTIONID(i) = *val++;
	}

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_POWER_MASK) {
		pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_POWER_MASK);

		count = kpc_configurable_count();
		<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; count; ++i)
			<span class="enscript-keyword">if</span> ((1ULL &lt;&lt; i) &amp; pmc_mask)
				CONFIGURABLE_ACTIONID(i) = *val++;
	}

	lck_mtx_unlock(&amp;kpc_config_lock);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">kpc_get_actionid</span>(uint32_t classes, uint32_t *val)
{
	uint32_t count = 0;
	uint64_t pmc_mask = 0ULL;

	assert(val);

	lck_mtx_lock(&amp;kpc_config_lock);

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_FIXED_MASK) {
		count = kpc_get_counter_count(KPC_CLASS_FIXED_MASK);
		memcpy(val, &amp;FIXED_ACTIONID(0), count*<span class="enscript-keyword">sizeof</span>(uint32_t));
		val += count;
	}

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_CONFIGURABLE_MASK) {
		pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_CONFIGURABLE_MASK);

		count = kpc_configurable_count();
		<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; count; ++i)
			<span class="enscript-keyword">if</span> ((1ULL &lt;&lt; i) &amp; pmc_mask)
				*val++ = CONFIGURABLE_ACTIONID(i);
	}

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_POWER_MASK) {
		pmc_mask = kpc_get_configurable_pmc_mask(KPC_CLASS_POWER_MASK);

		count = kpc_configurable_count();
		<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; count; ++i)
			<span class="enscript-keyword">if</span> ((1ULL &lt;&lt; i) &amp; pmc_mask)
				*val++ = CONFIGURABLE_ACTIONID(i);
	}

	lck_mtx_unlock(&amp;kpc_config_lock);

	<span class="enscript-keyword">return</span> 0;

}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kpc_set_running</span>(uint32_t classes)
{
	uint32_t all_cfg_classes = KPC_CLASS_CONFIGURABLE_MASK | KPC_CLASS_POWER_MASK;
	<span class="enscript-type">struct</span> kpc_running_remote mp_config = {
		.classes = classes, .cfg_target_mask= 0ULL, .cfg_state_mask = 0ULL
	};

	<span class="enscript-comment">/* target all available PMCs */</span>
	mp_config.cfg_target_mask = kpc_get_configurable_pmc_mask(all_cfg_classes);

	<span class="enscript-comment">/* translate the power class for the machine layer */</span>
	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_POWER_MASK)
		mp_config.classes |= KPC_CLASS_CONFIGURABLE_MASK;

	<span class="enscript-comment">/* generate the state of each configurable PMCs */</span>
	mp_config.cfg_state_mask = kpc_get_configurable_pmc_mask(classes);

	<span class="enscript-keyword">return</span> kpc_set_running_arch(&amp;mp_config);
}

boolean_t
<span class="enscript-function-name">kpc_register_pm_handler</span>(kpc_pm_handler_t handler)
{
	<span class="enscript-keyword">return</span> kpc_reserve_pm_counters(0x38, handler, TRUE);
}

boolean_t
<span class="enscript-function-name">kpc_reserve_pm_counters</span>(uint64_t pmc_mask, kpc_pm_handler_t handler,
                        boolean_t custom_config)
{
	uint64_t all_mask = (1ULL &lt;&lt; kpc_configurable_count()) - 1;
	uint64_t req_mask = 0ULL;

	<span class="enscript-comment">/* pre-condition */</span>
	assert(handler != NULL);
	assert(kpc_pm_handler == NULL);

	<span class="enscript-comment">/* check number of counters requested */</span>
	req_mask = (pmc_mask &amp; all_mask);
	assert(kpc_popcount(req_mask) &lt;= kpc_configurable_count());

	<span class="enscript-comment">/* save the power manager states */</span>
	kpc_pm_has_custom_config = custom_config;
	kpc_pm_pmc_mask = req_mask;
	kpc_pm_handler = handler;

	printf(<span class="enscript-string">&quot;kpc: pm registered pmc_mask=%llx custom_config=%d\n&quot;</span>,
	       req_mask, custom_config);

	<span class="enscript-comment">/* post-condition */</span>
	{
		uint32_t cfg_count = kpc_get_counter_count(KPC_CLASS_CONFIGURABLE_MASK);
		uint32_t pwr_count = kpc_popcount(kpc_pm_pmc_mask);
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cfg_count</span>, <span class="enscript-variable-name">pwr_count</span>)
		assert((cfg_count + pwr_count) == kpc_configurable_count());
	}

	<span class="enscript-keyword">return</span> force_all_ctrs ? FALSE : TRUE;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kpc_release_pm_counters</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* pre-condition */</span>
	assert(kpc_pm_handler != NULL);

	<span class="enscript-comment">/* release the counters */</span>
	kpc_pm_has_custom_config = FALSE;
	kpc_pm_pmc_mask = 0ULL;
	kpc_pm_handler = NULL;

	printf(<span class="enscript-string">&quot;kpc: pm released counters\n&quot;</span>);

	<span class="enscript-comment">/* post-condition */</span>
	assert(kpc_get_counter_count(KPC_CLASS_CONFIGURABLE_MASK) == kpc_configurable_count());
}

uint8_t
<span class="enscript-function-name">kpc_popcount</span>(uint64_t value)
{
	<span class="enscript-keyword">return</span> __builtin_popcountll(value);
}

uint64_t
<span class="enscript-function-name">kpc_get_configurable_pmc_mask</span>(uint32_t classes)
{
	uint32_t configurable_count = kpc_configurable_count();
	uint64_t cfg_mask = 0ULL, pwr_mask = 0ULL, all_cfg_pmcs_mask = 0ULL;

	<span class="enscript-comment">/* not configurable classes or no configurable counters */</span>
	<span class="enscript-keyword">if</span> (((classes &amp; (KPC_CLASS_CONFIGURABLE_MASK | KPC_CLASS_POWER_MASK)) == 0) ||
	    (configurable_count == 0))
	{
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	assert(configurable_count &lt; 64);
	all_cfg_pmcs_mask = (1ULL &lt;&lt; configurable_count) - 1;

	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_CONFIGURABLE_MASK) {
		<span class="enscript-keyword">if</span> (force_all_ctrs == TRUE)
			cfg_mask |= all_cfg_pmcs_mask;
		<span class="enscript-keyword">else</span>
			cfg_mask |= (~kpc_pm_pmc_mask) &amp; all_cfg_pmcs_mask;
	}

	<span class="enscript-comment">/*
	 * The power class exists iff:
	 * 	- No tasks acquired all PMCs
	 * 	- PM registered and uses kpc to interact with PMCs
	 */</span>
	<span class="enscript-keyword">if</span> ((force_all_ctrs == FALSE) &amp;&amp;
	    (kpc_pm_handler != NULL) &amp;&amp;
	    (kpc_pm_has_custom_config == FALSE) &amp;&amp;
	    (classes &amp; KPC_CLASS_POWER_MASK))
	{
		pwr_mask |= kpc_pm_pmc_mask &amp; all_cfg_pmcs_mask;
	}

<span class="enscript-reference">exit</span>:
	<span class="enscript-comment">/* post-conditions */</span>
	assert( ((cfg_mask | pwr_mask) &amp; (~all_cfg_pmcs_mask)) == 0 );
	assert( kpc_popcount(cfg_mask | pwr_mask) &lt;= kpc_configurable_count() );
	assert( (cfg_mask &amp; pwr_mask) == 0ULL );

	<span class="enscript-keyword">return</span> cfg_mask | pwr_mask;
}

</pre>
<hr />
</body></html>