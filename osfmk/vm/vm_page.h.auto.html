<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_page.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_page.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>
<span class="enscript-comment">/*
 *	File:	vm/vm_page.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Date:	1985
 *
 *	Resident memory system definitions.
 */</span>

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">_VM_VM_PAGE_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_VM_VM_PAGE_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_options.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/macro_help.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>


<span class="enscript-comment">/* 
 * VM_PAGE_MIN_SPECULATIVE_AGE_Q through VM_PAGE_MAX_SPECULATIVE_AGE_Q
 * represents a set of aging bins that are 'protected'...
 *
 * VM_PAGE_SPECULATIVE_AGED_Q is a list of the speculative pages that have
 * not yet been 'claimed' but have been aged out of the protective bins
 * this occurs in vm_page_speculate when it advances to the next bin 
 * and discovers that it is still occupied... at that point, all of the
 * pages in that bin are moved to the VM_PAGE_SPECULATIVE_AGED_Q.  the pages
 * in that bin are all guaranteed to have reached at least the maximum age
 * we allow for a protected page... they can be older if there is no
 * memory pressure to pull them from the bin, or there are no new speculative pages
 * being generated to push them out.
 * this list is the one that vm_pageout_scan will prefer when looking 
 * for pages to move to the underweight free list
 * 
 * VM_PAGE_MAX_SPECULATIVE_AGE_Q * VM_PAGE_SPECULATIVE_Q_AGE_MS
 * defines the amount of time a speculative page is normally
 * allowed to live in the 'protected' state (i.e. not available
 * to be stolen if vm_pageout_scan is running and looking for
 * pages)...  however, if the total number of speculative pages
 * in the protected state exceeds our limit (defined in vm_pageout.c)
 * and there are none available in VM_PAGE_SPECULATIVE_AGED_Q, then
 * vm_pageout_scan is allowed to steal pages from the protected
 * bucket even if they are underage.
 *
 * vm_pageout_scan is also allowed to pull pages from a protected
 * bin if the bin has reached the &quot;age of consent&quot; we've set
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_PAGE_MAX_SPECULATIVE_AGE_Q</span>	10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_PAGE_MIN_SPECULATIVE_AGE_Q</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_PAGE_SPECULATIVE_AGED_Q</span>	0

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_PAGE_SPECULATIVE_Q_AGE_MS</span>	500

<span class="enscript-type">struct</span> vm_speculative_age_q {
	<span class="enscript-comment">/*
	 * memory queue for speculative pages via clustered pageins
	 */</span>
        queue_head_t	age_q;
        mach_timespec_t	age_ts;
};



<span class="enscript-type">extern</span>
<span class="enscript-type">struct</span> vm_speculative_age_q	vm_page_queue_speculative[];

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>			speculative_steal_index;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>			speculative_age_index;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		vm_page_speculative_q_age_ms;


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_PAGE_COMPRESSOR_COUNT</span>	(compressor_object-&gt;resident_page_count)

<span class="enscript-comment">/*
 *	Management of resident (logical) pages.
 *
 *	A small structure is kept for each resident
 *	page, indexed by page number.  Each structure
 *	is an element of several lists:
 *
 *		A hash table bucket used to quickly
 *		perform object/offset lookups
 *
 *		A list of all pages for a given object,
 *		so they can be quickly deactivated at
 *		time of deallocation.
 *
 *		An ordered list of pages due for pageout.
 *
 *	In addition, the structure contains the object
 *	and offset to which this page belongs (for pageout),
 *	and sundry status bits.
 *
 *	Fields in this structure are locked either by the lock on the
 *	object that the page belongs to (O) or by the lock on the page
 *	queues (P).  [Some fields require that both locks be held to
 *	change that field; holding either lock is sufficient to read.]
 */</span>


#<span class="enscript-reference">if</span>    <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)

<span class="enscript-comment">/*
 * in order to make the size of a vm_page_t 64 bytes (cache line size for both arm64 and x86_64)
 * we'll keep the next_m pointer packed... as long as the kernel virtual space where we allocate
 * vm_page_t's from doesn't span more then 256 Gbytes, we're safe.   There are live tests in the
 * vm_page_t array allocation and the zone init code to determine if we can safely pack and unpack
 * pointers from the 2 ends of these spaces
 */</span>
<span class="enscript-type">typedef</span> uint32_t	vm_page_packed_t;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VM_PAGE_PACK_PTR</span>(m)	(!(m) ? (vm_page_packed_t)0 : ((vm_page_packed_t)((uintptr_t)(((uintptr_t)(m) - (uintptr_t) VM_MIN_KERNEL_AND_KEXT_ADDRESS)) &gt;&gt; 6)))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VM_PAGE_UNPACK_PTR</span>(p)	(!(p) ? VM_PAGE_NULL : ((vm_page_t)((((uintptr_t)(p)) &lt;&lt; 6) + (uintptr_t) VM_MIN_KERNEL_AND_KEXT_ADDRESS)))

#<span class="enscript-reference">else</span>

<span class="enscript-comment">/*
 * we can't do the packing trick on 32 bit architectures, so 
 * just turn the macros into noops.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> vm_page	*vm_page_packed_t;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VM_PAGE_PACK_PTR</span>(m)	((vm_page_packed_t)(m))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VM_PAGE_UNPACK_PTR</span>(p)	((vm_page_t)(p))

#<span class="enscript-reference">endif</span>


<span class="enscript-type">struct</span> vm_page {
	queue_chain_t	pageq;		<span class="enscript-comment">/* queue info for FIFO */</span>
					<span class="enscript-comment">/* queue or free list (P) */</span>

	queue_chain_t	listq;		<span class="enscript-comment">/* all pages in same object (O) */</span>

	vm_object_offset_t offset;	<span class="enscript-comment">/* offset into that object (O,P) */</span>
	vm_object_t	object;		<span class="enscript-comment">/* which object am I in (O&amp;P) */</span>

	vm_page_packed_t next_m;	<span class="enscript-comment">/* VP bucket link (O) */</span>
	<span class="enscript-comment">/*
	 * The following word of flags is protected
	 * by the &quot;page queues&quot; lock.
	 *
	 * we use the 'wire_count' field to store the local
	 * queue id if local queues are enabled...
	 * see the comments at 'vm_page_queues_remove' as to
	 * why this is safe to do
	 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">local_id</span> wire_count
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	wire_count:16,	<span class="enscript-comment">/* how many wired down maps use me? (O&amp;P) */</span>
	<span class="enscript-comment">/* boolean_t */</span>	active:1,	<span class="enscript-comment">/* page is in active list (P) */</span>
			<span class="enscript-reference">inactive</span>:1,	<span class="enscript-comment">/* page is in inactive list (P) */</span>
			<span class="enscript-reference">clean_queue</span>:1,	<span class="enscript-comment">/* page is in pre-cleaned list (P) */</span>
		        <span class="enscript-reference">local</span>:1,	<span class="enscript-comment">/* page is in one of the local queues (P) */</span>
			<span class="enscript-reference">speculative</span>:1,	<span class="enscript-comment">/* page is in speculative list (P) */</span>
			<span class="enscript-reference">throttled</span>:1,	<span class="enscript-comment">/* pager is not responding or doesn't exist(P) */</span>
			<span class="enscript-reference">free</span>:1,		<span class="enscript-comment">/* page is on free list (P) */</span>
			<span class="enscript-reference">pageout_queue</span>:1,<span class="enscript-comment">/* page is on queue for pageout (P) */</span>
			<span class="enscript-reference">laundry</span>:1,	<span class="enscript-comment">/* page is being cleaned now (P)*/</span>
			<span class="enscript-reference">reference</span>:1,	<span class="enscript-comment">/* page has been used (P) */</span>
			<span class="enscript-reference">gobbled</span>:1,      <span class="enscript-comment">/* page used internally (P) */</span>
			<span class="enscript-reference">private</span>:1,	<span class="enscript-comment">/* Page should not be returned to
					 *  the free list (P) */</span>
			<span class="enscript-reference">no_cache</span>:1,	<span class="enscript-comment">/* page is not to be cached and should
					 * be reused ahead of other pages (P) */</span>

			<span class="enscript-reference">__unused_pageq_bits</span>:3;	<span class="enscript-comment">/* 3 bits available here */</span>

	ppnum_t		phys_page;	<span class="enscript-comment">/* Physical address of page, passed
					 *  to pmap_enter (read-only) */</span>

	<span class="enscript-comment">/*
	 * The following word of flags is protected
	 * by the &quot;VM object&quot; lock.
	 */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
	<span class="enscript-comment">/* boolean_t */</span>	busy:1,		<span class="enscript-comment">/* page is in transit (O) */</span>
			<span class="enscript-reference">wanted</span>:1,	<span class="enscript-comment">/* someone is waiting for page (O) */</span>
			<span class="enscript-reference">tabled</span>:1,	<span class="enscript-comment">/* page is in VP table (O) */</span>
			<span class="enscript-reference">hashed</span>:1,	<span class="enscript-comment">/* page is in vm_page_buckets[]
					   (O) + the bucket lock */</span>
			<span class="enscript-reference">fictitious</span>:1,	<span class="enscript-comment">/* Physical page doesn't exist (O) */</span>
	<span class="enscript-comment">/*
	 * IMPORTANT: the &quot;pmapped&quot;, &quot;xpmapped&quot; and &quot;clustered&quot; bits can be modified while holding the
	 * VM object &quot;shared&quot; lock + the page lock provided through the pmap_lock_phys_page function.
	 * This is done in vm_fault_enter and the CONSUME_CLUSTERED macro.
	 * It's also ok to modify them behind just the VM object &quot;exclusive&quot; lock.
	 */</span>
			<span class="enscript-reference">clustered</span>:1,	<span class="enscript-comment">/* page is not the faulted page (O) or (O-shared AND pmap_page) */</span>
			<span class="enscript-reference">pmapped</span>:1,     	<span class="enscript-comment">/* page has been entered at some
               				 * point into a pmap (O) or (O-shared AND pmap_page) */</span>
		        <span class="enscript-reference">xpmapped</span>:1,	<span class="enscript-comment">/* page has been entered with execute permission (O)
					   or (O-shared AND pmap_page) */</span>

			<span class="enscript-reference">wpmapped</span>:1,     <span class="enscript-comment">/* page has been entered at some
					 * point into a pmap for write (O) */</span>
			<span class="enscript-reference">pageout</span>:1,	<span class="enscript-comment">/* page wired &amp; busy for pageout (O) */</span>
			<span class="enscript-reference">absent</span>:1,	<span class="enscript-comment">/* Data has been requested, but is
					 *  not yet available (O) */</span>
			<span class="enscript-reference">error</span>:1,	<span class="enscript-comment">/* Data manager was unable to provide
					 *  data due to error (O) */</span>
			<span class="enscript-reference">dirty</span>:1,	<span class="enscript-comment">/* Page must be cleaned (O) */</span>
			<span class="enscript-reference">cleaning</span>:1,	<span class="enscript-comment">/* Page clean has begun (O) */</span>
			<span class="enscript-reference">precious</span>:1,	<span class="enscript-comment">/* Page is precious; data must be
					 *  returned even if clean (O) */</span>
			<span class="enscript-reference">overwriting</span>:1,  <span class="enscript-comment">/* Request to unlock has been made
					 * without having data. (O)
					 * [See vm_fault_page_overwrite] */</span>
			<span class="enscript-reference">restart</span>:1,	<span class="enscript-comment">/* Page was pushed higher in shadow
					   chain by copy_call-related pagers;
					   start again at top of chain */</span>
			<span class="enscript-reference">unusual</span>:1,	<span class="enscript-comment">/* Page is absent, error, restart or
					   page locked */</span>
			<span class="enscript-reference">encrypted</span>:1,	<span class="enscript-comment">/* encrypted for secure swap (O) */</span>
			<span class="enscript-reference">encrypted_cleaning</span>:1,	<span class="enscript-comment">/* encrypting page */</span>
			<span class="enscript-reference">cs_validated</span>:1,    <span class="enscript-comment">/* code-signing: page was checked */</span>	
			<span class="enscript-reference">cs_tainted</span>:1,	   <span class="enscript-comment">/* code-signing: page is tainted */</span>
			<span class="enscript-reference">cs_nx</span>:1,	   <span class="enscript-comment">/* code-signing: page is nx */</span>
			<span class="enscript-reference">reusable</span>:1,
		        <span class="enscript-reference">lopage</span>:1,
			<span class="enscript-reference">slid</span>:1,
		        <span class="enscript-reference">compressor</span>:1,	<span class="enscript-comment">/* page owned by compressor pool */</span>
		        <span class="enscript-reference">written_by_kernel</span>:1,	<span class="enscript-comment">/* page was written by kernel (i.e. decompressed) */</span>
			<span class="enscript-reference">__unused_object_bits</span>:4;  <span class="enscript-comment">/* 5 bits available here */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_ENCRYPTED_SWAP</span>	1
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_ENCRYPTED_SWAP</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT_PAGE_DECRYPTED</span>(page) 					\
	MACRO_BEGIN							\
	<span class="enscript-keyword">if</span> ((page)-&gt;encrypted) {					\
		panic(<span class="enscript-string">&quot;VM page %p should not be encrypted here\n&quot;</span>,	\
		      (page));						\
	}								\
	MACRO_END
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* DEBUG_ENCRYPTED_SWAP */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT_PAGE_DECRYPTED</span>(page) assert(!(page)-&gt;encrypted)
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* DEBUG_ENCRYPTED_SWAP */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> vm_page	*vm_page_t;


<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> vm_locks_array {
	<span class="enscript-type">char</span>	pad  __attribute__ ((aligned (64)));
	lck_mtx_t	vm_page_queue_lock2 __attribute__ ((aligned (64)));
	lck_mtx_t	vm_page_queue_free_lock2 __attribute__ ((aligned (64)));
	<span class="enscript-type">char</span>	pad2  __attribute__ ((aligned (64)));
} vm_locks_array_t;


#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PAGE_WIRED</span>(m)	((!(m)-&gt;local &amp;&amp; (m)-&gt;wire_count))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_PAGE_NULL</span>		((vm_page_t) 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NEXT_PAGE</span>(m)		((vm_page_t) (m)-&gt;pageq.next)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NEXT_PAGE_PTR</span>(m)	((vm_page_t *) &amp;(m)-&gt;pageq.next)

<span class="enscript-comment">/*
 * XXX	The unusual bit should not be necessary.  Most of the bit
 * XXX	fields above really want to be masks.
 */</span>

<span class="enscript-comment">/*
 *	For debugging, this macro can be defined to perform
 *	some useful check on a page structure.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PAGE_CHECK</span>(mem)			\
	MACRO_BEGIN				\
	VM_PAGE_QUEUES_ASSERT(mem, 1);		\
	MACRO_END

<span class="enscript-comment">/*     Page coloring:
 *
 *     The free page list is actually n lists, one per color,
 *     where the number of colors is a function of the machine's
 *     cache geometry set at system initialization.  To disable
 *     coloring, set vm_colors to 1 and vm_color_mask to 0.
 *     The boot-arg &quot;colors&quot; may be used to override vm_colors.
 *     Note that there is little harm in having more colors than needed.
 */</span>
 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_COLORS</span>      128
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DEFAULT_COLORS</span>	32

<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_colors;		<span class="enscript-comment">/* must be in range 1..MAX_COLORS */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_color_mask;		<span class="enscript-comment">/* must be (vm_colors-1) */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_cache_geometry_colors; <span class="enscript-comment">/* optimal #colors based on cache geometry */</span>

<span class="enscript-comment">/*
 * Wired memory is a very limited resource and we can't let users exhaust it
 * and deadlock the entire system.  We enforce the following limits:
 * 
 * vm_user_wire_limit (default: all memory minus vm_global_no_user_wire_amount)
 * 	how much memory can be user-wired in one user task
 *
 * vm_global_user_wire_limit (default: same as vm_user_wire_limit)
 * 	how much memory can be user-wired in all user tasks
 *
 * vm_global_no_user_wire_amount (default: VM_NOT_USER_WIREABLE)
 *	how much memory must remain user-unwired at any time
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_NOT_USER_WIREABLE</span> (64*1024*1024)	<span class="enscript-comment">/* 64MB */</span>
<span class="enscript-type">extern</span>
vm_map_size_t	vm_user_wire_limit;
<span class="enscript-type">extern</span>
vm_map_size_t	vm_global_user_wire_limit;
<span class="enscript-type">extern</span>
vm_map_size_t	vm_global_no_user_wire_amount;

<span class="enscript-comment">/*
 *	Each pageable resident page falls into one of three lists:
 *
 *	free	
 *		Available for allocation now.  The free list is
 *		actually an array of lists, one per color.
 *	inactive
 *		Not referenced in any map, but still has an
 *		object/offset-page mapping, and may be dirty.
 *		This is the list of pages that should be
 *		paged out next.  There are actually two
 *		inactive lists, one for pages brought in from
 *		disk or other backing store, and another
 *		for &quot;zero-filled&quot; pages.  See vm_pageout_scan()
 *		for the distinction and usage.
 *	active
 *		A list of pages which have been placed in
 *		at least one physical map.  This list is
 *		ordered, in LRU-like fashion.
 */</span>


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VPL_LOCK_SPIN</span> 1

<span class="enscript-type">struct</span> vpl {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vpl_count;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vpl_internal_count;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vpl_external_count;
	queue_head_t	vpl_queue;
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">VPL_LOCK_SPIN</span>
	lck_spin_t	vpl_lock;
#<span class="enscript-reference">else</span>
	lck_mtx_t	vpl_lock;
	lck_mtx_ext_t	vpl_lock_ext;
#<span class="enscript-reference">endif</span>
};

<span class="enscript-type">struct</span>	vplq {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">char</span>   cache_line_pad[128];
		<span class="enscript-type">struct</span> vpl vpl;
	} vpl_un;
};
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_local_q_count;
<span class="enscript-type">extern</span>
<span class="enscript-type">struct</span> vplq	*vm_page_local_q;
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_local_q_soft_limit;
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_local_q_hard_limit;
<span class="enscript-type">extern</span>
vm_locks_array_t vm_page_locks;

<span class="enscript-type">extern</span>
queue_head_t	vm_page_queue_free[MAX_COLORS];	<span class="enscript-comment">/* memory free queue */</span>
<span class="enscript-type">extern</span>
queue_head_t	vm_lopage_queue_free;		<span class="enscript-comment">/* low memory free queue */</span>
<span class="enscript-type">extern</span>
queue_head_t	vm_page_queue_active;	<span class="enscript-comment">/* active memory queue */</span>
<span class="enscript-type">extern</span>
queue_head_t	vm_page_queue_inactive;	<span class="enscript-comment">/* inactive memory queue for normal pages */</span>
<span class="enscript-type">extern</span>
queue_head_t    vm_page_queue_cleaned; <span class="enscript-comment">/* clean-queue inactive memory */</span>
<span class="enscript-type">extern</span>
queue_head_t	vm_page_queue_anonymous;	<span class="enscript-comment">/* inactive memory queue for anonymous pages */</span>
<span class="enscript-type">extern</span>
queue_head_t	vm_page_queue_throttled;	<span class="enscript-comment">/* memory queue for throttled pageout pages */</span>

<span class="enscript-type">extern</span>
queue_head_t	vm_objects_wired;
<span class="enscript-type">extern</span>
lck_spin_t	vm_objects_wired_lock;


<span class="enscript-type">extern</span>
vm_offset_t	first_phys_addr;	<span class="enscript-comment">/* physical address for first_page */</span>
<span class="enscript-type">extern</span>
vm_offset_t	last_phys_addr;		<span class="enscript-comment">/* physical address for last_page */</span>

<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_free_count;	<span class="enscript-comment">/* How many pages are free? (sum of all colors) */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_fictitious_count;<span class="enscript-comment">/* How many fictitious pages are free? */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_active_count;	<span class="enscript-comment">/* How many pages are active? */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_inactive_count;	<span class="enscript-comment">/* How many pages are inactive? */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    vm_page_cleaned_count; <span class="enscript-comment">/* How many pages are in the clean queue? */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_throttled_count;<span class="enscript-comment">/* How many inactives are throttled */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_speculative_count;	<span class="enscript-comment">/* How many speculative pages are unclaimed? */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_pageable_internal_count;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_pageable_external_count;
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_xpmapped_external_count;	<span class="enscript-comment">/* How many pages are mapped executable? */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_external_count;	<span class="enscript-comment">/* How many pages are file-backed? */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_internal_count;	<span class="enscript-comment">/* How many pages are anonymous? */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_wire_count;		<span class="enscript-comment">/* How many pages are wired? */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_wire_count_initial;	<span class="enscript-comment">/* How many pages wired at startup */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_free_target;	<span class="enscript-comment">/* How many do we want free? */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_free_min;	<span class="enscript-comment">/* When to wakeup pageout */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_throttle_limit;	<span class="enscript-comment">/* When to throttle new page creation */</span>
<span class="enscript-type">extern</span>
uint32_t	vm_page_creation_throttle;	<span class="enscript-comment">/* When to throttle new page creation */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_inactive_target;<span class="enscript-comment">/* How many do we want inactive? */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_anonymous_min;	<span class="enscript-comment">/* When it's ok to pre-clean */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_inactive_min;   <span class="enscript-comment">/* When do wakeup pageout */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_free_reserved;	<span class="enscript-comment">/* How many pages reserved to do pageout */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_throttle_count;	<span class="enscript-comment">/* Count of page allocations throttled */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_gobble_count;
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_stolen_count;	<span class="enscript-comment">/* Count of stolen pages not acccounted in zones */</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_speculative_used;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_purgeable_count;<span class="enscript-comment">/* How many pages are purgeable now ? */</span>
<span class="enscript-type">extern</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_purgeable_wired_count;<span class="enscript-comment">/* How many purgeable pages are wired now ? */</span>
<span class="enscript-type">extern</span>
uint64_t	vm_page_purged_count;	<span class="enscript-comment">/* How many pages got purged so far ? */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_free_wanted;
				<span class="enscript-comment">/* how many threads are waiting for memory */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	vm_page_free_wanted_privileged;
				<span class="enscript-comment">/* how many VM privileged threads are waiting for memory */</span>

<span class="enscript-type">extern</span> ppnum_t	vm_page_fictitious_addr;
				<span class="enscript-comment">/* (fake) phys_addr of fictitious pages */</span>

<span class="enscript-type">extern</span> ppnum_t	vm_page_guard_addr;
				<span class="enscript-comment">/* (fake) phys_addr of guard pages */</span>


<span class="enscript-type">extern</span> boolean_t	vm_page_deactivate_hint;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		vm_compressor_mode;

<span class="enscript-comment">/*
   0 = all pages avail ( default. )
   1 = disable high mem ( cap max pages to 4G)
   2 = prefer himem
*/</span>   
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		vm_himemory_mode;

<span class="enscript-type">extern</span> boolean_t	vm_lopage_needed;
<span class="enscript-type">extern</span> uint32_t		vm_lopage_free_count;
<span class="enscript-type">extern</span> uint32_t		vm_lopage_free_limit;
<span class="enscript-type">extern</span> uint32_t		vm_lopage_lowater;
<span class="enscript-type">extern</span> boolean_t	vm_lopage_refill;
<span class="enscript-type">extern</span> uint64_t		max_valid_dma_address;
<span class="enscript-type">extern</span> ppnum_t		max_valid_low_ppnum;

<span class="enscript-comment">/*
 * Prototypes for functions exported by this module.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_bootstrap(
					vm_offset_t	*startp,
					vm_offset_t	*endp);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_module_init(<span class="enscript-type">void</span>);
					
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_init_local_q(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_create(
					ppnum_t		start,
					ppnum_t		end);

<span class="enscript-type">extern</span> vm_page_t	kdp_vm_page_lookup(
					vm_object_t		object,
					vm_object_offset_t	offset);

<span class="enscript-type">extern</span> vm_page_t	vm_page_lookup(
					vm_object_t		object,
					vm_object_offset_t	offset);

<span class="enscript-type">extern</span> vm_page_t	vm_page_grab_fictitious(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> vm_page_t	vm_page_grab_guard(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_release_fictitious(
					vm_page_t page);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_more_fictitious(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		vm_pool_low(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> vm_page_t	vm_page_grab(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> vm_page_t	vm_page_grablo(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_release(
					vm_page_t	page);

<span class="enscript-type">extern</span> boolean_t	vm_page_wait(
					<span class="enscript-type">int</span>		interruptible );

<span class="enscript-type">extern</span> vm_page_t	vm_page_alloc(
					vm_object_t		object,
					vm_object_offset_t	offset);

<span class="enscript-type">extern</span> vm_page_t	vm_page_alloc_guard(
	vm_object_t		object,
	vm_object_offset_t	offset);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_init(
					vm_page_t	page,
					ppnum_t		phys_page,
					boolean_t 	lopage);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_free(
	                                vm_page_t	page);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_free_unlocked(
	                                vm_page_t	page,
					boolean_t	remove_from_hash);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_activate(
					vm_page_t	page);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_deactivate(
					vm_page_t	page);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_deactivate_internal(
	                                vm_page_t	page,
					boolean_t	clear_hw_reference);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_enqueue_cleaned(vm_page_t page);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_lru(
					vm_page_t	page);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_speculate(
					vm_page_t	page,
					boolean_t	new);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_speculate_ageit(
					<span class="enscript-type">struct</span> vm_speculative_age_q *aq);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_reactivate_all_throttled(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_reactivate_local(uint32_t lid, boolean_t force, boolean_t nolocks);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_rename(
					vm_page_t		page,
					vm_object_t		new_object,
					vm_object_offset_t	new_offset,
					boolean_t		encrypted_ok);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_insert(
					vm_page_t		page,
					vm_object_t		object,
					vm_object_offset_t	offset);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_insert_wired(
					vm_page_t		page,
					vm_object_t		object,
					vm_object_offset_t	offset,
					vm_tag_t                tag);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_insert_internal(
					vm_page_t		page,
					vm_object_t		object,
					vm_object_offset_t	offset,
					vm_tag_t                tag,
					boolean_t		queues_lock_held,
					boolean_t		insert_in_hash,
					boolean_t		batch_pmap_op,
					boolean_t               delayed_accounting,
					uint64_t		*delayed_ledger_update);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_replace(
					vm_page_t		mem,
					vm_object_t		object,
					vm_object_offset_t	offset);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_remove(
	                                vm_page_t	page,
					boolean_t	remove_from_hash);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_zero_fill(
					vm_page_t	page);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_part_zero_fill(
					vm_page_t	m,
					vm_offset_t	m_pa,
					vm_size_t	len);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_copy(
					vm_page_t	src_page,
					vm_page_t	dest_page);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_part_copy(
					vm_page_t	src_m,
					vm_offset_t	src_pa,
					vm_page_t	dst_m,
					vm_offset_t	dst_pa,
					vm_size_t	len);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_wire(
					vm_page_t	page,
					vm_tag_t        tag,
					boolean_t	check_memorystatus);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_unwire(
	                                vm_page_t	page,
					boolean_t	queueit);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_set_page_size(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_gobble(
				        vm_page_t      page);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_validate_cs(vm_page_t	page);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_validate_cs_mapped(
	vm_page_t	page,
	<span class="enscript-type">const</span> <span class="enscript-type">void</span>	*kaddr);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_validate_cs_mapped_chunk(
	vm_page_t	page,
	<span class="enscript-type">const</span> <span class="enscript-type">void</span>	*kaddr,
	vm_offset_t	chunk_offset,
	boolean_t	*validated,
	<span class="enscript-type">unsigned</span>	*tainted);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_free_prepare_queues(
					vm_page_t	page);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_page_free_prepare_object(
	                                vm_page_t	page,
					boolean_t	remove_from_hash);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
<span class="enscript-type">extern</span> wait_result_t	vm_page_sleep(
					vm_object_t	object,
					vm_page_t	m,
					<span class="enscript-type">int</span>	interruptible);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_pressure_response</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_pages_update</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pages_avail);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_CHECK_MEMORYSTATUS</span> do { \
	memorystatus_pages_update(		\
      		vm_page_pageable_external_count + \
		vm_page_free_count +		\
      		(VM_DYNAMIC_PAGING_ENABLED(memory_manager_default) ? 0 : vm_page_purgeable_count) \
		); \
	} <span class="enscript-keyword">while</span>(0)

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_CHECK_MEMORYSTATUS</span>	vm_pressure_response()


#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

<span class="enscript-comment">/*
 *	Functions implemented as macros. m-&gt;wanted and m-&gt;busy are
 *	protected by the object lock.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SET_PAGE_DIRTY</span>(m, set_pmap_modified)				\
		MACRO_BEGIN						\
		vm_page_t __page__ = (m);				\
		__page__-&gt;dirty = TRUE;					\
		MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PAGE_ASSERT_WAIT</span>(m, interruptible)			\
		(((m)-&gt;wanted = TRUE),				\
		 assert_wait((event_t) (m), (interruptible)))

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PAGE_SLEEP</span>(o, m, interruptible)				\
		vm_page_sleep(o, m, interruptible)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PAGE_SLEEP</span>(o, m, interruptible)				\
	(((m)-&gt;wanted = TRUE),					\
	 thread_sleep_vm_object((o), (m), (interruptible)))
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PAGE_WAKEUP_DONE</span>(m)					\
		MACRO_BEGIN					\
		(m)-&gt;busy = FALSE;				\
		<span class="enscript-keyword">if</span> ((m)-&gt;wanted) {				\
			(m)-&gt;wanted = FALSE;			\
			thread_wakeup((event_t) (m));		\
		}						\
		MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PAGE_WAKEUP</span>(m)						\
		MACRO_BEGIN					\
		<span class="enscript-keyword">if</span> ((m)-&gt;wanted) {				\
			(m)-&gt;wanted = FALSE;			\
			thread_wakeup((event_t) (m));		\
		}						\
		MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PAGE_FREE</span>(p) 			\
		MACRO_BEGIN			\
		vm_page_free_unlocked(p, TRUE);	\
		MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PAGE_GRAB_FICTITIOUS</span>(M)					\
		MACRO_BEGIN						\
		<span class="enscript-keyword">while</span> ((M = vm_page_grab_fictitious()) == VM_PAGE_NULL)	\
			vm_page_more_fictitious();			\
		MACRO_END

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VM_PAGE_WAIT</span>()		((void)vm_page_wait(THREAD_UNINT))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vm_page_queue_lock</span> (vm_page_locks.vm_page_queue_lock2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vm_page_queue_free_lock</span> (vm_page_locks.vm_page_queue_free_lock2)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_page_lock_queues</span>()	lck_mtx_lock(&amp;vm_page_queue_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_page_unlock_queues</span>()	lck_mtx_unlock(&amp;vm_page_queue_lock)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_page_lockspin_queues</span>()	lck_mtx_lock_spin(&amp;vm_page_queue_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_page_trylockspin_queues</span>()	lck_mtx_try_lock_spin(&amp;vm_page_queue_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_page_lockconvert_queues</span>()	lck_mtx_convert_spin(&amp;vm_page_queue_lock)

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">VPL_LOCK_SPIN</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VPL_LOCK_INIT</span>(vlq, vpl_grp, vpl_attr) lck_spin_init(&amp;vlq-&gt;vpl_lock, vpl_grp, vpl_attr)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VPL_LOCK</span>(vpl) lck_spin_lock(vpl)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VPL_UNLOCK</span>(vpl) lck_spin_unlock(vpl)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VPL_LOCK_INIT</span>(vlq, vpl_grp, vpl_attr) lck_mtx_init_ext(&amp;vlq-&gt;vpl_lock, &amp;vlq-&gt;vpl_lock_ext, vpl_grp, vpl_attr)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VPL_LOCK</span>(vpl) lck_mtx_lock_spin(vpl)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VPL_UNLOCK</span>(vpl) lck_mtx_unlock(vpl)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_queues_assert</span>(vm_page_t mem, <span class="enscript-type">int</span> val);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PAGE_QUEUES_ASSERT</span>(mem, val)	vm_page_queues_assert((mem), (val))
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PAGE_QUEUES_ASSERT</span>(mem, val)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PAGE_SPECULATIVE_USED_ADD</span>()				\
	MACRO_BEGIN						\
	OSAddAtomic(1, &amp;vm_page_speculative_used);	\
	MACRO_END
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VM_PAGE_SPECULATIVE_USED_ADD</span>()
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PAGE_CONSUME_CLUSTERED</span>(mem)				\
	MACRO_BEGIN						\
	pmap_lock_phys_page(mem-&gt;phys_page);			\
	<span class="enscript-keyword">if</span> (mem-&gt;clustered) {					\
	        assert(mem-&gt;object);				\
	        mem-&gt;object-&gt;pages_used++;			\
		mem-&gt;clustered = FALSE;				\
		VM_PAGE_SPECULATIVE_USED_ADD();			\
	}							\
	pmap_unlock_phys_page(mem-&gt;phys_page);			\
	MACRO_END


#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PAGE_COUNT_AS_PAGEIN</span>(mem)				\
	MACRO_BEGIN						\
	DTRACE_VM2(pgin, <span class="enscript-type">int</span>, 1, (uint64_t *), NULL);		\
	current_task()-&gt;pageins++;				\
	<span class="enscript-keyword">if</span> (mem-&gt;object-&gt;internal) {				\
		DTRACE_VM2(anonpgin, <span class="enscript-type">int</span>, 1, (uint64_t *), NULL);	\
	} <span class="enscript-keyword">else</span> {						\
		DTRACE_VM2(fspgin, <span class="enscript-type">int</span>, 1, (uint64_t *), NULL);	\
	}							\
	MACRO_END

<span class="enscript-comment">/* adjust for stolen pages accounted elsewhere */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PAGE_MOVE_STOLEN</span>(page_count)				\
	MACRO_BEGIN						\
	vm_page_stolen_count -=	(page_count);			\
	vm_page_wire_count_initial -= (page_count);		\
	MACRO_END
	
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_vm_page_unwire</span>		0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_vm_page_wire</span>			0x02
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_vm_page_free</span>			0x04
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_vm_page_activate</span>		0x08
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_vm_page_deactivate_internal</span>	0x10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_vm_page_speculate</span>	 	0x20
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_vm_page_lru</span>		 	0x40
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_vm_pageout_throttle_up</span>	0x80
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_PAGE_WAKEUP</span>			0x100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_clear_busy</span>			0x200
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_clear_reference</span>		0x400
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_set_reference</span>		0x800
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_move_page</span>			0x1000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_VM_PAGE_QUEUES_REMOVE</span>	0x2000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_enqueue_cleaned</span>      	0x4000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DW_vm_phantom_cache_update</span>	0x8000

<span class="enscript-type">struct</span> vm_page_delayed_work {
	vm_page_t	dw_m;
	<span class="enscript-type">int</span>		dw_mask;
};

<span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_do_delayed_work</span>(vm_object_t object, vm_tag_t tag, <span class="enscript-type">struct</span> vm_page_delayed_work *dwp, <span class="enscript-type">int</span> dw_count);

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_max_delayed_work_limit;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_DELAYED_WORK_LIMIT</span>	32

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DELAYED_WORK_LIMIT</span>(max)	((vm_max_delayed_work_limit &gt;= max ? max : vm_max_delayed_work_limit))

<span class="enscript-comment">/*
 * vm_page_do_delayed_work may need to drop the object lock...
 * if it does, we need the pages it's looking at to
 * be held stable via the busy bit, so if busy isn't already
 * set, we need to set it and ask vm_page_do_delayed_work
 * to clear it and wakeup anyone that might have blocked on
 * it once we're done processing the page.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_PAGE_ADD_DELAYED_WORK</span>(dwp, mem, dw_cnt)		\
	MACRO_BEGIN						\
	<span class="enscript-keyword">if</span> (mem-&gt;busy == FALSE) {				\
		mem-&gt;busy = TRUE;				\
		<span class="enscript-keyword">if</span> ( !(dwp-&gt;dw_mask &amp; DW_vm_page_free))		\
			dwp-&gt;dw_mask |= (DW_clear_busy | DW_PAGE_WAKEUP); \
	}							\
	dwp-&gt;dw_m = mem;					\
	dwp++;							\
	dw_cnt++;						\
	MACRO_END

<span class="enscript-type">extern</span> vm_page_t <span class="enscript-function-name">vm_object_page_grab</span>(vm_object_t);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PAGE_BUCKETS_CHECK</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_buckets_check</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PAGE_BUCKETS_CHECK */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_queues_remove</span>(vm_page_t mem);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_remove_internal</span>(vm_page_t page);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_enqueue_inactive</span>(vm_page_t mem, boolean_t first);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_check_pageable_safe</span>(vm_page_t page);


#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* _VM_VM_PAGE_H_ */</span>
</pre>
<hr />
</body></html>