<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_map.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_map.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * @OSF_COPYRIGHT@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>
<span class="enscript-comment">/*
 */</span>

<span class="enscript-comment">/*
 *	File:	vm/vm_map.h
 *	Author:	Avadis Tevanian, Jr., Michael Wayne Young
 *	Date:	1985
 *
 *	Virtual memory map module definitions.
 *
 * Contributors:
 *	avie, dlb, mwyoung
 */</span>

#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">_VM_VM_MAP_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_VM_VM_MAP_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_inherit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_behavior.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">KERNEL_PRIVATE</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>

__BEGIN_DECLS

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	vm_map_reference(vm_map_t	map);
<span class="enscript-type">extern</span> vm_map_t <span class="enscript-function-name">current_map</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/* Setup reserved areas in a new VM map */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_exec(
				vm_map_t		new_map,
				task_t			task,
				<span class="enscript-type">void</span>			*fsroot,
				cpu_type_t		cpu);

__END_DECLS

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">MACH_KERNEL_PRIVATE</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;task_swapper.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_assert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_object.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_page.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/macro_help.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">current_map_fast</span>()	(current_thread()-&gt;map)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">current_map</span>()		(current_map_fast())

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map_store.h&gt;</span>


<span class="enscript-comment">/*
 *	Types defined:
 *
 *	vm_map_t		the high-level address map data structure.
 *	vm_map_entry_t		an entry in an address map.
 *	vm_map_version_t	a timestamp of a map, for use with vm_map_lookup
 *	vm_map_copy_t		represents memory copied from an address map,
 *				 used for inter-map copy operations
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> vm_map_entry	*vm_map_entry_t;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_MAP_ENTRY_NULL</span>	((vm_map_entry_t) 0)


<span class="enscript-comment">/*
 *	Type:		vm_map_object_t [internal use only]
 *
 *	Description:
 *		The target of an address mapping, either a virtual
 *		memory object or a sub map (of the kernel map).
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">union</span> vm_map_object {
	vm_object_t		vmo_object;	<span class="enscript-comment">/* object object */</span>
	vm_map_t		vmo_submap;	<span class="enscript-comment">/* belongs to another map */</span>
} vm_map_object_t;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">named_entry_lock_init</span>(object)	lck_mtx_init(&amp;(object)-&gt;Lock, &amp;vm_object_lck_grp, &amp;vm_object_lck_attr)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">named_entry_lock_destroy</span>(object)	lck_mtx_destroy(&amp;(object)-&gt;Lock, &amp;vm_object_lck_grp)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">named_entry_lock</span>(object)		lck_mtx_lock(&amp;(object)-&gt;Lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">named_entry_unlock</span>(object)		lck_mtx_unlock(&amp;(object)-&gt;Lock)   

<span class="enscript-comment">/*
 *	Type:		vm_named_entry_t [internal use only]
 *
 *	Description:
 *		Description of a mapping to a memory cache object.
 *
 *	Implementation:
 *		While the handle to this object is used as a means to map
 * 		and pass around the right to map regions backed by pagers
 *		of all sorts, the named_entry itself is only manipulated
 *		by the kernel.  Named entries hold information on the
 *		right to map a region of a cached object.  Namely,
 *		the target cache object, the beginning and ending of the
 *		region to be mapped, and the permissions, (read, write)
 *		with which it can be mapped.
 *
 */</span>

<span class="enscript-type">struct</span> vm_named_entry {
	decl_lck_mtx_data(,	Lock)		<span class="enscript-comment">/* Synchronization */</span>
	<span class="enscript-type">union</span> {
		vm_object_t	object;		<span class="enscript-comment">/* object I point to */</span>
		memory_object_t	pager;		<span class="enscript-comment">/* amo pager port */</span>
		vm_map_t	map;		<span class="enscript-comment">/* map backing submap */</span>
		vm_map_copy_t	copy;		<span class="enscript-comment">/* a VM map copy */</span>
	} backing;
	vm_object_offset_t	offset;		<span class="enscript-comment">/* offset into object */</span>
	vm_object_size_t	size;		<span class="enscript-comment">/* size of region */</span>
	vm_object_offset_t	data_offset;	<span class="enscript-comment">/* offset to first byte of data */</span>
	vm_prot_t		protection;	<span class="enscript-comment">/* access permissions */</span>
	<span class="enscript-type">int</span>			ref_count;	<span class="enscript-comment">/* Number of references */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>				<span class="enscript-comment">/* Is backing.xxx : */</span>
	<span class="enscript-comment">/* boolean_t */</span>		internal:1,	<span class="enscript-comment">/* ... an internal object */</span>
	<span class="enscript-comment">/* boolean_t */</span>		is_sub_map:1,	<span class="enscript-comment">/* ... a submap? */</span>
	<span class="enscript-comment">/* boolean_t */</span>		is_pager:1,	<span class="enscript-comment">/* ... a pager port */</span>
	<span class="enscript-comment">/* boolean_t */</span>		is_copy:1;	<span class="enscript-comment">/* ... a VM map copy */</span>
};

<span class="enscript-comment">/*
 *	Type:		vm_map_entry_t [internal use only]
 *
 *	Description:
 *		A single mapping within an address map.
 *
 *	Implementation:
 *		Address map entries consist of start and end addresses,
 *		a VM object (or sub map) and offset into that object,
 *		and user-exported inheritance and protection information.
 *		Control information for virtual copy operations is also
 *		stored in the address map entry.
 */</span>

<span class="enscript-type">struct</span> vm_map_links {
	<span class="enscript-type">struct</span> vm_map_entry	*prev;		<span class="enscript-comment">/* previous entry */</span>
	<span class="enscript-type">struct</span> vm_map_entry	*next;		<span class="enscript-comment">/* next entry */</span>
	vm_map_offset_t		start;		<span class="enscript-comment">/* start address */</span>
	vm_map_offset_t		end;		<span class="enscript-comment">/* end address */</span>
};

<span class="enscript-comment">/*
 * IMPORTANT:
 * The &quot;alias&quot; field can be updated while holding the VM map lock
 * &quot;shared&quot;.  It's OK as along as it's the only field that can be
 * updated without the VM map &quot;exclusive&quot; lock.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VME_OBJECT</span>(entry) ((entry)-&gt;vme_object.vmo_object)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VME_OBJECT_SET</span>(entry, object)				\
	MACRO_BEGIN						\
	(entry)-&gt;vme_object.vmo_object = (object);		\
	MACRO_END
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VME_SUBMAP</span>(entry) ((entry)-&gt;vme_object.vmo_submap)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VME_SUBMAP_SET</span>(entry, submap)				\
	MACRO_BEGIN						\
	(entry)-&gt;vme_object.vmo_submap = (submap);		\
	MACRO_END
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VME_OFFSET</span>(entry) ((entry)-&gt;vme_offset &amp; ~PAGE_MASK)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VME_OFFSET_SET</span>(entry, offset)		\
	MACRO_BEGIN				\
	<span class="enscript-type">int</span> __alias;				\
	__alias = VME_ALIAS((entry));		\
	assert((offset &amp; PAGE_MASK) == 0);	\
	(entry)-&gt;vme_offset = offset | __alias;	\
	MACRO_END
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VME_OBJECT_SHADOW</span>(entry, length)			\
	MACRO_BEGIN						\
	vm_object_t		__object;			\
	vm_object_offset_t	__offset;			\
	__object = VME_OBJECT((entry));				\
	__offset = VME_OFFSET((entry));				\
	vm_object_shadow(&amp;__object, &amp;__offset, (length));	\
	<span class="enscript-keyword">if</span> (__object != VME_OBJECT((entry))) {			\
		VME_OBJECT_SET((entry), __object);		\
	}							\
	<span class="enscript-keyword">if</span> (__offset != VME_OFFSET((entry))) {			\
		VME_OFFSET_SET((entry), __offset);		\
	}							\
	MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VME_ALIAS_MASK</span> (PAGE_MASK)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VME_ALIAS</span>(entry) ((unsigned int)((entry)-&gt;vme_offset &amp; VME_ALIAS_MASK))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VME_ALIAS_SET</span>(entry, alias) \
	MACRO_BEGIN							\
	vm_map_offset_t __offset;					\
	__offset = VME_OFFSET((entry));					\
	(entry)-&gt;vme_offset = __offset | ((alias) &amp; VME_ALIAS_MASK);	\
	MACRO_END

<span class="enscript-type">struct</span> vm_map_entry {
	<span class="enscript-type">struct</span> vm_map_links	links;		<span class="enscript-comment">/* links to other entries */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vme_prev</span>		links.prev
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vme_next</span>		links.next
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vme_start</span>		links.start
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vme_end</span>			links.end

	<span class="enscript-type">struct</span> vm_map_store	store;
	<span class="enscript-type">union</span> vm_map_object	vme_object;	<span class="enscript-comment">/* object I point to */</span>
	vm_object_offset_t	vme_offset;	<span class="enscript-comment">/* offset into object */</span>

	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
	<span class="enscript-comment">/* boolean_t */</span>	is_shared:1,	<span class="enscript-comment">/* region is shared */</span>
	<span class="enscript-comment">/* boolean_t */</span>	is_sub_map:1,	<span class="enscript-comment">/* Is &quot;object&quot; a submap? */</span>
	<span class="enscript-comment">/* boolean_t */</span>	in_transition:1, <span class="enscript-comment">/* Entry being changed */</span>
	<span class="enscript-comment">/* boolean_t */</span>	needs_wakeup:1,	<span class="enscript-comment">/* Waiters on in_transition */</span>
	<span class="enscript-comment">/* vm_behavior_t */</span> behavior:2,	<span class="enscript-comment">/* user paging behavior hint */</span>
		<span class="enscript-comment">/* behavior is not defined for submap type */</span>
	<span class="enscript-comment">/* boolean_t */</span>	needs_copy:1,	<span class="enscript-comment">/* object need to be copied? */</span>

		<span class="enscript-comment">/* Only in task maps: */</span>
	<span class="enscript-comment">/* vm_prot_t */</span>	protection:3,	<span class="enscript-comment">/* protection code */</span>
	<span class="enscript-comment">/* vm_prot_t */</span>	max_protection:3, <span class="enscript-comment">/* maximum protection */</span>
	<span class="enscript-comment">/* vm_inherit_t */</span> inheritance:2, <span class="enscript-comment">/* inheritance */</span>
	<span class="enscript-comment">/* boolean_t */</span>	use_pmap:1,	<span class="enscript-comment">/*
					 * use_pmap is overloaded:
					 * if &quot;is_sub_map&quot;:
					 * 	use a nested pmap?
					 * else (i.e. if object):
					 * 	use pmap accounting
					 * 	for footprint?
					 */</span>
	<span class="enscript-comment">/* boolean_t */</span>	no_cache:1,	<span class="enscript-comment">/* should new pages be cached? */</span>
	<span class="enscript-comment">/* boolean_t */</span>	permanent:1,	<span class="enscript-comment">/* mapping can not be removed */</span>
	<span class="enscript-comment">/* boolean_t */</span>	superpage_size:1, <span class="enscript-comment">/* use superpages of a certain size */</span>
	<span class="enscript-comment">/* boolean_t */</span>	map_aligned:1,	<span class="enscript-comment">/* align to map's page size */</span>
	<span class="enscript-comment">/* boolean_t */</span>	zero_wired_pages:1, <span class="enscript-comment">/* zero out the wired pages of
					     * this entry it is being deleted
					     * without unwiring them */</span>
	<span class="enscript-comment">/* boolean_t */</span>	used_for_jit:1,
	<span class="enscript-comment">/* boolean_t */</span>	from_reserved_zone:1, <span class="enscript-comment">/* Allocated from
					       * kernel reserved zone	 */</span>

	<span class="enscript-comment">/* iokit accounting: use the virtual size rather than resident size: */</span>
	<span class="enscript-comment">/* boolean_t */</span> iokit_acct:1,
	<span class="enscript-comment">/* boolean_t */</span> vme_resilient_codesign:1,
	<span class="enscript-comment">/* boolean_t */</span> vme_resilient_media:1,
		<span class="enscript-reference">__unused</span>:6;
;

	<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>		wired_count;	<span class="enscript-comment">/* can be paged if = 0 */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>		user_wired_count; <span class="enscript-comment">/* for vm_wire */</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAP_ENTRY_CREATION_DEBUG</span> (1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAP_ENTRY_INSERTION_DEBUG</span> (1)
#<span class="enscript-reference">endif</span>	
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MAP_ENTRY_CREATION_DEBUG</span>
	<span class="enscript-type">struct</span> vm_map_header	*vme_creation_maphdr;
	uintptr_t		vme_creation_bt[16];
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MAP_ENTRY_INSERTION_DEBUG</span>
	uintptr_t		vme_insertion_bt[16];
#<span class="enscript-reference">endif</span>
};

<span class="enscript-comment">/*
 * Convenience macros for dealing with superpages
 * SUPERPAGE_NBASEPAGES is architecture dependent and defined in pmap.h
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SUPERPAGE_SIZE</span> (PAGE_SIZE*SUPERPAGE_NBASEPAGES)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SUPERPAGE_MASK</span> (-SUPERPAGE_SIZE)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SUPERPAGE_ROUND_DOWN</span>(a) (a &amp; SUPERPAGE_MASK)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SUPERPAGE_ROUND_UP</span>(a) ((a + SUPERPAGE_SIZE-1) &amp; SUPERPAGE_MASK)

<span class="enscript-comment">/*
 * wired_counts are unsigned short.  This value is used to safeguard
 * against any mishaps due to runaway user programs.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_WIRE_COUNT</span>		65535



<span class="enscript-comment">/*
 *	Type:		struct vm_map_header
 *
 *	Description:
 *		Header for a vm_map and a vm_map_copy.
 */</span>


<span class="enscript-type">struct</span> vm_map_header {
	<span class="enscript-type">struct</span> vm_map_links	links;		<span class="enscript-comment">/* first, last, min, max */</span>
	<span class="enscript-type">int</span>			nentries;	<span class="enscript-comment">/* Number of entries */</span>
	boolean_t		entries_pageable;
						<span class="enscript-comment">/* are map entries pageable? */</span>
	vm_map_offset_t		highest_entry_end_addr;	<span class="enscript-comment">/* The ending address of the highest allocated vm_entry_t */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">VM_MAP_STORE_USE_RB</span>
	<span class="enscript-type">struct</span> rb_head	rb_head_store;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span>			page_shift;	<span class="enscript-comment">/* page shift */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_MAP_HDR_PAGE_SHIFT</span>(hdr) ((hdr)-&gt;page_shift)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_MAP_HDR_PAGE_SIZE</span>(hdr) (1 &lt;&lt; VM_MAP_HDR_PAGE_SHIFT((hdr)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_MAP_HDR_PAGE_MASK</span>(hdr) (VM_MAP_HDR_PAGE_SIZE((hdr)) - 1)

<span class="enscript-comment">/*
 *	Type:		vm_map_t [exported; contents invisible]
 *
 *	Description:
 *		An address map -- a directory relating valid
 *		regions of a task's address space to the corresponding
 *		virtual memory objects.
 *
 *	Implementation:
 *		Maps are doubly-linked lists of map entries, sorted
 *		by address.  One hint is used to start
 *		searches again from the last successful search,
 *		insertion, or removal.  Another hint is used to
 *		quickly find free space.
 */</span>
<span class="enscript-type">struct</span> _vm_map {
	lck_rw_t			lock;		<span class="enscript-comment">/* map lock */</span>
	<span class="enscript-type">struct</span> vm_map_header	hdr;		<span class="enscript-comment">/* Map entry header */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">min_offset</span>		hdr.links.start	<span class="enscript-comment">/* start of range */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">max_offset</span>		hdr.links.end	<span class="enscript-comment">/* end of range */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">highest_entry_end</span>	hdr.highest_entry_end_addr
	pmap_t			pmap;		<span class="enscript-comment">/* Physical map */</span>
	vm_map_size_t		size;		<span class="enscript-comment">/* virtual size */</span>
	vm_map_size_t		user_wire_limit;<span class="enscript-comment">/* rlimit on user locked memory */</span>
	vm_map_size_t		user_wire_size; <span class="enscript-comment">/* current size of user locked memory in this map */</span>
	<span class="enscript-type">int</span>			ref_count;	<span class="enscript-comment">/* Reference count */</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">TASK_SWAPPER</span>
	<span class="enscript-type">int</span>			res_count;	<span class="enscript-comment">/* Residence count (swap) */</span>
	<span class="enscript-type">int</span>			sw_state;	<span class="enscript-comment">/* Swap state */</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>
	decl_lck_mtx_data(,	s_lock)		<span class="enscript-comment">/* Lock ref, res fields */</span>
	lck_mtx_ext_t		s_lock_ext;
	vm_map_entry_t		hint;		<span class="enscript-comment">/* hint for quick lookups */</span>
	<span class="enscript-type">struct</span> vm_map_links*	hole_hint;	<span class="enscript-comment">/* hint for quick hole lookups */</span>
	<span class="enscript-type">union</span>{
		vm_map_entry_t		_first_free;	<span class="enscript-comment">/* First free space hint */</span>
		<span class="enscript-type">struct</span> vm_map_links*	_holes;		<span class="enscript-comment">/* links all holes between entries */</span>
	}f_s;						<span class="enscript-comment">/* Union for free space data structures being used */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">first_free</span>		f_s._first_free
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">holes_list</span>		f_s._holes

	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		
	<span class="enscript-comment">/* boolean_t */</span>		wait_for_space:1, <span class="enscript-comment">/* Should callers wait for space? */</span>
	<span class="enscript-comment">/* boolean_t */</span>		wiring_required:1, <span class="enscript-comment">/* All memory wired? */</span>
	<span class="enscript-comment">/* boolean_t */</span>		no_zero_fill:1, <span class="enscript-comment">/*No zero fill absent pages */</span>
	<span class="enscript-comment">/* boolean_t */</span>		mapped_in_other_pmaps:1, <span class="enscript-comment">/*has this submap been mapped in maps that use a different pmap */</span>
	<span class="enscript-comment">/* boolean_t */</span>		switch_protect:1, <span class="enscript-comment">/*  Protect map from write faults while switched */</span>
	<span class="enscript-comment">/* boolean_t */</span>		disable_vmentry_reuse:1, <span class="enscript-comment">/*  All vm entries should keep using newer and higher addresses in the map */</span> 
	<span class="enscript-comment">/* boolean_t */</span>		map_disallow_data_exec:1, <span class="enscript-comment">/* Disallow execution from data pages on exec-permissive architectures */</span>
	<span class="enscript-comment">/* boolean_t */</span>		holelistenabled:1,
	<span class="enscript-comment">/* reserved */</span>		pad:24;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		timestamp;	<span class="enscript-comment">/* Version number */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		color_rr;	<span class="enscript-comment">/* next color (not protected by a lock) */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	<span class="enscript-type">void</span>			*default_freezer_handle;
#<span class="enscript-reference">endif</span>
 	boolean_t		jit_entry_exists;
} ;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_to_entry</span>(map)	((struct vm_map_entry *) &amp;(map)-&gt;hdr.links)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_first_entry</span>(map)	((map)-&gt;hdr.links.next)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_last_entry</span>(map)	((map)-&gt;hdr.links.prev)

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">TASK_SWAPPER</span>
<span class="enscript-comment">/*
 * VM map swap states.  There are no transition states.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAP_SW_IN</span>	 1	<span class="enscript-comment">/* map is swapped in; residence count &gt; 0 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAP_SW_OUT</span>	 2	<span class="enscript-comment">/* map is out (res_count == 0 */</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>

<span class="enscript-comment">/*
 *	Type:		vm_map_version_t [exported; contents invisible]
 *
 *	Description:
 *		Map versions may be used to quickly validate a previous
 *		lookup operation.
 *
 *	Usage note:
 *		Because they are bulky objects, map versions are usually
 *		passed by reference.
 *
 *	Implementation:
 *		Just a timestamp for the main map.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> vm_map_version {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	main_timestamp;
} vm_map_version_t;

<span class="enscript-comment">/*
 *	Type:		vm_map_copy_t [exported; contents invisible]
 *
 *	Description:
 *		A map copy object represents a region of virtual memory
 *		that has been copied from an address map but is still
 *		in transit.
 *
 *		A map copy object may only be used by a single thread
 *		at a time.
 *
 *	Implementation:
 * 		There are three formats for map copy objects.  
 *		The first is very similar to the main
 *		address map in structure, and as a result, some
 *		of the internal maintenance functions/macros can
 *		be used with either address maps or map copy objects.
 *
 *		The map copy object contains a header links
 *		entry onto which the other entries that represent
 *		the region are chained.
 *
 *		The second format is a single vm object.  This was used
 *		primarily in the pageout path - but is not currently used
 *		except for placeholder copy objects (see vm_map_copy_copy()).
 *
 *		The third format is a kernel buffer copy object - for data
 * 		small enough that physical copies were the most efficient
 *		method. This method uses a zero-sized array unioned with
 *		other format-specific data in the 'c_u' member. This unsized
 *		array overlaps the other elements and allows us to use this
 *		extra structure space for physical memory copies. On 64-bit
 *		systems this saves ~64 bytes per vm_map_copy.
 */</span>

<span class="enscript-type">struct</span> vm_map_copy {
	<span class="enscript-type">int</span>			type;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_MAP_COPY_ENTRY_LIST</span>		1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_MAP_COPY_OBJECT</span>		2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_MAP_COPY_KERNEL_BUFFER</span>	3
	vm_object_offset_t	offset;
	vm_map_size_t		size;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> vm_map_header    hdr;      <span class="enscript-comment">/* ENTRY_LIST */</span>
		vm_object_t             object;   <span class="enscript-comment">/* OBJECT */</span>
		uint8_t                 kdata[0]; <span class="enscript-comment">/* KERNEL_BUFFER */</span>
	} c_u;
};


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cpy_hdr</span>			c_u.hdr

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cpy_object</span>		c_u.object
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cpy_kdata</span>		c_u.kdata
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cpy_kdata_hdr_sz</span>	(offsetof(struct vm_map_copy, c_u.kdata))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_MAP_COPY_PAGE_SHIFT</span>(copy) ((copy)-&gt;cpy_hdr.page_shift)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_MAP_COPY_PAGE_SIZE</span>(copy) (1 &lt;&lt; VM_MAP_COPY_PAGE_SHIFT((copy)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_MAP_COPY_PAGE_MASK</span>(copy) (VM_MAP_COPY_PAGE_SIZE((copy)) - 1)

<span class="enscript-comment">/*
 *	Useful macros for entry list copy objects
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_copy_to_entry</span>(copy)		\
		((<span class="enscript-type">struct</span> vm_map_entry *) &amp;(copy)-&gt;cpy_hdr.links)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_copy_first_entry</span>(copy)		\
		((copy)-&gt;cpy_hdr.links.next)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_copy_last_entry</span>(copy)		\
		((copy)-&gt;cpy_hdr.links.prev)

<span class="enscript-comment">/*
 *	Macros:		vm_map_lock, etc. [internal use only]
 *	Description:
 *		Perform locking on the data portion of a map.
 *	When multiple maps are to be locked, order by map address.
 *	(See vm_map.c::vm_remap())
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock_init</span>(map)						\
	((map)-&gt;timestamp = 0 ,						\
	lck_rw_init(&amp;(map)-&gt;lock, &amp;vm_map_lck_grp, &amp;vm_map_lck_rw_attr))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock</span>(map)		lck_rw_lock_exclusive(&amp;(map)-&gt;lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_unlock</span>(map)						\
		((map)-&gt;timestamp++ ,	lck_rw_done(&amp;(map)-&gt;lock))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock_read</span>(map)		lck_rw_lock_shared(&amp;(map)-&gt;lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_unlock_read</span>(map)		lck_rw_done(&amp;(map)-&gt;lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock_write_to_read</span>(map)					\
		((map)-&gt;timestamp++ ,	lck_rw_lock_exclusive_to_shared(&amp;(map)-&gt;lock))
<span class="enscript-comment">/* lock_read_to_write() returns FALSE on failure.  Macro evaluates to 
 * zero on success and non-zero value on failure.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock_read_to_write</span>(map)	(lck_rw_lock_shared_to_exclusive(&amp;(map)-&gt;lock) != TRUE)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span> || <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock_assert_held</span>(map) \
	lck_rw_assert(&amp;(map)-&gt;lock, LCK_RW_ASSERT_HELD)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock_assert_shared</span>(map)	\
	lck_rw_assert(&amp;(map)-&gt;lock, LCK_RW_ASSERT_SHARED)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock_assert_exclusive</span>(map) \
	lck_rw_assert(&amp;(map)-&gt;lock, LCK_RW_ASSERT_EXCLUSIVE)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock_assert_notheld</span>(map) \
	lck_rw_assert(&amp;(map)-&gt;lock, LCK_RW_ASSERT_NOTHELD)
#<span class="enscript-reference">else</span>  <span class="enscript-comment">/* MACH_ASSERT || DEBUG */</span> 
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock_assert_held</span>(map)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock_assert_shared</span>(map)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock_assert_exclusive</span>(map)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_lock_assert_notheld</span>(map)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT || DEBUG */</span>

<span class="enscript-comment">/*
 *	Exported procedures that operate on vm_map_t.
 */</span>

<span class="enscript-comment">/* Initialize the module */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_init(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_kernel_reserved_entry_init(<span class="enscript-type">void</span>);

<span class="enscript-comment">/* Allocate a range in the specified virtual address map and
 * return the entry allocated for that range. */</span>
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_find_space</span>(
				vm_map_t		map,
				vm_map_address_t	*address,	<span class="enscript-comment">/* OUT */</span>
				vm_map_size_t		size,
				vm_map_offset_t		mask,
				<span class="enscript-type">int</span>			flags,
				vm_map_entry_t		*o_entry);	<span class="enscript-comment">/* OUT */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_map_clip_start</span>(
	vm_map_t	map,
	vm_map_entry_t	entry,
	vm_map_offset_t	endaddr);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_map_clip_end</span>(
	vm_map_t	map,
	vm_map_entry_t	entry,
	vm_map_offset_t	endaddr);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">vm_map_entry_should_cow_for_true_share</span>(
	vm_map_entry_t	entry);

<span class="enscript-comment">/* Lookup map entry containing or the specified address in the given map */</span>
<span class="enscript-type">extern</span> boolean_t	vm_map_lookup_entry(
				vm_map_t		map,
				vm_map_address_t	address,
				vm_map_entry_t		*entry);	<span class="enscript-comment">/* OUT */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_copy_remap(
	vm_map_t		map,
	vm_map_entry_t		where,
	vm_map_copy_t		copy,
	vm_map_offset_t		adjustment,
	vm_prot_t		cur_prot,
	vm_prot_t		max_prot,
	vm_inherit_t		inheritance);

<span class="enscript-comment">/* Find the VM object, offset, and protection for a given virtual address
 * in the specified map, assuming a page fault of the	type specified. */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_lookup_locked(
				vm_map_t		*var_map,	<span class="enscript-comment">/* IN/OUT */</span>
				vm_map_address_t	vaddr,
				vm_prot_t		fault_type,
				<span class="enscript-type">int</span>			object_lock_type,
				vm_map_version_t 	*out_version,	<span class="enscript-comment">/* OUT */</span>
				vm_object_t		*object,	<span class="enscript-comment">/* OUT */</span>
				vm_object_offset_t 	*offset,	<span class="enscript-comment">/* OUT */</span>
				vm_prot_t		*out_prot,	<span class="enscript-comment">/* OUT */</span>
				boolean_t		*wired,		<span class="enscript-comment">/* OUT */</span>
				vm_object_fault_info_t	fault_info,	<span class="enscript-comment">/* OUT */</span>
				vm_map_t		*real_map);	<span class="enscript-comment">/* OUT */</span>

<span class="enscript-comment">/* Verifies that the map has not changed since the given version. */</span>
<span class="enscript-type">extern</span> boolean_t	vm_map_verify(
				vm_map_t	 	map,
				vm_map_version_t 	*version);	<span class="enscript-comment">/* REF */</span>

<span class="enscript-type">extern</span> vm_map_entry_t	vm_map_entry_insert(
				vm_map_t		map,
				vm_map_entry_t		insp_entry,
				vm_map_offset_t		start,
				vm_map_offset_t		end,
				vm_object_t		object,
				vm_object_offset_t	offset,
				boolean_t		needs_copy,
				boolean_t		is_shared,
				boolean_t		in_transition,
				vm_prot_t		cur_protection,
				vm_prot_t		max_protection,
				vm_behavior_t		behavior,
				vm_inherit_t		inheritance,
				<span class="enscript-type">unsigned</span>		wired_count,
				boolean_t		no_cache,
				boolean_t		permanent,
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		superpage_size,
				boolean_t		clear_map_aligned,
				boolean_t		is_submap);


<span class="enscript-comment">/*
 *	Functions implemented as macros
 */</span>
#<span class="enscript-reference">define</span>		<span class="enscript-function-name">vm_map_min</span>(map)	((map)-&gt;min_offset)
						<span class="enscript-comment">/* Lowest valid address in
						 * a map */</span>

#<span class="enscript-reference">define</span>		<span class="enscript-function-name">vm_map_max</span>(map)	((map)-&gt;max_offset)
						<span class="enscript-comment">/* Highest valid address */</span>

#<span class="enscript-reference">define</span>		<span class="enscript-function-name">vm_map_pmap</span>(map)	((map)-&gt;pmap)
						<span class="enscript-comment">/* Physical map associated
						 * with this address map */</span>

#<span class="enscript-reference">define</span>		<span class="enscript-function-name">vm_map_verify_done</span>(map, version)    vm_map_unlock_read(map)
						<span class="enscript-comment">/* Operation that required
						 * a verified lookup is
						 * now complete */</span>

<span class="enscript-comment">/*
 * Macros/functions for map residence counts and swapin/out of vm maps
 */</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">TASK_SWAPPER</span>

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">MACH_ASSERT</span>
<span class="enscript-comment">/* Gain a reference to an existing map */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_reference(
				vm_map_t	map);
<span class="enscript-comment">/* Lose a residence count */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_res_deallocate(
				vm_map_t	map);
<span class="enscript-comment">/* Gain a residence count on a map */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_res_reference(
				vm_map_t	map);
<span class="enscript-comment">/* Gain reference &amp; residence counts to possibly swapped-out map */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_reference_swap(
				vm_map_t	map);

#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* MACH_ASSERT */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_reference</span>(map)		\
MACRO_BEGIN					\
	vm_map_t Map = (map);		\
	<span class="enscript-keyword">if</span> (Map) {				\
		lck_mtx_lock(&amp;Map-&gt;s_lock);	\
		Map-&gt;res_count++;		\
		Map-&gt;ref_count++;		\
		lck_mtx_unlock(&amp;Map-&gt;s_lock);	\
	}					\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_res_reference</span>(map)		\
MACRO_BEGIN					\
	vm_map_t Lmap = (map);		\
	<span class="enscript-keyword">if</span> (Lmap-&gt;res_count == 0) {		\
		lck_mtx_unlock(&amp;Lmap-&gt;s_lock);\
		vm_map_lock(Lmap);		\
		vm_map_swapin(Lmap);		\
		lck_mtx_lock(&amp;Lmap-&gt;s_lock);	\
		++Lmap-&gt;res_count;		\
		vm_map_unlock(Lmap);		\
	} <span class="enscript-keyword">else</span>					\
		++Lmap-&gt;res_count;		\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_res_deallocate</span>(map)		\
MACRO_BEGIN					\
	vm_map_t Map = (map);		\
	<span class="enscript-keyword">if</span> (--Map-&gt;res_count == 0) {	\
		lck_mtx_unlock(&amp;Map-&gt;s_lock);	\
		vm_map_lock(Map);		\
		vm_map_swapout(Map);		\
		vm_map_unlock(Map);		\
		lck_mtx_lock(&amp;Map-&gt;s_lock);	\
	}					\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_reference_swap</span>(map)	\
MACRO_BEGIN				\
	vm_map_t Map = (map);		\
	lck_mtx_lock(&amp;Map-&gt;s_lock);	\
	++Map-&gt;ref_count;		\
	vm_map_res_reference(Map);	\
	lck_mtx_unlock(&amp;Map-&gt;s_lock);	\
MACRO_END
#<span class="enscript-reference">endif</span> 	<span class="enscript-comment">/* MACH_ASSERT */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_swapin(
				vm_map_t	map);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_swapout(
				vm_map_t	map);

#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_reference</span>(map)			\
MACRO_BEGIN					\
	vm_map_t Map = (map);			\
	<span class="enscript-keyword">if</span> (Map) {				\
		lck_mtx_lock(&amp;Map-&gt;s_lock);	\
		Map-&gt;ref_count++;		\
		lck_mtx_unlock(&amp;Map-&gt;s_lock);	\
	}					\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_reference_swap</span>(map)	vm_map_reference(map)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_res_reference</span>(map)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_res_deallocate</span>(map)

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* TASK_SWAPPER */</span>

<span class="enscript-comment">/*
 *	Submap object.  Must be used to create memory to be put
 *	in a submap by vm_map_submap.
 */</span>
<span class="enscript-type">extern</span> vm_object_t	vm_submap_object;

<span class="enscript-comment">/*
 *	Wait and wakeup macros for in_transition map entries.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_entry_wait</span>(map, interruptible)    	\
	((map)-&gt;timestamp++ ,				\
	 lck_rw_sleep(&amp;(map)-&gt;lock, LCK_SLEEP_EXCLUSIVE|LCK_SLEEP_PROMOTED_PRI, \
				  (event_t)&amp;(map)-&gt;hdr,	interruptible))


#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_entry_wakeup</span>(map)        \
	thread_wakeup((event_t)(&amp;(map)-&gt;hdr))


#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vm_map_ref_fast</span>(map)			\
	MACRO_BEGIN					\
	lck_mtx_lock(&amp;map-&gt;s_lock);			\
	map-&gt;ref_count++;				\
	vm_map_res_reference(map);			\
	lck_mtx_unlock(&amp;map-&gt;s_lock);			\
	MACRO_END

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vm_map_dealloc_fast</span>(map)		\
	MACRO_BEGIN					\
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> c;				\
							\
	lck_mtx_lock(&amp;map-&gt;s_lock);			\
	c = --map-&gt;ref_count;			\
	<span class="enscript-keyword">if</span> (c &gt; 0)					\
		vm_map_res_deallocate(map);		\
	lck_mtx_unlock(&amp;map-&gt;s_lock);			\
	<span class="enscript-keyword">if</span> (c == 0)					\
		vm_map_destroy(map);			\
	MACRO_END


<span class="enscript-comment">/* simplify map entries */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_simplify_entry(
	vm_map_t	map,
	vm_map_entry_t	this_entry);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_simplify(
				vm_map_t		map,
				vm_map_offset_t		start);

<span class="enscript-comment">/* Move the information in a map copy object to a new map copy object */</span>
<span class="enscript-type">extern</span> vm_map_copy_t	vm_map_copy_copy(
				vm_map_copy_t           copy);

<span class="enscript-comment">/* Create a copy object from an object. */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_copyin_object(
				vm_object_t		object,
				vm_object_offset_t	offset,
				vm_object_size_t	size,
				vm_map_copy_t		*copy_result); <span class="enscript-comment">/* OUT */</span>

<span class="enscript-type">extern</span> kern_return_t	vm_map_random_address_for_size(
				vm_map_t	map,
				vm_map_offset_t	*address,
				vm_map_size_t	size);

<span class="enscript-comment">/* Enter a mapping */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_enter(
				vm_map_t		map,
				vm_map_offset_t		*address,
				vm_map_size_t		size,
				vm_map_offset_t		mask,
				<span class="enscript-type">int</span>			flags,
				vm_object_t		object,
				vm_object_offset_t	offset,
				boolean_t		needs_copy,
				vm_prot_t		cur_protection,
				vm_prot_t		max_protection,
				vm_inherit_t		inheritance);


<span class="enscript-comment">/* XXX should go away - replaced with regular enter of contig object */</span>
<span class="enscript-type">extern</span>  kern_return_t	vm_map_enter_cpm(
				vm_map_t		map,
				vm_map_address_t	*addr,
				vm_map_size_t		size,
				<span class="enscript-type">int</span>			flags);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_remap</span>(
				vm_map_t		target_map,
				vm_map_offset_t		*address,
				vm_map_size_t		size,
				vm_map_offset_t		mask,
				<span class="enscript-type">int</span>			flags,
				vm_map_t		src_map,
				vm_map_offset_t		memory_address,
				boolean_t		copy,
				vm_prot_t		*cur_protection,
				vm_prot_t		*max_protection,
				vm_inherit_t		inheritance);


<span class="enscript-comment">/*
 * Read and write from a kernel buffer to a specified map.
 */</span>
<span class="enscript-type">extern</span>	kern_return_t	vm_map_write_user(
				vm_map_t		map,
				<span class="enscript-type">void</span>			*src_p,
				vm_map_offset_t		dst_addr,
				vm_size_t		size);

<span class="enscript-type">extern</span>	kern_return_t	vm_map_read_user(
				vm_map_t		map,
				vm_map_offset_t		src_addr,
				<span class="enscript-type">void</span>			*dst_p,
				vm_size_t		size);

<span class="enscript-comment">/* Create a new task map using an existing task map as a template. */</span>
<span class="enscript-type">extern</span> vm_map_t		vm_map_fork(
				ledger_t		ledger,
				vm_map_t		old_map);

<span class="enscript-comment">/* Change inheritance */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_inherit(
				vm_map_t		map,
				vm_map_offset_t		start,
				vm_map_offset_t		end,
				vm_inherit_t		new_inheritance);

<span class="enscript-comment">/* Add or remove machine-dependent attributes from map regions */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_machine_attribute(
				vm_map_t		map,
				vm_map_offset_t		start,
				vm_map_offset_t		end,
				vm_machine_attribute_t	attribute,
				vm_machine_attribute_val_t* value); <span class="enscript-comment">/* IN/OUT */</span>

<span class="enscript-type">extern</span> kern_return_t	vm_map_msync(
				vm_map_t		map,
				vm_map_address_t	address,
				vm_map_size_t		size,
				vm_sync_t		sync_flags);

<span class="enscript-comment">/* Set paging behavior */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_behavior_set(
				vm_map_t		map,
				vm_map_offset_t		start,
				vm_map_offset_t		end,
				vm_behavior_t		new_behavior);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_purgable_control</span>(
				vm_map_t		map,
				vm_map_offset_t		address,
				vm_purgable_t		control,
				<span class="enscript-type">int</span>			*state);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_region</span>(
				vm_map_t		 map,
				vm_map_offset_t		*address,
				vm_map_size_t		*size,
				vm_region_flavor_t	 flavor,
				vm_region_info_t	 info,
				mach_msg_type_number_t	*count,
				mach_port_t		*object_name);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_region_recurse_64</span>(
				vm_map_t		 map,
				vm_map_offset_t		*address,
				vm_map_size_t		*size,
				natural_t	 	*nesting_depth,
				vm_region_submap_info_64_t info,
				mach_msg_type_number_t  *count);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_page_query_internal</span>(
				vm_map_t		map,
				vm_map_offset_t		offset,
				<span class="enscript-type">int</span>			*disposition,
				<span class="enscript-type">int</span>			*ref_count);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_query_volatile</span>(
	vm_map_t	map,
	mach_vm_size_t	*volatile_virtual_size_p,
	mach_vm_size_t	*volatile_resident_size_p,
	mach_vm_size_t	*volatile_compressed_size_p,
	mach_vm_size_t	*volatile_pmap_size_p,
	mach_vm_size_t	*volatile_compressed_pmap_size_p);

<span class="enscript-type">extern</span> kern_return_t	vm_map_submap(
				vm_map_t		map,
				vm_map_offset_t		start,
				vm_map_offset_t		end,
				vm_map_t		submap,
				vm_map_offset_t		offset,
				boolean_t		use_pmap);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_map_submap_pmap_clean</span>(
	vm_map_t	map,
	vm_map_offset_t	start,
	vm_map_offset_t	end,
	vm_map_t	sub_map,
	vm_map_offset_t	offset);

<span class="enscript-comment">/* Convert from a map entry port to a map */</span>
<span class="enscript-type">extern</span> vm_map_t <span class="enscript-function-name">convert_port_entry_to_map</span>(
	ipc_port_t	port);

<span class="enscript-comment">/* Convert from a port to a vm_object */</span>
<span class="enscript-type">extern</span> vm_object_t <span class="enscript-function-name">convert_port_entry_to_object</span>(
	ipc_port_t	port);


<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_set_cache_attr</span>(
        vm_map_t        map,
        vm_map_offset_t va);


<span class="enscript-comment">/* definitions related to overriding the NX behavior */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_ABI_32</span>	0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_ABI_64</span>	0x2

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">override_nx</span>(vm_map_t map, uint32_t user_tag);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">vm_map_purge</span>(vm_map_t map);


<span class="enscript-comment">/* kext exported versions */</span>

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_wire_external</span>(
	<span class="enscript-type">register</span> vm_map_t	map,
	<span class="enscript-type">register</span> vm_map_offset_t	start,
	<span class="enscript-type">register</span> vm_map_offset_t	end,
	<span class="enscript-type">register</span> vm_prot_t	caller_prot,
	boolean_t		user_wire);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_wire_and_extract_external</span>(
	vm_map_t	map,
	vm_map_offset_t	start,
	vm_prot_t	caller_prot,
	boolean_t	user_wire,
	ppnum_t		*physpage_p);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_KERNEL_PRIVATE */</span>

__BEGIN_DECLS

<span class="enscript-comment">/* Create an empty map */</span>
<span class="enscript-type">extern</span> vm_map_t		vm_map_create(
				pmap_t			pmap,
				vm_map_offset_t 	min_off,
				vm_map_offset_t 	max_off,
				boolean_t		pageable);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_disable_hole_optimization(vm_map_t map);

<span class="enscript-comment">/* Get rid of a map */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_destroy(
				vm_map_t		map,
				<span class="enscript-type">int</span>			flags);

<span class="enscript-comment">/* Lose a reference */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_deallocate(
				vm_map_t		map);

<span class="enscript-type">extern</span> vm_map_t		vm_map_switch(
				vm_map_t		map);

<span class="enscript-comment">/* Change protection */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_protect(
				vm_map_t		map,
				vm_map_offset_t		start,
				vm_map_offset_t		end,
				vm_prot_t		new_prot,
				boolean_t		set_max);

<span class="enscript-comment">/* Check protection */</span>
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">vm_map_check_protection</span>(
				vm_map_t		map,
				vm_map_offset_t		start,
				vm_map_offset_t		end,
				vm_prot_t		protection);

<span class="enscript-comment">/* wire down a region */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_wire(
				vm_map_t		map,
				vm_map_offset_t		start,
				vm_map_offset_t		end,
				vm_prot_t		access_type,
				boolean_t		user_wire);

<span class="enscript-type">extern</span> kern_return_t	vm_map_wire_and_extract(
				vm_map_t		map,
				vm_map_offset_t		start,
				vm_prot_t		access_type,
				boolean_t		user_wire,
				ppnum_t			*physpage_p);

<span class="enscript-comment">/* unwire a region */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_unwire(
				vm_map_t		map,
				vm_map_offset_t		start,
				vm_map_offset_t		end,
				boolean_t		user_wire);

<span class="enscript-comment">/* Enter a mapping of a memory object */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_enter_mem_object(
				vm_map_t		map,
				vm_map_offset_t		*address,
				vm_map_size_t		size,
				vm_map_offset_t		mask,
				<span class="enscript-type">int</span>			flags,
				ipc_port_t		port,
				vm_object_offset_t	offset,
				boolean_t		needs_copy,
				vm_prot_t		cur_protection,
				vm_prot_t		max_protection,
				vm_inherit_t		inheritance);

<span class="enscript-comment">/* Enter a mapping of a memory object */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_enter_mem_object_prefault(
				vm_map_t		map,
				vm_map_offset_t		*address,
				vm_map_size_t		size,
				vm_map_offset_t		mask,
				<span class="enscript-type">int</span>			flags,
				ipc_port_t		port,
				vm_object_offset_t	offset,
				vm_prot_t		cur_protection,
				vm_prot_t		max_protection,
				upl_page_list_ptr_t	page_list,
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 		page_list_count);

<span class="enscript-comment">/* Enter a mapping of a memory object */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_enter_mem_object_control(
				vm_map_t		map,
				vm_map_offset_t		*address,
				vm_map_size_t		size,
				vm_map_offset_t		mask,
				<span class="enscript-type">int</span>			flags,
				memory_object_control_t	control,
				vm_object_offset_t	offset,
				boolean_t		needs_copy,
				vm_prot_t		cur_protection,
				vm_prot_t		max_protection,
				vm_inherit_t		inheritance);

<span class="enscript-comment">/* Deallocate a region */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_remove(
				vm_map_t		map,
				vm_map_offset_t		start,
				vm_map_offset_t		end,
				boolean_t		flags);

<span class="enscript-comment">/* Discard a copy without using it */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_copy_discard(
				vm_map_copy_t		copy);

<span class="enscript-comment">/* Overwrite existing memory with a copy */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_copy_overwrite(
				vm_map_t                dst_map,
				vm_map_address_t        dst_addr,
				vm_map_copy_t           copy,
				boolean_t               interruptible);

<span class="enscript-comment">/* Place a copy into a map */</span>
<span class="enscript-type">extern</span> kern_return_t	vm_map_copyout(
				vm_map_t		dst_map,
				vm_map_address_t	*dst_addr,	<span class="enscript-comment">/* OUT */</span>
				vm_map_copy_t		copy);

<span class="enscript-type">extern</span> kern_return_t	vm_map_copyout_internal(
	vm_map_t		dst_map,
	vm_map_address_t	*dst_addr,	<span class="enscript-comment">/* OUT */</span>
	vm_map_copy_t		copy,
	boolean_t		consume_on_success,
	vm_prot_t		cur_protection,
	vm_prot_t		max_protection,
	vm_inherit_t		inheritance);

<span class="enscript-type">extern</span> kern_return_t	vm_map_copyin(
				vm_map_t			src_map,
				vm_map_address_t	src_addr,
				vm_map_size_t		len,
				boolean_t			src_destroy,
				vm_map_copy_t		*copy_result);	<span class="enscript-comment">/* OUT */</span>

<span class="enscript-type">extern</span> kern_return_t	vm_map_copyin_common(
				vm_map_t		src_map,
				vm_map_address_t	src_addr,
				vm_map_size_t		len,
				boolean_t		src_destroy,
				boolean_t		src_volatile,
				vm_map_copy_t		*copy_result,	<span class="enscript-comment">/* OUT */</span>
				boolean_t		use_maxprot);

<span class="enscript-type">extern</span> kern_return_t	vm_map_copy_extract(
	vm_map_t		src_map,
	vm_map_address_t	src_addr,
	vm_map_size_t		len,
	vm_map_copy_t		*copy_result,	<span class="enscript-comment">/* OUT */</span>
	vm_prot_t		*cur_prot,	<span class="enscript-comment">/* OUT */</span>
	vm_prot_t		*max_prot);


<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_disable_NX(
			        vm_map_t		map);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_disallow_data_exec(
			        vm_map_t		map);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_set_64bit(
			        vm_map_t		map);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_set_32bit(
			        vm_map_t		map);

<span class="enscript-type">extern</span> boolean_t	vm_map_has_hard_pagezero(
		       		vm_map_t		map,
				vm_map_offset_t		pagezero_size);

<span class="enscript-type">extern</span> boolean_t	vm_map_is_64bit(
			        vm_map_t		map);


<span class="enscript-type">extern</span> kern_return_t	vm_map_raise_max_offset(
	vm_map_t	map,
	vm_map_offset_t	new_max_offset);

<span class="enscript-type">extern</span> kern_return_t	vm_map_raise_min_offset(
	vm_map_t	map,
	vm_map_offset_t	new_min_offset);

<span class="enscript-type">extern</span> vm_map_offset_t	vm_compute_max_offset(
				boolean_t		is64);

<span class="enscript-type">extern</span> uint64_t 	vm_map_get_max_aslr_slide_pages(
				vm_map_t map);
	
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		vm_map_set_user_wire_limit(
				vm_map_t		map,
				vm_size_t		limit);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_map_switch_protect</span>(
				vm_map_t		map, 
				boolean_t		val);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_map_iokit_mapped_region</span>(
				vm_map_t		map,
				vm_size_t		bytes);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_map_iokit_unmapped_region</span>(
				vm_map_t		map,
				vm_size_t		bytes);


<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">first_free_is_valid</span>(vm_map_t);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> 		vm_map_page_shift(
				vm_map_t 		map);

<span class="enscript-type">extern</span> vm_map_offset_t	vm_map_page_mask(
				vm_map_t 		map);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		vm_map_page_size(
				vm_map_t 		map);

<span class="enscript-type">extern</span> vm_map_offset_t	vm_map_round_page_mask(
				vm_map_offset_t		offset,
				vm_map_offset_t		mask);

<span class="enscript-type">extern</span> vm_map_offset_t	vm_map_trunc_page_mask(
				vm_map_offset_t		offset,
				vm_map_offset_t		mask);

<span class="enscript-type">extern</span> boolean_t	vm_map_page_aligned(
				vm_map_offset_t		offset,
				vm_map_offset_t		mask);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_page_info</span>(
	vm_map_t		map,
	vm_map_offset_t		offset,
	vm_page_info_flavor_t	flavor,
	vm_page_info_t		info,
	mach_msg_type_number_t	*count);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>


#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">MACH_KERNEL_PRIVATE</span>

<span class="enscript-comment">/*
 *	Macros to invoke vm_map_copyin_common.  vm_map_copyin is the
 *	usual form; it handles a copyin based on the current protection
 *	(current protection == VM_PROT_NONE) is a failure.
 *	vm_map_copyin_maxprot handles a copyin based on maximum possible
 *	access.  The difference is that a region with no current access
 *	BUT possible maximum access is rejected by vm_map_copyin(), but
 *	returned by vm_map_copyin_maxprot.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">vm_map_copyin</span>(src_map, src_addr, len, src_destroy, copy_result) \
		vm_map_copyin_common(src_map, src_addr, len, src_destroy, \
					FALSE, copy_result, FALSE)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vm_map_copyin_maxprot</span>(src_map, \
			      src_addr, len, src_destroy, copy_result) \
		vm_map_copyin_common(src_map, src_addr, len, src_destroy, \
					FALSE, copy_result, TRUE)


<span class="enscript-comment">/*
 * Internal macros for rounding and truncation of vm_map offsets and sizes
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_MAP_ROUND_PAGE</span>(x,pgmask) (((vm_map_offset_t)(x) + (pgmask)) &amp; ~((signed)(pgmask)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_MAP_TRUNC_PAGE</span>(x,pgmask) ((vm_map_offset_t)(x) &amp; ~((signed)(pgmask)))

<span class="enscript-comment">/*
 * Macros for rounding and truncation of vm_map offsets and sizes
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_MAP_PAGE_SHIFT</span>(map) ((map) ? (map)-&gt;hdr.page_shift : PAGE_SHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_MAP_PAGE_SIZE</span>(map) (1 &lt;&lt; VM_MAP_PAGE_SHIFT((map)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_MAP_PAGE_MASK</span>(map) (VM_MAP_PAGE_SIZE((map)) - 1)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VM_MAP_PAGE_ALIGNED</span>(x,pgmask) (((x) &amp; (pgmask)) == 0)

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_KERNEL_PRIVATE */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_set_page_shift</span>(vm_map_t map, <span class="enscript-type">int</span> pageshift);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_round_page</span>(x,pgmask) (((vm_map_offset_t)(x) + (pgmask)) &amp; ~((signed)(pgmask)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">vm_map_trunc_page</span>(x,pgmask) ((vm_map_offset_t)(x) &amp; ~((signed)(pgmask)))

<span class="enscript-comment">/*
 * Flags for vm_map_remove() and vm_map_delete()
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_MAP_NO_FLAGS</span>	  		0x0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_MAP_REMOVE_KUNWIRE</span>	  	0x1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_MAP_REMOVE_INTERRUPTIBLE</span>  	0x2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VM_MAP_REMOVE_WAIT_FOR_KWIRE</span>  	0x4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_MAP_REMOVE_SAVE_ENTRIES</span>	0x8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_MAP_REMOVE_NO_PMAP_CLEANUP</span>	0x10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_MAP_REMOVE_NO_MAP_ALIGN</span>	0x20
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_MAP_REMOVE_NO_UNNESTING</span>	0x40

<span class="enscript-comment">/* Support for UPLs from vm_maps */</span>

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_get_upl</span>(
				vm_map_t		target_map,
				vm_map_offset_t		map_offset,
				upl_size_t		*size,
				upl_t			*upl,
				upl_page_info_array_t	page_info,
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*page_infoCnt,
				upl_control_flags_t	*flags,
				<span class="enscript-type">int</span>			force_data_sync);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_map_sizes</span>(vm_map_t map,
		vm_map_size_t * psize,
		vm_map_size_t * pfree,
		vm_map_size_t * plargest_free);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DYNAMIC_CODE_SIGNING</span>
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_sign</span>(vm_map_t map, 
				 vm_map_offset_t start, 
				 vm_map_offset_t end);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_partial_reap</span>(
              	vm_map_t map,
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *reclaimed_resident,
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *reclaimed_compressed);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
<span class="enscript-type">void</span>	vm_map_freeze_thaw_init(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	vm_map_freeze_thaw(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	vm_map_demand_fault(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_freeze_walk</span>(
              	vm_map_t map,
              	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *purgeable_count,
              	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *wired_count,
              	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *clean_count,
              	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *dirty_count,
             	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dirty_budget,
              	boolean_t *has_shared);

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_freeze</span>(
             	vm_map_t map,
             	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *purgeable_count,
             	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *wired_count,
             	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *clean_count,
             	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *dirty_count,
             	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dirty_budget,
             	boolean_t *has_shared);
                
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_map_thaw</span>(
                vm_map_t map);
#<span class="enscript-reference">endif</span>

__END_DECLS

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KERNEL_PRIVATE */</span>
 
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* _VM_VM_MAP_H_ */</span>
</pre>
<hr />
</body></html>