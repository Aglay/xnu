<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>default_freezer.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">default_freezer.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;CONFIG_FREEZE defined without matching CONFIG_MEMORYSTATUS&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/default_freezer.h&gt;</span>

<span class="enscript-comment">/*
 * Indicates that a page has been faulted back in.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FREEZER_OFFSET_ABSENT</span> ((vm_object_offset_t)(-1))

lck_grp_attr_t	default_freezer_handle_lck_grp_attr;	
lck_grp_t	default_freezer_handle_lck_grp;

<span class="enscript-type">void</span>
<span class="enscript-function-name">default_freezer_init</span>(<span class="enscript-type">void</span>)
{
	lck_grp_attr_setdefault(&amp;default_freezer_handle_lck_grp_attr);
	lck_grp_init(&amp;default_freezer_handle_lck_grp, <span class="enscript-string">&quot;default_freezer_handle&quot;</span>,
		     &amp;default_freezer_handle_lck_grp_attr);

}


<span class="enscript-comment">/*
 * Create the mapping table that will
 * tell us the object/offset pair that
 * corresponds to the page being sent
 * out or being brought back in.
 */</span>

default_freezer_mapping_table_t
<span class="enscript-function-name">default_freezer_mapping_create</span>(vm_object_t object, vm_offset_t offset)
{
	default_freezer_mapping_table_t table;
	
	table = kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> default_freezer_mapping_table));
	<span class="enscript-keyword">if</span> (table) {
		memset(table, 0, <span class="enscript-keyword">sizeof</span>(*table));
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;Could not allocate mapping table\n&quot;</span>);
	}
	
	table-&gt;object = object;
	table-&gt;offset = offset;
	
	<span class="enscript-keyword">return</span> table;
}

<span class="enscript-comment">/*
 * Table modifications/lookup are done behind
 * the compact_object lock.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">default_freezer_mapping_free</span>(default_freezer_mapping_table_t *table_p, boolean_t all)
{	
	default_freezer_mapping_table_t freezer_table = *table_p;
	assert(freezer_table);
	
	<span class="enscript-keyword">if</span> (all) {
		<span class="enscript-keyword">do</span> { 
			default_freezer_mapping_table_t next = freezer_table-&gt;next;
			kfree(freezer_table, <span class="enscript-keyword">sizeof</span>(*freezer_table));
			freezer_table = next;	
		} <span class="enscript-keyword">while</span> (freezer_table);
	} <span class="enscript-keyword">else</span> {
		kfree(freezer_table, <span class="enscript-keyword">sizeof</span>(*freezer_table));
	}
}
 
kern_return_t
<span class="enscript-function-name">default_freezer_mapping_store</span>(
		default_freezer_mapping_table_t table,
		memory_object_offset_t table_offset,
		memory_object_t memory_object,
		memory_object_offset_t offset)
{
	default_freezer_mapping_table_entry_t entry;
	uint32_t index;

	assert(table);

	<span class="enscript-keyword">while</span> (table-&gt;next) {
		table = table-&gt;next;
	}

	<span class="enscript-keyword">if</span> (table-&gt;index &gt;= MAX_FREEZE_TABLE_ENTRIES) {
		vm_object_t compact_object = table-&gt;object;
		default_freezer_mapping_table_t next;
		
		next = default_freezer_mapping_create(compact_object, table_offset);
		<span class="enscript-keyword">if</span> (!next) {
			<span class="enscript-keyword">return</span> KERN_FAILURE;
		}
		table-&gt;next = next;
	}

	index = (table)-&gt;index++;
	entry = &amp;(table)-&gt;entry[index];

	entry-&gt;memory_object = memory_object;
	entry-&gt;offset = offset;
	
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">default_freezer_mapping_update</span>(
		default_freezer_mapping_table_t table, 
		memory_object_t memory_object,
		memory_object_offset_t offset,
		memory_object_offset_t *table_offset, <span class="enscript-comment">/*OUT: contains the offset into the compact object*/</span>
		boolean_t remove_entry)
{

	kern_return_t kr = KERN_SUCCESS;
	vm_object_offset_t compact_offset;
	default_freezer_mapping_table_entry_t entry;
	uint32_t index = 0;
	
	<span class="enscript-keyword">if</span> (table == NULL){
		<span class="enscript-keyword">return</span> KERN_FAILURE;
	}

	compact_offset = table-&gt;offset;

	<span class="enscript-keyword">while</span> (1) {	
		<span class="enscript-keyword">if</span> (index &gt;= table-&gt;index) {
			<span class="enscript-keyword">if</span> (table-&gt;next) {
				table = table-&gt;next;
				index = 0;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* End of tables and we didn't find our candidate entry */</span>
				kr = KERN_FAILURE;
				<span class="enscript-keyword">break</span>;
			}
		}

		entry = &amp;table-&gt;entry[index];

		<span class="enscript-keyword">if</span> (memory_object == entry-&gt;memory_object &amp;&amp; offset == entry-&gt;offset) {
			<span class="enscript-keyword">if</span> (remove_entry == TRUE) {
				<span class="enscript-comment">/*
				 * Mark the page absent whilst retaining the object 
				 * for cleanup during thaw.
				 */</span>
				entry-&gt;offset = FREEZER_OFFSET_ABSENT;
			}
			<span class="enscript-keyword">if</span> (table_offset != NULL) {
				*table_offset = compact_offset;
			}
			<span class="enscript-keyword">break</span>;
		}
	
		index++;
		compact_offset += PAGE_SIZE;
	}
	<span class="enscript-keyword">return</span> kr;
}



<span class="enscript-comment">/*
 * Create a freezer memory object for this
 * vm object. This will be one of the vm
 * objects that will pack the compact object.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">default_freezer_memory_object_create</span>(
			vm_object_t	object,
			default_freezer_handle_t df_handle)
{

	default_freezer_memory_object_t fo = NULL;
	
	fo = kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> default_freezer_memory_object));

	<span class="enscript-keyword">if</span> (fo) {
		memory_object_control_t control = NULL;

		memset(fo, 0, <span class="enscript-keyword">sizeof</span>(*fo));
		
		control = memory_object_control_allocate(object);
		assert (control != MEMORY_OBJECT_CONTROL_NULL);

		df_memory_object_init((memory_object_t)fo, control, 0);		
		fo-&gt;fo_df_handle = df_handle;

		default_freezer_handle_reference_locked(fo-&gt;fo_df_handle);
	
		object-&gt;pager = (memory_object_t)fo;
		object-&gt;pager_created = TRUE;
		object-&gt;pager_initialized = TRUE;
		object-&gt;pager_ready = TRUE;
		object-&gt;pager_trusted = TRUE;
		object-&gt;pager_control = control;
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot; Could not allocate freezer object\n&quot;</span>);
	}
}

kern_return_t
<span class="enscript-function-name">default_freezer_pack</span>(
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	*purgeable_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	*wired_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	*clean_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	*dirty_count,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	dirty_budget,
	boolean_t	*shared,
	vm_object_t	src_object,
	default_freezer_handle_t df_handle)
{
	kern_return_t			kr = KERN_SUCCESS;

	<span class="enscript-keyword">if</span> (df_handle) {
		default_freezer_handle_lock(df_handle);
	}

	kr = vm_object_pack(purgeable_count, wired_count, clean_count, dirty_count, dirty_budget, shared, src_object, df_handle);
	
	<span class="enscript-keyword">if</span> (df_handle) {
		default_freezer_handle_unlock(df_handle);
	}

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/* 
 * Called with freezer_handle locked.
 * default_freezer_pack locks the handle, calls
 * vm_object_pack which, in turn, will call
 * default_freezer_pack_page().
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">default_freezer_pack_page</span>(
		vm_page_t p, 
		default_freezer_handle_t df_handle)
{

	default_freezer_mapping_table_t freeze_table = NULL;
	memory_object_t 		memory_object = NULL;
	vm_object_t			compact_object =  VM_OBJECT_NULL;

	assert(df_handle);

	compact_object = df_handle-&gt;dfh_compact_object;

	assert(compact_object);

	freeze_table =  df_handle-&gt;dfh_table;
	memory_object = p-&gt;object-&gt;pager;

	<span class="enscript-keyword">if</span> (memory_object == NULL) {
		default_freezer_memory_object_create(p-&gt;object, df_handle);
		memory_object = p-&gt;object-&gt;pager;
	} <span class="enscript-keyword">else</span> {
		assert(df_handle == ((default_freezer_memory_object_t)memory_object)-&gt;fo_df_handle);
	}

	vm_object_lock(compact_object);
	default_freezer_mapping_store(freeze_table, df_handle-&gt;dfh_compact_offset, memory_object, p-&gt;offset + p-&gt;object-&gt;paging_offset);
	vm_page_rename(p, compact_object, df_handle-&gt;dfh_compact_offset, FALSE);
	vm_object_unlock(compact_object);
	
	df_handle-&gt;dfh_compact_offset += PAGE_SIZE;
}


kern_return_t
<span class="enscript-function-name">default_freezer_unpack</span>(
		 default_freezer_handle_t df_handle)
{
	
	vm_page_t 				compact_page = VM_PAGE_NULL, src_page = VM_PAGE_NULL;
	uint32_t 				index = 0;
	vm_object_t 				src_object = VM_OBJECT_NULL;
	vm_object_t				compact_object = VM_OBJECT_NULL;
	memory_object_t				src_mem_object = MEMORY_OBJECT_NULL;
	memory_object_offset_t			src_offset = 0;
	vm_object_offset_t			compact_offset = 0;
	default_freezer_memory_object_t		fo = NULL;
	default_freezer_mapping_table_t 	freeze_table = NULL;
	boolean_t				should_unlock_handle = FALSE;
	kern_return_t				kr;

	assert(df_handle);

	default_freezer_handle_lock(df_handle);
	should_unlock_handle = TRUE;

	freeze_table = df_handle-&gt;dfh_table;	
	compact_object = df_handle-&gt;dfh_compact_object;

	assert(compact_object);
	assert(compact_object-&gt;alive);
	assert(!compact_object-&gt;terminating);
	assert(compact_object-&gt;pager_ready);
	
	<span class="enscript-comment">/* Bring the pages back in */</span>
	<span class="enscript-keyword">if</span> ((kr = vm_object_pagein(compact_object)) != KERN_SUCCESS) {
		<span class="enscript-keyword">if</span> (should_unlock_handle) {
			default_freezer_handle_unlock(df_handle);
		}
        	<span class="enscript-keyword">return</span> (kr);
	}

	vm_object_lock(compact_object);
	
	<span class="enscript-keyword">for</span> (index = 0, compact_offset = 0; ; index++, compact_offset += PAGE_SIZE){
		<span class="enscript-keyword">if</span> (index &gt;= freeze_table-&gt;index) {
			default_freezer_mapping_table_t table_next;
			
			table_next = freeze_table-&gt;next; 
			
			<span class="enscript-comment">/* Free the tables as we go along */</span>
			default_freezer_mapping_free(&amp;freeze_table, FALSE);
		
			<span class="enscript-keyword">if</span> (table_next == NULL){
				<span class="enscript-keyword">break</span>;
			}
			
			freeze_table = table_next;
			index = 0;
		}

		<span class="enscript-comment">/* 
		 * Skip slots that represent deallocated memory objects.
		 */</span>
		src_mem_object = freeze_table-&gt;entry[index].memory_object;
		<span class="enscript-keyword">if</span> (src_mem_object == MEMORY_OBJECT_NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* 
		 * Skip slots that represent faulted pages.
		 */</span>
		src_offset = freeze_table-&gt;entry[index].offset;
		<span class="enscript-keyword">if</span> (src_offset != FREEZER_OFFSET_ABSENT) {
			
			compact_page = vm_page_lookup(compact_object, compact_offset);
			assert(compact_page);

			fo = (default_freezer_memory_object_t)src_mem_object;
		
			src_object = memory_object_control_to_vm_object(fo-&gt;fo_pager_control); 
	
			<span class="enscript-comment">/* Move back over from the freeze object to the original */</span>
			vm_object_lock(src_object);
			src_page = vm_page_lookup(src_object, src_offset - src_object-&gt;paging_offset);
			<span class="enscript-keyword">if</span> (src_page != VM_PAGE_NULL){
				<span class="enscript-comment">/*
				 * We might be racing with a VM fault. 
				 * So handle that gracefully.
				 */</span>
				assert(src_page-&gt;absent == TRUE);
				VM_PAGE_FREE(src_page);
			}
			vm_page_rename(compact_page, src_object, src_offset - src_object-&gt;paging_offset, FALSE);
			vm_object_unlock(src_object);
		}
		
	}
	
	vm_object_unlock(compact_object);
	
	vm_object_deallocate(compact_object);
	
	<span class="enscript-keyword">if</span> (should_unlock_handle) {
		df_handle-&gt;dfh_table = NULL;
		df_handle-&gt;dfh_compact_object = VM_OBJECT_NULL;
		df_handle-&gt;dfh_compact_offset = 0;
		default_freezer_handle_unlock(df_handle);
	}
	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">df_memory_object_reference</span>(__unused memory_object_t mem_obj)
{

	<span class="enscript-comment">/* No-op */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">df_memory_object_deallocate</span>(memory_object_t mem_obj)
{

	default_freezer_memory_object_t	fo = (default_freezer_memory_object_t)mem_obj;

	assert(fo);
	
	<span class="enscript-keyword">if</span> (fo-&gt;fo_df_handle != NULL) {
		
		default_freezer_mapping_table_t table = NULL;
		default_freezer_mapping_table_entry_t entry;
		boolean_t found = FALSE;
		uint32_t index = 0;
		vm_object_t compact_object = VM_OBJECT_NULL;
		
		default_freezer_handle_lock(fo-&gt;fo_df_handle);

		compact_object =  fo-&gt;fo_df_handle-&gt;dfh_compact_object;
		table = fo-&gt;fo_df_handle-&gt;dfh_table;

		<span class="enscript-keyword">if</span> (compact_object == VM_OBJECT_NULL || table == NULL) {
			<span class="enscript-comment">/*Nothing to do. A thaw must have cleared it all out.*/</span>
		} <span class="enscript-keyword">else</span> {
			vm_object_lock(compact_object);
		
			<span class="enscript-comment">/* Remove from table */</span>
			<span class="enscript-keyword">while</span> (1) {	
				<span class="enscript-keyword">if</span> (index &gt;= table-&gt;index) {
					<span class="enscript-keyword">if</span> (table-&gt;next) {
						table = table-&gt;next;
						index = 0;
					} <span class="enscript-keyword">else</span> {
						<span class="enscript-comment">/* End of tables */</span>
						<span class="enscript-keyword">break</span>;
					}
				}

				entry = &amp;table-&gt;entry[index];
				<span class="enscript-keyword">if</span> (mem_obj == entry-&gt;memory_object) {
					<span class="enscript-comment">/* It matches, so clear the entry */</span>
					<span class="enscript-keyword">if</span> (!found) {
						found = TRUE;
					} 
					entry-&gt;memory_object = MEMORY_OBJECT_NULL;
					entry-&gt;offset = 0;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (MEMORY_OBJECT_NULL != entry-&gt;memory_object) {
					<span class="enscript-comment">/* We have a different valid object; we're done */</span>
					<span class="enscript-keyword">if</span> (found) {
						<span class="enscript-keyword">break</span>;
					}
				}
			
				index++;
			}
		
			vm_object_unlock(compact_object);
		}

		<span class="enscript-keyword">if</span> (default_freezer_handle_deallocate_locked(fo-&gt;fo_df_handle)) {
			default_freezer_handle_unlock(fo-&gt;fo_df_handle);
		}	
	}

	kfree(fo, <span class="enscript-keyword">sizeof</span>(*fo));
}

kern_return_t
<span class="enscript-function-name">df_memory_object_init</span>(
		memory_object_t mem_obj,
		memory_object_control_t control,
		__unused memory_object_cluster_size_t pager_page_size)
{

	default_freezer_memory_object_t	fo = (default_freezer_memory_object_t)mem_obj;
	assert(fo);

	fo-&gt;fo_pager_ops = &amp;default_freezer_ops;
	fo-&gt;fo_pager_header.io_bits = IKOT_MEMORY_OBJECT;
	fo-&gt;fo_pager_control = control;
	
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">df_memory_object_terminate</span>(memory_object_t mem_obj)
{

	default_freezer_memory_object_t	fo = (default_freezer_memory_object_t)mem_obj;
	assert(fo);
	memory_object_control_deallocate(fo-&gt;fo_pager_control);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


kern_return_t
<span class="enscript-function-name">df_memory_object_data_request</span>(
		memory_object_t mem_obj, 
		memory_object_offset_t offset,
		memory_object_cluster_size_t length,
		vm_prot_t protection_required,
		memory_object_fault_info_t fault_info)
{

	vm_object_t	src_object = VM_OBJECT_NULL, compact_object = VM_OBJECT_NULL;
	memory_object_offset_t	compact_offset = 0;
	memory_object_t pager = NULL;
	kern_return_t kr = KERN_SUCCESS;
	boolean_t	drop_object_ref = FALSE;
	vm_page_t compact_page, dst_page;

	default_freezer_memory_object_t fo = (default_freezer_memory_object_t)mem_obj;
	default_freezer_handle_t	df_handle = NULL;

	df_handle = fo-&gt;fo_df_handle;

	<span class="enscript-keyword">if</span> (df_handle == NULL) {
		kr = KERN_FAILURE;
	} <span class="enscript-keyword">else</span> {
		default_freezer_handle_lock(df_handle);
		
		src_object = memory_object_control_to_vm_object(fo-&gt;fo_pager_control);
		compact_object = fo-&gt;fo_df_handle-&gt;dfh_compact_object;
	
		<span class="enscript-keyword">if</span> (compact_object == NULL) {
			kr = KERN_FAILURE;
		} <span class="enscript-keyword">else</span> {	
			vm_object_lock(compact_object);
			vm_object_reference_locked(compact_object);
			drop_object_ref = TRUE;

			kr = default_freezer_mapping_update(fo-&gt;fo_df_handle-&gt;dfh_table,
								mem_obj,
								offset,
								&amp;compact_offset,
								FALSE);
			vm_object_unlock(compact_object);
		}
		default_freezer_handle_unlock(df_handle);
	}
	

	<span class="enscript-keyword">if</span> (length == 0){
		<span class="enscript-comment">/*Caller is just querying to see if we have the page*/</span>
		<span class="enscript-keyword">if</span> (drop_object_ref) {
			vm_object_deallocate(compact_object);
		}
		<span class="enscript-keyword">return</span> kr;
	}

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS){

		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> request_flags;
		upl_t        upl;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> page_list_count = 0;

		request_flags = UPL_NO_SYNC | UPL_RET_ONLY_ABSENT | UPL_SET_LITE | UPL_SET_INTERNAL;
		<span class="enscript-comment">/*
		 * Should we decide to activate USE_PRECIOUS (from default_pager_internal.h)
		 * here, then the request_flags will need to add these to the ones above:
		 *
		 * request_flags |= UPL_PRECIOUS | UPL_CLEAN_IN_PLACE
		 */</span>
		request_flags |= UPL_REQUEST_SET_DIRTY;

		memory_object_super_upl_request(fo-&gt;fo_pager_control,
						(memory_object_offset_t)offset,
						PAGE_SIZE, PAGE_SIZE, 
						&amp;upl, NULL, &amp;page_list_count,
						request_flags);
		upl_range_needed(upl, 0, 1);

		upl_abort(upl, UPL_ABORT_UNAVAILABLE);
		upl_deallocate(upl);
		
		<span class="enscript-keyword">if</span> (drop_object_ref) {
			vm_object_deallocate(compact_object);
		}

		<span class="enscript-keyword">return</span> KERN_SUCCESS;
	}
	vm_object_lock(compact_object);

	assert(compact_object-&gt;alive);
	assert(!compact_object-&gt;terminating);

	<span class="enscript-comment">/*
	 * note that the activity_in_progress could be non-zero, but
	 * the pager has not yet been created since the activity_in_progress
	 * count is bumped via vm_pageout_cluster, while the pager isn't created
	 * until the pageout thread runs and starts to process the pages
	 * placed on the I/O queue... once the processing of the compact object
	 * proceeds to the point where it's placed the first page on the I/O
	 * queue, we need to wait until the entire freeze operation has completed.
	 */</span>
	vm_object_paging_wait(compact_object, THREAD_UNINT);

	<span class="enscript-keyword">if</span> (compact_object-&gt;pager_ready) {
		vm_object_paging_begin(compact_object);

		compact_object-&gt;blocked_access = TRUE;
		pager = (memory_object_t)compact_object-&gt;pager;

		vm_object_unlock(compact_object);

		((vm_object_fault_info_t) fault_info)-&gt;io_sync = TRUE;

		<span class="enscript-comment">/*
		 * We have a reference on both the default_freezer
		 * memory object handle and the compact object.
		 */</span>
		kr = dp_memory_object_data_request(pager,
						   compact_offset,
						   length,
						   protection_required,
						   fault_info);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
			panic(<span class="enscript-string">&quot;%d: default_freezer TOC pointed us to default_pager incorrectly\n&quot;</span>, kr);

		vm_object_lock(compact_object);

		compact_object-&gt;blocked_access = FALSE;
		vm_object_paging_end(compact_object);
	}
	vm_object_lock(src_object);

	<span class="enscript-keyword">if</span> ((compact_page = vm_page_lookup(compact_object, compact_offset)) != VM_PAGE_NULL){
			
		dst_page = vm_page_lookup(src_object, offset - src_object-&gt;paging_offset);
			
		<span class="enscript-keyword">if</span> (dst_page &amp;&amp; !dst_page-&gt;absent){
			<span class="enscript-comment">/*
			 * Someone raced us here and unpacked
			 * the object behind us.
			 * So cleanup before we return.
			 */</span>
			VM_PAGE_FREE(compact_page);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (dst_page != NULL) {
				VM_PAGE_FREE(dst_page);
			}
			vm_page_rename(compact_page, src_object, offset - src_object-&gt;paging_offset, FALSE);
				
			<span class="enscript-keyword">if</span> (default_freezer_mapping_update(fo-&gt;fo_df_handle-&gt;dfh_table,
							   mem_obj,
							   offset,
							   NULL,
							   TRUE) != KERN_SUCCESS) {
				printf(<span class="enscript-string">&quot;Page for object: 0x%lx at offset: 0x%lx not found in table\n&quot;</span>, (uintptr_t)src_object, (uintptr_t)offset);
			}
			
			PAGE_WAKEUP_DONE(compact_page);
		}
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;%d: default_freezer: compact_object doesn't have the page for object 0x%lx at offset 0x%lx \n&quot;</span>, kr, (uintptr_t)compact_object, (uintptr_t)compact_offset);
		kr = KERN_SUCCESS;
	}
	vm_object_unlock(src_object);
	vm_object_unlock(compact_object);
	vm_object_deallocate(compact_object);

	<span class="enscript-keyword">return</span> kr;
}

kern_return_t
<span class="enscript-function-name">df_memory_object_data_return</span>(
		__unused memory_object_t		mem_obj,
		__unused memory_object_offset_t	offset,
		__unused memory_object_cluster_size_t			size,
		__unused memory_object_offset_t	*resid_offset,
		__unused <span class="enscript-type">int</span>		*io_error,
		__unused boolean_t	dirty,
		__unused boolean_t	kernel_copy,
		__unused <span class="enscript-type">int</span>	upl_flags)
{

	panic(<span class="enscript-string">&quot; default_freezer: df_memory_object_data_return should not be called\n&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">df_memory_object_data_initialize</span>(
		__unused memory_object_t mem_obj,
		__unused  memory_object_offset_t offset,
		__unused memory_object_cluster_size_t size)
{
	
	panic(<span class="enscript-string">&quot; default_freezer: df_memory_object_data_initialize should not be called\n&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">df_memory_object_data_unlock</span>(
		__unused memory_object_t mem_obj,
		__unused memory_object_offset_t offset,
		__unused memory_object_size_t length,
		__unused vm_prot_t prot)
{

	panic(<span class="enscript-string">&quot; default_freezer: df_memory_object_data_unlock should not be called\n&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

kern_return_t
<span class="enscript-function-name">df_memory_object_synchronize</span>(
		__unused memory_object_t mem_obj,
		__unused memory_object_offset_t offset,
		__unused memory_object_size_t length,
		__unused vm_sync_t flags)
{

	panic(<span class="enscript-string">&quot; default_freezer: df_memory_object_synchronize should not be called\n&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

kern_return_t
<span class="enscript-function-name">df_memory_object_map</span>(
		__unused memory_object_t mem_obj,
		__unused vm_prot_t prot)
{

	panic(<span class="enscript-string">&quot; default_freezer: df_memory_object_map should not be called\n&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}

kern_return_t
<span class="enscript-function-name">df_memory_object_last_unmap</span>(__unused memory_object_t mem_obj)
{

	panic(<span class="enscript-string">&quot; default_freezer: df_memory_object_last_unmap should not be called\n&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_FAILURE;
}


kern_return_t
<span class="enscript-function-name">df_memory_object_data_reclaim</span>(
		__unused memory_object_t mem_obj,
		__unused boolean_t reclaim_backing_store)
{

	panic(<span class="enscript-string">&quot;df_memory_object_data_reclaim\n&quot;</span>);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}


<span class="enscript-comment">/*
 * The freezer handle is used to make sure that
 * we don't race against the lookup and termination
 * of the compact object.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">default_freezer_handle_lock</span>(default_freezer_handle_t df_handle) {
	lck_rw_lock_exclusive(&amp;df_handle-&gt;dfh_lck);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">default_freezer_handle_unlock</span>(default_freezer_handle_t df_handle) {
	lck_rw_done(&amp;df_handle-&gt;dfh_lck);
}

default_freezer_handle_t
<span class="enscript-function-name">default_freezer_handle_allocate</span>(<span class="enscript-type">void</span>)
{

	default_freezer_handle_t		df_handle = NULL;
	df_handle = kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> default_freezer_handle));

	<span class="enscript-keyword">if</span> (df_handle) {
		memset(df_handle, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> default_freezer_handle));
		lck_rw_init(&amp;df_handle-&gt;dfh_lck, &amp;default_freezer_handle_lck_grp, NULL);
		<span class="enscript-comment">/* No one knows of this handle yet so no need to lock it. */</span>
		default_freezer_handle_reference_locked(df_handle);
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;Failed to allocated default_freezer_handle structure\n&quot;</span>);
	}
	<span class="enscript-keyword">return</span> df_handle;
}

kern_return_t
<span class="enscript-function-name">default_freezer_handle_init</span>(
	default_freezer_handle_t df_handle) 
{
	kern_return_t				kr = KERN_SUCCESS;
	vm_object_t				compact_object = VM_OBJECT_NULL;

	<span class="enscript-keyword">if</span> (df_handle == NULL || df_handle-&gt;dfh_table != NULL) {
		kr = KERN_FAILURE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Create our compact object */</span>
		compact_object = vm_object_allocate((vm_map_offset_t)(VM_MAX_ADDRESS) - (vm_map_offset_t)(VM_MIN_ADDRESS));
		<span class="enscript-keyword">if</span> (!compact_object) {
			kr = KERN_FAILURE;
		} <span class="enscript-keyword">else</span> {
			df_handle-&gt;dfh_compact_object = compact_object;
			df_handle-&gt;dfh_compact_offset = 0;
			df_handle-&gt;dfh_table = default_freezer_mapping_create(df_handle-&gt;dfh_compact_object, df_handle-&gt;dfh_compact_offset);
			<span class="enscript-keyword">if</span> (!df_handle-&gt;dfh_table) {
				kr = KERN_FAILURE;
			}	
		}
	}

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">default_freezer_handle_reference_locked</span>(
	default_freezer_handle_t df_handle)
{
	assert(df_handle);
	df_handle-&gt;dfh_ref_count++;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">default_freezer_handle_deallocate</span>(
	default_freezer_handle_t df_handle)
{
	assert(df_handle);
	default_freezer_handle_lock(df_handle);
	<span class="enscript-keyword">if</span> (default_freezer_handle_deallocate_locked(df_handle)) {
		default_freezer_handle_unlock(df_handle);
	}
}

boolean_t
<span class="enscript-function-name">default_freezer_handle_deallocate_locked</span>(
	default_freezer_handle_t df_handle)
{
	boolean_t	should_unlock = TRUE;

	assert(df_handle);
	df_handle-&gt;dfh_ref_count--;
	<span class="enscript-keyword">if</span> (df_handle-&gt;dfh_ref_count == 0) {

		<span class="enscript-keyword">if</span> (df_handle-&gt;dfh_compact_object) {
			vm_object_deallocate(df_handle-&gt;dfh_compact_object);
			df_handle-&gt;dfh_compact_object = NULL;
			df_handle-&gt;dfh_compact_offset = 0;
		}
			
		<span class="enscript-keyword">if</span> (df_handle-&gt;dfh_table) {
			default_freezer_mapping_free(&amp;df_handle-&gt;dfh_table, TRUE);
			df_handle-&gt;dfh_table = NULL;
		}
	
		lck_rw_done(&amp;df_handle-&gt;dfh_lck);
		lck_rw_destroy(&amp;df_handle-&gt;dfh_lck, &amp;default_freezer_handle_lck_grp);
		should_unlock = FALSE;

		kfree(df_handle, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> default_freezer_handle));
	}
	<span class="enscript-keyword">return</span> should_unlock;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">default_freezer_pageout</span>(
	default_freezer_handle_t df_handle)
{
	assert(df_handle);

	vm_object_pageout(df_handle-&gt;dfh_compact_object);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>
</pre>
<hr />
</body></html>